<!DOCTYPE html><html><head><title>Help for package ibmdbR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ibmdbR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ibmdbR-package'>
<p>IBM In-Database Analytics</p></a></li>
<li><a href='#as.ida.data.frame'><p>Convert an R object to an IDA data frame</p></a></li>
<li><a href='#ida.col.def+20methods'><p>Available methods for ida.col.def</p></a></li>
<li><a href='#ida.data.frame+20methods'><p>Available methods for ida.data.frame</p></a></li>
<li><a href='#ida.data.frame+2C+20is.ida.data.frame'><p>Create an IDA data frame</p></a></li>
<li><a href='#ida.list'><p>Store and retrieve R objects in the database</p></a></li>
<li><a href='#ida.list+20methods'><p>Available methods for ida.list</p></a></li>
<li><a href='#idaArule'><p>Association Rule Mining</p></a></li>
<li><a href='#idaConnect+2C+20idaClose'>
<p>Open or closes a IDA database connection</p></a></li>
<li><a href='#idaCreateView+2C+20idaDropView'><p>Create or drop a view</p></a></li>
<li><a href='#idaDeleteTable+2C+20idaExistTable+2C+20idaGetValidTableName+2C+20idaIsView'><p>Miscellaneous tools</p></a></li>
<li><a href='#idadf+2CidaSave+2CidaUpdate'><p>Query, store and update data in the database.</p></a></li>
<li><a href='#idaDivCluster'><p>Hierarchical (divisive) clustering</p></a></li>
<li><a href='#idaDropModel'><p>Drop a predictive model from the database</p></a></li>
<li><a href='#idaGetModelName'><p>Get the name of a model</p></a></li>
<li><a href='#idaGlm'><p>Generalized Linear Models (GLM)</p></a></li>
<li><a href='#idaInit'><p>Initialize the In-Database Analytics functions</p></a></li>
<li><a href='#idaKMeans'><p>k-means clustering</p></a></li>
<li><a href='#idaListAccelerators+2C+20idaSetAccelerator+2C+20idaGetAccelerator+2C+20idaGetAcceleratorDetails'><p>Show and set accelerator settings</p></a></li>
<li><a href='#idaListModels+20and+20idaModelExists'><p>List all predictive models in the database</p></a></li>
<li><a href='#idaLm'><p>Linear regression</p></a></li>
<li><a href='#idaMerge'><p>Merge IDA data frames</p></a></li>
<li><a href='#idaNaiveBayes'><p>Naive Bayes Classifier</p></a></li>
<li><a href='#idaQuery+2C+20idaScalarQuery'><p>Run an SQL query on the database</p></a></li>
<li><a href='#idaRetrieveModel'><p>Retrieve a predictive model from the database</p></a></li>
<li><a href='#idaSample'><p>Taking a random sample from a IDA data frame</p></a></li>
<li><a href='#idaShowTables'><p>Return a list of tables</p></a></li>
<li><a href='#idaTable'><p>In-Database Cross Tabulation and Table Creation</p></a></li>
<li><a href='#idaTApply'><p>Apply R-function to subsets of IDA data frame</p></a></li>
<li><a href='#idaTree'><p>Decision and Regression tree</p></a></li>
<li><a href='#idaTwoStep'><p>two step clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.51.0</td>
</tr>
<tr>
<td>Title:</td>
<td>IBM in-Database Analytics for R</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), methods, RODBC, Matrix, arules</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, rpart, rpart.plot</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, SparkR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>
        Functionality required to efficiently use R with IBM(R) Db2(R)
        Warehouse offerings (formerly IBM dashDB(R)) and IBM Db2 for z/OS(R) in
        conjunction with IBM Db2 Analytics Accelerator for z/OS.
        Many basic and complex R operations are pushed down into the database, 
        which removes the main memory boundary of R and allows to make full 
        use of parallel processing in the underlying database.
        For executing R-functions in a multi-node environment in parallel the idaTApply() function
        requires the 'SparkR' package (<a href="https://spark.apache.org/docs/latest/sparkr.html">https://spark.apache.org/docs/latest/sparkr.html</a>).
        The optional 'ggplot2' package is needed for the plot.idaLm() function only.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-23 22:17:18 UTC; mingpang</td>
</tr>
<tr>
<td>Author:</td>
<td>Shaikh Quader [aut, cre],
  Toni Bollinger [aut],
  Ming-pang Wei [aut],
  Alexander Eckert [aut],
  Michael Wurst [aut],
  Craig Blaha [ctb] (documentation),
  IBM Corporation [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shaikh Quader &lt;db2-analytics@de.ibm.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ibmdbR-package'>
IBM In-Database Analytics
</h2><span id='topic+ibmdbR-package'></span><span id='topic+ibmdbR'></span>

<h3>Description</h3>

<p>In-database analytics functions operate directly on data in a database, 
rather than requiring that the data first be extracted to working memory.
This lets you analyze large amounts of data that would be impractical 
or impossible to extract. It also avoids security issues associated 
with extracting data, and ensures that the data being analyzed 
is as current as possible. Some functions additionally use lazy loading 
to load only those parts of the data that are actually required, 
to further increase efficiency.
</p>
<p>This package also contains a data structure called a <code><a href="#topic+ida.list">ida.list</a></code>, which you 
can use to store R objects in the database. This simplifies the sharing 
of R objects among users. Each user is assigned two tables for R object 
storage: a private table, to which only that user has access, and a 
public table, which can be read by other users. Use a IDA list to generate 
a pointer to either of these tables, and use the pointer to list, store, 
or retrieve R objects.</p>

<hr>
<h2 id='as.ida.data.frame'>Convert an R object to an IDA data frame</h2><span id='topic+as.ida.data.frame'></span>

<h3>Description</h3>

<p>This function creates an IDA data frame <code><a href="#topic+ida.data.frame">ida.data.frame</a></code> from a local R <code>data.frame</code>
by creating a table in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ida.data.frame(x, table=NULL, clear.existing=FALSE, case.sensitive=TRUE, 
                  rownames=NULL, dbname=NULL, asAOT=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ida.data.frame_+3A_x">x</code></td>
<td>
<p>The name of the input object that is to be converted to a IDA data frame.</p>
</td></tr>
<tr><td><code id="as.ida.data.frame_+3A_table">table</code></td>
<td>
<p>The name of the database table that is to be created to hold the 
contents of the IDA data frame. The specified name is folded to uppercase.
If this parameter is not specified, a name is generated automatically.</p>
</td></tr>
<tr><td><code id="as.ida.data.frame_+3A_clear.existing">clear.existing</code></td>
<td>
<p>If the <code>table</code> parameter is specified, 
this parameter indicates whether the existing table is to be 
dropped (TRUE) or whether the <code>as.ida.data.frame</code> statement is to be ignored and 
a warning message issued (FALSE).</p>
</td></tr> 
<tr><td><code id="as.ida.data.frame_+3A_case.sensitive">case.sensitive</code></td>
<td>
<p>If the <code>table</code> parameter is specified for an existing table, 
this parameter specifies whether the column names in that table name are to be treated
as case-sensitive (TRUE) or not case-sensitive (FALSE).</p>
</td></tr>
<tr><td><code id="as.ida.data.frame_+3A_rownames">rownames</code></td>
<td>
<p>The name of the column for the unique row id. 
If the value of this parameter is NULL, this column is not added to the output table.</p>
</td></tr>
<tr><td><code id="as.ida.data.frame_+3A_dbname">dbname</code></td>
<td>
<p>DB2 for z/OS only parameter: the name of the database where the table should be created in.</p>
</td></tr>  
<tr><td><code id="as.ida.data.frame_+3A_asaot">asAOT</code></td>
<td>
<p>DB2 for z/OS only parameter: the table should be created as an &quot;accelerator only table&quot;.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A IDA data frame that points to the newly created table.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Add an ID column to iris
iris2 &lt;- iris
iris2$ID &lt;- 1:150

#Upload it and overwrite if already exists
idf &lt;- as.ida.data.frame(iris2,"IRIS",clear.existing=T)
	

## End(Not run)
</code></pre>

<hr>
<h2 id='ida.col.def+20methods'>Available methods for ida.col.def</h2><span id='topic++21+2Cida.col.def-method'></span><span id='topic+as.character+2Cida.col.def-method'></span><span id='topic+as.integer+2Cida.col.def-method'></span><span id='topic+as.numeric+2Cida.col.def-method'></span><span id='topic+as.vector+2Cida.col.def-method'></span><span id='topic+as.vector+2Cida.col.def+2CANY-method'></span><span id='topic+ifelse+2Cida.col.def-method'></span><span id='topic+print+2Cida.col.def-method'></span><span id='topic+db.is.null'></span><span id='topic+format.ida.col.def'></span>

<h3>Description</h3>

<p><code>ida.col.def</code> objects are used to define new columns of a <code>ida.data.frame</code> based
on existing ones.
</p>
<p>For details see the documentation of <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>.
</p>

<hr>
<h2 id='ida.data.frame+20methods'>Available methods for ida.data.frame</h2><span id='topic+sd+2Cida.data.frame-method'></span><span id='topic+max+2Cida.data.frame-method'></span><span id='topic+mean+2Cida.data.frame-method'></span><span id='topic+min+2Cida.data.frame-method'></span><span id='topic+length+2Cida.data.frame-method'></span><span id='topic+print+2Cida.data.frame-method'></span><span id='topic+names+2Cida.data.frame-method'></span><span id='topic+colnames+2Cida.data.frame-method'></span><span id='topic+summary+2Cida.data.frame-method'></span><span id='topic+NROW+2Cida.data.frame-method'></span><span id='topic+NCOL+2Cida.data.frame-method'></span><span id='topic+dim+2Cida.data.frame-method'></span><span id='topic+var+2Cida.data.frame-method'></span><span id='topic+head+2Cida.data.frame-method'></span><span id='topic+hist+2Cida.data.frame-method'></span><span id='topic++24+2Cida.data.frame-method'></span><span id='topic++24+3C-+2Cida.data.frame-method'></span><span id='topic++5B+2Cida.data.frame-method'></span><span id='topic+as.data.frame+2Cida.data.frame-method'></span><span id='topic+cor+2Cida.data.frame-method'></span><span id='topic+cov+2CANY+2CANY-method'></span><span id='topic+cov+2CANY+2Cida.data.frame-method'></span><span id='topic+cov+2Cida.data.frame+2CANY-method'></span><span id='topic+cov+2Cida.data.frame+2Cida.data.frame-method'></span><span id='topic++5B+2Cida.data.frame+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p><code>ida.data.frame</code> objects provide many methods that will behave exactly like or very
similar to methods defined on a regular <code>data.frame</code>. The following is a list of
currently supported methods: as.data.frame, sd, max, mean, min, length, print, names, colnames,
summary, NROW, NCOL, dim, var, head, hist, cor, cov. Furthermore, the $ and [] operators allow you
to select columns and rows and the $&lt;- operator will allow you to add columns. For details see
the documentation of <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>.
</p>

<hr>
<h2 id='ida.data.frame+2C+20is.ida.data.frame'>Create an IDA data frame</h2><span id='topic+ida.data.frame'></span><span id='topic+is.ida.data.frame'></span>

<h3>Description</h3>

<p>This function creates an IDA data frame (that is, an object of the class <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).
It does not store any data in local memory, but aggregates metadata used to determine the
exact table subset (columns - <code>SELECT</code> clause; and/or rows - 
<code>WHERE</code> clause) and creates a pointer to a table located in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ida.data.frame(table)
is.ida.data.frame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ida.data.frame+2B2C+2B20is.ida.data.frame_+3A_table">table</code></td>
<td>
<p>Name of a table or view in the current database.</p>
</td></tr>
<tr><td><code id="ida.data.frame+2B2C+2B20is.ida.data.frame_+3A_x">x</code></td>
<td>
<p>An <code>ida.data.frame</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

   
<p>The argument table must be a valid table or view name and the table/view must exist.
</p>
<p>If schema or table are set in quotes, they will be treated case sensitive otherwise
they are automatically converted to the default schema of the database. Columns
are always treated case sensitive. 
</p>
<p>A subset of columns and/or rows may be specified
using the indexing operator <code>[]</code> (which is translated to the
<code>SELECT</code> clause for columns and/or the <code>WHERE</code> clause for
rows). Note that columns are treated case sensitive.
</p>
<p>One limitation is that rows cannot be selected using their numbers.
Instead, you must specify value-based conditions, for example <code>d[d$ID &gt; 10,]</code>
which means &ldquo;all rows where the value of the first column is
greater than 10&rdquo;. The <code>$</code> operator may be also used to select
an <code>ida.data.frame</code> column.
</p>
<p>You can also add and alter columns in an ida.data.frame. Currently, a limited set of functions and operators
is supported to define columns based on other columns. The following is supported:
</p>

<ul>
<li><p> Arithmetic operators are +,-,/,*,^
</p>
</li>
<li><p> Mathematical functions are abs, sqrt, log, log10, exp, floor, round, ceiling
</p>
</li>
<li><p> Casting functions: as.numeric, as.integer, as.character
</p>
</li>
<li><p> Comparison and logical operators: &lt;,&lt;=,&gt;,&gt;=,!=,==,!,&amp;,|
</p>
</li>
<li><p> Conditional functions: ifelse
</p>
</li>
<li><p> Special functions: is.db.null (checks whether column value is NULL in the table)
</p>
</li></ul>

<p>There are several rules for adding columns:
</p>

<ol>
<li><p> You can not combine columns from different tables or from ida.data.frames that have different WHERE conditions.
</p>
</li>
<li><p> You cannot add a column to an ida.data.frame that was defined on columns from another ida.data.frame
</p>
</li>
<li><p> You can only add columns that evaluate to non-logical, atomic values
</p>
</li></ol>

<p>The package does basic type checking to enforce these rules, however, it is still possible that the database
will refuse a query that was not properly defined.
</p>
<p><code>is.ida.data.frame</code> checks if the given object's class is <code>ida.data.frame</code>.
</p>


<h3>Value</h3>

<p><code>ida.data.frame</code> returns an IDA data frame.
</p>
<p><code>is.ida.data.frame</code> returns a logical value that indicates
whether the specified object is an IDA data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf &lt;- ida.data.frame('IRIS')
is.ida.data.frame(idf)

#Select only certain rows or columns
#The following creates an ida.data.frame that only selects rows with
#Species=='setosa' and the first three columns of the table
idf2 &lt;- idf[idf$Species=='setosa',1:3]

#Define new columns based on existing ones
idf$SepalLengthX &lt;- idf$SepalLength+1
idf$SepalLengthY &lt;- ifelse(idf$SepalLengthX&gt;4.5,idf$ID,10)

#Take a look at the newly defined columns
head(idf)

 

## End(Not run)
</code></pre>

<hr>
<h2 id='ida.list'>Store and retrieve R objects in the database</h2><span id='topic+ida.list'></span><span id='topic+is.ida.list'></span>

<h3>Description</h3>

<p>A user can elect to store R objects in a database table rather than storing them in a workstation file system. 
This makes it easier for users to share objects, and simplifies backup tasks.
</p>
<p>Each user has two R object storage tables:
</p>
  
<ul>
<li><p> A private table, for objects that other users are not to be able to access
</p>
</li>
<li><p> A public table, for objects that other users are to be able to read
</p>
</li></ul>

<p>Use the <code>ida.list</code> function to create a pointer to either of your own R object storage tables, 
or to the public R object storage table of another user. You can then use the pointer to store 
objects in or retrieve objects from the corresponding table. (If the table belongs to another user 
you can only retrieve objects from it, not store objects in it.)
</p>
<p>Please note that whether public tables might not have effect on databases that do not allow to set
permissions accordingly, for instance, in multi-tenant environments. To enable the sharing of objects in DB2,
an administrator needs to first create a role names R_USERS_PUBLIC and assign it to all users who
should be allowed to share objects. For Db2, roles will be setup automatically if in the scope of the plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ida.list(type='public',user=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ida.list_+3A_type">type</code></td>
<td>
<p>The type (private or public) of the table. You can specify 'private' only if <code>user</code> is NULL  
or is set explicitly to your own user ID.</p>
</td></tr> 
<tr><td><code id="ida.list_+3A_user">user</code></td>
<td>
<p>The user ID of the owner of the R object storage table. If set to NULL, the user ID is that of the current user. The user ID is treated case-sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pointer to an R object storage table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a pointer to the private R object storage table of the current user.
myPrivateObjects &lt;- ida.list(type='private')

# Use the pointer created in the previous example to store a series of numbers in an object with 
# the name 'series100' in the private R object storage table of the current user.
myPrivateObjects['series100'] &lt;- 1:100

# Retrieve the object with the name 'series100' from the 
# private R object storage table of the current user.
x &lt;- myPrivateObjects['series100']

# Delete the object with name 'series100' from the 
# private R object storage table of the current user.

myPrivateObjects['series100'] &lt;- NULL

# List all objects in the private R object storage table of the current user.
names(myPrivateObjects)

# Return the number of objects in the private R object storage table of the current user.
length(myPrivateObjects)

# Create a pointer to the public R object storage table of the current user.
myPublicObjects &lt;- ida.list(type="public")


## End(Not run)
</code></pre>

<hr>
<h2 id='ida.list+20methods'>Available methods for ida.list</h2><span id='topic++21+2Cida.list-method'></span><span id='topic++24+2Cida.list-method'></span><span id='topic++24+3C-+2Cida.list-method'></span><span id='topic++5B+2Cida.list-method'></span><span id='topic++5B+2Cida.list+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cida.list-method'></span><span id='topic++5B+3C-+2Cida.list+2CANY+2CANY+2CANY-method'></span><span id='topic+length+2Cida.list-method'></span><span id='topic+names+2Cida.list-method'></span><span id='topic+print+2Cida.list-method'></span>

<h3>Description</h3>

<p><code>ida.list</code> objects provide methods that will behave exactly like or very
similar to methods defined on a regular <code>list</code>. The following methods are currently supported: length, names, print.
</p>
<p>For details see the documentation of <code><a href="#topic+ida.list">ida.list</a></code>.
</p>

<hr>
<h2 id='idaArule'>Association Rule Mining</h2><span id='topic+idaArule'></span><span id='topic+idaApplyRules'></span>

<h3>Description</h3>

<p>This function calculates association rules on a database table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaArule(
		data,
		tid,
		item,
		maxlen=5,
		maxheadlen=1,
		minsupport=NULL,
		minconf=0.5,
		nametable=NULL,
		namecol=NULL,
		modelname=NULL
)

idaApplyRules(modelname, newdata, tid, item, nametable=NULL, namecol=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaArule_+3A_data">data</code></td>
<td>
<p>An <code>ida.data.frame</code> object pointing to the data to be mined.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_tid">tid</code></td>
<td>
<p>Input table column that identifies the transactions by an id.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_item">item</code></td>
<td>
<p>Input table column that identifies items in transactions.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_maxlen">maxlen</code></td>
<td>
<p>The maximum length of a rule. Must be two or larger.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_maxheadlen">maxheadlen</code></td>
<td>
<p>The maximum length of the rule head.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_minsupport">minsupport</code></td>
<td>
<p>The minimal support of a rule to be considered.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_minconf">minconf</code></td>
<td>
<p>The minimal confidence of a rule to be considered.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_nametable">nametable</code></td>
<td>
<p>A database table containing a mapping between the items in the input table and their name. 
The table must contain at least two columns, the first column is named as the column indicated in the item parameter 
and the second column is named as indicated in parameter namecol.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_namecol">namecol</code></td>
<td>
<p>The name of the column containing the item name in case <code>nametable</code> was specified.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_modelname">modelname</code></td>
<td>
<p>The name of the model in-database. If NULL, it is automatically generated.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_newdata">newdata</code></td>
<td>
<p>A table to which to apply the rules.</p>
</td></tr>
<tr><td><code id="idaArule_+3A_...">...</code></td>
<td>
<p>Additional stored procedure parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>idaArule</code> finds association rules in transactional data. The input data must be in transactional format, thus each
row of the table contains exactly one item and an identifier of which transaction this item is assigned to. These two
columns need to be specified using the <code>tid</code> and <code>item</code> parameters. If the items are referred to with numeric IDs in the
transaction table, it is often useful to add a name mapping to produce rules that contain names instead of item IDs. This can be
achieved by setting the parameters <code>nametable</code> and <code>namecol</code>.
</p>
<p>Models are stored persistently in database under the name <code>modelname</code>. Model names cannot have more than 64 characters and
cannot contain white spaces. They need to be quoted like table names, otherwise they will be treated upper case by default. Only one
model with a given name is allowed in the database at a time. If a model with <code>modelname</code> already exists, you need to drop it with <code>idaDropModel</code>
first before you can create another one with the same name. The model name can be used to retrieve the model later (<code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>).
</p>
<p><code>idaApplyRules</code> applies a rule model stored in the database to a table with transactions. 
</p>


<h3>Value</h3>

<p><code>idaArule</code> returns an object of class <code>rules</code> compatible with the packages <code>arules</code> and <code>arulesViz</code>
<code>idaApplyRules</code> returns an object of class <code>ida.data.frame</code>, pointing to a table that contains a mapping between transaction IDs and matched 
rules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

idf &lt;- ida.data.frame("GOSALES.ORDER_DETAILS")

r &lt;- idaArule(idf,tid="ORDER_NUMBER",item="PRODUCT_NUMBER",minsupport=0.01)

inspect(r)

applyResult &lt;- idaApplyRules(idaGetModelname(r),idf,"ORDER_NUMBER","PRODUCT_NUMBER")
	

## End(Not run)</code></pre>

<hr>
<h2 id='idaConnect+2C+20idaClose'>
Open or closes a IDA database connection</h2><span id='topic+idaClose'></span><span id='topic+idaConnect'></span>

<h3>Description</h3>

<p>These functions are used to open or close an existing IDA database connection.</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaConnect(dsn, uid = "", pwd = "", conType = "odbc", 
  dsnLookup = c("auto", "default", "store"), ...)

idaClose(idaConn, conType = "odbc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_dsn">dsn</code></td>
<td>
<p>The DSN of the data base.</p>
</td></tr>
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_uid">uid</code></td>
<td>
<p>The user name.</p>
</td></tr>
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_pwd">pwd</code></td>
<td>
<p>The password.</p>
</td></tr>
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_contype">conType</code></td>
<td>
<p>The connection type.</p>
</td></tr>  
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_dsnlookup">dsnLookup</code></td>
<td>
<p>This parameter only is used when ibmdbR is loaded in an RStudio instance of IBM Data Science Experience. Per default (&quot;auto&quot;) ibmdbR automatically detects if the provided dsn value is an usual DSN string or the name of a connection in the local connection store. The lookup method can also be manually set to &quot;default&quot;, if the dsn parameter should be treated as an usual DSN string. If set to &quot;store&quot; the connection store of RStudio on DSX will be used.</p>
</td></tr>
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_...">...</code></td>
<td>
<p>Additional arguments for DSN lookup.</p>
</td></tr>
<tr><td><code id="idaConnect+2B2C+2B20idaClose_+3A_idaconn">idaConn</code></td>
<td>
<p>The connection object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Opens or closes a connection to a database. Currently, RODBC is used as underlying library, this might
change, however, in the future. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Connect locally 
con &lt;- idaConnect('BLUDB','','')

#Close the connection
idaClose(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='idaCreateView+2C+20idaDropView'>Create or drop a view</h2><span id='topic+idaCreateView'></span><span id='topic+idaDropView'></span>

<h3>Description</h3>

<p>Use these functions to create or drop a view that is based on a <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaCreateView(x, newColumn = NULL) 
idaDropView(v) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaCreateView+2B2C+2B20idaDropView_+3A_x">x</code></td>
<td>
<p><code>ida.data.frame</code> for which a view is to be created.</p>
</td></tr>
<tr><td><code id="idaCreateView+2B2C+2B20idaDropView_+3A_newcolumn">newColumn</code></td>
<td>
<p>The expression specifying the column to be added.</p>
</td></tr>
<tr><td><code id="idaCreateView+2B2C+2B20idaDropView_+3A_v">v</code></td>
<td>
<p>Name of the view to be dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>idaCreateView</code> function creates a view from the specified IDA data frame.
The <code>idaDropView</code> function drops the specified view.
</p>


<h3>Value</h3>

<p>The <code>idaCreateView</code> function returns the view name.
The <code>idaDropView</code> function does not return a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf &lt;- ida.data.frame('IRIS')

#Create a view based on the IDA data frame
vname &lt;- idaCreateView(idf)

#Drop the view
idaDropView(vname)

## End(Not run)
</code></pre>

<hr>
<h2 id='idaDeleteTable+2C+20idaExistTable+2C+20idaGetValidTableName+2C+20idaIsView'>Miscellaneous tools</h2><span id='topic+idaDeleteTable'></span><span id='topic+idaExistTable'></span><span id='topic+idaGetValidTableName'></span><span id='topic+idaIsView'></span><span id='topic+idaAppend'></span>

<h3>Description</h3>

<p>These functions simplify working with database tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
idaAppend(df, table)

idaDeleteTable(table)

idaExistTable(tableName)

idaIsView(tableName)

idaGetValidTableName(prefix="DATA_FRAME_")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaDeleteTable+2B2C+2B20idaExistTable+2B2C+2B20idaGetValidTableName+2B2C+2B20idaIsView_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> object.</p>
</td></tr>
<tr><td><code id="idaDeleteTable+2B2C+2B20idaExistTable+2B2C+2B20idaGetValidTableName+2B2C+2B20idaIsView_+3A_table">table</code></td>
<td>
<p>The name of a database table or an <code>ida.data.frame</code>.</p>
</td></tr>
<tr><td><code id="idaDeleteTable+2B2C+2B20idaExistTable+2B2C+2B20idaGetValidTableName+2B2C+2B20idaIsView_+3A_tablename">tableName</code></td>
<td>
<p>The name of a database table.</p>
</td></tr>
<tr><td><code id="idaDeleteTable+2B2C+2B20idaExistTable+2B2C+2B20idaGetValidTableName+2B2C+2B20idaIsView_+3A_prefix">prefix</code></td>
<td>
<p>Keyword used to specify the prefix of a table name.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Use the <code>idaAppend</code> function to append a <code>data.frame</code> to the specified table. 
</p>
<p>Use the <code>idaDeleteTable</code> function to drop the specified table. 
The specified table must exist in the current database. 
</p>
<p>Use the <code>idaExistTable</code> function to determine whether the specified table exists in the database.
</p>
<p>Use the <code>idaGetValidTableName</code> function to obtain a table name that is not yet in use. This name will be the specified or default prefix followed by a number, for example, data_frame_7.
</p>


<h3>Value</h3>

<p>The <code>idaDeleteTable</code> function does not return a value.
</p>
<p>The <code>idaExistTable</code> function returns a logical value (TRUE or FALSE) that indicates
whether the specified table exists in the database.
</p>
<p>The <code>idaGetValidTableName</code> function returns a string representing a table name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Check whether a table with a given name exists
idaExistTable('IRIS')

#Create a pointer to the table
idf &lt;- ida.data.frame('IRIS')

#Obtain a unique table name for a copy
copyTableName &lt;- idaGetValidTableName(prefix = "COPY_")

#Create a copy of the original table
idfCopy &lt;- as.ida.data.frame(as.data.frame(idf),copyTableName)

#Delete the copy again
idaDeleteTable(copyTableName)


## End(Not run)
</code></pre>

<hr>
<h2 id='idadf+2CidaSave+2CidaUpdate'>Query, store and update data in the database.</h2><span id='topic+idadf'></span><span id='topic+idaSave'></span><span id='topic+idaUpdate'></span>

<h3>Description</h3>

<p>These functions allow to query, store and update data in the database.
Usually, it is easier to use <code><a href="#topic+idaQuery">idaQuery</a></code>,<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>
and <code><a href="#topic+as.ida.data.frame">as.ida.data.frame</a></code> instead of these methods. 
</p>
<p>They can be useful, however, if an explicit connection object is
needed, e.g. if there are several connections to different
databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idadf(idaConn, query)
idaSave(idaConn, dfrm, tblName = "", rowName = "", conType = "odbc")
idaUpdate(db2Conn, updf, dfrm, idaIndex = "", conType = "odbc")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_idaconn">idaConn</code></td>
<td>
<p>The IDA connection object.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_db2conn">db2Conn</code></td>
<td>
<p>The IDA connection object.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_query">query</code></td>
<td>
<p>A query.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_dfrm">dfrm</code></td>
<td>
<p>A data.frame to store.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_tblname">tblName</code></td>
<td>
<p>Name of the table to which to store the data.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_rowname">rowName</code></td>
<td>
<p>Name of the row name column.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_updf">updf</code></td>
<td>
<p>Name of the table to update.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_idaindex">idaIndex</code></td>
<td>
<p>Name of the index column.</p>
</td></tr>
<tr><td><code id="idadf+2B2CidaSave+2B2CidaUpdate_+3A_contype">conType</code></td>
<td>
<p>Type of the connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>idadf</code>,<code>idaSave</code> and <code>idaUpdate</code> are simple wrappers around the RODBC functions <code><a href="RODBC.html#topic+sqlQuery">sqlQuery</a></code>,
<code><a href="RODBC.html#topic+sqlSave">sqlSave</a></code> and <code><a href="RODBC.html#topic+sqlUpdate">sqlUpdate</a></code>.
</p>
<p>Usually, it is easier to use <code><a href="#topic+idaQuery">idaQuery</a></code>,<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>
and <code><a href="#topic+as.ida.data.frame">as.ida.data.frame</a></code> instead of these methods. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idaQuery">idaQuery</a></code>,<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>,<code><a href="#topic+as.ida.data.frame">as.ida.data.frame</a></code>,<code><a href="RODBC.html#topic+sqlQuery">sqlQuery</a></code>,<code><a href="RODBC.html#topic+sqlSave">sqlSave</a></code>,<code><a href="RODBC.html#topic+sqlUpdate">sqlUpdate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create connection to DB
con &lt;- idaConnect("BLUDB", "", "")

# create data.frame from table
df &lt;- idadf(con, "SELECT * FROM IRIS")

# close the connection again
idaClose(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='idaDivCluster'>Hierarchical (divisive) clustering</h2><span id='topic+idaDivCluster'></span><span id='topic+print.idaDivCluster'></span><span id='topic+predict.idaDivCluster'></span>

<h3>Description</h3>

<p>This function generates a hierarchical (divisive) clustering model 
based on the contents of an IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>) by applying recursively the K-means algorithm.	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaDivCluster(
    data,
    id,
    distance="euclidean",
    maxiter=5, 
    minsplit=5,
    maxdepth=3,
    randseed=12345,
    outtable=NULL,
    modelname=NULL
)

## S3 method for class 'idaDivCluster'
print(x,...)  
## S3 method for class 'idaDivCluster'
predict(object, newdata, id,...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaDivCluster_+3A_data">data</code></td>
<td>
<p>An IDA data frame that contains the input data for the function. The input IDA data frame 
must include a column that contains a unique ID for each row.</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_id">id</code></td>
<td>
<p>The name of the column that contains a unique ID for each row of the input data.</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_distance">distance</code></td>
<td>
<p>The distance function that is to be used. This can be set to <code>"euclidean"</code>, which 
causes the squared Euclidean distance to be used, or <code>"norm_euclidean"</code>, which causes normalized euclidean distance to be used.</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations to perform in the base K-means Clustering algorithm</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of instances per cluster that can be split.</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_maxdepth">maxdepth</code></td>
<td>
<p>The maximum number of cluster levels (including leaves).</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_randseed">randseed</code></td>
<td>
<p>The seed for the random number generator.</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_outtable">outtable</code></td>
<td>
<p>The name of the output table that is to contain the results of the operation. When NULL 
is specified, a table name is generated automatically.</p>
</td></tr> 
<tr><td><code id="idaDivCluster_+3A_modelname">modelname</code></td>
<td>
<p>The name under which the model is stored in the database.
This is the name that is specified when using functions such as <code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code> or <code><a href="#topic+idaDropModel">idaDropModel</a></code>.</p>
</td></tr>
<tr><td><code id="idaDivCluster_+3A_object">object</code></td>
<td>
<p>An object of the class <code>idaDivCluster</code> to used for prediction, i.e. for applying it to new data.</p>
</td></tr> 
<tr><td><code id="idaDivCluster_+3A_x">x</code></td>
<td>
<p>An object of the class <code>idaDivCluster</code> to be printed.</p>
</td></tr> 
<tr><td><code id="idaDivCluster_+3A_newdata">newdata</code></td>
<td>
<p>An IDA data frame that contains the data to which to apply the model.</p>
</td></tr> 
<tr><td><code id="idaDivCluster_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to the print or predict method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The idaDivCluster clustering function builds a hierarchical clustering model by applying the K-means algorithm 
recursively in a top-down fashion. The hierarchy of clusters is represented in a binary tree structure (each
parent node has exactly 2 child nodes). The leafs of the cluster tree are identified by negative numbers.
</p>
<p>Models are stored persistently in the database under the name <code>modelname</code>. Model names cannot have more than 64 characters and
cannot contain white spaces. They need to be quoted like table names, otherwise they will be treated upper case by default. Only one
model with a given name is allowed in the database at a time. If a model with <code>modelname</code> already exists, you need to drop it with <code>idaDropModel</code>
first before you can create another one with the same name. The model name can be used to retrieve the model later (<code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>).
</p>
<p>The output of the print function for a idaDivCluster object is:
</p>

<ul>
<li><p> A vector containing a list of centers
</p>
</li>
<li><p> A vector containing a list of cluster sizes
</p>
</li>
<li><p> A vector containing a list of the number of elements in each cluster
</p>
</li>
<li><p> A data frame or the name of the table containing the calculated cluster assignments
</p>
</li>
<li><p> The within-cluster sum of squares (which indicates cluster density)
</p>
</li>
<li><p> The names of the slots that are available in the idaDivCluster object.
</p>
</li></ul>



<h3>Value</h3>

<p>The idaDivCluster function returns an object of class <code>idaDivCluster</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>, <code><a href="#topic+idaDropModel">idaDropModel</a></code>, <code><a href="#topic+idaListModels">idaListModels</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Create ida data frame
idf &lt;- ida.data.frame("IRIS")

#Create a DivCluster model stored in the database as DivClusterMODEL
dcm &lt;- idaDivCluster(idf, id="ID",modelname="DivClusterMODEL") 
	
#Print the model
print(dcm)

#Predict the model
pred &lt;- predict(dcm,idf,id="ID")

#Inspect the predictions
head(pred)
	

## End(Not run)</code></pre>

<hr>
<h2 id='idaDropModel'>Drop a predictive model from the database</h2><span id='topic+idaDropModel'></span>

<h3>Description</h3>

<p>Use this function to drop from the database a model that was created by using a function like <code><a href="#topic+idaNaiveBayes">idaNaiveBayes</a></code>, <code><a href="#topic+idaLm">idaLm</a></code>, <code><a href="#topic+idaTree">idaTree</a></code>, <code><a href="#topic+idaArule">idaArule</a></code>
or <code><a href="#topic+idaKMeans">idaKMeans</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaDropModel(modelname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaDropModel_+3A_modelname">modelname</code></td>
<td>
<p>The name of the predictive model to be dropped.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Drop the model with the name KMEANSMODEL
idaDropModel("KMEANSMODEL");

## End(Not run)
</code></pre>

<hr>
<h2 id='idaGetModelName'>Get the name of a model</h2><span id='topic+idaGetModelname'></span>

<h3>Description</h3>

<p>Use this function to get the name under which a model is stored in-database. This function can be applied to objects returned by
functions like <code><a href="#topic+idaNaiveBayes">idaNaiveBayes</a></code>, <code><a href="#topic+idaKMeans">idaKMeans</a></code> or <code><a href="#topic+idaArule">idaArule</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaGetModelname(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaGetModelName_+3A_object">object</code></td>
<td>
<p>The object representing the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fully qualified name of the model, as stored in-database. This name is used, e.g. in conjunction with the <code>idaRetrieveModel</code>
or with the <code>idaDropModel</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Get the name of a model stored in variable km	
modelname &lt;- idaGetModelname(km)


## End(Not run)</code></pre>

<hr>
<h2 id='idaGlm'>Generalized Linear Models (GLM)</h2><span id='topic+idaGlm'></span><span id='topic+print.idaGlm'></span><span id='topic+predict.idaGlm'></span>

<h3>Description</h3>

<p> This function computes generalized linear models on the contents of an <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>
idaGlm(	form, data, id = "id", intercept = T, family = "bernoulli", family_param = -1, 
          link = "logit", link_param = 1, maxit = 20, eps = 1e-3, tol = 1e-7, 
          method = "irls", trials = NULL, incolumn = "", interaction = "", 
          modelname = NULL, format = "glm", raw.resid = F, dropAfter = F, ...)
          
## S3 method for class 'idaGlm'
print(x, ...)
## S3 method for class 'idaGlm'
predict(object, newdata, id, outtable = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaGlm_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that describes the GLM to build.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_data">data</code></td>
<td>
<p>An <code>ida.data.frame</code> object that stores the data to be used for GLM building.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_id">id</code></td>
<td>
<p>The ID column name.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_intercept">intercept</code></td>
<td>
<p>The intercept.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_family">family</code></td>
<td>
<p>The type of error distribution. It can have one of the follwing values: 
&quot;bernoulli&quot;, &quot;gaussian&quot;, &quot;poisson&quot;, &quot;binomial&quot;, &quot;negativebinomial&quot;, &quot;wald&quot;, &quot;gamma&quot;</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_family_param">family_param</code></td>
<td>
<p>A family-specific parameter.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_link">link</code></td>
<td>
<p>Type of the link function. It can have one of the follwoing values:</p>
</td></tr>
</table>
<p>&quot;clog&quot;, &quot;cloglog&quot;, &quot;gaussit&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;logit&quot;, &quot;oddspower&quot;, &quot;power&quot;, &quot;probit&quot;, and &quot;sqrt&quot;.
For Db2 for z/OS it can have the following values as well:
&quot;canbinom&quot;, &quot;cangeom&quot;, &quot;cannegbinom&quot;, &quot;cauchit&quot;, &quot;inverse&quot;, &quot;invnegative&quot;, &quot;invsquare&quot;, &quot;loglog&quot; .
</p>
<table>
<tr><td><code id="idaGlm_+3A_link_param">link_param</code></td>
<td>
<p>Link parameter, 1 by default.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations. 20 by default.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_eps">eps</code></td>
<td>
<p>Maximum (relative) error used as a stopping criterion. This should be sufficiently small for the algorithm to work.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_tol">tol</code></td>
<td>
<p>The tolerance for the linear equation solver to consider a value equal to be zero. This should be sufficiently small for the algorithm to work.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_method">method</code></td>
<td>
<p>Computing algorithm: either <code>"irls"</code> (&quot;iteratively reweighted least square&quot;) or <code>"psgd"</code> (&quot;parallel stochastic gradient descent&quot;).</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_trials">trials</code></td>
<td>
<p>The input table column containing the number of trials for the binominal distribution. Ignored unless family is 'binomial'.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_incolumn">incolumn</code></td>
<td>
<p>Overwrite automatic creation of incolumn parameter and specify your own incolumn here.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_interaction">interaction</code></td>
<td>
<p>Overwrite automatic creation of interaction parameter and specify your own interaction here.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_modelname">modelname</code></td>
<td>
<p>Name of the model that will be created in the database. Will be created automatically if not specified.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_format">format</code></td>
<td>
<p>Specify output format. Either <code>"glm"</code> for output looking like <code>stats::glm</code> or <code>raw</code> for downloading all results as <code>data.frame</code>s.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_raw.resid">raw.resid</code></td>
<td>
<p>If <code>format</code> equals <code>"raw"</code>, whether to download the residuals or return <code>NULL</code> instead.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_dropafter">dropAfter</code></td>
<td>
<p>Whether to drop the results after downloading them as specified in <code>format</code>.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_x">x</code></td>
<td>
<p>An <code>idaGlm</code> object.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_object">object</code></td>
<td>
<p>An <code>idaGlm</code> object.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_newdata">newdata</code></td>
<td>
<p>New data used for prediction as <code>ida.data.frame</code>.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_outtable">outtable</code></td>
<td>
<p>The name of the table the results will be written in.</p>
</td></tr>
<tr><td><code id="idaGlm_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the GLM algorithm and requirements to the <code>data</code>, please refer to
the documentation of the <code>nza..GLM</code> stored procedure in the Netezza
In-Database Analytics Reference Guide or Netezza In-Database Analytics Developers Guide.
</p>


<h3>Value</h3>


<ul>
<li><p> The function <code>idaGlm</code> returns the generalized linear regression model of classes 
<code>glm</code> and <code>idaGlm</code> if <code>format</code> equals <code>"glm"</code> or a <code>list</code> of
<code>data.frame</code>s if <code>format</code> equals <code>"raw"</code>.
</p>
</li>
<li><p> The functions <code>print</code> and <code>summary</code> have no return values.
</p>
</li>
<li><p> The function <code>predict</code> returns an <code>ida.data.frame</code> that contains the predicted values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Add isSetosa column to iris data frame
iris2 &lt;- iris
iris2$isSetosa &lt;- ifelse(iris2$Species=="setosa", 1, 0)

#Store the iris2 data frame in the IRIS2 table
idf &lt;-as.ida.data.frame(iris2, table="IRIS2", clear.existing=T, rownames="ID")

#Calculate GLM model in-db
glm &lt;- idaGlm(isSetosa~PetalLength+SepalLength*SepalWidth+PetalWidth, idf, id="ID")

#Print the model
print(glm)

#Apply the model to data
idf2 &lt;- predict(glm, idf, "ID")

#Inspect the results
head(idf2)


## End(Not run)</code></pre>

<hr>
<h2 id='idaInit'>Initialize the In-Database Analytics functions</h2><span id='topic+idaInit'></span>

<h3>Description</h3>

<p>This function initializes the In-Database Analytics functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaInit(con,jobDescription=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaInit_+3A_con">con</code></td>
<td>
<p>An open RODBC connection.</p>
</td></tr>
<tr><td><code id="idaInit_+3A_jobdescription">jobDescription</code></td>
<td>
<p>Optional argument that allows to assign a description to the jobs submitted from the R session.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use an existing RODBC connection to initialize the IDA in-database analytics functions.
All commands are sent through this connection.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Initialize the IDA Analytics functions
con &lt;- idaConnect('BLUDB','','')

#Initialize the in-database functionality
idaInit(con)


## End(Not run)
</code></pre>

<hr>
<h2 id='idaKMeans'>k-means clustering</h2><span id='topic+idaKMeans'></span><span id='topic+print.idaKMeans'></span><span id='topic+predict.idaKMeans'></span>

<h3>Description</h3>

<p>This function generates a k-means clustering model based on the contents of a IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaKMeans(
	data,
	id, 
	k=3,
	maxiter=5,
	distance="euclidean",
	outtable=NULL,
	randseed=12345,
	statistics=NULL,
	modelname=NULL
)

## S3 method for class 'idaKMeans'
print(x,...)  
## S3 method for class 'idaKMeans'
predict(object, newdata, id,...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaKMeans_+3A_data">data</code></td>
<td>
<p>An IDA data frame that contains the input data for the function. The input IDA data frame 
must include a column that contains a unique ID for each row.</p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_id">id</code></td>
<td>
<p>The name of the column that contains a unique ID for each row of the input data.</p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_k">k</code></td>
<td>
<p>The number of clusters to be calculated.</p>
</td></tr> 
<tr><td><code id="idaKMeans_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations to be used to calculate the k-means clusters. A larger 
number of iterations increases both the precision of the results and the amount of time required to 
calculate them. </p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_distance">distance</code></td>
<td>
<p>The distance function that is to be used. This can be set to <code>"euclidean"</code>, which 
causes the squared Euclidean distance to be used, or <code>"norm_euclidean"</code>, which causes normalized euclidean distance to be used.</p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_outtable">outtable</code></td>
<td>
<p>The name of the output table that is to contain the results of the operation. When NULL 
is specified, a table name is generated automatically.</p>
</td></tr> 
<tr><td><code id="idaKMeans_+3A_randseed">randseed</code></td>
<td>
<p>The seed for the random number generator.</p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_statistics">statistics</code></td>
<td>
<p>Denotes which statistics to calculate. Allowed values are <code>"none"</code>,<code>"columns"</code> and <code>"all"</code>. If NULL, the default of the database system will be used.</p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_modelname">modelname</code></td>
<td>
<p>The name under which the model is stored in the database.
This is the name that is specified when using functions such as <code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code> or <code><a href="#topic+idaDropModel">idaDropModel</a></code>.</p>
</td></tr>
<tr><td><code id="idaKMeans_+3A_object">object</code></td>
<td>
<p>An object of the class <code>idaKMeans</code> to be used for prediction, i.e. for applying it to new data.</p>
</td></tr> 
<tr><td><code id="idaKMeans_+3A_x">x</code></td>
<td>
<p>An object of the class <code>idaKMeans</code> to be printed.</p>
</td></tr> 
<tr><td><code id="idaKMeans_+3A_newdata">newdata</code></td>
<td>
<p>A IDA data frame that contains the data to which to apply the model.</p>
</td></tr> 
<tr><td><code id="idaKMeans_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to the print or predict method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The idaKMeans function calculates the squared Euclidean distance between rows, and groups them into clusters.  
Initial clusters are chosen randomly using a random seed, and the results are adjusted iteratively until 
either the maximum number of iterations is reached or until two iterations return identical results. 
Variables with missing values are set zero for distance calculation.
</p>
<p>Models are stored persistently in database under the name <code>modelname</code>. Model names cannot have more than 64 characters and
cannot contain white spaces. They need to be quoted like table names, otherwise they will be treated upper case by default. Only one
model with a given name is allowed in the database at a time. If a model with <code>modelname</code> already exists, you need to drop it with <code>idaDropModel</code>
first before you can create another one with the same name. The model name can be used to retrieve the model later (<code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>).
</p>
<p>The output of the print function for a idaKMeans object is:
</p>

<ul>
<li><p> A vector containing a list of centers
</p>
</li>
<li><p> A vector containing a list of cluster sizes
</p>
</li>
<li><p> A vector containing a list of the number of elements in each cluster
</p>
</li>
<li><p> A data frame or the name of the table containing the calculated cluster assignments
</p>
</li>
<li><p> The within-cluster sum of squares (which indicates cluster density)
</p>
</li>
<li><p> The names of the slots that are available in the idaKMeans object
</p>
</li></ul>



<h3>Value</h3>

<p>The idaKMeans function returns an object of class <code>idaKMeans</code> and <code>kmeans</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>, <code><a href="#topic+idaDropModel">idaDropModel</a></code>, <code><a href="#topic+idaListModels">idaListModels</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Create ida data frame
idf &lt;- ida.data.frame("IRIS")

#Create a kmeans model stored in the database as KMEANSMODEL
km &lt;- idaKMeans(idf, id="ID",modelname="KMEANSMODEL") 
	
#Print the model
print(km)

#Predict the model
pred &lt;- predict(km,idf,id="ID")

#Inspect the predictions
head(pred)
	

## End(Not run)</code></pre>

<hr>
<h2 id='idaListAccelerators+2C+20idaSetAccelerator+2C+20idaGetAccelerator+2C+20idaGetAcceleratorDetails'>Show and set accelerator settings</h2><span id='topic+idaListAccelerators'></span><span id='topic+idaSetAccelerator'></span><span id='topic+idaGetAccelerator'></span><span id='topic+idaGetAcceleratorDetails'></span>

<h3>Description</h3>

<p>Use these functions for DB2 for z/OS connections to retrieve the list of available accelerators and 
to set and get the current accelerator settings.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaListAccelerators()
idaSetAccelerator(acceleratorName, queryAcceleration="ENABLE")
idaGetAccelerator()
idaGetAcceleratorDetails()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaListAccelerators+2B2C+2B20idaSetAccelerator+2B2C+2B20idaGetAccelerator+2B2C+2B20idaGetAcceleratorDetails_+3A_acceleratorname">acceleratorName</code></td>
<td>
<p>The name of the accelerator where the analytics functions 
(like idaKMeans or idaTree)  are executed.</p>
</td></tr>
<tr><td><code id="idaListAccelerators+2B2C+2B20idaSetAccelerator+2B2C+2B20idaGetAccelerator+2B2C+2B20idaGetAcceleratorDetails_+3A_queryacceleration">queryAcceleration</code></td>
<td>
<p>The value which the DB2 for z/OS register CURRENT QUERY ACCELERATION is set to. Possible values 
are &quot;NONE&quot;, ENABLE&quot;, &quot;ENABLE WITH FALLBACK&quot;, &quot;ELIGIBLE&quot; and &quot;ALL&quot; </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>idaListAccelerators</code> returns a data frame that contains a list of the accelerators 
available for the current DB2 for z/OS connection.
</p>
<p><code>idaSetAccelerator</code> sets the accelerator to be used for the subsequent calls of the analytics functions.
</p>
<p><code>idaGetAccelerator</code> retrieves the name of the accelerator.
</p>
<p><code>idaGetAcceleratorDetails</code> retrieves the name of accelerator together with the encoding (like UNICODE or EBCDIC) of its data
and the value for query acceleration (like ENABLE or ELIGIBLE) and returns these values in a list object with elements &quot;Accelerator&quot;, &quot;Encoding&quot; 
and &quot;QueryAcceleration&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Get a list of all accelerators
q &lt;- idaListAccelerators();

#Set accelerator to "MYACCEL"
idaSetAccelerator("MYACCEL");

#Get name of current accelerator"
idaGetAccelerator();

#Get name of current accelerator together with its encoding and query acceleration"
idaGetAcceleratorDetails();

#Get encoding of current acccelerator
idaGetAcceleratorDetails()$Encoding

## End(Not run)
</code></pre>

<hr>
<h2 id='idaListModels+20and+20idaModelExists'>List all predictive models in the database</h2><span id='topic+idaListModels'></span><span id='topic+idaModelExists'></span>

<h3>Description</h3>

<p>Use these function to list all models in the schema of the current user that were created using the functions like <code><a href="#topic+idaNaiveBayes">idaNaiveBayes</a></code> 
or <code><a href="#topic+idaKMeans">idaKMeans</a></code> or check whether a model with a specific name exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaListModels()
idaModelExists(modelname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaListModels+2B20and+2B20idaModelExists_+3A_modelname">modelname</code></td>
<td>
<p>The name of a predictive model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>idaListModels</code> returns a data frame that contains a list of the predictive models that are stored
in the current schema and information about each one.
</p>
<p><code>idaModelExists</code> returns a boolean value depending on whether the model exists or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Get a list of all models
q &lt;- idaListModels();

## End(Not run)
</code></pre>

<hr>
<h2 id='idaLm'>Linear regression</h2><span id='topic+idaLm'></span><span id='topic+print.idaLm'></span><span id='topic+predict.idaLm'></span><span id='topic+plot.idaLm'></span>

<h3>Description</h3>

<p> This function performs linear regression on the contents of an <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>
idaLm(form, idadf, id = "id", modelname = NULL, dropModel = TRUE, limit = 25)

## S3 method for class 'idaLm'
print(x, ...)
## S3 method for class 'idaLm'
predict(object, newdata, id, outtable = NULL, ...)
## S3 method for class 'idaLm'
plot(x, names = TRUE, max_forw = 50, max_plot = 15, order = NULL,
lmgON = FALSE, backwardON = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaLm_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that specifies both the name of the column that contains the continuous  
target variable and either a list of columns separated by plus symbols or a single period (to specify that all other columns in the ida.data.frame are to be used as predictors).
The specified columns can contain continuous or categorical values. 
The specified formula cannot contain transformations.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_idadf">idadf</code></td>
<td>
<p>An ida.data.frame that contains the input data for the function.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_id">id</code></td>
<td>
<p>The name of the column that contains a unique ID for each row of the input data. An id column needs to be specified, if a model contains categorical values, more than 41 columns or when dropModel is set to FALSE. If no valid id column was specified, a temporary id column will be used (not for DB2 for z/OS).</p>
</td></tr>
<tr><td><code id="idaLm_+3A_modelname">modelname</code></td>
<td>
<p>Name of the model that will be created in the database.</p>
</td></tr>

<tr><td><code id="idaLm_+3A_dropmodel">dropModel</code></td>
<td>
<p>logical: If TRUE the in database model will be dropped after the calculation.</p>
</td></tr>

<tr><td><code id="idaLm_+3A_limit">limit</code></td>
<td>
<p>The maximum number of levels for a categorical column. Its default value is 25.
This parameter only exists for consistency with older version of idaLm.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_x">x</code></td>
<td>
<p>An object of the class <code>idaLm</code>.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_object">object</code></td>
<td>
<p>An object of the class <code>idaLm</code></p>
</td></tr>
<tr><td><code id="idaLm_+3A_newdata">newdata</code></td>
<td>
<p>An ida.data.frame that contains data that will be predicted.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_outtable">outtable</code></td>
<td>
<p>The name of the table where the results will be written in.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_names">names</code></td>
<td>
<p><code>logical</code>: If set to TRUE then the plot will contain the names of the attributes instead of numbers.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_max_forw">max_forw</code></td>
<td>
<p><code>integer</code>: The maximum number of iterations the heuristic forward/backward will be calculated.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_max_plot">max_plot</code></td>
<td>
<p><code>integer</code>: The maximum number of attributes that will appear in the plot. It must be bigger than 0.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_order">order</code></td>
<td>
<p>Vector of attribute names. The method will calculate the value of the models with the attributes in the order of the vector and plot the value for each of it.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_lmgon">lmgON</code></td>
<td>
<p><code>logical</code>: If set TRUE the method will calculate the importance metric lmg. This method has exponential runningtime and is not supported for more than 15 attributes</p>
</td></tr>
<tr><td><code id="idaLm_+3A_backwardon">backwardON</code></td>
<td>
<p><code>logical</code>: If set TRUE the method will calculate the backward heuristic. By default (FALSE) it will do the forward heuristic.</p>
</td></tr>
<tr><td><code id="idaLm_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>idaLm</code> function computes a linear regression model by extracting a covariance matrix and 
computing its inverse. This implementation is optimized for problems that involve a large number of 
samples and a relatively small number of predictors. The maximum number of columns is 78.
</p>
<p>Missing values in the input table are ignored when calculating the covariance matrix. If this 
leads to undefined entries in the covariance matrix, the function fails. If the inverse of the 
covariance matrix cannot be computed (for example, due to correlated predictors), the Moore-Penrose 
generalized inverse is used instead.
</p>
<p>The output of the idaLm function has the following attributes:
</p>
<p>$coefficients is a vector with two values. The first value is the slope of the line that best 
fits the input data; the second value is its y-intercept.
</p>
<p>$RSS is the root sum square (that is, the square root of the sum of the squares).
</p>
<p>$effects is not used and can be ignored.
</p>
<p>$rank is the rank.
</p>
<p>$df.residuals is the number of degrees of freedom associated with the residuals. 
</p>
<p>$coefftab is a is a vector with four values:
</p>

<ul>
<li><p> The slope and y-intercept of the line that best fits the input data
</p>
</li>
<li><p> The standard error
</p>
</li>
<li><p> The t-value
</p>
</li>
<li><p> The p-value
</p>
</li></ul>

<p>$Loglike is the log likelihood ratio. 
</p>
<p>$AIC is the Akaike information criterion. This is a measure of the relative quality of the model.
</p>
<p>$BIC is the Bayesian information criterion. This is used for model selection.
</p>
<p>$CovMat the Matrix used in the calculation (&quot;Covariance Matrix&quot;). This matrix is necessary for the Calculation in plot.idaLm and the statistics.
</p>
<p>$card the number of dummy variables created for categorical columns and 1 for numericals.
</p>
<p>$model the in database modelname of the idaLm object.
</p>
<p>$numrow the number of rows of the input table that do not contain NAs.
</p>
<p>$sigma the residual standard error.
</p>
<p>The <code>plot.idaLm</code> function uses <code class="reqn">R^2</code> as a measure of quality of a linear model.
<code class="reqn">R^2</code> compares the variance of the predicted values and the variance of the actual values
of the target variable.
</p>
<p>$First:            Returns the <code class="reqn">R^2</code> value of the linear model for each attribute alone.
</p>
<p>$Usefulness:       Returns the <code class="reqn">R^2</code> value reduction of the linear model with all
attributes to the linear model with one attribute taken away.
</p>
<p>$Forward_Values:   Is only calculated if backwardON=FALSE. This is a heuristic that adds in         
each step the attribute which has the most <code class="reqn">R^2</code> increase.
</p>
<p>$LMG:              Is only calculated if lmgON=TRUE. It returns the increase of <code class="reqn">R^2</code> of
each attribute averaged over every possible permutation. By grouping some
of the permutations we only need to average over every possible subset. 
For n attributes there are <code class="reqn">2^n</code> subsets. So LMG is an algorithm with
exponential runningtime and is not recommended for more than 15
attributes.
</p>
<p>$Backward_Values:  Is only calculated if backwardON=TRUE. Similar to the forward heuristic.
This time we choose in each step of the algorithm that has minimal
<code class="reqn">R^2</code> reduction when taking it out of the model, starting with all
attributes.
</p>
<p>$Model_Values:     Is only calculated if order is a vector of attributes. In this case the
function calculates the <code class="reqn">R^2</code> value for the models that we get when
we add one attribute of order in each step.
</p>
<p>RelImpPlot.png:    If lmgON=FALSE. This plot shows a stackplot of the values
Usefulness,First and the Model_Value of the heuristic. Note that usually                     Usefulness&lt;First&lt;Model_Value and that the bars overlap each other.
If lmgON=TRUE. This plot shows the LMG values of the
attributes in the order of the heuristic forward, backward or order.
</p>


<h3>Value</h3>

<p>The procedure returns a linear regression model of class <code>idaLm</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create a pointer to table IRIS
idf &lt;- ida.data.frame("IRIS")

#Calculate linear model in-db
lm1 &lt;- idaLm(SepalLength~., idf)

library(ggplot2)
plot(lm1)

#Calculating linear models with categorical values requires an id column
lm1 &lt;- idaLm(SepalLength~., idf, id="ID")

## End(Not run)
</code></pre>

<hr>
<h2 id='idaMerge'>Merge IDA data frames</h2><span id='topic+idaMerge'></span>

<h3>Description</h3>

<p>This function merges two IDA data frames(that is, two objects of the class <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaMerge(x, y, by=intersect(x@cols, y@cols), by.x=by, by.y=by, 
    all=FALSE, all.x=all, all.y=all, sort=TRUE,   
    suffixes=c("_x", "_y"), table=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaMerge_+3A_x">x</code></td>
<td>
<p>The first <code>ida.data.frame</code> object to be merged.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_y">y</code></td>
<td>
<p>The second <code>ida.data.frame</code> object to be merged.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_by">by</code></td>
<td>
<p>Specification of the common columns; see the
<em>Details</em> section.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_by.x">by.x</code></td>
<td>
<p>Specification of the common columns; see the
<em>Details</em> section.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_by.y">by.y</code></td>
<td>
<p>Specification of the common columns; see the
<em>Details</em> section.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_all">all</code></td>
<td>
<p>Whether non-matching columns of <code>x</code> and <code>y</code> are to be appended to the result. 
If set to FALSE, only columns common to both <code>x</code> and <code>y</code> are included in the output.
This parameter overrides the <code>all.x</code> and <code>all.y</code> parameters.
In SQL database terminology, specifying <code>all=FALSE</code> results in 
an inner join that is equivalent to a natural join, and specifying 
<code>all=TRUE</code> results in a full outer join. 
In a full outer join, the columns that 
are common to both <code>x</code> and <code>y</code> are followed by the remaining 
columns in <code>x</code>, which are followed by the remaining columns in <code>y</code>.
</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_all.x">all.x</code></td>
<td>
<p>If columns from only one of the IDA data frames being merged are to be included in the output, 
set its corresponding parameter to TRUE and the other parameter to FALSE.
In SQL database terminology, specifying <code>all.x=TRUE</code> and <code>all.y=FALSE</code> results in a left outer join, 
and specifying <code>all.x=FALSE</code> and <code>all.y=TRUE</code> results in a right outer join. 
</p>
<p>If <code>TRUE</code>, then extra rows are added to the
output, one for each row in <code>x</code> that has no matching row in
<code>y</code>. These rows have a value of <code>NA</code> in those columns
that are typically filled with values from <code>y</code>. The default is
<code>FALSE</code>, so that only rows with data from both <code>x</code> and
<code>y</code> are included in the output.
</p>
<p>If <code>all.x</code> is true, all the non matching cases of <code>x</code> are
also appended to the result, with a value of <code>NA</code> filled in the
corresponding columns of <code>y</code></p>
</td></tr>
<tr><td><code id="idaMerge_+3A_all.y">all.y</code></td>
<td>
<p>Analogous to <code>all.x</code></p>
</td></tr>	
<tr><td><code id="idaMerge_+3A_sort">sort</code></td>
<td>
<p>This parameter is ignored. The output is never sorted regardless of the setting of this parameter.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_suffixes">suffixes</code></td>
<td>

<p>Two 2-character strings, each of which specifies a suffix that is
used when generating column names.
By specifying different suffixes, you can ensure that each column 
can be uniquely attributed to either <code>x</code> or <code>y</code>. 
Note that a dot (.) is not a valid character for a column name.</p>
</td></tr>
<tr><td><code id="idaMerge_+3A_table">table</code></td>
<td>
<p>Name of the output IDA data frame. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merges two IDA data frames on the columns that they have in common.
The rows in the two data frames that match on the specified columns
are extracted, and joined together. If there is more than one match,
all possible matches contribute one row each. For the precise meaning
of &lsquo;match&rsquo;.
</p>
<p>If <code>by</code> or both <code>by.x</code> and <code>by.y</code> are of length 0 (a
length zero vector or <code>NULL</code>), the result, <code>r</code>, is the
Cartesian product of <code>x</code> and <code>y</code>, that is, a <em>cross join</em>. 
</p>
<p>If non-merged columns of the data frames have identical names and are to be included in the output, 
suffixes are appended to the names of the corresponding columns in the output to make their names unique. 
</p>
<p>Note that this function creates, in the current database, a view that corresponds to the output object. 
Within the current session, this view can be accessed using the same IDA data frame object. 
However, it is persistent and, after it is no longer needed, it must be dropped manually. 
</p>


<h3>Value</h3>

<p>A <code>ida.data.frame</code> object.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ida.data.frame">ida.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

idf &lt;- ida.data.frame('IRIS')

#Perform a self-join
idf2 &lt;- idaMerge(idf,idf,by="ID")


## End(Not run)

</code></pre>

<hr>
<h2 id='idaNaiveBayes'>Naive Bayes Classifier</h2><span id='topic+idaNaiveBayes'></span><span id='topic+predict.idaNaiveBayes'></span><span id='topic+print.idaNaiveBayes'></span>

<h3>Description</h3>

<p>This function generates a Naive Bayes classification model based on the contents of an IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaNaiveBayes(form,data,id="id",modelname=NULL)

## S3 method for class 'idaNaiveBayes'
predict(object,newdata,id, withProbabilities=FALSE,...)
## S3 method for class 'idaNaiveBayes'
print(x,...)  

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaNaiveBayes_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that describes the model to fit.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_data">data</code></td>
<td>
<p>An <code>ida.data.frame</code> object.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_id">id</code></td>
<td>
<p>The name of the column that contains unique IDs.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_modelname">modelname</code></td>
<td>
<p>Name for the model. Will be created automatically unless specified otherwise.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_object">object</code></td>
<td>
<p>An object of the class <code>idaNaiveBayes</code> to used for prediction, i.e. for applying it to new data.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_newdata">newdata</code></td>
<td>
<p>An IDA data frame that contains the data to which to apply the model.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_withprobabilities">withProbabilities</code></td>
<td>
<p>A boolean value indicating if the probabilities for each class value are included in the result of the predict function.</p>
</td></tr>
<tr><td><code id="idaNaiveBayes_+3A_x">x</code></td>
<td>
<p>An object of the class <code>idaNaiveBayes</code> to be printed.</p>
</td></tr> 
<tr><td><code id="idaNaiveBayes_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to the print and predict method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>idaNaiveBayes</code> builds a Naive Bayes classification model, thus a model that assumes independence
of input variables with respect to the target variable.
</p>
<p>Continuous input variables are discretized using
equal width discretization. Missing values are ignored on a record and attribute level when calculating the
conditional probabilities. 
</p>
<p>Models are stored persistently in the database under the name <code>modelname</code>. Model names cannot have more than 64 characters and
cannot contain white spaces. They need to be quoted like table names, otherwise they will be treated upper case by default. Only one
model with a given name is allowed in the database at a time. If a model with <code>modelname</code> already exists, you need to drop it with <code>idaDropModel</code>
first before you can create another one with the same name. The model name can be used to retrieve the model later (<code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>).
</p>


<h3>Value</h3>

<p>The function <code>idaNaiveBayes</code> returns an object of class <code>"idaNaiveBayes"</code> and <code>"naiveBayes"</code> compatible
with Naive Bayes objects produced by the e1071 package.
</p>
<p>The <code>predict.idaNaiveBayes</code> method applies the model to the data in a table and returns an IDA data frame that contains
a list of tuples, each of which comprises one row ID and one prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create ida data frame
idf &lt;- ida.data.frame("IRIS")

#Create a naive bayes model
nb &lt;- idaNaiveBayes(Species~SepalLength,idf,"ID")

#Print the model
print(nb)

#Apply the model to data
idf2 &lt;- predict(nb,idf,"ID")

#Inspect the results
head(idf2)


## End(Not run)
</code></pre>

<hr>
<h2 id='idaQuery+2C+20idaScalarQuery'>Run an SQL query on the database</h2><span id='topic+idaQuery'></span><span id='topic+idaScalarQuery'></span>

<h3>Description</h3>

<p>Use these functions to run any SQL query on the database and put the
results into a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaQuery(..., as.is=TRUE, na.strings = "NA")

idaScalarQuery(..., as.is=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaQuery+2B2C+2B20idaScalarQuery_+3A_...">...</code></td>
<td>
<p>Any number of query parts which are passed to <code>paste</code>.</p>
</td></tr>
<tr><td><code id="idaQuery+2B2C+2B20idaScalarQuery_+3A_as.is">as.is</code></td>
<td>
<p>Specifies whether the result columns are to be converted using RODBC type conversions (as.is=FALSE) or left unconverted (as.is=TRUE).
For more information about RODBC type conversions, see the descriptions of the functions <code>sqlGetResults</code> and <code>type.convert</code>.</p>
</td></tr>
<tr><td><code id="idaQuery+2B2C+2B20idaScalarQuery_+3A_na.strings">na.strings</code></td>
<td>
<p>character vector of strings to be mapped to NA when reading character data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parts of the input query are concatenated with <code>paste(..., sep="")</code>
and the result is passed to the database.
</p>


<h3>Value</h3>

<p>The <code>idaQuery</code> function returns a data frame that contains the
result of the specified query.
</p>
<p>The <code>idaScalarQuery</code> function returns the result of the specified query coerced
to a single scalar value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#idaScalarQuery returns a single value
v &lt;- idaScalarQuery("SELECT COUNT(*) FROM IRIS")

#idaQuery returns a data.frame
df &lt;- idaQuery("SELECT * FROM IRIS")

#idaQuery and idaScalarQuery automatically paste all arguments into a single query
#This is convenient if you use variables

tableName &lt;- "IRIS"
df &lt;- idaScalarQuery("SELECT COUNT(*) FROM ",tableName)

## End(Not run)
</code></pre>

<hr>
<h2 id='idaRetrieveModel'>Retrieve a predictive model from the database</h2><span id='topic+idaRetrieveModel'></span>

<h3>Description</h3>

<p>Use this function to retrieve from the database a model that was created using a function like <code><a href="#topic+idaNaiveBayes">idaNaiveBayes</a></code> 
or <code><a href="#topic+idaKMeans">idaKMeans</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaRetrieveModel(modelname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaRetrieveModel_+3A_modelname">modelname</code></td>
<td>
<p>The name of the predictive model to be retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an R object that contains a representation of the retrieved model.
The class of the returned object depends on the function that was used to create the 
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Retrieve the model with name "MYKMEANSMODEL" from the database
trCopy &lt;- idaRetrieveModel("KMEANSMODEL");

## End(Not run)
</code></pre>

<hr>
<h2 id='idaSample'>Taking a random sample from a IDA data frame</h2><span id='topic+idaSample'></span>

<h3>Description</h3>

<p>This function draws a random sample from a IDA data frame (that is, an object of the class <code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaSample(bdf, n, stratCol=NULL,stratVals=NULL,stratProbs=NULL,
dbPreSamplePercentage=100,fetchFirst=F);
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaSample_+3A_bdf">bdf</code></td>
<td>
<p>The IDA data frame from which the sample is to be drawn.</p>
</td></tr>
<tr><td><code id="idaSample_+3A_n">n</code></td>
<td>
<p>The number of rows of sample data to be retrieved.</p>
</td></tr>
<tr><td><code id="idaSample_+3A_stratcol">stratCol</code></td>
<td>
<p>For stratified sampling, the column that determines the strata.</p>
</td></tr>
<tr><td><code id="idaSample_+3A_stratvals">stratVals</code></td>
<td>
<p>For stratified sampling, a vector of values that determine the subset of strata from which samples are to be drawn.</p>
</td></tr>
<tr><td><code id="idaSample_+3A_stratprobs">stratProbs</code></td>
<td>
<p>For stratified sampling, a vector of explicit sampling probabilities. 
Each value corresponds to a value of the vector specified for <code>stratVals</code>.</p>
</td></tr>
<tr><td><code id="idaSample_+3A_dbpresamplepercentage">dbPreSamplePercentage</code></td>
<td>
<p>The percentage of the IDA data frame from which the sample is to be drawn (see details).</p>
</td></tr> 
<tr><td><code id="idaSample_+3A_fetchfirst">fetchFirst</code></td>
<td>
<p>Fetch first rows instead of using random sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>stratCol</code> is specified, a stratified sample based on the contents of the specified column is taken. 
Unless <code>stratVals</code> is also specified, each unique value in the column results in one stratum.
If <code>stratVals</code> is also specified, only the values it specifies result in strata, and only rows that contain one of those values are included in the  
sample; other rows are ignored. 
</p>
<p>Unless <code>stratProbs</code> is also specified, the number of rows retrieved for each stratum is proportional 
to the size of that stratum relative to the overall sample. 
</p>
<p>To undersample or oversample data, use <code>stratProbs</code> to specify, for each 
value of <code>stratVals</code>, the fraction of the rows of the corresponding stratum that are to be included in the sample. 
</p>
<p>For each stratum, the calculated number of rows is rounded up to the next highest integer. This ensures that there
is at least one sample for each stratum. Consequently, the number of samples that is returned might
be higher than the value specified for <code>n</code>.
</p>
<p>The value of <code>dbPreSamplePercentage</code> is a numeric value in the range 0-100 that represents the percentage of the 
IDA data frame that is to serve as the source of the sample data. 
When working with an especially large IDA data frame, specifying a value smaller than 100 improves performance, because less data must be processed.
However, the proportionality of the pre-sampled data might vary from that of the complete data, and this would result in
a biased sample. It can even happen that entire strata are excluded from the final sample.
</p>
<p>When <code>fetchFirst</code> is set to TRUE, the sample values of each stratum are taken in the order in which they are 
returned from the database rather than randomly. This is usually much faster than random sampling, but can introduce bias.
</p>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> that contains the sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
idf&lt;-ida.data.frame('IRIS')

#Simple random sampling
df &lt;- idaSample(idf,10)

#Stratified sample
df &lt;- idaSample(idf,10,'Species')


## End(Not run)
</code></pre>

<hr>
<h2 id='idaShowTables'>Return a list of tables</h2><span id='topic+idaShowTables'></span>

<h3>Description</h3>

<p>Returns a data frame that contains the names of the tables contained in the
current database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaShowTables(showAll=FALSE, matchStr=NULL, schema=NULL, accelerated=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaShowTables_+3A_showall">showAll</code></td>
<td>
<p>List all tables that are listed in the catalog of the current database (TRUE) or only those tables that are in the current schema (FALSE).</p>
</td></tr>
<tr><td><code id="idaShowTables_+3A_matchstr">matchStr</code></td>
<td>
<p>If not NULL, only tables that contain the character string in this argument will be returned.</p>
</td></tr>
<tr><td><code id="idaShowTables_+3A_schema">schema</code></td>
<td>
<p>If not NULL, only tables with this schema will be returned. This parameter is ignored if showAll=FALSE.</p>
</td></tr>
<tr><td><code id="idaShowTables_+3A_accelerated">accelerated</code></td>
<td>
<p>Valid for DB2 for z/OS connections only. If TRUE, only accelerated tables will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns Schema, Name, Owner, and Type. 
For DB2 for z/OS connections the columns Acceleratorname and Enable are included as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Get a list of all tables in the current schema
tabs &lt;- idaShowTables()


## End(Not run)
</code></pre>

<hr>
<h2 id='idaTable'>In-Database Cross Tabulation and Table Creation</h2><span id='topic+idaTable'></span>

<h3>Description</h3>

<p>Function used to build a contingency table of the counts at each combination of factor levels based on the contents of a IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaTable(idadf,max.entries=1000)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaTable_+3A_idadf">idadf</code></td>
<td>
<p>A IDA data frame that contains the input data for the function.</p>
</td></tr>
<tr><td><code id="idaTable_+3A_max.entries">max.entries</code></td>
<td>
<p>The maximum number of entries. If the cross product of all columns exceeds this number, an error will  be thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>idaTable</code> uses the cross-classifying factors to build a contingency table of the counts at each combination of categorical
values in all categorical columns of the <code>ida.data.frame</code> passed as input. 
</p>


<h3>Value</h3>

<p>The <code>idaTable</code> function returns a contingency table, an object of class &quot;table&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Create a pointer to the table IRIS
idf&lt;-ida.data.frame('IRIS')

#Add a column
idf$SepalLengthg4 &lt;- ifelse(idf$SepalLength&gt;4,'t','f')

#Calculate the cross-table between Species and SepalLengthg4
idaTable(idf[,c('Species','SepalLengthg4')])


## End(Not run)
</code></pre>

<hr>
<h2 id='idaTApply'>Apply R-function to subsets of IDA data frame</h2><span id='topic+idaTApply'></span>

<h3>Description</h3>

<p>This function applies a R function to each subset (group of rows) of
a given IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaTApply(X, INDEX, FUN = NULL, output.name=NULL, output.signature=NULL,
          clear.existing=FALSE, debugger.mode=FALSE,
          num.tasks = 0, working.dir=NULL, apply.function="default", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaTApply_+3A_x">X</code></td>
<td>
<p>A IDA data frame that contains the input data for the function.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_index">INDEX</code></td>
<td>
<p>The name or the position of the column of the input IDA data frame X used to partition
the input data into subsets.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_fun">FUN</code></td>
<td>
<p>The R function to be applied to the subsets of the input data.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_output.name">output.name</code></td>
<td>
<p>The name of the output table where the results are written to.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_output.signature">output.signature</code></td>
<td>
<p>The Db2 data types of the output table.
It is a named list with the column names as the names and the data types as the values.
Supported data types are CHAR, VARCHAR, SMALLINT, INTEGER, BIGINT, FLOAT, REAL, DOUBLE,
DECFLOAT, DECIMAL, NUMERIC, DATE</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_clear.existing">clear.existing</code></td>
<td>
<p>If TRUE the ouput table is dropped before recreating it.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_debugger.mode">debugger.mode</code></td>
<td>
<p>If TRUE intermediate results written into the working directory will not be removed.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_num.tasks">num.tasks</code></td>
<td>
<p>The number of parallel tasks, i.e. R processes, which execute the R function on the subsets
of the input data.
If not specified or if the value is less than 1 it is calculated based on the number of available CPUs.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_working.dir">working.dir</code></td>
<td>
<p>The name of the directory where the directory is created into which intermediate results
are written to. This directory is removed if debugger.mode is FALSE. The default value for
working.directory is the value of the
extbl_location Db2 database configuration variable or, if this variable has not been set, the home directory.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_apply.function">apply.function</code></td>
<td>
<p>The name of the R function to be used for parallelizing the execution of the
calls of the function FUN.
Possible values are &quot;default&quot;, &quot;spark.lapply&quot; and &quot;mclapply&quot;. If the value is &quot;default&quot; &quot;spark-lapply&quot; is used in a
multi-node and &quot;mclapply&quot; in a single node environment.
Please note that using the &quot;spark.lapply&quot; function requires Db2 Warehouse with integrated Spark.</p>
</td></tr>
<tr><td><code id="idaTApply_+3A_...">...</code></td>
<td>
<p>Additional parameters that can be passed to the function FUN to be called by idaTApply.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>idaTApply</code> applies a user-provided R function to each subset (group of rows) of a given ida.data.frame.
The subsets are determined by a specified index column. The results of applying the function are written into a Db2 table
which is referenced by the returned ida.data.frame.
</p>


<h3>Value</h3>

<p>The <code>idaTApply</code> function returns a <code>ida.data.frame</code>     .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create an ida data frame from the iris data
idf &lt;- as.ida.data.frame(iris)

#Define a function that computes the mean value for every column of a data frame x
#except the index column.
#It returns a data frame with the value of the index column and the mean values.
columnMeans&lt;- function(x, index) {
       cbind(index=x[1,match(index, names(x))],
              as.data.frame(as.list(apply(x[,names(x) != index],2,mean))))}


#Apply the columnMeans function to the subsets of the iris data identified by the Species column
resSig &lt;- list(Species="VARCHAR(12)", MSepalLength="DOUBLE", MSepalWidth="DOUBLE",
                                       MPetalLength="DOUBLE", MPetalWidth="DOUBLE")
resDf &lt;-
  idaTApply(idf, "Species", FUN=columnMeans, output.name="IRIS_MEANS", output.signature=resSig)

#It is possible as well to apply an anonymous function.
#The value "5" of the second parameter designates the position of the "Species" column
#in the idf ida.data.frame.
#The output table of the previous call is recreated because of the "clear.existing=T" parameter.
resDf &lt;- idaTApply(idf, 5,
                   FUN=function(x, index) {
                              cbind(index=x[1,match(index, names(x))],
                                     as.data.frame(as.list(apply(x[,names(x) != index],2,mean))))},
                   output.name="IRIS_MEANS", output.signature=resSig, clear.existing=T)

#Apply the columnMeans2 function which has an additional parameter "columns"
#to specify the columns for which the mean values are computed
columnMeans2 &lt;- function(x, index, columns) {
       cbind(index=x[1,match(index, names(x))],
              as.data.frame(as.list(apply(x[,names(x) != index &amp; names(x) %in% columns],2,mean))))}
petalColumns &lt;- c("PetalLength", "PetalWidth")
resSig2 &lt;- list(Species="VARCHAR(12)", MPetalLength="DOUBLE", MPetalWidth="DOUBLE")
resDf2 &lt;- idaTApply(idf, "Species", FUN=columnMeans2, output.name="IRIS_MEANS2",
                    output.signature=resSig2, clear.existing=T, columns=petalColumns)

## End(Not run)
</code></pre>

<hr>
<h2 id='idaTree'>Decision and Regression tree</h2><span id='topic+idaTree'></span><span id='topic+plot.idaTree'></span><span id='topic+predict.idaTree'></span>

<h3>Description</h3>

<p>This function generates a tree model based on the contents of an IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaTree( form, data, id, minsplit=50, maxdepth=10, qmeasure=NULL,
         minimprove=0.01, eval=NULL, valtable=NULL, modelname=NULL)

## S3 method for class 'idaTree'
plot(x,...)  
## S3 method for class 'idaTree'
predict(object, newdata, id, ...)  

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaTree_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that specifies both the name of the column that contains the categorical 
target variable and either a list of columns separated by plus symbols (each column corresponds to one predictor 
variable) or a single period (to specify that all other columns in the IDA data frame are to be used as predictors.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_data">data</code></td>
<td>
<p>An IDA data frame that contains the input data for the function. The input IDA data frame 
must include a column that contains a unique ID for each row.</p>
</td></tr>	
<tr><td><code id="idaTree_+3A_id">id</code></td>
<td>
<p>The name of the column that contains a unique ID for each row of the input data.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of rows a node must contain to be split further.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_maxdepth">maxdepth</code></td>
<td>
<p>The maximum depth (that is, the number of hierarchical levels) of the generated tree.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_qmeasure">qmeasure</code></td>
<td>
<p>The measure that is to be used to prune the tree. 
For a decision tree, allowed values are <code>"Acc"</code> (this is the default) and <code>"wAcc"</code>. 
For a regression tree, allowed values are <code>"mse"</code> (this is the default), <code>"r2"</code>, <code>"pearson"</code>, and <code>"spearman"</code>.</p>
</td></tr>  	
<tr><td><code id="idaTree_+3A_minimprove">minimprove</code></td>
<td>
<p>The minimum improvement. A node is not split further unless the split improves the 
class impurity by at least the amount specified for this parameter.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_eval">eval</code></td>
<td>
<p>The criterion that is to be used to calculate each split.
For a decision tree, allowed values are <code>"entropy"</code> (this is the default) and <code>"gini"</code>.
For a regression tree, the only allowed value is <code>"variance"</code> (this is the default).</p>
</td></tr>
<tr><td><code id="idaTree_+3A_valtable">valtable</code></td>
<td>
<p>When the output tree is to be pruned using external data, use this parameter 
to specify the fully-qualified name of the table that contains that data. Otherwise, specify NULL.</p>
</td></tr>	
<tr><td><code id="idaTree_+3A_modelname">modelname</code></td>
<td>
<p>The name under which the model is stored in the database.
This is the name that is specified when using functions such as <code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code> or <code><a href="#topic+idaDropModel">idaDropModel</a></code>.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_object">object</code></td>
<td>
<p>An object of the class <code>idaTree</code>.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_x">x</code></td>
<td>
<p>An object of the class <code>idaTree</code>.</p>
</td></tr>
<tr><td><code id="idaTree_+3A_newdata">newdata</code></td>
<td>
<p>A IDA data frame that contains the data to which to apply the model.</p>
</td></tr> 
<tr><td><code id="idaTree_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to plot or predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idaTree function uses a top-down, iterative procedure to generate a decision-tree or regression-tree model,
depending on the type of the target variable. The resulting model comprises a network of nodes and connectors, 
and each subnode is the endpoint of a binary split.
</p>
<p>A node is not split further when any of the following are true:
</p>

<ul>
<li><p> The node has a uniform class (and therefore cannot be split further).
</p>
</li>
<li><p> Additional splits do not improve the class impurity by at least the amount specified by <code>minimprove</code>.
</p>
</li>
<li><p> The number of rows contained by the node is less than the value specified by <code>minsplit</code>.
</p>
</li>
<li><p> The tree depth reaches the value specified by <code>maxdepth</code>.
</p>
</li></ul>

<p>If variable that is used to determine a split does not have a value, the corresponding row remains in the node that is being split.
</p>
<p>The output of the print function for a idaTree object is a textual description of the corresponding model.
</p>
<p>The output of the plot function for a idaTree object is a graphical representation of the corresponding model.
</p>
<p>Models are stored persistently in the database under the name <code>modelname</code>. Model names cannot have more than 64 characters and
cannot contain white spaces. They need to be quoted like table names, otherwise they will be treated upper case by default. Only one
model with a given name is allowed in the database at a time. If a model with <code>modelname</code> already exists, you need to drop it with <code>idaDropModel</code>
first before you can create another one with the same name. The model name can be used to retrieve the model later (<code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>).
</p>
<p>The <code>predict.idaTree</code> method applies the model to the data in a table and returns a IDA data frame that contains
a list of tuples, each of which comprises one row ID and one prediction.
</p>


<h3>Value</h3>

<p>The idaTree function returns an object of classes <code>idaTree</code> and <code>rpart</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>, <code><a href="#topic+idaDropModel">idaDropModel</a></code>, <code><a href="#topic+idaListModels">idaListModels</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Create a pointer to the table IRIS
idf &lt;- ida.data.frame('IRIS')

#Create a tree model
tr &lt;- idaTree(Species~.,idf,"ID",modelname="MYTREEMODEL")

#Print the model
print(tr)

#Plot the model
plot(tr)

#Apply the model to data
pred &lt;- predict(tr,idf,id="ID")

#Inspect the predictions
head(pred)


## End(Not run)

</code></pre>

<hr>
<h2 id='idaTwoStep'>two step clustering</h2><span id='topic+idaTwoStep'></span><span id='topic+print.idaTwoStep'></span><span id='topic+predict.idaTwoStep'></span>

<h3>Description</h3>

<p>This function generates a two step clustering model based on the contents of an IDA data frame (<code><a href="#topic+ida.data.frame">ida.data.frame</a></code>).	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaTwoStep( data, id, k = 3, maxleaves = 1000, distance = "euclidean", outtable = NULL,
            randseed = 12345, statistics = NULL, maxk = 20, nodecapacity = 6,
            leafcapacity = 8, outlierfraction = 0, modelname = NULL)

## S3 method for class 'idaTwoStep'
print(x,...)  
## S3 method for class 'idaTwoStep'
predict(object, newdata, id,...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaTwoStep_+3A_data">data</code></td>
<td>
<p>A IDA data frame that contains the input data for the function. The input IDA data frame 
must include a column that contains a unique ID for each row.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_id">id</code></td>
<td>
<p>The name of the column that contains a unique ID for each row of the input data.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_k">k</code></td>
<td>
<p>The number of clusters to be calculated.</p>
</td></tr> 
<tr><td><code id="idaTwoStep_+3A_maxleaves">maxleaves</code></td>
<td>
<p>The maximum number of leaf nodes in the initial clustering tree. When the tree contains maxleaves 
leaf nodes, the following data records are aggregated into clusters associated with the existing leaf nodes.
This parameter is available for Db2 for z/OS only and ignored for Db2 Warehouse with integrated Spark.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_maxk">maxk</code></td>
<td>
<p>The maximum number of clusters that can be determined automatically.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_nodecapacity">nodecapacity</code></td>
<td>
<p>The branching factor of the internal tree that is used in pass 1.
Each node can have up to &lt;nodecapacity&gt; subnodes. </p>
</td></tr>
</table>
<p>This parameter is available for Db2 Warehouse with integrated Spark only and ignored for Db2 for z/OS.
</p>
<table>
<tr><td><code id="idaTwoStep_+3A_leafcapacity">leafcapacity</code></td>
<td>
<p>The number of clusters per leaf node in the internal tree that is used in pass 1.
This parameter is available for Db2 Warehouse with integrated Spark only and ignored for Db2 for z/OS.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_outlierfraction">outlierfraction</code></td>
<td>
<p>The fraction of the records that is to be considered as outlier in the internal tree that is used in pass 1.
Clusters that contain less than &lt;outlierfraction&gt; times the mean number of data records per cluster are removed.
This parameter is available for Db2 Warehouse with integrated Spark only and ignored for Db2 for z/OS.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_distance">distance</code></td>
<td>
<p>The distance function that is to be used. This can be set to <code>"euclidean"</code>, which 
causes the squared Euclidean distance to be used, or <code>"norm_euclidean"</code>, which causes normalized euclidean distance to be used.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_outtable">outtable</code></td>
<td>
<p>The name of the output table that is to contain the results of the operation. When NULL 
is specified, a table name is generated automatically.</p>
</td></tr> 
<tr><td><code id="idaTwoStep_+3A_randseed">randseed</code></td>
<td>
<p>The seed for the random number generator.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_statistics">statistics</code></td>
<td>
<p>Denotes which statistics to calculate. Allowed values are <code>"none"</code>,<code>"columns"</code> and <code>"all"</code>.
If NULL, the default of the database system will be used.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_modelname">modelname</code></td>
<td>
<p>The name under which the model is stored in the database.
This is the name that is specified when using functions such as <code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code> or <code><a href="#topic+idaDropModel">idaDropModel</a></code>.</p>
</td></tr>
<tr><td><code id="idaTwoStep_+3A_object">object</code></td>
<td>
<p>An object of the class <code>idaTwoStep</code> to be used for prediction, i.e. for applying it to new data.</p>
</td></tr> 
<tr><td><code id="idaTwoStep_+3A_x">x</code></td>
<td>
<p>An object of the class <code>idaTwoStep</code> to be printed.</p>
</td></tr> 
<tr><td><code id="idaTwoStep_+3A_newdata">newdata</code></td>
<td>
<p>A IDA data frame that contains the data to which to apply the model.</p>
</td></tr> 
<tr><td><code id="idaTwoStep_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to the print or predict method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The idaTwoStep clustering function distributes first the input data into a hierarchical tree structure 
according to the distance between the data records where each leaf node corresponds to a (small) cluster.
Then idaTwoStep reduces the tree by aggregating the leaf nodes according to the distance function until k clusters remain.
</p>
<p>Models are stored persistently in database under the name <code>modelname</code>. Model names cannot have more than 64 characters and
cannot contain white spaces. They need to be quoted like table names, otherwise they will be treated upper case by default. Only one
model with a given name is allowed in the database at a time. If a model with <code>modelname</code> already exists, you need to drop it with <code>idaDropModel</code>
first before you can create another one with the same name. The model name can be used to retrieve the model later (<code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>).
</p>
<p>The output of the print function for a idaTwoStep object is:
</p>

<ul>
<li><p> A vector containing a list of centers
</p>
</li>
<li><p> A vector containing a list of cluster sizes
</p>
</li>
<li><p> A vector containing a list of the number of elements in each cluster
</p>
</li>
<li><p> A data frame or the name of the table containing the calculated cluster assignments
</p>
</li>
<li><p> The within-cluster sum of squares (which indicates cluster density)
</p>
</li>
<li><p> The names of the slots that are available in the idaTwoStep object
</p>
</li></ul>



<h3>Value</h3>

<p>The idaTwoStep function returns an object of class <code>idaTwoStep</code> and <code>TwoStep</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idaRetrieveModel">idaRetrieveModel</a></code>, <code><a href="#topic+idaDropModel">idaDropModel</a></code>, <code><a href="#topic+idaListModels">idaListModels</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#Create ida data frame
idf &lt;- ida.data.frame("IRIS")

#Create a TwoStep model stored in the database as TwoStepMODEL
tsm &lt;- idaTwoStep(idf, id="ID",modelname="TwoStepMODEL") 
	
#Print the model
print(tsm)

#Predict the model
pred &lt;- predict(tsm,idf,id="ID")

#Inspect the predictions
head(pred)
	

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
