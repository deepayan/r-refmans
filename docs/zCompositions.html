<!DOCTYPE html><html><head><title>Help for package zCompositions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zCompositions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cmultRepl'>
<p>Bayesian-Multiplicative replacement of count zeros</p></a></li>
<li><a href='#lcTest'><p>Log-contrast homogeneity test</p></a></li>
<li><a href='#LPdata'>
<p>La Paloma data set</p></a></li>
<li><a href='#LPdataZM'>
<p>La Paloma data set (incl. zeros and missing data)</p></a></li>
<li><a href='#lrDA'>
<p>Log-ratio DA algorithm</p></a></li>
<li><a href='#lrEM'>
<p>Log-ratio EM algorithm</p></a></li>
<li><a href='#lrEMplus'>
<p>Log-ratio EM algorithm (plus)</p></a></li>
<li><a href='#lrSVD'><p>Log-ratio SVD algorithm</p></a></li>
<li><a href='#lrSVDplus'>
<p>Log-ratio SVD algorithm (plus)</p></a></li>
<li><a href='#mdl'>
<p>Water data set: matrix of limits of detection</p></a></li>
<li><a href='#multKM'>
<p>Multiplicative Kaplan-Meier smoothing spline (KMSS) replacement</p></a></li>
<li><a href='#multLN'>
<p>Multiplicative lognormal replacement</p></a></li>
<li><a href='#multRepl'><p>Multiplicative simple replacement</p></a></li>
<li><a href='#multReplus'>
<p>Multiplicative simple replacement (plus)</p></a></li>
<li><a href='#Pigs'>
<p>Pigs data set</p></a></li>
<li><a href='#splineKM'>
<p>Display Kaplan-Meier empirical cumulative distribution function and smoothing spline curve fit</p></a></li>
<li><a href='#Water'>
<p>Water data set</p></a></li>
<li><a href='#zCompositions'>
<p>Treatment of Zeros, Left-Censored and Missing Values in Compositional Data Sets</p></a></li>
<li><a href='#zPatterns'>
<p>Find and display patterns of zeros/missing values in a data set</p></a></li>
<li><a href='#zVarArray'><p>Variation array for grouped data</p></a></li>
<li><a href='#zVarArrayError'><p>Variation array relative error</p></a></li>
<li><a href='#zVarArrayTest'><p>Variation array homogeneity test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Treatment of Zeros, Left-Censored and Missing Values in
Compositional Data Sets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javier Palarea-Albaladejo &lt;javier.palarea@udg.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), methods, MASS, NADA, truncnorm</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Principled methods for the imputation of zeros, left-censored and missing data in
    compositional data sets (Palarea-Albaladejo and Martin-Fernandez (2015) &lt;<a href="https://doi.org/10.1016%2Fj.chemolab.2015.02.019">doi:10.1016/j.chemolab.2015.02.019</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Japal/zCompositions">https://github.com/Japal/zCompositions</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Japal/zCompositions/issues">https://github.com/Japal/zCompositions/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-13 08:53:43 UTC; Japal</td>
</tr>
<tr>
<td>Author:</td>
<td>Javier Palarea-Albaladejo
    <a href="https://orcid.org/0000-0003-0162-669X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Josep Antoni Martin-Fernandez
    <a href="https://orcid.org/0000-0003-2366-1592"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-13 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cmultRepl'>
Bayesian-Multiplicative replacement of count zeros
</h2><span id='topic+cmultRepl'></span>

<h3>Description</h3>

<p>This function implements methods for imputing zeros in compositional count data sets based on a Bayesian-multiplicative replacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmultRepl(X, label = 0,
             method = c("GBM","SQ","BL","CZM","user"), output = c("prop","p-counts"),
             frac = 0.65, threshold = 0.5, adjust = TRUE, t = NULL, s = NULL,
             z.warning = 0.8, z.delete = TRUE, suppress.print = FALSE,
             delta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmultRepl_+3A_x">X</code></td>
<td>

<p>Count data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote count zeros in <code>X</code> (default <code>label=0</code>).</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_method">method</code></td>
<td>

<p>Geometric Bayesian multiplicative (<code>GBM</code>, default); square root BM (<code>SQ</code>); Bayes-Laplace BM (<code>BL</code>); count zero multiplicative (<code>CZM</code>); user-specified hyper-parameters (<code>user</code>).
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_output">output</code></td>
<td>
<p>Output format: imputed proportions (<code>prop</code>, default) or <em>pseudo</em>-counts (<code>p-counts</code>). 
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_frac">frac</code></td>
<td>

<p>If <code>method="CZM"</code>, fraction of the upper threshold used to impute zeros (default <code>frac=0.65</code>). Also, fraction of the lowest estimated probability used to adjust imputed proportions falling above it (when <code>adjust=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_threshold">threshold</code></td>
<td>

<p>For a vector of counts, factor applied to the quotient 1 over the number of trials (sum of the counts) used to produce an upper limit for replacing zero counts by the <code>CZM</code> method (default <code>threshold=0.5</code>).
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_adjust">adjust</code></td>
<td>

<p>Logical vector setting whether imputed proportions falling above the lowest estimated probability for a multinomial part must be adjusted or not (default <code>adjust=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_t">t</code></td>
<td>

<p>If <code>method="user"</code>, user-specified <em>t</em> hyper-parameter of the Dirichlet prior distribution for each count vector (row) in <code>X</code>. It must be a matrix of the same dimensions as <code>X</code>.
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_s">s</code></td>
<td>
<p>If <code>method="user"</code>, user-specified <em>s</em> hyper-parameter of the Dirichlet prior distribution for each count vector (row) in <code>X</code>. It must be a vector of length equal to the number of rows of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_suppress.print">suppress.print</code></td>
<td>

<p>Suppress printed feedback (<code>suppress.print=FALSE</code>, default).
</p>
</td></tr>
<tr><td><code id="cmultRepl_+3A_delta">delta</code></td>
<td>
<p>This argument has been deprecated and replaced by <code>frac</code> (see package's NEWS for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero counts, assumed to be due to under-reporting or limited sampling, are imputed under a Bayesian paradigm (<code>GBM</code>, <code>SQ</code> or <code>BL</code> method) by posterior estimates of the multinomial probabilities generating the counts, assuming a Dirichlet prior distribution. The argument <code>method</code> sets the Dirichlet hyper-parameters <code>t</code> (priori estimates of multinomial probabilities) and <code>s</code> (<em>strength</em>). The user can specify their own by setting <code>method="user"</code> and entering them as <code>t</code> and <code>s</code> arguments. Note that, under certain circumstances (see references for details), these methods can generate imputed proportions falling above the lowest estimated probability  of a multinomial part (<em>c</em>/<em>n</em>, where <em>c</em> is the count and <em>n</em> is the number of trials). In such cases, the imputation is adjusted by using a fraction (<code>frac</code>) of the minimum <em>c</em>/<em>n</em> for that part. Lastly, the non-zero parts are multiplicatively adjusted according to their compositional nature.
</p>
<p>On the other hand, <code>method="CZM"</code> uses multiplicative simple replacement (<code><a href="#topic+multRepl">multRepl</a></code>) on the matrix of estimated probabilities. The upper limit and the fraction used are specified by, respectively, the arguments <code>threshold</code> and <code>frac</code>. Suggested values are <code>threshold=0.5</code> (so the upper limit for a multinomial probability turns out to be 0.5/<em>n</em>), and <code>frac=0.65</code> (so the imputed proportion is 65% of the upper limit).
</p>


<h3>Value</h3>

<p>By default (<code>output="prop"</code>) the function returns an imputed data set (<code><a href="base.html#topic+data.frame">data.frame</a></code> class) in proportions (estimated probabilities). Alternatively, these proportions are re-scaled to produce a compositionally-equivalent matrix of <em>pseudo</em>-counts (<code>output="p-counts"</code>) which preserves the ratios between parts.
</p>
<p>When <code>adjust=TRUE</code> and <code>verbose=TRUE</code>, the number of times, if any, an imputed proportion was adjusted to fall below the minimum estimated multinomial probability is printed.
</p>


<h3>References</h3>

<p>Martin-Fernandez, J.A., Hron, K., Templ, M., Filzmoser, P., Palarea-Albaladejo, J. Bayesian-multiplicative treatment of count zeros in compositional data sets. Statistical Modelling 2015; 15: 134-158.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pigs)

# GBM method and matrix of estimated probabilities
Pigs.GBM &lt;- cmultRepl(Pigs)

</code></pre>

<hr>
<h2 id='lcTest'>Log-contrast homogeneity test</h2><span id='topic+lcTest'></span>

<h3>Description</h3>

<p>This function tests for homogeneity across groups of means and variances of
user-defined log-contrasts. Groups can be defined by either zero/unobserved data patterns or by a grouping
factor in fully observed zero-free data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcTest(
  X,
  label = 0,
  groups = NULL,
  lc = NULL,
  method = c("parametric", "nonparametric"),
  b = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcTest_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="lcTest_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zero or unobserved data in <code>X</code> (<code>label = 0</code>, default).</p>
</td></tr>
<tr><td><code id="lcTest_+3A_groups">groups</code></td>
<td>
<p>Grouping factor in fully observed zero-free data sets (<code>groups = NULL</code>, default).</p>
</td></tr>
<tr><td><code id="lcTest_+3A_lc">lc</code></td>
<td>
<p>User-defined log-contrast (see details below).</p>
</td></tr>
<tr><td><code id="lcTest_+3A_method">method</code></td>
<td>
<p>Approach used for mean and variance homogeneity testing (<code>method = "parametric"</code>, default).</p>
</td></tr>
<tr><td><code id="lcTest_+3A_b">b</code></td>
<td>
<p>Number of bootstrap resamples used by permutation test (<code>b = 1000</code>, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Homogeneity of log-contrast means and variances across groups is tested using either parametric or non-parametric tests. When
<code>method = "parametric"</code>, ordinary analysis of variance and Bartlett's tests are used. Alternatively,
Kruskal-Wallis and Fligner-Killen tests are used instead when <code>method = "nonparametric"</code>. The results of a permutation test of homogeneity of variation
arrays based on total weighted squared relative errors are also provided (see <code><a href="#topic+zVarArrayTest">zVarArrayTest</a></code> for more details).
The log-contrast is specified by the <code>lc</code> argument using a vector of codes 1, -1 and 0 for components
in the numerator, denominator and omitted respectively.
</p>


<h3>Value</h3>

<p>Test p-values for log-contrast means and variances.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+zVarArray">zVarArray</a></code>, <code><a href="#topic+zVarArrayError">zVarArrayError</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
zPatterns(Water, label = 0)

# Test of homogeneity in log-contrast Potassium/Arsenic*Calcium
lcTest(Water, label = 0, lc = c(1,-1,-1,0))
</code></pre>

<hr>
<h2 id='LPdata'>
La Paloma data set
</h2><span id='topic+LPdata'></span>

<h3>Description</h3>

<p>96 samples of a 15-part geochemical composition in micrograms/gram from La Paloma stream (Venezuela) including 6.11% values below the limit of detection (coded as 0). For more details see Montero-Serrano et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LPdata)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 96 observations on the following 15 variables.
</p>

<dl>
<dt><code>Cr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>V</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cu</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ti</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ni</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Sr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>La</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ce</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ba</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Li</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>K</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Rb</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Montero-Serrano JC, Palarea-Albaladejo J, Martin-Fernandez JA, and Martinez-Santana M and Gutierrez-Martin JV. Multivariate analysis applied to chemostratigraphic data: identification of chemofacies and stratigraphic correlation, Sedimentary Geology 2010; 228(3-4): 218-228 .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LPdata)

zPatterns(LPdata,label=0)
</code></pre>

<hr>
<h2 id='LPdataZM'>
La Paloma data set (incl. zeros and missing data)
</h2><span id='topic+LPdataZM'></span>

<h3>Description</h3>

<p>96 samples of a 15-part geochemical composition in micrograms/gram from La Paloma stream (Venezuela). For more details see Montero-Serrano et al. (2010).
</p>
<p>Duplicate of the <code>LPdata</code> data set including 2.36% missing at random cells (35.42% samples with missing data; coded as <code>NA</code>) along with 6.11% values below the limit of detection (coded as 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LPdataZM)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 96 observations on the following 15 variables.
</p>

<dl>
<dt><code>Cr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>V</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cu</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ti</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ni</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Sr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>La</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ce</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ba</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Li</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>K</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Rb</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Montero-Serrano JC, Palarea-Albaladejo J, Martin-Fernandez JA, and Martinez-Santana M and Gutierrez-Martin JV. Multivariate analysis applied to chemostratigraphic data: identification of chemofacies and stratigraphic correlation, Sedimentary Geology 2010; 228(3-4): 218-228 .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LPdata">LPdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LPdataZM)

zPatterns(LPdataZM,label=0) # Show zero patterns

zPatterns(LPdataZM,label=NA) # Show missingness patterns
</code></pre>

<hr>
<h2 id='lrDA'>
Log-ratio DA algorithm
</h2><span id='topic+lrDA'></span>

<h3>Description</h3>

<p>This function implements a simulation-based Data Augmentation (DA) algorithm to impute left-censored values (e.g. values below detection limit, rounded zeros) via coordinates representation of compositional data sets which incorporate the information of the relative covariance structure. Alternatively, this function can be used to impute missing data. Multiple imputation estimates can be also obtained from the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrDA(X, label = NULL, dl = NULL,
        ini.cov=c("lrEM","complete.obs","multRepl"), frac = 0.65,
        imp.missing = FALSE, n.iters = 1000, m = 1, store.mi = FALSE, closure = NULL,
        z.warning = 0.8, z.delete = TRUE, delta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrDA_+3A_x">X</code></td>
<td>

<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="lrDA_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="lrDA_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.
</p>
</td></tr>
<tr><td><code id="lrDA_+3A_ini.cov">ini.cov</code></td>
<td>
<p>Initial estimation of the log-ratio covariance matrix. It can be based on lrEM estimation (<code>"lrEM"</code>, default), complete observations (<code>"complete.obs"</code>)  or multiplicative simple replacement (<code>"multRepl"</code>).</p>
</td></tr>
<tr><td><code id="lrDA_+3A_frac">frac</code></td>
<td>

<p>If <code>ini.cov="multRepl"</code>, parameter for initial multiplicative simple replacement (<code><a href="#topic+multRepl">multRepl</a></code>) (default = 0.65).
</p>
</td></tr>
<tr><td><code id="lrDA_+3A_imp.missing">imp.missing</code></td>
<td>
<p>If <code>TRUE</code> then unobserved data identified by <code>label</code> are treated as missing data (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lrDA_+3A_n.iters">n.iters</code></td>
<td>

<p>Number of iterations for the DA algorithm (default = 1000).
</p>
</td></tr>
<tr><td><code id="lrDA_+3A_m">m</code></td>
<td>

<p>Number of multiple imputations (default = 1).
</p>
</td></tr>
<tr><td><code id="lrDA_+3A_store.mi">store.mi</code></td>
<td>

<p>Logical value. If <code>m&gt;1</code> creates a list with <code>m</code> imputed data matrices. (<code>store.mi=FALSE</code>, default).
</p>
</td></tr>
<tr><td><code id="lrDA_+3A_closure">closure</code></td>
<td>
<p>Closure value used to add a residual part if needed when multiplicative simple replacement is used to initiate the DA algorithm, either directly (<code>ini.cov="multRepl"</code>) or as part of lrEM estimation (<code>ini.cov="lrEM"</code>) (see <code>?multRepl</code>).</p>
</td></tr>
<tr><td><code id="lrDA_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="lrDA_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="lrDA_+3A_delta">delta</code></td>
<td>
<p>This argument has been deprecated and replaced by <code>frac</code> (see package's NEWS for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After convergence of the Markov chain Monte Carlo (MCMC) iterative process to its steady state, this function imputes unobserved compositional parts by simulated values from their posterior predictive distributions through coordinates representation, given the information from the observed data. For left-censoring problems, it allows for either single (<code>vector</code> form) or multiple (<code>matrix</code> form, same size as <code>X</code>) limits of detection by component. Any threshold value can be set for non-censored elements (e.g. use 0 if no threshold for a particular column or element of the data matrix).
</p>
<p>It produces imputed data sets on the same scale as the input data set. If <code>X</code> is not closed to a constant sum, then the results are adjusted to provide a compositionally equivalent data set, expressed in the original scale, which leaves the absolute values of the observed components unaltered.
</p>
<p>The common conjugate normal inverted-Wishart distribution with non-informative Jeffreys prior has been assumed for the model parameters in the coordinates space. Under this setting, convergence is expected to be fast (<code>n.iters</code> set to 1000 by default). Besides, considering EM parameter estimates as initial point for the DA algorithm (<code>ini.cov="lrEM"</code>) assures faster convergence by starting near the centre of the posterior distribution. Note that the estimation of the covariance matrix requires a regular data set, i.e. having more observations than variables in the data.
</p>
<p>By setting <code>m</code> greater than 1, the procedure also allows for multiple imputations of the censored values drawn at regular intervals after convergence. In this case, in addition to the burn-in period for convergence, <code>n.iters</code> determines the gap, large enough to prevent from correlated values, between successive imputations. The total number of iterations is then <code>n.iters*m</code>. By default, a single imputed data set results from averaging the <code>m</code> imputations in the space of coordinates. If <code>store.mi=TRUE</code>, a list with <code>m</code> imputed data sets is generated instead.
</p>
<p>In the case of censoring patterns involving samples containing only one observed component, these are imputed by multiplicative simple replacement (<code><a href="#topic+multRepl">multRepl</a></code>) and a warning message identifying them is printed.
</p>

<p><em>Missing data imputation</em>
</p>
<p>This function can be employed to impute missing data by setting <code>imp.missing = TRUE</code>. For this case, the argument <code>label</code> indicates the unique label for missing values. The argument <code>dl</code> is ignored as it is meaningless here.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale, or a <code><a href="base.html#topic+list">list</a></code> of imputed data sets if multiple imputation is carried out (<code>m&gt;1</code>) and <code>store.mi=TRUE</code>.
</p>


<h3>References</h3>

<p>Palarea-Albaladejo J, Martin-Fernandez JA, Olea, RA. A bootstrap estimation scheme for chemical compositional data with nondetects. Journal of Chemometrics 2014; 28: 585-599.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+lrEM">lrEM</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set closed to 100 (percentages, common dl = 1%)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,26.20,0.00,15.22,6.80,12.05,
              10.76,31.36,7.10,12.74,31.34,6.70,
              10.85,46.40,31.89,10.86,0.00,0.00,
              7.57,11.35,30.24,6.39,13.65,30.80,
              38.09,7.62,23.68,9.70,20.91,0.00,
              27.67,7.15,13.05,32.04,6.54,13.55,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)

# Imputation by single simulated values
X_lrDA &lt;- lrDA(X,label=0,dl=rep(1,6),ini.cov="multRepl",n.iters=150)

# Imputation by multiple imputation (m = 5, one imputation every 150 iterations)
X_milrDA &lt;- lrDA(X,label=0,dl=rep(1,6),ini.cov="multRepl",m=5,n.iters=150)

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_lrDA2 &lt;- lrDA(X,label=0,dl=mdl,ini.cov="multRepl",n.iters=150)

# Non-closed compositional data set
data(LPdata) # data (ppm/micrograms per gram)
dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
LPdata2 &lt;- subset(LPdata,select=-c(Cu,Ni,La))  # select a subset for illustration purposes
dl2 &lt;- dl[-c(5,7,10)]

## Not run:  # May take a little while
LPdata2_lrDA &lt;- lrDA(LPdata2,label=0,dl=dl2)
## End(Not run)

## Not run:  # May take a little while
# Treating zeros as missing data for illustration purposes only
LPdata2_lrDAmiss &lt;- lrDA(LPdata2,label=0,imp.missing=TRUE,closure=10^6)
## End(Not run)

</code></pre>

<hr>
<h2 id='lrEM'>
Log-ratio EM algorithm
</h2><span id='topic+lrEM'></span>

<h3>Description</h3>

<p>This function implements model-based ordinary and robust Expectation-Maximisation algorithms to impute left-censored data (e.g. values below detection limit, rounded zeros) via coordinates representation of compositional data which incorporate the information of the relative covariance structure.
</p>
<p>This function can be also used to impute missing data instead by setting <code>imp.missing = TRUE</code> (see <code><a href="#topic+lrEMplus">lrEMplus</a></code> to treat censored and missing data simultaneously).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrEM(X, label = NULL, dl = NULL, rob = FALSE,
        ini.cov = c("complete.obs", "multRepl"), frac = 0.65,
        tolerance = 0.0001, max.iter = 50, rlm.maxit = 150,
        imp.missing = FALSE, suppress.print = FALSE, closure = NULL,
        z.warning = 0.8, z.delete = TRUE, delta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrEM_+3A_x">X</code></td>
<td>

<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="lrEM_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds. 
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_rob">rob</code></td>
<td>

<p>Logical value. <code>FALSE</code> provides maximum-likelihood estimates of model parameters (default), <code>TRUE</code> provides robust parameter estimates.
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_ini.cov">ini.cov</code></td>
<td>
<p>Initial estimation of either the log-ratio covariance matrix (ML estimation) or unobserved data (robust estimation). It can be based on either complete observations (<code>"complete.obs"</code>, default) or multiplicative simple replacement (<code>"multRepl"</code>).</p>
</td></tr>
<tr><td><code id="lrEM_+3A_frac">frac</code></td>
<td>

<p>If <code>ini.cov="multRepl"</code>, parameter for initial multiplicative simple replacement of left-censored data (see <code><a href="#topic+multRepl">multRepl</a></code>) (default = 0.65).
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_tolerance">tolerance</code></td>
<td>
<p>Convergence criterion for the EM algorithm (default = 0.0001).</p>
</td></tr>
<tr><td><code id="lrEM_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of iterations for the EM algorithm (default = 50).
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_rlm.maxit">rlm.maxit</code></td>
<td>

<p>If <code>rob=TRUE</code>, maximum number of iterations for the embedded robust regression estimation (default = 150; see <code><a href="MASS.html#topic+rlm">rlm</a></code> in <code>MASS</code> package for details).
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_imp.missing">imp.missing</code></td>
<td>
<p>If <code>TRUE</code> then unobserved data identified by <code>label</code> are treated as missing data (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lrEM_+3A_suppress.print">suppress.print</code></td>
<td>

<p>Suppress printed feedback (<code>suppress.print = FALSE</code>, default).
</p>
</td></tr>
<tr><td><code id="lrEM_+3A_closure">closure</code></td>
<td>
<p>Closure value used to add a residual part if needed when <code>ini.cov="multRepl"</code> is used (see <code>?multRepl</code>).</p>
</td></tr>
<tr><td><code id="lrEM_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="lrEM_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="lrEM_+3A_delta">delta</code></td>
<td>
<p>This argument has been deprecated and replaced by <code>frac</code> (see package's NEWS for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After convergence, this function imputes unobserved compositional data by their estimated conditional expected values through coordinates representation, given the information from the observed data. For left-censoring problems, it allows for either single (<code>vector</code> form) or multiple (<code>matrix</code> form, same size as <code>X</code>) limits of detection by component. Any threshold value can be set for non-censored elements (e.g. use 0 if no threshold for a particular column or element of the data matrix).
</p>
<p>It produces an imputed data set on the same scale as the input data set. If <code>X</code> is not closed to a constant sum, then the results are adjusted to provide a compositionally equivalent data set, expressed in the original scale, which leaves the absolute values of the observed components unaltered.
</p>
<p>Under maximum likelihood (ML) estimation (default, <code>rob=FALSE</code>), a correction factor based on the residual covariance obtained by censored regression is applied for the correct estimation of the conditional covariance matrix in the maximisation step of the EM algorithm. This is required in order to obtain the conditional expectation of the sum of cross-products between two components in the case that both involve imputed values. Note that the procedure is based on the oblique additive log-ratio (alr) transformation to simplify calculations and alleviates computational burden. Nonetheless, the same results would be obtained using an isometric log-ratio transformation (ilr). Note also that alr requires at least one complete column. Otherwise, a preliminary imputation, e.g. by <code><a href="#topic+multRepl">multRepl</a></code> or <code><a href="#topic+multLN">multLN</a></code>, of the most simplest censoring pattern may be enough. The argument <code>ini.cov</code> determines how the initial estimation of the log-ratio covariance matrix required to start the EM process is worked out. Note that the estimation of the covariance matrix, and hence the lrEM routine, requires a regular data set, i.e. having more observations than variables in the data.
</p>
<p>Under robust estimation (<code>rob=TRUE</code>), the algorithm requires ilr transformations in order to satisfy requirements for robust estimation methods (MM-estimation by default, see <code>rlm</code> function for more details). An initial estimation of nondetects is required to get the algorithm started. This can be based on either the subset of fully observed cases (<code>ini.cov="complete.obs"</code>) or a multiplicative simple replacement of all nondetects in the data set (<code>ini.cov="multRepl"</code>). Note that the robust regression method involved includes random elements which can, occasionally, give rise to <code><a href="base.html#topic+NaN">NaN</a></code> values getting the routine execution halted. If this happened, we suggest to simply re-run the function once again.
</p>
<p>Note that conditional imputation based on log-ratio coordinates cannot be conducted when there exist censoring patterns including samples with only one observed component. As a workaround, <code>lrEM</code> applies multiplicative simple replacement (<code><a href="#topic+multRepl">multRepl</a></code>) on those and a warning message identifying the problematic cases is printed. Alternatively, it might be sensible to simply remove those non-informative samples from the data set.
</p>
<p><em>Missing data imputation</em>
</p>
<p>When <code>imp.missing = TRUE</code>, unobserved values are treated as general missing data and imputed by their conditional expectation using the EM algorithm. Either maximum-likelihood or robust estimation can be used through the <code>rob</code> argument. For this case, the argument <code>label</code> indicates the unique label for missing values. The algorithm can be initiated using either <code>"complete.obs"</code> or <code>"multRepl"</code> (for missing data) as specified by the <code>ini.cov</code> argument. The argument <code>dl</code> is ignored.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale. The number of iterations required for convergence is also printed (this can be suppressed by setting <code>suppress.print=TRUE</code>).
</p>


<h3>References</h3>

<p>Martin-Fernandez, J.A., Hron, K., Templ, M., Filzmoser, P., Palarea-Albaladejo, J. Model-based replacement of rounded zeros in compositional data: classical and robust approaches. Computational Statistics &amp; Data Analysis 2012; 56: 2688-2704.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA, Gomez-Garcia J. A parametric approach for dealing with compositional rounded zeros. Mathematical Geology 2007; 39: 625-45.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. A modified EM alr-algorithm for replacing rounded zeros in compositional data sets. Computers &amp; Geosciences 2008; 34: 902-917.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. Values below detection limit in compositional chemical data. Analytica Chimica Acta 2013; 764: 32-43.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set closed to 100 (percentages, common dl = 1%)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,26.20,0.00,15.22,6.80,12.05,
              10.76,31.36,7.10,12.74,31.34,6.70,
              10.85,46.40,31.89,10.86,0.00,0.00,
              7.57,11.35,30.24,6.39,13.65,30.80,
              38.09,7.62,23.68,9.70,20.91,0.00,
              27.67,7.15,13.05,32.04,6.54,13.55,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
              
X_lrEM &lt;- lrEM(X,label=0,dl=rep(1,6),ini.cov="multRepl")
X_roblrEM &lt;- lrEM(X,label=0,dl=rep(1,6),ini.cov="multRepl",rob=TRUE,tolerance=0.001)

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_lrEM2 &lt;- lrEM(X,label=0,dl=mdl,ini.cov="multRepl")

# Non-closed compositional data set
data(LPdata) # data (ppm/micrograms per gram)
dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
LPdata2 &lt;- subset(LPdata,select=-c(Cu,Ni,La))  # select a subset for illustration purposes
dl2 &lt;- dl[-c(5,7,10)]

LPdata2_lrEM &lt;- lrEM(LPdata2,label=0,dl=dl2)
LPdata2_roblrEM &lt;- lrEM(LPdata2,label=0,dl=dl2,rob=TRUE,tolerance=0.005)

# Two subsets of limits of detection (using e.g. robust parameter estimation)
 # Using a subset of LPdata for faster execution
data(LPdata) # data (ppm/micrograms per gram)
LPdata2 &lt;- subset(LPdata,select=-c(Cu,Ni,La))
dl2 &lt;- c(2,1,0,0,0,1,0.6,1,0,0,632,10)
 # DLs for first 50 samples of LPdata2
dl2a &lt;- matrix(rep(1,50),ncol=1)%*%dl2
 # DLs for last 46 samples of LPdata
dl2b &lt;- matrix(rep(1,46),ncol=1)%*%c(1,0.5,0,0,0,0.75,0.3,1,0,0,600,8) 

mdl &lt;- rbind(dl2a,dl2b)
LPdata2_roblrEM &lt;- lrEM(LPdata2,label=0,dl=mdl,rob=TRUE,tolerance=0.005)

# Treating zeros as general missing data for illustration purposes only
LPdata2_miss &lt;- lrEM(LPdata2,label=0,imp.missing=TRUE)
</code></pre>

<hr>
<h2 id='lrEMplus'>
Log-ratio EM algorithm (plus) 
</h2><span id='topic+lrEMplus'></span>

<h3>Description</h3>

<p>This function implements an extended version of the log-ratio EM algorithm (<code>lrEM</code> function) to simultaneously deal with both zeros (i.e. data below detection limit, rounded zeros) and missing data in compositional data sets.
</p>
<p>Note: zeros and missing data must be labelled using 0 and <code>NA</code> respectively to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrEMplus(X, dl = NULL, rob = FALSE,
            ini.cov = c("complete.obs", "multRepl"), frac = 0.65,
            tolerance = 0.0001, max.iter = 50, rlm.maxit = 150,
            suppress.print = FALSE, closure = NULL,
            z.warning = 0.8, z.delete = TRUE, delta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrEMplus_+3A_x">X</code></td>
<td>

<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_rob">rob</code></td>
<td>

<p>Logical value. <code>FALSE</code> provides maximum-likelihood estimates of model parameters (default), <code>TRUE</code> provides robust parameter estimates.
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_ini.cov">ini.cov</code></td>
<td>
<p>Initial estimation of either the log-ratio covariance matrix (ML estimation) or unobserved data (robust estimation). It can be based on either complete observations (<code>"complete.obs"</code>, default) or multiplicative simple replacement (<code>"multRepl"</code>).</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_frac">frac</code></td>
<td>

<p>If <code>ini.cov="multRepl"</code>, parameter for initial multiplicative simple replacement of left-censored data (see <code><a href="#topic+multRepl">multRepl</a></code>) (default = 0.65).
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_tolerance">tolerance</code></td>
<td>
<p>Convergence criterion (default = 0.0001).</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_max.iter">max.iter</code></td>
<td>

<p>Maximum number of iterations (default = 50).
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_rlm.maxit">rlm.maxit</code></td>
<td>

<p>If <code>rob=TRUE</code>, maximum number of iterations for the embedded robust regression estimation (default = 150; see <code><a href="MASS.html#topic+rlm">rlm</a></code> in <code>MASS</code> package for details).
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_suppress.print">suppress.print</code></td>
<td>

<p>Suppress printed feedback (<code>suppress.print = FALSE</code>, default).
</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_closure">closure</code></td>
<td>
<p>Closure value used to add a residual part if needed when <code>ini.cov="multRepl"</code> is used (see <code>?multRepl</code>).</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="lrEMplus_+3A_delta">delta</code></td>
<td>
<p>This argument has been deprecated and replaced by <code>frac</code> (see package's NEWS for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure starts with an initial imputation of either zeros (using simple replacement with <code>frac*dl</code>) or missing values (using geometric mean imputation from observed data) depending of which problem is the least frequent in the data set. Subsequently, iterative calls to <code>lrEM</code> replace zeros and missing data alternately until convergence to a stable solution or the maximum number of iterations is reached.
</p>
<p>See <code>?lrEM</code> for more details.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set in the same scale as the original. The number of iterations required for convergence is also printed (this can be suppressed by setting <code>suppress.print=TRUE</code>).
</p>


<h3>References</h3>

<p>Martin-Fernandez, J.A., Hron, K., Templ, M., Filzmoser, P., Palarea-Albaladejo, J. Model-based replacement of rounded zeros in compositional data: classical and robust approaches. Computational Statistics &amp; Data Analysis 2012; 56: 2688-2704.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA, Gomez-Garcia J. A parametric approach for dealing with compositional rounded zeros. Mathematical Geology 2007; 39: 625-45.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. A modified EM alr-algorithm for replacing rounded zeros in compositional data sets. Computers &amp; Geosciences 2008; 34: 902-917.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. Values below detection limit in compositional chemical data. Analytica Chimica Acta 2013; 764: 32-43.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lrEM">lrEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set closed to 100 (percentages, common dl = 1%)
# (Note that zeros and missing in the same row or column are allowed)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,41.42,0.00,NA,6.80,12.05,
              NA,35.13,7.96,14.28,35.12,7.51,
              10.85,46.40,31.89,10.86,0.00,0.00,
              10.85,16.27,NA,9.16,19.57,44.15,
              38.09,7.62,23.68,9.70,20.91,0.00,
              NA,9.89,18.04,44.30,9.04,18.73,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
              
X_lrEMplus &lt;- lrEMplus(X,dl=rep(1,6),ini.cov="multRepl")
X_roblrEMplus &lt;- lrEMplus(X,dl=rep(1,6),ini.cov="multRepl",rob=TRUE,max.iter=4)

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_lrEMplus2 &lt;- lrEMplus(X,dl=mdl,ini.cov="multRepl")

# Non-closed compositional data set
data(LPdataZM) # (in ppm; 0 is nondetect and NA is missing data)

dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
LPdataZM2 &lt;- subset(LPdataZM,select=-c(Cu,Ni,La))  # select a subset for illustration purposes
dl2 &lt;- dl[-c(5,7,10)]

LPdataZM2_lrEMplus &lt;- lrEMplus(LPdataZM2,dl=dl2)
</code></pre>

<hr>
<h2 id='lrSVD'>Log-ratio SVD algorithm</h2><span id='topic+lrSVD'></span>

<h3>Description</h3>

<p>This function implements an iterative algorithm to impute left-censored data (e.g. values below detection limit,
rounded zeros) based on the singular value decomposition (SVD) of a compositional data set. It is particularly indicated for the case in which the data contain more variables than observations.
</p>
<p>This function can be also used to impute missing data instead by setting <code>imp.missing = TRUE</code> (see <code><a href="#topic+lrSVDplus">lrSVDplus</a></code> to treat censored and missing data simultaneously).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrSVD(X, label = NULL, dl = NULL, frac = 0.65, ncp = 2, 
         imp.missing=FALSE, beta = 0.5, method = c("ridge", "EM"),
         row.w = NULL, coeff.ridge = 1, threshold = 1e-04, seed = NULL,
         nb.init = 1, max.iter = 1000, z.warning = 0.8, z.delete = TRUE,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrSVD_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_dl">dl</code></td>
<td>
<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_frac">frac</code></td>
<td>
<p>Parameter for initial multiplicative simple replacement of left-censored data (see <code><a href="#topic+multRepl">multRepl</a></code>) (default = 0.65).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_ncp">ncp</code></td>
<td>
<p>Number of components for low-rank matrix approximation (default = 2).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_imp.missing">imp.missing</code></td>
<td>
<p>If <code>TRUE</code> then unobserved data identified by <code>label</code> are treated as missing data (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_beta">beta</code></td>
<td>
<p>Weighting parameter, balance between the two conditions in objective function (default = 0.5).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_method">method</code></td>
<td>
<p>Parameter estimation method for the iterative algorithm (<code>method = "ridge"</code>, default).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_row.w">row.w</code></td>
<td>
<p>row weights (default = NULL, a vector of 1 for uniform row weights).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>Used when <code>method = "ridge"</code> (default = 1).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for assessing convergence (default = 1e-04).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_seed">seed</code></td>
<td>
<p>Seed for random initialisation of the algorithm (default <code>seed = NULL</code>, unobserved values initially imputed by the column mean).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_nb.init">nb.init</code></td>
<td>
<p>Number of random initialisations (default = 1).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations for the algorithm (default = 1000).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="lrSVD_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements an efficient imputation algorithm particularly suitable for the case of continuous high-dimensional (wide) compositional data sets (more columns than rows), although it is equally applicable to regular data sets. It is based on a low-rank representation of the data set by a principal components (PC) model as derived by singular value decomposition (SVD) of the data matrix, extending recent work on principal component imputation and matrix completion methods to the case of censored compositional data (the code builds on the function <code>imputePCA</code>; see <code>missMDA</code> package for more details). A preliminary imputation by multiplicative replacement (see <code><a href="#topic+multRepl">multRepl</a></code>) is conducted to initiate the iterative algorithm in log-ratio coordinates. Two steps, estimation of latent PC model loadings and imputation of empty data matrix cells using the model, are iteratively repeated until convergence. Parameter fitting in this context is performed by a regularisation method (ridge regression in this case) or by the expectation-maximisation (EM) algorithm. Regularization has been shown generally preferable and it is set as default method (note the regularisation parameter <code>coeff.ridge</code> set to 1 by default. If it is &lt; 1 the result is closer to EM estimation, whereas for values &gt; 1 it is closer to mean estimation).
</p>
<p>An imputed data set is produced on the same scale as the input data set. If <code>X</code> is not closed to a constant sum, then the results are adjusted to provide a compositionally equivalent data set, expressed in the original scale, which leaves the absolute values of the observed components unaltered.
</p>
<p><em>Missing data imputation</em>
</p>
<p>When <code>imp.missing = TRUE</code>, unobserved values are treated as general missing data. For this case, the argument <code>label</code> indicates the unique label for missing values and the argument <code>dl</code> is ignored.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale.
</p>


<h3>References</h3>

<p>Palarea-Albaladejo, J, Antoni Martín-Fernández, J, Ruiz-Gazen, A, Thomas-Agnan, C. lrSVD: An efficient imputation algorithm for incomplete high-throughput compositional data. Journal of Chemometrics 2022; 36: e3459.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>, <code><a href="#topic+lrSVDplus">lrSVDplus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Data set closed to 100 (percentages, common dl = 1%)
 X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
               39.73,26.20,0.00,15.22,6.80,12.05,
               10.76,31.36,7.10,12.74,31.34,6.70,
               10.85,46.40,31.89,10.86,0.00,0.00,
               7.57,11.35,30.24,6.39,13.65,30.80,
               38.09,7.62,23.68,9.70,20.91,0.00,
               27.67,7.15,13.05,32.04,6.54,13.55,
               44.41,15.04,7.95,0.00,10.82,21.78,
               11.50,30.33,6.85,13.92,30.82,6.58,
               19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
 
 X_lrSVD&lt;- lrSVD(X,label=0,dl=rep(1,6))
 
 # Multiple limits of detection by component
 mdl &lt;- matrix(0,ncol=6,nrow=10)
 mdl[2,] &lt;- rep(1,6)
 mdl[4,] &lt;- rep(0.75,6)
 mdl[6,] &lt;- rep(0.5,6)
 mdl[8,] &lt;- rep(0.5,6)
 mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)
 
 X_lrSVD2 &lt;- lrSVD(X,label=0,dl=mdl)
 
 # Non-closed compositional data set
 data(LPdata) # data (ppm/micrograms per gram)
 dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
 LPdata2 &lt;- subset(LPdata,select=-c(Cu,Ni,La))  # select a subset for illustration purposes
 dl2 &lt;- dl[-c(5,7,10)]
 
 LPdata2_lrSVD &lt;- lrSVD(LPdata2,label=0,dl=dl2)
 
 # Treating zeros as general missing data for illustration purposes only
 LPdata2_miss &lt;- lrSVD(LPdata2,label=0,imp.missing=TRUE)
</code></pre>

<hr>
<h2 id='lrSVDplus'>
Log-ratio SVD algorithm (plus) 
</h2><span id='topic+lrSVDplus'></span>

<h3>Description</h3>

<p>This function implements an extended version of the log-ratio SVD algorithm (<code>lrSVD</code> function) to simultaneously deal with both zeros (i.e. data below detection limit, rounded zeros) and missing data in compositional data sets.
</p>
<p>Note: zeros and missing data must be labelled using 0 and <code>NA</code> respectively to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrSVDplus(X, dl = NULL, frac = 0.65,
             ncp = 2, beta = 0.5, method = c("ridge", "EM"), row.w = NULL,
             coeff.ridge = 1, threshold = 1e-04, seed = NULL, nb.init = 1,
             max.iter = 1000, z.warning = 0.8, z.delete = TRUE,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrSVDplus_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_dl">dl</code></td>
<td>
<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_frac">frac</code></td>
<td>
<p>Parameter for initial multiplicative simple replacement of left-censored data (see <code><a href="#topic+multRepl">multRepl</a></code>) (default = 0.65).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_ncp">ncp</code></td>
<td>
<p>Number of components in low-rank matrix approximation (default = 2).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_beta">beta</code></td>
<td>
<p>Weighting parameter, balance between the two conditions in objective function (default = 0.5).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_method">method</code></td>
<td>
<p>Parameter estimation method for the iterative algorithm (<code>method = "ridge"</code>, default).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_row.w">row.w</code></td>
<td>
<p>row weights (default = NULL, a vector of 1 for uniform row weights).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>Used when <code>method = "ridge"</code> (default = 1).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for assessing convergence (default = 1e-04).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_seed">seed</code></td>
<td>
<p>Seed for random initialisation of the algorithm (default <code>seed = NULL</code>, unobserved values initially imputed by the column mean).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_nb.init">nb.init</code></td>
<td>
<p>Number of random initialisations (default = 1).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations for the algorithm (default = 1000).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="lrSVDplus_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure starts with an initial imputation of zeros (using simple replacement with <code>frac*dl</code>) and missing values (using geometric mean imputation from observed data). Subsequently, the iterative algorithm is run until convergence (see <code>?lrSVD</code> for more details).
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale.
</p>


<h3>References</h3>

<p>Palarea-Albaladejo, J, Antoni Martín-Fernández, J, Ruiz-Gazen, A, Thomas-Agnan, C. lrSVD: An efficient imputation algorithm for incomplete high-throughput compositional data. Journal of Chemometrics 2022; 36: e3459.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set closed to 100 (percentages, common dl = 1%)
# (Note that zeros and missing in the same row or column are allowed)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,41.42,0.00,NA,6.80,12.05,
              NA,35.13,7.96,14.28,35.12,7.51,
              10.85,46.40,31.89,10.86,0.00,0.00,
              10.85,16.27,NA,9.16,19.57,44.15,
              38.09,7.62,23.68,9.70,20.91,0.00,
              NA,9.89,18.04,44.30,9.04,18.73,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
              
X_lrSVDplus &lt;- lrSVDplus(X,dl=rep(1,6))

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_lrSVDplus2 &lt;- lrSVDplus(X,dl=mdl)

# Non-closed compositional data set
data(LPdataZM) # (in ppm; 0 is nondetect and NA is missing data)

dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
LPdataZM2 &lt;- subset(LPdataZM,select=-c(Cu,Ni,La))  # select a subset for illustration purposes
dl2 &lt;- dl[-c(5,7,10)]

LPdataZM2_lrSVDplus &lt;- lrSVDplus(LPdataZM2,dl=dl2)
</code></pre>

<hr>
<h2 id='mdl'>
Water data set: matrix of limits of detection 
</h2><span id='topic+mdl'></span>

<h3>Description</h3>

<p>Matrix of varying limits of detection for the <code><a href="#topic+Water">Water</a></code> data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mdl)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> with 100 rows and 4 columns.
</p>


<h3>Details</h3>

<p>Three limits of detection (0.75, 1 and 1.25) were considered for Potassium, four for Arsenic (1.5, 3, 4 and 5), two for Sulphate (29 and 35) and no one for Calcium.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
data(mdl)
</code></pre>

<hr>
<h2 id='multKM'>
Multiplicative Kaplan-Meier smoothing spline (KMSS) replacement
</h2><span id='topic+multKM'></span>

<h3>Description</h3>

<p>This function implements non-parametric multiplicative KMSS imputation of left-censored values (e.g. values below detection limit, rounded zeros) in compositional data sets. It is based on simulation from a smoothing spline fitted to the Kaplan-Meier (KM) estimate of the empirical cumulative distribution function (ECDF) of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multKM(X, label = NULL, dl = NULL, n.draws = 1000, n.knots = NULL,
          z.warning = 0.8, z.delete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multKM_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="multKM_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved left-censored values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="multKM_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.
</p>
</td></tr>
<tr><td><code id="multKM_+3A_n.draws">n.draws</code></td>
<td>

<p>Number of random draws from the inverse KM ECDF generated to produce an averaged imputed value (<code>n.draws=1000</code>, default).
</p>
</td></tr>
<tr><td><code id="multKM_+3A_n.knots">n.knots</code></td>
<td>
<p>Integer or function giving the number of knots used for fitting a cubic smoothing spline to the KM ECDF (see <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for default value). It allows for a vector or list of settings per column of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="multKM_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="multKM_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imputes left-censored compositional values by averaging (geometric mean) n random draws (<code>n.draws</code> argument) from a cubic smoothing spline curve fitting the inverse KM ECDF below the corresponding limit of detection or censoring threshold. It then applies a multiplicative adjustment to preserve the multivariate compositional properties of the samples. It allows for either single (<code>vector</code> form) or multiple (<code>matrix</code> form, same size as <code>X</code>) limits of detection by component. Although note that it is equivalent to simple substitution by the limit of detection for singly censored components. Any threshold value can be set for non-censored elements (e.g. use 0 if no threshold for a particular column or element of the data matrix).
</p>
<p>It produces an imputed data set on the same scale as the input data set. If <code>X</code> is not closed to a constant sum, then the results are adjusted to provide a compositionally equivalent data set, expressed in the original scale, which leaves the absolute values of the observed components unaltered.
</p>
<p>The level of smoothing of the estimated spline can be controlled by the <code>n.knots</code> argument. The function <code><a href="#topic+splineKM">splineKM</a></code> can assist in choosing a finer value, although the default setting works generally well.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale.
</p>


<h3>References</h3>

<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package
for multivariate imputation of left-censored data under a compositional approach.
Chemometrics and Intelligent Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+splineKM">splineKM</a></code>, <code><a href="#topic+lrEM">lrEM</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
data(mdl) # matrix of limits of detection for Water

Water_multKM &lt;- multKM(Water,label=0,dl=mdl)

# Different smoothing degree by component
Water_multKM2 &lt;- multKM(Water,label=0,dl=mdl,n.knots=c(25,50,30,75))

# Easy to use for KM multiple imputation (m = 10)
Water.mi &lt;- vector("list",length=10)
for (m in 1:10){
  Water.mi[[m]] &lt;- multKM(Water,label=0,dl=mdl,n.draws=1)
}

</code></pre>

<hr>
<h2 id='multLN'>
Multiplicative lognormal replacement
</h2><span id='topic+multLN'></span>

<h3>Description</h3>

<p>This function implements model-based multiplicative lognormal imputation of left-censored values (e.g. values below detection limit, rounded zeros) in compositional data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multLN(X, label = NULL, dl = NULL, rob = FALSE, random = FALSE,
          z.warning = 0.8, z.delete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multLN_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="multLN_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved left-censored values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="multLN_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.
</p>
</td></tr>
<tr><td><code id="multLN_+3A_rob">rob</code></td>
<td>

<p>Logical value. <code>FALSE</code> provides maximum-likelihood estimates of model parameters (default), <code>TRUE</code> provides robust estimates (see <code>NADA</code> package for details).
</p>
</td></tr>
<tr><td><code id="multLN_+3A_random">random</code></td>
<td>

<p>Logical value. Values imputed using either estimated geometric mean (<code>FALSE</code>, default) or random values (<code>TRUE</code>) below the limit of detection.
</p>
</td></tr>
<tr><td><code id="multLN_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="multLN_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function imputes left-censored compositional values by the estimated geometric mean of the values below the corresponding limit of detection or censoring threshold and applies a multiplicative adjustment to preserve the multivariate compositional properties of the samples. Alternatively, imputation can be carried out by random values below the limit of detection (<code>random = TRUE</code>) based on a normal distribution on the positive real line (see below).
</p>
<p>It depends on package <code>NADA</code> to produce the required model parameter estimates (either maximum likelihood or robust regression on order statistics). It allows for either single (<code>vector</code> form) or multiple (<code>matrix</code> form, same size as <code>X</code>) limits of detection by component. Any threshold value can be set for non-censored elements (e.g. use 0 if no threshold for a particular column or element of the data matrix).
</p>
<p>It produces an imputed data set on the same scale as the input data set. If <code>X</code> is not closed to a constant sum, then the results are adjusted to provide a compositionally equivalent data set, expressed in the original scale, which leaves the absolute values of the observed components unaltered. Note that a normal distribution on the positive real line is considered. That is, it is defined with respect to a measure according to own geometry of the positive real line, instead of the standard lognormal based on the Lebesgue measure in real space.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale.
</p>


<h3>References</h3>

<p>Mateu-Figueras G, Pawlowsky-Glahn V, Egozcue JJ. The normal distribution in some constrained sample spaces. SORT 2013; 37: 29-56.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. Values below detection limit in compositional chemical data. Analytica Chimica Acta 2013; 764: 32-43.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+lrEM">lrEM</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set closed to 100 (percentages, common dl = 1%)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,26.20,0.00,15.22,6.80,12.05,
              10.76,31.36,7.10,12.74,31.34,6.70,
              10.85,46.40,31.89,10.86,0.00,0.00,
              7.57,11.35,30.24,6.39,13.65,30.80,
              38.09,7.62,23.68,9.70,20.91,0.00,
              27.67,7.15,13.05,32.04,6.54,13.55,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
              
X_multLN &lt;- multLN(X,label=0,dl=rep(1,6))

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_multLN2 &lt;- multLN(X,label=0,dl=mdl)

# Non-closed compositional data set
data(LPdata) # data (ppm/micrograms per gram)
dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)

# Using ML for parameter estimation
LPdata_multLN &lt;- multLN(LPdata,label=0,dl=dl) 
# For comparison
LPdata[30:35,1:10]
round(LPdata_multLN[30:35,1:10],1)

# Using ROS for parameter estimation
LPdata_multLNrob &lt;- multLN(LPdata,label=0,dl=dl,rob=TRUE)
round(LPdata_multLNrob[30:35,1:10],1)

# Using random values &lt; dl
LPdata_multRLN &lt;- multLN(LPdata,label=0,dl=dl,random=TRUE)
round(LPdata_multRLN[30:35,1:10],1)

# Two subsets of limits of detection (using e.g. ML parameter estimation)
data(LPdata)
dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
 # DLs for first 50 samples of LPdata
dl1 &lt;- matrix(rep(1,50),ncol=1)%*%dl
 # DLs for last 46 samples of LPdata
dl2 &lt;- matrix(rep(1,46),ncol=1)%*%c(1,0.5,0,0,2.5,0,5.5,0.75,0.3,1.5,1,0,0,600,8) 

mdl &lt;- rbind(dl1,dl2)
LPdata_multLN2 &lt;- multLN(LPdata,label=0,dl=mdl)

</code></pre>

<hr>
<h2 id='multRepl'>Multiplicative simple replacement
</h2><span id='topic+multRepl'></span>

<h3>Description</h3>

<p>This function implements non-parametric multiplicative simple imputation of left-censored (e.g. values below detection limit, rounded zeros) and missing data in compositional data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multRepl(X, label = NULL, dl = NULL, frac = 0.65, imp.missing = FALSE, closure = NULL,
            z.warning=0.8, z.delete = TRUE, delta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multRepl_+3A_x">X</code></td>
<td>

<p>Compositional vector (<code>numeric</code> class) or data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="multRepl_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="multRepl_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.
</p>
</td></tr>
<tr><td><code id="multRepl_+3A_frac">frac</code></td>
<td>

<p>Fraction of the detection limit/threshold used for imputation (default = 0.65, expressed as a proportion).
</p>
</td></tr>
<tr><td><code id="multRepl_+3A_imp.missing">imp.missing</code></td>
<td>
<p>If <code>TRUE</code> then unobserved values identified by <code>label</code> are treated as missing data (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="multRepl_+3A_closure">closure</code></td>
<td>
<p>Closure value used to add a residual part for imputation (see below).</p>
</td></tr>
<tr><td><code id="multRepl_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="multRepl_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="multRepl_+3A_delta">delta</code></td>
<td>
<p>This argument has been deprecated and replaced by <code>frac</code> (see package's NEWS for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imputes left-censored compositional values by a given fraction <code>frac</code> of the corresponding limit of detection and applies a multiplicative adjustment to preserve the multivariate compositional properties of the samples. It allows for either single (<code>vector</code> form) or multiple (<code>matrix</code> form, same size as <code>X</code>) limits of detection by component. Any threshold value can be set for non-censored elements (e.g. use 0 if no threshold for a particular column or element of the data matrix).
</p>
<p><em>Missing data imputation</em>: missing data can be imputed by setting <code>imp.missing = TRUE</code>. They are replaced by the estimated column geometric mean from observed values. The non-missing parts in the composition are applied multiplicative adjustment. The argument <code>dl</code> and <code>frac</code> are ignored and <code>X</code> is require to be a data matrix in this case.
</p>
<p>Note: negative values can be generated when unobserved components are a large portion of the composition, which is more likely for missing data (e.g in major chemical elements) and non-closed compositions. A workaround is to add a residual filling the gap up to the closure/total when possible. This is done internally when a value for <code>closure</code> is specified (e.g. <code>closure=10^6</code> if ppm or <code>closure=100</code> if percentages). The residual is discarded after imputation.
</p>
<p>This function produces an imputed data set on the same scale as the input data set. If <code>X</code> is not closed to a constant sum, then the results are adjusted to provide a compositionally equivalent data set, expressed in the original scale, which leaves the absolute values of the observed components unaltered. Note that this adjustment only applies to data sets and not when a single composition is entered. In this latter case, the composition is treated as a closed vector.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional vector or data set expressed in the original scale.
</p>


<h3>References</h3>

<p>Martin-Fernandez JA, Barcelo-Vidal C, Pawlowsky-Glahn V. Dealing with zeros and missing values in compositional data sets using nonparametric imputation. Mathematical Geology 2003; 35: 253-78.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. Values below detection limit in compositional chemical data. Analytica Chimica Acta 2013; 764: 32-43.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+lrEM">lrEM</a></code>, <code><a href="#topic+lrSVD">lrSVD</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A compositional vector (NA indicates nondetect)
y &lt;- c(0.6,NA,0.25,0.03,0.12,NA)
dl &lt;- c(0,0.01,0,0,0,0.005)
# Using the default frac = 0.65
yr &lt;- multRepl(y,label=NA,dl=dl)
round(yr,4)

# Data set closed to 100 (percentages, common dl = 1%)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,26.20,0.00,15.22,6.80,12.05,
              10.76,31.36,7.10,12.74,31.34,6.70,
              10.85,46.40,31.89,10.86,0.00,0.00,
              7.57,11.35,30.24,6.39,13.65,30.80,
              38.09,7.62,23.68,9.70,20.91,0.00,
              27.67,7.15,13.05,32.04,6.54,13.55,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
              
X_multRepl &lt;- multRepl(X,label=0,dl=rep(1,6))

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_multRepl2 &lt;- multRepl(X,label=0,dl=mdl)

# Non-closed compositional data set
data(LPdata) # data (ppm/micrograms per gram)
dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
LPdata_multRepl &lt;- multRepl(LPdata,label=0,dl=dl)

# Two subsets of limits of detection
data(LPdata)
dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
 # DLs for first 50 samples of LPdata
dl1 &lt;- matrix(rep(1,50),ncol=1)%*%dl
 # DLs for last 46 samples of LPdata
dl2 &lt;- matrix(rep(1,46),ncol=1)%*%c(1,0.5,0,0,2.5,0,5.5,0.75,0.3,1.5,1,0,0,600,8) 

mdl &lt;- rbind(dl1,dl2)
LPdata_multRepl2 &lt;- multRepl(LPdata,label=0,dl=mdl)

# Data set with missing values closed to 100 (percentages)
X &lt;- matrix(c(10.47,8.58,59.72,19.30,1.93,
              12.13,7.44,62.87,16.37,1.19,
                 NA,7.30,75.91,16.79,NA,
               9.77,7.80,65.68,14.78,1.97,
              10.79,9.55,65.87,12.41,1.38,
              14.54,8.18,64.55,12.73,NA,
              12.28,7.58,66.01,12.93,1.20,
              28.09,22.92,NA,40.11,8.88,
               7.02,6.30,75.65,11.03,NA),byrow=TRUE,ncol=5)
              
X_multReplMiss &lt;- multRepl(X,label=NA,imp.missing=TRUE)

# Non-closed compositional data set
data(LPdata) # (in ppm units)
# Treating zeros as missing data for illustration purposes only
LPdata_multReplMiss &lt;- multRepl(LPdata,label=0,imp.missing=TRUE)
# Negative values generated (see e.g. K and Rb in sample #60)

# Workaround: use residual part to fill up the gap to 10^6 for imputation
LPdata_multReplMiss2 &lt;- multRepl(LPdata,label=0,imp.missing=TRUE,closure=10^6)



</code></pre>

<hr>
<h2 id='multReplus'>
Multiplicative simple replacement (plus) 
</h2><span id='topic+multReplus'></span>

<h3>Description</h3>

<p>This function implements an extended version of multiplicative simple imputation (<code>multRepl</code> function) to simultaneously deal with both zeros (i.e. data below detection limit, rounded zeros) and missing data in compositional data sets.
</p>
<p>Note: zeros and missing data must be labelled using 0 and <code>NA</code> respectively to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multReplus(X, dl = NULL, frac = 0.65, closure = NULL,
              z.warning = 0.8, z.delete = TRUE, delta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multReplus_+3A_x">X</code></td>
<td>

<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).
</p>
</td></tr>
<tr><td><code id="multReplus_+3A_dl">dl</code></td>
<td>

<p>Numeric vector or matrix of detection limits/thresholds. These must be given on the same scale as <code>X</code>. If <code>NULL</code> the column minima are used as thresholds.
</p>
</td></tr>
<tr><td><code id="multReplus_+3A_frac">frac</code></td>
<td>

<p>Fraction of the detection limit/threshold used for imputation (default = 0.65, expressed as a proportion).
</p>
</td></tr>
<tr><td><code id="multReplus_+3A_closure">closure</code></td>
<td>
<p>Closure value used to add a residual part for imputation (see below).</p>
</td></tr>
<tr><td><code id="multReplus_+3A_z.warning">z.warning</code></td>
<td>
<p>Threshold used to identify individual rows or columns including an excess of zeros/unobserved values (to be specify in proportions, default <code>z.warning=0.8</code>).</p>
</td></tr>
<tr><td><code id="multReplus_+3A_z.delete">z.delete</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, rows/columns identified by <code>z.warning</code> are omitted in the imputed data set. Otherwise, the function stops in error when rows/columns are identified by <code>z.warning</code> (default <code>z.delete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="multReplus_+3A_delta">delta</code></td>
<td>
<p>This argument has been deprecated and replaced by <code>frac</code> (see package's NEWS for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure firstly replaces missing data using the estimated geometric mean based on the observed values and then zeros using <code>frac*dl</code>. The observed components are applied a multiplicative adjustment to preserve the multivariate compositional properties of the samples.
</p>
<p>Note: negative values can be generated when unobserved components are a large portion of the composition, which is more likely for missing data (e.g in major chemical elements) and non-closed compositions. A workaround is to add a residual filling the gap up to the closure/total when possible. This is done internally when a value for <code>closure</code> is specified (e.g. <code>closure=10^6</code> if ppm or <code>closure=100</code> if percentages). The residual is discarded after imputation.
</p>
<p>See <code>?multRepl</code> for more details.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the imputed compositional data set expressed in the original scale.
</p>


<h3>References</h3>

<p>Martin-Fernandez JA, Barcelo-Vidal C, Pawlowsky-Glahn V. Dealing with zeros and missing values in compositional data sets using nonparametric imputation. Mathematical Geology 2003; 35: 253-78.
</p>
<p>Palarea-Albaladejo J, Martin-Fernandez JA. Values below detection limit in compositional chemical data. Analytica Chimica Acta 2013; 764: 32-43.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+lrEMplus">lrEMplus</a></code>, <code><a href="#topic+lrSVDplus">lrSVDplus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set closed to 100 (percentages, common dl = 1%)
# (Note that zeros and missing in the same row are allowed)
X &lt;- matrix(c(26.91,8.08,12.59,31.58,6.45,14.39,
              39.73,41.42,0.00,NA,6.80,12.05,
              NA,35.13,7.96,14.28,35.12,7.51,
              10.85,46.40,31.89,10.86,0.00,0.00,
              10.85,16.27,NA,9.16,19.57,44.15,
              38.09,7.62,23.68,9.70,20.91,0.00,
              NA,9.89,18.04,44.30,9.04,18.73,
              44.41,15.04,7.95,0.00,10.82,21.78,
              11.50,30.33,6.85,13.92,30.82,6.58,
              19.04,42.59,0.00,38.37,0.00,0.00),byrow=TRUE,ncol=6)
              
X_multReplus &lt;- multReplus(X,dl=rep(1,6))

# Multiple limits of detection by component
mdl &lt;- matrix(0,ncol=6,nrow=10)
mdl[2,] &lt;- rep(1,6)
mdl[4,] &lt;- rep(0.75,6)
mdl[6,] &lt;- rep(0.5,6)
mdl[8,] &lt;- rep(0.5,6)
mdl[10,] &lt;- c(0,0,1,0,0.8,0.7)

X_multReplus2 &lt;- multReplus(X,dl=mdl)

# Non-closed compositional data set
data(LPdataZM) # (in ppm; 0 is nondetect and NA is missing data)

dl &lt;- c(2,1,0,0,2,0,6,1,0.6,1,1,0,0,632,10) # limits of detection (0 for no limit)
LPdataZM2 &lt;- subset(LPdataZM,select=-c(Cu,Ni,La))  # select a subset for illustration purposes
dl2 &lt;- dl[-c(5,7,10)]

## Not run: 
LPdataZM2_multReplus &lt;- multReplus(LPdataZM2,dl=dl2)
# Negative values generated (see e.g. K in sample #64)

## End(Not run)

# Workaround: use residual part to fill up the gap to 10^6 for imputation
LPdataZM2_multReplus &lt;- multReplus(LPdataZM2,dl=dl2,closure=10^6)

</code></pre>

<hr>
<h2 id='Pigs'>
Pigs data set
</h2><span id='topic+Pigs'></span>

<h3>Description</h3>

<p>Count data set consisting of scan sample behavioural observations of a group of 29 sows during a day from 7:30am to 3:30pm, and recorded every 5 minutes (97 times). Six locations were considered: straw bed (BED), half in the straw bed (HALF.BED), dunging passage (PASSAGE), half in the dunging passage (HALF.PASS), feeder (FEEDER) and half in the feeder (HALF.FEED).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pigs)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 29 observations on the following 6 variables.
</p>

<dl>
<dt><code>BED</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HALF.BED</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>PASSAGE</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HALF.PASS</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FEEDER</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HALF.FEED</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data set kindly provided by the Animal Behaviour and Welfare group at Scotland's Rural College (SRUC), Scotland, UK.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pigs)
</code></pre>

<hr>
<h2 id='splineKM'>
Display Kaplan-Meier empirical cumulative distribution function and smoothing spline curve fit
</h2><span id='topic+splineKM'></span>

<h3>Description</h3>

<p>This function shows the empirical cumulative distribution function (ECDF) for left-censored data as estimated by the Kaplan-Meier (KM) method and a cubic smoothing spline fitted to it (KMSS method, see <code><a href="#topic+multKM">multKM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineKM(x, label = NULL, dl = NULL, n.knots = NULL,
            legend.pos = "bottomright",
            ylab = "ECDF", xlab = "Value",
            col.km = "black", lty.km = 1, lwd.km = 1,
            col.sm = "red", lty.sm = 2, lwd.sm = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineKM_+3A_x">x</code></td>
<td>

<p>Numerical data vector (<code><a href="base.html#topic+vector">vector</a></code> class).
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_label">label</code></td>
<td>

<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote left-censored values in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_dl">dl</code></td>
<td>

<p>Numeric vector of detection limits/thresholds for each element of <code>x</code> (same length as <code>x</code>). These must be given on the same scale as <code>x</code> (use e.g. 0 for detected data). 
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_n.knots">n.knots</code></td>
<td>
<p>Integer or function giving the number of knots used for fitting a cubic smoothing spline to the KM ECDF (see <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for default value).
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_legend.pos">legend.pos</code></td>
<td>

<p>Location of the graph legend. Choose one amongst <code>"bottomleft"</code>, <code>"bottomright"</code> (default), <code>"topleft"</code> or <code>"topright"</code>.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_ylab">ylab</code></td>
<td>

<p>Title for y-axis.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_xlab">xlab</code></td>
<td>

<p>Title for x-axis.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_col.km">col.km</code></td>
<td>

<p>Plotting color for KM ECDF (see base graphical parameters <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_lty.km">lty.km</code></td>
<td>

<p>Line type for KM ECDF (see base graphical parameters <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_lwd.km">lwd.km</code></td>
<td>

<p>Line width for KM ECDF (see base graphical parameters <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_col.sm">col.sm</code></td>
<td>

<p>Plotting color for smoothing spline curve.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_lty.sm">lty.sm</code></td>
<td>

<p>Line style for smoothing spline curve.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_lwd.sm">lwd.sm</code></td>
<td>

<p>Line width for smoothing spline curve.
</p>
</td></tr>
<tr><td><code id="splineKM_+3A_...">...</code></td>
<td>

<p>Other graphical parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
data(mdl)

# Examine default spline smoothed KM ECDF fit for Potassium and Sulphate
splineKM(Water[,1],label=0,mdl[,1])
splineKM(Water[,4],label=0,mdl[,4],xlim=c(28,41))

# Reduce to 5 knots for Potassium
splineKM(Water[,1],label=0,mdl[,1],n.knots=5)
</code></pre>

<hr>
<h2 id='Water'>
Water data set
</h2><span id='topic+Water'></span>

<h3>Description</h3>

<p>100 simulated samples of a 4-part groundwater composition in percentage subject to multiple limits of detection by component. The associated matrix of limits of detection is stored in <code>mdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Water)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 100 observations on the following 4 variables.
</p>

<dl>
<dt><code>Potassium</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Arsenic</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Calcium</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Sulphate</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Three limits of detection (0.75, 1 and 1.25) were considered for Potassium, four for Arsenic (1.5, 3, 4 and 5), two for Sulphate (29 and 35) and no one for Calcium. In the case of Sulphate, the detection limit equal to 29 is the minimum value registered for that component. All nondetects coded as 0.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
zPatterns(Water,label=0)
</code></pre>

<hr>
<h2 id='zCompositions'>
Treatment of Zeros, Left-Censored and Missing Values in Compositional Data Sets
</h2><span id='topic+zCompositions-package'></span>

<h3>Description</h3>

<p>Following compositional data analysis principles, this package provides simple and friendly tools to explore and impute zeros, left-censored (such as rounded zeros or values below single or multiple limits of detection; a.k.a nondetects) and missing data; including zero pattern/group-wise data analysis and testing procedures.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> zCompositions</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.0-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-13</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Javier Palarea-Albaladejo and Josep Antoni Martin-Fernandez
</p>
<p>Maintainer: Javier Palarea-Albaladejo &lt;javier.palarea@udg.edu&gt;
</p>


<h3>References</h3>

<p>Martin-Fernandez, J.A., Barcelo-Vidal, C., Pawlowsky-Glahn, V., 2003. Dealing with zeros and missing values in compositional data sets using nonparametric imputation. Mathematical Geology 35 (3): 253-27.
</p>
<p>Martin-Fernandez, J.A., Hron, K., Templ, M., Filzmoser, P., Palarea-Albaladejo, J., 2012. Model-based replacement of rounded zeros in compositional data: Classical and robust approaches. Computational Statistics and Data Analysis 56: 2688-2704.
</p>
<p>Martin-Fernandez, J.A., Hron, K., Templ, M., Filzmoser, P., Palarea-Albaladejo, J., 2015. Bayesian-multiplicative treatment of count zeros in compositional data sets. Statistical Modelling 15 (2): 134-158.
</p>
<p>Palarea-Albaladejo, J., Martin-Fernandez, J.A., Gomez-Garcia, J., 2007. A parametric approach for dealing with compositional rounded zeros. Mathematical Geology 39 (7): 625-645.
</p>
<p>Palarea-Albaladejo, J., Martin-Fernandez, J.A., 2008. A modified EM alr-algorithm for replacing rounded zeros in compositional data sets. Computers &amp; Geosciences 34 (8): 902-917.
</p>
<p>Palarea-Albaladejo, J., Martin-Fernandez, J.A., 2013. Values below detection limit in compositional chemical data. Analytica Chimica Acta 764: 32-43.
</p>
<p>Palarea-Albaladejo, J., Martin-Fernandez J.A., Olea, R.A., 2014. A bootstrap estimation scheme for chemical compositional data with nondetects. Journal of Chemometrics 28: 585-599.
</p>
<p>Palarea-Albaladejo J. and Martin-Fernandez J.A., 2015. zCompositions &ndash; R package
for multivariate imputation of left-censored data under a compositional approach.
Chemometrics and Intelligent Laboratory Systems 143: 85-96.
</p>
<p>Palarea-Albaladejo, J, Antoni Martín-Fernández, J, Ruiz-Gazen, A, Thomas-Agnan, C., 2022. lrSVD: An efficient imputation algorithm for incomplete high-throughput compositional data. Journal of Chemometrics 36: e3459.
</p>


<h3>See Also</h3>

<p>Aitchison, J., 1986. The Statistical Analysis of Compositional Data. Monographs on Statistics and Applied Probability. Chapman and Hall Ltd., London, UK (re-edited in 2003 with additional material).
</p>
<p>Filzmoser, P.,  Hron, K.,  Templ, M., 2018. Applied Compositional Data Analysis. With Worked Examples in R. Springer, Switzerland.
</p>
<p>Filzmoser P., Hron K., Martín-Fernández J.A., Palarea-Albaladejo J. (eds.), 2021. Advances in Compositional Data Analysis. Springer, Cham.
</p>
<p>Pawlowsky-Glahn, V., Buccianti, A. (Eds.), 2011. Compositional Data Analysis: Theory and Applications. John Wiley &amp; Sons, Ltd., Chichester,UK.
</p>
<p>Pawlowsky-Glahn, V., Egozcue, J.J., Tolosana-Delgado, R., 2015. Modeling and analysis of compositional data. John Wiley &amp; Sons, Ltd., Chichester, UK.
</p>
<p>van den Boogaart, K.G., Tolosana-Delgado, R., 2013, Analyzing Compositional Data with R. Springer-Verlag, Berlin, Germany.
</p>

<hr>
<h2 id='zPatterns'>
Find and display patterns of zeros/missing values in a data set
</h2><span id='topic+zPatterns'></span>

<h3>Description</h3>

<p>This function summarises the patterns of zero and/or missing values in a data set and returns a vector of pattern numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zPatterns(X, label = NULL, plot = TRUE,
             axis.labels = c("Component", "Pattern ID"),
             bar.ordered = as.character(c(FALSE,FALSE)),
             bar.colors = c("red3", "red3"), bar.labels = FALSE,
             show.means = FALSE, round.means = 2, cex.means = 1,
             type.means = c("cgm","am"),
             cell.colors = c("dodgerblue", "white"),
             cell.labels = c(label, paste("No", label)), cex.axis = 1.1,
             grid.color = "black", grid.lty = "dotted",
             legend = TRUE, suppress.print = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zPatterns_+3A_x">X</code></td>
<td>

<p>Data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to identify zeros/unobserved values in <code>X</code>.</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_plot">plot</code></td>
<td>
<p>Logical value indicating whether a graphical summary of the patterns is produced or not (default <code>plot=TRUE</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_axis.labels">axis.labels</code></td>
<td>
<p>Vector of axis labels for the table of patterns (format <code>c("x-axis","y-axis")</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_bar.ordered">bar.ordered</code></td>
<td>
<p>Vector of logical values to order table of patterns according to frequencies by patterns, component or both; with the first element referring to the patterns and the second to the components (default <code>c(FALSE,FALSE)</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_bar.colors">bar.colors</code></td>
<td>
<p>Colors for the margin barplots (format <code>c("col.top","col.right")</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_bar.labels">bar.labels</code></td>
<td>
<p>Logical value indicating if labels showing percentages must be added to the margin barplots (default <code>bar.labels=FALSE</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_show.means">show.means</code></td>
<td>
<p>Logical value indicating if mean values by pattern are shown on the graphical summary table (default <code>show.means=FALSE</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_round.means">round.means</code></td>
<td>
<p>When <code>show.means=TRUE</code>, number of decimal places for the mean values shown (2=default).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_cex.means">cex.means</code></td>
<td>
<p>When <code>show.means=TRUE</code>, numeric character expansion factor; character size for the mean values shown (1=default).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_type.means">type.means</code></td>
<td>
<p>When <code>show.means=TRUE</code>, statistic used for computing the means. Either compositional geometric mean (<code>type.means=cgm</code>, in percentage units, default) or standard arithmetic mean (<code>type.means=am</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_cell.colors">cell.colors</code></td>
<td>
<p>Vector of colors for the table cells (format <code>c("col.unobserved","col.observed")</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_cell.labels">cell.labels</code></td>
<td>
<p>Labels for the cells (format <code>c("Unobserved","Observed")</code>, default <code>c(label,paste("No",label))</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Axis labels scaling factor relative to default.</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_grid.color">grid.color</code></td>
<td>
<p>Color of the grid lines (default <code>"black"</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_grid.lty">grid.lty</code></td>
<td>
<p>Style of the grid lines (default <code>"dotted"</code>, see <code>lty</code> in <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_legend">legend</code></td>
<td>
<p>Logical value indicating if a legend must be included (default <code>legend=TRUE</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_suppress.print">suppress.print</code></td>
<td>
<p>Suppress printed feedback (default <code>suppress.print=FALSE</code>).</p>
</td></tr>
<tr><td><code id="zPatterns_+3A_...">...</code></td>
<td>
<p>Other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector (factor type) of pattern IDs corresponding to each row of <code>X</code>.
</p>
<p>By default, a summary table is printed showing patterns in the data according to <code>label</code> and some summary statistics: number of zero/missing components by pattern (No.Unobs), pattern frequency in percentage, percentage zero/missing values by component (column) and overall percentage of zero/missing values in the data set. The symbols + and - indicate, respectively, zero/missing and observed components within each pattern. A graphical version of the summary table is returned including barplots on the margins displaying percentage zero/missing and compositional geometric means by pattern (if <code>show.means=TRUE</code>; expressed in percentage scale). Common arithmetic means can be also shown for the case of ordinary data (<code>type.means="am"</code>), however this is not recommended for compositional data.
</p>
<p>The patterns are assigned ID number and by default arranged in the table in the same order as they are found in the data set. The argument <code>bar.ordered</code> can be used to re-arrange the display according to frequencies of patterns, of unobserved values by component or both.
</p>
<p>A warning message is shown if zeros or NA values not identified by <code>label</code> are present in the data set. These will be ignored for the graphical display and numerical summaries of patterns, which will be only based on <code>label</code>.
</p>
<p>Check out 'plus' functions to deal with zeros and missing data simultaneously.
</p>


<h3>References</h3>

<p>Palarea-Albaladejo J. and Martin-Fernandez JA. zCompositions &ndash; R package for multivariate imputation of
left-censored data under a compositional approach. Chemometrics and Intelligence Laboratory Systems 2015; 143: 85-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lrEM">lrEM</a></code>, <code><a href="#topic+lrEMplus">lrEMplus</a></code>, <code><a href="#topic+lrDA">lrDA</a></code>, <code><a href="#topic+multRepl">multRepl</a></code>, <code><a href="#topic+multReplus">multReplus</a></code>, <code><a href="#topic+multLN">multLN</a></code>, <code><a href="#topic+multKM">multKM</a></code>, <code><a href="#topic+cmultRepl">cmultRepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LPdata)

pattern.ID &lt;- zPatterns(LPdata,label=0)

LPdata[pattern.ID==5,]
LPdata[pattern.ID==7,]
LPdata[pattern.ID==10,]

# Modify cell labels and show percentages along with barplots
pattern.ID &lt;- zPatterns(LPdata,label=0,
              cell.labels=c("Zero","Non-zero"),bar.labels=TRUE)

# Show compositional geometric means (in %) per zero pattern
zPatterns(LPdata,label=0,show.means=TRUE)

# Same but orderer by pattern frequency and incidence of zeros by component
zPatterns(LPdata,label=0,bar.ordered=c(TRUE,TRUE),,bar.labels=TRUE,show.means=TRUE)

# Data set with zeros and missing data (0 = zero; NA = missing) (see lrEMplus function).
data(LPdataZM)

# Show missingness patterns only
zPatterns(LPdataZM,label=NA)

# Show zero patterns only and means by pattern based on available data
# (blanks indicate not enough data available for computation)
zPatterns(LPdataZM,label=0,show.means=TRUE)
</code></pre>

<hr>
<h2 id='zVarArray'>Variation array for grouped data</h2><span id='topic+zVarArray'></span>

<h3>Description</h3>

<p>This function returns overall and separate variation arrays for groups
in a compositional data set. Groups can be defined by either zero/unobserved data patterns or
by a grouping factor in fully observed zero-free data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zVarArray(X, label = 0, groups = NULL, suppress.print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zVarArray_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="zVarArray_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved data in <code>X</code> (<code>label = 0</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArray_+3A_groups">groups</code></td>
<td>
<p>Grouping factor in fully observed zero-free data sets (<code>groups = NULL</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArray_+3A_suppress.print">suppress.print</code></td>
<td>
<p>Suppress printed feedback (<code>suppress.print = FALSE</code>, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly aimed to investigate heterogeneous relative variation
structures in compositional data sets containing zeros or unobserved values. For each pattern of zero or unobserved values,
log-ratio variances (upper triangle of variation matrix) and means (lower triangle of variation matrix) are computed from the
available data. Note that (1) NAs are produced for log-ratio variances and means in groups containing less than two observations,
and (2) at least two components must be available in each group to compute log-ratios.
</p>
<p>The overall estimate is obtained across groups by pairwise deletion. Note that, unlike the ordinary <code><a href="stats.html#topic+var">var</a></code>
function, maximum likelihood estimates of the variances are computed. That is,
the observed sum of squares is divided by the corresponding number of observations n and not by n-1.
</p>
<p>Group-wise variation arrays can be obtained from fully observed zero-free data by setting a grouping factor
using the argument <code>groups</code>.
</p>


<h3>Value</h3>

<p>List of variation arrays by pattern/group and overall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
zPatterns(Water, label = 0)
zVarArray(Water)

# From a completed data set

data(mdl) # matrix of limits of detection for Water
Water_multKM &lt;- multKM(Water,label=0,dl=mdl) # nondetects imputation

# Results split by two ficticious groups A and B
zVarArray(Water_multKM,groups=rep(c("A","B"),each=50))
</code></pre>

<hr>
<h2 id='zVarArrayError'>Variation array relative error</h2><span id='topic+zVarArrayError'></span>

<h3>Description</h3>

<p>This function computes squared relative errors of variation arrays per group with respect to the overall variation array
based on observed data in a compositional data set. Groups can be defined by either zero/unobserved data patterns or
by a grouping factor in fully observed zero-free data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zVarArrayError(
  X,
  label = 0,
  groups = NULL,
  breakdown = FALSE,
  suppress.print = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zVarArrayError_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="zVarArrayError_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved data in <code>X</code> (<code>label = 0</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArrayError_+3A_groups">groups</code></td>
<td>
<p>Grouping factor in fully observed zero-free data sets (<code>groups = NULL</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArrayError_+3A_breakdown">breakdown</code></td>
<td>
<p>Logical value. Show results broken down by group (<code>breakdown = FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArrayError_+3A_suppress.print">suppress.print</code></td>
<td>
<p>Suppress printed feedback (<code>suppress.print = FALSE</code>, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Squared relative errors (SRE) are calculated by confronting variation arrays (log-ratio variances and means) obtained per group and
the overall variation array based on observed data. Raw SREs are computed for each available pair-wise log-ratio. The weighted version uses
the corresponding group sizes to weight raw SREs. Total SRE is obtained as the sum of weighted SREs for each log-ratio. Further details by group are
provided by setting <code>breakdown = TRUE</code>.
</p>


<h3>Value</h3>

<p>1. SRE for each log-ratio variance and mean.
2. Weighted SRE for each log-ratio variance and mean.
3. Total SRE across log-ratio variances and means.
4. Percentage contribution of each log-ratio to SRE in log-ratio variances and means.
If <code>breakdown = TRUE</code>:
4. SREs per group.
5. Weighted SREs per group.
6. Percentage contribution of each group to total SRE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+zVarArray">zVarArray</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
zPatterns(Water, label = 0)
zVarArrayError(Water)
zVarArrayError(Water, breakdown = TRUE)

# From a completed data set

data(mdl) # matrix of limits of detection for Water
Water_multKM &lt;- multKM(Water,label=0,dl=mdl) # nondetects imputation

# Results split by two ficticious groups A and B
zVarArrayError(Water_multKM,groups=rep(c("A","B"),each=50))
</code></pre>

<hr>
<h2 id='zVarArrayTest'>Variation array homogeneity test</h2><span id='topic+zVarArrayTest'></span>

<h3>Description</h3>

<p>This function performs a permutation test of the homogeneity of group-wise and overall variation arrays from all
pair-wise log-ratios in a compositional data set. Groups can be defined by either zero/unobserved data patterns or by a grouping
factor in fully observed zero-free data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zVarArrayTest(X, label = 0, groups = NULL, b = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zVarArrayTest_+3A_x">X</code></td>
<td>
<p>Compositional data set (<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> class).</p>
</td></tr>
<tr><td><code id="zVarArrayTest_+3A_label">label</code></td>
<td>
<p>Unique label (<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>) used to denote zeros/unobserved data in <code>X</code> (<code>label = 0</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArrayTest_+3A_groups">groups</code></td>
<td>
<p>Grouping factor in fully observed zero-free data sets (<code>groups = NULL</code>, default).</p>
</td></tr>
<tr><td><code id="zVarArrayTest_+3A_b">b</code></td>
<td>
<p>Number of bootstrap resamples used (<code>b = 1000</code>, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permutation test of homogeneity is based on total weighted squared relative errors (SRE) reflecting on divergence
between group-wise variation arrays and overall (see <code><a href="#topic+zVarArrayError">zVarArrayError</a></code> and
<code><a href="#topic+zVarArray">zVarArray</a></code> for more details). Note that for groups including less than two observations SRE is set to NA.
</p>


<h3>Value</h3>

<p>Test p-values for log-ratio variances and means.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zPatterns">zPatterns</a></code>, <code><a href="#topic+zVarArray">zVarArray</a></code>, <code><a href="#topic+zVarArrayError">zVarArrayError</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Water)
zPatterns(Water, label = 0)
zVarArrayTest(Water)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
