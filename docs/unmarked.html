<!DOCTYPE html><html><head><title>Help for package unmarked</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unmarked}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unmarked-package'><p>Models for Data from Unmarked Animals</p></a></li>
<li><a href='#+5B-methods'><p>Methods for bracket extraction [ in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#backTransform-methods'><p>Methods for Function backTransform in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#birds'><p> BBS Point Count and Occurrence Data from 2 Bird Species</p></a></li>
<li><a href='#coef-methods'><p>Methods for Function coef in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#colext'><p>Fit the dynamic occupancy model of MacKenzie et. al (2003)</p></a></li>
<li><a href='#computeMPLElambda'><p>Compute the penalty weight for the MPLE penalized likelihood method</p></a></li>
<li><a href='#confint-methods'><p>Methods for Function confint in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#crossbill'>
<p>Detection/non-detection data on the European crossbill (<em>Loxia</p>
curvirostra</em>)</a></li>
<li><a href='#crossVal'><p>Cross-validation methods for fitted unmarked models and fit lists</p></a></li>
<li><a href='#cruz'>
<p>Landscape data for Santa Cruz Island</p></a></li>
<li><a href='#csvToUMF'><p>Convert .CSV File to an unmarkedFrame</p></a></li>
<li><a href='#detFuns'><p>Distance-sampling detection functions and associated density functions</p></a></li>
<li><a href='#distsamp'><p>Fit the hierarchical distance sampling model of Royle et al. (2004)</p></a></li>
<li><a href='#distsampOpen'>
<p>Open population model for distance sampling data</p></a></li>
<li><a href='#fitList'><p>constructor of unmarkedFitList objects</p></a></li>
<li><a href='#fitted-methods'><p>Methods for Function fitted in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#formatDistData'><p>Bin distance data</p></a></li>
<li><a href='#formatMult'><p>Create unmarkedMultFrame from Long Format Data Frame</p></a></li>
<li><a href='#formatWideLong'>
<p>Convert between wide and long data formats.</p></a></li>
<li><a href='#frogs'><p> 2001 Delaware North American Amphibian Monitoring Program Data</p></a></li>
<li><a href='#gdistremoval'>
<p>Fit the combined distance and removal model of Amundson et al. (2014).</p></a></li>
<li><a href='#gdistsamp'>
<p>Fit the generalized distance sampling model of Chandler et al. (2011).</p></a></li>
<li><a href='#getB-methods'><p>Methods for Function getB in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#getFP-methods'><p>Methods for Function getFP in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#getP-methods'><p>Methods for Function getP in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#gf'><p> Green frog count index data</p></a></li>
<li><a href='#gmultmix'><p>Generalized multinomial N-mixture model</p></a></li>
<li><a href='#goccu'>
<p>Fit multi-scale occupancy models</p></a></li>
<li><a href='#gpcount'>
<p>Generalized binomial N-mixture model for repeated count data</p></a></li>
<li><a href='#imputeMissing'>
<p>A function to impute missing entries in continuous obsCovs</p></a></li>
<li><a href='#issj'>
<p>Distance-sampling data for the Island Scrub Jay (<em>Aphelocoma</p>
insularis</em>)</a></li>
<li><a href='#jay'>
<p>European Jay data from the Swiss Breeding Bird Survey 2002</p></a></li>
<li><a href='#lambda2psi'>
<p>Convert Poisson mean (lambda) to probability of occurrence (psi).</p></a></li>
<li><a href='#linearComb-methods'><p>Methods for Function linearComb in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#linetran'>
<p>Simulated line transect data</p></a></li>
<li><a href='#makePiFuns'><p>Create functions to compute multinomial cell probabilities</p></a></li>
<li><a href='#mallard'><p>Mallard count data</p></a></li>
<li><a href='#masspcru'><p> Massachusetts North American Amphibian Monitoring Program Data</p></a></li>
<li><a href='#MesoCarnivores'>
<p>Occupancy data for coyote, red fox, and bobcat</p></a></li>
<li><a href='#modSel'><p>Model selection results from an unmarkedFitList</p></a></li>
<li><a href='#multinomPois'><p>Multinomial-Poisson Mixtures Model</p></a></li>
<li><a href='#multmixOpen'>
<p>Open population multinomial N-mixture model</p></a></li>
<li><a href='#nmixTTD'><p>Fit N-mixture Time-to-detection Models</p></a></li>
<li><a href='#nonparboot-methods'><p> Nonparametric bootstrapping in unmarked</p></a></li>
<li><a href='#occu'><p>Fit the MacKenzie et al. (2002) Occupancy Model</p></a></li>
<li><a href='#occuCOP'><p>Fit the occupancy model using count dta</p></a></li>
<li><a href='#occuFP'><p>Fit occupancy models when false positive detections occur (e.g., Royle and Link [2006]</p>
and Miller et al. [2011])</a></li>
<li><a href='#occuMS'><p>Fit Single-Season and Dynamic Multi-State Occupancy Models</p></a></li>
<li><a href='#occuMulti'><p>Fit the Rota et al. (2016) Multi-species Occupancy Model</p></a></li>
<li><a href='#occuPEN'><p>Fit the MacKenzie et al. (2002) Occupancy Model with the penalized likelihood methods of Hutchinson et al. (2015)</p></a></li>
<li><a href='#occuPEN_CV'><p>Fit the MacKenzie et al. (2002) Occupancy Model with the penalized likelihood methods of Hutchinson et al. (2015) using cross-validation</p></a></li>
<li><a href='#occuRN'><p>Fit the occupancy model of Royle and Nichols (2003)</p></a></li>
<li><a href='#occuTTD'><p>Fit Single-Season and Dynamic Time-to-detection Occupancy Models</p></a></li>
<li><a href='#optimizePenalty-methods'><p> Identify Optimal Penalty Parameter Value</p></a></li>
<li><a href='#ovendata'>
<p>Removal data for the Ovenbird</p></a></li>
<li><a href='#parboot'><p>Parametric bootstrap method for fitted models inheriting class.</p></a></li>
<li><a href='#pcount'><p>Fit the N-mixture model of Royle (2004)</p></a></li>
<li><a href='#pcount.spHDS'>
<p>Fit spatial hierarchical distance sampling model.</p></a></li>
<li><a href='#pcountOpen'><p>Fit the open N-mixture models of Dail and Madsen and extensions</p></a></li>
<li><a href='#piFuns'><p>Compute multinomial cell probabilities</p></a></li>
<li><a href='#plotEffects'><p>Plot marginal effects of covariates in unmarked models</p></a></li>
<li><a href='#pointtran'>
<p>Simulated point-transect data</p></a></li>
<li><a href='#posteriorSamples'><p>Draw samples from the posterior predictive distribution</p></a></li>
<li><a href='#powerAnalysis'><p>Conduct a power analysis on an unmarked model</p></a></li>
<li><a href='#predict-methods'><p> Methods for Function predict in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#randomTerms'><p>Extract estimates of random effect terms</p></a></li>
<li><a href='#ranef-methods'><p> Methods for Function <code>ranef</code> in Package <span class="pkg">unmarked</span></p></a></li>
<li><a href='#SE-methods'><p>Methods for Function SE in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#shinyPower'><p>Launch a Shiny app to help with power analysis</p></a></li>
<li><a href='#sight2perpdist'>
<p>Convert sight distance and sight angle to perpendicular distance.</p></a></li>
<li><a href='#sigma'><p>Extract estimates of random effect standard deviations</p></a></li>
<li><a href='#simulate-methods'><p>Methods for Function simulate in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#SSE'><p>Compute Sum of Squared Residuals for a Model Fit.</p></a></li>
<li><a href='#Switzerland'>
<p>Swiss landscape data</p></a></li>
<li><a href='#unmarkedEstimate-class'><p>Class &quot;unmarkedEstimate&quot;</p></a></li>
<li><a href='#unmarkedEstimateList-class'><p>Class &quot;unmarkedEstimateList&quot;</p></a></li>
<li><a href='#unmarkedFit-class'><p>Class &quot;unmarkedFit&quot;</p></a></li>
<li><a href='#unmarkedFitList-class'><p>Class &quot;unmarkedFitList&quot;</p></a></li>
<li><a href='#unmarkedFrame'><p>Create an unmarkedFrame, or one of its child classes.</p></a></li>
<li><a href='#unmarkedFrame-class'><p>Class &quot;unmarkedFrame&quot;</p></a></li>
<li><a href='#unmarkedFrameDS'><p>Organize data for the distance sampling model of Royle et al. (2004)</p>
fit by distsamp</a></li>
<li><a href='#unmarkedFrameDSO'><p>Create an object of class unmarkedFrameDSO that contains data used by distsampOpen.</p></a></li>
<li><a href='#unmarkedFrameGDR'><p>Organize data for the combined distance and removal point-count model of</p>
Amundson et al. (2014) fit by <code>gdistremoval</code></a></li>
<li><a href='#unmarkedFrameMMO'><p>Create an object of class unmarkedFrameMMO that contains data used by multmixOpen.</p></a></li>
<li><a href='#unmarkedFrameMPois'><p>Organize data for the multinomial-Poisson mixture model of Royle (2004)</p>
fit by multinomPois</a></li>
<li><a href='#unmarkedFrameOccu'><p>Organize data for the single season occupancy models fit by occu and</p>
occuRN</a></li>
<li><a href='#unmarkedFrameOccuCOP'><p>Organize data for the occupancy model using count data fit by <code>occuCOP</code></p></a></li>
<li><a href='#unmarkedFrameOccuFP'><p>Organize data for the single season occupancy models fit by occuFP</p></a></li>
<li><a href='#unmarkedFrameOccuMS'><p>Organize data for the multi-state occupancy model fit by occuMS</p></a></li>
<li><a href='#unmarkedFrameOccuMulti'><p>Organize data for the multispecies occupancy model fit by occuMulti</p></a></li>
<li><a href='#unmarkedFrameOccuTTD'><p>Create an unmarkedFrameOccuTTD object for the time-to-detection model</p>
fit by occuTTD</a></li>
<li><a href='#unmarkedFramePCO'><p>Create an object of class unmarkedFramePCO that contains data used by pcountOpen.</p></a></li>
<li><a href='#unmarkedFramePCount'><p>Organize data for the N-mixture model fit by pcount</p></a></li>
<li><a href='#unmarkedMultFrame'><p>Create an unmarkedMultFrame, unmarkedFrameGMM, unmarkedFrameGDS,</p>
or unmarkedFrameGPC object</a></li>
<li><a href='#unmarkedPower-methods'><p>Methods for unmarkedPower objects</p></a></li>
<li><a href='#unmarkedPowerList'><p>Create or summarize a series of unmarked power analyses</p></a></li>
<li><a href='#unmarkedRanef-class'><p>Class <code>"unmarkedRanef"</code></p></a></li>
<li><a href='#vcov-methods'><p>Methods for Function vcov in Package &lsquo;unmarked&rsquo;</p></a></li>
<li><a href='#vif'><p>Compute Variance Inflation Factors for an unmarkedFit Object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Models for Data from Unmarked Animals</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, lattice, lme4, MASS, Matrix, methods, parallel, Rcpp
(&ge; 0.8.0), stats, TMB (&ge; 1.7.18), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pbapply, knitr, rmarkdown, raster, shiny, testthat, terra</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits hierarchical models of animal abundance and occurrence to data collected using survey methods such as point counts, site occupancy sampling, distance sampling, removal sampling, and double observer sampling. Parameters governing the state and observation processes can be modeled as functions of covariates. References: Kellner et al. (2023) &lt;<a href="https://doi.org/10.1111%2F2041-210X.14123">doi:10.1111/2041-210X.14123</a>&gt;, Fiske and Chandler (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v043.i10">doi:10.18637/jss.v043.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'classes.R' 'unmarkedEstimate.R' 'mapInfo.R' 'unmarkedFrame.R'
'unmarkedFit.R' 'utils.R' 'getDesign.R' 'colext.R' 'distsamp.R'
'multinomPois.R' 'occu.R' 'occuRN.R' 'occuMulti.R' 'pcount.R'
'gmultmix.R' 'pcountOpen.R' 'gdistsamp.R' 'unmarkedFitList.R'
'unmarkedLinComb.R' 'ranef.R' 'boot.R' 'occuFP.R' 'gpcount.R'
'occuPEN.R' 'pcount.spHDS.R' 'occuMS.R' 'occuTTD.R'
'distsampOpen.R' 'multmixOpen.R' 'unmarkedCrossVal.R' 'piFun.R'
'vif.R' 'makePiFun.R' 'posteriorSamples.R' 'nmixTTD.R'
'gdistremoval.R' 'plotEffects.R' 'mixedModelTools.R' 'power.R'
'simulate.R' 'predict.R' 'goccu.R' 'occuCOP.R' 'RcppExports.R'
'zzz.R'</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, TMB, RcppEigen</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://groups.google.com/d/forum/unmarked">https://groups.google.com/d/forum/unmarked</a>,
<a href="https://rbchan.github.io/unmarked/">https://rbchan.github.io/unmarked/</a>,
<a href="https://github.com/ianfiske/unmarked">https://github.com/ianfiske/unmarked</a>,
<a href="https://github.com/rbchan/unmarked">https://github.com/rbchan/unmarked</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rbchan/unmarked/issues">https://github.com/rbchan/unmarked/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 21:07:52 UTC; ken</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Chandler [aut],
  Ken Kellner [cre, aut],
  Ian Fiske [aut],
  David Miller [aut],
  Andy Royle [aut],
  Jeff Hostetler [aut],
  Rebecca Hutchinson [aut],
  Adam Smith [aut],
  Lea Pautrel [aut],
  Marc Kery [ctb],
  Mike Meredith [ctb],
  Auriel Fournier [ctb],
  Ariel Muldoon [ctb],
  Chris Baker [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ken Kellner &lt;contact@kenkellner.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='unmarked-package'>Models for Data from Unmarked Animals</h2><span id='topic+unmarked'></span><span id='topic+unmarked-package'></span>

<h3>Description</h3>

<p>Fits hierarchical models of animal
occurrence and abundance to data collected on species that may be
detected imperfectly.  Models include single- and multi-season site
occupancy models, binomial N-mixture models, and multinomial N-mixture
models. The data can arise from survey methods such as occurrence
sampling, temporally replicated counts, removal sampling, double
observer sampling, and distance sampling. Parameters governing the
state and observation processes can be modeled as functions of
covariates. General treatment of these models can be found in
MacKenzie et al. (2006) and Royle and Dorazio (2008). The primary
reference for the package is Fiske and Chandler (2011).</p>


<h3>Details</h3>

<p><strong>Overview of Model-fitting Functions:</strong>
</p>
<p><code><a href="#topic+occu">occu</a></code> fits occurrence models with no linkage between
abundance and detection (MacKenzie et al. 2002).
</p>
<p><code><a href="#topic+occuRN">occuRN</a></code> fits abundance models to presence/absence data by
exploiting the link between detection probability and abundance (Royle and
Nichols 2003).
</p>
<p><code><a href="#topic+occuFP">occuFP</a></code> fits occupancy models to data characterized by
false negatives and false positive detections (e.g., Royle and Link
[2006] and Miller et al. [2011]).
</p>
<p><code><a href="#topic+occuMulti">occuMulti</a></code> fits multi-species occupancy model of Rota et
al. [2016].
</p>
<p><code><a href="#topic+colext">colext</a></code> fits the mutli-season occupancy model of
MacKenzie et al. (2003).
</p>
<p><code><a href="#topic+pcount">pcount</a></code> fits N-mixture models (aka binomial mixture models) to
repeated count data (Royle 2004a, Kery et al 2005).
</p>
<p><code><a href="#topic+distsamp">distsamp</a></code> fits the distance sampling model of
Royle et al. (2004) to distance data recorded in discrete intervals.
</p>
<p><code><a href="#topic+gdistsamp">gdistsamp</a></code> fits the generalized distance sampling model
described by Chandler et al. (2011) to distance data recorded in
discrete intervals.
</p>
<p><code><a href="#topic+gpcount">gpcount</a></code> fits the generalized N-mixture model
described by Chandler et al. (2011) to repeated count data collected
using the robust design.
</p>
<p><code><a href="#topic+multinomPois">multinomPois</a></code> fits the multinomial-Poisson model of Royle (2004b)
to data collected using methods such as removal sampling or double observer
sampling.
</p>
<p><code><a href="#topic+gmultmix">gmultmix</a></code> fits a generalized form of the multinomial-mixture model
of Royle (2004b) that allows for estimating availability and detection
probability.
</p>
<p><code><a href="#topic+pcountOpen">pcountOpen</a></code> fits the open population model of Dail and
Madsen (2011) to repeated count data. This is a genearlized form of the
Royle (2004a) N-mixture model that includes parameters for recruitment
and apparent survival.
</p>
<p><strong>Data:</strong> All data are passed to unmarked's estimation functions as
a formal S4 class called an unmarkedFrame, which has child classes
for each model type. This allows metadata (eg as distance interval cut
points, measurement units, etc...) to be stored with the response and
covariate data. See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> for a detailed
description of unmarkedFrames and how to create them.
</p>
<p><strong>Model Specification:</strong>  <em>unmarked</em>'s
model-fitting functions allow specification of covariates for both the
state process and the detection process.  For two-level hierarchical
models, (eg <code><a href="#topic+occu">occu</a></code>, <code><a href="#topic+occuRN">occuRN</a></code>, <code><a href="#topic+pcount">pcount</a></code>,
<code><a href="#topic+multinomPois">multinomPois</a></code>, <code><a href="#topic+distsamp">distsamp</a></code>) covariates for the
detection process (at the site or observation level) and the state
process (at the site level) are specified with a double right-hand sided
formula, in that order.  Such a formula looks like
</p>
<p><code class="reqn">~ x1 + x2 + \ldots + x_n  ~ x_1 + x_2 + \ldots + x_n</code>
</p>
<p>where <code class="reqn">x_1</code> through <code class="reqn">x_n</code> are additive covariates of
the process of interest.  Using two tildes in a single formula
differs from standard R convention, but it is informative about the model
being fit. The meaning of these covariates, or what they
model, is full described in the help files for the individual functions
and is not the same for all functions. For models with more than two
processes (eg <code><a href="#topic+colext">colext</a></code>, <code><a href="#topic+gmultmix">gmultmix</a></code>,
<code><a href="#topic+pcountOpen">pcountOpen</a></code>), single right-hand sided formulas (only one
tilde) are used to model each parameter.
</p>
<p><strong>Utility Functions:</strong>  <em>unmarked</em> contains several utility
functions for organizing data into the form required by its model-fitting
functions.  <code><a href="#topic+csvToUMF">csvToUMF</a></code> converts an appropriately
formated comma-separated values (.csv) file to a list containing the
components required by model-fitting functions.</p>


<h3>Author(s)</h3>

<p>Ian Fiske, Richard Chandler, Andy Royle, Marc Kery, David
Miller, and Rebecca Hutchinson</p>


<h3>References</h3>

<p>Chandler, R. B., J. A. Royle, and D. I. King. 2011. Inference about
density and temporary emigration in unmarked populations. <em>Ecology</em>
92:1429-1435.
</p>
<p>Dail, D. and L. Madsen. 2011. Models for estimating abundance from
repeated counts of an open metapopulation. <em>Biometrics</em> 67:577-587.
</p>
<p>Fiske, I. and R. B. Chandler. 2011. <em>unmarked</em>: An R package for
fitting hierarchical models of wildlife occurrence and
abundance. <em>Journal of Statistical Software</em> 43:1&ndash;23.
</p>
<p>Kery, M., Royle, J. A., and Schmid, H. 2005 Modeling avian abundance from
replicated counts using binomial mixture models. <em>Ecological
Applications</em> 15:1450&ndash;1461.
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. A. Royle, and C. A. Langtimm. 2002. Estimating site occupancy rates
when detection probabilities are less than one. <em>Ecology</em> 83:
2248&ndash;2255.
</p>
<p>MacKenzie, D. I., J. D. Nichols, J. E. Hines, M. G. Knutson, and
A. B. Franklin. 2003. Estimating site occupancy, colonization, and
local extinction when a species is detected
imperfectly. <em>Ecology</em> 84:2200&ndash;2207.
</p>
<p>MacKenzie, D. I., J. D. Nichols, J. A. Royle, K. H. Pollock,
L. L. Bailey, and J. E. Hines. 2006. <em>Occupancy Estimation and
Modeling</em>. Amsterdam: Academic Press.
</p>
<p>Miller, D.A., J.D. Nichols, B.T. McClintock, E.H.C. Grant, L.L. Bailey,
and L.A. Weir. 2011. Improving occupancy estimation when two types of
observational error occur: non-detection and species
misidentification. <em>Ecology</em> 92:1422-1428.
</p>
<p>Rota, C.T., et al. 2016. A multi-species occupancy model for two or more
interacting species. Methods in Ecology and Evolution 7: 1164-1173.
</p>
<p>Royle, J. A. 2004a. N-Mixture models for estimating population size from
spatially replicated counts. <em>Biometrics</em> 60:108&ndash;105.
</p>
<p>Royle, J. A. 2004b. Generalized estimators of avian abundance from
count survey data. <em>Animal Biodiversity and Conservation</em>
27:375&ndash;386.
</p>
<p>Royle, J. A., D. K. Dawson, and S. Bates. 2004. Modeling abundance
effects in distance sampling. <em>Ecology</em> 85:1591&ndash;1597.
</p>
<p>Royle, J. A., and R. M. Dorazio. 2006. Hierarchical models of animal
abundance and occurrence. <em>Journal Of Agricultural Biological And
Environmental Statistics</em> 11:249&ndash;263.
</p>
<p>Royle, J.A., and W.A. Link. 2006. Generalized site occupancy models
allowing for false positive and false negative errors. <em>Ecology</em>
87:835-841.
</p>
<p>Royle, J. A. and R. M. Dorazio. 2008. <em>Hierarchical Modeling and
Inference in Ecology</em>. Academic Press.
</p>
<p>Royle, J. A. and J. D. Nichols. 2003. Estimating Abundance from
Repeated Presence-Absence Data or Point Counts. <em>Ecology</em>,
84:777&ndash;790.
</p>
<p>Sillett, S. and Chandler, R.B. and Royle, J.A. and Kery, M. and
Morrison, S.A. In Press. Hierarchical distance sampling models to
estimate population size and habitat-specific abundance of an island
endemic. <em>Ecological Applications</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## An example site-occupancy analysis

# Simulate occupancy data
set.seed(344)
nSites &lt;- 100
nReps &lt;- 5
covariates &lt;- data.frame(veght=rnorm(nSites),
    habitat=factor(c(rep('A', 50), rep('B', 50))))

psipars &lt;- c(-1, 1, -1)
ppars &lt;- c(1, -1, 0)
X &lt;- model.matrix(~veght+habitat, covariates) # design matrix
psi &lt;- plogis(X %*% psipars)
p &lt;- plogis(X %*% ppars)

y &lt;- matrix(NA, nSites, nReps)
z &lt;- rbinom(nSites, 1, psi)       # true occupancy state
for(i in 1:nSites) {
    y[i,] &lt;- rbinom(nReps, 1, z[i]*p[i])
    }

# Organize data and look at it
umf &lt;- unmarkedFrameOccu(y = y, siteCovs = covariates)
head(umf)
summary(umf)


# Fit some models
fm1 &lt;- occu(~1 ~1, umf)
fm2 &lt;- occu(~veght+habitat ~veght+habitat, umf)
fm3 &lt;- occu(~veght ~veght+habitat, umf)


# Model selection
fms &lt;- fitList(m1=fm1, m2=fm2, m3=fm3)
modSel(fms)

# Empirical Bayes estimates of the number of sites occupied
sum(bup(ranef(fm3), stat="mode"))     # Sum of posterior modes
sum(z)                                # Actual


# Model-averaged prediction and plots

# psi in each habitat type
newdata1 &lt;- data.frame(habitat=c('A', 'B'), veght=0)
Epsi1 &lt;- predict(fms, type="state", newdata=newdata1)
with(Epsi1, {
    plot(1:2, Predicted, xaxt="n", xlim=c(0.5, 2.5), ylim=c(0, 0.5),
        xlab="Habitat",
        ylab=expression(paste("Probability of occurrence (", psi, ")")),
        cex.lab=1.2,
        pch=16, cex=1.5)
    axis(1, 1:2, c('A', 'B'))
    arrows(1:2, Predicted-SE, 1:2, Predicted+SE, angle=90, code=3, length=0.05)
    })


# psi and p as functions of vegetation height
newdata2 &lt;- data.frame(habitat=factor('A', levels=c('A','B')),
    veght=seq(-2, 2, length=50))
Epsi2 &lt;- predict(fms, type="state", newdata=newdata2, appendData=TRUE)
Ep &lt;- predict(fms, type="det", newdata=newdata2, appendData=TRUE)

op &lt;- par(mfrow=c(2, 1), mai=c(0.9, 0.8, 0.2, 0.2))
plot(Predicted~veght, Epsi2, type="l", lwd=2, ylim=c(0,1),
    xlab="Vegetation height (standardized)",
    ylab=expression(paste("Probability of occurrence (", psi, ")")))
    lines(lower ~ veght, Epsi2, col=gray(0.7))
    lines(upper ~ veght, Epsi2, col=gray(0.7))
plot(Predicted~veght, Ep, type="l", lwd=2, ylim=c(0,1),
    xlab="Vegetation height (standardized)",
    ylab=expression(paste("Detection probability (", italic(p), ")")))
lines(lower~veght, Ep, col=gray(0.7))
lines(upper~veght, Ep, col=gray(0.7))
par(op)


</code></pre>

<hr>
<h2 id='+5B-methods'>Methods for bracket extraction [ in Package &lsquo;unmarked&rsquo;</h2><span id='topic++5B-methods'></span><span id='topic++5B+2CunmarkedEstimateList+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CunmarkedFit+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CunmarkedFrame+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrame+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrame+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedMultFrame+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedMultFrame+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGMM+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGDS+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFramePCO+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFramePCO+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGPC+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGPC+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrame+2Clist+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for bracket extraction <code>[</code> in Package &lsquo;unmarked&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedEstimateList,ANY,ANY,ANY'
x[i, j, drop]
## S4 method for signature 'unmarkedFit,ANY,ANY,ANY'
x[i, j, drop]
## S4 method for signature 'unmarkedFrame,numeric,numeric,missing'
x[i, j]
## S4 method for signature 'unmarkedFrame,list,missing,missing'
x[i, j]
## S4 method for signature 'unmarkedMultFrame,missing,numeric,missing'
x[i, j]
## S4 method for signature 'unmarkedMultFrame,numeric,missing,missing'
x[i, j]
## S4 method for signature 'unmarkedFrameGMM,numeric,missing,missing'
x[i, j]
## S4 method for signature 'unmarkedFrameGDS,numeric,missing,missing'
x[i, j]
## S4 method for signature 'unmarkedFramePCO,numeric,missing,missing'
x[i, j]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B-methods_+3A_x">x</code></td>
<td>
<p>Object of appropriate S4 class</p>
</td></tr>
<tr><td><code id="+2B5B-methods_+3A_i">i</code></td>
<td>
<p>Row numbers</p>
</td></tr>
<tr><td><code id="+2B5B-methods_+3A_j">j</code></td>
<td>
<p>Observation numbers (eg occasions, distance classes, etc...)</p>
</td></tr>
<tr><td><code id="+2B5B-methods_+3A_drop">drop</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;unmarkedEstimateList&quot;, i = &quot;ANY&quot;, j = &quot;ANY&quot;, drop = &quot;ANY&quot;</dt><dd><p>Extract a
unmarkedEstimate object from an unmarkedEstimateList by name (either 'det'
or 'state')</p>
</dd>
<dt>x = &quot;unmarkedFit&quot;, i = &quot;ANY&quot;, j = &quot;ANY&quot;, drop = &quot;ANY&quot;</dt><dd><p>Extract a
unmarkedEstimate object from an unmarkedFit by name (either 'det'
or 'state')</p>
</dd>
<dt>x = &quot;unmarkedFrame&quot;, i = &quot;missing&quot;, j = &quot;numeric&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract observations from an unmarkedFrame.</p>
</dd>
<dt>x = &quot;unmarkedFrame&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract rows from an unmarkedFrame </p>
</dd>
<dt>x = &quot;unmarkedFrame&quot;, i = &quot;numeric&quot;, j = &quot;numeric&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract rows and observations from an unmarkedFrame </p>
</dd>
<dt>x = &quot;unmarkedMultFrame&quot;, i = &quot;missing&quot;, j = &quot;numeric&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract primary sampling periods from an unmarkedMultFrame</p>
</dd>
<dt>x = &quot;unmarkedFrame&quot;, i = &quot;list&quot;, j = &quot;missing&quot;, drop = &quot;missing&quot;</dt><dd>
<p>List is the index of observations to subset for each site. </p>
</dd>
<dt>x = &quot;unmarkedMultFrame&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract rows (sites) from an unmarkedMultFrame</p>
</dd>
<dt>x = &quot;unmarkedGMM&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract rows (sites) from an unmarkedFrameGMM object</p>
</dd>
<dt>x = &quot;unmarkedGDS&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract rows (sites) from an unmarkedFrameGDS object</p>
</dd>
<dt>x = &quot;unmarkedPCO&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop = &quot;missing&quot;</dt><dd>
<p>Extract rows (sites) from an unmarkedFramePCO object</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
	obsCovs = mallard.obs)
summary(mallardUMF)

mallardUMF[1:5,]
mallardUMF[,1:2]
mallardUMF[1:5, 1:2]

</code></pre>

<hr>
<h2 id='backTransform-methods'>Methods for Function backTransform in Package &lsquo;unmarked&rsquo;</h2><span id='topic+backTransform'></span><span id='topic+backTransform-methods'></span><span id='topic+backTransform+2CunmarkedEstimate-method'></span><span id='topic+backTransform+2CunmarkedFit-method'></span><span id='topic+backTransform+2CunmarkedLinComb-method'></span><span id='topic+show+2CunmarkedBackTrans-method'></span>

<h3>Description</h3>

<p>Methods for function <code>backTransform</code> in Package &lsquo;unmarked&rsquo;. 
This converts from link-scale to original-scale</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFit'
backTransform(obj, type)
## S4 method for signature 'unmarkedEstimate'
backTransform(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backTransform-methods_+3A_obj">obj</code></td>
<td>
<p>Object of appropriate S4 class</p>
</td></tr>
<tr><td><code id="backTransform-methods_+3A_type">type</code></td>
<td>
<p>one of names(obj), eg 'state' or 'det'</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;unmarkedEstimate&quot;</dt><dd><p>Typically done internally</p>
</dd>
<dt>obj = &quot;unmarkedFit&quot;</dt><dd><p>Back-transform a parameter from a fitted model. Only
possible if no covariates are present. Must specify argument type 
as one of the values returned by names(obj).</p>
</dd>
<dt>obj = &quot;unmarkedLinComb&quot;</dt><dd><p>Back-transform a predicted value created by 
<code>linearComb</code>. This is done internally by <code><a href="#topic+predict">predict</a></code> but
can be done explicitly by user.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site, 
    obsCovs = mallard.obs)

(fm &lt;- pcount(~ 1 ~ forest, mallardUMF))    # Fit a model
backTransform(fm, type="det")               # This works because there are no detection covariates
#backTransform(fm, type="state")             # This doesn't work because covariates are present
lc &lt;- linearComb(fm, c(1, 0), type="state") # Estimate abundance on the log scale when forest=0
backTransform(lc)                           # Abundance on the original scale

## End(Not run)

</code></pre>

<hr>
<h2 id='birds'> BBS Point Count and Occurrence Data from 2 Bird Species</h2><span id='topic+birds'></span><span id='topic+catbird'></span><span id='topic+catbird.bin'></span><span id='topic+woodthrush'></span><span id='topic+woodthrush.bin'></span>

<h3>Description</h3>

<p>Data frames for 2 species from the breeding bird survey (BBS).  Each
data frame has a row for each site and columns for each sampling
event.  There is a point count and occurrence&ndash;designated by
<code>.bin</code>&ndash;  version for each species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(birds)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>catbird</code></dt><dd><p>A data frame of point count observations for
the catbird.</p>
</dd>
<dt><code>catbird.bin</code></dt><dd><p>A data frame of occurrence observations for
the catbird.</p>
</dd>
<dt><code>woodthrush</code></dt><dd><p>A data frame of point count observations for
the wood thrush.</p>
</dd>
<dt><code>woodthrush.bin</code></dt><dd><p>A data frame of point count observations for
the wood thrush.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Royle J. N-mixture models for estimating population size from spatially
replicated counts. Biometrics. 2004.  60(1):108&ndash;115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(birds)
</code></pre>

<hr>
<h2 id='coef-methods'>Methods for Function coef in Package &lsquo;unmarked&rsquo;</h2><span id='topic+coef-methods'></span><span id='topic+coef+2ClinCombOrBackTrans-method'></span><span id='topic+coef+2CunmarkedEstimate-method'></span><span id='topic+coef+2CunmarkedFit-method'></span>

<h3>Description</h3>

<p>Extract coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFit'
coef(object, type, altNames = TRUE, fixedOnly=TRUE)
## S4 method for signature 'unmarkedEstimate'
coef(object, altNames = TRUE, fixedOnly=TRUE, ...)
## S4 method for signature 'linCombOrBackTrans'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef-methods_+3A_object">object</code></td>
<td>
<p>Object of appropriate S4 class</p>
</td></tr>
<tr><td><code id="coef-methods_+3A_type">type</code></td>
<td>
<p>Either 'state' or 'det'</p>
</td></tr>
<tr><td><code id="coef-methods_+3A_altnames">altNames</code></td>
<td>
<p>Return specific names for parameter estimates?</p>
</td></tr>
<tr><td><code id="coef-methods_+3A_fixedonly">fixedOnly</code></td>
<td>
<p>Return only fixed effect parameters?</p>
</td></tr>
<tr><td><code id="coef-methods_+3A_...">...</code></td>
<td>
<p>Further arguments. Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of parameter estimates.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;linCombOrBackTrans&quot;</dt><dd><p>Object from linearComb</p>
</dd>
<dt>object = &quot;unmarkedEstimate&quot;</dt><dd><p>unmarkedEstimate object</p>
</dd>
<dt>object = &quot;unmarkedFit&quot;</dt><dd><p>Fitted model</p>
</dd>
</dl>

<hr>
<h2 id='colext'>Fit the dynamic occupancy model of MacKenzie et. al (2003)</h2><span id='topic+colext'></span>

<h3>Description</h3>

<p>Estimate parameters of the colonization-extinction model,
including covariate-dependent rates and detection process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>colext(psiformula= ~1, gammaformula =  ~ 1, epsilonformula = ~ 1,
    pformula = ~ 1, data, starts, method="BFGS", se=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colext_+3A_psiformula">psiformula</code></td>
<td>
<p>Right-hand sided formula for the initial
probability of occupancy at each site.</p>
</td></tr>
<tr><td><code id="colext_+3A_gammaformula">gammaformula</code></td>
<td>
<p>Right-hand sided formula for colonization probability.</p>
</td></tr>
<tr><td><code id="colext_+3A_epsilonformula">epsilonformula</code></td>
<td>
<p>Right-hand sided formula for extinction probability.</p>
</td></tr>
<tr><td><code id="colext_+3A_pformula">pformula</code></td>
<td>
<p>Right-hand sided formula for detection probability.</p>
</td></tr>
<tr><td><code id="colext_+3A_data">data</code></td>
<td>
<p>unmarkedMultFrame object that supplies the data (see <code><a href="#topic+unmarkedMultFrame">unmarkedMultFrame</a></code>).</p>
</td></tr>
<tr><td><code id="colext_+3A_starts">starts</code></td>
<td>
<p>optionally, initial values for parameters in the optimization.</p>
</td></tr>
<tr><td><code id="colext_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="colext_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard errors.</p>
</td></tr>
<tr><td><code id="colext_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the colonization-extinction model of
MacKenzie et al (2003).  The colonization and extinction rates can be
modeled with covariates that vary yearly at each site using a logit
link.  These covariates are supplied by special unmarkedMultFrame
<code>yearlySiteCovs</code> slot.  These parameters are specified using the
<code>gammaformula</code> and <code>epsilonformula</code> arguments.  The initial
probability of occupancy is modeled by covariates specified in the
<code>psiformula</code>.
</p>
<p>The conditional detection rate can also be modeled as a function of
covariates that vary at the secondary sampling period (ie., repeat
visits).  These covariates are specified by the first part of the
<code>formula</code> argument and the data is supplied via the usual
<code>obsCovs</code> slot.
</p>
<p>The projected and smoothed trajectories (Weir et al 2009) can be
obtained from the <code>smoothed.mean</code> and <code>projected.mean</code> slots
(see examples).
</p>


<h3>Value</h3>

<p>unmarkedFitColExt object describing model fit.</p>


<h3>References</h3>

<p>MacKenzie, D.I. et al. (2002) Estimating Site Occupancy Rates When Detection Probabilities Are Less Than One. Ecology, 83(8), 2248-2255.
</p>
<p>MacKenzie, D. I., J. D. Nichols, J. E. Hines, M. G. Knutson, and A. B. Franklin.
2003. Estimating site occupancy, colonization, and local extinction when a
species is detected imperfectly. <em>Ecology</em> 84:2200&ndash;2207.
</p>
<p>MacKenzie, D. I. et al. (2006) <em>Occupancy Estimation and Modeling</em>.Amsterdam: Academic Press.
</p>
<p>Weir L. A., Fiske I. J., Royle J. (2009) Trends in Anuran Occupancy from
Northeastern States of the North American Amphibian Monitoring
Program. Herpetological Conservation and Biology. 4(3):389-402.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonparboot">nonparboot</a></code>, <code><a href="#topic+unmarkedMultFrame">unmarkedMultFrame</a></code>, and <code><a href="#topic+formatMult">formatMult</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
R &lt;- 4 # number of sites
J &lt;- 3 # number of secondary sampling occasions
T &lt;- 2 # number of primary periods

y &lt;- matrix(c(
   1,1,0,  0,0,0,
   0,0,0,  0,0,0,
   1,1,1,  1,1,0,
   1,0,1,  0,0,1), nrow=R, ncol=J*T, byrow=TRUE)
y

site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

yearly.site.covs &lt;- list(
   year = matrix(c(
      'year1', 'year2',
      'year1', 'year2',
      'year1', 'year2',
      'year1', 'year2'), nrow=R, ncol=T, byrow=TRUE)
      )
yearly.site.covs

obs.covs &lt;- list(
   x4 = matrix(c(
      -1,0,1,  -1,1,1,
      -2,0,0,  0,0,2,
      -3,1,0,  1,1,2,
      0,0,0,   0,1,-1), nrow=R, ncol=J*T, byrow=TRUE),
   x5 = matrix(c(
      'a','b','c',  'a','b','c',
      'd','b','a',  'd','b','a',
      'a','a','c',  'd','b','a',
      'a','b','a',  'd','b','a'), nrow=R, ncol=J*T, byrow=TRUE))
obs.covs

umf &lt;- unmarkedMultFrame(y=y, siteCovs=site.covs,
    yearlySiteCovs=yearly.site.covs, obsCovs=obs.covs,
    numPrimary=2)                  # organize data
umf                                # look at data
summary(umf)                       # summarize
fm &lt;- colext(~1, ~1, ~1, ~1, umf)  # fit a model
fm



## Not run: 
# Real data
data(frogs)
umf &lt;- formatMult(masspcru)
obsCovs(umf) &lt;- scale(obsCovs(umf))

## Use 1/4 of data just for run speed in example
umf &lt;- umf[which((1:numSites(umf)) %% 4 == 0),]

## constant transition rates
(fm &lt;- colext(psiformula = ~ 1,
gammaformula = ~ 1,
epsilonformula = ~ 1,
pformula = ~ JulianDate + I(JulianDate^2), umf, control = list(trace=1, maxit=1e4)))

## get the trajectory estimates
smoothed(fm)
projected(fm)

# Empirical Bayes estimates of number of sites occupied in each year
re &lt;- ranef(fm)
modes &lt;- colSums(bup(re, stat="mode"))
plot(1:7, modes, xlab="Year", ylab="Sites occupied", ylim=c(0, 70))

## Find bootstrap standard errors for smoothed trajectory
fm &lt;- nonparboot(fm, B = 100)  # This takes a while!
fm@smoothed.mean.bsse

## try yearly transition rates
yearlySiteCovs(umf) &lt;- data.frame(year = factor(rep(1:7, numSites(umf))))
(fm.yearly &lt;- colext(psiformula = ~ 1,
gammaformula = ~ year,
epsilonformula = ~ year,
pformula = ~ JulianDate + I(JulianDate^2), umf,
	control = list(trace=1, maxit=1e4)))

## End(Not run)

</code></pre>

<hr>
<h2 id='computeMPLElambda'>Compute the penalty weight for the MPLE penalized likelihood method</h2><span id='topic+computeMPLElambda'></span>

<h3>Description</h3>

<p>This function computes the weight for the MPLE penalty of Moreno &amp; Lele (2010). </p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMPLElambda(formula, data, knownOcc=numeric(0), starts,
method="BFGS",engine=c("C", "R"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMPLElambda_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and occupancy in that order.</p>
</td></tr>
<tr><td><code id="computeMPLElambda_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> object</p>
</td></tr>
<tr><td><code id="computeMPLElambda_+3A_knownocc">knownOcc</code></td>
<td>
<p>Vector of sites that are known to be occupied. These
should be supplied as row numbers of the y matrix, eg, c(3,8) if
sites 3 and 8 were known to be occupied a priori.</p>
</td></tr>
<tr><td><code id="computeMPLElambda_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="computeMPLElambda_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="computeMPLElambda_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; or &quot;R&quot; to use fast C++ code or native R
code during the optimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+occuPEN">occuPEN</a></code> for details and examples.
</p>


<h3>Value</h3>

<p>The computed lambda.</p>


<h3>Author(s)</h3>

<p>Rebecca A. Hutchinson</p>


<h3>References</h3>

<p>Moreno, M. and S. R. Lele. 2010. Improved estimation of site occupancy
using penalized likelihood. Ecology 91: 341-346.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>,
<code><a href="#topic+occu">occu</a></code>, <code><a href="#topic+occuPEN">occuPEN</a></code>, <code><a href="#topic+occuPEN_CV">occuPEN_CV</a></code>, 
<code><a href="#topic+nonparboot">nonparboot</a></code></p>

<hr>
<h2 id='confint-methods'>Methods for Function confint in Package &lsquo;unmarked&rsquo;</h2><span id='topic+confint-methods'></span><span id='topic+confint+2CunmarkedBackTrans-method'></span><span id='topic+confint+2CunmarkedEstimate-method'></span><span id='topic+confint+2CunmarkedFit-method'></span><span id='topic+confint+2CunmarkedLinComb-method'></span>

<h3>Description</h3>

<p>Methods for function <code>confint</code> in Package &lsquo;unmarked&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedBackTrans'
confint(object, parm, level)
## S4 method for signature 'unmarkedEstimate'
confint(object, parm, level)
## S4 method for signature 'unmarkedLinComb'
confint(object, parm, level)
## S4 method for signature 'unmarkedFit'
confint(object, parm, level, type, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint-methods_+3A_object">object</code></td>
<td>
<p>Object of appropriate S4 class</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_parm">parm</code></td>
<td>
<p>Name of parameter(s) of interest</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_level">level</code></td>
<td>
<p>Level of confidence</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_type">type</code></td>
<td>
<p>Either &quot;state&quot; or &quot;det&quot;</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_method">method</code></td>
<td>
<p>Either &quot;normal&quot; or &quot;profile&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of lower and upper confidence intervals. These are
asymtotic unless method='profile' is used on unmarkedFit objects in which case
they are profile likelihood intervals.</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFit-class">unmarkedFit-class</a></code></p>

<hr>
<h2 id='crossbill'>
Detection/non-detection data on the European crossbill (<em>Loxia
curvirostra</em>)
</h2><span id='topic+crossbill'></span>

<h3>Description</h3>

<p>267 1-kmsq quadrats were surveyed 3 times per year during 1999-2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crossbill)</code></pre>


<h3>Format</h3>

<p>A data frame with 267 observations on the following 58 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Plot ID</p>
</dd>
<dt><code>ele</code></dt><dd><p>Elevation</p>
</dd>
<dt><code>forest</code></dt><dd><p>Percent forest cover</p>
</dd>
<dt><code>surveys</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det991</code></dt><dd><p>Detection data for 1999, survey 1</p>
</dd>
<dt><code>det992</code></dt><dd><p>Detection data for 1999, survey 2</p>
</dd>
<dt><code>det993</code></dt><dd><p>Detection data for 1999, survey 3</p>
</dd>
<dt><code>det001</code></dt><dd><p>Detection data for 2000, survey 1</p>
</dd>
<dt><code>det002</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det003</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det011</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det012</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det013</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det021</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det022</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det023</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det031</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det032</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det033</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det041</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det042</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det043</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det051</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det052</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det053</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det061</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det062</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>det063</code></dt><dd><p>Detection data for 2006, survey 3</p>
</dd>
<dt><code>det071</code></dt><dd><p>Detection data for 2007, survey 1</p>
</dd>
<dt><code>det072</code></dt><dd><p>Detection data for 2007, survey 2</p>
</dd>
<dt><code>det073</code></dt><dd><p>Detection data for 2007, survey 3</p>
</dd>
<dt><code>date991</code></dt><dd><p>Day of the season for 1999, survey 1</p>
</dd>
<dt><code>date992</code></dt><dd><p>Day of the season for 1999, survey 2</p>
</dd>
<dt><code>date993</code></dt><dd><p>Day of the season for 1999, survey 3</p>
</dd>
<dt><code>date001</code></dt><dd><p>Day of the season for 2000, survey 1</p>
</dd>
<dt><code>date002</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date003</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date011</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date012</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date013</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date021</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date022</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date023</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date031</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date032</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date033</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date041</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date042</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date043</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date051</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date052</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date053</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date061</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date062</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date063</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date071</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date072</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date073</code></dt><dd><p>Day of the season for 2007, survey 3</p>
</dd>
</dl>



<h3>Source</h3>

<p>Schmid, H. N. Zbinden, and V. Keller. 2004. Uberwachung der
Bestandsentwicklung haufiger Brutvogel in der Schweiz,
Swiss Ornithological Institute Sempach Switzerland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Switzerland">Switzerland</a></code> for corresponding covariate data
defined for all 1-kmsq pixels in Switzerland. Useful for making
species distribution maps.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crossbill)
str(crossbill)
</code></pre>

<hr>
<h2 id='crossVal'>Cross-validation methods for fitted unmarked models and fit lists</h2><span id='topic+crossVal'></span><span id='topic+crossVal-methods'></span><span id='topic+crossVal+2CunmarkedFit-method'></span><span id='topic+crossVal+2CunmarkedFitList-method'></span><span id='topic+unmarkedCrossVal-class'></span><span id='topic+unmarkedCrossValList-class'></span><span id='topic+show+2CunmarkedCrossVal-method'></span><span id='topic+show+2CunmarkedCrossValList-method'></span>

<h3>Description</h3>

<p>Test predictive accuracy of fitted models using several 
cross-validation approaches. The dataset is divided by site only into folds or
testing and training datasets (i.e., encounter histories within sites are
never split up).</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFit'
crossVal(
  object, method=c("Kfold","holdout","leaveOneOut"),
  folds=10, holdoutPct=0.25, statistic=RMSE_MAE, parallel=FALSE, ncores, ...)
## S4 method for signature 'unmarkedFitList'
crossVal(
  object, method=c("Kfold","holdout","leaveOneOut"),
  folds=10, holdoutPct=0.25, statistic=RMSE_MAE, parallel=FALSE, ncores, 
  sort = c("none", "increasing", "decreasing"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossVal_+3A_object">object</code></td>
<td>
<p>A fitted model inheriting class <code>unmarkedFit</code> or a list of 
fitted models with class <code>unmarkedFitList</code></p>
</td></tr>
<tr><td><code id="crossVal_+3A_method">method</code></td>
<td>
<p>Cross validation method to use as string. Valid options are 
<code>"Kfold"</code>, <code>"holdout"</code>, or <code>"leaveOneOut"</code></p>
</td></tr>
<tr><td><code id="crossVal_+3A_folds">folds</code></td>
<td>
<p>Number of folds to use for k-fold cross validation</p>
</td></tr>
<tr><td><code id="crossVal_+3A_holdoutpct">holdoutPct</code></td>
<td>
<p>Proportion of dataset (value between 0-1) to use as the 
&quot;holdout&quot; or &quot;test&quot; set, for the holdout method</p>
</td></tr>
<tr><td><code id="crossVal_+3A_statistic">statistic</code></td>
<td>
<p>Function that calculates statistics for each fold. The
function must take an <code>unmarkedFit</code> object as the first argument and
return a named numeric vector with statistic value(s). The default function
<code>RMSE_MAE</code> returns root-mean-square error and mean absolute error.
See <code>unmarked:::RMSE_MAE</code> for an example of correct statistic
function structure.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, run folds in parallel. This may speed up 
cross-validation if the unmarked model takes a long time to fit or you have 
a large number of sites and are using leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_ncores">ncores</code></td>
<td>
<p>Number of parallel cores to use.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_sort">sort</code></td>
<td>
<p>If doing cross-validation on a <code>fitList</code>, you can optionally
sort the resulting table(s) of statistic values for each model.</p>
</td></tr>
<tr><td><code id="crossVal_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the statistic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unmarkedCrossVal</code> or <code>unmarkedCrossValList</code> object containing
calculated statistic values for each fold.
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+fitList">fitList</a></code>,
<code><a href="#topic+unmarkedFit">unmarkedFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Get data
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)))    
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) * obsNum(pferUMF)))

#Fit occupancy model
fm &lt;- occu(~ obsvar1 ~ 1, pferUMF)

#k-fold cross validation with 10 folds
(kfold = crossVal(fm, method="Kfold", folds=10))

#holdout method with 25
(holdout = crossVal(fm,method='holdout', holdoutPct=0.25))

#Leave-one-out method
(leave = crossVal(fm, method='leaveOneOut'))

#Fit a second model and combine into a fitList
fm2 &lt;- occu(~1 ~1, pferUMF)
fl &lt;- fitList(fm2,fm)

#Cross-validation for all fits in fitList using holdout method
(cvlist &lt;- crossVal(fl, method='holdout'))


## End(Not run)
</code></pre>

<hr>
<h2 id='cruz'>
Landscape data for Santa Cruz Island
</h2><span id='topic+cruz'></span>

<h3>Description</h3>

<p>Spatially-referenced elevation, forest cover, and vegetation data for
Santa Cruz Island.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cruz)</code></pre>


<h3>Format</h3>

<p>A data frame with 2787 observations on the following 5 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>Easting (meters)</p>
</dd>
<dt><code>y</code></dt><dd><p>Northing (meters)</p>
</dd>
<dt><code>elevation</code></dt><dd><p>a numeric vector, FEET (multiply by 0.3048 to convert to meters) </p>
</dd>
<dt><code>forest</code></dt><dd><p>a numeric vector, proportion cover</p>
</dd>
<dt><code>chaparral</code></dt><dd><p>a numeric vector, proportion cover</p>
</dd>
</dl>



<h3>Details</h3>

<p>The resolution is 300x300 meters.
</p>
<p>The Coordinate system is EPSG number 26911
</p>
<p>NAD_1983_UTM_Zone_11N
Projection: Transverse_Mercator
False_Easting: 500000.000000
False_Northing: 0.000000
Central_Meridian: -117.000000
Scale_Factor: 0.999600
Latitude_Of_Origin: 0.000000
Linear Unit: Meter
GCS_North_American_1983
Datum: D_North_American_1983
</p>


<h3>Source</h3>

<p>Brian Cohen of the Nature Conservancy helped prepare the data
</p>


<h3>References</h3>

<p>Sillett, S. and Chandler, R.B. and Royle, J.A. and Kery, M. and
Morrison, S.A. In Press. Hierarchical distance sampling models to
estimate population size and habitat-specific abundance of an island
endemic. <em>Ecological Applications</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(lattice)
data(cruz)
str(cruz)

levelplot(elevation ~ x + y, cruz, aspect="iso",
    col.regions=terrain.colors(100))

if(require(raster)) {
elev &lt;- rasterFromXYZ(cruz[,1:3],
     crs="+proj=utm +zone=11 +ellps=GRS80 +datum=NAD83 +units=m +no_defs")
elev
plot(elev)
}

## End(Not run)



</code></pre>

<hr>
<h2 id='csvToUMF'>Convert .CSV File to an unmarkedFrame</h2><span id='topic+csvToUMF'></span>

<h3>Description</h3>

<p>This function converts an appropriatedly formated comma-separated
values file (.csv) to a format usable by <em>unmarked</em>'s fitting
functions (see <em>Details</em>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>csvToUMF(filename, long=FALSE, type, species, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csvToUMF_+3A_filename">filename</code></td>
<td>
<p>string describing filename of file to read in</p>
</td></tr>
<tr><td><code id="csvToUMF_+3A_long">long</code></td>
<td>
<p><code>FALSE</code> if file is in long format or <code>TRUE</code> if
file is in long format (see <em>Details</em>)</p>
</td></tr>
<tr><td><code id="csvToUMF_+3A_species">species</code></td>
<td>
<p>if data is in long format with multiple species, then
this can specify a particular species to extract if there is a
column named &quot;species&quot;.</p>
</td></tr>
<tr><td><code id="csvToUMF_+3A_type">type</code></td>
<td>
<p>specific type of unmarkedFrame.</p>
</td></tr>
<tr><td><code id="csvToUMF_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the unmarkedFrame constructor.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function provides a quick way to take a .csv file with headers
named as described below and provides the data required and returns of
data in the format required by the model-fitting functions in
<code><a href="#topic+unmarked">unmarked</a></code>.  The .csv file can be in one of 2 formats: long or
wide.  See the first 2 lines of the <em>examples</em> for what these
formats look like.
</p>
<p>The .csv file is formatted as follows:
</p>

<ul>
<li><p> col 1 is site labels.
</p>
</li>
<li><p> if data is in long format, col 2 is date of observation.
</p>
</li>
<li><p> next J columns are the observations (y) - counts or 0/1's.
</p>
</li>
<li><p> next is a series of columns for the site variables (one column
per variable).  The column header is the variable name.
</p>
</li>
<li><p> next is a series of columns for the observation-level variables.
These are in sets of J columns for each variable, e.g., var1-1 var1-2
var1-3 var2-1 var2-2 var2-3, etc.  The column header of the first
variable in each group must indicate the variable name.
</p>
</li></ul>


<h3>Value</h3>

<p>an unmarkedFrame object</p>


<h3>Author(s)</h3>

<p>Ian Fiske <a href="mailto:ianfiske@gmail.com">ianfiske@gmail.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># examine a correctly formatted long .csv
head(read.csv(system.file("csv","frog2001pcru.csv", package="unmarked")))

# examine a correctly formatted wide .csv
head(read.csv(system.file("csv","widewt.csv", package="unmarked")))

# convert them!
dat1 &lt;- csvToUMF(system.file("csv","frog2001pcru.csv", package="unmarked"),
                 long = TRUE, type = "unmarkedFrameOccu")
dat2 &lt;- csvToUMF(system.file("csv","frog2001pfer.csv", package="unmarked"),
                 long = TRUE, type = "unmarkedFrameOccu")
dat3 &lt;- csvToUMF(system.file("csv","widewt.csv", package="unmarked"),
                 long = FALSE, type = "unmarkedFrameOccu")
</code></pre>

<hr>
<h2 id='detFuns'>Distance-sampling detection functions and associated density functions</h2><span id='topic+detFuns'></span><span id='topic+gxhn'></span><span id='topic+gxexp'></span><span id='topic+gxhaz'></span><span id='topic+grhn'></span><span id='topic+grexp'></span><span id='topic+grhaz'></span><span id='topic+dxhn'></span><span id='topic+dxexp'></span><span id='topic+dxhaz'></span><span id='topic+drhn'></span><span id='topic+drexp'></span><span id='topic+drhaz'></span>

<h3>Description</h3>

<p>These functions represent the currently available detection
functions used for modeling line and point transect data with
<code><a href="#topic+distsamp">distsamp</a>. Detection functions begin with "g", and density
    functions begin with a "d".</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gxhn(x, sigma)
gxexp(x, rate)
gxhaz(x, shape, scale)

dxhn(x, sigma)
dxexp(x, rate)
dxhaz(x, shape, scale)
drhn(r, sigma)
drexp(r, rate)
drhaz(r, shape, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detFuns_+3A_x">x</code></td>
<td>
<p>Perpendicular distance</p>
</td></tr>
<tr><td><code id="detFuns_+3A_r">r</code></td>
<td>
<p>Radial distance</p>
</td></tr>
<tr><td><code id="detFuns_+3A_sigma">sigma</code></td>
<td>
<p>Shape parameter of half-normal detection function</p>
</td></tr>
<tr><td><code id="detFuns_+3A_rate">rate</code></td>
<td>
<p>Shape parameter of negative-exponential detection function</p>
</td></tr>
<tr><td><code id="detFuns_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of hazard-rate detection function</p>
</td></tr>
<tr><td><code id="detFuns_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of hazard-rate detection function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+distsamp">distsamp</a></code> for example of using these for plotting
detection function</p>


<h3>Examples</h3>

<pre><code class='language-R'># Detection probabilities at 25m for range of half-normal sigma values.
round(gxhn(25, 10:15), 2)

# Plot negative exponential distributions
plot(function(x) gxexp(x, rate=10), 0, 50, xlab="distance",
    ylab="Detection probability")
plot(function(x) gxexp(x, rate=20), 0, 50, add=TRUE, lty=2)
plot(function(x) gxexp(x, rate=30), 0, 50, add=TRUE, lty=3)

# Plot half-normal probability density functions for line- and point-transects
par(mfrow=c(2, 1))
plot(function(x) dxhn(x, 20), 0, 50, xlab="distance",
    ylab="Probability density", main="Line-transect")
plot(function(x) drhn(x, 20), 0, 50, xlab="distance",
    ylab="Probability density", main="Point-transect")
</code></pre>

<hr>
<h2 id='distsamp'>Fit the hierarchical distance sampling model of Royle et al. (2004)</h2><span id='topic+distsamp'></span>

<h3>Description</h3>

<p>Fit the hierarchical distance sampling model of Royle et al. (2004)
to line or point transect data recorded in discrete distance intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsamp(formula, data, keyfun=c("halfnorm", "exp",
  "hazard", "uniform"), output=c("density", "abund"),
  unitsOut=c("ha", "kmsq"), starts, method="BFGS", se=TRUE,
  engine=c("C", "R", "TMB"), rel.tol=0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distsamp_+3A_formula">formula</code></td>
<td>
<p>Double right-hand formula describing detection
covariates followed by abundance covariates. ~1 ~1 would be a null
model.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_data">data</code></td>
<td>
<p>object of class <code>unmarkedFrameDS</code>, containing response
matrix, covariates, distance interval cut points, survey type (&quot;line&quot;
or &quot;point&quot;), transect lengths (for survey = &quot;line&quot;), and units (&quot;m&quot;
or &quot;km&quot;) for cut points and transect lengths. See example for set up.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_keyfun">keyfun</code></td>
<td>
<p>One of the following detection functions:
&quot;halfnorm&quot;, &quot;hazard&quot;, &quot;exp&quot;, or &quot;uniform.&quot; See details.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_output">output</code></td>
<td>
<p>Model either &quot;density&quot; or &quot;abund&quot;</p>
</td></tr>
<tr><td><code id="distsamp_+3A_unitsout">unitsOut</code></td>
<td>
<p>Units of density. Either &quot;ha&quot; or &quot;kmsq&quot; for hectares and
square kilometers, respectively.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_starts">starts</code></td>
<td>
<p>Vector of starting values for parameters.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard errors.</p>
</td></tr>
<tr><td><code id="distsamp_+3A_engine">engine</code></td>
<td>
<p>Use code written in C++ or R</p>
</td></tr>
<tr><td><code id="distsamp_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Requested relative accuracy of the integral, see
<code><a href="stats.html#topic+integrate">integrate</a></code></p>
</td></tr>
<tr><td><code id="distsamp_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike conventional distance sampling, which uses the 'conditional on
detection' likelihood formulation, this model is based upon the
unconditional likelihood and allows for modeling both abundance and
detection  function parameters.
</p>
<p>The latent transect-level abundance distribution
<code class="reqn">f(N | \mathbf{\theta})</code> assumed to be
Poisson with mean <code class="reqn">\lambda</code> (but see <code><a href="#topic+gdistsamp">gdistsamp</a></code>
for alternatives).
</p>
<p>The detection process is modeled as multinomial:
<code class="reqn">y_{ij} \sim Multinomial(N_i, \pi_{ij})</code>,
where <code class="reqn">\pi_{ij}</code> is the multinomial cell probability for transect i in
distance class j. These are computed based upon a detection function
<code class="reqn">g(x | \mathbf{\sigma})</code>, such as the half-normal,
negative exponential, or hazard rate.
</p>
<p>Parameters <code class="reqn">\lambda</code> and <code class="reqn">\sigma</code> can be vectors
affected by transect-specific covariates using the log link.</p>


<h3>Value</h3>

<p>unmarkedFitDS object (child class of <code><a href="#topic+unmarkedFit-class">unmarkedFit-class</a></code>)
describing the model fit.</p>


<h3>Note</h3>

<p>You cannot use obsCovs.
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a></p>


<h3>References</h3>

<p>Royle, J. A., D. K. Dawson, and S. Bates (2004) Modeling
abundance effects in distance sampling. <em>Ecology</em> 85, pp. 1591-1597.
</p>
<p>Sillett, S. and Chandler, R.B. and Royle, J.A. and Kery, M. and
Morrison, S.A. In Press. Hierarchical distance sampling models to
estimate population size and habitat-specific abundance of an island
endemic. <em>Ecological Applications</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrameDS">unmarkedFrameDS</a></code>,
<code><a href="#topic+unmarkedFit-class">unmarkedFit-class</a></code> <code><a href="#topic+fitList">fitList</a></code>,
<code><a href="#topic+formatDistData">formatDistData</a></code>, <code><a href="#topic+parboot">parboot</a></code>,
<code><a href="#topic+sight2perpdist">sight2perpdist</a></code>, <code><a href="#topic+detFuns">detFuns</a></code>,
<code><a href="#topic+gdistsamp">gdistsamp</a></code>, <code><a href="#topic+ranef">ranef</a></code>.
Also look at vignette(&quot;distsamp&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Line transect examples

data(linetran)

ltUMF &lt;- with(linetran, {
   unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
   siteCovs = data.frame(Length, area, habitat),
   dist.breaks = c(0, 5, 10, 15, 20),
   tlength = linetran$Length * 1000, survey = "line", unitsIn = "m")
   })

ltUMF
summary(ltUMF)
hist(ltUMF)

# Half-normal detection function. Density output (log scale). No covariates.
(fm1 &lt;- distsamp(~ 1 ~ 1, ltUMF))

# Some methods to use on fitted model
summary(fm1)
backTransform(fm1, type="state")                # animals / ha
exp(coef(fm1, type="state", altNames=TRUE))     # same
backTransform(fm1, type="det")                  # half-normal SD
hist(fm1, xlab="Distance (m)")	# Only works when there are no det covars
# Empirical Bayes estimates of posterior distribution for N_i
plot(ranef(fm1, K=50))

# Effective strip half-width
(eshw &lt;- integrate(gxhn, 0, 20, sigma=10.9)$value)

# Detection probability
eshw / 20 # 20 is strip-width


# Halfnormal. Covariates affecting both density and and detection.
(fm2 &lt;- distsamp(~area + habitat ~ habitat, ltUMF))

# Hazard-rate detection function.
(fm3 &lt;- distsamp(~ 1 ~ 1, ltUMF, keyfun="hazard"))

# Plot detection function.
fmhz.shape &lt;- exp(coef(fm3, type="det"))
fmhz.scale &lt;- exp(coef(fm3, type="scale"))
plot(function(x) gxhaz(x, shape=fmhz.shape, scale=fmhz.scale), 0, 25,
	xlab="Distance (m)", ylab="Detection probability")



## Point transect examples

# Analysis of the Island Scrub-jay data.
# See Sillett et al. (In press)

data(issj)
str(issj)

jayumf &lt;- unmarkedFrameDS(y=as.matrix(issj[,1:3]),
 siteCovs=data.frame(scale(issj[,c("elevation","forest","chaparral")])),
 dist.breaks=c(0,100,200,300), unitsIn="m", survey="point")

(fm1jay &lt;- distsamp(~chaparral ~chaparral, jayumf))




## Not run: 

data(pointtran)

ptUMF &lt;- with(pointtran, {
	unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4, dc5),
	siteCovs = data.frame(area, habitat),
	dist.breaks = seq(0, 25, by=5), survey = "point", unitsIn = "m")
	})

# Half-normal.
(fmp1 &lt;- distsamp(~ 1 ~ 1, ptUMF))
hist(fmp1, ylim=c(0, 0.07), xlab="Distance (m)")

# effective radius
sig &lt;- exp(coef(fmp1, type="det"))
ea &lt;- 2*pi * integrate(grhn, 0, 25, sigma=sig)$value # effective area
sqrt(ea / pi) # effective radius

# detection probability
ea / (pi*25^2)


## End(Not run)
</code></pre>

<hr>
<h2 id='distsampOpen'>
Open population model for distance sampling data
</h2><span id='topic+distsampOpen'></span>

<h3>Description</h3>

<p>Fit the model of Dail and Madsen (2011) and Hostetler and Chandler
(2015) with a distance sampling observation model (Sollmann et al. 2015). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsampOpen(lambdaformula, gammaformula, omegaformula, pformula,
    data, keyfun=c("halfnorm", "exp", "hazard", "uniform"),
    output=c("abund", "density"), unitsOut=c("ha", "kmsq"),
    mixture=c("P", "NB", "ZIP"), K,
    dynamics=c("constant", "autoreg", "notrend", "trend", "ricker", "gompertz"),
    fix=c("none", "gamma", "omega"), immigration=FALSE, iotaformula = ~1,
    starts, method="BFGS", se=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distsampOpen_+3A_lambdaformula">lambdaformula</code></td>
<td>
<p>Right-hand sided formula for initial abundance</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_gammaformula">gammaformula</code></td>
<td>
<p>Right-hand sided formula for recruitment rate (when 
dynamics is &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot;) or population growth rate 
(when dynamics is &quot;trend&quot;, &quot;ricker&quot;, or &quot;gompertz&quot;)</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_omegaformula">omegaformula</code></td>
<td>
<p>Right-hand sided formula for apparent survival probability
(when dynamics is &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot;) or equilibrium
abundance (when dynamics is &quot;ricker&quot; or &quot;gompertz&quot;)</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_pformula">pformula</code></td>
<td>
<p>A right-hand side formula describing the detection 
function covariates</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_data">data</code></td>
<td>
<p>An object of class <code><a href="#topic+unmarkedFrameDSO">unmarkedFrameDSO</a></code></p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_keyfun">keyfun</code></td>
<td>
<p>One of the following detection functions: &quot;halfnorm&quot;, &quot;hazard&quot;, 
&quot;exp&quot;, or &quot;uniform&quot;</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_output">output</code></td>
<td>
<p>Model either &quot;density&quot; or &quot;abund&quot;</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_unitsout">unitsOut</code></td>
<td>
<p>Units of density. Either &quot;ha&quot; or &quot;kmsq&quot; for hectares and 
square kilometers, respectively</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_mixture">mixture</code></td>
<td>
<p>String specifying mixture: &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for
the Poisson, negative binomial, or zero-inflated Poisson
distributions respectively</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_k">K</code></td>
<td>
<p>Integer defining upper bound of discrete integration. This
should be higher than the maximum observed count and high enough
that it does not affect the parameter estimates. However, the higher
the value the slower the computation</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_dynamics">dynamics</code></td>
<td>
<p>Character string describing the type of population
dynamics. &quot;constant&quot; indicates that there is no relationship between
omega and gamma. &quot;autoreg&quot; is an auto-regressive model in which
recruitment is modeled as gamma*N[i,t-1]. &quot;notrend&quot; model gamma as
lambda*(1-omega) such that there is no temporal trend. &quot;trend&quot; is
a model for exponential growth, N[i,t] = N[i,t-1]*gamma, where gamma
in this case is finite rate of increase (normally referred to as
lambda). &quot;ricker&quot; and &quot;gompertz&quot; are models for density-dependent
population growth.  &quot;ricker&quot; is the Ricker-logistic model, N[i,t] =
N[i,t-1]*exp(gamma*(1-N[i,t-1]/omega)), where gamma is the maximum
instantaneous population growth rate (normally referred to as r) and
omega is the equilibrium abundance (normally referred to as K).  &quot;gompertz&quot;
is a modified version of the Gompertz-logistic model, N[i,t] =
N[i,t-1]*exp(gamma*(1-log(N[i,t-1]+1)/log(omega+1))), where the
interpretations of gamma and omega are similar to in the Ricker model</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_fix">fix</code></td>
<td>
<p>If &quot;omega&quot;, omega is fixed at 1. If &quot;gamma&quot;, gamma is fixed at 0</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_immigration">immigration</code></td>
<td>
<p>Logical specifying whether or not to include an immigration 
term (iota) in population dynamics</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_iotaformula">iotaformula</code></td>
<td>
<p>Right-hand sided formula for average number of immigrants 
to a site per time step</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_starts">starts</code></td>
<td>
<p>Vector of starting values</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_se">se</code></td>
<td>
<p>Logical specifying whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="distsampOpen_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These models generalize distance sampling models (Buckland et al. 2001) by
relaxing the closure assumption (Dail and Madsen 2011, Hostetler and Chandler
2015, Sollmann et al. 2015).
</p>
<p>The models include two or three additional parameters:
gamma, either the recruitment rate (births and immigrations), the
finite rate of increase, or the maximum instantaneous rate of increase;
omega, either the apparent survival rate (deaths and emigrations) or the
equilibrium abundance (carrying capacity); and iota, the number of immigrants
per site and year. Estimates of
population size at each time period can be derived from these
parameters, and thus so can trend estimates. Or, trend can be estimated
directly using dynamics=&quot;trend&quot;.
</p>
<p>When immigration is set to FALSE (the default), iota is not modeled.
When immigration is set to TRUE and dynamics is set to &quot;autoreg&quot;, the model
will separately estimate birth rate (gamma) and number of immigrants (iota).
When immigration is set to TRUE and dynamics is set to &quot;trend&quot;, &quot;ricker&quot;, or
&quot;gompertz&quot;, the model will separately estimate local contributions to
population growth (gamma and omega) and number of immigrants (iota).
</p>
<p>The latent abundance distribution, <code class="reqn">f(N | \mathbf{\theta})</code> can be set as a Poisson, negative binomial, or zero-inflated
Poisson random
variable, depending on the setting of the <code>mixture</code> argument,
<code>mixture = "P"</code>, <code>mixture = "NB"</code>, <code>mixture = "ZIP"</code>
respectively.  For the first two distributions, the mean of <code class="reqn">N_i</code> is
<code class="reqn">\lambda_i</code>.  If <code class="reqn">N_i \sim NB</code>, then an
additional parameter, <code class="reqn">\alpha</code>, describes dispersion (lower
<code class="reqn">\alpha</code> implies higher variance). For the ZIP distribution,
the mean is <code class="reqn">\lambda_i(1-\psi)</code>, where psi is the
zero-inflation parameter.
</p>
<p>For &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot; dynamics, the latent abundance state
following the initial sampling period arises
from a
Markovian process in which survivors are modeled as <code class="reqn">S_{it} \sim
Binomial(N_{it-1}, \omega_{it})</code>, and recruits
follow <code class="reqn">G_{it} \sim Poisson(\gamma_{it})</code>.
Alternative population dynamics can be specified
using the <code>dynamics</code> and <code>immigration</code> arguments.
</p>
<p><code class="reqn">\lambda_i</code>, <code class="reqn">\gamma_{it}</code>, and
<code class="reqn">\iota_{it}</code> are modeled 
using the the log link.
<code class="reqn">p_{ijt}</code> is modeled using
the logit link.
<code class="reqn">\omega_{it}</code> is either modeled using the logit link (for
&quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot; dynamics) or the log link (for &quot;ricker&quot;
or &quot;gompertz&quot; dynamics).  For &quot;trend&quot; dynamics, <code class="reqn">\omega_{it}</code>
is not modeled.
</p>
<p>For the distance sampling detection process, half-normal (<code>"halfnorm"</code>), 
exponential (<code>"exp"</code>), hazard (<code>"hazard"</code>), and uniform
(<code>"uniform"</code>) key functions are available.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitDSO</p>


<h3>Warning</h3>

<p>This function can be extremely slow, especially if
there are covariates of gamma or omega. Consider testing the timing on
a small subset of the data, perhaps with se=FALSE. Finding the lowest
value of K that does not affect estimates will also help with speed. </p>


<h3>Note</h3>

<p>When gamma or omega are modeled using year-specific covariates, the
covariate data for the final year will be ignored; however,
they must be supplied.
</p>
<p>If the time gap between primary periods is not constant, an M by T
matrix of integers should be supplied to <code><a href="#topic+unmarkedFrameDSO">unmarkedFrameDSO</a></code>
using the <code>primaryPeriod</code> argument.
</p>
<p>Secondary sampling periods are optional, but can greatly improve the
precision of the estimates.
</p>
<p>Optimization may fail if the initial value of the intercept for the 
detection parameter (sigma) is too small or large relative to transect width.
By default, this parameter is initialized at log(average band width).
You may have to adjust this starting value.
</p>


<h3>Author(s)</h3>

<p>Richard Chandler, Jeff Hostetler, Andy Royle, Ken Kellner</p>


<h3>References</h3>

<p>Buckland, S.T., Anderson, D.R., Burnham, K.P., Laake, J.L., Borchers, D.L. 
and Thomas, L. (2001) <em>Introduction to Distance Sampling: Estimating 
Abundance of Biological Populations</em>. Oxford University Press, Oxford, UK.
</p>
<p>Dail, D. and L. Madsen (2011) Models for Estimating Abundance from
Repeated Counts of an Open Metapopulation. <em>Biometrics</em>. 67: 577-587.
</p>
<p>Hostetler, J. A. and R. B. Chandler (2015) Improved State-space Models for
Inference about Spatial and Temporal Variation in Abundance from Count Data.
<em>Ecology</em> 96: 1713-1723.
</p>
<p>Sollmann, R., Gardner, B., Chandler, R.B., Royle, J.A. and Sillett, T.S. 
(2015) An open-population hierarchical distance sampling model. 
<em>Ecology</em> 96: 325-331.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distsamp">distsamp</a>, <a href="#topic+gdistsamp">gdistsamp</a>, <a href="#topic+unmarkedFrameDSO">unmarkedFrameDSO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  ## Not run: 
  
  #Generate some data 
  set.seed(123)
  lambda=4; gamma=0.5; omega=0.8; sigma=25; 
  M=100; T=10; J=4
  y &lt;- array(NA, c(M, J, T))
  N &lt;- matrix(NA, M, T)
  S &lt;- G &lt;- matrix(NA, M, T-1)
  db &lt;- c(0, 25, 50, 75, 100)

  #Half-normal, line transect
  g &lt;- function(x, sig) exp(-x^2/(2*sig^2))

  cp &lt;- u &lt;- a &lt;- numeric(J)
  L &lt;-  1
  a[1] &lt;- L*db[2]
  cp[1] &lt;- integrate(g, db[1], db[2], sig=sigma)$value
  for(j in 2:J) {
    a[j] &lt;-  db[j+1]  - sum(a[1:j])
    cp[j] &lt;- integrate(g, db[j], db[j+1], sig=sigma)$value
  }
  u &lt;- a / sum(a)
  cp &lt;- cp / a * u
  cp[j+1] &lt;- 1-sum(cp)

  for(i in 1:M) {
    N[i,1] &lt;- rpois(1, lambda)
    y[i,1:J,1] &lt;- rmultinom(1, N[i,1], cp)[1:J]

    for(t in 1:(T-1)) {
        S[i,t] &lt;- rbinom(1, N[i,t], omega)
        G[i,t] &lt;- rpois(1, gamma)
        N[i,t+1] &lt;- S[i,t] + G[i,t]
        y[i,1:J,t+1] &lt;- rmultinom(1, N[i,t+1], cp)[1:J]
        }
  }
  y &lt;- matrix(y, M)
 
  #Make a covariate
  sc &lt;- data.frame(x1 = rnorm(M))

  umf &lt;- unmarkedFrameDSO(y = y, siteCovs=sc, numPrimary=T, dist.breaks=db, 
                          survey="line", unitsIn="m", tlength=rep(1, M))

  (fit &lt;- distsampOpen(~x1, ~1, ~1, ~1, data = umf, K=50, keyfun="halfnorm"))
  
  #Compare to truth
  cf &lt;- coef(fit)
  data.frame(model=c(exp(cf[1]), cf[2], exp(cf[3]), plogis(cf[4]), exp(cf[5])), 
             truth=c(lambda, 0, gamma, omega, sigma))

  #Predict
  head(predict(fit, type='lambda'))

  #Check fit with parametric bootstrap
  pb &lt;- parboot(fit, nsims=15)
  plot(pb)
  
  # Empirical Bayes estimates of abundance for each site / year
  re &lt;- ranef(fit)
  plot(re, layout=c(10,5), xlim=c(-1, 10))
 
  
## End(Not run) 
</code></pre>

<hr>
<h2 id='fitList'>constructor of unmarkedFitList objects</h2><span id='topic+fitList'></span>

<h3>Description</h3>

<p>Organize models for model selection or model-averaged prediction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitList(..., fits, autoNames=c("object", "formula"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitList_+3A_...">...</code></td>
<td>
<p>Fitted models. Preferrably named.</p>
</td></tr>
<tr><td><code id="fitList_+3A_fits">fits</code></td>
<td>
<p>An alternative way of providing the models. A (preferrably named) list of fitted models.</p>
</td></tr>
<tr><td><code id="fitList_+3A_autonames">autoNames</code></td>
<td>
<p>Option to change the names <code>unmarked</code> assigns to models if you don't name them yourself. If <code>autoNames="object"</code>, models in the <code>fitList</code> will be named based on their R object names.  If <code>autoNames="formula"</code>, the models will instead be named based on their formulas. This is not possible for some model types.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Two requirements exist to conduct AIC-based model-selection and model-averaging in unmarked. First, the data objects (ie, unmarkedFrames) must be identical among fitted models. Second, the response matrix must be identical among fitted models after missing values have been removed. This means that if a response value was removed in one model due to missingness, it needs to be removed from all models.
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(linetran)
(dbreaksLine &lt;- c(0, 5, 10, 15, 20)) 
lengths &lt;- linetran$Length * 1000

ltUMF &lt;- with(linetran, {
	unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4), 
	siteCovs = data.frame(Length, area, habitat), dist.breaks = dbreaksLine,
	tlength = lengths, survey = "line", unitsIn = "m")
	})

fm1 &lt;- distsamp(~ 1 ~1, ltUMF)
fm2 &lt;- distsamp(~ area ~1, ltUMF)
fm3 &lt;- distsamp( ~ 1 ~area, ltUMF)

## Two methods of creating an unmarkedFitList using fitList()

# Method 1
fmList &lt;- fitList(Null=fm1, .area=fm2, area.=fm3)

# Method 2. Note that the arugment name "fits" must be included in call.
models &lt;- list(Null=fm1, .area=fm2, area.=fm3)
fmList &lt;- fitList(fits = models)

# Extract coefficients and standard errors
coef(fmList)
SE(fmList)

# Model-averaged prediction
predict(fmList, type="state")

# Model selection
modSel(fmList, nullmod="Null")
</code></pre>

<hr>
<h2 id='fitted-methods'>Methods for Function fitted in Package &lsquo;unmarked&rsquo;</h2><span id='topic+fitted-methods'></span><span id='topic+fitted+2CunmarkedFit-method'></span><span id='topic+fitted+2CunmarkedFitColExt-method'></span><span id='topic+fitted+2CunmarkedFitOccu-method'></span><span id='topic+fitted+2CunmarkedFitOccuFP-method'></span><span id='topic+fitted+2CunmarkedFitOccuRN-method'></span><span id='topic+fitted+2CunmarkedFitOccuMulti-method'></span><span id='topic+fitted+2CunmarkedFitOccuMS-method'></span><span id='topic+fitted+2CunmarkedFitOccuTTD-method'></span><span id='topic+fitted+2CunmarkedFitNmixTTD-method'></span><span id='topic+fitted+2CunmarkedFitPCount-method'></span><span id='topic+fitted+2CunmarkedFitDS-method'></span><span id='topic+fitted+2CunmarkedFitGMM-method'></span><span id='topic+fitted+2CunmarkedFitGDR-method'></span><span id='topic+fitted+2CunmarkedFitDailMadsen-method'></span><span id='topic+fitted+2CunmarkedFitGOccu-method'></span><span id='topic+fitted+2CunmarkedFitOccuCOP-method'></span>

<h3>Description</h3>

<p>Extracted fitted values from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFit'
fitted(object, na.rm = FALSE)
## S4 method for signature 'unmarkedFitColExt'
fitted(object, na.rm = FALSE)
## S4 method for signature 'unmarkedFitOccu'
fitted(object, na.rm = FALSE)
## S4 method for signature 'unmarkedFitOccuRN'
fitted(object, K, na.rm = FALSE)
## S4 method for signature 'unmarkedFitPCount'
fitted(object, K, na.rm = FALSE)
## S4 method for signature 'unmarkedFitDS'
fitted(object, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted-methods_+3A_object">object</code></td>
<td>
<p>A fitted model of appropriate S4 class</p>
</td></tr>
<tr><td><code id="fitted-methods_+3A_k">K</code></td>
<td>
<p>Integer specifying upper bound of integration.</p>
</td></tr>
<tr><td><code id="fitted-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should missing values be removed from data?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of expected values</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;unmarkedFit&quot;</dt><dd><p>A fitted model</p>
</dd>
<dt>object = &quot;unmarkedFitColExt&quot;</dt><dd><p>A model fit by <code><a href="#topic+colext">colext</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitOccu&quot;</dt><dd><p>A model fit by <code><a href="#topic+occu">occu</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitOccuRN&quot;</dt><dd><p>A model fit by <code><a href="#topic+occuRN">occuRN</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitPCount&quot;</dt><dd><p>A model fit by <code><a href="#topic+pcount">pcount</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitDS&quot;</dt><dd><p>A model fit by <code><a href="#topic+distsamp">distsamp</a></code></p>
</dd>
</dl>

<hr>
<h2 id='formatDistData'>Bin distance data</h2><span id='topic+formatDistData'></span>

<h3>Description</h3>

<p>Convert individual-level distance data to the transect-level
format required by <code><a href="#topic+distsamp">distsamp</a></code> or <code><a href="#topic+gdistsamp">gdistsamp</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>formatDistData(distData, distCol, transectNameCol, dist.breaks,
                      occasionCol, effortMatrix)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatDistData_+3A_distdata">distData</code></td>
<td>
<p>data.frame where each row is a detected individual.
Must have at least 2 columns. One for distances and the other for
transect names.</p>
</td></tr>
<tr><td><code id="formatDistData_+3A_distcol">distCol</code></td>
<td>
<p>character, name of the column in distData that contains
the distances. The distances should be numeric.</p>
</td></tr>
<tr><td><code id="formatDistData_+3A_transectnamecol">transectNameCol</code></td>
<td>
<p>character, column name containing transect
names. The transect column should be a factor.</p>
</td></tr>
<tr><td><code id="formatDistData_+3A_dist.breaks">dist.breaks</code></td>
<td>
<p>numeric vector of distance interval cutpoints. Length
must equal J+1.</p>
</td></tr>
<tr><td><code id="formatDistData_+3A_occasioncol">occasionCol</code></td>
<td>
<p>optional character. If transects were visited more
than once, this can be used to format data for <code>gdistsamp</code>. It is
the name of the column in distData that contains the occasion
numbers. The occasion column should be a factor.</p>
</td></tr>
<tr><td><code id="formatDistData_+3A_effortmatrix">effortMatrix</code></td>
<td>
<p>optional matrix of 1 and 0s that is M * T in size and will allow for the insertion of NAs where the matrix = 0, indicating that a survey was not completed. When not supplied a matrix of all 1s is created since it is assumed all surveys were completed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a site (M) by distance interval (J) response
matrix from a data.frame containing the detection distances for each
individual and the transect names. Alternatively, if each transect was
surveyed T times, the resulting matrix is M x JT, which is the format
required by <code><a href="#topic+gdistsamp">gdistsamp</a></code>, see<code><a href="#topic+unmarkedFrameGDS">unmarkedFrameGDS</a></code>.</p>


<h3>Value</h3>

<p>An M x J or M x JT matrix containing the binned distance
data. Transect  names will become rownames and colnames will describe
the distance intervals.</p>


<h3>Note</h3>

<p>It is important that the factor containing transect names includes
levels for all the transects surveyed, not just those with &gt;=1
detection. Likewise, if transects were visited more than once, the
factor containing the occasion numbers should include levels for all
occasions. See the example for how to add levels to a factor.</p>


<h3>See Also</h3>

<p><code><a href="#topic+distsamp">distsamp</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a data.frame containing distances of animals detected
# along 4 transects.
dat &lt;- data.frame(transect=gl(4,5, labels=letters[1:4]),
                  distance=rpois(20, 10))
dat

# Look at your transect names.
levels(dat$transect)

# Suppose that you also surveyed a transect named "e" where no animals were
# detected. You must add it to the levels of dat$transect
levels(dat$transect) &lt;- c(levels(dat$transect), "e")
levels(dat$transect)

# Distance cut points defining distance intervals
cp &lt;- c(0, 8, 10, 12, 14, 18)

# Create formated response matrix
yDat &lt;- formatDistData(dat, "distance", "transect", cp)
yDat

# Now you could merge yDat with transect-level covariates and
# then use unmarkedFrameDS to prepare data for distsamp


## Example for data from multiple occasions

dat2 &lt;- data.frame(distance=1:100, site=gl(5, 20),
                   visit=factor(rep(1:4, each=5)))
cutpt &lt;- seq(0, 100, by=25)
y2 &lt;- formatDistData(dat2, "distance", "site", cutpt, "visit")
umf &lt;- unmarkedFrameGDS(y=y2, numPrimary=4, survey="point",
                        dist.breaks=cutpt, unitsIn="m")
 ## Example for datda from multiple occasions with effortMatrix
 
 dat3 &lt;-  data.frame(distance=1:100, site=gl(5, 20), visit=factor(rep(1:4, each=5)))
 cutpt &lt;- seq(0, 100, by=25)
 
 effortMatrix &lt;- matrix(ncol=4, nrow=5, rbinom(20,1,0.8))
 
 y3 &lt;- formatDistData(dat2, "distance", "site", cutpt, "visit", effortMatrix)
 </code></pre>

<hr>
<h2 id='formatMult'>Create unmarkedMultFrame from Long Format Data Frame</h2><span id='topic+formatMult'></span>

<h3>Description</h3>

<p>This convenience function converts multi-year data in long format to unmarkedMultFrame Object.  See Details for more information.</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatMult(df.in)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatMult_+3A_df.in">df.in</code></td>
<td>
<p>a data.frame appropriately formatted (see Details).</p>
</td></tr></table>


<h3>Details</h3>

<p><code>df.in</code> is a data frame with columns formatted as follows:
</p>
<p>Column 1 = year number <br />
Column 2 = site name or number <br />
Column 3 = julian date or chronological sample number during year <br />
Column 4 = observations (y) <br />
Column 5 &ndash; Final Column = covariates 
</p>
<p>Note that if the data is already in wide format, it may be easier to create an unmarkedMultFrame object
directly with a call to <code><a href="#topic+unmarkedMultFrame">unmarkedMultFrame</a></code>.</p>


<h3>Value</h3>

<p>unmarkedMultFrame object</p>

<hr>
<h2 id='formatWideLong'>
Convert between wide and long data formats.
</h2><span id='topic+formatWide'></span><span id='topic+formatLong'></span>

<h3>Description</h3>

<p>Convert a data.frame between wide and long formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatWide(dfin, sep = ".", obsToY, type, ...)
formatLong(dfin, species = NULL, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatWideLong_+3A_dfin">dfin</code></td>
<td>
<p>A data.frame to be reformatted.
</p>
</td></tr>
<tr><td><code id="formatWideLong_+3A_sep">sep</code></td>
<td>
<p>A seperator of column names in wide format.
</p>
</td></tr>
<tr><td><code id="formatWideLong_+3A_obstoy">obsToY</code></td>
<td>
<p>Optional matrix specifying relationship between covariate
column structure and response matrix structure.
</p>
</td></tr>
<tr><td><code id="formatWideLong_+3A_type">type</code></td>
<td>
<p>Type of unmarkedFrame to create?
</p>
</td></tr>
<tr><td><code id="formatWideLong_+3A_species">species</code></td>
<td>
<p>Character name of species response column
</p>
</td></tr>
<tr><td><code id="formatWideLong_+3A_...">...</code></td>
<td>
<p>Further arguments to the unmarkedFrame* constructor functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that not all possible <code>unmarkedFrame</code>* classes have been tested with these
functions. Multinomial data sets (e.g., removal, double-observer, capture-recapture)
are almost certainly easier to enter directly to the constructor function and are not
supported by <code>formatLong</code> or <code>formatWide</code>.
</p>
<p>In order for these functions to work, the columns of <code>dfin</code> need to be in the
correct order.  <code>formatLong</code> requires that the columns are in the
following scheme:
</p>

<ol>
<li><p> site name or number.
</p>
</li>
<li><p> date or observation number.
</p>
</li>
<li><p> response variable (detections, counts, etc).
</p>
</li>
<li><p> The remaining columns are observation-level covariates.
</p>
</li></ol>

<p><code>formatWide</code> requires particular names for the columns.
The column order for <code>formatWide</code> is
</p>

<ol>
<li><p> (optional) site name, named &ldquo;site&rdquo;.
</p>
</li>
<li><p> response, named &ldquo;y.1&rdquo;, &ldquo;y.2&rdquo;, ..., &ldquo;y.J&rdquo;.
</p>
</li>
<li><p> columns of site-level covariates, each with a relevant name per column.
</p>
</li>
<li><p> groups of columns of observation-level covariates, each group
having the name form &ldquo;someObsCov.1&rdquo;, &ldquo;someObsCov.2&rdquo;,
...,
&ldquo;someObsCov.J&rdquo;.
</p>
</li></ol>



<h3>Value</h3>

<p>A data.frame</p>


<h3>See Also</h3>

<p><code><a href="#topic+csvToUMF">csvToUMF</a></code>
</p>

<hr>
<h2 id='frogs'> 2001 Delaware North American Amphibian Monitoring Program Data </h2><span id='topic+frogs'></span><span id='topic+pcru.data'></span><span id='topic+pcru.bin'></span><span id='topic+pcru.y'></span><span id='topic+pfer.data'></span><span id='topic+pfer.bin'></span><span id='topic+pfer.y'></span><span id='topic+frog2001pfer'></span><span id='topic+frog2001pcru'></span>

<h3>Description</h3>

<p>frogs contains NAAMP data for Pseudacris feriarum (pfer) and Pseudacris
crucifer (pcru) in 2001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(frogs)</code></pre>


<h3>Format</h3>


<dl>
<dt>pcru.y</dt><dd><p>matrix of observed calling indices for pcru</p>
</dd>
<dt>pcru.bin</dt><dd><p>matrix of detections for pcru</p>
</dd>
<dt>pcru.data</dt><dd><p>array of covariates measured at the
observation-level for pcru</p>
</dd>
<dt>pfer.y</dt><dd><p>matrix of observed calling indices for pfer</p>
</dd>
<dt>pfer.bin</dt><dd><p>matrix of detections for pfer</p>
</dd>
<dt>pfer.data</dt><dd><p>array of covariates measured at the
observation-level for pfer</p>
</dd>
</dl>



<h3>Details</h3>

<p>The rows of pcru.y, pcru.bin, pfer.y, and pfer.bin correspond to sites
and columns correspond to visits to each site.  The first 2 dimensions
of pfer.data and pcru.data are matrices of covariates that correspond to
the observation matrices (sites <code class="reqn">\times</code> observation), with the 3rd
dimension corresponding to separate covariates.
</p>


<h3>Source</h3>

<p>https://www.pwrc.usgs.gov/naamp/
</p>


<h3>References</h3>

<p>Mossman MJ, Weir LA. North American Amphibian Monitoring Program (NAAMP). Amphibian Declines: the conservation status of United States species. University of California Press, Berkeley, California, USA. 2005:307-313.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(frogs)
str(pcru.data)
</code></pre>

<hr>
<h2 id='gdistremoval'>
Fit the combined distance and removal model of Amundson et al. (2014).
</h2><span id='topic+gdistremoval'></span>

<h3>Description</h3>

<p>Fit the model of Amundson et al. (2014) to point count datasets containing
both distance and time of observation data. The Amundson et al. (2014) model
is extended to account for temporary emigration by estimating an additional
availability probability if multiple counts at a site are available.
Abundance can be modeled as a Poisson, negative binomial, or Zero-inflated Poisson.
Multiple distance sampling key functions are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdistremoval(lambdaformula=~1, phiformula=~1, removalformula=~1,
  distanceformula=~1, data, keyfun=c("halfnorm", "exp", "hazard", "uniform"),
  output=c("abund", "density"), unitsOut=c("ha", "kmsq"), mixture=c('P', 'NB', 'ZIP'), 
  K, starts, method = "BFGS", se = TRUE, engine=c("C","TMB"), threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdistremoval_+3A_lambdaformula">lambdaformula</code></td>
<td>
<p>A right-hand side formula describing the abundance covariates</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_phiformula">phiformula</code></td>
<td>
<p>A right-hand side formula describing the availability covariates</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_removalformula">removalformula</code></td>
<td>
<p>A right-hand side formula describing removal probability covariates</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_distanceformula">distanceformula</code></td>
<td>
<p>A right-hand side formula describing the detection function covariates</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_data">data</code></td>
<td>
<p>An object of class <code>unmarkedFrameGDR</code></p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_keyfun">keyfun</code></td>
<td>
<p>One of the following detection functions: &quot;halfnorm&quot;, &quot;hazard&quot;, &quot;exp&quot;,
or &quot;uniform&quot;</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_output">output</code></td>
<td>
<p>Model either &quot;abund&quot; or &quot;density&quot;</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_unitsout">unitsOut</code></td>
<td>
<p>Units of density. Either &quot;ha&quot; or &quot;kmsq&quot; for hectares and square
kilometers, respectively</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_mixture">mixture</code></td>
<td>
<p>Either &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for the Poisson, negative binomial,
and Zero-inflated Poisson models of abundance</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_k">K</code></td>
<td>
<p>An integer value specifying the upper bound used in the integration</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_starts">starts</code></td>
<td>
<p>A numeric vector of starting values for the model parameters</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; to use C++ code or &quot;TMB&quot; to use TMB for optimization</p>
</td></tr>
<tr><td><code id="gdistremoval_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled</p>
</td></tr> 
<tr><td><code id="gdistremoval_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper bounds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class unmarkedFitGDR</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>Amundson, C.L., Royle, J.A. and Handel, C.M., 2014. A hierarchical model 
combining distance sampling and time removal to estimate detection probability 
during avian point counts. The Auk 131: 476-494.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrameGDR">unmarkedFrameGDR</a></code>, <code><a href="#topic+gdistsamp">gdistsamp</a></code>, <code><a href="#topic+gmultmix">gmultmix</a></code></p>

<hr>
<h2 id='gdistsamp'>
Fit the generalized distance sampling model of Chandler et al. (2011).
</h2><span id='topic+gdistsamp'></span>

<h3>Description</h3>

<p>Extends the distance sampling model of Royle et al. (2004) to estimate
the probability of being available for detection. Also allows abundance
to be modeled using the negative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdistsamp(lambdaformula, phiformula, pformula, data, keyfun =
c("halfnorm", "exp", "hazard", "uniform"), output = c("abund",
"density"), unitsOut = c("ha", "kmsq"), mixture = c("P", "NB", "ZIP"), K,
starts, method = "BFGS", se = TRUE, engine=c("C","R"), rel.tol=1e-4, threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdistsamp_+3A_lambdaformula">lambdaformula</code></td>
<td>

<p>A right-hand side formula describing the abundance covariates.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_phiformula">phiformula</code></td>
<td>

<p>A right-hand side formula describing the availability covariates.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_pformula">pformula</code></td>
<td>

<p>A right-hand side formula describing the detection function covariates.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_data">data</code></td>
<td>

<p>An object of class <code>unmarkedFrameGDS</code>
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_keyfun">keyfun</code></td>
<td>

<p>One of the following detection functions: &quot;halfnorm&quot;, &quot;hazard&quot;, &quot;exp&quot;,
or &quot;uniform.&quot; See details.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_output">output</code></td>
<td>

<p>Model either &quot;density&quot; or &quot;abund&quot;
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_unitsout">unitsOut</code></td>
<td>

<p>Units of density. Either &quot;ha&quot; or &quot;kmsq&quot; for hectares and square
kilometers, respectively.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_mixture">mixture</code></td>
<td>

<p>Either &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for the Poisson, negative binomial, or
zero-inflated Poisson models of abundance.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_k">K</code></td>
<td>

<p>An integer value specifying the upper bound used in the integration.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_starts">starts</code></td>
<td>

<p>A numeric vector of starting values for the model parameters.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_method">method</code></td>
<td>

<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_se">se</code></td>
<td>

<p>logical specifying whether or not to compute standard errors.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_engine">engine</code></td>
<td>

<p>Either &quot;C&quot; to use fast C++ code or &quot;R&quot; to use native R code during the 
optimization.
</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative accuracy for the integration of the detection function.
See <a href="stats.html#topic+integrate">integrate</a>. You might try adjusting this if you get an error
message related to the integral. Alternatively, try providing
different starting values.</p>
</td></tr>
<tr><td><code id="gdistsamp_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.</p>
</td></tr> 
<tr><td><code id="gdistsamp_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model extends the model of Royle et al. (2004) by estimating the
probability of being available for detection <code class="reqn">\phi</code>. This
effectively relaxes the assumption that <code class="reqn">g(0)=1</code>. In other words,
inividuals at a distance of 0 are not assumed to be detected with
certainty. To estimate this additional parameter, replicate distance
sampling data must be collected at each transect. Thus the data are
collected at i = 1, 2, ..., R transects on t = 1, 2, ..., T
occassions. As with the model of Royle et al. (2004), the detections
must be binned into distance classes. These data must be formatted in
a matrix with R rows, and JT columns where J is the number of distance
classses. See <code><a href="#topic+unmarkedFrameGDS">unmarkedFrameGDS</a></code> for more information.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitGDS.
</p>


<h3>Note</h3>

<p>If you aren't interested in estimating phi, but you want to
use the negative binomial distribution, simply set numPrimary=1 when
formatting the data.
</p>


<h3>Note</h3>

<p>You cannot use obsCovs, but you can use yearlySiteCovs (a confusing name
since this model isn't for multi-year data. It's just a hold-over
from the colext methods of formatting data upon which it is based.)
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a>
</p>


<h3>References</h3>

<p>Royle, J. A., D. K. Dawson, and S. Bates. 2004. Modeling
abundance effects in distance sampling. <em>Ecology</em>
85:1591-1597.
</p>
<p>Chandler, R. B, J. A. Royle, and D. I. King. 2011. Inference about
density and temporary emigration in unmarked
populations. <em>Ecology</em>  92:1429&ndash;1435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distsamp">distsamp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Simulate some line-transect data

set.seed(36837)

R &lt;- 50 # number of transects
T &lt;- 5  # number of replicates
strip.width &lt;- 50
transect.length &lt;- 100
breaks &lt;- seq(0, 50, by=10)

lambda &lt;- 5 # Abundance
phi &lt;- 0.6  # Availability
sigma &lt;- 30 # Half-normal shape parameter

J &lt;- length(breaks)-1
y &lt;- array(0, c(R, J, T))
for(i in 1:R) {
    M &lt;- rpois(1, lambda) # Individuals within the 1-ha strip
    for(t in 1:T) {
        # Distances from point
        d &lt;- runif(M, 0, strip.width)
        # Detection process
        if(length(d)) {
            cp &lt;- phi*exp(-d^2 / (2 * sigma^2)) # half-normal w/ g(0)&lt;1
            d &lt;- d[rbinom(length(d), 1, cp) == 1]
            y[i,,t] &lt;- table(cut(d, breaks, include.lowest=TRUE))
            }
        }
    }
y &lt;- matrix(y, nrow=R) # convert array to matrix

# Organize data
umf &lt;- unmarkedFrameGDS(y = y, survey="line", unitsIn="m",
    dist.breaks=breaks, tlength=rep(transect.length, R), numPrimary=T)
summary(umf)


# Fit the model
m1 &lt;- gdistsamp(~1, ~1, ~1, umf, output="density", K=50)

summary(m1)


backTransform(m1, type="lambda")
backTransform(m1, type="phi")
backTransform(m1, type="det")

## Not run: 
# Empirical Bayes estimates of abundance at each site
re &lt;- ranef(m1)
plot(re, layout=c(10,5), xlim=c(-1, 20))

## End(Not run)

</code></pre>

<hr>
<h2 id='getB-methods'>Methods for Function getB in Package &lsquo;unmarked&rsquo;</h2><span id='topic+getB'></span><span id='topic+getB-methods'></span><span id='topic+getB+2CunmarkedFitOccuFP-method'></span>

<h3>Description</h3>

<p>Methods for function <code>getB</code> in Package &lsquo;unmarked&rsquo;. These methods
return a matrix of probabilities detections were certain for occupancy
models that account for false positives.
</p>

<hr>
<h2 id='getFP-methods'>Methods for Function getFP in Package &lsquo;unmarked&rsquo;</h2><span id='topic+getFP'></span><span id='topic+getFP-methods'></span><span id='topic+getFP+2CunmarkedFitOccuFP-method'></span>

<h3>Description</h3>

<p>Methods for function <code>getFP</code> in Package &lsquo;unmarked&rsquo;. These methods
return a matrix of false positive detection probabilities.
</p>

<hr>
<h2 id='getP-methods'>Methods for Function getP in Package &lsquo;unmarked&rsquo;</h2><span id='topic+getP'></span><span id='topic+getP-methods'></span><span id='topic+getP+2CunmarkedFit-method'></span><span id='topic+getP+2CunmarkedFitOccuFP-method'></span><span id='topic+getP+2CunmarkedFitOccuMulti-method'></span><span id='topic+getP+2CunmarkedFitOccuMS-method'></span><span id='topic+getP+2CunmarkedFitOccuTTD-method'></span><span id='topic+getP+2CunmarkedFitDS-method'></span><span id='topic+getP+2CunmarkedFitMPois-method'></span><span id='topic+getP+2CunmarkedFitColExt-method'></span><span id='topic+getP+2CunmarkedFitPCO-method'></span><span id='topic+getP+2CunmarkedFitGMM-method'></span><span id='topic+getP+2CunmarkedFitGDS-method'></span><span id='topic+getP+2CunmarkedFitGPC-method'></span><span id='topic+getP+2CunmarkedFitDSO-method'></span><span id='topic+getP+2CunmarkedFitMMO-method'></span><span id='topic+getP+2CunmarkedFitGDR-method'></span><span id='topic+getP+2CunmarkedFitGOccu-method'></span><span id='topic+getP+2CunmarkedFitOccuCOP-method'></span>

<h3>Description</h3>

<p>Methods for function <code>getP</code> in Package &lsquo;unmarked&rsquo;. These methods return a matrix of the back-transformed detection parameter (<code class="reqn">p</code> the detection probability or <code class="reqn">\lambda</code> the detection rate, depending on the model). The matrix is of dimension MxJ, with M the number of sites and J the number of sampling periods; or of dimension MxJT for models with multiple primary periods T.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "unmarkedFit")</code></dt><dd><p>A fitted model object</p>
</dd>
<dt><code>signature(object = "unmarkedFitDS")</code></dt><dd><p>A fitted model object</p>
</dd>
<dt><code>signature(object = "unmarkedFitMPois")</code></dt><dd><p>A fitted model object</p>
</dd>
<dt><code>signature(object = "unmarkedFitGMM")</code></dt><dd><p>A fitted model object</p>
</dd>
<dt><code>signature(object = "unmarkedFitOccuCOP")</code></dt><dd><p>With <code>unmarkedFitOccuCOP</code> the object of a model fitted with <code>occuCOP</code>. Returns a matrix of <code class="reqn">\lambda</code> the detection rate.</p>
</dd>
</dl>

<hr>
<h2 id='gf'> Green frog count index data</h2><span id='topic+gf'></span><span id='topic+gf.data'></span><span id='topic+gf.obs'></span>

<h3>Description</h3>

<p>Multinomial calling index data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gf)</code></pre>


<h3>Format</h3>

<p>A list with 2 components
</p>

<dl>
<dt>gf.data</dt><dd><p>220 x 3 matrix of count indices</p>
</dd>
<dt>gf.obs</dt><dd><p>list of covariates</p>
</dd>
</dl>



<h3>References</h3>

<p>Royle, J. Andrew, and William A. Link. 2005. A General Class of Multinomial
Mixture Models for Anuran Calling Survey Data. Ecology 86, no. 9: 2505&ndash;2512.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gf)
str(gf.data)
str(gf.obs)
</code></pre>

<hr>
<h2 id='gmultmix'>Generalized multinomial N-mixture model</h2><span id='topic+gmultmix'></span>

<h3>Description</h3>

<p>A three level hierarchical model for designs involving
repeated counts that yield multinomial outcomes.  Possible data collection
methods include repeated removal sampling and double observer sampling.
The three model parameters are abundance, availability, and detection
probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmultmix(lambdaformula, phiformula, pformula, data, mixture = c("P", "NB", "ZIP"), K, 
         starts, method = "BFGS", se = TRUE, engine=c("C","R"), threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmultmix_+3A_lambdaformula">lambdaformula</code></td>
<td>
<p>Righthand side (RHS) formula describing abundance
covariates</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_phiformula">phiformula</code></td>
<td>
<p>RHS formula describing availability covariates</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_pformula">pformula</code></td>
<td>
<p>RHS formula describing detection covariates</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_data">data</code></td>
<td>
<p>An object of class unmarkedFrameGMM</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_mixture">mixture</code></td>
<td>
<p>Either &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for the Poisson, negative binomial, or
zero-inflated Poisson models of abundance</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_k">K</code></td>
<td>
<p>The upper bound of integration</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_starts">starts</code></td>
<td>
<p>Starting values</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="gmultmix_+3A_se">se</code></td>
<td>
<p>Logical. Should standard errors be calculated?</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; to use fast C++ code or &quot;R&quot; to use native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="gmultmix_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.</p>
</td></tr> 
<tr><td><code id="gmultmix_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The latent transect-level super-population abundance distribution
<code class="reqn">f(M | \mathbf{\theta})</code> can be set as a
Poisson, negative binomial, or zero-inflated Poisson random variable, 
depending on the setting of the <code>mixture</code> argument. 
<code>mixture = "P"</code>, <code>mixture = "NB"</code>, and <code>mixture = "ZIP"</code>
select the Poisson, negative binomial, and zero-inflated Poisson distributions 
respectively.  The mean of <code class="reqn">M_i</code> is <code class="reqn">\lambda_i</code>.  
If <code class="reqn">M_i \sim NB</code>, then an additional parameter, <code class="reqn">\alpha</code>, 
describes dispersion (lower <code class="reqn">\alpha</code> implies higher variance). If 
<code class="reqn">M_i \sim ZIP</code>, then an additional zero-inflation parameter
<code class="reqn">\psi</code> is estimated.
</p>
<p>The number of individuals available for detection at time j
is a modeled as binomial:
<code class="reqn">N_{ij} \sim Binomial(M_i, \mathbf{\phi_{ij}})</code>.
</p>
<p>The detection process is modeled as multinomial:
<code class="reqn">\mathbf{y_{it}} \sim
Multinomial(N_{it}, \pi_{it})</code>,
where <code class="reqn">\pi_{ijt}</code> is the multinomial cell probability for
plot i at time t on occasion j.
</p>
<p>Cell probabilities are computed via a user-defined function related to the
sampling design. Alternatively, the default functions
<code><a href="#topic+removalPiFun">removalPiFun</a></code>
or <code><a href="#topic+doublePiFun">doublePiFun</a></code> can be used for equal-interval removal
sampling or
double observer sampling. Note that the function for computing cell
probabilites
is specified when setting up the data using <code><a href="#topic+unmarkedFrameGMM">unmarkedFrameGMM</a></code>.
</p>
<p>Parameters <code class="reqn">\lambda</code>, <code class="reqn">\phi</code> and <code class="reqn">p</code> can be
modeled as linear functions of covariates using the log, logit and logit
links
respectively.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitGMM.
</p>


<h3>Note</h3>

<p>In the case where availability for detection is due to random temporary
emigration, population density at time j, D(i,j), can be estimated by
N(i,j)/plotArea.
</p>
<p>This model is also applicable to sampling designs in which the local
population size is closed during the J repeated counts, and availability
is related to factors such as the probability of vocalizing. In this
case, density can be estimated by M(i)/plotArea.
</p>
<p>If availability is a function of both temporary emigration and other
processess such as song rate, then density cannot be directly estimated,
but inference about the super-population size, M(i), is possible.
</p>
<p>Three types of covariates can be supplied, site-level,
site-by-year-level, and observation-level. These must be formatted
correctly when organizing the data with <code><a href="#topic+unmarkedFrameGPC">unmarkedFrameGPC</a></code>
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a> and Andy Royle
</p>


<h3>References</h3>

<p>Royle, J. A. (2004) Generalized estimators of avian abundance from count
survey data. <em>Animal Biodiversity and Conservation</em> 27,
pp. 375&ndash;386.
</p>
<p>Chandler, R. B., J. A. Royle, and D. I. King. 2011. Inference about
density and temporary emigration in unmarked populations. Ecology
92:1429-1435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrameGMM">unmarkedFrameGMM</a></code> for setting up the data and metadata.
<code><a href="#topic+multinomPois">multinomPois</a></code> for surveys where no secondary sampling periods were
used. Example functions to calculate multinomial cell probabilities are
described <code><a href="#topic+piFuns">piFuns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data using the multinomial-Poisson model with a
# repeated constant-interval removal design.

n &lt;- 100  # number of sites
T &lt;- 4    # number of primary periods
J &lt;- 3    # number of secondary periods

lam &lt;- 3
phi &lt;- 0.5
p &lt;- 0.3

#set.seed(26)
y &lt;- array(NA, c(n, T, J))
M &lt;- rpois(n, lam)          # Local population size
N &lt;- matrix(NA, n, T)       # Individuals available for detection

for(i in 1:n) {
    N[i,] &lt;- rbinom(T, M[i], phi)
    y[i,,1] &lt;- rbinom(T, N[i,], p)    # Observe some
    Nleft1 &lt;- N[i,] - y[i,,1]         # Remove them
    y[i,,2] &lt;- rbinom(T, Nleft1, p)   # ...
    Nleft2 &lt;- Nleft1 - y[i,,2]
    y[i,,3] &lt;- rbinom(T, Nleft2, p)
    }

y.ijt &lt;- cbind(y[,1,], y[,2,], y[,3,], y[,4,])


umf1 &lt;- unmarkedFrameGMM(y=y.ijt, numPrimary=T, type="removal")

(m1 &lt;- gmultmix(~1, ~1, ~1, data=umf1, K=30))

backTransform(m1, type="lambda")        # Individuals per plot
backTransform(m1, type="phi")           # Probability of being avilable
(p &lt;- backTransform(m1, type="det"))    # Probability of detection
p &lt;- coef(p)

# Multinomial cell probabilities under removal design
c(p, (1-p) * p, (1-p)^2 * p)

# Or more generally:
head(getP(m1))

# Empirical Bayes estimates of super-population size
re &lt;- ranef(m1)
plot(re, layout=c(5,5), xlim=c(-1,20), subset=site%in%1:25)


</code></pre>

<hr>
<h2 id='goccu'>
Fit multi-scale occupancy models
</h2><span id='topic+goccu'></span>

<h3>Description</h3>

<p>Fit multi-scale occupancy models as described in Nichols et al. (2008) to
repeated presence-absence data collected using the robust design. This model
allows for inference about occupancy, availability, and detection probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goccu(psiformula, phiformula, pformula, data, linkPsi = c("logit", "cloglog"),
      starts, method = "BFGS", se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goccu_+3A_psiformula">psiformula</code></td>
<td>

<p>Right-hand sided formula describing occupancy covariates
</p>
</td></tr>
<tr><td><code id="goccu_+3A_phiformula">phiformula</code></td>
<td>

<p>Right-hand sided formula describing availability covariates
</p>
</td></tr>
<tr><td><code id="goccu_+3A_pformula">pformula</code></td>
<td>

<p>Right-hand sided formula for detection probability covariates
</p>
</td></tr>
<tr><td><code id="goccu_+3A_data">data</code></td>
<td>

<p>An object of class unmarkedFrameGOccu or unmarkedMultFrame
</p>
</td></tr>
<tr><td><code id="goccu_+3A_linkpsi">linkPsi</code></td>
<td>
<p>Link function for the occupancy model. Options are  
<code>"logit"</code> for the standard occupancy model or <code>"cloglog"</code> 
for the complimentary log-log link, which relates occupancy
to site-level abundance.
</p>
</td></tr>
<tr><td><code id="goccu_+3A_starts">starts</code></td>
<td>

<p>Starting values
</p>
</td></tr>
<tr><td><code id="goccu_+3A_method">method</code></td>
<td>

<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>
</p>
</td></tr>
<tr><td><code id="goccu_+3A_se">se</code></td>
<td>

<p>Logical. Should standard errors be calculated?
</p>
</td></tr>
<tr><td><code id="goccu_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code><a href="stats.html#topic+optim">optim</a></code>, such as lower and upper
bounds
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Primary periods could represent spatial or temporal sampling replicates.
For example, you could have several spatial sub-units within each site, where each
sub-unit was then sampled repeatedly. This is a frequent design for eDNA studies.
Or, you could have multiple primary periods of sampling at each site
(conducted at different times within a season), each of which contains 
several secondary sampling periods. In both cases the robust design structure
can be used to estimate an availability probability in addition to
detection probability. See Kery and Royle (2015) 10.10 for more details.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitGOccu
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a>
</p>


<h3>References</h3>

<p>Kery, M., &amp; Royle, J. A. (2015). Applied hierarchical modeling in ecology: 
Volume 1: Prelude and static models. Elsevier Science.
</p>
<p>Nichols, J. D., Bailey, L. L., O'Connell Jr, A. F., Talancy, N. W., 
Campbell Grant, E. H., Gilbert, A. T., Annand E. M., Husband, T. P., &amp; Hines, J. E.
(2008). Multi-scale occupancy estimation and modelling using multiple detection methods. 
Journal of Applied Ecology, 45(5), 1321-1329.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+occu">occu</a></code>, <code><a href="#topic+colext">colext</a></code>,
<code><a href="#topic+unmarkedMultFrame">unmarkedMultFrame</a></code>, <code><a href="#topic+unmarkedFrameGOccu">unmarkedFrameGOccu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
M &lt;- 100
T &lt;- 5
J &lt;- 4

psi &lt;- 0.5
phi &lt;- 0.3
p &lt;- 0.4

z &lt;- rbinom(M, 1, psi)
zmat &lt;- matrix(z, nrow=M, ncol=T)

zz &lt;- rbinom(M*T, 1, zmat*phi)
zz &lt;- matrix(zz, nrow=M, ncol=T)

zzmat &lt;- zz[,rep(1:T, each=J)]
y &lt;- rbinom(M*T*J, 1, zzmat*p)
y &lt;- matrix(y, M, J*T)
umf &lt;- unmarkedMultFrame(y=y, numPrimary=T)

## Not run: 
  mod &lt;- goccu(psiformula = ~1, phiformula = ~1, pformula = ~1, umf)
  plogis(coef(mod))

## End(Not run)

</code></pre>

<hr>
<h2 id='gpcount'>
Generalized binomial N-mixture model for repeated count data
</h2><span id='topic+gpcount'></span>

<h3>Description</h3>

<p>Fit the model of Chandler et al. (2011) to repeated count data collected
using the robust design. This model allows for inference about
population size, availability, and detection probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpcount(lambdaformula, phiformula, pformula, data,
mixture = c("P", "NB", "ZIP"), K, starts, method = "BFGS", se = TRUE,
engine = c("C", "R"), threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpcount_+3A_lambdaformula">lambdaformula</code></td>
<td>

<p>Right-hand sided formula describing covariates of abundance.
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_phiformula">phiformula</code></td>
<td>

<p>Right-hand sided formula describing availability covariates
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_pformula">pformula</code></td>
<td>

<p>Right-hand sided formula for detection probability covariates
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_data">data</code></td>
<td>

<p>An object of class unmarkedFrameGPC
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_mixture">mixture</code></td>
<td>

<p>Either &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for Poisson, negative binomial, or 
zero-inflated Poisson distributions
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_k">K</code></td>
<td>

<p>The maximum possible value of M, the super-population size.
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_starts">starts</code></td>
<td>

<p>Starting values
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_method">method</code></td>
<td>

<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_se">se</code></td>
<td>

<p>Logical. Should standard errors be calculated?
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_engine">engine</code></td>
<td>

<p>Either &quot;C&quot; or &quot;R&quot; for the C++ or R versions of the likelihood. The C++
code is faster, but harder to debug.
</p>
</td></tr>
<tr><td><code id="gpcount_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.
</p>
</td></tr> 
<tr><td><code id="gpcount_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code><a href="stats.html#topic+optim">optim</a></code>, such as lower and upper
bounds
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The latent transect-level super-population abundance distribution
<code class="reqn">f(M | \mathbf{\theta})</code> can be set as either a
Poisson, negative binomial, or zero-inflated Poisson random variable, depending on the
setting of the <code>mixture</code> argument. The expected value of
<code class="reqn">M_i</code> is <code class="reqn">\lambda_i</code>.  If <code class="reqn">M_i \sim NB</code>,
then an additional parameter, <code class="reqn">\alpha</code>, describes
dispersion (lower <code class="reqn">\alpha</code> implies higher variance). If 
<code class="reqn">M_i \sim ZIP</code>, then an additional zero-inflation parameter
<code class="reqn">\psi</code> is estimated.
</p>
<p>The number of individuals available for detection at time j
is a modeled as binomial:
<code class="reqn">N_{ij} \sim Binomial(M_i, \mathbf{\phi_{ij}})</code>.
</p>
<p>The detection process is also modeled as binomial:
<code class="reqn">y_{ikj} \sim Binomial(N_{ij}, p_{ikj})</code>.
</p>
<p>Parameters <code class="reqn">\lambda</code>, <code class="reqn">\phi</code> and <code class="reqn">p</code> can be
modeled as linear functions of covariates using the log, logit and logit
links respectively.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitGPC
</p>


<h3>Note</h3>

<p>In the case where availability for detection is due to random temporary
emigration, population density at time j, D(i,j), can be estimated by
N(i,j)/plotArea.
</p>
<p>This model is also applicable to sampling designs in which the local
population size is closed during the J repeated counts, and availability
is related to factors such as the probability of vocalizing. In this
case, density can be estimated by M(i)/plotArea.
</p>
<p>If availability is a function of both temporary emigration and other
processess such as song rate, then density cannot be directly estimated,
but inference about the super-population size, M(i), is possible.
</p>
<p>Three types of covariates can be supplied, site-level,
site-by-year-level, and observation-level. These must be formatted
correctly when organizing the data with <code><a href="#topic+unmarkedFrameGPC">unmarkedFrameGPC</a></code>
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a>
</p>


<h3>References</h3>

<p>Royle, J. A. 2004. N-Mixture models for estimating population size from
spatially replicated counts. <em>Biometrics</em> 60:108&ndash;105.
</p>
<p>Chandler, R. B., J. A. Royle, and D. I. King. 2011. Inference about
density and temporary emigration in unmarked populations. Ecology
92:1429-1435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gmultmix">gmultmix</a></code>, <code><a href="#topic+gdistsamp">gdistsamp</a></code>,
<code><a href="#topic+unmarkedFrameGPC">unmarkedFrameGPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(54)

nSites &lt;- 20
nVisits &lt;- 4
nReps &lt;- 3

lambda &lt;- 5
phi &lt;- 0.7
p &lt;- 0.5

M &lt;- rpois(nSites, lambda) # super-population size

N &lt;- matrix(NA, nSites, nVisits)
y &lt;- array(NA, c(nSites, nReps, nVisits))
for(i in 1:nVisits) {
    N[,i] &lt;- rbinom(nSites, M, phi) # population available during vist j
}
colMeans(N)

for(i in 1:nSites) {
    for(j in 1:nVisits) {
        y[i,,j] &lt;- rbinom(nReps, N[i,j], p)
    }
}

ym &lt;- matrix(y, nSites)
ym[1,] &lt;- NA
ym[2, 1:nReps] &lt;- NA
ym[3, (nReps+1):(nReps+nReps)] &lt;- NA
umf &lt;- unmarkedFrameGPC(y=ym, numPrimary=nVisits)

## Not run: 
fmu &lt;- gpcount(~1, ~1, ~1, umf, K=40, control=list(trace=TRUE, REPORT=1))

backTransform(fmu, type="lambda")
backTransform(fmu, type="phi")
backTransform(fmu, type="det")

## End(Not run)

</code></pre>

<hr>
<h2 id='imputeMissing'>
A function to impute missing entries in continuous obsCovs
</h2><span id='topic+imputeMissing'></span>

<h3>Description</h3>

<p>This function uses an ad-hoc averaging approach to impute missing
entries in obsCovs.  The missing entry is replaced by an average of the
average for the site and the average for the visit number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeMissing(umf, whichCovs = seq(length=ncol(obsCovs(umf))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeMissing_+3A_umf">umf</code></td>
<td>

<p>The data set who's obsCovs are being imputed.
</p>
</td></tr>
<tr><td><code id="imputeMissing_+3A_whichcovs">whichCovs</code></td>
<td>

<p>An integer vector giving the indices of the covariates to be imputed.
This defaults to all covariates in <code>obsCovs</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A version of <code>umf</code> that has the requested obsCovs imputed.
</p>


<h3>Author(s)</h3>

<p>Ian Fiske
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(frogs)
pcru.obscovs &lt;- data.frame(MinAfterSunset=as.vector(t(pcru.data[,,1])),
     Wind=as.vector(t(pcru.data[,,2])),
     Sky=as.vector(t(pcru.data[,,3])),
     Temperature=as.vector(t(pcru.data[,,4])))
pcruUMF &lt;- unmarkedFrameOccu(y = pcru.bin, obsCovs = pcru.obscovs)
pcruUMF.i1 &lt;- imputeMissing(pcruUMF)
pcruUMF.i2 &lt;- imputeMissing(pcruUMF, whichCovs = 2)

</code></pre>

<hr>
<h2 id='issj'>
Distance-sampling data for the Island Scrub Jay (<em>Aphelocoma
insularis</em>)
</h2><span id='topic+issj'></span>

<h3>Description</h3>

<p>Data were collected at 307 survey locations (&quot;point transects&quot;) on
Santa Cruz Island, California during the Fall of 2008. The distance
data are binned into 3 distance intervals
[0-100], (100-200], and (200-300]. The coordinates of the survey
locations as well as 3 habitat covariates are also included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(issj)</code></pre>


<h3>Format</h3>

<p>A data frame with 307 observations on the following 8 variables.
</p>

<dl>
<dt><code>issj[0-100]</code></dt><dd><p>Number of individuals detected within 100m</p>
</dd>
<dt><code>issj(100-200]</code></dt><dd><p>Detections in the interval (100-200m]</p>
</dd>
<dt><code>issj(200-300]</code></dt><dd><p>Detections in the interval (200-300m]</p>
</dd>
<dt><code>x</code></dt><dd><p>Easting (meters)</p>
</dd>
<dt><code>y</code></dt><dd><p>Northing (meters)</p>
</dd>
<dt><code>elevation</code></dt><dd><p>Elevation in meters</p>
</dd>
<dt><code>forest</code></dt><dd><p>Forest cover</p>
</dd>
<dt><code>chaparral</code></dt><dd><p>Chaparral cover</p>
</dd>
</dl>



<h3>References</h3>

<p>Sillett, S. and Chandler, R.B. and Royle, J.A. and Kery, M. and
Morrison, S.A. In Press. Hierarchical distance sampling models to
estimate population size and habitat-specific abundance of an island
endemic. <em>Ecological Applications</em>
</p>


<h3>See Also</h3>

<p>Island-wide covariates are also available <code><a href="#topic+cruz">cruz</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(issj)
str(issj)
head(issj)

umf &lt;- unmarkedFrameDS(y=as.matrix(issj[,1:3]), siteCovs=issj[,6:8],
    dist.breaks=c(0,100,200,300), unitsIn="m", survey="point")
summary(umf)

</code></pre>

<hr>
<h2 id='jay'>
European Jay data from the Swiss Breeding Bird Survey 2002
</h2><span id='topic+jay'></span>

<h3>Description</h3>

<p>The Swiss breeding bird survey (&quot;Monitoring Haufige Brutvogel&quot; MHB) has monitored the populations of 150 common species since 1999. The MHB sample consists of 267 1-km squares that are laid out as a grid across Switzerland. Fieldwork is conducted by about 200 skilled birdwatchers, most of them volunteers. Avian populations are monitored using a simplified territory mapping protocol, where each square is surveyed up to three times during the breeding season (only twice above the tree line). Surveys are conducted along a transect that does not change over the years.
</p>
<p>The list <code>jay</code> has the data for European Jay territories for 238 sites surveyed in 2002.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("jay")</code></pre>


<h3>Format</h3>

<p><code>jay</code> is a list with 3 elements:
</p>

<dl>
<dt><b>caphist </b></dt><dd><p>a data frame with rows for 238 sites and columns for each of the observable detection histories. For the sites visited 3 times, these are <code>"100", "010", "001", "110", "101", "011", "111"</code>. Sites visited twice have <code>"10x", "01x", "11x"</code>. 
</p>
<p>Each row gives the number of territories with the corresponding detection history, with NA for the detection histories not applicable: sites visited 3 times have NAs in the last 3 columns while those visited twice have NAs in the first 7 columns.
</p>
</dd>
</dl>

<dl>
<dt><b>sitescovs </b></dt><dd><p>a data frame with rows for 238 sites, and the following columns:
</p>

<ol>
<li><p> elev : the mean elevation of the quadrat, m.
</p>
</li>
<li><p> length : the length of the route walked in the quadrat, km.
</p>
</li>
<li><p> forest : percentage forest cover.
</p>
</li></ol>
</dd></dl>


<dl>
<dt><b>covinfo </b></dt><dd><p>a data frame with rows for 238 sites, and the following columns:
</p>

<ol>
<li><p> x, y : the coordinates of the site.
</p>
</li>
<li><p> date1, date2, date3 : the Julian date of the visit, with 1 April = 1. Sites visited twice have NA in the 3rd column.
</p>
</li>
<li><p> dur1, dur2, dur3 : the duration of the survey, mins. For 10 visits the duration is not available, so there are additional NAs in these columns.
</p>
</li></ol>
</dd></dl>

 

<h3>Note</h3>

<p>In previous versions, <code>jay</code> had additional information not required for the analysis, and a data frame with essentially the same information as the <code>Switzerland</code> data set.
</p>


<h3>Source</h3>

<p>Swiss Ornithological Institute
</p>


<h3>References</h3>

<p>Royle, J.A., Kery, M., Gauthier, R., Schmid, H. (2007) Hierarchical spatial models of abundance and occurrence from imperfect survey data. <em>Ecological Monographs</em>, 77, 465-481.
</p>
<p>Kery &amp; Royle (2016) <em>Applied Hierarachical Modeling in Ecology</em> Section 7.9
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jay)
str(jay)

# Carry out a simple analysis, without covariates:
# Create a customised piFun (see ?piFun for details)
crPiFun &lt;- function(p) {
   p1 &lt;- p[,1] # Extract the columns of the p matrix, one for 
   p2 &lt;- p[,2] #   each of J = 3 sample occasions
   p3 &lt;- p[,3]
   cbind(      # define multinomial cell probabilities:
      "100" = p1 * (1-p2) * (1-p3),
      "010" = (1-p1) * p2 * (1-p3),
      "001" = (1-p1) * (1-p2) * p3,
      "110" = p1 * p2 * (1-p3),
      "101" = p1 * (1-p2) * p3,
      "011" = (1-p1) * p2 * p3,
      "111" = p1 * p2 * p3,
      "10x" = p1*(1-p2),
      "01x" = (1-p1)*p2,
      "11x" = p1*p2)
}
# Build the unmarkedFrame object
mhb.umf &lt;- unmarkedFrameMPois(y=as.matrix(jay$caphist),
  obsToY=matrix(1, 3, 10), piFun="crPiFun")
# Fit a model
( fm1 &lt;- multinomPois(~1 ~1, mhb.umf) )
</code></pre>

<hr>
<h2 id='lambda2psi'>
Convert Poisson mean (lambda) to probability of occurrence (psi).
</h2><span id='topic+lambda2psi'></span>

<h3>Description</h3>

<p>Abundance and occurrence are fundamentally related.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda2psi(lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda2psi_+3A_lambda">lambda</code></td>
<td>

<p>Numeric vector with values &gt;= 0
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of psi values of the same length as lambda.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcount">pcount</a></code>, <code><a href="#topic+multinomPois">multinomPois</a></code>, <code><a href="#topic+distsamp">distsamp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda2psi(0:5)
</code></pre>

<hr>
<h2 id='linearComb-methods'>Methods for Function linearComb in Package &lsquo;unmarked&rsquo;</h2><span id='topic+linearComb'></span><span id='topic+linearComb-methods'></span><span id='topic+linearComb+2CunmarkedEstimate+2CmatrixOrVector-method'></span><span id='topic+linearComb+2CunmarkedFit+2CmatrixOrVector-method'></span><span id='topic+show+2CunmarkedLinComb-method'></span>

<h3>Description</h3>

<p>Methods for function <code>linearComb</code> in Package &lsquo;unmarked&rsquo;
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;unmarkedEstimate&quot;, coefficients = &quot;matrixOrVector&quot;</dt><dd><p>Typically 
called internally</p>
</dd>
<dt>obj = &quot;unmarkedFit&quot;, coefficients = &quot;matrixOrVector&quot;</dt><dd><p>Returns 
linear combinations of parameters from a fitted model.  Coefficients
are supplied through coefficients.  The required argument <code>type</code>
specifies which model estimate to use.  You can use
<code>names(fittedmodel)</code> to view possible values for the <code>type</code> argument.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(ovendata)
ovenFrame &lt;- unmarkedFrameMPois(ovendata.list$data,
siteCovs=as.data.frame(scale(ovendata.list$covariates[,-1])), type = "removal")
fm &lt;- multinomPois(~ 1 ~ ufc + trba, ovenFrame)
linearComb(fm, c(1, 0.5, 0.5), type = "state")
linearComb(fm, matrix(c(1, 0.5, 0.5, 1, 0, 0, 1, 0, 0.5), 3, 3,
  byrow=TRUE), type="state")
</code></pre>

<hr>
<h2 id='linetran'>
Simulated line transect data
</h2><span id='topic+linetran'></span>

<h3>Description</h3>

<p>Response matrix of animals detected in four distance classes plus transect 
lengths and two covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(linetran)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 7 variables.
</p>

<dl>
<dt><code>dc1</code></dt><dd><p>Counts in distance class 1 [0-5 m)</p>
</dd>
<dt><code>dc2</code></dt><dd><p>Counts in distance class 2 [5-10 m)</p>
</dd>
<dt><code>dc3</code></dt><dd><p>Counts in distance class 3 [10-15 m)</p>
</dd>
<dt><code>dc4</code></dt><dd><p>Counts in distance class 4 [15-20 m)</p>
</dd>
<dt><code>Length</code></dt><dd><p>Transect lengths in km</p>
</dd>
<dt><code>area</code></dt><dd><p>Numeric covariate</p>
</dd>
<dt><code>habitat</code></dt><dd><p>a factor with levels <code>A</code> and <code>B</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(linetran)
linetran

# Format for distsamp()
ltUMF &lt;- with(linetran, {
        unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4), 
        siteCovs = data.frame(Length, area, habitat), 
        dist.breaks = c(0, 5, 10, 15, 20),
        tlength = linetran$Length * 1000, survey = "line", unitsIn = "m")
        })

</code></pre>

<hr>
<h2 id='makePiFuns'>Create functions to compute multinomial cell probabilities</h2><span id='topic+makePiFuns'></span><span id='topic+makeRemPiFun'></span><span id='topic+makeCrPiFun'></span><span id='topic+makeCrPiFunMb'></span><span id='topic+makeCrPiFunMh'></span>

<h3>Description</h3>

<p>These are factory functions that generate piFuns with the required defaults, which are enclosed within the environment of the piFun. See the main entry for <a href="#topic+piFuns">piFuns</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRemPiFun(times)
makeCrPiFun(nOcc)
makeCrPiFunMb(nOcc)
makeCrPiFunMh(nOcc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePiFuns_+3A_times">times</code></td>
<td>

<p>a vector of times for each interval, <code>length(times)</code> is the number of survey occasions; can be all 1's if times are the same.
</p>
</td></tr>
<tr><td><code id="makePiFuns_+3A_nocc">nOcc</code></td>
<td>

<p>the number of survey occasions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makeRemPiFun</code> produces a piFun for a removal model with the required number of occasions and potentially varying time intervals. The input to the piFun must be probabilities <em>per unit time</em>. This is a generalisation of the piFun in the Examples section of <a href="#topic+piFuns">piFuns</a>.
</p>
<p><code>makeCrPiFun</code> produces a piFun for a standard capture-recapture model, M0, Mt or Mx. Probabilities of detection may vary across occasions. See Kery &amp; Royle (2016) section 7.8.1.
</p>
<p><code>makeCrPiFunMb</code> produces a piFun for a capture-recapture model with a behavioral response after the first capture, Mb. Probabilities of detection are constant across occasions. The first column is the probability of detection for animals not caught before, column #2 is for animals after the first capture. The remaining columns are ignored. See Kery &amp; Royle (2016) section 7.8.2.
</p>
<p><code>makeCrPiFunMh</code> produces a piFun for a capture-recapture model with individual heterogeneity in detection probability, Mh, using a logit-normal distribution. Probabilities of detection are constant across occasions. The first column is the mean of the logit-normal on the probability scale. Cell p[1, 2] is a value in [0, 1] which controls the spread of the distribution. The remaining cells are ignored. See Kery &amp; Royle (2016) section 7.8.3.
</p>


<h3>Value</h3>

<p>A piFun with the appropriate defaults.
</p>


<h3>References</h3>

<p>Kery, M., Royle, J. A. (2016) <em>Applied Hierarchical Modeling in Ecology</em> Vol 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate piFuns and check their behaviour:

# makeRemPiFun
# ============
( pRem &lt;- matrix(0.4, nrow=5, ncol=3) )
myPi &lt;- makeRemPiFun(times=c(2,3,5))
myPi(pRem)
ls(environment(myPi))  # See what's in the environment
environment(myPi)$times

( pRem &lt;- matrix(runif(15), 5, 3) )
myPi(pRem)

myPi &lt;- makeRemPiFun(c(5,3,2))
environment(myPi)$times
myPi(pRem)

# More than 3 occasions
myPi &lt;- makeRemPiFun(c(1,2,3,5))
try(myPi(pRem))  # Error
( pRem &lt;- matrix(runif(20), 5, 4) )
myPi(pRem)
# Probability of escaping detection
1 - rowSums(myPi(pRem))

# makeCrPiFun
# ===========
p &lt;- matrix(0.4, 2, 3)
myPi &lt;- makeCrPiFun(3)
myPi(p)
myPi  # Look at the function
ls(environment(myPi))
environment(myPi)$histories

p &lt;- matrix(runif(6, 0.1, 0.9), 2, 3)  # different p's everywhere
myPi(p)

p &lt;- matrix(runif(4*5, 0.1, 0.9), 4, 5)  # &gt; 3 occasions
try(myPi(p))  # Error
myPi &lt;- makeCrPiFun(5)
( tmp &lt;- myPi(p) )
1 - rowSums(tmp) # Probability of non-capture

# makeCrPiFunMb
# ==============
( pMb &lt;- cbind(rep(0.7, 5), 0.3, NA) )
myPi &lt;- makeCrPiFunMb(3)
myPi(pMb)

( pMb &lt;- matrix(runif(15), 5, 3) )  # col #3 will be ignored
myPi(pMb)

# with &gt; 3 occasions
( pMb &lt;- matrix(runif(15), 3, 5) )
try(myPi(pMb))
myPi &lt;- makeCrPiFunMb(5)
myPi(pMb)

# makeCrPiFunMh
# =============
pMh &lt;- cbind(rep(0.4, 5), NA, NA)
pMh[1, 2] &lt;- 0.3
pMh
myPi &lt;- makeCrPiFunMh(3)
myPi(pMh)
pMh &lt;- cbind(runif(5), NA, NA)
pMh[1, 2] &lt;- 0.3
pMh
myPi(pMh)

# with &gt; 3 occasions
pMh &lt;- cbind(runif(5), NA, NA, NA, NA)
pMh[1, 2] &lt;- 0.3
pMh
try(myPi(pMh))
myPi &lt;- makeCrPiFunMh(5)
1 - rowSums(myPi(pMh))  # Probability of non-detection
</code></pre>

<hr>
<h2 id='mallard'>Mallard count data</h2><span id='topic+mallard'></span><span id='topic+mallard.y'></span><span id='topic+mallard.obs'></span><span id='topic+mallard.site'></span>

<h3>Description</h3>

<p>Mallard repeated count data and covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mallard)</code></pre>


<h3>Format</h3>

<p>A list with 3 components
</p>

<dl>
<dt>mallard.y</dt><dd><p>response matrix</p>
</dd>
<dt>mallard.site</dt><dd><p>site-specific covariates</p>
</dd>
<dt>mallard.obs</dt><dd><p>survey-specific covariates</p>
</dd>
</dl>



<h3>References</h3>

<p>Kery, M., Royle, J. A., and Schmid, H. (2005) Modeling Avaian Abundance from Replicated
Counts Using Binomial Mixture Models. <em>Ecological Applications</em> 15(4), 
pp. 1450&ndash;1461.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mallard)
str(mallard.y)
str(mallard.site)
str(mallard.obs)
</code></pre>

<hr>
<h2 id='masspcru'> Massachusetts North American Amphibian Monitoring Program Data </h2><span id='topic+masspcru'></span>

<h3>Description</h3>

<p><code>masspcru</code> contains NAAMP data for Pseudacris
crucifer (pcru) in Massachusetts from 2001 to 2007 in the raw long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(masspcru)</code></pre>


<h3>Format</h3>

<p>Data frame with
</p>

<dl>
<dt>SurveyYear</dt><dd><p>Year of data collection.</p>
</dd>
<dt>RouteNumStopNum</dt><dd><p>Stop number.</p>
</dd>
<dt>JulianDate</dt><dd><p>Day of year.</p>
</dd>
<dt>Pcru</dt><dd><p>Observed calling index.</p>
</dd>
<dt>MinAfterSunset</dt><dd><p>Minutes after sunset of the observation.</p>
</dd>
<dt>Temperature</dt><dd><p>Temperature measured during observation.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data come from the North American Amphibian Monitoring Program.
Please see the reference below for more details.
</p>


<h3>Source</h3>

<p>https://www.pwrc.usgs.gov/naamp/
</p>


<h3>References</h3>

<p>Mossman MJ, Weir LA. North American Amphibian Monitoring Program (NAAMP). Amphibian Declines: the conservation status of United States species. University of California Press, Berkeley, California, USA. 2005:307-313.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(masspcru)
str(masspcru)
</code></pre>

<hr>
<h2 id='MesoCarnivores'>
Occupancy data for coyote, red fox, and bobcat
</h2><span id='topic+MesoCarnivores'></span>

<h3>Description</h3>

<p>Occupancy data and site covariates for coyote, red fox, and bobcat from 1437 camera trap sites sampled 3 times. Each sampling period represents one week. This data is a simplified form of the dataset used by Rota et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MesoCarnivores)</code></pre>


<h3>Format</h3>

<p>A list with four elements:
</p>

<dl>
<dt><code>bobcat</code></dt><dd><p>A 1437x3 occupancy matrix for bobcat</p>
</dd>
<dt><code>coyote</code></dt><dd><p>A 1437x3 occupancy matrix for coyote</p>
</dd>
<dt><code>redfox</code></dt><dd><p>A 1437x3 occupancy matrix for red fox</p>
</dd>
<dt><code>sitecovs</code></dt><dd><p>A data frame containing covariates for the 1437 sites, with the following columns:
</p>

<dl>
<dt><code>Dist_5km</code></dt><dd><p>Proportion of disturbed land in 5 km radius</p>
</dd>
<dt><code>HDens_5km</code></dt><dd><p>Housing density in 5 km radius</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>Latitude / 100</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>Longitude / 100</p>
</dd>
<dt><code>People_site</code></dt><dd><p>Number of photos of people at site / 1000</p>
</dd>
<dt><code>Trail</code></dt><dd><p>1 if camera was on trail, 0 if not</p>
</dd>
</dl>

</dd>
</dl>



<h3>Source</h3>

<p>Used with permission of Roland Kays and Arielle Parsons at North Carolina State University and the North Carolina Museum of Natural Sciences.
</p>


<h3>References</h3>

<p>Rota, C.T., et al. 2016. A multi-species occupancy model for two or more
interacting species. Methods in Ecology and Evolution 7: 1164-1173.
</p>

<hr>
<h2 id='modSel'>Model selection results from an unmarkedFitList</h2><span id='topic+modSel'></span><span id='topic+modSel-methods'></span><span id='topic+unmarkedModSel-class'></span><span id='topic+show+2CunmarkedModSel-method'></span><span id='topic+summary+2CunmarkedModSel-method'></span><span id='topic+coef+2CunmarkedModSel-method'></span><span id='topic+SE+2CunmarkedModSel-method'></span>

<h3>Description</h3>

<p>Model selection results from an unmarkedFitList</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="modSel_+3A_object">object</code></td>
<td>
<p>an object of class &quot;unmarkedFitList&quot; created by the function
<code><a href="#topic+fitList">fitList</a></code>.</p>
</td></tr>
<tr><td><code id="modSel_+3A_nullmod">nullmod</code></td>
<td>
<p>optional character naming which model in the
<code>fitList</code> contains results from the null model. Only used in
calculation of Nagelkerke's R-squared index.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S4 object with the following slots
</p>
<table>
<tr><td><code>Full</code></td>
<td>
<p>data.frame with formula, estimates, standard errors and model 
selection information. Converge is optim convergence code. CondNum is
model condition number. n is the number of sites. delta is delta AIC.
cumltvWt is cumulative AIC weight.
Rsq is Nagelkerke's (1991) R-squared index, which is only returned when 
the nullmod argument is specified. </p>
</td></tr>
<tr><td><code>Names</code></td>
<td>
<p>matrix referencing column names of estimates (row 1) and 
standard errors (row 2).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Two requirements exist to conduct AIC-based model-selection and model-averaging in unmarked. First, the data objects (ie, unmarkedFrames) must be identical among fitted models. Second, the response matrix must be identical among fitted models after missing values have been removed. This means that if a response value was removed in one model due to missingness, it needs to be removed from all models.
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a></p>


<h3>References</h3>

<p>Nagelkerke, N.J.D. (2004) A Note on a General Definition of the 
Coefficient of Determination. <em>Biometrika</em> 78, pp. 691-692.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(linetran)
(dbreaksLine &lt;- c(0, 5, 10, 15, 20)) 
lengths &lt;- linetran$Length * 1000

ltUMF &lt;- with(linetran, {
	unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4), 
	siteCovs = data.frame(Length, area, habitat), dist.breaks = dbreaksLine,
	tlength = lengths, survey = "line", unitsIn = "m")
	})

fm1 &lt;- distsamp(~ 1 ~1, ltUMF)
fm2 &lt;- distsamp(~ area ~1, ltUMF)
fm3 &lt;- distsamp( ~ 1 ~area, ltUMF)

fl &lt;- fitList(Null=fm1, A.=fm2, .A=fm3)
fl

ms &lt;- modSel(fl, nullmod="Null")
ms

coef(ms)                            # Estimates only
SE(ms)                              # Standard errors only
(toExport &lt;- as(ms, "data.frame"))  # Everything

</code></pre>

<hr>
<h2 id='multinomPois'>Multinomial-Poisson Mixtures Model</h2><span id='topic+multinomPois'></span>

<h3>Description</h3>

<p>Fit the multinomial-Poisson mixture model to data collected
using
survey methods such as removal sampling or double observer sampling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomPois(formula, data, starts, method = "BFGS",
   se = TRUE, engine=c("C","R","TMB"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomPois_+3A_formula">formula</code></td>
<td>
<p>double right-hand side formula for detection and abundance
covariates, in that order.</p>
</td></tr>
<tr><td><code id="multinomPois_+3A_data">data</code></td>
<td>
<p>unmarkedFrame supplying data.</p>
</td></tr>
<tr><td><code id="multinomPois_+3A_starts">starts</code></td>
<td>
<p>vector of starting values.</p>
</td></tr>
<tr><td><code id="multinomPois_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="multinomPois_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="multinomPois_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; to use fast C++ code or &quot;R&quot; to use native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="multinomPois_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes advantage of the closed form of the integrated
likelihood when a latent Poisson distribution is assumed for abundance
at each site and a multinomial distribution is taken for the observation
state. Many common sampling methods can be framed in this context.  For
example, double-observer point counts and removal sampling
can be analyzed with this function by specifying the proper
multinomial cell probablilities.  This is done with by supplying the
appropriate function (piFun) argument.  <a href="#topic+removalPiFun">removalPiFun</a> and <a href="#topic+doublePiFun">doublePiFun</a> are supplied as example cell probability functions.</p>


<h3>Value</h3>

<p>unmarkedFit object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Ian Fiske</p>


<h3>References</h3>

<p>Royle, J. A. (2004). Generalized estimators of avian abundance from
count survey data. Animal Biodiversity and Conservation, 27(1), 375-386.
</p>
<p>Royle, J. A., &amp; Dorazio, R. M. (2006). Hierarchical Models of Animal Abundance and Occurrence. Journal Of Agricultural Biological And Environmental Statistics, 11(3), 249.</p>


<h3>See Also</h3>

<p><a href="#topic+piFuns">piFuns</a>, <code><a href="#topic+unmarkedFrameMPois">unmarkedFrameMPois</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate independent double observer data
nSites &lt;- 50
lambda &lt;- 10
p1 &lt;- 0.5
p2 &lt;- 0.3
cp &lt;- c(p1*(1-p2), p2*(1-p1), p1*p2)
set.seed(9023)
N &lt;- rpois(nSites, lambda)
y &lt;- matrix(NA, nSites, 3)
for(i in 1:nSites) {
  y[i,] &lt;- rmultinom(1, N[i], c(cp, 1-sum(cp)))[1:3]
}

# Fit model
observer &lt;- matrix(c('A','B'), nSites, 2, byrow=TRUE)
umf &lt;- unmarkedFrameMPois(y=y, obsCovs=list(observer=observer),
    type="double")
fm &lt;- multinomPois(~observer-1 ~1, umf)

# Estimates of fixed effects
e &lt;- coef(fm)
exp(e[1])
plogis(e[2:3])

# Estimates of random effects
re &lt;- ranef(fm, K=20)
#ltheme &lt;- canonical.theme(color = FALSE)
#lattice.options(default.theme = ltheme)
plot(re, layout=c(10,5))



## Real data
data(ovendata)
ovenFrame &lt;- unmarkedFrameMPois(ovendata.list$data,
    siteCovs=as.data.frame(scale(ovendata.list$covariates[,-1])),
    type = "removal")
(fm1 &lt;- multinomPois(~ 1 ~ ufc + trba, ovenFrame))

# Detection probability for a single pass
backTransform(fm1, type="det")

# Detection probability after 4 removal passes
rowSums(getP(fm1))

# Empirical Bayes estimates of abundance at first 25 sites
# Very low uncertainty because p is very high
plot(ranef(fm1, K=10), layout=c(10,7), xlim=c(-1, 10))

</code></pre>

<hr>
<h2 id='multmixOpen'>
Open population multinomial N-mixture model
</h2><span id='topic+multmixOpen'></span>

<h3>Description</h3>

<p>Fit the model of Dail and Madsen (2011) and Hostetler and Chandler
(2015) for designs involving repeated counts that yield multinomial outcomes.
Possible data collection methods include repeated removal sampling and 
double observer sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multmixOpen(lambdaformula, gammaformula, omegaformula, pformula,
    data, mixture=c("P", "NB", "ZIP"), K,
    dynamics=c("constant", "autoreg", "notrend", "trend", "ricker", "gompertz"),
    fix=c("none", "gamma", "omega"), immigration=FALSE, iotaformula = ~1,
    starts, method="BFGS", se=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multmixOpen_+3A_lambdaformula">lambdaformula</code></td>
<td>
<p>Right-hand sided formula for initial abundance</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_gammaformula">gammaformula</code></td>
<td>
<p>Right-hand sided formula for recruitment rate (when 
dynamics is &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot;) or population growth rate 
(when dynamics is &quot;trend&quot;, &quot;ricker&quot;, or &quot;gompertz&quot;)</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_omegaformula">omegaformula</code></td>
<td>
<p>Right-hand sided formula for apparent survival probability
(when dynamics is &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot;) or equilibrium
abundance (when dynamics is &quot;ricker&quot; or &quot;gompertz&quot;)</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_pformula">pformula</code></td>
<td>
<p>A right-hand side formula describing the detection 
function covariates</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_data">data</code></td>
<td>
<p>An object of class <code><a href="#topic+unmarkedFrameMMO">unmarkedFrameMMO</a></code></p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_mixture">mixture</code></td>
<td>
<p>String specifying mixture: &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for
the Poisson, negative binomial, or zero-inflated Poisson
distributions respectively</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_k">K</code></td>
<td>
<p>Integer defining upper bound of discrete integration. This
should be higher than the maximum observed count and high enough
that it does not affect the parameter estimates. However, the higher
the value the slower the computation</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_dynamics">dynamics</code></td>
<td>
<p>Character string describing the type of population
dynamics. &quot;constant&quot; indicates that there is no relationship between
omega and gamma. &quot;autoreg&quot; is an auto-regressive model in which
recruitment is modeled as gamma*N[i,t-1]. &quot;notrend&quot; model gamma as
lambda*(1-omega) such that there is no temporal trend. &quot;trend&quot; is
a model for exponential growth, N[i,t] = N[i,t-1]*gamma, where gamma
in this case is finite rate of increase (normally referred to as
lambda). &quot;ricker&quot; and &quot;gompertz&quot; are models for density-dependent
population growth.  &quot;ricker&quot; is the Ricker-logistic model, N[i,t] =
N[i,t-1]*exp(gamma*(1-N[i,t-1]/omega)), where gamma is the maximum
instantaneous population growth rate (normally referred to as r) and
omega is the equilibrium abundance (normally referred to as K).  &quot;gompertz&quot;
is a modified version of the Gompertz-logistic model, N[i,t] =
N[i,t-1]*exp(gamma*(1-log(N[i,t-1]+1)/log(omega+1))), where the
interpretations of gamma and omega are similar to in the Ricker model</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_fix">fix</code></td>
<td>
<p>If &quot;omega&quot;, omega is fixed at 1. If &quot;gamma&quot;, gamma is fixed at 0</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_immigration">immigration</code></td>
<td>
<p>Logical specifying whether or not to include an immigration 
term (iota) in population dynamics</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_iotaformula">iotaformula</code></td>
<td>
<p>Right-hand sided formula for average number of immigrants 
to a site per time step</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_starts">starts</code></td>
<td>
<p>Vector of starting values</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_se">se</code></td>
<td>
<p>Logical specifying whether or not to compute standard errors</p>
</td></tr>
<tr><td><code id="multmixOpen_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These models generalize multinomial N-mixture models (Royle et al. 2004) by
relaxing the closure assumption (Dail and Madsen 2011, Hostetler and Chandler
2015, Sollmann et al. 2015).
</p>
<p>The models include two or three additional parameters:
gamma, either the recruitment rate (births and immigrations), the
finite rate of increase, or the maximum instantaneous rate of increase;
omega, either the apparent survival rate (deaths and emigrations) or the
equilibrium abundance (carrying capacity); and iota, the number of immigrants
per site and year. Estimates of
population size at each time period can be derived from these
parameters, and thus so can trend estimates. Or, trend can be estimated
directly using dynamics=&quot;trend&quot;.
</p>
<p>When immigration is set to FALSE (the default), iota is not modeled.
When immigration is set to TRUE and dynamics is set to &quot;autoreg&quot;, the model
will separately estimate birth rate (gamma) and number of immigrants (iota).
When immigration is set to TRUE and dynamics is set to &quot;trend&quot;, &quot;ricker&quot;, or
&quot;gompertz&quot;, the model will separately estimate local contributions to
population growth (gamma and omega) and number of immigrants (iota).
</p>
<p>The latent abundance distribution, <code class="reqn">f(N | \mathbf{\theta})</code> can be set as a Poisson, negative binomial, or zero-inflated
Poisson random
variable, depending on the setting of the <code>mixture</code> argument,
<code>mixture = "P"</code>, <code>mixture = "NB"</code>, <code>mixture = "ZIP"</code>
respectively.  For the first two distributions, the mean of <code class="reqn">N_i</code> is
<code class="reqn">\lambda_i</code>.  If <code class="reqn">N_i \sim NB</code>, then an
additional parameter, <code class="reqn">\alpha</code>, describes dispersion (lower
<code class="reqn">\alpha</code> implies higher variance). For the ZIP distribution,
the mean is <code class="reqn">\lambda_i(1-\psi)</code>, where psi is the
zero-inflation parameter.
</p>
<p>For &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot; dynamics, the latent abundance state
following the initial sampling period arises
from a
Markovian process in which survivors are modeled as <code class="reqn">S_{it} \sim
Binomial(N_{it-1}, \omega_{it})</code>, and recruits
follow <code class="reqn">G_{it} \sim Poisson(\gamma_{it})</code>.
Alternative population dynamics can be specified
using the <code>dynamics</code> and <code>immigration</code> arguments.
</p>
<p><code class="reqn">\lambda_i</code>, <code class="reqn">\gamma_{it}</code>, and
<code class="reqn">\iota_{it}</code> are modeled 
using the the log link.
<code class="reqn">p_{ijt}</code> is modeled using
the logit link.
<code class="reqn">\omega_{it}</code> is either modeled using the logit link (for
&quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot; dynamics) or the log link (for &quot;ricker&quot;
or &quot;gompertz&quot; dynamics).  For &quot;trend&quot; dynamics, <code class="reqn">\omega_{it}</code>
is not modeled.
</p>
<p>The detection process is modeled as multinomial:
<code class="reqn">\mathbf{y_{it}} \sim
Multinomial(N_{it}, \pi_{it})</code>,
where <code class="reqn">\pi_{ijt}</code> is the multinomial cell probability for
plot i at time t on occasion j.
</p>
<p>Options for the detection process include equal-interval removal sampling
(<code>"removal"</code>), double observer sampling (<code>"double"</code>), or 
dependent double-observer sampling (<code>"depDouble"</code>). This option is
specified when setting up the data using <code><a href="#topic+unmarkedFrameMMO">unmarkedFrameMMO</a></code>. Note
that unlike the related functions <code><a href="#topic+multinomPois">multinomPois</a></code> and
<code><a href="#topic+gmultmix">gmultmix</a></code>, custom functions for the detection process (i.e., 
<code>piFun</code>s) are not supported. To request additional options contact the author.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitMMO</p>


<h3>Warning</h3>

<p>This function can be extremely slow, especially if
there are covariates of gamma or omega. Consider testing the timing on
a small subset of the data, perhaps with se=FALSE. Finding the lowest
value of K that does not affect estimates will also help with speed. </p>


<h3>Note</h3>

<p>When gamma or omega are modeled using year-specific covariates, the
covariate data for the final year will be ignored; however,
they must be supplied.
</p>
<p>If the time gap between primary periods is not constant, an M by T
matrix of integers should be supplied to <code><a href="#topic+unmarkedFrameMMO">unmarkedFrameMMO</a></code>
using the <code>primaryPeriod</code> argument.
</p>
<p>Secondary sampling periods are optional, but can greatly improve the
precision of the estimates.
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a>, Richard Chandler</p>


<h3>References</h3>

<p>Dail, D. and L. Madsen (2011) Models for Estimating Abundance from
Repeated Counts of an Open Metapopulation. <em>Biometrics</em>. 67: 577-587.
</p>
<p>Hostetler, J. A. and R. B. Chandler (2015) Improved State-space Models for
Inference about Spatial and Temporal Variation in Abundance from Count Data.
<em>Ecology</em> 96: 1713-1723.
</p>
<p>Royle, J. A. (2004). Generalized estimators of avian abundance from
count survey data. <em>Animal Biodiversity and Conservation</em> 27(1), 375-386.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinomPois">multinomPois</a>, <a href="#topic+gmultmix">gmultmix</a>, <a href="#topic+unmarkedFrameMMO">unmarkedFrameMMO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
  #Generate some data 
  set.seed(123)
  lambda=4; gamma=0.5; omega=0.8; p=0.5
  M &lt;- 100; T &lt;- 5
  y &lt;- array(NA, c(M, 3, T))
  N &lt;- matrix(NA, M, T)
  S &lt;- G &lt;- matrix(NA, M, T-1)

  for(i in 1:M) {
    N[i,1] &lt;- rpois(1, lambda)
    y[i,1,1] &lt;- rbinom(1, N[i,1], p)    # Observe some
    Nleft1 &lt;- N[i,1] - y[i,1,1]         # Remove them
    y[i,2,1] &lt;- rbinom(1, Nleft1, p)   # ...
    Nleft2 &lt;- Nleft1 - y[i,2,1]
    y[i,3,1] &lt;- rbinom(1, Nleft2, p)

    for(t in 1:(T-1)) {
      S[i,t] &lt;- rbinom(1, N[i,t], omega)
      G[i,t] &lt;- rpois(1, gamma)
      N[i,t+1] &lt;- S[i,t] + G[i,t]
      y[i,1,t+1] &lt;- rbinom(1, N[i,t+1], p)    # Observe some
      Nleft1 &lt;- N[i,t+1] - y[i,1,t+1]         # Remove them
      y[i,2,t+1] &lt;- rbinom(1, Nleft1, p)   # ...
      Nleft2 &lt;- Nleft1 - y[i,2,t+1]
      y[i,3,t+1] &lt;- rbinom(1, Nleft2, p)
    }
  }
  y=matrix(y, M)
  
  #Create some random covariate data
  sc &lt;- data.frame(x1=rnorm(100))

  ## Not run: 
  #Create unmarked frame
  umf &lt;- unmarkedFrameMMO(y=y, numPrimary=5, siteCovs=sc, type="removal")

  #Fit model
  (fit &lt;- multmixOpen(~x1, ~1, ~1, ~1, K=30, data=umf))
  
  #Compare to truth
  cf &lt;- coef(fit)
  data.frame(model=c(exp(cf[1]), cf[2], exp(cf[3]), plogis(cf[4]), plogis(cf[5])), 
             truth=c(lambda, 0, gamma, omega, p))

  #Predict
  head(predict(fit, type='lambda'))

  #Check fit with parametric bootstrap
  pb &lt;- parboot(fit, nsims=15)
  plot(pb)

  # Empirical Bayes estimates of abundance for each site / year
  re &lt;- ranef(fit)
  plot(re, layout=c(10,5), xlim=c(-1, 10))
  
## End(Not run)

</code></pre>

<hr>
<h2 id='nmixTTD'>Fit N-mixture Time-to-detection Models</h2><span id='topic+nmixTTD'></span>

<h3>Description</h3>

<p>Fit N-mixture models with time-to-detection data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmixTTD(stateformula= ~1, detformula = ~1, data, K=100,
    mixture = c("P","NB"), ttdDist = c("exp", "weibull"), starts, method="BFGS", 
    se=TRUE, engine = c("C", "R"), threads = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmixTTD_+3A_stateformula">stateformula</code></td>
<td>
<p>Right-hand sided formula for the abundance at each site.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_detformula">detformula</code></td>
<td>
<p>Right-hand sided formula for mean time-to-detection.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_data">data</code></td>
<td>
<p><code>unmarkedFrameOccuTTD</code> object that supplies the data
(see <code><a href="#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code>). Note that only single-season
models are supported by <code>nmixTTD</code>.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_k">K</code></td>
<td>
<p>The upper summation index used to numerically integrate out the
latent abundance. This should be set high enough so that it does not
affect the parameter estimates. Computation time will increase with K.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_mixture">mixture</code></td>
<td>
<p>String specifying mixture distribution: &quot;P&quot; for Poisson or 
&quot;NB&quot; for negative binomial.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_ttddist">ttdDist</code></td>
<td>
<p>Distribution to use for time-to-detection; either
<code>"exp"</code> for the exponential, or <code>"weibull"</code> for the Weibull,
which adds an additional shape parameter <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_starts">starts</code></td>
<td>
<p>optionally, initial values for parameters in the optimization.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard errors.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; or &quot;R&quot; to use fast C++ code or native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="nmixTTD_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.</p>
</td></tr> 
<tr><td><code id="nmixTTD_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model extends time-to-detection (TTD) occupancy models to estimate site 
abundance using data from single or repeated visits. Latent abundance can be 
modeled as Poisson (<code>mixture="P"</code>) or negative binomial (<code>mixture="NB"</code>). 
Time-to-detection can be modeled as an exponential (<code>ttdDist="exp"</code>) or 
Weibull (<code>ttdDist="weibull"</code>) random variable with rate parameter <code class="reqn">\lambda</code> 
and, for the Weibull, an additional shape parameter <code class="reqn">k</code>. Note that 
<code>occuTTD</code> puts covariates on <code class="reqn">\lambda</code> and not <code class="reqn">1/\lambda</code>, i.e., 
the expected time between events. 
</p>
<p>Assuming that there are <code class="reqn">N</code> independent individuals at a site, and all
individuals have the same individual detection rate, the expected
detection rate across all individuals <code class="reqn">\lambda</code> is equal to the the 
individual-level detection rate <code class="reqn">r</code> multipled by the number of individuals
present <code class="reqn">N</code>.
</p>
<p>In the case where there are no detections before the maximum sample time at
a site (<code>surveyLength</code>) is reached, we are not sure if the site has 
<code class="reqn">N=0</code> or if we just didn't wait long enough for a detection. We therefore 
must censor (<code class="reqn">C</code> the exponential or Weibull distribution at the maximum survey 
length, <code class="reqn">Tmax</code>. Thus, assuming true abundance at site <code class="reqn">i</code> is 
<code class="reqn">N_i</code>, and an exponential distribution for the TTD <code class="reqn">y_i</code> (parameterized 
with the rate), then:
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim Exponential(r_i * N_i) C(Tmax)</code>
</p>

<p>Note that when <code class="reqn">N_i = 0</code>, the exponential rate <code class="reqn">lambda = 0</code> and the
scale is therefore <code class="reqn">1 / 0 = Inf</code>, and thus the value will be censored
at <code class="reqn">Tmax</code>.
</p>
<p>Because in <code>unmarked</code> values of <code>NA</code> are typically used to indicate 
missing values that were a result of the sampling structure (e.g., lost data), 
we indicate a censored <code class="reqn">y_i</code> in <code>nmixTTD</code> instead by setting 
<code class="reqn">y_i = Tmax_i</code> in the <code>y</code> matrix provided to 
<code><a href="#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code>. You can provide either a single value of 
<code class="reqn">Tmax</code> to the <code>surveyLength</code> argument of <code>unmarkedFrameOccuTTD</code>, 
or provide a matrix, potentially with a unique value of <code class="reqn">Tmax</code> for each 
value of <code>y</code>. Note that in the latter case the value of <code>y</code> that will 
be interpreted by <code>nmixTTD</code> as a censored observation (i.e., <code class="reqn">Tmax</code>) 
will differ between observations!
</p>


<h3>Value</h3>

<p>unmarkedFitNmixTTD object describing model fit.</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>Strebel, N., Fiss, C., Kellner, K. F., Larkin, J. L., Kery, M., &amp; Cohen, J (2021). 
Estimating abundance based on time-to-detection data. Methods in Ecology and Evolution 12: 909-920.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulate data
M = 1000 # Number of sites
nrep &lt;- 3 # Number of visits per site
Tmax = 5 # Max duration of a visit
alpha1 = -1 # Covariate on rate
beta1 = 1 # Covariate on density
mu.lambda = 1 # Rate at alpha1 = 0
mu.dens = 1 # Density at beta1 = 0

covDet &lt;- matrix(rnorm(M*nrep),nrow = M,ncol = nrep) #Detection covariate
covDens &lt;- rnorm(M) #Abundance/density covariate
dens &lt;- exp(log(mu.dens) + beta1 * covDens)
sum(N &lt;- rpois(M, dens)) # Realized density per site
lambda &lt;- exp(log(mu.lambda) + alpha1 * covDet) # per-individual detection rate
ttd &lt;- NULL
for(i in 1:nrep) {
  ttd &lt;- cbind(ttd,rexp(M, N*lambda[,i]))  # Simulate time to first detection per visit
}
ttd[N == 0,] &lt;- 5 # Not observed where N = 0; ttd set to Tmax
ttd[ttd &gt;= Tmax] &lt;- 5 # Crop at Tmax

#Build unmarked frame
umf &lt;- unmarkedFrameOccuTTD(y = ttd, surveyLength=5,
                            siteCovs = data.frame(covDens=covDens),
                            obsCovs = data.frame(covDet=as.vector(t(covDet))))

#Fit model
fit &lt;- nmixTTD(~covDens, ~covDet, data=umf, K=max(N)+10)

#Compare to truth
cbind(coef(fit), c(log(mu.dens), beta1, log(mu.lambda), alpha1))

#Predict abundance/density values
head(predict(fit, type='state'))


## End(Not run)
</code></pre>

<hr>
<h2 id='nonparboot-methods'> Nonparametric bootstrapping in unmarked </h2><span id='topic+nonparboot'></span><span id='topic+nonparboot-methods'></span><span id='topic+nonparboot+2CunmarkedFit-method'></span><span id='topic+nonparboot+2CunmarkedFitColExt-method'></span><span id='topic+nonparboot+2CunmarkedFitDS-method'></span><span id='topic+nonparboot+2CunmarkedFitMPois-method'></span><span id='topic+nonparboot+2CunmarkedFitOccu-method'></span><span id='topic+nonparboot+2CunmarkedFitOccuPEN-method'></span><span id='topic+nonparboot+2CunmarkedFitOccuPEN_CV-method'></span><span id='topic+nonparboot+2CunmarkedFitOccuRN-method'></span><span id='topic+nonparboot+2CunmarkedFitPCount-method'></span><span id='topic+nonparboot+2CunmarkedFitGDS-method'></span><span id='topic+nonparboot+2CunmarkedFitGMM-method'></span><span id='topic+nonparboot+2CunmarkedFitOccuTTD-method'></span><span id='topic+nonparboot+2CunmarkedFitOccuMulti-method'></span><span id='topic+nonparboot+2CunmarkedFitNmixTTD-method'></span><span id='topic+nonparboot+2CunmarkedFitGDR-method'></span><span id='topic+nonparboot+2CunmarkedFitDailMadsen-method'></span><span id='topic+nonparboot+2CunmarkedFitOccuCOP-method'></span>

<h3>Description</h3>

<p>Call <code>nonparboot</code> on an unmarkedFit to obtain non-parametric
bootstrap samples.  These can then be used by <code>vcov</code> in order to
get bootstrap estimates of standard errors.
</p>


<h3>Details</h3>

<p>Calling <code>nonparboot</code> on an unmarkedFit returns the original
unmarkedFit, with the bootstrap samples added on.  Then subsequent
calls to <code><a href="stats.html#topic+vcov">vcov</a></code> with the argument
<code>method="nonparboot"</code> will use these bootstrap samples.
Additionally, standard errors of derived estimates from either
<code><a href="#topic+linearComb">linearComb</a></code> or <code><a href="#topic+backTransform">backTransform</a></code> can be
instructed to use bootstrap samples by providing the argument
<code>method = "nonparboot"</code>.
</p>
<p>For <code><a href="#topic+occu">occu</a></code> and <code><a href="#topic+occuRN">occuRN</a></code> both sites and
occassions are re-sampled. For all other fitting functions, only sites
are re-sampled.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "unmarkedFit")</code></dt><dd><p> Obtain nonparametric
bootstrap samples for a general unmarkedFit.  </p>
</dd>
<dt><code>signature(object = "unmarkedFitColExt")</code></dt><dd><p> Obtain nonparametric
bootstrap samples for colext fits.  </p>
</dd>
<dt><code>signature(object = "unmarkedFitDS")</code></dt><dd><p> Obtain nonparametric
bootstrap samples for a distsamp fits. </p>
</dd>
<dt><code>signature(object = "unmarkedFitMPois")</code></dt><dd><p> Obtain nonparametric
bootstrap samples for a distsamp fits. </p>
</dd>
<dt><code>signature(object = "unmarkedFitOccu")</code></dt><dd><p>  Obtain nonparametric
bootstrap samples for a occu fits. </p>
</dd>
<dt><code>signature(object = "unmarkedFitOccuPEN")</code></dt><dd><p>  Obtain nonparametric
bootstrap samples for an occuPEN fit. </p>
</dd>
<dt><code>signature(object = "unmarkedFitOccuPEN_CV")</code></dt><dd><p>  Obtain nonparametric
bootstrap samples for occuPEN_CV fit. </p>
</dd>
<dt><code>signature(object = "unmarkedFitOccuRN")</code></dt><dd><p>  Obtain nonparametric
bootstrap samples for a occuRN fits. </p>
</dd>
<dt><code>signature(object = "unmarkedFitPCount")</code></dt><dd><p>  Obtain nonparametric
bootstrap samples for a pcount fits. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(ovendata)
ovenFrame &lt;- unmarkedFrameMPois(ovendata.list$data,
siteCovs=as.data.frame(scale(ovendata.list$covariates[,-1])), type = "removal")
(fm &lt;- multinomPois(~ 1 ~ ufc + trba, ovenFrame))
fm &lt;- nonparboot(fm, B = 20) # should use larger B in real life.
vcov(fm, method = "hessian")
vcov(fm, method = "nonparboot")
avg.abundance &lt;- backTransform(linearComb(fm, type = "state", coefficients = c(1, 0, 0)))

## Bootstrap sample information propagates through to derived quantities.
vcov(avg.abundance, method = "hessian")
vcov(avg.abundance, method = "nonparboot")
SE(avg.abundance, method = "nonparboot")
</code></pre>

<hr>
<h2 id='occu'>Fit the MacKenzie et al. (2002) Occupancy Model</h2><span id='topic+occu'></span>

<h3>Description</h3>

<p>This function fits the single season occupancy model of MacKenzie et al (2002).</p>


<h3>Usage</h3>

<pre><code class='language-R'>occu(formula, data, knownOcc=numeric(0), linkPsi=c("logit", "cloglog"),
            starts, method="BFGS", se=TRUE, engine=c("C", "R", "TMB"),
            threads = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occu_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and occupancy in that order.</p>
</td></tr>
<tr><td><code id="occu_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> object</p>
</td></tr>
<tr><td><code id="occu_+3A_knownocc">knownOcc</code></td>
<td>
<p>Vector of sites that are known to be occupied. These
should be supplied as row numbers of the y matrix, eg, c(3,8) if
sites 3 and 8 were known to be occupied a priori.</p>
</td></tr>
<tr><td><code id="occu_+3A_linkpsi">linkPsi</code></td>
<td>
<p>Link function for the occupancy model. Options are  
<code>"logit"</code> for the standard occupancy model or <code>"cloglog"</code> 
for the complimentary log-log link, which relates occupancy
to site-level abundance. See details.</p>
</td></tr>
<tr><td><code id="occu_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="occu_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occu_+3A_se">se</code></td>
<td>
<p>Logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="occu_+3A_engine">engine</code></td>
<td>
<p>Code to use for optimization. Either &quot;C&quot; for fast C++ code,
&quot;R&quot; for native R code, or &quot;TMB&quot; for Template Model Builder. &quot;TMB&quot; is
used automatically if your formula contains random effects.</p>
</td></tr>
<tr><td><code id="occu_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.</p>
</td></tr> 
<tr><td><code id="occu_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> and <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> for a
description of how to supply data to the <code>data</code> argument.
</p>
<p><code>occu</code> fits the standard occupancy model based on zero-inflated
binomial models (MacKenzie et al. 2006, Royle and Dorazio
2008).  The occupancy state process (<code class="reqn">z_i</code>) of site <code class="reqn">i</code> is
modeled as
</p>
<p style="text-align: center;"><code class="reqn">z_i \sim Bernoulli(\psi_i)</code>
</p>

<p>The observation process is modeled as
</p>
<p style="text-align: center;"><code class="reqn">y_{ij}|z_i \sim Bernoulli(z_i p_{ij})</code>
</p>

<p>By default, covariates of <code class="reqn">\psi_i</code> and <code class="reqn">p_{ij}</code> are modeled
using the logit link according to the <code>formula</code> argument.  The formula is a double right-hand sided formula
like <code>~ detform ~ occform</code> where <code>detform</code> is a formula for the detection process and <code>occform</code> is a
formula for the partially observed occupancy state.  See <a href="stats.html#topic+formula">formula</a> for details on constructing model formulae
in <span class="rlang"><b>R</b></span>.
</p>
<p>When <code>linkPsi = "cloglog"</code>, the complimentary log-log link 
function is used for <code class="reqn">psi</code> instead of the logit link. The cloglog link
relates occupancy probability to the intensity parameter of an underlying
Poisson process (Kery and Royle 2016). Thus, if abundance at a site is 
can be modeled as <code class="reqn">N_i ~ Poisson(\lambda_i)</code>, where 
<code class="reqn">log(\lambda_i) = \alpha + \beta*x</code>, then presence/absence data at the 
site can be modeled as <code class="reqn">Z_i ~ Binomial(\psi_i)</code> where 
<code class="reqn">cloglog(\psi_i) = \alpha + \beta*x</code>. 
</p>


<h3>Value</h3>

<p>unmarkedFitOccu object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Ian Fiske</p>


<h3>References</h3>

<p>Kery, Marc, and J. Andrew Royle. 2016. <em>Applied Hierarchical Modeling in
Ecology</em>, Volume 1. Academic Press. 
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy Rates
When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>
<p>MacKenzie, D. I. et al. 2006. <em>Occupancy Estimation and Modeling</em>.
Amsterdam: Academic Press.
</p>
<p>Royle, J. A. and R. Dorazio. 2008. <em>Hierarchical Modeling and Inference
in Ecology</em>. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>,
<code><a href="#topic+modSel">modSel</a></code>, <code><a href="#topic+parboot">parboot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)
plot(pferUMF, panels=4)
# add some fake covariates for illustration
siteCovs(pferUMF) &lt;- data.frame(sitevar1 = rnorm(numSites(pferUMF)))

# observation covariates are in site-major, observation-minor order
obsCovs(pferUMF) &lt;- data.frame(obsvar1 = rnorm(numSites(pferUMF) * obsNum(pferUMF)))

(fm &lt;- occu(~ obsvar1 ~ 1, pferUMF))

confint(fm, type='det', method = 'normal')
confint(fm, type='det', method = 'profile')

# estimate detection effect at obsvars=0.5
(lc &lt;- linearComb(fm['det'],c(1,0.5)))

# transform this to probability (0 to 1) scale and get confidence limits
(btlc &lt;- backTransform(lc))
confint(btlc, level = 0.9)

# Empirical Bayes estimates of proportion of sites occupied
re &lt;- ranef(fm)
sum(bup(re, stat="mode"))

</code></pre>

<hr>
<h2 id='occuCOP'>Fit the occupancy model using count dta</h2><span id='topic+occuCOP'></span>

<h3>Description</h3>

<p>This function fits a single season occupancy model using count data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuCOP(data, 
        psiformula = ~1, lambdaformula = ~1, 
        psistarts, lambdastarts, starts,
        method = "BFGS", se = TRUE, 
        engine = c("C", "R"), na.rm = TRUE, 
        return.negloglik = NULL, L1 = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuCOP_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccuCOP">unmarkedFrameOccuCOP</a></code> object created with the <code><a href="#topic+unmarkedFrameOccuCOP">unmarkedFrameOccuCOP</a></code> function.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_psiformula">psiformula</code></td>
<td>
<p>Formula describing the occupancy covariates.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_lambdaformula">lambdaformula</code></td>
<td>
<p>Formula describing the detection covariates.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_psistarts">psistarts</code></td>
<td>
<p>Vector of starting values for likelihood maximisation with <code><a href="stats.html#topic+optim">optim</a></code> for occupancy probability <code class="reqn">\psi</code>. These values must be logit-transformed (with <code><a href="stats.html#topic+qlogis">qlogis</a></code>) (see details). By default, optimisation will start at 0, corresponding to an occupancy probability of 0.5 (<code>plogis(0)</code> is 0.5).</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_lambdastarts">lambdastarts</code></td>
<td>
<p>Vector of starting values for likelihood maximisation with <code><a href="stats.html#topic+optim">optim</a></code> for detection rate <code class="reqn">\lambda</code>. These values must be log-transformed (with <code><a href="base.html#topic+log">log</a></code>) (see details). By default, optimisation will start at 0, corresponding to detection rate of 1 (<code>exp(0)</code> is 1).</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_starts">starts</code></td>
<td>
<p>Vector of starting values for likelihood maximisation with <code><a href="stats.html#topic+optim">optim</a></code>. If <code>psistarts</code> and <code>lambdastarts</code> are provided, <code>starts = c(psistarts, lambdastarts)</code>.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_method">method</code></td>
<td>
<p>Optimisation method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_se">se</code></td>
<td>
<p>Logical specifying whether to compute (<code>se=TRUE</code>) standard errors or not (<code>se=FALSE</code>).</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_engine">engine</code></td>
<td>
<p>Code to use for optimisation. Either <code>"C"</code> for fast C++ code, or <code>"R"</code> for native R code.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical specifying whether to fit the model (<code>na.rm=TRUE</code>) or not (<code>na.rm=FALSE</code>) if there are NAs in the <code><a href="#topic+unmarkedFrameOccuCOP">unmarkedFrameOccuCOP</a></code> object.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_return.negloglik">return.negloglik</code></td>
<td>
<p>A list of vectors of parameters (<code>c(psiparams, lambdaparams)</code>). If specified, the function will not maximise likelihood but return the negative log-likelihood for the those parameters in the <code>nll</code> column of a dataframe. See an example below.</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_l1">L1</code></td>
<td>
<p>Logical specifying whether the length of observations (<code>L</code>) are purposefully set to 1 (<code>L1=TRUE</code>) or not (<code>L1=FALSE</code>).</p>
</td></tr>
<tr><td><code id="occuCOP_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+optim">optim</a></code>, such as lower and upper bounds or a list of control parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+unmarkedFrameOccuCOP">unmarkedFrameOccuCOP</a></code> for a description of how to supply data to the <code>data</code> argument. See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> for a more general documentation of <code>unmarkedFrame</code> objects for the different models implemented in <span class="pkg">unmarked</span>.
</p>


<h4>The COP occupancy model</h4>

<p><code>occuCOP</code> fits a single season occupancy model using count data, as described in Pautrel et al. (2023). 
</p>
<p>The <strong>occupancy sub-model</strong> is:
</p>
<p style="text-align: center;"><code class="reqn">z_i \sim \text{Bernoulli}(\psi_i)</code>
</p>


<ul>
<li><p> With <code class="reqn">z_i</code> the occupany state of site <code class="reqn">i</code>. <code class="reqn">z_i=1</code> if site <code class="reqn">i</code> is occupied by the species, <em>i.e.</em> if the species is present in site <code class="reqn">i</code>. <code class="reqn">z_i=0</code> if site <code class="reqn">i</code> is not occupied.
</p>
</li>
<li><p> With <code class="reqn">\psi_i</code> the occupancy probability of site <code class="reqn">i</code>.
</p>
</li></ul>

<p>The <strong>observation sub-model</strong> is:
</p>
<p style="text-align: center;"><code class="reqn">
      N_{ij} | z_i = 1 \sim \text{Poisson}(\lambda_{ij} L_{ij}) \\
      N_{ij} | z_i = 0 \sim 0
    </code>
</p>


<ul>
<li><p> With <code class="reqn">N_{ij}</code> the count of detection events in site <code class="reqn">i</code> during observation <code class="reqn">j</code>.
</p>
</li>
<li><p> With <code class="reqn">\lambda_{ij}</code> the detection rate in site <code class="reqn">i</code> during observation <code class="reqn">j</code> (<em>for example, 1 detection per day.</em>).
</p>
</li>
<li><p> With <code class="reqn">L_{ij}</code> the length of observation <code class="reqn">j</code> in site <code class="reqn">i</code> (<em>for example, 7 days.</em>).
</p>
</li></ul>

<p>What we call &quot;observation&quot; (<code class="reqn">j</code>) here can be a sampling occasion, a transect, a discretised session. Consequently, the unit of <code class="reqn">\lambda_{ij}</code> and <code class="reqn">L_{ij}</code> can be either a time-unit (day, hour, ...) or a space-unit (kilometer, meter, ...).
</p>



<h4>The transformation of parameters <code class="reqn">\psi</code> and <code class="reqn">\lambda</code></h4>

<p>In order to perform unconstrained optimisation, parameters are transformed.
</p>
<p>The occupancy probability (<code class="reqn">\psi</code>) is transformed with the logit function (<code>psi_transformed = qlogis(psi)</code>). It can be back-transformed with the &quot;inverse logit&quot; function (<code>psi = plogis(psi_transformed)</code>).
</p>
<p>The detection rate (<code class="reqn">\lambda</code>) is transformed with the log function (<code>lambda_transformed = log(lambda)</code>). It can be back-transformed with the exponential function (<code>lambda = exp(lambda_transformed)</code>).
</p>



<h3>Value</h3>

<p><code>unmarkedFitOccuCOP</code> object describing the model fit. See the <code><a href="#topic+unmarkedFit-class">unmarkedFit</a></code> classes.</p>


<h3>Author(s)</h3>

<p>La Pautrel</p>


<h3>References</h3>

<p>Pautrel, L., Moulherat, S., Gimenez, O. &amp; Etienne, M.-P. Submitted. <em>Analysing biodiversity observation data collected in continuous time: Should we use discrete or continuous-time occupancy models?</em> Preprint at <a href="https://doi.org/10.1101/2023.11.17.567350">doi:10.1101/2023.11.17.567350</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, 
<code><a href="#topic+unmarkedFrameOccuCOP">unmarkedFrameOccuCOP</a></code>,
<code><a href="#topic+unmarkedFit-class">unmarkedFit-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
options(max.print = 50)

# We simulate data in 100 sites with 3 observations of 7 days per site.
nSites &lt;- 100
nObs &lt;- 3

# For an occupancy covariate, we associate each site to a land-use category.
landuse &lt;- sample(factor(c("Forest", "Grassland", "City"), ordered = TRUE), 
                  size = nSites, replace = TRUE)
simul_psi &lt;- ifelse(landuse == "Forest", 0.8, 
                    ifelse(landuse == "Grassland", 0.4, 0.1))
z &lt;- rbinom(n = nSites, size = 1, prob = simul_psi)

# For a detection covariate, we create a fake wind variable.
wind &lt;- matrix(rexp(n = nSites * nObs), nrow = nSites, ncol = nObs)
simul_lambda &lt;- wind / 5
L = matrix(7, nrow = nSites, ncol = nObs)

# We now simulate count detection data
y &lt;- matrix(rpois(n = nSites * nObs, lambda = simul_lambda * L), 
            nrow = nSites, ncol = nObs) * z

# We create our unmarkedFrameOccuCOP object
umf &lt;- unmarkedFrameOccuCOP(
  y = y,
  L = L,
  siteCovs = data.frame("landuse" = landuse),
  obsCovs = list("wind" = wind)
)
print(umf)

# We fit our model without covariates
fitNull &lt;- occuCOP(data = umf)
print(fitNull)

# We fit our model with covariates
fitCov &lt;- occuCOP(data = umf, psiformula = ~ landuse, lambdaformula = ~ wind)
print(fitCov)

# We back-transform the parameter's estimates
## Back-transformed occupancy probability with no covariates
backTransform(fitNull, "psi")

## Back-transformed occupancy probability depending on habitat use
predict(fitCov,
        "psi",
        newdata = data.frame("landuse" = c("Forest", "Grassland", "City")),
        appendData = TRUE)

## Back-transformed detection rate with no covariates
backTransform(fitNull, "lambda")

## Back-transformed detection rate depending on wind
predict(fitCov,
        "lambda",
        appendData = TRUE)

## This is not easily readable. We can show the results in a clearer way, by:
##  - adding the site and observation
##  - printing only the wind covariate used to get the predicted lambda
cbind(
  data.frame(
    "site" = rep(1:nSites, each = nObs),
    "observation" = rep(1:nObs, times = nSites),
    "wind" = getData(fitCov)@obsCovs
  ),
  predict(fitCov, "lambda", appendData = FALSE)
)

# We can choose the initial parameters when fitting our model.
# For psi, intituively, the initial value can be the proportion of sites 
#          in which we have observations.
(psi_init &lt;- mean(rowSums(y) &gt; 0))

# For lambda, the initial value can be the mean count of detection events 
#             in sites in which there was at least one observation.
(lambda_init &lt;- mean(y[rowSums(y) &gt; 0, ]))

# We have to transform them.
occuCOP(
  data = umf,
  psiformula = ~ 1,
  lambdaformula = ~ 1,
  psistarts = qlogis(psi_init),
  lambdastarts = log(lambda_init)
)

# If we have covariates, we need to have the right length for the start vectors.
# psi ~ landuse --&gt; 3 param to estimate: Intercept, landuseForest, landuseGrassland
# lambda ~ wind --&gt; 2 param to estimate: Intercept, wind
occuCOP(
  data = umf,
  psiformula = ~ landuse,
  lambdaformula = ~ wind,
  psistarts = rep(qlogis(psi_init), 3),
  lambdastarts = rep(log(lambda_init), 2)
)

# And with covariates, we could have chosen better initial values, such as the
# proportion of sites in which we have observations per land-use category.
(psi_init_covs &lt;- c(
  "City" = mean(rowSums(y[landuse == "City", ]) &gt; 0),
  "Forest" = mean(rowSums(y[landuse == "Forest", ]) &gt; 0),
  "Grassland" = mean(rowSums(y[landuse == "Grassland", ]) &gt; 0)
))
occuCOP(
  data = umf,
  psiformula = ~ landuse,
  lambdaformula = ~ wind,
  psistarts = qlogis(psi_init_covs))

# We can fit our model with a different optimisation algorithm.
occuCOP(data = umf, method = "Nelder-Mead")

# We can run our model with a C++ or with a R likelihood function.
## They give the same result. 
occuCOP(data = umf, engine = "C", psistarts = 0, lambdastarts = 0)
occuCOP(data = umf, engine = "R", psistarts = 0, lambdastarts = 0)

## The C++ (the default) is faster.
system.time(occuCOP(data = umf, engine = "C", psistarts = 0, lambdastarts = 0))
system.time(occuCOP(data = umf, engine = "R", psistarts = 0, lambdastarts = 0))

## However, if you want to understand how the likelihood is calculated,
## you can easily access the R likelihood function.
print(occuCOP(data = umf, engine = "R", psistarts = 0, lambdastarts = 0)@nllFun)

# Finally, if you do not want to fit your model but only get the likelihood,
# you can get the negative log-likelihood for a given set of parameters.
occuCOP(data = umf, return.negloglik = list(
  c("psi" = qlogis(0.25), "lambda" = log(2)),
  c("psi" = qlogis(0.5), "lambda" = log(1)),
  c("psi" = qlogis(0.75), "lambda" = log(0.5))
))
</code></pre>

<hr>
<h2 id='occuFP'>Fit occupancy models when false positive detections occur (e.g., Royle and Link [2006]
and Miller et al. [2011]) </h2><span id='topic+occuFP'></span>

<h3>Description</h3>

<p>This function fits the single season occupancy model while allowing for
false positive detections.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuFP(detformula = ~ 1, FPformula = ~ 1, Bformula = ~ 1, 
stateformula = ~ 1, data, starts, method="BFGS", se = TRUE, engine = "R", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuFP_+3A_detformula">detformula</code></td>
<td>
<p>formula describing covariates of
detection.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_fpformula">FPformula</code></td>
<td>
<p>formula describing covariates of
false positive detection probability.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_bformula">Bformula</code></td>
<td>
<p>formula describing covariates of
probability detections are certain.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_stateformula">stateformula</code></td>
<td>
<p>formula describing covariates of
occupancy.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccuFP">unmarkedFrameOccuFP</a></code> object</p>
</td></tr>
<tr><td><code id="occuFP_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_se">se</code></td>
<td>
<p>Logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_engine">engine</code></td>
<td>
<p>Currently only choice is R.</p>
</td></tr>
<tr><td><code id="occuFP_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> and <code><a href="#topic+unmarkedFrameOccuFP">unmarkedFrameOccuFP</a></code> for a
description of how to supply data to the <code>data</code> argument.
</p>
<p><code>occuFP</code> fits an extension of the standard single-season occupancy model (MacKenzie et al. 2002), which allows
false positive detections. The occupancy status of a site is the same way as with the <code><a href="#topic+occu">occu</a></code> function, where stateformula
is used to specify factors that lead to differences in occupancy probabilities among sites.
</p>
<p>The observation process differs in that both false negative and false positive errors are modeled for observations. The
function allows data to be of 3 types. These types are specified using in <code>unmarkedFrameOccuFP</code> as type. Occassions
are specified to belong to 1 of the 3 data types and all or a subset of the data types can be combined in the same model.
</p>
<p>For type 1 data, the detection process is assumed to fit the assumptions of the standard MacKenzie model
where false negative probabilities are estimated but false positive detections are assumed not to occur. If all of your
data is of this type you should use <code>occu</code> to analyze data. The detection parameter p, which is modeled using the
detformula is the only observation parameter for these data.
</p>
<p>For type 2 data, both false negative and false positive detection probabilities are estimated. If all data is of this
type the likelihood follows Royle and Link (2006). Both p (the true positive detection probability) and fp (the false
positive detection probability described by fpformula) are estimated for occassions when this data type occurs
</p>
<p>For type 3 data, observations are assumed to include both certain detections (false positives assumed not to occur)
and uncertain detections that may include false positive detections. When only this data type occurs, the estimator
is the same as the multiple detection state model described in Miller et al. (2011). Three observation parameters occur
for this data type: p - true positive detection probability, fp - false positive detection probability, and b - the
probability a true positive detection was designated as certain.
</p>
<p>When both type 1 and type 2 data occur, the estimator is equivalent to the multiple detection method model described
in Miller et al. (2011). The frog data example in the same paper uses an analysis where type 1 (dipnet surveys) and
type 3 (call surveys) data were used.
</p>
<p>Data in the y matrix of the unmarked frame should be all 0s and 1s for
type 1 and type 2 data. For type 3 data, uncertain detections are given
a value of 1 and certain detections a value of 2.  </p>


<h3>Value</h3>

<p>unmarkedFitOccuFP object describing the model fit.</p>


<h3>Author(s)</h3>

<p>David Miller</p>


<h3>References</h3>

<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy Rates
When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>
<p>Miller, D.A., J.D. Nichols, B.T. McClintock, E.H.C. Grant, L.L. Bailey,
and L.A. Weir. 2011. Improving occupancy estimation when two types of
observational error occur: non-detection and species
misidentification. Ecology 92:1422-1428.
</p>
<p>Royle, J.A., and W.A. Link. 2006. Generalized site occupancy models
allowing for false positive and false negative errors. Ecology
87:835-841.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccuFP">unmarkedFrameOccuFP</a></code>,
<code><a href="#topic+modSel">modSel</a></code>, <code><a href="#topic+parboot">parboot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
n = 100
o = 10
o1 = 5
y = matrix(0,n,o)
p = .7
r = .5
fp = 0.05
y[1:(n*.5),(o-o1+1):o] &lt;- rbinom((n*o1*.5),1,p)
y[1:(n*.5),1:(o-o1)] &lt;- rbinom((o-o1)*n*.5,1,r)
y[(n*.5+1):n,(o-o1+1):o] &lt;- rbinom((n*o1*.5),1,fp)
type &lt;- c((o-o1),o1,0)  ### vector with the number of each data type
site &lt;- c(rep(1,n*.5*.8),rep(0,n*.5*.2),rep(1,n*.5*.2),rep(0,n*.8*.5))
occ &lt;- matrix(c(rep(0,n*(o-o1)),rep(1,n*o1)),n,o)
site &lt;- data.frame(habitat = site)
occ &lt;- list(METH = occ)

umf1 &lt;- unmarkedFrameOccuFP(y,site,occ, type = type)

m1 &lt;- occuFP(detformula = ~ METH, FPformula = ~1,
             stateformula = ~ habitat, data = umf1)
predict(m1, type = 'fp')
coef(m1)
confint(m1, type = 'det')

</code></pre>

<hr>
<h2 id='occuMS'>Fit Single-Season and Dynamic Multi-State Occupancy Models</h2><span id='topic+occuMS'></span>

<h3>Description</h3>

<p>This function fits single-season and dynamic multi-state occupancy models with both the multinomial and conditional binomial parameterizations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuMS(detformulas, psiformulas, phiformulas=NULL, data, 
    parameterization=c("multinomial","condbinom"),
    starts, method="BFGS", se=TRUE, engine=c("C","R"), silent=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuMS_+3A_detformulas">detformulas</code></td>
<td>
<p>Character vector of formulas for detection probabilities.
See details for a description of how to order these formulas.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_psiformulas">psiformulas</code></td>
<td>
<p>Character vector of formulas for occupancy probabilities. 
See details for a description of how to order these formulas.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_phiformulas">phiformulas</code></td>
<td>
<p>Character vector of formulas for state transition probabilities. 
Only used if you are fitting a dynamic model. See details for a 
description of how to order these formulas.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccuMS">unmarkedFrameOccuMS</a></code> object</p>
</td></tr>
<tr><td><code id="occuMS_+3A_parameterization">parameterization</code></td>
<td>
<p>Either <code>"multinomial"</code> for the multinomial 
parameterization (MacKenzie et al. 2009) which allows an arbitrary
number of occupancy states, or <code>"condbinom"</code> for the conditional 
binomial parameterization (Nichols et al. 2007) which requires exactly
3 occupancy states. See details.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_se">se</code></td>
<td>
<p>Logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; to use fast C++ code or &quot;R&quot; to use native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_silent">silent</code></td>
<td>
<p>Boolean; if <code>TRUE</code>, suppress warnings.</p>
</td></tr>
<tr><td><code id="occuMS_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traditional occupancy models fit data with exactly two states: detection and
non-detection (MacKenzie et al. 2002).
The <code>occuMS</code> function fits models to occupancy data for which there are 
greater than 2 states (Nichols et al 2007, MacKenzie et al. 2009). For example, 
detections may be further divided into multiple biologically relevant categories, 
e.g. breeding vs. non-breeding, or some/many individuals present. As with
detection status, classification of these additional occupancy states is likely
to be imperfect.
</p>
<p>Multiple parameterizations for multi-state occupancy models have been proposed.
The <code>occuMS</code> function fits two at present: the &quot;conditional binomial&quot; 
parameterization of Nichols et al. (2007), and the more general &quot;multinomial&quot;
parameterization of MacKenzie et al. (2009). Both single-season
and dynamic models are possible with <code>occuMS</code> (MacKenzie et al. 2009).
</p>
<p>The conditional binomial parameterization 
(<code>parameterization = 'condbinom'</code>) models occupancy and the presence or
absence of an additional biological state of interest given the species
is present (typically breeding status). Thus, there should be exactly 3 occupancy 
states in the data: 0 (non-detection); 1 (detection, no evidence of breeding);
or 2 (detection, evidence of breeding). 
</p>
<p>Two state parameters are estimated:
<code class="reqn">\psi</code>, the probability of occupancy, and <code class="reqn">R</code>, the probability of 
successful reproduction given an occupied state (although this could be some
other binary biological condition). Covariates (in <code>siteCovs</code>) can be 
supplied for either or both of these parameters with the <code>stateformulas</code> 
argument, which takes a character vector of R-style formulas with length = 2, 
with formulas in the order (<code class="reqn">\psi</code>, <code class="reqn">R</code>). For example, to fit a model 
where <code class="reqn">\psi</code> varies with a landcover covariate and <code class="reqn">R</code> is constant,
<code>stateformulas = c('~landcover','~1')</code>. 
</p>
<p>There are three detection parameters associated with the
conditional binomial parameterization: <code class="reqn">p_1</code>, the probability of 
detecting the species given true state 1; <code class="reqn">p_2</code>, the probability of detecting
the species given true state 2; and <code class="reqn">\delta</code>, the probability of detecting 
state 2 (i.e., breeding), given that the species has been detected.
See MacKenzie et al. (2009), pages 825-826 for more details.
As with occupancy, covariates (in <code>obsCovs</code>) can be supplied for these 
detection probabilities with the <code>detformulas</code> argument, which takes a 
character vector of formulas with length = 3 in the order 
(<code class="reqn">p_1</code>, <code class="reqn">p_2</code>, <code class="reqn">\delta</code>). So, to fit a model where <code class="reqn">p_1</code> varies 
with temperature and the other two parameters are constant, 
<code>detformulas = c('~temp','~1','~1')</code>.
</p>
<p>The multinomial parameterization (<code>parameterization = "multinomial"</code>) is
more general, allowing an arbitrary number of occupancy states <code class="reqn">S</code>.
<code class="reqn">S</code> - 1 occupancy probabilities <code class="reqn">\psi</code> are estimated. Thus, if there
are <code class="reqn">S</code> = 4 occupancy states (0, 1, 2, 3), <code>occuMS</code> estimates <code class="reqn">\psi_1</code>,
<code class="reqn">\psi_2</code>, and <code class="reqn">\psi_3</code> (the probability of state 0 can be obtained by 
subtracting the others from 1). Covariates can be supplied for each occupancy
probability with a character vector with length <code class="reqn">S-1</code>, e.g. 
<code>stateformulas =</code> <code>c('~landcover','~1','~1')</code> where <code class="reqn">\psi_1</code> varies with
landcover and <code class="reqn">\psi_2</code> and <code class="reqn">\psi_3</code> are constant.
</p>
<p>The number of detection probabilities estimated quickly expands as <code class="reqn">S</code>
increases, equal to <code class="reqn">S \times (S-1) / 2</code>. In the simplest case
(when <code class="reqn">S</code> = 3), there are 3 detection probabilities: <code class="reqn">p_{11}</code>, 
the probability of detecting state 1 given true state 1; <code class="reqn">p_{12}</code>, 
the probability of detecting state 1 given true state 2; and <code class="reqn">p_{22}</code>, 
the probability of detecting state 2 given true state 2. 
Covariates can be supplied for any or all of these detection probabilities with 
the <code>detformulas</code> argument, which takes a character vector of formulas 
with length = 3 in the order (<code class="reqn">p_{11}</code>, <code class="reqn">p_{12}</code>, <code class="reqn">p_{22}</code>). So, 
to fit a model where <code class="reqn">p_{11}</code> varies with temperature and the other two detection 
probabilities are constant, <code>detformulas = c('~temp','~1','~1')</code>.
If there were <code class="reqn">S</code> = 4 occupancy states, there are 6 estimated detection
probabilities and the order is (<code class="reqn">p_{11}</code>, <code class="reqn">p_{12}</code>, <code class="reqn">p_{13}</code>,
<code class="reqn">p_{22}</code>, <code class="reqn">p_{23}</code>, <code class="reqn">p_{33}</code>), and so on. See MacKenzie et al. (2009)
for a more detailed explanation.
</p>
<p>Dynamic (multi-season) models can be fit as well for both parameterizations
(MacKenzie et al. 2009). In a standard dynamic occupancy model, additional
parameters for probabilities of colonization (i.e., state 0 -&gt; 1) and 
extinction (1 -&gt; 0) are estimated. In a multi-state context, we must estimate a
transition probability matrix (<code class="reqn">\phi</code>) between all possible states. You can 
provide formulas for some of the probabilities in this matrix using the 
<code>phiformulas</code> argument. The approach differs depending on parameterization.
</p>
<p>For the conditional binomial parameterization, <code>phiformulas</code> is a 
character vector of length 6. The first three elements are formulas for the 
probability a site is occupied at time <code class="reqn">t</code> given that it was previously
in states 0, 1, or 2 at time <code class="reqn">t-1</code> (<code>phi0, phi1, phi2</code>). Elements 4-6 
are formulas for the probability of reproduction (or other biological state) 
given state 0, 1, or 2 at time <code class="reqn">t-1</code> (<code>R0, R1, R2</code>). See 
<code>umf@phiOrder$cond_binom</code> for a reminder of the correct order, where
<code>umf</code> is your <code>unmarkedFrameOccuMS</code>.
</p>
<p>For the multinomial parameterization, <code>phiformulas</code> can be used to provide
formulas for some transitions between different occupancy states. You can't 
give formulas for the probabilities of remaining in the same state between 
seasons to keep the model identifiable. Thus, if there are 3 possible states
(0, 1, 2), <code>phiformulas</code> should contain 6 formulas for the following 
transitions: <code>p(0-&gt;1), p(0-&gt;2), p(1-&gt;0), p(1-&gt;2), p(2-&gt;0), p(2-&gt;1)</code>,
in that order (and similar for more than 3 states). The remaining probabilities
of staying in the same state between seasons can be obtained via subtraction.
See <code>umf@phiOrder$multinomial</code> for the correct order matching the number
of states in your dataset.
</p>
<p>See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> and <code><a href="#topic+unmarkedFrameOccuMS">unmarkedFrameOccuMS</a></code> for a
description of how to supply data to the <code>data</code> argument.
</p>


<h3>Value</h3>

<p>unmarkedFitOccuMS object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy Rates
When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>
<p>MacKenzie, D. I., Nichols, J. D., Seamans, M. E., and R. J. Gutierrez, 2009. 
Modeling species occurrence dynamics with multiple states and imperfect 
detection. Ecology 90: 823-835.
</p>
<p>Nichols, J. D., Hines, J. E., Mackenzie, D. I., Seamans, M. E., and 
R. J. Gutierrez. 2007. Occupancy estimation and modeling with multiple states 
and state uncertainty. Ecology 88: 1395-1400.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccuMS">unmarkedFrameOccuMS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#Simulate data

#Parameters
N &lt;- 500; J &lt;- 5; S &lt;- 3
site_covs &lt;- matrix(rnorm(N*2),ncol=2)
obs_covs &lt;- matrix(rnorm(N*J*2),ncol=2)
a1 &lt;- -0.5; b1 &lt;- 1; a2 &lt;- -0.6; b2 &lt;- -0.7

##################################
## Multinomial parameterization ##
##################################

p11 &lt;- -0.4; p12 &lt;- -1.09; p22 &lt;- -0.84
truth &lt;- c(a1,b1,a2,b2,p11,0,p12,p22)

#State process
lp &lt;- matrix(NA,ncol=S,nrow=N)
for (n in 1:N){
  lp[n,2] &lt;- exp(a1+b1*site_covs[n,1])
  lp[n,3] &lt;- exp(a2+b2*site_covs[n,2])
  lp[n,1] &lt;- 1  
}
psi_mat &lt;- lp/rowSums(lp)

z &lt;- rep(NA,N)
for (n in 1:N){
  z[n] &lt;- sample(0:2, 1, replace=T, prob=psi_mat[n,])
}

probs_raw &lt;- matrix(c(1,0,0,1,exp(p11),0,1,exp(p12),exp(p22)),nrow=3,byrow=T)
probs_raw &lt;- probs_raw/rowSums(probs_raw)
  
y &lt;- matrix(0,nrow=N,ncol=J)
for (n in 1:N){

  probs &lt;- switch(z[n]+1,
                  probs_raw[1,],
                  probs_raw[2,],
                  probs_raw[3,])
  if(z[n]&gt;0){
    y[n,] &lt;- sample(0:2, J, replace=T, probs)
  }
}

#Construct unmarkedFrame
umf &lt;- unmarkedFrameOccuMS(y=y,siteCovs=as.data.frame(site_covs),
                           obsCovs=as.data.frame(obs_covs))

#Formulas

#3 states, so detformulas is a character vector of formulas of 
#length 3 in following order:
#1) p[11]: prob of detecting state 1 given true state 1
#2) p[12]: prob of detecting state 1 given true state 2
#3) p[22]: prob of detecting state 2 given true state 2
detformulas &lt;- c('~V1','~1','~1')
#If you had 4 states, it would be p[11],p[12],p[13],p[22],p[23],p[33] and so on

#3 states, so stateformulas is a character vector of length 2 in following order:
#1) psi[1]: probability of state 1
#2) psi[2]: probability of state 2
#You can get probability of state 0 (unoccupied) as 1 - psi[1] - psi[2]
stateformulas &lt;- c('~V1','~V2')

#Fit model
fit &lt;- occuMS(detformulas, stateformulas, data=umf,
              parameterization="multinomial")

#Look at results
fit
#Compare with truth
cbind(truth=truth,estimate=coef(fit))

#Generate predicted values
lapply(predict(fit,type='psi'),head)
lapply(predict(fit,type='det'),head)

#Fit a null model
detformulas &lt;- rep('~1',3)
stateformulas &lt;- rep('~1',2)
fit_null &lt;- occuMS(detformulas, stateformulas, data=umf,
                   parameterization="multinomial")

#Compare fits
modSel(fitList(fit,fit_null))

###########################################
## Conditional binomial parameterization ##
###########################################

p11 &lt;- 0.4; p12 &lt;- 0.6; p22 &lt;- 0.8
truth_cb &lt;- c(a1,b1,a2,b2,qlogis(p11),0,qlogis(c(p12,p22)))

#Simulate data

#State process
psi_mat &lt;- matrix(NA,ncol=S,nrow=N)
for (n in 1:N){
  psi_mat[n,2] &lt;- plogis(a1+b1*site_covs[n,1])
  psi_mat[n,3] &lt;- plogis(a2+b2*site_covs[n,2])
}
psi_bin &lt;- matrix(NA,nrow=nrow(psi_mat),ncol=ncol(psi_mat))
psi_bin[,1] &lt;- 1-psi_mat[,2]
psi_bin[,2] &lt;- (1-psi_mat[,3])*psi_mat[,2]
psi_bin[,3] &lt;- psi_mat[,2]*psi_mat[,3]
z &lt;- rep(NA,N)
for (n in 1:N){
  z[n] &lt;- sample(0:2, 1, replace=T, prob=psi_bin[n,])
}

#Detection process
y_cb &lt;- matrix(0,nrow=N,ncol=J)
for (n in 1:N){
  #p11 = p1; p12 = p2; p22 = delta
  probs &lt;- switch(z[n]+1,
                  c(1,0,0),
                  c(1-p11,p11,0),
                  c(1-p12,p12*(1-p22),p12*p22)) 
  if(z[n]&gt;0){
    y_cb[n,] &lt;- sample(0:2, J, replace=T, probs)
  }
}

#Build unmarked frame
umf2 &lt;- unmarkedFrameOccuMS(y=y_cb,siteCovs=as.data.frame(site_covs),
                           obsCovs=as.data.frame(obs_covs))

#Formulas

#detformulas is a character vector of formulas of length 3 in following order:
#1) p[1]: prob of detecting species given true state 1
#2) p[2]: prob of detecting species given true state 2
#3) delta: prob of detecting state 2 (eg breeding) given species was detected
detformulas &lt;- c('~V1','~1','~1')

#stateformulas is a character vector of length 2 in following order:
#1) psi: probability of occupancy
#2) R: probability state 2 (eg breeding) given occupancyc
stateformulas &lt;- c('~V1','~V2')

#Fit model
fit_cb &lt;- occuMS(detformulas, stateformulas, data=umf2,
                 parameterization='condbinom')

#Look at results
fit_cb
#Compare with truth
cbind(truth=truth_cb,estimate=coef(fit_cb))

#Generate predicted values
lapply(predict(fit_cb,type='psi'),head)
lapply(predict(fit_cb,type='det'),head)


##################################
## Dynamic (multi-season) model ##
##################################

#Simulate data-----------------------------------------------
N &lt;- 500 #Number of sites
T &lt;- 3 #Number of primary periods
J &lt;- 5 #Number of secondary periods
S &lt;- 3 #Number of occupancy states (0,1,2)

#Generate covariates
site_covs &lt;- as.data.frame(matrix(rnorm(N*2),ncol=2))
yearly_site_covs &lt;- as.data.frame(matrix(rnorm(N*T*2),ncol=2))
obs_covs &lt;- as.data.frame(matrix(rnorm(N*J*T*2),ncol=2))

#True parameter values
b &lt;- c(
  #Occupancy parameters
  a1=-0.5, b1=1, a2=-0.6, b2=-0.7,
  #Transition prob (phi) parameters
  phi01=0.7, phi01_cov=-0.5, phi02=-0.5, phi10=1.2, 
  phi12=0.3, phi12_cov=1.1, phi20=-0.3, phi21=1.4, phi21_cov=0,
  #Detection prob parameters
  p11=-0.4, p11_cov=0, p12=-1.09, p22=-0.84
)

#Generate occupancy probs (multinomial parameterization)
lp &lt;- matrix(1, ncol=S, nrow=N)
lp[,2] &lt;- exp(b[1]+b[2]*site_covs[,1])
lp[,3] &lt;- exp(b[3]+b[4]*site_covs[,2])
psi &lt;- lp/rowSums(lp)

#True occupancy state matrix
z &lt;- matrix(NA, nrow=N, ncol=T)

#Initial occupancy
for (n in 1:N){
  z[n,1] &lt;- sample(0:(S-1), 1, prob=psi[n,])
}

#Raw phi probs
phi_raw &lt;- matrix(NA, nrow=N*T, ncol=S^2-S)
phi_raw[,1] &lt;- exp(b[5]+b[6]*yearly_site_covs[,1]) #p[0-&gt;1]
phi_raw[,2] &lt;- exp(b[7]) #p[0-&gt;2]
phi_raw[,3] &lt;- exp(b[8]) #p[1-&gt;0]
phi_raw[,4] &lt;- exp(b[9]+b[10]*yearly_site_covs[,2]) #p[1-&gt;2]
phi_raw[,5] &lt;- exp(b[11]) #p[2-&gt;0]
phi_raw[,6] &lt;- exp(b[12]+b[13]*yearly_site_covs[,1])

#Generate states in times 2..T
px &lt;- 1
for (n in 1:N){
  for (t in 2:T){
    phi_mat &lt;- matrix(c(1, phi_raw[px,1], phi_raw[px,2],  # phi|z=0
                        phi_raw[px,3], 1, phi_raw[px,4],  # phi|z=1
                        phi_raw[px,5], phi_raw[px,6], 1), # phi|z=2
                      nrow=S, byrow=T)
    phi_mat &lt;- phi_mat/rowSums(phi_mat)
    z[n, t] &lt;- sample(0:(S-1), 1, prob=phi_mat[z[n,(t-1)]+1,])
    px &lt;- px + 1
    if(t==T) px &lt;- px + 1 #skip last datapoint for each site
  }
}

#Raw p probs
p_mat &lt;- matrix(c(1, 0, 0, #p|z=0
                  1, exp(b[14]), 0, #p|z=1
                  1, exp(b[16]), exp(b[17])), #p|z=2 
                nrow=S, byrow=T)
p_mat &lt;- p_mat/rowSums(p_mat)

#Simulate observation data
y &lt;- matrix(0, nrow=N, ncol=J*T)
for (n in 1:N){
  yx &lt;- 1
  for (t in 1:T){
    if(z[n,t]==0){
      yx &lt;- yx + J
      next
    }
    for (j in 1:J){
      y[n, yx] &lt;- sample(0:(S-1), 1, prob=p_mat[z[n,t]+1,])
      yx &lt;- yx+1
    }
  }
}
#-----------------------------------------------------------------

#Model fitting

#Build UMF
umf &lt;- unmarkedFrameOccuMS(y=y, siteCovs=site_covs,
                           obsCovs=obs_covs,
                           yearlySiteCovs=yearly_site_covs,
                           numPrimary=3)
summary(umf)

#Formulas
#Initial occupancy
psiformulas &lt;- c('~V1','~V2') #on psi[1] and psi[2]

#Transition probs
#Guide to order:
umf@phiOrder$multinomial
phiformulas &lt;- c('~V1','~1','~1','~V2','~1','~V1')

#Detection probability
detformulas &lt;- c('~V1','~1','~1') #on p[1|1], p[1|2], p[2|2]

#Fit model
(fit &lt;- occuMS(detformulas=detformulas, psiformulas=psiformulas,
              phiformulas=phiformulas, data=umf))

#Compare with truth
compare &lt;- cbind(b,coef(fit),
                 coef(fit)-1.96*SE(fit),coef(fit)+1.96*SE(fit))
colnames(compare) &lt;- c('truth','estimate','lower','upper')
round(compare,3)

#Estimated phi matrix for site 1
phi_est &lt;- predict(fit, 'phi', se.fit=F)
phi_est &lt;- sapply(phi_est, function(x) x$Predicted[1])
phi_est_mat &lt;- matrix(NA, nrow=S, ncol=S)
phi_est_mat[c(4,7,2,8,3,6)] &lt;- phi_est
diag(phi_est_mat) &lt;- 1 - rowSums(phi_est_mat,na.rm=T)

#Actual phi matrix for site 1
phi_act_mat &lt;- diag(S)
phi_act_mat[c(4,7,2,8,3,6)] &lt;- phi_raw[1,]
phi_act_mat &lt;- phi_act_mat/rowSums(phi_act_mat)

#Compare
cat('Estimated phi\n')
phi_est_mat
cat('Actual phi\n')
phi_act_mat

#Rough check of model fit
fit_sim &lt;- simulate(fit, nsim=20)
hist(sapply(fit_sim,mean),col='gray')
abline(v=mean(umf@y),col='red',lwd=2)
#line should fall near middle of histogram


## End(Not run)

</code></pre>

<hr>
<h2 id='occuMulti'>Fit the Rota et al. (2016) Multi-species Occupancy Model</h2><span id='topic+occuMulti'></span>

<h3>Description</h3>

<p>This function fits the multispecies occupancy model of Rota et al (2016).</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuMulti(detformulas, stateformulas, data, maxOrder, penalty=0, boot=30, 
       starts, method="BFGS", se=TRUE, engine=c("C","R"), silent=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuMulti_+3A_detformulas">detformulas</code></td>
<td>
<p>Character vector of formulas for the detection models, one per species.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_stateformulas">stateformulas</code></td>
<td>
<p>Character vector of formulas for the natural parameters. 
To fix a natural parameter at 0, specify the corresponding formula as <code>"0"</code> or <code>"~0"</code>.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccuMulti">unmarkedFrameOccuMulti</a></code> object</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_maxorder">maxOrder</code></td>
<td>
<p>Optional; specify maximum interaction order. Defaults to 
number of species (all possible interactions). Reducing this value may
speed up optimization if you aren't interested in higher-order interactions.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_penalty">penalty</code></td>
<td>
<p>Penalty term for likelihood. The total penalty is calculated
as <code>penalty * 0.5 * sum(paramvals^2)</code>. Defaults to 0 (no penalty).</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_boot">boot</code></td>
<td>
<p>Number of bootstrap samples to use to generate the 
variance-covariance matrix when <code>penalty &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_se">se</code></td>
<td>
<p>Logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; to use fast C++ code or &quot;R&quot; to use native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_silent">silent</code></td>
<td>
<p>Boolean; if <code>TRUE</code>, suppress warnings.</p>
</td></tr>
<tr><td><code id="occuMulti_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> and <code><a href="#topic+unmarkedFrameOccuMulti">unmarkedFrameOccuMulti</a></code> for a
description of how to supply data to the <code>data</code> argument.
</p>
<p><code>occuMulti</code> fits the multispecies occupancy model from Rota et al. (2016),
for two or more interacting species.
The model generalizes the standard single-species occupancy model from
MacKenzie et al. (2002).
The latent occupancy state at site <code class="reqn">i</code> for a set of <code class="reqn">s</code> potentially
interacting species is a vector <code class="reqn">\mathbf{Z}_i</code> of length <code class="reqn">s</code>
containing a sequence of the values 0 or 1. For example, when <code class="reqn">s = 2</code>, 
the possible states are <code class="reqn">[11]</code>, <code class="reqn">[10]</code>, <code class="reqn">[01]</code>, or <code class="reqn">[00]</code>, 
corresponding to both species present, only species 1 or species 2 present, 
or both species absent, respectively. The latent state modeled as a 
multivariate Bernoulli random variable:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{Z}_i \sim \textrm{MVB}(\boldsymbol{\psi}_i)</code>
</p>

<p>where <code class="reqn">\boldsymbol{\psi}_i</code> is a vector of length <code class="reqn">2^s</code> containing the probability of each possible combination of 0s and 1s, such that 
<code class="reqn">\sum\boldsymbol{\psi}_i = 1</code>.
</p>
<p>For <code class="reqn">s = 2</code>, the corresponding natural parameters <code class="reqn">f</code> are
</p>
<p style="text-align: center;"><code class="reqn">f_1 = \log\left(\frac{\psi_{10}}{\psi_{00}}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">f_2 = \log\left(\frac{\psi_{01}}{\psi_{00}}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">f_{12} = \log\left(\frac{\psi_{11}\psi_{00}}{\psi_{10}\psi_{01}}\right)</code>
</p>

<p>The natural parameters can then be modeled as linear functions of covariates.
Covariates for each <code class="reqn">f</code> must be specified with the <code>stateformulas</code> argument, 
which takes a character vector of individual formulas of length equal to the number of 
natural parameters (which in turn depends on the number of species in the model).
</p>
<p>The observation process is similar to the standard single-species occupancy
model, except that the observations <code class="reqn">\mathbf{y}_{ij}</code> at site <code class="reqn">i</code> 
on occasion <code class="reqn">j</code> are vectors of length <code class="reqn">s</code> and there are independent
values of detection probability <code class="reqn">p</code> for each species <code class="reqn">s</code>:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y}_{ij}|\mathbf{Z}_i \sim \textrm{MVB}(\mathbf{Z}_i p_{sij})</code>
</p>

<p>Independent detection models (potentially containing different covariates) 
must be provided for each species with the <code>detformulas</code> argument, 
which takes a character vector of individual formulas with length equal to 
the number of species <code class="reqn">s</code>.
</p>
<p>If you are having problems with separation or boundary estimates (indicated by 
very large parameter estimates and SEs), use of penalized likelihood may
help: see Clipp et al. (2021). <code>occuMulti</code> supports use of the
Bayes-inspired penalty of Hutchinson et al. (2015). You can set the penalty
value manually using the <code>penalty</code> argument, or identify the optimal
penalty using K-fold cross validation with the <code>optimizePenalty</code> function.
See example below.
</p>


<h3>Value</h3>

<p>unmarkedFitOccuMulti object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>Clipp, H. L., Evans, A., Kessinger, B. E., Kellner, K. F., and C. T. Rota.
2021. A penalized likelihood for multi-species occupancy models improves 
predictions of species interactions. Ecology.
</p>
<p>Hutchinson, R. A., J. V. Valente, S. C. Emerson, M. G. Betts, and
T. G. Dietterich. 2015. Penalized Likelihood Methods Improve Parameter
Estimates in Occupancy Models. Methods in Ecology and Evolution. DOI:
10.1111/2041-210X.12368
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy Rates
When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>
<p>Rota, C.T., et al. 2016. A multi-species occupancy model for two or more
interacting species. Methods in Ecology and Evolution 7: 1164-1173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccuMulti">unmarkedFrameOccuMulti</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Simulate 3 species data
N &lt;- 1000
nspecies &lt;- 3
J &lt;- 5

occ_covs &lt;- as.data.frame(matrix(rnorm(N * 10),ncol=10))
names(occ_covs) &lt;- paste('occ_cov',1:10,sep='')

det_covs &lt;- list()
for (i in 1:nspecies){
  det_covs[[i]] &lt;- matrix(rnorm(N*J),nrow=N)
}
names(det_covs) &lt;- paste('det_cov',1:nspecies,sep='')

#True vals
beta &lt;- c(0.5,0.2,0.4,0.5,-0.1,-0.3,0.2,0.1,-1,0.1)
f1 &lt;- beta[1] + beta[2]*occ_covs$occ_cov1
f2 &lt;- beta[3] + beta[4]*occ_covs$occ_cov2
f3 &lt;- beta[5] + beta[6]*occ_covs$occ_cov3
f4 &lt;- beta[7]
f5 &lt;- beta[8]
f6 &lt;- beta[9]
f7 &lt;- beta[10]
f &lt;- cbind(f1,f2,f3,f4,f5,f6,f7)
z &lt;- expand.grid(rep(list(1:0),nspecies))[,nspecies:1]
colnames(z) &lt;- paste('sp',1:nspecies,sep='')
dm &lt;- model.matrix(as.formula(paste0("~.^",nspecies,"-1")),z)

psi &lt;- exp(f %*% t(dm))
psi &lt;- psi/rowSums(psi)

#True state
ztruth &lt;- matrix(NA,nrow=N,ncol=nspecies)
for (i in 1:N){
  ztruth[i,] &lt;- as.matrix(z[sample(8,1,prob=psi[i,]),])
}

p_true &lt;- c(0.6,0.7,0.5)

# fake y data
y &lt;- list()

for (i in 1:nspecies){
  y[[i]] &lt;- matrix(NA,N,J)
  for (j in 1:N){
    for (k in 1:J){
      y[[i]][j,k] &lt;- rbinom(1,1,ztruth[j,i]*p_true[i])
    }
  }
}
names(y) &lt;- c('coyote','tiger','bear')

#Create the unmarked data object
data = unmarkedFrameOccuMulti(y=y,siteCovs=occ_covs,obsCovs=det_covs)

#Summary of data object
summary(data)
plot(data)

# Look at f parameter design matrix
data@fDesign

# Formulas for state and detection processes

# Length should match number/order of columns in fDesign
occFormulas &lt;- c('~occ_cov1','~occ_cov2','~occ_cov3','~1','~1','~1','~1')

#Length should match number/order of species in data@ylist
detFormulas &lt;- c('~1','~1','~1')

fit &lt;- occuMulti(detFormulas,occFormulas,data)

#Look at output
fit

plot(fit)

#Compare with known values
cbind(c(beta,log(p_true/(1-p_true))),fit@opt$par)

#predict method
lapply(predict(fit,'state'),head)
lapply(predict(fit,'det'),head)

#marginal occupancy
head(predict(fit,'state',species=2))
head(predict(fit,'state',species='bear'))
head(predict(fit,'det',species='coyote'))

#probability of co-occurrence of two or more species
head(predict(fit, 'state', species=c('coyote','tiger')))

#conditional occupancy
head(predict(fit,'state',species=2,cond=3)) #tiger | bear present
head(predict(fit,'state',species='tiger',cond='bear')) #tiger | bear present
head(predict(fit,'state',species='tiger',cond='-bear')) #bear absent
head(predict(fit,'state',species='tiger',cond=c('coyote','-bear')))

#residuals (by species)
lapply(residuals(fit),head)

#ranef (by species)
ranef(fit, species='coyote')

#parametric bootstrap
bt &lt;- parboot(fit,nsim=30)

#update model
occFormulas &lt;- c('~occ_cov1','~occ_cov2','~occ_cov2+occ_cov3','~1','~1','~1','~1')
fit2 &lt;- update(fit,stateformulas=occFormulas)

#List of fitted models
fl &lt;- fitList(fit,fit2)
coef(fl)

#Model selection
modSel(fl)

#Fit model while forcing some natural parameters to be 0
#For example: fit model with no species interactions
occFormulas &lt;- c('~occ_cov1','~occ_cov2','~occ_cov2+occ_cov3','0','0','0','0')
fit3 &lt;- occuMulti(detFormulas,occFormulas,data)

#Alternatively, you can force all interaction parameters above a certain
#order to be zero with maxOrder. This will be faster.
occFormulas &lt;- c('~occ_cov1','~occ_cov2','~occ_cov2+occ_cov3')
fit4 &lt;- occuMulti(detFormulas,occFormulas,data,maxOrder=1)

#Add Bayes penalty term to likelihood. This is useful if your parameter
#estimates are very large, eg because of separation.
fit5 &lt;- occuMulti(detFormulas, occFormulas, data, penalty=1)

#Find optimal penalty term value from a range of possible values using
#K-fold cross validation, and re-fit the model
fit_opt &lt;- optimizePenalty(fit5, penalties=c(0,1,2))

## End(Not run)

</code></pre>

<hr>
<h2 id='occuPEN'>Fit the MacKenzie et al. (2002) Occupancy Model with the penalized likelihood methods of Hutchinson et al. (2015)</h2><span id='topic+occuPEN'></span>

<h3>Description</h3>

<p>This function fits the occupancy model of MacKenzie et al (2002) with the penalized methods of Hutchinson et al (2015).</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuPEN(formula, data, knownOcc=numeric(0), starts, method="BFGS",
    engine=c("C", "R"), lambda=0, pen.type = c("Bayes","Ridge","MPLE"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuPEN_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and occupancy in that order.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> object</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_knownocc">knownOcc</code></td>
<td>
<p>Vector of sites that are known to be occupied. These
should be supplied as row numbers of the y matrix, eg, c(3,8) if
sites 3 and 8 were known to be occupied a priori.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; or &quot;R&quot; to use fast C++ code or native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_lambda">lambda</code></td>
<td>
<p>Penalty weight parameter.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_pen.type">pen.type</code></td>
<td>
<p>Which form of penalty to use.</p>
</td></tr>
<tr><td><code id="occuPEN_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> and <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> for a
description of how to supply data to the <code>data</code> argument.
</p>
<p><code>occuPEN</code> fits the standard occupancy model based on
zero-inflated binomial models (MacKenzie et al. 2006, Royle and
Dorazio 2008) using the penalized likelihood methods described in
Hutchinson et al. (2015).  See <code><a href="#topic+occu">occu</a></code> for model
details. <code>occuPEN</code> returns parameter estimates that maximize a
penalized likelihood in which the penalty is specified by the
<code>pen.type</code> argument. The penalty function is weighted by
<code>lambda</code>. 
</p>
<p>The MPLE method includes an equation for computing <code>lambda</code>
(Moreno &amp; Lele, 2010). If the value supplied does not equal match the
one computed with this equation, the supplied value is used anyway
(with a warning).
</p>


<h3>Value</h3>

<p>unmarkedFitOccuPEN object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Rebecca A. Hutchinson</p>


<h3>References</h3>

<p>Hutchinson, R. A., J. V. Valente, S. C. Emerson, M. G. Betts, and
T. G. Dietterich. 2015. Penalized Likelihood Methods Improve Parameter
Estimates in Occupancy Models. Methods in Ecology and Evolution. DOI:
10.1111/2041-210X.12368
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy Rates
When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>
<p>MacKenzie, D. I. et al. 2006. <em>Occupancy Estimation and Modeling</em>.
Amsterdam: Academic Press.
</p>
<p>Moreno, M. and S. R. Lele. 2010. Improved estimation of site occupancy
using penalized likelihood. Ecology 91: 341-346.
</p>
<p>Royle, J. A. and R. Dorazio. 2008. <em>Hierarchical Modeling and Inference
in Ecology</em>. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>,
<code><a href="#topic+occu">occu</a></code>, <code><a href="#topic+computeMPLElambda">computeMPLElambda</a></code>, 
<code><a href="#topic+occuPEN_CV">occuPEN_CV</a></code>, <code><a href="#topic+nonparboot">nonparboot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate occupancy data
set.seed(344)
nSites &lt;- 100
nReps &lt;- 2
covariates &lt;- data.frame(veght=rnorm(nSites),
    habitat=factor(c(rep('A', nSites/2), rep('B', nSites/2))))

psipars &lt;- c(-1, 1, -1)
ppars &lt;- c(1, -1, 0)
X &lt;- model.matrix(~veght+habitat, covariates) # design matrix
psi &lt;- plogis(X %*% psipars)
p &lt;- plogis(X %*% ppars)

y &lt;- matrix(NA, nSites, nReps)
z &lt;- rbinom(nSites, 1, psi)       # true occupancy state
for(i in 1:nSites) {
    y[i,] &lt;- rbinom(nReps, 1, z[i]*p[i])
    }

# Organize data and look at it
umf &lt;- unmarkedFrameOccu(y = y, siteCovs = covariates)
obsCovs(umf) &lt;- covariates
head(umf)
summary(umf)


# Fit some models
fmMLE &lt;- occu(~veght+habitat ~veght+habitat, umf)
fm1pen &lt;- occuPEN(~veght+habitat ~veght+habitat, umf,lambda=0.33,pen.type="Ridge")
fm2pen &lt;- occuPEN(~veght+habitat ~veght+habitat, umf,lambda=1,pen.type="Bayes")

# MPLE:
fm3pen &lt;- occuPEN(~veght+habitat ~veght+habitat, umf,lambda=0.5,pen.type="MPLE")
MPLElambda = computeMPLElambda(~veght+habitat ~veght+habitat, umf) 
fm4pen &lt;- occuPEN(~veght+habitat ~veght+habitat, umf,lambda=MPLElambda,pen.type="MPLE")

# nonparametric bootstrap for uncertainty analysis:
fm1pen &lt;- nonparboot(fm1pen,B=20) # should use more samples
vcov(fm1pen,method="nonparboot")




</code></pre>

<hr>
<h2 id='occuPEN_CV'>Fit the MacKenzie et al. (2002) Occupancy Model with the penalized likelihood methods of Hutchinson et al. (2015) using cross-validation</h2><span id='topic+occuPEN_CV'></span>

<h3>Description</h3>

<p>This function fits the occupancy model of MacKenzie et al
(2002) with the penalized methods of Hutchinson et al (2015) using
k-fold cross-validation to choose the penalty weight.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuPEN_CV(formula, data, knownOcc=numeric(0), starts, method="BFGS",
    engine=c("C", "R"), lambdaVec=c(0,2^seq(-4,4)),
    pen.type = c("Bayes","Ridge"), k = 5, foldAssignments = NA,
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuPEN_CV_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and occupancy in that order.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_data">data</code></td>
<td>
<p>An <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> object</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_knownocc">knownOcc</code></td>
<td>
<p>Vector of sites that are known to be occupied. These
should be supplied as row numbers of the y matrix, eg, c(3,8) if
sites 3 and 8 were known to be occupied a priori.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_starts">starts</code></td>
<td>
<p>Vector of parameter starting values.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; or &quot;R&quot; to use fast C++ code or native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_lambdavec">lambdaVec</code></td>
<td>
<p>Vector of values to try for lambda.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_pen.type">pen.type</code></td>
<td>
<p>Which form of penalty to use.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_k">k</code></td>
<td>
<p>Number of folds for k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_foldassignments">foldAssignments</code></td>
<td>
<p>Vector containing the number of the fold
that each site falls into. Length of the vector should be equal
to the number of sites, and the vector should contain k unique
values. E.g. for 9 sites and 3 folds, c(1,2,3,1,2,3,1,2,3) or
c(1,1,1,2,2,2,3,3,3).</p>
</td></tr>
<tr><td><code id="occuPEN_CV_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code> and <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> for a
description of how to supply data to the <code>data</code> argument.
</p>
<p>This function wraps k-fold cross-validation around <code>occuPEN_CV</code>
for the &quot;Bayes&quot; and &quot;Ridge&quot; penalties of Hutchinson et al. (2015). The
user may specify the number of folds (<code>k</code>), the values to try
(<code>lambdaVec</code>), and the assignments of sites to folds
(<code>foldAssignments</code>). If <code>foldAssignments</code> is not provided,
the assignments are done pseudo-randomly, and the function attempts to
put some sites with and without positive detections in each fold. This
randomness introduces variability into the results of this function
across runs; to eliminate the randomness, supply foldAssignments. 
</p>


<h3>Value</h3>

<p>unmarkedFitOccuPEN_CV object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Rebecca A. Hutchinson</p>


<h3>References</h3>

<p>Hutchinson, R. A., J. V. Valente, S. C. Emerson, M. G. Betts, and
T. G. Dietterich. 2015. Penalized Likelihood Methods Improve Parameter
Estimates in Occupancy Models. Methods in Ecology and Evolution. DOI:
10.1111/2041-210X.12368
</p>
<p>MacKenzie, D. I., J. D. Nichols, G. B. Lachman, S. Droege,
J. Andrew Royle, and C. A. Langtimm. 2002. Estimating Site Occupancy Rates
When Detection Probabilities Are Less Than One. Ecology 83: 2248-2255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>,
<code><a href="#topic+occu">occu</a></code>, <code><a href="#topic+occuPEN">occuPEN</a></code>, <code><a href="#topic+nonparboot">nonparboot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate occupancy data
set.seed(646)
nSites &lt;- 60
nReps &lt;- 2
covariates &lt;- data.frame(veght=rnorm(nSites),
    habitat=factor(c(rep('A', 30), rep('B', 30))))

psipars &lt;- c(-1, 1, -1)
ppars &lt;- c(1, -1, 0)
X &lt;- model.matrix(~veght+habitat, covariates) # design matrix
psi &lt;- plogis(X %*% psipars)
p &lt;- plogis(X %*% ppars)

y &lt;- matrix(NA, nSites, nReps)
z &lt;- rbinom(nSites, 1, psi)       # true occupancy state
for(i in 1:nSites) {
    y[i,] &lt;- rbinom(nReps, 1, z[i]*p[i])
    }

# Organize data and look at it
umf &lt;- unmarkedFrameOccu(y = y, siteCovs = covariates)
obsCovs(umf) &lt;- covariates
head(umf)
summary(umf)

## Not run: 

# Fit some models
fmMLE &lt;- occu(~veght+habitat ~veght+habitat, umf)
fmMLE@estimates

fm1penCV &lt;- occuPEN_CV(~veght+habitat ~veght+habitat,
 umf,pen.type="Ridge", foldAssignments=rep(1:5,ceiling(nSites/5))[1:nSites])
fm1penCV@lambdaVec
fm1penCV@chosenLambda
fm1penCV@estimates

fm2penCV &lt;- occuPEN_CV(~veght+habitat ~veght+habitat,
umf,pen.type="Bayes",foldAssignments=rep(1:5,ceiling(nSites/5))[1:nSites])
fm2penCV@lambdaVec
fm2penCV@chosenLambda
fm2penCV@estimates

# nonparametric bootstrap for uncertainty analysis:
# bootstrap is wrapped around the cross-validation
fm2penCV &lt;- nonparboot(fm2penCV,B=10) # should use more samples
vcov(fm2penCV,method="nonparboot")

# Mean squared error of parameters:
mean((c(psipars,ppars)-c(fmMLE[1]@estimates,fmMLE[2]@estimates))^2)
mean((c(psipars,ppars)-c(fm1penCV[1]@estimates,fm1penCV[2]@estimates))^2)
mean((c(psipars,ppars)-c(fm2penCV[1]@estimates,fm2penCV[2]@estimates))^2)

## End(Not run)


</code></pre>

<hr>
<h2 id='occuRN'>Fit the occupancy model of Royle and Nichols (2003)</h2><span id='topic+occuRN'></span>

<h3>Description</h3>

<p>Fit the occupancy model of Royle and Nichols (2003), which relates probability
of detection of the species to the number of individuals available for detection at each site.
Probability of occupancy is a derived parameter: the probability that at least one
individual is available for detection at the site.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuRN(formula, data, K=25, starts, method="BFGS", se=TRUE, 
              engine=c("C","R"), threads=1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuRN_+3A_formula">formula</code></td>
<td>
<p>double right-hand side formula describing covariates of
detection and abundance, in that order.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_data">data</code></td>
<td>
<p>Object of class <code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> supplying data
to the model.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_k">K</code></td>
<td>
<p>the upper summation index used to numerically integrate out the
latent abundance. This should be set high enough so that it does not
affect the parameter estimates. Computation time will increase with K.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_starts">starts</code></td>
<td>
<p>initial values for the optimization.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; to use fast C++ code or &quot;R&quot; to use native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="occuRN_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.</p>
</td></tr> 
<tr><td><code id="occuRN_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the latent abundance mixture model described in
Royle and Nichols (2003).
</p>
<p>The number of animals available for detection at site <code class="reqn">i</code> is modelled as Poisson:
</p>
<p style="text-align: center;"><code class="reqn">N_i \sim Poisson(\lambda_i)</code>
</p>

<p>We assume that all individuals at site <code class="reqn">i</code> during sample <code class="reqn">j</code> have identical
detection probabilities, <code class="reqn">r_{ij}</code>, and that detections are independent. The species
will be recorded if at least one individual is detected. Thus, the detection
probability for the species is linked to the
detection probability for an individual by
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = 1 - (1 - r_{ij}) ^ {N_i}</code>
</p>

<p>Note that if <code class="reqn">N_i = 0</code>, then <code class="reqn">p_{ij} = 0</code>, and increasing values of <code class="reqn">N_i</code> lead to higher values of <code class="reqn">p_{ij}</code> The equation for the detection history is then:
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} \sim Bernoulli(p_{ij})</code>
</p>

<p>Covariates of <code class="reqn">\lambda_i</code> are modelled with the log link
and covariates of <code class="reqn">r_{ij}</code> are modelled with the logit link.
</p>


<h3>Value</h3>

<p>unmarkedFit object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Ian Fiske</p>


<h3>References</h3>

<p>Royle, J. A. and Nichols, J. D. (2003) Estimating Abundance from
Repeated Presence-Absence Data or Point Counts. <em>Ecology</em>, 84(3)
pp. 777&ndash;790.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(birds)
woodthrushUMF &lt;- unmarkedFrameOccu(woodthrush.bin)
# survey occasion-specific detection probabilities
(fm.wood.rn &lt;- occuRN(~ obsNum ~ 1, woodthrushUMF))

# Empirical Bayes estimates of abundance at each site
re &lt;- ranef(fm.wood.rn)
plot(re)



## End(Not run)

</code></pre>

<hr>
<h2 id='occuTTD'>Fit Single-Season and Dynamic Time-to-detection Occupancy Models</h2><span id='topic+occuTTD'></span>

<h3>Description</h3>

<p>Fit time-to-detection occupancy models of Garrard et al. 
(2008, 2013), either single-season or dynamic. Time-to-detection can be 
modeled with either an exponential or Weibull distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occuTTD(psiformula= ~1, gammaformula =  ~ 1, epsilonformula = ~ 1,
    detformula = ~ 1, data, ttdDist = c("exp", "weibull"), 
    linkPsi = c("logit", "cloglog"), starts, method="BFGS", se=TRUE, 
    engine = c("C", "R"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occuTTD_+3A_psiformula">psiformula</code></td>
<td>
<p>Right-hand sided formula for the initial probability of 
occupancy at each site.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_gammaformula">gammaformula</code></td>
<td>
<p>Right-hand sided formula for colonization probability.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_epsilonformula">epsilonformula</code></td>
<td>
<p>Right-hand sided formula for extinction probability.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_detformula">detformula</code></td>
<td>
<p>Right-hand sided formula for mean time-to-detection.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_data">data</code></td>
<td>
<p><code>unmarkedFrameOccuTTD</code> object that supplies the data 
(see <code><a href="#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code>).</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_ttddist">ttdDist</code></td>
<td>
<p>Distribution to use for time-to-detection; either
<code>"exp"</code> for the exponential, or <code>"weibull"</code> for the Weibull,
which adds an additional shape parameter <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_linkpsi">linkPsi</code></td>
<td>
<p>Link function for the occupancy model. Options are  
<code>"logit"</code> for the standard occupancy model or <code>"cloglog"</code> 
for the complimentary log-log link, which relates occupancy
to site-level abundance.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_starts">starts</code></td>
<td>
<p>optionally, initial values for parameters in the optimization.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard errors.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot; or &quot;R&quot; to use fast C++ code or native R
code during the optimization.</p>
</td></tr>
<tr><td><code id="occuTTD_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates site occupancy and detection probability from time-to-detection 
(TTD) data, e.g. time to first detection of a particular bird species 
during a point count or time-to-detection of a plant species while searching 
a quadrat (Garrard et al. 2008). Time-to-detection can be modeled 
as an exponential (<code>ttdDist="exp"</code>) or Weibull (<code>ttdDist="weibull"</code>) 
random variable with rate parameter <code class="reqn">\lambda</code> and, for the Weibull, 
an additional shape parameter <code class="reqn">k</code>. Note that <code>occuTTD</code> puts covariates
on <code class="reqn">\lambda</code> and not <code class="reqn">1/\lambda</code>, i.e., the expected time between events.
</p>
<p>In the case where there are no detections before the maximum sample time at
a site (<code>surveyLength</code>) is reached, we are not sure if the site is 
unoccupied or if we just didn't wait long enough for a detection. We therefore 
must censor the exponential or Weibull distribution at the maximum survey 
length, <code class="reqn">Tmax</code>. Thus, assuming true site occupancy at site <code class="reqn">i</code> is 
<code class="reqn">z_i</code>, an exponential distribution for the TTD <code class="reqn">y_i</code>, and that 
<code class="reqn">d_i = 1</code> indicates <code class="reqn">y_i</code> is censored (Kery and Royle 2016): 
</p>
<p style="text-align: center;"><code class="reqn">d_i = z_i * I(y_i &gt; Tmax_i) + (1 - z_i)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">y_i|z_i \sim Exponential(\lambda_i), d_i = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">y_i|z_i = Missing, d_i = 1</code>
</p>

<p>Because in <code>unmarked</code> values of <code>NA</code> are typically used to indicate 
missing values that were a result of the sampling structure (e.g., lost data), 
we indicate a censored <code class="reqn">y_i</code> in <code>occuTTD</code> instead by setting 
<code class="reqn">y_i = Tmax_i</code> in the <code>y</code> matrix provided to 
<code><a href="#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code>. You can provide either a single value of 
<code class="reqn">Tmax</code> to the <code>surveyLength</code> argument of <code>unmarkedFrameOccuTTD</code>, 
or provide a matrix, potentially with a unique value of <code class="reqn">Tmax</code> for each 
value of <code>y</code>. Note that in the latter case the value of <code>y</code> that will 
be interpreted by <code>occuTTD</code> as a censored observation (i.e., <code class="reqn">Tmax</code>) 
will differ between observations!
</p>
<p>Occupancy and detection can be estimated with only a single survey per site, 
unlike a traditional occupancy model that requires at least two replicated 
surveys at at least some sites. However, <code>occuTTD</code> also supports 
multiple surveys per site using the model described in Garrard et al. (2013). 
Furthermore, multi-season dynamic models are supported, using the same basic 
structure as for standard occupancy models (see <code><a href="#topic+colext">colext</a></code>). 
</p>
<p>When <code>linkPsi = "cloglog"</code>, the complimentary log-log link 
function is used for <code class="reqn">psi</code> instead of the logit link. The cloglog link
relates occupancy probability to the intensity parameter of an underlying
Poisson process (Kery and Royle 2016). Thus, if abundance at a site is 
can be modeled as <code class="reqn">N_i ~ Poisson(\lambda_i)</code>, where 
<code class="reqn">log(\lambda_i) = \alpha + \beta*x</code>, then presence/absence data at the 
site can be modeled as <code class="reqn">Z_i ~ Binomial(\psi_i)</code> where 
<code class="reqn">cloglog(\psi_i) = \alpha + \beta*x</code>. 
</p>


<h3>Value</h3>

<p>unmarkedFitOccuTTD object describing model fit.</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>Garrard, G.E., Bekessy, S.A., McCarthy, M.A. and Wintle, B.A. 2008. When have 
we looked hard enough? A novel method for setting minimum survey effort 
protocols for flora surveys. Austral Ecology 33: 986-998.
</p>
<p>Garrard, G.E., McCarthy, M.A., Williams, N.S., Bekessy, S.A. and Wintle, 
B.A. 2013. A general model of detectability using species traits. Methods in 
Ecology and Evolution 4: 45-52.
</p>
<p>Kery, Marc, and J. Andrew Royle. 2016. <em>Applied Hierarchical Modeling in
Ecology</em>, Volume 1. Academic Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarked">unmarked</a></code>, <code><a href="#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

### Single season model
N &lt;- 500; J &lt;- 1

#Simulate occupancy
scovs &lt;- data.frame(elev=c(scale(runif(N, 0,100))),
                    forest=runif(N,0,1),
                    wind=runif(N,0,1))

beta_psi &lt;- c(-0.69, 0.71, -0.5)
psi &lt;- plogis(cbind(1, scovs$elev, scovs$forest) %*% beta_psi)
z &lt;- rbinom(N, 1, psi)

#Simulate detection
Tmax &lt;- 10 #Same survey length for all observations
beta_lam &lt;- c(-2, -0.2, 0.7)
rate &lt;- exp(cbind(1, scovs$elev, scovs$wind) %*% beta_lam)
ttd &lt;- rexp(N, rate)
ttd[z==0] &lt;- Tmax #Censor at unoccupied sites
ttd[ttd&gt;Tmax] &lt;- Tmax #Censor when ttd was greater than survey length

#Build unmarkedFrame
umf &lt;- unmarkedFrameOccuTTD(y=ttd, surveyLength=Tmax, siteCovs=scovs)

#Fit model
fit &lt;- occuTTD(psiformula=~elev+forest, detformula=~elev+wind, data=umf)

#Predict psi values
predict(fit, type='psi', newdata=data.frame(elev=0.5, forest=1))

#Predict lambda values
predict(fit, type='det', newdata=data.frame(elev=0.5, wind=0))

#Calculate p, probability species is detected at a site given it is present
#for a value of lambda. This is equivalent to eq 4 of Garrard et al. 2008
lam &lt;- predict(fit, type='det', newdata=data.frame(elev=0.5, wind=0))$Predicted
pexp(Tmax, lam)

#Estimated p for all observations
head(getP(fit))

### Dynamic model

N &lt;- 1000; J &lt;- 2; T &lt;- 2
scovs &lt;- data.frame(elev=c(scale(runif(N, 0,100))),
                    forest=runif(N,0,1),
                    wind=runif(N,0,1))

beta_psi &lt;- c(-0.69, 0.71, -0.5)
psi &lt;- plogis(cbind(1, scovs$elev, scovs$forest) %*% beta_psi)
z &lt;- matrix(NA, N, T)
z[,1] &lt;- rbinom(N, 1, psi)

#Col/ext process
ysc &lt;- data.frame(forest=rep(scovs$forest, each=T), 
                  elev=rep(scovs$elev, each=T))
c_b0 &lt;- -0.4; c_b1 &lt;- 0.3
gam &lt;- plogis(c_b0 + c_b1 * scovs$forest)
e_b0 &lt;- -0.7; e_b1 &lt;- 0.4
ext &lt;- plogis(e_b0 + e_b1 * scovs$elev)

for (i in 1:N){
  for (t in 1:(T-1)){
    if(z[i,t]==1){
      #ext
      z[i,t+1] &lt;- rbinom(1, 1, (1-ext[i]))
    } else {
      #col
      z[i,t+1] &lt;- rbinom(1,1, gam[i])
    }
  }
}

#Simulate detection
ocovs &lt;- data.frame(obs=rep(c('A','B'),N*T))
Tmax &lt;- 10
beta_lam &lt;- c(-2, -0.2, 0.7)
rate &lt;- exp(cbind(1, scovs$elev, scovs$wind) %*% beta_lam)
#Add second observer at each site
rateB &lt;- exp(cbind(1, scovs$elev, scovs$wind) %*% beta_lam - 0.5)
#Across seasons
rate2 &lt;- as.numeric(t(cbind(rate, rateB, rate, rateB)))
ttd &lt;- rexp(N*T*2, rate2)
ttd &lt;- matrix(ttd, nrow=N, byrow=T)
ttd[ttd&gt;Tmax] &lt;- Tmax
ttd[z[,1]==0,1:2] &lt;- Tmax
ttd[z[,2]==0,3:4] &lt;- Tmax
  
umf &lt;- unmarkedFrameOccuTTD(y = ttd, surveyLength = Tmax, 
                            siteCovs = scovs, obsCovs=ocovs,
                            yearlySiteCovs=ysc, numPrimary=2) 

dim(umf@y) #num sites, (num surveys x num primary periods)

fit &lt;- occuTTD(psiformula=~elev+forest,detformula=~elev+wind+obs,
               gammaformula=~forest, epsilonformula=~elev, 
               data=umf,se=T,engine="C")

truth &lt;- c(beta_psi, c_b0, c_b1, e_b0, e_b1, beta_lam, -0.5)

#Compare to truth
cbind(coef(fit), truth)


## End(Not run)
</code></pre>

<hr>
<h2 id='optimizePenalty-methods'> Identify Optimal Penalty Parameter Value </h2><span id='topic+optimizePenalty'></span><span id='topic+optimizePenalty-methods'></span><span id='topic+optimizePenalty+2CunmarkedFitOccuMulti-method'></span>

<h3>Description</h3>

<p>Identify the optimal value of the penalty term for <code>unmarked</code> models that
support penalized likelihood. For each potential value of the penalty term, 
K-fold cross validation is performed. Log-likelihoods for the test data in 
each fold are calculated and summed. The penalty term that maximizes the sum 
of the fold log-likelihoods is selected as the optimal value. Finally, the 
model is re-fit with the full dataset using the selected penalty term.
Right now only Bayes-inspired penalty of Hutchinson et al. (2015) is supported.
</p>
<p>Currently the only fitting function that supports <code>optimizePenalty</code> is
<code>occuMulti</code> for multispecies occupancy modeling; see Clipp et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFitOccuMulti'
optimizePenalty(
  object, penalties = c(0, 2^seq(-4, 4)), k = 5, boot = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizePenalty-methods_+3A_object">object</code></td>
<td>
<p>A fitted model inheriting class <code>unmarkedFit</code></p>
</td></tr>
<tr><td><code id="optimizePenalty-methods_+3A_penalties">penalties</code></td>
<td>
<p>Vector of possible penalty values, all of which must be &gt;= 0</p>
</td></tr>
<tr><td><code id="optimizePenalty-methods_+3A_k">k</code></td>
<td>
<p>Number of folds to use for k-fold cross validation</p>
</td></tr>
<tr><td><code id="optimizePenalty-methods_+3A_boot">boot</code></td>
<td>
<p>Number of bootstrap samples to use to generate the 
variance-covariance matrix for the final model.</p>
</td></tr>
<tr><td><code id="optimizePenalty-methods_+3A_...">...</code></td>
<td>
<p>Other arguments, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unmarkedFit</code> object of same type as input, with the optimal
penalty value applied.
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>Clipp, H. L., Evans, A., Kessinger, B. E., Kellner, K. F., and C. T. Rota.
2021. A penalized likelihood for multi-species occupancy models improves 
predictions of species interactions. Ecology.
</p>
<p>Hutchinson, R. A., J. V. Valente, S. C. Emerson, M. G. Betts, and
T. G. Dietterich. 2015. Penalized Likelihood Methods Improve Parameter
Estimates in Occupancy Models. Methods in Ecology and Evolution. DOI:
10.1111/2041-210X.12368
</p>

<hr>
<h2 id='ovendata'>
Removal data for the Ovenbird
</h2><span id='topic+ovendata'></span><span id='topic+ovendata.list'></span>

<h3>Description</h3>

<p>Removal sampling data collected for the Ovenbird (<em>Seiurus aurocapillus</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ovendata)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;ovendata.list&quot; which consists of
</p>

<dl>
<dt>data</dt><dd><p>matrix of removal counts</p>
</dd>
<dt>covariates</dt><dd><p>data frame of site-level covariates</p>
</dd>
</dl>



<h3>Source</h3>

<p>J.A. Royle (see reference below)
</p>


<h3>References</h3>

<p>Royle, J. A. (2004). Generalized estimators of avian abundance from count survey data. Animal Biodiversity and Conservation, 27(1), 375-386.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ovendata)
str(ovendata.list)
ovenFrame &lt;- unmarkedFrameMPois(ovendata.list$data,
siteCovs=as.data.frame(scale(ovendata.list$covariates[,-1])), type = "removal")
</code></pre>

<hr>
<h2 id='parboot'>Parametric bootstrap method for fitted models inheriting class.</h2><span id='topic+parboot'></span><span id='topic+plot+2Cparboot+2Cmissing-method'></span><span id='topic+show+2Cparboot-method'></span>

<h3>Description</h3>

<p>Simulate datasets from a fitted model, refit the model, and
generate a sampling distribution for a user-specified fit-statistic.</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="parboot_+3A_object">object</code></td>
<td>
<p>a fitted model inheriting class &quot;unmarkedFit&quot;</p>
</td></tr>
<tr><td><code id="parboot_+3A_statistic">statistic</code></td>
<td>
<p>a function returning a vector of fit-statistics.
First argument must be the fitted model.
Default is sum of squared residuals.</p>
</td></tr>
<tr><td><code id="parboot_+3A_nsim">nsim</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="parboot_+3A_report">report</code></td>
<td>
<p>print fit statistic every 'report' iterations during resampling</p>
</td></tr>
<tr><td><code id="parboot_+3A_seed">seed</code></td>
<td>
<p>set seed for reproducible bootstrap</p>
</td></tr>
<tr><td><code id="parboot_+3A_parallel">parallel</code></td>
<td>
<p>logical (default = <code>TRUE</code>) indicating whether to compute 
bootstrap on multiple cores, if present.  If <code>TRUE</code>, suppresses reporting
of bootstrapped statistics.  Defaults to serial calculation when <code>nsim</code> &lt; 100.
Parallel computation is likely to be slower for simple models when <code>nsim</code> &lt; ~500,
but should speed up the bootstrap of more complicated models.</p>
</td></tr>
<tr><td><code id="parboot_+3A_ncores">ncores</code></td>
<td>
<p>integer (default = one less than number of available cores) number of cores to
use when bootstrapping in parallel.</p>
</td></tr> 
<tr><td><code id="parboot_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to statistic</p>
</td></tr></table>


<h3>Details</h3>

<p>This function simulates datasets based upon a fitted model,
refits the model, and evaluates a user-specified fit-statistic for each
simulation. Comparing this sampling distribution to the observed statistic
provides a means of evaluating goodness-of-fit or assessing uncertainty in
a quantity of interest.</p>


<h3>Value</h3>

<p>An object of class parboot with three slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>parboot call</p>
</td></tr>
<tr><td><code>t0</code></td>
<td>
<p>Numeric vector of statistics for original fitted model.</p>
</td></tr>
<tr><td><code>t.star</code></td>
<td>
<p>nsim by length(t0) matrix of statistics for each simulation fit.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a> and Adam Smith</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef">ranef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(linetran)
(dbreaksLine &lt;- c(0, 5, 10, 15, 20))
lengths &lt;- linetran$Length

ltUMF &lt;- with(linetran, {
	unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
	siteCovs = data.frame(Length, area, habitat), dist.breaks = dbreaksLine,
	tlength = lengths*1000, survey = "line", unitsIn = "m")
    })

# Fit a model
(fm &lt;- distsamp(~area ~habitat, ltUMF))

# Function returning three fit-statistics.
fitstats &lt;- function(fm, na.rm=TRUE) {
    observed &lt;- getY(fm@data)
    expected &lt;- fitted(fm)
    resids &lt;- residuals(fm)
    sse &lt;- sum(resids^2, na.rm=na.rm)
    chisq &lt;- sum((observed - expected)^2 / expected, na.rm=na.rm)
    freeTuke &lt;- sum((sqrt(observed) - sqrt(expected))^2, na.rm=na.rm)
    out &lt;- c(SSE=sse, Chisq=chisq, freemanTukey=freeTuke)
    return(out)
}

(pb &lt;- parboot(fm, fitstats, nsim=25, report=1))
plot(pb, main="")


# Finite-sample inference for a derived parameter.
# Population size in sampled area

Nhat &lt;- function(fm) {
    sum(bup(ranef(fm, K=50)))
    }

set.seed(345)
(pb.N &lt;- parboot(fm, Nhat, nsim=25, report=5))

# Compare to empirical Bayes confidence intervals
colSums(confint(ranef(fm, K=50)))



</code></pre>

<hr>
<h2 id='pcount'>Fit the N-mixture model of Royle (2004)</h2><span id='topic+pcount'></span>

<h3>Description</h3>

<p>Fit the N-mixture model of Royle (2004)</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcount(formula, data, K, mixture=c("P", "NB", "ZIP"),
    starts, method="BFGS", se=TRUE, engine=c("C", "R", "TMB"), threads=1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcount_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and abundance, in that order</p>
</td></tr>
<tr><td><code id="pcount_+3A_data">data</code></td>
<td>
<p>an unmarkedFramePCount object supplying data to the model.</p>
</td></tr>
<tr><td><code id="pcount_+3A_k">K</code></td>
<td>
<p>Integer upper index of integration for N-mixture. This should be
set high enough so that it does not affect the parameter estimates. Note
that computation time will increase with K.</p>
</td></tr>
<tr><td><code id="pcount_+3A_mixture">mixture</code></td>
<td>
<p>character specifying mixture: &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot;.</p>
</td></tr>
<tr><td><code id="pcount_+3A_starts">starts</code></td>
<td>
<p>vector of starting values</p>
</td></tr>
<tr><td><code id="pcount_+3A_method">method</code></td>
<td>
<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="pcount_+3A_se">se</code></td>
<td>
<p>logical specifying whether or not to compute standard
errors.</p>
</td></tr>
<tr><td><code id="pcount_+3A_engine">engine</code></td>
<td>
<p>Either &quot;C&quot;, &quot;R&quot;, or &quot;TMB&quot; to use fast C++ code, native R
code, or TMB (required for random effects) during the optimization.</p>
</td></tr>
<tr><td><code id="pcount_+3A_threads">threads</code></td>
<td>
<p>Set the number of threads to use for optimization in C++, if
OpenMP is available on your system. Increasing the number of threads
may speed up optimization in some cases by running the likelihood 
calculation in parallel. If <code>threads=1</code> (the default), OpenMP is disabled.</p>
</td></tr> 
<tr><td><code id="pcount_+3A_...">...</code></td>
<td>
<p>Additional arguments to optim, such as lower and upper
bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits N-mixture model of Royle (2004) to spatially replicated count data.
</p>
<p>See <code><a href="#topic+unmarkedFramePCount">unmarkedFramePCount</a></code> for a description of how to format data
for <code>pcount</code>.
</p>
<p>This function fits the latent N-mixture model for point count data
(Royle 2004, Kery et al 2005).
</p>
<p>The latent abundance distribution, <code class="reqn">f(N | \mathbf{\theta})</code> can be set as a Poisson, negative binomial, or zero-inflated
Poisson random
variable, depending on the setting of the <code>mixture</code> argument,
<code>mixture = "P"</code>, <code>mixture = "NB"</code>, <code>mixture = "ZIP"</code>
respectively.  For the first two distributions, the mean of <code class="reqn">N_i</code> is
<code class="reqn">\lambda_i</code>.  If <code class="reqn">N_i \sim NB</code>, then an
additional parameter, <code class="reqn">\alpha</code>, describes dispersion (lower
<code class="reqn">\alpha</code> implies higher variance). For the ZIP distribution,
the mean is <code class="reqn">\lambda_i(1-\psi)</code>, where psi is the
zero-inflation parameter.
</p>
<p>The detection process is modeled as binomial: <code class="reqn">y_{ij} \sim
Binomial(N_i, p_{ij})</code>.
</p>
<p>Covariates of <code class="reqn">\lambda_i</code> use the log link and
covariates of <code class="reqn">p_{ij}</code> use the logit link.</p>


<h3>Value</h3>

<p>unmarkedFit object describing the model fit.</p>


<h3>Author(s)</h3>

<p>Ian Fiske and Richard Chandler</p>


<h3>References</h3>

<p>Royle, J. A. (2004) N-Mixture Models for Estimating Population Size from
Spatially Replicated Counts. <em>Biometrics</em> 60, pp. 108&ndash;105.
</p>
<p>Kery, M., Royle, J. A., and Schmid, H. (2005) Modeling Avaian Abundance from
Replicated Counts Using Binomial Mixture Models. <em>Ecological Applications</em>
15(4), pp. 1450&ndash;1461.
</p>
<p>Johnson, N.L, A.W. Kemp, and S. Kotz. (2005) Univariate Discrete
Distributions, 3rd ed. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFramePCount">unmarkedFramePCount</a></code>, <code><a href="#topic+pcountOpen">pcountOpen</a></code>,
<code><a href="#topic+ranef">ranef</a></code>, <code><a href="#topic+parboot">parboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulate data
set.seed(35)
nSites &lt;- 100
nVisits &lt;- 3
x &lt;- rnorm(nSites)               # a covariate
beta0 &lt;- 0
beta1 &lt;- 1
lambda &lt;- exp(beta0 + beta1*x)   # expected counts at each site
N &lt;- rpois(nSites, lambda)       # latent abundance
y &lt;- matrix(NA, nSites, nVisits)
p &lt;- c(0.3, 0.6, 0.8)            # detection prob for each visit
for(j in 1:nVisits) {
  y[,j] &lt;- rbinom(nSites, N, p[j])
  }

# Organize data
visitMat &lt;- matrix(as.character(1:nVisits), nSites, nVisits, byrow=TRUE)

umf &lt;- unmarkedFramePCount(y=y, siteCovs=data.frame(x=x),
    obsCovs=list(visit=visitMat))
summary(umf)

# Fit a model
fm1 &lt;- pcount(~visit-1 ~ x, umf, K=50)
fm1

plogis(coef(fm1, type="det")) # Should be close to p


# Empirical Bayes estimation of random effects
(fm1re &lt;- ranef(fm1))
plot(fm1re, subset=site %in% 1:25, xlim=c(-1,40))
sum(bup(fm1re))         # Estimated population size
sum(N)                  # Actual population size


# Real data
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
obsCovs = mallard.obs)
(fm.mallard &lt;- pcount(~ ivel+ date + I(date^2) ~ length + elev + forest, mallardUMF, K=30))
(fm.mallard.nb &lt;- pcount(~ date + I(date^2) ~ length + elev, mixture = "NB", mallardUMF, K=30))


## End(Not run)

</code></pre>

<hr>
<h2 id='pcount.spHDS'>
Fit spatial hierarchical distance sampling model.
</h2><span id='topic+pcount.spHDS'></span>

<h3>Description</h3>

<p>Function fits an N-mixture model for a discrete state space with raster covariates, and a detection function which decreases with distance from the observer, assumed to be at the centre. See Kery &amp; Royle (2016) Section 9.8.4 for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcount.spHDS(formula, data, K, mixture = c("P", "NB", "ZIP"), starts,
  method = "BFGS", se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcount.spHDS_+3A_formula">formula</code></td>
<td>

<p>Double right-hand side formula describing covariates of detection and abundance, in that order.
</p>
<p>Detection model should be specified without an intercept, for example:
<code>~ -1 + I(dist^2)</code>, where <code>dist</code> is a covariate giving the distance of each cell of the raster from the observer.
Internally this forces the intercept <code>p(0) = 1</code>, conventional for distance
sampling models (see Kery &amp; Royle (2016) for explanation). More general models
work but may not honor that constraint. e.g.,
<code>~ 1,
~ dist,
~ I(dist^2),
~ dist + I(dist^2)</code>
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_data">data</code></td>
<td>

<p>an <code>unmarkedFramePCount</code> object supplying data to the model.
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_k">K</code></td>
<td>

<p>Integer upper index of integration for N-mixture. This should be set high enough so that it does not affect the parameter estimates. Note that computation time will increase with K.
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_mixture">mixture</code></td>
<td>

<p>character specifying mixture: Poisson (P), Negative-Binomial (NB), or Zero Inflated Poisson (ZIP).
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_starts">starts</code></td>
<td>

<p>vector of starting values
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_method">method</code></td>
<td>

<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_se">se</code></td>
<td>

<p>logical specifying whether or not to compute standard errors.
</p>
</td></tr>
<tr><td><code id="pcount.spHDS_+3A_...">...</code></td>
<td>

<p>Additional arguments to optim, such as lower and upper bounds
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>unmarkedFit object describing the model fit.
</p>


<h3>Author(s)</h3>

<p>Kery &amp; Royle
</p>


<h3>References</h3>

<p>Kery &amp; Royle (2016) <em>Applied Hierarachical Modeling in Ecology</em> Section 9.8.4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some data to analyse
# This is based on Kery and Royle (2016) section 9.8.3
# See AHMbook::sim.spatialDS for more simulation options.

# We will simulate distance data for a logit detection function with sigma = 1,
# for a 6x6 square, divided into a 30 x 30 grid of pixels (900 in all), with the
# observer in the centre.

set.seed(2017)

## 1. Create coordinates for 30 x 30 grid
grx &lt;- seq(0.1, 5.9, 0.2)    # mid-point coordinates
gr &lt;- expand.grid(grx, grx)  # data frame with coordinates of pixel centres

## 2a. Simulate spatially correlated Habitat covariate
# Get the pair-wise distances between pixel centres
tmp &lt;- as.matrix(dist(gr))  # a 900 x 900 matrix
# Correlation is a negative exponential function of distance, with scale parameter = 1
V &lt;- exp(-tmp/1)
Habitat &lt;- crossprod(t(chol(V)), rnorm(900))

## 2b. Do a detection covariate: the distance of each pixel centre from the observer
dist &lt;- sqrt((gr[,1]-3)^2 + (gr[,2]-3)^2)

## 3. Simulate the true population
# Probability that an animal is in a pixel depends on the Habitat covariate, with
#   coefficient beta:
beta &lt;- 1
probs &lt;- exp(beta*Habitat) / sum(exp(beta*Habitat))
# Allocate 600 animals to the 900 pixels, get the pixel ID for each animal
pixel.id &lt;- sample(1:900, 600, replace=TRUE, prob=probs)

## 4. Simulate the detection process
# Get the distance of each animal from the observer
# (As an approximation, we'll treat animals as if they are at the pixel centre.)
d &lt;- dist[pixel.id]
# Calculate probability of detection with logit detection function with
sigma &lt;- 1
p &lt;- 2*plogis(-d^2/(2*sigma^2))
# Simulate the 1/0 detection/nondetection vector
y &lt;- rbinom(600, 1, p)
# Check the number of animals detected
sum(y)
# Select the pixel IDs for the animals detected and count the number in each pixel
detected.pixel.id &lt;- pixel.id[y == 1]
pixel.count &lt;- tabulate(detected.pixel.id, nbins=900)

## 5. Prepare the data for unmarked
# Centre the Habitat covariate
Habitat &lt;- Habitat - mean(Habitat)
# Construct the unmarkedFramePCount object
umf &lt;- unmarkedFramePCount(y=cbind(pixel.count),     # y needs to be a 1-column matrix
   siteCovs=data.frame(dist=dist, Habitat=Habitat))
summary(umf)

## 6. Fit some models
(fm0 &lt;- pcount.spHDS(~ -1 + I(dist^2) ~ 1, umf, K = 20))
(fm1 &lt;- pcount.spHDS(~ -1 + I(dist^2) ~ Habitat, umf, K = 20))
# The true Habitat coefficient (beta above) = 1
# fm1 has much lower AIC; look at the population estimate
sum(predict(fm1, type="state")[, 1])
</code></pre>

<hr>
<h2 id='pcountOpen'>Fit the open N-mixture models of Dail and Madsen and extensions</h2><span id='topic+pcountOpen'></span>

<h3>Description</h3>

<p>Fit the models of Dail and Madsen (2011) and Hostetler and
Chandler (in press), which are
generalized forms of the Royle (2004) N-mixture model for open
populations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcountOpen(lambdaformula, gammaformula, omegaformula, pformula,
  data, mixture = c("P", "NB", "ZIP"), K, dynamics=c("constant", "autoreg",
  "notrend", "trend", "ricker", "gompertz"), fix=c("none", "gamma", "omega"),
  starts, method = "BFGS", se = TRUE, immigration = FALSE,
  iotaformula = ~1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcountOpen_+3A_lambdaformula">lambdaformula</code></td>
<td>

<p>Right-hand sided formula for initial abundance
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_gammaformula">gammaformula</code></td>
<td>

<p>Right-hand sided formula for recruitment rate (when dynamics is &quot;constant&quot;,
&quot;autoreg&quot;, or &quot;notrend&quot;) or population growth rate (when dynamics is
&quot;trend&quot;, &quot;ricker&quot;, or &quot;gompertz&quot;)
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_omegaformula">omegaformula</code></td>
<td>

<p>Right-hand sided formula for apparent survival probability
(when dynamics is &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot;) or equilibrium
abundance (when dynamics is &quot;ricker&quot; or &quot;gompertz&quot;)
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_pformula">pformula</code></td>
<td>

<p>Right-hand sided formula for detection probability
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_data">data</code></td>
<td>

<p>An object of class <code><a href="#topic+unmarkedFramePCO">unmarkedFramePCO</a></code>. See details
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_mixture">mixture</code></td>
<td>

<p>character specifying mixture: &quot;P&quot;, &quot;NB&quot;, or &quot;ZIP&quot; for
the Poisson, negative binomial, and zero-inflated Poisson
distributions.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_k">K</code></td>
<td>

<p>Integer defining upper bound of discrete integration. This
should be higher than the maximum observed count and high enough
that it does not affect the parameter estimates. However, the higher
the value the slower the compuatation.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_dynamics">dynamics</code></td>
<td>

<p>Character string describing the type of population
dynamics. &quot;constant&quot; indicates that there is no relationship between
omega and gamma. &quot;autoreg&quot; is an auto-regressive model in which
recruitment is modeled as gamma*N[i,t-1]. &quot;notrend&quot; model gamma as
lambda*(1-omega) such that there is no temporal trend. &quot;trend&quot; is
a model for exponential growth, N[i,t] = N[i,t-1]*gamma, where gamma
in this case is finite rate of increase (normally referred to as
lambda). &quot;ricker&quot; and &quot;gompertz&quot; are models for density-dependent
population growth.  &quot;ricker&quot; is the Ricker-logistic model, N[i,t] =
N[i,t-1]*exp(gamma*(1-N[i,t-1]/omega)), where gamma is the maximum
instantaneous population growth rate (normally referred to as r) and
omega is the equilibrium abundance (normally referred to as K).  &quot;gompertz&quot;
is a modified version of the Gompertz-logistic model, N[i,t] =
N[i,t-1]*exp(gamma*(1-log(N[i,t-1]+1)/log(omega+1))), where the
interpretations of gamma and omega are similar to in the Ricker model.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_fix">fix</code></td>
<td>

<p>If &quot;omega&quot;, omega is fixed at 1. If &quot;gamma&quot;, gamma is fixed at 0.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_starts">starts</code></td>
<td>

<p>vector of starting values
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_method">method</code></td>
<td>

<p>Optimization method used by <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_se">se</code></td>
<td>

<p>logical specifying whether or not to compute standard errors.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_immigration">immigration</code></td>
<td>

<p>logical specifying whether or not to include an immigration term (iota) in
population dynamics.
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_iotaformula">iotaformula</code></td>
<td>

<p>Right-hand sided formula for average number of immigrants to a site
per time step
</p>
</td></tr>
<tr><td><code id="pcountOpen_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These models generalize the Royle (2004) N-mixture model by relaxing the
closure assumption. The models include two or three additional parameters:
gamma, either the recruitment rate (births and immigrations), the
finite rate of increase, or the maximum instantaneous rate of increase;
omega, either the apparent survival rate (deaths and emigrations) or the
equilibrium abundance (carrying capacity); and iota, the number of immigrants
per site and year. Estimates of
population size at each time period can be derived from these
parameters, and thus so can trend estimates. Or, trend can be estimated
directly using dynamics=&quot;trend&quot;.
</p>
<p>When immigration is set to FALSE (the default), iota is not modeled.
When immigration is set to TRUE and dynamics is set to &quot;autoreg&quot;, the model
will separately estimate birth rate (gamma) and number of immigrants (iota).
When immigration is set to TRUE and dynamics is set to &quot;trend&quot;, &quot;ricker&quot;, or
&quot;gompertz&quot;, the model will separately estimate local contributions to
population growth (gamma and omega) and number of immigrants (iota).
</p>
<p>The latent abundance distribution, <code class="reqn">f(N | \mathbf{\theta})</code> can be set as a Poisson, negative binomial, or zero-inflated
Poisson random
variable, depending on the setting of the <code>mixture</code> argument,
<code>mixture = "P"</code>, <code>mixture = "NB"</code>, <code>mixture = "ZIP"</code>
respectively.  For the first two distributions, the mean of <code class="reqn">N_i</code> is
<code class="reqn">\lambda_i</code>.  If <code class="reqn">N_i \sim NB</code>, then an
additional parameter, <code class="reqn">\alpha</code>, describes dispersion (lower
<code class="reqn">\alpha</code> implies higher variance). For the ZIP distribution,
the mean is <code class="reqn">\lambda_i(1-\psi)</code>, where psi is the
zero-inflation parameter.
</p>
<p>For &quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot; dynamics, the latent abundance state
following the initial sampling period arises
from a
Markovian process in which survivors are modeled as <code class="reqn">S_{it} \sim
Binomial(N_{it-1}, \omega_{it})</code>, and recruits
follow <code class="reqn">G_{it} \sim Poisson(\gamma_{it})</code>.
Alternative population dynamics can be specified
using the <code>dynamics</code> and <code>immigration</code> arguments.
</p>
<p>The detection process is modeled as binomial: <code class="reqn">y_{ijt} \sim
Binomial(N_{it}, p_{ijt})</code>.
</p>
<p><code class="reqn">\lambda_i</code>, <code class="reqn">\gamma_{it}</code>, and
<code class="reqn">\iota_{it}</code> are modeled 
using the the log link.
<code class="reqn">p_{ijt}</code> is modeled using
the logit link.
<code class="reqn">\omega_{it}</code> is either modeled using the logit link (for
&quot;constant&quot;, &quot;autoreg&quot;, or &quot;notrend&quot; dynamics) or the log link (for &quot;ricker&quot;
or &quot;gompertz&quot; dynamics).  For &quot;trend&quot; dynamics, <code class="reqn">\omega_{it}</code>
is not modeled.
</p>


<h3>Value</h3>

<p>An object of class unmarkedFitPCO.
</p>


<h3>Warning</h3>

<p>This function can be extremely slow, especially if
there are covariates of gamma or omega. Consider testing the timing on
a small subset of the data, perhaps with se=FALSE. Finding the lowest
value of K that does not affect estimates will also help with speed. </p>


<h3>Note</h3>

<p>When gamma or omega are modeled using year-specific covariates, the
covariate data for the final year will be ignored; however,
they must be supplied.
</p>
<p>If the time gap between primary periods is not constant, an M by T
matrix of integers should be supplied to <code><a href="#topic+unmarkedFramePCO">unmarkedFramePCO</a></code>
using the <code>primaryPeriod</code> argument.
</p>
<p>Secondary sampling periods are optional, but can greatly improve the
precision of the estimates.
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a> and Jeff Hostetler</p>


<h3>References</h3>

<p>Royle, J. A. (2004) N-Mixture Models for Estimating Population Size from
Spatially Replicated Counts. <em>Biometrics</em> 60, pp. 108&ndash;105.
</p>
<p>Dail, D. and L. Madsen (2011) Models for Estimating Abundance from
Repeated Counts of an Open Metapopulation. <em>Biometrics</em>. 67, pp
577-587.
</p>
<p>Hostetler, J. A. and R. B. Chandler (2015) Improved State-space Models for
Inference about Spatial and Temporal Variation in Abundance from Count Data.
<em>Ecology</em>
96:1713-1723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcount">pcount</a>, <a href="#topic+unmarkedFramePCO">unmarkedFramePCO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulation
## No covariates, constant time intervals between primary periods, and
## no secondary sampling periods

set.seed(3)
M &lt;- 50
T &lt;- 5
lambda &lt;- 4
gamma &lt;- 1.5
omega &lt;- 0.8
p &lt;- 0.7
y &lt;- N &lt;- matrix(NA, M, T)
S &lt;- G &lt;- matrix(NA, M, T-1)
N[,1] &lt;- rpois(M, lambda)
for(t in 1:(T-1)) {
	S[,t] &lt;- rbinom(M, N[,t], omega)
	G[,t] &lt;- rpois(M, gamma)
	N[,t+1] &lt;- S[,t] + G[,t]
	}
y[] &lt;- rbinom(M*T, N, p)


# Prepare data
umf &lt;- unmarkedFramePCO(y = y, numPrimary=T)
summary(umf)


# Fit model and backtransform
(m1 &lt;- pcountOpen(~1, ~1, ~1, ~1, umf, K=20)) # Typically, K should be higher

(lam &lt;- coef(backTransform(m1, "lambda"))) # or
lam &lt;- exp(coef(m1, type="lambda"))
gam &lt;- exp(coef(m1, type="gamma"))
om &lt;- plogis(coef(m1, type="omega"))
p &lt;- plogis(coef(m1, type="det"))

## Not run: 
# Finite sample inference. Abundance at site i, year t
re &lt;- ranef(m1)
devAskNewPage(TRUE)
plot(re, layout=c(5,5), subset = site %in% 1:25 &amp; year %in% 1:2,
     xlim=c(-1,15))
devAskNewPage(FALSE)

(N.hat1 &lt;- colSums(bup(re)))

# Expected values of N[i,t]
N.hat2 &lt;- matrix(NA, M, T)
N.hat2[,1] &lt;- lam
for(t in 2:T) {
    N.hat2[,t] &lt;- om*N.hat2[,t-1] + gam
    }

rbind(N=colSums(N), N.hat1=N.hat1, N.hat2=colSums(N.hat2))



## End(Not run)

</code></pre>

<hr>
<h2 id='piFuns'>Compute multinomial cell probabilities</h2><span id='topic+removalPiFun'></span><span id='topic+doublePiFun'></span><span id='topic+piFuns'></span>

<h3>Description</h3>

<p>Compute the cell probabilities used in the multinomial-Poisson models <a href="#topic+multinomPois">multinomPois</a> and <a href="#topic+gmultmix">gmultmix</a>. These functions use piFuns <em>internally</em> to calculate multinomial likelihoods from the occasion-wise detection probabilities. The only reason to call them directly is to check their behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removalPiFun(p)
doublePiFun(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piFuns_+3A_p">p</code></td>
<td>

<p>matrix of detection probabilities at each site for each observation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These two functions are provided as examples of possible functions to calculate multinomial cell probabilities. Users may write their own functions for specific sampling designs (see the example).
</p>


<h3>Value</h3>

<p>For removalPiFun, a matrix of cell probabilities for each site and sampling period.
</p>
<p>For doublePiFun, a matrix of cell probabilities for each site and observer combination. Column one is probability observer 1 but not observer 2 detects the object, column two is probability that observer 2 but not observer 1 detects the object, and column 3 is probability of both detecting.
</p>


<h3>See Also</h3>

<p><a href="#topic+makePiFuns">makePiFuns</a> for factory functions to create customised piFuns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(pRem &lt;- matrix(0.5, nrow=3, ncol=3))	# Capture probabilities
removalPiFun(pRem)			# Cell probs

(pDouble &lt;- matrix(0.5, 3, 2))		# Observer detection probs
doublePiFun(pDouble)			# Cell probs

# A user-defined piFun calculating removal probs when time intervals differ.
# Here 10-minute counts were divided into 2, 3, and 5 minute intervals.
# This function could be supplied to unmarkedFrameMPois along with the obsToY
# argument shown below.

instRemPiFun &lt;- function(p) {
	M &lt;- nrow(p)
	J &lt;- ncol(p)
	pi &lt;- matrix(NA, M, J)
	p[,1] &lt;- pi[,1] &lt;- 1 - (1 - p[,1])^2
	p[,2] &lt;- 1 - (1 - p[,2])^3
	p[,3] &lt;- 1 - (1 - p[,3])^5
	for(i in 2:J) {
		pi[,i] &lt;- pi[, i - 1]/p[, i - 1] * (1 - p[, i - 1]) * p[, i]
		}
	return(pi)
	}

instRemPiFun(pRem)

# Associated obsToY matrix required by unmarkedFrameMPois
o2y &lt;- diag(3) # if y has 3 columns
o2y[upper.tri(o2y)] &lt;- 1
o2y

</code></pre>

<hr>
<h2 id='plotEffects'>Plot marginal effects of covariates in unmarked models</h2><span id='topic+plotEffects'></span><span id='topic+plotEffects-methods'></span><span id='topic+plotEffects+2CunmarkedFit-method'></span><span id='topic+plotEffectsData'></span><span id='topic+plotEffectsData-methods'></span><span id='topic+plotEffectsData+2CunmarkedFit-method'></span>

<h3>Description</h3>

<p>This function generates a plot visualizing the effects
of a single covariate on a parameter (e.g. occupancy, abundance) in an unmarked 
model. If the covariate is numeric, the result is a line plot with an error
ribbon where the x-axis is the range of the covariate and the y-axis is the 
predicted parameter value. If the covariate is an R factor (i.e., categorical),
the x-axis instead contains each unique value of the covariate. 
</p>
<p>All covariates in the model besides the one being plotted are held either at
their median value (if they are numeric) or at their reference level (if they
are factors).
</p>
<p>Some types of unmarked models may require additional arguments, which are passed
to the matching <code>predict</code> method. For example, <code>unmarkedFitOccuMulti</code> 
models require the <code>species</code> argument to be included in the function 
call in order to work properly.
</p>
<p>If you want to customize a plot, the easiest approach is to get data 
formatted for plotting using <code>plotEffectsData</code>, and use that. If
you want to see and/or modify the code used by <code>plotEffects</code> to generate
the default plots, run <code>getMethod("plotEffects", "unmarkedFit")</code> in
the R console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFit'
plotEffects(object, type, covariate, level=0.95, ...)
## S4 method for signature 'unmarkedFit'
plotEffectsData(object, type, covariate, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEffects_+3A_object">object</code></td>
<td>
<p>A fitted model inheriting class <code>unmarkedFit</code></p>
</td></tr>
<tr><td><code id="plotEffects_+3A_type">type</code></td>
<td>
<p>Submodel in which the covariate of interest can be found, for
example <code>"state"</code> or <code>"det"</code>. This will depend on the fitted model</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_covariate">covariate</code></td>
<td>
<p>The name of the covariate to be plotted, as a character string</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_level">level</code></td>
<td>
<p>Confidence level for the error ribbons or bars</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the <code>predict</code> function, required
for some <code>unmarkedFit</code> types such as <code>unmarkedFitOccuMulti</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot (<code>plotEffects</code> or a data frame (<code>plotEffectsData</code>)
containing values to be used in a plot.
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulate data and build an unmarked frame
set.seed(123)
dat_occ &lt;- data.frame(x1=rnorm(500))
dat_p &lt;- data.frame(x2=rnorm(500*5))

y &lt;- matrix(NA, 500, 5)
z &lt;- rep(NA, 500)

b &lt;- c(0.4, -0.5, 0.3, 0.5)

re_fac &lt;- factor(sample(letters[1:5], 500, replace=T))
dat_occ$group &lt;- re_fac
re &lt;- rnorm(5, 0, 1.2)
re_idx &lt;- as.numeric(re_fac)

idx &lt;- 1
for (i in 1:500){
  z[i] &lt;- rbinom(1,1, plogis(b[1] + b[2]*dat_occ$x1[i] + re[re_idx[i]]))
  for (j in 1:5){
    y[i,j] &lt;- z[i]*rbinom(1,1,
                    plogis(b[3] + b[4]*dat_p$x2[idx]))
    idx &lt;- idx + 1
  }
}

umf &lt;- unmarkedFrameOccu(y=y, siteCovs=dat_occ, obsCovs=dat_p)

# Fit model
(fm &lt;- occu(~x2 ~x1 + group, umf))

# Plot marginal effects of various covariates
plotEffects(fm, "state", "x1")
plotEffects(fm, "state", "group")
plotEffects(fm, "det", "x2")

# Get raw data used for a plot
plotEffectsData(fm, "state", "group")

# See code used by plotEffects so you can edit it yourself and customize the plot
methods::getMethod("plotEffects", "unmarkedFit")

## End(Not run)
</code></pre>

<hr>
<h2 id='pointtran'>
Simulated point-transect data
</h2><span id='topic+pointtran'></span>

<h3>Description</h3>

<p>Response matrix of animals detected in five distance classes plus two covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pointtran)</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 7 variables.
</p>

<dl>
<dt><code>dc1</code></dt><dd><p>Counts in distance class 1 [0-5 m)</p>
</dd>
<dt><code>dc2</code></dt><dd><p>Counts in distance class 2 [5-10 m)</p>
</dd>
<dt><code>dc3</code></dt><dd><p>Counts in distance class 3 [10-15 m)</p>
</dd>
<dt><code>dc4</code></dt><dd><p>Counts in distance class 4 [15-20 m)</p>
</dd>
<dt><code>dc5</code></dt><dd><p>Counts in distance class 5 [20-25 m)</p>
</dd>
<dt><code>area</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>habitat</code></dt><dd><p>a factor with levels <code>A</code> <code>B</code> <code>C</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(pointtran)
pointtran

# Format for distsamp()
ptUMF &lt;- with(pointtran, {
        unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4, dc5), 
        siteCovs = data.frame(area, habitat), 
        dist.breaks = seq(0, 25, by=5), survey = "point", unitsIn = "m")
        })
</code></pre>

<hr>
<h2 id='posteriorSamples'>Draw samples from the posterior predictive distribution</h2><span id='topic+posteriorSamples'></span><span id='topic+posteriorSamples-methods'></span><span id='topic+posteriorSamples+2CunmarkedRanef-method'></span><span id='topic+posteriorSamples+2CunmarkedFit-method'></span><span id='topic+unmarkedPostSamples-class'></span><span id='topic+show+2CunmarkedPostSamples-method'></span><span id='topic++5B+2CunmarkedPostSamples+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Draw samples from the empirical Bayes posterior predictive distribution 
derived from unmarked models or ranef objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedRanef'
posteriorSamples(object, nsims=100, ...)
## S4 method for signature 'unmarkedFit'
posteriorSamples(object, nsims=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorSamples_+3A_object">object</code></td>
<td>
<p>An object inheriting class <code>unmarkedRanef</code> or 
<code>unmarkedFit</code></p>
</td></tr>
<tr><td><code id="posteriorSamples_+3A_nsims">nsims</code></td>
<td>
<p>Number of draws to make from the posterior predictive distribution</p>
</td></tr>
<tr><td><code id="posteriorSamples_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unmarkedPostSamples</code> object containing the draws from the
posterior predictive distribution. The draws are in the <code>@samples</code> slot. 
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef">ranef</a></code>,
<code><a href="#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data under N-mixture model
set.seed(4564)
R &lt;- 20
J &lt;- 5
N &lt;- rpois(R, 10)
y &lt;- matrix(NA, R, J)
y[] &lt;- rbinom(R*J, N, 0.5)

# Fit model
umf &lt;- unmarkedFramePCount(y=y)
fm &lt;- pcount(~1 ~1, umf, K=50)

# Estimates of conditional abundance distribution at each site
(re &lt;- ranef(fm))

#Draw from the posterior predictive distribution
(ppd &lt;- posteriorSamples(re, nsims=100))

</code></pre>

<hr>
<h2 id='powerAnalysis'>Conduct a power analysis on an unmarked model</h2><span id='topic+powerAnalysis'></span>

<h3>Description</h3>

<p>This function uses a simulation-based approach to estimate power for parameters 
in unmarked models. At a minimum, users must provide a fitted <code>unmarked</code> model object
(preferably fit with simulated data) which ensures the model has been properly
specified, a list of effect sizes for each parameter in the model (<code>coefs</code>), 
and the desired Type I error (<code>alpha</code>). It is also possible to get power
for a range of other sample sizes besides the sample size in the fitted
model object using the <code>design</code> argument to subsample within the
provided dataset. See the <code>unmarkedPower</code> vignette for more details and
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  powerAnalysis(object, coefs=NULL, design=NULL, alpha=0.05, nulls=list(),
                datalist=NULL, 
                nsim=ifelse(is.null(datalist), 100, length(datalist)), 
                parallel=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerAnalysis_+3A_object">object</code></td>
<td>
<p>A fitted model inheriting class <code>unmarkedFit</code>. This
could potentially be fit using real data, but ideally you would simulate
an appropriate dataset using <code>simulate</code></p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_coefs">coefs</code></td>
<td>
<p>A list containing the desired effect sizes for which you want
to estimate power. This list must follow a specific format. There is one
named entry in the list per submodel (e.g., occupancy, detection). To
get the required submodel names call <code>names(object)</code> on your fitted model.
Then, each list entry is a named vector with the names corresponding to the
parameter names for that submodel, and the values corresponding to the 
desired effect sizes. It may be easier to leave <code>coefs=NULL</code>, which
will generate an error message with a template that you can fill in.
</p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_design">design</code></td>
<td>
<p>An optional list of design/sample size parameters containing 
at a minimum two named elements: <code>M</code>, the number of sites, and <code>J</code> 
the number of observations per site. If this list is provided, <code>unmarked</code> 
will subsample the provided dataset to the specified number of sites and
observations, allowing you to test power for different designs. If
your model has multiple primary periods you must also include <code>T</code>,
the number of periods, in the list.
</p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_alpha">alpha</code></td>
<td>
<p>Desired Type I error rate</p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_nulls">nulls</code></td>
<td>
<p>If provided, a list matching the structure of <code>coefs</code> which
defines the null hypothesis value for each parameter. By default the null
is 0 for all parameters.
</p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_datalist">datalist</code></td>
<td>
<p>An optional list of previously-simulated datasets, in the form
of <code>unmarkedFrames</code> matching the model type of <code>object</code>, which
will be used for the power analysis simulations.
</p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to conduct</p>
</td></tr>
<tr><td><code id="powerAnalysis_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, run folds in parallel. This may speed up 
the power analysis in some situations
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unmarkedPower</code> object containing the results of the power analysis</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedPowerList">unmarkedPowerList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulate an occupancy dataset
# Covariates to include in simulation
forms &lt;- list(state=~elev, det=~1)

# Covariate effects and intercept values
coefs &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))

# Study design
design &lt;- list(M=300, J=8) # 300 sites, 8 occasions per site

# Simulate an unmarkedFrameOccu
occu_umf &lt;- simulate("occu", formulas=forms, coefs=coefs, design=design)

# Fit occupancy model to simulated data
# This will contain all the model structure info powerAnalysis needs
# The estimates from the model aren't used
template_model &lt;- occu(~1~elev, occu_umf)

# If we run powerAnalysis without specifying coefs we'll get a template list
powerAnalysis(template_model)

# Set desired effect sizes to pass to coefs
effect_sizes &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))

# Run power analysis and look at summary
(pa &lt;- powerAnalysis(template_model, coefs=effect_sizes, alpha=0.05))

# Try a smaller sample size in the study design
(pa2 &lt;- powerAnalysis(template_model, coefs=effect_sizes, alpha=0.05,
                      design=list(M=100, J=2)))


## End(Not run)
</code></pre>

<hr>
<h2 id='predict-methods'> Methods for Function predict in Package &lsquo;unmarked&rsquo; </h2><span id='topic+predict'></span><span id='topic+predict-methods'></span><span id='topic+predict+2CANY-method'></span><span id='topic+predict+2CunmarkedFit-method'></span><span id='topic+predict+2CunmarkedFitOccuFP-method'></span><span id='topic+predict+2CunmarkedFitOccuMulti-method'></span><span id='topic+predict+2CunmarkedFitOccuMS-method'></span><span id='topic+predict+2CunmarkedFitOccuTTD-method'></span><span id='topic+predict+2CunmarkedFitNmixTTD-method'></span><span id='topic+predict+2CunmarkedFitPCount-method'></span><span id='topic+predict+2CunmarkedFitColExt-method'></span><span id='topic+predict+2CunmarkedFitGMM-method'></span><span id='topic+predict+2CunmarkedFitGDS-method'></span><span id='topic+predict+2CunmarkedFitPCO-method'></span><span id='topic+predict+2CunmarkedFitDSO-method'></span><span id='topic+predict+2CunmarkedFitGDR-method'></span><span id='topic+predict+2CunmarkedFitList-method'></span><span id='topic+predict+2CunmarkedRanef-method'></span>

<h3>Description</h3>

<p>These methods return predicted values from fitted model objects.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "unmarkedFit")</code></dt><dd>
<p>&quot;type&quot; must be either &lsquo;state&rsquo; or &lsquo;det&rsquo;.
</p>
</dd>
<dt><code>signature(object = "unmarkedFitColExt")</code></dt><dd>
<p>&quot;type&quot; must be 'psi', 'col', 'ext', or 'det'.
</p>
</dd>
<dt><code>signature(object = "unmarkedFitGMM")</code></dt><dd>
<p>&quot;type&quot; must be 'lambda', 'psi', 'det'
</p>
</dd>
<dt><code>signature(object = "unmarkedFitList")</code></dt><dd>
<p>&quot;type&quot; depends upon the fitted models
</p>
</dd>
<dt><code>signature(object = "unmarkedRanef")</code></dt><dd>
<p>Use this method to generate the empirical Bayes posterior predictive distribution
for functions of the random variables (latent abundance or occurrence).
</p>
<p>In addition to the output object from <code>ranef</code>, you must also supply a 
custom function to argument <code>func</code>. The function must take as input a matrix
with dimensions M x T, where M is the number of sites and T is the number of 
primary periods (T=1 for single-season models). The output of this function should 
be a vector or matrix containing the derived parameters of interest. 
</p>
<p>You may also manually set the number of draws from the posterior predictive
distribution with argument <code>nsims</code>; the default is 100.
</p>
<p>The output of <code>predict</code> will be a vector or array with one more dimension
than the output of the function supplied <code>func</code>, corresponding to the number
of draws requested <code>nsims</code>. For example, if <code>func</code>
outputs a scalar, the output of <code>predict</code> will be a vector with length
equal to <code>nsims</code>. If <code>func</code> outputs a 3x2 matrix, the output of
<code>predict</code> will be an array with dimensions 3x2x<code>nsims</code>.
See <code><a href="#topic+ranef">ranef</a></code> for an example.
</p>
<p>Alternatively, you can use the <code><a href="#topic+posteriorSamples">posteriorSamples</a></code> function on the
<code>ranef</code> output object to obtain the full posterior predictive distribution. 
This is useful if you are having trouble designing your custom function or if 
you want to obtain multiple different derived parameters from the same posterior
predictive distribution.
</p>
</dd>
</dl>

<hr>
<h2 id='randomTerms'>Extract estimates of random effect terms</h2><span id='topic+randomTerms'></span><span id='topic+randomTerms-methods'></span><span id='topic+randomTerms+2CunmarkedFit-method'></span><span id='topic+randomTerms+2CunmarkedEstimate-method'></span>

<h3>Description</h3>

<p>Extract estimates and summary statistics of random effect terms from an
<code>unmarkedFit</code> model or an <code>unmarkedEstimate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedEstimate'
randomTerms(object, level=0.95, ...)
## S4 method for signature 'unmarkedFit'
randomTerms(object, type, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomTerms_+3A_object">object</code></td>
<td>
<p>An object inheriting class <code>unmarkedEstimate</code> or 
<code>unmarkedFit</code></p>
</td></tr>
<tr><td><code id="randomTerms_+3A_level">level</code></td>
<td>
<p>Significance level to use for confidence interval</p>
</td></tr>
<tr><td><code id="randomTerms_+3A_type">type</code></td>
<td>
<p>If provided, return only random effect terms from the chosen
submodel type (as a character string)</p>
</td></tr>
<tr><td><code id="randomTerms_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing estimates, SEs, and confidence intervals
for random effect terms in the model. 
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>

<hr>
<h2 id='ranef-methods'> Methods for Function <code>ranef</code> in Package <span class="pkg">unmarked</span> </h2><span id='topic+ranef'></span><span id='topic+ranef-methods'></span><span id='topic+ranef+2CunmarkedFitOccu-method'></span><span id='topic+ranef+2CunmarkedFitOccuFP-method'></span><span id='topic+ranef+2CunmarkedFitOccuRN-method'></span><span id='topic+ranef+2CunmarkedFitOccuMulti-method'></span><span id='topic+ranef+2CunmarkedFitOccuMS-method'></span><span id='topic+ranef+2CunmarkedFitPCount-method'></span><span id='topic+ranef+2CunmarkedFitMPois-method'></span><span id='topic+ranef+2CunmarkedFitDS-method'></span><span id='topic+ranef+2CunmarkedFitGMM-method'></span><span id='topic+ranef+2CunmarkedFitGDS-method'></span><span id='topic+ranef+2CunmarkedFitGPC-method'></span><span id='topic+ranef+2CunmarkedFitGMMorGDS-method'></span><span id='topic+ranef+2CunmarkedFitColExt-method'></span><span id='topic+ranef+2CunmarkedFitPCO-method'></span><span id='topic+ranef+2CunmarkedFitOccuTTD-method'></span><span id='topic+ranef+2CunmarkedFitNmixTTD-method'></span><span id='topic+ranef+2CunmarkedFitGDR-method'></span><span id='topic+ranef+2CunmarkedFitDailMadsen-method'></span><span id='topic+ranef+2CunmarkedFitGOccu-method'></span><span id='topic+ranef+2CunmarkedFitOccuCOP-method'></span>

<h3>Description</h3>

<p>Estimate posterior distributions of the random variables (latent
abundance or occurrence) using empirical Bayes methods. These methods
return an object storing the posterior distributions of the latent
variables at each site, and for each year (primary period) in the case
of open population models. See <a href="#topic+unmarkedRanef-class">unmarkedRanef-class</a> for methods
used to manipulate the returned object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "unmarkedFitOccu")</code></dt><dd><p>Computes the
conditional distribution of occurrence given the data and the
estimates of the
fixed effects, <code class="reqn">Pr(z_i=1 | y_{ij}, \hat{\psi}_i,
  \hat{p}_{ij})</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitOccuRN")</code></dt><dd><p>Computes the
conditional abundance distribution given the data and the estimates of
the fixed effects, <code class="reqn">Pr(N_i=k | y_{ij}, \hat{\psi}_i, \hat{r}_{ij})
  k = 0,1,\dots,K</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitPCount")</code></dt><dd><p><code class="reqn">Pr(N_i=k |
  y_{ij}, \hat{\lambda}_i, \hat{p}_{ij}) k = 0,1,\dots,K</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitMPois")</code></dt><dd><p><code class="reqn">Pr(N_i=k |
  y_{ij}, \hat{\lambda}_i, \hat{p}_{ij}) k = 0,1,\dots,K</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitDS")</code></dt><dd><p><code class="reqn">Pr(N_i=k |
  y_{i,1:J}, \hat{\lambda}_i, \hat{\sigma}_{i}) k =
  0,1,\dots,K</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitGMM")</code></dt><dd><p><code class="reqn">Pr(M_i=k |
  y_{i,1:J,t}, \hat{\lambda}_i, \hat{\phi}_{it}, \hat{p}_{ijt})  k =
  0,1,\dots,K</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitGDS")</code></dt><dd><p><code class="reqn">Pr(M_i=k |
  y_{i,1:J,t}, \hat{\lambda}_i, \hat{\phi}_{it}, \hat{\sigma}_{it})
  k = 0,1,\dots,K</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitColExt")</code></dt><dd><p><code class="reqn">Pr(z_{it}=1 |
  y_{ijt}, \hat{\psi}_i, \hat{\gamma}_{it}, \hat{\epsilon}_{it},
  \hat{p}_{ijt})</code></p>
</dd>
<dt><code>signature(object = "unmarkedFitPCO")</code></dt><dd><p><code class="reqn">Pr(N_{it}=k |
  y_{ijt}, \hat{\lambda}_i, \hat{\gamma}_{it}, \hat{\omega}_{it},
  \hat{\iota}_{it}, \hat{p}_{ijt}) k = 0,1,...,K</code></p>
</dd>
</dl>



<h3>Warning</h3>

<p>Empirical Bayes methods can underestimate the variance of the
posterior distribution because they do not account for uncertainty in
the hyperparameters (lambda or psi). Eventually, we hope to add
methods to account for the uncertainty of the hyperparameters.
</p>
<p>Note also that the posterior mode appears to exhibit some bias as an
estimator or abundance. Consider using the posterior mean instead,
even though it will not be an integer in general. More
simulation studies are needed to evaluate the performance of empirical
Bayes methods for these models.
</p>


<h3>Note</h3>

<p>From Carlin and Louis (1996): &ldquo;... the Bayesian approach to
inference depends on a prior distribution for the model
parameters. This prior can depend on unknown parameters which in turn
may follow some second-stage prior. This sequence of parameters and
priors consitutes a hierarchical model. The hierarchy must stop at
some point, with all remaining prior parameters assumed known. Rather
than make this assumption, the basic empirical Bayes approach uses the
observed data to estimate these final stage parameters (or to estimate
the Bayes rule), and proceeds as in a standard Bayesian analysis.&rdquo;
</p>


<h3>Author(s)</h3>

<p>Richard Chandler <a href="mailto:rbchan@uga.edu">rbchan@uga.edu</a></p>


<h3>References</h3>

<p>Laird, N.M. and T.A. Louis. 1987. Empirical Bayes confidence intervals
based on bootstrap samples. Journal of the American Statistical
Association 82:739&ndash;750.
</p>
<p>Carlin, B.P and T.A Louis. 1996. Bayes and Empirical Bayes Methods for
Data Analysis. Chapman and Hall/CRC.
</p>
<p>Royle, J.A and R.M. Dorazio. 2008. Hierarchical Modeling and Inference
in Ecology. Academic Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+unmarkedRanef-class">unmarkedRanef-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data under N-mixture model
set.seed(4564)
R &lt;- 20
J &lt;- 5
N &lt;- rpois(R, 10)
y &lt;- matrix(NA, R, J)
y[] &lt;- rbinom(R*J, N, 0.5)

# Fit model
umf &lt;- unmarkedFramePCount(y=y)
fm &lt;- pcount(~1 ~1, umf, K=50)

# Estimates of conditional abundance distribution at each site
(re &lt;- ranef(fm))
# Best Unbiased Predictors
bup(re, stat="mean")           # Posterior mean
bup(re, stat="mode")           # Posterior mode
confint(re, level=0.9) # 90% CI

# Plots
plot(re, subset=site %in% c(1:10), layout=c(5, 2), xlim=c(-1,20))

# Compare estimates to truth
sum(N)
sum(bup(re))

# Extract all values in convenient formats
post.df &lt;- as(re, "data.frame")
head(post.df)
post.arr &lt;- as(re, "array")

#Generate posterior predictive distribution for a function
#of random variables using predict()

#First, create a function that operates on a vector of 
#length M (if you fit a single-season model) or a matrix of 
#dimensions MxT (if a dynamic model), where
#M = nsites and T = n primary periods
#Our function will generate mean abundance for sites 1-10 and sites 11-20
myfunc &lt;- function(x){ #x will be length 20 since M=20
  
  #Mean of first 10 sites
  group1 &lt;- mean(x[1:10])
  #Mean of sites 11-20
  group2 &lt;- mean(x[11:20])
  
  #Naming elements of the output is optional but helpful
  return(c(group1=group1, group2=group2))

}

#Get 100 samples of the values calculated in your function
(pr &lt;- predict(re, func=myfunc, nsims=100))

#Summarize posterior
data.frame(mean=rowMeans(pr),
           se=apply(pr, 1, stats::sd),
           lower=apply(pr, 1, stats::quantile, 0.025),
           upper=apply(pr, 1, stats::quantile, 0.975))

#Alternatively, you can return the posterior predictive distribution
#and run operations on it separately
(ppd &lt;- posteriorSamples(re, nsims=100))

</code></pre>

<hr>
<h2 id='SE-methods'>Methods for Function SE in Package &lsquo;unmarked&rsquo;</h2><span id='topic+SE'></span><span id='topic+SE-methods'></span><span id='topic+SE+2ClinCombOrBackTrans-method'></span><span id='topic+SE+2CunmarkedEstimate-method'></span><span id='topic+SE+2CunmarkedFit-method'></span>

<h3>Description</h3>

<p>Extract standard errors of parameter estimates from a fitted model.</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;linCombOrBackTrans&quot;</dt><dd><p>A model prediction</p>
</dd>
<dt>obj = &quot;unmarkedEstimate&quot;</dt><dd><p>See <code><a href="#topic+unmarkedEstimate-class">unmarkedEstimate-class</a></code></p>
</dd>
<dt>obj = &quot;unmarkedFit&quot;</dt><dd><p>A fitted model</p>
</dd>
</dl>

<hr>
<h2 id='shinyPower'>Launch a Shiny app to help with power analysis</h2><span id='topic+shinyPower'></span>

<h3>Description</h3>

<p>Launch a Shiny app to test power under various scenarios. Requires the Shiny 
package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shinyPower(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shinyPower_+3A_object">object</code></td>
<td>
<p>A template <code>unmarkedFit</code> object; see 
documentation for <code>powerAnalysis</code> for details on how to create this</p>
</td></tr>
<tr><td><code id="shinyPower_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects.</p>

<hr>
<h2 id='sight2perpdist'>
Convert sight distance and sight angle to perpendicular distance.
</h2><span id='topic+sight2perpdist'></span>

<h3>Description</h3>

<p>When distance data are collected on line transects using sight distances and
sight angles, they need to be converted to perpendicular distances before 
analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sight2perpdist(sightdist, sightangle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sight2perpdist_+3A_sightdist">sightdist</code></td>
<td>

<p>Distance from observer
</p>
</td></tr>
<tr><td><code id="sight2perpdist_+3A_sightangle">sightangle</code></td>
<td>

<p>Angle from center line. In degrees between 0 and 180.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Perpendicular distance
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distsamp">distsamp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round(sight2perpdist(10, c(0, 45, 90, 135, 180)))
</code></pre>

<hr>
<h2 id='sigma'>Extract estimates of random effect standard deviations</h2><span id='topic+sigma'></span><span id='topic+sigma-methods'></span><span id='topic+sigma+2CunmarkedFit-method'></span><span id='topic+sigma+2CunmarkedEstimate-method'></span>

<h3>Description</h3>

<p>Extract estimates and summary statistics of random effect standard
deviations from an <code>unmarkedFit</code> model or an <code>unmarkedEstimate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedEstimate'
sigma(object, level=0.95, ...)
## S4 method for signature 'unmarkedFit'
sigma(object, type, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma_+3A_object">object</code></td>
<td>
<p>An object inheriting class <code>unmarkedEstimate</code> or 
<code>unmarkedFit</code></p>
</td></tr>
<tr><td><code id="sigma_+3A_level">level</code></td>
<td>
<p>Significance level to use for confidence interval</p>
</td></tr>
<tr><td><code id="sigma_+3A_type">type</code></td>
<td>
<p>If provided, return only random effect SDs from the chosen
submodel type (as a character string)</p>
</td></tr>
<tr><td><code id="sigma_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing estimates, SEs, and confidence intervals
for random effect standard deviations in the model. 
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>

<hr>
<h2 id='simulate-methods'>Methods for Function simulate in Package &lsquo;unmarked&rsquo;</h2><span id='topic+simulate-methods'></span><span id='topic+simulate+2CunmarkedFitColExt-method'></span><span id='topic+simulate+2CunmarkedFitDS-method'></span><span id='topic+simulate+2CunmarkedFitMPois-method'></span><span id='topic+simulate+2CunmarkedFitOccu-method'></span><span id='topic+simulate+2CunmarkedFitOccuRN-method'></span><span id='topic+simulate+2CunmarkedFitOccuFP-method'></span><span id='topic+simulate+2CunmarkedFitOccuMulti-method'></span><span id='topic+simulate+2CunmarkedFitOccuMS-method'></span><span id='topic+simulate+2CunmarkedFitOccuTTD-method'></span><span id='topic+simulate+2CunmarkedFitNmixTTD-method'></span><span id='topic+simulate+2CunmarkedFitPCount-method'></span><span id='topic+simulate+2CunmarkedFitPCO-method'></span><span id='topic+simulate+2CunmarkedFitGMM-method'></span><span id='topic+simulate+2CunmarkedFitGDS-method'></span><span id='topic+simulate+2CunmarkedFitGPC-method'></span><span id='topic+simulate+2CunmarkedFitGDR-method'></span><span id='topic+simulate+2CunmarkedFitDailMadsen-method'></span><span id='topic+simulate+2CunmarkedFitGOccu-method'></span><span id='topic+simulate+2CunmarkedFitOccuCOP-method'></span><span id='topic+simulate+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Simulate data from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedFitColExt'
simulate(object, nsim, seed, na.rm)
## S4 method for signature 'unmarkedFitDS'
simulate(object, nsim, seed, na.rm)
## S4 method for signature 'unmarkedFitMPois'
simulate(object, nsim, seed, na.rm)
## S4 method for signature 'unmarkedFitOccu'
simulate(object, nsim, seed, na.rm)
## S4 method for signature 'unmarkedFitOccuRN'
simulate(object, nsim, seed, na.rm)
## S4 method for signature 'unmarkedFitPCount'
simulate(object, nsim, seed, na.rm)
## S4 method for signature 'character'
simulate(object, nsim=1, seed=NULL, formulas, coefs=NULL,
  design, guide=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate-methods_+3A_object">object</code></td>
<td>
<p>Fitted model of appropriate S4 class</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator. Not currently implemented</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, should missing values be removed?</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_formulas">formulas</code></td>
<td>

<p>A named list of formulas, one per submodel (e.g. a formula for occupancy
<code>"state"</code> and a formula for detection <code>"det"</code>). To get the correct
submodel names for a given model, fit an example for that model, and then
call <code>names(fitted_model)</code>
</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_coefs">coefs</code></td>
<td>

<p>A named list of vectors of coefficients associated with the regression
intercepts and slopes for each submodel. List should be named as with
<code>formulas</code> above. Each element of the list should be a named vector,
where the names correspond to the names of the parameters in the model
(intercept and covariates). If you are not sure how to structure this list,
just run <code>simulate</code> with <code>coefs=NULL</code>; this will generate
a template list you can copy and fill in.
</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_design">design</code></td>
<td>

<p>A named list of components of the study design. Must include at least <code>M</code>,
the number of sites, and <code>J</code> the number of observations per site. If you
are fitting a model with multiple primary periods you must also provide
<code>T</code>, the number of primary periods.
</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_guide">guide</code></td>
<td>

<p>An optional list defining the format (continuous or categorical/factor) and distribution,
if continuous, of covariates you want to simulate. By default all covariates
are simulated from a standard normal. See example below for an example of
how to specify entries in the <code>guide</code> list.
</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_...">...</code></td>
<td>

<p>Additional arguments that are needed to fully specify the simulated dataset
for a particular model. For example, <code>mixture</code> for <code>pcount</code> models
or <code>keyfun</code> for <code>distsamp</code> models.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>object = &quot;unmarkedFitColExt&quot;</dt><dd><p>A model fit by <code><a href="#topic+colext">colext</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitDS&quot;</dt><dd><p>A model fit by <code><a href="#topic+distsamp">distsamp</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitMPois&quot;</dt><dd><p>A model fit by <code><a href="#topic+multinomPois">multinomPois</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitOccu&quot;</dt><dd><p>A model fit by <code><a href="#topic+occu">occu</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitOccuRN&quot;</dt><dd><p>A model fit by <code><a href="#topic+occuRN">occuRN</a></code></p>
</dd>
<dt>object = &quot;unmarkedFitPCount&quot;</dt><dd><p>A model fit by <code><a href="#topic+pcount">pcount</a></code></p>
</dd>
<dt>object = &quot;character&quot;</dt><dd><p>An <code>unmarkedFrame</code> of the appropriate type</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulation of an occupancy dataset from scratch

# Formulas for each submodel
# occupancy is a function of elevation, detection is intercept-only
forms &lt;- list(state=~elev, det=~1)

# Specify list of coefficients - there must be a value for each
# covariate plus an intercept for each submodel
coefs &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))

# Study design
design &lt;- list(M=300, J=8) # 300 sites, 8 occasions per site

# If we don't specify coefs, unmarked will generate a template you can copy and use
simulate("occu", formulas=forms, design=design)

# Generate unmarkedFrameOccu
occu_umf &lt;- simulate("occu", formulas=forms, coefs=coefs, design=design)
head(occu_umf) # note one covariate, elev

# What if we wanted to add a categorical/factor covariate or
# customize the distribution of elev?
# Use the guide argument

# Updated formulas with new covariate
forms2 &lt;- list(state=~elev+landcover, det=~1)

# Guide
# landcover is factor, you must provide the levels
guide &lt;- list(landcover=factor(levels=c("forest","grass")),  
              elev=list(dist=rnorm, mean=2, sd=0.5)) # custom distribution

# Updated coefficients list
coefs2 &lt;- list(state=c(intercept=0, elev=-0.4, landcovergrass=0.2), det=c(intercept=0))

# Simulate new dataset
head(simulate("occu", formulas=forms2, coefs=coefs2, design=design, guide=guide))
# Note new categorical covariate

# For some models you may want to specify other arguments, such as 'mixture'
# for pcount or 'keyfun' for distsamp
# See the documentation for the associated fitting function and unmarkedFrame
# for what arguments are possible to include for a given model
head(simulate("pcount", formulas=forms, coefs=coefs, design=design, mixture="NB"))

## End(Not run)
</code></pre>

<hr>
<h2 id='SSE'>Compute Sum of Squared Residuals for a Model Fit.</h2><span id='topic+SSE'></span><span id='topic+SSE-methods'></span><span id='topic+SSE+2CunmarkedFit-method'></span><span id='topic+SSE+2CunmarkedFitOccuMulti-method'></span><span id='topic+SSE+2CunmarkedFitGDR-method'></span>

<h3>Description</h3>

<p>Compute the sum of squared residuals for an unmarked fit object.  This
is useful for a <code><a href="#topic+parboot">parboot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSE(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSE_+3A_fit">fit</code></td>
<td>
<p>An unmarked fit object.</p>
</td></tr>
<tr><td><code id="SSE_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value for the models SSE.</p>


<h3>See Also</h3>

<p><code><a href="#topic+parboot">parboot</a></code>
</p>

<hr>
<h2 id='Switzerland'>
Swiss landscape data
</h2><span id='topic+Switzerland'></span>

<h3>Description</h3>

<p>Spatially-referenced data on elevation, forest cover, and water at a
1km-sq resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Switzerland)</code></pre>


<h3>Format</h3>

<p>A data frame with 42275 observations on the following 5 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>Easting (m)</p>
</dd>
<dt><code>y</code></dt><dd><p>Northing (m)</p>
</dd>
<dt><code>elevation</code></dt><dd><p>a numeric vector (m)</p>
</dd>
<dt><code>forest</code></dt><dd><p>a numeric vector (percent cover)</p>
</dd>
<dt><code>water</code></dt><dd><p>a numeric vector (percent cover)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Forest and water coverage (in percent area) was computed using the
1992-97 landcover dataset of the Swiss Federal Statistical Office
(http://www.bfs.admin.ch). Median elevation (in metres) was computed
using a median aggregation of the digital elevation model of the Swiss
Federal Statistical Office.
</p>
<p>x and y are the coordinates of the center of each 1km2 pixel.
</p>
<p>The coordinate reference system intentionally not specified. 
</p>
<p>These data can only be used for non-profit projects. Otherwise, written
permission must be obtained from the Swiss Federal Statistical Office
</p>


<h3>Source</h3>

<p>Swiss Federal Statistical Office (http://www.bfs.admin.ch)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lattice)
data(Switzerland)
str(Switzerland)

levelplot(elevation ~ x + y, Switzerland, aspect="iso",
    col.regions=terrain.colors(100))

## Not run: 
library(raster)
el.r &lt;- rasterFromXYZ(Switzerland[,c("x","y","elevation")], crs =
"+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333
+k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel
+towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs")
plot(el.r)
spplot(el.r)

## End(Not run)

</code></pre>

<hr>
<h2 id='unmarkedEstimate-class'>Class &quot;unmarkedEstimate&quot;</h2><span id='topic+unmarkedEstimate'></span><span id='topic+unmarkedEstimate-class'></span><span id='topic+show+2CunmarkedEstimate-method'></span><span id='topic+summary+2CunmarkedEstimate-method'></span>

<h3>Description</h3>

<p>Contains parameter estimates, covariance matrix, and metadata</p>


<h3>Objects from the Class</h3>

<p>Creating these objects is done internally not by users. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code> storing parameter 
names</p>
</dd>
<dt><code>short.name</code>:</dt><dd><p>Object of class <code>"character"</code> storing 
abbreviated parameter names</p>
</dd>
<dt><code>estimates</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>covMat</code>:</dt><dd><p>Object of class <code>"matrix"</code></p>
</dd>
<dt><code>covMatBS</code>:</dt><dd><p>Object of class <code>"matrix"</code></p>
</dd>
<dt><code>fixed</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>invlink</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>invlinkGrad</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>randomVarInfo</code>:</dt><dd><p>Object of class <code>"list"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>backTransform</dt><dd><p><code>signature(obj = "unmarkedEstimate")</code></p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "unmarkedEstimate")</code></p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "unmarkedEstimate")</code></p>
</dd>
<dt>linearComb</dt><dd><p><code>signature(obj = "unmarkedEstimate", 
		coefficients = "matrixOrVector")</code></p>
</dd>
<dt>SE</dt><dd><p><code>signature(obj = "unmarkedEstimate")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "unmarkedEstimate")</code></p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "unmarkedEstimate")</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>These methods are typically called within a call to a method for 
<code><a href="#topic+unmarkedFit-class">unmarkedFit-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("unmarkedEstimate")
</code></pre>

<hr>
<h2 id='unmarkedEstimateList-class'>Class &quot;unmarkedEstimateList&quot;</h2><span id='topic+unmarkedEstimateList-class'></span><span id='topic+names+2CunmarkedEstimateList-method'></span><span id='topic+show+2CunmarkedEstimateList-method'></span><span id='topic+summary+2CunmarkedEstimateList-method'></span>

<h3>Description</h3>

<p>Class to hold multiple unmarkedEstimates in an
<code><a href="#topic+unmarkedFit">unmarkedFit</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>estimates</code>:</dt><dd><p>A <code>"list"</code> of models.</p>
</dd>
</dl>


<hr>
<h2 id='unmarkedFit-class'>Class &quot;unmarkedFit&quot; </h2><span id='topic+unmarkedFit'></span><span id='topic+unmarkedFit-class'></span><span id='topic+getData'></span><span id='topic+getData+2CunmarkedFit-method'></span><span id='topic+hessian'></span><span id='topic+hessian+2CunmarkedFit-method'></span><span id='topic+hist+2CunmarkedFitDS-method'></span><span id='topic+mle'></span><span id='topic+mle+2CunmarkedFit-method'></span><span id='topic+names+2CunmarkedFit-method'></span><span id='topic+nllFun'></span><span id='topic+nllFun+2CunmarkedFit-method'></span><span id='topic+parboot+2CunmarkedFit-method'></span><span id='topic+parboot+2CunmarkedFitOccuMulti-method'></span><span id='topic+plot+2CunmarkedFit+2Cmissing-method'></span><span id='topic+plot+2CunmarkedFitOccuMulti+2Cmissing-method'></span><span id='topic+plot+2CunmarkedFitGDR+2Cmissing-method'></span><span id='topic+plot+2CunmarkedFitOccuCOP+2Cmissing-method'></span><span id='topic+profile+2CunmarkedFit-method'></span><span id='topic+residuals+2CunmarkedFit-method'></span><span id='topic+residuals+2CunmarkedFitOccu-method'></span><span id='topic+residuals+2CunmarkedFitOccuFP-method'></span><span id='topic+residuals+2CunmarkedFitOccuRN-method'></span><span id='topic+residuals+2CunmarkedFitOccuMulti-method'></span><span id='topic+residuals+2CunmarkedFitOccuTTD-method'></span><span id='topic+residuals+2CunmarkedFitGDR-method'></span><span id='topic+residuals+2CunmarkedFitOccuCOP-method'></span><span id='topic+update+2CunmarkedFit-method'></span><span id='topic+update+2CunmarkedFitColExt-method'></span><span id='topic+update+2CunmarkedFitGMM-method'></span><span id='topic+update+2CunmarkedFitOccuMulti-method'></span><span id='topic+update+2CunmarkedFitOccuMS-method'></span><span id='topic+update+2CunmarkedFitOccuTTD-method'></span><span id='topic+update+2CunmarkedFitNmixTTD-method'></span><span id='topic+update+2CunmarkedFitGDR-method'></span><span id='topic+update+2CunmarkedFitDailMadsen-method'></span><span id='topic+update+2CunmarkedFitGOccu-method'></span><span id='topic+sampleSize'></span><span id='topic+sampleSize+2CunmarkedFit-method'></span><span id='topic+unmarkedFitOccu-class'></span><span id='topic+unmarkedFitOccuPEN-class'></span><span id='topic+unmarkedFitOccuPEN_CV-class'></span><span id='topic+unmarkedFitOccuFP-class'></span><span id='topic+unmarkedFitPCount-class'></span><span id='topic+unmarkedFitDS-class'></span><span id='topic+unmarkedFitMPois-class'></span><span id='topic+unmarkedFitPCO-class'></span><span id='topic+unmarkedFitGMM-class'></span><span id='topic+unmarkedFitOccuMulti-class'></span><span id='topic+unmarkedFitOccuMS-class'></span><span id='topic+unmarkedFitOccuTTD-class'></span><span id='topic+unmarkedFitNmixTTD-class'></span><span id='topic+unmarkedFitDSO-class'></span><span id='topic+unmarkedFitMMO-class'></span><span id='topic+plot+2Cprofile+2Cmissing-method'></span><span id='topic+show+2CunmarkedFit-method'></span><span id='topic+summary+2CunmarkedFit-method'></span><span id='topic+summary+2CunmarkedFitDS-method'></span><span id='topic+smoothed'></span><span id='topic+smoothed+2CunmarkedFitColExt-method'></span><span id='topic+projected'></span><span id='topic+projected+2CunmarkedFitColExt-method'></span><span id='topic+logLik'></span><span id='topic+logLik+2CunmarkedFit-method'></span><span id='topic+LRT'></span><span id='topic+LRT+2CunmarkedFit+2CunmarkedFit-method'></span><span id='topic+getY+2CunmarkedFit-method'></span><span id='topic+getY+2CunmarkedFitOccu-method'></span><span id='topic+getY+2CunmarkedFitColExt-method'></span><span id='topic+getY+2CunmarkedFitOccuRN-method'></span><span id='topic+getY+2CunmarkedFitOccuMulti-method'></span>

<h3>Description</h3>

<p>Contains fitted model information which can be manipulated or
extracted using the methods described below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fitType</code>:</dt><dd><p>Object of class <code>"character"</code> </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code> </p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"formula"</code> </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"unmarkedFrame"</code> </p>
</dd>
<dt><code>sitesRemoved</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>estimates</code>:</dt><dd><p>Object of class <code>"unmarkedEstimateList"</code> </p>
</dd>
<dt><code>AIC</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>opt</code>:</dt><dd><p>Object of class <code>"list"</code> containing results from
<code><a href="stats.html#topic+optim">optim</a></code> </p>
</dd>
<dt><code>negLogLike</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>nllFun</code>:</dt><dd><p>Object of class <code>"function"</code> </p>
</dd>
<dt><code>knownOcc</code>:</dt><dd><p>unmarkedFitOccu only: sites known to be occupied</p>
</dd>
<dt><code>K</code>:</dt><dd><p>unmarkedFitPCount only: upper bound used in integration</p>
</dd>
<dt><code>mixture</code>:</dt><dd><p>unmarkedFitPCount only: Mixing distribution</p>
</dd>
<dt><code>keyfun</code>:</dt><dd><p>unmarkedFitDS only: detection function used by
<a href="#topic+distsamp">distsamp</a></p>
</dd>
<dt><code>unitsOut</code>:</dt><dd><p>unmarkedFitDS only: density units</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "unmarkedFit", i = "ANY", j = "ANY",
		drop = "ANY")</code>: extract one of names(obj), eg 'state' or 'det' </p>
</dd>
<dt>backTransform</dt><dd><p><code>signature(obj = "unmarkedFit")</code>: back-transform
parameters to original scale when no covariate effects are modeled </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "unmarkedFit")</code>: returns parameter
estimates. type can be one of names(obj), eg 'state' or 'det'.
If altNames=TRUE estimate names are more specific. </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "unmarkedFit")</code>: Returns confidence
intervals. Must specify type and method (either &quot;normal&quot; or &quot;profile&quot;) </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "unmarkedFit")</code>: returns expected
values of Y </p>
</dd>
<dt>getData</dt><dd><p><code>signature(object = "unmarkedFit")</code>: extracts data </p>
</dd>
<dt>getP</dt><dd><p><code>signature(object = "unmarkedFit")</code>: calculates and extracts
expected detection probabilities </p>
</dd>
<dt>getFP</dt><dd><p><code>signature(object = "unmarkedFit")</code>: calculates and extracts
expected false positive detection probabilities </p>
</dd>
<dt>getB</dt><dd><p><code>signature(object = "unmarkedFit")</code>: calculates and extracts
expected probabilities a true positive detection was classified as certain </p>
</dd>
<dt>hessian</dt><dd><p><code>signature(object = "unmarkedFit")</code>: Returns hessian
matrix </p>
</dd>
<dt>linearComb</dt><dd><p><code>signature(obj = "unmarkedFit",
		coefficients = "matrixOrVector")</code>: Returns estimate and SE on original
scale when covariates are present </p>
</dd>
<dt>mle</dt><dd><p><code>signature(object = "unmarkedFit")</code>: Same as coef(fit)? </p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "unmarkedFit")</code>: Names of parameter levels </p>
</dd>
<dt>nllFun</dt><dd><p><code>signature(object = "unmarkedFit")</code>: returns negative
log-likelihood used to estimate parameters </p>
</dd>
<dt>parboot</dt><dd><p><code>signature(object = "unmarkedFit")</code>: Parametric
bootstrapping method to assess goodness-of-fit </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "unmarkedFit", y = "missing")</code>: Plots
expected vs. observed values </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "unmarkedFit")</code>: Returns predictions
and standard errors for original data or for covariates in a new
data.frame </p>
</dd>
<dt>profile</dt><dd><p><code>signature(fitted = "unmarkedFit")</code>: used by confint
method='profile' </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "unmarkedFit")</code>: returns residuals </p>
</dd>
<dt>sampleSize</dt><dd><p><code>signature(object = "unmarkedFit")</code>: returns number
of sites in sample </p>
</dd>
<dt>SE</dt><dd><p><code>signature(obj = "unmarkedFit")</code>: returns standard errors </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "unmarkedFit")</code>: concise results </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "unmarkedFit")</code>: results with more
details </p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "unmarkedFit")</code>: refit model with
changes to one or more arguments </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "unmarkedFit")</code>: returns
variance-covariance matrix </p>
</dd>
<dt>smoothed</dt><dd><p><code>signature(object="unmarkedFitColExt")</code>:
Returns the smoothed trajectory from a colonization-extinction
model fit.  Takes additional logical argument mean which specifies
whether or not to return the average over sites.</p>
</dd>
<dt>projected</dt><dd><p><code>signature(object="unmarkedFitColExt")</code>:
Returns the projected trajectory from a colonization-extinction
model fit.  Takes additional logical argument mean which specifies
whether or not to return the average over sites.</p>
</dd>
<dt>logLik</dt><dd><p><code>signature(object="unmarkedFit")</code>:
Returns the log-likelihood.</p>
</dd>
<dt>LRT</dt><dd><p><code>signature(m1="unmarkedFit", m2="unmarkedFit")</code>:
Returns the chi-squared statistic, degrees-of-freedom, and p-value from
a Likelihood Ratio Test.</p>
</dd>
</dl>



<h3>Note</h3>

<p> This is a superclass with child classes for each fit type </p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("unmarkedFit")

# Format removal data for multinomPois
data(ovendata)
ovenFrame &lt;- unmarkedFrameMPois(y = ovendata.list$data,
	siteCovs = as.data.frame(scale(ovendata.list$covariates[,-1])),
	type = "removal")

# Fit a couple of models
(fm1 &lt;- multinomPois(~ 1 ~ ufc + trba, ovenFrame))
summary(fm1)

# Apply a bunch of methods to the fitted model

# Look at the different parameter types
names(fm1)
fm1['state']
fm1['det']

# Coefficients from abundance part of the model
coef(fm1, type='state')

# Variance-covariance matrix
vcov(fm1, type='state')

# Confidence intervals using profiled likelihood
confint(fm1, type='state', method='profile')

# Expected values
fitted(fm1)

# Original data
getData(fm1)

# Detection probabilities
getP(fm1)

# log-likelihood
logLik(fm1)

# Back-transform detection probability to original scale
# backTransform only works on models with no covariates or
#     in conjunction with linearComb (next example)
backTransform(fm1, type ='det')

# Predicted abundance at specified covariate values
(lc &lt;- linearComb(fm1, c(Int = 1, ufc = 0, trba = 0), type='state'))
backTransform(lc)

# Assess goodness-of-fit
parboot(fm1)
plot(fm1)

# Predict abundance at specified covariate values.
newdat &lt;- data.frame(ufc = 0, trba = seq(-1, 1, length=10))
predict(fm1, type='state', newdata=newdat)

# Number of sites in the sample
sampleSize(fm1)

# Fit a new model without covariates
(fmNull &lt;- update(fm1, formula = ~1 ~1))

# Likelihood ratio test
LRT(fm1, fmNull)


</code></pre>

<hr>
<h2 id='unmarkedFitList-class'>Class &quot;unmarkedFitList&quot;</h2><span id='topic+unmarkedFitList-class'></span><span id='topic+modSel+2CunmarkedFitList-method'></span><span id='topic+summary+2CunmarkedFitList-method'></span><span id='topic+coef+2CunmarkedFitList-method'></span><span id='topic+SE+2CunmarkedFitList-method'></span>

<h3>Description</h3>

<p>Class to hold multiple fitted models from one of
<code>unmarked</code>'s fitting functions</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the <code><a href="#topic+fitList">fitList</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fits</code>:</dt><dd><p>A <code>"list"</code> of models.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "unmarkedFitList")</code>:
Extract coefficients</p>
</dd>
<dt>SE</dt><dd><p><code>signature(object = "unmarkedFitList")</code>:
Extract standard errors</p>
</dd>
<dt>modSel</dt><dd><p><code>signature(object = "unmarkedFitList")</code>:
Model selection</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "unmarkedFitList")</code>:
Model-averaged prediction</p>
</dd>
</dl>



<h3>Note</h3>

<p>Model-averaging regression coefficients is intentionally not implemented.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitList">fitList</a></code>,
<code><a href="#topic+unmarkedFit-class">unmarkedFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("unmarkedFitList")

data(linetran)
(dbreaksLine &lt;- c(0, 5, 10, 15, 20))
lengths &lt;- linetran$Length * 1000

ltUMF &lt;- with(linetran, {
	unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
	siteCovs = data.frame(Length, area, habitat), dist.breaks = dbreaksLine,
	tlength = lengths, survey = "line", unitsIn = "m")
	})

fm1 &lt;- distsamp(~ 1 ~1, ltUMF)
fm2 &lt;- distsamp(~ area ~1, ltUMF)
fm3 &lt;- distsamp( ~ 1 ~area, ltUMF)

fl &lt;- fitList(Null=fm1, A.=fm2, .A=fm3)
fl

coef(fl)
SE(fl)

ms &lt;- modSel(fl, nullmod="Null")
ms


</code></pre>

<hr>
<h2 id='unmarkedFrame'>Create an unmarkedFrame, or one of its child classes.</h2><span id='topic+unmarkedFrame'></span>

<h3>Description</h3>

<p>Constructor for unmarkedFrames.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrame(y, siteCovs=NULL, obsCovs=NULL, mapInfo, obsToY)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrame_+3A_y">y</code></td>
<td>
<p>An MxJ matrix of the observed measured data, where M is the
number of sites and J is the maximum number of observations per site.</p>
</td></tr>
<tr><td><code id="unmarkedFrame_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrame_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code>
with MxJ rows in site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFrame_+3A_obstoy">obsToY</code></td>
<td>
<p>optional matrix specifying relationship between
observation-level covariates and response matrix</p>
</td></tr>
<tr><td><code id="unmarkedFrame_+3A_mapinfo">mapInfo</code></td>
<td>
<p>geographic coordinate information. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrame is the S4 class that holds data structures to be passed
to the model-fitting functions in unmarked.
</p>
<p>An unmarkedFrame contains the observations (<code>y</code>), covariates
measured at the observation level (<code>obsCovs</code>), and covariates
measured at the site level (<code>siteCovs</code>).
For a data set with M sites and J observations at each site, y is an
M x J matrix. <code>obsCovs</code> and <code>siteCovs</code> are both data frames
(see <a href="base.html#topic+data.frame">data.frame</a>).  <code>siteCovs</code> has M rows so that each row
contains the covariates for the corresponding sites.
<code>obsCovs</code> has M*obsNum rows so that each covariates is ordered by
site first, then observation number.  Missing values are coded with
<code>NA</code> in any of y, siteCovs, or obsCovs.
</p>
<p>Additionally, unmarkedFrames contain metadata: obsToY, mapInfo.
obsToY is a matrix describing relationship between response matrix and
observation-level covariates. Generally this does not need to be
supplied by the user; however, it may be needed when using
<code><a href="#topic+multinomPois">multinomPois</a></code>. For example, double observer sampling, y
has 3 columns corresponding the observer 1, observer 2, and both, but
there were only two independent observations.
In this situation, y has 3 columns, but obsToY must be specified.
</p>
<p>Several child classes of <code>unmarkedFrame</code> require addional
metadata. For example, <code>unmarkedFrameDS</code> is used to organize
distsance sampling data for the <code><a href="#topic+distsamp">distsamp</a></code> function, and
it has arguments dist.breaks, tlength, survey, and unitsIn, which
specify the distance interval cut points, transect lengths, &quot;line&quot; or
&quot;point&quot; transect, and units of measure, respectively.
</p>
<p>All site-level covariates are automatically copied to obsCovs so that
site level covariates are available at the observation level.
</p>


<h3>Value</h3>

<p>an unmarkedFrame object</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>,
<code><a href="#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>, <code><a href="#topic+unmarkedFramePCount">unmarkedFramePCount</a></code>,
<code><a href="#topic+unmarkedFrameDS">unmarkedFrameDS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set up data for pcount()
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
	obsCovs = mallard.obs)
summary(mallardUMF)


# Set up data for occu()
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)


# Set up data for distsamp()
data(linetran)
ltUMF &lt;- with(linetran, {
	unmarkedFrameDS(y = cbind(dc1, dc2, dc3, dc4),
	siteCovs = data.frame(Length, area, habitat),
	dist.breaks = c(0, 5, 10, 15, 20),
	tlength = linetran$Length * 1000, survey = "line", unitsIn = "m")
	})
summary(ltUMF)


# Set up data for multinomPois()
data(ovendata)
ovenFrame &lt;- unmarkedFrameMPois(ovendata.list$data,
	siteCovs=as.data.frame(scale(ovendata.list$covariates[,-1])),
	type = "removal")
summary(ovenFrame)


## Not run: 
# Set up data for colext()
frogUMF &lt;- formatMult(masspcru)
summary(frogUMF)

## End(Not run)

</code></pre>

<hr>
<h2 id='unmarkedFrame-class'>Class &quot;unmarkedFrame&quot; </h2><span id='topic+unmarkedFrame-class'></span><span id='topic+coordinates+2CunmarkedFrame-method'></span><span id='topic+coordinates'></span><span id='topic+coords'></span><span id='topic+getY'></span><span id='topic+getY+2CunmarkedFrame-method'></span><span id='topic+head+2CunmarkedFrame-method'></span><span id='topic+hist+2CunmarkedFrameDS-method'></span><span id='topic+mapInfo'></span><span id='topic+numSites'></span><span id='topic+numSites+2CunmarkedFrame-method'></span><span id='topic+numY'></span><span id='topic+numY+2CunmarkedFrame-method'></span><span id='topic+obsCovs+2CunmarkedFrame-method'></span><span id='topic+obsCovs+3C-+2CunmarkedFrame-method'></span><span id='topic+obsCovs'></span><span id='topic+obsCovs+3C-'></span><span id='topic+obsNum+2CunmarkedFrame-method'></span><span id='topic+obsNum'></span><span id='topic+obsToY+2CunmarkedFrame-method'></span><span id='topic+obsToY+3C-+2CunmarkedFrame-method'></span><span id='topic+obsToY'></span><span id='topic+obsToY+3C-'></span><span id='topic+plot+2CunmarkedFrame+2Cmissing-method'></span><span id='topic+plot+2CunmarkedFrameOccuMulti+2Cmissing-method'></span><span id='topic+plot+2CunmarkedFrameOccuTTD+2Cmissing-method'></span><span id='topic+projection+2CunmarkedFrame-method'></span><span id='topic+projection'></span><span id='topic+siteCovs+2CunmarkedFrame-method'></span><span id='topic+siteCovs+3C-+2CunmarkedFrame-method'></span><span id='topic+siteCovs'></span><span id='topic+siteCovs+3C-'></span><span id='topic+unmarkedFrameOccu-class'></span><span id='topic+unmarkedFrameOccuMulti-class'></span><span id='topic+unmarkedFrameOccuMS-class'></span><span id='topic+unmarkedFrameOccuTTD-class'></span><span id='topic+unmarkedFrameMPois-class'></span><span id='topic+unmarkedFramePCount-class'></span><span id='topic+unmarkedFrameDS-class'></span><span id='topic+unmarkedMultFrame-class'></span><span id='topic+unmarkedFramePCO-class'></span><span id='topic+unmarkedFrameGMM-class'></span><span id='topic+unmarkedFrameGDS-class'></span><span id='topic+unmarkedFrameGPC-class'></span><span id='topic+unmarkedFrameDSO-class'></span><span id='topic+unmarkedFrameMMO-class'></span><span id='topic+show+2CunmarkedFrame-method'></span><span id='topic+show+2CunmarkedFrameOccuMulti-method'></span><span id='topic+show+2CunmarkedFrameOccuTTD-method'></span><span id='topic+show+2CunmarkedMultFrame-method'></span><span id='topic+show+2CunmarkedFrameOccuCOP-method'></span><span id='topic+summary+2CunmarkedFrame-method'></span><span id='topic+summary+2CunmarkedFrameDS-method'></span><span id='topic+summary+2CunmarkedMultFrame-method'></span><span id='topic+summary+2CunmarkedFrameOccuMulti-method'></span><span id='topic+summary+2CunmarkedFrameOccuTTD-method'></span><span id='topic+summary+2CunmarkedFrameOccuCOP-method'></span><span id='topic++5B+2CunmarkedFrameOccuMulti+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuTTD+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGDR+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuMS+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuTTD+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuMulti+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameDSO+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGDR+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameGDR+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuCOP+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuCOP+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunmarkedFrameOccuCOP+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for manipulating, summarizing and viewing
unmarkedFrames</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the constructor function
<code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>. These objects are passed to the data
argument of the fitting functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"matrix"</code></p>
</dd>
<dt><code>obsCovs</code>:</dt><dd><p>Object of class <code>"optionalDataFrame"</code></p>
</dd>
<dt><code>siteCovs</code>:</dt><dd><p>Object of class <code>"optionalDataFrame"</code></p>
</dd>
<dt><code>mapInfo</code>:</dt><dd><p>Object of class <code>"optionalMapInfo"</code></p>
</dd>
<dt><code>obsToY</code>:</dt><dd><p>Object of class <code>"optionalMatrix"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "unmarkedFrame", i = "numeric", j =
	"missing", drop = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "unmarkedFrame", i = "numeric", j =
	"numeric", drop = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "unmarkedFrame", i = "missing", j =
	"numeric", drop = "missing")</code>: ... </p>
</dd>
<dt>coordinates</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract
coordinates </p>
</dd>
<dt>getY</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract y
matrix </p>
</dd>
<dt>numSites</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract M </p>
</dd>
<dt>numY</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract
ncol(y) </p>
</dd>
<dt>obsCovs</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract
observation-level covariates </p>
</dd>
<dt>obsCovs&lt;-</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: add or
modify observation-level covariates </p>
</dd>
<dt>obsNum</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract
number of observations </p>
</dd>
<dt>obsToY</dt><dd><p><code>signature(object = "unmarkedFrame")</code>:  </p>
</dd>
<dt>obsToY&lt;-</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "unmarkedFrame", y = "missing")</code>:
visualize response variable.
Takes additional argument <code>panels</code> which specifies how many
panels data should be split over.</p>
</dd>
<dt>projection</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract
projection information </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: view data as
data.frame </p>
</dd>
<dt>siteCovs</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: extract
site-level covariates </p>
</dd>
<dt>siteCovs&lt;-</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: add or
modify site-level covariates </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "unmarkedFrame")</code>: summarize
data </p>
</dd>
<dt>getL</dt><dd><p><code>signature(object = "unmarkedFrameOccuCOP")</code>: extract L </p>
</dd>
</dl>



<h3>Note</h3>

<p> This is a superclass with child classes for each fitting function.</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, <code><a href="#topic+unmarkedFit-class">unmarkedFit</a></code>,
<code><a href="#topic+unmarked-package">unmarked-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# List all the child classes of unmarkedFrame
showClass("unmarkedFrame")

# Organize data for pcount()
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs = mallard.site,
	obsCovs = mallard.obs)


# Vizualize it
plot(mallardUMF)

mallardUMF


# Summarize it
summary(mallardUMF)

str(mallardUMF)

numSites(mallardUMF)

numY(mallardUMF)

obsNum(mallardUMF)


# Extract components of data
getY(mallardUMF)

obsCovs(mallardUMF)
obsCovs(mallardUMF, matrices = TRUE)

siteCovs(mallardUMF)

mallardUMF[1:5,]	# First 5 rows in wide format

mallardUMF[,1:2]	# First 2 observations



</code></pre>

<hr>
<h2 id='unmarkedFrameDS'>Organize data for the distance sampling model of Royle et al. (2004)
fit by distsamp</h2><span id='topic+unmarkedFrameDS'></span>

<h3>Description</h3>

<p>Organizes count data along with the covariates and metadata.
This S4 class is required by the data argument of <code><a href="#topic+distsamp">distsamp</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameDS(y, siteCovs=NULL, dist.breaks, tlength, survey,
    unitsIn, mapInfo)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameDS_+3A_y">y</code></td>
<td>
<p>An RxJ matrix of count data, where R is the
number of sites (transects) and J is the number of distance
classes.</p>
</td></tr>
<tr><td><code id="unmarkedFrameDS_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have R rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameDS_+3A_dist.breaks">dist.breaks</code></td>
<td>
<p>vector of distance cut-points delimiting the
distance classes. It must be of length J+1.</p>
</td></tr>
<tr><td><code id="unmarkedFrameDS_+3A_tlength">tlength</code></td>
<td>
<p>A vector of length R containing the trasect lengths. This is
ignored when survey=&quot;point&quot;.</p>
</td></tr>
<tr><td><code id="unmarkedFrameDS_+3A_survey">survey</code></td>
<td>
<p>Either &quot;point&quot; or &quot;line&quot; for point- and line-transects.</p>
</td></tr>
<tr><td><code id="unmarkedFrameDS_+3A_unitsin">unitsIn</code></td>
<td>
<p>Either &quot;m&quot; or &quot;km&quot; defining the measurement units for
<em>both</em> <code>dist.breaks</code> and <code>tlength</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="unmarkedFrameDS_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr></table>


<h3>Details</h3>

<p>unmarkedFrameDS is the S4 class that holds data to be passed
to the <code><a href="#topic+distsamp">distsamp</a></code> model-fitting function.</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameDS</p>


<h3>Note</h3>

<p>If you have continuous distance data, they must be &quot;binned&quot; into
discrete distance classes, which are delimited by dist.breaks.</p>


<h3>References</h3>

<p>Royle, J. A., D. K. Dawson, and S. Bates (2004) Modeling
abundance effects in distance sampling. <em>Ecology</em> 85, pp. 1591-1597.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>,
<code><a href="#topic+distsamp">distsamp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
R &lt;- 4 # number of sites
J &lt;- 3 # number of distance classes

db &lt;- c(0, 10, 20, 30) # distance break points

y &lt;- matrix(c(
   5,4,3, # 5 detections in 0-10 distance class at this transect
   0,0,0,
   2,1,1,
   1,1,0), nrow=R, ncol=J, byrow=TRUE)
y

site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

umf &lt;- unmarkedFrameDS(y=y, siteCovs=site.covs, dist.breaks=db, survey="point",
    unitsIn="m")            # organize data
umf                         # look at data
summary(umf)                # summarize
fm &lt;- distsamp(~1 ~1, umf)  # fit a model


</code></pre>

<hr>
<h2 id='unmarkedFrameDSO'>Create an object of class unmarkedFrameDSO that contains data used by distsampOpen.</h2><span id='topic+unmarkedFrameDSO'></span>

<h3>Description</h3>

<p>Organizes distance sampling data and experimental design information 
from multiple primary periods along with associated covariates. This S4 class 
is required by the data argument of <code><a href="#topic+distsampOpen">distsampOpen</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameDSO(y, siteCovs=NULL, yearlySiteCovs=NULL, numPrimary, 
       primaryPeriod, dist.breaks, tlength, survey, unitsIn)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameDSO_+3A_y">y</code></td>
<td>
<p>An MxJT matrix of the repeated count data, where M is the number
of sites (i.e., points or transects), J is the number of distance classes
and T is the maximum number of primary sampling periods per site</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>Either a named list of MxT <code><a href="base.html#topic+data.frame">data.frame</a></code>s,
or a site-major <code><a href="base.html#topic+data.frame">data.frame</a></code> with MT rows and 1 column per
covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_numprimary">numPrimary</code></td>
<td>
<p>Maximum number of observed primary periods for each site</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_primaryperiod">primaryPeriod</code></td>
<td>
<p>An MxJT matrix of integers indicating the primary period 
of each observation</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_dist.breaks">dist.breaks</code></td>
<td>
<p>vector of distance cut-points delimiting the
distance classes. It must be of length J+1</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_tlength">tlength</code></td>
<td>
<p>A vector of length R containing the transect lengths. This is
ignored when survey=&quot;point&quot;</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_survey">survey</code></td>
<td>
<p>Either &quot;point&quot; or &quot;line&quot; for point- and line-transects</p>
</td></tr>
<tr><td><code id="unmarkedFrameDSO_+3A_unitsin">unitsIn</code></td>
<td>
<p>Either &quot;m&quot; or &quot;km&quot; defining the measurement units for
<em>both</em> <code>dist.breaks</code> and <code>tlength</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unmarkedFrameDSO</code> is the S4 class that holds data to be passed
to the <code><a href="#topic+distsampOpen">distsampOpen</a></code> model-fitting function. Unlike
most unmarked functions, <code>obsCovs</code> cannot be supplied.
</p>
<p>If you have continuous distance data, they must be &quot;binned&quot; into
discrete distance classes, which are delimited by dist.breaks.
</p>
<p>When gamma or omega are modeled using year-specific covariates, the
covariate data for the final year will be ignored; however,
they must be supplied.
</p>
<p>If the time gap between primary periods is not constant, an M by T
matrix of integers should be supplied using the <code>primaryPeriod</code> argument.
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameDSO</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>,
<code><a href="#topic+distsampOpen">distsampOpen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
M &lt;- 4 # number of sites
J &lt;- 3 # number of distance classes
T &lt;- 2 # number of primary periods

db &lt;- c(0, 10, 20, 30) # distance break points

y &lt;- matrix(c(
   5,4,3, 6,2,1, # In bin 1: 5 detections in primary period 1, 6 in period 2
   0,0,0, 0,1,0,
   2,1,1, 0,0,0,
   1,1,0, 1,1,1), nrow=M, ncol=J*T, byrow=TRUE)
y

# Primary periods of observations
# In this case there are no gaps
primPer &lt;- matrix(as.integer(c(
    1,2,
    1,2,
    1,2,
    1,2)), nrow=M, ncol=T, byrow=TRUE)

#Site covs: M rows and 1 column per covariate
site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

#Yearly site covs on gamma/omega
ysc &lt;- list(
    x3 = matrix(c(
        1,2,
        1,2,
        1,2,
        1,2), nrow=M, ncol=T, byrow=TRUE))

umf &lt;- unmarkedFrameDSO(y=y, siteCovs=site.covs, yearlySiteCovs=ysc,
                        numPrimary=T, primaryPeriod=primPer,
                        dist.breaks=db, survey="point", unitsIn="m")            

umf                         # look at data
summary(umf)                # summarize


</code></pre>

<hr>
<h2 id='unmarkedFrameGDR'>Organize data for the combined distance and removal point-count model of 
Amundson et al. (2014) fit by <code>gdistremoval</code></h2><span id='topic+unmarkedFrameGDR'></span><span id='topic+unmarkedFrameGDR-class'></span>

<h3>Description</h3>

<p>Organize data for the combined distance and removal point-count model of 
Amundson et al. (2014) fit by <code>gdistremoval</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>  unmarkedFrameGDR(yDistance, yRemoval, numPrimary=1, siteCovs=NULL, obsCovs=NULL, 
                   yearlySiteCovs=NULL, dist.breaks, unitsIn, period.lengths=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameGDR_+3A_ydistance">yDistance</code></td>
<td>
<p>An MxTJ matrix of count data, where M is the number of sites
(points), T is the number of primary periods (can be 1) and J is the number of 
distance classes</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_yremoval">yRemoval</code></td>
<td>
<p>An MxTJ matrix of count data, where M is the number of sites
(points), T is the number of primary periods (can be 1) and J is the number of 
time removal periods</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_numprimary">numPrimary</code></td>
<td>
<p>Number of primary periods in the dataset</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_obscovs">obsCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have MxTJ rows and one column per covariate.
These covariates are used only by the removal part of the model</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary
by site and primary period. This should have MxT rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_dist.breaks">dist.breaks</code></td>
<td>
<p>vector of distance cut-points delimiting the
distance classes. It must be of length J+1</p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_unitsin">unitsIn</code></td>
<td>
<p>Either &quot;m&quot; or &quot;km&quot; defining the measurement units for
<code>dist.breaks</code></p>
</td></tr>
<tr><td><code id="unmarkedFrameGDR_+3A_period.lengths">period.lengths</code></td>
<td>
<p>Optional vector of time lengths of each removal period. 
Each value in the vector must be a positive integer, and the total length
of the vector must be equal to the number of removal periods J. If this is 
not provided (the default), then all periods are assumed to have an equal 
length of 1 time unit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrameGDR is the S4 class that holds data to be passed
to the <code><a href="#topic+gdistremoval">gdistremoval</a></code> model-fitting function.</p>


<h3>Value</h3>

<p>an object of class <code>unmarkedFrameGDR</code></p>


<h3>Note</h3>

<p>If you have continuous distance data, they must be &quot;binned&quot; into
discrete distance classes, which are delimited by dist.breaks.</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>References</h3>

<p>Amundson, C.L., Royle, J.A. and Handel, C.M., 2014. A hierarchical model 
combining distance sampling and time removal to estimate detection probability 
during avian point counts. The Auk 131: 476-494.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>,
<code><a href="#topic+gdistremoval">gdistremoval</a></code></p>

<hr>
<h2 id='unmarkedFrameMMO'>Create an object of class unmarkedFrameMMO that contains data used by multmixOpen.</h2><span id='topic+unmarkedFrameMMO'></span>

<h3>Description</h3>

<p>Organizes count data and experimental design information 
from multiple primary periods along with associated covariates. This S4 class 
is required by the data argument of <code><a href="#topic+multmixOpen">multmixOpen</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameMMO(y, siteCovs=NULL, obsCovs=NULL, yearlySiteCovs=NULL, 
       numPrimary, type, primaryPeriod)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameMMO_+3A_y">y</code></td>
<td>
<p>An MxJT matrix of the repeated count data, where M is the number
of sites (i.e., points or transects), J is the number of distance classes
and T is the maximum number of primary sampling periods per site</p>
</td></tr>
<tr><td><code id="unmarkedFrameMMO_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameMMO_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of covariates
that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with MxJT rows in
site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFrameMMO_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>Either a named list of MxT <code><a href="base.html#topic+data.frame">data.frame</a></code>s,
or a site-major <code><a href="base.html#topic+data.frame">data.frame</a></code> with MT rows and 1 column per
covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameMMO_+3A_numprimary">numPrimary</code></td>
<td>
<p>Maximum number of observed primary periods for each site</p>
</td></tr>
<tr><td><code id="unmarkedFrameMMO_+3A_type">type</code></td>
<td>
<p>Either &quot;removal&quot; for removal sampling, &quot;double&quot; for standard 
double observer sampling, or &quot;depDouble&quot; for dependent double observer 
sampling</p>
</td></tr>
<tr><td><code id="unmarkedFrameMMO_+3A_primaryperiod">primaryPeriod</code></td>
<td>
<p>An MxJT matrix of integers indicating the primary period 
of each observation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unmarkedFrameMMO</code> is the S4 class that holds data to be passed
to the <code><a href="#topic+multmixOpen">multmixOpen</a></code> model-fitting function.
</p>
<p>Options for the detection process (<code>type</code>) include equal-interval removal 
sampling (<code>"removal"</code>), double observer sampling (<code>"double"</code>), or 
dependent double-observer sampling (<code>"depDouble"</code>). Note
that unlike the related functions <code><a href="#topic+multinomPois">multinomPois</a></code> and
<code><a href="#topic+gmultmix">gmultmix</a></code>, custom functions for the detection process (i.e., 
<code>piFun</code>s) are not supported. To request additional options contact the author.
</p>
<p>When gamma or omega are modeled using year-specific covariates, the
covariate data for the final year will be ignored; however,
they must be supplied.
</p>
<p>If the time gap between primary periods is not constant, an M by T
matrix of integers should be supplied using the <code>primaryPeriod</code> argument.  
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameMMO</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>,
<code><a href="#topic+multmixOpen">multmixOpen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Generate some data 
  set.seed(123)
  lambda=4; gamma=0.5; omega=0.8; p=0.5
  M &lt;- 100; T &lt;- 5
  y &lt;- array(NA, c(M, 3, T))
  N &lt;- matrix(NA, M, T)
  S &lt;- G &lt;- matrix(NA, M, T-1)

  for(i in 1:M) {
    N[i,1] &lt;- rpois(1, lambda)
    y[i,1,1] &lt;- rbinom(1, N[i,1], p)    # Observe some
    Nleft1 &lt;- N[i,1] - y[i,1,1]         # Remove them
    y[i,2,1] &lt;- rbinom(1, Nleft1, p)   # ...
    Nleft2 &lt;- Nleft1 - y[i,2,1]
    y[i,3,1] &lt;- rbinom(1, Nleft2, p)

    for(t in 1:(T-1)) {
      S[i,t] &lt;- rbinom(1, N[i,t], omega)
      G[i,t] &lt;- rpois(1, gamma)
      N[i,t+1] &lt;- S[i,t] + G[i,t]
      y[i,1,t+1] &lt;- rbinom(1, N[i,t+1], p)    # Observe some
      Nleft1 &lt;- N[i,t+1] - y[i,1,t+1]         # Remove them
      y[i,2,t+1] &lt;- rbinom(1, Nleft1, p)   # ...
      Nleft2 &lt;- Nleft1 - y[i,2,t+1]
      y[i,3,t+1] &lt;- rbinom(1, Nleft2, p)
    }
  }
  y=matrix(y, M)
  
  #Create some random covariate data
  sc &lt;- data.frame(x1=rnorm(100))

  #Create unmarked frame
  umf &lt;- unmarkedFrameMMO(y=y, numPrimary=5, siteCovs=sc, type="removal")
  
  summary(umf)

</code></pre>

<hr>
<h2 id='unmarkedFrameMPois'>Organize data for the multinomial-Poisson mixture model of Royle (2004) 
fit by multinomPois</h2><span id='topic+unmarkedFrameMPois'></span>

<h3>Description</h3>

<p>Organizes count data along with the covariates. 
This S4 class is required by the data argument of 
<code><a href="#topic+multinomPois">multinomPois</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameMPois(y, siteCovs=NULL, obsCovs=NULL, type, obsToY, 
    mapInfo, piFun)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameMPois_+3A_y">y</code></td>
<td>
<p>An RxJ matrix of count data, where R is the 
number of sites (transects) and J is the maximum number of observations
per site.</p>
</td></tr>
<tr><td><code id="unmarkedFrameMPois_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the 
site level. This should have R rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameMPois_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of RxJ <code><a href="base.html#topic+data.frame">data.frame</a></code>s or 
a <code>data.frame</code> with RxJ rows and one column per covariate. 
For the latter format, the covariates should be in site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFrameMPois_+3A_type">type</code></td>
<td>
<p>Either &quot;removal&quot; for removal sampling, &quot;double&quot; for standard 
double observer sampling, or &quot;depDouble&quot; for dependent double observer 
sampling. If this argument not specified, the user must
provide an <code>obsToY</code> matrix. See details.</p>
</td></tr>
<tr><td><code id="unmarkedFrameMPois_+3A_obstoy">obsToY</code></td>
<td>
<p>A matrix describing the relationship between <code>obsCovs</code> 
and <code>y</code>. This is necessary because under some sampling designs 
the dimensions of <code>y</code> do not equal the dimensions of each 
observation level covariate. For example, in double observer sampling
there are 3 observations (seen only by observer A, detected only by 
observer B, and detected by both), but each observation-level covariate
can only have 2 columns, one for each observer. This matrix is created 
automatically if <code>type</code> is specified. </p>
</td></tr> 
<tr><td><code id="unmarkedFrameMPois_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="unmarkedFrameMPois_+3A_pifun">piFun</code></td>
<td>
<p>Function used to compute the multinomial cell probabilities 
from a matrix of detection probabilities. This is created automatically
if <code>type</code> is specified.</p>
</td></tr></table>


<h3>Details</h3>

<p>unmarkedFrameMPois is the S4 class that holds data to be passed 
to the <code><a href="#topic+multinomPois">multinomPois</a></code> model-fitting function.</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameMPois</p>


<h3>References</h3>

<p>Royle, J. A. (2004). Generalized estimators of avian abundance from
count survey data. Animal Biodiversity and Conservation, 27(1), 375-386.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, 
<code><a href="#topic+multinomPois">multinomPois</a></code>, <code><a href="#topic+piFuns">piFuns</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake doulbe observer data
R &lt;- 4 # number of sites
J &lt;- 2 # number of observers

y &lt;- matrix(c(
   1,0,3,
   0,0,0,
   2,0,1,
   0,0,2), nrow=R, ncol=J+1, byrow=TRUE)
y

site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

obs.covs &lt;- list(
   x3 = matrix(c(
      -1,0,
      -2,0,
      -3,1,
       0,0), 
      nrow=R, ncol=J, byrow=TRUE),
   x4 = matrix(c(
      'a','b',
      'a','b',
      'a','b',
      'a','b'), 
      nrow=R, ncol=J, byrow=TRUE))
obs.covs


# Create unmarkedFrame
umf &lt;- unmarkedFrameMPois(y=y, siteCovs=site.covs, obsCovs=obs.covs,
    type="double")
    
# The above is the same as:
o2y &lt;- matrix(1, 2, 3)
pifun &lt;- function(p)
{
    M &lt;- nrow(p)
    pi &lt;- matrix(NA, M, 3)
    pi[, 1] &lt;- p[, 1] * (1 - p[, 2])
    pi[, 2] &lt;- p[, 2] * (1 - p[, 1])
    pi[, 3] &lt;- p[, 1] * p[, 2]
    return(pi)
}

umf &lt;- unmarkedFrameMPois(y=y, siteCovs=site.covs, obsCovs=obs.covs,
    obsToY=o2y, piFun="pifun")


# Fit a model
fm &lt;- multinomPois(~1 ~1, umf)



</code></pre>

<hr>
<h2 id='unmarkedFrameOccu'>Organize data for the single season occupancy models fit by occu and 
occuRN</h2><span id='topic+unmarkedFrameOccu'></span>

<h3>Description</h3>

<p>Organizes detection, non-detection data along with the covariates. 
This S4 class is required by the data argument of <code><a href="#topic+occu">occu</a></code> and
<code><a href="#topic+occuRN">occuRN</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameOccu(y, siteCovs=NULL, obsCovs=NULL, mapInfo)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameOccu_+3A_y">y</code></td>
<td>
<p>An RxJ matrix of the detection, non-detection data, where R is the 
number of sites, J is the maximum number of sampling periods per site.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccu_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the 
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccu_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of 
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
RxJ rows in site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccu_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrameOccu is the S4 class that holds data to be passed 
to the <code><a href="#topic+occu">occu</a></code> and <code><a href="#topic+occuRN">occuRN</a></code> model-fitting function.
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameOccu</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, 
<code><a href="#topic+occu">occu</a></code>, <code><a href="#topic+occuRN">occuRN</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
R &lt;- 4 # number of sites
J &lt;- 3 # number of visits
y &lt;- matrix(c(
   1,1,0,
   0,0,0,
   1,1,1,
   1,0,1), nrow=R, ncol=J, byrow=TRUE)
y

site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

obs.covs &lt;- list(
   x3 = matrix(c(
      -1,0,1,
      -2,0,0,
      -3,1,0,
      0,0,0), nrow=R, ncol=J, byrow=TRUE),
   x4 = matrix(c(
      'a','b','c',
      'd','b','a',
      'a','a','c',
      'a','b','a'), nrow=R, ncol=J, byrow=TRUE))
obs.covs

umf &lt;- unmarkedFrameOccu(y=y, siteCovs=site.covs, 
    obsCovs=obs.covs)   # organize data
umf                     # look at data
summary(umf)            # summarize      
fm &lt;- occu(~1 ~1, umf)  # fit a model


</code></pre>

<hr>
<h2 id='unmarkedFrameOccuCOP'>Organize data for the occupancy model using count data fit by <code>occuCOP</code></h2><span id='topic+unmarkedFrameOccuCOP'></span><span id='topic+getL'></span><span id='topic+getL+2CunmarkedFrameOccuCOP-method'></span>

<h3>Description</h3>

<p>Organizes count data along with the covariates. The <a href="#topic+unmarkedFrame-class">unmarkedFrame</a> S4 class required by the <code>data</code> argument of <code><a href="#topic+occuCOP">occuCOP</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameOccuCOP(y, L, siteCovs = NULL, obsCovs = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameOccuCOP_+3A_y">y</code></td>
<td>
<p>An MxJ matrix of the count data, where M is the number of sites, J is the maximum number of observation periods (sampling occasions, transects, discretised sessions...) per site.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuCOP_+3A_l">L</code></td>
<td>
<p>An MxJ matrix of the length of the observation periods. For example, duration of the sampling occasion in hours, duration of the discretised session in days, or length of the transect in meters.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuCOP_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuCOP_+3A_obscovs">obsCovs</code></td>
<td>
<p>A named list of dataframes of dimension MxJ, with one dataframe per covariate that varies between sites and observation periods</p>
</td></tr>

</table>


<h3>Details</h3>

<p>unmarkedFrameOccuCOP is the <a href="#topic+unmarkedFrame-class">unmarkedFrame</a> S4 class that holds data to be passed to the <code><a href="#topic+occuCOP">occuCOP</a></code> model-fitting function.
</p>


<h3>Value</h3>

<p>an object of class <code>unmarkedFrameOccuCOP</code></p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, 
<code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, 
<code><a href="#topic+occuCOP">occuCOP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fake data
M &lt;- 4 # Number of sites
J &lt;- 3 # Number of observation periods

# Count data
(y &lt;- matrix(
  c(1, 3, 0,
    0, 0, 0,
    2, 0, 5,
    1, NA, 0),
  nrow = M,
  ncol = J,
  byrow = TRUE
))

# Length of observation periods
(L &lt;- matrix(
  c(1, 3, NA,
    2, 2, 2,
    1, 2, 1,
    7, 1, 3),
  nrow = M,
  ncol = J,
  byrow = TRUE
))

# Site covariates
(site.covs &lt;- data.frame(
  "elev" = rexp(4),
  "habitat" = factor(c("forest", "forest", "grassland", "grassland"))
))

# Observation covariates (as a list)
(obs.covs.list &lt;- list(
  "rain" = matrix(rexp(M * J), nrow = M, ncol = J),
  "wind" = matrix(
    sample(letters[1:3], replace = TRUE, size = M * J),
    nrow = M, ncol = J)
))

# Organise data in a unmarkedFrameOccuCOP object
umf &lt;- unmarkedFrameOccuCOP(
  y = y,
  L = L,
  siteCovs = site.covs,
  obsCovs = obs.covs.list
)

# Extract L
getL(umf)

# Look at data
print(umf) # Print the whole data set
print(umf[1, 2]) # Print the data of the 1st site, 2nd observation
summary(umf) # Summarise the data set
plot(umf) # Plot the count of detection events


# L is optional, if absent, it will be replaced by a MxJ matrix of 1
unmarkedFrameOccuCOP(
  y = y,
  siteCovs = site.covs,
  obsCovs = obs.covs.list
)

# Covariates are optional
unmarkedFrameOccuCOP(y = y)
</code></pre>

<hr>
<h2 id='unmarkedFrameOccuFP'>Organize data for the single season occupancy models fit by occuFP</h2><span id='topic+unmarkedFrameOccuFP'></span>

<h3>Description</h3>

<p>Organizes detection, non-detection data along with the covariates.
This S4 class is required by the data argument of <code><a href="#topic+occu">occu</a></code> and
<code><a href="#topic+occuRN">occuRN</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameOccuFP(y, siteCovs=NULL, obsCovs=NULL, type, mapInfo)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameOccuFP_+3A_y">y</code></td>
<td>
<p>An RxJ matrix of the detection, non-detection data, where R is the
number of sites, J is the maximum number of sampling periods per site.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuFP_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuFP_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with
RxJ rows in site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuFP_+3A_type">type</code></td>
<td>
<p>A vector with 3 values designating the number of occassions
where data is of type 1, type 2, and type 3 - see <code><a href="#topic+occuFP">occuFP</a></code>
for more details about data types.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuFP_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrameOccuFP is the S4 class that holds data to be passed
to the <code><a href="#topic+occu">occu</a></code> and <code><a href="#topic+occuRN">occuRN</a></code> model-fitting function.
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameOccuFP</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>,
<code><a href="#topic+occuFP">occuFP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
n = 100
o = 10
o1 = 5
y = matrix(0,n,o)
p = .7
r = .5
fp = 0.05
y[1:(n*.5),(o-o1+1):o] &lt;- rbinom((n*o1*.5),1,p)
y[1:(n*.5),1:(o-o1)] &lt;- rbinom((o-o1)*n*.5,1,r)
y[(n*.5+1):n,(o-o1+1):o] &lt;- rbinom((n*o1*.5),1,fp)
type &lt;- c((o-o1),o1,0)  ### vector with the number of each data type
site &lt;- c(rep(1,n*.5*.8),rep(0,n*.5*.2),rep(1,n*.5*.2),rep(0,n*.8*.5))
occ &lt;- matrix(c(rep(0,n*(o-o1)),rep(1,n*o1)),n,o)
site &lt;- data.frame(habitat = site)
occ &lt;- list(METH = occ)

umf1 &lt;- unmarkedFrameOccuFP(y,site,occ, type = type)

m1 &lt;- occuFP(detformula = ~ METH, FPformula = ~1, stateformula = ~ habitat, data = umf1)

</code></pre>

<hr>
<h2 id='unmarkedFrameOccuMS'>Organize data for the multi-state occupancy model fit by occuMS</h2><span id='topic+unmarkedFrameOccuMS'></span>

<h3>Description</h3>

<p>Organizes multi-state occupancy data (currently single-season only) 
along with covariates. This S4 class is required by the data argument 
of <code><a href="#topic+occuMS">occuMS</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameOccuMS(y, siteCovs=NULL, obsCovs=NULL, 
                           numPrimary=1, yearlySiteCovs=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameOccuMS_+3A_y">y</code></td>
<td>
<p>An MxR matrix of multi-state occupancy data for a species, 
where M is the number of sites and R is the maximum number of 
observations per site (across all primary and secondary periods, if 
you have multi-season data). Values in <code>y</code> should be integers ranging from
0 (non-detection) to the number of total states - 1. For example, if you
have 3 occupancy states, <code>y</code> should contain only values 0, 1, or 2.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMS_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the 
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMS_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of 
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
MxR rows in the ordered by site-observation (if single-season) or 
site-primary period-observation (if multi-season).</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMS_+3A_numprimary">numPrimary</code></td>
<td>
<p>Number of primary time periods (e.g. seasons) for the 
dynamic or multi-season version of the model. There should be
an equal number of secondary periods in each primary period.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMS_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>A data frame with one column per covariate that varies 
among sites and primary periods (e.g. years). It should have MxT rows
where M is the number of sites and T the number of primary periods,
ordered by site-primary period. These covariates only used for dynamic 
(multi-season) models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrameOccuMS is the S4 class that holds data to be passed 
to the <code><a href="#topic+occuMS">occuMS</a></code> model-fitting function.
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameOccuMS</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, 
<code><a href="#topic+occuMS">occuMS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
#Parameters
N &lt;- 100; J &lt;- 3; S &lt;- 3
psi &lt;- c(0.5,0.3,0.2)
p11 &lt;- 0.4; p12 &lt;- 0.25; p22 &lt;- 0.3

#Simulate state
z &lt;- sample(0:2, N, replace=TRUE, prob=psi)

#Simulate detection
y &lt;- matrix(0,nrow=N,ncol=J)
for (n in 1:N){
  probs &lt;- switch(z[n]+1,
                  c(0,0,0),
                  c(1-p11,p11,0),
                  c(1-p12-p22,p12,p22))
  
  if(z[n]&gt;0){
    y[n,] &lt;- sample(0:2, J, replace=TRUE, probs)
  }
}

#Covariates
site_covs &lt;- as.data.frame(matrix(rnorm(N*2),ncol=2)) # nrow = # of sites
obs_covs &lt;- as.data.frame(matrix(rnorm(N*J*2),ncol=2)) # nrow = N*J

#Build unmarked frame
umf &lt;- unmarkedFrameOccuMS(y=y,siteCovs=site_covs,obsCovs=obs_covs)

umf                     # look at data
summary(umf)            # summarize      
plot(umf)               # visualize
umf@numStates           # check number of occupancy states detected
</code></pre>

<hr>
<h2 id='unmarkedFrameOccuMulti'>Organize data for the multispecies occupancy model fit by occuMulti</h2><span id='topic+unmarkedFrameOccuMulti'></span>

<h3>Description</h3>

<p>Organizes detection, non-detection data for multiple species along 
with the covariates. This S4 class is required by the data argument 
of <code><a href="#topic+occuMulti">occuMulti</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFrameOccuMulti(y, siteCovs=NULL, obsCovs=NULL, 
                              maxOrder, mapInfo)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameOccuMulti_+3A_y">y</code></td>
<td>
<p>A list (optionally a named list) of length S where each element 
is an MxJ matrix of the detection, non-detection data for one species, 
where M is the number of sites, J is the maximum number of sampling 
periods per site, and S is the number of species in the analysis.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMulti_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the 
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMulti_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of 
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
MxJ rows in site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMulti_+3A_maxorder">maxOrder</code></td>
<td>
<p>Optional; specify maximum interaction order. Defaults to 
number of species (all possible interactions). Reducing this value may
speed up creation of unmarked frame if you aren't interested in 
higher-order interactions.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuMulti_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrameOccuMulti is the S4 class that holds data to be passed 
to the <code><a href="#topic+occuMulti">occuMulti</a></code> model-fitting function.
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameOccuMulti</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, 
<code><a href="#topic+occuMulti">occuMulti</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
S &lt;- 3 # number of species
M &lt;- 4 # number of sites
J &lt;- 3 # number of visits

y &lt;- list(matrix(rbinom(M*J,1,0.5),M,J), # species 1
          matrix(rbinom(M*J,1,0.5),M,J), # species 2
          matrix(rbinom(M*J,1,0.2),M,J)) # species 3

site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

umf &lt;- unmarkedFrameOccuMulti(y=y, siteCovs=site.covs, 
    obsCovs=NULL)   # organize data
umf                     # look at data
summary(umf)            # summarize      
plot(umf)               # visualize
#fm &lt;- occu(~1 ~1, umf)  # fit a model


</code></pre>

<hr>
<h2 id='unmarkedFrameOccuTTD'>Create an unmarkedFrameOccuTTD object for the time-to-detection model
fit by occuTTD</h2><span id='topic+unmarkedFrameOccuTTD'></span>

<h3>Description</h3>

<p>Organizes time-to-detection occupancy data along with covariates. 
This S4 class is required by the data argument of <code><a href="#topic+occuTTD">occuTTD</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>  unmarkedFrameOccuTTD(y, surveyLength, siteCovs=NULL, obsCovs=NULL, 
                           numPrimary=1, yearlySiteCovs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFrameOccuTTD_+3A_y">y</code></td>
<td>
<p>An MxR matrix of time-to-detection data for a species, 
where M is the number of sites and R is the maximum number of 
observations per site (across all primary periods and observations, if 
you have multi-season data). Values in <code>y</code> should be positive.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuTTD_+3A_surveylength">surveyLength</code></td>
<td>
<p>The maximum length of a survey, in the same units as 
<code>y</code>. You can provide either a single value (if all surveys had
the same max length), or a matrix matching the dimensions of <code>y</code>
(if surveys had different max lengths).</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuTTD_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the 
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuTTD_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of 
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
MxR rows in the ordered by site-observation (if single-season) or 
site-primary period-observation (if multi-season).</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuTTD_+3A_numprimary">numPrimary</code></td>
<td>
<p>Number of primary time periods (e.g. seasons) for the 
dynamic or multi-season version of the model. There should be
an equal number of secondary periods in each primary period.</p>
</td></tr>
<tr><td><code id="unmarkedFrameOccuTTD_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>A data frame with one column per covariate that varies 
among sites and primary periods (e.g. years). It should have MxT rows
where M is the number of sites and T the number of primary periods,
ordered by site-primary period. These covariates only used for dynamic 
(multi-season) models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFrameOccuTTD is the S4 class that holds data to be passed 
to the <code><a href="#topic+occuTTD">occuTTD</a></code> model-fitting function.
</p>


<h3>Value</h3>

<p>an object of class unmarkedFrameOccuTTD</p>


<h3>Note</h3>

<p>If the time-to-detection values in <code>y</code> are very large (e.g., because
they are expressed as numbers of seconds) you may have issues fitting models.
An easy solution is to convert your units (e.g., from seconds to decimal
minutes) to keep the values as close to 0 as possible.
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # For a single-season model
  N &lt;- 100 #Number of sites
  psi &lt;- 0.4 #Occupancy probability
  lam &lt;- 7 #Parameter for exponential distribution of time to detection
  Tmax &lt;- 10 #Maximum survey length

  z &lt;- rbinom(N, 1, psi) #Simulate occupancy
  y &lt;- rexp(N, 1/lam) #Simulate time to detection
  y[z==0] &lt;- Tmax
  y[y&gt;Tmax] &lt;- Tmax
  
  sc &lt;- as.data.frame(matrix(rnorm(N*2),ncol=2)) #Site covs
  oc &lt;- as.data.frame(matrix(rnorm(N*2),ncol=2)) #obs covs

  umf &lt;- unmarkedFrameOccuTTD(y=y, surveyLength=Tmax, siteCovs=sc, obsCovs=oc)
  
</code></pre>

<hr>
<h2 id='unmarkedFramePCO'>Create an object of class unmarkedFramePCO that contains data used by pcountOpen.</h2><span id='topic+unmarkedFramePCO'></span>

<h3>Description</h3>

<p>Organizes repeated count data along with the covariates and possibly the dates on which each survey was conducted. This S4 class is required by the data argument of <code><a href="#topic+pcountOpen">pcountOpen</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFramePCO(y, siteCovs=NULL, obsCovs=NULL, yearlySiteCovs, mapInfo,
    numPrimary, primaryPeriod)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFramePCO_+3A_y">y</code></td>
<td>
<p>An MxJT matrix of the repeated count data, where M is the number
of sites, J is the maximum number of secondary sampling periods per site
and T is the maximum number of primary sampling periods per site.</p>
</td></tr>
<tr><td><code id="unmarkedFramePCO_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the
site level. This should have M rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFramePCO_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of covariates
that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with MxJT rows in
site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFramePCO_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>Either a named list of MxT <code><a href="base.html#topic+data.frame">data.frame</a></code>s,
or a site-major <code><a href="base.html#topic+data.frame">data.frame</a></code> with MT rows and 1 column per
covariate.</p>
</td></tr>
<tr><td><code id="unmarkedFramePCO_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="unmarkedFramePCO_+3A_numprimary">numPrimary</code></td>
<td>
<p>Maximum number of observed primary periods for each site</p>
</td></tr>
<tr><td><code id="unmarkedFramePCO_+3A_primaryperiod">primaryPeriod</code></td>
<td>
<p>matrix of integers indicating the primary period of each survey.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedFramePCO is the S4 class that holds data to be passed
to the <code><a href="#topic+pcountOpen">pcountOpen</a></code> model-fitting function.
</p>
<p>The unmarkedFramePCO class is similar to the unmarkedFramePCount class except
that it contains the dates for each survey, which needs to be supplied .
</p>


<h3>Value</h3>

<p>an object of class unmarkedFramePCO</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>,
<code><a href="#topic+pcountOpen">pcountOpen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Repeated count data with 5 primary periods and
# no secondary sampling periods (ie J==1)
y1 &lt;- matrix(c(
    0, 2, 3, 2, 0,
    2, 2, 3, 1, 1,
    1, 1, 0, 0, 3,
    0, 0, 0, 0, 0), nrow=4, ncol=5, byrow=TRUE)

# Site-specific covariates
sc1 &lt;- data.frame(x1 = 1:4, x2 = c('A','A','B','B'))

# Observation-specific covariates
oc1 &lt;- list(
    x3 = matrix(1:5, nrow=4, ncol=5, byrow=TRUE),
    x4 = matrix(letters[1:5], nrow=4, ncol=5, byrow=TRUE))

# Primary periods of surveys
primaryPeriod1 &lt;- matrix(as.integer(c(
    1, 2, 5, 7, 8,
    1, 2, 3, 4, 5,
    1, 2, 4, 5, 6,
    1, 3, 5, 6, 7)), nrow=4, ncol=5, byrow=TRUE)


# Create the unmarkedFrame
umf1 &lt;- unmarkedFramePCO(y=y1, siteCovs=sc1, obsCovs=oc1, numPrimary=5,
    primaryPeriod=primaryPeriod1)

# Take a look
umf1
summary(umf1)






# Repeated count data with 4 primary periods and
# no 2 secondary sampling periods (ie J=2)
y2 &lt;- matrix(c(
    0,0,  2,2,  3,2,  2,2,
    2,2,  2,1,  3,2,  1,1,
    1,0,  1,1,  0,0,  0,0,
    0,0,  0,0,  0,0,  0,0), nrow=4, ncol=8, byrow=TRUE)


# Site-specific covariates
sc2 &lt;- data.frame(x1 = 1:4, x2 = c('A','A','B','B'))

# Observation-specific covariates
oc2 &lt;- list(
    x3 = matrix(1:8, nrow=4, ncol=8, byrow=TRUE),
    x4 = matrix(letters[1:8], nrow=4, ncol=8, byrow=TRUE))

# Yearly-site covariates
ysc &lt;- list(
    x5 = matrix(c(
        1,2,3,4,
        1,2,3,4,
        1,2,3,4,
        1,2,3,4), nrow=4, ncol=4, byrow=TRUE))

# Primary periods of surveys
primaryPeriod2 &lt;- matrix(as.integer(c(
    1,2,5,7,
    1,2,3,4,
    1,2,4,5,
    1,3,5,6)), nrow=4, ncol=4, byrow=TRUE)

# Create the unmarkedFrame
umf2 &lt;- unmarkedFramePCO(y=y2, siteCovs=sc2, obsCovs=oc2,
    yearlySiteCovs=ysc,
    numPrimary=4, primaryPeriod=primaryPeriod2)

# Take a look
umf2
summary(umf2)


</code></pre>

<hr>
<h2 id='unmarkedFramePCount'>Organize data for the N-mixture model fit by pcount</h2><span id='topic+unmarkedFramePCount'></span>

<h3>Description</h3>

<p>Organizes repeated count data along with the covariates. 
This S4 class is required by the data argument of <code><a href="#topic+pcount">pcount</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>unmarkedFramePCount(y, siteCovs=NULL, obsCovs=NULL, mapInfo)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedFramePCount_+3A_y">y</code></td>
<td>
<p>An RxJ matrix of the repeated count data, where R is the number 
of sites, J is the maximum number of sampling periods per site.</p>
</td></tr>
<tr><td><code id="unmarkedFramePCount_+3A_sitecovs">siteCovs</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of covariates that vary at the 
site level. This should have R rows and one column per covariate</p>
</td></tr>
<tr><td><code id="unmarkedFramePCount_+3A_obscovs">obsCovs</code></td>
<td>
<p>Either a named list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s of 
covariates that vary within sites, or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
RxJ rows in site-major order.</p>
</td></tr>
<tr><td><code id="unmarkedFramePCount_+3A_mapinfo">mapInfo</code></td>
<td>
<p>Currently ignored</p>
</td></tr></table>


<h3>Details</h3>

<p>unmarkedFramePCount is the S4 class that holds data to be passed 
to the <code><a href="#topic+pcount">pcount</a></code> model-fitting function.</p>


<h3>Value</h3>

<p>an object of class unmarkedFramePCount</p>


<h3>See Also</h3>

<p><code><a href="#topic+unmarkedFrame-class">unmarkedFrame-class</a></code>, <code><a href="#topic+unmarkedFrame">unmarkedFrame</a></code>, 
<code><a href="#topic+pcount">pcount</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake data
R &lt;- 4 # number of sites
J &lt;- 3 # number of visits
y &lt;- matrix(c(
   1,2,0,
   0,0,0,
   1,1,1,
   2,2,1), nrow=R, ncol=J, byrow=TRUE)
y

site.covs &lt;- data.frame(x1=1:4, x2=factor(c('A','B','A','B')))
site.covs

obs.covs &lt;- list(
   x3 = matrix(c(
      -1,0,1,
      -2,0,0,
      -3,1,0,
      0,0,0), nrow=R, ncol=J, byrow=TRUE),
   x4 = matrix(c(
      'a','b','c',
      'd','b','a',
      'a','a','c',
      'a','b','a'), nrow=R, ncol=J, byrow=TRUE))
obs.covs

umf &lt;- unmarkedFramePCount(y=y, siteCovs=site.covs, 
    obsCovs=obs.covs)          # organize data
umf                            # take a l
summary(umf)                   # summarize data
fm &lt;- pcount(~1 ~1, umf, K=10) # fit a model
      

</code></pre>

<hr>
<h2 id='unmarkedMultFrame'>Create an unmarkedMultFrame, unmarkedFrameGMM, unmarkedFrameGDS,
or unmarkedFrameGPC object</h2><span id='topic+unmarkedMultFrame'></span><span id='topic+yearlySiteCovs'></span><span id='topic+yearlySiteCovs+2CunmarkedMultFrame-method'></span><span id='topic+yearlySiteCovs+3C-'></span><span id='topic+yearlySiteCovs+3C-+2CunmarkedMultFrame-method'></span><span id='topic+unmarkedFrameGMM'></span><span id='topic+unmarkedFrameGDS'></span><span id='topic+unmarkedFrameGPC'></span><span id='topic+unmarkedFrameGOccu'></span>

<h3>Description</h3>

<p>These functions construct unmarkedFrames for data
collected during primary and secondary sampling periods.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  unmarkedMultFrame(y, siteCovs, obsCovs, numPrimary, yearlySiteCovs)
  unmarkedFrameGMM(y, siteCovs, obsCovs, numPrimary, yearlySiteCovs, type,
    obsToY, piFun)
  unmarkedFrameGDS(y, siteCovs, numPrimary, yearlySiteCovs, dist.breaks,
    survey, unitsIn, tlength)
  unmarkedFrameGPC(y, siteCovs, obsCovs, numPrimary, yearlySiteCovs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedMultFrame_+3A_y">y</code></td>
<td>
<p>A matrix of the observed data.</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_sitecovs">siteCovs</code></td>
<td>
<p>Data frame of covariates that vary at the site level.</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_obscovs">obsCovs</code></td>
<td>
<p>Data frame of covariates that vary within
site-year-observation level.</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_numprimary">numPrimary</code></td>
<td>
<p>Number of primary time periods (seasons in the
multiseason model).</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_yearlysitecovs">yearlySiteCovs</code></td>
<td>
<p>Data frame containing covariates at the
site-year level.</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_type">type</code></td>
<td>
<p>Set to &quot;removal&quot; for constant-interval removal
sampling, &quot;double&quot; for standard double observer sampling, or 
&quot;depDouble&quot; for dependent double observer sampling. 
This should be not be specified for other types of survey designs.</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_obstoy">obsToY</code></td>
<td>
<p>A matrix specifying relationship between observation-level
covariates and response matrix</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_pifun">piFun</code></td>
<td>
<p>A function converting an MxJ matrix of detection probabilities
into an MxJ matrix of multinomial cell probabilities.</p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_dist.breaks">dist.breaks</code></td>
<td>
<p>see <code><a href="#topic+unmarkedFrameDS">unmarkedFrameDS</a></code></p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_survey">survey</code></td>
<td>
<p>see <code><a href="#topic+unmarkedFrameDS">unmarkedFrameDS</a></code></p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_unitsin">unitsIn</code></td>
<td>
<p>see <code><a href="#topic+unmarkedFrameDS">unmarkedFrameDS</a></code></p>
</td></tr>
<tr><td><code id="unmarkedMultFrame_+3A_tlength">tlength</code></td>
<td>
<p>see <code><a href="#topic+unmarkedFrameDS">unmarkedFrameDS</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>unmarkedMultFrame objects are used by <code><a href="#topic+colext">colext</a></code>.
</p>
<p>unmarkedFrameGMM objects are used by <code><a href="#topic+gmultmix">gmultmix</a></code>.
</p>
<p>unmarkedFrameGDS objects are used by <code><a href="#topic+gdistsamp">gdistsamp</a></code>.
</p>
<p>unmarkedFrameGPC objects are used by <code><a href="#topic+gpcount">gpcount</a></code>.
</p>
<p>For a study with <em>M</em> sites, <em>T</em> years, and a maximum of
<em>J</em> observations per site-year, the data can be supplied in a
variety of ways but are stored as follows.
<code>y</code> is an <code class="reqn">M \times TJ</code> matrix, with each row
corresponding to a site.  <code>siteCovs</code> is a data frame with <code class="reqn">M</code>
rows.  <code>yearlySiteCovs</code> is a data frame with <code class="reqn">MT</code> rows which
are in site-major, year-minor order.  <code>obsCovs</code> is a data frame
with <code class="reqn">MTJ</code> rows, which are ordered by site-year-observation, so that
a column of <code>obsCovs</code> corresponds to <code>as.vector(t(y))</code>,
element-by-element.  The number of years must be specified in
<code>numPrimary</code>.
</p>
<p>If the data are in long format, the convenience function
<code><a href="#topic+formatMult">formatMult</a></code> is useful for creating the unmarkedMultFrame.
</p>
<p>unmarkedFrameGMM and unmarkedFrameGDS are superclasses of
unmarkedMultFrame containing information on
the survey design used that resulted in multinomial outcomes. For
unmarkedFrameGMM and constant-interval removal sampling, you can set
type=&quot;removal&quot; and ignore
the arguments obsToY and piFun. Similarly, for double-observer sampling,
setting type=&quot;double&quot; or type=&quot;depDouble&quot; will automatically create an appropiate 
obsToY matrix and <code><a href="#topic+piFuns">piFuns</a></code>. For all other situations, the type 
argument of unmarkedFrameGMM should be
ignored and the obsToY and piFun arguments must be specified. piFun must be a
function that converts an MxJ matrix of detection probabilities into an MxJ
matrix of multinomial cell probabilities. obsToY is a matrix describing how
the obsCovs relate to the observed counts y. For further discussion and examples
see the help page for <code><a href="#topic+multinomPois">multinomPois</a></code> and <code><a href="#topic+piFuns">piFuns</a></code>.
</p>
<p>unmarkedFrameGMM and unmarkedFrameGDS objects can be created from an
unmarkedMultFrame using the
&quot;as&quot; conversion method. See examples.
</p>


<h3>Value</h3>

<p>an unmarkedMultFrame or unmarkedFrameGMM object</p>


<h3>Note</h3>

<p>Data used with <a href="#topic+colext">colext</a>, <a href="#topic+gmultmix">gmultmix</a>, and
<a href="#topic+gdistsamp">gdistsamp</a> may be collected during a single year, so
yearlySiteCovs may be a misnomer is some cases. </p>


<h3>See Also</h3>

<p><code><a href="#topic+formatMult">formatMult</a></code>, <code><a href="#topic+colext">colext</a></code>,
<code><a href="#topic+gmultmix">gmultmix</a></code>, <code><a href="#topic+gpcount">gpcount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 50   # number of sites
T &lt;- 4    # number of primary periods
J &lt;- 3    # number of secondary periods

site &lt;- 1:50
years &lt;- data.frame(matrix(rep(2010:2013, each=n), n, T))
years &lt;- data.frame(lapply(years, as.factor))
occasions &lt;- data.frame(matrix(rep(1:(J*T), each=n), n, J*T))

y &lt;- matrix(0:1, n, J*T)

umf &lt;- unmarkedMultFrame(y=y,
    siteCovs = data.frame(site=site),
    obsCovs=list(occasion=occasions),
    yearlySiteCovs=list(year=years),
    numPrimary=T)

umfGMM1 &lt;- unmarkedFrameGMM(y=y,
    siteCovs = data.frame(site=site),
    obsCovs=list(occasion=occasions),
    yearlySiteCovs=data.frame(year=c(t(years))),
    # or: yearlySiteCovs=list(year=years),
    numPrimary=T, type="removal")


# A user-defined piFun calculating removal probs when time intervals differ.
instRemPiFun &lt;- function(p) {
	M &lt;- nrow(p)
	J &lt;- ncol(p)
	pi &lt;- matrix(NA, M, J)
	p[,1] &lt;- pi[,1] &lt;- 1 - (1 - p[,1])^2
	p[,2] &lt;- 1 - (1 - p[,2])^3
	p[,3] &lt;- 1 - (1 - p[,3])^5
	for(i in 2:J) {
		pi[,i] &lt;- pi[, i - 1]/p[, i - 1] * (1 - p[, i - 1]) * p[, i]
		}
	return(pi)
	}

# Associated obsToY matrix required by unmarkedFrameMPois
o2y &lt;- diag(ncol(y))
o2y[upper.tri(o2y)] &lt;- 1
o2y


umfGMM2 &lt;- unmarkedFrameGMM(y=y,
    siteCovs = data.frame(site=site),
    obsCovs=list(occasion=occasions),
    yearlySiteCovs=data.frame(year=c(t(years))),
    numPrimary=T, obsToY=o2y, piFun="instRemPiFun")

str(umfGMM2)



</code></pre>

<hr>
<h2 id='unmarkedPower-methods'>Methods for unmarkedPower objects</h2><span id='topic+unmarkedPower-methods'></span><span id='topic+unmarkedPower-class'></span><span id='topic+show+2CunmarkedPower-method'></span><span id='topic+summary+2CunmarkedPower-method'></span><span id='topic+update+2CunmarkedPower-method'></span>

<h3>Description</h3>

<p>Various functions to summarize and update unmarkedPower objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unmarkedPower'
show(object)
## S4 method for signature 'unmarkedPower'
summary(object, ...)
## S4 method for signature 'unmarkedPower'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedPower-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>unmarkedPower</code> created with the 
<code>powerAnalysis</code> function</p>
</td></tr>
<tr><td><code id="unmarkedPower-methods_+3A_...">...</code></td>
<td>
<p>For <code>update</code>, arguments to change in the updated power analysis.
Not used by <code>summary</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>show</code> and <code>summary</code>, summary output is printed to the console.
For <code>update</code>, a new <code>powerAnalysis</code> object corresponding to the 
new arguments provided.
</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+powerAnalysis">powerAnalysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulate an occupancy dataset
forms &lt;- list(state=~elev, det=~1)
coefs &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))
design &lt;- list(M=300, J=8) # 300 sites, 8 occasions per site
occu_umf &lt;- simulate("occu", formulas=forms, coefs=coefs, design=design)

# Fit occupancy model to simulated data
template_model &lt;- occu(~1~elev, occu_umf)

# Set desired effect sizes to pass to coefs
effect_sizes &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))

# Run power analysis
pa &lt;- powerAnalysis(template_model, coefs=effect_sizes, alpha=0.05)

# Look at summary
summary(pa)

# Update the analysis with new arguments
(pa2 &lt;- update(pa, alpha=0.01))


## End(Not run)
</code></pre>

<hr>
<h2 id='unmarkedPowerList'>Create or summarize a series of unmarked power analyses</h2><span id='topic+unmarkedPowerList'></span><span id='topic+unmarkedPowerList+2Clist-method'></span><span id='topic+unmarkedPowerList+2CunmarkedFit-method'></span><span id='topic+unmarkedPowerList-class'></span><span id='topic+unmarkedPowerList-methods'></span><span id='topic+show+2CunmarkedPowerList-method'></span><span id='topic+summary+2CunmarkedPowerList-method'></span><span id='topic+plot+2CunmarkedPowerList+2CANY-method'></span>

<h3>Description</h3>

<p>A list of power analyses created with <code>powerAnalysis</code> can be combined 
using <code>unmarkedPowerList</code>, allowing comparison e.g. between different
study designs/sample sizes. Additionally an <code>unmarkedPowerList</code> can be
created directly from an <code>unmarkedFit</code> template model by specifying
a series of study designs (number of sites, number of observations) 
as a <code>data.frame</code>. A series of methods for <code>unmarkedPowerList</code>
objects are available including a <code>plot</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
unmarkedPowerList(object, ...)
## S4 method for signature 'unmarkedFit'
unmarkedPowerList(object, coefs, design, alpha=0.05,
                                          nulls=list(), nsim=100, parallel=FALSE, ...)
## S4 method for signature 'unmarkedPowerList'
show(object)
## S4 method for signature 'unmarkedPowerList'
summary(object, ...)
## S4 method for signature 'unmarkedPowerList,ANY'
plot(x, power=NULL, param=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmarkedPowerList_+3A_object">object</code>, <code id="unmarkedPowerList_+3A_x">x</code></td>
<td>
<p>A <code>list</code> of <code>unmarkedPower</code> objects, a fitted model 
inheriting class <code>unmarkedFit</code>, or an <code>unmarkedPowerList</code> object,
depending on the method
</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_coefs">coefs</code></td>
<td>
<p>A named list of effect sizes, see documentation for
<code>powerAnalysis</code></p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_design">design</code></td>
<td>
<p>A <code>data.frame</code> with one row per study design to test, and
at least 2 named columns: <code>M</code> for number of sites and <code>J</code> for
number of observations. If you have &gt;1 primary period a <code>T</code> column
must also be provided</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_alpha">alpha</code></td>
<td>
<p>Type I error rate</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_nulls">nulls</code></td>
<td>
<p>If provided, a list matching the structure of <code>coefs</code> which
defines the null hypothesis value for each parameter. By default the null
is 0 for all parameters.
</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to run for each scenario/study design</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, run simulations in parallel</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_power">power</code></td>
<td>
<p>When plotting, the target power. Draws a horizontal line
at a given value of power on the plot</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_param">param</code></td>
<td>
<p>When plotting, the model parameter to plot power vs. sample size for.
By default this is the first parameter (which is usually an intercept,
so not very interesting)</p>
</td></tr>
<tr><td><code id="unmarkedPowerList_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>unmarkedPowerList</code> object, a summary of the object in the console,
or a summary plot, depending on the method</p>


<h3>Author(s)</h3>

<p>Ken Kellner <a href="mailto:contact@kenkellner.com">contact@kenkellner.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+powerAnalysis">powerAnalysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Simulate an occupancy dataset and build template model
forms &lt;- list(state=~elev, det=~1)
coefs &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))
design &lt;- list(M=300, J=8) # 300 sites, 8 occasions per site
occu_umf &lt;- simulate("occu", formulas=forms, coefs=coefs, design=design)
template_model &lt;- occu(~1~elev, occu_umf)

# Generate two power analysis
effect_sizes &lt;- list(state=c(intercept=0, elev=-0.4), det=c(intercept=0))
pa &lt;- powerAnalysis(template_model, coefs=effect_sizes, alpha=0.05)
pa2 &lt;- powerAnalysis(template_model, effect_sizes, design=list(M=100,J=2))

# Build unmarkedPowerList and look at summary
(pl &lt;- unmarkedPowerList(list(pa,pa2)))

# Run a bunch of power analyses for different scenarios all at once
scenarios &lt;- expand.grid(M=c(50,200,400),
                         J=c(3,5,8))
(pl2 &lt;- unmarkedPowerList(template_model, effect_sizes, design=scenarios, nsim=20))

# Look at summary plot for elev effect
plot(pl2, power=0.8, param='elev')


## End(Not run)
</code></pre>

<hr>
<h2 id='unmarkedRanef-class'>Class <code>"unmarkedRanef"</code></h2><span id='topic+unmarkedRanef-class'></span><span id='topic+bup'></span><span id='topic+bup+2CunmarkedRanef-method'></span><span id='topic+confint+2CunmarkedRanef-method'></span><span id='topic+plot+2CunmarkedRanef+2Cmissing-method'></span><span id='topic+show+2CunmarkedRanef-method'></span>

<h3>Description</h3>

<p>Stores the estimated posterior distributions of
the latent abundance or occurrence variables.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code><a href="#topic+ranef">ranef</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>post</code>:</dt><dd><p>An <code><a href="base.html#topic+array">array</a></code> with nSites rows and Nmax
(K+1) columns and nPrimaryPeriod slices </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>bup</dt><dd><p><code>signature(object = "unmarkedRanef")</code>: Extract the
Best Unbiased Predictors (BUPs) of the latent variables (abundance
or occurrence state). Either the posterior mean or median can be
requested using the <code>stat</code> argument.</p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "unmarkedRanef")</code>: Compute
confidence intervals.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "unmarkedRanef", y = "missing")</code>:
Plot the posteriors using <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "unmarkedRanef")</code>: Display the
modes and confidence intervals</p>
</dd>
</dl>



<h3>Warnings</h3>

<p>Empirical Bayes methods can underestimate the variance of the
posterior distribution because they do not account for uncertainty in
the hyperparameters (lambda or psi). Simulation studies
indicate that the posterior mode can exhibit (3-5
percent) negatively bias as a point
estimator of site-specific abundance. It appears to be safer to use
the posterior mean even though this will not be an integer in general.
</p>


<h3>References</h3>

<p>Laird, N.M. and T.A. Louis. 1987. Empirical Bayes confidence intervals
based on bootstrap samples. Journal of the American Statistical
Association 82:739&ndash;750.
</p>
<p>Carlin, B.P and T.A Louis. 1996. Bayes and Empirical Bayes Methods for
Data Analysis. Chapman and Hall/CRC.
</p>
<p>Royle, J.A and R.M. Dorazio. 2008. Hierarchical Modeling and Inference
in Ecology. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef">ranef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("unmarkedRanef")
</code></pre>

<hr>
<h2 id='vcov-methods'>Methods for Function vcov in Package &lsquo;unmarked&rsquo;</h2><span id='topic+vcov-methods'></span><span id='topic+vcov+2ClinCombOrBackTrans-method'></span><span id='topic+vcov+2CunmarkedEstimate-method'></span><span id='topic+vcov+2CunmarkedFit-method'></span><span id='topic+vcov+2CunmarkedFitOccuMulti-method'></span>

<h3>Description</h3>

<p>Extract variance-covariance matrix from a fitted model.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;linCombOrBackTrans&quot;</dt><dd><p>See <code><a href="#topic+linearComb-methods">linearComb-methods</a></code></p>
</dd>
<dt>object = &quot;unmarkedEstimate&quot;</dt><dd><p>See <code><a href="#topic+unmarkedEstimate-class">unmarkedEstimate-class</a></code></p>
</dd>
<dt>object = &quot;unmarkedFit&quot;</dt><dd><p>A fitted model</p>
</dd>
</dl>

<hr>
<h2 id='vif'>Compute Variance Inflation Factors for an unmarkedFit Object.</h2><span id='topic+vif'></span>

<h3>Description</h3>

<p>Compute the variance inflation factors (VIFs) for covariates in one level of the 
model (i.e., occupancy or detection). Calculation of VIFs follows the approach 
of function <code>vif</code> in package <code>car</code>, using the correlation matrix of 
fitted model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif(mod, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_+3A_mod">mod</code></td>
<td>
<p>An unmarked fit object.</p>
</td></tr>
<tr><td><code id="vif_+3A_type">type</code></td>
<td>
<p>Level of the model for which to calculate VIFs (for example,
<code>'state'</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of variance inflation factor values for each covariate.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
