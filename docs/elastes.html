<!DOCTYPE html><html><head><title>Help for package elastes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {elastes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_elastic_shape_mean'><p>Compute an elastic full Procrustes mean for a collection of curves</p></a></li>
<li><a href='#elastes-package'><p>elastes: Elastic Full Procrustes Means for Sparse and Irregular Planar Curves</p></a></li>
<li><a href='#fit_alignment_proc2d'><p>Optimal rotation and scaling alignment to a smooth curve</p></a></li>
<li><a href='#fit_mean'><p>Mean estimation for open planar curves.</p></a></li>
<li><a href='#get_center'><p>Calculate the center of a curve</p></a></li>
<li><a href='#get_distance'><p>Distance to a smooth curve</p></a></li>
<li><a href='#get_evals'><p>Evaluate a curve on a grid</p></a></li>
<li><a href='#get_optimal_t'><p>Finds optimal alignment for discrete open curves</p></a></li>
<li><a href='#get_polygon_length'><p>Calculate the polygon length of a curve</p></a></li>
<li><a href='#get_procrustes_fit'><p>Get Procrustes data curve from mean object.</p></a></li>
<li><a href='#get_Procrustes_fit_from_param'><p>Helper functions for calculating Procrustes data curve from rotation, scaling and translation parameters.</p></a></li>
<li><a href='#plot.elastic_shape_mean'><p>Plot method for planar elastic Procrustes mean curves</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Elastic Full Procrustes Means for Sparse and Irregular Planar
Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for the computation of functional elastic shape 
  means over sets of open planar curves. The package is particularly suitable for 
  settings where these curves are only sparsely and irregularly observed. It uses 
  a novel approach for elastic shape mean estimation, where planar curves are
  treated as complex functions and a full Procrustes mean is estimated from the
  corresponding smoothed Hermitian covariance surface. This is combined with the 
  methods for elastic mean estimation proposed in Steyer, Stöcker, Greven	(2022)
  &lt;<a href="https://doi.org/10.1111%2Fbiom.13706">doi:10.1111/biom.13706</a>&gt;. See Stöcker et. al. (2022) &lt;<a href="https://arxiv.org/abs/2203.10522">arXiv:2203.10522</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>elasdics, utils, graphics, stats, splines, mgcv, sparseFLMM,
orthogonalsplinebasis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, covr, testthat (&ge; 3.0.0), rmarkdown, shapes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mpff.github.io/elastes/">https://mpff.github.io/elastes/</a>, <a href="https://github.com/mpff/elastes">https://github.com/mpff/elastes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mpff/elastes/issues">https://github.com/mpff/elastes/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 13:46:08 UTC; Manuel Pfeuffer</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel Pfeuffer [aut, cre],
  Lisa Steyer [aut],
  Almond Stoecker [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel Pfeuffer &lt;manuel.pfeuffer@hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 15:00:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_elastic_shape_mean'>Compute an elastic full Procrustes mean for a collection of curves</h2><span id='topic+compute_elastic_shape_mean'></span>

<h3>Description</h3>

<p>Computes an elastic full Procrustes mean for curves stored in <code>data_curves</code>.
Constructor function for class <code>elastic_shape_mean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_elastic_shape_mean(
  data_curves,
  knots = seq(0, 1, len = 13),
  type = c("smooth", "polygon"),
  penalty = 2,
  var_type = c("smooth", "constant", "zero"),
  pfit_method = c("smooth", "polygon"),
  smooth_warp = function(i) 0,
  eps = 0.05,
  max_iter = 50,
  verbose = FALSE,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_elastic_shape_mean_+3A_data_curves">data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with observed points in each row. Each
variable is one coordinate direction. If there is a variable <code>t</code>,
it is treated as the time parametrization, not as an additional coordinate.</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_knots">knots</code></td>
<td>
<p>set of knots for the mean spline curve</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_type">type</code></td>
<td>
<p>if &quot;smooth&quot; linear srv-splines are used which results in a differentiable mean curve
if &quot;polygon&quot; the mean will be piecewise linear.</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_penalty">penalty</code></td>
<td>
<p>the penalty to use in the covariance smoothing step. use '-1' for no penalty.</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_var_type">var_type</code></td>
<td>
<p>(experimental) assume &quot;smooth&quot;, &quot;constant&quot; or &quot;zero&quot; measurement-error variance along t</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_pfit_method">pfit_method</code></td>
<td>
<p>(experimental) &quot;smooth&quot; or &quot;polygon&quot;</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_smooth_warp">smooth_warp</code></td>
<td>
<p>(experimental) controls the weighting of original and smoothed observations
over the iterations, if pfit_method == &quot;smooth&quot;.</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if L2 norm of coefficients changes by less than <code>eps</code></p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_verbose">verbose</code></td>
<td>
<p>print iterations</p>
</td></tr>
<tr><td><code id="compute_elastic_shape_mean_+3A_cluster">cluster</code></td>
<td>
<p>(experimental) use the parallel package for faster computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>elastic_shape_mean</code>, which is a <code>list</code>
with entries
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>&quot;smooth&quot; if mean was modeled using linear srv-splines, &quot;polygon&quot; if constant srv-splines</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>spline coefficients</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>spline knots</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>sample elastic shape variance</p>
</td></tr>
<tr><td><code>data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with observed points in each row.
First variable <code>t</code> gives the initial parametrization, second variable <code>t_optim</code>
the optimal parametrization when the curve is aligned to the mean. Has the
attributes 'rotation', 'scaling', 'translation' and 'dist_to_mean'. Use
<code><a href="#topic+get_procrustes_fit">get_procrustes_fit</a></code> to get the elastic full Procrustes fit.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>see <code>fit_mean</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>curve &lt;- function(t){
  rbind(t*cos(13*t), t*sin(13*t))
}
set.seed(18)
data_curves &lt;- lapply(1:4, function(i){
  m &lt;- sample(10:15, 1)
  delta &lt;- abs(rnorm(m, mean = 1, sd = 0.05))
  t &lt;- cumsum(delta)/sum(delta)
  data.frame(t(curve(t)) + 0.07*t*matrix(cumsum(rnorm(2*length(delta))),
             ncol = 2))
})

#randomly rotate and scale curves
rand_scale &lt;- function(curve){ ( 0.5 + runif(1) ) * curve }
rand_rotate &lt;- function(curve){
  names &lt;- colnames(curve)
  theta &lt;- 2*pi*runif(1)
  mat &lt;- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), nrow = 2, ncol = 2)
  curve.rot &lt;- as.matrix(curve) %*% t(mat)
  curve.rot &lt;- as.data.frame(curve.rot)
  colnames(curve.rot) &lt;- names
  return(curve.rot)
}
data_curves &lt;- lapply(data_curves, rand_scale)
data_curves &lt;- lapply(data_curves, rand_rotate)

#compute smooth procrustes mean with 2 order penalty
knots &lt;- seq(0,1, length = 11)
elastic_shape_mean &lt;- compute_elastic_shape_mean(
    data_curves,
    knots = knots,
    type = "smooth",
    penalty = 2
    )
plot(elastic_shape_mean)
</code></pre>

<hr>
<h2 id='elastes-package'>elastes: Elastic Full Procrustes Means for Sparse and Irregular Planar Curves</h2><span id='topic+elastes'></span><span id='topic+elastes-package'></span>

<h3>Description</h3>

<p>Provides functions for the computation of functional elastic shape means over sets of open planar curves. The package is particularly suitable for settings where these curves are only sparsely and irregularly observed. It uses a novel approach for elastic shape mean estimation, where planar curves are treated as complex functions and a full Procrustes mean is estimated from the corresponding smoothed Hermitian covariance surface. This is combined with the methods for elastic mean estimation proposed in Steyer, Stöcker, Greven (2022) <a href="https://doi.org/10.1111/biom.13706">doi:10.1111/biom.13706</a>. See Stöcker et. al. (2022) <a href="https://arxiv.org/abs/2203.10522">arXiv:2203.10522</a> for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Manuel Pfeuffer <a href="mailto:manuel.pfeuffer@hu-berlin.de">manuel.pfeuffer@hu-berlin.de</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Lisa Steyer <a href="mailto:lisa.steyer@hu-berlin.de">lisa.steyer@hu-berlin.de</a>
</p>
</li>
<li><p> Almond Stoecker <a href="mailto:almond.stoecker@epfl.ch">almond.stoecker@epfl.ch</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mpff.github.io/elastes/">https://mpff.github.io/elastes/</a>
</p>
</li>
<li> <p><a href="https://github.com/mpff/elastes">https://github.com/mpff/elastes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mpff/elastes/issues">https://github.com/mpff/elastes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='fit_alignment_proc2d'>Optimal rotation and scaling alignment to a smooth curve</h2><span id='topic+fit_alignment_proc2d'></span>

<h3>Description</h3>

<p>Finds optimal rotation and scaling alignment for a discrete open srv curve to a smooth curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_alignment_proc2d(
  q,
  type,
  knots,
  var_type,
  coefs.compl,
  method,
  cov_fit,
  pca,
  L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_alignment_proc2d_+3A_q">q</code></td>
<td>
<p>complex srv curve with parametrization, needs to be vectorized.
The result of a call to <code>get_model_data_complex</code></p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_type">type</code></td>
<td>
<p>spline degree</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_knots">knots</code></td>
<td>
<p>basis knots</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_var_type">var_type</code></td>
<td>
<p>either &quot;smooth&quot; or &quot;constant&quot; measurement error in cov_fit object</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_coefs.compl">coefs.compl</code></td>
<td>
<p>complex coefficients of smooth curve</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_method">method</code></td>
<td>
<p>temp</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_cov_fit">cov_fit</code></td>
<td>
<p>temp</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_pca">pca</code></td>
<td>
<p>temp</p>
</td></tr>
<tr><td><code id="fit_alignment_proc2d_+3A_l">L</code></td>
<td>
<p>temp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal rotation G and scaling b
</p>

<hr>
<h2 id='fit_mean'>Mean estimation for open planar curves.</h2><span id='topic+fit_mean'></span>

<h3>Description</h3>

<p>Fits an elastic full Procrustes mean for open, planar curves.
Is usually called from <code><a href="#topic+compute_elastic_shape_mean">compute_elastic_shape_mean</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mean(
  srv_data_curves,
  knots,
  penalty,
  var_type,
  pfit_method,
  max_iter,
  type,
  eps,
  cluster,
  verbose,
  smooth_warp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mean_+3A_srv_data_curves">srv_data_curves</code></td>
<td>
<p>list of <code>data.frame</code>s with srv vectors in each row.curves</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_knots">knots</code></td>
<td>
<p>set of knots for the mean spline curve</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_penalty">penalty</code></td>
<td>
<p>the penalty to use in the covariance smoothing step. use '-1' for no penalty.</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_var_type">var_type</code></td>
<td>
<p>(experimental) assume &quot;smooth&quot;, &quot;constant&quot; or &quot;zero&quot; measurement-error variance along t</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_pfit_method">pfit_method</code></td>
<td>
<p>(experimental) &quot;smooth&quot; or &quot;polygon&quot;</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_max_iter">max_iter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_type">type</code></td>
<td>
<p>if &quot;smooth&quot; linear srv-splines are used which results in a differentiable mean curve
if &quot;polygon&quot; the mean will be piecewise linear.</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if L2 norm of coefficients changes less</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_cluster">cluster</code></td>
<td>
<p>a cluster object for use in the <code>bam</code> call</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_verbose">verbose</code></td>
<td>
<p>print iterations</p>
</td></tr>
<tr><td><code id="fit_mean_+3A_smooth_warp">smooth_warp</code></td>
<td>
<p>(experimental) controls the weighting of original and smoothed observations
over the iterations, if pfit_method == &quot;smooth&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with entries
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>&quot;smooth&quot; or &quot;polygon&quot;</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p><code>coefs</code> srv spline coefficients of the estimated mean</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>spline knots</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>penalty used in the covariance estimation</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>distances to mean</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a <code>list</code> containing
<code>t_optims</code>optimal parametrizations
<code>G_optims</code>optimal rotations
<code>b_optims</code>optimal scalings
<code>n_optims</code>optimal re-normalization
<code>n_iter</code>number of iterations until convergence
<code>gram</code> the mean basis Gram matrix,
<code>cov_fit</code> the covariance smoothing objects in the final iteration,
<code>cov_pca</code> cov coef matrix pca object in the final iteration and
<code>pfit_coefs</code> the mean basis coefs of smoothed pfits in the final iteration</p>
</td></tr>
</table>

<hr>
<h2 id='get_center'>Calculate the center of a curve</h2><span id='topic+get_center'></span>

<h3>Description</h3>

<p>Calculate the center of a curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_center(curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_center_+3A_curve">curve</code></td>
<td>
<p>a <code>data.frame</code> with observed points in each row. Each
variable is one coordinate direction. If there is a variable <code>t</code>,
<code>t_optim</code> or <code>id</code>, it is treated as the time parametrization, not
as an additional coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The average of observed points in <code>curve</code>.
</p>

<hr>
<h2 id='get_distance'>Distance to a smooth curve</h2><span id='topic+get_distance'></span>

<h3>Description</h3>

<p>Finds the distance of a discrete open srv curve to a smooth curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance(srv_curve, s, q, eps = 10 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_distance_+3A_srv_curve">srv_curve</code></td>
<td>
<p>srv transformation of the smooth curve, needs to be vectorized</p>
</td></tr>
<tr><td><code id="get_distance_+3A_s">s</code></td>
<td>
<p>time points for q, first has to be 0, last has to be 1</p>
</td></tr>
<tr><td><code id="get_distance_+3A_q">q</code></td>
<td>
<p>square root velocity vectors, one less than time points in s</p>
</td></tr>
<tr><td><code id="get_distance_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance between srv_curve and q
</p>

<hr>
<h2 id='get_evals'>Evaluate a curve on a grid</h2><span id='topic+get_evals'></span><span id='topic+get_evals.data.frame'></span><span id='topic+get_evals.elastic_shape_mean'></span>

<h3>Description</h3>

<p>Evaluate a curve on a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_evals(curve, t_grid = NULL, ...)

## S3 method for class 'data.frame'
get_evals(curve, t_grid = NULL, ...)

## S3 method for class 'elastic_shape_mean'
get_evals(curve, t_grid = NULL, centering = TRUE, srv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_evals_+3A_curve">curve</code></td>
<td>
<p>a one parameter function which is to be evaluated on a grid</p>
</td></tr>
<tr><td><code id="get_evals_+3A_t_grid">t_grid</code></td>
<td>
<p>the curve is evaluated at the values in t_grid, first value needs
to be 0, last value needs to be 1.
If t_grid = NULL, a default regular grid with grid length 0.01 is chosen</p>
</td></tr>
<tr><td><code id="get_evals_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="get_evals_+3A_centering">centering</code></td>
<td>
<p>TRUE if curves shall be centered</p>
</td></tr>
<tr><td><code id="get_evals_+3A_srv">srv</code></td>
<td>
<p>TRUE if SRV curve shall be evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with evaluations of the curve
at the values in <code>t_grid</code> in its rows.
</p>


<h3>See Also</h3>

<p>See <code><a href="elasdics.html#topic+get_evals">get_evals</a></code> for the original code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve &lt;- function(t){c(t*sin(10*t), t*cos(10*t))}
plot(get_evals(curve), type = "b")
</code></pre>

<hr>
<h2 id='get_optimal_t'>Finds optimal alignment for discrete open curves</h2><span id='topic+get_optimal_t'></span>

<h3>Description</h3>

<p>Finds optimal aligned time points for srv curve q to  srv curve p using
coordinate wise optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_optimal_t(srv_procrustes_curves, coefs, t_optims, type, knots, eps, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_optimal_t_+3A_srv_procrustes_curves">srv_procrustes_curves</code></td>
<td>
<p>scaling and rotation aligned srv curves</p>
</td></tr>
<tr><td><code id="get_optimal_t_+3A_coefs">coefs</code></td>
<td>
<p>mean coefficients</p>
</td></tr>
<tr><td><code id="get_optimal_t_+3A_t_optims">t_optims</code></td>
<td>
<p>current optimal parametrization</p>
</td></tr>
<tr><td><code id="get_optimal_t_+3A_type">type</code></td>
<td>
<p>&quot;smooth&quot; or &quot;polygon&quot;</p>
</td></tr>
<tr><td><code id="get_optimal_t_+3A_knots">knots</code></td>
<td>
<p>mean basis knots</p>
</td></tr>
<tr><td><code id="get_optimal_t_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance</p>
</td></tr>
<tr><td><code id="get_optimal_t_+3A_i">i</code></td>
<td>
<p>current iteration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal time points for srv_data_curves, without first value 0 and last value 1
optimal time points have the distance of the observation to the srv_curve as an attribute
</p>

<hr>
<h2 id='get_polygon_length'>Calculate the polygon length of a curve</h2><span id='topic+get_polygon_length'></span>

<h3>Description</h3>

<p>Calculate the polygon length of a curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_polygon_length(curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_polygon_length_+3A_curve">curve</code></td>
<td>
<p>a <code>data.frame</code> with observed points in each row. Each
variable is one coordinate direction. If there is a variable <code>t</code>,
<code>t_optim</code> or <code>id</code>, it is treated as the time parametrization, not
as an additional coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of <code>curve</code>, treating it as a polygon.
</p>

<hr>
<h2 id='get_procrustes_fit'>Get Procrustes data curve from mean object.</h2><span id='topic+get_procrustes_fit'></span>

<h3>Description</h3>

<p>Compute the Procrustes aligned data curve...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_procrustes_fit(data_curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_procrustes_fit_+3A_data_curve">data_curve</code></td>
<td>
<p>A <code>data.frame</code> in an <code>elastic_shape_mean</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aligned data_curve as a <code>data.frame</code>.
</p>

<hr>
<h2 id='get_Procrustes_fit_from_param'>Helper functions for calculating Procrustes data curve from rotation, scaling and translation parameters.</h2><span id='topic+get_Procrustes_fit_from_param'></span><span id='topic+get_procrustes_fit_from_param'></span>

<h3>Description</h3>

<p>Compute the Procrustes fit given optimal rotation, scaling and translation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_procrustes_fit_from_param(
  data_curve,
  rot,
  scale,
  plength,
  trans,
  norm_factor
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Procrustes_fit_from_param_+3A_data_curve">data_curve</code></td>
<td>
<p>A <code>data.frame</code> with observed points on a curve.
Each row is one point, each variable one coordinate direction. If there is a variable <code>t</code>,
it is treated as the time parametrization, not as an additional coordinate.</p>
</td></tr>
<tr><td><code id="get_Procrustes_fit_from_param_+3A_rot">rot</code></td>
<td>
<p>The rotation (in radian).</p>
</td></tr>
<tr><td><code id="get_Procrustes_fit_from_param_+3A_scale">scale</code></td>
<td>
<p>The scaling.</p>
</td></tr>
<tr><td><code id="get_Procrustes_fit_from_param_+3A_plength">plength</code></td>
<td>
<p>The polygon length of the original curve.</p>
</td></tr>
<tr><td><code id="get_Procrustes_fit_from_param_+3A_trans">trans</code></td>
<td>
<p>The translation.</p>
</td></tr>
<tr><td><code id="get_Procrustes_fit_from_param_+3A_norm_factor">norm_factor</code></td>
<td>
<p>The normalization factor from the smooth curve estimate.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.elastic_shape_mean'>Plot method for planar elastic Procrustes mean curves</h2><span id='topic+plot.elastic_shape_mean'></span>

<h3>Description</h3>

<p>Plots objects of class <code>elastic_shape_mean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_shape_mean'
plot(x, srv = FALSE, centering = TRUE, asp = 1, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elastic_shape_mean_+3A_x">x</code></td>
<td>
<p>object of class <code>elastic_shaped_mean</code>,
usually a result of a call to <code><a href="#topic+compute_elastic_shape_mean">compute_elastic_shape_mean</a></code></p>
</td></tr>
<tr><td><code id="plot.elastic_shape_mean_+3A_srv">srv</code></td>
<td>
<p>TRUE if the SRV curve should be plotted</p>
</td></tr>
<tr><td><code id="plot.elastic_shape_mean_+3A_centering">centering</code></td>
<td>
<p>TRUE if mean and pfits should be centered</p>
</td></tr>
<tr><td><code id="plot.elastic_shape_mean_+3A_asp">asp</code></td>
<td>
<p>numeric, giving the aspect ratio of the two coordinates,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.elastic_shape_mean_+3A_col">col</code></td>
<td>
<p>color of the mean curve.</p>
</td></tr>
<tr><td><code id="plot.elastic_shape_mean_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p>For examples see documentation of <code><a href="#topic+compute_elastic_shape_mean">compute_elastic_shape_mean</a></code>.
See <code><a href="elasdics.html#topic+plot.elastic_mean">plot.elastic_mean</a></code> for the original code.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
