<!DOCTYPE html><html lang="en"><head><title>Help for package hmmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hmmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hmmm-package'><p>package hmmm</p></a></li>
<li><a href='#accident'>
<p>factory accident data</p></a></li>
<li><a href='#akaike'><p> akaike criterium</p></a></li>
<li><a href='#anova.hmmmfit'><p>anova for the class hmmmfit</p></a></li>
<li><a href='#create.XMAT'><p>design matrix for a hmm model</p></a></li>
<li><a href='#depression'>
<p>longitudinal study of mental depression</p></a></li>
<li><a href='#drinks'>
<p>soft-drinks data</p></a></li>
<li><a href='#getnames'>
<p>vector of frequencies from a data frame</p></a></li>
<li><a href='#GMI'>
<p>Function  to compute the generalized marginal interactions associated to a hyerarchical family of marginal sets</p></a></li>
<li><a href='#hmmm.chibar'><p>chi-bar statistic test for hmm models</p></a></li>
<li><a href='#hmmm.mlfit'><p>fit a hmm model</p></a></li>
<li><a href='#hmmm.model'><p>define a hmm model</p></a></li>
<li><a href='#hmmm.model.X'><p>hmm model with covariates effect on parameters</p></a></li>
<li><a href='#inv_GMI'>
<p>Function to compute a vector of joint probabilities from a vector of generalizedmarginal interactions (GMI)</p></a></li>
<li><a href='#kentucky'><p>Kentucky traffic accident data</p></a></li>
<li><a href='#loglin.model'><p>define a log-linear model</p></a></li>
<li><a href='#madsen'><p>Madsen data</p></a></li>
<li><a href='#marg.list'><p> lists of marginal sets</p></a></li>
<li><a href='#mphineq.fit'><p>fit mph models under inequality constraints</p></a></li>
<li><a href='#polbirth'><p>political orientation and teenage birth control data</p></a></li>
<li><a href='#print.hmmmchibar'><p>print for hmmm.chibar</p></a></li>
<li><a href='#print.hmmmfit'><p>print for the class hmmmfit</p></a></li>
<li><a href='#recursive'>
<p>recursive marginal interactions</p></a></li>
<li><a href='#relpol'><p>religion and political orientation data</p></a></li>
<li><a href='#relpolbirth'><p>religion, political orientation and teenage birth control data</p></a></li>
<li><a href='#summary.hmmmchibar'><p>summary for hmmm.chibar</p></a></li>
<li><a href='#summary.hmmmfit'>
<p>summary for the class hmmmfit</p></a></li>
<li><a href='#summary.hmmmmod'><p>summary and print for the class hmmmmod</p></a></li>
<li><a href='#summary.mphfit'>
<p>summary and print for the class <code>mphfit</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Multinomial Marginal Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for specifying and fitting marginal models for contingency tables proposed by Bergsma and Rudas (2002) &lt;<a href="https://doi.org/10.1214%2Faos%2F1015362188">doi:10.1214/aos/1015362188</a>&gt; here called hierarchical multinomial marginal models (hmmm) and their extensions presented by Bartolucci, Colombi and Forcina (2007) <a href="https://www.jstor.org/stable/24307737">https://www.jstor.org/stable/24307737</a>; multinomial Poisson homogeneous (mph) models and homogeneous linear predictor (hlp) models for contingency tables proposed by Lang (2004) &lt;<a href="https://doi.org/10.1214%2Faos%2F1079120140">doi:10.1214/aos/1079120140</a>&gt; and Lang (2005) &lt;<a href="https://doi.org/10.1198%2F016214504000001042">doi:10.1198/016214504000001042</a>&gt;. Inequality constraints on the parameters are allowed and can be tested.</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, MASS, mvtnorm, nleqslv, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-09 10:27:29 UTC; rcolombi</td>
</tr>
<tr>
<td>Author:</td>
<td>Roberto Colombi [aut, cre],
  Sabrina Giordano [aut],
  Manuela Cazzaro [aut],
  Joseph Lang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roberto Colombi &lt;colombi@unibg.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 08:43:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='hmmm-package'>package hmmm</h2><span id='topic+hmmm-package'></span>

<h3>Description</h3>

<p>Functions for specifying and fitting marginal models for 
contingency tables proposed by Bergsma and Rudas (2002)
here called hierarchical multinomial marginal models (hmmm) and their extensions presented
by Bartolucci et al (2007); multinomial Poisson homogeneous (mph) models and homogeneous linear predictor (hlp) models for contingency 
tables proposed by Lang (2004, 2005); hidden Markov models where the distribution of the observed variables is described by a marginal model. 
Inequality constraints on the parameters are allowed and can be tested.</p>


<h3>Author(s)</h3>

<p>Roberto Colombi, Sabrina Giordano and Manuela Cazzaro. Joseph B. Lang is the author
of functions &lsquo;num.deriv.fct&rsquo;, &lsquo;create.U&rsquo; for mph models.</p>


<h3>References</h3>

<p>Bergsma WP, Rudas T (2002) 
Marginal models for categorical data. The Annals of Statistics, 30, 140-159
</p>
<p>Bartolucci F, Colombi R, Forcina A (2007) An extended class of marginal link functions for modelling contingency 
tables by equality and inequality constraints. Statistica Sinica, 17, 691-711
</p>
<p>Lang  JB (2004) Multinomial Poisson homogeneous models for contingency tables. The Annals of Statistics, 32, 340-383
</p>
<p>Lang JB (2005) Homogeneous linear predictor models for contingency tables. Journal of the American Statistical Association, 100, 121-134.
</p>

<hr>
<h2 id='accident'>
factory accident data
</h2><span id='topic+accident'></span>

<h3>Description</h3>

<p>Data on factory accidents occurred in Bergamo (Italy) in 1998, collected by the Inail (Italian institute for insurance against factory accidents): 1052 workers who suffered an accident and claimed for a compensation are classified according to the type of injury, the time to 
recover (number of working days lost), the age (years), 
and the solar hour (part of the day in which the accident occurred).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(accident)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>

<dl>
<dt><code>Type</code></dt><dd><p> A factor with levels: <code>uncertain</code>, <code>avoidable</code>, <code>not-avoidable</code></p>
</dd>
<dt><code>Time</code></dt><dd><p>A factor with levels: <code>0 |-- 7</code>, <code>7 |-- 21</code>, <code>21 |-- 60</code>, <code>&gt;= 60</code></p>
</dd>
<dt><code>Age</code></dt><dd><p>A factor with levels: <code>&lt;= 25</code>, <code>26 -- 45</code>, <code>&gt; 45</code></p>
</dd>
<dt><code>Hour</code></dt><dd><p>A factor with levels: <code>morning</code>, <code>afternoon</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>
 

<h3>Source</h3>

<p>Inail, Bergamo (Italy) 1998</p>


<h3>References</h3>

<p>Cazzaro M, Colombi R (2008) Modelling two way contingency tables with recursive logits and odds ratios. Statistical Methods and Applications, 17, 435-453.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(accident)</code></pre>

<hr>
<h2 id='akaike'> akaike criterium </h2><span id='topic+akaike'></span>

<h3>Description</h3>

<p>Compute AIC value for a list of hmm  models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>akaike(..., LRTEST = FALSE, ORDERED = FALSE, NAMES = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="akaike_+3A_...">...</code></td>
<td>
<p>objects  created by &lsquo;hmmm.mlfit&rsquo; or 
&lsquo;hidden.emfit&rsquo;
</p>
</td></tr>
<tr><td><code id="akaike_+3A_lrtest">LRTEST</code></td>
<td>

<p>If TRUE, the first model must include all the others models as special cases.
For every model, the  likelihood ratio statistic test with respect to the first model is computed
</p>
</td></tr>
<tr><td><code id="akaike_+3A_ordered">ORDERED</code></td>
<td>

<p>If TRUE, in the output the models are ordered according to the  Akaike criterium starting from the lowest AIC value
</p>
</td></tr>
<tr><td><code id="akaike_+3A_names">NAMES</code></td>
<td>

<p>Optional character vector with the names of the models. If it is NULL (the default) model names are created as model1, model2..... 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The models in input must be at least two objects of the classes <code>hmmmfit</code> or <code>hidden</code>.
</p>


<h3>Value</h3>

<p>A matrix with row names given by <code>NAMES</code> and column names describing the 
output for every model (position of the model in the input list <code>#model</code>, 
the loglikelihood function <code>loglik</code>, the number of parameters <code>npar</code>, 
the number of constraints of the model <code>dfmodel</code>, likelihood ratio test <code>LRTEST</code>, degrees of freedom <code>dftest</code>, <code>PVALUE</code>, <code>AIC</code>, <code>DELTAAIC</code>). The <code>DELTAAIC</code> is the difference between the AIC value of every model and the lowest AIC value.
</p>


<h3>References</h3>

<p>Konishi S, Kitagawa G (2008)
Information criteria and statistical modeling. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
# 1 = Influence; 2 = Satisfaction;  3 = Contact; 4 = Housing 
names&lt;-c("Inf","Sat","Co","Ho")
y&lt;-getnames(madsen,st=6)

margin &lt;- marg.list(c("marg-marg-l-l", "g-marg-l-l", "marg-g-l-l", "g-g-l-l"))

# additive effect of 3 and 4 on logits of 1 in marginal  
# distribution {1, 3, 4}, conditional independence 2_||_3|4 
modelA &lt;- hmmm.model(marg = margin, lev = c(3, 3, 2, 4), names = names)
modA &lt;- hmmm.mlfit(y, modelA)
modA

# additive effect of 3 and 4 on logits of 1 in marginal
# distributions {1, 3, 4} and {2, 3, 4}
modelB &lt;- hmmm.model(marg = margin, lev = c(3, 3, 2, 4),
names = names, sel = c(18:23, 34:39))
modB &lt;- hmmm.mlfit(y, modelB)
modB

# 1 and 2 do not depend on the levels of 3 and 4
modelC &lt;- hmmm.model(marg = margin, lev = c(3, 3, 2, 4),
names = names, sel = c(18:23, 34:39, 44:71))
modC &lt;- hmmm.mlfit(y, modelC)
modC

akaike(modB, modA, modC, ORDERED = TRUE, NAMES = c("modB", "modA", "modC"))
akaike(modA, modB, modC, LRTEST = TRUE, NAMES = c("modA", "modB", "modC"))</code></pre>

<hr>
<h2 id='anova.hmmmfit'>anova for the class hmmmfit</h2><span id='topic+anova.hmmmfit'></span>

<h3>Description</h3>

<p>The generic function &lsquo;anova&rsquo; is adapted to the objects inheriting from class <code>hmmmfit</code> 
(anova.hmmmfit) to compute the likelihood ratio test for nested hmm models estimated 
by &lsquo;hmmm.mlfit&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmmmfit'
anova(object,objectlarge,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.hmmmfit_+3A_object">object</code></td>
<td>
<p>Object of the class <code>hmmmfit</code>, reduced model, i.e. modelA</p>
</td></tr>
<tr><td><code id="anova.hmmmfit_+3A_objectlarge">objectlarge</code></td>
<td>
<p>Object of the class <code>hmmmfit</code>, large model, i.e. modelB</p>
</td></tr>
<tr><td><code id="anova.hmmmfit_+3A_...">...</code></td>
<td>
<p>Other models and further arguments passed to or from other methods</p>
</td></tr></table>


<h3>Details</h3>

<p>Nested models, fitted by &lsquo;hmmm.mlfit&rsquo;, are compared (e.g. modelA is nested in modelB), 
the likelihood ratio statistic with the degrees of freedom and 
the associated pvalue is printed.
</p>


<h3>Value</h3>

<p> A matrix with information about Likelihood ratio tests degree of freedom and P values for the compared models.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code>, <code><a href="#topic+summary.hmmmfit">summary.hmmmfit</a></code>, <code><a href="#topic+print.hmmmfit">print.hmmmfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
y&lt;-getnames(madsen)
names&lt;-c("Infl","Sat","Co","Ho")

fA&lt;-~Co*Ho+Sat*Co+Sat*Ho
modelA&lt;-loglin.model(lev=c(3,3,2,4),formula=fA,names=names)
fB&lt;-~Co*Ho+Sat*Co+Infl*Co+Sat*Ho+Infl*Sat
modelB&lt;-loglin.model(lev=c(3,3,2,4),formula=fB,names=names)

modA&lt;-hmmm.mlfit(y,modelA)
modB&lt;-hmmm.mlfit(y,modelB)

anova(modA,modB)
</code></pre>

<hr>
<h2 id='create.XMAT'>design matrix for a hmm model</h2><span id='topic+create.XMAT'></span>

<h3>Description</h3>

<p>Function to specify the matrix X of the linear predictor Cln(Mm)=Xbeta for a hmm model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.XMAT(model, Formula = NULL, 
strata = 1, fnames = NULL, cocacontr = NULL, 
ncocacontr = NULL, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.XMAT_+3A_model">model</code></td>
<td>
<p>Object created by  &lsquo;hmmm.model&rsquo;</p>
</td></tr>
<tr><td><code id="create.XMAT_+3A_formula">Formula</code></td>
<td>
<p>List of model-formulas; one formula for every marginal interaction</p>
</td></tr>
<tr><td><code id="create.XMAT_+3A_strata">strata</code></td>
<td>
<p>Number of categories of the factors that describe the strata</p>
</td></tr>
<tr><td><code id="create.XMAT_+3A_fnames">fnames</code></td>
<td>
<p>Names of the factors that describe the strata</p>
</td></tr>
<tr><td><code id="create.XMAT_+3A_cocacontr">cocacontr</code></td>
<td>
<p>A list of zero-one matrices to build &quot;r&quot; logits created by the function &lsquo;recursive&rsquo;</p>
</td></tr>
<tr><td><code id="create.XMAT_+3A_ncocacontr">ncocacontr</code></td>
<td>
<p>Number of contrasts for every factor, if NULL the maximum number is used</p>
</td></tr>
<tr><td><code id="create.XMAT_+3A_replace">replace</code></td>
<td>
<p>If TRUE a new model object with design matrix X is produced, if FALSE the list of design matrices associated to each element specified in Formula is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the marginal interactions of a hmm model are defined in terms of
a linear predictor of covariates Cln(Mm)=Xbeta, the list of model formulas defines additive effects of covariates on the interactions. 
In a case with 
two response variables declared by <code>names&lt;-c("A","B")</code>
and two covariates, named C and D by <code>fnames=c("C","D")</code>, the additive effect of the covariates 
on marginal logits of A and B and 
log odds ratios (A.B) of the two responses is specified by the following <code>Formula</code>:
<code>Formula&lt;-list(A=~A*(C+D), B=~B*(C+D), A.B=~A.B*(C+D))</code>. Use &quot;zero&quot; to constrain to zero all the interactions of a given type.
</p>


<h3>Value</h3>

<p>A list of matrices or a hmm model with X as design matrix according to the input argument <code>replace</code>. The parameters beta in 
the predictor Cln(Mm)=Xbeta are the effects specified in <code>Formula</code> and correspond to the columns of X.</p>


<h3>References</h3>

<p>Lang  JB (2004) Multinomial Poisson homogeneous models for contingency tables. The Annals of Statistics, 32, 340-383.
</p>
<p>Lang JB (2005) Homogeneous linear predictor models for contingency tables. Journal of the American Statistical 
Association, 100, 121-134.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code>, <code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code>, <code><a href="#topic+summary.hmmmfit">summary.hmmmfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(accident)
y&lt;-getnames(accident,st=9,sep=";")
# responses: 1 = Type, 2 = Time; covariates: 3 = Age, 4 = Hour

marglist&lt;-c("l-m","m-g","l-g")
marginals&lt;-marg.list(marglist,mflag="m")
names&lt;-c("Type","Time")

modelsat&lt;-hmmm.model(marg=marginals,lev=c(3,4),
strata=6, names=names) 

# Create X to account for additive effect of Age and Hour on the logits of Type and Time
# and constant association between Type and Time
al&lt;-list(Type=~Type*(Age+Hour),
Time=~Time*(Age+Hour),Type.Time=~Type.Time)
# list of matrices (replace=FALSE)
listmat&lt;-create.XMAT(modelsat,Formula=al,strata=c(3,2),fnames=c("Age","Hour"),replace=FALSE)

# the model obtained by the modified X (replace=TRUE)
model&lt;-create.XMAT(modelsat,Formula=al,strata=c(3,2),fnames=c("Age","Hour")) 
fitmodel&lt;-hmmm.mlfit(y,model,y.eps=0.00001,maxit=2000)
print(fitmodel)
</code></pre>

<hr>
<h2 id='depression'>
longitudinal study of mental depression</h2><span id='topic+depression'></span>

<h3>Description</h3>

<p>A longitudinal study comparing a new drug with a standard drug for treatment of 
340 subjects suffering mental depression (Koch et al., 1977, Agresti, 2013). The patients are classified according 
to the severity of the initial diagnosis (mild and severe), the treatment type they received (standard and new drugs)
and the responses on 
the depression assessment (normal and abnormal) at three occasions: after one week (R1), 
two (R2), and four weeks (R3) of treatment.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(depression)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>

<dl>
<dt><code>R3</code></dt><dd><p> A factor with levels: <code>N</code> as normal, <code>A</code> as abnormal</p>
</dd>
<dt><code>R2</code></dt><dd><p> A factor with levels: <code>N</code> as normal, <code>A</code> as abnormal</p>
</dd>
<dt><code>R1</code></dt><dd><p> A factor with levels: <code>N</code> as normal, <code>A</code> as abnormal</p>
</dd>
<dt><code>Treatment</code></dt><dd><p>A factor with levels: <code>standard</code>, <code>new drug</code></p>
</dd>
<dt><code>Diagnosis</code></dt><dd><p>A factor with levels: <code>mild</code>, <code>severe</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>
 

<h3>References</h3>

<p> Agresti A (2013) Categorical Data Analysis (third edition). Wiley.
</p>
<p>Koch GG,  Landis JR,  Freeman JL, Freeman DH and Lehnen RG  (1977) A general metodology for the analysis of experiments
with repeated measurement of categorical data. Biometrics, 38, 563-595.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(depression)
</code></pre>

<hr>
<h2 id='drinks'>
soft-drinks data</h2><span id='topic+drinks'></span>

<h3>Description</h3>

<p>A one-year categorical time series of daily sales of soft-drinks.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(drinks)</code></pre>


<h3>Format</h3>

<p>A five-variate time series of sale levels of soft-drinks on 269 days
</p>

<dl>
<dt><code>lemon.tea</code></dt><dd><p>A factor with levels: 1 = low, 2 = medium, 3 = high</p>
</dd>
<dt><code>orange.juice</code></dt><dd><p>A factor with levels: 1 = low, 2 = medium, 3 = high</p>
</dd>
<dt><code>apple.juice</code></dt><dd><p>A factor with levels: 1 = low, 2 = medium, 3 = high</p>
</dd>
<dt><code>mint.tea</code></dt><dd><p>A factor with levels: 1 = low, 2 = high</p>
</dd>
<dt><code>soya.milk</code></dt><dd><p>A factor with levels: 1 = low, 2 = high</p>
</dd>
</dl>



<h3>References</h3>

<p>Colombi R, Giordano S (2011) Lumpability for discrete hidden Markov models. Advances in Statistical Analysis, 95(3), 293-311.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drinks)</code></pre>

<hr>
<h2 id='getnames'>
vector of frequencies from a data frame
</h2><span id='topic+getnames'></span>

<h3>Description</h3>

<p>Function to extract the vector of frequencies associated with the category names from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnames(dat, st = 3, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getnames_+3A_dat">dat</code></td>
<td>
<p>A contingency table in data frame format</p>
</td></tr>
<tr><td><code id="getnames_+3A_st">st</code></td>
<td>
<p>Length of the string for every category name</p>
</td></tr>
<tr><td><code id="getnames_+3A_sep">sep</code></td>
<td>
<p>Separator of category names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a column vector of the frequencies of every combination of categories
of the involved variables in the data frame <code>dat</code> where each column corresponds to a variable,
each row to a combination of categories and the last column reports the frequencies. The variables
are arranged so that the farther to the left the 
column is the faster the category changes. Every frequency of each combination of categories is associated with a string of short
category names. The length of the names is determined by setting <code>st</code> and
consecutive names are separated by the symbol declared by <code>sep</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
y&lt;-getnames(madsen,st=3,sep=";")</code></pre>

<hr>
<h2 id='GMI'>
Function  to compute the generalized marginal interactions associated to a hyerarchical family of marginal sets
</h2><span id='topic+GMI'></span>

<h3>Description</h3>

<p>Given a vector of joint probabilities the generalized marginal interactions (gmi) associated to a hyerarchical family of marginal sets are computed
If the input is a matrix gmi are computed for every column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GMI(freq, marg, lev, names, mflag = "M")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GMI_+3A_freq">freq</code></td>
<td>

<p>matrix of joint probabilities. Every column describes a joint pdf.
</p>
</td></tr>
<tr><td><code id="GMI_+3A_marg">marg</code></td>
<td>

<p>A character vector  decribing  the marginal sets and the logits used to build the interactions See the help of marg.list 
</p>
</td></tr>
<tr><td><code id="GMI_+3A_lev">lev</code></td>
<td>
<p> number of categories of the categorical variables. See the help of hmmm.model 
</p>
</td></tr>
<tr><td><code id="GMI_+3A_names">names</code></td>
<td>
<p> names of the categorical variables
</p>
</td></tr>
<tr><td><code id="GMI_+3A_mflag">mflag</code></td>
<td>

<p>The symbol used to denote variables that are marginalized, default &quot;M&quot;
See marg.list
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components: marginals and gmi; marginals is a legend that explains the interactions, gmi is a vector or a matrix that contains the interactions
</p>


<h3>Author(s)</h3>

<p>R. Colombi
</p>


<h3>References</h3>

<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y&lt;-c(50,36, 15,15,13,15,84,60,42,35,6,26,105,113,57,5,
  26,62,465,334,4,10,34,186,1404)
lev&lt;-c(5,5)
marg&lt;-c("g-m","m-g","g-g")
names&lt;-c("H","S")
o&lt;-GMI(cbind(c(y),c(y/sum(y))),marg,lev,names,mflag="m")
o
</code></pre>

<hr>
<h2 id='hmmm.chibar'>chi-bar statistic test for hmm models</h2><span id='topic+hmmm.chibar'></span>

<h3>Description</h3>

<p>Function to calculate weights and pvalues of a chi-bar-square distributed statistic
for testing hypotheses of inequality constraints on parameters of hmm models.
The models in input are objects inheriting from class <code>hmmmfit</code> or <code>mphfit</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmm.chibar(nullfit, disfit, satfit, repli = 6000, 
kudo = FALSE, TESTAB = FALSE, 
alpha = c(0.02,0.03,0), pesi = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmmm.chibar_+3A_nullfit">nullfit</code></td>
<td>
<p>The estimated model with inequalities turned into equalities</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_disfit">disfit</code></td>
<td>
<p>The estimated model with inequalities</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_satfit">satfit</code></td>
<td>
<p>The estimated model without inequalities</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_repli">repli</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_kudo">kudo</code></td>
<td>
<p>If TRUE, the chi-bar weights are not simulated but  computed by the Kudo's method</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_testab">TESTAB</code></td>
<td>
<p>If TRUE, the LR tuned testing procedure is performed (see Details)</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_alpha">alpha</code></td>
<td>
<p>Three significance levels c(alpha1, alpha2, alpha12) of the LR tuned testing procedure</p>
</td></tr>
<tr><td><code id="hmmm.chibar_+3A_pesi">pesi</code></td>
<td>
<p>The chi-bar weights if they are known</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the 3 argument models must be obtained by &lsquo;hmmm.mlfit&rsquo; or by &lsquo;mphineq.fit&rsquo;.
The method &quot;Simulation 2&quot; described in Silvapulle and Sen, 2005, pg. 79 is used if <code>kudo = FALSE</code>, otherwise the Kudo's exact method is used
as described by El Barmi and Dykstra (1999). The Kudo's method can be reasonably used with less than 10-15 inequalities.
If TESTA is the LR statistics  for <code>nullfit</code>  against the <code>disfit</code> model
while TESTB  is the LR statistics for <code>disfit</code> against the <code>satfit</code> model then 
the LR tuned testing procedure (Colombi and Forcina, 2013) runs as follows:
accept <code>nullfit</code> if TESTB &lt; y2 and TESTA &lt; y1,
where 
Pr(TESTB &gt; y2) = alpha2-alpha12 and  Pr(TESTA &lt; y1, TESTB &lt; y2) = 1-alpha1-alpha2,
reject <code>nullfit</code>  in favour of <code>disfit</code>  if TESTA &gt; y1 and
TESTB &lt; y12, where Pr(TESTA &gt; y1, TESTB &lt; y12) = alpha1,
otherwise reject <code>nullfit</code> for <code>satfit</code>.
</p>


<h3>Value</h3>

<p>A list with the statistics test of type A and B (Silvapulle and Sen, 2005, pg. 61) 
and their pvalues. If <code>TESTAB = TRUE</code> details on the LR tuned testing procedure (Colombi and Forcina, 2013) are reported.
</p>


<h3>References</h3>

<p> Colombi R. Forcina A. (2013) Testing order restrictions in contingency tables. Submitted.
</p>
<p>El Barmi H, Dykstra R (1999) Likelihood ratio test against a set of inequality constraints. 
Journal of Nonparametric Statistics, 11, 233-261. 
</p>
<p>Silvapulle MJ, Sen PK (2005) Constrained statistical
inference, Wiley, New Jersey.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.hmmmchibar">summary.hmmmchibar</a></code>, <code><a href="#topic+print.hmmmchibar">print.hmmmchibar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(polbirth)
# 1 = Politics; 2 = Birthcontrol
y&lt;-getnames(polbirth,st=12,sep=";")                     
names&lt;-c("Pol","Birth")
marglist&lt;-c("l-m","m-l","l-l")
marginals&lt;-marg.list(marglist,mflag="m")
ineq&lt;-list(marg=c(1,2),int=list(c(1,2)),types=c("l","l"))

# definition of the model with inequalities on interactions in ineq
model&lt;-hmmm.model(marg=marginals,dismarg=list(ineq),lev=c(7,4),names=names)

# saturated model
msat&lt;-hmmm.mlfit(y,model)

# model with non-negative local log-odds ratios: "Likelihood ratio monotone dependence model"
mlr&lt;-hmmm.mlfit(y,model,noineq=FALSE)

# model with null local log-odds ratios: "Stochastic independence model"
model0&lt;-hmmm.model(marg=marginals,lev=c(7,4),sel=c(10:27),names=names)
mnull&lt;-hmmm.mlfit(y,model0)

# HYPOTHESES TESTED:
#     testA --&gt; H0=(mnull model) vs H1=(mlr model)
#     testB --&gt; H0=(mlr model) vs H1=(msat model)

P&lt;-hmmm.chibar(nullfit=mnull,disfit=mlr,satfit=msat)
summary(P)</code></pre>

<hr>
<h2 id='hmmm.mlfit'>fit a hmm model</h2><span id='topic+hmmm.mlfit'></span>

<h3>Description</h3>

<p>Function to estimate a hierarchical multinomial marginal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmm.mlfit(y, model, noineq = TRUE, maxit = 1000, 
norm.diff.conv = 1e-05, norm.score.conv = 1e-05,
y.eps = 0, chscore.criterion = 2,
m.initial = y, mup = 1, step = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmmm.mlfit_+3A_y">y</code></td>
<td>
<p>A vector of frequencies of the contingency table</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_model">model</code></td>
<td>
<p>An object created by &lsquo;hmmm.model&rsquo;</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_noineq">noineq</code></td>
<td>
<p>If TRUE inequality constraints specified in the model are ignored</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_norm.diff.conv">norm.diff.conv</code></td>
<td>
<p>Convergence criterium value on the parameters</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_norm.score.conv">norm.score.conv</code></td>
<td>
<p>Convergence criterium value on the constraints</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_y.eps">y.eps</code></td>
<td>
<p>Non-negative constant to be  added 
to the original counts in y</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_chscore.criterion">chscore.criterion</code></td>
<td>
<p>If equal to zero, convergence
information are printed at every iteration</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_m.initial">m.initial</code></td>
<td>
<p>Initial estimate of m (expected frequencies)</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_mup">mup</code></td>
<td>
<p> Weight for the constraints penalty part of the merit function</p>
</td></tr>
<tr><td><code id="hmmm.mlfit_+3A_step">step</code></td>
<td>
<p>Interval length for the line search</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sequential quadratic procedure is used to maximize the log-likelihood function
under inequality and equality constraints. 
This function calls the procedure &lsquo;mphineq.fit&rsquo;  which is a generalization of the procedure
&lsquo;mph.fit&rsquo; by Lang (2004).</p>


<h3>Value</h3>

<p>An object of the class <code>hmmmfit</code>; an estimate of a marginal model defined by &lsquo;hmmm.model&rsquo;.
The output can be displayed using &lsquo;summary&rsquo; or &lsquo;print&rsquo;.</p>


<h3>References</h3>

<p> Bartolucci F, Colombi R, Forcina A (2007) An extended class of marginal link 
functions for modelling contingency tables by equality
and inequality constraints. Statistica Sinica, 17, 691-711.
</p>
<p>Bergsma WP, Rudas T (2002) Marginal models for categorical data. The Annals of Statistics, 30, 140-159. 
</p>
<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>
<p>Lang  JB (2004) Multinomial Poisson homogeneous models for contingency tables. The Annals of Statistics, 32, 340-383.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code>, <code><a href="#topic+hmmm.model.X">hmmm.model.X</a></code>, <code><a href="#topic+summary.hmmmfit">summary.hmmmfit</a></code>, <code><a href="#topic+print.hmmmfit">print.hmmmfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(relpol)
y&lt;-getnames(relpol,st=12)
# 1 = Religion, 2 = Politics
names&lt;-c("Rel","Pol")
marglist&lt;-c("l-m","m-g","l-g")
marginals&lt;-marg.list(marglist,mflag="m")

# Hypothesis of stochastic independence: all log odds ratios are null 
model&lt;-hmmm.model(marg=marginals,lev=c(3,7),sel=c(9:20),names=names)
fitmodel&lt;-hmmm.mlfit(y,model)
print(fitmodel, aname="Independence model",printflag=TRUE)
summary(fitmodel)

</code></pre>

<hr>
<h2 id='hmmm.model'>define a hmm model</h2><span id='topic+hmmm.model'></span>

<h3>Description</h3>

<p>Function to define a hierarchical multinomial marginal model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmm.model(marg = NULL, dismarg = 0, lev, cocacontr = NULL, strata = 1,
Z = NULL, ZF = Z, X = NULL, D = NULL, E = NULL, 
names = NULL, formula = NULL, sel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmmm.model_+3A_marg">marg</code></td>
<td>

<p>A list of the marginal sets and their  marginal interactions as
described in Bartolucci et al. (2007). See below</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_dismarg">dismarg</code></td>
<td>
<p>Similar to marg but used to define inequalities Kln(Am)&gt;0. Default 0 if there are no
inequalities</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_lev">lev</code></td>
<td>
<p>Number of categories of the variables</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_cocacontr">cocacontr</code></td>
<td>
<p>A list of zero-one matrices to build &quot;r&quot; logits
created by the function &lsquo;recursive&rsquo;</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_strata">strata</code></td>
<td>

<p>Number of strata defined by the combination of the categories of the covariates</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_z">Z</code></td>
<td>

<p>Zero-one matrix describing the strata</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_zf">ZF</code></td>
<td>

<p>Zero-one matrix for strata with fixed number of observations</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_x">X</code></td>
<td>

<p>Design matrix for Cln(Mm)=Xbeta. Identity matrix if not declared.  
It can be defined later or changed only  by using the function &lsquo;create.XMAT&rsquo;</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_d">D</code></td>
<td>

<p>If the matrix D is declared, the inequalities are expressed as  DKln(Am)&gt;0.
Useful for changing the sign of inequalities 
or for selecting a subset of inequalities</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_e">E</code></td>
<td>
<p>If E is a matrix, then E defines the equality contrasts as
ECln(Mm)=0</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_names">names</code></td>
<td>
<p>A character vector whose elements are the names of the variables
</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_formula">formula</code></td>
<td>

<p>Formula of the reference log-linear model</p>
</td></tr>
<tr><td><code id="hmmm.model_+3A_sel">sel</code></td>
<td>

<p>Vector reporting the positions of the interactions constrained to be zero</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables are denoted by integers, the lower the number identifying the variable 
the faster its category subscript changes in the vectorized contingency table. Suppose that the variables are 1 and 2 
with categories k_1, k_2, the joint frequencies yij, where i=1,...,k_1, j=1,...,k_2, 
are arranged in a vector so that the subscript i changes faster than j. If <code>strata</code> is greater than one, the
vectorized contingency tables must be entered strata by strata. So that, for example, if the variables are distinguished in 
responses and covariates, the categories of the covariates determine the strata and the data are arranged 
in such a way that the categories of the response variable changes faster than the categories of covariate. The names of the variables in <code>names</code> must be declared according to the order of the variables.  
</p>
<p>The list <code>marg</code> of the marginal sets of a complete hierarchical marginal parameterization, together with the types of logits for the variables,
must be  created by the function &lsquo;marg.list&rsquo;. See the help of this function for more details.
If <code>marg</code> is not specified the multivariate logit model by Glonek and McCullagh (1995) 
with interactions of type local is used. The list  <code>marg</code> is used to create the link function 
Cln(Mm) and its derivative (m is the vector of expected frequencies).
</p>
<p>If the model is defined in the form Cln(Mm) = Xbeta, the matrix X 
has to be declared (see the function &lsquo;create.XMAT&rsquo;). If there are only nullity constraints on parameters, the model is in the form ECln(Mm)=0 and X is ignored. In such a case, E can be declared as matrix or it is automatically constructed if <code>sel</code> is declared. If <code>sel</code> is not NULL, then the model is defined under equality constraints, i.e. ECln(Mm)=0.
When <code>X</code>, <code>E</code> and <code>sel</code> are left at default level, a saturated model is defined.  
</p>
<p>For models with inequality constraints on marginal parameters, the input argument <code>dismarg</code> is declared as a list whose components are of type: <code>list(marg=c(1,2),int=list(c(1),c(1,2)),</code> <code>types=c("g","l" ))</code>, with elements
<code>marg</code>: the marginal set, <code>int</code>: the list of the interaction subject to inequality constraint, and <code>types</code>: the logit 
used for every variable (&quot;g&quot;=global, &quot;l&quot;=local, &quot;c&quot;=continuation, &quot;rc&quot;=reverse continuation, 
&quot;r&quot;=recursive, &quot;b&quot;=baseline, &quot;marg&quot; is assigned  to each variable not belonging 
to the marginal set).  This list is used to create the link function 
Cln(Mm) and its derivative for the inequality constraints. 
</p>
<p>The matrix Z is of dimension c x s, where c is the number of counts 
and s is the number of strata or populations. 
Thus, the rows correspond to the number of observations  and 
the columns correspond to the strata.  A 1 in 
row i and column j means that the ith count comes 
from the jth stratum.  Note that Z has exactly 
one 1 in each row, and at least one 1 in each 
column.  When the population matrix Z 
is a column vector of 1 indicates that all 
the counts come from the same and only stratum.
For hmm models, it is assumed that all 
the strata have  the same number of response levels. 
If Z is not given, a population Z matrix corresponding 
to data entered by <code>strata</code> is defined and ZF=Z. 
For non-zero ZF, the columns 
are a subset of the columns in Z.
If the jth column of Z is included in ZF, then the 
sample size of the jth stratum is considered fixed, otherwise
if the jth column of Z is NOT included in ZF, the 
jth stratum sample size is taken to be a realization 
of a Poisson random variable.  As ZF=Z the sample size in every stratum 
is fixed; this 
is the (product-)multinomial setting.  
</p>
<p>The formula  of the reference log-linear model must be defined using the names of the variables declared in <code>names</code>, for example
<code>names&lt;-c("A","B","C","D")</code>, <code>formula=~A*C*D+B*C*D+A:B</code>. The interactions not involved in <code>formula</code> cannot be further constrained in 
the marginal model. The default <code>formula = NULL</code> indicates the saturated log-linear model as reference model.
The likelihood function of the reference model is maximized by &lsquo;hmmm.mlfit&rsquo; under the constraints ECln(Mm)=0 on the marginal parameters.
</p>
<p>The arguments <code>dismarg</code> and <code>formula</code> can be used only if <code>strata=1</code>.</p>


<h3>Value</h3>

<p>An object of the class <code>hmmmmod</code>; it describes a marginal model that can be estimated by &lsquo;hmmm.mlfit&rsquo;.
</p>


<h3>References</h3>

<p>Bartolucci F, Colombi R, Forcina A (2007) An extended class of marginal link functions for modelling
contingency tables by equality and inequality constraints. Statistica Sinica, 17, 691-711.
</p>
<p>Bergsma WP, Rudas T (2002) Marginal models for categorical data. 
The Annals of Statistics, 30, 140-159.
</p>
<p>Cazzaro M, Colombi R (2009) Multinomial-Poisson models subject to inequality 
constraints. Statistical Modelling, 9(3), 215-233.
</p>
<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>
<p>Glonek GFV, McCullagh P (1995) Multivariate logistic models for
contingency tables. Journal of the Royal Statistical Society, B, 57, 533-546.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model.X">hmmm.model.X</a></code>, <code><a href="#topic+create.XMAT">create.XMAT</a></code>, <code><a href="#topic+summary.hmmmmod">summary.hmmmmod</a></code>, <code><a href="#topic+print.hmmmmod">print.hmmmmod</a></code>, 
<code><a href="#topic+marg.list">marg.list</a></code>, <code><a href="#topic+recursive">recursive</a></code>, <code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
# 1 = Influence; 2 = Satisfaction;  3 = Contact; 4 = Housing 
names&lt;-c("Inf","Sat","Co","Ho")
y&lt;-getnames(madsen,st=6)

# hmm model -- marginal sets: {3,4} {1,3,4} {2,3,4} {1,2,3,4}
margi&lt;-c("m-m-l-l","l-m-l-l","m-l-l-l","l-l-l-l")
marginals&lt;-marg.list(margi,mflag="m")
model&lt;-hmmm.model(marg=marginals,lev=c(3,3,2,4),names=names)
summary(model)

# hmm model with equality constraints
# independencies 1_||_4|3 and 2_||_3|4 impose equality constraints 
sel&lt;-c(12:23,26:27,34:39) # positions of the zero-constrained interactions 
model_eq&lt;-hmmm.model(marg=marginals,lev=c(3,3,2,4),sel=sel,names=names)
summary(model_eq)

# hmm model with inequality constraints
# the distribution of 1 given 4 is stochastically decreasing wrt the categories of 3;
# the distribution of 2 given 3 is stochastically decreasing wrt the categories of 4:
marg134ineq&lt;-list(marg=c(1,3,4),int=list(c(1,3)),types=c("l","marg","l","l"))
marg234ineq&lt;-list(marg=c(2,3,4),int=list(c(2,4)),types=c("marg","l","l","l"))
ineq&lt;-list(marg134ineq,marg234ineq)
model_ineq&lt;-hmmm.model(marg=marginals,lev=c(3,3,2,4),dismarg=ineq,D=diag(-1,8),names=names)
summary(model_ineq)
# The argument D is used to turn the 8 inequalities from 
# non-negative (default) into non-positive constraints</code></pre>

<hr>
<h2 id='hmmm.model.X'>hmm model with covariates effect on parameters</h2><span id='topic+hmmm.model.X'></span>

<h3>Description</h3>

<p>Function to define a hmm model whose parameters depend on covariates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmm.model.X(marg, lev, names, Formula = NULL, strata = 1, 
fnames = NULL, cocacontr = NULL, ncocacontr = NULL, replace=TRUE)
</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="hmmm.model.X_+3A_marg">marg</code></td>
<td>
<p>A list of the marginal sets and their  marginal interactions as
described in Bartolucci et al. (2007). See details of <code>hmmm.model</code></p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_lev">lev</code></td>
<td>
<p>Number of categories of the response variables</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_names">names</code></td>
<td>
<p>A character vector whose elements are the names of the response variables</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_formula">Formula</code></td>
<td>
<p>List of model-formulas; one formula for every marginal interaction</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_strata">strata</code></td>
<td>
<p>Number of categories of the covariates that describe the strata</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_fnames">fnames</code></td>
<td>
<p>Names of the covariates that describe the strata</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_cocacontr">cocacontr</code></td>
<td>
<p>A list of zero-one matrices to build &quot;r&quot; logits created by the function &lsquo;recursive&rsquo;</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_ncocacontr">ncocacontr</code></td>
<td>
<p>Number of contrasts for every covariate, if NULL the maximum number is used</p>
</td></tr>
<tr><td><code id="hmmm.model.X_+3A_replace">replace</code></td>
<td>
<p>If TRUE a new model object with design matrix X is produced, if FALSE the list of design matrices associated to each element specified in Formula is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>names</code> and <code>fnames</code> report the names of responses and covariates according to the order in which the variables are declared, see details of function &lsquo;hmmm.model&rsquo;. 
</p>
<p>When the marginal interactions of a hmm model are defined in terms of
a linear predictor of covariates Cln(Mm)=Xbeta, the list of model formulas defines additive effects of covariates on the interactions. 
In a case with 
two response variables declared by <code>names&lt;-c("A","B")</code>
and two covariates, named C and D by <code>fnames=c("C","D")</code>, the additive effect of the covariates 
on marginal logits of A and B and 
log odds ratios (A.B) of the two responses is specified by the following <code>Formula</code>:
<code>Formula&lt;-list(A=~A*(C+D), B=~B*(C+D), A.B=~A.B*(C+D))</code>. Use &quot;zero&quot; to constrain to zero all the interactions of a given type. The saturated model is the default if <code>Formula</code> is not specified.
</p>


<h3>Value</h3>

<p>An object of the class <code>hmmmmod</code>; it describes a marginal model with effects of covariates on the interactions. This model can be estimated by &lsquo;hmmm.mlfit&rsquo;.</p>


<h3>References</h3>

<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>
<p>Glonek GFV, McCullagh P (1995) Multivariate logistic models for
contingency tables. Journal of the Royal Statistical Society, B, 57, 533-546.
</p>
<p>Marchetti GM, Lupparelli M (2011) Chain graph models of multivariate regression type for categorical data. Bernoulli, 17, 827-844.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code>, <code><a href="#topic+create.XMAT">create.XMAT</a></code>, <code><a href="#topic+summary.hmmmmod">summary.hmmmmod</a></code>, <code><a href="#topic+print.hmmmmod">print.hmmmmod</a></code>, 
<code><a href="#topic+marg.list">marg.list</a></code>, <code><a href="#topic+recursive">recursive</a></code>, <code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(accident)
y&lt;-getnames(accident,st=9,sep=";")
# responses: 1 = Type, 2 = Time; covariates: 3 = Age, 4 = Hour

marginals&lt;-marg.list(c("b-marg","marg-g","b-g"))
al&lt;-list(
Type=~Type*(Age+Hour),
Time=~Time*(Age+Hour),
Type.Time=~Type.Time*(Age+Hour)
)
# model with additive effect of the covariates on logits and log-o.r. of the responses
model&lt;-hmmm.model.X(marg=marginals,lev=c(3,4),names=c("Type","Time"),
Formula=al,strata=c(3,2),fnames=c("Age","Hour"))
mod&lt;-hmmm.mlfit(y,model,y.eps=0.1)
</code></pre>

<hr>
<h2 id='inv_GMI'>
Function to compute a vector of joint probabilities from a vector of generalizedmarginal interactions (GMI)
</h2><span id='topic+inv_GMI'></span>

<h3>Description</h3>

<p> Given an hmmm model and the vector of its  generalized interactions eta
the vector of joint probabilities p is  computed by inverting
eta=C*ln(M*p)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_GMI(etpar, mod, start = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_GMI_+3A_etpar">etpar</code></td>
<td>

<p>vector of GMI
</p>
</td></tr>
<tr><td><code id="inv_GMI_+3A_mod">mod</code></td>
<td>

<p>hmmm model corresponding to etapar; an object of class hmmmod created by hmmm.model
</p>
</td></tr>
<tr><td><code id="inv_GMI_+3A_start">start</code></td>
<td>

<p>starting values for log-liner parameters in the non linear equations problem
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of joint probabilities
</p>


<h3>Author(s)</h3>

<p>Colombi R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p4&lt;-c(
0.0895, 0.0351 ,0.0004, 0.0003, 0.0352, 0.2775, 0.0619, 0.0004, 0.0004, 0.0620, 0.2775,
0.0351 ,0.0001,
0.0004, 0.0352 ,0.089)

marg&lt;-marg.list(c("l-m","m-l","l-l"), mflag="m") 
labelrisp&lt;-c("R1","R2")
modello&lt;-hmmm.model(marg=marg,lev=c(4,4),names=labelrisp)
etpar&lt;-GMI(c(p4),c("l-m","m-l","l-l"),c(4,4),labelrisp,mflag="m")
etpar$gmi
p4rec&lt;-inv_GMI(etpar$gmi,modello)
P&lt;-cbind(p4rec,c(p4),c(p4)-p4rec)
colnames(P)&lt;-c("prob","prob from eta","check")
P
</code></pre>

<hr>
<h2 id='kentucky'>Kentucky traffic accident data</h2><span id='topic+kentucky'></span>

<h3>Description</h3>

<p>The traffic accident data collected by the Kentucky State Police from 1995 to 1999. 
The annual numbers of vehicle occupants involved in Kentucky accidents are classified according to 3 
variables: injury, restraint usage and year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kentucky)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>
<dl>
<dt><code>Injury</code></dt><dd><p>A factor with levels: <code>1</code> = not injured; <code>2</code> = possible injury;
<code>3</code> = nonincapacitating injury;  <code>4</code> = incapacitating injury;  <code>5</code> = killed</p>
</dd>
<dt><code>Restraint.usage</code></dt><dd><p>A factor with levels: <code>yes</code> = restraint used, <code>no</code> = restraint not used</p>
</dd>
<dt><code>Year</code></dt><dd><p><code>1995</code>, <code>1996</code>, <code>1997</code>, <code>1998</code>, <code>1999</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>


<h3>Source</h3>

<p>www.kentuckystatepolice.org/text/data.htm</p>


<h3>References</h3>

<p>Lang JB (2005) Homogeneous linear predictor models for contingency tables. 
Journal of the American Statistical Association, 100, 121-134.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kentucky)</code></pre>

<hr>
<h2 id='loglin.model'>define a log-linear model</h2><span id='topic+loglin.model'></span>

<h3>Description</h3>

<p>Function to specify a hierarchical log-linear model. This is a particular case of a hmm model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglin.model(lev, int = NULL, strata = 1, dismarg = 0, type = "b", 
D = TRUE, c.gen = TRUE, printflag = FALSE, names = NULL, formula = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglin.model_+3A_lev">lev</code></td>
<td>
<p>Vector of number of categories of variables</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_int">int</code></td>
<td>
<p>Generating class of the log-linear model (must be a list) or list of all the interactions included</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_strata">strata</code></td>
<td>
<p>Number of strata</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_dismarg">dismarg</code></td>
<td>
<p>List of interactions constrained by inequalities - see &lsquo;hmmm.model&rsquo;</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_type">type</code></td>
<td>
<p>&quot;b&quot; for baseline logits, &quot;l&quot; for local logits</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_d">D</code></td>
<td>
<p>Input argument for inequalities - see &lsquo;hmmm.model&rsquo;</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_c.gen">c.gen</code></td>
<td>
<p>If FALSE the input int must be the list of the minimal interaction sets to be excluded</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_printflag">printflag</code></td>
<td>
<p>If TRUE information on the included and excluded interactions are given</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_names">names</code></td>
<td>
<p>A character vector whose elements are the names of the variables</p>
</td></tr>
<tr><td><code id="loglin.model_+3A_formula">formula</code></td>
<td>
<p>A formula describing a log-linear model</p>
</td></tr></table>


<h3>Details</h3>

<p>This function simplifies &lsquo;hmmm.model&rsquo; in the case of log-linear models. If <code>formula</code> is employed, <code>c.gen</code> and <code>int</code> 
must not be declared while <code>names</code> must be specified.</p>


<h3>Value</h3>

<p>An object of the class <code>hmmmmod</code> defining a log-linear model that can be estimated by &lsquo;hmmm.mlfit&rsquo;.</p>


<h3>Note</h3>

<p>If <code>int</code> and <code>formula</code> are not supplied a saturated log-linear model is defined. For log-linear models where the parameters 
depend on covariates first define a saturated log-linear model and then use the function &lsquo;create.XMAT&rsquo;.
</p>


<h3>References</h3>

<p>Agresti A (2012) Categorical data Analysis, (3ed), Wiley, New York.
</p>
<p>Bergsma W, Croon M, Hagenaars JA (2009) Marginal Models for Dependent, Clustered, and Longitudinal Categorical Data. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code>, <code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code>, <code><a href="#topic+create.XMAT">create.XMAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
y&lt;-getnames(madsen)
names&lt;-c("Infl","Sat","Co","Ho")

f&lt;-~Co*Ho+Sat*Co+Infl*Co+Sat*Ho+Infl*Sat
model&lt;-loglin.model(lev=c(3,3,2,4),formula=f,names=names)
mod&lt;-hmmm.mlfit(y,model,maxit=3000)
print(mod,printflag=TRUE)
</code></pre>

<hr>
<h2 id='madsen'>Madsen data</h2><span id='topic+madsen'></span>

<h3>Description</h3>

<p>The dataset concerns 1681 rental property residents classified according to their 
satisfaction from the house, perceived influence on the management of the property,  type of rental accommodation, 
and contact with other residents.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(madsen)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>
<dl>
<dt><code>Influence</code></dt><dd><p>A factor with levels: <code>low</code>, <code>medium</code>, <code>high</code></p>
</dd>
<dt><code>Satisfaction</code></dt><dd><p>A factor with levels: <code>low</code>, <code>medium</code>, <code>high</code></p>
</dd>
<dt><code>Contact</code></dt><dd><p>A factor with levels: <code>low</code>, <code>high</code></p>
</dd>
<dt><code>Housing</code></dt><dd><p>A factor with levels: <code>tower block</code>, <code>apartment</code>, <code>atrium house</code>, <code>terraced house</code></p>
</dd>
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>


<h3>References</h3>

<p>Madsen M (1976) Statistical analysis of multiple contingency tables. Two examples. 
Scandinavian Journal of Statistics, 3, 97-106. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
</code></pre>

<hr>
<h2 id='marg.list'> lists of marginal sets</h2><span id='topic+marg.list'></span>

<h3>Description</h3>

<p>An easy option to define the first input argument 
<code>marg</code> of the function &lsquo;hmmm.model&rsquo; which specifies the list of marginal sets of a hmm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg.list(all.m, sep = "-", mflag = "marg")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marg.list_+3A_all.m">all.m</code></td>
<td>
<p>A character vector with one element for every marginal set, see below</p>
</td></tr>
<tr><td><code id="marg.list_+3A_sep">sep</code></td>
<td>
<p> The separator used between logits type, default &quot;-&quot; </p>
</td></tr>
<tr><td><code id="marg.list_+3A_mflag">mflag</code></td>
<td>
<p>The symbol used to denote variables that are marginalized, default &quot;marg&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>all.m</code> is a string indicating the logit types used to build the interactions 
in each marginal set. For each variable in the marginal set the corresponding logit symbol is inserted 
(&quot;b&quot; baseline, &quot;g&quot; global, &quot;c&quot; continuation, &quot;rc&quot; 
reverse continuation, &quot;r&quot; recursive, &quot;l&quot; local). Symbols are separated 
by <code>sep</code> and the variables not included in the marginal set are denoted by <code>mflag</code>.
So, for example, &quot;marg-g-c&quot; indicates a marginal set involving variables 2, 3 with global and continuation logits respectively.</p>


<h3>Value</h3>

<p>The list <code>marg</code> used as first input argument in &lsquo;hmmm.model&rsquo; &ndash; see the function &lsquo;hmmm.model&rsquo;.</p>


<h3>Note</h3>

<p>This function creates the complete list of the interactions that can be
defined in a marginal set. Therefore, it cannot be used to specify only the
interactions subject to inequality constraints. When inequalities are involved in the model, marginal sets and types of logits are declared as illustrated in the details of function &lsquo;hmmm.model&rsquo;.</p>


<h3>References</h3>

<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(madsen)
marginals&lt;-c("m-m-b-b","g-m-b-b","m-g-b-b","g-g-b-b")
margi&lt;-marg.list(marginals,mflag="m")
names&lt;-c("Inf","Sat","Co","Ho")
model&lt;-hmmm.model(marg=margi,lev=c(3,3,2,4),names=names)
print(model)
</code></pre>

<hr>
<h2 id='mphineq.fit'>fit mph models under inequality constraints</h2><span id='topic+mphineq.fit'></span>

<h3>Description</h3>

<p>Function to maximize the log-likelihood function of multinomial Poisson homogeneous (mph) models
under nonlinear equality and inequality constraints.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mphineq.fit(y, Z, ZF = Z, h.fct = 0, derht.fct = 0, d.fct = 0,
derdt.fct = 0, L.fct = 0, derLt.fct = 0, X = NULL, formula = NULL, 
names = NULL, lev = NULL, E = NULL, maxiter = 100, 
step = 1, norm.diff.conv = 1e-05, norm.score.conv = 1e-05, 
y.eps = 0, chscore.criterion = 2, m.initial = y, mup = 1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mphineq.fit_+3A_y">y</code></td>
<td>
<p>Vector of frequencies of the multi-way table</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_z">Z</code></td>
<td>
<p>Population matrix. The population matrix Z is a c x s zero-one matrix, where c is the number of counts 
and s is the number of strata or populations. Thus, the rows correspond to the number of observations  and 
the columns correspond to the strata.  A 1 in row i and column j means that the ith count comes 
from the jth stratum.  Note that Z has exactly one 1 in each row, and at least one 1 in each 
column.  When Z = matrix(1,length(y),1) is a column vector of 1, all 
the counts come from the same and only stratum.</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_zf">ZF</code></td>
<td>
<p>Sample constraints matrix. For non-zero ZF, if the columns are a subset of the columns in the population matrix Z,
then the sample size of the jth stratum is considered fixed, 
otherwise if the jth column of Z is NOT included in ZF, the jth stratum sample size is taken to be a realization 
of a Poisson random variable.  When ZF=0, all of the stratum sample sizes are taken to be realizations of
Poisson random variables.  The default, ZF=Z, means that all the stratum sample sizes are fixed; this 
is the (product-)multinomial setting.  Note that ZF'y = n is the vector of fixed sample sizes</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_h.fct">h.fct</code></td>
<td>
<p>Function h(m) of equality constraints, m is the vector of expected frequencies. This function of m must return a vector</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_derht.fct">derht.fct</code></td>
<td>
<p>Derivative of h(m), if not supplied numerical derivative are used</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_d.fct">d.fct</code></td>
<td>
<p>Function for inequality constraints d(m)&gt;0. This function of m must return a vector</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_derdt.fct">derdt.fct</code></td>
<td>
<p>Derivative of d(m), if not supplied numerical derivative are used</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_l.fct">L.fct</code></td>
<td>
<p>Link function for the linear model L(m)=Xbeta</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_derlt.fct">derLt.fct</code></td>
<td>
<p>Derivative of L(m), if not supplied numerical derivative are used</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_x">X</code></td>
<td>
<p>Model matrix for L(m)=Xbeta</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_formula">formula</code></td>
<td>
<p>Formula of the reference log-linear model</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_names">names</code></td>
<td>
<p>A character vector whose elements are the names of the variables</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_lev">lev</code></td>
<td>
<p>Number of categories of the variables</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_e">E</code></td>
<td>
<p>If E is a matrix, then X is ignored and E defines the equality contrasts as
EL(m)=0</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_step">step</code></td>
<td>
<p> Interval length for the linear search</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_norm.diff.conv">norm.diff.conv</code></td>
<td>
<p>Convergence criterium for parameters</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_norm.score.conv">norm.score.conv</code></td>
<td>
<p>Convergence criterium for constraints</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_y.eps">y.eps</code></td>
<td>
<p> Non-negative constant to be temporarily added to the original frequencies in y</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_chscore.criterion">chscore.criterion</code></td>
<td>
<p>If zero, convergence information are printed at every iteration</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_m.initial">m.initial</code></td>
<td>
<p>Initial estimate of m</p>
</td></tr>
<tr><td><code id="mphineq.fit_+3A_mup">mup</code></td>
<td>
<p>Weight for the constraint part of the merit function</p>
</td></tr></table>


<h3>Details</h3>

<p>This function extends &lsquo;mph.fit&rsquo; written by JB Lang, Dept of Statistics and Actuarial Science
University of Iowa, in order to include inequality constraints.
In particular, the Aitchison Silvey (AS) algorithm has been replaced by a sequential 
quadratic algorithm which is equivalent to AS when inequalities are not present.
The R functions &lsquo;quadprog&rsquo; and &lsquo;optimize&rsquo; have been used to implement 
the sequential quadratic algorithm.
More precisely, the AS updating formulas are replaced 
by an equality-inequality constrained quadratic programming problem.
The &lsquo;mph.fit&rsquo; step halving linear search is replaced by an optimal
step length search performed by &lsquo;optimize&rsquo;. 
</p>


<h3>Value</h3>

<p>An object of the class <code>mphineq</code>, an estimate of a Multinomial Homogeneous Poisson Model.
The output can be displayed using &lsquo;summary&rsquo; or &lsquo;print&rsquo;.</p>


<h3>References</h3>

<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>
<p>Lang  JB (2004) Multinomial Poisson homogeneous models for contingency tables. The Annals of Statistics, 32, 340-383.
</p>
<p>Lang JB (2005) Homogeneous linear predictor models
for contingency tables. Journal of the American Statistical Association, 100, 121-134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.mphfit">print.mphfit</a></code>, <code><a href="#topic+summary.mphfit">summary.mphfit</a></code>, <code><a href="#topic+hmmm.model">hmmm.model</a></code>, <code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(104,24,65,76,146,30,50,9,166) # Table 2 (Lang, 2004)
y &lt;- matrix(y,9,1)

# population matrix: 3 strata with 3 observations each
Z &lt;- kronecker(diag(3),matrix(1,3,1))
# the 3rd stratum sample size is fixed
ZF &lt;- kronecker(diag(3),matrix(1,3,1))[,3]

########################################################################
# Let (i,j) be a cross-citation, where i is the citing journal and j is 
# the cited journal. Let m_ij be the expected counts of cross-citations.
# The Gini concentrations of citations for each of the journals are: 
# G_i = sum_j=1_3 (m_ij/m_i+)^2  for i=1,2,3.

 
Gini&lt;-function(m) {
 A&lt;-matrix(m,3,3,byrow=TRUE)
 GNum&lt;-rowSums(A^2)
 GDen&lt;-rowSums(A)^2
 G&lt;-GNum/GDen
 c(G[1],G[2],G[3])-c(0.410,0.455,0.684)
 }



# HYPOTHESIS: no change in Gini concentrations
# from the 1987-1989 observed values

mod_eq &lt;- mphineq.fit(y,Z,ZF,h.fct=Gini)

print(mod_eq)

# Example of MPH model subject to inequality constraints


# HYPOTHESIS: increase in Gini concentrations
# from the 1987-1989 observed values

mod_ineq &lt;- mphineq.fit(y,Z,ZF,d.fct=Gini)


# Reference model: model without inequalities --&gt; saturated model
mod_sat &lt;-mphineq.fit(y,Z,ZF)


# HYPOTHESES TESTED:
# NB: testA --&gt; H0=(mod_eq) vs H1=(mod_ineq model)
# testB --&gt; H0=(mod_ineq model) vs H1=(sat_mod model)

hmmm.chibar(nullfit=mod_eq,disfit=mod_ineq,satfit=mod_sat)
</code></pre>

<hr>
<h2 id='polbirth'>political orientation and teenage birth control data</h2><span id='topic+polbirth'></span>

<h3>Description</h3>

<p>Data on political orientation and opinion on teenage birth control of a sample of 911 U.S. citizens.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(polbirth)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>
<dl>
<dt><code>Politics</code></dt><dd><p>A factor with levels: <code>Extremely liberal</code>, <code>Liberal</code>, <code>Slightly liberal</code>, <code>Moderate</code>,
<code>Slightly conservative</code>, <code>Conservative</code>, <code>Extremely conservative</code></p>
</dd>
<dt><code>Birthcontrol</code></dt><dd><p>A factor with levels: <code>Strongly agree</code>, <code>Agree</code>, <code>Disagree</code>, <code>Strongly disagree</code></p>
</dd> 
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>


<h3>Details</h3>

<p>This is a sub-data frame obtained by marginalizing the data frame &lsquo;relpolbirth&rsquo;
with respect to the variable religion.</p>


<h3>Source</h3>

<p>General Social Survey, 1993.</p>


<h3>References</h3>

<p>Bergsma W, Croon M, Hagenaars JA (2009) Marginal Models for Dependent, Clustered, and Longitudinal Categorical Data. Springer.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(polbirth)</code></pre>

<hr>
<h2 id='print.hmmmchibar'>print for hmmm.chibar</h2><span id='topic+print.hmmmchibar'></span>

<h3>Description</h3>

<p>Function to print the results for tests of type A and B (Silvapulle and Sen, 2005) on 
inequality constraints.
The generic function &lsquo;print&rsquo; 
is adapted to the objects inheriting from class <code>hmmmchibar</code> (print.hmmmchibar).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmmmchibar'
print(x,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hmmmchibar_+3A_x">x</code></td>
<td>
<p>An object of the class <code>hmmmchibar</code></p>
</td></tr>
<tr><td><code id="print.hmmmchibar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It provides the output
of the function &lsquo;hmmm.chibar&rsquo;, that is the results of testing models defined by &lsquo;hmmm.model&rsquo; and
estimated 
by &lsquo;hmmm.mlfit&rsquo;, with equality and inequality constraints on marginal interactions. The statistics test of type A and B and 
their pvalues are tabulated. If <code>TESTAB = TRUE</code> when the function &lsquo;hmmm.chibar&rsquo; is called, the output of the LR tuned testing procedure (Colombi and Forcina, 2013) 
is displayed.</p>


<h3>Note</h3>

<p>Use &lsquo;summary&rsquo; to display a much detailed output.</p>


<h3>References</h3>

<p>Colombi R. Forcina A. (2013) Testing order restrictions in contingency tables. Submitted
</p>
<p>Silvapulle MJ, Sen PK (2005) Constrained statistical
inference, Wiley, New Jersey.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.chibar">hmmm.chibar</a></code>, <code><a href="#topic+summary.hmmmchibar">summary.hmmmchibar</a></code></p>

<hr>
<h2 id='print.hmmmfit'>print for the class hmmmfit</h2><span id='topic+print.hmmmfit'></span>

<h3>Description</h3>

<p>The generic function &lsquo;print&rsquo; is adapted to the objects inheriting from class <code>hmmmfit</code> 
(print.hmmmfit) to display the results of the estimation of a hmm model by &lsquo;hmmm.mlfit&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmmmfit'
print(x, aname = " ", printflag = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hmmmfit_+3A_x">x</code></td>
<td>
<p>An object of the class <code>hmmmfit</code>, i.e. a result of &lsquo;hmmm.mlfit&rsquo;</p>
</td></tr>
<tr><td><code id="print.hmmmfit_+3A_aname">aname</code></td>
<td>
<p>The name of the fitted object model</p>
</td></tr>
<tr><td><code id="print.hmmmfit_+3A_printflag">printflag</code></td>
<td>
<p>If FALSE only the goodness-of-fit test is displayed,
if TRUE the estimates of the interaction parameters are also returned</p>
</td></tr>
<tr><td><code id="print.hmmmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr></table>


<h3>Details</h3>

<p>The printed output provides the likelihood ratio statistic test to assess the fitting of the model estimated by &lsquo;hmmm.mlfit&rsquo;.
Degrees of freedom and pvalues are meaningful only for the hmm models without inequality constraints (see &lsquo;hmmm.chibar&rsquo; to 
test hmm models defined under inequality constraints on interactions). 
Moreover, if <code>printflag</code> is TRUE, the estimated interactions are displayed for every stratum, together with 
the marginal sets where they are defined and the type of logits considered.
</p>


<h3>Value</h3>

<p>No return value</p>


<h3>Note</h3>

<p>Use &lsquo;summary&rsquo; to display a much detailed output.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code>, <code><a href="#topic+summary.hmmmfit">summary.hmmmfit</a></code>, <code><a href="#topic+anova.hmmmfit">anova.hmmmfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(relpol)
y&lt;-getnames(relpol,st=12)
# 1 = Religion, 2 = Politics
names&lt;-c("Rel","Pol")
marglist&lt;-c("l-m","m-g","l-g")
marginals&lt;-marg.list(marglist,mflag="m")

# Hypothesis of stochastic independence: all log odds ratios are null 
model&lt;-hmmm.model(marg=marginals,lev=c(3,7),sel=c(9:20),names=names)
fitmodel&lt;-hmmm.mlfit(y,model)
print(fitmodel,aname="independence model",printflag=TRUE)
# summary(fitmodel)
</code></pre>

<hr>
<h2 id='recursive'>
recursive marginal interactions
</h2><span id='topic+recursive'></span>

<h3>Description</h3>

<p>A function to define logits of recursive (or nested) type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recursive(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recursive_+3A_...">...</code></td>
<td>
<p>As many inputs as there are variables in the multi-way table. Each input is a matrix of values -1,0,1 to define recursive logits or 0 for logits of different type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used when logits of type &quot;r&quot; are used for at least one variable.
An input argument for each categorical variable is necessary. Inputs are ordered according
to the order of the variables.
</p>
<p>For a categorical variable with k categories, k-1 recursive logits can be defined using a matrix 
with k-1 rows and k columns. 
The rows of this matrix specify the categories whose probabilities constitute numerator and 
denominator of every recursive logit. Specifically,  
in every row, a value among -1,0,1 is associated to every category: value 1 (-1) corresponds to the category whose probability 
is cumulated at the numerator (denominator), 0 if the 
category is not involved.</p>


<h3>Value</h3>

<p>A zero-one matrix to be assigned to the <code>cocacontr</code> input argument in defining a model by &lsquo;hmmm.model&rsquo; when logits &quot;r&quot; 
are used for at least one variable in the multi-way table.
</p>


<h3>References</h3>

<p>Cazzaro M, Colombi R (2008) Modelling two way contingency tables with recursive logits and odds ratios. Statistical Methods and Applications, 17, 435-453.
</p>
<p>Cazzaro M, Colombi R (2013)
Marginal nested interactions for contingency tables. Communications in Statistics - Theory and Methods, to appear.
</p>
<p>Colombi R, Giordano S, Cazzaro M (2014) hmmm: An R Package for hierarchical multinomial marginal models. Journal of Statistical Software, 59(11), 1-25, URL http://www.jstatsoft.org/v59/i11/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code>, <code><a href="#topic+create.XMAT">create.XMAT</a></code>, <code><a href="#topic+hmmm.model.X">hmmm.model.X</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kentucky)
# 1 = injury 2 = restraint 3 = year
y&lt;-getnames(kentucky,st=4)

marglist&lt;-marg.list(c("m-m-l","m-l-l","r-l-l"),mflag="m")
R1&lt;-matrix(c(1,1,1,-1,-1,
             0,0,0,1,-1,
             1,1,-1,0,0,
             1,-1,0,0,0),4,5,byrow=TRUE)
# logits of recursive (or nested) type for variable 1:
# log p(injury&lt;=3)/p(injury&gt;3); log p(injury=4)/p(injury=5);
# log p(injury&lt;=2)/p(injury=3); log p(injury=1)/p(injury=2);
rec&lt;-recursive(R1,0,0) # only variable 1 has recursive logits 

# additive effect of variables 2,3 on the recursive logits of variable 1
model&lt;-hmmm.model(marg=marglist,lev=c(5,2,5),sel=c(34:49),cocacontr=rec)
mod&lt;-hmmm.mlfit(y,model)
print(mod,printflag=TRUE)
</code></pre>

<hr>
<h2 id='relpol'>religion and political orientation data</h2><span id='topic+relpol'></span>

<h3>Description</h3>

<p>Data on religion and political orientation of a sample of 911 U.S. citizens.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(relpol)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>
<dl>
<dt><code>Religion</code></dt><dd><p>A factor with levels: <code>Protestant</code>, <code>Catholic</code>, <code>None</code></p>
</dd>
<dt><code>Politics</code></dt><dd><p>A factor with levels: <code>Extremely liberal</code>, <code>Liberal</code>, <code>Slightly liberal</code>, <code>Moderate</code>,
<code>Slightly conservative</code>, <code>Conservative</code>, <code>Extremely conservative</code></p>
</dd> 
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>


<h3>Details</h3>

<p>This is a sub-data frame obtained by marginalizing the data frame &lsquo;relpolbirth&rsquo;
with respect to the variable opinion on teenage birth control.</p>


<h3>Source</h3>

<p>General Social Survey, 1993</p>


<h3>References</h3>

<p>Bergsma W, Croon M, Hagenaars JA (2009) Marginal models for dependent, clustered, and longitudinal categorical data. Springer.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(relpol)</code></pre>

<hr>
<h2 id='relpolbirth'>religion, political orientation and teenage birth control data</h2><span id='topic+relpolbirth'></span>

<h3>Description</h3>

<p>Data on religion, political orientation and opinion on teenage birth control of a sample of 911 U.S. citizens.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(relpolbirth)</code></pre>


<h3>Format</h3>

<p>A data frame whose columns contain:
</p>
<dl>
<dt><code>Religion</code></dt><dd><p>A factor with levels: <code>Protestant</code>, <code>Catholic</code>, <code>None</code></p>
</dd>
<dt><code>Politics</code></dt><dd><p>A factor with levels: <code>Extremely liberal</code>, <code>Liberal</code>, <code>Slightly liberal</code>, <code>Moderate</code>,
<code>Slightly conservative</code>, <code>Conservative</code>, <code>Extremely conservative</code></p>
</dd>
<dt><code>Birthcontrol</code></dt><dd><p>A factor with levels: <code>Strongly agree</code>, <code>Agree</code>, <code>Disagree</code>, <code>Strongly disagree</code></p>
</dd> 
<dt><code>Freq</code></dt><dd><p>A numeric vector of frequencies</p>
</dd></dl>


<h3>Source</h3>

<p>General Social Survey, 1993</p>


<h3>References</h3>

<p>Bergsma W, Croon M, Hagenaars JA (2009) Marginal models for dependent, clustered, and longitudinal categorical data. Springer.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(relpolbirth)</code></pre>

<hr>
<h2 id='summary.hmmmchibar'>summary for hmmm.chibar</h2><span id='topic+summary.hmmmchibar'></span>

<h3>Description</h3>

<p>Function to print the results for tests of type A and B (Silvapulle and Sen, 2005) on inequality constraints and to 
tabulate the chi-bar distribution functions of the statistics test.
The generic function &lsquo;summary&rsquo;
is adapted to the objects inheriting from class <code>hmmmchibar</code> (summary.hmmmchibar).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmmmchibar'
summary(object, plotflag = 1, step = 0.01, lsup = 0,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hmmmchibar_+3A_object">object</code></td>
<td>
<p>An object of the class <code>hmmmchibar</code></p>
</td></tr>
<tr><td><code id="summary.hmmmchibar_+3A_plotflag">plotflag</code></td>
<td>
<p>1 to print only pvalues and statistic values,
2 to display the survival functions for type A and type B statistics tests and 3 to provide 
a plot of the survival functions (red: type B, black: type A)</p>
</td></tr>
<tr><td><code id="summary.hmmmchibar_+3A_step">step</code></td>
<td>
<p> Distance between points at which the distribution functions are evaluated</p>
</td></tr>
<tr><td><code id="summary.hmmmchibar_+3A_lsup">lsup</code></td>
<td>
<p> Distribution functions are evaluated in the interval 0 - lsup</p>
</td></tr>
<tr><td><code id="summary.hmmmchibar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It provides the output
of the function &lsquo;hmmm.chibar&rsquo;, that is the results of testing models defined by &lsquo;hmmm.model&rsquo; and
estimated 
by &lsquo;hmmm.mlfit&rsquo;, with equality and inequality constraints on marginal interactions. 
The statistics test of type A and B, their pvalues and the chi-bar distribution functions 
are tabulated. If <code>TESTAB = TRUE</code> when the function &lsquo;hmmm.chibar&rsquo; is called, the output of the LR tuned testing procedure (Colombi and Forcina, 2013) 
is displayed.</p>


<h3>Note</h3>

<p>Use &lsquo;print&rsquo; for a short output.</p>


<h3>References</h3>

<p>Colombi R. Forcina A. (2013) Testing order restrictions in contingency tables. Submitted
</p>
<p>Silvapulle MJ, Sen PK (2005) Constrained statistical
inference, Wiley, New Jersey.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.chibar">hmmm.chibar</a></code>, <code><a href="#topic+print.hmmmchibar">print.hmmmchibar</a></code></p>

<hr>
<h2 id='summary.hmmmfit'>
summary for the class hmmmfit
</h2><span id='topic+summary.hmmmfit'></span>

<h3>Description</h3>

<p>The generic function &lsquo;summary&rsquo; is adapted to the objects inheriting from class <code>hmmmfit</code> 
(summary.hmmmfit) to display the results of the estimation of a hmm model by &lsquo;hmmm.mlfit&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmmmfit'
summary(object, cell.stats = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hmmmfit_+3A_object">object</code></td>
<td>
<p>An object of the class <code>hmmmfit</code>, i.e. a result of &lsquo;hmmm.mlfit&rsquo;</p>
</td></tr>
<tr><td><code id="summary.hmmmfit_+3A_cell.stats">cell.stats</code></td>
<td>
<p>If TRUE cell-specific statistics are returned</p>
</td></tr><tr><td><code id="summary.hmmmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr></table>


<h3>Details</h3>

<p>The marginal interactions of a hmm model can be defined in terms of linear predictor of covariates Cln(Mm)=Xbeta, where
the X matrix is specified by &lsquo;create.XMAT&rsquo; and 
the parameters beta indicate the additive effects of covariate on the marginal interactions. 
The function &lsquo;hmmm.mlfit&rsquo; estimates either the parameters beta and the interactions; the function &lsquo;summary&rsquo; of a fitted model 
(by &lsquo;hmmm.mlfit&rsquo;) returns the estimated betas and the estimated interactions, while the function &lsquo;print&rsquo; provides the 
estimated interactions only. If the model is defined under  equality constraints ECln(Mm)=0, parameters betas are meaningless so they are not printed. 
</p>
<p>The printed output of &lsquo;summary&rsquo; provides: 1. values of the likelihood ratio and
Pearson's score statistics, degrees of freedom and pvalues. Note that degrees of freedom and pvalues are meaningful only for 
the hmm models without inequality constraints (see &lsquo;hmmm.chibar&rsquo; to test hmm models defined under inequality constraints on interactions); 
2. the linear predictor model results: estimated betas, standard errors, z-ratios, pvalues; estimated interactions, 
standard errors, residuals; 3. cell-specific statistics: 
observed and predicted frequencies of the multi-way table, estimated joint probabilities with standard errors, adjusted residuals; 
4. convergence statistics.</p>


<h3>Value</h3>

<p>No return value</p>


<h3>Note</h3>

<p>Use &lsquo;print&rsquo; to display only the goodness-of-fit test and the estimated interactions.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.mlfit">hmmm.mlfit</a></code>, <code><a href="#topic+print.hmmmfit">print.hmmmfit</a></code>, <code><a href="#topic+anova.hmmmfit">anova.hmmmfit</a></code>, <code><a href="#topic+create.XMAT">create.XMAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(relpol)
y&lt;-getnames(relpol,st=12,sep=";")
# 1 = Religion, 2 = Politics
names&lt;-c("Rel","Pol")
marglist&lt;-c("l-m","m-g","l-g")
marginals&lt;-marg.list(marglist,mflag="m")

# Hypothesis of stochastic independence: all log odds ratios are null 
model&lt;-hmmm.model(marg=marginals,lev=c(3,7),sel=c(9:20),names=names)
fitmodel&lt;-hmmm.mlfit(y,model)
# print(fitmodel,aname="Independence model",printflag=TRUE)
summary(fitmodel)
</code></pre>

<hr>
<h2 id='summary.hmmmmod'>summary and print for the class hmmmmod</h2><span id='topic+summary.hmmmmod'></span><span id='topic+print.hmmmmod'></span>

<h3>Description</h3>

<p>The generic functions &lsquo;summary&rsquo; and &lsquo;print&rsquo; are adapted to the objects inheriting from class <code>hmmmod</code>
(summary.hmmmmod, print.hmmmmod) to display the summary of a model defined by &lsquo;hmmm.model&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmmmmod'
summary(object,...)
## S3 method for class 'hmmmmod'
print(x,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hmmmmod_+3A_object">object</code>, <code id="summary.hmmmmod_+3A_x">x</code></td>
<td>
<p>An object of the class <code>hmmmod</code>, i.e. a result of &lsquo;hmmm.model&rsquo;</p>
</td></tr>
<tr><td><code id="summary.hmmmmod_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr></table>


<h3>Details</h3>

<p>The output provides the list of interactions and the marginal distributions where those 
interactions are defined. The names of the involved variables are displayed 
if <code>names</code> is not NULL. For every interaction, the logit type used for each variable 
in the interaction set and the number of parameters are indicated. 
The last two columns give the position of the parameters in the vector
where all the interactions are arranged.</p>


<h3>Value</h3>

<p>No return value</p>


<h3>Note</h3>

<p>Functions &lsquo;summary&rsquo; and &lsquo;print&rsquo; display the same output.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmm.model">hmmm.model</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>marginals&lt;-marg.list(c("g-m","m-l","g-l"),mflag="m")
model&lt;-hmmm.model(marg=marginals,lev=c(3,7),names=c("A","B"))
summary(model) </code></pre>

<hr>
<h2 id='summary.mphfit'>
summary and print for the class <code>mphfit</code>
</h2><span id='topic+summary.mphfit'></span><span id='topic+print.mphfit'></span>

<h3>Description</h3>

<p>The generic functions &lsquo;summary&rsquo; and &lsquo;print&rsquo; are adapted to the objects inheriting from class <code>mphfit</code>
(summary.mphfit, print.mphfit) to display the results of the estimation of a mph model by &lsquo;mphineq.fit&rsquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mphfit'
summary(object, ...)
## S3 method for class 'mphfit'
print(x,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mphfit_+3A_object">object</code>, <code id="summary.mphfit_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>mphfit</code>, i.e. a result of &lsquo;mphineq.fit&rsquo;</p>
</td></tr>
<tr><td><code id="summary.mphfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr></table>


<h3>Details</h3>

<p>The output of &lsquo;summary&rsquo; provides: 1. the goodness-of-fit of the estimated model tested by the likelihood ratio and
Pearson's Score Statistics, degrees of freedom and pvalues. Note that degrees of freedom and pvalues are meaningful only for 
the mph models without inequality constraints; 
2. cell-specific statistics: 
observed and predicted frequencies of the multi-way table, estimated joint probabilities with standard errors, adjusted residuals.</p>


<h3>Value</h3>

<p>No return value</p>


<h3>Note</h3>

<p>Use &lsquo;print&rsquo; to display only the goodness-of-fit test.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mphineq.fit">mphineq.fit</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
