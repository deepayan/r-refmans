<!DOCTYPE html><html lang="en"><head><title>Help for package HiGarrote</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HiGarrote}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blood_glucose'><p>Blood Glucose Experiment</p></a></li>
<li><a href='#cast_fatigue'><p>Cast Fatigue Experiment</p></a></li>
<li><a href='#HiGarrote'><p>An Automatic Method for the Analysis of Experiments using Hierarchical Garrote</p></a></li>
<li><a href='#nnGarrote'><p>Nonnegative Garrote Method with Hierarchical Structures</p></a></li>
<li><a href='#router_bit'><p>Router Bit Experiment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonnegative Garrote Method Incorporating Hierarchical
Relationships</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Yang Yu [aut, cre],
  V. Roshan Joseph [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Yang Yu &lt;wyu322@gatech.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the nonnegative garrote method that incorporates hierarchical relationships among variables. The core function, HiGarrote(), offers an automated approach for analyzing experiments while respecting hierarchical structures among effects. For methodological details, refer to Yu and Joseph (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2411.01383">doi:10.48550/arXiv.2411.01383</a>&gt;. This work is supported by U.S. National Science Foundation grant DMS-2310637.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, matrixcalc, MaxPro, nloptr, purrr, quadprog, Rcpp (&ge;
1.0.12), RcppArmadillo, rlist, scales, stringr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-29 19:16:47 UTC; weiyang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-30 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blood_glucose'>Blood Glucose Experiment</h2><span id='topic+blood_glucose'></span>

<h3>Description</h3>

<p>Hamada and Wu (1992) analyzed an 18-run experiment designed to study blood glucose readings of a clinical testing device.
The experiment contains one two-level factor and seven three-level quantitative factors, which are denoted by A through H.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(blood_glucose)
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 9 columns.
</p>


<h3>Source</h3>

<p>Hamada, M. and Wu, C. F. J. (1992) &quot;Analysis of Designed Experiments with Complex Aliasing,&quot; <em>Journal of Quality Technology</em>, 24, 130â€“-137.
</p>

<hr>
<h2 id='cast_fatigue'>Cast Fatigue Experiment</h2><span id='topic+cast_fatigue'></span>

<h3>Description</h3>

<p>Hunter et al. (1982) used a 12-run Plackett-Burman design to investigate the effects of seven two-level factors on the fatigue life of weld-repaired castings.
The seven factors are denoted by capital letters A through G.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cast_fatigue)
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 8 columns.
</p>


<h3>Source</h3>

<p>Hunter, G. B., Hodi, F. S., and Eagar, T. W. (1982) &quot;High Cycle Fatigue of Weld Repaired Cast Ti-6AI-4V,&quot; <em>Metallurgical Transactions A</em>, 13, 1589&ndash;1594.
</p>

<hr>
<h2 id='HiGarrote'>An Automatic Method for the Analysis of Experiments using Hierarchical Garrote</h2><span id='topic+HiGarrote'></span>

<h3>Description</h3>

<p>'HiGarrote()' provides an automatic method for analyzing experimental data. 
This function applies the nonnegative garrote method to select important effects while preserving their hierarchical structures.
It first estimates regression parameters using generalized ridge regression, where the ridge parameters are derived from a Gaussian process prior placed on the input-output relationship. 
Subsequently, the initial estimates will be used in the nonnegative garrote for effects selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HiGarrote(
  D,
  y,
  quali_id = NULL,
  quanti_id = NULL,
  heredity = "weak",
  U = NULL,
  me_num = NULL,
  quali_contr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HiGarrote_+3A_d">D</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data frame for the unreplicated design matrix, where <code class="reqn">n</code> is the run size and <code class="reqn">p</code> is the number of factors.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_y">y</code></td>
<td>
<p>A vector for the responses corresponding to <code>D</code>. For replicated experiments, <code>y</code> should be an <code class="reqn">n \times r</code> matrix, where <code class="reqn">r</code> is the number of replicates.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_quali_id">quali_id</code></td>
<td>
<p>A vector indexing qualitative factors.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_quanti_id">quanti_id</code></td>
<td>
<p>A vector indexing quantitative factors.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_heredity">heredity</code></td>
<td>
<p>Choice of heredity principles: weak or strong. The default is weak.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_u">U</code></td>
<td>
<p>Optional. An <code class="reqn">n \times P</code> model matrix, where <code class="reqn">P</code> is the number of potential effects. 
The inclusion of potential effects supports only main effects and two-factor interactions. 
Three-factor and higher order interactions are not supported.
The colon symbol &quot;:&quot; must be included in the names of a two-factor interaction for separating its parent main effects.
By default, <code>U</code> will be automatically constructed.
The potential effects will then include all the main effects of qualitative factors, the first two main effects (linear and quadratic) of all the quantitative factors, and all the two-factor interactions generated by those main effects.
By default, the coding systems of qualitative and quantitative factors are Helmert coding and orthogonal polynomial coding, respectively.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_me_num">me_num</code></td>
<td>
<p>Optional. A <code class="reqn">p \times 1</code> vector for the main effects number of each factor.
<code>me_num</code> is required when <code>U</code> is not <code>NULL</code> and must be consistent with the main effects number specified in <code>U</code>.</p>
</td></tr>
<tr><td><code id="HiGarrote_+3A_quali_contr">quali_contr</code></td>
<td>
<p>Optional. A list specifying the contrasts of factors. 
<code>quali_contr</code> is required only when the main effects of a qualitative factor are not generated by the default Helmert coding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector for the nonnegative garrote estimates of the identified effects.
</p>


<h3>References</h3>

<p>Yu, W. Y. and Joseph, V. R. (2024) &quot;Automated Analysis of Experiments using Hierarchical Garrote,&quot; arXiv preprint arXiv:2411.01383.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cast fatigue experiment
data(cast_fatigue)
X &lt;- cast_fatigue[,1:7]
y &lt;- cast_fatigue[,8]
HiGarrote::HiGarrote(X, y)

# Blood glucose experiment
data(blood_glucose)
X &lt;- blood_glucose[,1:8]
y &lt;- blood_glucose[,9]
HiGarrote::HiGarrote(X, y, quanti_id = 2:8) 


# Router bit experiment
data(router_bit)
X &lt;- router_bit[, 1:9]
y &lt;- router_bit[,10]
for(i in c(4,5)){
my.contrasts &lt;- matrix(c(-1,-1,1,1,1,-1,-1,1,-1,1,-1,1), ncol = 3)
X[,i] &lt;- as.factor(X[,i])
contrasts(X[,i]) &lt;- my.contrasts
colnames(contrasts(X[,i])) &lt;- paste0(".",1:(4-1))
}
U &lt;- model.matrix(~.^2, X)
U &lt;- U[, -1]  # remove the unnecessary intercept terms from the model matrix
me_num = c(rep(1,3), rep(3,2), rep(1, 4))
quali_contr &lt;- list(NULL, NULL, NULL,
                    matrix(c(-1,-1,1,1,1,-1,-1,1,-1,1,-1,1), ncol = 3),
                    matrix(c(-1,-1,1,1,1,-1,-1,1,-1,1,-1,1), ncol = 3),
                    NULL, NULL, NULL, NULL)
HiGarrote::HiGarrote(X, y, quali_id = c(4,5), U = U, 
me_num = me_num, quali_contr = quali_contr)

# Experiments with replicates
# Generate simulated data
data(cast_fatigue)
X &lt;- cast_fatigue[,1:7]
U &lt;- data.frame(model.matrix(~.^2, X)[,-1])
error &lt;- matrix(rnorm(24), ncol = 2) # two replicates for each run
y &lt;- 20*U$A + 10*U$A.B + 5*U$A.C + error
HiGarrote::HiGarrote(X, y)


</code></pre>

<hr>
<h2 id='nnGarrote'>Nonnegative Garrote Method with Hierarchical Structures</h2><span id='topic+nnGarrote'></span>

<h3>Description</h3>

<p>'nnGarrote()' implements the nonnegative garrote method, as described in Yuan et al. (2009), for selecting important variables while preserving hierarchical structures.
The method begins by obtaining the least squares estimates of the regression parameters under a linear model.
These initial estimates are then used in the nonnegative garrote to perform variable selection.
This function supports prediction based on the linear model fitted with the selected variables and their nonnegative garrote estimates.
Note that this method is suitable only when the number of observations is much larger than the number of variables, ensuring that the least squares estimation remains reliable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnGarrote(U, y, new_U = NULL, heredity = "weak")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnGarrote_+3A_u">U</code></td>
<td>
<p>An <code class="reqn">n \times P</code> model matrix, where <code class="reqn">n</code> is the number of data and <code class="reqn">P</code> is the number of potential variables.
The inclusion of potential variables supports only up to second-order interactions.
Three-order and higher order interactions are not supported.
The colon symbol &quot;:&quot; must be included in the names of a second-order interaction for separating its parent variables.
Please see the example for the naming format.</p>
</td></tr>
<tr><td><code id="nnGarrote_+3A_y">y</code></td>
<td>
<p>A vector for the responses.</p>
</td></tr>
<tr><td><code id="nnGarrote_+3A_new_u">new_U</code></td>
<td>
<p>Optional. A matrix or data frame of the new model matrix for prediction.</p>
</td></tr>
<tr><td><code id="nnGarrote_+3A_heredity">heredity</code></td>
<td>
<p>Choice of heredity principles: weak or strong. The default is weak.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>new_U</code> is <code>NULL</code>, the function returns a vector for the nonnegative garrote estimates of the identified variables.
</p>
<p>If <code>new_U</code> is not <code>NULL</code>, the function returns a list with:
</p>

<ul>
<li> <p><code>beta_nng</code>: a vector for the nonnegative garrote estimates of the identified variables.
</p>
</li>
<li> <p><code>pred</code>: predictions for the output corresponding to <code>new_U</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Yuan, M., Joseph, V. R., and Zou H. (2009) &quot;Structured Variable Selection and Estimation,&quot; The Annals of Applied Statistics, 3(4):1738â€“1757.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- runif(1000)
x2 &lt;- runif(1000)
x3 &lt;- runif(1000)
error &lt;- rnorm(1000)
X &lt;- data.frame(x1, x2, x3)
U_all &lt;- data.frame(model.matrix(~. + x1:x2 + x1:x3 + x2:x3 + I(x1^2) + I(x2^2) + I(x3^2), X))
colnames(U_all) &lt;- c("X.Intercept.", "x1", "x2", "x3", "x1:x1", "x2:x2", "x3:x3",
 "x1:x2", "x1:x3", "x2:x3")
# ":" is required for detecting the parent variables of a second-order interaction.

new_idx &lt;- sample(1:1000, 800)
new_U &lt;- U_all[new_idx,]
U_idx &lt;- setdiff(1:1000, new_idx)
U &lt;- U_all[U_idx,]
y_all &lt;- 20*U_all$x1 + 15*U_all$`x1:x1` + 10*U_all$`x1:x2` + error
y &lt;- y_all[U_idx]
nnGarrote(U, y, new_U)


</code></pre>

<hr>
<h2 id='router_bit'>Router Bit Experiment</h2><span id='topic+router_bit'></span>

<h3>Description</h3>

<p>Phadke (1986) described a 32-run experiment aimed at increasing the lifespan of router bits used in a routing process to cut printed wiring boards from a panel.
The experiment contains seven two-level factors and two four-level qualitative factors which are denoted by A through J with the exclusion of I.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(router_bit)
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 rows and 10 columns.
</p>


<h3>Source</h3>

<p>Phadke, M. S. (1986) &quot;Design Optimization Case Studies,&quot; <em>AT&amp;T Technical Journal</em>, 65, 51&ndash;68.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
