<!DOCTYPE html><html><head><title>Help for package movieROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {movieROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biROC'>
<p>Build a ROC curve for a bivariate marker</p></a></li>
<li><a href='#gROC'>
<p>Build a ROC curve for a univariate marker</p></a></li>
<li><a href='#gROC_param'>
<p>Build a binormal ROC curve for a univariate marker</p></a></li>
<li><a href='#HCC'>
<p>Hepatocellular carcinoma data</p></a></li>
<li><a href='#hROC'>
<p>Build a ROC curve for a transformation of a univariate marker</p></a></li>
<li><a href='#movieROC'>
<p>Create a video with the building procedure of the ROC curve</p></a></li>
<li><a href='#movieROC2_densities'>
<p>Create a video with the building procedure of the smooth ROC curve estimate</p></a></li>
<li><a href='#multiROC'>
<p>Build a ROC curve for a multivariate marker with dimension higher than two</p></a></li>
<li><a href='#plot'>
<p>Plot an ROC curve</p></a></li>
<li><a href='#plot_densities'>
<p>Plot density function estimates for controls and cases</p></a></li>
<li><a href='#plot_densityROC'>
<p>Plot standard smooth ROC curve estimate</p></a></li>
<li><a href='#plot.buildROC'>
<p>Plot the building procedure of the ROC curve</p></a></li>
<li><a href='#plot.funregions'>
<p>Plot the transformation function used for the marker</p></a></li>
<li><a href='#plot.regions'>
<p>Plot the classification regions underlying a ROC curve</p></a></li>
<li><a href='#predict'>
<p>Predict the classification regions for a particular specificity</p></a></li>
<li><a href='#print'>
<p>Print an ROC curve object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualizing the Decision Rules Underlying Binary Classification</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Visualization of decision rules for binary classification and Receiver Operating Characteristic (ROC) curve estimation under different generalizations:
  - making the classification subsets flexible to cover those scenarios where both extremes of the
  marker are associated with a higher risk of being positive, considering two thresholds 
  (gROC curve);
  - transforming the marker by a function either defined by the user or resulting from a logistic 
  regression model (hROC curve);
  - considering a linear transformation with some fixed parameters introduced by the user, 
  dynamic parameters or empirically maximizing TPR for each FPR for a bivariate marker.
  Also a quadratic transformation with particular coefficients or a function fitted by a logistic 
  regression model can be considered (biROC curve);
  - considering a linear transformation with some fixed parameters introduced by the user, 
  dynamic parameters or a function fitted by a logistic regression model (multiROC curve).
  The classification regions behind each point of the ROC curve are displayed in both fixed 
  graphics (plot.buildROC(), plot.regions() or plot.funregions() function) or videos (movieROC() 
  function).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>rms, animation, intrval, gtools, e1071, robustbase, Rsolnp,
ks, zoo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 11:43:03 UTC; sonia</td>
</tr>
<tr>
<td>Author:</td>
<td>Sonia Perez-Fernandez
    <a href="https://orcid.org/0000-0002-2767-6399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sonia Perez-Fernandez &lt;perezsonia@uniovi.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='biROC'>
Build a ROC curve for a bivariate marker
</h2><span id='topic+biROC'></span><span id='topic+biROC.default'></span>

<h3>Description</h3>

<p>This is one of the main functions of the movieROC package.
It builds a bivariate ROC curve by considering one of these methods:
i) fitting a binary logistic regression model with a particular combination
(fixed by the user) of the two components on the right-hand side,
ii) linear combinations with fixed parameters,
iii) linear combinations with dynamic parameters, or
iv) quadratic combinations with fixed parameters.
It returns a &lsquo;biroc&rsquo; object, a list of class &lsquo;biroc&rsquo;.
This object can be <code>print</code>ed or <code>plot</code>ted. It may be also passed to
<code><a href="#topic+plot.buildROC">plot.buildROC</a></code> and <code><a href="#topic+movieROC">movieROC</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biROC(X, D, ...)
## Default S3 method:
biROC(X, D, method = c("lrm", "fixedLinear", "fixedQuadratic",
        "dynamicEmpirical", "dynamicMeisner", "kernelOptimal"),
    formula.lrm = "D ~ X.1 + I(X.1^2) + X.2 + I(X.2^2) + I(X.1*X.2)",
    stepModel = TRUE, methodLinear = c("coefLinear", "SuLiu", "PepeThompson",
      "logistic", "minmax"), coefLinear = c(1, 1), coefQuadratic = c(1, 1, 0, 1, 1),
    K = 201, alpha = 0.5, approxh = 0.5, multiplier = 2,
    kernelOptimal.H = c("Hbcv", "Hscv", "Hpi", "Hns", "Hlscv", "Hbcv.diag",
        "Hscv.diag", "Hpi.diag", "Hlscv.diag"), eps = sqrt(.Machine$double.eps),
    verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biROC_+3A_x">X</code></td>
<td>

<p>Matrix (dimension <code class="reqn">n \times 2</code>) of marker values where <code class="reqn">n</code> is the sample size.</p>
</td></tr>
<tr><td><code id="biROC_+3A_d">D</code></td>
<td>

<p>Vector of response values. Two levels; if more, the two first ones are used.</p>
</td></tr>
<tr><td><code id="biROC_+3A_method">method</code></td>
<td>

<p>Method used to build the classification regions. One of <code>"lrm"</code> (fitting a binary logistic regression model by the input parameter <code>formula</code> computed by using the <code>lrm</code> function in the <code>rms</code> package), <code>"fixedLinear"</code> (linear frontiers with fixed parameters given in <code>coefLinear</code>), <code>"fixedQuadratic"</code> (quadratic frontiers with fixed parameters given in <code>coefQuadratic</code>), <code>"dynamicMeisner"</code> (linear frontiers with dynamic parameters reported by Meisner et al. (2021) method  computed by using the <code>maxTPR</code> function in the <a href="https://CRAN.R-project.org/package=maxTPR"><span class="pkg">maxTPR</span></a> package), <code>"dynamicEmpirical"</code> (linear frontiers with dynamic parameters reported by the empirical method), or <code>"kernelOptimal"</code> (estimating optimal transformation based on bivariate kernel density estimation by Mart√≠nez-Camblor et al. (2021) using the <code>kde</code> function in the <a href="https://CRAN.R-project.org/package=ks"><span class="pkg">ks</span></a> package). Default: <code>"lrm"</code>.</p>
</td></tr>
<tr><td><code id="biROC_+3A_formula.lrm">formula.lrm</code></td>
<td>

<p>If <code>method = "lrm"</code>, the transformation employed in the right-hand side of the logistic regression model (in terms of <code>X.1</code>, <code>X.2</code> and <code>D</code>). Default: quadratic formula.</p>
</td></tr>
<tr><td><code id="biROC_+3A_stepmodel">stepModel</code></td>
<td>

<p>If TRUE and <code>method = "lrm"</code>, a model selection is performed based on the AIC (Akaike information criterion) in a stepwise algorithm (see <code>step</code> function for more information). Default: TRUE.
</p>
</td></tr>
<tr><td><code id="biROC_+3A_methodlinear">methodLinear</code></td>
<td>

<p>If <code>method = "fixedLinear"</code>, method used to build the classification regions. One of <code>"coefLinear"</code> (particular fixed coefficients in <code>coefLinear</code>), <code>"SuLiu"</code> (Su and Liu, 1993), <code>"PepeThompson"</code> (Pepe and Thompson, 2000), <code>"logistic"</code> (logistic regression model), <code>"minmax"</code> (Liu et al., 2011). Default: <code>"coefLinear"</code>.</p>
</td></tr>
<tr><td><code id="biROC_+3A_coeflinear">coefLinear</code></td>
<td>

<p>If <code>method = "fixedLinear"</code> and <code>methodLinear = "coefLinear"</code>, a vector of length 2 with the coefficients <code class="reqn">\beta_1</code> and <code class="reqn">\beta_2</code> used to <code class="reqn">\mathcal{L}_{\boldsymbol{\beta}}(\boldsymbol{X}) = \beta_1 X_1 +\beta_2 X_2</code>. Default: <code class="reqn">(1,1)</code>.
</p>
</td></tr>
<tr><td><code id="biROC_+3A_coefquadratic">coefQuadratic</code></td>
<td>

<p>If <code>method = "fixedQuadratic"</code>, a vector of length 5 with coefficients <code class="reqn">\beta_1, \dots, \beta_5</code> used to <code class="reqn">\mathcal{Q}_{\boldsymbol{\beta}}(\boldsymbol{X}) = \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_1 X_2 + \beta_4 X_1^2 + \beta_5 X_2^2</code>. Default: <code class="reqn">(1,1,0,1,1)</code>.</p>
</td></tr>
<tr><td><code id="biROC_+3A_k">K</code></td>
<td>

<p>If <code>method = "dynamicEmpirical"</code>, the number of equally spaced <code class="reqn">\alpha \in (-1,1)</code> studied. Default: 201.</p>
</td></tr>
<tr><td><code id="biROC_+3A_alpha">alpha</code>, <code id="biROC_+3A_approxh">approxh</code>, <code id="biROC_+3A_multiplier">multiplier</code></td>
<td>

<p>If <code>method = "dynamicMeisner"</code>, input parameters used in the <code>maxTPR</code> function of the <a href="https://CRAN.R-project.org/package=maxTPR"><span class="pkg">maxTPR</span></a> package. Default: <code>alpha = 0.5</code>, <code>approxh = 0.5</code> and <code>multiplier = 2</code>.
</p>
</td></tr>
<tr><td><code id="biROC_+3A_kerneloptimal.h">kernelOptimal.H</code></td>
<td>

<p>If <code>method = "kernelOptimal"</code>, the bandwidth matrix <code>H</code> used in the <code>kde</code> function of the <a href="https://CRAN.R-project.org/package=ks"><span class="pkg">ks</span></a> package. Default: <code>"Hbcv"</code> (biased cross-validation (BCV) bandwidth matrix selector for bivariate data).
</p>
</td></tr>
<tr><td><code id="biROC_+3A_eps">eps</code></td>
<td>

<p>Epsilon value to consider. Default: <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="biROC_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, a progress bar is displayed for computationally intensive methods. Default: FALSE.</p>
</td></tr>
<tr><td><code id="biROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &lsquo;biroc&rsquo; with the following fields:
</p>
<table>
<tr><td><code>controls</code>, <code>cases</code></td>
<td>
<p>Marker values of negative and positive subjects, respectively.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>Levels of response values.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Vector of false-positive rates.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>Vector of values of the ROC curve for <code>t</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>Area under the curve estimate.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>If <code>method = "lrm"</code>, <code>"fixedLinear"</code>, <code>"fixedQuadratic"</code>, or <code>"kernelOptimal"</code>, resulting
univariate marker values.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>If <code>method = "lrm"</code>, <code>"fixedLinear"</code>, <code>"fixedQuadratic"</code>, or <code>"kernelOptimal"</code>, vector of final
marker thresholds resulting in (<code>t</code>, <code>roc</code>).</p>
</td></tr>
<tr><td><code>CoefTable</code></td>
<td>
<p>If <code>method = "dynamicMeisner"</code> or <code>"dynamicEmpirical"</code>, a list of length equal to length of vector <code>t</code>. Each element of the list keeps the linear coefficients (<code>coef</code>), threshold for such linear combination (<code>c</code>), the corresponding point in the ROC curve (<code>t</code>, <code>roc</code>), the resulting univariate marker values (<code>Z</code>) and a matrix of dimension 100 <code class="reqn">\times</code> 100 with the marker values over a grid of (<code class="reqn">X_1</code>, <code class="reqn">X_2</code>) bivariate values (<code>f</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Q. Su and J. S. Liu. (1993) &ldquo;Linear combinations of multiple diagnostic markers&rdquo;. <em>Journal of the American Statistical Association</em>, <b>88</b>(424): 1350‚Äì1355. DOI: <a href="https://doi.org/10.1080/01621459.1993.10476417">doi:10.1080/01621459.1993.10476417</a>.
</p>
<p>M. S. Pepe and M. L. Thompson (2000) &ldquo;Combining diagnostic test results to increase accuracy&rdquo;. <em>Biostatistics</em>, <b>1</b>
(2):123‚Äì140. DOI: <a href="https://doi.org/10.1093/biostatistics/1.2.123">doi:10.1093/biostatistics/1.2.123</a>.
</p>
<p>C. Liu, A. Liu, and S. Halabi (2011) &ldquo;A min‚Äìmax combination of biomarkers to improve diagnostic accuracy&rdquo;. <em>Statistics in Medicine</em>, <b>30</b>(16): 2005‚Äì2014. DOI: <a href="https://doi.org/10.1002/sim.4238">doi:10.1002/sim.4238</a>.
</p>
<p>P. Mart√≠nez-Camblor, S. P√©rez-Fern√°ndez, and S. D√≠az-Coto (2021) &ldquo;Optimal classification scores based on multivariate marker transformations&rdquo;. <em>AStA Advances in Statistical Analysis</em>, <b>105</b>(4): 581‚Äì599. DOI: <a href="https://doi.org/10.1007/s10182-020-00388-z">doi:10.1007/s10182-020-00388-z</a>.
</p>
<p>A. Meisner, M. Carone, M. S. Pepe, and K. F. Kerr (2021) &ldquo;Combining biomarkers by maximizing the true positive rate for a fixed false positive rate&rdquo;. <em>Biometrical Journal</em>, 63(6): 1223‚Äì1240. DOI: <a href="https://doi.org/10.1002/bimj.202000210">doi:10.1002/bimj.202000210</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# ROC curve for genes 20202438 and 18384097 to identify tumor by 4 different methods:
X &lt;- cbind(HCC$cg20202438, HCC$cg18384097); D &lt;- HCC$tumor
## 1. Linear combinations with fixed parameters by Pepe and Thompson (2000)
biROC(X, D, method = "fixedLinear", methodLinear = "PepeThompson")
## 2.Linear combinations with dynamic parameters by Meisner et al. (2021)

### Time consuming
biROC(X, D, method = "dynamicMeisner")

## 3. Logistic regression model with quadratic formula by default
biROC(X, D)
## 4. Optimal transformation with multivariate KDE by Mart√≠nez-Camblor et al. (2021)
biROC(X, D, method = "kernelOptimal")
</code></pre>

<hr>
<h2 id='gROC'>
Build a ROC curve for a univariate marker
</h2><span id='topic+gROC'></span><span id='topic+gROC.default'></span>

<h3>Description</h3>

<p>This is one of the main functions of the movieROC package.
It builds a univariate ROC curve (standard or general) and returns a
&lsquo;groc&rsquo; object, a list of class &lsquo;groc&rsquo;.
This object can be <code>print</code>ed, <code>plot</code>ted, or <code>predict</code>ed
for a particular point. It may be also passed to other functions:
<code><a href="#topic+plot.regions">plot.regions</a></code>, <code><a href="#topic+plot.buildROC">plot.buildROC</a></code>, <code><a href="#topic+movieROC">movieROC</a></code>,
<code><a href="#topic+plot_densities">plot_densities</a></code>, and <code><a href="#topic+plot_densityROC">plot_densityROC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gROC(X, D, ...)
## Default S3 method:
gROC(X, D, side = c("right", "left", "both", "both2"),
    restric = FALSE, optim = TRUE, t0 = NULL, t0max = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gROC_+3A_x">X</code></td>
<td>

<p>Vector of marker values.</p>
</td></tr>
<tr><td><code id="gROC_+3A_d">D</code></td>
<td>

<p>Vector of response values. Two levels; if more, the two first ones are used.</p>
</td></tr>
<tr><td><code id="gROC_+3A_side">side</code></td>
<td>

<p>Type of ROC curve. One of <code>"right"</code> (<code class="reqn">\mathcal{R}_r(\cdot)</code>),
<code>"left"</code> (<code class="reqn">\mathcal{R}_l(\cdot)</code>), <code>"both"</code> (<code class="reqn">\mathcal{R}_g(\cdot)</code>)
or <code>"both2"</code> (<code class="reqn">\mathcal{R}_{g'}(\cdot)</code>). Default: <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="gROC_+3A_restric">restric</code></td>
<td>

<p>If TRUE, the gROC curve with restriction <em>(C)</em> is computed. Default: FALSE.</p>
</td></tr>
<tr><td><code id="gROC_+3A_optim">optim</code></td>
<td>

<p>If TRUE (and <code>restric = TRUE</code>), the computation of the optimal gROC curve
under restriction <em>(C)</em> is performed by using Floyd's algorithm. Default: TRUE.</p>
</td></tr>
<tr><td><code id="gROC_+3A_t0">t0</code></td>
<td>

<p>An integer number between 1 and <code class="reqn">m+1</code> (where <code class="reqn">m</code> is the negative sample size).
If <code>restric = TRUE</code>, the restricted gROC curve is computed departing
from (<code>t0</code><code class="reqn">-1</code>)/<code class="reqn">m</code>. Default: the one reporting the Youden index.</p>
</td></tr>
<tr><td><code id="gROC_+3A_t0max">t0max</code></td>
<td>

<p>If TRUE, the computation of the gROC curve under restriction <em>(C)</em> is performed
departing from every possible <code>t0</code> and the one reporting the maximum AUC is selected.</p>
</td></tr>
<tr><td><code id="gROC_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, a progress bar is displayed for computationally intensive methods. Default: FALSE.</p>
</td></tr>
<tr><td><code id="gROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function's main job is to estimate an ROC curve for a univariate marker
under one of these considerations: larger values of the marker are associated
with a higher probability of being positive (resulting in the <em>right-sided</em>
ROC curve, <code class="reqn">\mathcal{R}_r (\cdot)</code>), the opposite (<em>left-sided</em> ROC curve,
<code class="reqn">\mathcal{R}_l (\cdot)</code>), when both smaller and larger values of the marker are
associated with having more probability of being positive (<em>gROC curve</em>,
<code class="reqn">\mathcal{R}_g(\cdot)</code>), the opposite (<em>opposite gROC curve</em>, <code class="reqn">\mathcal{R}_{g'}(\cdot)</code>).
</p>


<h3>Value</h3>

<p>A list of class &lsquo;groc&rsquo; with the following fields:
</p>
<table>
<tr><td><code>controls</code>, <code>cases</code></td>
<td>
<p>Marker values of negative and positive subjects, respectively.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>Levels of response values.</p>
</td></tr>
<tr><td><code>side</code></td>
<td>
<p>Type of ROC curve.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Vector of false-positive rates.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>Vector of values of the ROC curve for <code>t</code>.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Vector of marker thresholds resulting in (<code>t</code>, <code>roc</code>)
if <code>side = "right" | "left"</code>.</p>
</td></tr>
<tr><td><code>xl</code>, <code>xu</code></td>
<td>
<p>Vectors of marker thresholds resulting in (<code>t</code>, <code>roc</code>)
if <code>side = "both" | "both2"</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>Area under the curve estimate.</p>
</td></tr>
<tr><td><code>aucfree</code></td>
<td>
<p>Area under the curve estimate without restrictions.</p>
</td></tr>
<tr><td><code>aucs</code></td>
<td>
<p>Area under the curve with restriction <em>(C)</em> departing from every
false-positive rate, <code class="reqn">FPR \in \{ 0, 1/m, \dots, 1 \}</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# ROC curve estimates for gene 03515901 and response tumor
gROC(X = HCC[,"cg03515901"], D = HCC$tumor) # Standard right-sided ROC curve
gROC(X = HCC[,"cg03515901"], D = HCC$tumor, side = "left") # Left-sided ROC curve
gROC(X = HCC[,"cg03515901"], D = HCC$tumor, side = "both") # gROC curve without restrictions


### Warning: Next line of code is time consuming. gROC curve with restriction (C)
gROC(X = HCC[,"cg03515901"], D = HCC$tumor, side = "both", restric = TRUE)

</code></pre>

<hr>
<h2 id='gROC_param'>
Build a binormal ROC curve for a univariate marker
</h2><span id='topic+gROC_param'></span>

<h3>Description</h3>

<p>This function builds a univariate ROC curve (standard or general) 
assuming the binormal scenario with parameters being the sample estimates. 
It returns a &lsquo;groc&rsquo; object, a list of class &lsquo;groc&rsquo;.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gROC_param(X, D, side = c("right", "left", "both", "both2"), N = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gROC_param_+3A_x">X</code></td>
<td>

<p>Vector of marker values.</p>
</td></tr>
<tr><td><code id="gROC_param_+3A_d">D</code></td>
<td>

<p>Vector of response values. Two levels; if more, the two first ones are used.</p>
</td></tr>
<tr><td><code id="gROC_param_+3A_side">side</code></td>
<td>

<p>Type of ROC curve. One of <code>"right"</code> (<code class="reqn">\mathcal{R}_r(\cdot)</code>), 
<code>"left"</code> (<code class="reqn">\mathcal{R}_l(\cdot)</code>), <code>"both"</code> (<code class="reqn">\mathcal{R}_g(\cdot)</code>) 
or <code>"both2"</code> (<code class="reqn">\mathcal{R}_{g'}(\cdot)</code>). Default: <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="gROC_param_+3A_n">N</code></td>
<td>

<p>Number indicating the length of the vector of FPR considered to build the ROC curve: 
<code class="reqn">t \in \{ 0, 1/N, 2/N, \dots, 1 \}</code>. Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="gROC_param_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function's main job is to estimate an ROC curve for a univariate marker 
under one of these considerations: larger values of the marker are associated 
with a higher probability of being positive (resulting in the <em>right-sided</em> 
ROC curve, <code class="reqn">\mathcal{R}_r (\cdot)</code>), the opposite (<em>left-sided</em> ROC curve, 
<code class="reqn">\mathcal{R}_l (\cdot)</code>), when both smaller and larger values of the marker are 
associated with having more probability of being positive (<em>gROC curve</em>, 
<code class="reqn">\mathcal{R}_g(\cdot)</code>), the opposite (<em>opposite gROC curve</em>, <code class="reqn">\mathcal{R}_{g'}(\cdot)</code>).  
</p>


<h3>Value</h3>

<p>A list of class &lsquo;groc&rsquo; with the following fields: 
</p>
<table>
<tr><td><code>controls</code>, <code>cases</code></td>
<td>
<p>Marker values of negative and positive subjects, respectively.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>Levels of response values.</p>
</td></tr>
<tr><td><code>side</code></td>
<td>
<p>Type of ROC curve.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Vector of false-positive rates.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>Vector of values of the ROC curve for <code>t</code>.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Vector of marker thresholds resulting in (<code>t</code>, <code>roc</code>) 
if <code>side = "right" | "left"</code>.</p>
</td></tr>
<tr><td><code>xl</code>, <code>xu</code></td>
<td>
<p>Vectors of marker thresholds resulting in (<code>t</code>, <code>roc</code>) 
if <code>side = "both" | "both2"</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>Area under the curve estimate.</p>
</td></tr>
<tr><td><code>a</code>, <code>b</code></td>
<td>
<p>Estimates for parameters <code class="reqn">a</code> and <code class="reqn">b</code> considered for the ROC curve estimation: 
<code class="reqn">\hat{a} = \left[ \overline{\xi_n} - \overline{\chi_m} \right]/\hat{s}_\xi</code> and 
<code class="reqn">\hat{b} = \hat{s}_\chi / \hat{s}_\xi</code>.</p>
</td></tr>
<tr><td><code>p0</code></td>
<td>
<p>Estimate of the &quot;central value&quot;, <code class="reqn">\mu^*</code>, about to which the thresholds <code class="reqn">x^L</code> 
and <code class="reqn">x^U</code> are symmetrical.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# ROC curve estimates for gene 03515901 and response tumor assuming the binormal scenario
gROC_param(X = HCC[,"cg03515901"], D = HCC$tumor) # Standard right-sided ROC curve
gROC_param(X = HCC[,"cg03515901"], D = HCC$tumor, side = "left") # Left-sided ROC curve 
gROC_param(X = HCC[,"cg03515901"], D = HCC$tumor, side = "both") # gROC curve 
</code></pre>

<hr>
<h2 id='HCC'>
Hepatocellular carcinoma data
</h2><span id='topic+HCC'></span>

<h3>Description</h3>

<p>This dataset is derived from gene expression arrays of tumor and adjacent non-tumor tissues of 62 Taiwanese cases of hepatocellular carcinoma. The complete dataset was
deposited in <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi">NCBI‚Äôs Gene Expression Omnibus (GEO)</a> and it is available through series accession number GSE37988. This dataset contains 948 from the 27,578 autosomal CpG sites screened.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HCC")</code></pre>


<h3>Format</h3>

<p>A data frame with 124 observations on 952 variables. First 4 variables are <code>tissue</code> (identification number for the tissue; from 1 to 62), <code>sex</code> (female or male), <code>age</code> (age in years of the patient), and <code>tumor</code> (status of the tissue; nontumor or tumor). The following 948 from <code>cg03409548</code> to <code>cg20240860</code> are numeric variables containing the relative gene expression intensities of the corresponding gene.
</p>


<h3>Source</h3>

<p>NCBI‚Äôs Gene Expression Omnibus (GEO) - Series accession number GSE37988 (<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE37988">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE37988</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)
str(HCC) # Data structure
table(HCC$tumor) # Number of non-tumor and tumor tissues

# Histograms of gene 18384097 expression intensities for non-tumor and tumor tissues
oldpar &lt;- par(mfrow = c(2,1))
x &lt;- subset(HCC, tumor == "nontumor")$cg18384097
y &lt;- subset(HCC, tumor == "tumor")$cg18384097
hist(x, xlim = c(0,1), main = "Gene 18384097 in non-tumor tissues")
hist(y, xlim = c(0,1), main = "Gene 18384097 in tumor tissues")
par(oldpar)
</code></pre>

<hr>
<h2 id='hROC'>
Build a ROC curve for a transformation of a univariate marker
</h2><span id='topic+hROC'></span><span id='topic+hROC.default'></span>

<h3>Description</h3>

<p>This is one of the main functions of the movieROC package. 
It builds a univariate ROC curve for a transformed marker <code class="reqn">h(X)</code> 
and returns a &lsquo;hroc&rsquo; object, a list of class &lsquo;hroc&rsquo;. 
This object can be <code>print</code>ed, <code>plot</code>ted, or <code>predict</code>ed
for a particular point. It may be also passed to  
<code><a href="#topic+plot.funregions">plot.funregions</a></code> and <code><a href="#topic+plot.regions">plot.regions</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hROC(X, D, ...)
## Default S3 method:
hROC(X, D, type = c("lrm", "h.fun", "overfitting"), 
    formula.lrm = "D ~ pol(X,3)", h.fun = function(x) {x}, 
    plot.h = FALSE, plot.roc = FALSE, new.window = FALSE, 
    main = NULL, xlab = "x", ylab = "h(x)", xaxis = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hROC_+3A_x">X</code></td>
<td>

<p>Vector of marker values.</p>
</td></tr>
<tr><td><code id="hROC_+3A_d">D</code></td>
<td>

<p>Vector of response values. Two levels; if more, the two first ones are used.</p>
</td></tr>
<tr><td><code id="hROC_+3A_type">type</code></td>
<td>

<p>Type of transformation considered. One of <code>"lrm"</code> (a binary logistic 
regression is computed by using <code>lrm</code> function in <code>rms</code> package), 
<code>"h.fun"</code> (the transformation indicated in the input parameter <code>h.fun</code> 
is considered) or <code>"overfitting"</code> (the overfitting transformation, 
<code class="reqn">\ell_{of}(\cdot)</code> is taken). Default: <code>"lrm"</code>.</p>
</td></tr>
<tr><td><code id="hROC_+3A_formula.lrm">formula.lrm</code></td>
<td>

<p>If <code>type = "lrm"</code>, the transformation employed in the right-hand side 
of the logistic regression model (in terms of <code>X</code> and <code>D</code>). 
Default: <code>'D ~ pol(X, 3)'</code>.</p>
</td></tr>
<tr><td><code id="hROC_+3A_h.fun">h.fun</code></td>
<td>

<p>If <code>type = "h.fun"</code>, the transformation employed (as a function in R). 
Default: <code>function(x){x}</code>.</p>
</td></tr>
<tr><td><code id="hROC_+3A_plot.h">plot.h</code></td>
<td>

<p>If TRUE, the transformation employed is illustrated.</p>
</td></tr>
<tr><td><code id="hROC_+3A_plot.roc">plot.roc</code></td>
<td>

<p>If TRUE, the resulting ROC curve is illustrated.</p>
</td></tr>
<tr><td><code id="hROC_+3A_new.window">new.window</code></td>
<td>

<p>If TRUE, two previous graphics are plotted separately in different windows.
</p>
</td></tr>
<tr><td><code id="hROC_+3A_main">main</code></td>
<td>

<p>A main title for the plot used if <code>plot.h = TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="hROC_+3A_xlab">xlab</code>, <code id="hROC_+3A_ylab">ylab</code></td>
<td>

<p>A label for the x and y axis of the plot used if <code>plot.h = TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="hROC_+3A_xaxis">xaxis</code></td>
<td>

<p>Graphical parameter used if <code>plot.h = TRUE</code>. If FALSE, plotting of the axis is supressed.
</p>
</td></tr>
<tr><td><code id="hROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &lsquo;hroc&rsquo; with the following fields: 
</p>
<table>
<tr><td><code>levels</code></td>
<td>
<p>Levels of response values.</p>
</td></tr>
<tr><td><code>X</code>, <code>Y</code></td>
<td>
<p>Original and transformed marker values, respectively.</p>
</td></tr>
<tr><td><code>Sp</code>, <code>Se</code></td>
<td>
<p>Vector of true-negtive and true-positive rates, respectively.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>Area under the curve estimate.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>If <code>type = "lrm"</code>, the coefficients of the logistic regression model fitted by <code>formula</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# ROC curve for gene 18384097 to identify tumor by considering 4  different transformations:
X &lt;- HCC$cg18384097; D &lt;- HCC$tumor
## 1. Ordinary cubic polynomial formula for binary logistic regression
hROC(X, D)
## 2. Linear tail-restricted cubic splines for binary logistic regression
hROC(X, D, formula.lrm = "D ~ rcs(X,8)")
## 3. Overfitting transformation for this particular sample
hROC(X, D, type = "overfitting")
## 4. Optimal transformation in terms of likelihood ratio 
##    by kernel density estimation with bandwidth h=3
EstDensTransf_FUN &lt;- function(X, D, h = 1){
  D &lt;- as.factor(D)
  controls &lt;- X[D == levels(D)[1]]; dens_controls &lt;- density(controls, adjust = h)
  cases &lt;- X[D == levels(D)[2]]; dens_cases &lt;- density(cases, adjust = h)
  dens_controls_FUN &lt;- approxfun(dens_controls$x, dens_controls$y, rule = 0)
  dens_cases_FUN &lt;- approxfun(dens_cases$x, dens_cases$y, rule = 0)
  function(x) dens_cases_FUN(x)/(dens_controls_FUN(x) + dens_cases_FUN(x))
}
hROC(X, D, type = "h.fun", h.fun = function(x) EstDensTransf_FUN(X, D, h = 3)(x))
</code></pre>

<hr>
<h2 id='movieROC'>
Create a video with the building procedure of the ROC curve
</h2><span id='topic+movieROC'></span><span id='topic+movieROC.groc'></span><span id='topic+movieROC.biroc'></span><span id='topic+movieROC.multiroc'></span>

<h3>Description</h3>

<p>Save a video as a GIF illustrating the construction of the ROC curve. Particularly, for each
element in vector <code>fpr</code> (optional input parameter), the function executed is
</p>
<p>- for &lsquo;groc&rsquo; and &lsquo;biroc&rsquo; objects:
</p>
<p><code>plot.buildROC(obj, FPR = fpr[i], build.process = TRUE,...)</code>;
</p>
<p>- for &lsquo;multiroc&rsquo; objects:
</p>
<p><code>plot.buildROC(obj, FPR = fpr[i], build.process = TRUE, display.method, displayOV,...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movieROC(x, ...)
## S3 method for class 'groc'
movieROC(x, fpr = NULL, h = c(1,1), histogram = FALSE, breaks = 15,
  reduce = TRUE, completeROC = FALSE, videobar = TRUE, file = "animation1.gif",
  save = TRUE, legends = FALSE, speedcorrection = FALSE, tpause = 1, interval = 0.2,
  ani.width, ani.height, xlab = "Marker", main.density = "Density functions",
  cex.lab = 2.5, cex.axis = 1.75, cex.main = 2.25 + as.numeric(reduce),
  xlim = NULL, ylim = NULL, cex.point = 1.5, lwd.curve = 2, mar = NULL,
  lim.density = 0.01, col.controlscases = c("#485C99", "#8F3D52"),
  col.curve = "black", col.threshold = "#FCBA04", verbose = FALSE, ...)
## S3 method for class 'biroc'
movieROC(x, fpr = NULL, border = TRUE, completeROC = FALSE,
  videobar = TRUE, file = "animation1.gif", save = TRUE, legends = FALSE,
  tpause = 1, interval = 0.2, ani.width, ani.height, xlab = "X1", ylab = "X2",
  cex = 0.8, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2,
  alpha.points = 1, alpha.contour = 0.25, lwd.curve = 2, lty.curve = 1,
  lf = NULL, col.controlscases = c('#485C99','#8F3D52'),
  col.curve = 'black', col.threshold = '#FCBA04', verbose = FALSE, ...)
## S3 method for class 'multiroc'
movieROC(x, fpr = NULL, display.method = c("PCA", "OV"),
  displayOV = c(1,2), border = TRUE, completeROC = FALSE, videobar = TRUE,
  file = "animation1.gif", save = TRUE, legends = FALSE, tpause = 1,
  interval = 0.2, ani.width, ani.height, xlab = NULL, ylab = NULL,
  cex = 0.8, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2, alpha.points = 1,
  alpha.contour = 0.25, lwd.curve = 2, lty.curve = 1, lf = NULL,
  col.controlscases = c('#485C99','#8F3D52'), col.curve = 'black',
  col.threshold = '#FCBA04', verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movieROC_+3A_x">x</code></td>
<td>

<p>An ROC curve object from the <span class="pkg">movieROC</span> package. Possible classes are: &lsquo;groc&rsquo; (output of <code>gROC</code> function), &lsquo;biroc&rsquo; (output of <code>biROC</code> function), and &lsquo;multiroc&rsquo; (output of <code>multiROC</code> function).</p>
</td></tr>
<tr><td><code id="movieROC_+3A_fpr">fpr</code></td>
<td>

<p>A vector of false-positive rates for which the building process of the ROC curve is displayed. Default: if length of <code>x$t</code> is lower than 150, such vector is taken as <code>fpr</code>; otherwise, an equally-space vector of length 100 covering the range of the marker is considered.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_h">h</code></td>
<td>

<p>A vector of length 2 with the bandwidth used to compute kernel density estimation for controls and cases, respectively. See <code>adjust</code> parameter in <code>density</code> function from <span class="pkg">stats</span> package. Default: <code>h = c(1,1)</code>.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_histogram">histogram</code></td>
<td>

<p>If TRUE, histograms are displayed on the left instead of kernel density estimates. Default: FALSE. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_breaks">breaks</code></td>
<td>

<p>If <code>histogram = TRUE</code>, number of breaks used for the histograms. Default: 15.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_reduce">reduce</code></td>
<td>

<p>If FALSE, two extra graphics are displayed at the bottom (see Details for more information). Default: TRUE. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_completeroc">completeROC</code></td>
<td>

<p>A logical value indicating if the whole ROC curve should be displayed in light gray or not. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_videobar">videobar</code></td>
<td>

<p>If TRUE, a text progress bar is shown in the R console. Default: TRUE.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, a progress bar is displayed for computationally intensive methods. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_file">file</code></td>
<td>

<p>File name of the movie (with the extension). Default: <code>"animation1.gif"</code>.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_save">save</code></td>
<td>

<p>If TRUE, video is saved as a GIF by using the <code>saveGIF</code> function in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package. Default: TRUE.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_legends">legends</code></td>
<td>

<p>If TRUE, a legend with colors meaning is displayed on the left graphic and the AUC is shown on the right graphic. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_speedcorrection">speedcorrection</code></td>
<td>

<p>If TRUE, only some FPR in <code>fpr</code> vector are considered to make the video faster. Default: FALSE. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_tpause">tpause</code></td>
<td>

<p>If <code>save = FALSE</code>, time interval to suspend execution for, in seconds. Default: 1.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_interval">interval</code></td>
<td>

<p>If <code>save = TRUE</code>, a positive number to set the time interval of the animation (unit in seconds) in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package. Default: 0.2.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_ani.width">ani.width</code>, <code id="movieROC_+3A_ani.height">ani.height</code></td>
<td>

<p>If <code>save = TRUE</code>, width and height of image frames (unit in px) in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_xlab">xlab</code>, <code id="movieROC_+3A_ylab">ylab</code></td>
<td>

<p>Label for x- and y-axis on the left plot. <code>ylab</code> not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_main.density">main.density</code></td>
<td>

<p>Title for the left plot. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_cex.lab">cex.lab</code>, <code id="movieROC_+3A_cex.axis">cex.axis</code>, <code id="movieROC_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for labels, axis annotation and main titles, respectively, relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_cex">cex</code></td>
<td>

<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default. Default: 0.8. Not available for object of class &lsquo;groc&rsquo; (<code>cex=1</code> in this case).</p>
</td></tr>
<tr><td><code id="movieROC_+3A_cex.point">cex.point</code></td>
<td>

<p>The magnification to be used for the particular point on the ROC curve and its text, relative to the current setting of <code>cex</code>. Default: <code>cex.point = 1.5</code>. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_xlim">xlim</code>, <code id="movieROC_+3A_ylim">ylim</code></td>
<td>

<p>Range for x- and y-axis on the left plot. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_lim.density">lim.density</code></td>
<td>

<p>If <code>xlim</code> is <code>NULL</code>, lower limit for the density estimate to compute the range for the x-axis on the left plot. Default: 0.01. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_lty.curve">lty.curve</code>, <code id="movieROC_+3A_lwd.curve">lwd.curve</code>, <code id="movieROC_+3A_col.curve">col.curve</code></td>
<td>

<p>The line type, width and color for ROC curve. Default: <code>lty.curve = 1</code> (solid), <code>lwd.curve = 2</code> and <code>col.curve = "black"</code>.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_mar">mar</code></td>
<td>

<p>A numerical vector of the form c(bottom, left, top, right) which gives the number of lines of margin to be specified on the four sides of the plot. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_col.controlscases">col.controlscases</code></td>
<td>

<p>Vector of length 2 with the color used to control and case group, respectively. Default: <code>c('#485C99','#8F3D52')</code>.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_col.threshold">col.threshold</code></td>
<td>

<p>Color for the chosen point. Default: <code>"FCBA04"</code>.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_border">border</code></td>
<td>

<p>If TRUE, a border for the classification subsets is drawn. Default: TRUE. Not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_alpha.points">alpha.points</code>, <code id="movieROC_+3A_alpha.contour">alpha.contour</code></td>
<td>

<p>Number in [0,1] modifying the opacity alpha of the color for the points and classification region. The <code>adjustcolor</code> function in <span class="pkg">grDevices</span> package is used. Default: <code>alpha.points = 1, alpha.contour = 0.25</code>. Not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_lf">lf</code></td>
<td>

<p>Epsilon value for steps. Not used.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_display.method">display.method</code></td>
<td>

<p>Method to display the marker values from a &lsquo;multiroc&rsquo; object on the left plot. Methods available: <code>"OV"</code> (projected over two selected components of the marker indicated in <code>displayOV</code>), or <code>"PCA"</code> (projected over the two principal components from a Principal Component Analysis). Default: <code>"PCA"</code>. Only available for object of class &lsquo;multiroc&rsquo;.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_displayov">displayOV</code></td>
<td>

<p>If <code>display.method = "OV"</code>, the two components of the marker used to project the marker values on the left plot. Default: <code>c(1,2)</code> (two first components). Only available for object of class &lsquo;multiroc&rsquo;.</p>
</td></tr>
<tr><td><code id="movieROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed to the <code>saveGIF</code> function in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A video with the building procedure of the ROC curve estimate with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# Standard ROC curve for gene 20202438
roc_cg20202438 &lt;- gROC(X = HCC$cg20202438, D = HCC$tumor, side = "right")

### Do not change the \code{save} parameter to save the video in a GIF
### with the name "video_cg20202438":
movieROC(roc_cg20202438, file = "video_cg20202438.gif", save = FALSE)

# Multivariate ROC curve for genes 0202438, 18384097, and 03515901
multiroc_PT &lt;- multiROC(X = cbind(HCC$cg20202438, HCC$cg18384097, HCC$cg03515901),
    D = HCC$tumor, method = "fixedLinear", methodLinear = "PepeThompson")

# Two first components from PCA:
### Do not change the \code{save} parameter to save the video in a GIF
### with the name "video_multiroc_pca":
movieROC(multiroc_PT, file = "video_multiroc_pca.gif", save = FALSE)


### Do not change the \code{save} parameter to save the video in a GIF
### with the name "video_multiroc_orig":
movieROC(multiroc_PT, display.method = "OV", displayOV = c(1,3),
    file = "video_multiroc_orig.gif", cex = 1.2, xlab = "Gene 20202438",
    ylab = "Gene 03515901", lwd.curve = 4, save = FALSE)
  
</code></pre>

<hr>
<h2 id='movieROC2_densities'>
Create a video with the building procedure of the smooth ROC curve estimate
</h2><span id='topic+movieROC2_densities'></span>

<h3>Description</h3>

<p>This function tracks the construction of the standard ROC curve (right- or left-sided, depending on the <code>side</code> of the object of class &lsquo;groc&rsquo; included) resulting from the kernel density function estimation for controls and cases. Four graphics are displayed: top-left, the kernel density estimates; top-right, the resulting ROC curve; bottom-left, boxplots and points for controls and cases and classification subset in gray color; bottom-right, classification subsets for every FPR until the current one. It makes use of the <code><a href="#topic+plot_densityROC">plot_densityROC</a></code> function for each screenshot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movieROC2_densities(obj, h = c(1, 1), cut.off = NULL, completeROC = FALSE,
  legends = FALSE, videobar = TRUE, file = "animation1.gif", clean = FALSE,
  interval = 0.2, ani.width = 500, ani.height = 750, save = TRUE,
  tpause = 1, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movieROC2_densities_+3A_obj">obj</code></td>
<td>

<p>An object of class &lsquo;groc&rsquo; with <code>side = "right"</code> or <code>"left"</code>.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_h">h</code></td>
<td>

<p>A vector of length 2 with the bandwidth used to compute kernel density estimation for controls and cases, respectively. See <code>adjust</code> parameter in <code>density</code> function from <span class="pkg">stats</span> package. Default: <code>h = c(1,1)</code>.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_cut.off">cut.off</code></td>
<td>

<p>Vector with marker cutoffs for which the graphics are displayed. Default: if number of unique marker values is lower than 150, these are considered; otherwise, a equally-spaced grid of length 102 in the range of the marker is used.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_save">save</code></td>
<td>

<p>If TRUE, video is saved as a GIF by using the <code>saveGIF</code> function in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package. Default: TRUE.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_completeroc">completeROC</code></td>
<td>

<p>A logical value indicating if the whole ROC curve should be displayed in light gray or not. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_legends">legends</code></td>
<td>

<p>If TRUE, legends with the meaning of colors are displayed. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_videobar">videobar</code></td>
<td>

<p>If TRUE, a text progress bar is shown in the R console. Default: TRUE.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_file">file</code></td>
<td>

<p>File name of the movie (with the extension). Default: <code>"animation1.gif"</code>.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_clean">clean</code></td>
<td>

<p>Whether to delete the individual image frames in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_interval">interval</code></td>
<td>

<p>A positive number to set the time interval of the animation (unit in seconds) in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package. Default: 0.2.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_ani.width">ani.width</code>, <code id="movieROC2_densities_+3A_ani.height">ani.height</code></td>
<td>

<p>Width and height of image frames (unit in px) in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_tpause">tpause</code></td>
<td>

<p>If <code>save = FALSE</code>, time interval to suspend execution for, in seconds. Default: 1.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, a progress bar is displayed for computationally intensive methods. Default: FALSE.</p>
</td></tr>
<tr><td><code id="movieROC2_densities_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed to the <code>saveGIF</code> function in <a href="https://CRAN.R-project.org/package=animation"><span class="pkg">animation</span></a> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A video with the building procedure of the smooth ROC curve estimate with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# Standard ROC curve for gene 20202438
roc_cg20202438 &lt;- gROC(X = HCC$cg20202438, D = HCC$tumor)

### Do not change the \code{save} parameter to save the video in a GIF
### with the name "video_cg20202438_smooth":
movieROC2_densities(roc_cg20202438, file = "video_cg20202438_smooth.gif", save = FALSE)
</code></pre>

<hr>
<h2 id='multiROC'>
Build a ROC curve for a multivariate marker with dimension higher than two
</h2><span id='topic+multiROC'></span><span id='topic+multiROC.default'></span>

<h3>Description</h3>

<p>This is one of the main functions of the movieROC package.
It builds a multivariate ROC curve by considering one of these methods:
i) fitting a binary logistic regression model with a particular combination
(fixed by the user) of the two components on the right-hand side,
ii) linear combinations with fixed parameters, or
iii) linear combinations with dynamic parameters.
It returns a &lsquo;multiroc&rsquo; object, a list of class &lsquo;multiroc&rsquo;.
This object can be <code>print</code>ed or <code>plot</code>ted. It may be also passed to
<code><a href="#topic+plot.buildROC">plot.buildROC</a></code> and <code><a href="#topic+movieROC">movieROC</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiROC(X, D, ...)
## Default S3 method:
multiROC(X, D, method = c("lrm", "fixedLinear",
        "dynamicMeisner", "kernelOptimal"),
    formula.lrm = "D ~ X.1 + I(X.1^2) + X.2 + I(X.2^2) + I(X.1*X.2)",
    stepModel = TRUE, coefLinear = rep(1, ncol(X)),
    methodLinear = c("coefLinear", "SuLiu", "PepeThompson", "logistic", "minmax"),
    alpha = 0.5, approxh = 0.5, multiplier = 2, kernelOptimal.H =
        c("Hpi", "Hscv", "Hns", "Hlscv", "Hscv.diag", "Hpi.diag", "Hlscv.diag"),
    eps = sqrt(.Machine$double.eps), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiROC_+3A_x">X</code></td>
<td>

<p>Matrix (dimension <code class="reqn">n \times p</code>) of marker values where <code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the dimension of the multivariate marker.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_d">D</code></td>
<td>

<p>Vector of response values. Two levels; if more, the two first ones are used.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_method">method</code></td>
<td>

<p>Method used to build the classification regions. One of <code>"lrm"</code> (fitting a binary logistic regression model by the input parameter <code>formula</code>), <code>"fixedLinear"</code> (linear frontiers with fixed parameters given in <code>coefLinear</code>), <code>"dynamicMeisner"</code> (linear frontiers with dynamic parameters reported by Meisner et al. (2021) method), or <code>"kernelOptimal"</code> (estimating optimal transformation based on bivariate kernel density estimation by Mart√≠nez-Camblor et al. (2021) using the <code>kde</code> function in the <a href="https://CRAN.R-project.org/package=ks"><span class="pkg">ks</span></a> package). Default: <code>"lrm"</code>.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_formula.lrm">formula.lrm</code></td>
<td>

<p>If <code>method = "lrm"</code>, the transformation employed in the right-hand side of the logistic regression model (in terms of <code>X.1</code>, <code>X.2</code> <code>dots</code>, <code>X.p</code>, and <code>D</code>). Default: quadratic formula for the two first components <code>X.1</code> and <code>X.2</code>.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_stepmodel">stepModel</code></td>
<td>

<p>If TRUE and <code>method = "lrm"</code>, a model selection is performed based on the AIC (Akaike information criterion) in a stepwise algorithm (see <code>step</code> function for more information). Default: TRUE.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_coeflinear">coefLinear</code></td>
<td>

<p>If <code>method = "fixedLinear"</code> and <code>methodLinear = "coefLinear"</code>, a vector of length <code class="reqn">p</code> with the coefficients <code class="reqn">\beta_i</code> (<code class="reqn">i \in  \{1, \dots, p\}</code>) used to <code class="reqn">\mathcal{L}_{\boldsymbol{\beta}}(\boldsymbol{X}) = \beta_1 X_1 + \dots + \beta_p X_p</code>. Default: <code class="reqn">(1,\dots,1)</code>.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_methodlinear">methodLinear</code></td>
<td>

<p>If <code>method = "fixedLinear"</code>, method used to build the classification regions. One of <code>"coefLinear"</code> (particular fixed coefficients in <code>coefLinear</code>), <code>"SuLiu"</code> (Su and Liu, 1993), <code>"PepeThompson"</code> (Pepe and Thompson, 2000), <code>"logistic"</code> (logistic regression model), <code>"minmax"</code> (Liu et al., 2011). Default: <code>"coefLinear"</code>.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_alpha">alpha</code>, <code id="multiROC_+3A_approxh">approxh</code>, <code id="multiROC_+3A_multiplier">multiplier</code></td>
<td>

<p>If <code>method = "dynamicMeisner"</code>, input parameters used in the <code>maxTPR</code> function of the <a href="https://CRAN.R-project.org/package=maxTPR"><span class="pkg">maxTPR</span></a> package. Default: <code>alpha = 0.5</code>, <code>approxh = 0.5</code> and <code>multiplier = 2</code>.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_kerneloptimal.h">kernelOptimal.H</code></td>
<td>

<p>If <code>method = "kernelOptimal"</code>, the bandwidth matrix <code>H</code> used in the <code>kde</code> function of the <a href="https://CRAN.R-project.org/package=ks"><span class="pkg">ks</span></a> package. Default: <code>"Hpi"</code> (plug-in bandwidth selector).</p>
</td></tr>
<tr><td><code id="multiROC_+3A_eps">eps</code></td>
<td>

<p>Epsilon value to consider. Default: <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, a progress bar is displayed for computationally intensive methods. Default: FALSE.</p>
</td></tr>
<tr><td><code id="multiROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &lsquo;multiroc&rsquo; with the following fields:
</p>
<table>
<tr><td><code>controls</code>, <code>cases</code></td>
<td>
<p>Marker values of negative and positive subjects, respectively.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>Levels of response values.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Vector of false-positive rates.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>Vector of values of the ROC curve for <code>t</code>.</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>Area under the curve estimate.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>If <code>method = "lrm"</code>, <code>"fixedLinear"</code>, or <code>"kernelOptimal"</code>, resulting
univariate marker values.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>If <code>method = "lrm"</code>, <code>"fixedLinear"</code>, or <code>"kernelOptimal"</code>, vector of final
marker thresholds resulting in (<code>t</code>, <code>roc</code>).</p>
</td></tr>
<tr><td><code>CoefTable</code></td>
<td>
<p>If <code>method = "dynamicMeisner"</code> or <code>"dynamicEmpirical"</code>, a list of length equal to length of vector <code>t</code>. Each element of the list keeps the linear coefficients (<code>coef</code>), threshold for such linear combination (<code>c</code>), the corresponding point in the ROC curve (<code>t</code>, <code>roc</code>), the resulting univariate marker values (<code>Z</code>) and a matrix of dimension 100 <code class="reqn">\times</code> 100 with the marker values over a grid of (<code class="reqn">X_1</code>, <code class="reqn">X_2</code>) bivariate values (<code>f</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Q. Su and J. S. Liu. (1993) &ldquo;Linear combinations of multiple diagnostic markers&rdquo;. <em>Journal of the American Statistical Association</em>, <b>88</b>(424): 1350‚Äì1355. DOI: <a href="https://doi.org/10.1080/01621459.1993.10476417">doi:10.1080/01621459.1993.10476417</a>.
</p>
<p>M. S. Pepe and M. L. Thompson (2000) &ldquo;Combining diagnostic test results to increase accuracy&rdquo;. <em>Biostatistics</em>, <b>1</b>
(2):123‚Äì140. DOI: <a href="https://doi.org/10.1093/biostatistics/1.2.123">doi:10.1093/biostatistics/1.2.123</a>.
</p>
<p>C. Liu, A. Liu, and S. Halabi (2011) &ldquo;A min‚Äìmax combination of biomarkers to improve diagnostic accuracy&rdquo;. <em>Statistics in Medicine</em>, <b>30</b>(16): 2005‚Äì2014. DOI: <a href="https://doi.org/10.1002/sim.4238">doi:10.1002/sim.4238</a>.
</p>
<p>P. Mart√≠nez-Camblor, S. P√©rez-Fern√°ndez, and S. D√≠az-Coto (2021) &ldquo;Optimal classification scores based on multivariate marker transformations&rdquo;. <em>AStA Advances in Statistical Analysis</em>, <b>105</b>(4): 581‚Äì599. DOI: <a href="https://doi.org/10.1007/s10182-020-00388-z">doi:10.1007/s10182-020-00388-z</a>.
</p>
<p>A. Meisner, M. Carone, M. S. Pepe, and K. F. Kerr (2021) &ldquo;Combining biomarkers by maximizing the true positive rate for a fixed false positive rate&rdquo;. <em>Biometrical Journal</em>, 63(6): 1223‚Äì1240. DOI: <a href="https://doi.org/10.1002/bimj.202000210">doi:10.1002/bimj.202000210</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# ROC curve for genes 20202438, 18384097, and 03515901 to identify tumor
# by 4 different methods:
X &lt;- cbind(HCC$cg20202438, HCC$cg18384097, HCC$cg03515901); D &lt;- HCC$tumor
## 1. Linear combinations with fixed parameters by Pepe and Thompson (2000)
multiROC(X, D, method = "fixedLinear", methodLinear = "PepeThompson")
## 2.Linear combinations with dynamic parameters by Meisner et al. (2021)

### Time consuming
multiROC(X, D, method = "dynamicMeisner")
## 3. Logistic regression model with quadratic formula by default
multiROC(X, D)
## 4. Optimal transformation with multivariate KDE by Mart√≠nez-Camblor et al. (2021)
multiROC(X, D, method = "kernelOptimal")
</code></pre>

<hr>
<h2 id='plot'>
Plot an ROC curve
</h2><span id='topic+plot'></span><span id='topic+plot.groc'></span><span id='topic+plot.hroc'></span><span id='topic+plot.biroc'></span><span id='topic+plot.multiroc'></span>

<h3>Description</h3>

<p>This is one of the core functions of the movieROC package. It displays the empirical ROC curve estimate from an object of class &lsquo;groc&rsquo;, &lsquo;hroc&rsquo;, &lsquo;biroc&rsquo; , or &lsquo;multiroc&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
plot(x, xlim = c(0, 1), ylim = c(0, 1), lwd = 3, 
  xlab = "False-Positive Rate", ylab = "True-Positive Rate", main = "ROC curve", 
  cex.lab = 1.25, cex.main = 1.5, type = NULL, new = TRUE, ...)
## S3 method for class 'hroc'
plot(x, type = 'S', xlim = c(0,1), ylim = c(0,1), 
  lwd = 3, xlab = "False-Positive Rate", ylab = "True-Positive Rate", 
  main = "ROC Curve", cex.lab = 1.25, cex.main = 1.5, new = TRUE, ...)
## S3 method for class 'biroc'
plot(x, ...)
## S3 method for class 'multiroc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>

<p>An ROC curve object from movieROC package. Possible classes are: &lsquo;groc&rsquo; (output of <code>gROC</code> function), &lsquo;hroc&rsquo; (output of <code>hROC</code> function), &lsquo;biroc&rsquo; (output of <code>biROC</code> function), and &lsquo;multiroc&rsquo; (output of <code>multiROC</code> function).</p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code>, <code id="plot_+3A_ylim">ylim</code></td>
<td>

<p>Range for x- and y-axis. Default: unit interval.</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd">lwd</code></td>
<td>

<p>Line width of the ROC curve. Default: 3.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code>, <code id="plot_+3A_ylab">ylab</code></td>
<td>

<p>Label for x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>

<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_cex.lab">cex.lab</code>, <code id="plot_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for labels and main title, respectively, relative to the current setting of <code>cex</code>. Default: <code>cex.lab = 1.25, cex.main = 1.5</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>

<p>What type of plot should be drawn (see help from <code>plot</code> function in <span class="pkg">base</span> package). Default: <code>type = "s"</code> (stair steps), except for <code>x</code> object from <code>gROC_param</code> function, in which case <code>type = "l"</code> (lines).</p>
</td></tr>
<tr><td><code id="plot_+3A_new">new</code></td>
<td>

<p>If TRUE, a new plot is displayed; otherwise, the ROC curve is plotted over the existing graphic. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>

<p>Other graphical parameters to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the ROC curve with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)
# ROC curve estimates for gene 03515901 and response tumor
rroc &lt;- gROC(X = HCC[,"cg03515901"], D = HCC$tumor) # Right-sided
lroc &lt;- gROC(X = HCC[,"cg03515901"], D = HCC$tumor, side = "left") # Left-sided
hroc &lt;- hROC(X = HCC[,"cg03515901"], D = HCC$tumor) # Transformed by a cubic polinomial

plot(rroc, lty = 2, frame = FALSE)
plot(lroc, new = FALSE)
plot(hroc, new = FALSE, col = "blue")
legend("topleft", legend = c("Right-sided", "Left-sided", "Transformed marker"),
    col = c("black", "black", "blue"), lty = c(1,2,1), lwd = 2, bty = "n")

# ROC curve estimate for genes 20202438 and 18384097 to simultaneously identify tumor
# by a logistic regression model with quadratic formula
biroc &lt;- biROC(X = cbind(HCC$cg20202438, HCC$cg18384097), D = HCC$tumor)
plot(biroc)
legend("bottomright", paste("AUC = ", format(biroc$auc, digits = 3)))

# ROC curve estimate for genes 20202438, 18384097 and 03515901 to simultaneously 
# identify tumor by a linear combinations with fixed parameters by Pepe and Thompson (2000)
multiroc &lt;- multiROC(X = cbind(HCC$cg20202438, HCC$cg18384097, HCC$cg03515901), 
    D = HCC$tumor, method = "fixedLinear", methodLinear = "PepeThompson")
plot(multiroc)
legend("bottomright", paste("AUC = ", format(multiroc$auc, digits = 3)))
</code></pre>

<hr>
<h2 id='plot_densities'>
Plot density function estimates for controls and cases
</h2><span id='topic+plot_densities'></span>

<h3>Description</h3>

<p>This function plots the kernel density function estimates for controls and cases from an object of class &lsquo;groc&rsquo;. It offers the possibility of plotting the histograms instead of the smooth estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_densities(obj, h = c(1, 1), histogram = FALSE, breaks = 15, 
  col = c("#485C99", "#8F3D52"), lwd = 2, xlim = NULL, ylim = NULL, 
  xaxs = "i", yaxs = "i", xlab = "Marker", ylab = "f(x)", 
  main = "Density functions", legend = FALSE, pos.legend = "topright", 
  cex.lab = 1.5, cex.axis = 1.5, cex.main = 2, cex.legend = 1, 
  eps = sqrt(.Machine$double.eps), new = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_densities_+3A_obj">obj</code></td>
<td>

<p>An object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_h">h</code></td>
<td>

<p>A vector of length 2 with the bandwidth used to compute kernel density estimation for controls and cases, respectively. See <code>adjust</code> parameter in <code>density</code> function from <span class="pkg">stats</span> package. Default: <code>h = c(1,1)</code>.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_histogram">histogram</code></td>
<td>

<p>If TRUE, histograms are displayed instead of kernel density estimates. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_breaks">breaks</code></td>
<td>

<p>If <code>histogram = TRUE</code>, number of breaks used for the histograms. Default: 15.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_col">col</code></td>
<td>

<p>A vector of length 2 with color used for controls and cases, respectively. Default: <code>c("#485C99", "#8F3D52")</code>.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_lwd">lwd</code></td>
<td>

<p>Line width for the density function or histogram. Default: 2.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_xlim">xlim</code>, <code id="plot_densities_+3A_ylim">ylim</code></td>
<td>

<p>Range for x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_xaxs">xaxs</code>, <code id="plot_densities_+3A_yaxs">yaxs</code></td>
<td>

<p>The style of axis interval calculation to be used for the x- and the y-axis, respectively. Default: <code>"i"</code> (internal; just finds an axis with pretty labels that fits within the original data range). For more information, see help for <code>par</code>.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_xlab">xlab</code>, <code id="plot_densities_+3A_ylab">ylab</code></td>
<td>

<p>Label for x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_main">main</code></td>
<td>

<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_cex.lab">cex.lab</code>, <code id="plot_densities_+3A_cex.axis">cex.axis</code>, <code id="plot_densities_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for labels, axis annotation and main titles, respectively, relative to the current setting of <code>cex</code>. Default: <code>cex.lab = 1.5, cex.axis = 1.5, cex.main = 2</code>.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_legend">legend</code></td>
<td>

<p>If TRUE, a legend with the meaning of colors is displayed on the left plot. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_pos.legend">pos.legend</code>, <code id="plot_densities_+3A_cex.legend">cex.legend</code></td>
<td>

<p>The position and magnification to be used for legend, relative to the current setting of <code>cex</code>. Default: <code>pos.legend = "topright", cex.legend = 1</code>.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_eps">eps</code></td>
<td>

<p>Epsilon value to consider. Default: <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_new">new</code></td>
<td>

<p>If TRUE, a new plot is displayed; otherwise, density estimates are displayed over the current plot. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot_densities_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the kernel density function estimates for both populations with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)
roc_cg20202438 &lt;- gROC(X = HCC$cg20202438, D = HCC$tumor)
plot_densities(roc_cg20202438, main = "Density functions and histogram")
plot_densities(roc_cg20202438, histogram = TRUE, new = FALSE)
</code></pre>

<hr>
<h2 id='plot_densityROC'>
Plot standard smooth ROC curve estimate
</h2><span id='topic+plot_densityROC'></span>

<h3>Description</h3>

<p>This function estimates the standard ROC curve (right- or left-sided, depending on the <code>side</code> of the object of class &lsquo;groc&rsquo; included) resulting from the kernel density function estimation for controls and cases. Two graphics are displayed: left, the kernel density estimates; right, the resulting ROC curve. Two extra graphics may be shown at the bottom if the used introduces a value for the input parameter <code>C</code>: left, boxplots and points for controls and cases and corresponding classification subset in gray color; right, classification subsets for every FPR until the one corresponding to the chosen <code>C</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_densityROC(obj, h = c(1, 1), C = NULL, build.process = FALSE, 
  completeROC = TRUE, legends = FALSE, rel.tol = 0.001, 
  par.specify = FALSE, cex.lab = 1.5, cex.axis = 1.25, cex.main = 1.75, 
  lwd = 2, col = c("#485C99", "#8F3D52"), col.roc = "blue", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_densityROC_+3A_obj">obj</code></td>
<td>

<p>An object of class &lsquo;groc&rsquo; with <code>side = "right"</code> or <code>"left"</code>.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_h">h</code></td>
<td>

<p>A vector of length 2 with the bandwidth used to compute kernel density estimation for controls and cases, respectively. See <code>adjust</code> parameter in <code>density</code> function from <span class="pkg">stats</span> package. Default: <code>h = c(1,1)</code>.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_c">C</code></td>
<td>

<p>Marker cutoff for which the graphics are displayed. Default: none.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_build.process">build.process</code></td>
<td>

<p>If FALSE, the whole ROC curve is displayed; otherwise, if <code>completeROC = TRUE</code>, the portion of the ROC curve until the fixed FPR (resulting from the chosen <code>C</code>) is highlighted in black and the rest is shown in gray. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_completeroc">completeROC</code></td>
<td>

<p>If <code>build.process = TRUE</code>, a logical value indicating if the whole ROC curve should be displayed in light gray or not. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_legends">legends</code></td>
<td>

<p>If TRUE, legends with the meaning of colors are displayed. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_rel.tol">rel.tol</code></td>
<td>

<p>Relative accuracy requested for the <code>integrate</code> function from <span class="pkg">stats</span> package. Default: 0.001.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_par.specify">par.specify</code></td>
<td>

<p>If FALSE, graphics are organized in one row and two columns. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_cex.lab">cex.lab</code>, <code id="plot_densityROC_+3A_cex.axis">cex.axis</code>, <code id="plot_densityROC_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for labels, axis annotation and main titles, respectively, relative to the current setting of <code>cex</code>. Default: <code>cex.lab = 1.5, cex.axis = 1.25, cex.main = 1.75</code>.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_lwd">lwd</code>, <code id="plot_densityROC_+3A_col.roc">col.roc</code></td>
<td>

<p>Line width and color for the ROC curve. Default: <code>lwd = 2, col.roc = "blue"</code>.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_col">col</code></td>
<td>

<p>A vector of length 2 with color used for controls and cases, respectively. Default: <code>c("#485C99", "#8F3D52")</code>.</p>
</td></tr>
<tr><td><code id="plot_densityROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the standard smooth ROC curve estimate with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)
roc_cg20202438 &lt;- gROC(X = HCC$cg20202438, D = HCC$tumor)
plot_densityROC(roc_cg20202438)
plot_densityROC(roc_cg20202438, h = c(2,2))
</code></pre>

<hr>
<h2 id='plot.buildROC'>
Plot the building procedure of the ROC curve
</h2><span id='topic+plot.buildROC'></span><span id='topic+plot.buildROC.groc'></span><span id='topic+plot.buildROC.biroc'></span><span id='topic+plot.buildROC.multiroc'></span>

<h3>Description</h3>

<p>This function tracks the ROC curve. It plots two graphics in the same figure:
right, the empirical ROC curve estimate; left, classification subset for a 
particular FPR or threshold(s) for the marker (threshold only for object of class &lsquo;groc&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'buildROC'
plot(x, ...)
## S3 method for class 'groc'
plot.buildROC(x, FPR = NULL, C = NULL, XL = NULL, XU = NULL, h = c(1,1), 
    histogram = FALSE, breaks = 15, reduce = TRUE, build.process = FALSE, 
    completeROC = FALSE, new.window = FALSE, legends = FALSE, type = 's', 
    cex.point = 1.5, lwd.curve = 2, mar = NULL, lim.density = 0.01, xlim = NULL, 
    ylim = NULL, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2, xlab = "Marker", 
    main.density = "Density functions", col.controlscases = c('#485C99','#8F3D52'), 
    col.threshold = '#FCBA04', col.curve = 'black', eps = sqrt(.Machine$double.eps), 
    ...)
## S3 method for class 'biroc'
plot.buildROC(x, FPR = 0.15, build.process = FALSE, completeROC = TRUE, 
    new = FALSE, new.window = FALSE, border = TRUE, cutoff = TRUE, 
    legends = FALSE, type = 's', col.controlscases = c('#485C99','#8F3D52'), 
    col.threshold = '#FCBA04', col.curve = 'black', cex.point = 1.5, 
    alpha.points = .75, alpha.contour = 0.25, lwd.curve = 2, lty.curve = 1, 
    cex = 0.8, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2, xlab = "X1", ylab = "X2", 
    lf = NULL, eps = sqrt(.Machine$double.eps), ...)
## S3 method for class 'multiroc'
plot.buildROC(x, FPR = 0.15, display.method = c("PCA", "OV"), 
    displayOV = c(1,2), build.process = FALSE, completeROC = TRUE, 
    new = FALSE, new.window = FALSE, border = FALSE, cutoff = TRUE, legends = FALSE, 
    type = 's', col.controlscases = c('#485C99','#8F3D52'), 
    col.threshold = '#FCBA04', col.curve = 'black', cex.point = 1.5, 
    alpha.points = .75, alpha.contour = 0.25, lwd.curve = 2, lty.curve = 1, 
    cex = 0.8, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2, xlab = NULL, ylab = NULL, 
    lf = NULL, eps = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.buildROC_+3A_x">x</code></td>
<td>

<p>An ROC curve object from movieROC package. Possible classes are: &lsquo;groc&rsquo; (output of <code>gROC</code> function), &lsquo;biroc&rsquo; (output of <code>biROC</code> function), and &lsquo;multiroc&rsquo; (output of <code>multiROC</code> function).</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_fpr">FPR</code></td>
<td>

<p>False-positive rate for which the left plot is computed. Default: 0.15.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_c">C</code></td>
<td>

<p>Marker cutoff for which the left plot is computed. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_xl">XL</code>, <code id="plot.buildROC_+3A_xu">XU</code></td>
<td>

<p>Marker cutoffs for which the left plot is computed. Only available for object of class &lsquo;groc&rsquo; with <code>side = "both"</code> or <code>"both2"</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_h">h</code></td>
<td>

<p>A vector of length 2 with the bandwidth used to compute kernel density estimation for controls and cases, respectively. See <code>adjust</code> parameter in <code>density</code> function from <span class="pkg">stats</span> package. Default: <code>h = c(1,1)</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_histogram">histogram</code></td>
<td>

<p>If TRUE, histograms are displayed on the left instead of kernel density estimates. Default: FALSE. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_breaks">breaks</code></td>
<td>

<p>If <code>histogram = TRUE</code>, number of breaks used for the histograms. Default: 15.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_reduce">reduce</code></td>
<td>

<p>If FALSE, two extra graphics are displayed at the bottom (see Details for more information). Default: TRUE. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_build.process">build.process</code></td>
<td>

<p>If FALSE, the whole ROC curve is displayed; otherwise, if <code>completeROC = TRUE</code>, the portion of the ROC curve until the fixed FPR is highlighted in black and the rest is shown in gray. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_completeroc">completeROC</code></td>
<td>

<p>If <code>build.process = TRUE</code>, a logical value indicating if the whole ROC curve should be displayed in light gray or not. Default: FALSE for &lsquo;groc&rsquo; object; TRUE for &lsquo;biroc&rsquo; and &lsquo;multiroc&rsquo; objects.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_new.window">new.window</code>, <code id="plot.buildROC_+3A_new">new</code></td>
<td>

<p>If TRUE, graphics are displayed in a new window. Default: FALSE. <code>new</code> not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_legends">legends</code></td>
<td>

<p>If TRUE, a legend with colors meaning is displayed on the left graphic and the AUC is shown on the right graphic. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_type">type</code>, <code id="plot.buildROC_+3A_lty.curve">lty.curve</code>, <code id="plot.buildROC_+3A_lwd.curve">lwd.curve</code>, <code id="plot.buildROC_+3A_col.curve">col.curve</code></td>
<td>

<p>The line type, width and color for ROC curve. Default: <code>type = "s"</code> (stair steps), <code>lty.curve = 1</code> (solid), <code>lwd.curve = 2</code> and <code>col.curve = "black"</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_cex.lab">cex.lab</code>, <code id="plot.buildROC_+3A_cex.axis">cex.axis</code>, <code id="plot.buildROC_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for labels, axis annotation and main titles, respectively, relative to the current setting of <code>cex</code>. Default: <code>cex.lab = 1.5, cex.axis = 1.5, cex.main = 2</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_cex">cex</code></td>
<td>

<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default. Default: 0.8. Not available for object of class &lsquo;groc&rsquo; (<code>cex=1</code> in this case).</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_cex.point">cex.point</code></td>
<td>

<p>The magnification to be used for the particular point on the ROC curve and its text, relative to the current setting of <code>cex</code>. Default: <code>cex.point = 1.5</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_xlim">xlim</code>, <code id="plot.buildROC_+3A_ylim">ylim</code></td>
<td>

<p>Range for x- and y-axis on the left plot. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_lim.density">lim.density</code></td>
<td>

<p>If <code>xlim</code> is <code>NULL</code>, lower limit for the density estimate to compute the range for the x-axis on the left plot. Default: 0.01. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_xlab">xlab</code>, <code id="plot.buildROC_+3A_ylab">ylab</code></td>
<td>

<p>Label for x- and y-axis on the left plot. <code>ylab</code> not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_main.density">main.density</code></td>
<td>

<p>Title for the left plot. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_col.controlscases">col.controlscases</code></td>
<td>

<p>Vector of length 2 with the color used to control and case group, respectively. Default: <code>c('#485C99','#8F3D52')</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_col.threshold">col.threshold</code></td>
<td>

<p>Color for the chosen point. Default: <code>"FCBA04"</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_mar">mar</code></td>
<td>

<p>A numerical vector of the form c(bottom, left, top, right) which gives the number of lines of margin to be specified on the four sides of the plot. Only available for a &lsquo;groc&rsquo; object.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_eps">eps</code></td>
<td>

<p>Epsilon value to consider. Default: <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_border">border</code></td>
<td>

<p>If TRUE, a border for the classification subsets is drawn. Default: TRUE for &lsquo;biroc&rsquo; object and FALSE for &lsquo;multiroc&rsquo; object. Not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_cutoff">cutoff</code></td>
<td>

<p>If TRUE, the cutoff value for the resulting univariate marker is displayed on the right plot (ROC curve). Default: TRUE. Not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_alpha.points">alpha.points</code>, <code id="plot.buildROC_+3A_alpha.contour">alpha.contour</code></td>
<td>

<p>Number in [0,1] modifying the opacity alpha of the color for the points and classification region. The <code>adjustcolor</code> function in <span class="pkg">grDevices</span> package is used. Default: <code>alpha.points = 0.75, alpha.contour = 0.25</code>. Not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_lf">lf</code></td>
<td>

<p>Epsilon value for steps. Not used. Not available for object of class &lsquo;groc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_display.method">display.method</code></td>
<td>

<p>Method to display the marker values from a &lsquo;multiroc&rsquo; object on the left plot. Methods available: <code>"OV"</code> (projected over two selected components of the marker indicated in <code>displayOV</code>), or <code>"PCA"</code> (projected over the two principal components from a Principal Component Analysis). Default: <code>"PCA"</code>. Only available for object of class &lsquo;multiroc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_displayov">displayOV</code></td>
<td>

<p>If <code>display.method = "OV"</code>, the two components of the marker used to project the marker values on the left plot. Default: <code>c(1,2)</code> (two first components). Only available for object of class &lsquo;multiroc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.buildROC_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- For univariate ROC curves:
</p>
<p>It plots two graphics in the same figure:
left, density function estimates for the marker in both populations with the areas 
corresponding to FPR and TPR colored (blue and red, respectively) for a particular 
FPR or threshold(s) for the marker; right, the empirical ROC curve estimate. 
</p>
<p>For an object of class &lsquo;groc&rsquo;, if the input parameter <code>reduce = FALSE</code>, 
two more graphics are displayed at the bottom: 
left, boxplots for the marker distribution in both populations;  
right, classification subsets for every false-positive rate (grey color by default).
</p>
<p>- For multivariate ROC curves:
</p>
<p>Plot two graphics in the same figure: right, the ROC curve highlighting the point and the
threshold for the resulting univariate marker; left, scatterplot with the marker values for controls (blue color) and cases (red color), and the classification subset (in gold color) reporting the false-positive rate selected by the user (if <code>FPR</code> is not <code>NULL</code>).
</p>
<p>If <code>build.process = FALSE</code>, the whole ROC curve is displayed; otherwise, if <code>completeROC = TRUE</code>, 
the portion of the ROC curve until the fixed FPR is highlighted in black and the rest is
shown in gray, while if <code>completeROC = FALSE</code>, only the first portion of the curve is illustrated.
</p>


<h3>Value</h3>

<p>A plot of the building procedure of the ROC curve with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

# Standard ROC curve for gene 20202438
roc_cg20202438 &lt;- gROC(X = HCC$cg20202438, D = HCC$tumor, side = "right")
plot.buildROC(roc_cg20202438)
plot.buildROC(roc_cg20202438, C = .77, build.process = TRUE, reduce = FALSE)

# Multivariate ROC curve for genes 0202438, 18384097, and 03515901
multiroc_PT &lt;- multiROC(X = cbind(HCC$cg20202438, HCC$cg18384097, HCC$cg03515901), 
    D = HCC$tumor, method = "fixedLinear", methodLinear = "PepeThompson")
plot.buildROC(multiroc_PT, cex = 1.2, lwd.curve = 4) # Two first components from PCA
plot.buildROC(multiroc_PT, display.method = "OV", displayOV = c(1,3), 
    cex = 1.2, xlab = "Gene 20202438", ylab = "Gene 03515901", lwd.curve = 4)
</code></pre>

<hr>
<h2 id='plot.funregions'>
Plot the transformation function used for the marker
</h2><span id='topic+plot.funregions'></span><span id='topic+plot.funregions.hroc'></span>

<h3>Description</h3>

<p>This function plots the transformation function used for the marker for an object of class &lsquo;hroc&rsquo;.
Over this graphic, the classification region for a particular FPR chosen by the user is displayed in blue color.
If the user specifies a second FPR (<code>FPR2</code>), the classification region is displayed on the same graphic in red color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funregions'
plot(x, ...)
## S3 method for class 'hroc'
plot.funregions(x, FPR = 0.15, FPR2 = NULL, 
  plot.subsets = TRUE, new.window = FALSE, main = NULL, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.funregions_+3A_x">x</code></td>
<td>

<p>An object of class &lsquo;hroc&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_fpr">FPR</code></td>
<td>

<p>False-positive rate used to display the classification region in blue. Default: 0.15.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_fpr2">FPR2</code></td>
<td>

<p>Other false-positive rate used to display the classification region in red. Default: none.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_plot.subsets">plot.subsets</code></td>
<td>

<p>If TRUE, the classification subsets are displayed. Otherwise, only the transformation function. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_new.window">new.window</code></td>
<td>

<p>If TRUE, graphics are displayed in a new window. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_main">main</code></td>
<td>

<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_ylim">ylim</code></td>
<td>

<p>Range for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.funregions_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the transformation function used for the marker with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

hroc_cg18384097 &lt;- hROC(X = HCC$cg18384097, D = HCC$tumor, 
    formula.lrm = "D ~ rcs(X,8)") 
plot.funregions(hroc_cg18384097)
plot.funregions(hroc_cg18384097, FPR = .1, FPR2 = .5)
</code></pre>

<hr>
<h2 id='plot.regions'>
Plot the classification regions underlying a ROC curve
</h2><span id='topic+plot.regions'></span><span id='topic+plot.regions.groc'></span><span id='topic+plot.regions.hroc'></span>

<h3>Description</h3>

<p>This function plots the classification regions for univariate markers.
It works for objects of class &lsquo;groc&rsquo; and &lsquo;hroc&rsquo;.
Two graphics are displayed in the same figure: left, classification subsets 
for every false-positive rate (grey color by default); right, 90¬∫ rotated ROC curve. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regions'
plot(x, ...)
## S3 method for class 'groc'
plot.regions(x, FPR = 0.15, plot.roc = TRUE, plot.auc = FALSE, 
  col = c("white", "grey"), col.FPR = "blue", lwd = 2, new.window = TRUE, 
  type.plotroc = "s", xlim = NULL, mar = c(5, 6, 4, 0.25), 
  cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.75, main = NULL, 
  xlab = "", ylab = "False-Positive Rate", main.plotroc = "ROC curve", 
  legend = TRUE, cex.legend = 1, ...)
## S3 method for class 'hroc'
plot.regions(x, FPR = 0.15, plot.roc = TRUE, plot.auc = FALSE, 
  col = c('white','grey'), col.FPR = 'blue', lwd = 2, new.window = TRUE, 
  type.plotroc = 's', xlim = NULL, mar = c(5,6,4,0.25), 
  cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.75, main = NULL, 
  xlab = "", ylab = "False-Positive Rate", main.plotroc = "ROC curve", 
  legend = TRUE, cex.legend = 1, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.regions_+3A_x">x</code></td>
<td>

<p>An ROC curve object from a univariate marker. Possible classes are: &lsquo;groc&rsquo; (output of <code>gROC</code> function) and &lsquo;hroc&rsquo; (output of <code>hROC</code> function),</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_fpr">FPR</code></td>
<td>

<p>False-positive rate to be highlighted, both on the ROC curve (right plot) and classification subset (left plot). Default: 0.15.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_plot.roc">plot.roc</code></td>
<td>

<p>If TRUE, the ROC curve is displayed. Default: TRUE.
</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_plot.auc">plot.auc</code></td>
<td>

<p>If TRUE, the AUC is displayed on the plot of the bottomleft corner of the ROC curve plot. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_col">col</code></td>
<td>

<p>Vector of length 2 with colors used for outside and inside of classification subsets, respectively. Default: <code>c("white", "grey")</code>.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_col.fpr">col.FPR</code></td>
<td>

<p>Color used to highlight the <code>FPR</code> chose. Default: <code>"blue"</code>.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_type.plotroc">type.plotroc</code>, <code id="plot.regions_+3A_lwd">lwd</code></td>
<td>

<p>Line type and width for the ROC curve. Default: <code>type.plotroc = "s", lwd = 2</code>.
</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_new.window">new.window</code></td>
<td>

<p>If TRUE, graphics are displayed in a new window. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_xlim">xlim</code></td>
<td>

<p>Range for x-axis on the left plot. Default: range of the marker values.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_mar">mar</code></td>
<td>

<p>A numerical vector of the form c(bottom, left, top, right) which gives the number of lines of margin to be specified on the four sides of the plot.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_cex.lab">cex.lab</code>, <code id="plot.regions_+3A_cex.axis">cex.axis</code>, <code id="plot.regions_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for labels, axis annotation and main titles, respectively, relative to the current setting of <code>cex</code>. Default: <code>cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.75</code>.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_xlab">xlab</code>, <code id="plot.regions_+3A_ylab">ylab</code></td>
<td>

<p>Label for x- and y-axis on the left plot.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_main">main</code>, <code id="plot.regions_+3A_main.plotroc">main.plotroc</code></td>
<td>

<p>Title for the left and the right plot, respectively.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_legend">legend</code></td>
<td>

<p>If TRUE, a legend with the meaning of colors is displayed on the left plot. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_cex.legend">cex.legend</code></td>
<td>

<p>The magnification to be used for legend, relative to the current setting of <code>cex</code>. Default: 1.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, a progress bar is displayed. Default: FALSE.</p>
</td></tr>
<tr><td><code id="plot.regions_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the classification regions underlying a ROC curve with the selected graphical parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)
# 1. Standard ROC curve
roc_cg18384097 &lt;- gROC(X = HCC$cg18384097, D = HCC$tumor)
plot.regions(roc_cg18384097, plot.auc = TRUE)
# 2. gROC curve
groc_cg18384097 &lt;- gROC(X = HCC$cg18384097, D = HCC$tumor, side = "both")
plot.regions(groc_cg18384097, plot.auc = TRUE)
# 3. hROC curve with a restricted cubic splines transformation
hroc_cg18384097 &lt;- hROC(X = HCC$cg18384097, D = HCC$tumor, 
    formula.lrm = "D ~ rcs(X,8)") 
plot.regions(hroc_cg18384097, plot.auc = TRUE)
</code></pre>

<hr>
<h2 id='predict'>
Predict the classification regions for a particular specificity
</h2><span id='topic+predict'></span><span id='topic+predict.groc'></span><span id='topic+predict.hroc'></span>

<h3>Description</h3>

<p>This function prints the classification subsets corresponding to a particular false-positive rate <code>FPR</code> or to cutoff value(s) <code>C</code> or <code>XL, XU</code> introduced by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
predict(object, FPR = NULL, C = NULL, XL = NULL, XU = NULL, ...)
## S3 method for class 'hroc'
predict(object, FPR = 0.15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>

<p>An object of class &lsquo;groc&rsquo; or &lsquo;hroc&rsquo;.</p>
</td></tr>
<tr><td><code id="predict_+3A_fpr">FPR</code></td>
<td>

<p>False-positive rate used to predict the classification region. Default: 0.15 if no cutoff value is provided by the next input parameters.</p>
</td></tr>
<tr><td><code id="predict_+3A_c">C</code></td>
<td>

<p>Cutoff value used to predict the classification region for &lsquo;groc&rsquo; object with <code>side = "right"</code> or <code>"left"</code>. If <code>FPR</code> is provided, <code>C</code> is not used. Default: none.</p>
</td></tr>
<tr><td><code id="predict_+3A_xl">XL</code>, <code id="predict_+3A_xu">XU</code></td>
<td>

<p>Cutoff values used to predict the classification region for &lsquo;groc&rsquo; object with <code>side = "both"</code> or <code>"both2"</code>. If <code>FPR</code> is provided, <code>C</code> is not used. Default: none.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 3 with the following fields:
</p>
<table>
<tr><td><code>ClassSubsets</code></td>
<td>
<p>A matrix with the classification region. Number of rows indicate the number of intervals whose union defines the classification region.</p>
</td></tr>
<tr><td><code>Specificity</code></td>
<td>
<p>Resulting specificity value.</p>
</td></tr>
<tr><td><code>Sensitivity</code></td>
<td>
<p>Resulting sensitivity value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(HCC)

roc &lt;- gROC(X = HCC$cg18384097, D = HCC$tumor) # Right-sided ROC curve
predict(roc, FPR = 0.5)
groc &lt;- gROC(X = HCC$cg18384097, D = HCC$tumor, side = "both") # gROC curve
predict(groc, FPR = 0.5)
hroc_cg18384097 &lt;- hROC(X = HCC$cg18384097, D = HCC$tumor, 
    formula.lrm = "D ~ rcs(X,8)") 
predict(hroc_cg18384097, FPR = 0.5)
</code></pre>

<hr>
<h2 id='print'>
Print an ROC curve object
</h2><span id='topic+print.groc'></span><span id='topic+print.hroc'></span><span id='topic+print.biroc'></span><span id='topic+print.multiroc'></span>

<h3>Description</h3>

<p>This function prints information about an ROC curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
print(x, ...)
## S3 method for class 'hroc'
print(x, ...)
## S3 method for class 'biroc'
print(x, ...)
## S3 method for class 'multiroc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>

<p>An ROC curve object from the <span class="pkg">movieROC</span> package. Possible classes are: 
&lsquo;groc&rsquo; (output of <code>gROC</code> function), &lsquo;hroc&rsquo; (output of <code>hROC</code> function), &lsquo;biroc&rsquo; (output of <code>biROC</code> function), and &lsquo;multiroc&rsquo; (output of <code>multiROC</code> function).</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed. Not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the details of an ROC curve object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for gROC, hROC, biROC and multiROC function
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
