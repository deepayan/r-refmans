<!DOCTYPE html><html lang="en"><head><title>Help for package GWlasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GWlasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GWlasso-package'><p>GWlasso: Geographically Weighted Lasso</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#Amesbury'><p>Amesbury Testate Amoebae dataset</p></a></li>
<li><a href='#compute_distance_matrix'><p>Compute distance matrix</p></a></li>
<li><a href='#gwl_bw_estimation'><p>Bandwidth estimation for Geographically Weighted Lasso</p></a></li>
<li><a href='#gwl_fit'><p>Fit a geographically weighted lasso with the selected bandwidth</p></a></li>
<li><a href='#plot_gwl_map'><p>Plot a map of beta coefficient for gwlfit object</p></a></li>
<li><a href='#plot.gwlfit'><p>Plot method for gwlfit object</p></a></li>
<li><a href='#predict.gwlfit'><p>Predict method for gwlfit objects</p></a></li>
<li><a href='#print.gwlest'><p>Printing gwlest objects</p></a></li>
<li><a href='#print.gwlfit'><p>Printing gwlfit objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Geographically Weighted Lasso</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs geographically weighted Lasso regressions. Find optimal bandwidth, fit a geographically weighted lasso or ridge regression, and make predictions.
    These methods are specially well suited for ecological inferences. Bandwidth selection algorithm is from A. Comber and P. Harris (2018) &lt;<a href="https://doi.org/10.1007%2Fs10109-018-0280-7">doi:10.1007/s10109-018-0280-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, ggside, glmnet, GWmodel, lifecycle, magrittr,
methods, progress, rlang, sf, tidyr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-22 07:51:01 UTC; nibor</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthieu Mulot <a href="https://orcid.org/0000-0002-8039-5078"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Sophie Erb <a href="https://orcid.org/0000-0002-0700-283X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthieu Mulot &lt;matthieu.mulot@gmail.com&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, maps, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nibortolum/GWlasso">https://github.com/nibortolum/GWlasso</a>,
<a href="https://nibortolum.github.io/GWlasso/">https://nibortolum.github.io/GWlasso/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nibortolum/GWlasso/issues">https://github.com/nibortolum/GWlasso/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-22 09:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='GWlasso-package'>GWlasso: Geographically Weighted Lasso</h2><span id='topic+GWlasso'></span><span id='topic+GWlasso-package'></span>

<h3>Description</h3>

<p>Performs geographically weighted Lasso regressions. Find optimal bandwidth, fit a geographically weighted lasso or ridge regression, and make predictions. These methods are specially well suited for ecological inferences. Bandwidth selection algorithm is from A. Comber and P. Harris (2018) <a href="https://doi.org/10.1007/s10109-018-0280-7">doi:10.1007/s10109-018-0280-7</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthieu Mulot <a href="mailto:matthieu.mulot@gmail.com">matthieu.mulot@gmail.com</a> (<a href="https://orcid.org/0000-0002-8039-5078">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Sophie Erb (<a href="https://orcid.org/0000-0002-0700-283X">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/nibortolum/GWlasso">https://github.com/nibortolum/GWlasso</a>
</p>
</li>
<li> <p><a href="https://nibortolum.github.io/GWlasso/">https://nibortolum.github.io/GWlasso/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nibortolum/GWlasso/issues">https://github.com/nibortolum/GWlasso/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='Amesbury'>Amesbury Testate Amoebae dataset</h2><span id='topic+Amesbury'></span>

<h3>Description</h3>

<p>Dataset from Amesbury (2016) in Development of a new pan-European testate amoeba transfer function for reconstructing peatland palaeohydrology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Amesbury
</code></pre>


<h3>Format</h3>



<h4><code>Amesbury</code></h4>

<p>This dataset contains the data from Amesbury (2016). In essence, it's a Testate amoebae community table (45 broad TA taxa and 1103 samples)
</p>

<dl>
<dt>spe.df</dt><dd><p>A species x sites dataframe with stites as rows and species in column</p>
</dd>
<dt>WTD</dt><dd><p>A vector od Water table depth associated with each samples</p>
</dd>
<dt>coords</dt><dd><p>a dataframe containing the coordinates of each sample</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.quascirev.2016.09.024">doi:10.1016/j.quascirev.2016.09.024</a>
</p>


<h3>References</h3>

<p>Matthew J. Amesbury, Graeme T. Swindles, Anatoly Bobrov, Dan J. Charman, Joseph Holden, Mariusz Lamentowicz, Gunnar Mallon, Yuri Mazei, Edward A.D. Mitchell, Richard J. Payne, Thomas P. Roland, T. Edward Turner, Barry G. Warner,
<em>Development of a new pan-European testate amoeba transfer function for reconstructing peatland palaeohydrology.
Quaternary Science Reviews, vol. 152, 2016, pages 132-151</em>.
<a href="https://doi.org/10.1016/j.quascirev.2016.09.024">doi:10.1016/j.quascirev.2016.09.024</a>.<br />
</p>

<hr>
<h2 id='compute_distance_matrix'>Compute distance matrix</h2><span id='topic+compute_distance_matrix'></span>

<h3>Description</h3>

<p><code>compute_distance_matrix()</code> is a small helper function to help you compute a distance matrix.
For the geographically method to work, is is important that distances between points are not zero. This function allows to add a small random noise to avoid zero distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_distance_matrix(data, method = "euclidean", add.noise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_distance_matrix_+3A_data">data</code></td>
<td>
<p>A dataframe or matrix containing at least two numerical columns.</p>
</td></tr>
<tr><td><code id="compute_distance_matrix_+3A_method">method</code></td>
<td>
<p>method to compute the distance matrix. Ultimately passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code>. Can be <code>euclidean</code>, <code>maximum</code>, <code>manhattan</code>, <code>canberra</code>, <code>binary</code> or <code>minkowski</code>.</p>
</td></tr>
<tr><td><code id="compute_distance_matrix_+3A_add.noise">add.noise</code></td>
<td>
<p>TRUE/FALSE set to TRUE to add a small noise to the distance matrix. Noise <code class="reqn">U</code> is generated as <code class="reqn"> U \sim (1\times 10^{-6}, 5\times 10^{-6})</code>.
Noise is added only for pairs for which distance is zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix, usable in <code><a href="#topic+gwl_bw_estimation">gwl_bw_estimation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords &lt;- data.frame("Lat" = rnorm(200), "Long" = rnorm(200))
distance_matrix &lt;- compute_distance_matrix(coords)

</code></pre>

<hr>
<h2 id='gwl_bw_estimation'>Bandwidth estimation for Geographically Weighted Lasso</h2><span id='topic+gwl_bw_estimation'></span>

<h3>Description</h3>

<p>This function performs a bruteforce selection of the optimal bandwidth for the selected kernel to perform a geographically weighted lasso.
The user should be aware that this function could be really long to run depending of the settings.
We recommend starting with <code>nbw = 5</code> and <code>nfolds = 5</code> at first to ensure that the function is running properly and producing the desired output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwl_bw_estimation(
  x.var,
  y.var,
  dist.mat,
  adaptive = TRUE,
  adptbwd.thresh = 0.1,
  kernel = "bisquare",
  alpha = 1,
  progress = TRUE,
  nbw = 100,
  nfolds = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gwl_bw_estimation_+3A_x.var">x.var</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an observation vector. <code>x</code> should have 2 or more columns.</p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_y.var">y.var</code></td>
<td>
<p>response variable for the lasso</p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_dist.mat">dist.mat</code></td>
<td>
<p>a distance matrix. can be generated by <code><a href="#topic+compute_distance_matrix">compute_distance_matrix()</a></code></p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_adaptive">adaptive</code></td>
<td>
<p>TRUE or FALSE Whether to perform an adaptive bandwidth search or not. A fixed bandwidth means that than samples are selected if they fit a determined fixed radius around a location.
in a aptative bandwidth , the radius around a location varies to gather a fixed number of samples around the investigated location</p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_adptbwd.thresh">adptbwd.thresh</code></td>
<td>
<p>the lowest fraction of samples to take into account for local regression. Must be 0 &lt; <code>adptbwd.thresh</code> &lt; 1</p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_kernel">kernel</code></td>
<td>
<p>the geographical kernel shape to compute the weight. passed to <code><a href="GWmodel.html#topic+gw.weight">GWmodel::gw.weight()</a></code>
Can be <code>gaussian</code>, <code>exponential</code>, <code>bisquare</code>, <code>tricube</code>, <code>boxcar</code></p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_alpha">alpha</code></td>
<td>
<p>the elasticnet mixing parameter. set 1 for lasso, 0 for ridge. see <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code></p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_progress">progress</code></td>
<td>
<p>if TRUE, print a progress bar</p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_nbw">nbw</code></td>
<td>
<p>the number of bandwidth to test</p>
</td></tr>
<tr><td><code id="gwl_bw_estimation_+3A_nfolds">nfolds</code></td>
<td>
<p>the number f folds for the glmnet cross validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>gwlest</code> object. It is a list with <code>rmspe</code> (the RMSPE of the model with the associated badwidth), <code>NA</code> (the number of NA in the dataset), <code>bw</code> (the optimal bandwidth), <code>bwd.vec</code> (the vector of tested bandwidth)
</p>


<h3>References</h3>

<p>A. Comber and P. Harris. <em>Geographically weighted elastic net logistic regression (2018).
Journal of Geographical Systems, vol. 20, no. 4, pages 317â€“341</em>.
<a href="https://doi.org/10.1007/s10109-018-0280-7">doi:10.1007/s10109-018-0280-7</a>.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predictors &lt;- matrix(data = rnorm(2500), 50,50)
y_value &lt;- sample(1:1000, 50)
coords &lt;- data.frame("Lat" = rnorm(50), "Long" = rnorm(50))
distance_matrix &lt;- compute_distance_matrix(coords)


  myst.est &lt;- gwl_bw_estimation(x.var = predictors, 
                                y.var = y_value,
                                dist.mat = distance_matrix,
                                adaptive = TRUE,
                                adptbwd.thresh = 0.5,
                                kernel = "bisquare",
                                alpha = 1,
                                progress = TRUE,
                                n=10,
                                nfolds = 5)
  
  
  myst.est
  

</code></pre>

<hr>
<h2 id='gwl_fit'>Fit a geographically weighted lasso with the selected bandwidth</h2><span id='topic+gwl_fit'></span>

<h3>Description</h3>

<p>Fit a geographically weighted lasso with the selected bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwl_fit(
  bw,
  x.var,
  y.var,
  kernel,
  dist.mat,
  alpha,
  adaptive,
  progress = TRUE,
  nfolds = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gwl_fit_+3A_bw">bw</code></td>
<td>
<p>Bandwidth</p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_x.var">x.var</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an observation vector. x should have 2 or more columns.</p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_y.var">y.var</code></td>
<td>
<p>response variable for the lasso</p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_kernel">kernel</code></td>
<td>
<p>the geographical kernel shape to compute the weight. passed to <code><a href="GWmodel.html#topic+gw.weight">GWmodel::gw.weight()</a></code>
Can be <code>gaussian</code>, <code>exponential</code>, <code>bisquare</code>, <code>tricube</code>, <code>boxcar</code></p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_dist.mat">dist.mat</code></td>
<td>
<p>a distance matrix. can be generated by <code><a href="#topic+compute_distance_matrix">compute_distance_matrix()</a></code></p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_alpha">alpha</code></td>
<td>
<p>the elasticnet mixing parameter. set 1 for lasso, 0 for ridge. see <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code></p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_adaptive">adaptive</code></td>
<td>
<p>TRUE or FALSE Whether to perform an adaptive bandwidth search or not. A fixed bandwidth means that samples are selected if they fit a determined fixed radius around a location.
In a adaptive bandwidth, the radius around a location varies to gather a fixed number of samples around the investigated location</p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_progress">progress</code></td>
<td>
<p>TRUE/FALSE whether to display a progress bar or not</p>
</td></tr>
<tr><td><code id="gwl_fit_+3A_nfolds">nfolds</code></td>
<td>
<p>the number f folds for the glmnet cross validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>gwlfit</code> object containing a fitted Geographically weighted Lasso.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predictors &lt;- matrix(data = rnorm(2500), 50,50)
y_value &lt;- sample(1:1000, 50)
coords &lt;- data.frame("Lat" = rnorm(50), "Long" = rnorm(50))
distance_matrix &lt;- compute_distance_matrix(coords)

my.gwl.fit &lt;- gwl_fit(bw = 20,
                      x.var = predictors, 
                      y.var = y_value,
                      kernel = "bisquare",
                      dist.mat = distance_matrix, 
                      alpha = 1, 
                      adaptive = TRUE, 
                      progress = TRUE,
                      nfolds = 5)

my.gwl.fit


</code></pre>

<hr>
<h2 id='plot_gwl_map'>Plot a map of beta coefficient for gwlfit object</h2><span id='topic+plot_gwl_map'></span>

<h3>Description</h3>

<p>this function plots a map of the beta coefficients for a selected column (aka species).
For this function to work, the coordinates supplied to <code><a href="#topic+gwl_fit">gwl_fit()</a></code> must be named &quot;Lat&quot; and &quot;Long&quot;.
The function is not bulletproof yet but is added here to reproduce the maps from the original publication.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gwl_map(x, column, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gwl_map_+3A_x">x</code></td>
<td>
<p>a <code>gwlfit</code> object returned by <code><a href="#topic+gwl_fit">gwl_fit()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_gwl_map_+3A_column">column</code></td>
<td>
<p>the name of a variable to be plotted on the map. Must be quoted. for instance &quot;NEB.MIN&quot;</p>
</td></tr>
<tr><td><code id="plot_gwl_map_+3A_crs">crs</code></td>
<td>
<p>the crs projection for the map (default is mercator WGS84). See <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Amesbury)
  
distance_matrix &lt;- compute_distance_matrix(Amesbury$coords[1:30,], add.noise = TRUE)
  
my.gwl.fit &lt;- gwl_fit(bw= 20,
                      x.var = Amesbury$spe.df[1:30,],
                      y.var = Amesbury$WTD[1:30],
                      dist.mat = distance_matrix,
                      adaptive = TRUE,
                      kernel = "bisquare",
                      alpha = 1,
                      progress = TRUE)
                        
if(requireNamespace("maps")){
    plot_gwl_map(my.gwl.fit, column = "NEB.MIN")
  }
  
</code></pre>

<hr>
<h2 id='plot.gwlfit'>Plot method for gwlfit object</h2><span id='topic+plot.gwlfit'></span>

<h3>Description</h3>

<p>Plot method for gwlfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gwlfit'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gwlfit_+3A_x">x</code></td>
<td>
<p>a <code>gwlfit</code> object returned by <code><a href="#topic+gwl_fit">gwl_fit()</a></code></p>
</td></tr>
<tr><td><code id="plot.gwlfit_+3A_...">...</code></td>
<td>
<p>ellipsis for S3 method compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predictors &lt;- matrix(data = rnorm(2500), 50,50)
y_value &lt;- sample(1:1000, 50)
coords &lt;- data.frame("Lat" = rnorm(50), "Long" = rnorm(50))
distance_matrix &lt;- compute_distance_matrix(coords)

my.gwl.fit &lt;- gwl_fit(bw = 20,
                      x.var = predictors, 
                      y.var = y_value,
                      kernel = "bisquare",
                      dist.mat = distance_matrix, 
                      alpha = 1, 
                      adaptive = TRUE, 
                      progress = TRUE,
                      nfolds = 5)

plot(my.gwl.fit)

</code></pre>

<hr>
<h2 id='predict.gwlfit'>Predict method for gwlfit objects</h2><span id='topic+predict.gwlfit'></span>

<h3>Description</h3>

<p>Predict method for gwlfit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gwlfit'
predict(object, newdata, newcoords, type = "response", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gwlfit_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;gwlfit&quot;</p>
</td></tr>
<tr><td><code id="predict.gwlfit_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame or matrix with the same columns as the training dataset</p>
</td></tr>
<tr><td><code id="predict.gwlfit_+3A_newcoords">newcoords</code></td>
<td>
<p>a dataframe or matrix of coordinates of the new data</p>
</td></tr>
<tr><td><code id="predict.gwlfit_+3A_type">type</code></td>
<td>
<p>the type of response. see <code><a href="glmnet.html#topic+predict.glmnet">glmnet::predict.glmnet()</a></code></p>
</td></tr>
<tr><td><code id="predict.gwlfit_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> to print info about the execution of the function (useful for very large predictions)</p>
</td></tr>
<tr><td><code id="predict.gwlfit_+3A_...">...</code></td>
<td>
<p>ellipsis for S3 compatibility. Not used in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of predicted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predictors &lt;- matrix(data = rnorm(2500), 50,50)
y_value &lt;- sample(1:1000, 50)
coords &lt;- data.frame("Lat" = rnorm(50), "Long" = rnorm(50))
distance_matrix &lt;- compute_distance_matrix(coords)

my.gwl.fit &lt;- gwl_fit(bw = 20,
                      x.var = predictors, 
                      y.var = y_value,
                      kernel = "bisquare",
                      dist.mat = distance_matrix, 
                      alpha = 1, 
                      adaptive = TRUE, 
                      progress = TRUE,
                      nfolds = 5)
                      
my.gwl.fit

new_predictors &lt;- matrix(data = rnorm(500), 10,50)
new_coords &lt;- data.frame("Lat" = rnorm(10), "Long" = rnorm(10))

predicted_values &lt;- predict(my.gwl.fit,
                             newdata = new_predictors, 
                             newcoords = new_coords)

</code></pre>

<hr>
<h2 id='print.gwlest'>Printing gwlest objects</h2><span id='topic+print.gwlest'></span>

<h3>Description</h3>

<p>Printing gwlest objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gwlest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gwlest_+3A_x">x</code></td>
<td>
<p>an object of class <code>gwlest</code></p>
</td></tr>
<tr><td><code id="print.gwlest_+3A_...">...</code></td>
<td>
<p>ellipsis for S3 method compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this function print key elements of a <code>gwlest</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predictors &lt;- matrix(data = rnorm(2500), 50,50)
y_value &lt;- sample(1:1000, 50)
coords &lt;- data.frame("Lat" = rnorm(50), "Long" = rnorm(50))
distance_matrix &lt;- compute_distance_matrix(coords)


myst.est &lt;- gwl_bw_estimation(x.var = predictors, 
                              y.var = y_value,
                              dist.mat = distance_matrix,
                              adaptive = TRUE,
                              adptbwd.thresh = 0.5,
                              kernel = "bisquare",
                              alpha = 1,
                              progress = TRUE,
                              n=10,
                              nfolds = 5)
  
myst.est
  

</code></pre>

<hr>
<h2 id='print.gwlfit'>Printing gwlfit objects</h2><span id='topic+print.gwlfit'></span>

<h3>Description</h3>

<p>Printing gwlfit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gwlfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gwlfit_+3A_x">x</code></td>
<td>
<p>a <code>gwlfit</code> object</p>
</td></tr>
<tr><td><code id="print.gwlfit_+3A_...">...</code></td>
<td>
<p>ellipsis for S3 method compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this function print key elements of a <code>gwlfit</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predictors &lt;- matrix(data = rnorm(2500), 50,50)
y_value &lt;- sample(1:1000, 50)
coords &lt;- data.frame("Lat" = rnorm(50), "Long" = rnorm(50))
distance_matrix &lt;- compute_distance_matrix(coords)

my.gwl.fit &lt;- gwl_fit(bw = 20,
                      x.var = predictors, 
                      y.var = y_value,
                      kernel = "bisquare",
                      dist.mat = distance_matrix, 
                      alpha = 1, 
                      adaptive = TRUE, 
                      progress = TRUE,
                      nfolds = 5)

my.gwl.fit


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
