<!DOCTYPE html><html><head><title>Help for package distory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distory}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distory-package'><p>Distance Between Phylogenetic Histories</p></a></li>
<li><a href='#bethe.tree'><p>Bethe Tree</p></a></li>
<li><a href='#bin.multiPhylo'><p>Bin Trees</p></a></li>
<li><a href='#dist.multiPhylo'><p>Geodesic Distance Between Phylogenetic Trees</p></a></li>
<li><a href='#gromov.hyperbolicity'><p>Gromov Hyperbolicity Constant</p></a></li>
<li><a href='#mcmc.target.seq'><p>Find MCMC Target Sequence</p></a></li>
<li><a href='#orthant.boundary.tree'><p>Orthant Boundary Tree</p></a></li>
<li><a href='#phylo.diff'><p>Differences Between Phylogenetic Trees</p></a></li>
<li><a href='#position.leverage'><p>Position Leverage</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Distance Between Phylogenetic Histories</td>
</tr>
<tr>
<td>Author:</td>
<td>John Chakerian [aut, cre], Susan Holmes [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Paradis &lt;Emmanuel.Paradis@ird.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>ape (&ge; 5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Geodesic distance between phylogenetic trees and
  associated functions. The theoretical background of 'distory'
  is published in Billera et al. (2001) "Geometry of the space of
  phylogenetic trees." &lt;<a href="https://doi.org/10.1006%2Faama.2001.0759">doi:10.1006/aama.2001.0759</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-19 03:33:59 UTC; paradis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-19 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='distory-package'>Distance Between Phylogenetic Histories</h2><span id='topic+distory-package'></span><span id='topic+distory'></span>

<h3>Description</h3>

<p>The <span class="pkg">distory</span> package provides functions for computing geodesic distances
between phylogenetic trees, as well as functions which use this distance.
Methods for computing Gromov delta-hyperbolicity, Markov Chain Monte Carlo
routines in tree space, and per-position leverage for DNA sequences are
included.
</p>


<h3>Details</h3>

<p>A description of the algorithm used for the distance computation can
be found in <code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code>.
</p>


<h3>Author(s)</h3>

<p>John Chakerian &lt;chakj@stanford.edu&gt; and Susan Holmes &lt;susan@stat.stanford.edu&gt;
</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>
<p>Billera, L. J., Holmes, S. P., and Vogtmann, K. (2001) Geometry of the space
of phylogenetic trees. <em>Advances in Applied Mathematics</em>,
<b>27</b>, 733_-767.
</p>
<p>Megan Owen and J. Scott Provan (2010) A fast algorithm for computing
geodesic distances in tree space. <em>IEEE/ACM Transactions on
Computational Biology and Bioinformatics</em>, 14 Jan. 2010.
</p>

<hr>
<h2 id='bethe.tree'>Bethe Tree</h2><span id='topic+bethe.tree'></span>

<h3>Description</h3>

<p>Generates a Bethe tree with given tips, inner edge lengths, and outgroup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bethe.tree(tips, level.lengths = NULL, outgroup="O", outgroup.dist=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bethe.tree_+3A_tips">tips</code></td>
<td>

<p>A list of tip names as a character vector. Should be a power of 2. All
tip names must be distinct.</p>
</td></tr>
<tr><td><code id="bethe.tree_+3A_level.lengths">level.lengths</code></td>
<td>

<p>Edge lengths for each level, counted from the bottom up. NULL means a
default of 1. If the vector isn't long enough, the last value will be
repeated as necessary.</p>
</td></tr>
<tr><td><code id="bethe.tree_+3A_outgroup">outgroup</code></td>
<td>
<p>The tip label for the outgroup.</p>
</td></tr>
<tr><td><code id="bethe.tree_+3A_outgroup.dist">outgroup.dist</code></td>
<td>
<p>The distance of the outgroup from the root.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a Bethe tree with specified internal edge lengths.
</p>


<h3>Value</h3>

<p>A class of type <code>phylo</code> representing the tree.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(bethe.tree(as.character(1:16), 1:4, "17", 14))
</code></pre>

<hr>
<h2 id='bin.multiPhylo'>Bin Trees</h2><span id='topic+bin.multiPhylo'></span>

<h3>Description</h3>

<p>Bins trees according to branching topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin.multiPhylo(treelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin.multiPhylo_+3A_treelist">treelist</code></td>
<td>
<p>A list of trees that can be passed to dist.phylo (see
the help for dist.phylo for acceptable formats).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bins trees according to branching topology. Two trees are considered to have
the same topology if the same set of partitions of tips are produced by
the edges, which corresponds to the same branching up to rearrangement
of tips.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of bin ids. Bin ids are assigned in order of the
first tree in that bin, that is, the first k unique trees in the list
passed will be assigned bins 1..k in order of appearance.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
otree &lt;- root(fastme.ols(dist.dna(woodmouse)), "No305", resolve.root=TRUE)
breps &lt;- 500

trees &lt;- boot.phylo(otree, woodmouse, B=breps, function(x)
        root(fastme.ols(dist.dna(x)), "No305", resolve.root=TRUE),trees=TRUE)

combined.trees &lt;- c(list(otree), trees$trees)

bin.multiPhylo(combined.trees)
</code></pre>

<hr>
<h2 id='dist.multiPhylo'>Geodesic Distance Between Phylogenetic Trees</h2><span id='topic+dist.multiPhylo'></span>

<h3>Description</h3>

<p>Computes the geodesic distance of a list of phylogenetic trees using a
polynomial algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.multiPhylo(x, method = "geodesic", force.multi2di = FALSE,
                outgroup = NULL, convert.multifurcating = FALSE,
                use.random.resolution = FALSE, scale = NULL,
                verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.multiPhylo_+3A_x">x</code></td>
<td>

<p>A list of ape trees (class 'phylo'). The list does not have to be of
class 'multiPhylo'. The function will also accept a list of strings of
trees in Newick format, or a single string with trees in Newick format
separated by semicolons. All the trees must have the same tip labels.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_method">method</code></td>
<td>

<p>Determines which distance method is used. Options are 'geodesic' for the
tree space geodesic distance, or 'edgeset' for the number of edges
(defined by splits of tips) that are different.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_force.multi2di">force.multi2di</code></td>
<td>

<p>Force conversion of every tree to strict bifurcating through the ape
function 'multi2di', using the use.random.resolution as its parameter.
This option should not be used in conjunction with specification of an
outgroup.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_outgroup">outgroup</code></td>
<td>

<p>Specifies an outgroup to root each tree with respect to. This calls the
ape function 'root' on every tree in the list.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_convert.multifurcating">convert.multifurcating</code></td>
<td>

<p>Setting this option will check every tree for multifurcations using the
ape function 'is.binary.tree' - if it returns FALSE, the ape function
'multi2di' will be called on it. Note that this does not ensure a tree
is strictly binary, since ape considers an unrooted tree binary even if
the root node is trifurcating. This option can be used in conjunction
with specification of an outgroup.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_use.random.resolution">use.random.resolution</code></td>
<td>

<p>Specifies the parameter to 'multi2di' if needed.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_scale">scale</code></td>
<td>

<p>Specifies a scale to make all trees unformly scaled (that is, the sum of
all edges will be uniform)scale to make all trees unformly scaled (that
is, the sum of all edge lengths will be uniform). The parameter can
either be a tree of class <code>phylo</code> or a numeric value for the sum of
all edge lengths.</p>
</td></tr>
<tr><td><code id="dist.multiPhylo_+3A_verbose">verbose</code></td>
<td>

<p>Turns on incremental status updates and more warnings. Helpful for large
computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the geodesic distance according to Billera et. al.
using an algorithm based off of the polynomial time algorithm of Owen
and Provan. Since it corresponds to a formal definition of tree-space as
a space of strictly binary trees, no mulifurcations are allowed, including
on the root node. In addition, negative and 0-lengthed edges are clamped to
a very small value (DBL_MIN) for technical reasons.
</p>
<p>The Newick parser supports only a subset of the Newick format. In
particular, it does not at the moment allow for internal node labels, only
weights. Weights will be automatically set to 1 if not specified. It may be
necessary to clean data in ape to make the trees conform to this.
</p>


<h3>Value</h3>

<p>Returns a distance matrix of class 'dist' representing the pairwise
geodesic distances between all input trees. Keep in mind this distance
matrix is not Euclidean. N/A values are provided in the case of an error in
determining the distance.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>
<p>Billera, L. J., Holmes, S. P., and Vogtmann, K. (2001) Geometry of the space
of phylogenetic trees. <em>Advances in Applied Mathematics</em>,
<b>27</b>, 733&ndash;767.
</p>
<p>Megan Owen and J. Scott Provan (2010) A fast algorithm for computing
geodesic distances in tree space. <em>IEEE/ACM Transactions on
Computational Biology and Bioinformatics</em>, 14 Jan. 2010.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>,
<code><a href="stats.html#topic+cmdscale">cmdscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(woodmouse)
otree &lt;- root(nj(dist.dna(woodmouse)), "No305", resolve.root=TRUE)
breps &lt;- 250

trees &lt;- boot.phylo(otree, woodmouse, B=breps, function(x)
    root(nj(dist.dna(x)), "No305", resolve.root=TRUE), trees = TRUE)

combined.trees &lt;- c(list(otree), trees$trees)
tree.dists &lt;- dist.multiPhylo(combined.trees)

mdres &lt;- cmdscale(tree.dists, k=breps, add=TRUE)
plot(mdres$points[,1], mdres$points[,2], col = c("red", rep("black", breps)))
text(mdres$points[,1], mdres$points[,2], labels = 1:(breps + 1),
     cex = 0.7, adj = c(0, 2))
</code></pre>

<hr>
<h2 id='gromov.hyperbolicity'>Gromov Hyperbolicity Constant</h2><span id='topic+gromov.hyperbolicity'></span>

<h3>Description</h3>

<p>Computes the Gromov Hyperbolicity Constant of a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gromov.hyperbolicity(d, deltas = FALSE, scale = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gromov.hyperbolicity_+3A_d">d</code></td>
<td>

<p>A distance matrix of type <code>dist</code> or <code>matrix</code>, or anything that
can be coerced into <code>dist</code> by <code>as.dist</code>. Must have at least 4
points.</p>
</td></tr>
<tr><td><code id="gromov.hyperbolicity_+3A_deltas">deltas</code></td>
<td>

<p>A logical value specifying whether to return the vector of delta values.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gromov.hyperbolicity_+3A_scale">scale</code></td>
<td>

<p>Specifies a scaling method for each delta. Default is no scaling (NA or
&quot;none&quot;). Available methods are &quot;max&quot; which scales deltas by the max of the
sums computed, and &quot;perimeter&quot; for the largest perimeter of the four
points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes a constant that represents the relaxation of a 4-point
condition for delta-hyperbolicity. See (Gromov 1987) for details.
</p>


<h3>Value</h3>

<p>The Gromov hyperbolicity constant of the given distance matrix.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>M. Gromov. <em>Hyperbolic groups</em>. In Essays in Group Theory, pages
73&ndash;263. Springer, New York, 1987.
</p>
<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># scale final delta by max distance
points &lt;- cbind(runif(100), runif(100))
d &lt;- dist(points)
gromov.hyperbolicity(d)/max(d)

# scale each delta by max distance for the 4 points
points &lt;- cbind(runif(100), runif(100))
d &lt;- dist(points)
gromov.hyperbolicity(d, scale="max")

# scale each delta by the max perimeter for the 4 points
points &lt;- cbind(runif(100), runif(100))
d &lt;- dist(points)
gromov.hyperbolicity(d, scale="max")
</code></pre>

<hr>
<h2 id='mcmc.target.seq'>Find MCMC Target Sequence</h2><span id='topic+mcmc.target.seq'></span><span id='topic+boot.samples.idxs'></span><span id='topic+lookup.samples'></span><span id='topic+convert.table.to.idx'></span>

<h3>Description</h3>

<p><code>mcmc.target.seq</code> uses MCMC to find a configuration of DNA positions
to get as close as possible to a given tree.
</p>
<p><code>boot.samples.idxs</code> bootstraps over indices into a DNA matrix.
</p>
<p><code>lookup.samples</code> goes from an index representation of a configuration
of DNA to the actual DNAbin format.
</p>
<p><code>convert.table.to.idx</code> converts a table of counts for positions 1..n
into a list of indices corresponding to positions (i.e. goes from the
tabled form to a vector whose tabling matches the input).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.target.seq(data, x, F, n)

boot.samples.idxs(data, B = 100, block = 1)

lookup.samples(data, idxs)

convert.table.to.idx(T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.target.seq_+3A_data">data</code></td>
<td>
<p>A DNA matrix in DNAbin format.</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_x">x</code></td>
<td>
<p>A tree of class 'phylo' to estimate.</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_f">F</code></td>
<td>
<p>A tree estimation function, accepting a DNA matrix in DNAbin
format and returning a tree of class 'phylo.'</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_n">n</code></td>
<td>
<p>The number of MCMC iterations to perform.</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_b">B</code></td>
<td>
<p> The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_block">block</code></td>
<td>
<p>The block size to use during bootstrapping.</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_idxs">idxs</code></td>
<td>
<p>A list of numeric vectors of indices to use for lookup.</p>
</td></tr>
<tr><td><code id="mcmc.target.seq_+3A_t">T</code></td>
<td>
<p>A table or table-like vector to convert.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcmc.target.seq</code> performs an MCMC with simulated annealing to locate
a configuration of DNA positions from the original matrix that gets as
close as possible to a target tree. Propositions for the MCMC replacing
one character with another uniformly at random.
</p>
<p>The remaining functions are intended to be used as support functions.
</p>


<h3>Value</h3>

<p><code>mcmc.target.seq</code> returns a list of 4 elements: a numeric vector of
counts of each position in the original matrix, the best estimated
tree, the best distance from the estimated tree to the target tree, and
a numeric vector of the distances for every iteration of the
simulation.
</p>
<p><code>boot.samples.idxs</code> returns a numeric vector representing the
bootstrapped idices.
</p>
<p><code>lookup.samples</code> returns a list of objects of class DNAbin
corresponding to the DNA sequences generated from indices into the original
DNA matrix.
</p>
<p><code>convert.table.to.idx</code> returns a numeric vector of indices based on
the table counts.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code>, <code><a href="#topic+orthant.boundary.tree">orthant.boundary.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example has been excluded from checks:
## copy/paste the code to try it

data(woodmouse)
otree &lt;- root(fastme.ols(dist.dna(woodmouse)), "No305", resolve.root=TRUE)
breps &lt;- 200

trees &lt;- boot.phylo(otree, woodmouse, B=breps, function(x)
        root(fastme.ols(dist.dna(x)), "No305", resolve.root=TRUE),
        trees = TRUE)

combined.trees &lt;- c(list(otree), trees$trees)

binning &lt;- bin.multiPhylo(combined.trees)

tree.a &lt;- combined.trees[[match(1, binning)]]
i &lt;- 2
max.bin &lt;- max(binning)
tree.b &lt;- combined.trees[[match(2, binning)]]

while(length(distinct.edges(tree.a,tree.b)) &gt; 1 &amp;&amp; i &lt; max.bin)
{
    i = i + 1
    tree.b = combined.trees[[match(i, binning)]]
}

bdy.tree &lt;- orthant.boundary.tree(tree.a, tree.b)

f.est &lt;- function(x) root(nj(dist.dna(x)), "No305", resolve.root=TRUE)

res &lt;- mcmc.target.seq(woodmouse, bdy.tree, f.est, 1000)

par(mfrow=c(2,1))
plot(res$tree)
plot(res$vals)

## End(Not run)</code></pre>

<hr>
<h2 id='orthant.boundary.tree'>Orthant Boundary Tree</h2><span id='topic+orthant.boundary.tree'></span>

<h3>Description</h3>

<p>Produces a degenerate tree on the boundary between trees that differ by one split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthant.boundary.tree(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthant.boundary.tree_+3A_x">x</code></td>
<td>
<p>The tree in the first orthant.</p>
</td></tr>
<tr><td><code id="orthant.boundary.tree_+3A_y">y</code></td>
<td>
<p>The tree in the second orthant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree found is the tree on the boundary between the two orthants such
that it is on the straight line connecting the two trees when one
orthant is thought of as being the (-,+) quadrant and the second
orthant as being the (+,+) quadrant, where the (0,y) line is the particular
boundary in question.
</p>


<h3>Value</h3>

<p>Returns an object of class 'phylo' representing the boundary tree.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.target.seq">mcmc.target.seq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(woodmouse)
otree &lt;- root(fastme.ols(dist.dna(woodmouse)), "No305", resolve.root=TRUE)
breps &lt;- 200

trees &lt;- boot.phylo(otree, woodmouse, B=breps, function(x)
        root(fastme.ols(dist.dna(x)), "No305", resolve.root=TRUE),
        trees = TRUE)

combined.trees &lt;- c(list(otree), trees$trees)

binning &lt;- bin.multiPhylo(combined.trees)

tree.a &lt;- combined.trees[[match(1, binning)]]
i &lt;- 2
max.bin &lt;- max(binning)
tree.b &lt;- combined.trees[[match(2, binning)]]

while(length(distinct.edges(tree.a,tree.b)) &gt; 1 &amp;&amp; i &lt; max.bin)
{
    i = i + 1
    tree.b = combined.trees[[match(i, binning)]]
}

plot(orthant.boundary.tree(tree.a, tree.b))
</code></pre>

<hr>
<h2 id='phylo.diff'>Differences Between Phylogenetic Trees</h2><span id='topic+phylo.diff'></span><span id='topic+distinct.edges'></span><span id='topic+edge.from.split'></span><span id='topic+get.bipartition'></span><span id='topic+partition.leaves'></span>

<h3>Description</h3>

<p>A family of functions for determining and plotting the differences between
two trees.
</p>
<p><code>phylo.diff</code> plots two trees side by side, highlighting edges unique
to each tree in red.
</p>
<p><code>distinct.edges</code> finds the edges present in the first argument not in
the second.
</p>
<p><code>edge.from.split</code> locates the edge id from a given split.
</p>
<p><code>get.bipartition</code> gets the bipartition of tips formed by a single edge.
</p>
<p><code>partition.leaves</code> returns the set of all bipartitions from all edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo.diff(x, y, ...)

distinct.edges(x, y)

edge.from.split(x, split)

get.bipartition(x, e)

partition.leaves(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo.diff_+3A_x">x</code></td>
<td>
<p>The first (or only) tree.</p>
</td></tr>
<tr><td><code id="phylo.diff_+3A_y">y</code></td>
<td>
<p>The second tree, for the functions that accept two trees.</p>
</td></tr>
<tr><td><code id="phylo.diff_+3A_split">split</code></td>
<td>
<p>A list of bipartitions, probably from <code>partition.leaves</code>.</p>
</td></tr>
<tr><td><code id="phylo.diff_+3A_e">e</code></td>
<td>
<p>An edge for a particular tree, given as an id.</p>
</td></tr>
<tr><td><code id="phylo.diff_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>plot.phylo</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phylo.diff</code> uses the ape tree plotting function. The other functions
are mostly meant as support functions.
</p>


<h3>Value</h3>

<p><code>phylo.diff</code> returns invisible.
</p>
<p><code>distinct.edges</code> returns a numeric vector of edge ids for the first
tree.
</p>
<p><code>edge.from.split</code> returns an edge id for a particular tree
corresponding to a given bipartition and NA if none such edge exists.
</p>
<p><code>get.bipartition</code> returns a character vector of the tips below that
edge in the given tree.
</p>
<p><code>partition.leaves</code> returns a list of partitions (themselves character
vectors) of the given tree.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
otree &lt;- root(fastme.ols(dist.dna(woodmouse)), "No305", resolve.root=TRUE)
breps &lt;- 10

trees &lt;- boot.phylo(otree, woodmouse, B=breps, function(x)
        root(fastme.ols(dist.dna(x)), "No305", resolve.root=TRUE),
        trees = TRUE)

combined.trees &lt;- c(list(otree), trees$trees)

binning &lt;- bin.multiPhylo(combined.trees)

phylo.diff(combined.trees[[match(1, binning)]], combined.trees[[match(2, binning)]])
</code></pre>

<hr>
<h2 id='position.leverage'>Position Leverage</h2><span id='topic+position.leverage'></span>

<h3>Description</h3>

<p>Provides a rough heuristic for determining the degree to which each
position in the DNA matrix affects the resulting tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position.leverage(data, F, to = NULL, rep = 50, by = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position.leverage_+3A_data">data</code></td>
<td>
<p>A DNA matrix in <code>DNAbin</code> format.</p>
</td></tr>
<tr><td><code id="position.leverage_+3A_f">F</code></td>
<td>

<p>A tree estimation function, accepting a DNA matrix of class <code>DNAbin</code>
and returning a tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="position.leverage_+3A_to">to</code></td>
<td>

<p>The tree with which distances are measured in respect to, or <code>NULL</code>
to indicate the tree estimated by <code>F</code> for the starting DNA matrix.</p>
</td></tr>
<tr><td><code id="position.leverage_+3A_rep">rep</code></td>
<td>

<p>The number of times to replicate the position in question.</p>
</td></tr>
<tr><td><code id="position.leverage_+3A_by">by</code></td>
<td>

<p>The function will perform the calculation on every <code>by</code>-th position
(that is, on <code>seq(1, N, by)</code>).</p>
</td></tr></table>


<h3>Details</h3>

<p>This function takes a DNA matrix and, for every <code>by</code>-th position,
replicates that position <code>rep</code> times, randomly removing
<code>rep</code> other positions to keep all sequences the same length
other positions to keep all sequences the same length. For each new DNA
matrix created in this way, <code>F</code> is used to estimate the corresponding
tree, and the distance to tree <code>to</code> is computed and stored. This
distance can be thought of as somewhat analogous to the leverage of that
position.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of distances from tree <code>to</code> for each position
sampled.
</p>


<h3>Author(s)</h3>

<p>John Chakerian</p>


<h3>References</h3>

<p>Chakerian, J. and Holmes, S. P. Computational Tools for Evaluating
Phylogenetic and Heirarchical Clustering Trees. arXiv:1006.1015v1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.multiPhylo">dist.multiPhylo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(woodmouse)
f.est &lt;- function(x) root(nj(dist.dna(x)), "No305", resolve.root = TRUE)
position.leverage(woodmouse, f.est, by = 10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
