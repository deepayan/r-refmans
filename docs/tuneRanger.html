<!DOCTYPE html><html><head><title>Help for package tuneRanger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tuneRanger}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#estimateTimeTuneRanger'><p>estimateTimeTuneRanger</p></a></li>
<li><a href='#restartTuneRanger'><p>restartTuneRanger</p></a></li>
<li><a href='#tuneMtryFast'><p>tuneMtryFast</p></a></li>
<li><a href='#tuneRanger'><p>tuneRanger</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tune Random Forest of the 'ranger' Package</td>
</tr>
<tr>
<td>Description:</td>
<td>Tuning random forest with one line. The package is mainly based on the packages 'ranger' and 'mlrMBO'.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), ranger (&ge; 0.8.0), mlrMBO (&ge; 1.1.1), parallel
(&ge; 3.3.3), lhs (&ge; 0.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mlr (&ge; 2.11), smoof (&ge; 1.5.1), ParamHelpers (&ge; 1.10),
methods (&ge; 3.3.3), BBmisc (&ge; 1.11), DiceKriging (&ge; 1.5.5)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 18:42:06 UTC; philipp</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp Probst [aut, cre],
  Simon Klau [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philipp Probst &lt;philipp_probst@gmx.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='estimateTimeTuneRanger'>estimateTimeTuneRanger</h2><span id='topic+estimateTimeTuneRanger'></span>

<h3>Description</h3>

<p>estimateTimeTuneRanger
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateTimeTuneRanger(
  task,
  iters = 100,
  num.threads = 1,
  num.trees = 1000,
  respect.unordered.factors = "order"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateTimeTuneRanger_+3A_task">task</code></td>
<td>
<p>The mlr task created by makeClassifTask or makeRegrTask.</p>
</td></tr>
<tr><td><code id="estimateTimeTuneRanger_+3A_iters">iters</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="estimateTimeTuneRanger_+3A_num.threads">num.threads</code></td>
<td>
<p>Number of threads. Default is 1.</p>
</td></tr>
<tr><td><code id="estimateTimeTuneRanger_+3A_num.trees">num.trees</code></td>
<td>
<p>Number of trees.</p>
</td></tr>
<tr><td><code id="estimateTimeTuneRanger_+3A_respect.unordered.factors">respect.unordered.factors</code></td>
<td>
<p>Handling of unordered factor covariates. One of 'ignore', 'order' and 'partition'. 'order' is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated time for the tuning procedure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>estimateTimeTuneRanger(iris.task)
</code></pre>

<hr>
<h2 id='restartTuneRanger'>restartTuneRanger</h2><span id='topic+restartTuneRanger'></span>

<h3>Description</h3>

<p>Restarts the tuning process if an error occured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restartTuneRanger(save.file.path = "optpath.RData", task, measure = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restartTuneRanger_+3A_save.file.path">save.file.path</code></td>
<td>
<p>File name in the current working directory to which interim results were saved by <code><a href="#topic+tuneRanger">tuneRanger</a></code>.</p>
</td></tr>
<tr><td><code id="restartTuneRanger_+3A_task">task</code></td>
<td>
<p>The mlr task created by <code><a href="mlr.html#topic+makeClassifTask">makeClassifTask</a></code> or <code><a href="mlr.html#topic+makeRegrTask">makeRegrTask</a></code>.</p>
</td></tr>
<tr><td><code id="restartTuneRanger_+3A_measure">measure</code></td>
<td>
<p>Performance measure that was already used in the original <code><a href="#topic+tuneRanger">tuneRanger</a></code> process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>recommended.pars</code></td>
<td>
<p>Recommended hyperparameters.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>A data.frame with all evaluated hyperparameters and performance and time results for each run.</p>
</td></tr>
</table>
<p>No model is build.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tuneRanger)
library(mlr)

# iris is a bit nonsense here
# A mlr task has to be created in order to use the package
# the already existing iris task is used here
estimateTimeTuneRanger(iris.task)
# temporarily file name to save results
path = tempfile()
res = tuneRanger(iris.task, measure = list(multiclass.brier), num.trees = 1000, 
  num.threads = 8, iters = 70, save.file.path = path)

# Mean of best 5 % of the results
res

# Restart after failing in one of the iterations:
res = restartTuneRanger(save.file.path = path, iris.task, 
measure = list(multiclass.brier))
## End(Not run)
</code></pre>

<hr>
<h2 id='tuneMtryFast'>tuneMtryFast</h2><span id='topic+tuneMtryFast'></span>

<h3>Description</h3>

<p>Similar to tuneRF in <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> but for <code><a href="ranger.html#topic+ranger">ranger</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuneMtryFast(
  formula = NULL,
  data = NULL,
  dependent.variable.name = NULL,
  mtryStart = floor(sqrt(ncol(data) - 1)),
  num.treesTry = 50,
  stepFactor = 2,
  improve = 0.05,
  trace = TRUE,
  plot = TRUE,
  doBest = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuneMtryFast_+3A_formula">formula</code></td>
<td>
<p>Object of class formula or character describing the model to fit. Interaction terms supported only for numerical variables.</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_data">data</code></td>
<td>
<p>Training data of class data.frame, matrix, dgCMatrix (Matrix) or gwaa.data (GenABEL).</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_dependent.variable.name">dependent.variable.name</code></td>
<td>
<p>Name of dependent variable, needed if no formula given. For survival forests this is the time variable.</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_mtrystart">mtryStart</code></td>
<td>
<p>starting value of mtry; default is the same as in <code><a href="ranger.html#topic+ranger">ranger</a></code></p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_num.treestry">num.treesTry</code></td>
<td>
<p>number of trees used at the tuning step</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_stepfactor">stepFactor</code></td>
<td>
<p>at each iteration, mtry is inflated (or deflated) by this value</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_improve">improve</code></td>
<td>
<p>the (relative) improvement in OOB error must be by this much for the search to continue</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_trace">trace</code></td>
<td>
<p>whether to print the progress of the search</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_plot">plot</code></td>
<td>
<p>whether to plot the OOB error as function of mtry</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_dobest">doBest</code></td>
<td>
<p>whether to run a forest using the optimal mtry found</p>
</td></tr>
<tr><td><code id="tuneMtryFast_+3A_...">...</code></td>
<td>
<p>options to be given to <code><a href="ranger.html#topic+ranger">ranger</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides fast tuning for the mtry hyperparameter. 
</p>
<p>Starting with the default value of mtry, search for the optimal value (with respect to Out-of-Bag error estimate) of mtry for randomForest.
</p>


<h3>Value</h3>

<p>If doBest=FALSE (default), it returns a matrix whose first column contains the mtry values searched, and the second column the corresponding OOB error.
</p>
<p>If doBest=TRUE, it returns the <code><a href="ranger.html#topic+ranger">ranger</a></code> object produced with the optimal mtry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tuneRanger)

data(iris)
res &lt;- tuneMtryFast(Species ~ ., data = iris, stepFactor = 1.5)
</code></pre>

<hr>
<h2 id='tuneRanger'>tuneRanger</h2><span id='topic+tuneRanger'></span>

<h3>Description</h3>

<p>Automatic tuning of random forests of the <code><a href="ranger.html#topic+ranger">ranger</a></code> package with one line of code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuneRanger(
  task,
  measure = NULL,
  iters = 70,
  iters.warmup = 30,
  time.budget = NULL,
  num.threads = NULL,
  num.trees = 1000,
  parameters = list(replace = FALSE, respect.unordered.factors = "order"),
  tune.parameters = c("mtry", "min.node.size", "sample.fraction"),
  save.file.path = NULL,
  build.final.model = TRUE,
  show.info = getOption("mlrMBO.show.info", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuneRanger_+3A_task">task</code></td>
<td>
<p>The mlr task created by <code><a href="mlr.html#topic+makeClassifTask">makeClassifTask</a></code>, <code><a href="mlr.html#topic+makeRegrTask">makeRegrTask</a></code> or <code><a href="mlr.html#topic+makeSurvTask">makeSurvTask</a></code>.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_measure">measure</code></td>
<td>
<p>Performance measure to evaluate/optimize. Default is brier score for classification and mse for regression. Can be changed to accuracy, AUC or logaritmic loss by setting it to <code>list(acc)</code>, <code>list(auc)</code> or <code>list(logloss)</code>. Other possible performance measures from mlr can be looked up in the <a href="https://mlr.mlr-org.com/articles/tutorial/measures.html">mlr tutorial</a>.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_iters">iters</code></td>
<td>
<p>Number of iterations. Default is 70.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_iters.warmup">iters.warmup</code></td>
<td>
<p>Number of iterations for the warmup. Default is 30.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_time.budget">time.budget</code></td>
<td>
<p>Running time budget in seconds. Note that the actual mbo run can take more time since the condition is checked after each iteration. The default NULL means: There is no time budget.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_num.threads">num.threads</code></td>
<td>
<p>Number of threads. Default is number of CPUs available.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_num.trees">num.trees</code></td>
<td>
<p>Number of trees.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_parameters">parameters</code></td>
<td>
<p>Optional list of fixed named parameters that should be passed to <code><a href="ranger.html#topic+ranger">ranger</a></code>.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_tune.parameters">tune.parameters</code></td>
<td>
<p>Optional character vector of parameters that should be tuned. 
Default is mtry, min.node.size and sample.fraction. Additionally replace and respect.unordered.factors can be 
included in the tuning process.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_save.file.path">save.file.path</code></td>
<td>
<p>File to which interim results are saved (e.g. &quot;optpath.RData&quot;) in the current working directory. 
Default is NULL, which does not save the results. If a file was specified and one iteration fails the algorithm can be 
started again with <code><a href="#topic+restartTuneRanger">restartTuneRanger</a></code>.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_build.final.model">build.final.model</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the best found model be fitted on the complete dataset?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tuneRanger_+3A_show.info">show.info</code></td>
<td>
<p>Verbose mlrMBO output on console? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model based optimization is used as tuning strategy and the three parameters min.node.size, sample.fraction and mtry are tuned at once. Out-of-bag predictions are used for evaluation, which makes it much faster than other packages and tuning strategies that use for example 5-fold cross-validation. Classification as well as regression is supported. 
The measure that should be optimized can be chosen from the list of measures in mlr: <a href="https://mlr.mlr-org.com/articles/tutorial/measures.html">mlr tutorial</a>
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>recommended.pars</code></td>
<td>
<p>Recommended hyperparameters.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>A data.frame with all evaluated hyperparameters and performance and time results for each run.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The final model if <code>build.final.model</code> set to TRUE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+estimateTimeTuneRanger">estimateTimeTuneRanger</a></code> for time estimation and <code><a href="#topic+restartTuneRanger">restartTuneRanger</a></code> for continuing the algorithm if there was an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tuneRanger)
library(mlr)

# A mlr task has to be created in order to use the package
data(iris)
iris.task = makeClassifTask(data = iris, target = "Species")
 
# Estimate runtime
estimateTimeTuneRanger(iris.task)
# Tuning
res = tuneRanger(iris.task, measure = list(multiclass.brier), num.trees = 1000, 
  num.threads = 2, iters = 70, save.file.path = NULL)
  
# Mean of best 5 % of the results
res
# Model with the new tuned hyperparameters
res$model
# Prediction
predict(res$model, newdata = iris[1:10,])
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
