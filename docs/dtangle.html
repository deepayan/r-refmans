<!DOCTYPE html><html><head><title>Help for package dtangle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtangle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baseline_exprs'><p>Estimate the offset terms.</p></a></li>
<li><a href='#combine_Y_refs'><p>Row-binds <code>Y</code> with <code>references</code> and generates <code>pure_samples</code>.</p></a></li>
<li><a href='#dtangle'><p>Deconvolve cell type mixing proportions from gene expression data.</p></a></li>
<li><a href='#dtangle2'><p>Deconvolve cell type mixing proportions from gene expression data.</p></a></li>
<li><a href='#est_phats'><p>Estimate the gene type proportions.</p></a></li>
<li><a href='#find_markers'><p>Find marker genes for each cell type.</p></a></li>
<li><a href='#get_gamma'><p>Determine gamma value by data type.</p></a></li>
<li><a href='#process_markers'><p>Determines number of markers <code>n_markers</code>, marker list <code>mrkrs</code>, and <code>gamma</code>.</p></a></li>
<li><a href='#shen_orr_ex'><p>Example Subset of Shen-Orr deconvolution data set.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cell Type Deconvolution from Gene Expressions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Deconvolving cell types from high-throughput gene profiling data. For more information on dtangle see Hunt et al. (2019) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty926">doi:10.1093/bioinformatics/bty926</a>&gt;.</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-11-29</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>DEoptimR,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-29 18:41:06 UTC; greg</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Hunt [aut, cre],
  Johann Gagnon-Bartsch [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Hunt &lt;ghunt@wm.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-01 17:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='baseline_exprs'>Estimate the offset terms.</h2><span id='topic+baseline_exprs'></span>

<h3>Description</h3>

<p>Estimate the offset terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_exprs(Y, pure_samples, markers, summary_fn = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_exprs_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="baseline_exprs_+3A_pure_samples">pure_samples</code></td>
<td>
<p>The pure sample indicies.
</p>
<p>(Optional) List of one-dimensional integer. Must implement <code>as.list</code>.
</p>
<p>The i-th element of the top-level list is a vector of indicies (rows of <code>Y</code> or <code>references</code>) that are pure samples of type i. If <code>references</code> is not specified then this argument identifies which rows of <code>Y</code> correspond to pure reference samples of which cell-types. If <code>references</code> is specified then this makes same idenficiation but for the <code>references</code> matrix instead.</p>
</td></tr>
<tr><td><code id="baseline_exprs_+3A_markers">markers</code></td>
<td>
<p>Marker gene indices.
</p>
<p>(Optional) List of one-dimensional integer.
</p>
<p>Top-level list should be same length as <code>pure_samples</code>, i.e. one element for each cell type. Each element of the top-level list is a vector of indicies (columns of <code>Y</code>) that will be considered markers of that particular type. If not supplied then <code>dtangle</code> finds markers internally using <code>find_markers</code>. Alternatively, one can supply the output of <code>find_markers</code> to the markers argument.</p>
</td></tr>
<tr><td><code id="baseline_exprs_+3A_summary_fn">summary_fn</code></td>
<td>
<p>What summary statistic to use when aggregating expression measurements.
</p>
<p>(Optional) Function that takes a one-dimensional vector of numeric and returns a single numeric.
</p>
<p>Defaults to the mean. Other good options include the median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of vectors. Each vector is estimated estimated basline in pure samples of markers for each group, resp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truth = shen_orr_ex$annotation$mixture
pure_samples &lt;- lapply(1:3, function(i) {
   which(truth[, i] == 1)
})
Y &lt;- shen_orr_ex$data$log
markers = find_markers(Y=Y,
pure_samples = pure_samples,data_type='microarray-gene',marker_method='ratio')$L
K = length(pure_samples)
n_markers = rep(20,K)
mrkrs &lt;- lapply(1:K, function(i) {
       markers[[i]][1:n_markers[i]]
})
dtangle:::baseline_exprs(Y, pure_samples, mrkrs)
</code></pre>

<hr>
<h2 id='combine_Y_refs'>Row-binds <code>Y</code> with <code>references</code> and generates <code>pure_samples</code>.</h2><span id='topic+combine_Y_refs'></span>

<h3>Description</h3>

<p>Row-binds <code>Y</code> with <code>references</code> and generates <code>pure_samples</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_Y_refs(Y, references, pure_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_Y_refs_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="combine_Y_refs_+3A_references">references</code></td>
<td>
<p>Cell-type reference expression matrix.
</p>
<p>(Optional) Two-dimensional numeric. Must implement <code>as.matrix</code>. Must have same number of columns as <code>Y</code>. Columns must correspond to columns of <code>Y</code>.
</p>
<p>Each row contains expression measurements for a reference profile of a particular cell type. Columns contain measurements of reference profiles of a gene. Optionally may merge this matrix with <code>Y</code> and use <code>pure_samples</code> to indicate which rows of <code>Y</code> are pure samples. If <code>pure_samples</code> is not specified <code>references</code> must be specified. In this case each row of <code>references</code> is assumed to be a distinct cell-type. If both <code>pure_samples</code> and <code>references</code> are specified then multiple rows of <code>references</code> may refer be the same cell type, and <code>pure_samples</code> specifies to which cell-type each row of <code>references</code> corresponds.</p>
</td></tr>
<tr><td><code id="combine_Y_refs_+3A_pure_samples">pure_samples</code></td>
<td>
<p>The pure sample indicies.
</p>
<p>(Optional) List of one-dimensional integer. Must implement <code>as.list</code>.
</p>
<p>The i-th element of the top-level list is a vector of indicies (rows of <code>Y</code> or <code>references</code>) that are pure samples of type i. If <code>references</code> is not specified then this argument identifies which rows of <code>Y</code> correspond to pure reference samples of which cell-types. If <code>references</code> is specified then this makes same idenficiation but for the <code>references</code> matrix instead.</p>
</td></tr>
</table>

<hr>
<h2 id='dtangle'>Deconvolve cell type mixing proportions from gene expression data.</h2><span id='topic+dtangle'></span>

<h3>Description</h3>

<p>Deconvolve cell type mixing proportions from gene expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtangle(Y, references = NULL, pure_samples = NULL, n_markers = NULL,
  data_type = NULL, gamma = NULL, markers = NULL,
  marker_method = "ratio", summary_fn = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtangle_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_references">references</code></td>
<td>
<p>Cell-type reference expression matrix.
</p>
<p>(Optional) Two-dimensional numeric. Must implement <code>as.matrix</code>. Must have same number of columns as <code>Y</code>. Columns must correspond to columns of <code>Y</code>.
</p>
<p>Each row contains expression measurements for a reference profile of a particular cell type. Columns contain measurements of reference profiles of a gene. Optionally may merge this matrix with <code>Y</code> and use <code>pure_samples</code> to indicate which rows of <code>Y</code> are pure samples. If <code>pure_samples</code> is not specified <code>references</code> must be specified. In this case each row of <code>references</code> is assumed to be a distinct cell-type. If both <code>pure_samples</code> and <code>references</code> are specified then multiple rows of <code>references</code> may refer be the same cell type, and <code>pure_samples</code> specifies to which cell-type each row of <code>references</code> corresponds.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_pure_samples">pure_samples</code></td>
<td>
<p>The pure sample indicies.
</p>
<p>(Optional) List of one-dimensional integer. Must implement <code>as.list</code>.
</p>
<p>The i-th element of the top-level list is a vector of indicies (rows of <code>Y</code> or <code>references</code>) that are pure samples of type i. If <code>references</code> is not specified then this argument identifies which rows of <code>Y</code> correspond to pure reference samples of which cell-types. If <code>references</code> is specified then this makes same idenficiation but for the <code>references</code> matrix instead.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_n_markers">n_markers</code></td>
<td>
<p>Number of marker genes.
</p>
<p>(Optional) One-dimensional numeric.
</p>
<p>How many markers genes to use for deconvolution. Can either be a single integer, vector of integers (one for each cell type), or single or vector of percentages (numeric in 0 to 1). If a single integer then all cell types use that number of markers. If a vector then the i-th element determines how many marker genes are used for the i-th cell type. If single percentage (in 0 to 1) then that percentage of markers are used for all types. If vector of percentages then that percentage used for each type, respectively. If not specified then top 10% of genes are used.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_data_type">data_type</code></td>
<td>
<p>Type of expression measurements.
</p>
<p>(Optional) One-dimensional string. 
</p>
<p>An optional string indicating the type of the expression measurements. This is used to set gamma to a pre-determined value based upon the data type. Valid values are for probe-level microarray as &ldquo;microarray-probe&rdquo;, gene-level microarray as &ldquo;microarray-gene&rdquo; or rna-seq as &ldquo;rna-seq&rdquo;. Alternatively can set <code>gamma</code> directly.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_gamma">gamma</code></td>
<td>
<p>Expression adjustment term.
</p>
<p>(Optional) One-dimensional positive numeric.
</p>
<p>If provided as a single positive number then that value will be used for <code>gamma</code> and over-ride the value of gamma chosen by the <code>data_type</code> argument. If neither <code>gamma</code> nor <code>data_type</code> are specified then <code>gamma</code> will be set to one.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_markers">markers</code></td>
<td>
<p>Marker gene indices.
</p>
<p>(Optional) List of one-dimensional integer.
</p>
<p>Top-level list should be same length as <code>pure_samples</code>, i.e. one element for each cell type. Each element of the top-level list is a vector of indicies (columns of <code>Y</code>) that will be considered markers of that particular type. If not supplied then <code>dtangle</code> finds markers internally using <code>find_markers</code>. Alternatively, one can supply the output of <code>find_markers</code> to the markers argument.</p>
</td></tr>
<tr><td><code id="dtangle_+3A_marker_method">marker_method</code></td>
<td>
<p>Method used to rank marker genes.
</p>
<p>(Optional) One-dimensional string.
</p>
<p>The method used to rank genes as markers. If not supplied defaults to &ldquo;ratio&rdquo;. Only used if markers are not provided to argument &ldquo;markers&rdquo;. Options are
</p>

<ul>
<li><p>'ratio' selects and ranks markers by the ratio of the mean expression of each gene in each cell type to the mean of that gene in all other cell types.
</p>
</li>
<li><p>'regression ' selects and ranks markers by estimated regression coefficients in a series of regressions with single covariate that is indicator of each type.
</p>
</li>
<li><p>'diff' selects and ranks markers based upon the difference, for each cell type, between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li>
<li><p>'p.value' selects and ranks markers based upon the p-value of a t-test between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dtangle_+3A_summary_fn">summary_fn</code></td>
<td>
<p>What summary statistic to use when aggregating expression measurements.
</p>
<p>(Optional) Function that takes a one-dimensional vector of numeric and returns a single numeric.
</p>
<p>Defaults to the mean. Other good options include the median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>

<ul>
<li><p>'estimates' a matrix estimated mixing proportions. One row for each sample, one column for each cell type.
</p>
</li>
<li><p>'markers' list of vectors of marker used for each cell type. Each element of list is vector of columns of <code>Y</code> used as a marker for the i-th cell type.
</p>
</li>
<li><p>'n_markers' vector of number of markers used for each cell type.
</p>
</li>
<li><p>'gamma' value of the sensitivity parameter gamma used by dtangle.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+find_markers">find_markers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truth = shen_orr_ex$annotation$mixture
pure_samples &lt;- lapply(1:3, function(i) {
   which(truth[, i] == 1)
})
Y &lt;- shen_orr_ex$data$log
n_markers = 20

dtangle(Y, pure_samples = pure_samples,
n_markers=n_markers,data_type='microarray-gene',marker_method = 'ratio')

n_markers = c(10,11,12)
dtangle(Y, pure_samples=pure_samples,
n_markers=n_markers,gamma=.8,marker_method = 'regression')
</code></pre>

<hr>
<h2 id='dtangle2'>Deconvolve cell type mixing proportions from gene expression data.</h2><span id='topic+dtangle2'></span>

<h3>Description</h3>

<p>Deconvolve cell type mixing proportions from gene expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtangle2(Y, references = NULL, pure_samples = NULL, n_markers = NULL,
  markers = NULL, marker_method = "ratio", weights = NULL,
  sto = TRUE, inv_scale = function(x) 2^x, fit_scale = log,
  loss_smry = "var", dtangle_init = TRUE, seed = NULL,
  verbose = FALSE, optim_opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtangle2_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_references">references</code></td>
<td>
<p>Cell-type reference expression matrix.
</p>
<p>(Optional) Two-dimensional numeric. Must implement <code>as.matrix</code>. Must have same number of columns as <code>Y</code>. Columns must correspond to columns of <code>Y</code>.
</p>
<p>Each row contains expression measurements for a reference profile of a particular cell type. Columns contain measurements of reference profiles of a gene. Optionally may merge this matrix with <code>Y</code> and use <code>pure_samples</code> to indicate which rows of <code>Y</code> are pure samples. If <code>pure_samples</code> is not specified <code>references</code> must be specified. In this case each row of <code>references</code> is assumed to be a distinct cell-type. If both <code>pure_samples</code> and <code>references</code> are specified then <code>pure_samples</code> specifies to which cell-type each row of <code>references</code> corresponds.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_pure_samples">pure_samples</code></td>
<td>
<p>The pure sample indicies.
</p>
<p>(Optional) List of one-dimensional integer. Must implement <code>as.list</code>.
</p>
<p>The i-th element of the top-level list is a vector of indicies (rows of <code>Y</code> or <code>references</code>) that are pure samples of type i. If <code>references</code> is not specified then this argument identifies which rows of <code>Y</code> correspond to pure reference samples of which cell-types. If <code>references</code> is specified then this makes same idenficiation but for the <code>references</code> matrix instead.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_n_markers">n_markers</code></td>
<td>
<p>Number of marker genes.
</p>
<p>(Optional) One-dimensional numeric.
</p>
<p>How many markers genes to use for deconvolution. Can either be a single integer, vector of integers (one for each cell type), or single or vector of percentages (numeric in 0 to 1). If a single integer then all cell types use that number of markers. If a vector then the i-th element determines how many marker genes are used for the i-th cell type. If single percentage (in 0 to 1) then that percentage of markers are used for all types. If vector of percentages then that percentage used for each type, respectively. If not specified then top 10% of genes are used.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_markers">markers</code></td>
<td>
<p>Marker gene indices.
</p>
<p>(Optional) List of one-dimensional integer.
</p>
<p>Top-level list should be same length as <code>pure_samples</code>, i.e. one element for each cell type. Each element of the top-level list is a vector of indicies (columns of <code>Y</code>) that will be considered markers of that particular type. If not supplied then <code>dtangle</code> finds markers internally using <code>find_markers</code>. Alternatively, one can supply the output of <code>find_markers</code> to the markers argument.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_marker_method">marker_method</code></td>
<td>
<p>Method used to rank marker genes.
</p>
<p>(Optional) One-dimensional string.
</p>
<p>The method used to rank genes as markers. If not supplied defaults to &ldquo;ratio&rdquo;. Only used if markers are not provided to argument &ldquo;markers&rdquo;. Options are
</p>

<ul>
<li><p>'ratio' selects and ranks markers by the ratio of the mean expression of each gene in each cell type to the mean of that gene in all other cell types.
</p>
</li>
<li><p>'regression ' selects and ranks markers by estimated regression coefficients in a series of regressions with single covariate that is indicator of each type.
</p>
</li>
<li><p>'diff' selects and ranks markers based upon the difference, for each cell type, between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li>
<li><p>'p.value' selects and ranks markers based upon the p-value of a t-test between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dtangle2_+3A_weights">weights</code></td>
<td>
<p>Weights for the genes.
</p>
<p>(Optional) String or one-dimensional numeric vector. 
</p>
<p>Weights for the genes in the optimization. If NULL (default) then does not weight genes differently. If 'variance' then inversely weights with the variance of the references. This only works if there is more than one reference per cell type so that the variance can be estimated. If a numeric then this uses whatever is specified as weights. They must be non-negative.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_sto">sto</code></td>
<td>
<p>Sum-to-one constraint.
</p>
<p>(Optional) Boolean.
</p>
<p>Re-normalize the estimates so that the cell-type proportions sum to one.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_inv_scale">inv_scale</code></td>
<td>
<p>Inverse scale transformation.
</p>
<p>(Optional) Function. 
</p>
<p>Defaults to 2^x. This is equivalent to assuming that the data has been log2-transformed. If another transformation has been applied to the data then this function should be used to specify the inverse of that transformation needed to put gene expressions on the linear scale.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_fit_scale">fit_scale</code></td>
<td>
<p>Transformation to used as part of optimization.
</p>
<p>(Optional) Function.
</p>
<p>Function to apply to gene expressions as part of optimization. Defaults to log.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_loss_smry">loss_smry</code></td>
<td>
<p>Loss summary function minimized to find estimated proportions.
</p>
<p>(Optional) String.
</p>
<p>Either 'var' (default) to minimze the (weighted) variance of the residuals or 'L2' to minimize the (weighted) sums of squares of the residuals.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_dtangle_init">dtangle_init</code></td>
<td>
<p>Optimization initialization.
</p>
<p>(Optional) Boolean.
</p>
<p>Boolean controlling if dtangle2 optimization should be initialized using dtangle1 estimates.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_seed">seed</code></td>
<td>
<p>(Optional) Integer.
</p>
<p>Value at which to seed the random seed before estimating. Optimization initialization might change if this value is not specified.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_verbose">verbose</code></td>
<td>
<p>(Optional) Boolean.
</p>
<p>Controls if optimization output is printed or not.</p>
</td></tr>
<tr><td><code id="dtangle2_+3A_optim_opts">optim_opts</code></td>
<td>
<p>(Optional) List.
</p>
<p>Optimization options passed to DEoptimR controlling optimization. Options that may be set are
</p>

<ul>
<li><p>'constr' constraint to enforce. Either 'box' for 0-1 box constraints that proportions are between zero and one, 'ineq' for constraints that proportions sum to less than one, 'eq' for equality constraints that proportions sum to one, or 'eq_solve' to solve for one of the parameters in terms of the other and enfoce equality constraints using inequality on remaining parameters. Default and recommended is 'box'.
</p>
</li>
<li><p>'ninit' number of randomly initalized points as part of the DEoptimR initial population.
</p>
</li>
<li><p>'tritter' how often to print results if 'verbose=TRUE'.
</p>
</li>
<li><p>'maxiter' maximum number of optimization iterations to use before exiting.
</p>
</li>
<li><p>'convtol' tolerance for convergence tolerance stopping criterion. 
</p>
</li>
<li><p>'constrtol' tolerance for constraint enforcement.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>

<ul>
<li><p>'estimates' a matrix estimated mixing proportions. One row for each sample, one column for each cell type.
</p>
</li>
<li><p>'markers' list of vectors of marker used for each cell type. Each element of list is vector of columns of <code>Y</code> used as a marker for the i-th cell type.
</p>
</li>
<li><p>'n_markers' vector of number of markers used for each cell type.
</p>
</li>
<li><p>'weights' the weights used as part of the optimization.
</p>
</li>
<li><p>'diag' diagnostic values for the estimated proportions.
<code>resids_hat</code>,<code>loss_hat</code>, and <code>p_hat</code> are the residuals, loss, and estimates for the proportions returned by dtangle2. Similarly, <code>resids_opt</code>,<code>loss_opt</code> and <code>p_opt</code> are these values for the optimized value not re-scaled to enforce the STO constraint. 

</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+find_markers">find_markers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
truth = shen_orr_ex$annotation$mixture
pure_samples &lt;- lapply(1:3, function(i) {
   which(truth[, i] == 1)
})
Y &lt;- shen_orr_ex$data$log
n_markers = 20

dtangle2(Y, pure_samples = pure_samples,
n_markers=n_markers)


</code></pre>

<hr>
<h2 id='est_phats'>Estimate the gene type proportions.</h2><span id='topic+est_phats'></span>

<h3>Description</h3>

<p>Estimate the gene type proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_phats(Y, markers, baseline_ests, gamma, summary_fn = mean,
  inv_scale = function(x) 2^x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_phats_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="est_phats_+3A_markers">markers</code></td>
<td>
<p>Marker gene indices.
</p>
<p>(Optional) List of one-dimensional integer.
</p>
<p>Top-level list should be same length as <code>pure_samples</code>, i.e. one element for each cell type. Each element of the top-level list is a vector of indicies (columns of <code>Y</code>) that will be considered markers of that particular type. If not supplied then <code>dtangle</code> finds markers internally using <code>find_markers</code>. Alternatively, one can supply the output of <code>find_markers</code> to the markers argument.</p>
</td></tr>
<tr><td><code id="est_phats_+3A_baseline_ests">baseline_ests</code></td>
<td>
<p>List of vectors (same structure as markers). One list entry for each cell type. Each list element is a vector of estimated offset for each marker of the respective type (output from <code>baseline_exprs</code>).</p>
</td></tr>
<tr><td><code id="est_phats_+3A_gamma">gamma</code></td>
<td>
<p>Expression adjustment term.
</p>
<p>(Optional) One-dimensional positive numeric.
</p>
<p>If provided as a single positive number then that value will be used for <code>gamma</code> and over-ride the value of gamma chosen by the <code>data_type</code> argument. If neither <code>gamma</code> nor <code>data_type</code> are specified then <code>gamma</code> will be set to one.</p>
</td></tr>
<tr><td><code id="est_phats_+3A_summary_fn">summary_fn</code></td>
<td>
<p>What summary statistic to use when aggregating expression measurements.
</p>
<p>(Optional) Function that takes a one-dimensional vector of numeric and returns a single numeric.
</p>
<p>Defaults to the mean. Other good options include the median.</p>
</td></tr>
<tr><td><code id="est_phats_+3A_inv_scale">inv_scale</code></td>
<td>
<p>Inverse scale transformation. Default to exponential as dtangle assumes data has been logarithmically transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated matrix of mixing proportions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truth = shen_orr_ex$annotation$mixture
pure_samples &lt;- lapply(1:3, function(i) {
   which(truth[, i] == 1)
})
Y &lt;- shen_orr_ex$data$log
markers = find_markers(Y=Y,pure_samples = pure_samples,
data_type='microarray-gene',marker_method='ratio')$L
K = length(pure_samples)
n_markers = rep(20,K)
mrkrs &lt;- lapply(1:K, function(i) {
       markers[[i]][1:n_markers[i]]
})
baseline = dtangle:::baseline_exprs(Y, pure_samples, mrkrs)
phats &lt;- dtangle:::est_phats(Y, mrkrs, baseline, gamma=.8)
</code></pre>

<hr>
<h2 id='find_markers'>Find marker genes for each cell type.</h2><span id='topic+find_markers'></span>

<h3>Description</h3>

<p>Find marker genes for each cell type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_markers(Y, references = NULL, pure_samples = NULL,
  data_type = NULL, gamma = NULL, marker_method = "ratio")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_markers_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="find_markers_+3A_references">references</code></td>
<td>
<p>Cell-type reference expression matrix.
</p>
<p>(Optional) Two-dimensional numeric. Must implement <code>as.matrix</code>. Must have same number of columns as <code>Y</code>. Columns must correspond to columns of <code>Y</code>.
</p>
<p>Each row contains expression measurements for a reference profile of a particular cell type. Columns contain measurements of reference profiles of a gene. Optionally may merge this matrix with <code>Y</code> and use <code>pure_samples</code> to indicate which rows of <code>Y</code> are pure samples. If <code>pure_samples</code> is not specified <code>references</code> must be specified. In this case each row of <code>references</code> is assumed to be a distinct cell-type. If both <code>pure_samples</code> and <code>references</code> are specified then multiple rows of <code>references</code> may refer be the same cell type, and <code>pure_samples</code> specifies to which cell-type each row of <code>references</code> corresponds.</p>
</td></tr>
<tr><td><code id="find_markers_+3A_pure_samples">pure_samples</code></td>
<td>
<p>The pure sample indicies.
</p>
<p>(Optional) List of one-dimensional integer. Must implement <code>as.list</code>.
</p>
<p>The i-th element of the top-level list is a vector of indicies (rows of <code>Y</code> or <code>references</code>) that are pure samples of type i. If <code>references</code> is not specified then this argument identifies which rows of <code>Y</code> correspond to pure reference samples of which cell-types. If <code>references</code> is specified then this makes same idenficiation but for the <code>references</code> matrix instead.</p>
</td></tr>
<tr><td><code id="find_markers_+3A_data_type">data_type</code></td>
<td>
<p>Type of expression measurements.
</p>
<p>(Optional) One-dimensional string. 
</p>
<p>An optional string indicating the type of the expression measurements. This is used to set gamma to a pre-determined value based upon the data type. Valid values are for probe-level microarray as &ldquo;microarray-probe&rdquo;, gene-level microarray as &ldquo;microarray-gene&rdquo; or rna-seq as &ldquo;rna-seq&rdquo;. Alternatively can set <code>gamma</code> directly.</p>
</td></tr>
<tr><td><code id="find_markers_+3A_gamma">gamma</code></td>
<td>
<p>Expression adjustment term.
</p>
<p>(Optional) One-dimensional positive numeric.
</p>
<p>If provided as a single positive number then that value will be used for <code>gamma</code> and over-ride the value of gamma chosen by the <code>data_type</code> argument. If neither <code>gamma</code> nor <code>data_type</code> are specified then <code>gamma</code> will be set to one.</p>
</td></tr>
<tr><td><code id="find_markers_+3A_marker_method">marker_method</code></td>
<td>
<p>Method used to rank marker genes.
</p>
<p>(Optional) One-dimensional string.
</p>
<p>The method used to rank genes as markers. If not supplied defaults to &ldquo;ratio&rdquo;. Only used if markers are not provided to argument &ldquo;markers&rdquo;. Options are
</p>

<ul>
<li><p>'ratio' selects and ranks markers by the ratio of the mean expression of each gene in each cell type to the mean of that gene in all other cell types.
</p>
</li>
<li><p>'regression ' selects and ranks markers by estimated regression coefficients in a series of regressions with single covariate that is indicator of each type.
</p>
</li>
<li><p>'diff' selects and ranks markers based upon the difference, for each cell type, between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li>
<li><p>'p.value' selects and ranks markers based upon the p-value of a t-test between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with four elements. &ldquo;L&rdquo; is respective ranked markers for each cell type and &ldquo;V&rdquo; is the corresponding values of the ranking method (higher are better) used to determine markers and sort them, &ldquo;M&rdquo; is the matrix used to create the other two arguments after sorting and subsetting, and &ldquo;sM&rdquo; is a sorted version of M.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>truth = shen_orr_ex$annotation$mixture
pure_samples &lt;- lapply(1:3, function(i) {
   which(truth[, i] == 1)
})
Y &lt;- shen_orr_ex$data$log
find_markers(Y=Y,pure_samples=pure_samples,
data_type='microarray-gene',marker_method='ratio')
</code></pre>

<hr>
<h2 id='get_gamma'>Determine gamma value by data type.</h2><span id='topic+get_gamma'></span>

<h3>Description</h3>

<p>Determine gamma value by data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gamma(data_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gamma_+3A_data_type">data_type</code></td>
<td>
<p>Type of expression measurements.
</p>
<p>(Optional) One-dimensional string. 
</p>
<p>An optional string indicating the type of the expression measurements. This is used to set gamma to a pre-determined value based upon the data type. Valid values are for probe-level microarray as &ldquo;microarray-probe&rdquo;, gene-level microarray as &ldquo;microarray-gene&rdquo; or rna-seq as &ldquo;rna-seq&rdquo;. Alternatively can set <code>gamma</code> directly.</p>
</td></tr>
</table>

<hr>
<h2 id='process_markers'>Determines number of markers <code>n_markers</code>, marker list <code>mrkrs</code>, and <code>gamma</code>.</h2><span id='topic+process_markers'></span>

<h3>Description</h3>

<p>Determines number of markers <code>n_markers</code>, marker list <code>mrkrs</code>, and <code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_markers(Y, pure_samples, n_markers, data_type, gamma, markers,
  marker_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_markers_+3A_y">Y</code></td>
<td>
<p>Expression matrix.
</p>
<p>(Required) Two-dimensional numeric. Must implement <code>as.matrix</code>.
</p>
<p>Each row contains expression measurements for a particular sample. Each columm contains the measurements of the same gene over all individuals. Can either contain just the mixture samples to be deconvolved or both the mixture samples and the reference samples. See <code>pure_samples</code> and <code>references</code> for more details.</p>
</td></tr>
<tr><td><code id="process_markers_+3A_pure_samples">pure_samples</code></td>
<td>
<p>The pure sample indicies.
</p>
<p>(Optional) List of one-dimensional integer. Must implement <code>as.list</code>.
</p>
<p>The i-th element of the top-level list is a vector of indicies (rows of <code>Y</code> or <code>references</code>) that are pure samples of type i. If <code>references</code> is not specified then this argument identifies which rows of <code>Y</code> correspond to pure reference samples of which cell-types. If <code>references</code> is specified then this makes same idenficiation but for the <code>references</code> matrix instead.</p>
</td></tr>
<tr><td><code id="process_markers_+3A_n_markers">n_markers</code></td>
<td>
<p>Number of marker genes.
</p>
<p>(Optional) One-dimensional numeric.
</p>
<p>How many markers genes to use for deconvolution. Can either be a single integer, vector of integers (one for each cell type), or single or vector of percentages (numeric in 0 to 1). If a single integer then all cell types use that number of markers. If a vector then the i-th element determines how many marker genes are used for the i-th cell type. If single percentage (in 0 to 1) then that percentage of markers are used for all types. If vector of percentages then that percentage used for each type, respectively. If not specified then top 10% of genes are used.</p>
</td></tr>
<tr><td><code id="process_markers_+3A_data_type">data_type</code></td>
<td>
<p>Type of expression measurements.
</p>
<p>(Optional) One-dimensional string. 
</p>
<p>An optional string indicating the type of the expression measurements. This is used to set gamma to a pre-determined value based upon the data type. Valid values are for probe-level microarray as &ldquo;microarray-probe&rdquo;, gene-level microarray as &ldquo;microarray-gene&rdquo; or rna-seq as &ldquo;rna-seq&rdquo;. Alternatively can set <code>gamma</code> directly.</p>
</td></tr>
<tr><td><code id="process_markers_+3A_gamma">gamma</code></td>
<td>
<p>Expression adjustment term.
</p>
<p>(Optional) One-dimensional positive numeric.
</p>
<p>If provided as a single positive number then that value will be used for <code>gamma</code> and over-ride the value of gamma chosen by the <code>data_type</code> argument. If neither <code>gamma</code> nor <code>data_type</code> are specified then <code>gamma</code> will be set to one.</p>
</td></tr>
<tr><td><code id="process_markers_+3A_markers">markers</code></td>
<td>
<p>Marker gene indices.
</p>
<p>(Optional) List of one-dimensional integer.
</p>
<p>Top-level list should be same length as <code>pure_samples</code>, i.e. one element for each cell type. Each element of the top-level list is a vector of indicies (columns of <code>Y</code>) that will be considered markers of that particular type. If not supplied then <code>dtangle</code> finds markers internally using <code>find_markers</code>. Alternatively, one can supply the output of <code>find_markers</code> to the markers argument.</p>
</td></tr>
<tr><td><code id="process_markers_+3A_marker_method">marker_method</code></td>
<td>
<p>Method used to rank marker genes.
</p>
<p>(Optional) One-dimensional string.
</p>
<p>The method used to rank genes as markers. If not supplied defaults to &ldquo;ratio&rdquo;. Only used if markers are not provided to argument &ldquo;markers&rdquo;. Options are
</p>

<ul>
<li><p>'ratio' selects and ranks markers by the ratio of the mean expression of each gene in each cell type to the mean of that gene in all other cell types.
</p>
</li>
<li><p>'regression ' selects and ranks markers by estimated regression coefficients in a series of regressions with single covariate that is indicator of each type.
</p>
</li>
<li><p>'diff' selects and ranks markers based upon the difference, for each cell type, between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li>
<li><p>'p.value' selects and ranks markers based upon the p-value of a t-test between the median expression of a gene by each cell type and the median expression of that gene by the second most highly expressed cell type.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='shen_orr_ex'>Example Subset of Shen-Orr deconvolution data set.</h2><span id='topic+shen_orr_ex'></span>

<h3>Description</h3>

<p>A subset of data from Shen-Orr et al. Triplicate samples of liver, brain and lung tissue were extracted from rats. RNA was extracted and mixed in known quantities. Gene expressions were measured using the Affymetrix Rat Genome 230 2.0 Array. True mixture proportions were known from experimental design. Gene expression measurements were summarized by RMA at the log2 level. Cell types reported are Liver, Brain and Lung. Data set introduced in 'Cell type-specific gene expression differences in complex tissues' by Shen-Orr et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shen_orr_ex
</code></pre>


<h3>Format</h3>

<p>List of lists. 
</p>

<dl>
<dt>data</dt><dd><p>list of data sets</p>
</dd>
<dt>annotation</dt><dd><p>annotation for the data set</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE19830">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE19830</a>, <a href="http://www.nature.com/nmeth/journal/v7/n4/abs/nmeth.1439.html">http://www.nature.com/nmeth/journal/v7/n4/abs/nmeth.1439.html</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
