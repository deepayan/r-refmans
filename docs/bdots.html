<!DOCTYPE html><html><head><title>Help for package bdots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bdots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ar1Solver'><p>Compute AR1 correlation coefficient</p></a></li>
<li><a href='#bdotsBoot'><p>Create bootstrapped curves from bdotsObj</p></a></li>
<li><a href='#bdotsCorr'><p>Correlation with fixed value in bdots</p></a></li>
<li><a href='#bdotsFit'><p>Fit nlme curves to grouped observations</p></a></li>
<li><a href='#bdotsFitter'><p>Fits Individual Subject Curve</p></a></li>
<li><a href='#bdotsRefit'><p>Refit Observations Returned from bdotsFit</p></a></li>
<li><a href='#bdRemove'><p>bdots Remove Function</p></a></li>
<li><a href='#ci'><p>ci dataset</p></a></li>
<li><a href='#coef.bdotsObj'><p>Extract bdotsFit Moedel Coefficients</p></a></li>
<li><a href='#coefWriteout'><p>Create <code>data.table</code> with <code>bdotsObj</code> parameters</p></a></li>
<li><a href='#cohort_unrelated'><p>cohort_unrelated dataset</p></a></li>
<li><a href='#curveFitter'><p>Curve Fitter</p></a></li>
<li><a href='#df_cohort_unrelated'><p>df_cohort_unrelated dataset</p></a></li>
<li><a href='#df_target'><p>df_target dataset</p></a></li>
<li><a href='#doubleGauss'><p>Double Gauss curve function for nlme</p></a></li>
<li><a href='#doubleGauss2'><p>DoubleGauss2 curve function for nlme</p></a></li>
<li><a href='#effectiveAlpha_f'><p>Effective Alpha Functional</p></a></li>
<li><a href='#expCurve'><p>Exponential curve function</p></a></li>
<li><a href='#findModifiedAlpha'><p>Find modified alpha</p></a></li>
<li><a href='#fwerAlpha'><p>fwerAlpha</p></a></li>
<li><a href='#getFitCorforGroups'><p>Get Fit Correlations</p></a></li>
<li><a href='#getSubCurveValues'><p>Return fitted values</p></a></li>
<li><a href='#linear'><p>Linear curve function</p></a></li>
<li><a href='#logistic'><p>Logistic curve function for nlme</p></a></li>
<li><a href='#p_adjust'><p>Adjust P-values for Multiple Comparisons</p></a></li>
<li><a href='#parTest2'><p>Parameter t-test</p></a></li>
<li><a href='#plot.bdotsBootObj'><p>Plot for object of class bdotsBootObj</p></a></li>
<li><a href='#plot.bdotsCorrObj'><p>Plots for bdotsCorr</p></a></li>
<li><a href='#plot.bdotsObj'><p>Plot a bdotsFit object</p></a></li>
<li><a href='#polynomial'><p>Polynomial curve function for nlme</p></a></li>
<li><a href='#print.bdotsBootObj'><p>Print 'bdotsBootObj'</p></a></li>
<li><a href='#print.bdotsBootSummary'><p>Print bdotsBoot Summary</p></a></li>
<li><a href='#print.bdotsPars_ttest2'><p>Print Parameter Test Summary</p></a></li>
<li><a href='#print.bdotsSummary'><p>Print bdotsObj Summary</p></a></li>
<li><a href='#rbindlist.bdObjList'><p>rbindlist for bdotsObjects</p></a></li>
<li><a href='#split.bdotsObj'><p>Split object of class bdotsObj</p></a></li>
<li><a href='#subset.bdotsBootObj'><p>Subset a nested group bdotsBoot objects</p></a></li>
<li><a href='#summary.bdotsBootObj'><p>Summary for bdotsBootObj</p></a></li>
<li><a href='#summary.bdotsObj'><p>Summary for bdotsObj</p></a></li>
<li><a href='#target'><p>target dataset</p></a></li>
<li><a href='#writeCSV'><p>Write fits from <code>bdotsBoot</code> to csv file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bootstrapped Differences of Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Collin Nolte, Michael Seedorff, Jacob Oleson, Grant Brown,
        Joseph Cavanaugh, and Bob McMurray</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Collin Nolte &lt;collin-nolte@uiowa.edu&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/collinn/bdots/issues">https://github.com/collinn/bdots/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, mvtnorm, parallel, stats, graphics, utils, ggplot2,
gridExtra</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyze differences among time series curves with p-value
        adjustment for multiple comparisons introduced in Oleson et al
        (2015) &lt;<a href="https://doi.org/10.1177%2F0962280215607411">doi:10.1177/0962280215607411</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/collinn/bdots">https://github.com/collinn/bdots</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 20:00:43 UTC; collin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ar1Solver'>Compute AR1 correlation coefficient</h2><span id='topic+ar1Solver'></span>

<h3>Description</h3>

<p>Computes value for AR1 correlation coefficient for use in <code>p_adjust</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1Solver(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar1Solver_+3A_t">t</code></td>
<td>
<p>A numeric vector of t-statistics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated AR1 correlation coefficient
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p_adjust">p_adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- rt(1e3, df = 1)
rho &lt;- ar1Solver(t)


</code></pre>

<hr>
<h2 id='bdotsBoot'>Create bootstrapped curves from bdotsObj</h2><span id='topic+bdotsBoot'></span>

<h3>Description</h3>

<p>Creates bootstrapped curves and performs alpha adjustment. Can perform
&quot;difference of difference&quot; for nested comparisons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdotsBoot(
  formula,
  bdObj,
  Niter = 1000,
  alpha = 0.05,
  padj = "oleson",
  cores = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdotsBoot_+3A_formula">formula</code></td>
<td>
<p>See details.</p>
</td></tr>
<tr><td><code id="bdotsBoot_+3A_bdobj">bdObj</code></td>
<td>
<p>An object of class 'bdotsObj'</p>
</td></tr>
<tr><td><code id="bdotsBoot_+3A_niter">Niter</code></td>
<td>
<p>Number of iterations of bootstrap to draw</p>
</td></tr>
<tr><td><code id="bdotsBoot_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="bdotsBoot_+3A_padj">padj</code></td>
<td>
<p>Adjustment to make to pvalues for significance. Will be able to
use anything from <code>p.adjust</code> function, but for now, just &quot;oleson&quot;</p>
</td></tr>
<tr><td><code id="bdotsBoot_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use in parallel. Default is zero, which
uses half of what is available.</p>
</td></tr>
<tr><td><code id="bdotsBoot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula is the only tricky part of this. There will be a minor
update to how it works in the future. The three parts we will examine here
are Groups, the LHS, and the RHS. For all variable names, special characters
should be included with backticks, i.e., <code>`my-var`</code>
</p>
<p>## Groups
</p>
<p>The Groups are the values input in <code>group</code> in the <code>bdotsFit</code> function,
which are columns of the dataset used. These will be denoted G_i
Within each group, we will designate the unique values within each group as v_j, ..., whereby
G_i(v_1, v_2) will designate unique two unique values within G_i. The possible
values of v_i will be implied by the group with which they are associated.
</p>
<p>For example, if we have groups <code>vehicle</code> and <code>color</code>, we could specify
that we are interested in all blue cars and trucks with the expression
<code>vehicle(car, truck) + color(red)</code>.
</p>
<p>## Formula
</p>
<p>### Bootstrapped difference of curves
</p>
<p>This illustrates the case in which we are taking a simple bootstraped difference
between two curves within a single group
</p>
<p>If only one group was provided in <code>bdotsFit</code>, we can take the bootstrapped
difference between two values within the group with
</p>
<p><code>y ~ Group1(val1, val2)</code>
</p>
<p>If more than two groups were provided, we must specify within which values of the
other groups we would like to compare the differences from Group1 in order to
uniquely identify the observations. This would be
</p>
<p><code>y ~ Group1(val1, val2) + Group2(val1)</code>
</p>
<p>For example, bootstrapping the differences between cars and trucks when <code>color</code>
was provided as a second group, we would need <code>y ~ vehicle(car, truck) + color(red)</code>.
</p>
<p>### Bootstrapped difference of difference curves
</p>
<p>This next portion illustrates the case in which we are interested in studying
the difference between the differences between two groups, which we will call
the innerGroup and the outerGroup following a nested container metaphor. Here,
we must use caution as the order of these differences matter. Using again the
vehicle example, we can describe this in two ways:
</p>

<ol>
<li><p> We may be interested in comparing the difference between red trucks and cars (d_red) with
the difference between blue trucks and cars (d_blue). In this case, we will be finding
the difference between cars and trucks twice (one for blue, one for red). The
vehicle type is the innerGroup, nested within the outerGroup, in this case, color.
</p>
</li>
<li><p> We may also be interested in comparing the difference between red trucks
and blue trucks (d_truck) with the difference between red and blue cars (d_car).
Here, innerGroup is the color and outerGroup is the vehicle
</p>
</li></ol>

<p>As our primary object of interest here is not the difference in outcome itself, but the difference
of the outcome within two groups, the LHS of the formula is written
<code>diffs(y, Group1(val1, val2))</code>, where Group1 is the innerGroup. The RHS
is then used to specify the groups of which we want to take the inner difference of. The
syntax here is the same as above. Together, then, the formula looks like
</p>
<p><code>diffs(y, Group1(val1, val2)) ~ Group2(val1, val2)</code>
</p>
<p>in the case in which only two grouping variables were provided to <code>bdotsFit</code>
and
</p>
<p><code>diffs(y, Group1(val1, val2)) ~ Group2(val1, val2) + Group3(val1) + ...</code>
</p>
<p>is used to uniquely identify the sets of differences when three or more groups were provided.
</p>


<h3>Value</h3>

<p>Object of class 'bdotsBootObj'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## fit &lt;- bdotsFit(cohort_unrelated, ...)

boot1 &lt;- bdotsBoot(formula = diffs(Fixations, LookType(Cohort, Unrelated_Cohort)) ~ Group(50, 65),
                   bdObj = fit,
                   N.iter = 1000,
                   alpha = 0.05,
                   p.adj = "oleson",
                   cores = 4)

boot2 &lt;- bdotsBoot(formula = Fixations ~ Group(50, 65) + LookType(Cohort),
                   bdObj = fit,
                   N.iter = 1000,
                   alpha = 0.05,
                   p.adj = "oleson",
                   cores = 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='bdotsCorr'>Correlation with fixed value in bdots</h2><span id='topic+bdotsCorr'></span>

<h3>Description</h3>

<p>Find the correlation of a fixed value with the bdots fitted
curves at each time point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdotsCorr(bdObj, val, ciBands = FALSE, method = "pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdotsCorr_+3A_bdobj">bdObj</code></td>
<td>
<p>Object of class 'bdotsObj'</p>
</td></tr>
<tr><td><code id="bdotsCorr_+3A_val">val</code></td>
<td>
<p>Character string of fixed value for correlation in dataset from 'bdotsFit'</p>
</td></tr>
<tr><td><code id="bdotsCorr_+3A_cibands">ciBands</code></td>
<td>
<p>Boolean for including confidence intervals</p>
</td></tr>
<tr><td><code id="bdotsCorr_+3A_method">method</code></td>
<td>
<p>Arguments for 'cor' or 'cor.test'. The default option us 'method = &quot;pearson&quot;'</p>
</td></tr>
</table>

<hr>
<h2 id='bdotsFit'>Fit nlme curves to grouped observations</h2><span id='topic+bdotsFit'></span>

<h3>Description</h3>

<p>Creates observation level curves to use in bdotsBoot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdotsFit(
  data,
  subject,
  time,
  y,
  group,
  curveType = doubleGauss(concave = TRUE),
  cor = TRUE,
  numRefits = 0,
  cores = 0,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdotsFit_+3A_data">data</code></td>
<td>
<p>Dataset used</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_subject">subject</code></td>
<td>
<p>Column name of dataset containing subject identifiers</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_time">time</code></td>
<td>
<p>Column name containing time variable</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_y">y</code></td>
<td>
<p>Column name containing outcome of interest</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_group">group</code></td>
<td>
<p>Character vector containing column names of groups. Can be
greater than one</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_curvetype">curveType</code></td>
<td>
<p>See details/vignette</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_cor">cor</code></td>
<td>
<p>Boolean. Autocorrelation?</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_numrefits">numRefits</code></td>
<td>
<p>Integer indicating number of attempts to fit an observation
if the first attempt fails</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_cores">cores</code></td>
<td>
<p>number of cores. Default is <code>0</code>, indicating half cores available</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_verbose">verbose</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="bdotsFit_+3A_...">...</code></td>
<td>
<p>Secret</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is step one of the three step bdots process. Things should be
more or less straight forward. The only tricky part involves curveType. For now
know that one can use doubleGauss(concave = TRUE/FALSE) or logistic(). Should
be passed in as a call. See the vignette on customizing this
</p>


<h3>Value</h3>

<p>Object of class 'bdotsObj', inherits from data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- bdotsFit(data = cohort_unrelated,
                subject = "Subject",
                time = "Time",
                y = "Fixations",
                group = c("Group", "LookType"),
                curveType = doubleGauss(concave = TRUE),
                cor = TRUE,
                numRefits = 2,
                cores = 0,
                verbose = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='bdotsFitter'>Fits Individual Subject Curve</h2><span id='topic+bdotsFitter'></span>

<h3>Description</h3>

<p>The one subject version of bdotsFit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdotsFitter(
  dat,
  curveType,
  rho,
  numRefits = 0,
  verbose,
  getCovOnly = NULL,
  params = NULL,
  splitVars = NULL,
  datVarNames = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdotsFitter_+3A_dat">dat</code></td>
<td>
<p>data for single subject/group combo</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_curvetype">curveType</code></td>
<td>
<p>this is actually a function. Should rename</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_numrefits">numRefits</code></td>
<td>
<p>number of refit attempts</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_verbose">verbose</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_getcovonly">getCovOnly</code></td>
<td>
<p>only find covariance matrix from starting parameter values</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_params">params</code></td>
<td>
<p>starting parameters, if wanting to add manually</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_splitvars">splitVars</code></td>
<td>
<p>variables used to identify group. Might combine with datVarNames</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_datvarnames">datVarNames</code></td>
<td>
<p>character vector indicating reponse and time values from parent call</p>
</td></tr>
<tr><td><code id="bdotsFitter_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='bdotsRefit'>Refit Observations Returned from bdotsFit</h2><span id='topic+bdotsRefit'></span>

<h3>Description</h3>

<p>Refit Observations Returned from bdotsFit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdotsRefit(
  bdObj,
  fitCode = 1L,
  quickRefit = FALSE,
  numRefits = 2L,
  paramDT = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdotsRefit_+3A_bdobj">bdObj</code></td>
<td>
<p>An object of class 'bdotsObj' returned from <code>bdotsFit</code></p>
</td></tr>
<tr><td><code id="bdotsRefit_+3A_fitcode">fitCode</code></td>
<td>
<p>A length one integer indicating observations to refit. See Details</p>
</td></tr>
<tr><td><code id="bdotsRefit_+3A_quickrefit">quickRefit</code></td>
<td>
<p>Boolean indicating if a quick refit should be used. If TRUE,
rather than prompting the user for adjustments for each observation, <code>bdotsReft</code>
will jitter the parameters of all observations indicated by <code>fitCode</code> and attempt
to refit. Between the original and the refitted curve, this will place priority on
the higher <code>fitCode</code>. If these are equal, R2 will take precedence. Otherwise,
the original fit will be kept.</p>
</td></tr>
<tr><td><code id="bdotsRefit_+3A_numrefits">numRefits</code></td>
<td>
<p>Integer indicating the number of refit attempts after jittering
parameters, either with quickRefit or when done individually</p>
</td></tr>
<tr><td><code id="bdotsRefit_+3A_paramdt">paramDT</code></td>
<td>
<p>A <code>data.table</code> or <code>data.frame</code> that matches the what is
returned by <code>coefWriteout(bdObj)</code>. That is, it should have columns
uniquely identifying observations with subjects and groups, as well as named
columns for the paramters. NA parameters are OK. Can also be a subset of the original rows.
Note, if this argument is not <code>NULL</code>, the remaining arguments will be ignored.</p>
</td></tr>
<tr><td><code id="bdotsRefit_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fitCode indicates lower bound on observations to refit. For example,
if <code>fitCode = 4</code>, <code>bdotsRefit</code> will prompt user to refit all
observations with fitCode = 4, 5, 6. The <code>quickRit</code> option will attempt
to jitter and refit all observations selected by <code>fitCode</code>. Otherwise, the
user will be prompted through a menu to individually refit observations
</p>


<h3>Value</h3>

<p>Returns bdObj with updated fits
</p>

<hr>
<h2 id='bdRemove'>bdots Remove Function</h2><span id='topic+bdRemove'></span>

<h3>Description</h3>

<p>Remove observations with a specified fitCode and optionally all pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdRemove(bdObj, fitCode = 6L, removePairs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdRemove_+3A_bdobj">bdObj</code></td>
<td>
<p>bdots object</p>
</td></tr>
<tr><td><code id="bdRemove_+3A_fitcode">fitCode</code></td>
<td>
<p>min fitCode to remove. Default is 6, which removes all subjects with NULL fits (fitCode = 5 would remove 5 and 6)</p>
</td></tr>
<tr><td><code id="bdRemove_+3A_removepairs">removePairs</code></td>
<td>
<p>Boolean. Remove subject pairs is one of pair is removed.
Default is TRUE to retain paired t-test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to remove all bdots observations with a fit code
equal to or larger than the argument passed to <code>fitCode</code> without refitting.
If <code>removePairs = TRUE</code>, all entries for a subject will be removed if their
fit failed in any of the groups in which they were a member
</p>

<hr>
<h2 id='ci'>ci dataset</h2><span id='topic+ci'></span>

<h3>Description</h3>

<p>ci dataset - need to include details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 108216 rows and 5 columns.
</p>

<hr>
<h2 id='coef.bdotsObj'>Extract bdotsFit Moedel Coefficients</h2><span id='topic+coef.bdotsObj'></span>

<h3>Description</h3>

<p>Returns coefficient matrix for bdotsFit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsObj'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.bdotsObj_+3A_object">object</code></td>
<td>
<p>A bdotsObj</p>
</td></tr>
<tr><td><code id="coef.bdotsObj_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns matrix of model coefficients for observations in <code>object</code>
</p>

<hr>
<h2 id='coefWriteout'>Create <code>data.table</code> with <code>bdotsObj</code> parameters</h2><span id='topic+coefWriteout'></span>

<h3>Description</h3>

<p>Creates an object of class <code>data.table</code> that matches
parameter values for each observation. This can then be
passed to the <code>bdotsRefit</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefWriteout(bdObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefWriteout_+3A_bdobj">bdObj</code></td>
<td>
<p>An object returned from <code>bdotsFit</code> or <code>bdotsRefit</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> matching parameter values to observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- bdotsFit(data = cohort_unrelated,
                subject = "Subject",
                time = "Time",
                y = "Fixations",
                group = c("Group", "LookType"),
                curveType = doubleGauss(concave = TRUE),
                cor = TRUE,
                numRefits = 2,
                cores = 0,
                verbose = FALSE)
parDT &lt;- coefWriteout(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='cohort_unrelated'>cohort_unrelated dataset</h2><span id='topic+cohort_unrelated'></span>

<h3>Description</h3>

<p>cohort_unrelated dataset - need to include details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohort_unrelated
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 50100 rows and 6 columns.
</p>

<hr>
<h2 id='curveFitter'>Curve Fitter</h2><span id='topic+curveFitter'></span>

<h3>Description</h3>

<p>Used in bdotsFit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curveFitter(dat, ff, params, rho, numRefits = 0, getCovOnly = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curveFitter_+3A_dat">dat</code></td>
<td>
<p>data used in building curve</p>
</td></tr>
<tr><td><code id="curveFitter_+3A_ff">ff</code></td>
<td>
<p>formula used in buildilng curve</p>
</td></tr>
<tr><td><code id="curveFitter_+3A_params">params</code></td>
<td>
<p>starting parameters</p>
</td></tr>
<tr><td><code id="curveFitter_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient</p>
</td></tr>
<tr><td><code id="curveFitter_+3A_numrefits">numRefits</code></td>
<td>
<p>number of refit attempts</p>
</td></tr>
<tr><td><code id="curveFitter_+3A_getcovonly">getCovOnly</code></td>
<td>
<p>only find covariance matrix from starting parameter values</p>
</td></tr>
<tr><td><code id="curveFitter_+3A_...">...</code></td>
<td>
<p>don't know that this is used, can maybe get rid of it</p>
</td></tr>
</table>

<hr>
<h2 id='df_cohort_unrelated'>df_cohort_unrelated dataset</h2><span id='topic+df_cohort_unrelated'></span>

<h3>Description</h3>

<p>df_cohort_unrelated dataset - need to include details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_cohort_unrelated
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 78156 rows and 5 columns.
</p>

<hr>
<h2 id='df_target'>df_target dataset</h2><span id='topic+df_target'></span>

<h3>Description</h3>

<p>df_target dataset - need to include details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_target
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 37575 rows and 4 columns.
</p>

<hr>
<h2 id='doubleGauss'>Double Gauss curve function for nlme</h2><span id='topic+doubleGauss'></span>

<h3>Description</h3>

<p>Double Gauss function used in fitting nlme curve for observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleGauss(dat, y, time, params = NULL, concave = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleGauss_+3A_dat">dat</code></td>
<td>
<p>subject data to be used</p>
</td></tr>
<tr><td><code id="doubleGauss_+3A_y">y</code></td>
<td>
<p>outcome variable, character vector</p>
</td></tr>
<tr><td><code id="doubleGauss_+3A_time">time</code></td>
<td>
<p>time variable, character vector</p>
</td></tr>
<tr><td><code id="doubleGauss_+3A_params">params</code></td>
<td>
<p><code>NULL</code> unless user wants to specify starting parameters for gnls</p>
</td></tr>
<tr><td><code id="doubleGauss_+3A_concave">concave</code></td>
<td>
<p>Boolean</p>
</td></tr>
<tr><td><code id="doubleGauss_+3A_...">...</code></td>
<td>
<p>just in case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User should only have to worry about setting concavity
of this function
</p>
<p><code>y ~ (time &lt; mu) * (exp(-1 * (time - mu) ^ 2
/ (2 * sig1 ^ 2)) * (ht - base1) + base1)
+ (mu &lt;= time) * (exp(-1 * (time - mu) ^ 2
                         / (2 * sig2 ^ 2)) * (ht - base2) + base2)</code>
</p>

<hr>
<h2 id='doubleGauss2'>DoubleGauss2 curve function for nlme</h2><span id='topic+doubleGauss2'></span>

<h3>Description</h3>

<p>DoubleGauss2 function used in fitting nlme curve for observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleGauss2(dat, y, time, params = NULL, concave = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleGauss2_+3A_dat">dat</code></td>
<td>
<p>subject data to be used</p>
</td></tr>
<tr><td><code id="doubleGauss2_+3A_y">y</code></td>
<td>
<p>outcome variable, character vector</p>
</td></tr>
<tr><td><code id="doubleGauss2_+3A_time">time</code></td>
<td>
<p>time variable, character vector</p>
</td></tr>
<tr><td><code id="doubleGauss2_+3A_params">params</code></td>
<td>
<p><code>NULL</code> unless user wants to specify starting parameters for gnls</p>
</td></tr>
<tr><td><code id="doubleGauss2_+3A_concave">concave</code></td>
<td>
<p>Boolean</p>
</td></tr>
<tr><td><code id="doubleGauss2_+3A_...">...</code></td>
<td>
<p>just in case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User should only have to worry about setting concavity
of this function. Presently only work for time series scaled out to 2000ms
</p>
<p><code>y ~ (time &lt; mu) * (exp(-1 * (time - mu) ^ 2
/ (2 * sig1 ^ 2)) * (ht - base1) + base1)
+ (mu &lt;= time) * (exp(-1 * (time - mu) ^ 2
                         / (2 * sig2 ^ 2)) * (ht - base2) + base2)</code>
</p>

<hr>
<h2 id='effectiveAlpha_f'>Effective Alpha Functional</h2><span id='topic+effectiveAlpha_f'></span>

<h3>Description</h3>

<p>Functional that returns function for computing effective alpha for given
parameters and distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectiveAlpha_f(rho, n = 10, df = NULL, method = "norm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectiveAlpha_f_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient</p>
</td></tr>
<tr><td><code id="effectiveAlpha_f_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="effectiveAlpha_f_+3A_df">df</code></td>
<td>
<p>Degrees of freedom if <code>method = "t"</code></p>
</td></tr>
<tr><td><code id="effectiveAlpha_f_+3A_method">method</code></td>
<td>
<p>Character string. Determines distribution for adjusted alpha
can be either <code>"norm"</code> for normal distribution or <code>"t"</code> for t-dist</p>
</td></tr>
</table>

<hr>
<h2 id='expCurve'>Exponential curve function</h2><span id='topic+expCurve'></span>

<h3>Description</h3>

<p>Exponential function used in fitting nlme curve for observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expCurve(dat, y, time, params = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expCurve_+3A_dat">dat</code></td>
<td>
<p>subject data to be used</p>
</td></tr>
<tr><td><code id="expCurve_+3A_y">y</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="expCurve_+3A_time">time</code></td>
<td>
<p>time variable</p>
</td></tr>
<tr><td><code id="expCurve_+3A_params">params</code></td>
<td>
<p><code>NULL</code> unless user wants to specify starting parameters for gnls</p>
</td></tr>
<tr><td><code id="expCurve_+3A_...">...</code></td>
<td>
<p>just in case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remove any values of zero, or jitter, before using with bdotsFit
</p>
<p><code>y ~ x_0 exp(k beta)</code>
</p>

<hr>
<h2 id='findModifiedAlpha'>Find modified alpha</h2><span id='topic+findModifiedAlpha'></span>

<h3>Description</h3>

<p>find modified alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findModifiedAlpha(
  rho,
  n,
  df,
  alpha = 0.05,
  errorAcc = 0.001,
  gradDiff = ifelse(cores &gt; 3, 0.5, 0.1),
  cores = 0,
  verbose = FALSE,
  method = "t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findModifiedAlpha_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_df">df</code></td>
<td>
<p>degrees of freedom if method == &quot;t&quot;</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_alpha">alpha</code></td>
<td>
<p>starting alpha from which to adjust</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_erroracc">errorAcc</code></td>
<td>
<p>acceptable error for alphastar</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_graddiff">gradDiff</code></td>
<td>
<p>gradient steps in algorithm</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_cores">cores</code></td>
<td>
<p>number of cores. Default is zero, or half of what's available</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_verbose">verbose</code></td>
<td>
<p>will probably remove this</p>
</td></tr>
<tr><td><code id="findModifiedAlpha_+3A_method">method</code></td>
<td>
<p>either &quot;t&quot; or &quot;norm&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='fwerAlpha'>fwerAlpha</h2><span id='topic+fwerAlpha'></span>

<h3>Description</h3>

<p>Family wise alpha calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwerAlpha(rho, k, n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwerAlpha_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient</p>
</td></tr>
<tr><td><code id="fwerAlpha_+3A_k">k</code></td>
<td>
<p>Bounds of non-critical region</p>
</td></tr>
<tr><td><code id="fwerAlpha_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns effective alpha, given number of tests and the correlation
coefficient. This isn't explicitly checked, but there is no reason this function
should take any non-scalar values. Derivation of this can be found on pg 12
of Jake's 'Detecting time-specific differences'. This function performs the
expression </p>
<p style="text-align: center;"><code class="reqn">1 - P(I_t)P(I_t \ | \ I_{t-1})^{N-1}</code>
</p>


<hr>
<h2 id='getFitCorforGroups'>Get Fit Correlations</h2><span id='topic+getFitCorforGroups'></span>

<h3>Description</h3>

<p>Helper function for finding correlation of fixed value and
fitted values within group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFitCorforGroups(x, val, ciBands = FALSE, method = "pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFitCorforGroups_+3A_x">x</code></td>
<td>
<p>A split object of class 'bdObj' split by identifiers</p>
</td></tr>
<tr><td><code id="getFitCorforGroups_+3A_val">val</code></td>
<td>
<p>Fixed value from dataset</p>
</td></tr>
<tr><td><code id="getFitCorforGroups_+3A_cibands">ciBands</code></td>
<td>
<p>boolean for including cibands</p>
</td></tr>
<tr><td><code id="getFitCorforGroups_+3A_method">method</code></td>
<td>
<p>method for correlation function</p>
</td></tr>
</table>

<hr>
<h2 id='getSubCurveValues'>Return fitted values</h2><span id='topic+getSubCurveValues'></span>

<h3>Description</h3>

<p>Returns fitted values at observed times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubCurveValues(bd, origNames = TRUE, origTime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubCurveValues_+3A_bd">bd</code></td>
<td>
<p>Single row of bdObj</p>
</td></tr>
<tr><td><code id="getSubCurveValues_+3A_orignames">origNames</code></td>
<td>
<p>use original names for y and time, or use &quot;y&quot; and &quot;time&quot;</p>
</td></tr>
<tr><td><code id="getSubCurveValues_+3A_origtime">origTime</code></td>
<td>
<p>Boolean. Do I actually want fitted values at observed times for that
subject, or data.table with fitted values at the union of times</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a single row of bdObj, this returns fitted values at the observed
times to use in conjunction with whatever else
</p>

<hr>
<h2 id='linear'>Linear curve function</h2><span id='topic+linear'></span>

<h3>Description</h3>

<p>Linear function used in fitting nlme curve for observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear(dat, y, time, params = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_+3A_dat">dat</code></td>
<td>
<p>subject data to be used</p>
</td></tr>
<tr><td><code id="linear_+3A_y">y</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="linear_+3A_time">time</code></td>
<td>
<p>time variable</p>
</td></tr>
<tr><td><code id="linear_+3A_params">params</code></td>
<td>
<p><code>NULL</code> unless user wants to specify starting parameters for gnls</p>
</td></tr>
<tr><td><code id="linear_+3A_...">...</code></td>
<td>
<p>just in case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Don't use this function please
</p>
<p><code>y ~ slope*time + intercept</code>
</p>

<hr>
<h2 id='logistic'>Logistic curve function for nlme</h2><span id='topic+logistic'></span>

<h3>Description</h3>

<p>Logistic function used in fitting nlme curve for observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic(dat, y, time, params = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_+3A_dat">dat</code></td>
<td>
<p>subject data to be used</p>
</td></tr>
<tr><td><code id="logistic_+3A_y">y</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="logistic_+3A_time">time</code></td>
<td>
<p>time variable</p>
</td></tr>
<tr><td><code id="logistic_+3A_params">params</code></td>
<td>
<p><code>NULL</code> unless user wants to specify starting parameters for gnls</p>
</td></tr>
<tr><td><code id="logistic_+3A_...">...</code></td>
<td>
<p>just in case</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y ~ mini + (peak - mini) / (1 + exp(4 * slope * (cross - (time)) / (peak - mini)))</code>
</p>

<hr>
<h2 id='p_adjust'>Adjust P-values for Multiple Comparisons</h2><span id='topic+p_adjust'></span>

<h3>Description</h3>

<p>Identical to <code>stats::p.adjust</code>, but includes <code>method = "oleson"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_adjust(p, method = "oleson", n = length(p), alpha = 0.05, df, rho, cores = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_adjust_+3A_p">p</code></td>
<td>
<p>numeric vector of p-values (possibly with NAs).</p>
</td></tr>
<tr><td><code id="p_adjust_+3A_method">method</code></td>
<td>
<p>correction method, a character string. Can be any of the methods in
p.adjust.methods, with the additional value <code>method = "oleson"</code></p>
</td></tr>
<tr><td><code id="p_adjust_+3A_n">n</code></td>
<td>
<p>number of comparisons, must be at least <code>length(p)</code>; only set this
(to non-default) when you know what you are doing!</p>
</td></tr>
<tr><td><code id="p_adjust_+3A_alpha">alpha</code></td>
<td>
<p>adjustment to be made with method oleson</p>
</td></tr>
<tr><td><code id="p_adjust_+3A_df">df</code></td>
<td>
<p>degrees of freedom, if using <code>method = "oleson"</code></p>
</td></tr>
<tr><td><code id="p_adjust_+3A_rho">rho</code></td>
<td>
<p>AR1 correlation coefficient, if using <code>method = "oleson"</code></p>
</td></tr>
<tr><td><code id="p_adjust_+3A_cores">cores</code></td>
<td>
<p>number of cores for use in parallel, only valid for
<code>method = "oleson"</code>. Default is zero, using half of the available cores</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works identically to the function <code>p.adjust</code>, with
the additional option to use <code>method = "oleson"</code>. For this option, user
must include a value for <code>df</code>, <code>alpha</code>. If <code>method = "oleson"</code> and
no value is given for <code>rho</code>, 0.9 will be used. To compute a value for <code>rho</code>
from t-statistics, use <code>ar1Solver</code>.
</p>


<h3>Value</h3>

<p>Returns a vector of adjusted p-values just as in <code>p.adjust</code>, but
with additional attributes for alphastar and rho.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ar1Solver">ar1Solver</a></code>
</p>

<hr>
<h2 id='parTest2'>Parameter t-test</h2><span id='topic+parTest2'></span>

<h3>Description</h3>

<p>Perform t-test on curve parameters of bdotsFit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parTest2(bdObj, group, vals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parTest2_+3A_bdobj">bdObj</code></td>
<td>
<p>Object of class <code>bdObj</code></p>
</td></tr>
<tr><td><code id="parTest2_+3A_group">group</code></td>
<td>
<p>Length one character of grouping column in which to perform t-test</p>
</td></tr>
<tr><td><code id="parTest2_+3A_vals">vals</code></td>
<td>
<p>Character vector of values within grouping column in which to perform the
test. If <code>NULL</code>, it will do all pairwise tests</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs pairwise t-test. Currently only tests at alpha = 0.95. Also
currently only allows t-test within single grouping column. Ability to test
across grouping columns to come later
</p>


<h3>Value</h3>

<p>List of t-test results of class <code>bdotsPars_ttest</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- bdotsFit(data = cohort_unrelated,
                subject = "Subject",
                time = "Time",
                y = "Fixations",
                group = c("Group", "LookType"),
                curveType = doubleGauss(concave = TRUE),
                cor = TRUE,
                numRefits = 2,
                cores = 0,
                verbose = FALSE)
tstats &lt;- parTest(res, group = "LookType", vals = c("Cohort", "Unrelated_Cohort"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bdotsBootObj'>Plot for object of class bdotsBootObj</h2><span id='topic+plot.bdotsBootObj'></span>

<h3>Description</h3>

<p>Allows a number of different but also unstable option for plotting an object
of class bdotsBoot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsBootObj'
plot(x, alpha = NULL, ciBands = TRUE, plotDiffs = TRUE, group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bdotsBootObj_+3A_x">x</code></td>
<td>
<p>An object of class bdotsBootObj</p>
</td></tr>
<tr><td><code id="plot.bdotsBootObj_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for plotting confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.bdotsBootObj_+3A_cibands">ciBands</code></td>
<td>
<p>Boolean indicating whether or not to include confidence intervals
around fitted curves</p>
</td></tr>
<tr><td><code id="plot.bdotsBootObj_+3A_plotdiffs">plotDiffs</code></td>
<td>
<p>Boolean to plot difference curve</p>
</td></tr>
<tr><td><code id="plot.bdotsBootObj_+3A_group">group</code></td>
<td>
<p>Specify group to plot if difference of difference was used. The
user can also subset the bdotsBootObj prior to plotting. Currently not used</p>
</td></tr>
<tr><td><code id="plot.bdotsBootObj_+3A_...">...</code></td>
<td>
<p>ignore for now, but will eventually allow plot parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot function is also a bit unstable and is expected to change
</p>


<h3>Value</h3>

<p>List of ggplot objects, which may be helpful if the margins are weird
</p>

<hr>
<h2 id='plot.bdotsCorrObj'>Plots for bdotsCorr</h2><span id='topic+plot.bdotsCorrObj'></span>

<h3>Description</h3>

<p>Plots correlation of fixed value wtih fitted curves over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsCorrObj'
plot(x, ciBands = FALSE, window = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bdotsCorrObj_+3A_x">x</code></td>
<td>
<p>object of class 'bdotsCorrObj'</p>
</td></tr>
<tr><td><code id="plot.bdotsCorrObj_+3A_cibands">ciBands</code></td>
<td>
<p>boolean. Whether or not to include confidence intervals in plots.
Must have been selected in 'bdotsCorr'</p>
</td></tr>
<tr><td><code id="plot.bdotsCorrObj_+3A_window">window</code></td>
<td>
<p>A length 2 numeric vector with start and end points
for the  plotting window</p>
</td></tr>
<tr><td><code id="plot.bdotsCorrObj_+3A_...">...</code></td>
<td>
<p>super secret, don't use</p>
</td></tr>
</table>

<hr>
<h2 id='plot.bdotsObj'>Plot a bdotsFit object</h2><span id='topic+plot.bdotsObj'></span>

<h3>Description</h3>

<p>Plot individual fits or model fit parameters from an object of class
'bdotsObj'. These functions are not very stable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsObj'
plot(x, fitCode = NULL, gridSize = NULL, plotfun = "fits", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bdotsObj_+3A_x">x</code></td>
<td>
<p>An object of class 'bdotsObj' returned from <code>bdotsFit</code></p>
</td></tr>
<tr><td><code id="plot.bdotsObj_+3A_fitcode">fitCode</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="plot.bdotsObj_+3A_gridsize">gridSize</code></td>
<td>
<p>Length one numeric indicating size of plot grid. Default is
2x2. For right now, they are square</p>
</td></tr>
<tr><td><code id="plot.bdotsObj_+3A_plotfun">plotfun</code></td>
<td>
<p>Plot either subject fits or model parameters with &quot;fits&quot; or &quot;pars&quot;</p>
</td></tr>
<tr><td><code id="plot.bdotsObj_+3A_...">...</code></td>
<td>
<p>ignore for now (other args to plot.generic)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Right now, these functions are a bit unstable and expected to change.
The largest current issue is with the placement of the legend, which cannot
be adjusted. If you are running into issues with seeing things correctly, try
making the &quot;Plots&quot; window in RStudio larger before running this function
</p>


<h3>Value</h3>

<p>This will return a list of all of the plots rendered.
</p>

<hr>
<h2 id='polynomial'>Polynomial curve function for nlme</h2><span id='topic+polynomial'></span>

<h3>Description</h3>

<p>Polynomial function used in fitting nlme curve for observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polynomial(dat, y, time, degree, raw = TRUE, params = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polynomial_+3A_dat">dat</code></td>
<td>
<p>subject data to be used</p>
</td></tr>
<tr><td><code id="polynomial_+3A_y">y</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="polynomial_+3A_time">time</code></td>
<td>
<p>time variable</p>
</td></tr>
<tr><td><code id="polynomial_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial</p>
</td></tr>
<tr><td><code id="polynomial_+3A_raw">raw</code></td>
<td>
<p>Boolean, use raw polynomials?</p>
</td></tr>
<tr><td><code id="polynomial_+3A_params">params</code></td>
<td>
<p><code>NULL</code> unless user wants to specify starting parameters for gnls</p>
</td></tr>
<tr><td><code id="polynomial_+3A_...">...</code></td>
<td>
<p>just in case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's recommended that one uses raw polynomials for this function for
numerical stability. As inference is not performed on the parameters themselves,
this should have minimial consequences
</p>
<p><code>y ~ mini + (peak - mini) / (1 + exp(4 * slope * (cross - (time)) / (peak - mini)))</code>
</p>

<hr>
<h2 id='print.bdotsBootObj'>Print 'bdotsBootObj'</h2><span id='topic+print.bdotsBootObj'></span>

<h3>Description</h3>

<p>Prints argument. Really, just the summary function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsBootObj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bdotsBootObj_+3A_x">x</code></td>
<td>
<p>An object of class 'bdotsBootObj'</p>
</td></tr>
<tr><td><code id="print.bdotsBootObj_+3A_...">...</code></td>
<td>
<p>Top secret alpha one code red</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic for printing 'bdotsBootObj'
</p>

<hr>
<h2 id='print.bdotsBootSummary'>Print bdotsBoot Summary</h2><span id='topic+print.bdotsBootSummary'></span>

<h3>Description</h3>

<p>That's pretty much it. This is a print method, so there is likely
not much need to call it directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsBootSummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bdotsBootSummary_+3A_x">x</code></td>
<td>
<p>generic name, but this will be an object of bdotsBootSummary</p>
</td></tr>
<tr><td><code id="print.bdotsBootSummary_+3A_...">...</code></td>
<td>
<p>ignored for now</p>
</td></tr>
</table>

<hr>
<h2 id='print.bdotsPars_ttest2'>Print Parameter Test Summary</h2><span id='topic+print.bdotsPars_ttest2'></span>

<h3>Description</h3>

<p>Print Parameter Test Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsPars_ttest2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bdotsPars_ttest2_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="print.bdotsPars_ttest2_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>That's pretty much it. This is a print method, so there is likely
not much need to call it directly
</p>

<hr>
<h2 id='print.bdotsSummary'>Print bdotsObj Summary</h2><span id='topic+print.bdotsSummary'></span>

<h3>Description</h3>

<p>Print bdotsObj Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsSummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bdotsSummary_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="print.bdotsSummary_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>That's pretty much it. This is a print method, so there is likely
not much need to call it directly
</p>

<hr>
<h2 id='rbindlist.bdObjList'>rbindlist for bdotsObjects</h2><span id='topic+rbindlist.bdObjList'></span>

<h3>Description</h3>

<p>Similar to data.table::rbindlist, but preserves botsObjects attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdObjList'
rbindlist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindlist.bdObjList_+3A_x">x</code></td>
<td>
<p>bdotsObject</p>
</td></tr>
<tr><td><code id="rbindlist.bdObjList_+3A_...">...</code></td>
<td>
<p>for compatability with data.table</p>
</td></tr>
</table>

<hr>
<h2 id='split.bdotsObj'>Split object of class bdotsObj</h2><span id='topic+split.bdotsObj'></span>

<h3>Description</h3>

<p>Analogous to other splitting functions, but retains necessary attributes
across the split object. As of now, it can only be unsplit with bdots::rbindlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsObj'
split(x, f, drop = FALSE, by, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.bdotsObj_+3A_x">x</code></td>
<td>
<p>Object of class bdotsObj</p>
</td></tr>
<tr><td><code id="split.bdotsObj_+3A_f">f</code></td>
<td>
<p>For consistency with generic, but is not used</p>
</td></tr>
<tr><td><code id="split.bdotsObj_+3A_drop">drop</code></td>
<td>
<p>logical. Default FALSE will not drop empty list elements caused
by factor levels not referred by that factor. Analagous to data.table::split</p>
</td></tr>
<tr><td><code id="split.bdotsObj_+3A_by">by</code></td>
<td>
<p>Character vector of column names on which to split. Usually will
be Subject or one of the fitted groups</p>
</td></tr>
<tr><td><code id="split.bdotsObj_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='subset.bdotsBootObj'>Subset a nested group bdotsBoot objects</h2><span id='topic+subset.bdotsBootObj'></span>

<h3>Description</h3>

<p>Subset a nested group bdotsBoot objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsBootObj'
subset(x, group, adjustAlpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.bdotsBootObj_+3A_x">x</code></td>
<td>
<p>An object returned from <code>bdotsBoot</code></p>
</td></tr>
<tr><td><code id="subset.bdotsBootObj_+3A_group">group</code></td>
<td>
<p>A group to subset. Must be an outer group</p>
</td></tr>
<tr><td><code id="subset.bdotsBootObj_+3A_adjustalpha">adjustAlpha</code></td>
<td>
<p>currently not used. Will give option to recompute adjusted alpha</p>
</td></tr>
<tr><td><code id="subset.bdotsBootObj_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to subset a bdotsBootObject that was fit to compute
the difference of differences. This allows the user to subset out the outer group
in the comparison for plotting and investigation
</p>

<hr>
<h2 id='summary.bdotsBootObj'>Summary for bdotsBootObj</h2><span id='topic+summary.bdotsBootObj'></span>

<h3>Description</h3>

<p>Provides summary information for bdotsBootObj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsBootObj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bdotsBootObj_+3A_object">object</code></td>
<td>
<p>An object of class bdotsObj</p>
</td></tr>
<tr><td><code id="summary.bdotsBootObj_+3A_...">...</code></td>
<td>
<p>Ignored for now</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class &quot;bdotsBootSummary&quot;. There is some summarized
information included if assigned to an object, i.e., 'summ &lt;- summary(bdBootObj)'
then 'str(summ)'
</p>

<hr>
<h2 id='summary.bdotsObj'>Summary for bdotsObj</h2><span id='topic+summary.bdotsObj'></span>

<h3>Description</h3>

<p>Provides summary information for bdotsObj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bdotsObj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bdotsObj_+3A_object">object</code></td>
<td>
<p>An object of class bdotsObj</p>
</td></tr>
<tr><td><code id="summary.bdotsObj_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class &quot;bdotsSummary&quot;. There is some summarized
information included if assigned to an object, i.e., 'summ &lt;- summary(bdObj)'
then 'str(summ)'
</p>

<hr>
<h2 id='target'>target dataset</h2><span id='topic+target'></span>

<h3>Description</h3>

<p>target dataset - need to include details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 25050 rows and 4 columns.
</p>

<hr>
<h2 id='writeCSV'>Write fits from <code>bdotsBoot</code> to csv file</h2><span id='topic+writeCSV'></span>

<h3>Description</h3>

<p>The function is used to write out columns for each group for which a curve
was bootstrapped
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCSV(bootObj, file, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCSV_+3A_bootobj">bootObj</code></td>
<td>
<p>An object of class <code>bdotsBootObj</code></p>
</td></tr>
<tr><td><code id="writeCSV_+3A_file">file</code></td>
<td>
<p>file name to write out csv</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for upper/lower CI</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>data.table::fread</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is potentially useful for constructing plots in a separate
application. There is an additional column, <code>Significant</code> indicating if
a particular time point was considered significant between the difference curves.
For difference of difference objects, this only indicates significance for the
outer difference.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
