<!DOCTYPE html><html lang="en"><head><title>Help for package UBStats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UBStats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#UBStats-package'><p>UBStats: a package for teaching and learning introductory statistics</p></a></li>
<li><a href='#CI.diffmean'><p>Confidence intervals for the difference between means</p></a></li>
<li><a href='#CI.diffprop'><p>Confidence intervals for the difference between proportions</p></a></li>
<li><a href='#CI.mean'><p>Confidence intervals for the mean</p></a></li>
<li><a href='#CI.prop'><p>Confidence intervals for the proportion</p></a></li>
<li><a href='#distr.plot.x'><p>Analysis of a univariate distribution using plots</p></a></li>
<li><a href='#distr.plot.xy'><p>Analysis of a bivariate distribution using plots</p></a></li>
<li><a href='#distr.summary.x'><p>Summary statistics for a single variable</p></a></li>
<li><a href='#distr.table.x'><p>Analysis of a univariate distribution using frequency tables</p></a></li>
<li><a href='#distr.table.xy'><p>Analysis of a bivariate distribution using cross-tables</p></a></li>
<li><a href='#LM.output'><p>Extract Model Residuals and other Regression Diagnostics</p></a></li>
<li><a href='#MktDATA'><p>Data: MktDATA</p></a></li>
<li><a href='#MktDATA.Orig'><p>Data: MktDATA.Orig</p></a></li>
<li><a href='#summaries.plot.x'><p>Plot of central and non-central conditional tendency measures for</p>
a single numeric variable</a></li>
<li><a href='#TEST.diffmean'><p>Tests on the difference between means</p></a></li>
<li><a href='#TEST.diffprop'><p>Tests on the difference between proportions</p></a></li>
<li><a href='#TEST.diffvar'><p>Tests on variances</p></a></li>
<li><a href='#TEST.mean'><p>Test on the mean</p></a></li>
<li><a href='#TEST.prop'><p>Test on the proportion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic statistical analyses. The package has been developed
    to be used in statistics courses at Bocconi University (Milan, Italy).
    Currently, the package includes some exploratory and inferential analyses
    usually presented in introductory statistics courses.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sergio Venturini &lt;sergio.venturini@unicatt.it&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), utils</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/raffaellapiccarreta/UBStats/issues">https://github.com/raffaellapiccarreta/UBStats/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-21 07:10:19 UTC; Sergio</td>
</tr>
<tr>
<td>Author:</td>
<td>Raffaella Piccarreta [aut],
  Sergio Venturini [cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-26 16:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='UBStats-package'>UBStats: a package for teaching and learning introductory statistics</h2><span id='topic+UBStats-package'></span><span id='topic+UBStats-pkg'></span><span id='topic+UBStats-p'></span><span id='topic+UBStats'></span>

<h3>Description</h3>

<p>The <span class="pkg">UBStats</span> package has been developed to support
instructors and students involved in basic statistics courses
at Bocconi University (Milan, Italy). It contains a limited
number of functions, with very similar and coherent syntax,
to easily perform descriptive and inferential statistical analyses.
</p>
<p>The main functions included in the package are:
</p>

<ul>
<li> <p><code><a href="#topic+distr.table.x">distr.table.x</a>()</code> and <code><a href="#topic+distr.plot.x">distr.plot.x</a>()</code> to
tabulate and plot the distribution of a single variable of any type
</p>
</li>
<li> <p><code><a href="#topic+distr.table.xy">distr.table.xy</a>()</code> and <code><a href="#topic+distr.plot.xy">distr.plot.xy</a>()</code>
to tabulate and plot the joint and conditional distributions for
two variables and to build scatterplots
</p>
</li>
<li> <p><code><a href="#topic+distr.summary.x">distr.summary.x</a>()</code> and <code><a href="#topic+summaries.plot.x">summaries.plot.x</a>()</code>
to calculate summaries of univariate distributions and/or conditional
summaries and to plot conditional location measures (means, medians
or quantiles)
</p>
</li>
<li> <p><code><a href="#topic+CI.mean">CI.mean</a>()</code> and <code><a href="#topic+TEST.mean">TEST.mean</a>()</code> to build
confidence intervals and to test hypotheses on the mean
</p>
</li>
<li> <p><code><a href="#topic+CI.prop">CI.prop</a>()</code> and <code><a href="#topic+TEST.prop">TEST.prop</a>()</code> to build
confidence intervals and to test hypotheses on the proportion
</p>
</li>
<li> <p><code><a href="#topic+CI.diffmean">CI.diffmean</a>()</code> and <code><a href="#topic+TEST.diffmean">TEST.diffmean</a>()</code> to
build confidence intervals and to test hypotheses on the difference
between means
</p>
</li>
<li> <p><code><a href="#topic+CI.diffprop">CI.diffprop</a>()</code> and <code><a href="#topic+TEST.diffprop">TEST.diffprop</a>()</code> to
build confidence intervals and to test hypotheses on the difference
between proportions
</p>
</li>
<li> <p><code><a href="#topic+TEST.diffvar">TEST.diffvar</a>()</code> to test hypotheses on the equality of
two variances
</p>
</li></ul>



<h3>Details</h3>

<p>The package has some distinctive features making it a convenient support
to students, attending courses on statistics using RStudio, approaching
the software for the first time.
</p>
<p>Descriptive statistical analyses can be performed for any type of variables,
with easy and intuitive procedures to tabulate also numerical variables
classified into intervals and/or variables measured in intervals. Collections
of univariate summary statistics can be easily obtained, also for factors.
Univariate and bivariate distributions can be graphically displayed using two
functions only, with a quite rich set of (basic) options.
</p>
<p>Inferential statistical analyses can be easily performed based on a reduced
set of functions with very similar syntax.
</p>
<p>A peculiar characteristic of the package is that in the case of errors the
procedure is not immediately interrupted. The functions collect all the
possible warnings and error and print a list of all the encountered problems
before the possible interruption due to unmanageable errors. This makes the
package very convenient for students who approach the study of statistics
using RStudio for the first time.
</p>
<p>To make suggestions about further developments please feel free to write
to <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>.
</p>

<hr>
<h2 id='CI.diffmean'>Confidence intervals for the difference between means</h2><span id='topic+CI.diffmean'></span>

<h3>Description</h3>

<p><code>CI.diffmean()</code> builds confidence intervals for the difference
between the means of two independent or paired populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI.diffmean(
  x,
  y,
  type = "independent",
  sigma.x = NULL,
  sigma.y = NULL,
  conf.level = 0.95,
  by,
  sigma.by = NULL,
  sigma.d = NULL,
  var.test = FALSE,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CI.diffmean_+3A_x">x</code>, <code id="CI.diffmean_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying two <em>numeric</em>
variables with the same length whose means have to be compared.
<code>x</code> and <code>y</code> can be the names of vectors in the workspace
or the names of columns in the data frame
specified in the <code>data</code> argument.
It is possible to use a mixed specification (e.g, one vector and one
column in data).</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_type">type</code></td>
<td>
<p>A length-one character vector specifying the type of samples.
Allowed values are <code>"independent"</code> or <code>"paired"</code>.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_sigma.x">sigma.x</code>, <code id="CI.diffmean_+3A_sigma.y">sigma.y</code></td>
<td>
<p>Optional numeric values specifying
the possibly known populations' standard deviations
(when <code>x</code> and <code>y</code> are specified). If <code>NULL</code> (default)
standard deviations are estimated using the data.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_conf.level">conf.level</code></td>
<td>
<p>Numeric value specifying the required
confidence level; default to 0.95.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_by">by</code></td>
<td>
<p>Optional unquoted string, available only when
<code>type = "independent"</code>, identifying a variable
(of any type), defined same way as <code>x</code>,
taking only <b>two</b> values used to split
<code>x</code> into two <b>independent samples</b>. Given the two
<em>ordered</em> values taken by <code>by</code>
(alphabetical or numerical order,
or order of the levels for factors), say <em>by1</em> and <em>by2</em>,
the confidence interval is built for the difference between the
populations means in the <em>by1</em>- and  in the <em>by2</em>-group.
Note that only <b>one</b> between <code>y</code> and <code>by</code> can be
specified.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_sigma.by">sigma.by</code></td>
<td>
<p>Optional numeric value specifying the possibly known
standard deviations for the two <em>independent</em> samples identified via
<code>by</code> (when <code>x</code> and <code>by</code> are specified).
<code>sigma.by</code> can be a single value indicating the same
standard deviation in the two by-groups, or a vector with two values,
specifying the standard deviations in the two by-groups. To avoid errors,
in the latter case the vector should be named, with names coinciding
with the two levels of <code>by</code>.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_sigma.d">sigma.d</code></td>
<td>
<p>Optional numeric value specifying the possibly known
standard deviation of the difference when samples are <b>paired</b>.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_var.test">var.test</code></td>
<td>
<p>Logical value indicating whether to run a test on the
equality of variance for two (<b>independent</b>) samples or not
(default).</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or
<code>y</code>. If not found in <code>data</code>, the variables
are taken from the environment
from which <code>CI.diffmean()</code> is called.</p>
</td></tr>
<tr><td><code id="CI.diffmean_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the confidence intervals for the difference
between the populations' means. For <em>independent</em> samples in the case
of unknown variances, the intervals are built both under the
assumption that the variances are equal and under the assumption that
they differ, using percentiles from both the normal and the
Student's t distribution. If 
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TEST.diffmean">TEST.diffmean</a>()</code> to test hypotheses on the
difference between two populations' means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Independent samples (default type), UNKNOWN variances
#  CI for the difference between means of males and females
#  - Using x,y: build vectors with data on the two groups
AOV_M &lt;- MktDATA$AOV[MktDATA$Gender == "M"]
AOV_F &lt;- MktDATA$AOV[MktDATA$Gender == "F"]
CI.diffmean(x = AOV_M, y = AOV_F)
#  - Change confidence level
CI.diffmean(x = AOV_M, y = AOV_F, conf.level = 0.99)
#  - Using x,by: groups identified by ordered levels of by
CI.diffmean(x = AOV, by = Gender, conf.level = 0.99, data = MktDATA)
#    Since order is F, M, CI is for mean(F) - mean(M)
#    To get the interval for mean(M) - mean(F)
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
CI.diffmean(x = AOV, by = Gender.R, conf.level = 0.99,  
            data = MktDATA)
#  - Testing hypotheses on equality of unknown variances
CI.diffmean(x = AOV_M, y = AOV_F, conf.level = 0.99, 
            var.test = TRUE)

#  - Output results: only information on the CI
out.ci_diffM&lt;-CI.diffmean(x = AOV_M, y = AOV_F)
#  - Output results: list with information on CI and test on var
out.ci_diffM.V&lt;-CI.diffmean(x = AOV_M, y = AOV_F, var.test = TRUE)

# Independent samples (default type), KNOWN variances
#  CI for the difference between means of males and females
#  - Using x,y: build vectors with data on the two groups
AOV_M &lt;- MktDATA$AOV[MktDATA$Gender == "M"]
AOV_F &lt;- MktDATA$AOV[MktDATA$Gender == "F"]
CI.diffmean(x = AOV_M, y = AOV_F, 
            sigma.x = 10, sigma.y = 20)
#  - Using x,by: groups identified by ordered levels of by
CI.diffmean(x = AOV, by = Gender, 
            sigma.by = c("M" = 10, "F"=20), data = MktDATA)
#    To change the sign, order levels as desired
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
CI.diffmean(x = AOV, by = Gender.R, 
            sigma.by = c("M" = 10, "F"=20), data = MktDATA)
#  - Output results 
out.ci_diffM&lt;-CI.diffmean(x = AOV_M, y = AOV_F, 
                          sigma.x = 10, sigma.y = 20)

# Paired samples: UNKNOWN variances
# - Default settings
CI.diffmean(x = NStore_Purch, y = NWeb_Purch,
            type = "paired", data=MktDATA)
# - Change confidence level
CI.diffmean(x = NStore_Purch, y = NWeb_Purch,
            type = "paired", conf.level = 0.9, data = MktDATA)
# Paired: KNOWN variances
CI.diffmean(x = NStore_Purch, y = NWeb_Purch,
            type = "paired", conf.level = 0.9, 
            sigma.d = 2, data = MktDATA)
#  - Output results 
out.ci_diffM&lt;-CI.diffmean(x = NStore_Purch, y = NWeb_Purch,
                          type = "paired", conf.level = 0.9, 
                          sigma.d = 2, data = MktDATA)

# Arguments force.digits and use.scientific
#  An input variable taking very low values
SmallX&lt;-MktDATA$AOV/5000
SmallX_M &lt;- SmallX[MktDATA$Gender == "M"]
SmallX_F &lt;- SmallX[MktDATA$Gender == "F"]
# - Default: manages possible excess of rounding
CI.diffmean(x = SmallX_M, y = SmallX_F)
# - Force to the requested nr of digits (default, 2)
CI.diffmean(x = SmallX_M, y = SmallX_F,
            force.digits = TRUE)
# - Allow scientific notation
CI.diffmean(x = SmallX_M, y = SmallX_F, 
            use.scientific = TRUE)

</code></pre>

<hr>
<h2 id='CI.diffprop'>Confidence intervals for the difference between proportions</h2><span id='topic+CI.diffprop'></span>

<h3>Description</h3>

<p><code>CI.diffprop()</code> builds confidence intervals for the difference
between the proportion of successes in two independent populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI.diffprop(
  x,
  y,
  success.x = NULL,
  success.y = NULL,
  conf.level = 0.95,
  by,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CI.diffprop_+3A_x">x</code>, <code id="CI.diffprop_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying the variables of
interest. <code>x</code> and <code>y</code> can be the
names of vectors or factors in the workspace or the
names of columns in the data frame
specified in the <code>data</code> argument.
It is possible to use a mixed specification
(e.g, one vector and one column in data).</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_success.x">success.x</code>, <code id="CI.diffprop_+3A_success.y">success.y</code></td>
<td>
<p>If <code>x,y</code> are factors, character
vectors, or numeric non-binary vectors, success must be used to indicate
the category/value corresponding to success in the populations. These
arguments can be omitted (<code>NULL</code>, default) if <code>x,y</code> are binary
numeric vectors (taking values 0 or 1 only; in this case success is
assumed to correspond to 1) or a logical vector (in these cases success
is assumed to correspond to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_conf.level">conf.level</code></td>
<td>
<p>Numeric value specifying the required
confidence level; default to 0.95.</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_by">by</code></td>
<td>
<p>Optional unquoted string identifying a variable
(of any type), defined same way as <code>x</code>,
taking only <b>two</b> values used to split
<code>x</code> into two independent samples. Given the two
<em>ordered</em> values taken by <code>by</code>
(alphabetical or numerical order,
or order of the levels for factors), say <em>by1</em> and <em>by2</em>,
the confidence interval is built for the difference between the
populations proportions in the <em>by1</em>- and  in the <em>by2</em>-group.
Note that only <b>one</b> between <code>y</code> and <code>by</code> can be
specified.</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or
<code>y</code>. If not found in <code>data</code>, the variables
are taken from the environment
from which <code>CI.diffprop()</code> is called.</p>
</td></tr>
<tr><td><code id="CI.diffprop_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the confidence intervals for the difference
between the proportions of successes in two independent populations.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TEST.diffprop">TEST.diffprop</a>()</code> to test hypotheses on the difference
between the proportions of successes in two populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Proportions of success defined on non-binary and 
#  non-logical vectors; 'success' coded same way
#  for both vectors
#  - Using x,y: build vectors with data on the two groups
WouldSuggest_F &lt;- MktDATA$WouldSuggest[MktDATA$Gender == "F"]
WouldSuggest_M &lt;- MktDATA$WouldSuggest[MktDATA$Gender == "M"]
CI.diffprop(x = WouldSuggest_M, y = WouldSuggest_F, 
            success.x = "Yes")

PastCampaigns_F&lt;-MktDATA$PastCampaigns[MktDATA$Gender=="F"]
PastCampaigns_M&lt;-MktDATA$PastCampaigns[MktDATA$Gender=="M"]
CI.diffprop(x = PastCampaigns_M, y = PastCampaigns_F,
            success.x = 0, conf.level = 0.99)
            
#  - Using x,by: groups identified by ordered levels of by
CI.diffprop(x = PastCampaigns, by = Gender,
            success.x=0, conf.level = 0.99, 
            data = MktDATA)
#    Since order is F, M, CI is for prop(F) - prop(M)
#    To get the interval for prop(M) - prop(F)
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
CI.diffprop(x = PastCampaigns, by = Gender.R,
            success.x=0, conf.level = 0.99, data = MktDATA)
 
# Proportions of success defined based on 
#  binary or logical vectors; 'success'
#  coded same way for both vectors
#  - Binary variable (success=1): based on x,y
LastCampaign_F&lt;-MktDATA$LastCampaign[MktDATA$Gender=="F"]
LastCampaign_M&lt;-MktDATA$LastCampaign[MktDATA$Gender=="M"]
CI.diffprop(x = LastCampaign_M, y = LastCampaign_F)
#  - Binary variable (success=1): based on x,y
#    see above for recoding of levels of Gender
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
CI.diffprop(x = LastCampaign, by = Gender.R, data = MktDATA)
#  - Logical variable (success=TRUE): based on x,y
Deals_w_child &lt;- MktDATA$Deals.ge50[MktDATA$Children&gt;0]
Deals_no_child &lt;- MktDATA$Deals.ge50[MktDATA$Children==0]
CI.diffprop(x = Deals_w_child, y = Deals_no_child, conf.level = 0.9)

# Proportions defined on 
#  non-binary and non-logical vectors, with 'success'
#  coded differently (only specification x,y is reasonable here)
WouldSuggest_Other&lt;-c(rep("OK",310),rep("KO",650-310))
CI.diffprop(x = WouldSuggest, y = WouldSuggest_Other, 
            success.x = "Yes", success.y = "OK",
            data = MktDATA)

# Proportions based on combined conditions
# - Build logical vector/s indicating whether a condition 
#   is satisfied
IsTop&lt;-MktDATA$AOV&gt;80
IsTop_OK&lt;-IsTop[MktDATA$WouldSuggest == "Yes"]
IsTop_KO&lt;-IsTop[MktDATA$WouldSuggest == "No"]
CI.diffprop(x = IsTop_OK, y = IsTop_KO, conf.level = 0.9)

Deals&lt;-MktDATA$NDeals&gt;=5
Deals_Married &lt;- Deals[MktDATA$Marital_Status=="Married" &amp; 
                         MktDATA$Children==0] 
Deals_Single &lt;- Deals[MktDATA$Marital_Status=="Single"] 
CI.diffprop(x = Deals_Married, y = Deals_Single, conf.level = 0.9)

# Output results           
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
out.ci_diffP&lt;-CI.diffprop(x = PastCampaigns, by = Gender.R,
                          success.x=0, conf.level = 0.99, 
                          data = MktDATA)

# Arguments force.digits and use.scientific
#  An input variable taking very low values
HighAOV &lt;- MktDATA$AOV&gt;150
# - Default: manages possible excess of rounding
CI.diffprop(x = HighAOV[MktDATA$Gender=="M"], 
            y = HighAOV[MktDATA$Gender=="F"])
#  - Force to the exact number of digits (default, 2)
CI.diffprop(x = HighAOV[MktDATA$Gender=="M"], 
            y = HighAOV[MktDATA$Gender=="F"],
            force.digits = TRUE)
#  - Allow scientific notation
CI.diffprop(x = HighAOV[MktDATA$Gender=="M"], 
            y = HighAOV[MktDATA$Gender=="F"],
            use.scientific = TRUE)

</code></pre>

<hr>
<h2 id='CI.mean'>Confidence intervals for the mean</h2><span id='topic+CI.mean'></span>

<h3>Description</h3>

<p><code>CI.mean()</code> builds confidence intervals for the mean of a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI.mean(
  x,
  sigma = NULL,
  conf.level = 0.95,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CI.mean_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the <em>numeric</em>
variable whose mean is of interest. <code>x</code> can be the
name of a vector in the workspace or the name of one of
the columns in the data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_sigma">sigma</code></td>
<td>
<p>An optional numeric value specifying the
population standard deviation. If <code>NULL</code> (default)
the population standard deviation is estimated using the
data.</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_conf.level">conf.level</code></td>
<td>
<p>Numeric value specifying the required
confidence level; default to 0.95.</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>.
If not found in <code>data</code>, <code>x</code> is taken from the
environment from which <code>CI.mean()</code> is called.</p>
</td></tr>
<tr><td><code id="CI.mean_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the confidence interval for the
population mean. If the variance is unknown, the interval is
built using percentiles from
both the normal and the Student's t distribution.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TEST.mean">TEST.mean</a>()</code> to test hypotheses on a population
mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# CI for the mean with KNOWN variance; default options
CI.mean(AOV, sigma = 30, data = MktDATA)

# CI for the mean with UNKNOWN variance;  
# - change digits and confidence level 0.99
CI.mean(AOV, conf.level = 0.99, digits = 3, data = MktDATA)

# Arguments force.digits and use.scientific
#  A variable taking very small values
SmallX&lt;-MktDATA$AOV/5000 
#  - Default: manages possible excess of rounding
CI.mean(SmallX)
#  - Forcing digits to the default values (2)
CI.mean(SmallX, force.digits = TRUE)
#  - Allow scientific notation
CI.mean(SmallX, use.scientific = TRUE)

# Output the table with the requested interval
out.ci_mean&lt;-CI.mean(AOV, data = MktDATA)

</code></pre>

<hr>
<h2 id='CI.prop'>Confidence intervals for the proportion</h2><span id='topic+CI.prop'></span>

<h3>Description</h3>

<p><code>CI.prop()</code> builds confidence intervals for the proportion of
successes in a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI.prop(
  x,
  success = NULL,
  conf.level = 0.95,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CI.prop_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the variable of interest.
<code>x</code> can be the name of a vector
or a factor in the workspace or the name of one of the columns in the
data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_success">success</code></td>
<td>
<p>If <code>x</code> is a factor, a character vector, or a numeric
non-binary vector, <code>success</code> must be used to indicate the category/value
corresponding to success. The argument can be omitted (<code>NULL</code>,
default) if <code>x</code> is a binary numeric vector (takes values 0 or 1 only;
in this case success is assumed to be 1) or a logical vector (in these
cases success is assumed to be <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_conf.level">conf.level</code></td>
<td>
<p>Numeric value specifying the required
confidence level; default to 0.95.</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>.
If not found in <code>data</code>, <code>x</code> is taken from the environment
from which <code>CI.prop()</code> is called.</p>
</td></tr>
<tr><td><code id="CI.prop_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the confidence intervals for
the population proportion of successes.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TEST.prop">TEST.prop</a>()</code> to test hypotheses on the
proportion of successes in a population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Success = one value of a character vector or factor
CI.prop(WouldSuggest, success = "Yes", data = MktDATA)

# - change confidence level and rounding
CI.prop(Education, success = "Post-Grad", 
        conf.level = 0.9, digits = 4, 
        data = MktDATA)

# Success = numeric value
CI.prop(Children, success = 2, data = MktDATA)

# Binary variable ('success' is 1 by default)
CI.prop(LastCampaign, digits = 3, data = MktDATA)

# Logical variable ('success' is TRUE by default)
CI.prop(RespCampaign, conf.level = 0.9, digits = 3, data = MktDATA)

# Success based on combined conditions
# - Build a (logical) vector indicating whether a condition is satisfied
IsTop &lt;- MktDATA$CustClass == "Gold" | MktDATA$CustClass == "Platinum"
CI.prop(IsTop, conf.level = 0.9)
# - A very rare event
HighAOV &lt;- MktDATA$AOV&gt;150
CI.prop(HighAOV, conf.level = 0.9)

# Arguments force.digits, use.scientific
# - Default: manages possible excess of rounding
CI.prop(HighAOV)
# - Forcing digits to the default values (2)
CI.prop(HighAOV, force.digits = TRUE)
# - Allow scientific notation
CI.prop(HighAOV, use.scientific = TRUE)

# Output results
out_ci_prop&lt;-CI.prop(HighAOV)

</code></pre>

<hr>
<h2 id='distr.plot.x'>Analysis of a univariate distribution using plots</h2><span id='topic+distr.plot.x'></span>

<h3>Description</h3>

<p><code>distr.plot.x()</code> generates plots of a univariate distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.plot.x(
  x,
  freq = "counts",
  plot.type,
  ord.freq = "none",
  breaks,
  adj.breaks = TRUE,
  interval = FALSE,
  bw = FALSE,
  color = NULL,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr.plot.x_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the variable whose
distribution has to be analysed. <code>x</code> can be the name of a vector
or a factor in the workspace or the name of one of the columns in the
data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_freq">freq</code></td>
<td>
<p>A single character specifying the frequencies to be
displayed. Allowed options (possibly abbreviated) are <code>"counts"</code>,
<code>"percentages"</code>, <code>"proportions"</code>, <code>"densities"</code>
(for histograms and density plots).</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_plot.type">plot.type</code></td>
<td>
<p>A single character specifying the type of plot to build.
Allowed options are <code>"pie"</code>, <code>"bars"</code>, <code>"spike"</code>,
<code>"histogram"</code>, <code>"density"</code>, <code>"boxplot"</code>, and
<code>"cumulative"</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_ord.freq">ord.freq</code></td>
<td>
<p>A single character vector that can be specified when
<code>plot.type = "pie"</code> or <code>plot.type = "bars"</code>. It indicates
whether the levels of <code>x</code> should be displayed in a standard order
(<code>ord.freq = "none"</code>, the default) or in an increasing
or decreasing order (<code>ord.freq = "increasing"</code> or
<code>ord.freq = "decreasing"</code>).</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_breaks">breaks</code></td>
<td>
<p>Allows to classify a <em>numerical</em> variable <code>x</code> into
intervals. It can be an integer indicating the number of intervals of
equal width used to classify <code>x</code>, or a vector of increasing numeric
values defining the endpoints of intervals (closed on the left and open
on the right; the last interval is closed on the right too). To cover
the entire range of values the maximum and the minimum values should be
included between the first and the last break. It is possible to specify
a set of breaks covering only a portion of the <code>x</code> range.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_adj.breaks">adj.breaks</code></td>
<td>
<p>Logical value indicating whether the endpoints of
intervals of a numerical variable <code>x</code> when classified
into intervals should be displayed avoiding scientific notation;
default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_interval">interval</code></td>
<td>
<p>Logical value indicating whether <code>x</code> is a variable
measured in intervals (<code>TRUE</code>). If the detected intervals are not
consistent (e.g. overlapping intervals, or intervals with upper endpoint
higher than the lower one), the variable is analyzed as it is, even if
results are not necessarily consistent; default to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_bw">bw</code></td>
<td>
<p>Logical value indicating whether plots should be colored
in scale of greys (<code>TRUE</code>) rather than using a standard
palette (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_color">color</code></td>
<td>
<p>Optional string vector allowing to specify colors
to use in the plot rather than a standard palette
(<code>NULL</code>, default).</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers on
axes should be displayed using scientific notation
(<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>.
If not found in <code>data</code>, <code>x</code> is taken from the environment
from which <code>distr.plot.x()</code> is called.</p>
</td></tr>
<tr><td><code id="distr.plot.x_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distr.table.x">distr.table.x</a>()</code> for tabulating a univariate
distribution.
</p>
<p><code><a href="#topic+distr.table.xy">distr.table.xy</a>()</code> for tabulating a bivariate
distribution.
</p>
<p><code><a href="#topic+distr.plot.xy">distr.plot.xy</a>()</code> for plotting a bivariate
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Pie charts 
# - A character variable: grey scale
distr.plot.x(x = LikeMost, plot.type = "pie", bw = TRUE, data = MktDATA)
# - A discrete numeric variable: user-defined palette
distr.plot.x(x = Children, plot.type = "pie", 
             color=c("red","gold","green","forestgreen"),
             data = MktDATA)

# Bar charts 
# - A factor: standard order of levels 
distr.plot.x(x = Education, plot.type = "bars", 
             freq = "percentage", data = MktDATA)
# - A factor: levels arranged by decreasing percentage 
distr.plot.x(x = Education, plot.type = "bars", 
             freq = "perc", ord.freq = "dec", data = MktDATA)
# - A discrete variable (note: distance between values
#   not taken into account)
distr.plot.x(x = NPickUp_Purch, plot.type = "bars",
             freq = "percentage", data = MktDATA)

# Spike plots 
# - A discrete variable
distr.plot.x(x = NPickUp_Purch, plot.type = "spike", 
             freq = "percent", data = MktDATA)
# - A factor (levels placed at the same distance)
distr.plot.x(x = Education, plot.type = "spike", 
             freq = "prop",data = MktDATA)
# - A variable measured in classes (levels placed at the 
#   same distance)
distr.plot.x(x = Income.S, interval = TRUE,
             plot.type = "spike", 
             freq = "prop",data = MktDATA)
# - A numeric variable classified into intervals
#   (levels placed at the same distance)
distr.plot.x(x = AOV, breaks = 5, plot.type = "spike", 
             data = MktDATA)

# Cumulative distribution plots
# - A discrete variable
distr.plot.x(x = Children, plot.type = "cum", data = MktDATA)
# - A continuous numerical variable 
distr.plot.x(x = AOV, plot.type = "cum", 
             freq = "perc", data = MktDATA)
# - A numeric variable classified into intervals
distr.plot.x(AOV, plot.type = "cum", 
             breaks = c(0,20,40,60,80,100,180), data = MktDATA)
# - A variable measured in classes
distr.plot.x(Income, plot.type = "cum", interval = TRUE, 
             freq = "percent", data = MktDATA)
# - A factor
distr.plot.x(x = Education, plot.type = "cum", 
             freq = "prop",data = MktDATA)

# Histograms 
# - A continuous numerical variable: no breaks provided
#    default classes built by R
distr.plot.x(x = AOV, plot.type = "histogram", data = MktDATA)
# - A continuous numerical variable: equal width intervals
distr.plot.x(x = AOV, plot.type = "histogram", 
             breaks = 10, data = MktDATA)
# - A continuous numerical variable: specified breaks
distr.plot.x(AOV, plot.type = "histogram", 
             breaks = c(0,20,40,60,80,100,180), 
             data = MktDATA)
# - A variable measured in classes
distr.plot.x(Income, plot.type = "histogram", 
             interval = TRUE, data = MktDATA)

# Density plots 
# - A  numerical variable
distr.plot.x(x = AOV, plot.type = "density", data = MktDATA)
# - A  numerical variable: breaks are ignored
distr.plot.x(AOV, plot.type = "density", 
             breaks = c(0,20,40,60,80,100,180), 
             data = MktDATA)
# - A variable measured in classes
distr.plot.x(Income, plot.type = "density", 
             interval = TRUE, data = MktDATA)

# Boxplots (only for numerical unclassified variables)
# - A  numerical variable
distr.plot.x(x = TotVal, plot.type = "boxplot", data = MktDATA)
# - A  numerical variable: with specified breaks
#   the plot is not built
# distr.plot.x(AOV, plot.type = "boxplot", 
#              breaks = c(0,20,40,60,80,100,180), 
#              data = MktDATA)

# Arguments adj.breaks, use.scientific
#  A variable with a very wide range (very small densities)
LargeX&lt;-MktDATA$AOV*5000000 
#  - Default formatting for intervals' endpoints
distr.plot.x(LargeX, breaks = 5, plot.type = "spike")
#  - Scientific notation for intervals' endpoints
distr.plot.x(LargeX, breaks = 5,plot.type = "spike",
             adj.breaks = FALSE)
#  - Default formatting for axes
distr.plot.x(LargeX, breaks = 5,plot.type = "histogram",
             freq = "densities")
#  - Scientific notation for axes
distr.plot.x(LargeX, breaks = 5,plot.type = "histogram",
             freq = "densities",use.scientific = TRUE)

</code></pre>

<hr>
<h2 id='distr.plot.xy'>Analysis of a bivariate distribution using plots</h2><span id='topic+distr.plot.xy'></span>

<h3>Description</h3>

<p><code>distr.plot.xy()</code> generates plots of a bivariate distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.plot.xy(
  x,
  y,
  plot.type,
  bar.type = "stacked",
  freq = "counts",
  freq.type = "joint",
  breaks.x,
  breaks.y,
  interval.x = FALSE,
  interval.y = FALSE,
  bw = FALSE,
  color = NULL,
  var.c,
  breaks.c,
  interval.c = FALSE,
  adj.breaks = TRUE,
  fitline = FALSE,
  legend = TRUE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr.plot.xy_+3A_x">x</code>, <code id="distr.plot.xy_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying the variables whose
distribution has to be graphically displayed. <code>x</code> and
<code>y</code> can be the name of a vector or a factor in the
workspace or the name of one of the columns in the data frame
specified in the <code>data</code> argument.
Note that in the plot <code>x</code> is reported on the
<em>horizontal</em> axis while <code>y</code> is reported on
the <em>vertical</em> axis.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_plot.type">plot.type</code></td>
<td>
<p>A single character specifying the type of plot to build.
Allowed options are <code>"bars"</code>, <code>"scatter"</code>, and
<code>"boxplot"</code>. If both <code>x</code> and <code>y</code> are character vectors
or factors and <code>bar.type = "scatter"</code> a bubble plot is
built, with dots having a size proportional to the joint frequency of
each pair of observed values. If <code>bar.type = "boxplot"</code>, at least
one input variable must be numeric; when both the variables are numeric
the conditional distributions of <code>y|x</code> are displayed, unless
otherwise specified using <code>freq.type="x|y"</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_bar.type">bar.type</code></td>
<td>
<p>A single character indicating whether in a bar plot
stacked (<code>bar.type = "stacked"</code>, default) or side-by-side
(<code>bar.type = "beside"</code>) bars should be displayed.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_freq">freq</code></td>
<td>
<p>A single character specifying the frequencies
to be displayed when a bar plot is requested (<code>plot.type="bars"</code>).
Allowed options (possibly abbreviated) are <code>"counts"</code>,
<code>"percentages"</code> and <code>"proportions"</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_freq.type">freq.type</code></td>
<td>
<p>A single character specifying the type of
frequencies to be displayed when a bar plot is requested
(<code>plot.type="bars"</code>). Allowed options are <code>joint</code> (default)
for joint frequencies, <code>x|y</code> for the distributions
of <code>x</code> conditioned to <code>y</code>, and <code>y|x</code> for
the distributions of <code>y</code> conditioned to <code>x</code>. The option
<code>x|y</code> can also be used when <code>plot.type="boxplot"</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_breaks.x">breaks.x</code>, <code id="distr.plot.xy_+3A_breaks.y">breaks.y</code></td>
<td>
<p>Allow to classify the variables <code>x</code>
and/or <code>y</code>, if <em>numerical</em>, into intervals.
They can be integers indicating the number of intervals of
equal width used to classify <code>x</code> and/or <code>y</code>, or
vectors of increasing numeric values defining the endpoints of
the intervals (closed on the left and open
on the right; the last interval is closed on the right too).
To cover the entire range of values taken by one variable,
the maximum and the minimum values should be included between
the first and the last break.
It is possible to specify a set of breaks covering only a portion
of the variable's range.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_interval.x">interval.x</code>, <code id="distr.plot.xy_+3A_interval.y">interval.y</code></td>
<td>
<p>Logical values indicating whether
<code>x</code> and/or <code>y</code> are variables measured in classes
(<code>TRUE</code>). If the detected intervals are not
consistent (e.g. overlapping intervals, or intervals with
upper endpoint higher than the lower one), the variable is
analyzed as it is, even if results are not necessarily
consistent; default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_bw">bw</code></td>
<td>
<p>Logical value indicating whether plots should be colored
in scale of greys (<code>TRUE</code>) rather than using a standard
palette (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_color">color</code></td>
<td>
<p>Optional string vector allowing to specify colors
to use in the plot rather than a standard palette
(<code>NULL</code>, default).</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_var.c">var.c</code></td>
<td>
<p>An optional unquoted string identifying one variable
used to color points in a scatter plot (<code>plot.type="scatter"</code>),
that can be defined same way as <code>x</code>. This is allowed only when
at least one of the input variables <code>x</code> and <code>y</code> is numeric.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_breaks.c">breaks.c</code></td>
<td>
<p>Allows to classify the variable <code>var.c</code>, if
<em>numerical</em>, into intervals. It can be defined as <code>breaks.x</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_interval.c">interval.c</code></td>
<td>
<p>Logical value indicating whether <code>var.c</code> is a variable
measured in intervals (<code>TRUE</code>) or not, as described for
<code>interval.x</code>; default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_adj.breaks">adj.breaks</code></td>
<td>
<p>Logical value indicating whether the endpoints of
intervals of a numerical variable (<code>x</code>, or <code>y</code>,
or <code>var.c</code>) when classified into intervals should be
displayed avoiding scientific notation; default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_fitline">fitline</code></td>
<td>
<p>Logical value indicating whether the line of best fit (also
called trend line or regression line) should be added to a scatter plot
(<code>fitline = TRUE</code>) or not (<code>fitline = FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_legend">legend</code></td>
<td>
<p>Logical value indicating whether a legend should be displayed
in the plot (<code>legend = TRUE</code>; default) or not (<code>legend = FALSE</code>).</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers on
axes should be displayed using scientific notation
(<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or <code>y</code>
and/or <code>var.c</code> (the variable used to color points in scatter plots).
If not found in <code>data</code>, the variables are taken from the environment
from which <code>distr.plot.xy()</code> is called.</p>
</td></tr>
<tr><td><code id="distr.plot.xy_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distr.table.xy">distr.table.xy</a>()</code> for tabulating a bivariate
distribution.
</p>
<p><code><a href="#topic+distr.table.x">distr.table.x</a>()</code> for tabulating a univariate
distribution.
</p>
<p><code><a href="#topic+distr.plot.x">distr.plot.x</a>()</code> for plotting a univariate
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Bivariate bar plots
# - Two discrete variables (factor or vector with few levels)
#   Joint counts
distr.plot.xy(CustClass, Children,plot.type = "bars", 
              freq = "Counts", freq.type = "joint",
              data = MktDATA)
# - Two discrete variables (factor or vector with few levels)
#   Joint percentages, side-by-side bars
#   User-defined colors
distr.plot.xy(Children,CustClass, plot.type = "bars", 
              bar.type = "beside",
              freq = "percent", freq.type = "joint",
              color = c("red","gold","green","forestgreen"),
              data = MktDATA)
# - One numeric variable classified into intervals
#   and one variable measured in classes
#   Conditional percentages of x|y 
distr.plot.xy(TotPurch, Income, plot.type = "bars", 
              freq = "percent",freq.type = "x|y",
              breaks.x = c(0,5,10,15,20,35),
              interval.y = TRUE, data = MktDATA)
#   Conditional percentages of y|x 
distr.plot.xy(TotPurch, Income, plot.type = "bars", 
              freq = "percent",freq.type = "y|x",
              breaks.x = c(0,5,10,15,20,35),
              interval.y = TRUE, data = MktDATA)

# Side-by-side boxplots
# - A continuous variable conditioned to a factor, 
#   a character, or a classified variable
#   The distributions of the numeric variable conditioned
#   to the factor (or character) are displayed
distr.plot.xy(x = AOV, y = Education, plot.type = "boxplot",
              data = MktDATA)
distr.plot.xy(x = Income.S, y = AOV, plot.type = "boxplot",
              interval.x = TRUE, data = MktDATA)
distr.plot.xy(x = Baseline, y = TotPurch, plot.type = "boxplot",
              breaks.y = c(0,5,10,15,20,35),
              data = MktDATA)
# - Two numerical variables. By default distributions 
#   of y|x are displayed unless differently 
#   specified in freq.type
distr.plot.xy(x = NPickUp_Purch, y = NWeb_Purch,
              plot.type = "boxplot", data = MktDATA)
distr.plot.xy(x = NPickUp_Purch, y = NWeb_Purch,
              plot.type = "boxplot",freq.type = "x|y",
              data = MktDATA)

# Scatter plots
# - Two numerical variables: default options
distr.plot.xy(Baseline, TotVal, plot.type = "scatter", 
              fitline = TRUE, data = MktDATA)
# - Two numerical variables: colors based on discrete var 
distr.plot.xy(Baseline, TotVal, plot.type = "scatter", 
              var.c = Marital_Status,  
              fitline = TRUE, data = MktDATA)
distr.plot.xy(Baseline, TotVal, plot.type = "scatter", 
              var.c = Income, interval.c = TRUE, 
              fitline = TRUE, data = MktDATA)
distr.plot.xy(Baseline, TotVal, plot.type = "scatter", 
              var.c = TotPurch, breaks.c = 10, 
              fitline = TRUE, data = MktDATA)
# - Two numerical variables: colors based 
#   on a continuous numerical variable
distr.plot.xy(Baseline, TotVal, plot.type = "scatter", 
              var.c = AOV, fitline = TRUE, data = MktDATA)

# - One numerical variable and one factor or character 
distr.plot.xy(Baseline, Marital_Status, plot.type = "scatter", 
              fitline = TRUE, data = MktDATA)
distr.plot.xy(Income.S, Baseline, plot.type = "scatter", 
              interval.x = TRUE,
              fitline = TRUE, data = MktDATA)
#   color based on a third variable
distr.plot.xy(TotPurch, TotVal, plot.type = "scatter", 
              breaks.x = c(0,5,10,15,20,35),
              var.c = AOV,
              fitline = TRUE, data = MktDATA)

# - Two factors or character vectors: bubble plots
distr.plot.xy(Education, LikeMost, plot.type = "scatter", 
              data = MktDATA)
# - Two classified variables (i.e. not properly numerical): 
#   bubble plots, changed color
distr.plot.xy(Income.S, TotPurch, plot.type = "scatter",
              interval.x = TRUE,
              breaks.y = c(0,5,10,15,20,35),
              color = "orchid", data = MktDATA)

# Arguments adj.breaks and use.scientific 
#  Variable with very wide ranges
LargeC&lt;-MktDATA$AOV*5000000 
LargeX&lt;-MktDATA$Baseline*1000000 
LargeY&lt;-MktDATA$TotVal*1000000
#  - Default: no scientific notation
distr.plot.xy(LargeX, LargeY, plot.type = "scatter", 
              var.c = LargeC, data = MktDATA)
distr.plot.xy(LargeX, LargeY, plot.type = "scatter", 
              breaks.x = 10, var.c = LargeC, 
              data = MktDATA)
#  - Scientific notation for axes 
distr.plot.xy(LargeX, LargeY, plot.type = "scatter", 
              breaks.x = 10, var.c = LargeC, 
              use.scientific = TRUE,
              data = MktDATA)
#  - Scientific notation for intervals' endpoints
distr.plot.xy(LargeX, LargeY, plot.type = "scatter", 
              breaks.x = 10, var.c = LargeC, 
              adj.breaks = FALSE,
              data = MktDATA)
#  - Scientific notation for intervals endpoints and axes
distr.plot.xy(LargeX, LargeY, plot.type = "scatter", 
              var.c = LargeC, fitline = TRUE, 
              adj.breaks = FALSE, use.scientific = TRUE,
              data = MktDATA)
distr.plot.xy(LargeX, LargeY, plot.type = "scatter", 
              breaks.x = 10, var.c = LargeC, 
              adj.breaks = FALSE, use.scientific = TRUE,
              data = MktDATA)

</code></pre>

<hr>
<h2 id='distr.summary.x'>Summary statistics for a single variable</h2><span id='topic+distr.summary.x'></span>

<h3>Description</h3>

<p><code>distr.summary.x()</code> computes summary statistics of a vector or a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.summary.x(
  x,
  stats = c("summary"),
  by1,
  by2,
  breaks.by1,
  interval.by1 = FALSE,
  breaks.by2,
  interval.by2 = FALSE,
  adj.breaks = TRUE,
  digits = 2,
  f.digits = 4,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr.summary.x_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the variable whose
distribution has to be summarized. <code>x</code> can be the name of a vector
or a factor in the workspace or the name of one of the columns in the
data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_stats">stats</code></td>
<td>
<p>A character vector specifying the summary statistics
to compute (more summaries can be specified).
Specific types of summaries can be requested with the following
options:
</p>

<ul>
<li> <p><code>"summary"</code>: min, q1, median, mean, q3, max, sd, var;
</p>
</li>
<li> <p><code>"central"</code>: central tendency measures;
</p>
</li>
<li> <p><code>"dispersion"</code>: measures of dispersion;
</p>
</li>
<li> <p><code>"fivenumbers"</code>: five-number summary;
</p>
</li>
<li> <p><code>"quartiles"</code>, <code>"quintiles"</code>, <code>"deciles"</code>,
<code>"percentiles"</code>: set of quantiles.
</p>
</li></ul>

<p>It is also possible to request the following statistics:
<code>"q1"</code>, <code>"q2"</code>, <code>"q3"</code>, <code>"mean"</code>, <code>"median"</code>,
<code>"mode"</code> (which returns the mode, the number of modes and the
proportion of cases with modal value respectively), <code>"min"</code>,
<code>"max"</code>, <code>"sd"</code>, <code>"var"</code>, <code>"cv"</code> (coefficient of
variation), <code>"range"</code>, <code>"IQrange"</code> (interquartile range),
and <code>"p1"</code>, <code>"p2"</code>,..., <code>"p100"</code> (i.e. specific
percentiles).</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_by1">by1</code>, <code id="distr.summary.x_+3A_by2">by2</code></td>
<td>
<p>Unquoted strings identifying optional variables
(typically taking few values/levels) used to build conditional
summaries, that can be defined same way as <code>x</code>.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_breaks.by1">breaks.by1</code>, <code id="distr.summary.x_+3A_breaks.by2">breaks.by2</code></td>
<td>
<p>Allow classifying the variables <code>by1</code>
and/or <code>by2</code>, if <em>numerical</em>, into intervals.
They can be integers indicating the number of intervals of
equal width used to classify <code>by1</code> and/or <code>by2</code>,
or vectors of increasing numeric values defining the endpoints
of intervals (closed on the left and open on the right; the last
interval is closed on the right too). To cover the entire range
of values the maximum and the minimum values should be
included between the first and the last break. It is possible to
specify a set of breaks covering only a portion of the range
of <code>by1</code> and/or <code>by2</code>.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_interval.by1">interval.by1</code>, <code id="distr.summary.x_+3A_interval.by2">interval.by2</code></td>
<td>
<p>Logical values indicating
whether <code>by1</code> and/or <code>by2</code> are variables
measured in classes (<code>TRUE</code>). If the intervals for
one variable are not consistent (e.g. overlapping intervals,
or intervals with upper endpoint higher than the lower one),
the variable is analysed as it is, even if
results are not necessarily consistent; default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_adj.breaks">adj.breaks</code></td>
<td>
<p>Logical value indicating whether the endpoints of
intervals of the numerical variables <code>by1</code> or <code>by2</code>,
when classified into intervals, should be displayed avoiding
scientific notation; default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_digits">digits</code>, <code id="distr.summary.x_+3A_f.digits">f.digits</code></td>
<td>
<p>Integer values specifying the number of
decimals used to round respectively summary statistics
(default: <code>digits=4</code>) and proportions
percentages (default: <code>f.digits=2</code>). If the chosen rounding
formats some non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether the
requested summaries should be forcedly rounded to the number of decimals
specified in <code>digits</code> and <code>f.digits</code> even if non-zero
values are rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>
and/or the variables specifying the layers, <code>by1</code> and <code>by2</code>.
If not found in <code>data</code>, the variables are taken from
the environment from which <code>distr.summary.x()</code> is called.</p>
</td></tr>
<tr><td><code id="distr.summary.x_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements are tables
(converted  to dataframes) with the requested summaries, possibly
conditioned to <code>by1</code> and/or <code>by2</code>. The values taken
by the conditioning variables are arranged in standard
order (logical, alphabetical or numerical order for vectors,
order of levels for factors, ordered intervals for classified
variables or for variables measured in classes).
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summaries.plot.x">summaries.plot.x</a>()</code> to graphically display
conditioned tendency summaries of a univariate distribution.
</p>
<p><code><a href="#topic+distr.table.x">distr.table.x</a>()</code> for tabulating a univariate
distribution.
</p>
<p><code><a href="#topic+distr.plot.x">distr.plot.x</a>()</code> for plotting a univariate
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Marginal summaries
# - Numerical variable: Default summaries
distr.summary.x(x = AOV, data = MktDATA)
# - Numerical variable: More summaries
distr.summary.x(x = AOV, 
                stats = c("central","dispersion","fivenum"),
                data = MktDATA)
distr.summary.x(x = AOV, stats = c("mode","mean","sd","cv","fivenum"),
                data = MktDATA)
# - Character or factor (only proper statistics calculated)
distr.summary.x(x = LikeMost, stats = c("mode","mean","sd","cv","fivenum"),
                data = MktDATA)
distr.summary.x(x = Education, stats = c("mode","mean","sd","cv","fivenum"),
                data = MktDATA)

# Measures conditioned to a single variable
# - Numerical variable by a character vector
distr.summary.x(x = TotVal, 
                stats = c("p5","p10","p25","p50","p75","p90","p95"),
                by1 = Gender, digits = 1, data = MktDATA)
# - Numerical variable by a numerical variable
#   classified into intervals
distr.summary.x(x = TotVal, 
                stats = c("central","dispersion"),
                by1 = AOV, breaks.by1 = 5,
                digits = 1, data = MktDATA)
# - Numerical variable by a variable measured in classes
distr.summary.x(x = TotVal, 
                stats = c("central","dispersion"),
                by1 = Income.S, 
                interval.by1 = TRUE,
                digits = 1, data = MktDATA)

# Measures conditioned to two variables
distr.summary.x(x = TotVal, stats = "fivenumbers", 
                by1 = Gender, by2 = Kids, data = MktDATA)
distr.summary.x(x = TotVal, stats = "fivenumbers", 
                by1 = Income.S, by2 = Gender,
                interval.by1 = TRUE, data = MktDATA)
distr.summary.x(x = TotVal, stats = "fivenumbers",
                by1 = Gender, by2 = AOV,
                breaks.by2 = 5, data = MktDATA)

# Arguments adj.breaks and use.scientific
#  Variables with a very wide range
LargeX&lt;-MktDATA$TotVal*1000000
LargeBY&lt;-MktDATA$AOV*5000000 
#  - Default: no scientific notation
distr.summary.x(LargeX, by1=LargeBY, breaks.by1 = 5, 
                data = MktDATA)
#  - Scientific notation for summaries 
distr.summary.x(LargeX, by1=LargeBY, breaks.by1 = 5, 
                use.scientific = TRUE, data = MktDATA)
#  - Scientific notation for intervals endpoints
distr.summary.x(LargeX, by1=LargeBY, breaks.by1 = 5, 
                adj.breaks = FALSE, data = MktDATA)
#  - Scientific notation for intervals endpoints and summaries
distr.summary.x(LargeX, by1=LargeBY, breaks.by1 = 5, 
                adj.breaks = FALSE, use.scientific = TRUE,
                data = MktDATA)

# Output the list with the requested summaries
Out_TotVal&lt;-distr.summary.x(x = TotVal, 
                            by1 = Income.S, by2 = Gender,
                            interval.by1 = TRUE,
                            stats = c("central","fivenum","dispersion"),
                            data = MktDATA)

</code></pre>

<hr>
<h2 id='distr.table.x'>Analysis of a univariate distribution using frequency tables</h2><span id='topic+distr.table.x'></span>

<h3>Description</h3>

<p><code>distr.table.x()</code> computes the frequency table of a vector or a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.table.x(
  x,
  freq = c("counts", "proportions"),
  total = TRUE,
  breaks,
  adj.breaks = TRUE,
  interval = FALSE,
  f.digits = 2,
  p.digits = 0,
  d.digits = 5,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr.table.x_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the variable whose
distribution has to be analysed. <code>x</code> can be the name of a vector
or a factor in the workspace or the name of one of the columns in the
data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_freq">freq</code></td>
<td>
<p>A character vector specifying the set of frequencies to be
displayed (more options are allowed). Allowed options (possibly abbreviated)
are <code>"counts"</code>, <code>"percentages"</code>, <code>"proportions"</code>,
<code>"densities"</code> (only for variables classified into intervals
or measured in classes), and <code>"cumulative"</code>.
If no frequency is specified, <code>"counts"</code>
and <code>"proportions"</code> are displayed by default.
If only <code>"cumulative"</code> is specified, counts and proportions
are displayed too, with their respective cumulative frequencies.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_total">total</code></td>
<td>
<p>Logical value indicating whether the sum of the requested
frequencies should be added to the table; default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_breaks">breaks</code></td>
<td>
<p>Allows to classify a <em>numerical</em> variable <code>x</code> into
intervals. It can be an integer indicating the number of intervals of
equal width used to classify <code>x</code>, or a vector of increasing numeric
values defining the endpoints of intervals (closed on the left and open
on the right; the last interval is closed on the right too). To cover
the entire range of values the maximum and the minimum values should be
included between the first and the last break. It is possible to specify
a set of breaks covering only a portion of the <code>x</code> range.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_adj.breaks">adj.breaks</code></td>
<td>
<p>Logical value indicating whether the endpoints of
intervals of a numerical variable <code>x</code> when classified
into intervals should be displayed avoiding scientific notation;
default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_interval">interval</code></td>
<td>
<p>Logical value indicating whether <code>x</code> is a variable
measured in intervals (<code>TRUE</code>). If the detected intervals are not
consistent (e.g. overlapping intervals, or intervals with upper endpoint
higher than the lower one), the variable is tabulated as it is, even if
results are not necessarily consistent; default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_f.digits">f.digits</code>, <code id="distr.table.x_+3A_p.digits">p.digits</code>, <code id="distr.table.x_+3A_d.digits">d.digits</code></td>
<td>
<p>Integer values specifying the number of
decimals used to round respectively proportions (default: <code>f.digits=2</code>),
percentages (default: <code>p.digits=0</code>), and densities
(default: <code>d.digits=5</code>). If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether frequencies and
densities should be forcedly rounded to the number of decimals specified in
<code>f.digits</code>, <code>p.digits</code>, and <code>d.digits</code> even if non-zero
values are rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables (typically densities) should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>.
If not found in <code>data</code>, <code>x</code> is taken from the environment
from which <code>distr.table.x()</code> is called.</p>
</td></tr>
<tr><td><code id="distr.table.x_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table (converted to dataframe) listing the
values taken by the variable, arranged in standard
order (logical, alphabetical or numerical order for vectors,
order of levels for factors, ordered intervals for classified
variables or for variables measured in classes), and the requested set
of frequencies.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distr.plot.x">distr.plot.x</a>()</code> for plotting a univariate
distribution.
</p>
<p><code><a href="#topic+distr.table.xy">distr.table.xy</a>()</code> for tabulating a bivariate
distribution.
</p>
<p><code><a href="#topic+distr.plot.xy">distr.plot.xy</a>()</code> for plotting a bivariate
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Character vectors, factors, and discrete numeric vectors
distr.table.x(Education, data = MktDATA)

distr.table.x(Children, freq = c("count","prop","cum"),
              data = MktDATA)

# Numerical variable classified into intervals
# - Classes of equal width
distr.table.x(AOV, breaks = 6, freq = c("Count","Prop","Perc","Cum"),
              p.digits = 2, data = MktDATA)
# - Classes with specified endpoints
distr.table.x(AOV, breaks = c(0,20,30,50,100,180),
              freq = c("Count","Perc","Cum","Densities"), 
              p.digits = 2, data = MktDATA)
# Numerical variable measured in classes
# - Variable measured in classes
distr.table.x(Income, freq = c("count","prop","cum","dens"),
              interval = TRUE, data = MktDATA)
# - An example of non-consistent intervals. 
#   Densities are not calculated
x.inconsistent &lt;- c(rep("0;10",30),rep("10;20",25),rep("25;8",25),
                    rep("15;31",15),rep("20;45",16),rep("30;40",18))
distr.table.x(x.inconsistent, freq = c("count","prop","cum","dens"),
              interval = TRUE)

# Arguments adj.breaks, use.scientific, and force.digits
#  A variable with a very wide range (very small densities)
LargeX &lt;- MktDATA$AOV*5000000 
# - Default: manages possible excess of rounding
distr.table.x(LargeX, breaks = 5, 
              freq = c("count","percent","densities"))
# - Forcing digits to the default values 
distr.table.x(LargeX, breaks = 5,
              freq=c("count","percent","dens"),
              force.digits = TRUE)
#  - Scientific notation for frequencies/densities 
distr.table.x(LargeX, breaks = 5,
              freq = c("count","percent","dens"),
              use.scientific = TRUE)
#  - Scientific notation both for intervals endpoints 
#    and for frequencies/densities
distr.table.x(LargeX, breaks = 5, adj.breaks = FALSE,
              freq = c("count","percent","dens"),
              use.scientific = TRUE)

# Output a dataframe with the table
table.AOV&lt;-distr.table.x(AOV, breaks = c(0,20,30,50,100,180),
                         freq = c("Count","Perc","Cum","Dens"), 
                         data = MktDATA)
                         
</code></pre>

<hr>
<h2 id='distr.table.xy'>Analysis of a bivariate distribution using cross-tables</h2><span id='topic+distr.table.xy'></span>

<h3>Description</h3>

<p><code>distr.table.xy()</code> displays tables of joint or conditional
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.table.xy(
  x,
  y,
  freq = "counts",
  freq.type = "joint",
  total = TRUE,
  breaks.x,
  breaks.y,
  adj.breaks = TRUE,
  interval.x = FALSE,
  interval.y = FALSE,
  f.digits = 2,
  p.digits = 0,
  force.digits = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distr.table.xy_+3A_x">x</code>, <code id="distr.table.xy_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying the variables whose joint
distribution has to be analysed. <code>x</code> and <code>y</code> can be the
name of a vector or a factor in the workspace or the name of one of
the columns in the data frame specified in the <code>data</code> argument.
Note that in the table <code>x</code> is displayed on the <em>rows</em> and
<code>y</code> on the <em>columns</em>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_freq">freq</code></td>
<td>
<p>A character vector specifying the set of frequencies
to be displayed (more options are allowed). Allowed options
(possibly abbreviated) are <code>"counts"</code>,
<code>"percentages"</code> and <code>"proportions"</code>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_freq.type">freq.type</code></td>
<td>
<p>A character vector specifying the types of
frequencies to be displayed (more types are allowed).
Allowed options are <code>joint</code> (default)
for joint frequencies, <code>x|y</code> (or <code>column</code>) for the distributions
of <code>x</code> conditioned to <code>y</code>, and <code>y|x</code> (or <code>row</code>) for
the distributions of <code>y</code> conditioned to <code>x</code>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_total">total</code></td>
<td>
<p>Logical value indicating whether the sum of the requested
frequencies should be added to the table; default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_breaks.x">breaks.x</code>, <code id="distr.table.xy_+3A_breaks.y">breaks.y</code></td>
<td>
<p>Allow to classify the variables <code>x</code>
and/or <code>y</code>, if <em>numerical</em>, into intervals.
They can be integers indicating the number of intervals of
equal width used to classify <code>x</code> and/or <code>y</code>, or
vectors of increasing numeric values defining the endpoints of
the intervals (closed on the left and open
on the right; the last interval is closed on the right too).
To cover the entire range of values taken by one variable,
the maximum and the minimum values should be included between
the first and the last break.
It is possible to specify a set of breaks covering only a portion
of the variable's range.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_adj.breaks">adj.breaks</code></td>
<td>
<p>Logical value indicating whether the endpoints of
intervals of a numerical variable (<code>x</code> or <code>y</code>)
when classified into intervals should be displayed avoiding
scientific notation; default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_interval.x">interval.x</code>, <code id="distr.table.xy_+3A_interval.y">interval.y</code></td>
<td>
<p>Logical values indicating whether
<code>x</code> and/or <code>y</code> are variables measured in classes
(<code>TRUE</code>). If the detected intervals are not
consistent (e.g. overlapping intervals, or intervals with
upper endpoint higher than the lower one), the variable is
tabulated as it is, even if results are not necessarily
consistent; default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_f.digits">f.digits</code>, <code id="distr.table.xy_+3A_p.digits">p.digits</code></td>
<td>
<p>Integer values specifying the number of
decimals used to round respectively proportions
(default: <code>f.digits=2</code>) and percentages (default: <code>p.digits=0</code>).
If the chosen rounding
formats some non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether proportions and
percentages should be forcedly rounded to the number of decimals specified in
<code>f.digits</code> and <code>p.digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or <code>y</code>.
If not found in <code>data</code>, the variables are taken from the environment
from which <code>distr.table.xy()</code> is called.</p>
</td></tr>
<tr><td><code id="distr.table.xy_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements are the requested tables
(converted  to dataframes) listing the values taken
by the two variables arranged in standard
order (logical, alphabetical or numerical order for vectors,
order of levels for factors, ordered intervals for classified
variables or for variables measured in classes)
and the specified joint or conditional types of frequencies.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distr.plot.xy">distr.plot.xy</a>()</code> for plotting a bivariate
distribution.
</p>
<p><code><a href="#topic+distr.table.x">distr.table.x</a>()</code> for tabulating a univariate
distribution.
</p>
<p><code><a href="#topic+distr.plot.x">distr.plot.x</a>()</code> for plotting a univariate
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Character vectors, factors, and discrete numeric vectors
# - Default: joint counts
distr.table.xy(LikeMost, Children, data = MktDATA) 

# - Joint and conditional distribution of x|y
#   counts and proportions, no totals
distr.table.xy(LikeMost, Education, freq = c("counts","Prop"), 
               freq.type = c("joint","x|y"), total = FALSE,
               data = MktDATA)
# - Joint and conditional row and column distributions (%) 
distr.table.xy(CustClass, Children, freq = "Percentages", 
               freq.type = c("joint","row","column"),
               data = MktDATA)

# Numerical variables classified or measured in classes
# - A numerical variable classified into intervals 
#   and a factor
distr.table.xy(CustClass, TotPurch, 
               breaks.y = c(0,5,10,15,20,35),
               freq = c("Counts","Prop"), freq.type = "y|x", 
               data = MktDATA)

# - Two numerical variables, one measured in classes
#   and the other classified into intervals 
distr.table.xy(Income.S, TotPurch, interval.x = TRUE,
               breaks.y = c(0,5,10,15,20,35),
               freq = c("Counts","Prop"), 
               freq.type = c("row","col"), data = MktDATA)

# Argument force.digits
# - Default: manages possible excess of rounding
distr.table.xy(CustClass, Children, freq = "Percentages", 
               freq.type = c("x|y"),data = MktDATA)
# - Force to the required rounding
distr.table.xy(CustClass, Children, freq = "Percentages", 
               freq.type = c("x|y"), 
               force.digits = TRUE, data = MktDATA)

# Output the list with the requested tables
tables.xy&lt;-distr.table.xy(Income.S, TotPurch, 
                          interval.x = TRUE,
                          breaks.y = c(0,5,10,15,20,35),
                          freq = c("Counts","Prop"), 
                          freq.type = c("joint","row","col"), 
                          data = MktDATA)

</code></pre>

<hr>
<h2 id='LM.output'>Extract Model Residuals and other Regression Diagnostics</h2><span id='topic+LM.output'></span>

<h3>Description</h3>

<p><code>LM.output()</code>  Provides fitted values, residuals and other basic
quantities used to check the quality of regression fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LM.output(object, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LM.output_+3A_object">object</code></td>
<td>
<p>An object returned by function lm.</p>
</td></tr>
<tr><td><code id="LM.output_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the data
frame possibly specified in the call of function lm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the variables in the model
and the model's fitted values, residuals
and influence statistics, merged with the dataframe
specified in the call of function lm, or with the
dataframe possibly specified in <code>data</code>
(if it is consistent with the model's output)
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Model and output based on a given dataframe
mod1 &lt;- lm(TotVal ~ Baseline + Kids + Age, data = MktDATA)
# Equivalent calls (since data is specified in lm() 
mod1_out &lt;- LM.output(mod1, data = MktDATA)
dim(mod1_out)
mod1_out &lt;- LM.output(mod1)
dim(mod1_out) # same as above

# Model based on a dataframe's columns
mod2 &lt;- lm(MktDATA$TotVal ~ MktDATA$Baseline + 
           MktDATA$Kids + MktDATA$Age)
mod2_out &lt;- LM.output(mod2)
# note: colnames in mod2_out
colnames(mod2_out)
# note that the dataframe in 'data' is not considered
# as compatible, because the names of columns differ
mod2_out &lt;- LM.output(mod2, data = MktDATA)

</code></pre>

<hr>
<h2 id='MktDATA'>Data: MktDATA</h2><span id='topic+MktDATA'></span>

<h3>Description</h3>

<p>This dataset is a modification of the original <code><a href="#topic+MktDATA.Orig">MktDATA.Orig</a></code>
dataset and it is provided for user convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MktDATA)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2224 observations and 26 variables.
</p>

<hr>
<h2 id='MktDATA.Orig'>Data: MktDATA.Orig</h2><span id='topic+MktDATA.Orig'></span>

<h3>Description</h3>

<p>This dataset contains the variables from a survey on a set of customers
of a company operating in the retail food sector. The company sells
products from 3 major categories (referred to as A, B, C) The customers can
order and acquire products in the company physical stores, or through the
company's website (in this case, they can order on the website and pick up the
order in one store). Information is collected on customers' activity in the
last two years (observation period), as well as some information retrieved
through questionnaires or fidelity cards. During such period different
marketing strategies were adopted to improve customers' fidelization, and 5
marketing campaigns were launched; a last campaign was launched at the end of
the observation period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MktDATA.Orig)
</code></pre>


<h3>Format</h3>


<p>A data frame with 2224 observations and the following 19
variables (levels of the variables listed in alphabetical order):
</p>

<ul>
<li> <p><strong><code>CustId</code></strong> (<code>num</code>): customer's identification label
</p>
</li>
<li> <p><strong><code>Gender</code></strong> (<code>chr</code>): customer's gender (<code>F</code>, <code>M</code>)
</p>
</li>
<li> <p><strong><code>Age</code></strong> (<code>num</code>): customer's age (in years)
</p>
</li>
<li> <p><strong><code>Education</code></strong> (<code>chr</code>): customer's level of education(<code>College</code>, <code>Graduate</code>,
<code>HighSchool</code>, <code>Post-Grad</code>)
</p>
</li>
<li> <p><strong><code>Marital_Status</code></strong> (<code>chr</code>): customer's marital status
(<code>Divorced</code>, <code>Married</code>, <code>Single</code>, <code>Together</code>, <code>Widow</code>)
</p>
</li>
<li> <p><strong><code>Children</code></strong> (<code>num</code>): number of children in the household
</p>
</li>
<li> <p><strong><code>Kids</code></strong> (<code>num</code>): number of kids aged less than 12 in the
household
</p>
</li>
<li> <p><strong><code>Income</code></strong> (<code>chr</code>): customer's income (measured in classes)
</p>
</li>
<li> <p><strong><code>Baseline</code></strong> (<code>num</code>): index (from 0 to 1) assigned by the marketing dept
indicating how promising the customer was judged at the beginning of
the observation period
</p>
</li>
<li> <p><strong><code>LikeMost</code></strong> (<code>chr</code>): Most frequently bought category in the last two
years (<code>P.A</code>, <code>P.B</code>, <code>P.C</code>)
</p>
</li>
<li> <p><strong><code>TotVal</code></strong> (<code>num</code>): amount spent in the last 2 years
</p>
</li>
<li> <p><strong><code>NPickUp_Purch</code></strong> (<code>num</code>): number of purchases made through company's
website and picked up in physical store
</p>
</li>
<li> <p><strong><code>NWeb_Purch</code></strong> (<code>num</code>): number of purchases made through company's website
and delivered at home
</p>
</li>
<li> <p><strong><code>NStore_Purch</code></strong> (<code>num</code>): number of purchases made in a physical store
</p>
</li>
<li> <p><strong><code>NDeals</code></strong> (<code>num</code>): number of products purchases with discount
</p>
</li>
<li> <p><strong><code>CustClass</code></strong> (<code>chr</code>): customer's classification (assigned by the marketing
dept) based on past profitability (<code>Bronze</code>, <code>Gold</code>, <code>Platinum</code>,
<code>Silver</code>)
</p>
</li>
<li> <p><strong><code>PastCampaigns</code></strong> (<code>num</code>): number of offers accepted by the customer in the
last 2 years' marketing campaigns
</p>
</li>
<li> <p><strong><code>LastCampaign</code></strong> (<code>num</code>): binary variable (0/1) indicating whether (1) or
not (0) the customer accepted the offer in the campaign launched at
the end of the observation period
</p>
</li>
<li> <p><strong><code>WouldSuggest</code></strong> (<code>chr</code>): variable signalling whether (<code>Yes</code>) or not
(<code>No</code>) the customer declared they would suggest the company's products
to friends and family
</p>
</li></ul>




<h3>Source</h3>

<p>The data set has been adapted from <a href="https://www.kaggle.com/code/dmitryuarov/customers-clustering-eda">https://www.kaggle.com/code/dmitryuarov/customers-clustering-eda</a>.
</p>

<hr>
<h2 id='summaries.plot.x'>Plot of central and non-central conditional tendency measures for
a single numeric variable</h2><span id='topic+summaries.plot.x'></span>

<h3>Description</h3>

<p><code>summaries.plot.x()</code> plots location statistics for a
numeric vector conditioned to the levels of one or more variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaries.plot.x(
  x,
  stats = "mean",
  plot.type = "bars",
  conf.level = 0.95,
  by1,
  by2,
  breaks.by1,
  interval.by1 = FALSE,
  breaks.by2,
  interval.by2 = FALSE,
  adj.breaks = TRUE,
  bw = FALSE,
  color = NULL,
  legend = TRUE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaries.plot.x_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying a <em>numerical</em> variable whose
tendency measures have to be graphically displayed.
<code>x</code> can be the name of a vector in the workspace or the
name of one of the columns in the data frame specified in the
<code>data</code> argument.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_stats">stats</code></td>
<td>
<p>A single character specifying the conditioned
tendency measure/s to
display in the plot. The available options are <code>"mean"</code>,
<code>"median"</code>, <code>"ci.mean"</code> (to plot the means and the
confidence intervals for the means), and specific sets of
quantiles, namely <code>"quartiles"</code>, <code>"quintiles"</code>,
<code>"deciles"</code>, and <code>"percentiles"</code> (note that for quantiles
only one single layer can be specified).</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_plot.type">plot.type</code></td>
<td>
<p>A single character specifying the type of plot
used to compare the requested measures conditioned to the levels
of one variable, <code>by1</code>, possibly broken down by the
levels of a second variable, <code>by2</code>, if specified.
The available options are:
</p>

<ul>
<li> <p><code>"bars"</code>: Available only when <code>stats</code> is <code>"mean"</code>,
<code>"median"</code>, or <code>"ci.mean"</code> and one single layer (<code>by1</code>)
is specified. For each level of <code>by1</code> a bar is built whose
height coincides with the conditional mean or median. Confidence
intervals for the means are reported when <code>stats = "ci.mean"</code>.
</p>
</li>
<li> <p><code>"points"</code>: Available only when <code>stats</code> is <code>"mean"</code>,
<code>"median"</code>, and <code>"ci.mean"</code>. Confidence
intervals for the means are reported when <code>stats = "ci.mean"</code> and
one single layer is specified.
</p>
</li>
<li> <p><code>"lines"</code>: Points joined by lines; this is the unique option
available for quantiles.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_conf.level">conf.level</code></td>
<td>
<p>A number between 0 and 1 indicating the
confidence level of the intervals for the conditional means
when <code>stats = "ci.mean"</code> is specified (default to 0.95).</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_by1">by1</code>, <code id="summaries.plot.x_+3A_by2">by2</code></td>
<td>
<p>Unquoted strings identifying variables
(typically taking few values/levels) used to build conditional
summaries, that can be defined same way as <code>x</code>. At least one
layer has to be specified. The conditional measures are plotted
against the values of <code>by1</code>, broken down by the levels
of <code>by2</code>, if specified.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_breaks.by1">breaks.by1</code>, <code id="summaries.plot.x_+3A_breaks.by2">breaks.by2</code></td>
<td>
<p>Allow classifying the variables
<code>by1</code>  and/or <code>by2</code>, if <em>numerical</em>, into intervals.
They can be integers indicating the number of intervals of
equal width used to classify <code>by1</code> and/or <code>by2</code>,
or vectors of increasing numeric values defining the endpoints
of intervals (closed on the left and open on the right; the last
interval is closed on the right too). To cover the entire range
of values the maximum and the minimum values should be
included between the first and the last break. It is possible to
specify a set of breaks covering only a portion of the range
of <code>by1</code> and/or <code>by2</code>.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_interval.by1">interval.by1</code>, <code id="summaries.plot.x_+3A_interval.by2">interval.by2</code></td>
<td>
<p>Logical values indicating
whether <code>by1</code> and/or <code>by2</code> are variables
measured in classes (<code>TRUE</code>). If the intervals for
one variable are not consistent (e.g. overlapping intervals,
or intervals with upper endpoint higher than the lower one),
the variable is analysed as it is, even if
results are not necessarily consistent; default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_adj.breaks">adj.breaks</code></td>
<td>
<p>Logical value indicating whether the endpoints of
intervals of the numerical variables <code>by1</code> or <code>by2</code>,
when classified into intervals, should be displayed avoiding
scientific notation; default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_bw">bw</code></td>
<td>
<p>Logical value indicating whether plots should be colored
in scale of greys (<code>TRUE</code>) rather than using a standard
palette (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_color">color</code></td>
<td>
<p>Optional string vector to specify colors
to use in the plot rather than a standard palette
(<code>NULL</code>, default).</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_legend">legend</code></td>
<td>
<p>Logical value indicating whether a legend should be displayed
in the plot (<code>legend = TRUE</code>; default) or not
(<code>legend = FALSE</code>).</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers on
axes should be displayed using scientific notation
(<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>
and/or the variables specifying the layers, <code>by1</code> and <code>by2</code>.
If not found in <code>data</code>, the variables are taken from
the environment from which <code>distr.summary.x()</code> is called.</p>
</td></tr>
<tr><td><code id="summaries.plot.x_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table (converted to dataframe) reporting the requested
statistics conditioned to the levels of the specified layers.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distr.summary.x">distr.summary.x</a>()</code> for tabulating summary
measures of a univariate distribution.
</p>
<p><code><a href="#topic+distr.plot.x">distr.plot.x</a>()</code> for plotting a univariate
distribution.
</p>
<p><code><a href="#topic+distr.table.x">distr.table.x</a>()</code> for tabulating a univariate
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Means (and their CI) or medians by a single variable
# - Barplot of means (default) by a character 
summaries.plot.x(x = TotVal, stats = "mean",  
               by1 = Gender, data = MktDATA)
# - Barplot of medians by a numerical variable
#   classified into intervals: user-defined color
summaries.plot.x(x = TotVal, stats = "median", 
                 by1 = AOV, breaks.by1 = 5, 
                 color = "purple", data = MktDATA)
# - Lineplot of means and their CI by a variable 
#   measured in classes
summaries.plot.x(x = TotVal, 
                 stats = "ci.mean", plot.type = "lines",
                 by1 = Income.S, interval.by1 = TRUE,
                 data = MktDATA)
# - Barplot of means and their CI by a 
#   numerical variable; change the confidence level
summaries.plot.x(x = TotVal, 
                 stats = "ci.mean", conf.level = 0.90,
                 plot.type = "bars", 
                 by1 = NWeb_Purch, data = MktDATA)
# - Note: no plot built for a variable with 
#   too many levels (&gt;20)
# summaries.plot.x(x = TotVal, 
#                  stats = "ci.mean", plot.type = "lines",
#                  by1 = AOV, data = MktDATA)

# Quantiles by a single variable
# - Only lines plots allowed for quantiles
summaries.plot.x(x = Baseline, 
                 stats = "deciles", plot.type = "lines",
                 by1 = NDeals, data = MktDATA)
summaries.plot.x(x = Baseline, 
                 stats = "quartiles", plot.type = "lines",
                 by1 = Marital_Status, data = MktDATA)

# Means and medians by two variables
# - Default: only lines allowed
summaries.plot.x(x = TotVal, stats = "mean", 
                 by1 = Education, by2 = Kids, 
                 data = MktDATA)
summaries.plot.x(x = TotVal, stats = "median", 
                 by1 = Income.S, by2 = Gender,
                 interval.by1 = TRUE,
                 data = MktDATA)
summaries.plot.x(x = Baseline, stats = "mean", 
                 by1 = CustClass, by2 = AOV,
                 breaks.by2 = 5, data = MktDATA)
# - "ci.mean" not allowed with two layers
CustClass_Kids&lt;-paste0(MktDATA$CustClass,"-",MktDATA$Kids)
summaries.plot.x(x = Baseline, stats = "ci.mean", 
                 conf.level = 0.99, by1 = CustClass_Kids,
                 color = "gold", data = MktDATA)

# Arguments adj.breaks and use.scientific
#  Variables with a very wide range
LargeX&lt;-MktDATA$TotVal*1000000
LargeBY&lt;-MktDATA$AOV*5000000 
#  - Default: no scientific notation
summaries.plot.x(LargeX, plot.type = "bars",
                 by1=LargeBY, breaks.by1 = 5, data = MktDATA)
#  - Scientific notation for summaries (axes) 
summaries.plot.x(LargeX, plot.type = "lines",
                 by1=LargeBY, breaks.by1 = 5, 
                 use.scientific = TRUE, data = MktDATA)
#  - Scientific notation for intervals endpoints
summaries.plot.x(LargeX, stats = "ci.mean",
                 plot.type = "lines",
                 by1=LargeBY, breaks.by1 = 5,
                 adj.breaks = FALSE, data = MktDATA)
#  - Scientific notation for intervals endpoints and summaries
summaries.plot.x(LargeX, stats = "quartiles",
                 plot.type = "lines", 
                 by1=LargeBY, breaks.by1 = 5, 
                 adj.breaks = FALSE, use.scientific = TRUE,
                 data = MktDATA)

# Output the table with the requested summaries 
Out_TotVal&lt;-summaries.plot.x(x = TotVal, stats = "ci.mean", 
                             by1 = Education, data = MktDATA)

</code></pre>

<hr>
<h2 id='TEST.diffmean'>Tests on the difference between means</h2><span id='topic+TEST.diffmean'></span>

<h3>Description</h3>

<p><code>TEST.diffmean()</code>  tests hypotheses on the difference between the
means of two independent or paired populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEST.diffmean(
  x,
  y,
  type = "independent",
  mdiff0 = 0,
  alternative = "two.sided",
  sigma.x = NULL,
  sigma.y = NULL,
  by,
  sigma.by = NULL,
  sigma.d = NULL,
  var.test = FALSE,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TEST.diffmean_+3A_x">x</code>, <code id="TEST.diffmean_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying the <em>numeric</em>
variables with the same length whose means have to be compared. <code>x</code> and
<code>y</code> can be the names of vectors in the workspace
or the names of columns in the data frame
specified in the <code>data</code> argument.
It is possible to use a mixed specification (e.g, one vector and one
column in data).</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_type">type</code></td>
<td>
<p>A length-one character vector specifying the type of samples.
Allowed values are <code>"independent"</code> or <code>"paired"</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_mdiff0">mdiff0</code></td>
<td>
<p>Numeric value that specifies the null hypothesis to test for
(default is 0).</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_alternative">alternative</code></td>
<td>
<p>A length-one character vector specifying the direction
of the alternative hypothesis. Allowed values are <code>"two.sided"</code>
(difference between populations' means differs from <code>mdiff0</code>; default), or <code>"less"</code>
(difference between populations' means is lower than <code>mdiff0</code>), or <code>"greater"</code>
(difference between populations' means is higher than <code>mdiff0</code>).</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_sigma.x">sigma.x</code>, <code id="TEST.diffmean_+3A_sigma.y">sigma.y</code></td>
<td>
<p>Optional numeric values specifying
the possibly known populations' standard deviations
(when <code>x</code> and <code>y</code> are specified). If <code>NULL</code> (default)
standard deviations are estimated using the data.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_by">by</code></td>
<td>
<p>Optional unquoted string, available only when
<code>type = "independent"</code>, identifying a variable
(of any type), defined same way as <code>x</code>,
taking only <b>two</b> values used to split
<code>x</code> into two <b>independent samples</b>. Given the two
<em>ordered</em> values taken by <code>by</code>
(alphabetical or numerical order,
or order of the levels for factors), say <em>by1</em> and <em>by2</em>,
hypotheses are tested on the difference between the
populations means in the <em>by1</em>- and  in the <em>by2</em>-group.
Note that only <b>one</b> between <code>y</code> and <code>by</code> can be
specified.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_sigma.by">sigma.by</code></td>
<td>
<p>Optional numeric value specifying the possibly known
standard deviations for the two <em>independent</em> samples identified via
<code>by</code> (when <code>x</code> and <code>by</code> are specified).
<code>sigma.by</code> can be a single value indicating the same
standard deviation in the two by-groups, or a vector with two values,
specifying the standard deviations in the two by-groups. To avoid errors,
in the latter case the vector should be named, with names coinciding
with the two levels of <code>by</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_sigma.d">sigma.d</code></td>
<td>
<p>Optional numeric value specifying the possibly known
standard deviation of the difference when samples are <b>paired</b>.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_var.test">var.test</code></td>
<td>
<p>Logical value indicating whether to run a test on the
equality of variance for two (<b>independent</b>) samples or not
(default).</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or
<code>y</code> or <code>by</code>. If not found in <code>data</code>, the variables
are taken from the environment
from which <code>TEST.diffmean()</code> is called.</p>
</td></tr>
<tr><td><code id="TEST.diffmean_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the results of the test on the difference
between the populations' means. For independent samples in the case
of unknown variances the test is run both under the
assumption that the variances are equal and under the assumption that
they differ, using percentiles from both the normal and the
Student's t distribution.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CI.diffmean">CI.diffmean</a>()</code> to build confidence intervals for
the difference between two populations' means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Independent samples (default type), UNKNOWN variances
#  Bilateral test on difference between means of males and females
#  - Using x,y: build vectors with data on the two groups
AOV_M &lt;- MktDATA$AOV[MktDATA$Gender == "M"]
AOV_F &lt;- MktDATA$AOV[MktDATA$Gender == "F"]
TEST.diffmean(x = AOV_M, y = AOV_F, mdiff0 = 0)
#  - Using x,by: groups identified by ordered levels of by
TEST.diffmean(x = AOV, by = Gender, mdiff0 = 0, data = MktDATA)
#    Since order is F, M, hypothesis are on mean(F) - mean(M)
#    To test hypotheses on mean(M) - mean(F)
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
TEST.diffmean(x = AOV, by = Gender.R , mdiff0 = 0, 
              data = MktDATA)
#  - Testing also hypotheses on equality of unknown variances
TEST.diffmean(x = AOV_M, y = AOV_F, mdiff0 = 0, 
              var.test = TRUE)

#  - Output results: test on differences
out.test_diffM&lt;-TEST.diffmean(x = AOV_M, y = AOV_F)
#  - Output results: list with both test on means and variances
out.test_diffM.V&lt;-TEST.diffmean(x = AOV_M, y = AOV_F, var.test = TRUE)

# Independent samples (default type), KNOWN variances
#  Test hypotheses on the difference between means of males and females
#  - Using x,y: build vectors with data on the two groups
AOV_M &lt;- MktDATA$AOV[MktDATA$Gender == "M"]
AOV_F &lt;- MktDATA$AOV[MktDATA$Gender == "F"]
TEST.diffmean(x = AOV_M, y = AOV_F, mdiff0 = 10, 
              alternative = "greater", sigma.x = 10, sigma.y = 20)
#  - Using x,by: groups identified by ordered levels of by
#    Adjust considering the ordering of levels
TEST.diffmean(x = AOV, by = Gender, mdiff0 = -10,
              alternative = "less",
              sigma.by = c("M" = 10, "F"=20), data = MktDATA)
#    To change the sign, order levels as desired
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
TEST.diffmean(x = AOV, by = Gender.R, mdiff0 = 10,
              alternative = "greater",
              sigma.by = c("M" = 10, "F"=20), data = MktDATA)
#  - Output results 
out.test_diffM&lt;-TEST.diffmean(x = AOV_M, y = AOV_F, mdiff0 = 10, 
                              alternative = "greater", 
                              sigma.x = 10, sigma.y = 20)

# Paired samples: UNKNOWN variances
# - Default settings
TEST.diffmean(x = NStore_Purch, y = NWeb_Purch, 
              type = "paired", 
              mdiff0 = 1.5, alternative = "greater", data=MktDATA)
# Paired: KNOWN variances
TEST.diffmean(x = NStore_Purch, y = NWeb_Purch,
              type = "paired", mdiff0 = 1.5, alternative = "greater",
              sigma.d = 2, data = MktDATA)
#  - Output results 
out.test_diffM&lt;-TEST.diffmean(x = NStore_Purch, 
                              y = NWeb_Purch,
                              type = "paired", mdiff0 = 1.5, alternative = "greater",
                              sigma.d = 2, data = MktDATA)

# Arguments force.digits and use.scientific
#  An input variable taking very low values
SmallX&lt;-MktDATA$AOV/50000
SmallX_M &lt;- SmallX[MktDATA$Gender == "M"]
SmallX_F &lt;- SmallX[MktDATA$Gender == "F"]
#  - Default output
TEST.diffmean(x = SmallX_M, y = SmallX_F)
#  - Request to use the exact number of digits (default, 2)
TEST.diffmean(x = SmallX_M, y = SmallX_F,
              force.digits = TRUE)
#  - Request to allow scientific notation
TEST.diffmean(x = SmallX_M, y = SmallX_F, 
              use.scientific = TRUE)

</code></pre>

<hr>
<h2 id='TEST.diffprop'>Tests on the difference between proportions</h2><span id='topic+TEST.diffprop'></span>

<h3>Description</h3>

<p><code>TEST.diffprop()</code> tests hypotheses on the difference between the
proportion of successes in two independent populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEST.diffprop(
  x,
  y,
  success.x = NULL,
  success.y = NULL,
  pdiff0 = 0,
  alternative = "two.sided",
  by,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TEST.diffprop_+3A_x">x</code>, <code id="TEST.diffprop_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying the variables of
interest. <code>x</code> and <code>y</code> can be the
names of vectors or factors in the workspace or the
names of columns in the data frame
specified in the <code>data</code> argument.
It is possible to use a mixed specification
(e.g, one vector and one column in data).</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_success.x">success.x</code>, <code id="TEST.diffprop_+3A_success.y">success.y</code></td>
<td>
<p>If <code>x,y</code> are factors, character
vectors, or numeric non-binary vectors, success must be used to indicate
the category/value corresponding to success in the populations. These
arguments can be omitted (<code>NULL</code>, default) if <code>x,y</code> are binary
numeric vectors (taking values 0 or 1 only; in this case success is
assumed to correspond to 1) or a logical vector (in these cases success
is assumed to correspond to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_pdiff0">pdiff0</code></td>
<td>
<p>Numeric value that specifies the null hypothesis to test for
(default is 0).</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_alternative">alternative</code></td>
<td>
<p>A length-one character vector specifying the direction
of the alternative hypothesis. Allowed values are <code>"two.sided"</code>
(difference between populations' proportions differs from <code>pdiff0</code>; default), or <code>"less"</code>
(difference between populations' proportions is lower than <code>pdiff0</code>), or <code>"greater"</code>
(difference between populations' proportions is higher than <code>pdiff0</code>).</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_by">by</code></td>
<td>
<p>Optional unquoted string identifying a variable
(of any type), defined same way as <code>x</code>,
taking only <b>two</b> values used to split
<code>x</code> into two independent samples. Given the two
<em>ordered</em> values taken by <code>by</code>
(alphabetical or numerical order,
or order of the levels for factors), say <em>by1</em> and <em>by2</em>,
hypotheses are tested on the difference between the
populations proportions in the <em>by1</em>- and  in the <em>by2</em>-group.
Note that only <b>one</b> between <code>y</code> and <code>by</code> can be
specified.</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or
<code>y</code> or <code>by</code>. If not found in <code>data</code>, the variables
are taken from the environment
from which <code>TEST.diffprop()</code> is called.</p>
</td></tr>
<tr><td><code id="TEST.diffprop_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the results of the test on the difference
between the proportions of successes in two independent populations.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CI.diffprop">CI.diffprop</a>()</code> to build confidence intervals for
the difference between two populations' proportions of successes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Proportions of success defined on non-binary and 
#  non-logical vectors; 'success' coded same way
#  for both vectors
#  - Using x,y: build vectors with data on the two groups
WouldSuggest_F &lt;- MktDATA$WouldSuggest[MktDATA$Gender == "F"]
WouldSuggest_M &lt;- MktDATA$WouldSuggest[MktDATA$Gender == "M"]
TEST.diffprop(x = WouldSuggest_M, y = WouldSuggest_F, 
              success.x = "Yes", pdiff0 = 0.1, alternative = "less")

PastCampaigns_F&lt;-MktDATA$PastCampaigns[MktDATA$Gender=="F"]
PastCampaigns_M&lt;-MktDATA$PastCampaigns[MktDATA$Gender=="M"]
TEST.diffprop(x = PastCampaigns_M, y = PastCampaigns_F,
              success.x = 0, pdiff0 = 0.2)

#  - Using x,by: groups identified by ordered levels of by
TEST.diffprop(x = PastCampaigns, by = Gender,
              success.x=0, pdiff0 = 0.2, data = MktDATA)
#    Since order is F, M, test is on prop(F) - prop(M)
#    To get the interval for prop(M) - prop(F)
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
TEST.diffprop(x = PastCampaigns, by = Gender.R,
              success.x=0, pdiff0 = 0.2, data = MktDATA)

# Proportions of success defined based on 
#  binary or logical vectors; 'success'
#  coded same way for both vectors
#  - Binary variable (success=1): based on x,y
LastCampaign_F&lt;-MktDATA$LastCampaign[MktDATA$Gender=="F"]
LastCampaign_M&lt;-MktDATA$LastCampaign[MktDATA$Gender=="M"]
TEST.diffprop(x = LastCampaign_M, y = LastCampaign_F)
#  - Binary variable (success=1): based on x,y
#    see above for recoding of levels of Gender
TEST.diffprop(x = LastCampaign, by = Gender, data = MktDATA)
Gender.R &lt;- factor(MktDATA$Gender, levels = c("M", "F"))
TEST.diffprop(x = LastCampaign, by = Gender.R, data = MktDATA)
#  - Logical variable (success=TRUE): based on x,y
Deals_w_child &lt;- MktDATA$Deals.ge50[MktDATA$Children&gt;0]
Deals_no_child &lt;- MktDATA$Deals.ge50[MktDATA$Children==0]
TEST.diffprop(x = Deals_w_child, y = Deals_no_child, 
              pdiff0 = 0.2, alternative = "less",)
# Proportions defined on 
#  non-binary and non-logical vectors, with 'success'
#  coded differently (only specification x,y is reasonable here)
WouldSuggest_Other&lt;-c(rep("OK",310),rep("KO",650-310))
TEST.diffprop(x = WouldSuggest, y = WouldSuggest_Other, 
              success.x = "Yes", success.y = "OK",
              pdiff0 = 0.1, alternative = "greater",
              data = MktDATA)

# Proportions based on combined conditions
# - Build logical vector/s indicating whether a condition 
#   is satisfied
IsTop&lt;-MktDATA$AOV&gt;80
IsTop_OK&lt;-IsTop[MktDATA$WouldSuggest == "Yes"]
IsTop_KO&lt;-IsTop[MktDATA$WouldSuggest == "No"]
TEST.diffprop(x = IsTop_OK, y = IsTop_KO, pdiff0 = 0.05,
              alternative = "greater")

Deals&lt;-MktDATA$NDeals&gt;=5
Deals_Married &lt;- Deals[MktDATA$Marital_Status=="Married" &amp; 
                         MktDATA$Children==0] 
Deals_Single &lt;- Deals[MktDATA$Marital_Status=="Single"] 
TEST.diffprop(x = Deals_Married, y = Deals_Single,
              alternative = "less")

# Output results           
out.test_diffP&lt;-TEST.diffprop(x = Deals_Married, y = Deals_Single,
                              alternative = "less")

# Arguments force.digits and use.scientific
#  An input variable taking very low values
HighAOV &lt;- MktDATA$AOV&gt;150
# - Default: manages possible excess of rounding
TEST.diffprop(x = HighAOV[MktDATA$Gender=="M"], 
              y = HighAOV[MktDATA$Gender=="F"])
#  - Force to the exact number of digits (default, 2)
TEST.diffprop(x = HighAOV[MktDATA$Gender=="M"], 
              y = HighAOV[MktDATA$Gender=="F"],
              force.digits = TRUE)
#  - Allow scientific notation
TEST.diffprop(x = HighAOV[MktDATA$Gender=="M"], 
              y = HighAOV[MktDATA$Gender=="F"],
              use.scientific = TRUE)

</code></pre>

<hr>
<h2 id='TEST.diffvar'>Tests on variances</h2><span id='topic+TEST.diffvar'></span>

<h3>Description</h3>

<p><code>TEST.diffvar()</code> tests the hypothesis of equality between the
variances of two independent populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEST.diffvar(
  x,
  y,
  by,
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TEST.diffvar_+3A_x">x</code>, <code id="TEST.diffvar_+3A_y">y</code></td>
<td>
<p>Unquoted strings identifying the <em>numeric</em>
variables with the same length whose variances have to be compared.
<code>x</code> and <code>y</code> can be the names of vectors in the workspace
or the names of columns in the data frame
specified in the <code>data</code> argument. It is possible to
use a mixed specification (e.g, one vector and one
column in data).</p>
</td></tr>
<tr><td><code id="TEST.diffvar_+3A_by">by</code></td>
<td>
<p>Optional unquoted string identifying a variable
(of any type), defined same way as <code>x</code>,
taking only <b>two</b> values used to split
<code>x</code> into two independent samples. Since the
null hypothesis of equal variances is tested against the
bilateral alternative only, the order of the levels of
<code>by</code> is irrelevant (differently from what holds
for functions building confidence intervals or testing
hypotheses on the differences between means or proportions).
Note that only <b>one</b> between <code>y</code> and <code>by</code> can be
specified.</p>
</td></tr>
<tr><td><code id="TEST.diffvar_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffvar_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="TEST.diffvar_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="TEST.diffvar_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code> and/or
<code>y</code>. If not found in <code>data</code>, the variables
are taken from the environment
from which <code>TEST.diffvar()</code> is called.</p>
</td></tr>
<tr><td><code id="TEST.diffvar_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the results of the test on the
difference between the variances of two independent populations.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CI.diffmean">CI.diffmean</a>()</code> to build confidence intervals for
the difference between two populations' means.
</p>
<p><code><a href="#topic+TEST.diffmean">TEST.diffmean</a>()</code> to test hypotheses on the difference
between two populations' means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Using x,y: build vectors with data on the two groups
AOV_M &lt;- MktDATA$AOV[MktDATA$Gender == "M"]
AOV_F &lt;- MktDATA$AOV[MktDATA$Gender == "F"]
TEST.diffvar(x = AOV_M, y = AOV_F)
TEST.diffvar(x = AOV_F, y = AOV_M) # same

# Using x,by: groups identified by ordered levels of by
TEST.diffvar(x = AOV, by = Gender, data=MktDATA)

# Output results
out_test.diffV&lt;-TEST.diffvar(x = AOV_M, y = AOV_F)

# Arguments force.digits and use.scientific
#  An input variable taking very low values
SmallX&lt;-MktDATA$AOV/50000
SmallX_M &lt;- SmallX[MktDATA$Gender == "M"]
SmallX_F &lt;- SmallX[MktDATA$Gender == "F"]
#  - Default output
TEST.diffvar(x = SmallX_M, y = SmallX_F)
#  - Request to use the exact number of digits (default, 2)
TEST.diffvar(x = SmallX_M, y = SmallX_F,
             force.digits = TRUE)
#  - Request to allow scientific notation
TEST.diffvar(x = SmallX_M, y = SmallX_F, 
             use.scientific = TRUE)

</code></pre>

<hr>
<h2 id='TEST.mean'>Test on the mean</h2><span id='topic+TEST.mean'></span>

<h3>Description</h3>

<p><code>TEST.mean()</code>  tests hypotheses on the mean of a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEST.mean(
  x,
  sigma = NULL,
  mu0 = 0,
  alternative = "two.sided",
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TEST.mean_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the <em>numeric</em>
variable whose mean is of interest. <code>x</code> can be the
name of a vector in the workspace or the name of one of
the columns in the data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_sigma">sigma</code></td>
<td>
<p>An optional numeric value specifying the
population standard deviation. If <code>NULL</code> (default)
the population standard deviation is estimated using the
data.</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_mu0">mu0</code></td>
<td>
<p>Numeric value that specifies the null hypothesis to test for
(default is 0).</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_alternative">alternative</code></td>
<td>
<p>A length-one character vector specifying the direction
of the alternative hypothesis. Allowed values are <code>"two.sided"</code>
(population mean differs from <code>mu0</code>; default), or <code>"less"</code>
(population mean is lower than <code>mu0</code>), or <code>"greater"</code>
(population mean is higher than <code>mu0</code>).</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>.
If not found in <code>data</code>, <code>x</code> is taken from the environment
from which <code>TEST.mean()</code> is called.</p>
</td></tr>
<tr><td><code id="TEST.mean_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the results of the test on the population mean.
If the variance is unknown, the test is run using percentiles from
both the normal and the Student's t distribution.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CI.mean">CI.mean</a>()</code> to build confidence intervals for the
population mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Test on the mean; KNOWN variance
# - Bilateral test
TEST.mean(NStore_Purch, sigma = 9, mu0 = 5, 
          alternative = "two.sided", data = MktDATA)
# - Unilateral test
TEST.mean(NStore_Purch, sigma = 9,mu0 = 5,
          alternative = "greater", data = MktDATA)

# Test on the mean; UNKNOWN variance;
# - Unilateral test
TEST.mean(TotVal, mu0 = 600, alternative = "less",
          data = MktDATA)

# Arguments force.digits and use.scientific
# An input variable taking very low values
SmallX&lt;-MktDATA$AOV/500
# Default output
TEST.mean(SmallX, mu0 = 0.1)
# Request to use the exact number of digits (default, 2)
TEST.mean(SmallX, mu0 = 0.1,force.digits=TRUE)
# Request to allow scientific notation
TEST.mean(SmallX, mu0 = 0.1,use.scientific=TRUE)

# Output results
out.test_mean&lt;-TEST.mean(TotVal, mu0 = 600, alternative = "less",
                         data = MktDATA)

</code></pre>

<hr>
<h2 id='TEST.prop'>Test on the proportion</h2><span id='topic+TEST.prop'></span>

<h3>Description</h3>

<p><code>TEST.prop()</code>  tests hypotheses on the proportion of successes in a
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEST.prop(
  x,
  success = NULL,
  p0 = 0.5,
  alternative = "two.sided",
  digits = 2,
  force.digits = FALSE,
  use.scientific = FALSE,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TEST.prop_+3A_x">x</code></td>
<td>
<p>An unquoted string identifying the variable of interest.
<code>x</code> can be the name of a vector
or a factor in the workspace or the name of one of the columns in the
data frame specified in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_success">success</code></td>
<td>
<p>If <code>x</code> is a factor, a character vector, or a numeric
non-binary vector, <code>success</code> must be used to indicate the category/value
corresponding to success. The argument can be omitted (<code>NULL</code>,
default) if <code>x</code> is a binary numeric vector (takes values 0 or 1 only;
in this case success is assumed to be 1) or a logical vector (in these
cases success is assumed to be <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_p0">p0</code></td>
<td>
<p>Numeric value that specifies the null hypothesis to test for
(default is 0).</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_alternative">alternative</code></td>
<td>
<p>A length-one character vector specifying the direction
of the alternative hypothesis. Allowed values are <code>"two.sided"</code>
(population proportion differs from <code>p0</code>; default), or <code>"less"</code>
(population proportion is lower than <code>p0</code>), or <code>"greater"</code>
(population proportion is higher than <code>p0</code>).</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_digits">digits</code></td>
<td>
<p>Integer value specifying the number of
decimals used to round statistics; default to 2. If the chosen rounding formats some
non-zero values as zero, the number of decimals is increased
so that all values have at least one significant digit, unless the argument
<code>force.digits</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_force.digits">force.digits</code></td>
<td>
<p>Logical value indicating whether reported values
should be forcedly rounded to the number of decimals specified in
<code>digits</code> even if non-zero values are
rounded to zero (default to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_use.scientific">use.scientific</code></td>
<td>
<p>Logical value indicating whether numbers
in tables should be displayed using
scientific notation (<code>TRUE</code>); default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_data">data</code></td>
<td>
<p>An optional data frame containing <code>x</code>.
If not found in <code>data</code>, <code>x</code> is taken from the environment
from which <code>TEST.prop()</code> is called.</p>
</td></tr>
<tr><td><code id="TEST.prop_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to low level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the results of the test on the population
proportion of successes.
</p>


<h3>Author(s)</h3>

<p>Raffaella Piccarreta <a href="mailto:raffaella.piccarreta@unibocconi.it">raffaella.piccarreta@unibocconi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CI.prop">CI.prop</a>()</code> to build confidence intervals for the
population proportion of successes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MktDATA, package = "UBStats")

# Success = one value of a character vector or factor
# - Bilateral test
TEST.prop(WouldSuggest, success = "Yes", p0 = 0.7, 
         data = MktDATA)
# - Unilateral test, change digits
TEST.prop(Education, success = "Post-Grad", p0 = 0.3, 
          alternative = "less", digits = 4,data = MktDATA)

# Success = numeric value; bilateral test
TEST.prop(Children, success = 2, p0 = 0.3, data = MktDATA)

# Binary variable (success = 1 by default); unilateral
TEST.prop(LastCampaign, p0 = 0.1, alternative = "greater", 
          digits = 3, data = MktDATA)

# Logical variable (success = TRUE by default); unilateral test
TEST.prop(Deals.ge50, p0 = 0.13, alternative = "greater", 
          digits = 3, data = MktDATA)

# Success based on combined conditions
# - Build a (logical) vector 
IsTop &lt;- MktDATA$CustClass == "Gold" |
  MktDATA$CustClass == "Platinum"
TEST.prop(IsTop, p0 = 0.2, data = MktDATA)

HighAOV &lt;- MktDATA$AOV&gt;150
TEST.prop(HighAOV, p0 = 0.1)
TEST.prop(HighAOV, p0 = 0.1, force.digits = TRUE)
TEST.prop(HighAOV, p0 = 0.1, use.scientific = TRUE)

# Output results
out_test_prop&lt;-TEST.prop(IsTop, p0 = 0.2, data = MktDATA)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
