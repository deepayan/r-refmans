<!DOCTYPE html><html><head><title>Help for package WSGeometry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WSGeometry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barycenter_lp'><p>Exact computation of 2-Wasserstein barycenters in R^d using linear programming</p></a></li>
<li><a href='#bin2d'><p>Bin data onto a grid.</p></a></li>
<li><a href='#frechet_func'><p>Compute the Frechet functional/The objective value of the barycenter problem</p></a></li>
<li><a href='#geodesic_pos'><p>Compute Wasserstein geodesics</p></a></li>
<li><a href='#grid_positions'><p>Generate a 2d grid in [0,1]^2 of given size.</p></a></li>
<li><a href='#kr_bary'><p>Solves the (2,C)-Barycenter problem between N measures of possibly unequal total mass on R^d.</p></a></li>
<li><a href='#kr_dist'><p>Compute the p-Kantorovich-Rubinstein distance between two measures of possibly unequal total mass.</p></a></li>
<li><a href='#location_scatter_bary'><p>Computes the 2-Wasserstein barycenter of location-scatter families of measures</p></a></li>
<li><a href='#multi_marginal'><p>Solve the multimarginal optimal transport problem by linear programming</p></a></li>
<li><a href='#plotGeodesic'><p>Plot previously computed Wasserstein geodesics</p></a></li>
<li><a href='#smear'><p>Split the values of entries in a matrix between a specified area round it.</p></a></li>
<li><a href='#wasserstein_bary'><p>Compute Wasserstein barycenters</p></a></li>
<li><a href='#ws_bary_maaipm'><p>Solves the 2-Wasserstein Barycenter problem between N probability measures on R^d using an interior point method.</p></a></li>
<li><a href='#ws_dist'><p>Compute the p-Wasserstein distance between two measures</p></a></li>
<li><a href='#ws_logpca'><p>Computes Wasserstein principal components</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometric Tools Based on Balanced/Unbalanced Optimal Transport</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Heinemann [aut, cre], Nicholas Bonneel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Heinemann &lt;florian.heinemann@uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes a variety of methods to compute objects related to the 'Wasserstein distance' (also known as 'Kantorovich distance' or 'Earth-Mover distance'). The main effort of this package is to allow for computations of 'Wasserstein barycenter' using regularised, unregularised and stochastic methods. It also provides convenient wrappers to call the 'transport' package with more general inputs. Handy visual tools are provided to showcase, barycenters, animations of optimal transport geodesics and animations of principal components in the 'Wasserstein space'. It also includes tools to compute 'Kantorovich-Rubinstein' distances and barycenters. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, transport, RSpectra, expm, plot3D, imager, grDevices,
stats, graphics, lpSolve, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magick, mvtnorm, Rsymphony</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-10 22:51:51 UTC; FHein</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-14 23:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='barycenter_lp'>Exact computation of 2-Wasserstein barycenters in R^d using linear programming</h2><span id='topic+barycenter_lp'></span>

<h3>Description</h3>

<p>This function solves the 2-Wasserstein barycenter problem of N finitely supported input
measures explicitly by solving the corresponding linear program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barycenter_lp(pos.list, weights.list, frechet.weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barycenter_lp_+3A_pos.list">pos.list</code></td>
<td>
<p>A list of Mxd matrices, specifying the positions of the data measures.</p>
</td></tr>
<tr><td><code id="barycenter_lp_+3A_weights.list">weights.list</code></td>
<td>
<p>A list of vectors with non-negative entries and identical total sum specifying
the weights of the data measures.</p>
</td></tr>
<tr><td><code id="barycenter_lp_+3A_frechet.weights">frechet.weights</code></td>
<td>
<p>A vector of positive entries summing to one specifying the weights of each data measure
in the Fréchet functional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries. The first entry contains the positions of
the computed barycenter and the second entry contains the corresponding weights.
</p>


<h3>References</h3>

<p>E Anderes, S Borgwardt, and J Miller (2016). Discrete Wasserstein barycenters: 
Optimal transport for discrete data. Mathematical Methods of Operations Research, 84(2):389-409.<br />
S Borgwardt and S Patterson (2020). Improved linear programs for discrete barycenters.
Informs Journal on Optimization 2(1):14-33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos.list&lt;-vector("list",4)
weights.list&lt;-vector("list",4)
pos.list[[1]]&lt;-matrix(c(0,0,1,1,1,0,0,1),nrow=4,ncol=2)/10
pos.list[[2]]&lt;-matrix(c(9,9,10,10,10,9,9,10),nrow=4,ncol=2)/10
pos.list[[3]]&lt;-matrix(c(9,9,10,10,1,0,0,1),nrow=4,ncol=2)/10
pos.list[[4]]&lt;-matrix(c(0,0,1,1,10,9,9,10),nrow=4,ncol=2)/10
plot(0, 0, xlab = "", ylab = "", type = "n", xlim = c(0, 1), ylim = c(0, 1))
for(i in 1:4)
  points(pos.list[[i]][,1], pos.list[[i]][,2], col = i)
weights.list[[1]]&lt;-rep(1/4,4)
weights.list[[2]]&lt;-rep(1/4,4)
weights.list[[3]]&lt;-rep(1/4,4)
weights.list[[4]]&lt;-rep(1/4,4)
bary&lt;-barycenter_lp(pos.list,weights.list)
points(bary$positions[,1],bary$positions[,2], col = "orange", pch = 13)
</code></pre>

<hr>
<h2 id='bin2d'>Bin data onto a grid.</h2><span id='topic+bin2d'></span>

<h3>Description</h3>

<p>Bin data onto a equidistant grid in [0,1]^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin2d(data.pos, data.weights, gridsize, turn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin2d_+3A_data.pos">data.pos</code></td>
<td>
<p>A Mx2 matrix specifying the positions of the data measure.</p>
</td></tr>
<tr><td><code id="bin2d_+3A_data.weights">data.weights</code></td>
<td>
<p>A list of vectors of the same size as the number of rows in data.pos.
All entries in the vector must be non-negative and the entries in the vector must sum to one.</p>
</td></tr>
<tr><td><code id="bin2d_+3A_gridsize">gridsize</code></td>
<td>
<p>A vector of two integers specifying the dimensions of the grid, which the data should be binned to.</p>
</td></tr>
<tr><td><code id="bin2d_+3A_turn">turn</code></td>
<td>
<p>A boolean specifying whether the output should be rotated to keep the previous orientation when the matrix
is plotted with the image function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the weights of the measure in each bin.
</p>

<hr>
<h2 id='frechet_func'>Compute the Frechet functional/The objective value of the barycenter problem</h2><span id='topic+frechet_func'></span>

<h3>Description</h3>

<p>This function computes the objective value of the barycenter problem for a given measure and a given dataset of measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechet_func(bary, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frechet_func_+3A_bary">bary</code></td>
<td>
<p>An object representing a measure, for which the Frechet value should be computed. Should be one of the following: 
A matrix, representing an image; A path to a file containing an image; 
A <a href="transport.html#topic+wpp-object">wpp-object</a>; 
A <a href="transport.html#topic+pp-object">pp-object</a>;
A list containing an entry named 'positions' with the support of the measure and an entry named 'weights' containing the weights of the support points;
A list containing en entry named 'positions&ldquo; specifying the support of a measure with uniform weights.</p>
</td></tr>
<tr><td><code id="frechet_func_+3A_data">data</code></td>
<td>
<p>A list of objects which should be compared to bary. Each element should be one of the following:
A matrix, representing an image; A path to a file containing an image; 
A <a href="transport.html#topic+wpp-object">wpp-object</a>; 
A <a href="transport.html#topic+pp-object">pp-object</a>;
A list containing an entry named 'positions' with the support of the measure and an entry named 'weights' containing the weights of the support points;
A list containing en entry named 'positions&ldquo; specifying the support of a measure with uniform weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number specifying the Frechet value of the input object for the given dataset.
</p>

<hr>
<h2 id='geodesic_pos'>Compute Wasserstein geodesics</h2><span id='topic+geodesic_pos'></span>

<h3>Description</h3>

<p>Computes the geodesic between two measures P1 and P2 in arbitrary dimensions at given timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic_pos(P1, P2, p = 2, steps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodesic_pos_+3A_p1">P1</code></td>
<td>
<p>One of the following: A matrix, representing an image;
A file name containing an image; A <a href="transport.html#topic+wpp-object">wpp-object</a>.</p>
</td></tr>
<tr><td><code id="geodesic_pos_+3A_p2">P2</code></td>
<td>
<p>One of the following: A matrix, representing an image;
A file name containing an image; A <a href="transport.html#topic+wpp-object">wpp-object</a>.</p>
</td></tr>
<tr><td><code id="geodesic_pos_+3A_p">p</code></td>
<td>
<p>A real number &gt;=1 specifying the exponent of the Wasserstein distance.</p>
</td></tr>
<tr><td><code id="geodesic_pos_+3A_steps">steps</code></td>
<td>
<p>A vector of numbers in [0,1] describing the time points at which the geodesic should be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as steps where each element is a <a href="transport.html#topic+wpp-object">wpp-object</a> describing the value of the geodesic at the 
corresponding times in steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U&lt;-runif(20)
U&lt;-U/sum(U)
pos&lt;-matrix(runif(2*20),nrow=20,ncol=2)
P1&lt;-transport::wpp(pos,U)
U&lt;-runif(20)
U&lt;-U/sum(U)
pos&lt;-matrix(runif(2*20),nrow=20,ncol=2)
P2&lt;-transport::wpp(pos,U)
geodesic&lt;-geodesic_pos(P1,P2,p=2,seq(0,1,0.1))
## Set the image and/or gif flags to TRUE to run the example. 
## CRAN policy prevents examples from generating files in the working directory,
## so this had to be disabled.
plotGeodesic(geodesic,File="GeodesicR2",images=FALSE,gif=FALSE)
</code></pre>

<hr>
<h2 id='grid_positions'>Generate a 2d grid in [0,1]^2 of given size.</h2><span id='topic+grid_positions'></span>

<h3>Description</h3>

<p>Generates a matrix containing the positions of the points of an equidistant 2d grid in [0,1]^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_positions(n, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_positions_+3A_n">n</code></td>
<td>
<p>Integer giving one dimension of the grid.</p>
</td></tr>
<tr><td><code id="grid_positions_+3A_m">m</code></td>
<td>
<p>integer giving the other dimension of the grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (nm)x2 grid containing the positions of the desired grid.
</p>

<hr>
<h2 id='kr_bary'>Solves the (2,C)-Barycenter problem between N measures of possibly unequal total mass on R^d.</h2><span id='topic+kr_bary'></span>

<h3>Description</h3>

<p>This is a wrapper function for multiple methods to solve the (2,C)-barycenter problem. It 
contains three methods:
&quot;fixed&quot;: This function finds the best approximation of the (2,C)-barycenter problem of N finitely supported input
measures on a given support set using a modified MAAIPM algorithm to solve the corresponding linear program. 
&quot;free&quot;: This functions finds an approximation of the 2-Wasserstein barycenter using the MAAIPM method by
alternating between updating weights and positions of a candidate barycenter.
&quot;multiscale&quot;: This finds the best approximation of the (2,C)-barycenter problem of N finitely supported input
measures by using a multi-scale version of a modified MAAIPM method. Given a starting grid it solves the fixed support 
(2,C)-barycenter problem on this grid. Then, the grid is refined, by splitting each grid point into 4 new ones.
Afterwards, all grids points below a certain threshold of mass are removed from the support. This procedure is repeated
until a prespecified resolution is reached. Note, the generated grids are assumed to be in [0,1]^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr_bary(
  data.list,
  C,
  method = "fixed",
  support,
  wmaxIter,
  pmaxIter,
  return_type = "default",
  thresh = 10^-3,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kr_bary_+3A_data.list">data.list</code></td>
<td>
<p>A list of objects from which the barycenter should be computed. Each element should be one of the following:
A matrix, representing an image; A path to a file containing an image; 
A <a href="transport.html#topic+wpp-object">wpp-object</a>; 
A list containing an entry named 'positions' with the support of the measure and an entry named 'weights' containing the weights of the support points;
A list containing en entry named 'positions&ldquo; specifying the support of a measure with uniform weights.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_c">C</code></td>
<td>
<p>A real number specifying the unbalanced optimal transport parameter used in the Kantorovich-
Rubinstein distance.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_method">method</code></td>
<td>
<p>A string determining which method is used. The available options &quot;fixed&quot;, &quot;free&quot; and &quot;multiscale&quot;
are described above.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_support">support</code></td>
<td>
<p>The role of this parameter changes depending of the method used.
&quot;fixed&quot;: This is a d x M matrix containing the positions of the fixed-support of the barycenter in R^d.
&quot;free&quot;: This is a d x M matrix containing the initial positions of the barycenter approximation.
&quot;multiscale&quot;: A vector with four entries. The first two are integers giving the resolution of the initial grid.
The third entry is another integer specifying how many times the grid should be refined. The fourth entry is
a real number specifying the threshold under which mass is considered to be zero.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_wmaxiter">wmaxIter</code></td>
<td>
<p>An integer specifying the maximum number of weight iterations to be performed.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_pmaxiter">pmaxIter</code></td>
<td>
<p>An integer specifying the maximum number of weight iterations to be performed for the &quot;free&quot;-
method.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_return_type">return_type</code></td>
<td>
<p>A string specifying the format in which the barycenter should be returned. For all methods
the options &quot;default&quot; (giving a list with an entry 'positions' containing the support of the barycenter
and an entry 'weights' containing the weights of the barycenter) and &quot;wpp&quot; (giving a <a href="transport.html#topic+wpp-object">wpp-object</a>)
are available. Additionally, for the &quot;fixed&quot; method there is the type &quot;vec&quot; which returns a vector of length
M, containing the weights of the barycenter on the given support and for the &quot;multiscale&quot; method there is the 
option &quot;mat&quot; which returns the barycenter in matrix form on a grid of the final resolution.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_thresh">thresh</code></td>
<td>
<p>A real number specifying a stopping criterion based on the magnitude of change between consecutive 
iterations. If one encounters numerical instabilities in the computations in the form of either returned NaNs
or warnings notifying the user about near singular matrices, this parameter can be increased to avoid this.</p>
</td></tr>
<tr><td><code id="kr_bary_+3A_threads">threads</code></td>
<td>
<p>An integer specifying the number of threads used for computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For details on the returned value refer to the parameter return_type.
</p>


<h3>References</h3>

<p>Ge, DongDong, et al. &quot;Interior-Point Methods Strike Back: Solving the Wasserstein Barycenter Problem.&quot; 
Advances in Neural Information Processing Systems 32 (2019): 6894-6905.
Kantorovich-Rubinstein distance and barycenter for finitely supported measures: Foundations and Algorithms; Heinemann, Klatt and Munk; https://arxiv.org/pdf/2112.03581.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a dataset consisting of measures supported on discretized nested ellipses.
N&lt;-5 #The number of measures generated
M&lt;-20 #The number of points each ellipse is discretized into
C&lt;-2 #The parameter of the Kantorovich-Rubinstein distance
data.list&lt;-vector("list",N)
set.seed(42)
nest.vec&lt;-rep(0,N) #A vector containing the number of ellipses in the data measures.
max.ell&lt;-3 #The maximum number of ellipses in each measure. The number is chosen
#uniformly between 1 and this value.
#This loop actually generates the measures for the example.
for (i in 1:N){
  pos.full&lt;-matrix(0,0,2)
  nesting.depth&lt;-ceiling(runif(1,0,max.ell))
  nest.vec[i]&lt;-nesting.depth
  for (k in 1:nesting.depth){
    t.vec&lt;-seq(0,2*pi,length.out=M)
    pos&lt;-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))/(3^(k-1)) 
    theta&lt;-runif(1,0,2*pi)
    rotation&lt;-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
    pos.full&lt;-rbind(pos.full,pos%*%rotation)
  }
  W&lt;-rep(1,M*nesting.depth)
  data.list[[i]]&lt;-transport::wpp((pos.full+1)/2,W)
}
#Using the multiscale method
system.time(bary.ms&lt;-WSGeometry::kr_bary(data.list,C,method="multiscale",
support=c(8,8,3,10^-2),wmaxIter=100,return_type="mat",thresh=6*10^-4,threads=1))

#Using the fixed support method
support&lt;-t(WSGeometry::grid_positions(20,20))
system.time(bary.fixed&lt;-WSGeometry::kr_bary(data.list,C,method="fixed",
support=support,wmaxIter=100,return_type="wpp",thresh=6*10^-4,threads=1))
#Using the free support method
support&lt;-t(WSGeometry::grid_positions(8,8))
system.time(bary.free&lt;-WSGeometry::kr_bary(data.list,C,method="free",
support=support,wmaxIter=100,pmaxIter=25,return_type="wpp",thresh=8*10^-4,threads=1))

#The outputs can be conveniently visualised using the image function for the "mat" output
#and the plot-method for the wpp-objects provided by the transport package.
image(bary.ms)
plot(bary.fixed)
plot(bary.free)

</code></pre>

<hr>
<h2 id='kr_dist'>Compute the p-Kantorovich-Rubinstein distance between two measures of possibly unequal total mass.</h2><span id='topic+kr_dist'></span>

<h3>Description</h3>

<p>This function constructs the corresponding problem and solves it suing the <a href="transport.html#topic+transport">transport</a>-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr_dist(A, B, p = 2, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kr_dist_+3A_a">A</code></td>
<td>
<p>One of the following: A matrix, representing an image;
A file name containing an image; A <a href="transport.html#topic+wpp-object">wpp-object</a>.</p>
</td></tr>
<tr><td><code id="kr_dist_+3A_b">B</code></td>
<td>
<p>One of the following: A matrix, representing an image;
A file name containing an image; A <a href="transport.html#topic+wpp-object">wpp-object</a>.</p>
</td></tr>
<tr><td><code id="kr_dist_+3A_p">p</code></td>
<td>
<p>A positive real number specifying the order of the Kantorovich-Rubinstein distance.</p>
</td></tr>
<tr><td><code id="kr_dist_+3A_c">C</code></td>
<td>
<p>A positive real number specifying the cost parameter of the Kantorovich-Rubinstein distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing an entry &quot;distance&quot; (specifying the KR distance between the two measures) and an 
entry &quot;plan&quot; containing an optimal plan for the unbalanced optimal transport problem.
</p>


<h3>References</h3>

<p>Kantorovich-Rubinstein distance and barycenter for finitely supported measures:  Foundations and Algorithms; Florian Heinemann, Marcel Klatt, Axel Munk; https://arxiv.org/pdf/2112.03581.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M&lt;-1000
W1&lt;-runif(M)
W2&lt;-runif(M)
pos1&lt;-matrix(runif(M*2),M,2)
pos2&lt;-matrix(runif(M*2),M,2)
wpp1&lt;-transport::wpp(pos1,W1)
wpp2&lt;-transport::wpp(pos2,W2)
system.time(res&lt;-WSGeometry:::kr_dist(wpp1,wpp2,2,2))
</code></pre>

<hr>
<h2 id='location_scatter_bary'>Computes the 2-Wasserstein barycenter of location-scatter families of measures</h2><span id='topic+location_scatter_bary'></span>

<h3>Description</h3>

<p>This function solves the 2-Wasserstein barycenter problem of N measures from a location-scatter 
family, where each data distribution is given by a mean vector and a covariance matrix. In particular, this can be
used to compute the barycenter of Gaussian distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_scatter_bary(
  means,
  cov,
  thresh = 10^(-5),
  maxiter = 100,
  showIter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_scatter_bary_+3A_means">means</code></td>
<td>
<p>A list of mean vectors of the elements of the location-scatter family.</p>
</td></tr>
<tr><td><code id="location_scatter_bary_+3A_cov">cov</code></td>
<td>
<p>A list of semipositive-definite covariance matrices of the elements of the 
location-scatter family.</p>
</td></tr>
<tr><td><code id="location_scatter_bary_+3A_thresh">thresh</code></td>
<td>
<p>A real number specifying the threshold for terminating the iterative algorithm.</p>
</td></tr>
<tr><td><code id="location_scatter_bary_+3A_maxiter">maxiter</code></td>
<td>
<p>An integer specifying after how many iterations the algorithm should be terminated
even if the specified threshold has not been reached.</p>
</td></tr>
<tr><td><code id="location_scatter_bary_+3A_showiter">showIter</code></td>
<td>
<p>A boolean specifying whether the number of performed iterations should be shown at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements. The first element &quot;mean&quot; gives the mean 
vector of the barycenter measure. The second elemenent &quot;cov&quot; gives the covariance matrix of the 
barycenter measure.
</p>


<h3>References</h3>

<p>PC Álvarez-Esteban, E del Barrio, JA Cuesta-Albertos, and C Matrán (2016).
A fixed-point approach to barycenters in Wasserstein space. J. Math. Anal.
Appl., 441(2):744–762.<br />
Y Zemel and VM Panaretos (2019). Fréchet Means and Procrustes Analysis in Wasserstein Space. Bernoulli 25(2):932-976.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#One dimensional example
mean.list&lt;-list(5,15)
var.list&lt;-list(1,4)
res&lt;-location_scatter_bary(mean.list,var.list)
x&lt;-seq(0,22,10^-4)
y1&lt;-dnorm(x,mean=5,sd=1)
y2&lt;-dnorm(x,mean=15,sd=2)
y3&lt;-dnorm(x,mean=res$mean,sd=sqrt(res$cov))
plot(x,y1,type="l",main = "Barycenter of two 1-d Gaussian distributions",
ylab = "density",col="blue")
lines(x,y2,col="green")
lines(x,y3,col="red")
legend(15,0.4, legend=c("N(5,1)", "N(15,4)","Barycenter"),
       col=c("blue","green","red"),lty=1,cex=0.9)
       
       
#two dimensional example
# packages graphics and mvtnorm are required to run this example
set.seed(2898581)
mean.list &lt;- list(c(0,0), c(0,0), c(0,0))
COV &lt;- 0.3 + rWishart(3, df = 2, Sigma = diag(2))
cov.list &lt;- list(COV[,, 1], COV[,, 2], COV[,, 3])
res&lt;-location_scatter_bary(mean.list, cov.list)

x &lt;- y &lt;- seq(-3, 3, .1)
z &lt;- array(0.0, dim = c(length(x), length(y), 4))
for(i in seq_along(x))
 for(j in seq_along(y))
 {
   for(n in 1:3)
     z[i, j, n] &lt;- mvtnorm::dmvnorm(c(x[i], y[j]), sigma = COV[, , n])
   
   z[i, j, 4] &lt;- mvtnorm::dmvnorm(c(x[i], y[j]), sigma = res$cov)
 }

op &lt;- par(mfrow = c(2, 2),  mai = c(0, 0, 0, 0))
for(n in 1:3)
{
 graphics::persp(x, y, z[, , n], theta = 30, phi = 30, expand = 0.5, col = "lightblue",
  zlab = "", ticktype = "detailed", shade = .75, lphi = 45, ltheta = 135)
 text(x = 0, y = 0.2, labels = paste("COV[,, ", n, "]", sep = ""))
}

graphics::persp(x, y, z[, , 4], theta = 30, phi = 30, expand = 0.5, col = "red", zlab = "",
ticktype = "detailed", shade = .75, lphi = 45, ltheta = 135)
text(x = 0, y = 0.2, labels = "barycenter")
par(op)
</code></pre>

<hr>
<h2 id='multi_marginal'>Solve the multimarginal optimal transport problem by linear programming</h2><span id='topic+multi_marginal'></span>

<h3>Description</h3>

<p>Solves the N-fold multimarginal optimal transport problem between N specified measures and a specified cost.  This is essentially a convenient wrapper function that builds and solves the corresponding linear program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_marginal(weights, costA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_marginal_+3A_weights">weights</code></td>
<td>
<p>A list of vectors specifying the weights of the marginal distributions. These vectors do not need to be of the same size.</p>
</td></tr>
<tr><td><code id="multi_marginal_+3A_costa">costA</code></td>
<td>
<p>An array where the entry (i1,i2,...,iN) specifies the value of the cost functional for the point i1 in the first measure, i2 in the second measure
and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries. The first entry contains the optimal multicoupling in array form, and the second entry contains 
the cost of the optimal solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W&lt;-list(rep(1,10),rep(1,10),rep(1,10))
C&lt;-array(runif(10^3),c(10,10,10))
MM&lt;-multi_marginal(W,C)
</code></pre>

<hr>
<h2 id='plotGeodesic'>Plot previously computed Wasserstein geodesics</h2><span id='topic+plotGeodesic'></span>

<h3>Description</h3>

<p>This function generates either a sequence of images or a gif displaying the input optimal transport geodesic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGeodesic(
  Geodesic,
  method = "default",
  images = FALSE,
  gif = FALSE,
  File = "Geodesic",
  resolution = c(400, 400),
  dotsize = 2,
  gridsize = c(100, 100),
  out.col = grey(0:1000/1000),
  splitrange = c(1, 1),
  turn = FALSE,
  phi = 40,
  theta = 40,
  fps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGeodesic_+3A_geodesic">Geodesic</code></td>
<td>
<p>A list of measures in R^2 or R^3 corresponding to the discretized time steps of the geodesic. 
Each entry in the list must be one of the following: a <a href="transport.html#topic+pp-object">pp-object</a>; a <a href="transport.html#topic+wpp-object">wpp-object</a>; or a list containing an entry named 'positions' that is an Mxd matrix.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_method">method</code></td>
<td>
<p>A string specifying the method used to plot each measure. The input &quot;default&quot; generates a scatterplot where the size of each point corresponds to its mass.
The input &quot;bin&quot; maps the data to a grid of prespecified size to plot it as an image. The input &quot;binSplit&quot; also maps the data to a grid, but afterwards the mass of each
pixel is split between all pixels in a specified range. This generates smoother output images.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_images">images</code></td>
<td>
<p>A boolean specifying whether image files should be generated.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_gif">gif</code></td>
<td>
<p>A boolean specifying whether a gif should be generated. To use this option the ImageMagick software and the <a href="magick.html#topic+magick">magick</a> R package need to be installed. 
(see https://cran.r-project.org/web/packages/magick/vignettes/intro.html for details and instructions.)</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_file">File</code></td>
<td>
<p>A string specifying the prefix of all generated files.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_resolution">resolution</code></td>
<td>
<p>A vector with two elements specifying the resolution of the output images.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_dotsize">dotsize</code></td>
<td>
<p>A positive number working as a multiplier on the size of the dots in the output generated by the default method.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_gridsize">gridsize</code></td>
<td>
<p>A vector with two elements specifying the size of the grid used for &quot;bin&quot; and &quot;binSplit&quot;.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_out.col">out.col</code></td>
<td>
<p>A colour vector, specifying the colour scheme used in the call of the image function when plotting the output of the &quot;bin&quot; and &quot;binSplit&quot; methods.
See the documentation of the image function for more details.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_splitrange">splitrange</code></td>
<td>
<p>A vector of two positive integers specifying the number of pixels the mass of a point is shared with in the &quot;binSplit&quot; method. 
The first entry controls the horizontal direction and the second controls the vertical direction.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_turn">turn</code></td>
<td>
<p>A boolean specifying whether the image should be rotated to account for the output of the image function.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_phi">phi</code></td>
<td>
<p>A number specifying the viewing direction in the three dimensional method. It gives the colatitude of the plot.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_theta">theta</code></td>
<td>
<p>A number specifying the viewing direction in the three dimensional setting. It gives the azimuthal direction of the plot.</p>
</td></tr>
<tr><td><code id="plotGeodesic_+3A_fps">fps</code></td>
<td>
<p>A positive number specifying the number of frames per second in the output gif.  The default adjusts the fps to output a gif file of length 10 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not provide any return value, but instead generates output files in the current working directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#2D-Example:
library(transport)
set.seed(420)
N&lt;-2
supp.size&lt;-10^2
L&lt;-sqrt(supp.size)
d&lt;-2
data.list&lt;-vector("list",N)
image.list&lt;-vector("list",N)
for (i in 1:N){
  t.vec&lt;-seq(0,2*pi,length.out=supp.size)
  pos&lt;-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))
  theta&lt;-runif(1,0,2*pi)
  rotation&lt;-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
  pos&lt;-pos%*%rotation
  pos&lt;-pos+1
  pos&lt;-pos/2
  W&lt;-rep(1/supp.size,supp.size)
  data.list[[i]]&lt;-transport::wpp(pos,W)
}
Geo&lt;-geodesic_pos(data.list[[1]],data.list[[2]],2,seq(0,1,0.1))
## Set the image and/or gif flags to TRUE to run the example. 
## CRAN policy prevents examples from generating files in the working directory,
## so this had to be disabled.
plotGeodesic(Geo,File="TestGeodesicDefault",images=FALSE,gif=FALSE)
plotGeodesic(Geo,method="bin",File="TestGeodesicDefaultBin",images=FALSE,gif=FALSE)
plotGeodesic(Geo,method="binSplit",File="TestGeodesicDefaultBinSPlit",
images=FALSE,gif=FALSE)

#3D-Example:
#Functions to build the example measures
gen_torus&lt;-function(M,R,r){
 theta&lt;-seq(0,2*pi,length.out=M)
 phi&lt;-seq(0,2*pi,length.out=M)
 G&lt;-expand.grid(theta,phi)
 x&lt;-(R+r*cos(G[,1]))*cos(G[,2])
 y&lt;-(R+r*cos(G[,1]))*sin(G[,2])
 z&lt;-r*sin(G[,1])
 return(cbind(x,y,z))
}
sq_norm&lt;-function(v){
 return(sqrt(sum(v^2)))
}
normalize&lt;-function(v){
 return(v/(sq_norm(v)))
}
rotate3D&lt;-function(pos,axis,angle){
 R&lt;-matrix(0,3,3)
 R[1]&lt;-cos(angle)+axis[1]^2*(1-cos(angle))
 R[2]&lt;-axis[1]*axis[2]*(1-cos(angle))+axis[3]*sin(angle)
 R[3]&lt;-axis[3]*axis[1]*(1-cos(angle))-axis[2]*sin(angle)
 R[4]&lt;-axis[1]*axis[2]*(1-cos(angle))-axis[3]*sin(angle)
 R[5]&lt;-cos(angle)+axis[2]^2*(1-cos(angle))
 R[6]&lt;-axis[2]*axis[3]*(1-cos(angle))+axis[1]*sin(angle)
 R[7]&lt;-axis[1]*axis[3]*(1-cos(angle))+axis[2]*sin(angle)
 R[8]&lt;-axis[2]*axis[2]*(1-cos(angle))-axis[1]*sin(angle)
 R[9]&lt;-cos(angle)+axis[3]^2*(1-cos(angle))
 return(t(diag(c(2,3,1))%*%(R%*%t(pos))))
}
## Example
set.seed(123)
M&lt;-40
U&lt;-runif(1,0.5,1)
Torus&lt;-gen_torus(M,U,min(U/2,runif(1)))
v&lt;-normalize(runif(3))
Torus&lt;-rotate3D(Torus,v,runif(1,0,2*pi))
Torus1&lt;-Torus%*%diag(runif(3,1,3))
U&lt;-runif(1,0.5,1)
Torus&lt;-gen_torus(M,U,min(U/2,runif(1)))
v&lt;-normalize(runif(3))
Torus&lt;-rotate3D(Torus,v,runif(1,0,2*pi))
Torus2&lt;-Torus%*%diag(runif(3,1,3))
L&lt;-length(Torus)/3
Torus1&lt;-transport::wpp(Torus1,rep(1/L,L))
Torus2&lt;-transport::wpp(Torus2,rep(1/L,L))
geo&lt;-geodesic_pos(Torus1,Torus2,p=2,seq(0,1,0.1))
## Set the image and/or gif flags to TRUE to run the example. 
## CRAN policy prevents examples from generating files in the working directory,
## so this had to be disabled.
plotGeodesic(geo,File="3dGeodesic",images=FALSE,gif=FALSE)

</code></pre>

<hr>
<h2 id='smear'>Split the values of entries in a matrix between a specified area round it.</h2><span id='topic+smear'></span>

<h3>Description</h3>

<p>Takes a matrix M and splits the value of the matrix at a given coordinate (i,j) with a rectangle of 
positions around it given by r1 and r2. The position (i,j) will get its previous value divided by (r1 x r2) and the 
surrounding positions (r1 in horizontal and r2 in vertical direction) will have their entries increased by the same value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smear(M, r1, r2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smear_+3A_m">M</code></td>
<td>
<p>A matrix with real numbers as entries.</p>
</td></tr>
<tr><td><code id="smear_+3A_r1">r1</code></td>
<td>
<p>Integer specifying the range of the split in the horizontal direction.</p>
</td></tr>
<tr><td><code id="smear_+3A_r2">r2</code></td>
<td>
<p>Integer specifying the range of the split in the vertical direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as M, which had the mass split applied to all entries simultaneously.
</p>

<hr>
<h2 id='wasserstein_bary'>Compute Wasserstein barycenters</h2><span id='topic+wasserstein_bary'></span>

<h3>Description</h3>

<p>This function computes the Wasserstein barycenter of a list of suitable objects and returns the barycenter in a prespecified form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein_bary(
  data.list,
  frechet.weights = NULL,
  method = "alternating",
  return_type = "wpp",
  supp.size = NULL,
  output.supp = NULL,
  shared = FALSE,
  sample.size = NULL,
  maxIter = 10,
  weights_maxIter = 100,
  pos_maxIter = 100,
  stepsize = 0.1,
  thresh = 10^(-12),
  regular = 10^-3,
  warmstart = TRUE,
  warmstartlength = 2,
  showIter = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_bary_+3A_data.list">data.list</code></td>
<td>
<p>A list of objects of which the barycenter should be computed. Each element should be one of the following:
A matrix, representing an image; A path to a file containing an image; 
A <a href="transport.html#topic+wpp-object">wpp-object</a>; 
A <a href="transport.html#topic+pp-object">pp-object</a>;
A list containing an entry named 'positions' with the support of the measure and an entry named 'weights' containing the weights of the support points;
A list containing en entry named 'positions&ldquo; specifying the support of a measure with uniform weights.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_frechet.weights">frechet.weights</code></td>
<td>
<p>A real vector summing to 1, specifying the weights in the Frechet functional.  Should be of the same length as data.list.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_method">method</code></td>
<td>
<p>A string specifiying the method to be used. This also determines which of the other parameters are active/used in this function call. See details
for the specific methods currently available.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_return_type">return_type</code></td>
<td>
<p>A string specifying the format of the output. The currently available options are &quot;default&quot; (which gives list with entries 'positions' and 'weights');
&quot;wpp&quot;- which gives a <a href="transport.html#topic+wpp-object">wpp-object</a>; and &quot;image_mat&quot; for a matrix of the same dimensions as the input matrices (only for the regular method).</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_supp.size">supp.size</code></td>
<td>
<p>A positive integer specifying the size of the support used to approximate the barycenter in the &quot;alternating&quot; method.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_output.supp">output.supp</code></td>
<td>
<p>An Mxd matrix specifying the support set on which the optimal weights of the barycenter should be approximated when method = &quot;fixed_support&quot;. Each row of the matrix represents one support point in R^d.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_shared">shared</code></td>
<td>
<p>A boolean flag specifying whether all measures have the same support set and the weights of the barycenter should be optimised over this set as well.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_sample.size">sample.size</code></td>
<td>
<p>A positive integer specifying the number of samples drawn in the stochastic approximation of the barycenter for method &quot;sampling&quot;.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_maxiter">maxIter</code></td>
<td>
<p>A positive integer specifyng the maximum number of &quot;outer&quot; iterations. The full number of iteration steps performed is 
maxIter * (weights_maxIter+pos_maxIter).</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_weights_maxiter">weights_maxIter</code></td>
<td>
<p>A positive integer specifying the maximum number of iterations on the weights of the barycenter.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_pos_maxiter">pos_maxIter</code></td>
<td>
<p>A positive integer specifying the maximum number of iterations on the support of the barycenter.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_stepsize">stepsize</code></td>
<td>
<p>A positive number specifying the stepsize in the position iterations.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_thresh">thresh</code></td>
<td>
<p>A positive number specifying the minimal amount of change between iterations, which does not cause the algorithm to terminate.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_regular">regular</code></td>
<td>
<p>A positive number specifying the regularisation parameter in the &quot;regular&quot; method.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_warmstart">warmstart</code></td>
<td>
<p>A boolean specifying whether the algorithm should use a warmstart based on a stochastic subgradient descent.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_warmstartlength">warmstartlength</code></td>
<td>
<p>A positive integer specifying the length of the warmstart. The number of steps in the SGD in the warmstart is 'length(data.list)*warmstartlength'.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_showiter">showIter</code></td>
<td>
<p>A boolean specifying whether the number of &quot;outer&quot; iterations performed should be shown at the end.</p>
</td></tr>
<tr><td><code id="wasserstein_bary_+3A_threads">threads</code></td>
<td>
<p>A positive integer specifying the number of threads used for parallel computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of this package.  It computes/approximates 2-Wasserstein barycenters using the different methods outlined in the following. <br />
&quot;lp&quot;. Here the barycenter problem can be posed as a linear program. This method builds and solves this linear program. While this gives exact
solutions to the problem, this method is highly run-time extensive and should only be used on small datasets. (See Anderes et al. (2016) and Borgwardt &amp; Patterson (2020) for details). <br />
&quot;regular&quot;. This method solves the entropy-regularised fixed support barycenter problem. Here, a penalisation term is introduced to the problem, which 
yields a strictly convex problem that can be solved with Sinkhorn's algorithm (for details see Benamou et al. (2015)). Additionally, it is 
assumed that all the measures have the same support set, and instead of an exact (regularised) barycenter, the methods finds the best solution
having the same support as the data. This is quite reasonable when the dataset consists of images and the barycenter should be an image as well.  The choice of the
regularisation parameter &quot;regular&quot; is a delicate issue. Large values reduce the runtime, but yield &quot;blurry&quot; barycenters.  Small values
yield sharper results, but have longer run-time and may cause numerical instabilities. The choice of this parameter depends on the dataset at hand,
and will typically require tuning. <br />
&quot;fixed_support&quot;. This method computes the best approximation of the barycenter, which is supported on a pre-specified support set (as supplied by the parameter &quot;output.support&quot;). Contrary to the &quot;regular&quot;
method, here this set does not need to coincide with any of the support sets of the data measures.  See Cuturi &amp; Doucet (2014) for details. <br />
&quot;alternating&quot;. This method computes the best approximation of the barycenter with a certain support size. It alternates between finding the best positions
for given weights and then finding the best weights for these positions. See Cuturi and Doucet (2014) for details. <br />
&quot;sampling&quot;. This method uses the SUA method of Heinemann et al. (2020) to generate a stochastic approximation of the barycenter.  It 
replaces the original measures by empirical measures obtained from samples of size 'sample.size' from each data measure.<br />
The unregularised optimal transport problems, which need to be solved for the iterative methods, without regularisation, in each iteration step, are solved using
a fast network simplex implementation (which is a modification of the LEMON Library by Nicolas Bonneel).
</p>


<h3>References</h3>

<p>E Anderes, S Borgwardt, and J Miller (2016). Discrete Wasserstein barycenters: 
Optimal transport for discrete data. Mathematical Methods of Operations Research, 84(2):389-409. <br />
S Borgwardt and S Patterson (2020). Improved linear programs for discrete barycenters.
Informs Journal on Optimization 2(1):14-33.<br />
J-D Benamou, G Carlier, M Cuturi, L Nenna, and G Peyré (2015). 
Iterative Bregman projections for regularized transportation problems. SIAM Journal on Scientific Computing 37(2):A1111-A1138. <br />
M Cuturi and A Doucet (2014). Fast Computation of Wasserstein Barycenters. Proceedings of the 31st International Conference on Machine Learning, PMLR 32(2):685-693. <br />
F Heinemann, A Munk, and Y Zemel (2020). Randomised Wasserstein barycenter computation: Resampling with statistical guarantees. arXiv preprint.<br />
N. Bonneel (2018). Fast Network Simplex for Optimal Transport. <br /> Github repository, nbonneel/network_simplex. <br />
N. Bonneel, M. van de Panne, S. Paris and W. Heidrich (2011). Displacement interpolation using Lagrangian mass transport. ACM Transactions on Graphics (SIGGRAPH ASIA 2011) 30(6).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Basic Examples
#build list
K&lt;-1
N&lt;-4*K
M&lt;-9
d&lt;-2
data.list&lt;-vector("list",N)

###image_mat
for (i in 1:K){
  U&lt;-runif(M)
  U&lt;-U/sum(U)
  data.list[[i]]&lt;-matrix(U,sqrt(M))
}

#wpp
for (i in (K+1):(2*K)){
  U&lt;-runif(M)
  U&lt;-U/sum(U)
  pos&lt;-matrix(runif(d*M),M,d)
  data.list[[i]]&lt;-transport::wpp(pos,U)
}

#point pattern
for (i in (2*K+1):(3*K)){
  pos&lt;-matrix(runif(d*M),M,d)
  data.list[[i]]&lt;-list(positions=pos)
}

#weighted point pattern

for (i in (3*K+1):(4*K)){
  U&lt;-runif(M)
  U&lt;-U/sum(U)
  pos&lt;-matrix(runif(d*M),M,d)
  data.list[[i]]&lt;-list(positions=pos,weights=U)
}

system.time(res1&lt;-wasserstein_bary(data.list,return_type = "wpp",method="lp"))
frechet_func(res1,data.list)

system.time(res2&lt;-wasserstein_bary(data.list,return_type = "wpp",method="alternating",
supp.size = M*N-N+1,warmstartlength = 3,pos_maxIter = 100,weights_maxIter = 100))
frechet_func(res2,data.list)

system.time(res3&lt;-wasserstein_bary(data.list,return_type = "wpp",
method="fixed_support",warmstartlength = 3,weights_maxIter = 100,output.supp = res1$coordinates))
frechet_func(res3,data.list)
system.time(res4&lt;-wasserstein_bary(data.list,return_type = "wpp",
method="sampling",sample.size=8,warmstartlength = 3,pos_maxIter = 100))
frechet_func(res4,data.list)

##Visual Examples
###ellipses
set.seed(420)
N&lt;-20
supp.size&lt;-10^2
L&lt;-sqrt(supp.size)
d&lt;-2
data.list&lt;-vector("list",N)
image.list&lt;-vector("list",N)
for (i in 1:N){
  t.vec&lt;-seq(0,2*pi,length.out=supp.size)
  pos&lt;-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))
  theta&lt;-runif(1,0,2*pi)
  rotation&lt;-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
  pos&lt;-pos%*%rotation
  pos&lt;-pos+1
  pos&lt;-pos/2
  W&lt;-rep(1/supp.size,supp.size)
  data.list[[i]]&lt;-transport::wpp(pos,W)
  I&lt;-bin2d(data.list[[i]]$coordinates,data.list[[i]]$mass,c(L*2,L*2))
  I&lt;-smear(I,1,1)
  I&lt;-I/sum(I)
  image.list[[i]]&lt;-I
}

system.time(res1&lt;-wasserstein_bary(data.list,return_type = "wpp",method="alternating"
,supp.size = supp.size,warmstartlength = 0,pos_maxIter = 10,weights_maxIter = 10,maxIter = 10))
plot(res1)
system.time(res2&lt;-wasserstein_bary(data.list,return_type = "wpp",
method="fixed_support",warmstartlength = 0,weights_maxIter = 50,maxIter=1,
output.supp = grid_positions(2*L,2*L)))
plot(res2)
system.time(res3&lt;-wasserstein_bary(data.list,return_type = "wpp",method="sampling",
sample.size=400,warmstartlength = 0,pos_maxIter = 100,stepsize = 1,maxIter=1))
plot(res3)

system.time(res4&lt;-wasserstein_bary(image.list,return_type = "wpp",
method="regular",stepsize = 1,weights_maxIter = 50))
plot(res4)
system.time(res5&lt;-wasserstein_bary(image.list,return_type = "wpp",
method="fixed_support",shared=TRUE,warmstartlength = 0,weights_maxIter = 50,maxIter=1,
output.supp = grid_positions(2*L,2*L)))
plot(res5)

</code></pre>

<hr>
<h2 id='ws_bary_maaipm'>Solves the 2-Wasserstein Barycenter problem between N probability measures on R^d using an interior point method.</h2><span id='topic+ws_bary_maaipm'></span>

<h3>Description</h3>

<p>This is a wrapper function for multiple methods to solve the 2-Wasserstein barycenter problem. It 
contains three methods:
&quot;fixed&quot;: This function finds the best approximation of the 2-Wasserstein barycenter problem of N finitely supported input
measures on a given support set using a modified MAAIPM algorithm to solve the corresponding linear program. 
&quot;free&quot;: This functions finds an approximation of the 2-Wasserstein barycenter using the MAAIPM method by
alternating between updating weights and positions of a candidate barycenter.
&quot;multiscale&quot;: This finds the best approximation of the 2-Wasserstein barycenter problem of N finitely supported input
measures by using a multi-scale version of a modified MAAIPM method. Given a starting grid it solves the fixed support 
2-Wasserstein barycenter problem on this grid. Then, the grid is refined, by splitting each grid point into 4 new ones.
Afterwards, all grids points below a certain threshold of mass are removed from the support. This procedure is repeated
until a prespecified resolution is reached. Note, the generated grids are assumed to be in [0,1]^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ws_bary_maaipm(
  data.list,
  method = "fixed",
  support,
  wmaxIter,
  pmaxIter,
  return_type = "default",
  thresh = 10^-3,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ws_bary_maaipm_+3A_data.list">data.list</code></td>
<td>
<p>A list of objects from which the barycenter should be computed. Each element should be one of the following:
A matrix, representing an image; A path to a file containing an image; 
A <a href="transport.html#topic+wpp-object">wpp-object</a>; 
A list containing an entry named 'positions' with the support of the measure and an entry named 'weights' containing the weights of the support points;
A list containing en entry named 'positions&ldquo; specifying the support of a measure with uniform weights.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_method">method</code></td>
<td>
<p>A string determining which method is used. The available options &quot;fixed&quot;, &quot;free&quot; and &quot;multiscale&quot;
are described above.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_support">support</code></td>
<td>
<p>The role of this parameter changes depending of the method used.
&quot;fixed&quot;: This is a d x M matrix containing the positions of the fixed-support of the barycenter in R^d.
&quot;free&quot;: This is a d x M matrix containing the initial positions of the barycenter approximation.
&quot;multiscale&quot;: A vector with four entries. The first two are integers giving the resolution of the initial grid.
The third entry is another integer specifying how many times the grid should be refined. The fourth entry is
a real number specifying the threshold under which mass is considered to be zero.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_wmaxiter">wmaxIter</code></td>
<td>
<p>An integer specifying the maximum number of weight iterations to be performed.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_pmaxiter">pmaxIter</code></td>
<td>
<p>An integer specifying the maximum number of weight iterations to be performed for the &quot;free&quot;-
method.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_return_type">return_type</code></td>
<td>
<p>A string specifying the format in which the barycenter should be returned. For all methods
the options &quot;default&quot; (giving a list with an entry 'positions' containing the support of the barycenter
and an entry 'weights' containing the weights of the barycenter) and &quot;wpp&quot; (giving a <a href="transport.html#topic+wpp-object">wpp-object</a>)
are available. Additionally, for the &quot;fixed&quot; method there is the type &quot;vec&quot; which returns a vector of length
M, containing the weights of the barycenter on the given support and for the &quot;multiscale&quot; method there is the 
option &quot;mat&quot; which returns the barycenter in matrix form on a grid of the final resolution.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_thresh">thresh</code></td>
<td>
<p>A real number specifying a stopping criterion based on the magnitude of change between consecutive 
iterations. If one encounters numerical instabilities in the computations in the form of either returned NaNs
or warnings notifying the user about near singular matrices, this parameter can be increased to avoid this.</p>
</td></tr>
<tr><td><code id="ws_bary_maaipm_+3A_threads">threads</code></td>
<td>
<p>An integer specifying the number of threads used for computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For details on the returned value refer to the parameter return_type.
</p>


<h3>References</h3>

<p>Ge, DongDong, et al. &quot;Interior-Point Methods Strike Back: Solving the Wasserstein Barycenter Problem.&quot; 
Advances in Neural Information Processing Systems 32 (2019): 6894-6905.
Kantorovich-Rubinstein distance and barycenter for finitely supported measures: Foundations and Algorithms; Heinemann, Klatt and Munk; https://arxiv.org/pdf/2112.03581.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a dataset consisting of measures supported on discretized nested ellipses.
N&lt;-5 #The number of measures generated
M&lt;-20 #The number of points each ellipse is discretized into
C&lt;-2 #The parameter of the Kantorovich-Rubinstein distance
data.list&lt;-vector("list",N)
set.seed(42)
ell.num&lt;-3 #The  number of ellipses in each measure.
#This loop actually generates the measures for the example.
for (i in 1:N){
  pos.full&lt;-matrix(0,0,2)
  nesting.depth&lt;-ell.num
  for (k in 1:nesting.depth){
    t.vec&lt;-seq(0,2*pi,length.out=M)
    pos&lt;-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))/(3^(k-1)) 
    theta&lt;-runif(1,0,2*pi)
    rotation&lt;-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
    pos.full&lt;-rbind(pos.full,pos%*%rotation)
  }
  W&lt;-rep(1,M*nesting.depth)
  W&lt;-W/sum(W)
  data.list[[i]]&lt;-transport::wpp((pos.full+1)/2,W)
}
#Using the multiscale method
system.time(bary.ms&lt;-WSGeometry::ws_bary_maaipm(data.list,method="multiscale",
support=c(8,8,3,10^-4),wmaxIter=100,return_type="mat",thresh=6*10^-4,threads=1))

#Using the fixed support method
support&lt;-t(WSGeometry::grid_positions(20,20))
system.time(bary.fixed&lt;-WSGeometry::ws_bary_maaipm(data.list,method="fixed",
support=support,wmaxIter=100,return_type="wpp",thresh=6*10^-4,threads=1))
#Using the free support method
support&lt;-t(WSGeometry::grid_positions(8,8))
system.time(bary.free&lt;-WSGeometry::ws_bary_maaipm(data.list,method="free",
support=support,wmaxIter=100,pmaxIter=25,return_type="wpp",thresh=6*10^-4,threads=1))

#The outputs can be conveniently visualised using the image function for the "mat" output
#and the plot-method for the wpp-objects provided by the transport package.
image(bary.ms)
plot(bary.fixed)
plot(bary.free)

</code></pre>

<hr>
<h2 id='ws_dist'>Compute the p-Wasserstein distance between two measures</h2><span id='topic+ws_dist'></span>

<h3>Description</h3>

<p>This is essentially a wrapper function of <a href="transport.html#topic+transport">transport</a>. It has the advantage of allowing 
more general input objects, such as images or matrices, without the user having to manually convert these objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ws_dist(A, B, p = 2, sampling = FALSE, S = NULL, R = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ws_dist_+3A_a">A</code></td>
<td>
<p>One of the following: A matrix, representing an image;
A file name containing an image; A <a href="transport.html#topic+wpp-object">wpp-object</a>.</p>
</td></tr>
<tr><td><code id="ws_dist_+3A_b">B</code></td>
<td>
<p>One of the following: A matrix, representing an image;
A file name containing an image; A <a href="transport.html#topic+wpp-object">wpp-object</a>.</p>
</td></tr>
<tr><td><code id="ws_dist_+3A_p">p</code></td>
<td>
<p>A positive real number specifying the power of the Wasserstein distance.</p>
</td></tr>
<tr><td><code id="ws_dist_+3A_sampling">sampling</code></td>
<td>
<p>A boolean specifying whether a stochastic approximation (Sommerfeld et al., 2019) should be used to approximate the distance.</p>
</td></tr>
<tr><td><code id="ws_dist_+3A_s">S</code></td>
<td>
<p>A positive integer specifying the number of samples drawn in the stochastic approximation.</p>
</td></tr>
<tr><td><code id="ws_dist_+3A_r">R</code></td>
<td>
<p>The number of repetitions averaged over in the stochastic approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number specifying the computed p-Wasserstein distance.
</p>


<h3>References</h3>

<p>M Sommerfeld, J Schrieber, Y Zemel, and A Munk (2019).
Optimal transport: Fast probabilistic approximations with exact solvers.  Journal of Machine Learning Research 20(105):1&ndash;23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1&lt;-transport::random32a$mass
P2&lt;-transport::random32b$mass
P1&lt;-P1/sum(P1)
P2&lt;-P2/sum(P2)
ws_dist(P1,P2)
</code></pre>

<hr>
<h2 id='ws_logpca'>Computes Wasserstein principal components</h2><span id='topic+ws_logpca'></span>

<h3>Description</h3>

<p>Computes principal components in the 2-Wasserstein Space for a dataset of weighted point measures in R^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ws_logpca(data.list, barycenter, pca.count, steps_number = 21)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ws_logpca_+3A_data.list">data.list</code></td>
<td>
<p>A list of objects of which the principal components should be computed. Each element should be one of the following:
A matrix, representing an image; A file name containing an image; 
A <a href="transport.html#topic+wpp-object">wpp-object</a>; 
A <a href="transport.html#topic+pp-object">pp-object</a>;
A list containing an entry 'positions' with the support of the measure and an entry 'weights' containing the weights of the support points;
A list containing en entry 'positions' specifying the support of a measure with uniform weights.</p>
</td></tr>
<tr><td><code id="ws_logpca_+3A_barycenter">barycenter</code></td>
<td>
<p>A barycenter of the dataset. See data.list for possible object types.</p>
</td></tr>
<tr><td><code id="ws_logpca_+3A_pca.count">pca.count</code></td>
<td>
<p>An integer specifying the number of principal components to be computed.</p>
</td></tr>
<tr><td><code id="ws_logpca_+3A_steps_number">steps_number</code></td>
<td>
<p>An integer specifying the number of discretisation steps for the output of the principal components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the principal components of a dataset consisting of weighted point measures in R^2.
To do this it first maps the data to the tangent space at the barycenter and then performs standard Euclidean PCA on this space.
Afterwards the resulting components are mapped back to the 2-Wasserstein space.
</p>


<h3>Value</h3>

<p>A list with two entries. The first contains a list (of length pca.count), where each entry is a list of <a href="transport.html#topic+wpp-object">wpp-object</a>s specifying one point on the corresponding principal
component. The second entry is a vector containing the eigenvalues of the computed principal components. The output can be plotted by applying
<a href="#topic+plotGeodesic">plotGeodesic</a> to each component of the list.
</p>


<h3>References</h3>

<p>E Cazelles, V Seguy, J Bigot, M Cuturi, and N Papadakis (2017); Log-PCA versus Geodesic PCA of histograms 
in the Wasserstein space. SIAM Journal on Scientific Computing 40(2):B429–B456. <br />
W Wei, D Slepcev, S Basu, JA Ozolek, and GK Rohde (2013). A Linear Optimal Transportation Framework for Quantifying and Visualizing Variations in Sets of Images. International Journal of Computer Vision 101(2):254-269.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2020)
N&lt;-20
supp.size&lt;-10^2
L&lt;-sqrt(supp.size)
d&lt;-2
data.list&lt;-vector("list",N)
image.list&lt;-vector("list",N)
for (i in 1:N){
  t.vec&lt;-seq(0,2*pi,length.out=supp.size)
  pos&lt;-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))
  theta&lt;-runif(1,0,2*pi)
  rotation&lt;-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
  pos&lt;-pos%*%rotation
  pos&lt;-pos+1
  pos&lt;-pos/2
  W&lt;-rep(1/supp.size,supp.size)
  data.list[[i]]&lt;-transport::wpp(pos,W)
}

res1&lt;-wasserstein_bary(data.list,return_type = "wpp",method="alternating",
supp.size = supp.size,warmstartlength = 2,pos_maxIter = 50,
weights_maxIter = 0,maxIter = 1,stepsize=1)
pcomps&lt;-ws_logpca(data.list,res1,3)
## Set the image and/or gif flags to TRUE to run the example. 
## CRAN policy prevents examples from generating files in the working directory,
## so this had to be disabled.
plotGeodesic(pcomps$components[[1]],File="PCA1",images=FALSE,gif=FALSE)
plotGeodesic(pcomps$components[[2]],File="PCA2",images=FALSE,gif=FALSE)
plotGeodesic(pcomps$components[[3]],File="PCA3",images=FALSE,gif=FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
