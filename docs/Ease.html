<!DOCTYPE html><html><head><title>Help for package Ease</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Ease}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alleleFreqMatGeneration'><p>Generation of the matrix for calculating allelic frequencies</p></a></li>
<li><a href='#areThereHomoz'><p>Are there any allelic combinations including homozygosity</p></a></li>
<li><a href='#catn'><p>Concatenate, print and line break</p></a></li>
<li><a href='#check.genome'><p>The validity check for the <code>Genome</code> class</p></a></li>
<li><a href='#check.metapopulation'><p>The validity check for the <code>Metapopulation</code> class</p></a></li>
<li><a href='#check.mutationMatrix'><p>The validity check associated with the <code>MutationMatrix</code> class</p></a></li>
<li><a href='#check.population'><p>The validity check for the <code>Population</code> class</p></a></li>
<li><a href='#check.selection'><p>The validity check for the <code>Selection</code> class</p></a></li>
<li><a href='#extractAlleleComb'><p>Extract the allele combination</p></a></li>
<li><a href='#Genome-class'><p><code>Genome</code> class</p></a></li>
<li><a href='#genotyping'><p>Genotyping</p></a></li>
<li><a href='#getCustomOutput'><p>Getting the custom output</p></a></li>
<li><a href='#getRecords'><p>Getting the simulation results</p></a></li>
<li><a href='#getResults'><p>Getting the simulation results</p></a></li>
<li><a href='#haploCrossMatrix'><p>Haplotype crossing matrix generation</p></a></li>
<li><a href='#haplotyping'><p>Haplotyping</p></a></li>
<li><a href='#IDgenomeGeneration'><p>Genome identifier</p></a></li>
<li><a href='#IDgenotypeGeneration'><p>Genotype identifier</p></a></li>
<li><a href='#IDhaplotypeGeneration'><p>Haplotype identifier</p></a></li>
<li><a href='#initialize,Genome-method'><p>Initialize method for the <code>Genome</code> class</p></a></li>
<li><a href='#initialize,Metapopulation-method'><p>Initialize method for the <code>Metapopulation</code> class</p></a></li>
<li><a href='#initialize,MutationMatrix-method'><p>Initialize method for the <code>MutationMatrix</code> class</p></a></li>
<li><a href='#initialize,Population-method'><p>Initialize method for the <code>Population</code> class</p></a></li>
<li><a href='#initialize,Selection-method'><p>Initialize method for the <code>Selection</code> class</p></a></li>
<li><a href='#is.correct.transition.matrix'><p>Test if a matrix is a correct transition matrix</p></a></li>
<li><a href='#is.default.matrix'><p>Test if a matrix is a default matrix</p></a></li>
<li><a href='#is.probability.matrix'><p>Test if a matrix is of probability</p></a></li>
<li><a href='#isAffected'><p>Is this haplo/geno-type affected ?</p></a></li>
<li><a href='#isHaploSelectFormula'><p>Are there any allelic combinations including homozygosity</p></a></li>
<li><a href='#listing'><p>Listing for display</p></a></li>
<li><a href='#meiosisMatrix'><p>Meiosis matrix generation</p></a></li>
<li><a href='#METAPOP_SIMULATION'><p>Simulation of a metapopulation</p></a></li>
<li><a href='#Metapopulation-class'><p>Metapopulation</p></a></li>
<li><a href='#mutation'><p>Definition of a mutation</p></a></li>
<li><a href='#MutationMatrix-class'><p>Mutation matrix</p></a></li>
<li><a href='#mutMatFriendly'><p>Individual mutation definition to allelic mutation matrices</p></a></li>
<li><a href='#mutMatRates'><p>Mutation matrix from rates</p></a></li>
<li><a href='#outFunct'><p>Custom output function</p></a></li>
<li><a href='#Population-class'><p>Population</p></a></li>
<li><a href='#print,Genome-method'><p>Print method for the <code>Genome</code> class</p></a></li>
<li><a href='#print,Metapopulation-method'><p>Print method for the <code>Metapopulation</code> class</p></a></li>
<li><a href='#print,MutationMatrix-method'><p>Print method for the <code>MutationMatrix</code> class</p></a></li>
<li><a href='#print,Population-method'><p>Print method for the <code>Population</code> class</p></a></li>
<li><a href='#print,Selection-method'><p>Print method for the <code>Selection</code> class</p></a></li>
<li><a href='#recombinationMatrix'><p>Recombination matrix generation</p></a></li>
<li><a href='#rowResultGen'><p>Processing a result (or record) list</p></a></li>
<li><a href='#selectFormIntoVect'><p>Conversion of selection formulas</p></a></li>
<li><a href='#selectInputTreatment'><p>Treatment of selection formulas</p></a></li>
<li><a href='#Selection-class'><p><code>Selection</code> class</p></a></li>
<li><a href='#selection.form.treatment'><p>Treatment of a selection formula</p></a></li>
<li><a href='#setGenome'><p>Setting the genome</p></a></li>
<li><a href='#setMetapopulation'><p>Setting a metapopulation</p></a></li>
<li><a href='#setMutationMatrix'><p>Setting the mutation matrix</p></a></li>
<li><a href='#setPopulation'><p>Setting a population</p></a></li>
<li><a href='#setSelectNeutral'><p>Setting the selection</p></a></li>
<li><a href='#setSelectOnGametes'><p>Setting the selection on gametes</p></a></li>
<li><a href='#setSelectOnGametesProd'><p>Setting the selection on gamete production</p></a></li>
<li><a href='#setSelectOnInds'><p>Setting the selection on individuals</p></a></li>
<li><a href='#show,Genome-method'><p>Show method for the <code>Genome</code> class</p></a></li>
<li><a href='#show,Metapopulation-method'><p>Show method for the <code>Metapopulation</code> class</p></a></li>
<li><a href='#show,MutationMatrix-method'><p>Show method for the <code>MutationMatrix</code> class</p></a></li>
<li><a href='#show,Population-method'><p>Show method for the <code>Population</code> class</p></a></li>
<li><a href='#show,Selection-method'><p>Show method for the <code>Selection</code> class</p></a></li>
<li><a href='#simulate,Metapopulation-method'><p>Simulate method for the <code>Metapopulation</code> class</p></a></li>
<li><a href='#whichHomoz'><p>Which alleles are homozygous in the input?</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Explicit Population Genetics Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Ehouarn Le Faou &lt;ehouarnlefaou@orange.fr&gt; [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ehouarn Le Faou &lt;ehouarnlefaou@orange.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation in a simple and efficient way of fully customisable population genetics simulations,
    considering multiple loci that have epistatic interactions. Specifically suited to the modelling of
    multilocus nucleocytoplasmic systems (with both diploid and haploid loci), it is nevertheless possible
    to simulate purely diploid (or purely haploid) genetic models.
	Examples of models that can be simulated with Ease are numerous, for example models of genetic
	incompatibilities as presented by Marie-Orleach et al. (2022) &lt;<a href="https://doi.org/10.1101%2F2022.07.25.501356">doi:10.1101/2022.07.25.501356</a>&gt;.
	Many others are conceivable, although few are actually explored, Ease having been developed
	in particular to provide a solution so that these kinds of models can be simulated simply.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0.7), RcppProgress (&ge; 0.1), stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>RcppExports.R ToolFunctions.R ModelFunctions.R GenomeClass.R
MutationMatrixClass.R SelectionClass.R PopulationClass.R
MetapopulationClass.R UserFunctions.R</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-19 07:44:55 UTC; ehoua</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-07 14:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='alleleFreqMatGeneration'>Generation of the matrix for calculating allelic frequencies</h2><span id='topic+alleleFreqMatGeneration'></span>

<h3>Description</h3>

<p>Generates a matrix that allows to go from genotypic frequencies
to allelic frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alleleFreqMatGeneration(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alleleFreqMatGeneration_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An allele frequency matrix is a matrix with rows equal to the number of
genotypes and columns equal to the number of alleles. By multiplying a
row matrix of genotype frequencies we obtain a row matrix of associated
allele frequencies.
</p>


<h3>Value</h3>

<p>A matrix for calculating allelic frequencies from genotypes
frequencies.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='areThereHomoz'>Are there any allelic combinations including homozygosity</h2><span id='topic+areThereHomoz'></span>

<h3>Description</h3>

<p>Test if there are homozygotes in the specified allelic combinations of
a selection formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areThereHomoz(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areThereHomoz_+3A_formula">formula</code></td>
<td>
<p>a selection formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if there are homozygotes
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='catn'>Concatenate, print and line break</h2><span id='topic+catn'></span>

<h3>Description</h3>

<p>Object output in the same way as the function <a href="base.html#topic+cat">cat</a> but adding
a line break at the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catn(..., file = "", sep = " ", fill = FALSE, labels = NULL, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catn_+3A_...">...</code></td>
<td>
<p>see <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="catn_+3A_file">file</code></td>
<td>
<p>see <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="catn_+3A_sep">sep</code></td>
<td>
<p>see <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="catn_+3A_fill">fill</code></td>
<td>
<p>see <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="catn_+3A_labels">labels</code></td>
<td>
<p>see <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="catn_+3A_append">append</code></td>
<td>
<p>see <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="base.html#topic+cat">cat</a>.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='check.genome'>The validity check for the <code>Genome</code> class</h2><span id='topic+check.genome'></span>

<h3>Description</h3>

<p>The validity check for the <code>Genome</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.genome(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.genome_+3A_object">object</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical corresponding to whether the object is a correct
<code>Genome</code> object.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='check.metapopulation'>The validity check for the <code>Metapopulation</code> class</h2><span id='topic+check.metapopulation'></span>

<h3>Description</h3>

<p>The validity check for the <code>Metapopulation</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.metapopulation(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.metapopulation_+3A_object">object</code></td>
<td>
<p>a <code>Metapopulation</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean corresponding to whether the object is a correct
<code>Metapopulation</code> object.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='check.mutationMatrix'>The validity check associated with the <code>MutationMatrix</code> class</h2><span id='topic+check.mutationMatrix'></span>

<h3>Description</h3>

<p>The validity check associated with the <code>MutationMatrix</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.mutationMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.mutationMatrix_+3A_object">object</code></td>
<td>
<p>an object of class <code>MutationMatrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical corresponding to whether <code>x</code> is a correct
<code>MutationMatrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='check.population'>The validity check for the <code>Population</code> class</h2><span id='topic+check.population'></span>

<h3>Description</h3>

<p>The validity check for the <code>Population</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.population(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.population_+3A_object">object</code></td>
<td>
<p>a <code>Population</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean corresponding to whether the object is a correct
<code>Population</code> object.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='check.selection'>The validity check for the <code>Selection</code> class</h2><span id='topic+check.selection'></span>

<h3>Description</h3>

<p>The validity check for the <code>Selection</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.selection(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.selection_+3A_object">object</code></td>
<td>
<p><code>Selection</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical corresponding to whether the object is a correct
<code>Selection</code> object.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='extractAlleleComb'>Extract the allele combination</h2><span id='topic+extractAlleleComb'></span>

<h3>Description</h3>

<p>Conversion of an allelic combination defined in a selection formula into the
vector listing the alleles present (alleles that must be in the homozygous
state appear 2 times, 1 time for heterozygous).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractAlleleComb(xVect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractAlleleComb_+3A_xvect">xVect</code></td>
<td>
<p>allelic combination extracted from a selection formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of alleles that must be present in the genotype to match
the input allelic combination
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='Genome-class'><code>Genome</code> class</h2><span id='topic+Genome-class'></span>

<h3>Description</h3>

<p>The <code>Genome</code> class allows to define all the characteristics of the
genome which will be used as a basis for the construction of transition
matrices from one generation to another in simulations of the model.
</p>


<h3>Details</h3>

<p>A genome includes the list of all possible haplotypes and genotypes
resulting from the combination of the alleles defined in input.
As the <code>Ease</code> package was originally built for population genetics
simulations including both diploid and haploid loci, it is necessary
that both types of loci are defined. Despite this, the user can define
only diploid or only haploid loci if they wish. If no diploid locus is
defined, one is automatically generated with only one allele, thus not
influencing the simulation. The same applies if no haploid locus is defined.
</p>
<p>Each locus is described by a vector of factors which are the names of
the possible alleles at that locus. All diploid (resp. haploid) loci
thus defined are grouped in a list, called <code>listDipLoci</code> (resp.
<code>listHapLoci</code>). Therefore, a <code>Genome</code> class object has two lists
of loci defined in this way, one for diploid loci, one for haploid loci.
The alleles and loci (diploid and haploid) must all have different
names so that no ambiguity can persist.
</p>
<p>If several are defined, the order of the diploid loci in the list is not
trivial. The rates of two-to-one combinations between them must indeed be
defined by the vector <code>recRate</code>. For example, if three diploid loci
are defined, <code>recRate</code> must be of length 2, the first of its values
defining the recombination rate between the first and second loci, the
second of its values the recombination rate between the second and third
loci. For example, if we want to define two groups of two loci that are
linked to each other but are on two different chromosomes, we can define
a <code>recRate = c(0.1, 0.5, 0.1)</code>. The first two loci are thus relatively
linked (recombination rate of 0.1), as are the last two loci. On the other
hand, the recombination rate of 0.5 between the second and third loci
ensures that the two groups are independent.
</p>


<h3>Slots</h3>


<dl>
<dt><code>listHapLoci</code></dt><dd><p>a list of haploid loci</p>
</dd>
<dt><code>listDipLoci</code></dt><dd><p>a list of diploid loci</p>
</dd>
<dt><code>recRate</code></dt><dd><p>a two-by-two recombination rate vector</p>
</dd>
<dt><code>nbHL</code></dt><dd><p>the number of haploid loci</p>
</dd>
<dt><code>nbDL</code></dt><dd><p>the number of diploid loci</p>
</dd>
<dt><code>listLoci</code></dt><dd><p>the list of all loci</p>
</dd>
<dt><code>haplotypesHL</code></dt><dd><p>haplotypes of haploid loci only</p>
</dd>
<dt><code>haplotypesDL</code></dt><dd><p>haplotypes of diploid loci only</p>
</dd>
<dt><code>haplotypes</code></dt><dd><p>haplotypes of all loci</p>
</dd>
<dt><code>alleles</code></dt><dd><p>the vector of all the alleles</p>
</dd>
<dt><code>nbAlleles</code></dt><dd><p>the number of alleles</p>
</dd>
<dt><code>nbHaplo</code></dt><dd><p>the number of haplotypes</p>
</dd>
<dt><code>IDhaplotypes</code></dt><dd><p>IDs of haplotypes</p>
</dd>
<dt><code>genotypes</code></dt><dd><p>the list of genotypes</p>
</dd>
<dt><code>nbGeno</code></dt><dd><p>the number of genotypes</p>
</dd>
<dt><code>IDgenotypes</code></dt><dd><p>IDs of genotypes</p>
</dd>
<dt><code>IDgenome</code></dt><dd><p>ID of the genome</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='genotyping'>Genotyping</h2><span id='topic+genotyping'></span>

<h3>Description</h3>

<p>Generation of genotypes associated with a <code>Genome</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotyping(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genotyping_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output genotypes are described as a list of three matrices. A
genotype consists of two diploid haplotypes (first two matrices)
and one haploid haplotype (third matrix), which are read at the
same row number on all three matrices.
</p>


<h3>Value</h3>

<p>A list of matrices describing genotypes in rows.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='getCustomOutput'>Getting the custom output</h2><span id='topic+getCustomOutput'></span>

<h3>Description</h3>

<p>Getting the custom output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCustomOutput(metapop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCustomOutput_+3A_metapop">metapop</code></td>
<td>
<p>a <code>Metapopulation</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list generated through the custom result function, if at least
it was specified during the simulation of the <code>Metapopulation</code>.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='getRecords'>Getting the simulation results</h2><span id='topic+getRecords'></span>

<h3>Description</h3>

<p>Getting the simulation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecords(metapop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRecords_+3A_metapop">metapop</code></td>
<td>
<p>a <code>Metapopulation</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each item is associated with a simulation. Each of
these elements consists of a list of data.frames, one per population.
These data.frames consist of the same columns as the results
(see <a href="#topic+getResults">getResults</a> documentation), except that they do not
include the stop conditions.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='getResults'>Getting the simulation results</h2><span id='topic+getResults'></span>

<h3>Description</h3>

<p>Getting the simulation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResults(metapop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResults_+3A_metapop">metapop</code></td>
<td>
<p>a <code>Metapopulation</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame where each line corresponds to a simulation. The
results include :
- the last generation reached (the threshold or the generation that first
verified at least one of the stopping conditions)
- the final population size
- the genotype frequencies
- allelic frequencies
- the reason(s) for the stop (either the threshold was reached, i.e.
<code>unstopped</code> or the stop condition(s) that was (were) reached, in the
form of boolean values
- Average fitness (individual, gamete production and gametic)
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='haploCrossMatrix'>Haplotype crossing matrix generation</h2><span id='topic+haploCrossMatrix'></span>

<h3>Description</h3>

<p>Generation of the haplotype crossing matrix associated to a <code>Genome</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploCrossMatrix(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haploCrossMatrix_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A crossover matrix is a square matrix of size equal to the number of
haplotypes. It describes for each combination of two gametic haplotypes
the genotype index resulting from their syngamy. In the general case it
is not a symmetrical matrix (it is if a single haploid locus with a single
allele is defined), because the transmission of haploid loci is only
maternal, therefore non-symmetrical as is the transmission of diploid
loci. It is therefore necessary to enter the haplotype frequencies of
male gametes in the columns and the haplotype frequencies of female
gametes in the rows during the calculations (this is done in the
simulations).
</p>


<h3>Value</h3>

<p>An haplotype crossing matrix.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='haplotyping'>Haplotyping</h2><span id='topic+haplotyping'></span>

<h3>Description</h3>

<p>Generation of haplotypes associated with a <code>Genome</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplotyping(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haplotyping_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generated haplotypes are output as a list of three enumeration
in the form of matrices of alleles (each row corresponding to an haplotype,
each column to a locus). The first enumeration corresponds to haplotypes
considering only haploid loci, the second only diploid loci and the third
all loci (with two matrices, 1 for haploid loci, 1 for diploid loci).
</p>


<h3>Value</h3>

<p>A list of matrices describing haplotypes in rows.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='IDgenomeGeneration'>Genome identifier</h2><span id='topic+IDgenomeGeneration'></span>

<h3>Description</h3>

<p>Generation of the input genome ID, i.e. the concatenation in string form
of the names of the loci and alleles constituting this genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDgenomeGeneration(listLoci, alleles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IDgenomeGeneration_+3A_listloci">listLoci</code></td>
<td>
<p>the list of all loci</p>
</td></tr>
<tr><td><code id="IDgenomeGeneration_+3A_alleles">alleles</code></td>
<td>
<p>the vector of all the alleles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genome ID as a character string.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='IDgenotypeGeneration'>Genotype identifier</h2><span id='topic+IDgenotypeGeneration'></span>

<h3>Description</h3>

<p>Generation of the input genotype ID, i.e. the concatenation in string form
of the names of the alleles constituting these haplotypes (the two from
the diploid genome and the one from the haploid genome).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDgenotypeGeneration(dl1, dl2, hl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IDgenotypeGeneration_+3A_dl1">dl1</code></td>
<td>
<p>the first diploid haplotype as a character (or factors) vector.</p>
</td></tr>
<tr><td><code id="IDgenotypeGeneration_+3A_dl2">dl2</code></td>
<td>
<p>the second diploid haplotype as a character (or factors) vector.</p>
</td></tr>
<tr><td><code id="IDgenotypeGeneration_+3A_hl">hl</code></td>
<td>
<p>the haploid haplotype as a character (or factors) vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genotype ID as a character string.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='IDhaplotypeGeneration'>Haplotype identifier</h2><span id='topic+IDhaplotypeGeneration'></span>

<h3>Description</h3>

<p>Generation of the input haplotype ID, i.e. the concatenation in string form
of the names of the alleles constituting this haplotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDhaplotypeGeneration(dl, hl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IDhaplotypeGeneration_+3A_dl">dl</code></td>
<td>
<p>the diploid haplotype as a character (or factors) vector.</p>
</td></tr>
<tr><td><code id="IDhaplotypeGeneration_+3A_hl">hl</code></td>
<td>
<p>the haploid haplotype as a character (or factors) vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The haplotype ID as a character string.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='initialize+2CGenome-method'>Initialize method for the <code>Genome</code> class</h2><span id='topic+initialize+2CGenome-method'></span>

<h3>Description</h3>

<p>Initialize method for the <code>Genome</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Genome'
initialize(.Object, listHapLoci, listDipLoci, recRate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CGenome-method_+3A_.object">.Object</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CGenome-method_+3A_listhaploci">listHapLoci</code></td>
<td>
<p>a list of haploid loci</p>
</td></tr>
<tr><td><code id="initialize+2B2CGenome-method_+3A_listdiploci">listDipLoci</code></td>
<td>
<p>a list of diploid loci</p>
</td></tr>
<tr><td><code id="initialize+2B2CGenome-method_+3A_recrate">recRate</code></td>
<td>
<p>a two-by-two recombination rate vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Genome</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='initialize+2CMetapopulation-method'>Initialize method for the <code>Metapopulation</code> class</h2><span id='topic+initialize+2CMetapopulation-method'></span>

<h3>Description</h3>

<p>Initialize method for the <code>Metapopulation</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Metapopulation'
initialize(.Object, populations, migMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CMetapopulation-method_+3A_.object">.Object</code></td>
<td>
<p>a <code>Metapopulation</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CMetapopulation-method_+3A_populations">populations</code></td>
<td>
<p>list of <code>Population</code> object(s)</p>
</td></tr>
<tr><td><code id="initialize+2B2CMetapopulation-method_+3A_migmat">migMat</code></td>
<td>
<p>migration matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Metapopulation</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='initialize+2CMutationMatrix-method'>Initialize method for the <code>MutationMatrix</code> class</h2><span id='topic+initialize+2CMutationMatrix-method'></span>

<h3>Description</h3>

<p>Initialize method for the <code>MutationMatrix</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MutationMatrix'
initialize(.Object, genomeObj, mutHapLoci, mutDipLoci)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CMutationMatrix-method_+3A_.object">.Object</code></td>
<td>
<p>a <code>MutationMatrix</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CMutationMatrix-method_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CMutationMatrix-method_+3A_muthaploci">mutHapLoci</code></td>
<td>
<p>a list of haploid locus by locus allelic mulation matrices.</p>
</td></tr>
<tr><td><code id="initialize+2B2CMutationMatrix-method_+3A_mutdiploci">mutDipLoci</code></td>
<td>
<p>a list of diploid locus by locus allelic mulation matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MutationMatrix</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='initialize+2CPopulation-method'>Initialize method for the <code>Population</code> class</h2><span id='topic+initialize+2CPopulation-method'></span>

<h3>Description</h3>

<p>Initialize method for the <code>Population</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Population'
initialize(
  .Object,
  name,
  size,
  dioecy,
  selfRate,
  demography,
  growthRate,
  initGenoFreq,
  genomeObj,
  initPopSize,
  selectionObj,
  mutMatrixObj
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_.object">.Object</code></td>
<td>
<p>a <code>Population</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_name">name</code></td>
<td>
<p>the name of the population.</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_size">size</code></td>
<td>
<p>the size of the population.</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_dioecy">dioecy</code></td>
<td>
<p>logical indicating whether the population is dioecious or not
(hermaphrodite).</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_selfrate">selfRate</code></td>
<td>
<p>the selfing rate of the population</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_demography">demography</code></td>
<td>
<p>logical indicating whether the population has stochastic
demography (this does not include migration), i.e. non-constant size and
potentially population growth or decay, depending on the situation it is in.</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_growthrate">growthRate</code></td>
<td>
<p>growth rate of the population.</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_initgenofreq">initGenoFreq</code></td>
<td>
<p>A row matrix of the size of the genotype number
describing the initial allele frequencies common to all simulations</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_initpopsize">initPopSize</code></td>
<td>
<p>initial population size, knowing that if the demography
is extinct, the initial population size will automatically be set equal to
the population size.</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_selectionobj">selectionObj</code></td>
<td>
<p>a <code>Selection</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CPopulation-method_+3A_mutmatrixobj">mutMatrixObj</code></td>
<td>
<p>a <code>MutationMatrix</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Population</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='initialize+2CSelection-method'>Initialize method for the <code>Selection</code> class</h2><span id='topic+initialize+2CSelection-method'></span>

<h3>Description</h3>

<p>Initialize method for the <code>Selection</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Selection'
initialize(.Object, genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CSelection-method_+3A_.object">.Object</code></td>
<td>
<p>a <code>Selection</code> object</p>
</td></tr>
<tr><td><code id="initialize+2B2CSelection-method_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Selection</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='is.correct.transition.matrix'>Test if a matrix is a correct transition matrix</h2><span id='topic+is.correct.transition.matrix'></span>

<h3>Description</h3>

<p>Test if a matrix is a correct transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.correct.transition.matrix(x, type, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.correct.transition.matrix_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="is.correct.transition.matrix_+3A_type">type</code></td>
<td>
<p>type of the matrice (mutation matrix ? recombination matrix ?)</p>
</td></tr>
<tr><td><code id="is.correct.transition.matrix_+3A_name">name</code></td>
<td>
<p>the name of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical corresponding to whether <code>x</code> is a correct transition
matrix, i.e. a square matrix with dimensions greater than 0 and whose rows
sum to 1.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='is.default.matrix'>Test if a matrix is a default matrix</h2><span id='topic+is.default.matrix'></span>

<h3>Description</h3>

<p>Test if a matrix is a default matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.default.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.default.matrix_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical corresponding to whether <code>x</code> is a default matrix
(matrix of dimension 0x0).
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='is.probability.matrix'>Test if a matrix is of probability</h2><span id='topic+is.probability.matrix'></span>

<h3>Description</h3>

<p>Test if a matrix is of probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.probability.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.probability.matrix_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical corresponding to whether <code>x</code> is a probability
matrix (sum of rows equal to 1).
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='isAffected'>Is this haplo/geno-type affected ?</h2><span id='topic+isAffected'></span>

<h3>Description</h3>

<p>Determination for a given genotype or haplotype whether it
contains the allelic combination under selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAffected(refDNAtype, selDNAtype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAffected_+3A_refdnatype">refDNAtype</code></td>
<td>
<p>the reference allelic combination (that of a genotype or a
haplotype</p>
</td></tr>
<tr><td><code id="isAffected_+3A_seldnatype">selDNAtype</code></td>
<td>
<p>the selected allelic combination</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logic indicating whether the reference genotype or haplotype
is affected by the allelic combination under selection
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='isHaploSelectFormula'>Are there any allelic combinations including homozygosity</h2><span id='topic+isHaploSelectFormula'></span>

<h3>Description</h3>

<p>Test if there are homozygotes in the specified allelic combinations of
a list of selection formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isHaploSelectFormula(selectFormula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isHaploSelectFormula_+3A_selectformula">selectFormula</code></td>
<td>
<p>a list of selection formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if there are homozygotes
</p>

<hr>
<h2 id='listing'>Listing for display</h2><span id='topic+listing'></span>

<h3>Description</h3>

<p>Listing from the elements of a vector by producing a string, with comma
separation between each element and the word &quot;and&quot; between the last two
elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listing(vect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listing_+3A_vect">vect</code></td>
<td>
<p>a vector of any class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A listing of the elements of the input vector as a string.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='meiosisMatrix'>Meiosis matrix generation</h2><span id='topic+meiosisMatrix'></span>

<h3>Description</h3>

<p>Generation of the meiosis matrix associated to a <code>Genome</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meiosisMatrix(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meiosisMatrix_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A meiosis matrix is a matrix where the number of rows is equal to the number
of genotypes and the number of columns to the number of haplotypes. It is a
matrix that allows to pass from parental genotypes to gametic haplotypes
by meiosis. It is a probability matrix in that the sum of the values in each
row is equal to 1. For a given genotype, the row associated with it
describes the probabilistic proportions that lead by meiosis to the
production of the other genotypes (and of itself if there are no mutations).
</p>


<h3>Value</h3>

<p>A meiosis matrix (probability matrix that associates to each
genotype in a row the probability of producing each of the possible
haplotypes).
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='METAPOP_SIMULATION'>Simulation of a metapopulation</h2><span id='topic+METAPOP_SIMULATION'></span>

<h3>Description</h3>

<p>Simulation of a metapopulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>METAPOP_SIMULATION(
  nbPop,
  ids,
  migMat,
  nsim,
  verbose,
  recording,
  recordGenGap,
  drift,
  nbHaplo,
  nbGeno,
  idGeno,
  nbAlleles,
  idAlleles,
  nbLoci,
  initGenoFreq,
  meiosisMat,
  gametogenesisMat,
  popSize,
  threshold,
  dioecy,
  selfRate,
  stopCondition,
  IDstopCondition,
  haploCrossMat,
  alleleFreqMat,
  gamFit,
  indFit,
  gamProdFit,
  demography,
  growthRate,
  initPopSize,
  nameOutFunct
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="METAPOP_SIMULATION_+3A_nbpop">nbPop</code></td>
<td>
<p>number of populations in the metapopulation</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_ids">ids</code></td>
<td>
<p>population IDs</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_migmat">migMat</code></td>
<td>
<p>migration matrix</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_verbose">verbose</code></td>
<td>
<p>boolean determining if the progress of the simulations should be displayed or not (useful in case of many simulations)</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_recording">recording</code></td>
<td>
<p>a boolean indicating whether to record all mutations, i.e.
to record allelic and genotypic frequencies along the simulations</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_recordgengap">recordGenGap</code></td>
<td>
<p>the number of generations between two records during
simulation, if the record parameter is TRUE. Whatever the value of this
parameter, both the first and the last generation will be included in
the record</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_drift">drift</code></td>
<td>
<p>a boolean indicating whether genetic drift should be
considered (i.e. whether deterministic simulations are performed or not)</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_nbhaplo">nbHaplo</code></td>
<td>
<p>number of haplotypes</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_nbgeno">nbGeno</code></td>
<td>
<p>number of genotypes</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_idgeno">idGeno</code></td>
<td>
<p>genotypes ID</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_nballeles">nbAlleles</code></td>
<td>
<p>number of alleles for each loci</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_idalleles">idAlleles</code></td>
<td>
<p>alleles ID</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_nbloci">nbLoci</code></td>
<td>
<p>number of loci</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_initgenofreq">initGenoFreq</code></td>
<td>
<p>list of initial genotype frequencies in the populations</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_meiosismat">meiosisMat</code></td>
<td>
<p>meiosis matrix</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_gametogenesismat">gametogenesisMat</code></td>
<td>
<p>gametogenesis matrix</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_popsize">popSize</code></td>
<td>
<p>list population sizes</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_threshold">threshold</code></td>
<td>
<p>threshold for simulations</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_dioecy">dioecy</code></td>
<td>
<p>whether the population(s) is dioecious or not (hermaphrodism)</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_selfrate">selfRate</code></td>
<td>
<p>list of the selfing rate in populations (only for hermaphroditic population)</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_stopcondition">stopCondition</code></td>
<td>
<p>list of stop conditions</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_idstopcondition">IDstopCondition</code></td>
<td>
<p>vector of stop condition ID</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_haplocrossmat">haploCrossMat</code></td>
<td>
<p>haplotypes crossing matrix</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_allelefreqmat">alleleFreqMat</code></td>
<td>
<p>matrix for calculating allelic frequencies</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_gamfit">gamFit</code></td>
<td>
<p>fitness of gametes</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_indfit">indFit</code></td>
<td>
<p>fitness of individuals</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_gamprodfit">gamProdFit</code></td>
<td>
<p>fitness for gamete production</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_demography">demography</code></td>
<td>
<p>list of population demographies</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_growthrate">growthRate</code></td>
<td>
<p>list of population growth rates</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_initpopsize">initPopSize</code></td>
<td>
<p>list of initial population</p>
</td></tr>
<tr><td><code id="METAPOP_SIMULATION_+3A_nameoutfunct">nameOutFunct</code></td>
<td>
<p>name of the custom output function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='Metapopulation-class'>Metapopulation</h2><span id='topic+Metapopulation-class'></span>

<h3>Description</h3>

<p>The class <code>Metapopulation</code> is used to centralise the information
relating to the populations that we want to simulate, as well as to define
the migration conditions between them if there are several. This class
is thus defined by a list of objects <code>Population</code> and a migration
matrix.
</p>


<h3>Slots</h3>


<dl>
<dt><code>populations</code></dt><dd><p>list of objects <code>Population</code></p>
</dd>
<dt><code>nbPop</code></dt><dd><p>number of populations</p>
</dd>
<dt><code>names</code></dt><dd><p>names of the populations</p>
</dd>
<dt><code>migMat</code></dt><dd><p>migration matrix between population (if there is more than one)</p>
</dd>
<dt><code>sizes</code></dt><dd><p>sizes of the populations</p>
</dd>
<dt><code>dioecies</code></dt><dd><p>sexual systems of the populations (they must all be the same)</p>
</dd>
<dt><code>selfRates</code></dt><dd><p>selfing rates of the populations</p>
</dd>
<dt><code>demographies</code></dt><dd><p>demography parameter of the populations</p>
</dd>
<dt><code>growthRates</code></dt><dd><p>growth rates of the populations</p>
</dd>
<dt><code>initPopSizes</code></dt><dd><p>initial population sizes of the populations</p>
</dd>
<dt><code>initGenoFreqs</code></dt><dd><p>initial genotypic frequencies of the populations</p>
</dd>
<dt><code>genome</code></dt><dd><p>a <code>Genome</code> object</p>
</dd>
<dt><code>genomeIDs</code></dt><dd><p>ID of the <code>Genome</code> object</p>
</dd>
<dt><code>mutMat</code></dt><dd><p>a <code>MutationMatrix</code> object</p>
</dd>
<dt><code>selection</code></dt><dd><p>a <code>Selection</code> object</p>
</dd>
<dt><code>recMat</code></dt><dd><p>recombination matrix</p>
</dd>
<dt><code>meiosisMat</code></dt><dd><p>a meiosis matrix</p>
</dd>
<dt><code>haploCrossMat</code></dt><dd><p>an haplotype crossing matrix</p>
</dd>
<dt><code>haploCrossMatNamed</code></dt><dd><p>an haplotype crossing matrix with names of
genotypes instead of their indices</p>
</dd>
<dt><code>gametogenesisMat</code></dt><dd><p>a gametogenesis matrix</p>
</dd>
<dt><code>alleleFreqMat</code></dt><dd><p>a matrix for calculating allelic frequencies</p>
</dd>
<dt><code>rawOutputSimul</code></dt><dd><p>raw output of the simulation function, its refinement
is done directly afterwards in the <code>simulate</code> method</p>
</dd>
<dt><code>stopCondition</code></dt><dd><p>list of stop conditions for the simulation (if required)</p>
</dd>
<dt><code>IDstopCondition</code></dt><dd><p>names of stop conditions. They are given an arbitrary
name if none is given by the user.</p>
</dd>
<dt><code>results</code></dt><dd><p>data.frame.</p>
</dd>
<dt><code>records</code></dt><dd><p>list.</p>
</dd>
<dt><code>customOutput</code></dt><dd><p>list.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='mutation'>Definition of a mutation</h2><span id='topic+mutation'></span>

<h3>Description</h3>

<p>Utility function to easily generate a mutation matrix
(see <a href="#topic+setMutationMatrix">setMutationMatrix</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation(from, to, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_+3A_from">from</code></td>
<td>
<p>name of the original allele</p>
</td></tr>
<tr><td><code id="mutation_+3A_to">to</code></td>
<td>
<p>name of the mutant allele</p>
</td></tr>
<tr><td><code id="mutation_+3A_rate">rate</code></td>
<td>
<p>rate at which the mutation occurs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mutation occurs from one allele to another at a specific rate. Please
take care to define alleles as traits, that these alleles are present
in the genome you are using and that the alleles are associated with
the same locus.
</p>


<h3>Value</h3>

<p>A standardised list of input parameters that will be used by the
function <a href="#topic+setMutationMatrix">setMutationMatrix</a> to generate the mutation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with two loci, each with two alleles ###

# Definition of the genome
DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)

# The mutation function allows each transition from one allele to
# another to be defined individually, to produce the mutation matrix
# as follows:
mutMatrixObj &lt;- setMutationMatrix(genomeObj,
  mutations = list(
    mutation(from = "A", to = "a", rate = 0.1),
    mutation(from = "B", to = "b", rate = 0.1)
  )
)

</code></pre>

<hr>
<h2 id='MutationMatrix-class'>Mutation matrix</h2><span id='topic+MutationMatrix-class'></span>

<h3>Description</h3>

<p>A mutation matrix is used to simulate mutations that affect loci. An object
of the class <code>MutationMatrix</code> does not only contain a (haplotypic)
mutation matrix. It also contains the attributes necessary for the
construction and easy-to-read display of this matrix.
</p>


<h3>Details</h3>

<p>The mutation matrix itself is a square matrix of size equal to the number of
haplotypes. It is a probability matrix in that the sum of the values in
each row is equal to 1. For a given haplotype, the row associated with it
describes the probabilistic proportions that lead by mutation of this
haplotype to the production of the other haplotypes (and of itself if there
are no mutations).
</p>


<h3>Slots</h3>


<dl>
<dt><code>mutHapLoci</code></dt><dd><p>a list of haploid locus by locus allelic mulation matrices.</p>
</dd>
<dt><code>mutDipLoci</code></dt><dd><p>a list of diploid locus by locus allelic mulation matrices.</p>
</dd>
<dt><code>mutLoci</code></dt><dd><p>a list concatenating <code>mutHapLoci</code> and <code>mutDipLoci</code></p>
</dd>
<dt><code>nbAlDL</code></dt><dd><p>a vector of the number(s) of alleles at each haploid locus</p>
</dd>
<dt><code>nbAlHL</code></dt><dd><p>a vector of the number(s) of alleles at each diploid locus</p>
</dd>
<dt><code>mutationMatrix</code></dt><dd><p>the haplotypic mutation matrix</p>
</dd>
<dt><code>nbHaplo</code></dt><dd><p>the number of haplotypes</p>
</dd>
<dt><code>nbDL</code></dt><dd><p>the number of diploid loci</p>
</dd>
<dt><code>nbHL</code></dt><dd><p>the number of haploid loci</p>
</dd>
<dt><code>haplotypes</code></dt><dd><p>the enumeration of haplotypes</p>
</dd>
<dt><code>IDgenome</code></dt><dd><p>ID of the associated genome</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='mutMatFriendly'>Individual mutation definition to allelic mutation matrices</h2><span id='topic+mutMatFriendly'></span>

<h3>Description</h3>

<p>Translation of the list of individually defined mutations into allelic
mutation matrices which are then used to generate the genotypic mutation
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutMatFriendly(genomeObj, mutations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutMatFriendly_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="mutMatFriendly_+3A_mutations">mutations</code></td>
<td>
<p>list of mutations defined individually with the function
<a href="#topic+mutation">mutation</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the two list of allelic mutation matrices, for haploid
and diploid loci respectively.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='mutMatRates'>Mutation matrix from rates</h2><span id='topic+mutMatRates'></span>

<h3>Description</h3>

<p>Generation of a mutation matrix from the allele enumeration vector of a loci
and the forward and backward mutation rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutMatRates(alleles, forwardMut, backwardMut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutMatRates_+3A_alleles">alleles</code></td>
<td>
<p>allele enumeration vector of a locus</p>
</td></tr>
<tr><td><code id="mutMatRates_+3A_forwardmut">forwardMut</code></td>
<td>
<p>forward mutation rate</p>
</td></tr>
<tr><td><code id="mutMatRates_+3A_backwardmut">backwardMut</code></td>
<td>
<p>backward mutation rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>MutationMatrix</code> for more details on mutation matrices.
</p>


<h3>Value</h3>

<p>An allelic mutation matrix (probability matrix which associates to
each allele in a row the probability of mutating or not to the other alleles
of the locus in question).
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='outFunct'>Custom output function</h2><span id='topic+outFunct'></span>

<h3>Description</h3>

<p>Allow to produce a custom output for a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outFunct(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outFunct_+3A_pop">pop</code></td>
<td>
<p>list of some characteristics of the population :
- customOutput : list of all previous savings
- gen : generation
- freqGeno : list of genotypic frequency matrices (matrix 1 x # genotypes).
The list is constructed as follows: if the population is hermaphroditic it
has only one element &quot;ind&quot;, if the population is dioecious it has three
elements, &quot;female&quot;, &quot;male&quot; and &quot;ind&quot; which correspond respectively to
the genotypic frequencies of the females, the males and the average of
the two (assuming a sex ratio of 50:50).
- freqHaplo : list of genotypic frequency matrices (matrix 1 x # haplotypes).
The list is constructed in the same way as for genotypic frequencies (see
above).
- freqAlleles : list of allelic frequency matrices (matrix 1 x # alleles).
The list is constructed in the same way as for genotypic frequencies (see
above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called each generation in each population of a simulation
and systematically returns a list with the first element being a logic that
indicates whether something should be saved. If so, the second element
of this list will be saved.
</p>
<p>By default the save nothing function, but it can be changed by the user as
an argument in the <code>simulate</code> method of the <code>Metapopulation</code>
class.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='Population-class'>Population</h2><span id='topic+Population-class'></span>

<h3>Description</h3>

<p>The <code>Population</code> class allows for the collection of the parameters necessary
to characterise a biological population. It is an essentially useful class
in that no method associated with the population class can simulate its
dynamics. To do this, it is necessary to use the Metapopulation class,
which takes as input a list of populations (from one). The Population
class is also used to check that each of these parameters is compatible
with each other.
</p>


<h3>Details</h3>

<p>Thus to build an object of class <code>Ease</code>, it is necessary to have
defined an object <code>Genome</code>, as well as an object <code>MutationMatrix</code>
and an object <code>Selection</code> (even if it is neutral, see
<a href="#topic+setSelectNeutral">setSelectNeutral</a>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>the name of the population.</p>
</dd>
<dt><code>size</code></dt><dd><p>the size of the population.</p>
</dd>
<dt><code>dioecy</code></dt><dd><p>logical indicating whether the population is dioecious or not
(hermaphrodite).</p>
</dd>
<dt><code>selfRate</code></dt><dd><p>the selfing rate of the population</p>
</dd>
<dt><code>demography</code></dt><dd><p>logical indicating whether the population has stochastic
demography (this does not include migration), i.e. non-constant size and
potentially population growth or decay, depending on the situation it is in.</p>
</dd>
<dt><code>growthRate</code></dt><dd><p>growth rate of the population.</p>
</dd>
<dt><code>initGenoFreq</code></dt><dd><p>A row matrix of the size of the genotype number
describing the initial allele frequencies common to all simulations</p>
</dd>
<dt><code>genome</code></dt><dd><p>a <code>Genome</code> object</p>
</dd>
<dt><code>initPopSize</code></dt><dd><p>initial population size, knowing that if the demography
is extinct, the initial population size will automatically be set equal to
the population size.</p>
</dd>
<dt><code>selection</code></dt><dd><p>a <code>Selection</code> object</p>
</dd>
<dt><code>mutMat</code></dt><dd><p>a <code>MutationMatrix</code> object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='print+2CGenome-method'>Print method for the <code>Genome</code> class</h2><span id='topic+print+2CGenome-method'></span>

<h3>Description</h3>

<p>Print method for the <code>Genome</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Genome'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CGenome-method_+3A_x">x</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="print+2B2CGenome-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only a display.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='print+2CMetapopulation-method'>Print method for the <code>Metapopulation</code> class</h2><span id='topic+print+2CMetapopulation-method'></span>

<h3>Description</h3>

<p>Print method for the <code>Metapopulation</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Metapopulation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CMetapopulation-method_+3A_x">x</code></td>
<td>
<p>a <code>Metapopulation</code> object</p>
</td></tr>
<tr><td><code id="print+2B2CMetapopulation-method_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='print+2CMutationMatrix-method'>Print method for the <code>MutationMatrix</code> class</h2><span id='topic+print+2CMutationMatrix-method'></span>

<h3>Description</h3>

<p>Print method for the <code>MutationMatrix</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MutationMatrix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CMutationMatrix-method_+3A_x">x</code></td>
<td>
<p>a <code>MutationMatrix</code> object</p>
</td></tr>
<tr><td><code id="print+2B2CMutationMatrix-method_+3A_...">...</code></td>
<td>
<p>there are no more parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only a display.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='print+2CPopulation-method'>Print method for the <code>Population</code> class</h2><span id='topic+print+2CPopulation-method'></span>

<h3>Description</h3>

<p>Print method for the <code>Population</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Population'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CPopulation-method_+3A_x">x</code></td>
<td>
<p>a <code>Population</code> object</p>
</td></tr>
<tr><td><code id="print+2B2CPopulation-method_+3A_...">...</code></td>
<td>
<p>the other parameter is <code>frame</code>, which is a logic indicating
whether the frame surrounding the display of the population characteristics
should be displayed or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='print+2CSelection-method'>Print method for the <code>Selection</code> class</h2><span id='topic+print+2CSelection-method'></span>

<h3>Description</h3>

<p>Print method for the <code>Selection</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Selection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CSelection-method_+3A_x">x</code></td>
<td>
<p>a <code>Selection</code> object</p>
</td></tr>
<tr><td><code id="print+2B2CSelection-method_+3A_...">...</code></td>
<td>
<p>there are no more parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only a display.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='recombinationMatrix'>Recombination matrix generation</h2><span id='topic+recombinationMatrix'></span>

<h3>Description</h3>

<p>Generation of the recombination matrix associated to a <code>Genome</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationMatrix(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombinationMatrix_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A recombination matrix is a square matrix of size equal to the number of
genotypes. It is a probability matrix in that the sum of the values in each
row is equal to 1. For a given genotype, the row associated with it
describes the probabilistic proportions that lead by recombination
between diploid loci to the production of the other genotypes (and of
itself if there are no mutations).
</p>


<h3>Value</h3>

<p>A recombination matrix (probability matrix which associates to each
genotype in a row the probability of recombining or not and of becoming
another genotype or remaining the same).
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='rowResultGen'>Processing a result (or record) list</h2><span id='topic+rowResultGen'></span>

<h3>Description</h3>

<p>Processing a result (or record) list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowResultGen(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowResultGen_+3A_x">x</code></td>
<td>
<p>list of result or record</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merges the column names of the matrices making up the list with
the names of the matrices, then merges the matrices together.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='selectFormIntoVect'>Conversion of selection formulas</h2><span id='topic+selectFormIntoVect'></span>

<h3>Description</h3>

<p>Conversion of a list of selection formulas into a genotypic (or haplotypic)
fitness vector associated with a <code>Genome</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectFormIntoVect(selectFormula, genomeObj, haplo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectFormIntoVect_+3A_selectformula">selectFormula</code></td>
<td>
<p>a list of selection formulas</p>
</td></tr>
<tr><td><code id="selectFormIntoVect_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="selectFormIntoVect_+3A_haplo">haplo</code></td>
<td>
<p>logical indicating whether the selection should apply to
haplotypes (in the case of gametic selection for example)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of fitness values
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='selectInputTreatment'>Treatment of selection formulas</h2><span id='topic+selectInputTreatment'></span>

<h3>Description</h3>

<p>Determines whether an entry for the selection is a list of selection
formulas or just a vector. If it is a list of formulas, turns them
into a vector. If it is a vector, does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectInputTreatment(selectInput, genomeObj, haplo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectInputTreatment_+3A_selectinput">selectInput</code></td>
<td>
<p>a selection input</p>
</td></tr>
<tr><td><code id="selectInputTreatment_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="selectInputTreatment_+3A_haplo">haplo</code></td>
<td>
<p>logical indicating whether the selection should apply to
haplotypes (in the case of gametic selection for example)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of fitness values
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='Selection-class'><code>Selection</code> class</h2><span id='topic+Selection-class'></span>

<h3>Description</h3>

<p>Class used to generate objects that manage the selection in the simulations.
</p>


<h3>Details</h3>

<p>An object of type <code>Selection</code> is an object which describes the set of
fitnesses which will be taken into account in the simulations. The
selection according to these fitnesses can be applied at three levels:
at the level of the individual, at the level of the production of
gametes and at the level of the gametes themselves.
Selection is therefore genotypic in the first two cases (each genotype
is associated with a fitness value) and haplotypic in the third (each
haplotype is associated with a fitness value).
</p>


<h3>Slots</h3>


<dl>
<dt><code>genome</code></dt><dd><p>a <code>Genome</code> object</p>
</dd>
<dt><code>IDhaplotypes</code></dt><dd><p>IDs of haplotypes</p>
</dd>
<dt><code>IDgenotypes</code></dt><dd><p>IDs of genotypes</p>
</dd>
<dt><code>IDgenome</code></dt><dd><p>ID of the associated genome</p>
</dd>
<dt><code>nbHaplo</code></dt><dd><p>the number of haplotypes</p>
</dd>
<dt><code>nbGeno</code></dt><dd><p>the number of genotypes</p>
</dd>
<dt><code>gamFit</code></dt><dd><p>the list of gametes' fitness</p>
</dd>
<dt><code>indFit</code></dt><dd><p>the list of individuals' fitness</p>
</dd>
<dt><code>gamProdFit</code></dt><dd><p>the list of gamete production fitness</p>
</dd>
<dt><code>sOnInds</code></dt><dd><p>a logical indicating whether a selection on individuals
has been configured by the user</p>
</dd>
<dt><code>sOnGams</code></dt><dd><p>a logical indicating whether a selection on gametes
has been configured by the user</p>
</dd>
<dt><code>sOnGamsProd</code></dt><dd><p>a logical indicating whether a selection on gamete
production has been configured by the user</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='selection.form.treatment'>Treatment of a selection formula</h2><span id='topic+selection.form.treatment'></span>

<h3>Description</h3>

<p>Conversion of the factors of a selection formula into the list of
corresponding allelic combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection.form.treatment(factors, genomeObj = NULL, checking = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection.form.treatment_+3A_factors">factors</code></td>
<td>
<p>formula factors (right-hand members)</p>
</td></tr>
<tr><td><code id="selection.form.treatment_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object for the test (see <code>checking</code>
parameter)</p>
</td></tr>
<tr><td><code id="selection.form.treatment_+3A_checking">checking</code></td>
<td>
<p>logical indicating whether a test verifying the
compatibility of input factors with the genome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors enumerating the allelic combinations that
correspond to the factors
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='setGenome'>Setting the genome</h2><span id='topic+setGenome'></span>

<h3>Description</h3>

<p>Generation of a genome class object from the list of haploid loci
and diploid loci. Each loci is defined by a factor vector that enumerates
its alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGenome(listHapLoci = list(), listDipLoci = list(), recRate = numeric())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGenome_+3A_listhaploci">listHapLoci</code></td>
<td>
<p>a list of haploid loci</p>
</td></tr>
<tr><td><code id="setGenome_+3A_listdiploci">listDipLoci</code></td>
<td>
<p>a list of diploid loci</p>
</td></tr>
<tr><td><code id="setGenome_+3A_recrate">recRate</code></td>
<td>
<p>a two-by-two recombination rate vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A genome includes the list of all possible haplotypes and genotypes
resulting from the combination of the alleles defined in input.
As the <code>Ease</code> package was originally built for population genetics
simulations including both diploid and haploid loci, it is necessary
that both types of loci are defined. Despite this, the user can define
only diploid or only haploid loci if they wish. If no diploid locus is
defined, one is automatically generated with only one allele, thus not
influencing the simulation. The same applies if no haploid locus is defined.
</p>
<p>Each locus is described by a vector of factors which are the names of
the possible alleles at that locus. All diploid (resp. haploid) loci
thus defined are grouped in a list, called <code>listDipLoci</code> (resp.
<code>listHapLoci</code>). Therefore, a <code>Genome</code> class object has two lists
of loci defined in this way, one for diploid loci, one for haploid loci.
The alleles and loci (diploid and haploid) must all have different
names so that no ambiguity can persist.
</p>
<p>If several are defined, the order of the diploid loci in the list is not
trivial. The rates of two-to-one combinations between them must indeed be
defined by the vector <code>recRate</code>. For example, if three diploid loci
are defined, <code>recRate</code> must be of length 2, the first of its values
defining the recombination rate between the first and second loci, the
second of its values the recombination rate between the second and third
loci. For example, if we want to define two groups of two loci that are
linked to each other but are on two different chromosomes, we can define
a <code>recRate = c(0.1, 0.5, 0.1)</code>. The first two loci are thus relatively
linked (recombination rate of 0.1), as are the last two loci. On the other
hand, the recombination rate of 0.5 between the second and third loci
ensures that the two groups are independent.
</p>


<h3>Value</h3>

<p>a <code>Genome</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)

</code></pre>

<hr>
<h2 id='setMetapopulation'>Setting a metapopulation</h2><span id='topic+setMetapopulation'></span>

<h3>Description</h3>

<p>A metapopulation is a set of population(s) (from 1) that are simulated
with potential migration between them. Only genotypes can migrate, i.e.
adult individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMetapopulation(populations, migMat = matrix(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMetapopulation_+3A_populations">populations</code></td>
<td>
<p>a list of <code>Population</code> objects</p>
</td></tr>
<tr><td><code id="setMetapopulation_+3A_migmat">migMat</code></td>
<td>
<p>a migration matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The construction of a <code>Metapopulation</code> object requires only two
arguments (one optional). The first is a population(s) list, defined
from the population class. The second is a migration matrix, which
connects the populations together. This matrix is a probability matrix
(square with the sum of the rows equal to 1, whose size is equal to the
number of populations) where each value corresponds to the proportion
of individuals (genotypes) that disperse from their source population
(row) to their target population (column).
</p>


<h3>Value</h3>

<p>a <code>Metapopulation</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of a population in its simplest form:
DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
mutations &lt;- list(
  mutation(from = "A", to = "a", rate = 1e-3),
  mutation(from = "B", to = "b", rate = 1e-3)
)
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)
pop &lt;- setPopulation(
  name = "A",
  size = 1000,
  dioecy = TRUE,
  genomeObj = genomeObj,
  selectionObj = setSelectNeutral(genomeObj),
  mutMatrixObj = setMutationMatrix(genomeObj, mutations = mutations)
)
metapop &lt;- setMetapopulation(populations = list(pop))
metapop &lt;- simulate(metapop, nsim = 10, seed = 123)
# Other examples available in the documentation of the package

</code></pre>

<hr>
<h2 id='setMutationMatrix'>Setting the mutation matrix</h2><span id='topic+setMutationMatrix'></span>

<h3>Description</h3>

<p>Generation of the mutation matrix associated with the genome given as input.
A mutation matrix is used to simulate mutations that affect loci. An object
of the class <code>MutationMatrix</code> does not only contain a (genotypic)
mutation matrix. It also contains the attributes necessary for the
construction and easy-to-read display of this matrix.
The mutation matrix itself is a square matrix of size equal to the number of
genotypes. It is a probability matrix in that the sum of the values in
each row is equal to 1. For a given genotype, the row associated with it
describes the probabilistic proportions that lead by mutation of this
genotype to the production of the other genotypes (and of itself if there
are no mutations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMutationMatrix(genomeObj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMutationMatrix_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="setMutationMatrix_+3A_...">...</code></td>
<td>
<p>see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three ways to define the mutation matrix associated with a
<code>Genome</code> class object.
</p>
<p>1) By giving two lists of allelic mutation matrices <code>mutHapLoci</code> and
<code>mutDipLoci</code>, for haploid and diploid loci respectively. Each of
these lists contains as many matrices as there are loci. These matrices
are transition matrices (squares, with the sum of the rows equal to 1)
of size equal to the number of alleles at the locus concerned.
</p>
<p>2) By giving a forward and a backward allelic mutation rate
(<code>forwardMut</code> and <code>backwardMut</code> respectively). The generated
mutation matrices will thus be defined with the same rates for all loci. A
forward mutation rate means that the transition from one allele to another
is done in the order in which they were defined when the Genome class object
was created, and in the other direction for the backward rate.
</p>
<p>3) By giving a list of <code>mutations</code> generated through the
<a href="#topic+mutation">mutation</a> function.
</p>


<h3>Value</h3>

<p>a <code>MutationMatrix</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with two loci, each with two alleles ###

# Definition of the genome
DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)

# Three ways to define the same mutation matrix associated with the
# genome defined above:

# 1) Mutation matrix from matrices
mutHapLoci &lt;- list(matrix(c(0.99, 0.01, 0.01, 0.99), 2))
mutDipLoci &lt;- list(matrix(c(0.99, 0.01, 0.01, 0.99), 2))
# One can then define the MutationMatrix class object:
setMutationMatrix(genomeObj,
  mutHapLoci = mutHapLoci,
  mutDipLoci = mutDipLoci
)

# 2) Mutation matrix from mutation rates
mutMatrixObj &lt;- setMutationMatrix(genomeObj, forwardMut = 0.1)
# or by adding a backward mutation rate:
mutMatrixObj &lt;- setMutationMatrix(genomeObj,
  forwardMut = 1e-3,
  backwardMut = 1e-4
)

# 3) Mutation matrix from single mutation definition
mutMatrixObj &lt;- setMutationMatrix(genomeObj,
  mutations = list(
    mutation(from = "A", to = "a", rate = 0.1),
    mutation(from = "B", to = "b", rate = 0.1)
  )
)

</code></pre>

<hr>
<h2 id='setPopulation'>Setting a population</h2><span id='topic+setPopulation'></span>

<h3>Description</h3>

<p>Generation of a population by providing all the necessary ingredients for
its definition, including a genome, a mutation matrix and a selection regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPopulation(
  name,
  size,
  dioecy,
  genomeObj,
  mutMatrixObj,
  selectionObj,
  selfRate = 0,
  demography = F,
  growthRate = 0,
  initPopSize = NULL,
  initGenoFreq = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPopulation_+3A_name">name</code></td>
<td>
<p>the name of the population</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_size">size</code></td>
<td>
<p>the population size</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_dioecy">dioecy</code></td>
<td>
<p>logical indicating whether the simulated population is
dioecious or hermaphroditic</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_mutmatrixobj">mutMatrixObj</code></td>
<td>
<p>a <code>MutationMatrix</code> object</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_selectionobj">selectionObj</code></td>
<td>
<p>a <code>Selection</code> object</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_selfrate">selfRate</code></td>
<td>
<p>the selfing rate</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_demography">demography</code></td>
<td>
<p>a logic indicating whether the population should have
a demography (stochasticity in the number of individuals present in the
population + logistic growth with carrying capacity equal to the <code>size</code>
parameter)</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_growthrate">growthRate</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_initpopsize">initPopSize</code></td>
<td>
<p>the initial size of the population. It is necessarily
equal to <code>size</code> if the population has no <code>demography</code>.</p>
</td></tr>
<tr><td><code id="setPopulation_+3A_initgenofreq">initGenoFreq</code></td>
<td>
<p>a vector of the size of the genotype number
describing the initial allele frequencies common to all simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A population is defined strictly by a name, a size, a sexual system
(dioecy or hermaphodite), and the three objects defined previously:
genome, mutation matrix and selection. In addition to that, it is
possible to define
- a selfing rate (by default equal to 0)
- a vector of initial genotypic frequencies
- a demography
</p>
<p>Two demographic regimes are possible: no demography, i.e. a fixed population
size, or demography, i.e. a population where the size fluctuates
stochastically. The boolean argument 'demography' is used to define whether
there should be stochasticity. For a fixed population size, it is therefore
sufficient to define that 'demography = FALSE' (default) and to set the
desired population size with the 'popSize' parameter.
</p>
<p>For a fluctuating demography, 'demography' must be 'TRUE' and three other
parameters are then needed: the initial population size ('initPopSize'),
the population growth rate ('growthRate') and the carrying capacity of the
population (the population size, 'popSize').
</p>
<p>It is also possible to avoid defining a population size altogether, by
setting off the genetic drift ('drift' parameter). This will allow the
model to be simulated deterministically.
</p>


<h3>Value</h3>

<p>a <code>Population</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of a population in its simplest form:
DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
mutations &lt;- list(
  mutation(from = "A", to = "a", rate = 1e-3),
  mutation(from = "B", to = "b", rate = 1e-3)
)
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)
pop &lt;- setPopulation(
  name = "A",
  size = 1000,
  dioecy = TRUE,
  genomeObj = genomeObj,
  selectionObj = setSelectNeutral(genomeObj),
  mutMatrixObj = setMutationMatrix(genomeObj, mutations = mutations)
)

</code></pre>

<hr>
<h2 id='setSelectNeutral'>Setting the selection</h2><span id='topic+setSelectNeutral'></span>

<h3>Description</h3>

<p>Generation of a neutral class <code>Selection</code> object. It can be used as a
basis for adding selection layers with the <code>setSelectOnInds</code>,
<code>setSelectOnGametes</code> or <code>setSelectOnGametesProd</code> functions, or
if the model is neutral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSelectNeutral(genomeObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSelectNeutral_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of type <code>Selection</code> is an object which describes the set of
fitnesses which will be taken into account in the simulations. The
selection according to these fitnesses can be applied at three levels:
at the level of the individual, at the level of the production of
gametes and at the level of the gametes themselves.
Selection is therefore genotypic in the first two cases (each genotype
is associated with a fitness value) and haplotypic in the third (each
haplotype is associated with a fitness value).
</p>


<h3>Value</h3>

<p>a <code>Selection</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with two loci, each with two alleles ###
# Definition of the diploid locus
DL &lt;- list(dl = c("A", "a"))
# Definition of the haploid locus
HL &lt;- list(hl = c("B", "b"))
# Definition of the object of Genome class
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)
genomeObj

### Exemple with more diploid loci ###
# Definition of the diploid loci
DL &lt;- list(
  dl1 = c("A", "a"),
  dl2 = c("B", "b"),
  dl3 = c("C", "c")
)
# Definition of the haploid locus
HL &lt;- list(hl = c("D", "d"))
# Definition of the object of Genome class, with in addition the necessary
# definition of recombination rates between loci:
genomeObj &lt;- setGenome(
  listHapLoci = HL, listDipLoci = DL,
  recRate = c(0.1, 0.5)
)
# Here we have a 0.1 recombination rate between dl1 and dl2 and a 0.5
# recombination rate between dl2 and dl3. It is as if dl1 and dl2 were linked,
# for example on the same chromosome, and that dl2 (and dl1 by consequence)
# and dl3 were independent, for example on different chromosomes.

genomeObj

</code></pre>

<hr>
<h2 id='setSelectOnGametes'>Setting the selection on gametes</h2><span id='topic+setSelectOnGametes'></span>

<h3>Description</h3>

<p>Generation of an object of the <code>Selection</code> class which defines a
selection among the individuals either by adding this type of selection
to an already existing <code>SelectionObj</code> object (parameter
<code>selectionObj</code>) or by creating one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSelectOnGametes(
  genomeObj = NULL,
  gamFit = c(),
  femaleFit = c(),
  maleFit = c(),
  selectionObj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSelectOnGametes_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="setSelectOnGametes_+3A_gamfit">gamFit</code></td>
<td>
<p>an haplotypic fitness vector for all individuals</p>
</td></tr>
<tr><td><code id="setSelectOnGametes_+3A_femalefit">femaleFit</code></td>
<td>
<p>an haplotypic fitness vector for females only</p>
</td></tr>
<tr><td><code id="setSelectOnGametes_+3A_malefit">maleFit</code></td>
<td>
<p>an haplotypic fitness vector for males only</p>
</td></tr>
<tr><td><code id="setSelectOnGametes_+3A_selectionobj">selectionObj</code></td>
<td>
<p>a <code>Selection</code> object (in the case where the
selection on individuals is overlaid on an existing <code>Selection</code> object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Selection</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)
selectionObj &lt;- setSelectOnGametes(
  genomeObj = genomeObj,
  gamFit = c(1, 1, 0.5, 0)
)

</code></pre>

<hr>
<h2 id='setSelectOnGametesProd'>Setting the selection on gamete production</h2><span id='topic+setSelectOnGametesProd'></span>

<h3>Description</h3>

<p>Generation of an object of the <code>Selection</code> class which defines a
selection on the gamete production either by adding this type of selection
to an already existing <code>SelectionObj</code> object (parameter
<code>selectionObj</code>) or by creating one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSelectOnGametesProd(
  genomeObj = NULL,
  indProdFit = c(),
  femProdFit = c(),
  maleProdFit = c(),
  selectionObj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSelectOnGametesProd_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="setSelectOnGametesProd_+3A_indprodfit">indProdFit</code></td>
<td>
<p>a genotypic fitness vector for all individuals</p>
</td></tr>
<tr><td><code id="setSelectOnGametesProd_+3A_femprodfit">femProdFit</code></td>
<td>
<p>a genotypic fitness vector for females only</p>
</td></tr>
<tr><td><code id="setSelectOnGametesProd_+3A_maleprodfit">maleProdFit</code></td>
<td>
<p>a genotypic fitness vector for males only</p>
</td></tr>
<tr><td><code id="setSelectOnGametesProd_+3A_selectionobj">selectionObj</code></td>
<td>
<p>a <code>Selection</code> object (in the case where the
selection on individuals is overlaid on an existing <code>Selection</code> object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Selection</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)
selectionObj &lt;- setSelectOnGametesProd(
  genomeObj = genomeObj,
  indProdFit = c(1, 1, 1, 1, 0.5, 0)
)

</code></pre>

<hr>
<h2 id='setSelectOnInds'>Setting the selection on individuals</h2><span id='topic+setSelectOnInds'></span>

<h3>Description</h3>

<p>Generation of an object of the <code>Selection</code> class which defines a
selection among the individuals either by adding this type of selection
to an already existing <code>SelectionObj</code> object (parameter
<code>selectionObj</code>) or by creating one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSelectOnInds(
  genomeObj = NULL,
  indFit = c(),
  femaleFit = c(),
  maleFit = c(),
  selectionObj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSelectOnInds_+3A_genomeobj">genomeObj</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
<tr><td><code id="setSelectOnInds_+3A_indfit">indFit</code></td>
<td>
<p>a genotypic fitness vector for all individuals (whether or not
they are hermaphordite)</p>
</td></tr>
<tr><td><code id="setSelectOnInds_+3A_femalefit">femaleFit</code></td>
<td>
<p>a genotypic fitness vector for females only (only if the
population is dioecious)</p>
</td></tr>
<tr><td><code id="setSelectOnInds_+3A_malefit">maleFit</code></td>
<td>
<p>a genotypic fitness vector for males only (only if the
population is dioecious)</p>
</td></tr>
<tr><td><code id="setSelectOnInds_+3A_selectionobj">selectionObj</code></td>
<td>
<p>a <code>Selection</code> object (in the case where the
selection on individuals is overlaid on an existing <code>Selection</code> object)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>Selection</code> object
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DL &lt;- list(dl = c("A", "a"))
HL &lt;- list(hl = c("B", "b"))
genomeObj &lt;- setGenome(listHapLoci = HL, listDipLoci = DL)
selectionObj &lt;- setSelectOnInds(
  genomeObj = genomeObj,
  indFit = c(1, 1, 1, 1, 0.5, 0)
)

</code></pre>

<hr>
<h2 id='show+2CGenome-method'>Show method for the <code>Genome</code> class</h2><span id='topic+show+2CGenome-method'></span>

<h3>Description</h3>

<p>Show method for the <code>Genome</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Genome'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CGenome-method_+3A_object">object</code></td>
<td>
<p>a <code>Genome</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only a display.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='show+2CMetapopulation-method'>Show method for the <code>Metapopulation</code> class</h2><span id='topic+show+2CMetapopulation-method'></span>

<h3>Description</h3>

<p>Show method for the <code>Metapopulation</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Metapopulation'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CMetapopulation-method_+3A_object">object</code></td>
<td>
<p>a <code>Metapopulation</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='show+2CMutationMatrix-method'>Show method for the <code>MutationMatrix</code> class</h2><span id='topic+show+2CMutationMatrix-method'></span>

<h3>Description</h3>

<p>Show method for the <code>MutationMatrix</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MutationMatrix'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CMutationMatrix-method_+3A_object">object</code></td>
<td>
<p>a <code>MutationMatrix</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only a display.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='show+2CPopulation-method'>Show method for the <code>Population</code> class</h2><span id='topic+show+2CPopulation-method'></span>

<h3>Description</h3>

<p>Show method for the <code>Population</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Population'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CPopulation-method_+3A_object">object</code></td>
<td>
<p>a <code>Population</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='show+2CSelection-method'>Show method for the <code>Selection</code> class</h2><span id='topic+show+2CSelection-method'></span>

<h3>Description</h3>

<p>Show method for the <code>Selection</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Selection'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSelection-method_+3A_object">object</code></td>
<td>
<p>a <code>Selection</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only a display.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='simulate+2CMetapopulation-method'>Simulate method for the <code>Metapopulation</code> class</h2><span id='topic+simulate+2CMetapopulation-method'></span>

<h3>Description</h3>

<p>Performing simulations of an Metapopulation object. The returned object is the same
Metapopulation object completed with the results and records if they have been
activated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Metapopulation'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  threshold = 500,
  includefreqGeno = TRUE,
  recording = FALSE,
  recordGenGap = 1,
  drift = TRUE,
  includeParams = TRUE,
  includeFitness = TRUE,
  verbose = FALSE,
  stopCondition = list(),
  nameOutFunct = "outFunct"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_object">object</code></td>
<td>
<p>a <code>Metapopulation</code> object</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulation to perform</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_seed">seed</code></td>
<td>
<p>the RNG seed to be fixed (allows exact reproduction of
results)</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_threshold">threshold</code></td>
<td>
<p>maximum duration of a simulation (in generations)</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_includefreqgeno">includefreqGeno</code></td>
<td>
<p>a logical indicating whether to include genotype
frequencies in the results</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_recording">recording</code></td>
<td>
<p>a logical indicating whether to record all mutations, i.e.
to record allelic and genotypic frequencies along the simulations</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_recordgengap">recordGenGap</code></td>
<td>
<p>the number of generations between two records during
simulation, if the record parameter is TRUE. Whatever the value of this
parameter, both the first and the last generation will be included in
the record</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_drift">drift</code></td>
<td>
<p>a logical indicating whether genetic drift should be
considered (i.e. whether deterministic simulations are performed or not)</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_includeparams">includeParams</code></td>
<td>
<p>a logical indicating whether the parameters should be
included in the result data.frame (can be useful when compiling multiple
result tables)</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_includefitness">includeFitness</code></td>
<td>
<p>a logical indicating whether the mean fitness should
be included in the result data.frame (can be useful when compiling multiple
result tables)</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_verbose">verbose</code></td>
<td>
<p>logical determining if the progress of the simulations should
be displayed or not (useful in case of many simulations)</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_stopcondition">stopCondition</code></td>
<td>
<p>list of vectors that each describe the allele(s) that
must be fixed to define a stop condition. Each of these vectors
will therefore be associated with a stop condition</p>
</td></tr>
<tr><td><code id="simulate+2B2CMetapopulation-method_+3A_nameoutfunct">nameOutFunct</code></td>
<td>
<p>name of the custom output function. This function is
called each generation in each population of a simulation and systematically
returns a list with the first element being a logic that indicates whether
something should be saved. If so, the second element of this
list will be saved.If the customOutFunct parameter is null (default),
there will be no custom output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Metapopulation</code> object from which we can now extract the results
(or the records if recording = TRUE) with the getResults and getRecords
functions.
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

<hr>
<h2 id='whichHomoz'>Which alleles are homozygous in the input?</h2><span id='topic+whichHomoz'></span>

<h3>Description</h3>

<p>Determine which alleles are at least once input as homozygous in the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichHomoz(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whichHomoz_+3A_formula">formula</code></td>
<td>
<p>a selection formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the enumeration of alleles that appear at least once homozygous
</p>


<h3>Author(s)</h3>

<p>Ehouarn Le Faou
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
