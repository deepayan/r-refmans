<!DOCTYPE html><html><head><title>Help for package SALES</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SALES}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef'><p>Extract Model Coefficients</p></a></li>
<li><a href='#coef.cpernet'><p>Get coefficients from a cpernet object</p></a></li>
<li><a href='#coef.cv.cpernet'><p>Get coefficients from a cv.cpernet object</p></a></li>
<li><a href='#coef.cv.ernet'><p>Get coefficients from a cv.ernet object</p></a></li>
<li><a href='#coef.ernet'><p>Get coefficients from an ernet object</p></a></li>
<li><a href='#cpernet'><p>Regularization paths for the coupled sparse asymmetric least squares</p>
(COSALES) regression (or the coupled sparse expectile regression)</a></li>
<li><a href='#cv.cpernet'><p>Cross-validation for cpernet</p></a></li>
<li><a href='#cv.ernet'><p>Cross-validation for ernet</p></a></li>
<li><a href='#ernet'><p>Regularization paths for the sparse asymmetric least squares (SALES)</p>
regression (or the sparse expectile regression)</a></li>
<li><a href='#plot.cpernet'><p>Plot coefficients from a cpernet object</p></a></li>
<li><a href='#plot.cv.cpernet'><p>Plot the cross-validated curve produced by cv.cpernet</p></a></li>
<li><a href='#plot.cv.ernet'><p>Plot the cross-validated curve produced by cv.ernet</p></a></li>
<li><a href='#plot.ernet'><p>Plot coefficients from an ernet object</p></a></li>
<li><a href='#predict'><p>Model predictions</p></a></li>
<li><a href='#predict.cpernet'><p>Make predictions from a cpernet object</p></a></li>
<li><a href='#predict.cv.cpernet'><p>Make predictions from a cv.cpernet object</p></a></li>
<li><a href='#predict.cv.ernet'><p>Make predictions from a cv.ernet object</p></a></li>
<li><a href='#predict.ernet'><p>Make predictions from an ernet object</p></a></li>
<li><a href='#print.cpernet'><p>Print a cpernet object</p></a></li>
<li><a href='#print.ernet'><p>Print an ernet object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The (Adaptive) Elastic Net and Lasso Penalized Sparse Asymmetric
Least Squares (SALES) and Coupled Sparse Asymmetric Least
Squares (COSALES) using Coordinate Descent and Proximal
Gradient Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;, Hui Zou &lt;zouxx019@umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, methods, Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>A coordinate descent algorithm for computing the solution paths of
    the sparse and coupled sparse asymmetric least squares, including the
    (adaptive) elastic net and Lasso penalized SALES and COSALES regressions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/knightgu/SALES">https://github.com/knightgu/SALES</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-15 18:30:16 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-15 15:45:23 UTC; yuwen</td>
</tr>
</table>
<hr>
<h2 id='coef'>Extract Model Coefficients</h2><span id='topic+coef'></span>

<h3>Description</h3>

<p><code>coef</code> is a generic function which extracts model coefficients from
objects returned by modeling functions. <code>coefficients</code> is an
<em>alias</em> for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted from the model object <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.ernet">coef.ernet</a></code>, <code><a href="#topic+coef.cpernet">coef.cpernet</a></code>
</p>

<hr>
<h2 id='coef.cpernet'>Get coefficients from a cpernet object</h2><span id='topic+coef.cpernet'></span><span id='topic+coef.cpalspath'></span>

<h3>Description</h3>

<p>Computes the coefficients or returns a list of the indices of the nonzero
coefficients at the requested values for <code>lambda</code> from a fitted cpernet
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpernet'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cpernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cpernet">cpernet</a></code> model object.</p>
</td></tr>
<tr><td><code id="coef.cpernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are to be made. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="coef.cpernet_+3A_type">type</code></td>
<td>
<p>type <code>"coefficients"</code> computes coefficients at the requested
values for <code>s</code>. Type <code>"nonzero"</code> returns a list of the indices of
nonzero coefficients for each value of <code>s</code>. Default is
<code>"coefficients"</code>.</p>
</td></tr>
<tr><td><code id="coef.cpernet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If
<code>s</code> is not in the lambda sequence used for fitting the model, the
<code>coef</code> function will use linear interpolation to make predictions. The
new values are interpolated using a fraction of coefficients from both left
and right <code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpernet">cpernet</a></code>, <code><a href="#topic+predict.cpernet">predict.cpernet</a></code>,
<code><a href="#topic+print.cpernet">print.cpernet</a></code>, <code><a href="#topic+plot.cpernet">plot.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2 &lt;- cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
              pf.mean = pf, pf.scale = pf2, intercept = TRUE,
              standardize = FALSE, lambda2 = lambda2)

mean.coef &lt;- as.vector(coef(m2, s = m2$lambda[50])[[1]])
scale.coef &lt;- as.vector(coef(m2, s = m2$lambda[50])[[2]])

</code></pre>

<hr>
<h2 id='coef.cv.cpernet'>Get coefficients from a cv.cpernet object</h2><span id='topic+coef.cv.cpernet'></span>

<h3>Description</h3>

<p>This function gets coefficients from a cross-validated cpernet model, using
the fitted <code>cv.cpernet</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.cpernet'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.cpernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.cpernet">cv.cpernet</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.cv.cpernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the value <code>s="lambda.1se"</code> stored on the CV
<code>object</code>, it is the largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum. Alternatively <code>s="lambda.min"</code>
can be used, it is the optimal value of <code>lambda</code> that gives minimum
cross validation error <code>cvm</code>. If <code>s</code> is numeric, it is taken as
the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="coef.cv.cpernet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation
to get coefficients or make coefficient predictions.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on
to the <code><a href="#topic+predict">predict</a></code> method for <code><a href="#topic+cpernet">cpernet</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.cpernet">cv.cpernet</a></code>, <code><a href="#topic+predict.cv.cpernet">predict.cv.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2.cv &lt;- cv.cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
                    pf.mean = pf, pf.scale = pf2,
                    standardize = FALSE, lambda2 = lambda2)
as.vector(coef(m2.cv, s = "lambda.min")$beta)
as.vector(coef(m2.cv, s = "lambda.min")$theta)

</code></pre>

<hr>
<h2 id='coef.cv.ernet'>Get coefficients from a cv.ernet object</h2><span id='topic+coef.cv.ernet'></span>

<h3>Description</h3>

<p>This function gets coefficients from a cross-validated ernet model, using
the fitted <code>cv.ernet</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.ernet'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.ernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.ernet">cv.ernet</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.cv.ernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the value <code>s="lambda.1se"</code> stored on the CV
<code>object</code>, it is the largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum. Alternatively <code>s="lambda.min"</code>
can be used, it is the optimal value of <code>lambda</code> that gives minimum
cross validation error <code>cvm</code>. If <code>s</code> is numeric, it is taken as
the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="coef.cv.ernet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation
to get coefficients or make coefficient predictions.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on
to the <code><a href="#topic+predict">predict</a></code> method for <code><a href="#topic+ernet">ernet</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.ernet">cv.ernet</a></code>, <code><a href="#topic+predict.cv.ernet">predict.cv.ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1.cv &lt;- cv.ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
                  pf2 = pf2, standardize = FALSE, intercept = FALSE,
                  lambda2 = lambda2)
as.vector(coef(m1.cv, s = "lambda.min"))

</code></pre>

<hr>
<h2 id='coef.ernet'>Get coefficients from an ernet object</h2><span id='topic+coef.ernet'></span><span id='topic+coef.alspath'></span>

<h3>Description</h3>

<p>Computes the coefficients or returns a list of the indices of the nonzero
coefficients at the requested values for <code>lambda</code> from a fitted ernet
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ernet'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.ernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+ernet">ernet</a></code> model object.</p>
</td></tr>
<tr><td><code id="coef.ernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are to be made. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="coef.ernet_+3A_type">type</code></td>
<td>
<p>type <code>"coefficients"</code> computes coefficients at the requested
values for <code>s</code>. Type <code>"nonzero"</code> returns a list of the indices of
nonzero coefficients for each value of <code>s</code>. Default is
<code>"coefficients"</code>.</p>
</td></tr>
<tr><td><code id="coef.ernet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If
<code>s</code> is not in the lambda sequence used for fitting the model, the
<code>coef</code> function will use linear interpolation to make predictions. The
new values are interpolated using a fraction of coefficients from both left
and right <code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ernet">ernet</a></code>, <code><a href="#topic+predict.ernet">predict.ernet</a></code>,
<code><a href="#topic+print.ernet">print.ernet</a></code>, <code><a href="#topic+plot.ernet">plot.ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1 &lt;- ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
            pf2 = pf2, standardize = FALSE, intercept = FALSE,
            lambda2 = lambda2)
as.vector(coef(m1, s = m1$lambda[5]))

</code></pre>

<hr>
<h2 id='cpernet'>Regularization paths for the coupled sparse asymmetric least squares
(COSALES) regression (or the coupled sparse expectile regression)</h2><span id='topic+cpernet'></span>

<h3>Description</h3>

<p>Fits regularization paths for coupled sparse asymmetric least squares
regression at a sequence of regularization parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpernet(
  x,
  y,
  w = 1,
  nlambda = 100L,
  method = "cper",
  lambda.factor = ifelse(2 * nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  lambda2 = 0,
  pf.mean = rep(1, nvars),
  pf2.mean = rep(1, nvars),
  pf.scale = rep(1, nvars),
  pf2.scale = rep(1, nvars),
  exclude,
  dfmax = nvars + 1,
  pmax = min(dfmax * 1.2, nvars),
  standardize = TRUE,
  intercept = TRUE,
  eps = 1e-08,
  maxit = 1000000L,
  tau = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpernet_+3A_x">x</code></td>
<td>
<p>matrix of predictors, of dimension (nobs * nvars); each row is an
observation.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_y">y</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_w">w</code></td>
<td>
<p>weight applied to the asymmetric squared error loss of the mean
part. See details. Default is 1.0.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of <code>lambda</code> values (default is 100).</p>
</td></tr>
<tr><td><code id="cpernet_+3A_method">method</code></td>
<td>
<p>a character string specifying the loss function to use. Only
<code>cper</code> is available now.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>The factor for getting the minimal lambda in the
<code>lambda</code> sequence, where we set <code>min(lambda)</code> =
<code>lambda.factor</code> * <code>max(lambda)</code> with <code>max(lambda)</code> being the
smallest value of <code>lambda</code> that penalizes all coefficients to zero.
The default value depends on the relationship between <code class="reqn">N</code> (the number
of observations) and <code class="reqn">p</code> (the number of predictors). If <code class="reqn">N &lt; p</code>,
the default is <code>0.01</code>. If <code class="reqn">N &gt; p</code>, the default is <code>0.0001</code>,
closer to zero. A very small value of <code>lambda.factor</code> will lead to a
saturated fit. The argument takes no effect if there is a user-supplied
<code>lambda</code> sequence.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied <code>lambda</code> sequence. Typically, by leaving
this option unspecified users can have the program compute its own
<code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.factor</code>. It
is better to supply, if necessary, a decreasing sequence of <code>lambda</code>
values than a single (small) value. The program will ensure that the
user-supplied <code>lambda</code> sequence is sorted in decreasing order.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_lambda2">lambda2</code></td>
<td>
<p>regularization parameter <code>lambda2</code> for the quadratic
penalty of the coefficients. Default is 0, meaning no L2 penalization.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_pf.mean">pf.mean</code>, <code id="cpernet_+3A_pf.scale">pf.scale</code></td>
<td>
<p>L1 penalty factor of length <code class="reqn">p</code> used for adaptive
LASSO or adaptive elastic net. Separate L1 penalty weights can be applied
to each mean or scale coefficient to allow different L1 shrinkage. Can be 0
for some variables, which imposes no shrinkage and results in that variable
being always included in the model. Default is 1 for all variables (and
implicitly infinity for variables listed in <code>exclude</code>).</p>
</td></tr>
<tr><td><code id="cpernet_+3A_pf2.mean">pf2.mean</code>, <code id="cpernet_+3A_pf2.scale">pf2.scale</code></td>
<td>
<p>L2 penalty factor of length <code class="reqn">p</code> used for
adaptive elastic net. Separate L2 penalty weights can be applied to each
mean or scale coefficient to allow different L2 shrinkage. Can be 0 for
some variables, which imposes no shrinkage. Default is 1 for all variables.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_exclude">exclude</code></td>
<td>
<p>indices of variables to be excluded from the model. Default is
none. Equivalent to an infinite penalty factor.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_dfmax">dfmax</code></td>
<td>
<p>limit the maximum number of variables in the model. Useful for
very large <code class="reqn">p</code>, if a partial path is desired. Default is <code class="reqn">p+1</code>.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_pmax">pmax</code></td>
<td>
<p>limit the maximum number of variables ever to be nonzero. For
example once <code class="reqn">\beta</code> enters the model, no matter how many times it
exits or re-enters the model through the path, it will be counted only
once. Default is <code>min(dfmax*1.2, p)</code>.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_standardize">standardize</code></td>
<td>
<p>logical flag for variable standardization, prior to
fitting the model sequence. The coefficients are always returned to the
original scale. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default=TRUE) or set to zero
(FALSE).</p>
</td></tr>
<tr><td><code id="cpernet_+3A_eps">eps</code></td>
<td>
<p>convergence threshold for coordinate descent. Each inner
coordinate descent loop continues until the maximum change in any
coefficient is less than <code>eps</code>. Defaults value is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of outer-loop iterations allowed at fixed lambda
values. Default is 1e7. If the algorithm does not converge, consider
increasing <code>maxit</code>.</p>
</td></tr>
<tr><td><code id="cpernet_+3A_tau">tau</code></td>
<td>
<p>the parameter <code>tau</code> in the coupled ALS regression model. The
value must be in (0,1) and cannot be 0.5. Default is 0.8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the objective function in <code>cpernet</code> is
</p>
<p style="text-align: center;"><code class="reqn">w*1'\Psi(y-X\beta,0.5)/N + 1'\Psi(y-X\beta-X\theta,\tau)/N +
  \lambda_1*\Vert\beta\Vert_1 + 0.5\lambda_2\Vert\beta\Vert_2^2 +
  \mu_1*\Vert\theta\Vert +
  0.5\mu_2\Vert\theta\Vert_2^2,</code>
</p>
<p> where
<code class="reqn">\Psi(u,\tau)=|\tau-I(u&lt;0)|*u^2</code> denotes the asymmetric squared error
loss and the penalty is a combination of L1 and L2 terms for both the mean
and scale coefficients.
</p>
<p>For faster computation, if the algorithm is not converging or running slow,
consider increasing <code>eps</code>, decreasing <code>nlambda</code>, or increasing
<code>lambda.factor</code> before increasing <code>maxit</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code><a href="#topic+cpernet">cpernet</a></code>. </p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call
that produced this object.</p>
</td></tr> <tr><td><code>b0</code>, <code>t0</code></td>
<td>
<p>intercept sequences both of
length <code>length(lambda)</code> for the mean and scale respectively.</p>
</td></tr>
<tr><td><code>beta</code>, <code>theta</code></td>
<td>
<p><code>p*length(lambda)</code> matrices of coefficients for the
mean and scale respectively, stored as sparse matrices (<code>dgCMatrix</code>
class, the standard class for sparse numeric matrices in the <code>Matrix</code>
package). To convert them into normal R matrices, use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df.beta</code>, <code>df.theta</code></td>
<td>
<p>the number of nonzero mean and scale coefficients
respectively for each value of <code>lambda</code>.</p>
</td></tr> <tr><td><code>dim</code></td>
<td>
<p>dimensions of
coefficient matrices.</p>
</td></tr> <tr><td><code>npasses</code></td>
<td>
<p>total number of iterations summed
over all lambda values.</p>
</td></tr> <tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0
if no error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>References</h3>

<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661–2694.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cpernet">plot.cpernet</a></code>, <code><a href="#topic+coef.cpernet">coef.cpernet</a></code>,
<code><a href="#topic+predict.cpernet">predict.cpernet</a></code>, <code><a href="#topic+print.cpernet">print.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2 &lt;- cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
              pf.mean = pf, pf.scale = pf2,
              standardize = FALSE, lambda2 = lambda2)

</code></pre>

<hr>
<h2 id='cv.cpernet'>Cross-validation for cpernet</h2><span id='topic+cv.cpernet'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for <code>cpernet</code>, produces a plot, and returns
a value for <code>lambda</code>. This function is based on the <code>cv</code> function
from the <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.cpernet(
  x,
  y,
  w = 1,
  lambda = NULL,
  pred.loss = "loss",
  nfolds = 5,
  foldid,
  tau = 0.8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.cpernet_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code><a href="#topic+cpernet">cpernet</a></code>.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_y">y</code></td>
<td>
<p>response variable <code>y</code> as in <code><a href="#topic+cpernet">cpernet</a></code>.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_w">w</code></td>
<td>
<p>weight applied to the asymmetric squared error loss of the mean
part. Default is 1.0.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_lambda">lambda</code></td>
<td>
<p>optional user-supplied lambda sequence; default is <code>NULL</code>,
and <code><a href="#topic+cpernet">cpernet</a></code> chooses its own sequence.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_pred.loss">pred.loss</code></td>
<td>
<p>loss function used to calculate cross-validation error. The
only option now is <code>"loss"</code>, which is the asymmetric squared error
loss (ASEL).</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds. Default value is 5. Although <code>nfolds</code> can
be as large as the sample size (leave-one-out CV), it is not recommended
for large datasets. Smallest value allowed is 3.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfolds</code>,
identifying what fold each observation is in. If supplied, <code>nfolds</code>
will be supressed.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_tau">tau</code></td>
<td>
<p>the asymmetry coefficient <code class="reqn">\tau</code> used in the asymmetric
squared error loss.</p>
</td></tr>
<tr><td><code id="cv.cpernet_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to cpernet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code><a href="#topic+cpernet">cpernet</a></code> <code>nfolds</code>+1 times. The
first gets the <code>lambda</code> sequence, and the remainder fits the model
with each of the folds removed. The average error and standard deviation
over the folds are computed.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+cv.cpernet">cv.cpernet</a></code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the mean cross-validated error - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>a list of two components, each representing the number of
non-zero coefficients at each <code>lambda</code> in the mean and scale part.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for plotting
purposes).</p>
</td></tr>
<tr><td><code>cpernet.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+cpernet">cpernet</a></code> object for the full
data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives minimum
cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpernet">cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2.cv &lt;- cv.cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
                    pf.mean = pf, pf.scale = pf2,
                    standardize = FALSE, lambda2 = lambda2)

</code></pre>

<hr>
<h2 id='cv.ernet'>Cross-validation for ernet</h2><span id='topic+cv.ernet'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for ernet, produces a plot, and returns a value
for <code>lambda</code>. This function is based on the <code>cv</code> function from the
<code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.ernet(
  x,
  y,
  lambda = NULL,
  pred.loss = "loss",
  nfolds = 5,
  foldid,
  tau = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.ernet_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code><a href="#topic+ernet">ernet</a></code>.</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_y">y</code></td>
<td>
<p>response variable <code>y</code> as in <code><a href="#topic+ernet">ernet</a></code>.</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_lambda">lambda</code></td>
<td>
<p>optional user-supplied lambda sequence; default is <code>NULL</code>,
and <code><a href="#topic+ernet">ernet</a></code> chooses its own sequence.</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_pred.loss">pred.loss</code></td>
<td>
<p>loss function used to calculate cross-validation error. The
only option now is <code>"loss"</code>, which is the asymmetric squared error
loss (ASEL).</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds. Default value is 5. Although <code>nfolds</code> can
be as large as the sample size (leave-one-out CV), it is not recommended
for large datasets. Smallest value allowed is 3.</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfolds</code>,
identifying what fold each observation is in. If supplied, <code>nfolds</code>
will be supressed.</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_tau">tau</code></td>
<td>
<p>the asymmetry coefficient <code class="reqn">\tau</code> used in the asymmetric
squared error loss.</p>
</td></tr>
<tr><td><code id="cv.ernet_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to ernet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code><a href="#topic+ernet">ernet</a></code> <code>nfolds</code>+1 times; the
first to get the <code>lambda</code> sequence, and the remainder to compute the
fit with each of the folds removed. The average error and standard
deviation over the folds are computed.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+cv.ernet">cv.ernet</a></code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the mean cross-validated error - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients at each <code>lambda</code>.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for plotting
purposes).</p>
</td></tr>
<tr><td><code>ernet.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+ernet">ernet</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives minimum
cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ernet">ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1.cv &lt;- cv.ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
                  pf2 = pf2, standardize = FALSE, intercept = FALSE,
                  lambda2 = lambda2)

</code></pre>

<hr>
<h2 id='ernet'>Regularization paths for the sparse asymmetric least squares (SALES)
regression (or the sparse expectile regression)</h2><span id='topic+ernet'></span>

<h3>Description</h3>

<p>Fits regularization paths for the Lasso or elastic net penalized asymmetric
least squares regression at a sequence of regularization parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ernet(
  x,
  y,
  nlambda = 100L,
  method = "er",
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  lambda2 = 0,
  pf = rep(1, nvars),
  pf2 = rep(1, nvars),
  exclude,
  dfmax = nvars + 1,
  pmax = min(dfmax * 1.2, nvars),
  standardize = TRUE,
  intercept = TRUE,
  eps = 1e-08,
  maxit = 1000000L,
  tau = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ernet_+3A_x">x</code></td>
<td>
<p>matrix of predictors, of dimension (nobs * nvars); each row is an
observation.</p>
</td></tr>
<tr><td><code id="ernet_+3A_y">y</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="ernet_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of <code>lambda</code> values (default is 100).</p>
</td></tr>
<tr><td><code id="ernet_+3A_method">method</code></td>
<td>
<p>a character string specifying the loss function to use. only
<code>er</code> is available now.</p>
</td></tr>
<tr><td><code id="ernet_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>The factor for getting the minimal lambda in the
<code>lambda</code> sequence, where we set <code>min(lambda)</code> =
<code>lambda.factor</code> * <code>max(lambda)</code> with <code>max(lambda)</code> being the
smallest value of <code>lambda</code> that penalizes all coefficients to zero.
The default depends on the relationship between <code class="reqn">N</code> (the number of rows
in the matrix of predictors) and <code class="reqn">p</code> (the number of predictors). If
<code class="reqn">N &lt; p</code>, the default is <code>0.01</code>. If <code class="reqn">N &gt; p</code>, the default is
<code>0.0001</code>, closer to zero. A very small value of <code>lambda.factor</code>
will lead to a saturated fit. It takes no effect if there is a
user-supplied <code>lambda</code> sequence.</p>
</td></tr>
<tr><td><code id="ernet_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied <code>lambda</code> sequence. Typically, by leaving
this option unspecified users can have the program compute its own
<code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.factor</code>. It
is better to supply, if necessary, a decreasing sequence of <code>lambda</code>
values than a single (small) value. The program will ensure that the
user-supplied <code>lambda</code> sequence is sorted in decreasing order before
fitting the model.</p>
</td></tr>
<tr><td><code id="ernet_+3A_lambda2">lambda2</code></td>
<td>
<p>regularization parameter <code>lambda2</code> for the quadratic
penalty of the coefficients.</p>
</td></tr>
<tr><td><code id="ernet_+3A_pf">pf</code></td>
<td>
<p>L1 penalty factor of length <code class="reqn">p</code> used for the adaptive LASSO or
adaptive elastic net. Separate L1 penalty weights can be applied to each
coefficient to allow different L1 shrinkage. Can be 0 for some variables,
which imposes no shrinkage, and results in that variable always be included
in the model. Default is 1 for all variables (and implicitly infinity for
variables listed in <code>exclude</code>).</p>
</td></tr>
<tr><td><code id="ernet_+3A_pf2">pf2</code></td>
<td>
<p>L2 penalty factor of length <code class="reqn">p</code> used for adaptive elastic net.
Separate L2 penalty weights can be applied to each coefficient to allow
different L2 shrinkage. Can be 0 for some variables, which imposes no
shrinkage. Default is 1 for all variables.</p>
</td></tr>
<tr><td><code id="ernet_+3A_exclude">exclude</code></td>
<td>
<p>indices of variables to be excluded from the model. Default is
none. Equivalent to an infinite penalty factor.</p>
</td></tr>
<tr><td><code id="ernet_+3A_dfmax">dfmax</code></td>
<td>
<p>the maximum number of variables allowed in the model. Useful for
very large <code class="reqn">p</code> when a partial path is desired. Default is <code class="reqn">p+1</code>.</p>
</td></tr>
<tr><td><code id="ernet_+3A_pmax">pmax</code></td>
<td>
<p>the maximum number of coefficients allowed ever to be nonzero.
For example once <code class="reqn">\beta</code> enters the model, no matter how many times it
exits or re-enters the model through the path, it will be counted only
once. Default is <code>min(dfmax*1.2, p)</code>.</p>
</td></tr>
<tr><td><code id="ernet_+3A_standardize">standardize</code></td>
<td>
<p>logical flag for variable standardization, prior to
fitting the model sequence. The coefficients are always returned to the
original scale. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ernet_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default is <code>TRUE</code>) or
set to zero (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="ernet_+3A_eps">eps</code></td>
<td>
<p>convergence threshold for coordinate descent. Each inner
coordinate descent loop continues until the maximum change in any
coefficient is less than <code>eps</code>. Defaults value is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="ernet_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of outer-loop iterations allowed at fixed lambda
values. Default is 1e7. If the algorithm does not converge, consider
increasing <code>maxit</code>.</p>
</td></tr>
<tr><td><code id="ernet_+3A_tau">tau</code></td>
<td>
<p>the parameter <code class="reqn">\tau</code> in the ALS regression model. The value
must be in (0,1). Default is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the objective function in <code>ernet</code> is
</p>
<p style="text-align: center;"><code class="reqn">1'\Psi_{\tau}(y-X\beta)/N + \lambda_{1}*\Vert\beta\Vert_1 +
  0.5\lambda_{2}*\Vert\beta\Vert_2^2,</code>
</p>
<p> where
<code class="reqn">\Psi_{\tau}</code> denotes the asymmetric squared error loss and
the penalty is a combination of weighted L1 and L2 terms.
</p>
<p>For faster computation, if the algorithm is not converging or running slow,
consider increasing <code>eps</code>, decreasing <code>nlambda</code>, or increasing
<code>lambda.factor</code> before increasing <code>maxit</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code><a href="#topic+ernet">ernet</a></code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of coefficients, stored as a
sparse matrix (<code>dgCMatrix</code> class, the standard class for sparse
numeric matrices in the <code>Matrix</code> package.). To convert it into normal
type matrix use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero coefficients for each value of
<code>lambda</code>.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of coefficient matrix</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>total number of iterations summed over all lambda values</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0 if no error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>References</h3>

<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661–2694.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ernet">plot.ernet</a></code>, <code><a href="#topic+coef.ernet">coef.ernet</a></code>,
<code><a href="#topic+predict.ernet">predict.ernet</a></code>, <code><a href="#topic+print.ernet">print.ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1 &lt;- ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
            pf2 = pf2, standardize = FALSE, intercept = FALSE,
            lambda2 = lambda2)

</code></pre>

<hr>
<h2 id='plot.cpernet'>Plot coefficients from a cpernet object</h2><span id='topic+plot.cpernet'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a fitted
cpernet object. This function is modified based on the <code>plot</code> method in
the <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpernet'
plot(x, xvar = c("norm", "lambda"), color = FALSE, label = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cpernet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+cpernet">cpernet</a></code> model</p>
</td></tr>
<tr><td><code id="plot.cpernet_+3A_xvar">xvar</code></td>
<td>
<p>what is on the x-axis. <code>"norm"</code> plots against the L1-norm of
the coefficients, <code>"lambda"</code> against the log-lambda sequence.</p>
</td></tr>
<tr><td><code id="plot.cpernet_+3A_color">color</code></td>
<td>
<p>if <code>TRUE</code>, plot the curves with rainbow colors. Otherwise,
plot the curves with gray colors. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.cpernet_+3A_label">label</code></td>
<td>
<p>if <code>TRUE</code>, label the curves with variable sequence numbers.
Otherwise, do not put labels. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.cpernet_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two coefficient profile plots are produced, one for the mean
coefficients and the other for the scale coefficients.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cv.cpernet">plot.cv.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2 &lt;- cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
              pf.mean = pf, pf.scale = pf2, intercept = TRUE,
              standardize = FALSE, lambda2 = lambda2)
plot(m2)

</code></pre>

<hr>
<h2 id='plot.cv.cpernet'>Plot the cross-validated curve produced by cv.cpernet</h2><span id='topic+plot.cv.cpernet'></span>

<h3>Description</h3>

<p>Plots the cross-validated curve, and upper and lower standard deviation
curves, as a function of the <code>lambda</code> values used. This function is
modified based on the <code>plot.cv.glmnet</code> function from the <code>glmnet</code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.cpernet'
plot(x, sign.lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.cpernet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+cv.cpernet">cv.cpernet</a></code> object</p>
</td></tr>
<tr><td><code id="plot.cv.cpernet_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>either plot against <code>log(lambda)</code> (default) or its
negative if <code>sign.lambda=-1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.cpernet_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot is produced.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cpernet">plot.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2.cv &lt;- cv.cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
                    pf.mean = pf, pf.scale = pf2,
                    standardize = FALSE, lambda2 = lambda2)
plot(m2.cv)

</code></pre>

<hr>
<h2 id='plot.cv.ernet'>Plot the cross-validated curve produced by cv.ernet</h2><span id='topic+plot.cv.ernet'></span>

<h3>Description</h3>

<p>Plots the cross-validated curve, and upper and lower standard deviation
curves, as a function of the <code>lambda</code> values used. This function is
modified based on the <code>plot.cv.glmnet</code> function from the <code>glmnet</code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.ernet'
plot(x, sign.lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.ernet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+cv.ernet">cv.ernet</a></code> object</p>
</td></tr>
<tr><td><code id="plot.cv.ernet_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>either plot against <code>log(lambda)</code> (default) or its
negative if <code>sign.lambda=-1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.ernet_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot is produced.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ernet">plot.ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1.cv &lt;- cv.ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
                  pf2 = pf2, standardize = FALSE, intercept = FALSE,
                  lambda2 = lambda2)
plot(m1.cv)

</code></pre>

<hr>
<h2 id='plot.ernet'>Plot coefficients from an ernet object</h2><span id='topic+plot.ernet'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a fitted
ernet object. This function is modified based on the <code>plot</code> method in
the <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ernet'
plot(x, xvar = c("norm", "lambda"), color = FALSE, label = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ernet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+ernet">ernet</a></code> model</p>
</td></tr>
<tr><td><code id="plot.ernet_+3A_xvar">xvar</code></td>
<td>
<p>what is on the x-axis. <code>"norm"</code> plots against the L1-norm of
the coefficients, <code>"lambda"</code> against the log-lambda sequence.</p>
</td></tr>
<tr><td><code id="plot.ernet_+3A_color">color</code></td>
<td>
<p>if <code>TRUE</code>, plot the curves with rainbow colors. Otherwise,
plot the curves with gray colors. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ernet_+3A_label">label</code></td>
<td>
<p>if <code>TRUE</code>, label the curves with variable sequence numbers.
Otherwise, do not put labels. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ernet_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cv.ernet">plot.cv.ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1 &lt;- ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
            pf2 = pf2, standardize = FALSE, intercept = FALSE,
            lambda2 = lambda2)
plot(m1)

</code></pre>

<hr>
<h2 id='predict'>Model predictions</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p><code>predict</code> is a generic function for predictions from the results of
various model fitting functions. The function invokes particular
<em>methods</em> which depend on the <code><a href="base.html#topic+class">class</a></code> of the first
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by <code>predict</code> depends on the
class of its argument. See the documentation of the particular methods for
details of what is produced by that method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ernet">predict.ernet</a></code>, <code><a href="#topic+predict.cpernet">predict.cpernet</a></code>.
</p>

<hr>
<h2 id='predict.cpernet'>Make predictions from a cpernet object</h2><span id='topic+predict.cpernet'></span><span id='topic+predict.cpalspath'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this function predicts fitted values from
a cpernet object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpernet'
predict(object, newx, s = NULL, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cpernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cpernet">cpernet</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.cpernet_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. NOTE: <code>newx</code> must be a matrix, <code>predict</code> function does not
accept a vector or other formats of <code>newx</code>.</p>
</td></tr>
<tr><td><code id="predict.cpernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are to be made. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.cpernet_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only <code>response</code> is available.
Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.cpernet_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If
<code>s</code> is not in the lambda sequence used for fitting the model, the
<code>predict</code> function will use linear interpolation to make predictions.
The new values are interpolated using a fraction of predicted values from
both left and right <code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpernet">cpernet</a></code>, <code><a href="#topic+coef.cpernet">coef.cpernet</a></code>,
<code><a href="#topic+plot.cpernet">plot.cpernet</a></code>, <code><a href="#topic+print.cpernet">print.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2 &lt;- cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
              pf.mean = pf, pf.scale = pf2,
              standardize = FALSE, lambda2 = lambda2)
predict(m2, newx = x, s = m2$lambda[50])

</code></pre>

<hr>
<h2 id='predict.cv.cpernet'>Make predictions from a cv.cpernet object</h2><span id='topic+predict.cv.cpernet'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated cpernet model, using
the fitted <code>cv.cpernet</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.cpernet'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.cpernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.cpernet">cv.cpernet</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.cpernet_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix. See documentation for <code>predict.cpernet</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.cpernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are to be made. Default is the value <code>s = "lambda.1se"</code> stored on the
CV object. Alternatively <code>s = "lambda.min"</code> can be used. If <code>s</code>
is numeric, it is taken as the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="predict.cv.cpernet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation
to make a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on
to the <code><a href="#topic+predict">predict</a></code> method for <code><a href="#topic+cpernet">cpernet</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.cpernet">cv.cpernet</a></code>, <code><a href="#topic+coef.cv.cpernet">coef.cv.cpernet</a></code>,
<code><a href="#topic+plot.cv.cpernet">plot.cv.cpernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2.cv &lt;- cv.cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
                    pf.mean = pf, pf.scale = pf2,
                    standardize = FALSE, lambda2 = lambda2)
as.vector(predict(m2.cv, newx = x, s = "lambda.min"))

</code></pre>

<hr>
<h2 id='predict.cv.ernet'>Make predictions from a cv.ernet object</h2><span id='topic+predict.cv.ernet'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated ernet model, using
the fitted <code>cv.ernet</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.ernet'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.ernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.ernet">cv.ernet</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.ernet_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix. See documentation for <code>predict.ernet</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.ernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are to be made. Default is the value <code>s = "lambda.1se"</code> stored on the
CV object. Alternatively <code>s = "lambda.min"</code> can be used. If <code>s</code>
is numeric, it is taken as the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="predict.cv.ernet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation
to make a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on
to the <code><a href="#topic+predict">predict</a></code> method for <code><a href="#topic+ernet">ernet</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.ernet">cv.ernet</a></code>, <code><a href="#topic+coef.cv.ernet">coef.cv.ernet</a></code>,
<code><a href="#topic+plot.cv.ernet">plot.cv.ernet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1.cv &lt;- cv.ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
                  pf2 = pf2, standardize = FALSE, intercept = FALSE,
                  lambda2 = lambda2)
as.vector(predict(m1.cv, newx = x, s = "lambda.min"))

</code></pre>

<hr>
<h2 id='predict.ernet'>Make predictions from an ernet object</h2><span id='topic+predict.ernet'></span><span id='topic+predict.alspath'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values from
a fitted ernet object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ernet'
predict(object, newx, s = NULL, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ernet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+ernet">ernet</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.ernet_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. NOTE: <code>newx</code> must be a matrix, <code>predict</code> function does not
accept a vector or other formats of <code>newx</code>.</p>
</td></tr>
<tr><td><code id="predict.ernet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions
are to be made. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.ernet_+3A_type">type</code></td>
<td>
<p>type of prediction required. Only <code>response</code> is available.
Gives predicted response for regression problems.</p>
</td></tr>
<tr><td><code id="predict.ernet_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are to be made. If
<code>s</code> is not in the lambda sequence used for fitting the model, the
<code>predict</code> function will use linear interpolation to make predictions.
The new values are interpolated using a fraction of predicted values from
both left and right <code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ernet">ernet</a></code>, <code><a href="#topic+coef.ernet">coef.ernet</a></code>,
<code><a href="#topic+plot.ernet">plot.ernet</a></code>, <code><a href="#topic+print.ernet">print.ernet</a></code>
</p>

<hr>
<h2 id='print.cpernet'>Print a cpernet object</h2><span id='topic+print.cpernet'></span>

<h3>Description</h3>

<p>Print a summary of the <code>cpernet</code> path at each step along the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpernet'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cpernet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+cpernet">cpernet</a></code> object.</p>
</td></tr>
<tr><td><code id="print.cpernet_+3A_digits">digits</code></td>
<td>
<p>significant digits in the output.</p>
</td></tr>
<tr><td><code id="print.cpernet_+3A_...">...</code></td>
<td>
<p>additional print arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the <code><a href="#topic+cpernet">cpernet</a></code> object is printed,
followed by a three-column matrix with columns <code>Df1</code>, <code>Df2</code> and
<code>Lambda</code>. The <code>Df1</code> and <code>Df2</code> columns are the number of
nonzero mean and scale coefficients respectively.
</p>


<h3>Value</h3>

<p>a three-column matrix, the first two columns are the number of
nonzero mean and scale coefficients respectively and the third column is
<code>Lambda</code>.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.30
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
w &lt;- 2.0
lambda2 &lt;- 1
m2 &lt;- cpernet(y = y, x = x, w = w, tau = tau, eps = 1e-8,
              pf.mean = pf, pf.scale = pf2,
              standardize = FALSE, lambda2 = lambda2)
print(m2)

</code></pre>

<hr>
<h2 id='print.ernet'>Print an ernet object</h2><span id='topic+print.ernet'></span>

<h3>Description</h3>

<p>Print a summary of the ernet path at each step along the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ernet'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ernet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+ernet">ernet</a></code> object.</p>
</td></tr>
<tr><td><code id="print.ernet_+3A_digits">digits</code></td>
<td>
<p>significant digits in the output.</p>
</td></tr>
<tr><td><code id="print.ernet_+3A_...">...</code></td>
<td>
<p>additional print arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the <code><a href="#topic+ernet">ernet</a></code> object is printed,
followed by a two-column matrix with columns <code>Df</code> and <code>Lambda</code>.
The <code>Df</code> column is the number of nonzero coefficients.
</p>


<h3>Value</h3>

<p>a two-column matrix, the first columns is the number of nonzero
coefficients and the second column is <code>Lambda</code>.
</p>


<h3>Author(s)</h3>

<p>Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 400
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n)
tau &lt;- 0.90
pf &lt;- abs(rnorm(p))
pf2 &lt;- abs(rnorm(p))
lambda2 &lt;- 1
m1 &lt;- ernet(y = y, x = x, tau = tau, eps = 1e-8, pf = pf,
            pf2 = pf2, standardize = FALSE, intercept = FALSE,
            lambda2 = lambda2)
print(m1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
