<!DOCTYPE html><html lang="en"><head><title>Help for package HMMRel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HMMRel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HMMRel-package'><p>HMMRel - Hidden Markov Models for Reliability and Maintenance</p></a></li>
<li><a href='#cost.cspc'>
<p>Maintenance Policy based on Critical State Probability Critera.</p></a></li>
<li><a href='#cost.wcspc'>
<p>Maintenance Policy based on Warning Signal Probability Criteria.</p></a></li>
<li><a href='#def.hmmR'>
<p>Define a HMM object for Reliability Analysis.</p></a></li>
<li><a href='#fit.hmmR'>
<p>Non-parametric fitting of a HMM using the Baum-Welch algorithm.</p></a></li>
<li><a href='#Rcalc.hmmR'>
<p>Calculate the reliability of a system based on HMM.</p></a></li>
<li><a href='#sim.hmmR'>
<p>Simulate sequence of states and signals of functioning of a system modelled by a HMM.</p></a></li>
<li><a href='#Virkler25'>
<p>Fatigue crack growth in materials: Virkler dataset (tests 1 to 25)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Hidden Markov Models for Reliability and Maintenance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>M.L. Gamiz [aut, cre, cph],
  N. Limnios [aut, cph],
  M.C. Segovia-Garcia [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>M.L. Gamiz &lt;mgamiz@ugr.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Reliability Analysis and Maintenance Optimization using Hidden Markov Models (HMM). The use of HMMs to model the state of a system which is not directly observable and instead certain indicators (signals) of the true situation are provided via a control system. A hidden model can provide key information about the system dependability, such as the reliability of the system and related measures. An estimation procedure is implemented based on the Baum-Welch algorithm. Classical structures such as K-out-of-N systems and Shock models are illustrated. Finally, the maintenance of the system is considered in the HMM context and two functions for new preventive maintenance strategies are considered. Maintenance efficiency is measured in terms of expected cost. Methods are described in Gamiz, Limnios, and Segovia-Garcia (2023) &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2022.05.006">doi:10.1016/j.ejor.2022.05.006</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-19 12:15:20 UTC; Usuario</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-19 14:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='HMMRel-package'>HMMRel - Hidden Markov Models for Reliability and Maintenance</h2><span id='topic+HMMRel-package'></span>

<h3>Description</h3>

<p>Reliability Analysis and Maintenance Optimization using Hidden Markov Models (HMM).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    <strong>Package:</strong> </td><td style="text-align: left;"> HMMRel </td>
</tr>
<tr>
 <td style="text-align: left;">
    <strong>Type:</strong> </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
    <strong>Version:</strong> </td><td style="text-align: left;"> 1.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <strong>Date:</strong> </td><td style="text-align: left;"> 2024-11-11 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <strong>License:</strong> </td><td style="text-align: left;"> GPL version 2 or later </td>
</tr>
<tr>
 <td style="text-align: left;">
    <strong>Maintainer:</strong> </td><td style="text-align: left;"> M.L. Gamiz &lt;mgamiz@ugr.es&gt; </td>
</tr>
<tr>
 <td style="text-align: left;">
    <strong>URL:</strong> </td><td style="text-align: left;"> <a href="http://wpd.ugr.es/~reliastat">http://wpd.ugr.es/~reliastat</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>M.L. Gamiz, N.Limnios, and M.C. Segovia-Garcia
</p>


<h3>References</h3>

<p>Gamiz, M.L., Limnios, N., Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>

<hr>
<h2 id='cost.cspc'>
Maintenance Policy based on Critical State Probability Critera.
</h2><span id='topic+cost.cspc'></span>

<h3>Description</h3>

<p>Preventive maintenance based on Critical State Probability Criteria (CSPC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost.cspc(prob,hmmR,n.up1,cost.C,cost.P,t.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost.cspc_+3A_prob">prob</code></td>
<td>
<p> A real number in the interval (0,1).</p>
</td></tr>
<tr><td><code id="cost.cspc_+3A_hmmr">hmmR</code></td>
<td>
<p> A hidden Markov Model.</p>
</td></tr>
<tr><td><code id="cost.cspc_+3A_n.up1">n.up1</code></td>
<td>
<p> An integer value for indicating the total number of optimal performance states of the hidden MC. </p>
</td></tr>
<tr><td><code id="cost.cspc_+3A_cost.c">cost.C</code></td>
<td>
<p> A positive real number denoting the cost value in monetary units incurred by a corrective maintenance action.</p>
</td></tr>
<tr><td><code id="cost.cspc_+3A_cost.p">cost.P</code></td>
<td>
<p> A positive real number denoting the cost value in monetary units incurred by a preventive maintenance action.</p>
</td></tr>
<tr><td><code id="cost.cspc_+3A_t.max">t.max</code></td>
<td>
<p> A time value for the maximum time the system will be in use. After that time the system will not operate anymore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preventive maintenance policies based on critical states probability critera (CSPC) are considered.
Roughly speaking, a preventive maintenance action is carried out once the system enters a subset of operational states that are considered critical
in some sense. The subset of operative states <code>up</code> is in turn split into two subsets:
optimal states or <code>up1</code> and operative but critical states or <code>up2</code>, where <code>up</code>=<code>up1</code> <code class="reqn">\cup</code> <code>up2</code>.
For a given probability value (<code>prob</code>) this function first calculates the optimal inspection time </p>
<p style="text-align: center;"><code class="reqn">\code{t.insp}=\min \{t&gt;0: \Pr( X(t) \in \text{up2}, X(u) \in \text{up1}, \forall u &lt; t )\geq \code{prob}\}.</code>
</p>

<p>The system is inspected every <code>t.insp</code> time-units. At the time of inspection, any of three situations can be found:
</p>

<ol>
<li><p> the system is in failure, then the system is returned to operational conditions (<code>up1</code>), and a cost of <code>cost.C</code> monetary-units is implied;
</p>
</li>
<li><p> the system is in a state of <code>up2</code>, then a preventive maintenance action is carried out, returning the system to a state in <code>up1</code> and implying a cost of <code>cost.P</code> monetary-units; and
</p>
</li>
<li><p> the  system is found in a state of <code>up1</code>, then no maintenance action is carried out and there is no associated cost.
</p>
</li></ol>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>time.insp</code></td>
<td>
<p>The time at which preventive maintenance is carried out.</p>
</td></tr>
<tr><td><code>t.max</code></td>
<td>
<p>The maximum time that the system is being used.</p>
</td></tr>
<tr><td><code>n.insp</code></td>
<td>
<p>The total number of inspections that are carried out during the system lifetime, i.e. in the interval (0, <code>t.max</code>).</p>
</td></tr>
<tr><td><code>total.cost</code></td>
<td>
<p>The total cost incurred by all maintenance actions (corrective and preventive) developed in the system.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M.L. Gamiz, N. Limnios, and M.C. Segovia-Garcia (2024)
</p>


<h3>References</h3>

<p>Gamiz, M.L., Limnios, N., and Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>


<h3>See Also</h3>

<p>See <code>cost.wspc</code> for the implementation of the WSPC algorithm for maintenance policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model&lt;-'other'
rate&lt;-p&lt;-NA
P&lt;-matrix(c(8,2,1,0,6,4,6,2,2)/10,3,3,byrow=TRUE)
M&lt;-matrix(c(7,3,0,4,3,3,0,4,6)/10,3,3,byrow=TRUE)
Nx&lt;-3; Ny&lt;-3
n.up&lt;-2; n.green&lt;-2
alpha&lt;-c(1,0,0)
hmm1&lt;-def.hmmR(model=model,rate=NA,p=NA,alpha=alpha,P=P,M=M,Nx=Nx,Ny=Ny,n.up=n.up,n.green=n.green)
prob&lt;-0.8;
n.up1&lt;-n.green1&lt;-1;cost.C&lt;-10;cost.P&lt;-1;t.max&lt;-50
cost1&lt;-cost.cspc(prob=prob,hmmR=hmm1,n.up1=n.up1,cost.C=cost.C,cost.P=cost.P,t.max=t.max)
cost1
#
v.prob&lt;-seq(0.1,0.99,length=100)
v.cost1&lt;-inspection.time&lt;-double(100)
for(i in 1:100)
{cost&lt;-cost.cspc(prob=v.prob[i],hmmR=hmm1,n.up1=n.up1,
   cost.C=cost.C,cost.P=cost.P,t.max=t.max)
v.cost1[i]&lt;-cost$total.cost
inspection.time[i]&lt;-cost$time.insp
}
oldpar &lt;- par(mar = c(5, 5, 10, 10))
plot(v.prob,v.cost1,type='s',main='CSPC Algorithm for Maintenance Policy',
xlab='Probability of critical state',
ylab='Cost of maintenance')
grid()
par(oldpar)
</code></pre>

<hr>
<h2 id='cost.wcspc'>
Maintenance Policy based on Warning Signal Probability Criteria.
</h2><span id='topic+cost.wspc'></span>

<h3>Description</h3>

<p>Preventive maintenance based on Warning Signal Probability Criteria (WSPC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost.wspc(prob,hmmR,n.up1,n.green1,cost.C,cost.P,t.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cost.wcspc_+3A_prob">prob</code></td>
<td>
<p> A real number in the interval (0,1).</p>
</td></tr>
<tr><td><code id="cost.wcspc_+3A_hmmr">hmmR</code></td>
<td>
<p> A hidden Markov Model.</p>
</td></tr>
<tr><td><code id="cost.wcspc_+3A_n.up1">n.up1</code></td>
<td>
<p> An integer value for indicating the total number of optimal performance states of the hidden MC. </p>
</td></tr>
<tr><td><code id="cost.wcspc_+3A_n.green1">n.green1</code></td>
<td>
<p> An integer value for indicating the total number of safe signals. A safe signal indicates an optimal system performance.</p>
</td></tr>
<tr><td><code id="cost.wcspc_+3A_cost.c">cost.C</code></td>
<td>
<p> A positive real number denoting the cost value in monetary units incurred by a corrective maintenance action.</p>
</td></tr>
<tr><td><code id="cost.wcspc_+3A_cost.p">cost.P</code></td>
<td>
<p> A positive real number denoting the cost value in monetary units incurred by a preventive maintenance action.</p>
</td></tr>
<tr><td><code id="cost.wcspc_+3A_t.max">t.max</code></td>
<td>
<p> A time value for the maximum time the system will be in use. After that time the system will not operate anymore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preventive maintenance policies based on Warning Signal Probability criteria (WSPC) are considered.
Roughly speaking, a preventive maintenance action is carried out at a time when the probability that a warning signal is received is above a prespecified value <code>prob</code>.
The subset of operative states <code>up</code> is in turn split into two subsets:
optimal states or <code>up1</code> and operative but critical states or <code>up2</code>, where <code>up</code>=<code>up1</code><code class="reqn">\cup</code><code>up2</code>.
Similarly, the set of <code>green</code> signals is split into two subsets: <code>safe</code> signals and <code>warning</code> signals.
<code>n.green1</code> is the size of subset <code>safe</code>.
For a given probability value (<code>prob</code>) this function first calculates the optimal inspection time
</p>
<p style="text-align: center;"><code class="reqn">\code{t.insp}=\min \{t&gt;0: \Pr( Y(t) \in \text{warning}, Y(u) \in \text{safe}, \forall u &lt; t )\geq \code{prob}\}.</code>
</p>

<p>The system is inspected every <code>t.insp</code> units.of time. At the time of inspection, any of three situations can be found:
</p>

<ol>
<li><p> the system is in failure, then the system is returned to operational conditions (<code>up1</code>), and a cost of <code>cost.C</code> monetary-units is implied;
</p>
</li>
<li><p> the system is in a state of <code>up2</code>, then a preventive maintenance action is carried out, returning the system to a state in <code>up1</code> and implying a cost of <code>cost.P</code> monetary-units; and
</p>
</li>
<li><p> the system is found in a state of <code>up1</code>, then no maintenance action is carried out and there is no associated cost.
</p>
</li></ol>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>time.insp</code></td>
<td>
<p>The time at which preventive maintenance is carried out.</p>
</td></tr>
<tr><td><code>t.max</code></td>
<td>
<p>The maximum time that the system is being used.</p>
</td></tr>
<tr><td><code>n.insp</code></td>
<td>
<p>The total number of inspections that are carried out during the system lifetime, i.e. in the interval (0, <code>t.max</code>).</p>
</td></tr>
<tr><td><code>total.cost</code></td>
<td>
<p>The total cost incurred by all maintenance actions (corrective and preventive) developed in the system.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M.L. Gamiz, N. Limnios, and M.C. Segovia-Garcia (2024)
</p>


<h3>References</h3>

<p>Gamiz, M.L., Limnios, N., and Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>


<h3>See Also</h3>

<p>See <code>cost.cspc</code> for the implementation of the CSPC algorithm for maintenance policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model&lt;-'other'
rate&lt;-p&lt;-NA
P&lt;-matrix(c(8,2,1,0,6,4,6,2,2)/10,3,3,byrow=TRUE)
M&lt;-matrix(c(7,3,0,4,3,3,0,4,6)/10,3,3,byrow=TRUE)
Nx&lt;-3; Ny&lt;-3
n.up&lt;-2; n.green&lt;-2
alpha&lt;-c(1,0,0)
hmm1&lt;-def.hmmR(model=model,rate=NA,p=NA,alpha=alpha,P=P,M=M,Nx=Nx,Ny=Ny,n.up=n.up,n.green=n.green)
prob&lt;-0.8;
n.up1&lt;-n.green1&lt;-1;cost.C&lt;-10;cost.P&lt;-5;t.max&lt;-50
cost1&lt;-cost.wspc(prob=prob,hmmR=hmm1,n.up1=n.up1,n.green1=n.green1,
         cost.C=cost.C,cost.P=cost.P,t.max=t.max)
cost1
#
v.prob&lt;-seq(0.1,0.99,length=100)
v.cost1&lt;-inspection.time&lt;-double(100)
for(i in 1:100)
{cost&lt;-cost.wspc(prob=v.prob[i],hmmR=hmm1,n.up1=n.up1,n.green1=n.green1,
cost.C=cost.C,cost.P=cost.P,t.max=t.max)
v.cost1[i]&lt;-cost$total.cost
#inspection.time[i]&lt;-cost$time.insp
}
oldpar&lt;-par(mar=c(5,5,10,10))
plot(v.prob,v.cost1,type='s',main='WSPC Algorithm for Maintenance Policy',
      xlab='Probability of critical state',
     ylab='Cost of maintenance')
grid()
par(oldpar)
</code></pre>

<hr>
<h2 id='def.hmmR'>
Define a HMM object for Reliability Analysis.
</h2><span id='topic+def.hmmR'></span>

<h3>Description</h3>

<p>This function creates a list with all the elements that describe a HMM in the context of Reliability and Maintenance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def.hmmR(model,rate,p,alpha,P,M,Nx,Ny,n.up,n.green)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="def.hmmR_+3A_model">model</code></td>
<td>
<p> A character string to choose which HMM model is considered. Possible values are &quot;KooN&quot;, &quot;shock&quot;, &quot;other&quot;</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_rate">rate</code></td>
<td>
<p> A positive real number indicating the failure rate of one unit of the system.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_p">p</code></td>
<td>
<p> A real number in the interval (0,1) indicating the probability that the system receives one shock during a unit of time.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_alpha">alpha</code></td>
<td>
<p> A vector of size <code>Nx</code> with the initial law of the hidden Markov chain.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_p">P</code></td>
<td>
<p> A square matrix of dimension <code>Nx</code> with the transition probabilities between the hidden states.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_m">M</code></td>
<td>
<p> A matrix of dimension <code>Nx</code> <code class="reqn">\times</code> <code>Ny</code> with the emission probabilities.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_nx">Nx</code></td>
<td>
<p> An integer indicating the total number of states in the system. By default the states are labelled: 1,...,<code>Nx</code>.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_ny">Ny</code></td>
<td>
<p> An integer indicating the total number of signals received.  By default the signals are labelled: 1,...,<code>Ny</code>.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_n.up">n.up</code></td>
<td>
<p> An integer lower than <code>Nx</code> indicating the number of (hidden) operative states in the system. The first <code>n.up</code> values in the state set denote operative states.</p>
</td></tr>
<tr><td><code id="def.hmmR_+3A_n.green">n.green</code></td>
<td>
<p> An integer lower then <code>Ny</code> indicating the number of signals of good performance. The first <code>n.green</code> signals are read as good performance of the system.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> When <code>model</code>=<code>"KooN"</code> the argument <code>Nx</code> is the maximum number of units in the system. There must be  <code>K</code>=<code>n.up</code> operative units for the system to function.
If <code>K</code>=1 a parallel system is built. If <code>K</code>=<code>Nx</code> a series system is built.
</p>
</li>
<li><p> When <code>model</code>=<code>"shock"</code> the argument <code>Nx</code> minus 1 is the maximum number of shocks that the system can accumulate before breakdown.
</p>
</li></ul>


<h3>Value</h3>

<p>A list with the elements of the HMM.
</p>
<table role = "presentation">
<tr><td><code>states</code></td>
<td>
<p>A set of <code>Nx</code> characters or integers decribing the hidden states of the system.</p>
</td></tr>
<tr><td><code>signals</code></td>
<td>
<p>A set of <code>Ny</code> characters or integers decribing the possible signals observed.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>A square matrix with <code>Nx</code> rows with the transition probabilities between the hidden states.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>A matrix of dimension <code>Nx</code> <code class="reqn">\times</code> <code>Ny</code> with the emission probabilities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M.L. Gamiz, N. Limnios, and M.C. Segovia-Garcia (2024)
</p>


<h3>References</h3>

<p>Gamiz, M.L., Limnios, N., and Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>


<h3>See Also</h3>

<p>See also <code>sim.hmmR</code> to simulate data from a given HMM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a HMM object describing a repairable system
## The system can be in one of 3 states: 2 up states and 1 down state.
## 3 different signals can be received: 2 good performance signals (green)
##  and 1 signal of failure (red)
P&lt;-matrix(c(8,2,1,0,6,4,6,2,2)/10,3,3,byrow=TRUE)
M&lt;-matrix(c(7,3,0,4,3,3,0,4,6)/10,3,3,byrow=TRUE)
Nx&lt;-3; Ny&lt;-3
n.up&lt;-2; n.green&lt;-2
alpha&lt;-c(1,0,0)
hmm1&lt;-def.hmmR(model='other',rate=NA,p=NA,alpha=alpha,P=P,M=M,Nx=Nx,Ny=Ny,
               n.up=n.up,n.green=n.green)
hmm1
</code></pre>

<hr>
<h2 id='fit.hmmR'>
Non-parametric fitting of a HMM using the Baum-Welch algorithm.
</h2><span id='topic+fit.hmmR'></span>

<h3>Description</h3>

<p>This function adapts the EM algorithm to fit the transition matrix of the hidden Markov chain as well as the emission probability matrix
of a HMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.hmmR(Y,P0,M0,alpha0,max.iter=50,epsilon=1e-9,Nx,Ny)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.hmmR_+3A_y">Y</code></td>
<td>
<p>A sequence of observations consisting of signals of system performance.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_p0">P0</code></td>
<td>
<p>A square matrix of dimension <code>Nx</code> with the transition probabilities of the hidden MC at the first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_m0">M0</code></td>
<td>
<p>A matrix of dimension <code>Nx</code> <code class="reqn">\times</code> <code>Ny</code> with the emission probabilities at the first step of the algorithm.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_alpha0">alpha0</code></td>
<td>
<p>A vector of size <code>Nx</code> with the initial distribution of the hidden Markov chain at the first iteration of the algorithm.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_max.iter">max.iter</code></td>
<td>
<p>An integer value with the maximum number of iterations in the iterative algorithm. Default value is <code>max.ite</code>=50.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric value with the tolerance in the iterative algorithm. Default value is <code>epsilon</code>=1e-9.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_nx">Nx</code></td>
<td>
<p>An integer value with the maximum number of states of the hidden Markov chain.</p>
</td></tr>
<tr><td><code id="fit.hmmR_+3A_ny">Ny</code></td>
<td>
<p>An integer value with the maximum number of signals emitted by the system.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>The argument <code>alpha0</code> representing the initial distribution of the hidden MC is fixed, and defined by the user. The argument <code>Nx</code> is the size of the state space of the hidden MC. As default, the set of numbers 1,...,<code>Nx</code> is the state space of the hidden MC.
</p>
</li>
<li><p><code>Ny</code> is the size of the alphabet of signals emitted.  As default, the set of numbers 1,...,<code>Ny</code> is the signal-alphabet.
</p>
</li>
<li><p>The successive iterations of the algorithm can be traced and information is accessible from the outcome of this function.
</p>
</li></ul>


<h3>Value</h3>

<p>Among other information, this function provides the following values:
</p>
<table role = "presentation">
<tr><td><code>P</code></td>
<td>
<p>A square matrix with <code>Nx</code> rows with the estimated transition probabilities.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>A matrix of <code>Nx</code> rows and <code>Ny</code> columns, with the estimated emission probabilities.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>An integer indicating the number of iterations performed in the algorithm.</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>A numeric value with the achieved tolerance value in the algorithm.</p>
</td></tr>
<tr><td><code>Fm</code></td>
<td>
<p>A matrix of dimension <code>n</code> <code class="reqn">\times</code> <code>Nx</code> with the estimated forward probability values at the last iteration of the algorithm, where <code>n</code> is the size of the observed vector <code>Y</code>. </p>
</td></tr>
<tr><td><code>Bm</code></td>
<td>
<p>A matrix of dimension <code>Nx</code> <code class="reqn">\times</code> <code>n</code> with the estimated forward probability values at the last iteration of the algorithm.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The estimated value of the Akaike statistics. The number of parameters to be estimated is <code>nparam</code>=<code>Nx</code>*(<code>Nx</code>-1)+<code>Nx</code>*(<code>Ny</code>-1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M.L. Gamiz, N. Limnios, and M.C. Segovia-Garcia (2024)
</p>


<h3>References</h3>

<p>Gamiz, M.L., Limnios, N., and Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>


<h3>See Also</h3>

<p>See <code>def.hmmR</code> to define an object HMM, and <code>sim.hmmR</code> to simulate a random path from a given HMM object.</p>


<h3>Examples</h3>

<pre><code class='language-R'>model&lt;-'other'
rate&lt;-NA
p&lt;-NA
P&lt;-matrix(c(0.7,0.3,1,0),2,2,byrow=TRUE)
M&lt;-matrix(c(0.6,0.4,0,0,0,1),2,3,byrow=TRUE)
alpha&lt;-c(1,0)
Nx&lt;-2
Ny&lt;-3
n.up&lt;-1
n.green&lt;-2
hmm0&lt;-def.hmmR(model,rate,p,alpha,P,M,Nx,Ny,n.up,n.green)
set.seed(1969)
datos&lt;-sim.hmmR(hmmR=hmm0,n=10)
estim&lt;-fit.hmmR(Y=datos$Yn,P0=P,M0=M,alpha0=alpha,max.iter=50,epsilon=1e-9,Ny=3,Nx=2)
estim$P;P
estim$M;M
</code></pre>

<hr>
<h2 id='Rcalc.hmmR'>
Calculate the reliability of a system based on HMM.
</h2><span id='topic+Rcalc.hmmR'></span>

<h3>Description</h3>

<p>For a given time <code>t</code> this function returns the value of the probability that the system does not fail in the interval <code>(0,t]</code>.
It gives the probability that the system survives and is still working beyond time <code>t</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rcalc.hmmR(hmmR,t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rcalc.hmmR_+3A_hmmr">hmmR</code></td>
<td>
<p> A Hidden Markov Model.</p>
</td></tr>
<tr><td><code id="Rcalc.hmmR_+3A_t">t</code></td>
<td>
<p> A value of time, it must be an integer equal or greater than 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state space is split into two subsets, i.e. <code>states</code>=<code>up</code> <code class="reqn">\cup</code> <code>down</code>. The subset <code>up</code> contains the states of good functioning, while the subset <code>down</code> contains the failure states.
The signals aphabet is split into two subsets, i.e. <code>signals</code>= <code>green</code> <code class="reqn">\cup</code> <code>red</code>.
A <code>green</code>-signal indicates good performance of the system, while a <code>red</code>-signal alerts of something wrong in the system.
This function returns the probability that the system has not entered the set of <code>down</code> states or any signal from the <code>red</code> subset of signals has been emitted at any time before <code>t</code>.
</p>


<h3>Value</h3>

<p>This function returns the probability that the system is working through a state in the <code>up</code> subset, and a <code>green</code> signal is being received.
If <code>t</code>=0, then the returned value is 1.
</p>


<h3>Author(s)</h3>

<p>M.L. Gamiz, N. Limnios, and M.C. Segovia-Garcia (2024)
</p>


<h3>References</h3>

<p>Gamiz, M. L., Limnios, N., and Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>


<h3>See Also</h3>

<p>See <code>def.hmmR</code> to define a HMM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model&lt;-'other'
rate&lt;-NA
p&lt;-NA
P&lt;-matrix(c(0.7,0.3,1,0),2,2,byrow=TRUE)
M&lt;-matrix(c(0.6,0.4,0,0,0,1),2,3,byrow=TRUE)
alpha&lt;-c(1,0)
Nx&lt;-2
Ny&lt;-3
n.up&lt;-1
n.green&lt;-2
hmm0&lt;-def.hmmR(model=model,rate=NA,p=NA,alpha=alpha,P=P,M=M,Nx=Nx,Ny=Ny,n.up=n.up,n.green=n.green)
times&lt;-0:30
Rt&lt;-Rcalc.hmmR(hmmR=hmm0,t=times)
oldpar &lt;- par(mar = c(5, 5, 10, 10))
plot(times,Rt,type='s',ylim=c(0,1),ylab='',xlab='time',main='Reliability based on HMM')
grid()
par(oldpar)
</code></pre>

<hr>
<h2 id='sim.hmmR'>
Simulate sequence of states and signals of functioning of a system modelled by a HMM.
</h2><span id='topic+sim.hmmR'></span>

<h3>Description</h3>

<p>This function simulates a sample path from a 2-dimensional HMM. It returns the hidden sequence of states and signals. At each time, the hidden state of the system is simulated from the HMM as well as the associated signal that informs on the system performance at that time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.hmmR(hmmR,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.hmmR_+3A_hmmr">hmmR</code></td>
<td>
<p> A Hidden Markov Model.</p>
</td></tr>
<tr><td><code id="sim.hmmR_+3A_n">n</code></td>
<td>
<p> An integer number indicating the length of the sequence of states and signals to be simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>sim.hmmR</code> returns a list with the following information:
</p>
<table role = "presentation">
<tr><td><code>Xn</code></td>
<td>
<p>The sequence of simulated hidden states.</p>
</td></tr>
<tr><td><code>Yn</code></td>
<td>
<p>The sequence of observed signals.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>The transition probability matrix of the hidden Markov chain (MC).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The initial distribution of the hidden MC.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>The emission probability matrix.</p>
</td></tr>
<tr><td><code>states</code></td>
<td>
<p>The set of hidden states of the system.</p>
</td></tr>
<tr><td><code>signal</code></td>
<td>
<p>The alphabet corresponding to the observations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M.L. Gamiz, N. Limnios, and M.C. Segovia-Garcia (2024)
</p>


<h3>References</h3>

<p>Gamiz, M.L., Limnios, N., Segovia-Garcia, M.C. (2023). Hidden Markov models in reliability and maintenance. European Journal of Operational Research, 304(3), 1242-1255.
</p>


<h3>See Also</h3>

<p>See <code>def.hmmR</code> to define a HMM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a HMM object describing a repairable system
P&lt;-matrix(c(8,2,1,0,6,4,6,2,2)/10,3,3,byrow=TRUE)
M&lt;-matrix(c(7,3,0,4,3,3,0,4,6)/10,3,3,byrow=TRUE)
hmm1&lt;-def.hmmR(model='other',rate=NA,p=NA,alpha=c(1,0,0),P=P,M=M,Nx=3,Ny=3,n.up=2,n.green=2)
sim.hmmR(hmmR=hmm1,n=20)
</code></pre>

<hr>
<h2 id='Virkler25'>
Fatigue crack growth in materials: Virkler dataset (tests 1 to 25)
</h2><span id='topic+Virkler25'></span>

<h3>Description</h3>

<p>The data consist of an aluminum alloy specimen that was tested to investigate fatigue crack propagation.
Starting from an initial crack of length 9 mm for a particular item in test, the number of cycles for the size of the crack to reach a predetermined value was recorded successively. That is, it is registered the number of cycles every time an increment of size 0.2 mm in length occurs. The experiment finishes once a critical size of the crack is reached, meaning the failure of the item. The data were first published in Virkler et al. (1979) where
there were 68 specimens tested to grow the initial crack of 9 mm to the final crack of 50 mm. The first 25 tests are included.</p>


<h3>Format</h3>

<p>A data frame with 26 variables:
</p>

<dl>
<dt>CrackLength</dt><dd><p>Length of the crack in the material.</p>
</dd>
<dt>CycleCount1</dt><dd><p>Cycle count for the first test.</p>
</dd>
<dt>CycleCount2</dt><dd><p>Cycle count for the second test.</p>
</dd>
<dt>CycleCount3</dt><dd><p>Cycle count for the third test.</p>
</dd>
<dt>CycleCount4</dt><dd><p>Cycle count for the fourth test.</p>
</dd>
<dt>CycleCount5</dt><dd><p>Cycle count for the fifth test.</p>
</dd>
<dt>CycleCount6</dt><dd><p>Cycle count for the sixth test.</p>
</dd>
<dt>CycleCount7</dt><dd><p>Cycle count for the seventh test.</p>
</dd>
<dt>CycleCount8</dt><dd><p>Cycle count for the eighth test.</p>
</dd>
<dt>CycleCount9</dt><dd><p>Cycle count for the ninth test.</p>
</dd>
<dt>CycleCount10</dt><dd><p>Cycle count for the tenth test.</p>
</dd>
<dt>CycleCount11</dt><dd><p>Cycle count for the eleventh test.</p>
</dd>
<dt>CycleCount12</dt><dd><p>Cycle count for the twelfth test.</p>
</dd>
<dt>CycleCount13</dt><dd><p>Cycle count for the thirteenth test.</p>
</dd>
<dt>CycleCount14</dt><dd><p>Cycle count for the fourteenth test.</p>
</dd>
<dt>CycleCount15</dt><dd><p>Cycle count for the fifteenth test.</p>
</dd>
<dt>CycleCount16</dt><dd><p>Cycle count for the sixteenth test.</p>
</dd>
<dt>CycleCount17</dt><dd><p>Cycle count for the seventeenth test.</p>
</dd>
<dt>CycleCount18</dt><dd><p>Cycle count for the eighteenth test.</p>
</dd>
<dt>CycleCount19</dt><dd><p>Cycle count for the nineteenth test.</p>
</dd>
<dt>CycleCount20</dt><dd><p>Cycle count for the twentieth test.</p>
</dd>
<dt>CycleCount21</dt><dd><p>Cycle count for the twenty-first test.</p>
</dd>
<dt>CycleCount22</dt><dd><p>Cycle count for the twenty-second test.</p>
</dd>
<dt>CycleCount23</dt><dd><p>Cycle count for the twenty-third test.</p>
</dd>
<dt>CycleCount24</dt><dd><p>Cycle count for the twenty-fourth test.</p>
</dd>
<dt>CycleCount25</dt><dd><p>Cycle count for the twenty-fifth test.</p>
</dd>
</dl>



<h3>References</h3>

<p>Virkler, D. A., Hillberry, B. M., and Goel, P. K. (1979). The statistical nature of fatigue
crack propagation. Journal of Engineering Materials and Technology, 101 , 148–153 .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Virkler25)
i&lt;-1 ## choose specimen number 1
ti&lt;-Virkler25[,(i+1)]/10000  ## cycles at which the cracksize increases 0.2 units.
yt&lt;-Virkler25[,1] ##
### the system is observed every 2000 cycles (0.2 unit times)
### observations:
t.obs&lt;-seq(0,max(ti),by=0.2)
yi&lt;-approx(x=ti,y=yt,xout=t.obs,method='linear',rule=2)$y
yi&lt;-diff(yi)
#discretize the observations:
yi&lt;-kmeans(yi,4)$cluster ## consider an alphabet of 4 signals
Nx&lt;-2; # consider 2 hidden states
Ny&lt;-4
alpha0&lt;-c(1,0)
estim&lt;-fit.hmmR(Y=yi,P0=NA,M0=NA,alpha0=alpha0,max.iter=50,epsilon=1e-9,Nx=Nx,Ny=Ny)
estim$P
estim$M
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
