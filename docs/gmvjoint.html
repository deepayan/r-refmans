<!DOCTYPE html><html lang="en"><head><title>Help for package gmvjoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmvjoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gmvjoint'>
<p>Joint Models of Survival and Multivariate Longitudinal Data</p></a></li>
<li><a href='#anova.joint'><p>Anova for joint models</p></a></li>
<li><a href='#boot.joint'><p>Bootstrapping a <code>joint</code> object</p></a></li>
<li><a href='#cond.ranefs'><p>Obtain conditional distribution of the random effects</p></a></li>
<li><a href='#dynPred'><p>Dynamic predictions for survival sub-model in a multivariate joint model.</p></a></li>
<li><a href='#extractAIC.joint'><p>Extract AIC from a joint model fit.</p></a></li>
<li><a href='#fitted.joint'><p>Obtain joint model fitted values</p></a></li>
<li><a href='#fixef.joint'><p>Extract fixed effects from a <code>joint</code> object.</p></a></li>
<li><a href='#joint'><p>Fit a joint model to time-to-event and multivariate longitudinal data</p></a></li>
<li><a href='#joint.object'><p>Fitted <code>joint</code> object</p></a></li>
<li><a href='#logLik.joint'><p>Log-likelihood for joint model.</p></a></li>
<li><a href='#parseCoxph'><p>Parsing the survival formula and constructing all survival-related data objects.</p></a></li>
<li><a href='#PBC'><p>Primary biliary cirrhosis data</p></a></li>
<li><a href='#plot.cond.b.joint'><p>Plot posterior distribution of the random effects for a <code>joint</code> model.</p></a></li>
<li><a href='#plot.dynPred'><p>Plot conditional survival probabilities.</p></a></li>
<li><a href='#plot.residuals.joint'><p>Plot joint model residuals</p></a></li>
<li><a href='#plot.ROC.joint'><p>Plot receiver operator characteristics.</p></a></li>
<li><a href='#ranef.joint'><p>Extract random effects from a <code>joint</code> object.</p></a></li>
<li><a href='#residuals.joint'><p>Obtain joint model residuals</p></a></li>
<li><a href='#rgenpois'><p>Simulate realisations from a generalised poisson distribution</p></a></li>
<li><a href='#ROC'><p>Receiver Operator Characteristics (ROC) for a <code>joint</code> model.</p></a></li>
<li><a href='#simData'><p>Simulate data from a multivariate joint model</p></a></li>
<li><a href='#summary.joint'><p>Summary of an <code>joint</code> object.</p></a></li>
<li><a href='#vcov.joint'><p>Extract the variance-covariance matrix from a <code>joint</code> fit.</p></a></li>
<li><a href='#xtable.joint'><p>Print an LaTeX-ready <code>xtable</code> for a <code>joint</code> object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Models of Survival and Multivariate Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit joint models of survival and multivariate longitudinal data. The longitudinal
    data is specified by generalised linear mixed models. The joint models are fit via maximum
    likelihood using an approximate expectation maximisation algorithm. 
    Bernhardt (2015) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2014.11.011">doi:10.1016/j.csda.2014.11.011</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), glmmTMB, survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6), MASS, methods, mvtnorm, pracma, reformulas,
stats, statmod, xtable</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jamesmurray7/gmvjoint">https://github.com/jamesmurray7/gmvjoint</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jamesmurray7/gmvjoint/issues">https://github.com/jamesmurray7/gmvjoint/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-05 21:00:06 UTC; lshjm44</td>
</tr>
<tr>
<td>Author:</td>
<td>James Murray [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Murray &lt;james.murray@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-05 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gmvjoint'>
Joint Models of Survival and Multivariate Longitudinal Data
</h2><span id='topic+gmvjoint-package'></span><span id='topic+gmvjoint'></span>

<h3>Description</h3>

<p>gmvjoint allows the user to fit joint models of survival and multivariate longitudinal data. The 
longitudinal data is specified by generalised linear mixed models (GLMMs). The joint models 
are fit via maximum likelihood using an approximate EM algorithm first proposed by Bernhardt et
al. (2015). The GLMMs are specified using the same syntax as for package <code>glmmTMB</code> Brooks et
al. (2017). The joint models themselves are then the  flexible extensions to those in e.g.
Wulfsohn and Tsiatis (1997). The user is able to simulate data under many different response
types.
</p>


<h3>Author(s)</h3>

 
<p>James Murray &lt;j.murray7@ncl.ac.uk&gt;
</p>


<h3>References</h3>

<p>Bernhardt PW, Zhang D and Wang HJ. A fast EM Algorithm for Fitting Joint Models of a Binary 
Response to Multiple Longitudinal Covariates Subject to Detection Limits. 
<em>Computational Statistics and Data Analysis</em> 2015; <strong>85</strong>; 37&ndash;53
</p>
<p>Mollie E. Brooks, Kasper Kristensen, Koen J. van Benthem, Arni Magnusson, Casper W. Berg, Anders
Nielsen, Hans J. Skaug, Martin Maechler and Benjamin M. Bolker (2017). glmmTMB Balances Speed and
Flexibility Among Packages for Zero-inflated Generalized Linear Mixed Modeling. 
<em>The R Journal</em>, <strong>9(2)</strong>, 378-400.
</p>
<p>Murray, J and Philipson P. A fast approximate EM algorithm for joint models of survival and
multivariate longitudinal data.<em>Computational Statistics and Data Analysis</em> 2022
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data
measured with error. <em>Biometrics.</em> 1997; <strong>53(1)</strong>, 330-339.
</p>

<hr>
<h2 id='anova.joint'>Anova for joint models</h2><span id='topic+anova.joint'></span>

<h3>Description</h3>

<p>Perform a likelihood ratio test between two (<strong>nested</strong>) <code>joint</code> 
models. The user must decide whether the models are truly nested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
anova(object, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function. This should be <strong>nested</strong>
in <code>object2</code>.</p>
</td></tr>
<tr><td><code id="anova.joint_+3A_object2">object2</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function. This should be more complex
than <code>object</code>.</p>
</td></tr>
<tr><td><code id="anova.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>anova.joint</code> with elements </p>

<dl>
<dt><code>mod0</code></dt><dd><p>the name of <code>object</code>.</p>
</dd>
<dt><code>l0</code></dt><dd><p>the log-likelihood of the nested model, i.e. fit under the null.</p>
</dd>
<dt><code>AIC0</code></dt><dd><p>AIC for <code>object</code>.</p>
</dd>
<dt><code>BIC0</code></dt><dd><p>BIC for <code>object</code>.</p>
</dd>
<dt><code>mod1</code></dt><dd><p>the name of <code>object2</code>.</p>
</dd>
<dt><code>l1</code></dt><dd><p>the log-likelihood under the alternative hypothesis.</p>
</dd>
<dt><code>AIC1</code></dt><dd><p>AIC for <code>object2</code>.</p>
</dd>
<dt><code>BIC1</code></dt><dd><p>BIC for <code>object2</code>.</p>
</dd>
<dt><code>LRT</code></dt><dd><p>likelihood ratio test statistic.</p>
</dd>
<dt><code>p</code></dt><dd><p>the p-value of <code>LRT</code>.</p>
</dd>
<dt><code>warnSurv</code></dt><dd><p>internal - logical value for printing difference in survival models.</p>
</dd>
<dt><code>warnRanefs</code></dt><dd><p>internal - logical value for printing difference in random effects
specifications.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint">joint</a></code> and <code><a href="#topic+logLik.joint">logLik.joint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rm(list=ls())
data(PBC)
# Compare quadratic vs linear time specification for log(serum bilirubin) -----
PBC$serBilir &lt;- log(PBC$serBilir)
long.formulas1 &lt;- list(serBilir ~ drug * time + (1 + time|id))
long.formulas2 &lt;- list(serBilir ~ drug * (time + I(time^2)) + (1 + time + I(time^2)|id))
surv.formula &lt;- Surv(survtime, status) ~ drug
family &lt;- list('gaussian')
# Fit the two competing models (fit is nested in fit2) ------------------------
fit &lt;- joint(long.formulas1, surv.formula, PBC, family, 
             control = list(verbose = FALSE))
fit2 &lt;- joint(long.formulas2, surv.formula, PBC, family, control = list(verbose = FALSE))
anova(fit, fit2)
# Quadratic terms improve fit significantly. 

</code></pre>

<hr>
<h2 id='boot.joint'>Bootstrapping a <code>joint</code> object</h2><span id='topic+boot.joint'></span>

<h3>Description</h3>

<p>Use an existing model fit by <code>joint</code> along with the data object originally
used and obtain a mean estimate, standard errors and 95% confidence interval using the
bootstrap. The original data is resampled by subject, not by observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.joint(
  fit,
  data,
  boot.size = NULL,
  nboot = 100L,
  replace = TRUE,
  progress = TRUE,
  use.MLEs = TRUE,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.joint_+3A_fit">fit</code></td>
<td>
<p>a joint model fit by the <code><a href="#topic+joint">joint</a></code> function.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_data">data</code></td>
<td>
<p>the original data used to fit the above joint model.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_boot.size">boot.size</code></td>
<td>
<p>integer, specifies the number of subjects to resample in the bootstrapping
approach. The default value is <code>boot.size = NULL</code> which defaults to the number of unique
subjects in the <code>joint</code> object.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_nboot">nboot</code></td>
<td>
<p>integer, specifies the number of bootstrap samples, default value is 
<code>nboot = 100L</code>.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_replace">replace</code></td>
<td>
<p>logical, should sampling be done with replacement? Defaults to 
<code>replace = TRUE</code>.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_progress">progress</code></td>
<td>
<p>logical, should a text progress bar showing overall progress be shown
and updated after each successful bootstrapped model fit? Defaults to <code>progress=TRUE</code>.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_use.mles">use.MLEs</code></td>
<td>
<p>logical, should the MLEs of the <code>fit</code> be used as initial conditions in 
each of the bootstrapped calls to <code>joint</code>? Defaults to <code>use.MLEs=TRUE</code> which
should help reduce the computational burden in fitting these bootstrap replicate <code>joint</code>
objects.</p>
</td></tr>
<tr><td><code id="boot.joint_+3A_control">control</code></td>
<td>
<p>a list of control arguments, with same possible arguments as shown in 
<code><a href="#topic+joint">joint</a></code>. Note that by default the <em>same</em> <code>control</code> arguments used in the
<code>joint</code> <code>fit</code> parameter are carried forwards, besides the items <code>return.dmats</code>,
<code>post.process</code>, and <code>verbose</code> which are all set to <code>FALSE</code> in <code>boot.joint</code>
in order to reduce memory overheads and computation time. Instead, the user
could lessen computational burden of this intensive bootstrapping by changing convergence 
criteria items e.g. <code>conv</code>, <code>tol.rel</code>, <code>tol.abs</code>, <code>tol.thr</code> in order to 
speed-up convergence of the <code>nboot</code> individual bootstrapped model fits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>boot.joint</code> which contains the MLEs from supplied <code>joint</code>
object, as well as the bootstrapped summaries and some model/computation information.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint">joint</a></code> <code><a href="#topic+vcov.joint">vcov.joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bivariate fit on PBC data -----------------------------------------
data(PBC)

# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'albumin', 'platelets'))
PBC &lt;- na.omit(PBC) 

# Specify bivariate fit
long.formulas &lt;- list(
  albumin ~ time*drug + (1 + time|id),
  platelets ~ time * drug + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;- joint(long.formulas, surv.formula, PBC, family = list('gaussian', 'poisson'))
# Set 50 bootstraps, with lower absolute tolerance and convergence of 'either'.
BOOT &lt;- boot.joint(fit, PBC, nboot = 50L, control = list(tol.abs = 5e-3, conv = 'either'),
                   use.MLEs = TRUE)
BOOT # Print to console via S3 method

</code></pre>

<hr>
<h2 id='cond.ranefs'>Obtain conditional distribution of the random effects</h2><span id='topic+cond.ranefs'></span>

<h3>Description</h3>

<p>Obtain the conditional distribution of the random effects of a <code>joint</code> model
fit. This is achieved by a Metropolis scheme. Approximate normality across random effects is
expected, and could be useful in diagnosing potential issues surrounding model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.ranefs(fit, burnin = 500L, N = 3500L, tune = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cond.ranefs_+3A_fit">fit</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="cond.ranefs_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations to discard, defaults to 500.</p>
</td></tr>
<tr><td><code id="cond.ranefs_+3A_n">N</code></td>
<td>
<p>Number of MC iterations to carry out <em>post</em> burn-in, defaults to 3500.</p>
</td></tr>
<tr><td><code id="cond.ranefs_+3A_tune">tune</code></td>
<td>
<p>Tuning parameter, problem-specific, defaults to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>cond.b.joint</code> containing: </p>

<dl>
<dt>walks</dt><dd><p>A list of length <code>n</code> containing the history of <code class="reqn">b_i</code> post burn-in.</p>
</dd>
<dt>acceptance</dt><dd><p>A numeric vector containing the acceptance rate for each sampled subject.</p>
</dd>
<dt>M</dt><dd><p>The ModelInfo list from <code>joint</code>. Used by S3 methods for class 
<code>cond.b.joint</code>.</p>
</dd>
<dt>bhats</dt><dd><p>Posterior estimates at MLEs for the random effects. Same as <code>ranef(joint)</code>.</p>
</dd>
<dt>Sigmahats</dt><dd><p>The covariances of <code>bhats</code>.</p>
</dd>
<dt>D</dt><dd><p>The MLE estimate for the variance-covariance matrix of random effects from 
<code>fit</code>.</p>
</dd>
<dt>q</dt><dd><p>Dimension of random effects.</p>
</dd>
<dt>K</dt><dd><p>Number of responses.</p>
</dd> 
<dt>qnames</dt><dd><p>The names of the random effects as determined by call to <code>joint</code>.</p>
</dd>
<dt>burnin</dt><dd><p>The amount of burn-in used.</p>
</dd>
<dt>N</dt><dd><p>Number of MC iterations.</p>
</dd>
<dt>tune</dt><dd><p>tuning parameter used</p>
</dd>
<dt>nobs</dt><dd><p>The number of observations for each subject for each response.</p>
</dd>
<dt>elapsed.time</dt><dd><p>Time taken for <code>cond.ranefs</code> to complete.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ranef.joint">ranef.joint</a></code> <code><a href="#topic+plot.cond.b.joint">plot.cond.b.joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- simData()$data
long.formulas &lt;- list(Y.1 ~ time + cont + bin + (1 + time|id), 
                      Y.2 ~ time + cont + bin + (1 + time|id))
surv.formula &lt;- Surv(survtime, status) ~ bin
fit &lt;- joint(long.formulas, surv.formula, dat, list("gaussian","gaussian"))
cond.b &lt;- cond.ranefs(fit, burnin = 50L, N = 1000, tune = 2)
cond.b
plot(cond.b) # Overall 
plot(cond.b, id = 1) # Plot the first subject (see plot.cond.b.joint).

</code></pre>

<hr>
<h2 id='dynPred'>Dynamic predictions for survival sub-model in a multivariate joint model.</h2><span id='topic+dynPred'></span>

<h3>Description</h3>

<p>Calculates individualised conditional survival probabilities for subjects
during a period of follow-up using a <code>joint</code> model fit along with requisite longitudinal 
process history. 
</p>
<p><strong>Note</strong> that this function is largely designed for use within the ROC function
which assesses discriminatory power of the joint model, however it <em>does</em> function
by itself with proper use of its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynPred(
  data,
  id,
  fit,
  u = NULL,
  nsim = 200,
  progress = TRUE,
  scale = NULL,
  df = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynPred_+3A_data">data</code></td>
<td>
<p>the data to which the original <code>joint</code> model was fit.</p>
</td></tr>
<tr><td><code id="dynPred_+3A_id">id</code></td>
<td>
<p>subject identifier, i.e. for which subject is the conditional survival probabilities 
desired?</p>
</td></tr>
<tr><td><code id="dynPred_+3A_fit">fit</code></td>
<td>
<p>a joint model fit by the  <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="dynPred_+3A_u">u</code></td>
<td>
<p>a numeric <code>vector</code> of candidate follow-up times for which a survival probability 
should be calculated. Note that the first item <code>u[1]</code> denotes the start of the &quot;window&quot;
and is dropped from calculations. If <code>u=NULL</code> (the default), then the probability of 
surviving all failure times after the <code>id</code>'s final longitudinal <code>time</code> is calculated.</p>
</td></tr>
<tr><td><code id="dynPred_+3A_nsim">nsim</code></td>
<td>
<p>how many Monte Carlo simulations should be carried out? Defaults to 
<code>nsim=200</code>. First-order estimates are calculated if <code>nsim=0</code>.</p>
</td></tr>
<tr><td><code id="dynPred_+3A_progress">progress</code></td>
<td>
<p>a logical, if <code>progress=TRUE</code> (the default) then a progress bar displaying
the current percentage of simulations have been completed.</p>
</td></tr>
<tr><td><code id="dynPred_+3A_scale">scale</code></td>
<td>
<p>numeric scales the variance-covariance parameter in the proposal distribution for 
the Metropolis-Hastings algorithm. Defaults to <code>scale = NULL</code> which doesn't scale the
variance term at all. Users are encouraged to experiment with values here; this parameter
controls the acceptance rate of the MH scheme.</p>
</td></tr>
<tr><td><code id="dynPred_+3A_df">df</code></td>
<td>
<p>numeric denotes the degrees of freedom of the proposed <code class="reqn">t</code> distribution on
the random effects; <code>df=4</code> is suggested and is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic predictions for the time-to-event process based on information available
on the subject's longitudinal process up to given time <code class="reqn">t</code> are calculated by Monte Carlo
simulation outlined in Rizopoulos (2011). For a subject last observed at time <code class="reqn">t</code>, the 
probability that they survive until future time <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
  Pr(T_i \ge u | T \ge t; \boldsymbol{Y}_i, \boldsymbol{b}_i; \boldsymbol{\Omega}) \approx
  \frac{S(u|\hat{\boldsymbol{b}}_i; \boldsymbol{\Omega})}
  {S(t|\hat{\boldsymbol{b}}_i; \boldsymbol{\Omega})}
</code>
</p>

<p>where <code class="reqn">T_i</code> is the true failure time for subject <code class="reqn">i</code>, <code class="reqn">\boldsymbol{Y}_i</code> their
longitudinal measurements up to time <code class="reqn">t</code>, and <code class="reqn">S()</code> the survival function.
</p>
<p><code class="reqn">\boldsymbol{\Omega}</code> is drawn from the multivariate normal distribution with mean
<code class="reqn">\hat{\boldsymbol{\Omega}}</code> and its variance taken from a fitted <code>joint</code> object.
<code class="reqn">\hat{\boldsymbol{b}}</code> is drawn from the <code class="reqn">t</code> distribution by means of a
Metropolis-Hastings algorithm with <code>nsim</code> iterations.
</p>


<h3>Value</h3>

<p>A list of class <code>dynPred</code> which consists of three items: </p>

<dl>
<dt><code>pi</code></dt><dd><p>A <code>data.frame</code> which contains each candidate failure time (supplied by
<code>u</code>), with the mean, median and 2.5% and 97.5% quantiles of probability of survival 
until this failure time.</p>
</dd>
<dt><code>pi.raw</code></dt><dd><p>A <code>matrix</code> of with <code>nsim</code> rows and <code>length(u)</code> columns,
each row represents the <code class="reqn">l</code>th conditional survival probability of survival each <code>u</code>
survival time. This is largely for debugging purposes.</p>
</dd>
<dt>MH.accept</dt><dd><p>The acceptance rate of the Metropolis-Hastings algorithm on the random
effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>References</h3>

<p>Bernhardt PW, Zhang D and Wang HJ. A fast EM Algorithm for Fitting Joint Models of a Binary 
Response to Multiple Longitudinal Covariates Subject to Detection Limits. 
<em>Computational Statistics and Data Analysis</em> 2015; <strong>85</strong>; 37&ndash;53
</p>
<p>Rizopoulos D. Dynamic predictions and prospective accuracy in joint models
for longitudinal and time-to-event data. <em>Biometrics</em> 2011;
<strong>67</strong>: 819â€“829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROC">ROC</a></code> and <code><a href="#topic+plot.dynPred">plot.dynPred</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(PBC)
PBC$serBilir &lt;- log(PBC$serBilir)
# Focus in on id 81, who fails at around 7 years of follow-up. \code{dynPred} allows us to
# infer how the model believes their survival probability would've progressed (ignoring the
# true outcome at start time).
# Univariate -----------------------------------------------------------
long.formulas &lt;- list(serBilir ~ drug * time + (1 + time|id))
surv.formula &lt;- Surv(survtime, status) ~ drug
family &lt;- list('gaussian')
fit &lt;- joint(long.formulas, surv.formula, PBC, family)
preds &lt;- dynPred(PBC, id = 81, fit = fit, u = NULL, nsim = 200,
                 scale = 2)
preds
plot(preds)
# Bivariate ------------------------------------------------------------
# Does introduction of albumin affect conditional survival probability?
long.formulas &lt;- list(
  serBilir ~ drug * time + I(time^2) + (1 + time + I(time^2)|id),
  albumin ~ drug * time + (1 + time|id)
)
fit &lt;- joint(long.formulas, surv.formula, data = PBC, family = list("gaussian", "gaussian"))
bi.preds &lt;- dynPred(PBC, id = 81, fit = fit, u = NULL, nsim = 200, 
                    scale = fit$coeffs$D/sqrt(fit$ModelInfo$n))
bi.preds
plot(bi.preds) # Appears to level-off dramatically; perhaps indicative of this id's albumin
               # levels, or acceleration in serBilir trajectory around 8.5 years.

</code></pre>

<hr>
<h2 id='extractAIC.joint'>Extract AIC from a joint model fit.</h2><span id='topic+extractAIC.joint'></span>

<h3>Description</h3>

<p>Extract AIC from a joint model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
extractAIC(fit, scale, k = 2, conditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractAIC.joint_+3A_fit">fit</code></td>
<td>
<p>A fitted <code>joint</code> object,</p>
</td></tr>
<tr><td><code id="extractAIC.joint_+3A_scale">scale</code></td>
<td>
<p>See <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>; not used.</p>
</td></tr>
<tr><td><code id="extractAIC.joint_+3A_k">k</code></td>
<td>
<p>Numeric specifying the &quot;weight&quot; of degrees of freedom (default <code>k=2</code>).</p>
</td></tr>
<tr><td><code id="extractAIC.joint_+3A_conditional">conditional</code></td>
<td>
<p>Should AIC of conditional or observed log-likelihood be used? Defaults
to <code>conditional = FALSE</code>.</p>
</td></tr>
<tr><td><code id="extractAIC.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2, with first and second element giving </p>

<dl>
<dt><code>df</code></dt><dd><p>The degrees of freedom for the fitted model.</p>
</dd>
<dt><code>AIC</code></dt><dd><p>The Akaike Information Criterion for the fitted model.</p>
</dd>
</dl>


<hr>
<h2 id='fitted.joint'>Obtain joint model fitted values</h2><span id='topic+fitted.joint'></span>

<h3>Description</h3>

<p>returns the fitted values from a <code>joint</code> object. Note that the 
<strong>linear predictor</strong> for each <code class="reqn">k=1,\dots,K</code> response is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
fitted(object, as = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by the <code><a href="#topic+joint">joint</a></code> function.</p>
</td></tr>
<tr><td><code id="fitted.joint_+3A_as">as</code></td>
<td>
<p>should the fitted values be returned as a <code>"matrix"</code> (the default) or as a 
<code>"list"</code>? Note that <code>as="matrix"</code> only works for balanced responses.</p>
</td></tr>
<tr><td><code id="fitted.joint_+3A_...">...</code></td>
<td>
<p>Additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or list) with a column (or list entry) for each of the fitted linear
predictors with class <code>fitted.joint</code>.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.joint">residuals.joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bivariate fit on PBC data -----------------------------------------
data(PBC)

# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'albumin', 'platelets'))
PBC &lt;- na.omit(PBC) 

# Specify bivariate fit
long.formulas &lt;- list(
  albumin ~ time*drug + (1 + time|id),
  platelets ~ time * drug + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;- joint(long.formulas, surv.formula, PBC, family = list('gaussian', 'poisson'))
fitted(fit)

</code></pre>

<hr>
<h2 id='fixef.joint'>Extract fixed effects from a <code>joint</code> object.</h2><span id='topic+fixef.joint'></span>

<h3>Description</h3>

<p>Extract fixed effects from a <code>joint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
fixef(object, what = c("long", "surv"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixef.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="fixef.joint_+3A_what">what</code></td>
<td>
<p>character string. Should the <code>"long"</code>itudinal process(es) be extracted,
or the <code>"surv"</code>ival ones?</p>
</td></tr>
<tr><td><code id="fixef.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing requested fixed effects.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.joint">ranef.joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate fit on PBC data -------------------------------------------
data(PBC)

# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'albumin'))
PBC &lt;- na.omit(PBC) 

# Specify simple univariate fit
long.formulas &lt;- list(
  albumin ~ time + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;- joint(long.formulas, surv.formula, PBC, family = list('gaussian'))

fixef(fit, 'long')
fixef(fit, 'surv')
</code></pre>

<hr>
<h2 id='joint'>Fit a joint model to time-to-event and multivariate longitudinal data</h2><span id='topic+joint'></span>

<h3>Description</h3>

<p>Fit a joint model to time-to-event and multivariate longitudinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint(
  long.formulas,
  surv.formula,
  data,
  family,
  disp.formulas = NULL,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_+3A_long.formulas">long.formulas</code></td>
<td>
<p>A list of formula objects specifying the <code class="reqn">K</code> responses. Each must be 
usable by <code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code>. A restriction is that unique identifiers must 
be named <code>id</code>, and increment in intervals of at exactly one. The variable for time
must be named <code>time</code>.</p>
</td></tr>
<tr><td><code id="joint_+3A_surv.formula">surv.formula</code></td>
<td>
<p>A formula specifying the time-to-event sub-model. Must be usable by 
<code><a href="survival.html#topic+coxph">coxph</a></code>.</p>
</td></tr>
<tr><td><code id="joint_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing all covariates and responses.</p>
</td></tr>
<tr><td><code id="joint_+3A_family">family</code></td>
<td>
<p>A list of length <code class="reqn">K</code> containing strings denoting the exponential families 
for each longitudinal sub-model, corresponding in order to <code>long.formulas</code>. For choices 
of <code>family</code>, see <strong>details</strong>.</p>
</td></tr>
<tr><td><code id="joint_+3A_disp.formulas">disp.formulas</code></td>
<td>
<p>An optional list of length <code class="reqn">K</code> specifying the dispersion models
wanted for each longitudinal sub-model, corresponding in order to <code>long.formulas</code>. Defaults
to <code>disp.formulas = NULL</code>. See <strong>details</strong> for more information.</p>
</td></tr>
<tr><td><code id="joint_+3A_control">control</code></td>
<td>
<p>A list of control values: </p>

<dl>
<dt><code>verbose</code></dt><dd><p>Logical: If <code>TRUE</code>, at each iteration parameter information will 
be printed to console. Default is <code>verbose=FALSE</code>.</p>
</dd>
<dt><code>conv</code></dt><dd><p>Character: Convergence criterion, see <strong>details</strong>.</p>
</dd>
<dt><code>tol.abs</code></dt><dd><p>Numeric: Tolerance value used to assess convergence, see 
<strong>details</strong>. Default is <code>tol.abs=1e-3</code>.</p>
</dd>
<dt><code>tol.rel</code></dt><dd><p>Numeric: Tolerance value used to assess convergence, see 
<strong>details</strong>. Default is <code>tol.rel=1e-2</code>.</p>
</dd>
<dt><code>tol.den</code></dt><dd><p>Numeric: Tolerance value used to assess convergence, see 
<strong>details</strong>. Default is <code>tol.den=1e-3</code>.</p>
</dd>
<dt><code>tol.thr</code></dt><dd><p>Numeric: Threshold used when <code>conv = 'sas'</code>, see 
<strong>details</strong>. Default is <code>tol.thr=1e-1</code>.</p>
</dd>
<dt><code>grad.eps</code></dt><dd><p>Numeric: Step size for numerical differentiation routines used to
calculate the gradient in updates to dispersion parameters. This defaults to the cube root 
of machine tolerance. If a different step size is wanted for each response, a list can also 
be provided, with each of its elements corresponding to each longitudinal response (even if
not fitted with a dispersion model).</p>
</dd>
<dt><code>hess.eps</code></dt><dd><p>Numeric: Step size for numerical differentiation routines used to
calculate the hessian in updates to dispersion parameters. This defaults to the fourth root 
of machine tolerance. Behaves in same way as <code>grad.eps</code> for more information.</p>
</dd>
<dt><code>inits</code></dt><dd><p>List: list of initial conditions, any/all of the following can be 
specified (largely for bootstrapping purposes). Accepts elements named: <code>D</code>, which
should be an appropriately-dimensioned variance-covariance matrix; <code>beta</code>, a vector
containing all fixed effects; <code>sigma</code> a list containing all dispersion parameters,
with non-applicable elements set to zero; <code>gamma</code> a vector containing all association
parameters; <code>zeta</code> a vector containing the time-invariant survival coefficients.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>Integer: Maximum number of EM iterations to carry out before
exiting the algorithm. Defaults to <code>maxit=200L</code>, which is usually sufficient.</p>
</dd>
<dt><code>correlated</code></dt><dd><p>Logical: Should covariance parameters <strong>between</strong> responses 
be estimated and used in determination of model convergence? Default is 
<code>correlated=TRUE</code>. A choice of <code>correlated=FALSE</code> is equivalent to imposing the 
belief that deviations in longitudinal trajectories are not correlated across responses, but
can decrease computation time, particularly for large <code class="reqn">K</code>.</p>
</dd>
<dt><code>gh.nodes</code></dt><dd><p>Integer: Number of weights and abscissae to use in gauss-hermite 
quadrature. Defaults to <code>gh.nodes=3</code>, which is usually sufficient.</p>
</dd>
<dt><code>gh.sigma</code></dt><dd><p>Numeric: Standard deviation for gauss-hermite approximation of normal
distribution. Defaults to <code>gh.sigma=1</code>. This should rarely (if ever) need altering.</p>
</dd>
<dt><code>return.dmats</code></dt><dd><p>Logical: Should data matrices be returned? Defaults to 
<code>return.dmats=TRUE</code>. Note that some S3 methods for <code><a href="#topic+joint.object">joint.object</a></code>s
require the returned object to include these data matrices.</p>
</dd>
<dt><code>return.inits</code></dt><dd><p>Logical: Should a list of inital conditons be returned? 
Defaults to <code>return.inits=FALSE</code>.</p>
</dd>
<dt><code>center.ph</code></dt><dd><p>Logical: Should the survival covariates be mean-centered? Defaults
to <code>center.ph=TRUE</code>.</p>
</dd>
<dt><code>post.process</code></dt><dd><p>Logical: Should model post-processing be carried out (assumes
that the model has converged). Defaults to <code>post.process = TRUE</code> which then returns
posterior modes and their variance for the random effects, as well as approximated standard
error. This is largely for internal use (i.e. if bootstrapping to obtain SEs instead).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>joint</code> fits a joint model to time-to-event data and multivariate 
longitudinal data. The longitudinal data can be specified by numerous models encompassing
a fairly wide range of data. This joint model fit is achieved by the use of an approximate
EM algorithm first proposed in Bernhardt et al. (2015), and later used in the 'classic' 
multivariate joint model in Murray and Philipson (2022). Each longitudinal response is 
modelled by 
</p>
<p style="text-align: center;"><code class="reqn">h_k(E[Y_{ik}|b_{ik};\Omega]) = X_{ik}\beta_k + Z_{ik}b_{ik}</code>
</p>
 
<p>where <code class="reqn">h_k</code> is a known, monotonic link function. An association is induced between the 
<code class="reqn">K</code>th response and the hazard <code class="reqn">\lambda_i(t)</code> by: 
</p>
<p style="text-align: center;"><code class="reqn">\lambda_i(t)=\lambda_0(t)\exp\{S_i^T\zeta + \sum_{k=1}^K\gamma_kW_k(t)^Tb_{ik}\}</code>
</p>
 
<p>where <code class="reqn">\gamma_k</code> is the association parameter and <code class="reqn">W_k(t)</code> is the vector function of 
time imposed on the <code class="reqn">K</code>th random effects structure (i.e. intercept-and-slope; spline).
</p>


<h3>Value</h3>

<p>An object with class <code>joint</code>. See <code><a href="#topic+joint.object">joint.object</a></code> for information.
</p>


<h3>Family specification</h3>

<p>Currently, five families are available for implementation, spanning continuous, binary and 
count data types: </p>

<dl>
<dt><code>'gaussian'</code></dt><dd><p>Normally distributed. The identity link is used. A term 
<code class="reqn">\sigma_k</code> will be estimated, denoting the <em>variance</em> of this response</p>
</dd>
<dt><code>'binomial'</code></dt><dd><p>For binary data types, a logit link is used.</p>
</dd>
<dt><code>'poisson'</code></dt><dd><p>For count data types where dispersion is either non-consequential 
or ignored. A log link is used.</p>
</dd>
<dt><code>'genpois'</code></dt><dd><p>For count data types where dispersion is at least of some
secondary interest. A log link is used. A term <code class="reqn">\sigma_k</code> is estimated, denoting
the dispersion, <code class="reqn">\varphi</code> of the response. This follows interpretation of Zamani &amp; 
Ismail (2012): <code class="reqn">\varphi&gt;0</code>: Over-dispersion; <code class="reqn">\varphi&lt;0</code>: Under-dispersion.
<code class="reqn">Var[Y]=(1+\varphi)^2\mu</code>.</p>
</dd>
<dt><code>'Gamma'</code></dt><dd><p>For continuous data where a Gamma distribution might be sensible.
The log link is used. A term <code class="reqn">\sigma_k</code> is be estimated, denoting the (log) shape of 
the distribution, which is then reported as <code class="reqn">\varphi_k=\exp\{\sigma_k\}</code>.</p>
</dd>
<dt><code>"negbin"</code></dt><dd><p>For count data types where overdispersion is modelled. A log link
is used. A term <code class="reqn">\sigma_k</code> is estimated, which is then reported as 
<code class="reqn">\varphi_k=\exp\{\sigma_k\}</code> which is the overdispersion. The variance of the response
is <code class="reqn">Var[Y]=\mu+\mu^2/\varphi</code>.</p>
</dd>
</dl>
 
<p>For families <code>"negbin"</code>, <code>"Gamma"</code>, <code>"genpois"</code>, the user can define the 
dispersion model desired in <code>disp.formulas</code>. For the <code>"negbin"</code> and <code>"Gamma"</code>
cases, we define <code class="reqn">\varphi_i=\exp\{W_i\sigma_i\}</code> (i.e. the exponent of the linear 
predictor of the dispersion model; and for <code>"genpois"</code> the identity of the linear
is used.
</p>


<h3>Dispersion models</h3>

<p>The <code>disp.formulas</code> in the function call allows the user to model the dispersion for
a given sub-model if wanted. The default value <code>disp.formulas = NULL</code> simply imposes
an 'intercept only' model. If the <code class="reqn">k</code>th item in <code>disp.formulas</code> corresponds to 
a longitudinal sub-model with no dispersion term, then it is simply ignored. With this in 
mind then, if a dispersion model is only required for, say, one sub-model, then the 
corresponding item in this list of models should be specified as such, with the others set to
<code>~1</code>.
</p>


<h3>Standard error estimation</h3>

<p>We follow the approximation of the observed empirical information matrix detailed by 
Mclachlan and Krishnan (2008), and later used in <code>joineRML</code> (Hickey et al., 2018).
These are only calculated if <code>post.process=TRUE</code>. Generally, these SEs are well-behaved,
but their reliability will depend on multiple factors: Sample size; number of events; 
collinearity of REs of responses; number of observed times, and so on. Some more discussion/
references are given in <code><a href="#topic+vcov.joint">vcov.joint</a></code>.
</p>


<h3>Convergence of the algorithm</h3>

<p>A few convergence criteria (specified by <code>control$conv</code>) are available: </p>

<dl>
<dt><code>abs</code></dt><dd><p>Convergence reached when maximum absolute change in parameter estimates
is <code>&lt;tol.abs</code>.</p>
</dd>
<dt><code>rel</code></dt><dd><p>Convergence reached when maximum absolute relative change in parameter
estimates is <code>&lt;tol.rel</code>. A small amount (<code>tol.den</code>) is added to the denominator 
to eschew numerical issues if parameters are nearly zero.</p>
</dd>
<dt><code>either</code></dt><dd><p>Convergence is reached when either <code>abs</code> or <code>rel</code> are met.</p>
</dd>
<dt><code>sas</code></dt><dd><p>Assess convergence for parameters <code class="reqn">|\Omega_a|</code><code>&lt;tol.thr</code> by the
<code>abs</code> criterion, else <code>rel</code>. This is the default.</p>
</dd>
</dl>

<p>Note that the baseline hazard is updated at each EM iteration, but is not monitored for 
convergence.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>References</h3>

<p>Bernhardt PW, Zhang D and Wang HJ. A fast EM Algorithm for Fitting Joint Models of a Binary 
Response to Multiple Longitudinal Covariates Subject to Detection Limits. 
<em>Computational Statistics and Data Analysis</em> 2015; <strong>85</strong>; 37&ndash;53
</p>
<p>Hickey GL, Philipson P, Jorgensen A, Kolamunnage-Dona R. <code>joineRML</code>: a joint model and
software package for time-to-event and multivariate longitudinal outcomes.
<em>BMC Med. Res. Methodol.</em> 2018; <strong>50</strong>
</p>
<p>McLachlan GJ, Krishnan T. <em>The EM Algorithm and Extensions.</em> Second Edition. 
Wiley-Interscience; 2008.
</p>
<p>Murray, J and Philipson P. A fast approximate EM algorithm for joint models of survival and
multivariate longitudinal data.<em>Computational Statistics and Data Analysis</em> 2022; 
<strong>170</strong>; 107438
</p>
<p>Zamani H and Ismail N. Functional Form for the Generalized Poisson Regression Model, 
<em>Communications in Statistics - Theory and Methods</em> 2012; <strong>41(20)</strong>; 3666-3675.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.joint">summary.joint</a></code>, <code><a href="#topic+logLik.joint">logLik.joint</a></code>, <code><a href="#topic+boot.joint">boot.joint</a></code>,
<code><a href="#topic+extractAIC.joint">extractAIC.joint</a></code>, <code><a href="#topic+fixef.joint">fixef.joint</a></code>, <code><a href="#topic+ranef.joint">ranef.joint</a></code>,
<code><a href="#topic+vcov.joint">vcov.joint</a></code>, <code><a href="#topic+joint.object">joint.object</a></code> and <code><a href="#topic+xtable.joint">xtable.joint</a></code>. For
data simulation see <code><a href="#topic+simData">simData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1) Fit on simulated bivariate data, (1x gaussian, 1x poisson) --------
beta &lt;- do.call(rbind, replicate(2, c(2, -0.1, 0.1, -0.2), simplify = FALSE))
gamma &lt;- c(0.3, -0.3)
D &lt;- diag(c(0.25, 0.09, 0.25, 0.05))
family &lt;- list('gaussian', 'poisson')
data &lt;- simData(ntms = 10, beta = beta, D = D, n = 100,
                family = family, zeta = c(0, -0.2),
                sigma = list(0.16, 0), gamma = gamma)$data

# Specify formulae and target families
long.formulas &lt;- list(
  Y.1 ~ time + cont + bin + (1 + time|id),  # Gaussian
  Y.2 ~ time + cont + bin + (1 + time|id)   # Poisson
)
surv.formula &lt;- Surv(survtime, status) ~ bin

fit &lt;- joint(long.formulas, surv.formula, data, family)


# 2) Fit on PBC data -----------------------------------------------------
data(PBC)
# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'serBilir', 'albumin', 'spiders', 'platelets'))
PBC &lt;- na.omit(PBC) 

# Specify GLMM sub-models, including interaction and quadratic time terms
long.formulas &lt;- list(
  log(serBilir) ~ drug * (time + I(time^2)) + (1 + time + I(time^2)|id),
  albumin ~ drug * time + (1 + time|id),
  platelets ~ drug * time + (1 + time|id),
  spiders ~ drug * time + (1|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;-  joint(long.formulas, surv.formula, PBC, 
              family = list("gaussian", "gaussian", "poisson", "binomial"),
              control = list(verbose = TRUE))
fit


# 3) Fit with dispersion models ----------------------------------------
beta &lt;- do.call(rbind, replicate(2, c(2, -0.1, 0.1, -0.2), simplify = FALSE))
gamma &lt;- c(0.3, -0.3)
D &lt;- diag(c(0.25, 0.09, 0.25, 0.05))
family &lt;- list('negbin', 'poisson')   # As an example; only requires one dispersion model.
sigma &lt;- list(c(1, 0.2), 0)           # Need to specify the model in simData call too.
disp.formulas = list(~time, ~1)       # Even though poisson doesn't model dispersion, need to
                                      # populate this element in disp.formulas!
# Simulate some data
data &lt;- simData(ntms = 10, beta = beta, D = D, n = 500,
                family = family, zeta = c(0, -0.2), sigma = sigma,
                disp.formulas = disp.formulas, gamma = gamma)$data

# Now fit using joint
long.formulas &lt;- list(
  Y.1 ~ time + cont + bin + (1+time|id),
  Y.2 ~ time + cont + bin + (1+time|id)
)
fit &lt;- joint(
  long.formulas, Surv(survtime, status) ~ bin,
  data, family, disp.formulas = disp.formulas
)
fit
summary(fit)

</code></pre>

<hr>
<h2 id='joint.object'>Fitted <code>joint</code> object</h2><span id='topic+joint.object'></span>

<h3>Description</h3>

<p>An object returned by the <code>joint</code> function, with class <code>joint</code>
a fitted joint model. Objects of this class currently have methods for: <code>logLik</code>,
<code>print</code>, <code>ranef</code>, <code>fixef</code>, <code>summary</code>, <code>AIC</code>, and <code>vcov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint.object
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>


<h3>Value</h3>

<p>A list with the following components. </p>

<dl>
<dt><code>coeffs</code></dt><dd><p>A list containing parameter estimates: </p>

<dl>
<dt><code>D</code></dt><dd><p>The variance-covariance matrix of the random effects.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of fixed effects for longitudinal processes.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>List of dispersion parameters, families with no dispersion parameter
are returned as an unnamed zero value.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>Vector of association parameters.</p>
</dd>
<dt><code>zeta</code></dt><dd><p>Vector of time-invariant survival coefficients.</p>
</dd>
</dl>
</dd>
<dt><code>hazard</code></dt><dd><p>A matrix containing unique failure times <code>ft</code>, their hazard 
contribution <code>haz</code> and the number of events at that failure time <code>nev</code>.</p>
</dd>
<dt><code>ModelInfo</code></dt><dd><p>A list containing information on the model fit: </p>

<dl>
<dt><code>ResponseInfo</code></dt><dd><p>A vector containing response names with (family) reported.</p>
</dd>
<dt><code>Resps</code></dt><dd><p>A vector containing response names only.</p>
</dd>
<dt><code>family</code></dt><dd><p>A list of families fit.</p>
</dd>
<dt><code>K</code></dt><dd><p>An integer specifying the number of longitudinal sub-models.</p>
</dd>
<dt><code>Pcounts</code></dt><dd><p>A list containing informations about the number of parameters/random
effects: </p>

<dl>
<dt><code>P</code></dt><dd><p>A vector of length K containing the number of fixed effects for each response
(in order).</p>
</dd>
<dt><code>Pd</code></dt><dd><p>A vector of length K containing the number of dispersion parameters for each
response (in order) 0 denotes no parameter for that response.</p>
</dd>
<dt><code>q</code></dt><dd><p>An integer denoting the number of random effects.</p>
</dd>
<dt><code>vD</code></dt><dd><p>An integer denoting the number of unique variance-covariance parameters
estimated.</p>
</dd>
</dl>
</dd>
<dt><code>long.formulas</code></dt><dd><p>A list of <code>long.formulas</code> (i.e. from <code>joint</code> call).</p>
</dd>
<dt><code>disp.formulas</code></dt><dd><p>A list of <code>disp.formulas</code> (i.e. from <code>joint</code> call).
If no <code>disp.formulas</code> are supplied to <code>joint</code>, then this is populated by a list of
<code class="reqn">K</code> &quot;<code>~1</code>&quot;. The environment is set to <code>parent.frame</code> in this case to avoid
memory overheads in returned objects.</p>
</dd>
<dt><code>surv.formula</code></dt><dd><p>Formula object from <code>joint</code> call.</p>
</dd>
<dt><code>survtime</code></dt><dd><p>The name of the event time used in <code>surv.formula</code>.</p>
</dd>
<dt><code>status</code></dt><dd><p>The name of the event indicator used in <code>surv.formula</code>.</p>
</dd>
<dt><code>control</code></dt><dd><p>List of control parameters used, see <code><a href="#topic+joint">joint</a></code>.</p>
</dd>
<dt><code>convergence.criteria</code></dt><dd><p>List of parameters relating to the stopping rule.</p>
</dd>
<dt><code>inds</code></dt><dd><p>A list of length two, named <code>R</code> and <code>Cpp</code>, each of which contains
the indices for fixed effects <code class="reqn">\beta</code> for each response, or the random effects <code class="reqn">b</code>
for the named platform.</p>
</dd> 
<dt><code>n</code></dt><dd><p>Number of subjects.</p>
</dd>
<dt><code>nobs</code></dt><dd><p>A vector containing total number of observations for each response.</p>
</dd>
<dt><code>mi</code></dt><dd><p>A <code class="reqn">K</code> x <code class="reqn">n</code> matrix containing the number of observations for 
subject <code class="reqn">i</code> for the <code class="reqn">k</code>th response.</p>
</dd>
<dt><code>nev</code></dt><dd><p>Number of events.</p>
</dd>
<dt><code>id.assign</code></dt><dd><p>A list containing the original ids of subjects in the <code>data</code> 
supplied to <code>joint</code>, and the id assigned to them for use in subsequent functions.</p>
</dd>
</dl>
</dd>
<dt><code>Hessian</code></dt><dd><p>The (approximated) Hessian found at MLEs. Only returned if 
control argument <code>post.process=TRUE</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>vcov</code></dt><dd><p>The full variance-covariance matrix between parameters. Only returned if 
control argument <code>post.process=TRUE</code>.</p>
</dd>
<dt><code>SE</code></dt><dd><p>A named vector of approximated standard error for each estimated parameter.
Only returned if control argument <code>post.process=TRUE</code>.</p>
</dd>
<dt><code>logLik</code></dt><dd><p>log-likelihood evaluated at parameter estimates. Only returned if control
argument <code>post.process=TRUE</code>.</p>
</dd>
<dt><code>REs</code></dt><dd><p>The random effects, with subject-specific variance matrices attributed. If
control argumnet <code>post.process=TRUE</code> then these are found at MLEs (i.e. are posterior
estimates), otherwise they are taken from the final EM iteration.</p>
</dd>
<dt><code>elapsed.time</code></dt><dd><p>Named numeric containing breakdown of elapsed time for <code>joint</code>
fit.</p>
</dd>
<dt><code>dmats</code></dt><dd><p>A list of data matrices on each of the longitudinal 
and survival processes for each subject.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint">joint</a></code>.
</p>

<hr>
<h2 id='logLik.joint'>Log-likelihood for joint model.</h2><span id='topic+logLik.joint'></span>

<h3>Description</h3>

<p>Calculate joint log-likelihood, degrees of freedom, AIC and BIC of 
joint model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
logLik(object, conditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.joint_+3A_object">object</code></td>
<td>
<p>a <code>joint</code> object.</p>
</td></tr>
<tr><td><code id="logLik.joint_+3A_conditional">conditional</code></td>
<td>
<p>Logical. Should the conditional or observed data log-likelihood
be returned? See <strong>details</strong>.</p>
</td></tr>
<tr><td><code id="logLik.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the log-likelihood of a joint model of survival and multivariate longitudinal
data (i.e. a <code>joint</code> object). The argument <code>conditional</code> manages whether
or not the log-likelihood <em>conditional</em> on the random effects, or simply
the observed data log-likelihood is returned (the default, <code>conditional = FALSE</code>). 
</p>
<p>If <code>conditional = TRUE</code>, then the log-likelihood conditional on the random 
effects is returned. That is
</p>
<p style="text-align: center;"><code class="reqn">\log f(T_i, \Delta_i, Y_i|b_i;\Omega) = 
      \log f(Y_i|b_i; \Omega) + \log f(T_i, \Delta_i|b_i; \Omega) + \log f(b_i|\Omega)</code>
</p>

<p>If <code>conditional = FALSE</code>, then the observed data log-likelihood is returned i.e.
</p>
<p style="text-align: center;"><code class="reqn">\log\int f(Y_i|b_i; \Omega)f(T_i, \Delta_i|b_i; \Omega)f(b_i|\Omega)db_i.</code>
</p>

<p>Additionally, the degrees of freedom, <code class="reqn">\nu</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\nu = \code{length(vech(D))} + \sum_{k=1}^K\{P_k + P_{\sigma_k}\} + P_s,</code>
</p>

<p>where <code class="reqn">P_k</code> denotes the number of coefficients estimated for the <code class="reqn">k</code>th response,
and <code class="reqn">P_{\sigma_k}</code> the number of dispersion parameters estimated. <code class="reqn">P_s</code> denotes
the number of survival coefficients, i.e. the length of <code>c(zeta, gamma)</code>. Finally,
all covariance parameters are captured in <code>length(vech(D))</code>. 
</p>
<p>With the degrees of freedom, we can additionally compute AIC and BIC, which are defined
in no special way; and are calculated using the observed data log-likelihood.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>logLik</code>, a number which is the log-likelihood
of the fitted model <code>object</code>. This has multiple attributes: <code>df</code> which is the 
degrees of freedom, <code>df.residual</code>; the number of residual degrees of freedom;
<code>AIC</code> and <code>BIC</code> which are the Akaike or Bayes information criterion evaluated at 
either the conditional or observed log-likelihood (as requested by argument 
<code>conditional</code>).
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>)
</p>


<h3>References</h3>

<p>Henderson R, Diggle P, Dobson A. Joint modelling of longitudinal measurements and event time
data. <em>Biostatistics</em> 2000; <strong>1(4)</strong>; 465-480.
</p>
<p>Wulfsohn MS, Tsiatis AA. A joint model for survival and longitudinal data measured with error.
<em>Biometrics</em> 1997; <strong>53(1)</strong>; 330-339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractAIC.joint">extractAIC.joint</a></code> and <code><a href="#topic+anova.joint">anova.joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bivariate simulated data (2x Gaussian)
data &lt;- simData(n = 100,
   D = diag(c(.25, .04, .2, .02)),
   gamma = c(0.4, -0.2), theta = c(-2, .2))$data
fit &lt;- joint(list(
    Y.1 ~ time + cont + bin + (1 + time|id),
    Y.2 ~ time + cont + bin + (1 + time|id)
  ), Surv(survtime, status) ~ cont + bin, 
  data = data, 
  family = list('gaussian', 'gaussian'))

logLik(fit)

</code></pre>

<hr>
<h2 id='parseCoxph'>Parsing the survival formula and constructing all survival-related data objects.</h2><span id='topic+parseCoxph'></span>

<h3>Description</h3>

<p>Creates a set of survival data and fits a <code>coxph</code> model
using a survival formula and a data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseCoxph(surv.formula, data, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseCoxph_+3A_surv.formula">surv.formula</code></td>
<td>
<p>A formula readable by 'coxph'.</p>
</td></tr>
<tr><td><code id="parseCoxph_+3A_data">data</code></td>
<td>
<p>a set of data containing covariate information for variables
named by &lsquo;surv.formula'. Can be of any &rsquo;completeness', as the function 
returns a reduced set.</p>
</td></tr>
<tr><td><code id="parseCoxph_+3A_center">center</code></td>
<td>
<p>Should the covariate matrices be mean-centered before being returned?
defaults to <code>center = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>parseCoxph</code> containing: </p>

<dl>
<dt><code>survdata</code></dt><dd><p>reduced version of <code>data</code>, with only one row per subject, with 
covariates specified by <code>surv.formula</code> along with survival time and failure status.</p>
</dd>
<dt><code>Smat</code></dt><dd><p>matrix containing all requisite survival covariates (one row per subject).</p>
</dd>
<dt><code>ph</code></dt><dd><p>the model fit from <code>coxph</code>.</p>
</dd>
<dt><code>Delta</code></dt><dd><p>list of failure indicators for each of the unique subjects.</p>
</dd>
<dt><code>n</code></dt><dd><p>number of unique subjects.</p>
</dd>
<dt><code>ft</code></dt><dd><p>vector of unique failure times.</p>
</dd>
<dt><code>nev</code></dt><dd><p>vector containing number of failures at each failure time <code>ft</code>.</p>
</dd>
<dt><code>survtime</code></dt><dd><p>the name of the <code>time</code> variable in <code>surv.formula</code>.</p>
</dd>
<dt><code>status</code></dt><dd><p>the name of the <code>event</code> variable in <code>surv.formula</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data = simData()$data
parseCoxph(Surv(survtime, status) ~ bin, data = data)
</code></pre>

<hr>
<h2 id='PBC'>Primary biliary cirrhosis data</h2><span id='topic+PBC'></span>

<h3>Description</h3>

<p>Primary biliary cirrhosis (PBC) data. PBC is a chronic liver disease which affects the bile 
ducts of the liver, complications of which can ultimately lead to death. The longitudinal 
profile of numerous biomarkers were observed for 312 patients at the Mayo Clinic between 1974
and 1984  with patients assigned to either the active (D-penicillamine, n=154 (50.6
placebo treatment arm (Murtaugh 1994). The data is publicly available in numerous places, 
including <code>joineRML</code> and <code>survival</code>. The presence of many longitudinal biomarkers 
of clinical interest as well as an event-time has lead to the PBC data becoming
widely used in literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('PBC')
</code></pre>


<h3>Format</h3>

<p><code>data.frame</code> with 312 patients and 19 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>Subject identifier</p>
</dd>
<dt><code>survtime</code></dt><dd><p>Survival time in years</p>
</dd>
<dt><code>drug</code></dt><dd><p>Binary indicator covariate: was the patient assigned active 
(<code>drug=1</code>) or placebo?</p>
</dd>
<dt><code>sex</code></dt><dd><p>Binary indicator covariate: Takes value 1 if the subject is female, and zero
if male.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time of visit (0=baseline).</p>
</dd>
<dt><code>ascites</code></dt><dd><p>Binary <em>response</em> variable. Takes value 1 if accumulation of fluid 
in abdomen (&quot;ascites&quot;) present.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>Binary <em>response</em> variable. Takes value 1 if enlarged liver 
(&quot;hepatomegaly&quot;) present.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>Binary <em>response</em> variable. Takes value 1 if malformed blood 
vessels in skin (&quot;hepatomegaly&quot;) present.</p>
</dd>
<dt><code>edema</code></dt><dd><p>Factor variable describing edema therapy, see 
<code><a href="survival.html#topic+pbcseq">pbcseq</a></code>.</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>Serum bilirubin (measured in mg/dl).</p>
</dd>
<dt><code>serChol</code></dt><dd><p>Serum cholesterol (measured in mg/dl).</p>
</dd>
<dt><code>album</code></dt><dd><p>Serum albumin (measured in mg/dl).</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>Alkaline phosphotase (measured in U/liter).</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>Aspartate aminotransferase (measured in U/liter).</p>
</dd>
<dt><code>platelets</code></dt><dd><p>Platelet count per cubic ml/1000.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>Histologic stage of disease, see <code><a href="survival.html#topic+pbcseq">pbcseq</a></code>.</p>
</dd>
<dt><code>status</code></dt><dd><p>Survival status, <code>status=1</code> if the subject experienced mortality 
and <code>=0</code> if censored.</p>
</dd>
<dt><code>age</code></dt><dd><p>Standardised age at baseline visit.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Nine longitudinal biomarkers exist with varying degrees of completeness in the data.
</p>


<h3>Source</h3>

<p><code><a href="survival.html#topic+pbcseq">pbcseq</a></code>
</p>


<h3>References</h3>

<p>Murtaugh PA, Dickson ER, Van Dam GM, Malinchoc M, Grambsch PM, Langworthy AL, Gips CH. Primary 
biliary cirrhosis: Prediction of short-term survival based on repeated patient visits. 
<em>Hepatology</em> 1994; <strong>20(1)</strong>; 126-134.
</p>

<hr>
<h2 id='plot.cond.b.joint'>Plot posterior distribution of the random effects for a <code>joint</code> model.</h2><span id='topic+plot.cond.b.joint'></span>

<h3>Description</h3>

<p>Plot posterior distribution of the random effects for a <code>joint</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cond.b.joint'
plot(
  x,
  id = NULL,
  show.cov = TRUE,
  nrow = NULL,
  ncol = NULL,
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cond.b.joint_+3A_x">x</code></td>
<td>
<p>object of class <code>cond.b.joint</code> fit by <code>cond.ranefs</code>.</p>
</td></tr>
<tr><td><code id="plot.cond.b.joint_+3A_id">id</code></td>
<td>
<p>integer, if specified this shows the plots the posterior density for the chosen
id (as they appeared in original <code>joint</code> model fit). By default this takes value 
<code>NULL</code>, which results in the posterior density for the entire data sample being plotted.</p>
</td></tr>
<tr><td><code id="plot.cond.b.joint_+3A_show.cov">show.cov</code></td>
<td>
<p>logical, should the 'true' (normal) density be overlaid on these plots? If 
<code>id</code> is <em>not</em> specified, this overlays a normal density with variance taken from
the <code>joint</code> fit's value for <code class="reqn">D</code>. If <code>id</code> <em>is</em> specified, then this overlays
a normal density with variance taken from that subject's <code class="reqn">\hat{\Sigma}_i</code>, along with an
open circle showing <code class="reqn">\hat{b}_i</code> from the model fit.</p>
</td></tr>
<tr><td><code id="plot.cond.b.joint_+3A_nrow">nrow</code></td>
<td>
<p>integer specifying the number of rows to use in paneled plot.</p>
</td></tr>
<tr><td><code id="plot.cond.b.joint_+3A_ncol">ncol</code></td>
<td>
<p>integer specifying the number of columns to use in paneled plot. Note that 
<em>both</em> <code>nrow</code> and <code>ncol</code> must be specified, or neither.</p>
</td></tr>
<tr><td><code id="plot.cond.b.joint_+3A_title">title</code></td>
<td>
<p>optional character string to specify the title. This is placed at the top middle of
the graphics device.</p>
</td></tr>
<tr><td><code id="plot.cond.b.joint_+3A_...">...</code></td>
<td>
<p>Additional arguments, these are passed to the plotting of the individual densities.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bivariate Gaussian 
dat &lt;- simData(n = 100)$data
long.formulas &lt;- list(Y.1 ~ time + cont + bin + (1 + time|id), 
                      Y.2 ~ time + cont + bin + (1 + time|id))
surv.formula &lt;- Surv(survtime, status) ~ bin
fit &lt;- joint(long.formulas, surv.formula, dat, list("gaussian","gaussian"))
cond.b &lt;- cond.ranefs(fit, burnin = 500L, N = 4500L)
# Posterior for entire sample with dummy title
plot(cond.b, title = "Example title")
# Posterior for a randomly selected id
dummy.id &lt;- sample(1:100, 1)
# Should show good agreement between true posterior and approximate normal.
plot(cond.b, id = dummy.id, title = paste0("id: ", dummy.id))

</code></pre>

<hr>
<h2 id='plot.dynPred'>Plot conditional survival probabilities.</h2><span id='topic+plot.dynPred'></span>

<h3>Description</h3>

<p>Produces a simple plot of the probability the subject survives given failure
times along with the 95% confidence interval if probabilities are generated from a simulation
scheme, and simply the first-order estimate otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynPred'
plot(x, what = c("median", "mean"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dynPred_+3A_x">x</code></td>
<td>
<p>an object with class <code>dynPred</code>.</p>
</td></tr>
<tr><td><code id="plot.dynPred_+3A_what">what</code></td>
<td>
<p>should the <code>"median"</code> (the default) or <code>"mean"</code> probability be displayed?
if first-order predictions are used, this is ignored.</p>
</td></tr>
<tr><td><code id="plot.dynPred_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynPred">dynPred</a></code>
</p>

<hr>
<h2 id='plot.residuals.joint'>Plot joint model residuals</h2><span id='topic+plot.residuals.joint'></span>

<h3>Description</h3>

<p>Plot residuals obtained by a joint model (obtained by <code><a href="#topic+joint">joint</a></code>). 
If the <code>residuals.joint</code> object represents the longitudinal process, a simple (paneled)
plot is produced (one for each response). If the residual object contains the Cox-Snell 
residuals then several plots are produced (interactively): The KM estimate of survival 
function of said residuals and then repeated for each survival covariate in the model call
to <code>joint</code> (if requested).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'residuals.joint'
plot(x, strata = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.residuals.joint_+3A_x">x</code></td>
<td>
<p>an object with class <code>residuals.joint</code>.</p>
</td></tr>
<tr><td><code id="plot.residuals.joint_+3A_strata">strata</code></td>
<td>
<p>logical, should strata (for the survival sub-model only). Defaults to 
<code>strata = FALSE</code> which produces only one plot of Cox-Snell residuals.</p>
</td></tr>
<tr><td><code id="plot.residuals.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.joint">residuals.joint</a></code>
</p>

<hr>
<h2 id='plot.ROC.joint'>Plot receiver operator characteristics.</h2><span id='topic+plot.ROC.joint'></span>

<h3>Description</h3>

<p>Produces a simple plot showing the true positive rate (sensitivity) against
the false positive rate (1-specificy) for a dynamic prediction routine on a <code>joint</code> model
along a specified time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ROC.joint'
plot(x, legend = TRUE, show.Youden = TRUE, show.F1 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ROC.joint_+3A_x">x</code></td>
<td>
<p>an object with class <code>ROC.joint</code>.</p>
</td></tr>
<tr><td><code id="plot.ROC.joint_+3A_legend">legend</code></td>
<td>
<p>should a legend displaying the number in risk set; number of failures in interval;
area under the ROC curve and median Brier score be added to the bottom-right corner of the ROC 
plot? Default is <code>legend = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ROC.joint_+3A_show.youden">show.Youden</code></td>
<td>
<p>should a line be drawn showing optimal cut-point using Youden's J statistic?
Defaults to <code>show.Youden = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ROC.joint_+3A_show.f1">show.F1</code></td>
<td>
<p>should a line be drawn showing optimal cut-point using the F-score?
Defaults to <code>show.F1 = FALSE</code>. Note that this measure comes under heavy criticism and is
included for completeness' sake.</p>
</td></tr>
<tr><td><code id="plot.ROC.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynPred">dynPred</a></code> and <code><a href="#topic+ROC">ROC</a></code>
</p>

<hr>
<h2 id='ranef.joint'>Extract random effects from a <code>joint</code> object.</h2><span id='topic+ranef.joint'></span>

<h3>Description</h3>

<p>Return the random effects <code class="reqn">\hat{\boldsymbol{b}}</code> which maximises the complete
data log-likelihood at the MLEs <code class="reqn">\hat{\Omega}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
ranef(object, Var = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="ranef.joint_+3A_var">Var</code></td>
<td>
<p>logical, should the estimated variance of the random effects at <code class="reqn">\hat{\Omega}</code>
be returned? Defaults to <code>Var=FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranef.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> containing required random effects effects. If <code>Var=TRUE</code>,
instead a list is returned with first element the <code>matrix</code> of random effects and second a 
<code>matrix</code> of the variances <code class="reqn">\hat{\Sigma}</code>. Note that these are <em>posterior modes</em>
of the random effects. Conditional distribution can be found by <code><a href="#topic+cond.ranefs">cond.ranefs</a></code>.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.joint">fixef.joint</a></code> <code><a href="#topic+cond.ranefs">cond.ranefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Univariate fit on PBC data -----------------------------------------
data(PBC)

# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'albumin'))
PBC &lt;- na.omit(PBC) 

# Specify univariate fit
long.formulas &lt;- list(
  albumin ~ time*drug + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;- joint(long.formulas, surv.formula, PBC, family = list('gaussian'))
b &lt;- ranef(fit, FALSE)

</code></pre>

<hr>
<h2 id='residuals.joint'>Obtain joint model residuals</h2><span id='topic+residuals.joint'></span>

<h3>Description</h3>

<p>returns the Pearson residuals values from a <code>joint</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
residuals(
  object,
  what = c("longit", "surv"),
  type = c("response", "pearson"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by <code><a href="#topic+joint">joint</a></code> function.</p>
</td></tr>
<tr><td><code id="residuals.joint_+3A_what">what</code></td>
<td>
<p>character string. Should the <code>"long"</code>itudinal process(es) be extracted,
or the <code>"surv"</code>ival ones?</p>
</td></tr>
<tr><td><code id="residuals.joint_+3A_type">type</code></td>
<td>
<p>character. The residual type for <code>what = "long"</code> residuals only. Choices are
on the <code>"response"</code> scale or <code>"pearson"</code> residuals. Cox-Snell residuals are 
returend if <code>what = "surv"</code>.</p>
</td></tr>
<tr><td><code id="residuals.joint_+3A_...">...</code></td>
<td>
<p>Additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of length <code class="reqn">K</code> of class <code>residuals.joint</code> containing
residuals produced by the joint model for each of the <code class="reqn">k=1,\dots,K</code> responses, 
along with the fitted values as an attribute.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.joint">fitted.joint</a></code> <code><a href="#topic+plot.residuals.joint">plot.residuals.joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Trivariate fit on PBC data -----------------------------------------
data(PBC)

# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'albumin', 'hepatomegaly', 'platelets'))
PBC &lt;- na.omit(PBC) 

# Specify trivariate fit
long.formulas &lt;- list(
  albumin ~ time*drug + (1 + time|id),
  platelets ~ time * drug + (1 + time|id),
  hepatomegaly ~ time * drug + (1|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;- joint(long.formulas, surv.formula, PBC, 
             family = list('gaussian', 'poisson', 'binomial'))
R &lt;- residuals(fit, type = 'pearson')
plot(R)
plot(residuals(fit, what = "surv"))

</code></pre>

<hr>
<h2 id='rgenpois'>Simulate realisations from a generalised poisson distribution</h2><span id='topic+rgenpois'></span>

<h3>Description</h3>

<p>Simulate realisations from a generalised poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgenpois(mu, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgenpois_+3A_mu">mu</code></td>
<td>
<p>A numeric vector of rates <code class="reqn">\exp{\eta}</code>, with <code class="reqn">\eta</code> the linear predictor.</p>
</td></tr>
<tr><td><code id="rgenpois_+3A_phi">phi</code></td>
<td>
<p>A numeric specifying the dispersion <code class="reqn">\varphi</code>. If <code class="reqn">\varphi&lt;0</code> the response 
will be under-dispersed and overdispersed if <code class="reqn">\varphi&gt;0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Follows the &quot;GP-1&quot; implementation of the generalised Poisson distribution outlined 
in Zamani &amp; Ismail (2012). The variance of produced <code class="reqn">Y</code> is <code class="reqn">(1+\varphi)^2\mu</code>. As such
the dispersion parameter is bounded (i.e. not in positive reals as with CMP distribution).
</p>


<h3>Value</h3>

<p>An appropriately-dimensioned vector of count data.
</p>


<h3>References</h3>

<p>Zamani H and Ismail N. Functional Form for the Generalized Poisson Regression Model, 
<em>Communications in Statistics - Theory and Methods</em> 2012; <strong>41(20)</strong>; 3666-3675.
</p>

<hr>
<h2 id='ROC'>Receiver Operator Characteristics (ROC) for a <code>joint</code> model.</h2><span id='topic+ROC'></span>

<h3>Description</h3>

<p>Using longitudinal information available up to a time, establish diagnostic
capabilities (ROC, AUC and Brier score) of a fitted joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROC(fit, data, Tstart, delta, control = list(), progress = TRUE, boot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROC_+3A_fit">fit</code></td>
<td>
<p>a joint model fit by the  <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="ROC_+3A_data">data</code></td>
<td>
<p>the data to which the original <code>joint</code> model was fit.</p>
</td></tr>
<tr><td><code id="ROC_+3A_tstart">Tstart</code></td>
<td>
<p>The start of the time window of interest, <code>Tstart</code> denotes the time
point up to which longitudinal process(es) is used in calculation of survival probabilities.</p>
</td></tr>
<tr><td><code id="ROC_+3A_delta">delta</code></td>
<td>
<p>scalar denoting the length of time interval to check for failure times.</p>
</td></tr>
<tr><td><code id="ROC_+3A_control">control</code></td>
<td>
<p>list of control arguments to be passed to <code><a href="#topic+dynPred">dynPred</a></code>, which
acts as the main workhorse function for <code>ROC</code>. Takes default arguments of 
<code><a href="#topic+dynPred">dynPred</a></code> if not supplied.</p>
</td></tr>
<tr><td><code id="ROC_+3A_progress">progress</code></td>
<td>
<p>should a progress bar be shown, showing the current progress of the ROC
function (
to <code>progress = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ROC_+3A_boot">boot</code></td>
<td>
<p>logical. Not currently used, legacy argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>ROC.joint</code> consisting of: </p>

<dl>
<dt><code>Tstart</code></dt><dd><p>numeric denoting the start of the time window of interest; all dynamic
predictions generated used longitudinal information up-to time <code class="reqn">T_{\mathrm{start}}</code>.</p>
</dd>
<dt><code>delta</code></dt><dd><p>scalar which denotes length of interval to check, such that the window
is defined by <code class="reqn">[T_{\mathrm{start}}, T_{\mathrm{start}}, + \delta]</code>.</p>
</dd>
<dt><code>candidate.u</code></dt><dd><p>candidate vector of failure times to calculate dynamic probability
of surviving for each subject alive in <code>data</code> at time <code class="reqn">T_{\mathrm{start}}</code>.</p>
</dd>
<dt><code>window.failures</code></dt><dd><p>numeric denoting the number of observed failures in
<code class="reqn">[T_{\mathrm{start}}, T_{\mathrm{start}}, + \delta]</code>.</p>
</dd>
<dt><code>Tstart.alive</code></dt><dd><p>numeric denoting the risk set at <code>Tstart</code>.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>a <code>data.frame</code> containing probabilistic <code>thresholds</code> with:
<code>TP</code> true positives; <code>FN</code> false negatives; <code>FP</code> false positives;
<code>TN</code> true negatives; <code>TPR</code> true positive rate (sensitivity); <code>FPR</code> false
positive rate (1-specificity); <code>Acc</code> accuracy; <code>PPV</code> positive predictive value
(precision); <code>NPV</code> negative predictive value; <code>F1s</code> F1 score and <code>J</code> Youden's
J statistic.</p>
</dd>
<dt>AUC</dt><dd><p>the area under the curve.</p>
</dd>
<dt>BrierScore</dt><dd><p>The Brier score.</p>
</dd>
<dt>PE</dt><dd><p>The predicted error (taking into account censoring), loss function: square.</p>
</dd>
<dt>MH.acceptance</dt><dd><p>Raw acceptance percentages for each subject sampled.</p>
</dd>
<dt>MH.acceptance.bar</dt><dd><p>mean acceptance of M-H scheme across all subjects.</p>
</dd>
<dt>simulation.info</dt><dd><p>list containing information about call to <code>dynPred</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynPred">dynPred</a></code>, and <code><a href="#topic+plot.ROC.joint">plot.ROC.joint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(PBC)
PBC$serBilir &lt;- log(PBC$serBilir)
long.formulas &lt;- list(serBilir ~ drug * time + (1 + time|id))
surv.formula &lt;- Surv(survtime, status) ~ drug
family &lt;- list('gaussian')
fit &lt;- joint(long.formulas, surv.formula, PBC, family)
(roc &lt;- ROC(fit, PBC, Tstart = 8, delta = 2, control = list(nsim = 25)))
plot(roc)

</code></pre>

<hr>
<h2 id='simData'>Simulate data from a multivariate joint model</h2><span id='topic+simData'></span>

<h3>Description</h3>

<p>Simulate multivariate longitudinal and survival data from a joint model 
specification, with potential mixture of response families. Implementation is similar 
to existing packages (e.g. <code>joineR</code>, <code>joineRML</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simData(
  n = 250,
  ntms = 10,
  fup = 5,
  family = list("gaussian", "gaussian"),
  sigma = list(0.16, 0.16),
  beta = rbind(c(1, 0.1, 0.33, -0.5), c(1, 0.1, 0.33, -0.5)),
  D = NULL,
  gamma = c(0.5, -0.5),
  zeta = c(0.05, -0.3),
  theta = c(-4, 0.2),
  cens.rate = exp(-3.5),
  regular.times = TRUE,
  dof = Inf,
  random.formulas = NULL,
  disp.formulas = NULL,
  return.ranefs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simData_+3A_n">n</code></td>
<td>
<p>the number of subjects</p>
</td></tr>
<tr><td><code id="simData_+3A_ntms">ntms</code></td>
<td>
<p>the number of time points</p>
</td></tr>
<tr><td><code id="simData_+3A_fup">fup</code></td>
<td>
<p>the maximum follow-up time, such that t = [0, ..., fup] with length <code>ntms</code>. 
In instances where subject <code class="reqn">i</code> <em>doesn't</em> fail before <code>fup</code>, their censoring
time is set as <code>fup + 0.1</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_family">family</code></td>
<td>
<p>a <code class="reqn">K</code>-<code>list</code> of families, see <strong>details</strong>.</p>
</td></tr>
<tr><td><code id="simData_+3A_sigma">sigma</code></td>
<td>
<p>a <code class="reqn">K</code>-<code>list</code> of dispersion parameters corresponding to the order of 
<code>family</code>, and matching <code>disp.formulas</code> specification; see <strong>details</strong>.</p>
</td></tr>
<tr><td><code id="simData_+3A_beta">beta</code></td>
<td>
<p>a <code class="reqn">K \times 4</code> matrix specifying fixed effects for each <code class="reqn">K</code> parameter, 
in the order (Intercept), time, continuous, binary.</p>
</td></tr>
<tr><td><code id="simData_+3A_d">D</code></td>
<td>
<p>a positive-definite matrix specifying the variance-covariance matrix for the random
effects. If not supplied an identity matrix is assumed.</p>
</td></tr>
<tr><td><code id="simData_+3A_gamma">gamma</code></td>
<td>
<p>a <code class="reqn">K</code>-vector specifying the association parameters for each longitudinal 
outcome.</p>
</td></tr>
<tr><td><code id="simData_+3A_zeta">zeta</code></td>
<td>
<p>a vector of length 2 specifying the coefficients for the baseline covariates in 
the survival sub-model, in the order of continuous and binary.</p>
</td></tr>
<tr><td><code id="simData_+3A_theta">theta</code></td>
<td>
<p>parameters to control the failure rate, see <strong>baseline hazard</strong>.</p>
</td></tr>
<tr><td><code id="simData_+3A_cens.rate">cens.rate</code></td>
<td>
<p>parameter for <code>rexp</code> to generate censoring times for each subject.</p>
</td></tr>
<tr><td><code id="simData_+3A_regular.times">regular.times</code></td>
<td>
<p>logical, if <code>regular.times = TRUE</code> (the default), then 
<em>every</em> subject will have the same follow-up times defined by 
<code>seq(0, fup, length.out = ntms)</code>. If <code>regular.times = FALSE</code> then follow-up times are
set as random draws from a uniform distribution with maximum <code>fup</code>.</p>
</td></tr>
<tr><td><code id="simData_+3A_dof">dof</code></td>
<td>
<p>integer, specifies the degrees of freedom of the multivariate t-distribution
used to generate the random effects. If specified, this t-distribution is used. If left
at the default <code>dof=Inf</code> then the random effects are drawn from a multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="simData_+3A_random.formulas">random.formulas</code></td>
<td>
<p>allows user to specify if an intercept-and-slope (<code>~ time</code>) or 
intercept-only (<code>~1</code>) random effects structure should be used on a response-by-response
basis. Defaults to an intercept-and-slope for all responses.</p>
</td></tr>
<tr><td><code id="simData_+3A_disp.formulas">disp.formulas</code></td>
<td>
<p>allows user to specify the dispersion model simulated. Intended use is
to allow swapping between intercept only (the default) and a time-varying one (<code>~ time</code>).
Note that this should be a <code class="reqn">K</code>-<code>list</code> of formula objects, so if only one dispersion 
model is wanted, then an intercept-only should be specified for remaining sub-models. The
corresponding item in list of <code>sigma</code> parameters should be of appropriate size. Defaults
to an intercept-only model.</p>
</td></tr>
<tr><td><code id="simData_+3A_return.ranefs">return.ranefs</code></td>
<td>
<p>a logical determining whether the <em>true</em> random effects should be 
returned. This is largely for internal/simulation use. Default <code>return.ranefs = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simData</code> simulates data from a multivariate joint model with a mixture of 
families for each <code class="reqn">k=1,\dots,K</code> response. The specification of <code>family</code> changes
requisite dispersion parameter <code>sigma</code>, if applicable. The <code>family</code> list can
(currently) contain: 
</p>

<dl>
<dt><code>"gaussian"</code></dt><dd><p>Simulated with identity link, corresponding item in <code>sigma</code>
will be the <strong>variance</strong>.</p>
</dd>
<dt><code>"poisson"</code></dt><dd><p>Simulated with log link, corresponding dispersion in <code>sigma</code> 
can be anything, as it doesn't impact simulation.</p>
</dd>
<dt><code>"binomial"</code></dt><dd><p>Simulated with logit link, corresponding dispersion in <code>sigma</code> 
can be anything, as it doesn't impact simulation.</p>
</dd>
<dt><code>"negbin"</code></dt><dd><p>Simulated with a log link, corresponding item in <code>sigma</code> will be
the <strong>overdispersion</strong> defined on the log scale. Simulated variance is 
<code class="reqn">\mu+\mu^2/\varphi</code>.</p>
</dd>
<dt><code>"genpois"</code></dt><dd><p>Simulated with a log link, corresponding item in <code>sigma</code> will be
the <strong>dispersion</strong>. Values &lt; 0 correspond to under-dispersion, and values &gt; 0 over-
dispersion. See <code><a href="#topic+rgenpois">rgenpois</a></code> for more information. Simulated variance is 
<code class="reqn">(1+\varphi)^2\mu</code>.</p>
</dd>
<dt><code>"Gamma"</code></dt><dd><p>Simulated with a log link, corresponding item in <code>sigma</code> will be
the <strong>shape</strong> parameter, defined on the log-scale.</p>
</dd>
</dl>

<p>Therefore, for families <code>"negbin"</code>, <code>"Gamma"</code>, <code>"genpois"</code>, the user can
define the dispersion model desired in <code>disp.formulas</code>, which creates a data matrix 
<code class="reqn">W</code>. For the <code>"negbin"</code> and <code>"Gamma"</code> cases, we define 
<code class="reqn">\varphi_i=\exp\{W_i\sigma_i\}</code> (i.e. the exponent of the linear predictor of the 
dispersion model); and for <code>"genpois"</code> the identity of the linear is used.
</p>


<h3>Value</h3>

<p>A list of two <code>data.frame</code>s: One with the full longitudinal data, and another 
with only survival data. If <code>return.ranefs=TRUE</code>, a matrix of the true <code class="reqn">b</code> values is
also returned. By default (i.e. no arguments provided), a bivariate Gaussian set of joint
data is returned.
</p>


<h3>Baseline hazard</h3>

<p>When simulating the survival time, the baseline hazard is a Gompertz distribution controlled 
by <code>theta=c(x,y)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_0(t) = \exp{x + yt}</code>
</p>

<p>where <code class="reqn">y</code> is the shape parameter, and the scale parameter is <code class="reqn">\exp{x}</code>.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>References</h3>

<p>Austin PC. Generating survival times to simulate Cox proportional hazards
models with time-varying covariates. <em>Stat Med.</em> 2012; <strong>31(29)</strong>:
3946-3958.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint">joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) A set of univariate data ------------------------------------------
beta &lt;- c(2.0, 0.33, -0.25, 0.15)
# Note that by default arguments are bivariate, so need to specify the univariate case
univ.data &lt;- simData(beta = beta,    
                     gamma = 0.15, sigma = list(0.2), family = list("gaussian"), 
                     D = diag(c(0.25, 0.05)))
                     
# 2) Univariate data, with failure rate controlled ---------------------
# In reality, many facets contribute to the simulated failure rate, in 
# this example, we'll just atler the baseline hazard via 'theta'.
univ.data.highfail &lt;- simData(beta = beta,
                              gamma = 0.15, sigma = list(0.0), family = list("poisson"),
                              D = diag(c(0.40, 0.08)), theta = c(-2, 0.1))

# 3) Trivariate (K = 3) mixture of families with dispersion parameters -
beta &lt;- do.call(rbind, replicate(3, c(2, -0.1, 0.1, -0.2), simplify = FALSE))
gamma &lt;- c(0.3, -0.3, 0.3)
D &lt;- diag(c(0.25, 0.09, 0.25, 0.05, 0.25, 0.09))
family &lt;- list('gaussian', 'genpois', 'negbin')
sigma &lt;- list(.16, 1.5, log(1.5))
triv.data &lt;- simData(ntms=15, family = family, sigma = sigma, beta = beta, D = D, 
                     gamma = gamma, theta = c(-3, 0.2), zeta = c(0,-.2))

# 4) K = 4 mixture of families with/out dispersion ---------------------
beta &lt;- do.call(rbind, replicate(4, c(2, -0.1, 0.1, -0.2), simplify = FALSE))
gamma &lt;- c(-0.75, 0.3, -0.6, 0.5)
D &lt;- diag(c(0.25, 0.09, 0.25, 0.05, 0.25, 0.09, 0.16, 0.02))
family &lt;- list('gaussian', 'poisson', 'binomial', 'gaussian')
sigma &lt;- list(.16, 0, 0, .05) # 0 can be anything here, as it is ignored internally.
mix.data &lt;- simData(ntms=15, family = family, sigma = sigma, beta = beta, D = D, gamma = gamma,
                    theta = c(-3, 0.2), zeta = c(0,-.2))
                    
# 5) Bivariate joint model with two dispersion models. -----------------
disp.formulas &lt;- list(~time, ~time)          # Two time-varying dispersion models
sigma &lt;- list(c(0.00, -0.10), c(0.10, 0.15)) # specified in form of intercept, slope
D &lt;- diag(c(.25, 0.04, 0.50, 0.10))
disp.data &lt;- simData(family = list("genpois", "negbin"), sigma = sigma, D = D,
                     beta = rbind(c(0, 0.05, -0.15, 0.00), 1 + c(0, 0.25, 0.15, -0.20)),
                     gamma = c(1.5, 1.5),
                     disp.formulas = disp.formulas, fup = 5)            

# 6) Trivariate joint model with mixture of random effects models ------
# It can be hard to e.g. fit a binomial model on an intercept and slope, since e.g.
# glmmTMB might struggle to accurately fit it (singular fits, etc.). To that end, could
# swap the corresponding random effects specification to be an intercept-only.
family &lt;- list("gaussian", "binomial", "gaussian")
# A list of formulae, even though we want to change the second sub-model's specification
# we need to specify the rest of the items, too (same as disp.formulas, sigma).
random.formulas &lt;- list(~time, ~1, ~time)
beta &lt;- rbind(c(2, -0.2, 0.5, -0.25), c(0, 0.5, 1, -1), c(-2, 0.2, -0.5, 0.25))
# NOTE that the specification of RE matrix will need to match.
D &lt;- diag(c(0.25, 0.09, 1, 0.33, 0.05))
# Simulate data, and return REs as a sanity check...
mix.REspec.data &lt;- simData(beta = beta, D = D, family = family,
                           gamma = c(-0.5, 1, 0.5), sigma = list(0.15, 0, 0.15),
                           random.formulas = random.formulas, return.ranefs = TRUE)
</code></pre>

<hr>
<h2 id='summary.joint'>Summary of an <code>joint</code> object.</h2><span id='topic+summary.joint'></span>

<h3>Description</h3>

<p>Generate summary of a fitted multivariate joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="summary.joint_+3A_...">...</code></td>
<td>
<p>additional arguments (none used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>summary.joint</code>.
</p>


<h3>Author(s)</h3>

<p>James Murray <a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint">joint</a></code> and <code><a href="#topic+joint.object">joint.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple univariate on log(serum bilirubin) ----------------------------
data(PBC)
long.formulas &lt;-  list(
  log(serBilir) ~ drug * (time + I(time^2)) + (1 + time + I(time^2)|id)
)
surv.formula &lt;- Surv(survtime, status) ~ sex + drug
fit &lt;- joint(long.formulas = long.formulas,
             surv.formula = surv.formula,
             data = PBC, family = list("gaussian"))
summary(fit)              

# Bivariate with a dispersion model ------------------------------------
PBC &lt;- na.omit(PBC[,c('id', 'survtime', 'status', 'sex', 
                      'drug', 'platelets', 'albumin', 'time')])
long.formula &lt;- list(
  platelets ~ time * drug + (1 + time|id),
  albumin ~ time * drug + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ sex + drug
fit &lt;- joint(long.formula, surv.formula, PBC, 
             family = list("negbin", "gaussian"),
             disp.formula = list(~time, ~1))
summary(fit)

</code></pre>

<hr>
<h2 id='vcov.joint'>Extract the variance-covariance matrix from a <code>joint</code> fit.</h2><span id='topic+vcov.joint'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix from a <code>joint</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
vcov(object, corr = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.joint_+3A_object">object</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="vcov.joint_+3A_corr">corr</code></td>
<td>
<p>should the correlation matrix be returned instead of the variance-covariance?</p>
</td></tr>
<tr><td><code id="vcov.joint_+3A_...">...</code></td>
<td>
<p>extra arguments (none used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the observed-empirical <strong>approximation</strong> of information matrix 
(Mclachlan &amp; Krishnan, 2008). The standard errors for the baseline hazard are not estimated.
</p>


<h3>Value</h3>

<p>A variance-covariance matrix for the joint model object.
</p>


<h3>Methodology</h3>

<p>Many competing ways exist for obtaining the observed information matrix in an EM algorithm. 
In the context of joint modelling, the observed empirical approximation of the information 
matrix has been used previously (<code>joineRML</code>, Hickey et al. 2018). Elsewhere,
estimation of the observed information in a semi-parametric setting is outlined neatly in
Xu et al. (2014). Here, they advocate for approximation of this information matrix by 
numerical differentiation of the profile Fisher Score vector. We do not consider this 
methodology owing to its computational expense. That is, for each element of <code class="reqn">\Omega</code> 
which is perturbed by some small amount <code class="reqn">\tilde{\Omega}^{p}</code>, we must re-calculate
<code class="reqn">\hat{b}_i</code> and <code class="reqn">\hat{\Sigma}_i</code>.
</p>


<h3>Author(s)</h3>

<p>James Murray <a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>
</p>


<h3>References</h3>

<p>Hickey GL, Philipson P, Jorgensen A, Kolamunnage-Dona R. <code>joineRML</code>: a joint model and
software package for time-to-event and multivariate longitudinal outcomes.
<em>BMC Med. Res. Methodol.</em> 2018; <strong>50</strong>
</p>
<p>McLachlan GJ, Krishnan T. <em>The EM Algorithm and Extensions.</em> Second Edition. 
Wiley-Interscience; 2008.
</p>
<p>Xu C, Baines PD, Wang J. Standard error estimation using the EM algorithm for the joint 
modeling of survival and longitudinal data. <em>Biostatistics</em> 2014; <strong>15</strong>(4).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate fit on PBC data -------------------------------------------
data(PBC)

# Subset data and remove NAs
PBC &lt;- subset(PBC, select = c('id', 'survtime', 'status', 'drug', 'time',
                              'albumin'))
PBC &lt;- na.omit(PBC) 

# Specify univariate fit
long.formulas &lt;- list(
  albumin ~ time + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ drug

fit &lt;- joint(long.formulas, surv.formula, PBC, family = list('gaussian'))

vcov(fit)
</code></pre>

<hr>
<h2 id='xtable.joint'>Print an LaTeX-ready <code>xtable</code> for a <code>joint</code> object.</h2><span id='topic+xtable.joint'></span>

<h3>Description</h3>

<p>Prints an <code>xtable</code> output for a fitted <code>joint</code> object to the console,
or to a specified save location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'joint'
xtable(
  x,
  caption = NULL,
  label = NULL,
  align = NULL,
  digits = NULL,
  display = NULL,
  auto = FALSE,
  p.val = FALSE,
  max.row = NULL,
  dp = 3,
  vcov = FALSE,
  capture = FALSE,
  capture.location = "",
  hlines = "middle-bottom",
  booktabs = TRUE,
  size = "footnotesize",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xtable.joint_+3A_x">x</code></td>
<td>
<p>a joint model fit by the <code>joint</code> function.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_caption">caption</code></td>
<td>
<p>character, specifies the <code>caption</code> argument of <code>xtable</code>. By default
this takes value <code>NULL</code>, which results in a generic caption being generated.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_label">label</code></td>
<td>
<p>character, specifies the <code>label</code> argument of <code>xtable</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_align">align</code></td>
<td>
<p>character, specifies the <code>align</code> argument of <code>xtable</code>. Note by default
this is <code>NULL</code>, as alignment is done internally.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_digits">digits</code></td>
<td>
<p>integer, specifies the <code>digits</code> argument of <code>xtable</code>. Note by default
this is <code>NULL</code>, as argument <code>dp</code> controls this (but can be specified through this, 
too).</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_display">display</code></td>
<td>
<p>character, specifies the <code>display</code> argument of <code>xtable</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_auto">auto</code></td>
<td>
<p>logical, specifies the <code>auto</code> argument of <code>xtable</code>. Defaults to 
<code>FALSE</code>. Not recommended to change.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_p.val">p.val</code></td>
<td>
<p>logical, should p-values be returned? Defaults to <code>p.val = FALSE</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_max.row">max.row</code></td>
<td>
<p>integer, the number of rows after which the table is &lsquo;broken&rsquo; vertically
and merged horizontally; useful for long tables. Defaults to <code>max.row = NULL</code> which
results in one long table. Note that this can be quite finicky, so trial and error may be 
required.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_dp">dp</code></td>
<td>
<p>integer, the number of decimal places to round the estimate, standard error and
confidence intervals to; defaults to <code>dp = 3</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_vcov">vcov</code></td>
<td>
<p>logical, should the half-vectorisation of the block diagonal of covariance 
matrix be reported? Default is <code>vcov = FALSE</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_capture">capture</code></td>
<td>
<p>logical, should the printed <code>xtable</code> output be saved anywhere instead
of just printed to the console? Defaults to <code>capture = FALSE</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_capture.location">capture.location</code></td>
<td>
<p>character, if <code>capture = TRUE</code>, this should specify what
<em>file</em> it should be saved in. Defaults to <code>capture.location = ""</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_hlines">hlines</code></td>
<td>
<p>character, specifies which horizontal lines are used in the outputted
LaTeX table. Supply a character string which contains <code>"top"</code>, <code>"middle"</code> and/or
<code>"bottom"</code> (in any order) to specify a <code>toprule</code>; <code>midrule</code> and 
<code>bottomrule</code> in the table. If <code>booktabs = FALSE</code>, then these will simply 
be <code>hline</code>s. For instance <code>hlines = "top-middle-bottom"</code> prints all three;
whilst <code>hlines = "middle-bottom"</code> skips the <code>toprule</code>.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_booktabs">booktabs</code></td>
<td>
<p>logical, if <code>booktabs = TRUE</code> (the default) then <code>toprule</code>;
<code>midrule</code> and <code>bottomrule</code> replace the usual <code>hline</code>s.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_size">size</code></td>
<td>
<p>character, LaTeX size to be placed before the tabular environment, defaults
to <code>size = "footnotesize"</code>; replace with <code>"normalsize"</code> if wanted.</p>
</td></tr>
<tr><td><code id="xtable.joint_+3A_...">...</code></td>
<td>
<p>additional arguments, none used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A LaTeX-ready <code>xtable</code> print-out of the joint model. A list containing 
constituent tables is also returned invisibly, along with the final <code>xtable</code> output.
</p>


<h3>Author(s)</h3>

<p>James Murray (<a href="mailto:j.murray7@ncl.ac.uk">j.murray7@ncl.ac.uk</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+joint">joint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bivariate joint model ------------------------------------------------
require(xtable)
data &lt;- simData(n = 100)$data
long.formula &lt;- list(
  Y.1 ~ time + cont + bin + (1 + time|id),
  Y.2 ~ time + cont + bin + (1 + time|id)
)
surv.formula &lt;- Surv(survtime, status) ~ cont + bin
family &lt;- list("gaussian", "gaussian")
fit &lt;- joint(long.formula, surv.formula, data, family)
xtable(fit)
# Example of arguments: add dummy caption, add p-values.
xtable(fit, p.val = TRUE, dp = 4, caption = "This is a caption")
# Change size, place horizontal lines everywhere
xtable(fit, size = "normalsize", hlines = c("top-middle-bottom"))
# Make a wider table without booktabs 
xtable(fit, booktabs = FALSE, max.row = 6)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
