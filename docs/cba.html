<!DOCTYPE html><html><head><title>Help for package cba</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cba}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ccfkms'><p>Clustering with Conjugate Convex Functions</p></a></li>
<li><a href='#circleplot.dist'><p>Plotting Distance Graphs</p></a></li>
<li><a href='#clmplot'><p>Plotting Logical Matrices</p></a></li>
<li><a href='#cluster.dist'><p>Clustering a Sparse Symmetric Distance Matrix</p></a></li>
<li><a href='#coding'><p>Dummy Coding</p></a></li>
<li><a href='#cut.ordered'><p>Converting Ordered Factors</p></a></li>
<li><a href='#fitted.proximus'><p>Extract from a Proximus Object</p></a></li>
<li><a href='#gknn'><p>Generalized k-Nearest Neighbor Classification</p></a></li>
<li><a href='#image'><p>Matrix Image Plots</p></a></li>
<li><a href='#lminter'><p>Interpolating Logical Matrices</p></a></li>
<li><a href='#lmplot'><p>Plotting Logical Matrices</p></a></li>
<li><a href='#Mushroom'><p>Mushroom Data Set</p></a></li>
<li><a href='#order'><p>Improving the Presentation of Matrix Objects</p></a></li>
<li><a href='#order.greedy'><p>Hierarchical Greedy Ordering</p></a></li>
<li><a href='#order.length'><p>Conciseness of Presentation Measures</p></a></li>
<li><a href='#order.optimal'><p>Optimal Leaf Ordering of Binary Trees.</p></a></li>
<li><a href='#plot.sdists.graph'><p>Plotting Edit Transcripts and Sequence Alignments</p></a></li>
<li><a href='#predict.ccfkms'><p>Clustering with Conjugate Convex Functions.</p></a></li>
<li><a href='#predict.rock'><p>Rock Clustering</p></a></li>
<li><a href='#proximus'><p>Proximus</p></a></li>
<li><a href='#rlbmat'><p>Block Uniform Logical Matrix Deviates</p></a></li>
<li><a href='#rockCluster'><p>Rock Clustering</p></a></li>
<li><a href='#sdists'><p>Sequence Distance Computation</p></a></li>
<li><a href='#sdists.center'><p>Centroid Sequences</p></a></li>
<li><a href='#sdists.center.align'><p>Align Sequences to a Center</p></a></li>
<li><a href='#sdists.trace'><p>Edit Transcripts and Sequence Alignments</p></a></li>
<li><a href='#stress'><p>Conciseness of Presentation Measures</p></a></li>
<li><a href='#summary.proximus'><p>Summarizing Proximus Objects</p></a></li>
<li><a href='#townships'><p>Bertin's Characteristics and Townships Data Set</p></a></li>
<li><a href='#Votes'><p>Congressional Votes 1984 Data Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering for Business Analytics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Buchta and Michael Hahsler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Buchta &lt;christian.buchta@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements clustering techniques such as Proximus and Rock, utility functions for efficient computation of cross distances and data manipulation. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), grid, proxy</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gclus, colorspace</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-07 07:29:24 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-07 09:48:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='ccfkms'>Clustering with Conjugate Convex Functions</h2><span id='topic+ccfkms'></span>

<h3>Description</h3>

<p>Partition a data set into convex sets using conjugate convex functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccfkms(x, n, p = NULL, par = 2, max.iter = 100, opt.std = FALSE,
       opt.retry = 0, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccfkms_+3A_x">x</code></td>
<td>
<p>a data matrix.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_n">n</code></td>
<td>
<p>optional number of prototypes.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_p">p</code></td>
<td>
<p>a matrix of initial prototypes.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_par">par</code></td>
<td>
<p>type or parameter of conjugate convex function.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_opt.std">opt.std</code></td>
<td>
<p>optionally standardize the data.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_opt.retry">opt.retry</code></td>
<td>
<p>number of retries.</p>
</td></tr>
<tr><td><code id="ccfkms_+3A_debug">debug</code></td>
<td>
<p>optionally turn on debugging output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of conjugate convex functions are available: one that is based on 
powers of the norm of the prototype vectors and another that is based on a 
logarithmic transformation of the norm. Both are intended to obtain more 
robust partitions.
</p>
<p>Using <code>par</code> = 2 is equivalent to performing ordinary k-means with
Euclidean distances. <code>par</code> = 1 is equivalent to LVQ of Kohonen type 
(the directions of the prototypes from the center of the data are used), 
and <code>par</code> = 0 is equivalent to using 2*ln(cosh(|p|))/2.
</p>
<p>Internally the algorithm uses sparse data structures and avoids computations 
with zero data values. Thus, the data must not be centered (the algorithm 
does this internally with the option to further standardize the data). For 
dense data this is slightly inefficient.
</p>
<p>If initial prototypes are omitted the number of prototypes must be specified.
In this case the initial prototypes are drawn from the data (without 
replacement).
</p>
<p>If the number of retries is greater than zero the best among that number 
of trial solutions is returned. Note that the number of prototypes must be
specified as the initial prototypes are sampled from the data.
</p>
<p>The debugging output shows the iteration number, the inverted information 
and the variance of the current partition as a percentage of the total (if 
each data point were a cluster), and the number of active prototypes (those 
with at least one member, i.e. a data point that is not closer to any 
other prototype).
</p>
<p>Note that the algorithm uses tie-breaking when it determines the cluster
memberships of the samples.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>centers</code></td>
<td>
<p>a matrix of cluster means (final prototypes).</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a vector of cluster sizes.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>a factor of cluster labels (indexes).</p>
</td></tr>
<tr><td><code>inv.inf</code></td>
<td>
<p>the inverted information of the partition.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>opt.std</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Support for data matrices <code>x</code> in sparse <code>dgTMatrix</code> and 
<code>dgCMatrix</code> format (see package <span class="pkg">Matrix</span>) is experimental. 
Support for the <code>dgRMatrix</code> format is currently suspended
due to problems with package <span class="pkg">Matrix</span>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>Helmut Strasser and Klaus Poetzelberger. Data Compression by 
Unsupervised Classification. <em>SFB Report Series</em>, No. 10, 1997.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code>cmeans</code>, <code>kkmeans</code> for similar or related
clustering techniques.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### extend proximus example
x &lt;- rlbmat()
rownames(x) &lt;- seq(dim(x)[1])
cm &lt;- ccfkms(x, n=4, opt.retry=10)
pcm &lt;- predict(cm, x)
## Not run: 
### using sparse data may be more time-efficient
### depending on the goodness of the implementation
### of subset, etc. in package Matrix.
require(Matrix)
#sx &lt;- as(x, "dgRMatrix")    # currently broken
sx &lt;- as(x, "dgCMatrix")
system.time(scm &lt;- ccfkms(sx, n=4, opt.retry=50))
system.time(cm &lt;- ccfkms(x, n=4, opt.retry=50))

## End(Not run)
</code></pre>

<hr>
<h2 id='circleplot.dist'>Plotting Distance Graphs</h2><span id='topic+circleplot.dist'></span>

<h3>Description</h3>

<p>Function for visualizing distance graphs using a circular layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleplot.dist(x, cutoff = 0.5, col = 1, circle = FALSE,
                scale = 1.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleplot.dist_+3A_x">x</code></td>
<td>
<p>an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="circleplot.dist_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value specifying the threshold for edge exclusion.</p>
</td></tr>
<tr><td><code id="circleplot.dist_+3A_col">col</code></td>
<td>
<p>a number or string specifying the edge color to use.</p>
</td></tr>
<tr><td><code id="circleplot.dist_+3A_circle">circle</code></td>
<td>
<p>a logical value specifying if a circle connecting the
nodes should be drawn.</p>
</td></tr>
<tr><td><code id="circleplot.dist_+3A_scale">scale</code></td>
<td>
<p>a numeric value specifying the plot range (the default
accommodates node labels).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the distance graph of <code>x</code> placing its nodes on a circle
such that the number of crossing edges is approximately minimized.
This is achieved by using <code>order.dist</code> for seriation.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+order.dist">order.dist</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
data(iris)
d &lt;- dist(iris[,-5])[[1:26]]
circleplot.dist(d, col = 2, scale = 1)

dimnames(d) &lt;- LETTERS[1:26]
circleplot.dist(d)
</code></pre>

<hr>
<h2 id='clmplot'>Plotting Logical Matrices</h2><span id='topic+clmplot'></span>

<h3>Description</h3>

<p>A wrapper function to <code>image</code> that produces a level plot with
the option to color the rows (or columns) based on a clustering and/or
classification of the data, and the option to reorder the rows and
columns for better presentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clmplot(x, col, col.bycol = FALSE, order=FALSE,
        dist.method = "binary", hclust.method = "average",
        axes = FALSE, xlab = "", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clmplot_+3A_x">x</code></td>
<td>
<p>an logical matrix.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_col">col</code></td>
<td>
<p>an optional vector defining a coloring.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_col.bycol">col.bycol</code></td>
<td>
<p>option to color by columns.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_order">order</code></td>
<td>
<p>option to (pre)order the rows and columns.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_dist.method">dist.method</code></td>
<td>
<p>method to be used by <code>dist</code>.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_hclust.method">hclust.method</code></td>
<td>
<p>method to be used by <code>hclust</code>.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_axes">axes</code></td>
<td>
<p>option to plot axes.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_xlab">xlab</code>, <code id="clmplot_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x and y axis.</p>
</td></tr>
<tr><td><code id="clmplot_+3A_...">...</code></td>
<td>
<p>further arguments to <code>image</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For dummy coded data the level <code>FALSE</code> is assumed to carry no 
information and is colored <code>white</code>. Thus, the level <code>TRUE</code> can 
be colored according to some classification of the rows (or columns) 
of the data matrix. If no color specification is supplied the default 
color <code>black</code> is used.
</p>
<p>If <code>col</code> is of type character it is assumed to contain color codes. 
Otherwise, it must be a factor and the levels are assigned colors
from <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>. 
</p>
<p>If <code>order</code> is <code>TRUE</code> the rows and columns are ordered
by <code>hclust</code> where the distances are computed by <code>dist</code>. 
</p>
<p>Note that an axis is only plotted if the number of elements (rows or
columns) is less than 100.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>rows</code></td>
<td>
<p>the row order.</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>the column order.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmplot">lmplot</a></code> for plotting of logical data at reduced resolutions,
<code><a href="stats.html#topic+heatmap">heatmap</a></code> for ordered plotting of real-valued data, and
package <span class="pkg">gclus</span> for ordering functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(sample(c(FALSE,TRUE),100,rep=TRUE),ncol=10)
clmplot(x, order=TRUE, axes=TRUE)
clmplot(x, col=rep(c(1,2),each=5))
clmplot(x, col=rep(c("red","blue"),each=5))
clmplot(x, col=rep(c("red","blue"),each=5), col.bycol=TRUE)
## Not run: 
### continue example (see rockCluster)
col &lt;- Votes$Class                                  # color by party
levels(col) &lt;- c("red","blue")
op &lt;- par(mfrow=c(1,2), pty="s")
clmplot(x, order=TRUE, col=as.character(col), main="Parties")
col &lt;- rf$cl                                        # color by cluster
levels(col) &lt;- c("blue","red","green", "black")     # map NA to black
clmplot(x, order=TRUE, col=as.character(col), main="Clusters")
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='cluster.dist'>Clustering a Sparse Symmetric Distance Matrix</h2><span id='topic+cluster.dist'></span>

<h3>Description</h3>

<p>Compute a clustering on a sparse symmetric distance matrix using
graph cutting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.dist(x, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.dist_+3A_x">x</code></td>
<td>
<p>an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="cluster.dist_+3A_beta">beta</code></td>
<td>
<p>the distance threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a clustering on an object of class <code>dist</code>
by cutting the graph induced by the threshold <code>beta</code> into all
disconnected subgraphs (the clusters). Two nodes are connected by a
link if their distance is below the specified threshold. Note that
the threshold is not strict, i.e. <code>&gt;=</code>.
</p>
<p>Note that distances of value <code>NA</code> and <code>NaN</code> are ignored.
This is not strictly correct but avoids computing <code class="reqn">2^k</code> possible
solutions if there are k <code>NA</code> values.
</p>
<p>The time complexity is <code class="reqn">O(n^2)</code> with n the number of rows/columns.
</p>


<h3>Value</h3>

<p>A factor of cluster labels (indexed 1,2,...,k).
</p>


<h3>Note</h3>

<p>Fixme: can the time complexity be improved?
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code> and <code><a href="#topic+sdists">sdists</a></code> for distance computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 3 clusters (1 = connected)
x &lt;- matrix(c(1,1,0,0,0,0,
	      1,1,0,0,0,0,
	      0,0,1,1,0,0,
	      0,0,1,1,0,0,
	      0,0,0,0,1,1,
	      0,0,0,0,1,1), ncol=6)
c &lt;- cluster.dist(as.dist(!x), beta = 0) # invert and note that 0 &gt;= 0
c
</code></pre>

<hr>
<h2 id='coding'>Dummy Coding</h2><span id='topic+as.dummy'></span><span id='topic+as.dummy.matrix'></span><span id='topic+as.dummy.data.frame'></span>

<h3>Description</h3>

<p>Functions that convert R objects to a dummy coded matrix (or a list of 
matrices). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dummy(x, ...)

## S3 method for class 'matrix'
as.dummy(x, sep = " ", drop = FALSE, ...)
## S3 method for class 'data.frame'
as.dummy(x, sep = " ", drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coding_+3A_x">x</code></td>
<td>
<p>an R object (see below).</p>
</td></tr>
<tr><td><code id="coding_+3A_sep">sep</code></td>
<td>
<p>separator used for construction of colnames.</p>
</td></tr>
<tr><td><code id="coding_+3A_drop">drop</code></td>
<td>
<p>drop factors with less than two levels.</p>
</td></tr>
<tr><td><code id="coding_+3A_...">...</code></td>
<td>
<p>other (unused) arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic is applicable to factor and to R objects that can be 
converted to factor, i.e. <code>logical</code>, <code>integer</code>, or 
<code>character</code>. For numeric data a discretization method has to be 
used.
</p>
<p>A factor is converted to as many logical variables as there are levels 
where the value <code>TRUE</code> indicates the presence of a level.
</p>
<p>The colnames are made of the concatenation of a variable name and the 
level, separated by <code>sep</code>. For <code>matrix</code> and <code>data.frame</code> 
variable names are created if necessary.
</p>
<p>A value of <code>NA</code> is mapped to <code>FALSE</code> across all levels.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with a <code>levels</code> attribute which contains a list of 
the levels of the coded variables.
</p>


<h3>Warning</h3>

<p>This is experimental code which may change in the future.</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.logical">as.logical</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 
x &lt;- as.integer(sample(3,10,rep=TRUE))
as.dummy(x)
is.na(x) &lt;- c(3,5)
as.dummy(x)
x &lt;- as.data.frame(x)
as.dummy(x)
</code></pre>

<hr>
<h2 id='cut.ordered'>Converting Ordered Factors</h2><span id='topic+cut.ordered'></span>

<h3>Description</h3>

<p>Reduce the levels of an ordered factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordered'
cut(x, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.ordered_+3A_x">x</code></td>
<td>
<p>an ordered factor.</p>
</td></tr>
<tr><td><code id="cut.ordered_+3A_breaks">breaks</code></td>
<td>
<p>a logical, character, or index vector of cut points.</p>
</td></tr>
<tr><td><code id="cut.ordered_+3A_...">...</code></td>
<td>
<p>further (unused) arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>breaks</code> is of class <code>logical</code> it must have the same length 
as the number of levels of <code>x</code>.
</p>
<p>If <code>breaks</code> is of class <code>character</code> partial matching with
the levels of <code>x</code> is attempted.
</p>
<p>Otherwise <code>breaks</code> is assumed to index the levels.
</p>


<h3>Value</h3>

<p>An ordered factor.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>Functions Missing in R: A Never Ending Story ;-)</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code> for converting numeric vectors to factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ordered(sample(letters[1:3],10,rep=TRUE))
cut(x, c(FALSE,TRUE,FALSE))
cut(x, "b")
cut(x, 2)
</code></pre>

<hr>
<h2 id='fitted.proximus'>Extract from a Proximus Object</h2><span id='topic+fitted.proximus'></span>

<h3>Description</h3>

<p>Get the full storage representation of the approximated matrix 
and the pattern labels of the original data samples from an object
of class <code>proximus</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proximus'
fitted(object, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.proximus_+3A_object">object</code></td>
<td>
<p>an object of class <code>proximus</code>.</p>
</td></tr>
<tr><td><code id="fitted.proximus_+3A_drop">drop</code></td>
<td>
<p>optionally drop patterns that do not meet the mining criteria.</p>
</td></tr>
<tr><td><code id="fitted.proximus_+3A_...">...</code></td>
<td>
<p>further (unused) arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If option <code>drop</code> is <code>TRUE</code> only patterns that satisfy the 
minimum size and maximum radius constraint are extracted. 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the fitted data matrix.</p>
</td></tr>
<tr><td><code>pl</code></td>
<td>
<p>a factor of pattern (cluster) labels. The indexes of the 
original data samples are provided as attribute <code>Index</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+proximus">proximus</a></code> for pattern mining with the Proximus algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see proximus
</code></pre>

<hr>
<h2 id='gknn'>Generalized k-Nearest Neighbor Classification</h2><span id='topic+gknn'></span>

<h3>Description</h3>

<p>Compute the k-nearest neighbor classification given a matrix of 
cross-distances and a factor of class values. For each row the majority 
class is found, where ties are broken at random (default). If there are ties 
for the kth nearest neighbor, all candidates are included in the vote 
(default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gknn(x, y, k = 1, l = 0, break.ties = TRUE, use.all = TRUE,
     prob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gknn_+3A_x">x</code></td>
<td>
<p>a cross-distances matrix.</p>
</td></tr>
<tr><td><code id="gknn_+3A_y">y</code></td>
<td>
<p>a factor of class values of the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="gknn_+3A_k">k</code></td>
<td>
<p>number of nearest neighbors to consider.</p>
</td></tr>
<tr><td><code id="gknn_+3A_l">l</code></td>
<td>
<p>minimum number of votes for a definite decision.</p>
</td></tr>
<tr><td><code id="gknn_+3A_break.ties">break.ties</code></td>
<td>
<p>option to break ties.</p>
</td></tr>
<tr><td><code id="gknn_+3A_use.all">use.all</code></td>
<td>
<p>option to consider all neighbors that are tied with the 
kth neighbor.</p>
</td></tr>
<tr><td><code id="gknn_+3A_prob">prob</code></td>
<td>
<p>optionally return proportions of winning votes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows of the cross-distances matrix are interpreted as referencing the 
test samples and the columns as referencing the training samples.
</p>
<p>The options are fashioned after <code>knn</code> in package <span class="pkg">class</span> but are
extended for tie breaking of votes, e.g. if only definite (majority) votes 
are of interest.
</p>
<p>Missing class values are not allowed because that would collide with a 
missing classification result.
</p>
<p>Missing distance values are ignored but with the possible consequence 
of missing classification results. Note that this depends on the 
options settings, e.g. 
</p>


<h3>Value</h3>

<p>Returns a factor of class values (of the rows of <code>x</code>) which may be 
<code>NA</code> in the case of doubt (no definite decision), ties, or missing
neighborhood information.
</p>
<p>The proportions of winning votes are returned as attribute <code>prob</code>
(if option <code>prob</code> was used).
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="proxy.html#topic+dist">dist</a></code> for efficient computation of cross-distances.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### extend Rock example
data(Votes)
x &lt;- as.dummy(Votes[-17])
rc &lt;- rockAll(x, n=2, m=100, theta=0.73, predict=FALSE, debug=TRUE)
gc &lt;- gknn(dist(x, rc$y, method="binary"), rc$cl, k=3)
table(gc[rc$s], rc$cl)

## End(Not run)
</code></pre>

<hr>
<h2 id='image'>Matrix Image Plots</h2><span id='topic+implot'></span>

<h3>Description</h3>

<p>Implements a wrapper function to <code>image</code> for proper plotting of
objects of class <code>matrix</code> and <code>dist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implot(x, xlab = "", ylab = "", axes = FALSE, ticks = 10,
       las = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_+3A_x">x</code></td>
<td>
<p>an object of class <code>matrix</code> or <code>dist</code>.</p>
</td></tr>
<tr><td><code id="image_+3A_xlab">xlab</code>, <code id="image_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x and y axis.</p>
</td></tr>
<tr><td><code id="image_+3A_axes">axes</code></td>
<td>
<p>logical, indicating whether <code>dimnames(x)</code> should be
drawn on the plot.</p>
</td></tr>
<tr><td><code id="image_+3A_ticks">ticks</code></td>
<td>
<p>the number of tick-marks to use.</p>
</td></tr>
<tr><td><code id="image_+3A_las">las</code></td>
<td>
<p>the axis style to use (see <code>par</code>).</p>
</td></tr>
<tr><td><code id="image_+3A_...">...</code></td>
<td>
<p>further arguments to <code>image</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots an object of class <code>matrix</code> in its original row and column
orientation. This means, in a plot the columns become the x-coordinates 
and the reversed rows the y-coordinates.
</p>
<p>If <code>x</code> is of class <code>dist</code> it is coerced to full-storage
<code>matrix</code> representation.
</p>


<h3>Value</h3>

<p>Returns the transformed <code>x</code> <em>invisibly</em>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+par">par</a></code> for details.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(sample(c(FALSE, TRUE),100,rep=TRUE),ncol=10,
	    dimnames=list(1:10,LETTERS[1:10]))
implot(x)
implot(x, col=c("white","black"), axes = TRUE)
</code></pre>

<hr>
<h2 id='lminter'>Interpolating Logical Matrices</h2><span id='topic+lminter'></span>

<h3>Description</h3>

<p>Interpolate a logical matrix into a lower-resolution representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lminter(x, block.size = 1, nbin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lminter_+3A_x">x</code></td>
<td>
<p>a logical matrix.</p>
</td></tr>
<tr><td><code id="lminter_+3A_block.size">block.size</code></td>
<td>
<p>the interpolation block size.</p>
</td></tr>
<tr><td><code id="lminter_+3A_nbin">nbin</code></td>
<td>
<p>the number of density bins.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partitions a binary matrix into square blocks of specified size 
(length) and interpolates the number of <code>TRUE</code> values per block 
using the specified number of bins. 
</p>
<p>Note that the effective number of bins is one greater than the specified 
number because the zero bin is always included. Excess rows and columns 
at the lower or right margins of the matrix are ignored.
</p>
<p>If the number of bins is null counts are mapped to zero and one 
thresholding at half of the number of distinct count values including 
zero. Thus, for even numbered block sizes there is a bias towards zero.
</p>


<h3>Value</h3>

<p>An integer matrix of bin numbers.
</p>


<h3>Note</h3>

<p>Package internal function.</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmplot">lmplot</a></code> for plotting logical matrices.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(sample(c(FALSE, TRUE), 4 ,rep=TRUE), ncol=2)
lminter(x, block.size=2, nbin=2)

## End(Not run)</code></pre>

<hr>
<h2 id='lmplot'>Plotting Logical Matrices</h2><span id='topic+lmplot'></span>

<h3>Description</h3>

<p>Implements a wrapper function to <code>image</code> that produces a black and
white or gray-scale plot of a logical matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmplot(x, block.size = 1, gray = FALSE, xlab = "", ylab = "", 
       axes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmplot_+3A_x">x</code></td>
<td>
<p>a logical matrix.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_block.size">block.size</code></td>
<td>
<p>the interpolation block size.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_gray">gray</code></td>
<td>
<p>optionally use a gray scale.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_xlab">xlab</code></td>
<td>
<p>title for the x axis.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_ylab">ylab</code></td>
<td>
<p>title for the y axis.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_axes">axes</code></td>
<td>
<p>option to plot axes.</p>
</td></tr>
<tr><td><code id="lmplot_+3A_...">...</code></td>
<td>
<p>further arguments to <code>image</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>TRUE</code> is represented by the color white and <code>FALSE</code> by the 
color black. 
</p>
<p>A lower resolution can be obtained by specifying an (interpolation) block 
size greater than one. Block densities can then be visualized by using 
the gray scale option. The number of levels of the palette corresponds to 
the block size but is capped to 8 levels (excluding white). Note that 
the opacity (blackness) corresponds with density (as on photographic 
film).
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+lminter">lminter</a></code> for interpolating logical matrices and 
<code><a href="Matrix.html#topic+image">image</a></code> for further plotting options</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
x &lt;- matrix(sample(c(FALSE, TRUE), 64, rep=TRUE), ncol=8)
lmplot(x)
### use lower resolution
lmplot(x, block.size=2)
### use gray scale
lmplot(x, block.size=2, gray=TRUE)
</code></pre>

<hr>
<h2 id='Mushroom'>Mushroom Data Set</h2><span id='topic+Mushroom'></span>

<h3>Description</h3>

<p>A data set with descriptions of hypothetical samples corresponding to
23 species of gilled mushrooms in the Agaricus and Lepiota Family,
classified according to their edibility as (definitely)
&lsquo;edible&rsquo; or &lsquo;poisonous&rsquo; (definitely poisonous, or of
unknown edibility and not recommended).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Mushroom")
</code></pre>


<h3>Format</h3>

<p>A data frame with 8124 observations on the following 23 variables.
</p>

<dl>
<dt><code>class</code></dt><dd><p>a factor with levels <code>edible</code> and
<code>poisonous</code>.</p>
</dd>
<dt><code>cap-shape</code></dt><dd><p>a factor with levels <code>bell</code>,
<code>conical</code>, <code>convex</code>, <code>flat</code>, <code>knobbed</code>,
<code>sunken</code>.</p>
</dd>
<dt><code>cap-surface</code></dt><dd><p>a factor with levels <code>fibrous</code>,
<code>grooves</code>, <code>scaly</code>, <code>smooth</code>.</p>
</dd>
<dt><code>cap-color</code></dt><dd><p>a factor with levels <code>brown</code>,
<code>buff</code>, <code>cinnamon</code>, <code>gray</code>, <code>green</code>,
<code>pink</code>, <code>purple</code>, <code>red</code>, <code>white</code>,
<code>yellow</code>.</p>
</dd>
<dt><code>bruises?</code></dt><dd><p>a factor with levels <code>bruises</code> and
<code>no</code>.</p>
</dd>
<dt><code>odor</code></dt><dd><p>a factor with levels <code>almond</code>, <code>anise</code>,
<code>creosote</code>, <code>fishy</code>, <code>foul</code>, <code>musty</code>,
<code>none</code>, <code>pungent</code>, <code>spicy</code>.</p>
</dd>
<dt><code>gill-attachment</code></dt><dd><p>a factor with levels <code>attached</code>
and <code>free</code>. </p>
</dd>
<dt><code>gill-spacing</code></dt><dd><p>a factor with levels <code>close</code> and
<code>crowded</code>.</p>
</dd>
<dt><code>gill-size</code></dt><dd><p>a factor with levels <code>broad</code> and
<code>narrow</code>.</p>
</dd>
<dt><code>gill-color</code></dt><dd><p>a factor with levels <code>black</code>,
<code>brown</code>, <code>buff</code>, <code>chocolate</code>, <code>gray</code>,
<code>green</code>, <code>orange</code>, <code>pink</code>, <code>purple</code>,
<code>red</code>, <code>white</code>, and <code>yellow</code>.</p>
</dd>
<dt><code>stalk-shape</code></dt><dd><p>a factor with levels <code>enlarging</code> and
<code>tapering</code>.</p>
</dd>
<dt><code>stalk-root</code></dt><dd><p>a factor with levels <code>bulbous</code>,
<code>club</code>, <code>equal</code>, and <code>rooted</code>. </p>
</dd>
<dt><code>stalk-surface-above-ring</code></dt><dd><p>a factor with levels
<code>fibrous</code>, <code>scaly</code>, <code>silky</code>, and <code>smooth</code>.</p>
</dd>
<dt><code>stalk-surface-below-ring</code></dt><dd><p>a factor with levels
<code>fibrous</code>, <code>scaly</code>, <code>silky</code>, and <code>smooth</code>.</p>
</dd>
<dt><code>stalk-color-above-ring</code></dt><dd><p>a factor with levels
<code>brown</code>, <code>buff</code>, <code>cinnamon</code>, <code>gray</code>,
<code>orange</code>, <code>pink</code>, <code>red</code>, <code>white</code>, and
<code>yellow</code>.</p>
</dd>
<dt><code>stalk-color-below-ring</code></dt><dd><p>a factor with levels
<code>brown</code>, <code>buff</code>, <code>cinnamon</code>, <code>gray</code>,
<code>orange</code>, <code>pink</code>, <code>red</code>, <code>white</code>, and
<code>yellow</code>.</p>
</dd>
<dt><code>veil-type</code></dt><dd><p>a factor with levels <code>partial</code>.</p>
</dd>
<dt><code>veil-color</code></dt><dd><p>a factor with levels <code>brown</code>,
<code>orange</code>, <code>white</code>, and <code>yellow</code>.</p>
</dd>
<dt><code>ring-number</code></dt><dd><p>a factor with levels <code>one</code>,
<code>one</code>, and <code>two</code>.</p>
</dd> 
<dt><code>ring-type</code></dt><dd><p>a factor with levels <code>evanescent</code>,
<code>flaring</code>, <code>large</code>, <code>none</code>, and <code>pendant</code>.</p>
</dd> 
<dt><code>spore-print-color</code></dt><dd><p>a factor with levels <code>black</code>,
<code>brown</code>, <code>buff</code>, <code>chocolate</code>, <code>green</code>,
<code>orange</code>, <code>purple</code>, <code>white</code>, and <code>yellow</code>.</p>
</dd>
<dt><code>population</code></dt><dd><p>a factor with levels <code>abundant</code>,
<code>clustered</code>, <code>numerous</code>, <code>scattered</code>,
<code>several</code>, and <code>solitary</code>.</p>
</dd>
<dt><code>habitat</code></dt><dd><p>a factor with levels <code>grasses</code>,
<code>leaves</code>, <code>meadows</code>, <code>paths</code>, <code>urban</code>,
<code>waste</code>, and <code>woods</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The records are drawn from
G. H. Lincoff (1981) (Pres.),
<em>The Audubon Society Field Guide to North American Mushrooms</em>.
New York: Alfred A. Knopf.
(See pages 500&ndash;525 for the Agaricus and Lepiota Family.)
</p>
<p>The Guide clearly states that there is no simple rule for determining
the edibility of a mushroom; no rule like &ldquo;leaflets three, let
it be&rdquo; for Poisonous Oak and Ivy.
</p>
<p>Unused levels in the original data were dropped.
</p>


<h3>Source</h3>

<p><a href="http://www.ics.uci.edu/~mlearn/MLRepository.html">http://www.ics.uci.edu/~mlearn/MLRepository.html</a>
</p>


<h3>References</h3>

<p>Blake, C.L. &amp; Merz, C.J. (1998).
UCI Repository of Machine Learning Databases.
Irvine, CA: University of California, Department of Information and
Computer Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Mushroom")
summary(Mushroom)
</code></pre>

<hr>
<h2 id='order'>Improving the Presentation of Matrix Objects</h2><span id='topic+order.dist'></span><span id='topic+order.matrix'></span><span id='topic+order.data.frame'></span>

<h3>Description</h3>

<p>High-level functions that improve the presentation of a matrix or data
frame by reordering their rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.dist(x, index = FALSE)
order.matrix(x, type = "neumann", by = c("both","rows","cols"),
             index = FALSE)
order.data.frame(x, type = "neumann", by = c("both","rows","cols"),
                 index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_+3A_x">x</code></td>
<td>
<p>an object of class <code>dist</code>, <code>matrix</code>, or
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="order_+3A_type">type</code></td>
<td>
<p>the type of stress measure to use (see details).</p>
</td></tr>
<tr><td><code id="order_+3A_by">by</code></td>
<td>
<p>option to order either by rows, or columns, or both.</p>
</td></tr>
<tr><td><code id="order_+3A_index">index</code></td>
<td>
<p>option to return the order index(ex) instead of the
reordered object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions try to improve the presentation of an object of class
<code>dist</code>, <code>matrix</code>, or<br /><code>data.frame</code> by reordering the rows
and columns such that similar entries are grouped together.
</p>
<p><code>order.dist</code> uses a simple heuristic to solve the TSP problem of
finding an ordering of minimum length (see <code>order.length</code>) for an
object of class <code>dist</code>. Note that the heuristic used is quick but
more elaborate TSP algorithms will produce better orderings.
</p>
<p><code>order.matrix</code> tries to minimize the stress measure of a matrix
(see <code>stress</code> by using the same TSP heuristic as above, once for
the column and once for the row ordering (while the other dimension is
fixed) if <code>by = "both"</code>.
</p>
<p><code>order.data.frame</code> uses attributes of type <code>numeric</code>
and <code>logical</code> only, combines them into a normalized matrix and
finds an ordering as above.
</p>


<h3>Value</h3>

<p>Either the reordered object supplied, or a vector of subscripts (for
<code>reorder.dist</code>), or a list with components <code>rows</code> and
<code>columns</code> containing the order indexes (for <code>reorder.matrix</code> 
and <code>reorder.data.frame</code>).
</p>


<h3>Note</h3>

<p>This is experimental code that may be integrated in a separate packages
in the future.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code>stress</code>, <code>stress.dist</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## not a hard problem
data(iris)
d &lt;- dist(iris[1:4])
implot(order.dist(d))
data(townships)
x &lt;- order.data.frame(townships)
x
</code></pre>

<hr>
<h2 id='order.greedy'>Hierarchical Greedy Ordering</h2><span id='topic+order.greedy'></span>

<h3>Description</h3>

<p>Compute a hierarchical greedy ordering of a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.greedy(dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.greedy_+3A_dist">dist</code></td>
<td>
<p>an object of class <code>dist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A single cluster is constructed by merging in each step the leaf 
closest to one of the two endpoints of the cluster. The algorithm
starts with a random leaf and uses tie-breaking.
</p>
<p>Clearly, the algorithm is more an ordering than a cluster algorithm. 
However, it constructs a binary merge tree so that the linear ordering 
of its leaves could be further improved.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>merge</code></td>
<td>
<p>a matrix containing the merge tree.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a vector containing the leaf ordering.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>a vector containing the merge heights.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The merge heights may not be monotonic.</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>F. Murtagh (1985). Multidimensional Cluster Algorithms. <em>Lectures in
Computational Statistics</em>, Physica Verlag, pp. 15.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code> for hierarchical clustering,
<code><a href="#topic+order.optimal">order.optimal</a></code> for optimal leaf ordering, and
<code><a href="#topic+order.length">order.length</a></code> for computing the objective value of a 
leaf ordering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- dist(matrix(runif(20), ncol=2))
hc &lt;- hclust(d)
co &lt;- order.optimal(d, hc$merge)
md &lt;- -as.dist(crossprod(as.matrix(d, diag = 0)))   # Murtagh's distances
hg &lt;- order.greedy(md)
go &lt;- order.optimal(md, hg$merge)
### compare images
op &lt;- par(mfrow=c(2,2), pty="s")
implot(d[[hc$order]], main="hclust")
implot(d[[co$order]], main="hlcust + optimal")
implot(d[[hg$order]], main="greedy")
implot(d[[go$order]], main="greedy + optimal")
par(op)
# compare lengths
order.length(d, hc$order)
order.length(d, co$order)
order.length(d, hg$order)
order.length(d, go$order)
</code></pre>

<hr>
<h2 id='order.length'>Conciseness of Presentation Measures</h2><span id='topic+order.length'></span>

<h3>Description</h3>

<p>Compute the length of a Hamilton path through a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.length(dist, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.length_+3A_dist">dist</code></td>
<td>
<p>an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="order.length_+3A_order">order</code></td>
<td>
<p>an optional permutation of the row (column) indexes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordering a distance matrix such that low distance values are placed 
close to the diagonal may improve its presentation. The length of an
order is the corresponding objective measure.
</p>
<p>The order corresponds to a path through a graph where each node is
visited only once, i.e. a Hamilton path. The length of a path is defined 
as the sum of the edge weights, i.e. distances. 
</p>
<p>If <code>order</code> is missing the identity order is used.
</p>
<p>If <code>order</code> is not unique <code>NA</code> is returned.
</p>
<p>If there are non-finite distance values <code>NA</code> is returned.
</p>


<h3>Value</h3>

<p>A scalar real value.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>R. Sedgewick. (2002). <em>Algorithms in C. Part 5. Graph Algorithms</em>.
3rd Edition, Addison-Wesley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- dist(matrix(runif(10),ncol=2))
order.length(d)
o &lt;- sample(5,5) # random order
order.length(d, o)
</code></pre>

<hr>
<h2 id='order.optimal'>Optimal Leaf Ordering of Binary Trees.</h2><span id='topic+order.optimal'></span>

<h3>Description</h3>

<p>Find an optimal linear leaf ordering of a binary merge tree as
produced by a hierarchical cluster algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.optimal(dist, merge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.optimal_+3A_dist">dist</code></td>
<td>
<p>an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="order.optimal_+3A_merge">merge</code></td>
<td>
<p>a binary merge tree (see <code><a href="stats.html#topic+hclust">hclust</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binary tree has <code class="reqn">2^{n-1}</code> internal nodes (subtrees) and
the same
number of leaf orderings. That is, at each internal node the left 
and right subtree (or leaves) can be swapped, or, in terms of a
dendrogram, be flipped.
</p>
<p>An objective measure of a leaf ordering is the sum of the distances
along the path connecting the leaves in the given order. An ordering 
with a minimal path length is defined to be an optimal ordering.
</p>
<p>This function provides an interface to the optimal leaf ordering
algorithm (see references) for tree representations that are used by 
hierarchical cluster algorithms such as <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>
<p>Note that non-finite distance values are not allowed.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>merge</code></td>
<td>
<p>a matrix containing the merge tree corresponding with the 
optimal leaf order.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a vector containing the optimal leaf order.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>the length of the ordering.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The time complexity of the algorithm is <code class="reqn">O(n^3)</code>.</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>Z. Bar-Joseph, E. D. Demaine, D. K. Gifford, and T. Jaakkola.
(2001). Fast Optimal Leaf Ordering for Hierarchical Clustering.
<em>Bioinformatics</em>, Vol. 17 Suppl. 1, pp. 22-29. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code> for hierarchical clustering and
<code><a href="#topic+order.length">order.length</a></code> for computing the objective value of a 
leaf ordering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- dist(matrix(runif(30), ncol=2))
hc &lt;- hclust(d)
co &lt;- order.optimal(d, hc$merge)
### compare dendrograms
ho &lt;- hc
ho$merge &lt;- co$merge
ho$order &lt;- co$order
op &lt;- par(mfrow=c(2,2), pty="s")
plot(hc, main="hclust")
plot(ho, main="optimal")
# compare images
implot(d[[hc$order]])
implot(d[[co$order]])
par(op)
### compare lengths
order.length(d, hc$order)
order.length(d, co$order)
cat("compare: ",co$length,"\n")
</code></pre>

<hr>
<h2 id='plot.sdists.graph'>Plotting Edit Transcripts and Sequence Alignments</h2><span id='topic+plot.sdists.graph'></span>

<h3>Description</h3>

<p>Function for visualizing the optimal transformation (alignment) graph
for two symbol sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sdists.graph'
plot(x, circle.col = 1, graph.col = 2,
     circle.scale = c("mean", "max", "last", "text"), main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sdists.graph_+3A_x">x</code></td>
<td>
<p>an object of class <code>sdists.graph.</code></p>
</td></tr>
<tr><td><code id="plot.sdists.graph_+3A_circle.col">circle.col</code></td>
<td>
<p>color to be used for circles.</p>
</td></tr>
<tr><td><code id="plot.sdists.graph_+3A_graph.col">graph.col</code></td>
<td>
<p>color to be used for the graph.</p>
</td></tr>
<tr><td><code id="plot.sdists.graph_+3A_circle.scale">circle.scale</code></td>
<td>
<p>scaling to be used for circles.</p>
</td></tr>
<tr><td><code id="plot.sdists.graph_+3A_main">main</code></td>
<td>
<p>plot title.</p>
</td></tr>
<tr><td><code id="plot.sdists.graph_+3A_...">...</code></td>
<td>
<p>further unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the dynamic programming table, the (back)pointers
and the combined graph of optimal edit transcripts (alignments) computed
with <code>sdist.trace</code>. The fist sequence is represented by the y-axis
and the second by the x-axis.
</p>
<p>The circumference of a circle is proportional to the minimum cost
(maximum weight) of edit (alignment) operations leading to a table cell.
<code>circle.scale</code> specifies the type of normalization performed where
<code>last</code> means the last table entry (containing the optimum value),
and <code>text</code> draws the values instead of circles.
</p>
<p>The (back)pointers, defining possible (traceback) paths, are plotted
as <code>dotted</code> edges. Note that a traceback starts in the last cell
of the table and ends at the origin.
</p>
<p>For the edges of the graph that is the union of all optimal paths, two
line types are used: <code>solid</code> for insert, delete, and replace
operations, and <code>dashed</code> for a match. The line width indicates the
number of times an edge is on a path, but note that the interpretation
is device-specific (compare <code><a href="graphics.html#topic+par">par</a></code>).
</p>


<h3>Note</h3>

<p>Some issues with grid were fixed in R.2.4.x (Fixme ?).
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>D. Gusfield (1997). <em>Algorithms on Strings, Trees, and Sequences</em>. 
Cambridge University Press, Chapter 11.
</p>
<p>Inspired by: <a href="http://home.uchicago.edu/~aabbott/">http://home.uchicago.edu/~aabbott/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdists.trace">sdists.trace</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## continue example in sdists.trace
x1 &lt;- "vintner"
y1 &lt;- "writers"
b11 &lt;- sdists.trace(x1, y1, weight=c(1,1,0,1), graph = TRUE)
b11
plot(b11)
plot(b11, circle.scale = "text")
## partial
b12 &lt;- sdists.trace(x1, y1, weight=c(1,1,0,1), graph = TRUE, partial = TRUE)
b12
plot(b12)
</code></pre>

<hr>
<h2 id='predict.ccfkms'>Clustering with Conjugate Convex Functions.</h2><span id='topic+predict.ccfkms'></span>

<h3>Description</h3>

<p>Classify the rows of a data matrix using conjugate convex functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ccfkms'
predict(object, x, drop = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ccfkms_+3A_object">object</code></td>
<td>
<p>an object of class <code>ccfkms</code>.</p>
</td></tr>
<tr><td><code id="predict.ccfkms_+3A_x">x</code></td>
<td>
<p>a data matrix containing test or new samples.</p>
</td></tr>
<tr><td><code id="predict.ccfkms_+3A_drop">drop</code></td>
<td>
<p>cluster size threshold.</p>
</td></tr>
<tr><td><code id="predict.ccfkms_+3A_...">...</code></td>
<td>
<p>other (unused) arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper to <code><a href="#topic+ccfkms">ccfkms</a></code> which uses a single iteration 
for classifying the data.
</p>
<p>In the case a <code>drop</code> value greater than zero is specified, all
clusters with size equal or less than this value are removed from the
classifier.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>centers</code></td>
<td>
<p>a matrix of cluster means.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a vector of cluster sizes.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>a factor of cluster labels (indexes).</p>
</td></tr>
<tr><td><code>inv.inf</code></td>
<td>
<p>the inverted information of the partition.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccfkms">ccfkms</a></code> for obtaining a classifier.</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see ccfkms
</code></pre>

<hr>
<h2 id='predict.rock'>Rock Clustering</h2><span id='topic+predict.rock'></span><span id='topic+fitted.rock'></span>

<h3>Description</h3>

<p>Classify the rows of a data matrix using the Rock classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rock'
predict(object, x, drop = 1, ...)

## S3 method for class 'rock'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rock_+3A_object">object</code></td>
<td>
<p>an object of class <code>rock</code>.</p>
</td></tr>
<tr><td><code id="predict.rock_+3A_x">x</code></td>
<td>
<p>a data matrix containing test or new samples.</p>
</td></tr>
<tr><td><code id="predict.rock_+3A_drop">drop</code></td>
<td>
<p>cluster size threshold.</p>
</td></tr>
<tr><td><code id="predict.rock_+3A_...">...</code></td>
<td>
<p>further (unused) arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides a wrapper function to the Rock classifier: cluster memberships 
of the (row) samples are determined by majority vote using the size (of 
the cluster) weighted number of links. 
</p>
<p>The classifier uses random tie-breaking and assigns samples with zero link 
counts to <code>NA</code>. This allows for detection of possible outliers, or
interesting patterns.
</p>
<p>In the case a <code>drop</code> value greater than zero is specified, all 
clusters with size equal or less than this value are removed from the 
classifier. Especially, <code>fitted</code> uses a threshold of one because
for singleton clusters the neighborhood is empty.
</p>
<p>Note that for the training data the predicted memberships need not 
necessarily be the same as those obtained from the cluster algorithm.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>cl</code></td>
<td>
<p>a factor of cluster memberships of the samples.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a vector of cluster sizes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rockCluster">rockCluster</a></code> for obtaining a rock classifier and
<code><a href="#topic+gknn">gknn</a></code> for k-nearest neighbor classification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example from paper
data(Votes)
x &lt;- as.dummy(Votes[-17])
rc &lt;- rockCluster(x, n=2, theta=0.73, debug=TRUE)
rp &lt;- predict(rc, x)
table(rp$cl)
</code></pre>

<hr>
<h2 id='proximus'>Proximus</h2><span id='topic+proximus'></span>

<h3>Description</h3>

<p>Cluster the rows of a logical matrix using the Proximus algorithm. The 
compression rate of the algorithm can be influenced by the choice of 
the maximum cluster radius and the minimum cluster size. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximus(x, max.radius = 2, min.size = 1, min.retry = 10,
         max.iter = 16, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proximus_+3A_x">x</code></td>
<td>
<p>a logical matrix.</p>
</td></tr>
<tr><td><code id="proximus_+3A_max.radius">max.radius</code></td>
<td>
<p>the maximum number of bits a member in a row set may 
deviate from its dominant pattern.</p>
</td></tr>
<tr><td><code id="proximus_+3A_min.size">min.size</code></td>
<td>
<p>the minimum split size of a row set.</p>
</td></tr>
<tr><td><code id="proximus_+3A_min.retry">min.retry</code></td>
<td>
<p>number of retries to split a pure rank-one approximation 
(translates into a resampling rate).</p>
</td></tr>
<tr><td><code id="proximus_+3A_max.iter">max.iter</code></td>
<td>
<p>the maximum number of iterations for finding a local 
rank-one approximation.</p>
</td></tr>
<tr><td><code id="proximus_+3A_debug">debug</code></td>
<td>
<p>optional debugging output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intended area of application is the compression of high-dimensional 
binary data into representative patterns. For instance, purchase incidence 
(market basket data) or term-document matrices may be preprocessed by 
Proximus for later association rule mining.
</p>
<p>The algorithm is of a recursive partitioning type. 
Specifically, at each step a binary split is attempted using a local 
rank-one approximation of the current submatrix (row set). That is a 
specialization of principal components to binary data which represents a 
matrix as the outer product of two binary vectors. The node expansion stops 
if a submatrix is pure, i.e., the column (presence set) vector indicates 
all the rows and the Hamming distances from the row (dominant attribute 
set) pattern vector, or the size of the row set, are less than or equal
the specified threshold. In the case the rank-one approximation does not 
result in a split but the radius constraint is violated, the matrix is 
split using a random row and the radius constraint.
</p>
<p>The debug option can be used to gain some insight into how the algorithm 
proceeds: a right angle bracket indicates a split and the return to
a recursion level is indicated by a left one. Leafs in the recursion tree 
are indicated by an asterisk and retries by a plus sign. The number of 
retries is bounded by the size of the current set divided by 
<code>min.retry</code>. 
Double angle brackets indicate a random split (see above). The numbers 
between square brackets indicate the current set size, the size of the 
presence (sub)set, and its radius. The adjoining numbers indicate the 
depth of the recursion and the count of retries. Finally, a count of 
the leaf nodes found so far is shown to the right of an asterisk.
</p>


<h3>Value</h3>

<p>An object of class <code>proximus</code> with the following components:
</p>
<table>
<tr><td><code>nr</code></td>
<td>
<p>the number of rows of the data matrix.</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>the number of columns of the data matrix.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>a list containing the approximations (patterns).</p>
</td></tr>
<tr><td><code>a$x</code></td>
<td>
<p>a vector of row (presence set) indexes.</p>
</td></tr>
<tr><td><code>a$y</code></td>
<td>
<p>a vector of column (dominant attribute set) indexes.</p>
</td></tr>
<tr><td><code>a$n</code></td>
<td>
<p>the number of ones in the approximated submatrix.</p>
</td></tr>
<tr><td><code>a$c</code></td>
<td>
<p>the absolute error reduction by the approximation.</p>
</td></tr>
<tr><td><code>max.radius</code></td>
<td>
<p>see arguments.</p>
</td></tr>
<tr><td><code>min.size</code></td>
<td>
<p>see arguments.</p>
</td></tr>
<tr><td><code>rownames</code></td>
<td>
<p>rownames of the data matrix.</p>
</td></tr>
<tr><td><code>colnames</code></td>
<td>
<p>colnames of the data matrix.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Deep recursions may exhaust your computer.</p>


<h3>Note</h3>

<p>The size of a set need not be equal or greater than the user defined 
threshold.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>M. Koyutürk, A. Graham, and N. Ramakrishnan. Compression, Clustering, and 
Pattern Discovery in Very High-Dimensional Discrete-Attribute Data Sets. 
<em>IEEE Transactions On Knowledge and Data Engineering</em>, Vol. 17, No. 4, 
(April) 2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.proximus">summary.proximus</a></code> for summaries,
<code><a href="stats.html#topic+fitted">fitted</a></code> for obtaining the approximated matrix and the 
pattern labels of the samples, and
<code><a href="#topic+lmplot">lmplot</a></code> for plotting logical matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(sample(c(FALSE, TRUE), 200, rep=TRUE), ncol=10)
pr &lt;- proximus(x, max.radius=8)
summary(pr)
### example from paper
x &lt;- rlbmat()
pr &lt;- proximus(x, max.radius=8, debug=TRUE)
op &lt;- par(mfrow=c(1,2), pty="s")
lmplot(x, main="Data")
box()
lmplot(fitted(pr)$x, main="Approximation")
box()
par(op)
</code></pre>

<hr>
<h2 id='rlbmat'>Block Uniform Logical Matrix Deviates</h2><span id='topic+rlbmat'></span>

<h3>Description</h3>

<p>Generate a uniform logical matrix deviate with a possibly overlapping 
block structure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlbmat(npat = 4, rows = 20, cols = 12, over = 4, noise = 0.01,
       prob = 0.8, perfect = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlbmat_+3A_npat">npat</code></td>
<td>
<p>number of patterns.</p>
</td></tr>
<tr><td><code id="rlbmat_+3A_rows">rows</code></td>
<td>
<p>number of rows per pattern.</p>
</td></tr>
<tr><td><code id="rlbmat_+3A_cols">cols</code></td>
<td>
<p>number of columns per pattern.</p>
</td></tr>
<tr><td><code id="rlbmat_+3A_over">over</code></td>
<td>
<p>number of additional columns per pattern that overlap.</p>
</td></tr>
<tr><td><code id="rlbmat_+3A_noise">noise</code></td>
<td>
<p>the probability of observing a one in the background
(non-pattern) matrix.</p>
</td></tr>
<tr><td><code id="rlbmat_+3A_prob">prob</code></td>
<td>
<p>the probability of observing <code>TRUE</code> in a pattern.</p>
</td></tr>
<tr><td><code id="rlbmat_+3A_perfect">perfect</code></td>
<td>
<p>option for overlap of the first and the last pattern.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements a test case for <code>proximus</code>. 
</p>


<h3>Value</h3>

<p>A logical matrix
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmplot">lmplot</a></code> and 
<code><a href="#topic+clmplot">clmplot</a></code> for plotting a logical matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rlbmat()
lmplot(x)
</code></pre>

<hr>
<h2 id='rockCluster'>Rock Clustering</h2><span id='topic+rockCluster'></span><span id='topic+rockLink'></span>

<h3>Description</h3>

<p>Cluster a data matrix using the Rock algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rockCluster(x, n, beta = 1-theta, theta = 0.5, fun = "dist",
            funArgs = list(method="binary"), debug = FALSE)

rockLink(x, beta = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rockCluster_+3A_x">x</code></td>
<td>
<p>a data matrix; for <code>rockLink</code> an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="rockCluster_+3A_n">n</code></td>
<td>
<p>the number of desired clusters.</p>
</td></tr>
<tr><td><code id="rockCluster_+3A_beta">beta</code></td>
<td>
<p>optional distance threshold.</p>
</td></tr>
<tr><td><code id="rockCluster_+3A_theta">theta</code></td>
<td>
<p>neighborhood parameter in the range [0,1).</p>
</td></tr>
<tr><td><code id="rockCluster_+3A_fun">fun</code></td>
<td>
<p>distance function to use.</p>
</td></tr>
<tr><td><code id="rockCluster_+3A_funargs">funArgs</code></td>
<td>
<p>a <code>list</code> of named parameter arguments to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="rockCluster_+3A_debug">debug</code></td>
<td>
<p>turn on/off debugging output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intended area of application is the clustering of binary (logical) 
data. For instance in a preprocessing step in data mining. However, 
arbitrary distance metrics could be used (see
<code><a href="proxy.html#topic+dist">dist</a></code>). 
</p>
<p>According to the reference (see below) the distance threshold and the 
neighborhood parameter are coupled. Thus, higher values of the neighborhood 
parameter <code>theta</code> pose a tighter constraint on the neighborhood. For 
any two data points the latter is defined as the number of other data points 
that are neighbors to both. Further, points only are neighbors (or linked) 
if their distance is less than or equal <code>beta</code>.
</p>
<p>Note that for a tight neighborhood specification the algorithm may be 
running out of clusters to merge, i.e. may terminate with more than the 
desired number of clusters. 
</p>
<p>The <code>debug</code> option can help in determining the proper settings by 
examining lines suffixed with a plus which indicates that non-singleton 
clusters were merged. 
</p>
<p>Note that tie-breaking is not implemented, i.e. the first max encountered 
is used. However, permuting the order of the data can help in determining 
the dependence of a solution on ties.
</p>
<p>Function <code>rockLink</code> is provided for applications that need to compute
link count distances efficiently. Note that <code>NA</code> and <code>NaN</code>
distances are ignored but supplying such values for the threshold
<code>beta</code> results in an error.
</p>


<h3>Value</h3>

<p><code>rockCluster</code> returns an object of class <code>rock</code>, a list with
the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the data matrix or a subset of it.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>a factor of cluster labels.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a vector of cluster sizes.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>
<p><code>rockLink</code> returns an object of class <code>dist</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>S. Guha, R. Rastogi, and K. Shim. ROCK: A Robust Clustering Algorithm for 
Categorical Attributes. <em>Information Science</em>, Vol. 25, No. 5, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="proxy.html#topic+dist">dist</a></code> for common distance functions,
<code><a href="stats.html#topic+predict">predict</a></code> for classifying new data samples, and
<code><a href="stats.html#topic+fitted">fitted</a></code> for classifying the clustered data samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example from paper
data(Votes)
x &lt;- as.dummy(Votes[-17])
rc &lt;- rockCluster(x, n=2, theta=0.73, debug=TRUE)
print(rc)
rf &lt;- fitted(rc)
table(Votes$Class, rf$cl)
## Not run: 
### large example from paper
data("Mushroom")
x &lt;- as.dummy(Mushroom[-1])
rc &lt;- rockCluster(x[sample(dim(x)[1],1000),], n=10, theta=0.8)
print(rc)
rp &lt;- predict(rc, x)
table(Mushroom$class, rp$cl)

## End(Not run)
### real valued example
gdist &lt;- function(x, y=NULL) 1-exp(-dist(x, y)^2)
xr &lt;- matrix(rnorm(200, sd=0.6)+rep(rep(c(1,-1),each=50),2), ncol=2)
rcr &lt;- rockCluster(xr, n=2, theta=0.75, fun=gdist, funArgs=NULL)
print(rcr)
</code></pre>

<hr>
<h2 id='sdists'>Sequence Distance Computation</h2><span id='topic+sdists'></span>

<h3>Description</h3>

<p>This function computes and returns the auto-distance matrix between 
the vectors of a list or between the character strings of a vector 
treating them as sequences of symbols, as well as the cross-distance 
matrix between two such lists or vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdists(x, y = NULL, method = "ow", weight = c(1, 1, 0, 2), 
       exclude = c(NA, NaN, Inf, -Inf), pairwise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdists_+3A_x">x</code>, <code id="sdists_+3A_y">y</code></td>
<td>
<p>a list (of vectors) or a vector of character.</p>
</td></tr>
<tr><td><code id="sdists_+3A_method">method</code></td>
<td>
<p>a mnemonic string referencing a distance measure.</p>
</td></tr>
<tr><td><code id="sdists_+3A_weight">weight</code></td>
<td>
<p>vector or matrix of parameter values.</p>
</td></tr>
<tr><td><code id="sdists_+3A_exclude">exclude</code></td>
<td>
<p>argument to factor.</p>
</td></tr>
<tr><td><code id="sdists_+3A_pairwise">pairwise</code></td>
<td>
<p>compute distances for the parallel pairs of <code>x</code>
and <code>y</code> only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a common interface to different methods for 
computation of distances between sequences, such as the edit a.k.a. 
Levenshtein distance. Conversely, in the context of sequence alignment 
the similarity of the maximizing alignment is computed.
</p>
<p>Note that negative similarities are returned as distances. So be careful
to use a proper weighting (scoring) scheme.
</p>
<p>The following methods are currently implemented:
</p>

<dl>
<dt><code>ow</code>:</dt><dd><p>operation-weight edit distance. Weights have to be
specified for deletion, insertion, match, and replacement. Other
weights for initial operations can be specified as
<code>weight[5:6]</code>.</p>
</dd>
<dt><code>aw</code>:</dt><dd><p>alphabet-weight sequential alignment similarity.
A matrix of weights (scores) for all possible symbol replacements 
needs to be specified with the convention that the first row/column 
defines the replacement with the empty (space) symbol. The colnames 
of this matrix are used as the levels argument for the encoding as 
<code>factor</code>. Consequently, unspecified symbols are mapped to
<code>NA</code>.</p>
</dd>
<dt><code>awl</code>:</dt><dd><p>alphabet-weight local sequential alignment similarity.
The weight matrix must be as described above. However, note that
zero acts as threshold for a 'restart' of the search for a local
alignment and at the same time indicates that the solution is the 
empty substring. Thus, you normally would use non-negative scores
for matches and non-positive weights otherwise.</p>
</dd>
</dl>

<p>Missing (and non-finite) values should be avoided, i.e. either be removed
or recoded (and appropriately weighted). By default they are excluded
when coercing to factor and therefore mapped to <code>NA</code>. The result 
is then defined to be <code>NA</code> as we cannot determine a match!
</p>
<p>The time complexity is O(n*m) for two sequences of length n and m.
</p>
<p>Note that in the case of auto-distances the weight matrix must be
(exactly) symmetric. Otherwise, for asymmetric weights <code>y</code>
must not be <code>NULL</code>. For instance, <code>x</code> may be supplied 
twice (see the examples).
</p>


<h3>Value</h3>

<p>Auto distances are returned as an object of class <code>dist</code> and 
cross-distances as an object of class <code>matrix</code>. 
</p>


<h3>Warning</h3>

<p>The interface is experimental and may change in the future</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>D. Gusfield (1997). <em>Algorithms on Strings, Trees, and Sequences</em>. 
Cambridge University Press, Chapter 11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdists.trace">sdists.trace</a></code> for computation of edit transcripts and sequence alignments,
<code><a href="proxy.html#topic+dist">dist</a></code> for computation of common distances,
<code><a href="base.html#topic+agrep">agrep</a></code> for searches for approximate matches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric data
sdists(list(c(2,2,3),c(2,4,3)))			# 2
sdists(list(c(2,2,3),c(2,4,3)),weight=c(1,1,0,1)) # 1

### character data
w &lt;- matrix(-1,nrow=8,ncol=8)			# weight/score matrix for
diag(w) &lt;- 0					# longest common subsequence
colnames(w) &lt;- c("",letters[1:7])
x &lt;- sapply(rbinom(3,64,0.5),function(n,x)
    paste(sample(x,n,rep=TRUE),collapse=""),
    colnames(w)[-1])
x
sdists(x,method="aw",weight=w)
sdists(x,x,method="aw",weight=w)		# check
## pairwise
sdists(x,rev(x),method="aw",weight=w,pairwise = TRUE)
diag(w) &lt;- seq(0,7)
sdists(x,method="aw", weight=w)			# global alignment
sdists(x,method="awl",weight=w)			# local alignment

## empty strings
sdists("", "FOO")
sdists("", list(c("F","O","O")))
sdists("", list(""))				# space symbol
sdists("", "abc", method="aw", weight=w)
sdists("", list(""), method="aw", weight=w)

### asymmetric weights
w[] &lt;- matrix(-sample(0:5,64,TRUE),ncol=8)
diag(w) &lt;- seq(0,7)
sdists(x,x,method="aw", weight=w)
sdists(x,x,method="awl",weight=w)

### missing values
sdists(list(c(2,2,3),c(2,NA,3)),exclude=NULL)	# 2 (include anything)
sdists(list(c(2,2,3),c(2,NA,3)),exclude=NA)	# NA

</code></pre>

<hr>
<h2 id='sdists.center'>Centroid Sequences</h2><span id='topic+sdists.center'></span>

<h3>Description</h3>

<p>Find centroid sequences among a collection of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdists.center(x, d = NULL, method = "ow", weight = c(1, 1, 0, 2),
              exclude = c(NA, NaN, Inf, -Inf), FUN = NULL, ...,
              unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdists.center_+3A_x">x</code></td>
<td>
<p>a list (of vectors) of a vector of character.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_d">d</code></td>
<td>
<p>a matrix or an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_method">method</code></td>
<td>
<p>argument to <code>sdists</code>.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_weight">weight</code></td>
<td>
<p>argument to <code>sdists</code>.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_exclude">exclude</code></td>
<td>
<p>argument to <code>sdists</code>.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_fun">FUN</code></td>
<td>
<p>a function to rank distances.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sdists.center_+3A_unique">unique</code></td>
<td>
<p>a logical specifying whether to return a unique
set of sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a wrapper to computing the distances among
the sequences in <code>x</code>, unless <code>d</code> is supplied, and the
subsequent selection of a set of centroid sequences with minimum
sum of distances to any other sequence.
</p>


<h3>Value</h3>

<p>A subset of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdists">sdists</a></code> for distance computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("ABCD", "AD", "BCD", "ACF", "CDF", "BC")
sdists.center(x)
</code></pre>

<hr>
<h2 id='sdists.center.align'>Align Sequences to a Center</h2><span id='topic+sdists.center.align'></span>

<h3>Description</h3>

<p>Find a global alignment of a collection of sequences using the
center-star-tree heuristic. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdists.center.align(x, center, method = "ow", weight = c(1, 1, 0, 2),
                    exclude = c(NA, NaN, Inf, -Inf),
                    break.ties = TRUE, transitive = FALSE,
                    to.data.frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdists.center.align_+3A_x">x</code></td>
<td>
<p>a list (of vectors) or a vector of character.</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_center">center</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_method">method</code></td>
<td>
<p>argument to <code>sdists</code>.</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_weight">weight</code></td>
<td>
<p>argument to <code>sdists</code>.</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_exclude">exclude</code></td>
<td>
<p>arguments to <code>sdists</code>.</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_break.ties">break.ties</code></td>
<td>
<p>a logical specifying whether random tie-breaking
should be performed. Otherwise the first alignment is used.</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_transitive">transitive</code></td>
<td>
<p>a logical specifying whether the sequences in
<code>x</code> should be aligned with each other, too.</p>
</td></tr>
<tr><td><code id="sdists.center.align_+3A_to.data.frame">to.data.frame</code></td>
<td>
<p>a logical specifying whether the result should
be converted to <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each component of <code>x</code> is aligned with <code>center</code> in turn
such that the latter is aligned with all sequences processed so
far.
</p>
<p>If <code>center</code> is missing <code>i<a href="#topic+sdists.center">sdists.center</a></code> is used
to compute an initial center.
</p>


<h3>Value</h3>

<p>Either a list of sequences with attributes <code>center</code> and
<code>ties</code>, or a <code>data.frame</code> with the sequences in
the columns.
</p>


<h3>Note</h3>

 
<p>The global alignment may depend on the order of <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>D. Gusfield (1997). <em>Algorithms on Strings, Trees, and
Sequences</em>.  Cambridge University Press, Chapter XX.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdists">sdists</a></code> for computation of distances, 
<code><a href="#topic+sdists.center">sdists.center</a></code> for computation of centroids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## continue example
x &lt;- c("ABCD", "AD", "BCD", "ACF", "CDF", "BC")
sdists.center.align(x)
sdists.center.align(x, transitive = TRUE, to.data.frame = TRUE)
</code></pre>

<hr>
<h2 id='sdists.trace'>Edit Transcripts and Sequence Alignments</h2><span id='topic+sdists.trace'></span>

<h3>Description</h3>

<p>This function computes and returns the set of all optimal but equivalent
edit transcripts that transforms one sequences into another at minimum
cost, as well as the corresponding aligned sequences, or, alternatively 
a combined edit graph. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdists.trace(x, y, method = "ow", weight = c(1, 1, 0, 2),
             exclude = c(NA, NaN, Inf, -Inf), graph = FALSE,
	     partial = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdists.trace_+3A_x">x</code>, <code id="sdists.trace_+3A_y">y</code></td>
<td>
<p>a numeric or string vector.</p>
</td></tr>
<tr><td><code id="sdists.trace_+3A_method">method</code></td>
<td>
<p>a mnemonic string referencing a distance measure.</p>
</td></tr>
<tr><td><code id="sdists.trace_+3A_weight">weight</code></td>
<td>
<p>vector or matrix of parameter values.</p>
</td></tr>
<tr><td><code id="sdists.trace_+3A_exclude">exclude</code></td>
<td>
<p>argument to factor.</p>
</td></tr>
<tr><td><code id="sdists.trace_+3A_graph">graph</code></td>
<td>
<p>option to compute the combined edit graph.</p>
</td></tr>
<tr><td><code id="sdists.trace_+3A_partial">partial</code></td>
<td>
<p>option to compute an approximate substring match.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>sdists.trace</code> complements the distance computation between
sequences by <code><a href="#topic+sdists">sdists</a></code>. So, please, see the details of
<code>method</code>, <code>weight</code>, and <code>exclude</code> there. However, note the
following differences: 1) you can supply only two sequences, either as
vectors of numeric symbol codes, factors, or as strings, i.e. scalar 
vectors of type <code>character</code>. 2) you can supply a weight matrix with
the rownames and colnames representing the symbol sets of the first and
second sequence. For instance, this allows you to align a sequence with
the profile of a multiple alignment. 3) if <code>method = "ow"</code> the
space symbol <code>""</code> is included in the factor levels so that you can
conveniently replace <code>NA</code> in the aligned sequences.
</p>
<p>A transcript uses the character codes <code>I</code>, <code>D</code>, <code>R</code>, and
<code>M</code>, for insert, delete, replace, and match operations, which
transform the first into the second sequence. Thus, conceptually a symbol
has to be inserted into the first, deleted from the second, replaced in the
first sequence, or matched in both, to obtain the second sequence. However,
in the aligned sequences you will see <code>NA</code>, where an insert or delete
would take place, indicating space. 
</p>
<p>In the case of a local alignment different symbols are used for the 
prefix and/or suffix of the alignment: <code>i</code>, <code>d</code>, and <code>?</code>
for insert, delete, and replace or match operations. However, note that
their sole purpose is to obtain a common representation of the two
sequences. Finally, only alignments of maximal length are reported.
</p>
<p>The time complexity of finding a transcript is <code class="reqn">O(n+m)</code> for two
sequences of length n and m, respectively <code class="reqn">O(n*m)</code> for the local
alignment problem. However, note that the runtime for generating all
transcripts can be <code class="reqn">O((n*m)^3)</code> in the worst case.
</p>
<p>If <code>partial = FALSE</code> computes an approximate substring match of
<code>x</code> (the pattern) in <code>y</code>, for <code>method = "ow"</code> only.
Returns the subset of paths which require the maximum number of match
and initial and final insert operations.
</p>


<h3>Value</h3>

<p>A list with components each a list of two factors, the aligned sequences.
The names of the components are the edit transcripts, and the attribute
<code>value</code> contains the minimum cost, i.e. the distance (or negative
similarity).
</p>
<p>If <code>graph = TRUE</code> a vector of edit transcripts is returned with
attributes <code>value</code>, <code>table</code>, <code>pointer</code>, and <code>graph</code>.
The second contains the values of the dynamic programming table and the
third a list of vectors <code>x0, y0, x1, y1</code> representing the
(back)pointers. Similarly, the fourth attribute is a list of vectors
<code>x0, y0, x1, y1, weight</code> representing the edge set of all optimal
paths. That is, each tuple contains the <code>from</code> and <code>to</code>
coordinates as used by <code>segments</code>, each representing a pair of
indexes into the first and second sequence, and the number of times an
edge occurs on a path. Note that the origin of the coordinate system
(0,0) corresponds to the element of <code>table</code> indexed by
(<code>""</code>,<code>""</code>),
where <code>""</code> indicates the space symbol. Thus, if used as subscripts
the coordinates have to be offset by one.
</p>


<h3>Warning</h3>

<p>The interface is experimental and may change in the future</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>References</h3>

<p>D. Gusfield (1997). <em>Algorithms on Strings, Trees, and Sequences</em>. 
Cambridge University Press, Chapter 11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdists">sdists</a></code> for computation of distances between sequences,
<code><a href="graphics.html#topic+segments">segments</a></code> for plotting of edge sets,
<code><a href="#topic+plot.sdists.graph">plot.sdists.graph</a></code> for visualizing alignments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### from the book
x1 &lt;- "vintner"
y1 &lt;- "writers"
b1 &lt;- sdists.trace(x1, y1, weight=c(1,1,0,1))
b1
## longest common subsequence ?
sdists.trace("a","b", weight=c(0,0,-1,0))
## from the book
w2 &lt;- matrix(-2,ncol=13,nrow=13)
w2[1,] &lt;- w2[,1] &lt;- -1
diag(w2) &lt;- c(0,rep(2,12))
x2 &lt;- "pqraxabcstvq"
y2 &lt;- "xyaxbacsll"
colnames(w2) &lt;- c("",unique(strsplit(paste(x2, y2, sep = ""),"")[[1]]))
b2 &lt;- sdists.trace(x2, y2, method="awl", weight=w2)
b2
## alignment with different symbol sets
x3 &lt;- "121314"
y3 &lt;- "ABACAD"
w3 &lt;- matrix(-1,nrow=5,ncol=5)
diag(w3) &lt;- 0
rownames(w3) &lt;- c("","1","2","3","4")
colnames(w3) &lt;- c("","A","B","C","D")
b3 &lt;- sdists.trace(x3, y3, method="aw", weight=w3)
b3
## partial
b4 &lt;- sdists.trace(x1, y1, weight=c(1,1,0,1), partial = TRUE)
b4
</code></pre>

<hr>
<h2 id='stress'>Conciseness of Presentation Measures</h2><span id='topic+stress'></span><span id='topic+stress.dist'></span>

<h3>Description</h3>

<p>Compute different types of conciseness of presentation measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress(x, rows = NULL, cols = NULL, type = "moore")

stress.dist(x, rows = NULL, cols = NULL, bycol = FALSE,
            type = "moore")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stress_+3A_x">x</code></td>
<td>
<p>a matrix object.</p>
</td></tr>
<tr><td><code id="stress_+3A_rows">rows</code></td>
<td>
<p>a subscript vector indexing the rows.</p>
</td></tr>
<tr><td><code id="stress_+3A_cols">cols</code></td>
<td>
<p>a subscript vector indexing the columns.</p>
</td></tr>
<tr><td><code id="stress_+3A_bycol">bycol</code></td>
<td>
<p>logical for computation over the columns.</p>
</td></tr>
<tr><td><code id="stress_+3A_type">type</code></td>
<td>
<p>the type of neighborhood to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>stress</code> computes the sum of squared distances of each
matrix entry from its adjacent entries. The following types of neighborhoods
are available:
</p>

<dl>
<dt><code>moore</code>:</dt><dd><p>comprises the eight adjacent entries (five at the
margins and three at the corners).</p>
</dd>
<dt><code>neumann</code>:</dt><dd><p>comprises the four adjacent entries (three at the
margins and two at the corners).</p>
</dd>
</dl>

<p>Function <code>stress.dist</code> computes the auto-distance matrix for each pair
of rows (or columns) given one of the above stress measures. Note that the
result depends on the ordering of the unused dimension.
</p>
<p>As the computation can be reduced to summing the edge distances between any
two neighboring points, only half of the value of the proposed measures is
reported.
</p>
<p>Row and/or column indexes (or labels) can be supplied to test specific
orderings, as well as subsets of indexes (labels).
</p>
<p>Note that the matrix should be normalized so that the distance computation
is meaningful.
</p>


<h3>Value</h3>

<p><code>stress</code> returns a scalar real, i.e. half of the global stress measure.
</p>
<p><code>stress.dist</code> returns an object of class <code><a href="stats.html#topic+dist">dist</a></code>, i.e. a
lower triangular matrix in column format.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="proxy.html#topic+dist">dist</a></code> for general distance computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
x1 &lt;- matrix(sample(c(FALSE,TRUE),25,rep=TRUE),ncol=5)
stress(x1)
stress(x1, type="neumann")
##
x2 &lt;- cbind(rbind(matrix(1,4,4),matrix(0,4,4)), 
	    rbind(matrix(0,4,4),matrix(1,4,4)))
stress.dist(x2)
stress.dist(x2, bycol=TRUE)
stress.dist(x2, type="neumann")
</code></pre>

<hr>
<h2 id='summary.proximus'>Summarizing Proximus Objects</h2><span id='topic+summary.proximus'></span><span id='topic+print.summary.proximus'></span>

<h3>Description</h3>

<p><code>summary</code> method for an object of class <code>proximus</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proximus'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.proximus_+3A_object">object</code></td>
<td>
<p>an object of class <code>proximus</code>.</p>
</td></tr>
<tr><td><code id="summary.proximus_+3A_...">...</code></td>
<td>
<p>further (unused) arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.proximus</code> with the following elements:
</p>
<table>
<tr><td><code>nr</code></td>
<td>
<p>the number of rows of the approximated matrix.</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>the number of columns of the approximated matrix.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>the relative error of the total approximation.</p>
</td></tr>
<tr><td><code>fnorm</code></td>
<td>
<p>the Frobenius norm of the total approximation.</p>
</td></tr>
<tr><td><code>jsim</code></td>
<td>
<p>the Jaccard similarity of the total approximation.</p>
</td></tr>
<tr><td><code>valid</code></td>
<td>
<p>the number of patterns that satisfy the mining constraints.</p>
</td></tr>
<tr><td><code>pattern</code></td>
<td>
<p>a <code>data.frame</code> of pattern summaries:</p>
</td></tr>
<tr><td><code>pattern$Size</code></td>
<td>
<p>the absolute size of the presence set.</p>
</td></tr>
<tr><td><code>pattern$Length</code></td>
<td>
<p>the number of <code>TRUE</code> values of the dominant 
pattern.</p>
</td></tr>
<tr><td><code>pattern$Radius</code></td>
<td>
<p>the Hamming radius of the presence set.</p>
</td></tr>
<tr><td><code>pattern$Error</code></td>
<td>
<p>the relative error of the presence set.</p>
</td></tr>
<tr><td><code>pattern$Fnorm</code></td>
<td>
<p>the Frobenius norm of the presence set.</p>
</td></tr>
<tr><td><code>pattern$Jsim</code></td>
<td>
<p>the Jaccard similarity of the presence set.</p>
</td></tr>
<tr><td><code>pattern$Valid</code></td>
<td>
<p>a logical indicating if the constraints are satisfied.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The function may change in future releases</p>


<h3>Author(s)</h3>

<p>Christian Buchta</p>


<h3>See Also</h3>

<p><code><a href="#topic+proximus">proximus</a></code> for obtaining a result object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### see proximus
</code></pre>

<hr>
<h2 id='townships'>Bertin's Characteristics and Townships Data Set</h2><span id='topic+townships'></span>

<h3>Description</h3>

<p>This data set was used to illustrate that the conciseness of presentation
can be improved by reordering the rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(townships)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 10 variables.
</p>

<dl>
<dt><code>Township</code></dt><dd><p>a factor with levels <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> <code>K</code> <code>L</code> <code>M</code> <code>N</code> <code>O</code> <code>P</code></p>
</dd>
<dt><code>High.School</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>Agricultural.Coop.</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>Railway.Station</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>One.Room.School</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>Veterinary</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>No.Doctor</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>No.Water.Supply</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>Police.Station</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>Land.Reallocation</code></dt><dd><p>a logical vector</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>townships</code> is a data set with 16 <code>logical</code> variables
indicating the presence (<code>TRUE</code>) or absence (<code>FALSE</code>)
of characteristics of townships.
</p>


<h3>References</h3>

<p>Bertin, J. (1981) <em>Graphics and Graphic Information Processing</em>.
Berlin, Walter de Gruyter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see order.data.frame
</code></pre>

<hr>
<h2 id='Votes'>Congressional Votes 1984 Data Set</h2><span id='topic+Votes'></span>

<h3>Description</h3>

<p>This data set includes votes for each of the U.S. House of
Representatives Congressmen on the 16 key votes identified by the
CQA.  The CQA lists nine different types of votes: voted for, paired
for, and announced for (these three simplified to yea), voted
against, paired against, and announced against (these three
simplified to nay), voted present, voted present to avoid conflict
of interest, and did not vote or otherwise make a position known
(these three simplified to an unknown disposition).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Votes)</code></pre>


<h3>Format</h3>

<p>A data frame with 435 observations on the following 17 variables.
</p>

<dl>
<dt><code>handicapped-infants</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>water-project-cost-sharing</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>adoption-of-the-budget-resolution</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>physician-fee-freeze</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>el-salvador-aid</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>religious-groups-in-schools</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>anti-satellite-test-ban</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>aid-to-nicaraguan-contras</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>mx-missile</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>immigration</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>synfuels-corporation-cutback</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>education-spending</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>superfund-right-to-sue</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>crime</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>duty-free-exports</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>export-administration-act-south-africa</code></dt><dd><p>a factor with levels <code>n</code> and <code>y</code></p>
</dd>
<dt><code>Class</code></dt><dd><p>a factor with levels <code>democrat</code> and <code>republican</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The records are drawn from:
</p>
<p><em>Congressional Quarterly Almanac</em>, 98th Congress, 
2nd session 1984, Volume XL: Congressional Quarterly Inc. 
Washington, D.C., 1985.
</p>
<p>It is important to recognize that <code>NA</code> in this database does 
not mean that the value of the attribute is unknown.  It 
means simply, that the value is not &quot;yea&quot; or &quot;nay&quot; (see above).
</p>


<h3>Source</h3>

<p><a href="http://www.ics.uci.edu/~mlearn/MLRepository.html">http://www.ics.uci.edu/~mlearn/MLRepository.html</a>
</p>


<h3>References</h3>

<p>Blake, C.L. &amp; Merz, C.J. (1998).
UCI Repository of Machine Learning Databases.
Irvine, CA: University of California, Department of Information and
Computer Science.	  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Votes)
summary(Votes)
## maybe str(Votes) ; plot(Votes) ...
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
