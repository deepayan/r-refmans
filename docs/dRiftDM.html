<!DOCTYPE html><html lang="en"><head><title>Help for package dRiftDM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dRiftDM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dRiftDM-package'><p>dRiftDM: Estimating (Time-Dependent) Drift Diffusion Models</p></a></li>
<li><a href='#add_residual'><p>Convolute the First Passage Times with the Non-Decision Time Distribution</p></a></li>
<li><a href='#aggregate_stats'><p>Aggregate Statistics ACROSS ID</p></a></li>
<li><a href='#b_coding+26lt+3B-'><p>The Coding of the Boundaries</p></a></li>
<li><a href='#b_constant'><p>Constant Boundary</p></a></li>
<li><a href='#b_hyperbol'><p>Collapsing Boundary - Hyperbolic Ratio Function</p></a></li>
<li><a href='#b_weibull'><p>Collapsing Boundary - Weibull Function</p></a></li>
<li><a href='#calc_cafs'><p>Calculate CAFs</p></a></li>
<li><a href='#calc_cafs_obs'><p>Calculate CAFs</p></a></li>
<li><a href='#calc_delta_funs'><p>Calculate delta function(s)</p></a></li>
<li><a href='#calc_ic'><p>Calculate Information Criteria (AIC and BIC)</p></a></li>
<li><a href='#calc_log_like'><p>Calculate the Log-Likelihood</p></a></li>
<li><a href='#calc_pdfs'><p>Calculate the PDFs</p></a></li>
<li><a href='#calc_quantiles'><p>Calculate Quantiles</p></a></li>
<li><a href='#calc_quantiles_obs'><p>Calculate Quantiles</p></a></li>
<li><a href='#calc_stats'><p>Calculate Statistics</p></a></li>
<li><a href='#calc_stats_pred_obs'><p>Calculate Statistics for Model Prediction and/or Observed Data</p></a></li>
<li><a href='#check_b_coding'><p>Check a B_Coding</p></a></li>
<li><a href='#check_digit_larger_0'><p>Checks if a variable/vector of length 1 is a number &gt; 0 or 0/expression</p></a></li>
<li><a href='#check_if_named_numeric_vector'><p>Check if Object is a Named Numeric Vector</p></a></li>
<li><a href='#check_internal_list'><p>checks if all entries of internal_list are an expression or integer.</p>
Throws an error if not (internal docu)</a></li>
<li><a href='#check_raw_data'><p>Check the Observed Data</p></a></li>
<li><a href='#check_unique_special_boundary'><p>Check for Unique Special Boundary Values</p></a></li>
<li><a href='#coef+26lt+3B-'><p>Access Coefficients of a Model</p></a></li>
<li><a href='#comp_funs+26lt+3B-'><p>The Component Functions of A Model</p></a></li>
<li><a href='#comp_vals'><p>Evaluate all Component Functions</p></a></li>
<li><a href='#component_shelf'><p>Diffusion Model Components</p></a></li>
<li><a href='#conds+26lt+3B-'><p>The Conditions of an Object</p></a></li>
<li><a href='#copy_class_attributes'><p>Copy Class Attributes from One Object to Another</p></a></li>
<li><a href='#count_unique_prms_one_internal_entry'><p>Count the number of digits &gt; 0</p></a></li>
<li><a href='#create_matrix_l_u'><p>Create a matrix for lower and upper</p></a></li>
<li><a href='#ddm_opts+26lt+3B-'><p>Optional Arguments for the Component Functions</p></a></li>
<li><a href='#defaults'><p>Default Values for the dRiftDM Package</p></a></li>
<li><a href='#dmc_dm'><p>Create the Diffusion Model for Conflict Tasks</p></a></li>
<li><a href='#dmc_synth_data'><p>A synthetic data set with two conditions</p></a></li>
<li><a href='#draw_from_pdf'><p>Draw Samples Using Inverse Transform Sampling</p></a></li>
<li><a href='#drift_dm'><p>Create a drift_dm object</p></a></li>
<li><a href='#drop_levels_ID_column'><p>Maybe droplevels of ID column</p></a></li>
<li><a href='#dt_b_constant'><p>Derivative of a Constant Boundary</p></a></li>
<li><a href='#estimate_model'><p>Estimate the Parameters of a drift_dm Model</p></a></li>
<li><a href='#estimate_model_ids'><p>Fit Multiple Individuals and Save Results</p></a></li>
<li><a href='#flex_cust_prm'><p>Specify custom parameters</p></a></li>
<li><a href='#flex_fix_prms'><p>Exclude parameters from being modified (i.e., fix it; internal docu)</p></a></li>
<li><a href='#flex_prms+26lt+3B-'><p>Flex_Prms</p></a></li>
<li><a href='#flex_restrain_prms'><p>Set parameters as equal across conditions</p></a></li>
<li><a href='#flex_special_dependency'><p>Set special dependencies (internal docu)</p></a></li>
<li><a href='#flex_specific_value'><p>Set a specific value to the parameter matrix (internal docu)</p></a></li>
<li><a href='#flex_vary_prms'><p>Allow parameters to vary</p></a></li>
<li><a href='#get_default_functions'><p>Get default/fall back component functions</p></a></li>
<li><a href='#get_example_fits_ids'><p>Auxiliary Function to create a fits_ids object</p></a></li>
<li><a href='#get_lower_upper_smart'><p>Turn default/special upper and lower arguments to vectors</p></a></li>
<li><a href='#hist.coefs_dm'><p>Plot Parameter Distribution(s)</p></a></li>
<li><a href='#internal_aggregate'><p>Aggregate Data Frame Columns by Group</p></a></li>
<li><a href='#internal_list_to_matrix'><p>Turn an internal list to a matrix</p></a></li>
<li><a href='#is_empty'><p>Check if an object of length &lt;= 1 is either empty or contains entry with &quot;&quot;</p></a></li>
<li><a href='#is_numeric'><p>Check if an object is a valid numeric vector</p></a></li>
<li><a href='#linearize_internal_list'><p>Relabel the internal list</p></a></li>
<li><a href='#load_fits_ids'><p>Load Estimates of a Fit Procedure</p></a></li>
<li><a href='#logLik.drift_dm'><p>Extract Log-Likelihood for a drift_dm Object</p></a></li>
<li><a href='#logLik.fits_ids_dm'><p>Extract Model Statistics for fits_ids_dm Object</p></a></li>
<li><a href='#max_number_one_internal_entry'><p>Get the maximum number from an internal entry or flex_prms_obj</p>
(internal docu)</a></li>
<li><a href='#modify_flex_prms'><p>Set Instructions to a flex_prms object</p></a></li>
<li><a href='#mu_constant'><p>Constant Drift Rate</p></a></li>
<li><a href='#mu_dmc'><p>Drift Rate for DMC</p></a></li>
<li><a href='#mu_int_constant'><p>Integral of Constant Drift Rate</p></a></li>
<li><a href='#mu_int_dmc'><p>Integral of DMC's Drift Rate</p></a></li>
<li><a href='#mu_ssp'><p>Drift Rate for SSP</p></a></li>
<li><a href='#new_drift_dm'><p>Create A DDM model - Internal</p></a></li>
<li><a href='#new_stats_dm'><p>Create a New stats_dm Object</p></a></li>
<li><a href='#nobs.drift_dm'><p>Get the Number of Observations for a drift_dm Object</p></a></li>
<li><a href='#nt_constant'><p>Constant Non-Decision time</p></a></li>
<li><a href='#nt_truncated_normal'><p>Truncated Normally-Distributed Non-Decision Time</p></a></li>
<li><a href='#nt_uniform'><p>Uniform Non-Decision Time</p></a></li>
<li><a href='#obs_data_to_rt_lists'><p>Disassemble an Observed Data set</p></a></li>
<li><a href='#obs_data+26lt+3B-'><p>The Observed Data</p></a></li>
<li><a href='#pdfs'><p>Access the Probability Density Functions of a Model</p></a></li>
<li><a href='#plot.cafs'><p>Plot Conditional Accuracy Functions (CAFs)</p></a></li>
<li><a href='#plot.delta_funs'><p>Plot Delta Functions</p></a></li>
<li><a href='#plot.drift_dm'><p>Plot Components of a Drift Diffusion Model</p></a></li>
<li><a href='#plot.quantiles'><p>Plot Quantiles</p></a></li>
<li><a href='#plot.stats_dm_list'><p>Plot Multiple Statistics</p></a></li>
<li><a href='#plot.traces_dm_list'><p>Plot Traces of a Drift Diffusion Model</p></a></li>
<li><a href='#print.cafs'><p>Print Functions for Stats Objects</p></a></li>
<li><a href='#print.summary.fits_ids_dm'><p>Summary and Printing for fits_ids_dm Objects</p></a></li>
<li><a href='#prm_cond_combo_2_labels'><p>Generate Parameter-Condition Labels</p></a></li>
<li><a href='#prms_cond_combo'><p>Unique Conditions-Parameter Combinations</p></a></li>
<li><a href='#prms_conds_to_modify'><p>Extract the conditions and parameters from an instruction string</p></a></li>
<li><a href='#prms_solve+26lt+3B-'><p>The Parameters for Deriving Model Predictions</p></a></li>
<li><a href='#prms_to_str'><p>Format Parameters as String</p></a></li>
<li><a href='#ratcliff_dm'><p>Create a Basic Diffusion Model</p></a></li>
<li><a href='#ratcliff_synth_data'><p>A synthetic data set with one condition</p></a></li>
<li><a href='#re_evaluate_model'><p>Re-evaluate the model</p></a></li>
<li><a href='#set_default_colors'><p>Set Default Colors</p></a></li>
<li><a href='#set_one_solver_setting'><p>Set one specific aspect of the solver settings</p></a></li>
<li><a href='#set_plot_limits'><p>Set Plot Limits</p></a></li>
<li><a href='#simulate_data'><p>Simulate Synthetic Responses</p></a></li>
<li><a href='#simulate_one_data_set'><p>Simulate one data set</p></a></li>
<li><a href='#simulate_traces'><p>Simulate Trajectories/Traces of a Model</p></a></li>
<li><a href='#simulate_traces_one_cond'><p>Simulate Traces for One Conditions</p></a></li>
<li><a href='#simulate_values'><p>Simulate Values</p></a></li>
<li><a href='#solver+26lt+3B-'><p>The Solver for Deriving Model Predictions</p></a></li>
<li><a href='#sort_one_internal_entry'><p>Sorts the numbers in ascending order</p></a></li>
<li><a href='#ssp_dm'><p>Create the Shrinking Spotlight Model</p></a></li>
<li><a href='#summarize_drift_dm_info'><p>Reads Info file</p></a></li>
<li><a href='#summary.coefs_dm'><p>Summary for <code>coefs_dm</code> Objects</p></a></li>
<li><a href='#summary.drift_dm'><p>Summary for <code>drift_dm</code> Objects</p></a></li>
<li><a href='#summary.flex_prms'><p>Summarizing Flex Parameters</p></a></li>
<li><a href='#summary.stats_dm'><p>Summary for <code>stats_dm</code> Objects</p></a></li>
<li><a href='#summary.traces_dm'><p>Summary for traces_dm and traces_dm_list Objects</p></a></li>
<li><a href='#try_cast_integer'><p>Convert Character Digits to Numeric Digits</p></a></li>
<li><a href='#ulrich_flanker_data'><p>Exemplary Flanker Data</p></a></li>
<li><a href='#ulrich_simon_data'><p>Exemplary Simon Data</p></a></li>
<li><a href='#unpack_obj'><p>Unpack/Destroy dRiftDM Objects</p></a></li>
<li><a href='#unpack_traces'><p>Unpack/Destroy Traces Objects</p></a></li>
<li><a href='#update_special_values'><p>Update all prms</p></a></li>
<li><a href='#validate_drift_dm'><p>Validate a DDM object</p></a></li>
<li><a href='#validate_fits_ids'><p>Validate a an Object of Type fits_ids_dm</p></a></li>
<li><a href='#validate_flex_prms'><p>checks if a flex_prms_object is parameterized in a reasonable way</p></a></li>
<li><a href='#validate_stats_dm'><p>Validate a stats_dm Object</p></a></li>
<li><a href='#x_beta'><p>Beta-Shaped Starting Point Distribution Centered Around Zero</p></a></li>
<li><a href='#x_dirac_0'><p>Constant Starting Point at Zero</p></a></li>
<li><a href='#x_uniform'><p>Uniform Starting Point Distribution Centered Around Zero</p></a></li>
<li><a href='#x2prms_vals'><p>Update the parameter matrix for vector inputs (internal docu)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating (Time-Dependent) Drift Diffusion Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and explore Drift Diffusion Models (DDMs),
    a common tool in psychology for describing decision processes in simple
    tasks. It can handle both time-independent and time-dependent DDMs. You
    either choose prebuilt models or create your own, and the package takes
    care of model predictions and parameter estimation. Model predictions
    are derived via the numerical solutions provided by Richter, Ulrich, and
    Janczyk (2023, &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2023.102756">doi:10.1016/j.jmp.2023.102756</a>&gt;).</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), cowsay, knitr, rmarkdown, DMCfun,
truncnorm, vdiffr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>withr, parallel, DEoptim, dfoptim, Rcpp, Rdpack, progress,
stats, lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bucky2177/dRiftDM">https://github.com/bucky2177/dRiftDM</a>,
<a href="https://bucky2177.github.io/dRiftDM/">https://bucky2177.github.io/dRiftDM/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bucky2177/dRiftDM/issues">https://github.com/bucky2177/dRiftDM/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-04 09:44:52 UTC; vkoob</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Koob [cre, aut, cph],
  Thomas Richter [aut, cph],
  Markus Janczyk [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Koob &lt;v.koob@web.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-04 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dRiftDM-package'>dRiftDM: Estimating (Time-Dependent) Drift Diffusion Models</h2><span id='topic+dRiftDM'></span><span id='topic+dRiftDM-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Fit and explore Drift Diffusion Models (DDMs), a common tool in psychology for describing decision processes in simple tasks. It can handle both time-independent and time-dependent DDMs. You either choose prebuilt models or create your own, and the package takes care of model predictions and parameter estimation. Model predictions are derived via the numerical solutions provided by Richter, Ulrich, and Janczyk (2023, <a href="https://doi.org/10.1016/j.jmp.2023.102756">doi:10.1016/j.jmp.2023.102756</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Valentin Koob <a href="mailto:v.koob@web.de">v.koob@web.de</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Thomas Richter [copyright holder]
</p>
</li>
<li><p> Markus Janczyk
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bucky2177/dRiftDM">https://github.com/bucky2177/dRiftDM</a>
</p>
</li>
<li> <p><a href="https://bucky2177.github.io/dRiftDM/">https://bucky2177.github.io/dRiftDM/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bucky2177/dRiftDM/issues">https://github.com/bucky2177/dRiftDM/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_residual'>Convolute the First Passage Times with the Non-Decision Time Distribution</h2><span id='topic+add_residual'></span>

<h3>Description</h3>

<p>Calls <a href="stats.html#topic+convolve">stats::convolve</a> for the first passage times and the non-decision
time distribution to derive the full distribution of response times. Before
convolution, I add the robustness parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_residual(pdf_nt, pdf_u, pdf_l, dt, nt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_residual_+3A_pdf_nt">pdf_nt</code></td>
<td>
<p>the non-decision time density values</p>
</td></tr>
<tr><td><code id="add_residual_+3A_pdf_u">pdf_u</code>, <code id="add_residual_+3A_pdf_l">pdf_l</code></td>
<td>
<p>the first passage times</p>
</td></tr>
<tr><td><code id="add_residual_+3A_dt">dt</code>, <code id="add_residual_+3A_nt">nt</code></td>
<td>
<p>step size and number of steps for the time space (for input
checks and scaling)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of PDFs for one condition &quot;pdf_u&quot; and &quot;pdf_l&quot;
</p>

<hr>
<h2 id='aggregate_stats'>Aggregate Statistics ACROSS ID</h2><span id='topic+aggregate_stats'></span><span id='topic+aggregate_stats.cafs'></span><span id='topic+aggregate_stats.quantiles'></span><span id='topic+aggregate_stats.delta_funs'></span><span id='topic+aggregate_stats.fit_stats'></span>

<h3>Description</h3>

<p><code>aggregate_stats</code> is a (not exported) generic function to aggregate
<code>stats_dm</code> objects across <code>ID</code>s. Since the column names may vary by the
statistic type, the behavior of aggregate depends on the subclass of
<code>stats_dm</code> (<code>cafs</code>, <code>quantiles</code>, <code>delta_funs</code>, or <code>fit_stats</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_stats(stat_df)

## S3 method for class 'cafs'
aggregate_stats(stat_df)

## S3 method for class 'quantiles'
aggregate_stats(stat_df)

## S3 method for class 'delta_funs'
aggregate_stats(stat_df)

## S3 method for class 'fit_stats'
aggregate_stats(stat_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_stats_+3A_stat_df">stat_df</code></td>
<td>
<p>A <code>data.frame</code> of class <code>stats_dm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each supported subclass, <code>aggregate_stats</code> calls
<code><a href="#topic+internal_aggregate">internal_aggregate()</a></code> with the relevant arguments
</p>


<h3>Value</h3>

<p>If no <code>"ID"</code> column exists in <code>stat_df</code> returns <code>stat_df</code> as-is.
If an <code>"ID"</code> column exists, then statistics are aggregated across it.
</p>


<h3>See Also</h3>

<p><a href="#topic+new_stats_dm">new_stats_dm</a>, <a href="#topic+calc_stats">calc_stats</a>,
<code><a href="#topic+internal_aggregate">internal_aggregate()</a></code>
</p>

<hr>
<h2 id='b_coding+26lt+3B-'>The Coding of the Boundaries</h2><span id='topic+b_coding+3C-'></span><span id='topic+b_coding+3C-.drift_dm'></span><span id='topic+b_coding'></span><span id='topic+b_coding.drift_dm'></span><span id='topic+b_coding.fits_ids_dm'></span>

<h3>Description</h3>

<p>Functions to get or set the &quot;boundary coding&quot; of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_coding(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
b_coding(object, ...) &lt;- value

b_coding(object, ...)

## S3 method for class 'drift_dm'
b_coding(object, ...)

## S3 method for class 'fits_ids_dm'
b_coding(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_coding+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code>
(see <a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="b_coding+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="b_coding+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a named list, specifying how boundaries are coded (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>b_coding()</code> is a generic accessor function, and <code style="white-space: pre;">&#8288;b_coding&lt;-()&#8288;</code> a
generic replacement function. The default methods get and set the &quot;boundary
coding&quot;, which is an attribute of <a href="#topic+drift_dm">drift_dm</a> model.
</p>
<p>The boundary coding summarizes which response time belongs to which boundary
and how the boundaries shall be &quot;labeled&quot;. The list specifies three entries:
</p>

<ul>
<li> <p><code>column</code>, contains a single character string, indicating which column
in an observed data set codes the boundaries.
</p>
</li>
<li> <p><code>u_name_value</code>, contains a numeric or character vector of length 1. The
name of this vector gives a label for the upper boundary, and the entry
gives the value stored in <code>obs_data[[column]]</code> coding the upper boundary.
</p>
</li>
<li> <p><code>l_name_value</code>, contains a numeric or character vector of length 1. The
name of this vector gives a label for the lower boundary, and the entry
gives the value stored in <code>obs_data[[column]]</code> coding the lower boundary.
</p>
</li></ul>

<p>The package <code>dRiftDM</code> has a default boundary coding:
</p>

<ul>
<li> <p><code>column</code> = &quot;Error&quot;
</p>
</li>
<li> <p><code>u_name_value</code> = c(&quot;corr&quot; = 0)
</p>
</li>
<li> <p><code>l_name_value</code> = c(&quot;err&quot; = 1)
</p>
</li></ul>

<p>Thus, per default, dRiftDM assumes that any observed data set has a column
&quot;Error&quot;, providing the values 0 and 1 for the upper and lower boundary,
respectively. The upper and lower boundaries are labeled &quot;corr&quot; and &quot;err&quot;,
respectively. These labels are used, for example, when calculating
statistics (see <a href="#topic+calc_stats">calc_stats</a>).
</p>
<p>When calling <code style="white-space: pre;">&#8288;b_coding&lt;-()&#8288;</code> with <code>value = NULL</code>, the default &quot;accuracy&quot;
coding is evoked
</p>


<h3>Value</h3>

<p>For <code>b_coding()</code> a list containing the boundary coding
For <code style="white-space: pre;">&#8288;b_coding&lt;-()&#8288;</code> the updated <code>drift_dm</code> or <code>fits_ids_dm</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show the default accuracy coding of dRiftDM
my_model &lt;- ratcliff_dm() # get a pre-built model
b_coding(my_model)

# can be modified/replaced
b_coding(my_model)[["column"]] &lt;- "Response"

# accessor method also available for fits_ids_dm objects
# get an exemplary fits_ids_dm object (see estimate_model_ids)
fits &lt;- get_example_fits_ids()
names(b_coding(fits))

</code></pre>

<hr>
<h2 id='b_constant'>Constant Boundary</h2><span id='topic+b_constant'></span>

<h3>Description</h3>

<p>Constant Boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_constant(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_constant_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing b</p>
</td></tr>
<tr><td><code id="b_constant_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="b_constant_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="b_constant_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="b_constant_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as t_vec with the b value for
each element of the vector.
</p>

<hr>
<h2 id='b_hyperbol'>Collapsing Boundary - Hyperbolic Ratio Function</h2><span id='topic+b_hyperbol'></span><span id='topic+dt_b_hyperbol'></span>

<h3>Description</h3>

<p>Provides the boundary, collapsing as a hyperbolic ratio function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_hyperbol(prms_model, prms_solve, t_vec, one_cond, ddm_opts)

dt_b_hyperbol(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_hyperbol_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing b0, kappa, t05</p>
</td></tr>
<tr><td><code id="b_hyperbol_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="b_hyperbol_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="b_hyperbol_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="b_hyperbol_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>b_hyperbol</code> and <code>dt_b_hyperbol</code> provide the plain boundary values and the
respective derivative, respectively.
</p>


<h3>Value</h3>

<p>a vector of the same length as t_vec with the boundary values (or
the deriviative) for each element of the vector.
</p>

<hr>
<h2 id='b_weibull'>Collapsing Boundary - Weibull Function</h2><span id='topic+b_weibull'></span><span id='topic+dt_b_weibull'></span>

<h3>Description</h3>

<p>Provides the boundary, collapsing in accordance with a Weibull function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_weibull(prms_model, prms_solve, t_vec, one_cond, ddm_opts)

dt_b_weibull(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_weibull_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing b0, lambda, k, kappa</p>
</td></tr>
<tr><td><code id="b_weibull_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="b_weibull_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="b_weibull_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="b_weibull_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>b_weibull</code> and <code>dt_b_weibull</code> provide the plain boundary values and the
respective derivative, respectively.
</p>


<h3>Value</h3>

<p>a vector of the same length as t_vec with the boundary values (or
the deriviative) for each element of the vector.
</p>

<hr>
<h2 id='calc_cafs'>Calculate CAFs</h2><span id='topic+calc_cafs'></span>

<h3>Description</h3>

<p>Function that calls the underlying CAF calculation functions
<a href="#topic+calc_cafs_obs">calc_cafs_obs</a> and <a href="#topic+calc_cafs_pred">calc_cafs_pred</a>. Does input checks
and the data wrangling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_cafs(
  pdf_u = NULL,
  pdf_l = NULL,
  rts_u = NULL,
  rts_l = NULL,
  one_cond,
  n_bins = NULL,
  b_coding
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_cafs_+3A_pdf_u">pdf_u</code>, <code id="calc_cafs_+3A_pdf_l">pdf_l</code></td>
<td>
<p>either NULL or density vectors</p>
</td></tr>
<tr><td><code id="calc_cafs_+3A_rts_u">rts_u</code>, <code id="calc_cafs_+3A_rts_l">rts_l</code></td>
<td>
<p>either NULL or RT vectors</p>
</td></tr>
<tr><td><code id="calc_cafs_+3A_one_cond">one_cond</code></td>
<td>
<p>a label for the data.frame</p>
</td></tr>
<tr><td><code id="calc_cafs_+3A_n_bins">n_bins</code></td>
<td>
<p>the number of bins, default is 5</p>
</td></tr>
<tr><td><code id="calc_cafs_+3A_b_coding">b_coding</code></td>
<td>
<p>used for accessing the upper boundary label, determines
the corresponding column of the returned data.frame (e.g., P_<code>corr</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if pdf_u and pdf_l are not NULL, returns CAFs of the densities
</p>
<p>if rts_u and rts_l are not NULL, returns CAFs of the response times
</p>
<p>if all are not NULL, returns both.
</p>


<h3>Value</h3>

<p>a data.frame with &quot;Source&quot;, &quot;Cond&quot;, &quot;Bin&quot;s, &quot;P_&lt;u_label&gt;&quot; for
the CAFs of type c(&quot;cafs&quot;, &quot;sum_dist&quot;, &quot;stats_dm&quot;, &quot;data.frame&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_stats_dm">new_stats_dm()</a></code>
</p>

<hr>
<h2 id='calc_cafs_obs'>Calculate CAFs</h2><span id='topic+calc_cafs_obs'></span><span id='topic+calc_cafs_pred'></span>

<h3>Description</h3>

<p>Backend functions to calculate conditional accuracy functions for RT
vectors or pdfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_cafs_obs(rts_u, rts_l, one_cond, n_bins)

calc_cafs_pred(pdf_u, pdf_l, one_cond, n_bins)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_cafs_obs_+3A_rts_u">rts_u</code>, <code id="calc_cafs_obs_+3A_rts_l">rts_l</code></td>
<td>
<p>vectors of RTs for the upper and lower boundary</p>
</td></tr>
<tr><td><code id="calc_cafs_obs_+3A_one_cond">one_cond</code></td>
<td>
<p>character label</p>
</td></tr>
<tr><td><code id="calc_cafs_obs_+3A_n_bins">n_bins</code></td>
<td>
<p>number of bins to use for the CAFs</p>
</td></tr>
<tr><td><code id="calc_cafs_obs_+3A_pdf_u">pdf_u</code>, <code id="calc_cafs_obs_+3A_pdf_l">pdf_l</code></td>
<td>
<p>density values for the upper and lower boundary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for RTs:
first elements are attributed to a bin (with bins calculated across all RTs
using equally spaced quantiles),
then accuracy per bin is calculated.
</p>
<p>for Densities: Add density values, calculate a CDF and force it between 0 and
</p>

<ol>
<li><p> Then determine the indices that cut the CDF into bins by considering
equally spaced quantiles. Then calculate the ratio of probability mass per
bin.
</p>
</li></ol>



<h3>Value</h3>

<p>a data.frame with the &quot;Cond&quot; label, the &quot;Bin&quot;s and &quot;P_U&quot; for
the CAFs
</p>

<hr>
<h2 id='calc_delta_funs'>Calculate delta function(s)</h2><span id='topic+calc_delta_funs'></span>

<h3>Description</h3>

<p>Given a dataset providing the quantiles (<a href="#topic+calc_quantiles">calc_quantiles</a>),
calculates delta function(s) for the character vectors minuends and
subtrahends
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_delta_funs(
  quantiles_dat,
  minuends = NULL,
  subtrahends = NULL,
  dvs = NULL,
  b_coding
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_delta_funs_+3A_quantiles_dat">quantiles_dat</code></td>
<td>
<p>a data.frame of quantiles (<a href="#topic+calc_quantiles">calc_quantiles</a>)</p>
</td></tr>
<tr><td><code id="calc_delta_funs_+3A_minuends">minuends</code>, <code id="calc_delta_funs_+3A_subtrahends">subtrahends</code></td>
<td>
<p>character vectors (with equal length), specifying
the conditions to use for the delta function: minuend - subtrahend</p>
</td></tr>
<tr><td><code id="calc_delta_funs_+3A_dvs">dvs</code></td>
<td>
<p>character, indicating which quantile columns to use. Default
is &quot;Quant_&lt;u_label&gt;&quot;. If multiple dvs are provided, then minuends and
subtrahends must have the same length, and matching occurs pairwise. In this
case, if only one minuend/subtrahend is specified, minuend and subtrahend are
recycled to the necessary length.</p>
</td></tr>
<tr><td><code id="calc_delta_funs_+3A_b_coding">b_coding</code></td>
<td>
<p>a <a href="#topic+b_coding">b_coding</a> object, necessary to build default
dvs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the quantile data_frame, <a href="stats.html#topic+reshape">stats::reshape</a> it to wide, and then
access the relevant <code>dv</code> columns, together with minuends and subtrahends
to calculate the delta functions.
</p>


<h3>Value</h3>

<p>a data.frame with columns &quot;Source&quot;, &quot;Prob&quot;, the &quot;Quant_&lt;u_label&gt;&quot;,
&quot;Quant_&lt;l_label&quot;. May have the following additional columns:
</p>

<ul>
<li><p> if only one dv: as many Delta_&lt;minuend_subtrahend&gt; and
Avg_&lt;minuends_subtrahends&gt; as minuends and subtrahends.
</p>
</li>
<li><p> if more than one dv: as many Delta_&lt;u/l-label&gt;<em>&lt;minuend_subtrahend&gt; and
Avg</em>&lt;u/l-label&gt;_&lt;minuends_subtrahends&gt; as minuends and subtrahends.
</p>
</li></ul>

<p>The data.frame is of type
c(&quot;delta_funs&quot;, &quot;sum_dist&quot;, &quot;stats_dm&quot;, &quot;data.frame&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_stats_dm">new_stats_dm()</a></code>
</p>

<hr>
<h2 id='calc_ic'>Calculate Information Criteria (AIC and BIC)</h2><span id='topic+calc_ic'></span>

<h3>Description</h3>

<p>Computes/Summarizes the Log-Likelihood, Akaike Information Criterion (AIC),
and the Bayesian Information Criterion (BIC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ic(drift_dm_obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_ic_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="calc_ic_+3A_...">...</code></td>
<td>
<p>further arguments (only relevant: k, for the penality of
<a href="stats.html#topic+AIC">stats::AIC</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions calls <a href="#topic+logLik.drift_dm">logLik.drift_dm</a>, and subsequently
<a href="stats.html#topic+AIC">stats::AIC</a> and <a href="stats.html#topic+AIC">stats::BIC</a>
</p>


<h3>Value</h3>

<p>A custom object of class <code>stats_dm</code>
(c(&quot;fit_stats&quot;, &quot;stats_dm&quot;, &quot;data.frame&quot;)), containing a data frame with
columns:
</p>

<ul>
<li> <p><code>Log_Like</code>: the input log-likelihood value
</p>
</li>
<li> <p><code>AIC</code>: the calculated AIC value
</p>
</li>
<li> <p><code>BIC</code>: the calculated BIC value
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+new_stats_dm">new_stats_dm()</a></code>, <a href="#topic+logLik.drift_dm">logLik.drift_dm</a>
</p>

<hr>
<h2 id='calc_log_like'>Calculate the Log-Likelihood</h2><span id='topic+calc_log_like'></span><span id='topic+log_like_heart'></span>

<h3>Description</h3>

<p>Wrapper function around <code>log_like_heart</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_log_like(pdfs, t_vec, obs_data, conds)

log_like_heart(pdf_u, pdf_l, t_vec, rts_u, rts_l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_log_like_+3A_pdfs">pdfs</code></td>
<td>
<p>a list of pdfs (see details)</p>
</td></tr>
<tr><td><code id="calc_log_like_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="calc_log_like_+3A_obs_data">obs_data</code></td>
<td>
<p>a list of obs_data</p>
</td></tr>
<tr><td><code id="calc_log_like_+3A_conds">conds</code></td>
<td>
<p>all conditions of a model</p>
</td></tr>
<tr><td><code id="calc_log_like_+3A_pdf_u">pdf_u</code>, <code id="calc_log_like_+3A_pdf_l">pdf_l</code></td>
<td>
<p>numeric vectors of the pdfs (unpacked)</p>
</td></tr>
<tr><td><code id="calc_log_like_+3A_rts_u">rts_u</code>, <code id="calc_log_like_+3A_rts_l">rts_l</code></td>
<td>
<p>numeric vectors of the observed RTs (unpacked)</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>calc_log_like</h4>

<p>Iterates over all conditions, and passes forward the (unpacked) arguments
to <code>log_like_heart</code>, adding each log-likelihood of a condition.
</p>
<p><code>pdfs</code> must be a list with entries named as the conditions, and then
each condition being a list of the two PDFs (named pdf_u and pdf_l)
</p>
<p><code>obs_data</code> must be a list with entries &quot;rts_u&quot; and &quot;rts_l&quot;, and then
each rts_* entry being a named list with the RT values for each condition
</p>



<h4>log_like_heart</h4>

<p>Gets the density values for RTs in rts_u/rts_l via <code><a href="stats.html#topic+approxfun">stats::approx()</a></code>,
takes the log of that, and then sums across both.
Wraps up the calculation in a tryCatch statement, throwing warnings when
log_like_values can not be calculated
</p>



<h3>Value</h3>

<p>a single value of the log-likelihood
</p>

<hr>
<h2 id='calc_pdfs'>Calculate the PDFs</h2><span id='topic+calc_pdfs'></span><span id='topic+calc_pdfs.ratcliff_dm'></span><span id='topic+calc_pdfs.drift_dm'></span>

<h3>Description</h3>

<p>This method takes the a model, the time and space vectors, and the
unpacked parameters for solving the PDF to derive the first passage
time across all conditions. It is a wrapper around the cpp implementations
and <a href="#topic+add_residual">add_residual</a>. Important: This function is used in the
depths of the package and the generic method is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_pdfs(drift_dm_obj, x_vec, t_vec, prms_solve)

## S3 method for class 'ratcliff_dm'
calc_pdfs(drift_dm_obj, x_vec, t_vec, prms_solve)

## S3 method for class 'drift_dm'
calc_pdfs(drift_dm_obj, x_vec, t_vec, prms_solve)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_pdfs_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>a model of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="calc_pdfs_+3A_x_vec">x_vec</code></td>
<td>
<p>numeric vector, the evidence space</p>
</td></tr>
<tr><td><code id="calc_pdfs_+3A_t_vec">t_vec</code></td>
<td>
<p>numeric vector, the time space</p>
</td></tr>
<tr><td><code id="calc_pdfs_+3A_prms_solve">prms_solve</code></td>
<td>
<p>the discretization (see <a href="#topic+prms_solve">prms_solve</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calc_pdfs is a generic method which dispatches the function call (not
exported).
</p>
<p>calc_pdfs.ratcliff_dm, is a specific method that checks for the presence of
the parameter <code>sd_muc</code>, and, if present, calls the calc_pdfs.drift_dm
function multiple times with different value for <code>muc</code> to approximate the
variable drift rate.
</p>
<p>calc_pdfs.drift_dm is the function that will be called for all models.
It evaluates the different components of a model, and subsequently calls
the cpp implementations for the KFE or integral method. It also calls the
<a href="#topic+add_residual">add_residual</a> function to convolute the non-decision time to the
first passage time.
</p>
<p>The numerical methods for deriving the PDFs are based on the code provided
by (Richter et al. 2023).
</p>


<h3>Value</h3>

<p>a list of PDFs, with named entries for each condition. Each of this
entry contains a list of vectors, named &quot;pdf_u&quot; and &quot;pdf_l&quot;
</p>


<h3>References</h3>

<p>Richter T, Ulrich R, Janczyk M (2023).
&ldquo;Diffusion models with time-dependent parameters: An analysis of computational effort and accuracy of different numerical methods.&rdquo;
<em>Journal of Mathematical Psychology</em>, <b>114</b>, 102756.
<a href="https://doi.org/10.1016/j.jmp.2023.102756">doi:10.1016/j.jmp.2023.102756</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+add_residual">add_residual</a>
</p>

<hr>
<h2 id='calc_quantiles'>Calculate Quantiles</h2><span id='topic+calc_quantiles'></span>

<h3>Description</h3>

<p>Function that calls the underlying quantile calculation functions
<a href="#topic+calc_quantiles_obs">calc_quantiles_obs</a> and <a href="#topic+calc_quantiles_pred">calc_quantiles_pred</a>. Does
input checks and the data wrangling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_quantiles(
  pdf_u = NULL,
  pdf_l = NULL,
  t_vec = NULL,
  rts_u = NULL,
  rts_l = NULL,
  one_cond,
  probs = NULL,
  b_coding
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_quantiles_+3A_pdf_u">pdf_u</code>, <code id="calc_quantiles_+3A_pdf_l">pdf_l</code></td>
<td>
<p>either NULL or density vectors</p>
</td></tr>
<tr><td><code id="calc_quantiles_+3A_t_vec">t_vec</code></td>
<td>
<p>the time space (required for the pdfs)</p>
</td></tr>
<tr><td><code id="calc_quantiles_+3A_rts_u">rts_u</code>, <code id="calc_quantiles_+3A_rts_l">rts_l</code></td>
<td>
<p>either NULL or RT vectors</p>
</td></tr>
<tr><td><code id="calc_quantiles_+3A_one_cond">one_cond</code></td>
<td>
<p>character label</p>
</td></tr>
<tr><td><code id="calc_quantiles_+3A_probs">probs</code></td>
<td>
<p>numeric vector with values between 0 and 1 for the probability
levels. Default is <code><a href="#topic+drift_dm_default_probs">drift_dm_default_probs()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_quantiles_+3A_b_coding">b_coding</code></td>
<td>
<p>used for accessing the upper/lower boundary labels,
determines the corresponding columns of the returned data.frame
(e.g., Quant_<code>corr</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if pdf_u and pdf_l are not NULL, returns quantiles for the densities
</p>
<p>if rts_u and rts_l are not NULL, returns quantiles for the response times
</p>
<p>if all are not NULL, returns both.
</p>


<h3>Value</h3>

<p>a data.frame with &quot;Source&quot;, &quot;Cond&quot;, &quot;Prob&quot;s, &quot;Quant_&lt;u_label&gt;&quot;,
&quot;Quant_&lt;l_label&gt;&quot; of type
c(&quot;quantiles&quot;, &quot;sum_dist&quot;, &quot;stats_dm&quot;, &quot;data.frame&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_stats_dm">new_stats_dm()</a></code>
</p>

<hr>
<h2 id='calc_quantiles_obs'>Calculate Quantiles</h2><span id='topic+calc_quantiles_obs'></span><span id='topic+calc_quantiles_pred'></span>

<h3>Description</h3>

<p>Backend functions to calculate quantiles for RT vectors or pdfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_quantiles_obs(rts_u, rts_l, one_cond, probs)

calc_quantiles_pred(
  pdf_u,
  pdf_l,
  t_vec,
  one_cond,
  probs,
  skip_if_contr_low = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_quantiles_obs_+3A_rts_u">rts_u</code>, <code id="calc_quantiles_obs_+3A_rts_l">rts_l</code></td>
<td>
<p>vectors of RTs for the upper and lower boundary</p>
</td></tr>
<tr><td><code id="calc_quantiles_obs_+3A_one_cond">one_cond</code></td>
<td>
<p>character label</p>
</td></tr>
<tr><td><code id="calc_quantiles_obs_+3A_probs">probs</code></td>
<td>
<p>numeric vector with values between 0 and 1 for the probability
levels</p>
</td></tr>
<tr><td><code id="calc_quantiles_obs_+3A_pdf_u">pdf_u</code>, <code id="calc_quantiles_obs_+3A_pdf_l">pdf_l</code></td>
<td>
<p>density values for the upper and lower boundary</p>
</td></tr>
<tr><td><code id="calc_quantiles_obs_+3A_t_vec">t_vec</code></td>
<td>
<p>the time space (required for the pdfs)</p>
</td></tr>
<tr><td><code id="calc_quantiles_obs_+3A_skip_if_contr_low">skip_if_contr_low</code></td>
<td>
<p>numeric. If the relative contribution of the upper
or lower PDF to the overall PDF is too low (default 0.01%), return NAs for
this PDF.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for RTs:
straightforward via <a href="stats.html#topic+quantile">stats::quantile</a>.
</p>
<p>for Densities: Calculate CDF (for each pdf separately here), and then map
the desired probability level via the CDF (y-axis) to the time space (x-axis)
</p>


<h3>Value</h3>

<p>a data.frame with the &quot;Cond&quot; label, the &quot;Prob&quot;s and &quot;Quant_U&quot; and
&quot;Quant_L&quot; for the quantiles
</p>

<hr>
<h2 id='calc_stats'>Calculate Statistics</h2><span id='topic+calc_stats'></span><span id='topic+calc_stats.data.frame'></span><span id='topic+calc_stats.drift_dm'></span><span id='topic+calc_stats.fits_ids_dm'></span><span id='topic+print.stats_dm'></span><span id='topic+print.stats_dm_list'></span>

<h3>Description</h3>

<p><code>calc_stats</code> provides an interface for calculating statistics/metrics on
model predictions and/or observed data. Supported statistics include
Conditional Accuracy Functions (CAFs), Quantiles, Delta Functions, and fit
statistics. Results can be aggregated across individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_stats(object, type, ...)

## S3 method for class 'data.frame'
calc_stats(
  object,
  type,
  ...,
  conds = NULL,
  verbose = 0,
  average = FALSE,
  split_by_ID = TRUE,
  b_coding = NULL
)

## S3 method for class 'drift_dm'
calc_stats(object, type, ..., conds = NULL)

## S3 method for class 'fits_ids_dm'
calc_stats(object, type, ..., verbose = 1, average = FALSE)

## S3 method for class 'stats_dm'
print(
  x,
  ...,
  round_digits = drift_dm_default_rounding(),
  print_rows = 10,
  some = FALSE,
  show_header = TRUE,
  show_note = TRUE
)

## S3 method for class 'stats_dm_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_stats_+3A_object">object</code></td>
<td>
<p>an object for which statistics are calculated. This can be a
<a href="base.html#topic+data.frame">data.frame</a> of observed data, a <a href="#topic+drift_dm">drift_dm</a> object, or a
<code>fits_ids_dm</code> object (see <a href="#topic+estimate_model_ids">estimate_model_ids</a>).</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_type">type</code></td>
<td>
<p>a character vector, specifying the statistics to calculate.
Supported values include <code>"cafs"</code>, <code>"quantiles"</code>, <code>"delta_funs"</code>, and
<code>"fit_stats"</code>.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the respective method and the
underlying calculation functions (see Details for mandatory arguments).</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_conds">conds</code></td>
<td>
<p>optional character vector specifying conditions to include.
Conditions must match those found in the <code>object</code>.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_verbose">verbose</code></td>
<td>
<p>integer, indicating if information about the progress
should be displayed. 0 -&gt; no information, 1 -&gt; a progress bar. Default is 0.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_average">average</code></td>
<td>
<p>logical. If <code>TRUE</code>, averages the statistics across individuals
where applicable. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_split_by_id">split_by_ID</code></td>
<td>
<p>logical. If <code>TRUE</code>, statistics are calculated separately
for each individual ID in <code>object</code> (when <code>object</code> is a <a href="base.html#topic+data.frame">data.frame</a>). Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_b_coding">b_coding</code></td>
<td>
<p>a list for boundary coding (see <a href="#topic+b_coding">b_coding</a>). Only
relevant when <code>object</code> is a <a href="base.html#topic+data.frame">data.frame</a>. For other <code>object</code> types, the
<code>b_coding</code> of the <code>Object</code> is used.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_x">x</code></td>
<td>
<p>an object of type <code>stats_dm</code> or <code>stats_dm_list</code>, as returned by
the function <code>calc_stats()</code>.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, controls the number of digits shown.
Default is 3.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_print_rows">print_rows</code></td>
<td>
<p>integer, controls the number of rows shown.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_some">some</code></td>
<td>
<p>logical. If <code>TRUE</code>, a subset of randomly sampled rows is shown.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_show_header">show_header</code></td>
<td>
<p>logical. If <code>TRUE</code>, a header specifying the type of
statistic will be displayed.</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_show_note">show_note</code></td>
<td>
<p>logical. If <code>TRUE</code>, a footnote  is displayed indicating
that the underlying <a href="base.html#topic+data.frame">data.frame</a> can be accessed as usual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_stats</code> is a generic function to handle the calculation of different
statistics/metrics for the supported object types. Per default, it returns
the requested statistics/metrics.
</p>


<h4>Conditional Accuracy Function (CAFs)</h4>

<p>CAFs are a way to quantify response accuracy against speed. To calculate
CAFs, RTs (whether correct or incorrect) are first binned and then the
percent correct responses per bin is calculated.
</p>
<p>When calculating model-based CAFs, a joint CDF combining both the pdf
of correct and incorrect responses is calculated. Afterwards, this CDF
is separated into even-spaced segments and the contribution of
the pdf associated with a correct response relative to the joint CDF is
calculated.
</p>
<p>The number of bins can be controlled by passing the argument <code>n_bins</code>.
The default is 5.
</p>



<h4>Quantiles</h4>

<p>For observed response times, the function <a href="stats.html#topic+quantile">stats::quantile</a> is used with
default settings.
</p>
<p>Which quantiles are calcuated can be controlled by providing the
probabilites, <code>probs</code>, with values in <code class="reqn">[0, 1]</code>. Default is
<code>seq(0.1, 0.9, 0.1)</code>.
</p>



<h4>Delta Functions</h4>

<p>Delta functions calculate the difference between quantiles
of two conditions against their mean:
</p>

<ul>
<li> <p><code class="reqn">Delta_i = Q_{i,j} - Q_{i,k}</code>
</p>
</li>
<li> <p><code class="reqn">Avg_i = 0.5 \cdot Q_{i,j} + 0.5 \cdot Q_{i,k}</code>
</p>
</li></ul>

<p>With i indicating a quantile, and j and k two conditions.
</p>
<p>To calculate delta functions, users have to specify:
</p>

<ul>
<li> <p><code>minuends</code>: character vector, specifying condition(s) j. Must be in
<code>conds(drift_dm_obj)</code>.
</p>
</li>
<li> <p><code>subtrahends</code>: character vector, specifying condition(s) k. Must be in
<code>conds(drift_dm_obj)</code>
</p>
</li>
<li> <p><code>dvs</code>: character, indicating which quantile columns to use.
Default is &quot;Quant_&lt;u_label&gt;&quot;. If multiple dvs are provided,
then minuends and subtrahends must have the same length,
and matching occurs pairwise. In this case, if only one
minuend/subtrahend is specified, minuend and subtrahend are recycled to
the necessary length.
</p>
</li></ul>




<h4>Fit Statistics</h4>

<p>Calculates the Akaike and Bayesian Information Criteria (AIC and BIC). Users
can provide a <code>k</code> argument to penalize the AIC statistic (see <a href="stats.html#topic+AIC">stats::AIC</a>
and <a href="#topic+AIC.fits_ids_dm">AIC.fits_ids_dm</a>)
</p>



<h3>Value</h3>

<p>If <code>type</code> is a single character string, then a subclass of <a href="base.html#topic+data.frame">data.frame</a> is
returned, containing the respective statistic. Objects of type <code>sum_dist</code>
will have an additional attribute storing the boundary encoding (see also
<a href="#topic+b_coding">b_coding</a>). The reason for returning subclasses of <a href="base.html#topic+data.frame">data.frame</a> is
to provide custom <code>plot()</code> methods (e.g., <a href="#topic+plot.cafs">plot.cafs</a>). To get rid
of the subclass label and additional attributes (i.e., to get just the plain
underlying <a href="base.html#topic+data.frame">data.frame</a>, users can use <code><a href="#topic+unpack_obj">unpack_obj()</a></code>).
</p>
<p>If <code>type</code> contains multiple character strings (i.e., is a character vector) a
subclass of <a href="base.html#topic+list">list</a> with the calculated statistics is returned. The list will
be of type <code>stats_dm_list</code> (to easily create multiple panels using the
respective <code><a href="#topic+plot.stats_dm_list">plot.stats_dm_list()</a></code> method).
</p>
<p>The print methods <code>print.stats_dm()</code> and <code>print.stats_dm_list()</code> each
invisibly return the supplied object <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Calculate CAFs and Quantiles from a model ---------------------
# get a model for demonstration purpose
a_model &lt;- ssp_dm(dx = .0025, dt = .0025, t_max = 2)
# and then calculate cafs and quantiles
some_stats &lt;- calc_stats(a_model, type = c("cafs", "quantiles"))
print(some_stats)

# Example 2: Calculate a Delta Function from a data.frame ------------------
# get a data set for demonstration purpose
some_data &lt;- ulrich_simon_data
conds(some_data) # relevant for minuends and subtrahends
some_stats &lt;- calc_stats(
  a_model,
  type = "delta_funs",
  minuends = "incomp",
  subtrahends = "comp"
)
print(some_stats, print_rows = 5)


# Example 3: Calculate Quantiles from a fits_ids_dm object -----------------
# get an auxiliary fits_ids_dm object
all_fits &lt;- get_example_fits_ids()
some_stats &lt;- calc_stats(all_fits, type = "quantiles")
print(some_stats, print_rows = 5) # note the ID column

# one can also request that the statistics are averaged across individuals
print(
  calc_stats(all_fits, type = "quantiles", average = TRUE)
)

</code></pre>

<hr>
<h2 id='calc_stats_pred_obs'>Calculate Statistics for Model Prediction and/or Observed Data</h2><span id='topic+calc_stats_pred_obs'></span>

<h3>Description</h3>

<p>This function derives statistics that can be calculated for both model
predictions and observed data. However, it does not calculate it, but
rather calls the respective backend functions.
Supported statistics currently include:
</p>

<ul>
<li><p> Conditional Accuracy Functions (CAFs; <code><a href="#topic+calc_cafs">calc_cafs()</a></code>)
</p>
</li>
<li><p> Quantiles (<code><a href="#topic+calc_quantiles">calc_quantiles()</a></code>)
</p>
</li>
<li><p> Delta Functions (<code><a href="#topic+calc_delta_funs">calc_delta_funs()</a></code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>calc_stats_pred_obs(type, b_coding, conds, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_stats_pred_obs_+3A_type">type</code></td>
<td>
<p>character string, specifying the type of statistic to calculate.
Available options are <code>"cafs"</code>, <code>"quantiles"</code>, and <code>"delta_funs"</code>.</p>
</td></tr>
<tr><td><code id="calc_stats_pred_obs_+3A_b_coding">b_coding</code></td>
<td>
<p>list for boundary coding (see <a href="#topic+b_coding">b_coding</a>).</p>
</td></tr>
<tr><td><code id="calc_stats_pred_obs_+3A_conds">conds</code></td>
<td>
<p>character vector, specifying the conditions to include in
calculations (used for labeling and subsetting the model PDFs and the
observed data).</p>
</td></tr>
<tr><td><code id="calc_stats_pred_obs_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the specific statistic
calculation function (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When calling this function the arguments <code>all_rts_u</code>/<code>all_rts_l</code> and/or
<code>all_pdfs</code> must be specified (see
<a href="#topic+re_evaluate_model">re_evaluate_model</a>, <a href="#topic+obs_data">obs_data</a>). Otherwise, the backend
functions won't work properly. Further arguments are:
</p>

<ul>
<li><p> for CAFS: <code>n_bins</code> controls the number of bins, with a default of 5.
</p>
</li>
<li><p> for Quantiles and Delta Functions: <code>probs</code> c ontrols the quantiles to
calculate. Default is <code>seq(0.1, 0.9, 0.1)</code>
(see <code><a href="#topic+drift_dm_default_probs">drift_dm_default_probs()</a></code>).
</p>
</li></ul>

<p>This function gets called by <a href="#topic+calc_stats">calc_stats</a>
</p>


<h3>Value</h3>

<p>A data frame with the calculated statistic across <code>conds</code>
(ordered according to <code>Source</code>).
</p>

<hr>
<h2 id='check_b_coding'>Check a B_Coding</h2><span id='topic+check_b_coding'></span>

<h3>Description</h3>

<p>Checks if a list satisfies the requirements to be considered a valid
<a href="#topic+b_coding">b_coding</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_b_coding(b_coding)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_b_coding_+3A_b_coding">b_coding</code></td>
<td>
<p>a named list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks for...
</p>

<ul>
<li><p> input being a list
</p>
</li>
<li><p> list is of length three and provides the names &quot;column&quot;, &quot;u_name_value&quot;,
&quot;l_name_value&quot;,
</p>
</li>
<li><p> if b_coding$column provides a single string
</p>
</li>
<li><p> if b_coding$u_name_value and b_coding$l_name_value provides a single
named value of type character or numeric, and that both are of the same
type
</p>
</li></ul>



<h3>Value</h3>

<p>the unmodified list for convenience
</p>

<hr>
<h2 id='check_digit_larger_0'>Checks if a variable/vector of length 1 is a number &gt; 0 or 0/expression</h2><span id='topic+check_digit_larger_0'></span>

<h3>Description</h3>

<p>assumed that x is either a digit or an expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_digit_larger_0(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_digit_larger_0_+3A_x">x</code></td>
<td>
<p>a vector of length 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single logical
</p>

<hr>
<h2 id='check_if_named_numeric_vector'>Check if Object is a Named Numeric Vector</h2><span id='topic+check_if_named_numeric_vector'></span>

<h3>Description</h3>

<p>Validates that an object is a named numeric vector with specified attributes.
Optionally checks specific names, length, and restrictions on label
characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_if_named_numeric_vector(
  x,
  var_name,
  labels = NULL,
  length = NULL,
  allow_non_word_chars = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_if_named_numeric_vector_+3A_x">x</code></td>
<td>
<p>numeric vector, expected to be named.</p>
</td></tr>
<tr><td><code id="check_if_named_numeric_vector_+3A_var_name">var_name</code></td>
<td>
<p>character, the name of the variable to display in error
messages.</p>
</td></tr>
<tr><td><code id="check_if_named_numeric_vector_+3A_labels">labels</code></td>
<td>
<p>character vector, optional, specifying valid names for <code>x</code>. If
provided, all names in <code>x</code> must match these labels.</p>
</td></tr>
<tr><td><code id="check_if_named_numeric_vector_+3A_length">length</code></td>
<td>
<p>integer, optional, specifying the exact required length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="check_if_named_numeric_vector_+3A_allow_non_word_chars">allow_non_word_chars</code></td>
<td>
<p>logical, whether to permit non-word characters in
names (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks for:
</p>

<ul>
<li><p> Numeric type of <code>x</code> with non-zero length
</p>
</li>
<li><p> Required length, if specified
</p>
</li>
<li><p> Unique, non-empty names for each entry in <code>x</code>
</p>
</li>
<li><p> Match of all names in <code>x</code> to <code>labels</code>, if <code>labels</code> is specified
</p>
</li>
<li><p> Absence of <code>NA</code> of <code>Inf</code> values in <code>x</code>
</p>
</li>
<li><p> Optional absence of non-word names if <code>allow_non_word_chars</code> is FALSE
</p>
</li></ul>



<h3>Value</h3>

<p>Throws an error if the conditions are not met. If all checks pass,
no output is returned.
</p>

<hr>
<h2 id='check_internal_list'>checks if all entries of internal_list are an expression or integer.
Throws an error if not (internal docu)</h2><span id='topic+check_internal_list'></span>

<h3>Description</h3>

<p>Checks also if there are entries for each parameter and condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_internal_list(internal_list, prm_names, cond_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_internal_list_+3A_internal_list">internal_list</code></td>
<td>
<p>a list, referring to a (linear) internal list of
a <a href="#topic+flex_prms">flex_prms</a> object.</p>
</td></tr>
<tr><td><code id="check_internal_list_+3A_prm_names">prm_names</code></td>
<td>
<p>the expected parameter of the flex_prms object</p>
</td></tr>
<tr><td><code id="check_internal_list_+3A_cond_names">cond_names</code></td>
<td>
<p>the expected conditions of the flex_prms object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the internal list for convenience
</p>

<hr>
<h2 id='check_raw_data'>Check the Observed Data</h2><span id='topic+check_raw_data'></span>

<h3>Description</h3>

<p>Checks a data set that is considered an &quot;observed data set&quot;. Used in the
internals of dRiftDM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_raw_data(obs_data, b_coding_column, u_value, l_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_raw_data_+3A_obs_data">obs_data</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a></p>
</td></tr>
<tr><td><code id="check_raw_data_+3A_b_coding_column">b_coding_column</code></td>
<td>
<p>a single string, indicating which column of <code>obs_data</code>
indicates how each RT corresponds to the boundaries.</p>
</td></tr>
<tr><td><code id="check_raw_data_+3A_u_value">u_value</code>, <code id="check_raw_data_+3A_l_value">l_value</code></td>
<td>
<p>the value within the <code>b_coding_column</code> column that
specifies the upper/lower boundary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks:
</p>

<ul>
<li><p> if <code>obs_data</code> is a data.frame
</p>
</li>
<li><p> For missing Values, and drops rows with missing values
</p>
</li>
<li><p> if &quot;RT&quot;, <code>b_coding_column</code>, and &quot;Cond&quot; column are present
</p>
</li>
<li><p> if &quot;Cond&quot; is of type character, and if not casts it to character
</p>
</li>
<li><p> if RT is of type numeric, and of not casts it to numeric
</p>
</li>
<li><p> RTs are &gt;= 0
</p>
</li>
<li><p> that the values in <code>b_coding_column</code> match with u_value and l_value
(casts the column if necessary)
</p>
</li>
<li><p> if <code>b_coding_column</code> has only 1 or 2 unique values
</p>
</li>
<li><p> When IDs are present, if each ID has values on each condition. At the same
time unused factor levels are dropped <a href="#topic+drop_levels_ID_column">drop_levels_ID_column</a>
</p>
</li></ul>



<h3>Value</h3>

<p>the <code>obs_data</code> for convenience (with edits as listed under Details).
</p>

<hr>
<h2 id='check_unique_special_boundary'>Check for Unique Special Boundary Values</h2><span id='topic+check_unique_special_boundary'></span>

<h3>Description</h3>

<p>Internal, deep in the depths of the package, function. Verifies that each
specified parameter value within a condition in <code>l_u</code> is unique within
the <code>linear_internal_list</code> in <code>drift_dm_obj</code>. If the same
value is associated with multiple conditions, an error is raised. Used for
checking the input to <a href="#topic+get_lower_upper_smart">get_lower_upper_smart</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_unique_special_boundary(drift_dm_obj, l_u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_unique_special_boundary_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="check_unique_special_boundary_+3A_l_u">l_u</code></td>
<td>
<p>a list specifying the upper/lower parameter/search space (see
<a href="#topic+simulate_data">simulate_data</a>, or <a href="#topic+estimate_model">estimate_model</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each condition in <code>l_u</code>, the function examines if the parameter
value specified is unique with respect to the <code>linear_internal_list</code>.
Non-unique values for a parameter-condition combination raise an error.
</p>

<hr>
<h2 id='coef+26lt+3B-'>Access Coefficients of a Model</h2><span id='topic+coef+3C-'></span><span id='topic+coef+3C-.drift_dm'></span><span id='topic+coef.drift_dm'></span><span id='topic+coef.fits_ids_dm'></span><span id='topic+print.coefs_dm'></span>

<h3>Description</h3>

<p>Extract or set the coefficients/parameters of <a href="#topic+drift_dm">drift_dm</a> or
<code>fits_ids_dm</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
coef(object, ..., eval_model = FALSE) &lt;- value

## S3 method for class 'drift_dm'
coef(object, ..., select_unique = TRUE, select_custom_prms = TRUE)

## S3 method for class 'fits_ids_dm'
coef(object, ...)

## S3 method for class 'coefs_dm'
print(
  x,
  ...,
  round_digits = drift_dm_default_rounding(),
  print_rows = 10,
  some = FALSE,
  show_header = TRUE,
  show_note = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code>
(see <a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the respective method.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>numerical, a vector with valid values to update the model's
parameters. Must match with the number of (unique and free) parameters.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating the parameters (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_select_unique">select_unique</code></td>
<td>
<p>logical, indicating if only those parameters shall be
returned that are considered unique (e.g., when a parameter is set to be
identical across three conditions, then the parameter is only returned once).
Default is <code>TRUE</code>. This will also return only those parameters that are
estimated.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_select_custom_prms">select_custom_prms</code></td>
<td>
<p>logical, indicating if custom parameters shall be
returned as well. Only has an effect if <code>select_unique = FALSE</code>.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object of type <code>coefs_dm</code>, as returned by the function
<code>coef()</code> when supplied with a <code>fits_ids_dm</code> object.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, controls the number of digits shown.
Default is 3.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_print_rows">print_rows</code></td>
<td>
<p>integer, controls the number of rows shown.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_some">some</code></td>
<td>
<p>logical. If <code>TRUE</code>, a subset of randomly sampled rows is shown.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_show_header">show_header</code></td>
<td>
<p>logical. If <code>TRUE</code>, a header specifying the type of
statistic will be displayed.</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_show_note">show_note</code></td>
<td>
<p>logical. If <code>TRUE</code>, a footnote  is displayed indicating
that the underlying <a href="base.html#topic+data.frame">data.frame</a> can be accessed as usual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coef()</code> are methods for the generic <code>coef</code> function; <code style="white-space: pre;">&#8288;coefs&lt;-()&#8288;</code> is a
generic replacement function, currently supporting objects of type
<a href="#topic+drift_dm">drift_dm</a>.
</p>
<p>The argument <code>value</code> supplied to the <code style="white-space: pre;">&#8288;coefs&lt;-()&#8288;</code> function must match with
the vector returned from <code style="white-space: pre;">&#8288;coef(&lt;object&gt;)&#8288;</code>. It is possible to
update just part of the (unique) parameters.
</p>
<p>Whenever the argument <code>select_unique = TRUE</code>, dRiftDM tries to provide
unique parameter labels.
</p>


<h3>Value</h3>

<p>For objects of type <a href="#topic+drift_dm">drift_dm</a>, <code>coefs()</code> returns either a named
numeric vector if <code>select_unique = TRUE</code>, or a matrix if
<code>select_unique = FALSE</code>. If <code>select_custom_prms = TRUE</code>, custom parameters
are added to the matrix.
</p>
<p>For objects of type <code>fits_ids_dm</code>, <code>coefs()</code> returns a <a href="base.html#topic+data.frame">data.frame</a>. If
<code>select_unique = TRUE</code>, the columns will be the (unique, free) parameters,
together with a column coding <code>IDs</code>. If <code>select_unique = FALSE</code>, the columns
will be the parameters as listed in the columns of <code>prms_matrix</code> (see
<a href="#topic+drift_dm">drift_dm</a>), together with columns coding the conditions and
<code>IDs</code>. If <code>select_custom_prms = TRUE</code>, the <a href="base.html#topic+data.frame">data.frame</a> will also contain
columns for the custom parameters. The returned <a href="base.html#topic+data.frame">data.frame</a> has the class
label <code>coefs_dm</code> to easily plot histograms for each parameter
(see <a href="#topic+hist.coefs_dm">hist.coefs_dm</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model and a data set for demonstration purpose
# (when creating the model, set the discretization to reasonable values)
a_model &lt;- dmc_dm(t_max = 1.5, dx = .0025, dt = .0025)
coef(a_model) # gives the free and unique parameters
coef(a_model, select_unique = FALSE) # gives the entire parameter matrix

</code></pre>

<hr>
<h2 id='comp_funs+26lt+3B-'>The Component Functions of A Model</h2><span id='topic+comp_funs+3C-'></span><span id='topic+comp_funs+3C-.drift_dm'></span><span id='topic+comp_funs'></span><span id='topic+comp_funs.drift_dm'></span><span id='topic+comp_funs.fits_ids_dm'></span>

<h3>Description</h3>

<p>Functions to get or set the &quot;component functions&quot; of an object. The component
functions are a list of functions providing the drift rate, boundary,
starting point distribution, and non-decision time distribution They are at
the heart of the package and shape the model's behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_funs(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
comp_funs(object, ..., eval_model = FALSE) &lt;- value

comp_funs(object, ...)

## S3 method for class 'drift_dm'
comp_funs(object, ...)

## S3 method for class 'fits_ids_dm'
comp_funs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_funs+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code>
(see <a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="comp_funs+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments passed down to the specific method.</p>
</td></tr>
<tr><td><code id="comp_funs+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a named list which provides the component functions to set
(see Details)</p>
</td></tr>
<tr><td><code id="comp_funs+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating the component funtions (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>).
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>comp_funs()</code> is a generic accessor function, and <code style="white-space: pre;">&#8288;comp_funs&lt;-()&#8288;</code> is a
generic replacement function. The default methods get and set the &quot;component
functions&quot;. The component functions are a list of functions, with the
following names (see also <code>vignette("customize_ddms", "dRiftDM")</code> for
examples):
</p>

<ul>
<li> <p><code>mu_fun</code> and <code>mu_int_fun</code>, provide the drift rate and its integral,
respectively, across the time space.
</p>
</li>
<li> <p><code>x_fun</code> provides a distribution of the starting point across the evidence
space.
</p>
</li>
<li> <p><code>b_fun</code> and <code>dt_b_fun</code> provide the values of the upper decision boundary
and its derivative, respectively, across the time space. It is assumed that
boundaries are symmetric.
</p>
</li>
<li> <p><code>nt_fun</code> provides a distribution of the non-decision component across the
time space.
</p>
</li></ul>

<p>All of the listed functions are stored in the list <code>comp_funs</code> of the
respective model (see also <code><a href="#topic+drift_dm">drift_dm()</a></code>).
</p>
<p>Each component function must take the model's parameters (i.e., one row of
<code>prms_matrix</code>), the parameters for deriving the PDFs, the time or evidence
space, a condition, and a list of optional values as arguments.
These arguments are provided with values when <code>dRiftDM</code> internally calls them.
</p>
<p>In order to work with <code>dRiftDM</code>, <code>mu_fun</code>, <code>mu_int_fun</code>, <code>b_fun</code>,
<code>dt_b_fun</code>, and <code>nt_fun</code> must have the following declaration:
<code style="white-space: pre;">&#8288;my_fun = function(prms_model, prms_solve, t_vec, one_cond, ddm_opts&#8288;</code>). Here,
<code>prms_model</code> is one row of <code>prms_matrix</code>, <a href="#topic+prms_solve">prms_solve</a> the
parameters relevant for deriving the PDFs, <code>t_vec</code> the time space, going from
0 to <code>t_max</code> with length <code>nt + 1</code> (see <a href="#topic+drift_dm">drift_dm</a>), and
<code>one_cond</code> a single character string, indicating the current condition.
Finally <code>dmm_opts</code> may contain additional values.
Each function must return a numeric vector
of the same length as <code>t_vec</code>. For <code>mu_fun</code>,
<code>mu_int_fun</code>, <code>b_fun</code>, <code>dt_b_fun</code> the returned values provide the
respective boundary/drift rate (and their derivative/integral) at every time
step <code class="reqn">t</code>. For <code>nt_fun</code> the returned values provide the density of the
non-decision time across the time space (which get convoluted with the
pdfs when solving the model)
</p>
<p>In order to work with <code>dRiftDM</code>, <code>x_fun</code> must have the following
declaration:
<code style="white-space: pre;">&#8288;my_fun = function(prms_model, prms_solve, x_vec, one_cond, ddm_opts&#8288;</code>).
Here, <code>x_vec</code> is the evidence space, going from -1 to 1 with length <code>nx + 1</code>
(see <a href="#topic+drift_dm">drift_dm</a>). Each function must return a numeric vector
of the same length as <code>x_vec</code>, providing the density values of the
starting points across the evidence space.
</p>


<h4>Drift rate and its integral:</h4>

<p>The drift rate is the first derivative of the expected time-course
of the diffusion process. For instance, if we assume that the diffusion
process <code class="reqn">X</code> is linear with a slope of <code class="reqn">v</code>...
</p>
<p style="text-align: center;"><code class="reqn">E(X) = v \cdot t</code>
</p>

<p>...then the drift rate at every time step <code class="reqn">t</code> is the constant <code class="reqn">v</code>,
obtained by taking the derivative of the expected time-course with respect
to <code class="reqn">t</code>:
</p>
<p style="text-align: center;"><code class="reqn">\mu(t) = v</code>
</p>

<p>Conversely, the integral of the drift rate is identical to the expected
time-course:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{int}(t) = v \cdot t</code>
</p>

<p>For the drift rate <code>mu_fun</code>, the default function when calling <code>drift_dm()</code>
is a numeric vector containing the number <code class="reqn">3</code>. Its integral counterpart
<code>mu_int_fun</code> will return a numeric vector containing the values <code>t_vec*3</code>.
</p>



<h4>Starting Point Distribution:</h4>

<p>The starting point of a diffusion model refers to the initial value taken
by the evidence accumulation process at time <code class="reqn">t=0</code>. This is a PDF
over the evidence space.
</p>
<p>The default function when calling <code>drift_dm()</code> will be a function
returning a dirac delta on zero, meaning that every potential diffusion
process starts at 0.
</p>



<h4>Boundary:</h4>

<p>The Boundary refers to the values of the absorbing boundaries at every time
step <code class="reqn">t</code> in a diffusion model. In most cases, this will be a constant.
For instance:
</p>
<p style="text-align: center;"><code class="reqn">b(t) = b</code>
</p>

<p>In this case, its derivative with respect to <code class="reqn">t</code> is 0.
</p>
<p>The default function when calling <code>drift_dm()</code> will be function for <code>b_fun</code>
returning a  numeric vector of length <code>length(t_vec)</code> containing the number
<code class="reqn">0.5</code>. Its counterpart <code>dt_b</code> will return a numeric vector of the same
length containing its derivative, namely, <code>0</code>.
</p>



<h4>Non-Decision Time:</h4>

<p>The non-decision time refers to an additional time-requirement. Its
distribution across the time space will be convoluted with the PDFs derived
from the diffusion process.
</p>
<p>In psychology, the non-decision time captures time-requirements outside the
central decision process, such as stimulus perception and motor execution.
</p>
<p>The default function when calling <code>drift_dm()</code> returns a dirac
delta on  <code class="reqn">t = 0.3</code>.
</p>



<h3>Value</h3>

<p>For <code>comp_funs()</code> the list of component functions.
</p>
<p>For <code style="white-space: pre;">&#8288;comp_funs&lt;-()&#8288;</code> the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>


<h3>Note</h3>

<p>There is only a replacement function for <a href="#topic+drift_dm">drift_dm</a> objects. This is
because replacing the component functions after the model has been fitted
(i.e., for a <code>fits_ids_dm</code> object) doesn't make sense.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model for demonstration
my_model &lt;- ratcliff_dm()
names(comp_funs(my_model))

# direct replacement (see customize_ddms for a more information on
# how to write custom component functions)
# 1. Choose a uniform non-decision time from the pre-built component_shelf()
nt_uniform &lt;- component_shelf()$nt_uniform
# swap it in
comp_funs(my_model)[["nt_fun"]] &lt;- nt_uniform

# now update the flex_prms object to ensure that this model has the required
# parameters
prms &lt;- c(muc = 3, b = 0.6, non_dec = 0.3, range_non_dec = 0.05)
conds &lt;- "null"
new_flex_prms &lt;- flex_prms(prms, conds = conds)
flex_prms(my_model) &lt;- new_flex_prms

# accessor method also available for fits_ids_dm objects
# (see estimate_model_ids)
# get an exemplary fits_ids_dm object
fits &lt;- get_example_fits_ids()
names(comp_funs(fits))

</code></pre>

<hr>
<h2 id='comp_vals'>Evaluate all Component Functions</h2><span id='topic+comp_vals'></span>

<h3>Description</h3>

<p>Gets/calculates all values provided by the component functions of a
<a href="#topic+drift_dm">drift_dm</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_vals(
  drift_dm_obj,
  x_vec = NULL,
  t_vec = NULL,
  nt = NULL,
  dt = NULL,
  nx = NULL,
  dx = NULL,
  prms_solve = NULL,
  solver = NULL,
  prms_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_vals_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="comp_vals_+3A_x_vec">x_vec</code></td>
<td>
<p>optional, the discretized evidence space</p>
</td></tr>
<tr><td><code id="comp_vals_+3A_t_vec">t_vec</code></td>
<td>
<p>optional, the discretized time space</p>
</td></tr>
<tr><td><code id="comp_vals_+3A_nx">nx</code>, <code id="comp_vals_+3A_nt">nt</code>, <code id="comp_vals_+3A_dx">dx</code>, <code id="comp_vals_+3A_dt">dt</code></td>
<td>
<p>optional, the steps and step sizes of each space</p>
</td></tr>
<tr><td><code id="comp_vals_+3A_prms_solve">prms_solve</code></td>
<td>
<p>optional, vector of solver settings</p>
</td></tr>
<tr><td><code id="comp_vals_+3A_solver">solver</code></td>
<td>
<p>optional, string controlling which component values are
evaluated</p>
</td></tr>
<tr><td><code id="comp_vals_+3A_prms_matrix">prms_matrix</code></td>
<td>
<p>optional, matrix of parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>arguments are optional, because they can be extracted from the model.
However, supplying these are faster than creating them.
</p>


<h3>Value</h3>

<p>If solver &quot;kfe&quot;, a named list with entries &quot;mu_vals&quot;, &quot;x_vals&quot;, &quot;b_vals&quot;,
&quot;dt_b_vals&quot;, &quot;nt_vals&quot;.
</p>
<p>If solver &quot;im_zero&quot;, the returned list will also contain &quot;mu_int_vals&quot;.
</p>

<hr>
<h2 id='component_shelf'>Diffusion Model Components</h2><span id='topic+component_shelf'></span>

<h3>Description</h3>

<p>This function is meant as a convenient way to access pre-built
model component functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component_shelf()
</code></pre>


<h3>Details</h3>

<p>The function provides the following functions:
</p>

<ul>
<li> <p><code>mu_constant</code>, provides the component function for a constant
drift rate with parameter <code>muc</code>.
</p>
</li>
<li> <p><code>mu_dmc</code>, provides the drift rate of the superimposed diffusion process
of DMC. Necessary parameters are <code>muc</code> (drift rate of the controlled
process), <code>a</code> (shape..), <code>A</code> (amplitude...), <code>tau</code> (scale of the
automatic process).
</p>
</li>
<li> <p><code>mu_ssp</code>, provides the drift rate for SSP.
Necessary parameters are <code>p</code> (perceptual input of flankers and
target), <code>sd_0</code> (initial spotlight width), <code>r</code> (shrinking rate of the
spotlight) and 'sign' (an auxiliary parameter for controlling the
contribution of the flanker stimuli). Note that no <code>mu_int_ssp</code> exists.
</p>
</li>
<li> <p><code>mu_int_constant</code>, provides the complementary integral to <code>mu_constant</code>.
</p>
</li>
<li> <p><code>mu_int_dmc</code>, provides the complementary integral to <code>mu_dmc</code>.
</p>
</li>
<li> <p><code>x_dirac_0</code>, provides a dirac delta for a starting point
centered between the boundaries (no parameter required).
</p>
</li>
<li> <p><code>x_uniform</code>, provides a uniform distribution for a start point
centered between the boundaries. Requires a parameter <code>range_start</code>
(between 0 and 2).
</p>
</li>
<li> <p><code>x_beta</code>, provides the function component for a symmetric
beta-shaped starting point distribution with parameter <code>alpha</code>.
</p>
</li>
<li> <p><code>b_constant</code>, provides a constant
boundary with parameter <code>b</code>.
</p>
</li>
<li> <p><code>b_hyperbol</code>, provides a collapsing boundary in terms of a
hyperbolic ratio function with parameters
<code>b0</code> as the initial value of the (upper) boundary,
<code>kappa</code> the size of the collapse, and <code>t05</code> the point in time where
the boundary has collapsed by half.
</p>
</li>
<li> <p><code>b_weibull</code>, provides a collapsing boundary in terms of a
Weibull distribution with parameters
<code>b0</code> as the initial value of the (upper) boundary,
<code>lambda</code> controlling the time of the collapse,
<code>k</code> the shape of the collapse, and <code>kappa</code> the size of the collapse.
</p>
</li>
<li> <p><code>dt_b_constant</code>, the first derivative of <code>b_constant</code>.
</p>
</li>
<li> <p><code>dt_b_hyperbol</code>, the first derivative of <code>b_hyperbol</code>.
</p>
</li>
<li> <p><code>nt_constant</code>, provides a constant
non-decision time with parameter <code>non_dec</code>.
</p>
</li>
<li> <p><code>nt_uniform</code>, provides a uniform distribution for the
non-decision time. Requires the parameters <code>non_dec</code> and <code>range_non_dec</code>.
</p>
</li>
<li> <p><code>nt_truncated_normal</code>, provides the component function for
a normally distributed non-decision time with parameters <code>non_dec</code>,
<code>sd_non_dec</code>. The Distribution is truncated to <code class="reqn">[0, t_{max}]</code>.
</p>
</li>
<li> <p><code>dummy_t</code> a function that accepts all required arguments for <code>mu_fun</code> or
<code>mu_int_fun</code> but which throws an error. Might come in handy when a user
doesn't require the integral of the drift rate.
</p>
</li></ul>

<p>See <code>vignette("customize_ddms", "dRiftDM")</code> for more information on how
to set/modify/customize the components of a diffusion model.
</p>


<h3>Value</h3>

<p>A list of the respective functions; each entry/function can be accessed by
&quot;name&quot; (see the Example and Details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pre_built_functions &lt;- component_shelf()
names(pre_built_functions)

</code></pre>

<hr>
<h2 id='conds+26lt+3B-'>The Conditions of an Object</h2><span id='topic+conds+3C-'></span><span id='topic+conds+3C-.drift_dm'></span><span id='topic+conds'></span><span id='topic+conds.drift_dm'></span><span id='topic+conds.fits_ids_dm'></span><span id='topic+conds.data.frame'></span><span id='topic+conds.traces_dm_list'></span>

<h3>Description</h3>

<p>Extract the conditions from a (supported) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conds(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
conds(object, ..., eval_model = FALSE, messaging = TRUE) &lt;- value

conds(object, ...)

## S3 method for class 'drift_dm'
conds(object, ...)

## S3 method for class 'fits_ids_dm'
conds(object, ...)

## S3 method for class 'data.frame'
conds(object, ...)

## S3 method for class 'traces_dm_list'
conds(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conds+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an <code>R</code> object, see details</p>
</td></tr>
<tr><td><code id="conds+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward.</p>
</td></tr>
<tr><td><code id="conds+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a character vector, providing labels for the model's new
conditions.</p>
</td></tr>
<tr><td><code id="conds+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating the conditions (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="conds+2B26lt+2B3B-_+3A_messaging">messaging</code></td>
<td>
<p>logical, indicating if messages shall be displayed or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conds()</code> is a generic accessor function and <code style="white-space: pre;">&#8288;conds&lt;-()&#8288;</code> is a
generic replacement function. The replacement method currently only supports
<a href="#topic+drift_dm">drift_dm</a> objects. The default methods get and set the conditions of an
object.
</p>
<p>When replacing the conditions of a <a href="#topic+drift_dm">drift_dm</a> object, a
new <a href="#topic+flex_prms">flex_prms</a> object is created and then set to the model,
resetting all parameter specifications and setting all parameter
values to those of the previously first condition.
In addition, if data was attached to the model, the data is removed.
This is because there is no meaningful way for dRiftDM to know how the model
should behave for the newly introduced condition(s), and how these new
conditions relate to the old ones. Messages reminding the user of this
behavior are displayed per default.
</p>


<h3>Value</h3>

<p>For <code>conds()</code> <code>NULL</code> or a character vector with the conditions. <code>NULL</code> is
given if the object has no conditions (e.g., when a data.frame has no <code>Cond</code>
column).
</p>
<p>For <code style="white-space: pre;">&#8288;conds&lt;-()&#8288;</code> the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model to demonstrate the conds() function
my_model &lt;- dmc_dm()
conds(my_model)

# accessor functions also work with other object types provided by dRiftDM
# (simulated traces; see the documentation of the respective function)
some_traces &lt;- simulate_traces(my_model, k = 1)
conds(some_traces)

# get an exemplary fits_ids_dm object (see estimate_model_ids)
fits &lt;- get_example_fits_ids()
conds(fits)

# also works with data.frames that have a "Cond" column
conds(dmc_synth_data)

</code></pre>

<hr>
<h2 id='copy_class_attributes'>Copy Class Attributes from One Object to Another</h2><span id='topic+copy_class_attributes'></span><span id='topic+copy_class_attributes.stats_dm'></span>

<h3>Description</h3>

<p>This function transfers class attributes from an <code>old</code> object to a <code>new</code>
object, ensuring that <code>new</code> inherits the class structure and missing
attributes of <code>old</code>. The primary purpose is to enforce class consistency and
restore any lost attributes when modifying or combining objects. It is
used in the internals of the package and it is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_class_attributes(old, new)

## S3 method for class 'stats_dm'
copy_class_attributes(old, new)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copy_class_attributes_+3A_old">old</code></td>
<td>
<p>The source object from which class attributes will be copied.</p>
</td></tr>
<tr><td><code id="copy_class_attributes_+3A_new">new</code></td>
<td>
<p>The target object to which class attributes will be assigned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that all class attributes of <code>new</code> can be found in
<code>old</code>. Note also, that the order of attributes is not ensured.
</p>


<h3>Value</h3>

<p>The modified <code>new</code> object with attributes and class from <code>old</code>.
</p>

<hr>
<h2 id='count_unique_prms_one_internal_entry'>Count the number of digits &gt; 0</h2><span id='topic+count_unique_prms_one_internal_entry'></span>

<h3>Description</h3>

<p>This function takes one entry of the internal_list (i.e., all conditions for
one parameter) and counts how often there are unique digits &gt; 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_unique_prms_one_internal_entry(one_internal_entry)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_unique_prms_one_internal_entry_+3A_one_internal_entry">one_internal_entry</code></td>
<td>
<p>such as <code>internal_list[["A"]]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer number
</p>

<hr>
<h2 id='create_matrix_l_u'>Create a matrix for lower and upper</h2><span id='topic+create_matrix_l_u'></span>

<h3>Description</h3>

<p>Outsourced, deep inside the package function to avoid large nesting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_matrix_l_u(l_u, conds, prm_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_matrix_l_u_+3A_l_u">l_u</code></td>
<td>
<p>either a list or a vector of numeric values</p>
</td></tr>
<tr><td><code id="create_matrix_l_u_+3A_conds">conds</code></td>
<td>
<p>a character string, conceptually representing the
conditions of a model</p>
</td></tr>
<tr><td><code id="create_matrix_l_u_+3A_prm_labels">prm_labels</code></td>
<td>
<p>a character string with parameter labels. Used as a fall
back when the default_values are not labeled (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is to build up a matrix, serving as the upper or
lower end of a parameter space (relevant when simulating data). The function
gets called by <code><a href="#topic+get_lower_upper_smart">get_lower_upper_smart()</a></code>.
</p>
<p>It assumes the following: <code>l_u</code> is either a list or a numeric vector.
</p>

<ul>
<li><p> The easiest case is when it is a numeric vector. In this case, the
function builds a matrix with as many rows as entries in <code>conds</code>. The
rows will also be labeled according to <code>conds</code>. The column names are
either the names specified with the numeric vector, or the labels specified
in <code>prm_labels</code>
</p>
</li>
<li><p> The less intuitive case is when <code>l_u</code> is a list. In this case, the list
requires an entry called &quot;default_values&quot; which specifies the named or plain
numeric vector as above. If the list only contains this entry, then the
behavior is as if <code>l_u</code> was already a numeric vector. However, the <code>l_u</code>
list can also have entries labeled as specific conditions, which contain
named (!) numeric vectors with parameter labels. This will modify the
value for the upper/lower parameter space with respect to the specified
parameters in the respective condition.#'
</p>
</li></ul>



<h3>Value</h3>

<p>a matrix indicating either the upper or lower end of a parameter
space. There will be as many rows as <code>conds</code> implies. The number of columns
depend on <code>l_u</code> (matching its length if it is a vector, or matching the
length of the entry &quot;default_values&quot; if it is a list).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_data">simulate_data()</a></code>, <code><a href="#topic+simulate_values">simulate_values()</a></code>
</p>

<hr>
<h2 id='ddm_opts+26lt+3B-'>Optional Arguments for the Component Functions</h2><span id='topic+ddm_opts+3C-'></span><span id='topic+ddm_opts+3C-.drift_dm'></span><span id='topic+ddm_opts'></span><span id='topic+ddm_opts.drift_dm'></span>

<h3>Description</h3>

<p>Functions to get or set the optional, user-defined R objects attached
to a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddm_opts(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
ddm_opts(object, ..., eval_model = FALSE) &lt;- value

ddm_opts(object, ...)

## S3 method for class 'drift_dm'
ddm_opts(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ddm_opts+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a>.</p>
</td></tr>
<tr><td><code id="ddm_opts+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments passed down to the specific method.</p>
</td></tr>
<tr><td><code id="ddm_opts+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>an arbitrary R object.</p>
</td></tr>
<tr><td><code id="ddm_opts+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not after attaching the arbitrary R object to the model
(see <a href="#topic+re_evaluate_model">re_evaluate_model</a>). Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When deriving model predictions, the model's component functions
(see <code><a href="#topic+comp_funs">comp_funs()</a></code>) are evaluated and the returned values are
passed forward to dedicated numerical methods implemented in dRiftDM.
To allow users to access arbitrary R objects within their custom component
functions, models may contain a <code>ddm_opts</code> entry (see also
<code><a href="#topic+drift_dm">drift_dm()</a></code> and the end of
<code>vignette("customize_ddms", "dRiftDM")</code> for an example).
</p>
<p><code>ddm_opts()</code> is a generic accessor function, and <code style="white-space: pre;">&#8288;ddm_opts&lt;-()&#8288;</code> is a
generic replacement function. The default methods get and set the optional
R object.
</p>


<h3>Value</h3>

<p>For <code>ddm_opts()</code> the optional R object that was once supplied by the user, or
<code>NULL</code>.
</p>
<p>For <code style="white-space: pre;">&#8288;ddm_opts&lt;-()&#8288;</code> the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>, <code><a href="#topic+comp_funs">comp_funs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model for demonstration
a_model &lt;- ratcliff_dm()
ddm_opts(a_model) &lt;- "Hello World"
ddm_opts(a_model)

</code></pre>

<hr>
<h2 id='defaults'>Default Values for the dRiftDM Package</h2><span id='topic+defaults'></span><span id='topic+drift_dm_approx_error'></span><span id='topic+drift_dm_medium_approx_error'></span><span id='topic+drift_dm_small_approx_error'></span><span id='topic+drift_dm_rough_approx_error'></span><span id='topic+drift_dm_robust_prm'></span><span id='topic+drift_dm_default_rounding'></span><span id='topic+drift_dm_default_probs'></span><span id='topic+drift_dm_default_b_coding'></span>

<h3>Description</h3>

<p>These functions provide default values for various settings in the
<code>dRiftDM</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drift_dm_approx_error()

drift_dm_medium_approx_error()

drift_dm_small_approx_error()

drift_dm_rough_approx_error()

drift_dm_robust_prm()

drift_dm_default_rounding()

drift_dm_default_probs()

drift_dm_default_b_coding()
</code></pre>


<h3>Details</h3>


<ul>
<li> <p><code>drift_dm_approx_error()</code>: Returns the default approximation error
for precise calculations (1e-20).
</p>
</li>
<li> <p><code>drift_dm_medium_approx_error()</code>: Returns a 'medium' level of approximation
error (1e-04).
</p>
</li>
<li> <p><code>drift_dm_small_approx_error()</code>: Returns a 'small' level of approximation
error (.01).
</p>
</li>
<li> <p><code>drift_dm_rough_approx_error()</code>: Returns a rough level of approximation
error (.1).
</p>
</li>
<li> <p><code>drift_dm_robust_prm()</code>: Returns a value that is added to the PDFs after
convolution with the non-decision time to make parameter estimation and the
evaluation of the log-likelihood more robust (1e-10).
</p>
</li>
<li> <p><code>drift_dm_default_rounding()</code>: Returns the default rounding precision for
numerical outputs (3).
</p>
</li>
<li> <p><code>drift_dm_default_probs()</code>: Returns the default sequence of probabilities
for quantiles (0.1, 0.2, ..., 0.9)
</p>
</li>
<li> <p><code>drift_dm_default_b_coding()</code>: Returns the default boundary coding
(list(column = &quot;Error&quot;, u_name_value = c(&quot;corr&quot; = 0),
l_name_value = c(&quot;err&quot; = 1))
</p>
</li></ul>



<h3>Value</h3>

<p>the respective values/lists as described in the Details section
</p>

<hr>
<h2 id='dmc_dm'>Create the Diffusion Model for Conflict Tasks</h2><span id='topic+dmc_dm'></span>

<h3>Description</h3>

<p>This function creates a <a href="#topic+drift_dm">drift_dm</a> object that corresponds to the
Diffusion Model for Conflict Tasks by
Ulrich et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmc_dm(
  var_non_dec = TRUE,
  var_start = TRUE,
  instr = NULL,
  obs_data = NULL,
  sigma = 1,
  t_max = 3,
  dt = 0.001,
  dx = 0.001,
  b_coding = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmc_dm_+3A_var_non_dec">var_non_dec</code>, <code id="dmc_dm_+3A_var_start">var_start</code></td>
<td>
<p>logical, indicating whether the model should
have a normally-distributed non-decision time or beta-shaped starting point
distribution, respectively.
(see <code>nt_truncated_normal</code> and <code>x_beta</code> in <a href="#topic+component_shelf">component_shelf</a>).
Defaults are <code>TRUE</code>. If <code>FALSE</code>, a constant non-decision time and
starting point is set (see <code>nt_constant</code> and <code>x_dirac_0</code> in
<a href="#topic+component_shelf">component_shelf</a>).</p>
</td></tr>
<tr><td><code id="dmc_dm_+3A_instr">instr</code></td>
<td>
<p>optional string with additional &quot;instructions&quot;, see
<code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code> and the Details below.</p>
</td></tr>
<tr><td><code id="dmc_dm_+3A_obs_data">obs_data</code></td>
<td>
<p>data.frame, an optional data.frame with the observed data.
See <a href="#topic+obs_data">obs_data</a>.</p>
</td></tr>
<tr><td><code id="dmc_dm_+3A_sigma">sigma</code>, <code id="dmc_dm_+3A_t_max">t_max</code>, <code id="dmc_dm_+3A_dt">dt</code>, <code id="dmc_dm_+3A_dx">dx</code></td>
<td>
<p>numeric, providing the settings for the diffusion
constant and discretization (see <a href="#topic+drift_dm">drift_dm</a>)</p>
</td></tr>
<tr><td><code id="dmc_dm_+3A_b_coding">b_coding</code></td>
<td>
<p>list, an optional list with the boundary encoding (see
<a href="#topic+b_coding">b_coding</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Diffusion Model for Conflict Tasks is a model for describing conflict
tasks like the Stroop, Simon, or flanker task.
</p>
<p>It has the following properties (see <a href="#topic+component_shelf">component_shelf</a>):
</p>

<ul>
<li><p> a constant boundary (parameter <code>b</code>)
</p>
</li>
<li><p> an evidence accumulation process that results from the sum of two
subprocesses:
</p>

<ul>
<li><p> a controlled process with drift rate <code>muc</code>
</p>
</li>
<li><p> a gamma-shaped process with a scale parameter <code>tau</code>, a shape
parameter <code>a</code>, and an amplitude <code>A</code>.
</p>
</li></ul>

</li></ul>

<p>If <code>var_non_dec = TRUE</code>, a (truncated) normally distributed non-decision with
mean <code>non_dec</code> and standard deviation <code>sd_non_dec</code> is assumed. If
<code>var_start = TRUE</code>,  a beta-shaped starting point distribution is assumed
with shape and scale parameter <code>alpha</code>.
</p>
<p>If <code>var_non_dec = TRUE</code>, a constant non-decision time at <code>non_dec</code> is set. If
<code>var_start = FALSE</code>, a starting point centered between the boundaries is
assumed (i.e., a dirac delta over 0).
</p>
<p>Per default the shape parameter <code>a</code> is set to 2 and not allowed to
vary. This is because the derivative of the scaled gamma-distribution
function does not exist at <code>t = 0</code> for <code>a &lt; 2</code>. We generally recommend keeping
<code>a</code> fixed to 2 for several reasons. If users decide to set <code>a != 2</code>, then a
small value of <code>0.0005</code> is added to the time vector <code>t_vec</code> before calculating
the derivative of the scaled gamma-distribution as originally introduced by
Ulrich et al. (2015). This can lead to large
numerical inaccuracies if <code>tau</code> is small and/or <code>dt</code> is large.
</p>
<p>The model assumes the amplitude <code>A</code> to be negative for
incompatible trials. Also, the model contains the custom parameter
<code>peak_l</code>, containing the peak latency (<code>(a-2)*tau</code>).
</p>


<h3>Value</h3>

<p>An object of type <code>drift_dm</code> (parent class) and <code>dmc_dm</code> (child class),
created by the function <code><a href="#topic+drift_dm">drift_dm()</a></code>.
</p>


<h3>References</h3>

<p>Ulrich R, Schröter H, Leuthold H, Birngruber T (2015).
&ldquo;Automatic and controlled stimulus processing in conflict tasks: Superimposed diffusion processes and delta functions.&rdquo;
<em>Cognitive Psychology</em>, <b>78</b>, 148&ndash;174.
<a href="https://doi.org/10.1016/j.cogpsych.2015.02.005">doi:10.1016/j.cogpsych.2015.02.005</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the model with default settings
my_model &lt;- dmc_dm()

# the model with no variability in the starting point and with a more coarse
# discretization
my_model &lt;- dmc_dm(
  var_start = FALSE,
  t_max = 1.5,
  dx = .0025,
  dt = .0025
)

</code></pre>

<hr>
<h2 id='dmc_synth_data'>A synthetic data set with two conditions</h2><span id='topic+dmc_synth_data'></span>

<h3>Description</h3>

<p>This dataset was simulated by using the Diffusion Model for Conflict tasks
(see  <code><a href="#topic+dmc_dm">dmc_dm()</a></code>) with parameter settings that are typical for a
Simon task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmc_synth_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 600 rows and 3 columns:
</p>

<dl>
<dt>RT</dt><dd><p>Response Times</p>
</dd>
<dt>Error</dt><dd><p>Error Coding (Error Response = 1; Correct Response = 0)</p>
</dd>
<dt>Cond</dt><dd><p>Condition ('comp' and 'incomp')</p>
</dd>
</dl>


<hr>
<h2 id='draw_from_pdf'>Draw Samples Using Inverse Transform Sampling</h2><span id='topic+draw_from_pdf'></span>

<h3>Description</h3>

<p><code>draw_from_pdf</code> generates samples from a given probability density function
(PDF) using inverse transform sampling. This function takes in a numeric PDF
vector and a corresponding domain vector, then returns a specified number
of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_from_pdf(a_pdf, x_def, k, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_from_pdf_+3A_a_pdf">a_pdf</code></td>
<td>
<p>a numeric vector representing the PDF values.</p>
</td></tr>
<tr><td><code id="draw_from_pdf_+3A_x_def">x_def</code></td>
<td>
<p>a numeric vector defining the domain (or x-values) corresponding
to the values in <code>a_pdf</code>. The vector <code>x_def</code> must be sorted in increasing
order.</p>
</td></tr>
<tr><td><code id="draw_from_pdf_+3A_k">k</code></td>
<td>
<p>a single integer specifying the number of samples to generate.</p>
</td></tr>
<tr><td><code id="draw_from_pdf_+3A_seed">seed</code></td>
<td>
<p>an optional single integer value used to set the seed for random
number generation, allowing for reproducibility of results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements inverse transform sampling by first constructing a
cumulative distribution function (CDF) from the given PDF. A uniform random
variable is then sampled for each of the <code>k</code> samples, and the corresponding
value in <code>x_def</code> is selected by locating the appropriate interval in the CDF.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>k</code> containing the sampled values from
the specified PDF. If <code>k</code> is 0, an empty numeric vector is returned.
</p>

<hr>
<h2 id='drift_dm'>Create a drift_dm object</h2><span id='topic+drift_dm'></span><span id='topic+print.drift_dm'></span>

<h3>Description</h3>

<p>This function creates an object of type drift_dm, which serves as the parent
class for all further created drift diffusion models (all of which have
a child class label, e.g., <code>dmc_dm</code>). The objects created by <code>drift_dm()</code> are
the backbone of the dRiftDM package. For a list of all pre-built models, see
<code>vignette("dRiftDM", "dRiftDM")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drift_dm(
  prms_model,
  conds,
  subclass,
  instr = NULL,
  obs_data = NULL,
  sigma = 1,
  t_max = 3,
  dt = 0.001,
  dx = 0.001,
  solver = "kfe",
  mu_fun = NULL,
  mu_int_fun = NULL,
  x_fun = NULL,
  b_fun = NULL,
  dt_b_fun = NULL,
  nt_fun = NULL,
  b_coding = NULL
)

## S3 method for class 'drift_dm'
print(x, ..., round_digits = drift_dm_default_rounding())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drift_dm_+3A_prms_model">prms_model</code></td>
<td>
<p>a named numeric vector of the model parameters. The names
indicate the model's parameters, and the numeric entries provide the current
parameter values.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_conds">conds</code></td>
<td>
<p>a character vector, giving the names of the model's conditions.
values within <code>conds</code> will be used when addressing the data and when
deriving the model's predictions.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_subclass">subclass</code></td>
<td>
<p>a character string, with a name for the newly created
diffusion model (e.g., <code>dmc_dm</code>). This will be the child class.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_instr">instr</code></td>
<td>
<p>an optional character string, providing &quot;instructions&quot; for the
underlying <a href="#topic+flex_prms">flex_prms</a> object.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_obs_data">obs_data</code></td>
<td>
<p>an optional data.frame, providing a data set (see
<code><a href="#topic+obs_data">obs_data()</a></code> for more information).</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_sigma">sigma</code></td>
<td>
<p>the diffusion constant. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_t_max">t_max</code></td>
<td>
<p>the maximum of the time space. Default is set <code>3</code> (seconds).</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_dt">dt</code>, <code id="drift_dm_+3A_dx">dx</code></td>
<td>
<p>the step size of the time and evidence space discretization,
respectively. Default is set to <code>.001</code> (which refers to seconds for dt).
Note that these values are set conservatively per default. In many cases,
users can increase the discretization.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_solver">solver</code></td>
<td>
<p>a character string, specifying which approach to use for
deriving the first passage time. Default is <code>kfe</code>, which provides access to
the numerical discretization of the Kolmogorov Forward Equation.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_mu_fun">mu_fun</code>, <code id="drift_dm_+3A_mu_int_fun">mu_int_fun</code>, <code id="drift_dm_+3A_x_fun">x_fun</code>, <code id="drift_dm_+3A_b_fun">b_fun</code>, <code id="drift_dm_+3A_dt_b_fun">dt_b_fun</code>, <code id="drift_dm_+3A_nt_fun">nt_fun</code></td>
<td>
<p>Optional custom
functions defining the components of a diffusion model. See
<code><a href="#topic+comp_funs">comp_funs()</a></code>. If an argument is <code>NULL</code>, dRiftDM falls
back to the respective default functions, which are documented in
<code><a href="#topic+comp_funs">comp_funs()</a></code>.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_b_coding">b_coding</code></td>
<td>
<p>an optional list, specifying how boundaries are coded. See
<code><a href="#topic+b_coding">b_coding()</a></code>. Default refers to accuracy coding.</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_x">x</code></td>
<td>
<p>an object of type <code>drift_dm</code></p>
</td></tr>
<tr><td><code id="drift_dm_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="drift_dm_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, controls the number of digits shown for
<code><a href="#topic+print.drift_dm">print.drift_dm()</a></code>. Default is <code>3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To modify the entries of a model users can use the replacement methods and
the <code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code> method (see also
<code>vignette("dRiftDM", "dRiftDM")</code> and
<code>vignette("customize_ddms", "dRiftDM")</code>).
</p>


<h3>Value</h3>

<p>For <code>drift_dm()</code>, a list with the parent class label <code>"drift_dm"</code>
and the child class label <code style="white-space: pre;">&#8288;&lt;subclass&gt;&#8288;</code>. The list contains the following
entries:
</p>

<ul>
<li><p> An instance of the class <a href="#topic+flex_prms">flex_prms</a> for controlling the model
parameters. Provides information about the number of parameters, conditions
etc.
</p>
</li>
<li><p> Parameters used for deriving the model predictions, <a href="#topic+prms_solve">prms_solve</a>,
containing the diffusion constant (<code>sigma</code>), the maximum of the time space
(<code>t_max</code>), the evidence and space discretization (<code>dt</code> and <code>dx</code>,
respectively), and the resulting number of steps for the time and evidence
space discretization (<code>nt</code> and <code>nx</code>, respectively).
</p>
</li>
<li><p> A character string <code>solver</code>, indicating the method for deriving the model
predictions.
</p>
</li>
<li><p> A list of functions called <a href="#topic+comp_funs">comp_funs</a>, providing the components
of the diffusion model (i.e., <code>mu_fun</code>, <code>mu_int_fun</code>, <code>x_fun</code>, <code>b_fun</code>,
<code>dt_b_fun</code>, <code>nt_fun</code>). These functions are called in the depths of the
package and will determine the behavior of the model
</p>
</li></ul>

<p>If (optional) observed data were passed via <code><a href="#topic+obs_data">obs_data()</a></code>,
the list will contain an entry <code>obs_data</code>. This is a (nested) list with
stored response times for the upper and lower boundary and with respect to
each condition.
</p>
<p>If the model has been evaluated (see <code><a href="#topic+re_evaluate_model">re_evaluate_model()</a></code>), the
list will contain...
</p>

<ul>
<li><p> ... the log likelihood; can be addressed via <code><a href="#topic+logLik.drift_dm">logLik.drift_dm()</a></code>.
</p>
</li>
<li><p> ... the PDFs of the first passage time; can be addressed via
<code><a href="#topic+pdfs">pdfs()</a></code>.
</p>
</li></ul>

<p>Finally, if arbitrary R objects were passed via <code><a href="#topic+ddm_opts">ddm_opts()</a></code>, to
access these objects when evaluating the component functions, the list will
contain an entry <code>ddm_opts</code>.
</p>
<p>Every model also has the attribute <a href="#topic+b_coding">b_coding</a>, which summarizes how
the boundaries are labeled.
</p>
<p>For <code>print.drift_dm()</code>, the supplied <code>drift_dm</code> object <code>x</code> (invisible return).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conds">conds()</a></code>, <code><a href="#topic+flex_prms">flex_prms()</a></code>, <code><a href="#topic+prms_solve">prms_solve()</a></code>,
<code><a href="#topic+solver">solver()</a></code>, <code><a href="#topic+obs_data">obs_data()</a></code>, <code><a href="#topic+comp_funs">comp_funs()</a></code>,
<code><a href="#topic+b_coding">b_coding()</a></code>, <code><a href="stats.html#topic+coef">coef()</a></code>, <code><a href="#topic+pdfs">pdfs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plain call, with default component functions -----------------------------
# create parameter and condition vectors
prms &lt;- c(muc = 4, b = 0.5)
conds &lt;- c("one", "two")

# then call the backbone function (note that we don't provide any component
# functions, so dRiftDM uses the default functions as documented in
# comp_funs())
my_model &lt;- drift_dm(prms_model = prms, conds = conds, subclass = "example")
print(my_model)

</code></pre>

<hr>
<h2 id='drop_levels_ID_column'>Maybe droplevels of ID column</h2><span id='topic+drop_levels_ID_column'></span>

<h3>Description</h3>

<p>This function takes a data frame with an ID colmumn, and drops the unused
levels from the ID column if it is factor; in this case a warning is
thrown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_levels_ID_column(some_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_levels_ID_column_+3A_some_data">some_data</code></td>
<td>
<p>a data.frame with an ID column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the ID column is not of type factor, then the unmodified object is
returned.
</p>
<p>if the ID column is of type factor, <a href="base.html#topic+droplevels">droplevels</a> is applied, and if levels
were dropped, a warning is thrown
</p>

<hr>
<h2 id='dt_b_constant'>Derivative of a Constant Boundary</h2><span id='topic+dt_b_constant'></span>

<h3>Description</h3>

<p>Derivative of a Constant Boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_b_constant(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dt_b_constant_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, no prm label required</p>
</td></tr>
<tr><td><code id="dt_b_constant_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="dt_b_constant_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="dt_b_constant_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="dt_b_constant_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as t_vec only zeros.
</p>

<hr>
<h2 id='estimate_model'>Estimate the Parameters of a drift_dm Model</h2><span id='topic+estimate_model'></span>

<h3>Description</h3>

<p>Find the 'best' parameter settings by fitting a <a href="#topic+drift_dm">drift_dm</a> models'
predicted probability density functions (PDFs) to the observed data
stored within the respective object. The fitting procedure is done by
minimizing the negative log-likelihood of the model.
</p>
<p>Users have three options:
</p>

<ul>
<li><p> Estimate the parameters via Differential Evolution (Default)
</p>
</li>
<li><p> Estimate the parameters via (bounded) Nelder-Mead
</p>
</li>
<li><p> Use Differential Evolution followed by Nelder-Mead.
</p>
</li></ul>

<p>See also <code>vignette("dRiftDM", "dRiftDM")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_model(
  drift_dm_obj,
  lower,
  upper,
  verbose = 0,
  use_de_optim = TRUE,
  use_nmkb = FALSE,
  seed = NULL,
  de_n_cores = 1,
  de_control = list(reltol = 1e-08, steptol = 50, itermax = 200, trace = FALSE),
  nmkb_control = list(tol = 1e-06)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_model_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object inheriting from <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="estimate_model_+3A_lower">lower</code>, <code id="estimate_model_+3A_upper">upper</code></td>
<td>
<p>numeric vectors or lists, specifying the lower and upper
bounds on each parameter to be optimized (see Details).</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_verbose">verbose</code></td>
<td>
<p>numeric, indicating the amount of information displayed.
If 0, no information is displayed (default). If 1, basic information about
the start of Differential Evolution or Nelder-Mead and the final
estimation result is given. If 2, each evaluation of the log-likelihood
function is shown. Note that <code>verbose</code> is independent of the information
displayed by <a href="DEoptim.html#topic+DEoptim">DEoptim::DEoptim</a>.</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_use_de_optim">use_de_optim</code></td>
<td>
<p>logical, indicating whether Differential Evolution via
<a href="DEoptim.html#topic+DEoptim">DEoptim::DEoptim</a> should be used. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="estimate_model_+3A_use_nmkb">use_nmkb</code></td>
<td>
<p>logical, indicating whether Nelder-Mead via
<a href="dfoptim.html#topic+nmkb">dfoptim::nmkb</a> should be used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_seed">seed</code></td>
<td>
<p>a single numeric, providing a seed for the Differential Evolution
algorithm</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_de_n_cores">de_n_cores</code></td>
<td>
<p>a single numeric, indicating the number of cores to use.
Run <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code> to see how many cores are available on your
machine. Note that it is generally not recommended to use all of your cores
as this will drastically slow down your machine for any additional task.</p>
</td></tr>
<tr><td><code id="estimate_model_+3A_de_control">de_control</code>, <code id="estimate_model_+3A_nmkb_control">nmkb_control</code></td>
<td>
<p>lists of additional control parameters passed
to <a href="DEoptim.html#topic+DEoptim">DEoptim::DEoptim</a> and <a href="dfoptim.html#topic+nmkb">dfoptim::nmkb</a>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Specifying lower/upper</h4>

<p>the function <code>estimate_model</code> provides a flexible way of specifying the
search space; identical to specifying the parameter simulation space in
<a href="#topic+simulate_data.drift_dm">simulate_data.drift_dm</a>.
</p>
<p>Users have three options to specify the simulation space:
</p>

<ul>
<li><p> Plain numeric vectors (not very much recommended). In this case,
<code>lower/upper</code> must be sorted in accordance with the parameters in the
<code>flex_prms_obj</code> object that vary for at least one condition
(call <code>print(drift_dm_obj)</code> and have a look at the <code style="white-space: pre;">&#8288;Unique Parameters&#8288;</code>
output)
</p>
</li>
<li><p> Named numeric vectors. In this case <code>lower/upper</code> have to provide labels
in accordance with the parameters that are considered &quot;free&quot; at least once
across conditions.
</p>
</li>
<li><p> The most flexible way is when <code>lower/upper</code> are lists. In this case, the
list requires an entry called &quot;default_values&quot; which specifies the named or
plain numeric vectors as above. If the list only contains this entry, then
the behavior is as if <code>lower/upper</code> were already numeric vectors. However,
the <code>lower/upper</code> lists can also provide entries labeled as specific
conditions, which contain named (!) numeric vectors with parameter labels.
This will modify the value for the upper/lower parameter space with respect
to the specified parameters in the respective condition.
</p>
</li></ul>




<h4>Details on Nelder-Mead and Differential Evolution</h4>

<p>If both <code>use_de_optim</code> and <code>use_nmkb</code> are <code>TRUE</code>, then Nelder-Mead follows
Differential Evolution. Note that Nelder-Mead requires a set of starting
parameters for which either the parameter values of <code>drift_dm_obj</code> or the
estimated parameter values by Differential Evolution are used.
</p>
<p>Default settings will lead <a href="DEoptim.html#topic+DEoptim">DEoptim::DEoptim</a> to stop if the algorithm is
unable to reduce the negative log-likelihood by a factor of
<code>reltol * (abs(val) + reltol)</code>after <code>steptol = 50</code> steps, with
<code>reltol = 1e-8</code> (or if the default itermax of 200 steps is reached).
Similarly, <a href="dfoptim.html#topic+nmkb">dfoptim::nmkb</a> will stop if the absolute difference of the
log-likelihood between successive iterations is below <code>tol = 1e-6</code>.See
<a href="DEoptim.html#topic+DEoptim.control">DEoptim::DEoptim.control</a> and the details of <a href="dfoptim.html#topic+nmkb">dfoptim::nmkb</a> for
further information.
</p>



<h3>Value</h3>

<p>the updated <code>drift_dm_obj</code> (with the estimated parameter values,
log-likelihood, and probability density functions of the first passage time)
</p>


<h3>See Also</h3>

<p><a href="#topic+estimate_model_ids">estimate_model_ids</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the example uses a simple model and the Nelder-Mead minimization
# routine to ensure that it runs in a couple of seconds.

# get a model and attach data to the model
my_model &lt;- ratcliff_dm(t_max = 1.5, dx = .005, dt = .005)
obs_data(my_model) &lt;- ratcliff_synth_data # this data set comes with dRiftDM


# set the search space
lower &lt;- c(muc = 1, b = 0.2, non_dec = 0.1)
upper &lt;- c(muc = 7, b = 1.0, non_dec = 0.6)

# then fit the data to the model using Nelder-Mead after setting some start
# values
coef(my_model) &lt;- c(muc = 2, b = 0.5, non_dec = 0.4)
my_model &lt;- estimate_model(
  drift_dm_obj = my_model, # (starting values are those set to the model)
  lower = lower, # lower and upper parameter ranges
  upper = upper,
  use_de_optim = FALSE, # don't use the default diff. evol. algorithm
  use_nmkb = TRUE # but Nelder-Mead (faster, but way less robust)
)

# show the result
print(my_model)

</code></pre>

<hr>
<h2 id='estimate_model_ids'>Fit Multiple Individuals and Save Results</h2><span id='topic+estimate_model_ids'></span>

<h3>Description</h3>

<p>Provides a wrapper around <a href="#topic+estimate_model">estimate_model</a> to fit multiple
individuals. Each individual will be stored in a folder. This folder will
also contain a file <code>drift_dm_fit_info.rds</code>, containing the main arguments
of the function call. One call to this function is considered a
&quot;fit procedure&quot;. Fit procedures can be loaded via <a href="#topic+load_fits_ids">load_fits_ids</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_model_ids(
  drift_dm_obj,
  obs_data_ids,
  lower,
  upper,
  fit_procedure_name,
  fit_path,
  fit_dir = "drift_dm_fits",
  folder_name = fit_procedure_name,
  seed = NULL,
  force_refit = FALSE,
  progress = 2,
  start_vals = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_model_ids_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object inheriting from <a href="#topic+drift_dm">drift_dm</a> that will
be estimated for each individual in <code>obs_data_ids</code>.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_obs_data_ids">obs_data_ids</code></td>
<td>
<p>data.frame, see
<a href="#topic+obs_data">obs_data</a>. An additional column <code>ID</code> necessary, to
identify a single individual.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_lower">lower</code>, <code id="estimate_model_ids_+3A_upper">upper</code></td>
<td>
<p>numeric vectors or lists, providing the parameter space,
see <a href="#topic+estimate_model">estimate_model</a>.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_fit_procedure_name">fit_procedure_name</code></td>
<td>
<p>character, providing a name of the fitting
procedure. This name will be stored in <code>drift_dm_fit_info.rds</code> to identify
the fitting procedure, see also <a href="#topic+load_fits_ids">load_fits_ids</a>.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_fit_path">fit_path</code></td>
<td>
<p>character, a path, pointing to the location where all fits
shall be stored (i.e., <code>fit_dir</code> will be created in this location). From the
user perspective, the path will likely be identical to the current working
directory.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_fit_dir">fit_dir</code></td>
<td>
<p>character, a directory where (multiple) fitting procedures
can be stored. If the directory does not exist yet, it will be created
via <code>base::create.dir(fit_dir, recursive = TRUE)</code> in the location
provided by <code>fit_path</code>. Default is <code>"drift_dm_fits"</code>.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_folder_name">folder_name</code></td>
<td>
<p>character, a folder name for storing all the individual
model fits. This variable should just state the name, and should not be
a path. Per default <code>folder_name</code> is identical to <code>fit_procedure_name</code>.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_seed">seed</code></td>
<td>
<p>numeric, a seed to make the fitting procedure reproducable
(only relevant for differential evolution, see <a href="#topic+estimate_model">estimate_model</a>).
Default is <code>NULL</code> which means no seed.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_force_refit">force_refit</code></td>
<td>
<p>logical, if <code>TRUE</code> each individual of a fitting routine will
be fitted once more. Default is <code>FALSE</code> which indicates that saved files</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_progress">progress</code></td>
<td>
<p>numerical, indicating if and how progress shall be displayed.
If 0, no progress is shown. If 1, the currently fitted individual is printed
out. If 2, a progressbar is shown. Default is 2.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_start_vals">start_vals</code></td>
<td>
<p>optional data.frame, providing values to be set
before calling <a href="#topic+estimate_model">estimate_model</a>. Can be used to control the
starting values for each individual when calling Nelder-Mead. Note that this
will only have an effect if DEoptim is not used (i.e., when setting
<code>use_de_optim = FALSE</code>; see <a href="#topic+estimate_model">estimate_model</a>). The data.frame
must provide a column <code>ID</code> whose entries match the <code>ID</code> column
in <code>obs_data_ids</code>, as well as a column for each parameter of the model
matching with <code>coef(drift_dm_obj, select_unique = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="estimate_model_ids_+3A_...">...</code></td>
<td>
<p>additional arguments passed down to <a href="#topic+estimate_model">estimate_model</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Examples and more information can also be found in
<code>vignette("dRiftDM", "dRiftDM")</code>.
</p>
<p>When developing the fitting routine we had three levels of files/folders
in mind:
</p>

<ul>
<li><p> In a directory/folder named <code>fit_dir</code> multiple fitting routines can be
stored (default is &quot;drift_dm_fits&quot;)
</p>
</li>
<li><p> Each fitting routine has its own folder with a name as given by
<code>folder_name</code> (e.g., &quot;ulrich_flanker&quot;, &quot;ulrich_simon&quot;, ...)
</p>
</li>
<li><p> Within each folder, a file called
<code>drift_dm_fit_info.rds</code> contains the main information about the function
call. That is, the time when last modifying/calling a fitting routine, the
<code>lower</code> and <code>upper</code> parameter boundaries, the <code>drift_dm_object</code> that was
fitted to each individual, the original data set <code>obs_data_ids</code>, and
the identifier <code>fit_procedure_name</code>. In the same folder each individual
has its own <code style="white-space: pre;">&#8288;&lt;individual&gt;.rds&#8288;</code> file containing the modified
<code>drift_dm_object</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>nothing (<code>NULL</code>; invisibly)
</p>


<h3>See Also</h3>

<p><a href="#topic+load_fits_ids">load_fits_ids</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We'll provide a somewhat unrealistic example, trimmed for speed.
# In practice, users likely employ more complex models and more individuals.
# However, a more realistic example would take minutes (and maybe even hours)
# and is therefore not suitable for an example.

# Fit the Ratcliff model to synthetic data --------------------------------
# get the model (pre-built by dRiftDM)
model &lt;- ratcliff_dm(t_max = 2.0, dx = .005, dt = .005)

# define an upper and lower boundary for the parameter space
lower &lt;- c(muc = 1, b = 0.2, non_dec = 0.1)
upper &lt;- c(muc = 7, b = 1.0, non_dec = 0.6)

# simulate synthetic data for demonstration purpose
synth_data_prms &lt;- simulate_data(
  model,
  n = 100, k = 2, lower = lower, upper = upper, seed = 1
)
synth_data &lt;- synth_data_prms$synth_data

# finally, call the fit procedure. To increase speed, we'll use the
# Nelder-Mead minimization routine. Note: We'll save the fits in tempdir()
# to avoid writing to a user's file directory without explicit permission.
estimate_model_ids(
  drift_dm_obj = model, # which model (the Ratcliff model)
  obs_data_ids = synth_data, # which data (the synthetic data set)
  lower = lower, # the lower and upper parameter/search space
  upper = upper,
  fit_procedure_name = "example", # a label for the fit procedure
  fit_path = tempdir(), # temporary directory (replace, e.g., with getwd())
  use_nmkb = TRUE, # use Nelder-Mead (fast, but less robust)
  use_de_optim = FALSE # and not differential evolution
)



</code></pre>

<hr>
<h2 id='flex_cust_prm'>Specify custom parameters</h2><span id='topic+flex_cust_prm'></span>

<h3>Description</h3>

<p>This function takes a flex_prms_obj and adds or builds the entry <code>cust_prms</code>
to allow for custom parameters. An examplary instruction is
&quot;peak_l = (a-1)*tau&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_cust_prm(flex_prms_obj, formula_instr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_cust_prm_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>a flex_prms object</p>
</td></tr>
<tr><td><code id="flex_cust_prm_+3A_formula_instr">formula_instr</code></td>
<td>
<p>a string referring to &quot;custom parameter combination&quot;
(see <a href="#topic+modify_flex_prms">modify_flex_prms</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entry <code>cust_prms</code> is a list with entries <code>expressions</code> and <code>values</code>.
Each of these is again a named list, that either contains the expression
with instructions on how to calculate the custom parameter (e.g., &quot;peak_l&quot;)
or the respective values. Values are getting updated/calculated in
<code>update_special_values()</code>
</p>
<p>The <code>cust_prms</code> exists of two entries &quot;expressions&quot; and values&quot;.
&quot;expressions&quot; contains a named list, with expressions referring to
<code>prms_matrix</code> (see <a href="#topic+flex_prms">flex_prms</a>) on how to calculate the custom
parameter (across all conditions). The &quot;values&quot; contain a named list,
with named numeric vectors (names are conditions, values the calculated
custom parameter values)
</p>


<h3>Value</h3>

<p>a modified flex_prms object with respect to the <code>cust_prms</code> entry
</p>

<hr>
<h2 id='flex_fix_prms'>Exclude parameters from being modified (i.e., fix it; internal docu)</h2><span id='topic+flex_fix_prms'></span>

<h3>Description</h3>

<p>This function modifies the (linear) internal list and sets the desired
parameters (based on the instruction string) to 0. This indicates that
this parameter is not altered within the function x2prms_vals
(i.e., ' prm &lt;!&gt; conda')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_fix_prms(flex_prms_obj, formula_instr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_fix_prms_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>a flex_prms object</p>
</td></tr>
<tr><td><code id="flex_fix_prms_+3A_formula_instr">formula_instr</code></td>
<td>
<p>a string referring to &quot;fix&quot;
(see <a href="#topic+modify_flex_prms">modify_flex_prms</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified flex_prms_obj with respect to the (linear) internal list
</p>

<hr>
<h2 id='flex_prms+26lt+3B-'>Flex_Prms</h2><span id='topic+flex_prms+3C-'></span><span id='topic+flex_prms+3C-.drift_dm'></span><span id='topic+flex_prms'></span><span id='topic+flex_prms.numeric'></span><span id='topic+flex_prms.flex_prms'></span><span id='topic+flex_prms.drift_dm'></span><span id='topic+print.flex_prms'></span>

<h3>Description</h3>

<p>Functions for creating, accessing replacing, or printing a <code>flex_prms</code> object.
Any object of type <code>flex_prms</code> provides a user-friendly way to specify
dependencies, parameter values etc. for a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_prms(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
flex_prms(object, ..., eval_model = FALSE) &lt;- value

flex_prms(object, ...)

## S3 method for class 'numeric'
flex_prms(object, ..., conds, instr = NULL, messaging = NULL)

## S3 method for class 'flex_prms'
flex_prms(object, ...)

## S3 method for class 'drift_dm'
flex_prms(object, ...)

## S3 method for class 'flex_prms'
print(
  x,
  ...,
  round_digits = drift_dm_default_rounding(),
  dependencies = TRUE,
  cust_parameters = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an <code>R</code> object (see Details)</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to the specific method.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>an object of type <code>flex_prms</code>.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when replacing the <code>flex_prms</code> object (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>).</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_conds">conds</code></td>
<td>
<p>A character vector, giving the names of the model's conditions.
values within <code>conds</code> will be used when addressing the data and when
deriving the model's predictions.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_instr">instr</code></td>
<td>
<p>optional string with &quot;instructions&quot;, see
<code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code>.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_messaging">messaging</code></td>
<td>
<p>optional logical, indicates if messages shall be displayed
when processing <code>instr</code>.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>an object of type <code>flex_prms</code></p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, controls the number of digits shown when
printing out a <code>flex_prms</code> object. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_dependencies">dependencies</code></td>
<td>
<p>logical, controlling if a summary of the special
dependencies shall be printed.</p>
</td></tr>
<tr><td><code id="flex_prms+2B26lt+2B3B-_+3A_cust_parameters">cust_parameters</code></td>
<td>
<p>logical, controlling if a summary of the custom
parameters shall be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of type <code>flex_prms</code> can be modified using the generic
<code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code> function and a corresponding set of
&quot;instructions&quot; (see the respective function for more details).
</p>
<p><code>flex_prms()</code> is a generic function. If called with a named numeric
vector, then this will create an object of type <code>flex_prms</code> (requires
<code>conds</code> to be specified). If called with other data types, gives the
respective <code>flex_prms</code> object
</p>
<p><code style="white-space: pre;">&#8288;flex_prms&lt;-()&#8288;</code> is a generic replacement function. Currently this only
supports objects of type <a href="#topic+drift_dm">drift_dm</a>. It will replace/update the
model with a new instance of type <code>flex_prms</code>.
</p>


<h3>Value</h3>

<p>The specific value returned depends on which method is called
</p>


<h4>Creating an object of type <code>flex_prms</code></h4>

<p>Can be achieved by calling <code>flex_prms()</code> with a named numeric vector, thus
when calling the underlying method <code>flex_prms.numeric</code> (see the example
below). In this case a list with the class label <code>"flex_prms"</code> is returned.
It containts three entries:
</p>

<ul>
<li><p> A nested list <code>internal_list</code>. This list specifies the dependencies
and restrains enforced upon the parameters across conditions. Integers &gt;= 1
indicate that this parameter will be estimated for a specific condition, and
conditions with the same number refer to a single parameter. Integers == 0
indicate thtat this parameter will not be esitmated for a specific condition
(i.e., it is considered &quot;fixed&quot;). Expressions will be evaluated at run time
and specify special dependencies among parameters.
</p>
</li>
<li><p> A nested list <code>linear_internal_list</code>. This list essentially contains
the same information as <code>internal_list</code>, but the parameters are sorted so
that they can be mapped to an integer vector (relevant only in the depths of
the package for the minimization routines).
</p>
</li>
<li><p> A numeric matrix <code>prms_matrix</code> which contains the currently set values for
each parameter across all conditions. Per default, the values of each
parameter are set equal across all conditions. Additionally, each parameter
is assumed to be restrained as equal across all conditions.
The values for all parameters given a condition will be passed to the
component functions (see <a href="#topic+comp_funs">comp_funs</a>).
</p>
</li>
<li><p> (optional) A list of additional parameters <code>cust_prms</code> that are derived
from the parameters in <code>prms_matrix</code>.
</p>
</li></ul>




<h4>Accessing an object of type <code>flex_prms</code></h4>

<p>Users can access/get the <code>flex_prms</code> object when calling <code>flex_prms()</code> with
an object of type <a href="#topic+drift_dm">drift_dm</a>, <code>fits_ids_dm</code>
(see <code><a href="#topic+estimate_model_ids">estimate_model_ids()</a></code>), or <code>flex_prms</code>. In this case, the
stored <code>flex_prms</code> object is returned.
</p>



<h4>Replacing an object of type <code>flex_prms</code></h4>

<p>The <code>flex_prms</code> object stored within an object of type <a href="#topic+drift_dm">drift_dm</a>
can be replaced by calling the generic <code style="white-space: pre;">&#8288;flex_prms&lt;-&#8288;</code> replacement function. In
this case, the modified <a href="#topic+drift_dm">drift_dm</a> object is returned.
</p>



<h4>Printing an object of type <code>flex_prms</code></h4>

<p>The <code>print.flex_prms()</code> method invisibly returns the supplied <code>flex_prms</code>
object.
</p>



<h3>Note</h3>

<p>There is only a replacement function for <a href="#topic+drift_dm">drift_dm</a> objects. This is
because replacing the solver settings after the model has been fitted (i.e.,
for a <code>fits_ids_dm</code> object) doesn't make sense.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_model_ids">estimate_model_ids()</a></code>, <code><a href="#topic+drift_dm">drift_dm()</a></code>,
<code><a href="#topic+summary.flex_prms">summary.flex_prms()</a></code>, <code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a flex_prms object -----------------------------------------------
conds &lt;- c("one", "two")
prms &lt;- c(muc = 3, b = 0.5)
one_instr &lt;- "muc ~ one + two"
flex_prms_obj &lt;- flex_prms(
  prms,
  conds = conds,
  instr = one_instr
)
print(flex_prms_obj)


# Access a flex_prms object of a model ------------------------------------
my_model &lt;- ratcliff_dm() # the Ratcliff DDM comes with dRiftDM
print(flex_prms(my_model))


# Replace the flex_prms object of a model ---------------------------------
# create a new flex_prms object
conds &lt;- c("one", "two")
prms &lt;- c(muc = 3, b = 0.6, non_dec = 0.3)
new_flex_prms_obj &lt;- flex_prms(
  prms,
  conds = conds
)

flex_prms(my_model) &lt;- new_flex_prms_obj

# acess the new flex_prms object
print(flex_prms(my_model))


# Control the print method -------------------------------------------------
dmc_model &lt;- dmc_dm() # another, more complex, model; comes with dRiftDM
print(flex_prms(dmc_model), round_digits = 1, cust_parameters = FALSE)

</code></pre>

<hr>
<h2 id='flex_restrain_prms'>Set parameters as equal across conditions</h2><span id='topic+flex_restrain_prms'></span>

<h3>Description</h3>

<p>This function takes a flex_prms object and modifies the (linear) internal
list so that a parameter is set as equal across multiple conditions,
according to the instruction formula (i.e., ' prm ~! conda + condb)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_restrain_prms(flex_prms_obj, formula_instr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_restrain_prms_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>flex_prms object</p>
</td></tr>
<tr><td><code id="flex_restrain_prms_+3A_formula_instr">formula_instr</code></td>
<td>
<p>a string referring to &quot;restrain&quot;
(see <a href="#topic+modify_flex_prms">modify_flex_prms</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified flex_prms object with an updated (linear) internal list
</p>

<hr>
<h2 id='flex_special_dependency'>Set special dependencies (internal docu)</h2><span id='topic+flex_special_dependency'></span>

<h3>Description</h3>

<p>Sets special dependencies so that parameters depend on other parameters.
(i.e., 'prmX ~ conda == -(prmY ~ condb)')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_special_dependency(flex_prms_obj, formula_instr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_special_dependency_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>a flex_prms object</p>
</td></tr>
<tr><td><code id="flex_special_dependency_+3A_formula_instr">formula_instr</code></td>
<td>
<p>a string referring to &quot;special dependency&quot;
(see <a href="#topic+modify_flex_prms">modify_flex_prms</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified flex_prms_object with a modified (linear) internal list
and modified parameter and custom parameter matrices
</p>

<hr>
<h2 id='flex_specific_value'>Set a specific value to the parameter matrix (internal docu)</h2><span id='topic+flex_specific_value'></span>

<h3>Description</h3>

<p>This function takes a flex_prms_obj and sets certain values to the parameter
matrix, based on the given instruction string (i.e., ' prm ~ conda =&gt; 0.3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_specific_value(flex_prms_obj, formula_instr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_specific_value_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>flex_prms object</p>
</td></tr>
<tr><td><code id="flex_specific_value_+3A_formula_instr">formula_instr</code></td>
<td>
<p>a string referring to &quot;set&quot;
(see <a href="#topic+modify_flex_prms">modify_flex_prms</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated flex_prms object with a modified prms_matrix object, and
(if applicable) a modified cust_prms matrix
</p>

<hr>
<h2 id='flex_vary_prms'>Allow parameters to vary</h2><span id='topic+flex_vary_prms'></span>

<h3>Description</h3>

<p>This function takes an object of type flex_prms and a instruction string
that refers to a &quot;vary&quot; instruction (i.e., ab ~ cd + ds). This string
is broken down and unique parameters are introduced for the condition x
parameter combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flex_vary_prms(flex_prms_obj, formula_instr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flex_vary_prms_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>an object of type flex_prms</p>
</td></tr>
<tr><td><code id="flex_vary_prms_+3A_formula_instr">formula_instr</code></td>
<td>
<p>a string referring to &quot;vary&quot;
(see <a href="#topic+modify_flex_prms">modify_flex_prms</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated flex_prms_obj with an updated (linear) internal list
</p>

<hr>
<h2 id='get_default_functions'>Get default/fall back component functions</h2><span id='topic+get_default_functions'></span>

<h3>Description</h3>

<p>If arguments are provided that are not NULL, the respective argument is
simply returned. If it is NULL, then a default/fall back component function
is returned for the respective component. This function is called to fill up
non-specified component functions when calling <code><a href="#topic+drift_dm">drift_dm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_functions(
  mu_fun = NULL,
  mu_int_fun = NULL,
  x_fun = NULL,
  b_fun = NULL,
  dt_b_fun = NULL,
  nt_fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_default_functions_+3A_mu_fun">mu_fun</code></td>
<td>
<p>drift rate function</p>
</td></tr>
<tr><td><code id="get_default_functions_+3A_mu_int_fun">mu_int_fun</code></td>
<td>
<p>integral drift rate function</p>
</td></tr>
<tr><td><code id="get_default_functions_+3A_x_fun">x_fun</code></td>
<td>
<p>starting point function</p>
</td></tr>
<tr><td><code id="get_default_functions_+3A_b_fun">b_fun</code></td>
<td>
<p>boundary function</p>
</td></tr>
<tr><td><code id="get_default_functions_+3A_dt_b_fun">dt_b_fun</code></td>
<td>
<p>derivative of boundary function</p>
</td></tr>
<tr><td><code id="get_default_functions_+3A_nt_fun">nt_fun</code></td>
<td>
<p>non-decision time function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>defaults...
</p>

<ul>
<li><p> mu_fun -&gt; constant drift rate of 3 (i.e., vector of 0s)
</p>
</li>
<li><p> mu_int_fun -&gt; constant drift rate of 3 (i.e., vector of 3 times t_vec)
</p>
</li>
<li><p> x_fun -&gt; dirac delta on zero <code><a href="#topic+x_dirac_0">x_dirac_0()</a></code>
</p>
</li>
<li><p> b_fun -&gt; constant boundary of 0.5 (i.e., vector of 0.5s)
</p>
</li>
<li><p> dt_b_fun -&gt; derivate of constant boundary (i.e., vector of 0s).
<code><a href="#topic+dt_b_constant">dt_b_constant()</a></code>
</p>
</li>
<li><p> nt_fun -&gt; constant non-decision time of 0.3 (i.e., vector for dirac delta
on 0.5).
</p>
</li></ul>



<h3>Value</h3>

<p>a list of <code>mu_fun</code>, <code>mu_int_fun</code>, <code>x_fun</code>, <code>b_fun</code>, <code>dt_b_fun</code>, and
<code>nt_fun</code>, with either the supplied component functions
or the added/filled in default component functions (if an argument is NULL).
</p>

<hr>
<h2 id='get_example_fits_ids'>Auxiliary Function to create a fits_ids object</h2><span id='topic+get_example_fits_ids'></span>

<h3>Description</h3>

<p>This function is merely a helper function to create an object of type
<code>fits_ids_dm.</code> It is used for example code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_example_fits_ids()
</code></pre>


<h3>Details</h3>

<p>The returned fit object comprises DMC (see <code><a href="#topic+dmc_dm">dmc_dm()</a></code>) fitted to
three participants of the ulrich_flanker_data.
</p>


<h3>Value</h3>

<p>An object of type <code>fits_ids_dm</code>, mimicking a result from calling
<code><a href="#topic+load_fits_ids">load_fits_ids()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fits &lt;- get_example_fits_ids()

</code></pre>

<hr>
<h2 id='get_lower_upper_smart'>Turn default/special upper and lower arguments to vectors</h2><span id='topic+get_lower_upper_smart'></span>

<h3>Description</h3>

<p>The function is used in the depths of the package to get the search space as
a vector, matching with the free parameters of a model.
Only relevant when users use the &quot;default parameters&quot; approach where they
only specify the parameter labels and assume the package figures out
how each parameter relates across conditions (see <a href="#topic+simulate_data">simulate_data</a>).
This comes in handy, when freeing a parameter across conditions, while the
search space remains the same (otherwise, a user would always have to adapt
the vectors for lower/upper to match with <a href="#topic+x2prms_vals">x2prms_vals</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lower_upper_smart(drift_dm_obj, lower, upper, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_lower_upper_smart_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type drift_dm</p>
</td></tr>
<tr><td><code id="get_lower_upper_smart_+3A_lower">lower</code>, <code id="get_lower_upper_smart_+3A_upper">upper</code></td>
<td>
<p>either a vector or list (see <a href="#topic+create_matrix_l_u">create_matrix_l_u</a>)</p>
</td></tr>
<tr><td><code id="get_lower_upper_smart_+3A_labels">labels</code></td>
<td>
<p>optional logical, if <code>TRUE</code>, then the returned vectors have
the unique parameter labels according to <a href="#topic+prm_cond_combo_2_labels">prm_cond_combo_2_labels</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first gets all unique parameters across conditions using
<a href="#topic+prms_cond_combo">prms_cond_combo</a>. The unique parameter labels are then forwarded
to <a href="#topic+create_matrix_l_u">create_matrix_l_u</a>, together with all (!) the conditions in the
model and the <code>upper</code>/<code>lower</code> arguments. Subsequently, the created matrices
are wrangled into vectors in accordance with <a href="#topic+prms_cond_combo">prms_cond_combo</a>. The
vectors are then passed back.
</p>


<h3>Value</h3>

<p>a list with two vectors named <code>lower/upper</code> that describe the search
space. The length and names (if requested) matches with
coef(model, select_unique = TRUE).
</p>

<hr>
<h2 id='hist.coefs_dm'>Plot Parameter Distribution(s)</h2><span id='topic+hist.coefs_dm'></span>

<h3>Description</h3>

<p>This function creates a histogram for each parameter in a <code>coefs_dm</code> object,
resulting from a call to <a href="#topic+coef.fits_ids_dm">coef.fits_ids_dm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coefs_dm'
hist(
  x,
  ...,
  separate_plots = TRUE,
  alpha = 0.5,
  main = NULL,
  colors = NULL,
  xlab = "values"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist.coefs_dm_+3A_x">x</code></td>
<td>
<p>an object of class <code>coefs_dm</code> (see <a href="#topic+coef.fits_ids_dm">coef.fits_ids_dm</a>)</p>
</td></tr>
<tr><td><code id="hist.coefs_dm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <a href="graphics.html#topic+hist">graphics::hist</a> function.</p>
</td></tr>
<tr><td><code id="hist.coefs_dm_+3A_separate_plots">separate_plots</code></td>
<td>
<p>logical, indicating whether to display separate panels
for each parameter in a single plot layout (<code>TRUE</code>), or to plot them
sequentially (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="hist.coefs_dm_+3A_alpha">alpha</code></td>
<td>
<p>numeric, specifying the transparency level for histogram colors
when conditions are present, with values between 0 (fully transparent) and
1 (fully opaque).</p>
</td></tr>
<tr><td><code id="hist.coefs_dm_+3A_main">main</code></td>
<td>
<p>character vector, specifying titles for each parameter histogram.
Defaults to parameter names.</p>
</td></tr>
<tr><td><code id="hist.coefs_dm_+3A_colors">colors</code></td>
<td>
<p>character vector, specifying colors for each condition if
conditions are present. Defaults to a rainbow color palette.
If <code>NULL</code> and no conditions are present, the default color is <code>"skyblue"</code>.</p>
</td></tr>
<tr><td><code id="hist.coefs_dm_+3A_xlab">xlab</code></td>
<td>
<p>character, specifying the label for the x-axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>hist.coefs_dm</code> function is designed for visualizing parameter
distributions for a single fit procedure.
</p>
<p>If multiple conditions are present, it overlays histograms for each condition
with adjustable transparency.
</p>
<p>When <code>separate_plots</code> is set to <code>TRUE</code>, histograms for each parameter are
displayed in a grid layout within a single graphics device.
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an auxiliary fit procedure result (see the function load_fits_ids)
all_fits &lt;- get_example_fits_ids()
hist(coef(all_fits)) # only three participants in this fit_ids object

# allows for some customization
hist(coef(all_fits), colors = "lightgreen")

</code></pre>

<hr>
<h2 id='internal_aggregate'>Aggregate Data Frame Columns by Group</h2><span id='topic+internal_aggregate'></span>

<h3>Description</h3>

<p>internal function to aggregate columns of a data frame across &quot;ID&quot;
while considering a set of grouping columns. It retains the class and
attriubtes of the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internal_aggregate(data, group_cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internal_aggregate_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> containing the data to be aggregated. It should
include both the grouping columns, an &quot;ID&quot; column, and the columns for which
aggregation shall take place.</p>
</td></tr>
<tr><td><code id="internal_aggregate_+3A_group_cols">group_cols</code></td>
<td>
<p>A character vector specifying the names of the columns to
group by during aggregation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>internal_aggregate</code> identifies DV columns as those not in <code>group_cols</code> or
<code>"ID"</code>. It then calculates the mean of these DV columns, grouped by the
specified columns.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the aggregated data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_stats">aggregate_stats()</a></code>, <code><a href="#topic+calc_stats">calc_stats()</a></code>,
<code><a href="#topic+new_stats_dm">new_stats_dm()</a></code>
</p>

<hr>
<h2 id='internal_list_to_matrix'>Turn an internal list to a matrix</h2><span id='topic+internal_list_to_matrix'></span>

<h3>Description</h3>

<p>this function wrangles the internal list to character matrix
to show how each parameter relates across conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internal_list_to_matrix(internal_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internal_list_to_matrix_+3A_internal_list">internal_list</code></td>
<td>
<p>the internal list of a flex_prms object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character matrix with all parameter labels (columns) and conditions
(rows)
</p>

<hr>
<h2 id='is_empty'>Check if an object of length &lt;= 1 is either empty or contains entry with &quot;&quot;</h2><span id='topic+is_empty'></span>

<h3>Description</h3>

<p>Check if an object of length &lt;= 1 is either empty or contains entry with &quot;&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_empty_+3A_x">x</code></td>
<td>
<p>a single value or empty vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE otherwise
</p>

<hr>
<h2 id='is_numeric'>Check if an object is a valid numeric vector</h2><span id='topic+is_numeric'></span>

<h3>Description</h3>

<p>This function verifies whether the input is a numeric vector with no missing
(<code>NA</code>, <code>NaN</code>) or infinite (<code>Inf</code> or <code>-Inf</code>) values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_numeric(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_numeric_+3A_x">x</code></td>
<td>
<p>An object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value: <code>TRUE</code> if the input is a numeric vector without any
missing or infinite values, otherwise <code>FALSE</code>.
</p>

<hr>
<h2 id='linearize_internal_list'>Relabel the internal list</h2><span id='topic+linearize_internal_list'></span>

<h3>Description</h3>

<p>The entries of the internal list are either digits (0-x) or expressions.
To ensure a valid mapping of these values to an input vector (as done when an
optimizer provides input parameters), we have to linearize the list
(done whenever modifying the list, see the different flex_* functions )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearize_internal_list(internal_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linearize_internal_list_+3A_internal_list">internal_list</code></td>
<td>
<p>the internal list, with entries for each parameter x
condition combination</p>
</td></tr>
</table>


<h3>Value</h3>

<p>another list, but with remapped digits in increasing order, while leaving
expressions or digits of 0 untouched.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flex_vary_prms">flex_vary_prms()</a></code>, <code><a href="#topic+flex_restrain_prms">flex_restrain_prms()</a></code>,
<code><a href="#topic+flex_fix_prms">flex_fix_prms()</a></code>, <code><a href="#topic+flex_special_dependency">flex_special_dependency()</a></code>
</p>

<hr>
<h2 id='load_fits_ids'>Load Estimates of a Fit Procedure</h2><span id='topic+load_fits_ids'></span><span id='topic+print.fits_ids_dm'></span>

<h3>Description</h3>

<p>This function loads the results of a fit procedure where a model was fitted
to multiple individuals (see <a href="#topic+estimate_model_ids">estimate_model_ids</a>). It is also the
function that creates an object of type <code>fits_ids_dm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_fits_ids(
  path = "drift_dm_fits",
  fit_procedure_name = "",
  detailed_info = FALSE,
  check_data = TRUE,
  progress = 2
)

## S3 method for class 'fits_ids_dm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_fits_ids_+3A_path">path</code></td>
<td>
<p>character, a path pointing to a folder or directory
containing the individual model fits.</p>
</td></tr>
<tr><td><code id="load_fits_ids_+3A_fit_procedure_name">fit_procedure_name</code></td>
<td>
<p>character, an optional name that identifies the
fit procedure that should be loaded</p>
</td></tr>
<tr><td><code id="load_fits_ids_+3A_detailed_info">detailed_info</code></td>
<td>
<p>logical, controls the amount of information displayed
in case multiple fit procedures were found and the user is prompted to
explicitly choose one</p>
</td></tr>
<tr><td><code id="load_fits_ids_+3A_check_data">check_data</code></td>
<td>
<p>logical, should the data be checked before passing them
back? This checks the observed data and the properties of the model. Default
is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="load_fits_ids_+3A_progress">progress</code></td>
<td>
<p>numerical, indicating if and how progress shall be depicted.
If 0, no progress is shown. If 1, basic infos about the checking progress
is shown. If 2, multiple progressbars are shown. Default is 2.</p>
</td></tr>
<tr><td><code id="load_fits_ids_+3A_x">x</code></td>
<td>
<p>an object of type <code>fits_ids_dm</code>, created when calling
<code>load_fits_ids</code></p>
</td></tr>
<tr><td><code id="load_fits_ids_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>with respect to the logic outlined in the details of
<a href="#topic+estimate_model_ids">estimate_model_ids</a> on the organization of fit procedures,
<code>path</code> could either point to a directory with (potentially) multiple fit
routines or to a specific folder with the individual fits. In either case
the intended location is recursively searched for files named
<code>drift_dm_fit_info.rds</code>.
</p>
<p>If the fit procedure was uniquely located, either because only one fit
routine was found in the intended location or because only one
<code>drift_dm_fit_info.rds</code> contains the optional identifier specified in
<code>fit_procedure_name</code>, then all individual model fits including the
information <code>fit_procedure_name</code> are loaded and returned.
</p>
<p>In case multiple fit procedures are identified, the user is
prompted with a <a href="utils.html#topic+menu">utils::menu</a>, listing information about the possible
candidates. The intended fit procedure can then interactively be chosen
by the user. The amount of displayed information is controlled via
<code>detailed_info</code>.
</p>
<p>The <code>print()</code> method for objects of type <code>fits_ids_dm</code> prints out basic
information about the fit procedure name, the fitted model, time of (last)
call, and the number of individual data sets.
</p>


<h3>Value</h3>

<p>For <code>load_fits_ids()</code>, an object of type <code>fits_ids_dm</code>, which essentially is
a list with two entries:
</p>

<ul>
<li> <p><code>drift_dm_fit_info</code>, containing a list of the main arguments when
<a href="#topic+estimate_model_ids">estimate_model_ids</a> was originally called, including
a time-stamp.
</p>
</li>
<li> <p><code>all_fits</code>, containing a list of all the modified/fitted <code>drift_dm</code>
objects. The list's entry are named according to the individuals'
identifier (i.e., <code>ID</code>).
</p>
</li></ul>

<p>For <code>print.fits_ids_dm()</code>, the supplied <code>fit_ids_dm</code> object <code>x</code> (invisible
return).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_model_ids">estimate_model_ids()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -------------------------------------------------------------------------
# We stored a fit procedure (matching with the example for
# estimate_model_ids()) within the package to easily access it here.
# -------------------------------------------------------------------------

# get the path to the fit procedures' location
# -&gt; if a user saved fit procedures in their working directory,
#    path_to would just be "drift_dm_fits" (see the default value of path)
path_to &lt;- file.path(
  system.file(package = "dRiftDM"), "drift_dm_fits"
)

# then load all the fits of a fit procedure
all_fits &lt;- load_fits_ids(path = path_to, fit_procedure_name = "example")
print(all_fits)
summary(all_fits)

</code></pre>

<hr>
<h2 id='logLik.drift_dm'>Extract Log-Likelihood for a drift_dm Object</h2><span id='topic+logLik.drift_dm'></span>

<h3>Description</h3>

<p>This method extracts the log-likelihood for a <code>drift_dm</code> object, ensuring
data is available and evaluating the model if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drift_dm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.drift_dm_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+drift_dm">drift_dm</a> object containing observed data</p>
</td></tr>
<tr><td><code id="logLik.drift_dm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logLik</code> object containing the log-likelihood value for the
<a href="#topic+drift_dm">drift_dm</a> object. This value has attributes for the number of
observations (<code>nobs</code>) and the number of model parameters (<code>df</code>).
</p>
<p>Returns <code>NULL</code> if observed data is not available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model and a data set for demonstration purpose
# (when creating the model, set the discretization to reasonable values)
a_model &lt;- dmc_dm(t_max = 1.5, dx = .0025, dt = .0025)
obs_data(a_model) &lt;- dmc_synth_data

# calculate the log-likelihood
logLik(a_model)

</code></pre>

<hr>
<h2 id='logLik.fits_ids_dm'>Extract Model Statistics for fits_ids_dm Object</h2><span id='topic+logLik.fits_ids_dm'></span><span id='topic+AIC.fits_ids_dm'></span><span id='topic+BIC.fits_ids_dm'></span>

<h3>Description</h3>

<p>These methods are wrappers to extract specific model fit statistics
(log-likelihood, AIC, BIC) for each model in a <code>fits_ids_dm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fits_ids_dm'
logLik(object, ...)

## S3 method for class 'fits_ids_dm'
AIC(object, ..., k = 2)

## S3 method for class 'fits_ids_dm'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.fits_ids_dm_+3A_object">object</code></td>
<td>
<p>a <code>fits_ids_dm</code> object (see <a href="#topic+estimate_model_ids">estimate_model_ids</a>)</p>
</td></tr>
<tr><td><code id="logLik.fits_ids_dm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="logLik.fits_ids_dm_+3A_k">k</code></td>
<td>
<p>numeric; penalty parameter for the AIC calculation.
Defaults to 2 (standard AIC).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function retrieves the relevant statistics by calling
<a href="#topic+calc_stats">calc_stats</a> with <code>type = "fit_stats"</code> and selects the columns
for <code>ID</code> and the required statistic.
</p>


<h3>Value</h3>

<p>An object of type <code>fit_stats</code> containing the respective statistic in
one column (named <code>Log_Like</code>, <code>AIC</code>, or <code>BIC</code>) and a corresponding <code>ID</code>
column.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">stats::AIC()</a></code>, <code><a href="stats.html#topic+AIC">stats::BIC()</a></code>, <a href="#topic+logLik.drift_dm">logLik.drift_dm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an auxiliary fits_ids object for demonstration purpose;
# such an object results from calling load_fits_ids
all_fits &lt;- get_example_fits_ids()

# AICs
AIC(all_fits)

# BICs
BIC(all_fits)

# Log-Likelihoods
logLik(all_fits)

# All unique and free parameters
coef(all_fits)

# Or all parameters across all conditions
coef(all_fits, select_unique = FALSE)

</code></pre>

<hr>
<h2 id='max_number_one_internal_entry'>Get the maximum number from an internal entry or flex_prms_obj
(internal docu)</h2><span id='topic+max_number_one_internal_entry'></span><span id='topic+get_number_prms'></span>

<h3>Description</h3>

<p>The entries of the internal list are either digits (0-x) or expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_number_one_internal_entry(one_internal_entry)

get_number_prms(flex_prms_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_number_one_internal_entry_+3A_one_internal_entry">one_internal_entry</code></td>
<td>
<p>one entry of multiple conditions</p>
</td></tr>
<tr><td><code id="max_number_one_internal_entry_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>a list stored as a flex_prms object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the largest digit in the entry or of the linear_list in
the supplied flex_prms_obj (0 if there are only
expressions). The largest number of the linear_list corresponds to the number
of model parameters.
</p>

<hr>
<h2 id='modify_flex_prms'>Set Instructions to a flex_prms object</h2><span id='topic+modify_flex_prms'></span><span id='topic+modify_flex_prms.drift_dm'></span><span id='topic+modify_flex_prms.flex_prms'></span>

<h3>Description</h3>

<p>Functions to carry out the &quot;instructions&quot; on how to modify a flex_prms
object, specified as a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_flex_prms(object, instr, ...)

## S3 method for class 'drift_dm'
modify_flex_prms(object, instr, ..., eval_model = FALSE)

## S3 method for class 'flex_prms'
modify_flex_prms(object, instr, ..., messaging = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_flex_prms_+3A_object">object</code></td>
<td>
<p>an object of type <code>drift_dm</code> or <code>flex_prms</code>.</p>
</td></tr>
<tr><td><code id="modify_flex_prms_+3A_instr">instr</code></td>
<td>
<p>a character string, specifying a set of instructions (see
Details).</p>
</td></tr>
<tr><td><code id="modify_flex_prms_+3A_...">...</code></td>
<td>
<p>further arguments passed forward to the respective method.</p>
</td></tr>
<tr><td><code id="modify_flex_prms_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating modifying the flex_prms object
(see <a href="#topic+re_evaluate_model">re_evaluate_model</a>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modify_flex_prms_+3A_messaging">messaging</code></td>
<td>
<p>logical, indicating if messages shall be displayed or not.
Can happen, for example, when setting a parameter value for a
specific condition, although the parameter values are assumed to be the
identical across conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modify_flex_prms</code> is a generic function. The default methods pass forward
a set of &quot;instructions&quot; to modify the (underlying) <a href="#topic+flex_prms">flex_prms</a>
object.
</p>
<p>These instructions are inspired by the model syntax of
the <code>lavaan</code> package. Note that
specifying multiple instructions is possible, but each instruction
has to be defined in its own line. Comments with '#' are possible, also
line continuations are possible, if the last symbol
is a &quot;+&quot;,&quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;(&quot;, or &quot;[&quot;.
The following instructions are implemented:
</p>
<p>The <strong>&quot;vary&quot;</strong> instruction:
</p>

<ul>
<li><p> Looks something like &quot;a ~ foo + bar&quot;
</p>
</li>
<li><p> This means that the parameter 'a' is allowed to vary independently for the
conditions 'foo' and 'bar'
</p>
</li>
<li><p> Thus, when estimating the model, the user will have independent values
for 'a' in conditions 'foo' and 'bar'
</p>
</li></ul>

<p>The <strong>&quot;restrain&quot;</strong> instruction:
</p>

<ul>
<li><p> Looks something like &quot;a ~! foo + bar &quot;
</p>
</li>
<li><p> This means that the parameter 'a' is assumed to be identical for the
conditions 'foo' and 'bar'
</p>
</li>
<li><p> Thus, when estimating the model, the user will have only a single value
for 'a' in conditions 'foo' and 'bar'
</p>
</li></ul>

<p>The <strong>&quot;set&quot;</strong> instruction:
</p>

<ul>
<li><p> Users may not always estimate a model directly but rather explore the
model behavior. In this case setting the value of a parameter is necessary.
</p>
</li>
<li><p> The corresponding instruction looks something like &quot;a ~ foo =&gt; 0.3&quot;
</p>
</li>
<li><p> This will set the value for 'a' in condition 'foo' to the value of 0.3
</p>
</li></ul>

<p>The <strong>&quot;fix&quot;</strong> instruction:
</p>

<ul>
<li><p> Oftentimes, certain parameters of a model are considered &quot;fixed&quot;, so that
they don't vary while the remaining parameters are estimated. An example
would be the shape parameter 'a' of DMC (see <a href="#topic+dmc_dm">dmc_dm</a>).
</p>
</li>
<li><p> The corresponding instruction looks something like &quot;a &lt;!&gt; foo + bar&quot;
</p>
</li>
<li><p> Usually, users want to call the &quot;set&quot; instruction prior or after the &quot;fix&quot;
instruction, to set the corresponding parameter to a certain value.
</p>
</li></ul>

<p>The <strong>&quot;special dependency&quot;</strong> instruction:
</p>

<ul>
<li><p> Sometimes, users want to allow one parameter to depend on another. For
instance, in DMC (see <a href="#topic+dmc_dm">dmc_dm</a>), the parameter A is positive in
the congruent condition, but negative in the incongruent condition. Thus,
parameters may have a 'special depencency' which can be expressed as an
equation.
</p>
</li>
<li><p> To define a special dependency, users can use the operation &quot;==&quot;.
The parameter that should have the dependency is on the left-hand side,
while the mathematical relationship to other parameters is defined on the
right-hand side.
</p>
</li>
<li><p> This then looks something like &quot;a ~ foo == -(a ~ bar)&quot;.
</p>
</li>
<li><p> This means that the parameter a in condition foo will always be
-1 * the parameter a in condition bar. Thus, if a in condition bar
has the value 5, then a in condition foo will be -5.
</p>
</li>
<li><p> The expression on the right-side can refer to any arbitrary
mathematical relation.
</p>
</li>
<li><p> Important: Make sure that each 'parameter ~ condition' combination on the
right-hand side of the equation are set in brackets.
</p>
</li>
<li><p> Another example: Parameter a in condition foo should be the mean of the
parameter b in conditions bar and baz; this would be the instruction
&quot;a ~ foo == 0.5*(b ~ bar) + 0.5*(b ~ baz)&quot;
</p>
</li></ul>

<p>The <strong>&quot;additional/custom parameter combination&quot;</strong> instruction:
</p>

<ul>
<li><p> Sometimes, users may want to combine multiple parameters to summarize
a certain property of the model. For example, in DMC (see <a href="#topic+dmc_dm">dmc_dm</a>),
the shape and rate parameter jointly determine the peak latency.
</p>
</li>
<li><p> To avoid having to calculate this manually, users can define &quot;custom&quot;
parameter combinations using the &quot;:=&quot; operation:
</p>
</li>
<li><p> An exemplary instruction might look like this:
&quot;peak_l := (a - 1) * tau&quot;
</p>
</li>
<li><p> Expressions and values that provide calculations for those parameters are
stored in a separate list <code>cust_prms</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>For <a href="#topic+drift_dm">drift_dm</a> objects, the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>
<p>For <a href="#topic+flex_prms">flex_prms</a>, the updated <a href="#topic+flex_prms">flex_prms</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flex_prms">flex_prms()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Modify a flex_prms object  directly ---------------------------
# create an auxiliary flex_prms object
a_flex_prms_obj &lt;- flex_prms(
  c(muc = 3, b = 0.5, non_dec = 0.3),
  conds = c("foo", "bar")
)

# then carry out some "instructions". Here (arbitrary operations):
# 1.) Consider b as fixed
# 2.) Let muc vary independently for the conditions foo and bar
# 3.) Set non_dec in condition bar to be half as large as non_dec in
#     condition bar
instr &lt;-
  "b &lt;!&gt;
 muc ~
 non_dec ~ bar == (non_dec ~ foo) / 2
"
modify_flex_prms(object = a_flex_prms_obj, instr = instr)


# Example 2: Modify a flex_prms object stored inside a drift_dm object -----
a_model &lt;- ratcliff_dm() # get a model for demonstration purpose
modify_flex_prms(object = a_model, instr = "muc ~ =&gt; 4")

</code></pre>

<hr>
<h2 id='mu_constant'>Constant Drift Rate</h2><span id='topic+mu_constant'></span>

<h3>Description</h3>

<p>Constant Drift Rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_constant(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_constant_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing muc</p>
</td></tr>
<tr><td><code id="mu_constant_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="mu_constant_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="mu_constant_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="mu_constant_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as t_vec with the drift rate for
each element of the vector.
</p>

<hr>
<h2 id='mu_dmc'>Drift Rate for DMC</h2><span id='topic+mu_dmc'></span>

<h3>Description</h3>

<p>Provides the drift rate of the superimposed decision process. That is
the derivative of the rescaled gamma function plus a constant drift rate for
the controlled process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_dmc(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_dmc_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing muc, tau, a, A</p>
</td></tr>
<tr><td><code id="mu_dmc_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="mu_dmc_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="mu_dmc_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="mu_dmc_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>provides the first derivative of the superimposed process with
respect to t_vec.
</p>

<hr>
<h2 id='mu_int_constant'>Integral of Constant Drift Rate</h2><span id='topic+mu_int_constant'></span>

<h3>Description</h3>

<p>Integral of Constant Drift Rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_int_constant(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_int_constant_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing muc</p>
</td></tr>
<tr><td><code id="mu_int_constant_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="mu_int_constant_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="mu_int_constant_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="mu_int_constant_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector calculated as t_vec*muc
</p>

<hr>
<h2 id='mu_int_dmc'>Integral of DMC's Drift Rate</h2><span id='topic+mu_int_dmc'></span>

<h3>Description</h3>

<p>Provides the integral of the drift rate of the superimposed decision process.
This is the sum of the rescaled gamma function and the linear function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_int_dmc(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_int_dmc_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing muc, tau, a, A</p>
</td></tr>
<tr><td><code id="mu_int_dmc_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="mu_int_dmc_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="mu_int_dmc_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="mu_int_dmc_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>provides the scaled gamma distribution function of the superimposed
process for each time step in t_vec.
</p>

<hr>
<h2 id='mu_ssp'>Drift Rate for SSP</h2><span id='topic+mu_ssp'></span>

<h3>Description</h3>

<p>Provides the drift rate for the SSP model. That is, the sum of attention
attributed to the flankers and central target, scaled by the perceptual
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_ssp(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_ssp_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters, containing p, sd_0, r, sign</p>
</td></tr>
<tr><td><code id="mu_ssp_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="mu_ssp_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="mu_ssp_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="mu_ssp_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>provides the drift rate for SSP with respect to t_vec
</p>

<hr>
<h2 id='new_drift_dm'>Create A DDM model - Internal</h2><span id='topic+new_drift_dm'></span>

<h3>Description</h3>

<p>This function takes all objects/vectors to create a ddm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_drift_dm(
  flex_prms_obj,
  prms_solve,
  solver,
  comp_funs,
  subclass,
  b_coding = NULL,
  obs_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_drift_dm_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>flex_prms object</p>
</td></tr>
<tr><td><code id="new_drift_dm_+3A_prms_solve">prms_solve</code></td>
<td>
<p>vector with sigma, t_max, dt, dx, nt, nx</p>
</td></tr>
<tr><td><code id="new_drift_dm_+3A_solver">solver</code></td>
<td>
<p>string (e.g., kfe)</p>
</td></tr>
<tr><td><code id="new_drift_dm_+3A_comp_funs">comp_funs</code></td>
<td>
<p>a list of component functions</p>
</td></tr>
<tr><td><code id="new_drift_dm_+3A_subclass">subclass</code></td>
<td>
<p>string with model info label set for child class</p>
</td></tr>
<tr><td><code id="new_drift_dm_+3A_b_coding">b_coding</code></td>
<td>
<p>optional list with b_coding (e.g., drift_dm_default_b_coding)</p>
</td></tr>
<tr><td><code id="new_drift_dm_+3A_obs_data">obs_data</code></td>
<td>
<p>optional data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not perform any input checks and just assembles all
arguments. Pre-wrangling of each argument is done in <code><a href="#topic+drift_dm">drift_dm()</a></code>.
Checks are done done with <code><a href="#topic+validate_drift_dm">validate_drift_dm()</a></code>, called in
<code><a href="#topic+drift_dm">drift_dm()</a></code>.
</p>


<h3>Value</h3>

<p>List with flex_prms_obj, prms_solve, solver, comp_funs. Attributes: class
info and b_encoding info. If obs_data is not null, then list of observed rts
see <code><a href="#topic+obs_data">obs_data()</a></code>.
</p>

<hr>
<h2 id='new_stats_dm'>Create a New stats_dm Object</h2><span id='topic+new_stats_dm'></span>

<h3>Description</h3>

<p><code>new_stats_dm</code> initializes a <code>stats_dm</code> object to label statistic types and
store necessary attributes for the custom methods (such as <code style="white-space: pre;">&#8288;plot_*&#8288;</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_stats_dm(stat_df, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_stats_dm_+3A_stat_df">stat_df</code></td>
<td>
<p>a <code>data.frame</code>, containing calculated statistics to be
encapsulated within the <code>stats_dm</code> class.</p>
</td></tr>
<tr><td><code id="new_stats_dm_+3A_type">type</code></td>
<td>
<p>a character string, specifying the type of statistic provided by
<code>stat_df</code>. Valid options include <code>"cafs"</code>, <code>"quantiles"</code>, <code>"delta_funs"</code>,
and <code>"fit_stats"</code>.</p>
</td></tr>
<tr><td><code id="new_stats_dm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to set attributes. For <code>"cafs"</code>,
<code>"quantiles"</code>, and <code>"delta_funs"</code>, a <code>b_coding</code> attribute is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>new_stats_dm</code> sets up the <code>stat_df</code> object by assigning it the class
<code>stats_dm</code>, along with additional classes based on the specified <code>type</code>.
For&quot;cafs&quot;, &quot;quantiles&quot;, &quot;delta_funs&quot;, this will be c(<code style="white-space: pre;">&#8288;&lt;type&gt;&#8288;</code>, &quot;sum_dist&quot;,
&quot;stats_dm&quot;, &quot;data.frame&quot;)&quot;. For fit statistics, this will be c(&quot;fit_stats&quot;,
&quot;stats_dm&quot;, &quot;data.frame&quot;)&quot;.
</p>
<p>For Conditional Accuracy Functions (CAFs), Quantiles, and Delta Functions,
the function requires a <code>b_coding</code> argument, which specifies boundary coding
details and is set as an attribute.
</p>
<p>The function performs validation through <a href="#topic+validate_stats_dm">validate_stats_dm</a> to
ensure that the <code>stats_dm</code> object is well formatted.
</p>


<h3>Value</h3>

<p>An object of class <code>stats_dm</code>, with additional classes and attributes
depending on <code>type</code>.
</p>

<hr>
<h2 id='nobs.drift_dm'>Get the Number of Observations for a drift_dm Object</h2><span id='topic+nobs.drift_dm'></span>

<h3>Description</h3>

<p>This method retrieves the total number of observations in the <code>obs_data</code>
list of a <code>drift_dm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drift_dm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.drift_dm_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+drift_dm">drift_dm</a> object, which contains the observed data
in <code>object$obs_data</code>.</p>
</td></tr>
<tr><td><code id="nobs.drift_dm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function iterates over each element in <code>object$obs_data</code>, counts
the entries in each nested component, and returns the cumulative sum as the
total observation count.
</p>
<p>It was written to provide an <code>nobs</code> method for calculating the log-likelihood
(<a href="stats.html#topic+logLik">logLik</a>), AIC (<a href="stats.html#topic+AIC">stats::AIC</a>), and BIC (<a href="stats.html#topic+AIC">stats::BIC</a>) statistics
for objects of type <a href="#topic+drift_dm">drift_dm</a>.
</p>


<h3>Value</h3>

<p>An integer representing the total number of observations across
all conditions in <code>object$obs_data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model and data set for demonstration purpose
a_model &lt;- dmc_dm()
obs_data(a_model) &lt;- dmc_synth_data

# then get the number of observations by accessing the model
nobs(a_model)

# same number of observations as in the original data set
nrow(dmc_synth_data)

</code></pre>

<hr>
<h2 id='nt_constant'>Constant Non-Decision time</h2><span id='topic+nt_constant'></span>

<h3>Description</h3>

<p>A dirac delta on &quot;non_dec&quot;, to provide a constant non-decision time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt_constant(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nt_constant_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters; containing &quot;non_dec&quot;</p>
</td></tr>
<tr><td><code id="nt_constant_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="nt_constant_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="nt_constant_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="nt_constant_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as t_vec with zeros, except for the
element matching with &quot;non_dec&quot; with respect to &quot;t_vec&quot;
</p>

<hr>
<h2 id='nt_truncated_normal'>Truncated Normally-Distributed Non-Decision Time</h2><span id='topic+nt_truncated_normal'></span>

<h3>Description</h3>

<p>Truncated Normally-Distributed Non-Decision Time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt_truncated_normal(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nt_truncated_normal_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters; including &quot;non_dec&quot; and
&quot;sd_non_dec&quot;</p>
</td></tr>
<tr><td><code id="nt_truncated_normal_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="nt_truncated_normal_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="nt_truncated_normal_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="nt_truncated_normal_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the PDF of a truncated normal distribution for t_vec, with
mean &quot;non_dec&quot; and standard deviation &quot;sd_non_dec&quot;. Lower truncation is 0.
Upper truncation is max(t_vec)
</p>

<hr>
<h2 id='nt_uniform'>Uniform Non-Decision Time</h2><span id='topic+nt_uniform'></span>

<h3>Description</h3>

<p>Uniform Non-Decision Time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt_uniform(prms_model, prms_solve, t_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nt_uniform_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters; including &quot;non_dec&quot; and
&quot;range_non_dec&quot;</p>
</td></tr>
<tr><td><code id="nt_uniform_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="nt_uniform_+3A_t_vec">t_vec</code></td>
<td>
<p>time space</p>
</td></tr>
<tr><td><code id="nt_uniform_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="nt_uniform_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the PDF of a uniform distribution for t_vec, centered around
&quot;non_dec&quot; and with a range of &quot;range_non_dec&quot;.
</p>

<hr>
<h2 id='obs_data_to_rt_lists'>Disassemble an Observed Data set</h2><span id='topic+obs_data_to_rt_lists'></span>

<h3>Description</h3>

<p>Takes a data.frame with columns RT, Cond, and <code>column</code> matching with
<a href="#topic+b_coding">b_coding</a>, and disassembles it into a list of rts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs_data_to_rt_lists(obs_data, b_coding = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obs_data_to_rt_lists_+3A_obs_data">obs_data</code></td>
<td>
<p>a data.frame wth columns RT, Cond, and <code>column</code> matching
<code>b_coding</code></p>
</td></tr>
<tr><td><code id="obs_data_to_rt_lists_+3A_b_coding">b_coding</code></td>
<td>
<p>a boundary coding list (see <a href="#topic+b_coding">b_coding</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>performs checks on <code>b_coding</code> (<a href="#topic+check_b_coding">check_b_coding</a>) and
<code>obs_data</code> (<a href="#topic+check_raw_data">check_raw_data</a>) before disassembling the data set.
</p>


<h3>Value</h3>

<p>a list of rts with entries
</p>

<ul>
<li><p> rts_u -&gt; containing a list of numeric vectors, with names according to the
values in Cond
</p>
</li>
<li><p> rts_l -&gt; containing a list of numeric vectors, with names according to the
values in Cond
</p>
</li></ul>


<hr>
<h2 id='obs_data+26lt+3B-'>The Observed Data</h2><span id='topic+obs_data+3C-'></span><span id='topic+obs_data+3C-.drift_dm'></span><span id='topic+obs_data'></span><span id='topic+obs_data.drift_dm'></span><span id='topic+obs_data.fits_ids_dm'></span>

<h3>Description</h3>

<p>Functions to get or set the &quot;observed data&quot; of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs_data(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
obs_data(object, ..., eval_model = FALSE) &lt;- value

obs_data(object, ...)

## S3 method for class 'drift_dm'
obs_data(object, ..., messaging = TRUE)

## S3 method for class 'fits_ids_dm'
obs_data(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obs_data+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code>
(see <a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="obs_data+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments passed down to the specific method.</p>
</td></tr>
<tr><td><code id="obs_data+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a> which provides three columns: (1) <code>RT</code> for
the response times, (2) a column for boundary coding according to the
model's <code><a href="#topic+b_coding">b_coding()</a></code>, (3) <code>Cond</code> for specifying the conditions.</p>
</td></tr>
<tr><td><code id="obs_data+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating the solver settings (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="obs_data+2B26lt+2B3B-_+3A_messaging">messaging</code></td>
<td>
<p>logical, indicating if messages shall be displayed or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>obs_data()</code> is a generic accessor function, and <code style="white-space: pre;">&#8288;obs_data&lt;-()&#8288;</code> is a
generic replacement function. The default methods get and set the &quot;observed
data&quot;. Their behavior, however, may be a bit unexpected.
</p>
<p>In <a href="#topic+drift_dm">drift_dm</a> objects, the observed data are not stored as a
<a href="base.html#topic+data.frame">data.frame</a>. Instead, any supplied observed data set is disassembled into
RTs for the upper and lower boundary and with respect to the different
conditions (ensures more speed and easier programming in the depths of the
package). Yet, <code>obs_data()</code> returns a <code>data.frame</code> for <a href="#topic+drift_dm">drift_dm</a>
objects. This implies that <code>obs_data()</code> does not merely access
the observed data, but re-assembles it. Consequently, a returned <a href="base.html#topic+data.frame">data.frame</a>
for the observed data is likely sorted differently than the <a href="base.html#topic+data.frame">data.frame</a> that
was originally set to the model via <code style="white-space: pre;">&#8288;obs_data&lt;-()&#8288;</code>. Also, when the originally
supplied data set provided more conditions than the model, the unused
conditions will not be part of the returned <a href="base.html#topic+data.frame">data.frame</a>.
</p>
<p>For <code>fits_ids_dm</code> (see <a href="#topic+load_fits_ids">load_fits_ids</a>), the observed data are
stored as a <a href="base.html#topic+data.frame">data.frame</a> in the general fit procedure info. This is the
<a href="base.html#topic+data.frame">data.frame</a> that <code>obs_data()</code> will return. Thus, the returned <a href="base.html#topic+data.frame">data.frame</a>
will match with the <a href="base.html#topic+data.frame">data.frame</a> that was initially supplied to
<a href="#topic+estimate_model_ids">estimate_model_ids</a>, although with unused conditions being dropped.
</p>
<p>In theory, it is possible to update parts of the &quot;observed data&quot;. However,
because <code>obs_data()</code> returns a re-assembled <a href="base.html#topic+data.frame">data.frame</a> for
<a href="#topic+drift_dm">drift_dm</a> objects, great care has to be taken with respect to the
ordering of the argument <code>value</code>. A message is displayed to remind the user
that the returned <a href="base.html#topic+data.frame">data.frame</a> may be sorted differently than expected.
</p>


<h3>Value</h3>

<p>For <code>obs_data()</code> a (re-assembled) <a href="base.html#topic+data.frame">data.frame</a> of the observed data. A
message is displayed to remind the user that the returned <a href="base.html#topic+data.frame">data.frame</a> may
be sorted differently than expected.
</p>
<p>For <code style="white-space: pre;">&#8288;obs_data&lt;-()&#8288;</code> the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>


<h3>Note</h3>

<p>There is only a replacement function for <a href="#topic+drift_dm">drift_dm</a> objects. This is
because replacing the observed data after the model has been fitted (i.e.,
for a <code>fits_ids_dm</code> object) doesn't make sense.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set some data to a model -------------------------------------------------
my_model &lt;- dmc_dm() # DMC is pre-built and directly available
# synthetic data suitable for DMC; comes with dRiftDM
some_data &lt;- dmc_synth_data
obs_data(my_model) &lt;- some_data

# Extract data from a model ------------------------------------------------
head(obs_data(my_model))

# Important: ---------------------------------------------------------------
# The returned data.frame may be sorted differently than the one initially
# supplied.
some_data &lt;- some_data[sample(1:nrow(some_data)), ] #' # shuffle the data set
obs_data(my_model) &lt;- some_data
all.equal(obs_data(my_model), some_data)
# so don't do obs_data(my_model)["Cond"] &lt;- ...

# Addition: ----------------------------------------------------------------
# accessor method also available for fits_ids_dm objects
# (see estimate_model_ids)
# get an exemplary fits_ids_dm object
fits &lt;- get_example_fits_ids()
head(obs_data(fits))

</code></pre>

<hr>
<h2 id='pdfs'>Access the Probability Density Functions of a Model</h2><span id='topic+pdfs'></span><span id='topic+pdfs.drift_dm'></span>

<h3>Description</h3>

<p>Functions to obtain the probability density functions (PDFs) of a model.
These PDFs represent the first-passage-time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfs(object, ...)

## S3 method for class 'drift_dm'
pdfs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdfs_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a>.</p>
</td></tr>
<tr><td><code id="pdfs_+3A_...">...</code></td>
<td>
<p>additional arguments passed down to the specific method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model has not been evaluated, <code><a href="#topic+re_evaluate_model">re_evaluate_model()</a></code> is
called before returning the PDFs.
</p>


<h3>Value</h3>

<p>A list with named elements corresponding to the conditions of a model (see
<code><a href="#topic+conds">conds()</a></code>). Each of these elements is another list, containing the
entries <code>pdf_u</code> and <code>pdf_l</code>, which are numeric vectors for the PDFs of the
upper and lower boundary, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>, <code><a href="#topic+re_evaluate_model">re_evaluate_model()</a></code>,
<code><a href="#topic+conds">conds()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model for demonstration purpose
a_model &lt;- dmc_dm(dx = .0025, dt = .0025)
str(pdfs(a_model))

</code></pre>

<hr>
<h2 id='plot.cafs'>Plot Conditional Accuracy Functions (CAFs)</h2><span id='topic+plot.cafs'></span>

<h3>Description</h3>

<p>This function generates a plot of Conditional Accuracy Functions (CAFs). It
can display observed and predicted values, making it useful for assessing
model fit or exploring observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cafs'
plot(
  x,
  ...,
  conds = NULL,
  col = NULL,
  xlim = NULL,
  ylim = c(0, 1),
  xlab = "Bins",
  ylab = NULL,
  pch = 21,
  lty = 1,
  type = "l",
  legend = NULL,
  legend_pos = "bottomright"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cafs_+3A_x">x</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, containing CAFs, typically resulting from a call
to <a href="#topic+calc_stats">calc_stats</a>.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <a href="base.html#topic+plot">plot</a>, <a href="graphics.html#topic+points">graphics::points</a>,
and <a href="graphics.html#topic+legend">graphics::legend</a> functions. Oftentimes, this will (unfortunately) lead
to an error due to a clash of arguments.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_conds">conds</code></td>
<td>
<p>character vector, specifying the conditions to plot.
Defaults to all unique conditions.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_col">col</code></td>
<td>
<p>Character vector, specifying colors for each condition. If a
single color is provided, it will be repeated for each condition.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_xlim">xlim</code>, <code id="plot.cafs_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, specifying the x and y axis
limits.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_xlab">xlab</code>, <code id="plot.cafs_+3A_ylab">ylab</code></td>
<td>
<p>character, labels for the x and y axes.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_pch">pch</code></td>
<td>
<p>integer, specifying the plotting symbol for observed data points.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_lty">lty</code></td>
<td>
<p>integer, line type for the predicted CAFs.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_type">type</code></td>
<td>
<p>character, type of plot for the predicted CAFs.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_legend">legend</code></td>
<td>
<p>character vector, specifying legend labels corresponding to
the conditions in the CAFs. Defaults to the condition names.</p>
</td></tr>
<tr><td><code id="plot.cafs_+3A_legend_pos">legend_pos</code></td>
<td>
<p>character, specifying the position of the legend on the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.cafs</code> function allows for a quick investigation of CAFs, including
options for color, symbols, and line types for different data sources
(observed vs. predicted). When the supplied <a href="base.html#topic+data.frame">data.frame</a> includes multiple
IDs, CAFs are aggregated across IDs before plotting.
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Only model predictions ---------------------------------------
# get a cafs data.frame for demonstration purpose
a_model &lt;- dmc_dm(t_max = 1.5, dt = .0025, dx = .0025)
cafs &lt;- calc_stats(a_model, type = "cafs")

# call the plot function with default values
plot(cafs)

# make the plot a little bit more pretty
plot(cafs,
  col = c("green", "red"),
  ylim = c(0.5, 1)
)

# Example 2: Model predictions and observed data --------------------------
obs_data(a_model) &lt;- dmc_synth_data
cafs &lt;- calc_stats(a_model, type = "cafs")
plot(cafs)
# Note: The model was not fitted to the data set, thus observed data and
# model predictions don't match


# Example 3: Only observed data -------------------------------------------
cafs &lt;- calc_stats(dmc_synth_data, type = "cafs")
plot(cafs)

</code></pre>

<hr>
<h2 id='plot.delta_funs'>Plot Delta Functions</h2><span id='topic+plot.delta_funs'></span>

<h3>Description</h3>

<p>This function generates a plot of delta functions, displaying observed and
predicted values, which can be useful for evaluating model fit or exploring
data characteristics.
</p>
<p>If the data contains multiple IDs, delta functions are aggregated across IDs
before plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delta_funs'
plot(
  x,
  ...,
  dv = NULL,
  col = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = "RT [s]",
  ylab = expression(Delta),
  pch = 21,
  lty = 1,
  type = "l",
  legend = NULL,
  legend_pos = "topright"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.delta_funs_+3A_x">x</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, containing delta functions, typically resulting from
a call to <a href="#topic+calc_stats">calc_stats</a>.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <a href="base.html#topic+plot">plot</a>, <a href="graphics.html#topic+points">graphics::points</a>,
and <a href="graphics.html#topic+legend">graphics::legend</a> functions. Oftentimes, this will (unfortunately) lead
to an error due to a clash of arguments.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_dv">dv</code></td>
<td>
<p>character vector, specifying the delta functions to plot. Defaults
to all columns beginning with &quot;Delta_&quot; in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_col">col</code></td>
<td>
<p>character vector, specifying colors for each delta function. If a
single color is provided, it will be repeated for each function.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_xlim">xlim</code>, <code id="plot.delta_funs_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, specifying the x and y axis
limits.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_xlab">xlab</code>, <code id="plot.delta_funs_+3A_ylab">ylab</code></td>
<td>
<p>character, labels for the x and y axes.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_pch">pch</code></td>
<td>
<p>integer, specifying the plotting symbol for observed data points.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_lty">lty</code></td>
<td>
<p>integer, line type for the predicted delta functions.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_type">type</code></td>
<td>
<p>character, type of plot for the predicted delta functions.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_legend">legend</code></td>
<td>
<p>character vector, specifying legend labels corresponding to
the delta functions. Defaults to the way functions were derived.</p>
</td></tr>
<tr><td><code id="plot.delta_funs_+3A_legend_pos">legend_pos</code></td>
<td>
<p>character, specifying the position of the legend on the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.delta_funs</code> function provides an easy way to investigate delta
functions, allowing for customization in color, symbols, and line types for
different data sources (observed vs. predicted). If multiple IDs are present
in the data, delta functions are aggregated across IDs before plotting.
By default, <code>ylim</code> is set to twice the range of the delta values to provide
more context.
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Only model predictions ---------------------------------------
# get a delta function data.frame for demonstration purpose
a_model &lt;- dmc_dm(t_max = 1.5, dt = .0025, dx = .0025)
deltas &lt;- calc_stats(
  a_model,
  type = "delta_funs",
  minuends = "incomp",
  subtrahends = "comp"
)

# call the plot function with default values
plot(deltas)

# modify the plot
plot(deltas,
  col = c("black"),
  lty = 2,
  xlim = c(0.2, 0.65)
)

# Example 2: Model predictions and observed data --------------------------
obs_data(a_model) &lt;- dmc_synth_data
deltas &lt;- calc_stats(
  a_model,
  type = "delta_funs",
  minuends = "incomp",
  subtrahends = "comp"
)
plot(deltas)
# Note: The model was not fitted to the data set, thus observed data and
# model predictions don't match


# Example 3: Only observed data -------------------------------------------
deltas &lt;- calc_stats(
  dmc_synth_data,
  type = "delta_funs",
  minuends = "incomp",
  subtrahends = "comp"
)
plot(deltas)

</code></pre>

<hr>
<h2 id='plot.drift_dm'>Plot Components of a Drift Diffusion Model</h2><span id='topic+plot.drift_dm'></span>

<h3>Description</h3>

<p>This function generates plots for all components of a drift diffusion model
(DDM), such as drift rate, boundary, and starting condition. Each component
is plotted against the time or evidence space, allowing for visual inspection
of the model's behavior across different conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drift_dm'
plot(
  x,
  ...,
  conds = NULL,
  col = NULL,
  xlim = NULL,
  legend = NULL,
  legend_pos = "topright",
  mfrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.drift_dm_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward.</p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_conds">conds</code></td>
<td>
<p>character vector, specifying conditions to plot. Defaults to all
conditions in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_col">col</code></td>
<td>
<p>character vector, specifying colors for each condition. If a
single color is provided, it will be repeated for each condition.</p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_xlim">xlim</code></td>
<td>
<p>numeric vector of length 2, specifying the x-axis limits for
components related to the time space.</p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_legend">legend</code></td>
<td>
<p>character vector, specifying legend labels corresponding to the
conditions.</p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_legend_pos">legend_pos</code></td>
<td>
<p>character, specifying the position of the legend on the
plot (e.g., <code>"topright"</code>).</p>
</td></tr>
<tr><td><code id="plot.drift_dm_+3A_mfrow">mfrow</code></td>
<td>
<p>an optional numeric vector of length 2, specifying the number of
rows and columns for arranging multiple panels in a single plot. If <code>NULL</code>
(default), <code>mfrow</code> will be <code>c(3,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.drift_dm</code> function provides an overview of key DDM components,
which include:
</p>

<ul>
<li> <p><code>mu_fun</code>: Drift rate over time.
</p>
</li>
<li> <p><code>mu_int_fun</code>: Integrated drift rate over time.
</p>
</li>
<li> <p><code>x_fun</code>: Starting condition as a density across evidence values.
</p>
</li>
<li> <p><code>b_fun</code>: Boundary values over time.
</p>
</li>
<li> <p><code>dt_b_fun</code>: Derivative of the boundary function over time.
</p>
</li>
<li> <p><code>nt_fun</code>: Non-decision time as a density over time.
</p>
</li></ul>

<p>For each component, if multiple conditions are specified, they will be
plotted using different colors as specified in <code>color</code>.
</p>
<p>When the evaluation of a model component fails, the respective component
will not be plotted, but no warning is thrown.
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot the component functions of the Ratcliff DDM
plot(ratcliff_dm())
plot(ratcliff_dm(var_non_dec = TRUE))
# Note: the variability in the drift rate for the Ratcliff DDM
# is not plotted! This is because it is not actually stored as a component
# function.

# plot the component functions of the DMC model
plot(dmc_dm(), col = c("green", "red"))

</code></pre>

<hr>
<h2 id='plot.quantiles'>Plot Quantiles</h2><span id='topic+plot.quantiles'></span>

<h3>Description</h3>

<p>This function generates a plot of quantiles. It can display observed and
predicted values, making it useful for assessing model fit or exploring
observed data distributions.
</p>
<p>If the data contains multiple IDs, quantiles are aggregated across IDs
before plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quantiles'
plot(
  x,
  ...,
  conds = NULL,
  dv = NULL,
  col = NULL,
  xlim = NULL,
  ylim = c(0, 1),
  xlab = "RT [s]",
  ylab = "F(RT)",
  pch = 21,
  lty = 1,
  type = "l",
  legend = NULL,
  legend_pos = "bottomright"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.quantiles_+3A_x">x</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, containing quantiles, typically resulting from a
call to <a href="#topic+calc_stats">calc_stats</a>.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <a href="base.html#topic+plot">plot</a>, <a href="graphics.html#topic+points">graphics::points</a>,
and <a href="graphics.html#topic+legend">graphics::legend</a> functions. Oftentimes, this will (unfortunately) lead
to an error due to a clash of arguments.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_conds">conds</code></td>
<td>
<p>character vector, specifying the conditions to plot. Defaults to
all unique conditions.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_dv">dv</code></td>
<td>
<p>character, specifying the quantiles to plot. Defaults to
quantiles derived from the upper boundary.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_col">col</code></td>
<td>
<p>character vector, specifying colors for each condition. If a
single color is provided, it will be repeated for each condition.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_xlim">xlim</code>, <code id="plot.quantiles_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, specifying the x and y axis
limits.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_xlab">xlab</code>, <code id="plot.quantiles_+3A_ylab">ylab</code></td>
<td>
<p>character, labels for the x and y axes.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_pch">pch</code></td>
<td>
<p>integer, specifying the plotting symbol for observed data points.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_lty">lty</code></td>
<td>
<p>integer, line type for the predicted quantiles.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_type">type</code></td>
<td>
<p>character, type of plot for the predicted quantiles.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_legend">legend</code></td>
<td>
<p>character vector, specifying legend labels corresponding to
the conditions in the quantiles. Defaults to the condition names.</p>
</td></tr>
<tr><td><code id="plot.quantiles_+3A_legend_pos">legend_pos</code></td>
<td>
<p>character, specifying the position of the legend on the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.quantiles</code> function allows for a quick investigation of quantiles,
including options for color, symbols, and line types for different data
sources (observed vs. predicted). When the supplied <a href="base.html#topic+data.frame">data.frame</a> includes
multiple IDs, quantiles are aggregated across IDs before plotting.
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Only model predictions ---------------------------------------
# get a quantiles data.frame for demonstration purpose
a_model &lt;- dmc_dm(t_max = 1.5, dt = .0025, dx = .0025)
quantiles &lt;- calc_stats(a_model, type = "quantiles")

# call the plot function with default values
plot(quantiles)

# make the plot a little bit more pretty
plot(quantiles,
  col = c("green", "red"),
  xlim = c(0.2, 0.6),
  ylab = "Quantile Level",
  xlab = "Response Times [s]"
)

# Example 2: Model predictions and observed data --------------------------
obs_data(a_model) &lt;- dmc_synth_data
quantiles &lt;- calc_stats(a_model, type = "quantiles")
plot(quantiles)
# Note: The model was not fitted to the data set, thus observed data and
# model predictions don't match


# Example 3: Only observed data -------------------------------------------
quantiles &lt;- calc_stats(dmc_synth_data, type = "quantiles")
plot(quantiles)

</code></pre>

<hr>
<h2 id='plot.stats_dm_list'>Plot Multiple Statistics</h2><span id='topic+plot.stats_dm_list'></span>

<h3>Description</h3>

<p>This function iterates over a list of statistics data, resulting from a call
to <code><a href="#topic+calc_stats">calc_stats()</a></code>, and subsequently plots each statistic. It allows
for flexible arrangement of multiple plots on a single graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stats_dm_list'
plot(x, ..., mfrow = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.stats_dm_list_+3A_x">x</code></td>
<td>
<p>an object of type <code>stats_dm_list</code>, which is essentially a list
multiple statistics, resulting from a call to <code><a href="#topic+calc_stats">calc_stats()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.stats_dm_list_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <a href="base.html#topic+plot">plot</a> function for each
individual <code>stats_dm</code> object in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.stats_dm_list_+3A_mfrow">mfrow</code></td>
<td>
<p>an optional numeric vector of length 2, specifying the number of
rows and columns for arranging multiple panels in a single plot
(e.g., <code>c(1, 3)</code>). Plots are provided sequentially if <code>NULL</code> (default),
using the current graphics layout of a user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot.stats_dm_list()</code> function is &quot;merely&quot; a wrapper. All plotting
is done by the respective <code>plot()</code> methods. If <code>dRiftDM</code> doesn't provide a
<code>plot()</code> method for an object stored in <code>x</code>, the respective entry is
skipped and a message is displayed.
</p>
<p>When users want more control over each plot, it is best to call the
<code>plot()</code> function separately for each statistic in the list
(e.g., <code>plot(x$cafs)</code>; <code>plot(x$quantiles)</code>)
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cafs">plot.cafs()</a></code>, <code><a href="#topic+plot.quantiles">plot.quantiles()</a></code>,
<code><a href="#topic+plot.delta_funs">plot.delta_funs()</a></code>, <code><a href="#topic+calc_stats">calc_stats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a list of statistics for demonstration purpose
all_fits &lt;- get_example_fits_ids()
stats &lt;- calc_stats(all_fits, type = c("cafs", "quantiles"))

# then call the plot function.
plot(stats, mfrow = c(1, 2))

</code></pre>

<hr>
<h2 id='plot.traces_dm_list'>Plot Traces of a Drift Diffusion Model</h2><span id='topic+plot.traces_dm_list'></span><span id='topic+plot.traces_dm'></span>

<h3>Description</h3>

<p>Creates a basic plot showing simulated traces (simulated evidence
accumulation processes) from a drift diffusion model. Such plots are useful
for exploring and testing model behavior, allowing users to visualize the
traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traces_dm_list'
plot(
  x,
  ...,
  col = NULL,
  col_b = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = "Time",
  ylab = "Evidence",
  lty = 1,
  type = "l",
  legend = NULL,
  legend_pos = "topright"
)

## S3 method for class 'traces_dm'
plot(
  x,
  ...,
  col = NULL,
  col_b = NULL,
  xlim = NULL,
  ylim = NULL,
  xlab = "Time",
  ylab = "Evidence",
  lty = 1,
  type = "l"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.traces_dm_list_+3A_x">x</code></td>
<td>
<p>an object of type <code>traces_dm_list</code> or <code>traces_dm</code>, containing the
traces to be plotted, resulting from a call to <a href="#topic+simulate_traces">simulate_traces</a>.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <a href="base.html#topic+plot">plot</a>, <a href="graphics.html#topic+points">graphics::points</a>,
and <a href="graphics.html#topic+legend">graphics::legend</a> functions. Oftentimes, this will (unfortunately) lead
to an error due to a clash of arguments.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_col">col</code></td>
<td>
<p>character, vector of colors for the evidence accumulation traces,
one per condition. Defaults to a rainbow palette if not specified.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_col_b">col_b</code></td>
<td>
<p>character, a vector of colors for the boundary lines.
Defaults to black for all conditions.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_xlim">xlim</code>, <code id="plot.traces_dm_list_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, specifying the x and y axis
limits.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_xlab">xlab</code>, <code id="plot.traces_dm_list_+3A_ylab">ylab</code></td>
<td>
<p>character, labels for the x and y axes.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_lty">lty</code></td>
<td>
<p>integer, line type for both the traces and boundary lines.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_type">type</code></td>
<td>
<p>character, type of plot to use for traces and boundaries.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_legend">legend</code></td>
<td>
<p>character vector, specifying legend labels, corresponding to
the conditions in the traces. Defaults to the condition names.</p>
</td></tr>
<tr><td><code id="plot.traces_dm_list_+3A_legend_pos">legend_pos</code></td>
<td>
<p>character, specifying the position of the legend on the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.traces_dm_list()</code> iterates over all conditions and plots the traces.
It includes a legend with condition labels.
</p>
<p><code>plot_traces_dm</code> only plots the traces provided (i.e., traces for one
condition)
</p>
<p>Boundaries and traces are color-coded according to <code>col</code> and <code>col_b</code>. The
function automatically generates the upper and lower boundaries based on
the information stored within <code>x</code>.
</p>


<h3>Value</h3>

<p>Nothing (<code>NULL</code>; invisibly)
</p>


<h3>See Also</h3>

<p><a href="#topic+simulate_traces">simulate_traces</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a couple of traces for demonstration purpose
a_model &lt;- dmc_dm()
some_traces &lt;- simulate_traces(a_model, k = 3)

# Plots for traces_dm_list objects ----------------------------------------
# basic plot
plot(some_traces)

# a slightly more beautiful plot :)
plot(some_traces,
  col = c("green", "red"),
  xlim = c(0, 0.35),
  xlab = "Time [s]",
  ylab = bquote(Realizations ~ of ~ X[t]),
  legend_pos = "bottomright"
)

# Plots for traces_dm objects ---------------------------------------------
# we can also extract a single set of traces and plot them
one_set_traces &lt;- some_traces$comp
plot(one_set_traces)

# modifications to the plot generally work in the same way
plot(one_set_traces,
  col = "green",
  xlim = c(0, 0.35),
  xlab = "Time [s]",
  ylab = bquote(Realizations ~ of ~ X[t])
)

</code></pre>

<hr>
<h2 id='print.cafs'>Print Functions for Stats Objects</h2><span id='topic+print.cafs'></span><span id='topic+print.quantiles'></span><span id='topic+print.delta_funs'></span><span id='topic+print.fit_stats'></span><span id='topic+print.sum_dist'></span>

<h3>Description</h3>

<p>when calling <code><a href="#topic+calc_stats">calc_stats()</a></code>, each returned statistic will be a
subclass of <code>stats_dm</code> and <a href="base.html#topic+data.frame">data.frame</a>. The following <code>print() </code>methods will
call the more generic <code><a href="#topic+print.stats_dm">print.stats_dm()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cafs'
print(x, ...)

## S3 method for class 'quantiles'
print(x, ...)

## S3 method for class 'delta_funs'
print(x, ...)

## S3 method for class 'fit_stats'
print(x, ...)

## S3 method for class 'sum_dist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cafs_+3A_x">x</code></td>
<td>
<p>a subclass of <a href="base.html#topic+data.frame">data.frame</a>, as returned by <code><a href="#topic+calc_stats">calc_stats()</a></code>.</p>
</td></tr>
<tr><td><code id="print.cafs_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward to
<code><a href="#topic+print.stats_dm">print.stats_dm()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> (invisibly)
</p>

<hr>
<h2 id='print.summary.fits_ids_dm'>Summary and Printing for fits_ids_dm Objects</h2><span id='topic+print.summary.fits_ids_dm'></span><span id='topic+summary.fits_ids_dm'></span>

<h3>Description</h3>

<p>Methods for summarizing and printing objects of the class <code>fits_ids_dm</code>,
which contain multiple fits across individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.fits_ids_dm'
print(x, ..., round_digits = drift_dm_default_rounding())

## S3 method for class 'fits_ids_dm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.fits_ids_dm_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.fits_ids_dm</code>.</p>
</td></tr>
<tr><td><code id="print.summary.fits_ids_dm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="print.summary.fits_ids_dm_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, specifying the number of decimal places for
rounding in the printed summary. Default is set to 3.</p>
</td></tr>
<tr><td><code id="print.summary.fits_ids_dm_+3A_object">object</code></td>
<td>
<p>an object of class <code>fits_ids_dm</code>, generated by a call
to <a href="#topic+load_fits_ids">load_fits_ids</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary.fits_ids_dm</code> function creates a summary object containing:
</p>

<ul>
<li> <p><strong>fit_procedure_name</strong>: The name of the fit procedure used.
</p>
</li>
<li> <p><strong>time_call</strong>: Timestamp of the last fit procedure call.
</p>
</li>
<li> <p><strong>lower</strong> and <strong>upper</strong>: Lower and upper bounds of the search space.
</p>
</li>
<li> <p><strong>model_type</strong>: Description of the model type, based on class information.
</p>
</li>
<li> <p><strong>prms</strong>: All parameter values across all conditions (essentially a call
to coef() with the argument select_unique = FALSE).
</p>
</li>
<li> <p><strong>stats</strong>: A named list of matrices for each condition, including mean and
standard error for each parameter.
</p>
</li>
<li> <p><strong>N</strong>: The number of individuals.
</p>
</li></ul>

<p>The <code>print.summary.fits_ids_dm</code> function displays the summary object in a
formatted manner.
</p>


<h3>Value</h3>

<p><code>summary.fits_ids_dm()</code> returns a list of class <code>summary.fits_ids_dm</code> (see
the Details section summarizing each entry of this list).
</p>
<p><code>print.summary.fits_ids_dm()</code> returns invisibly the <code>summary.fits_ids_dm</code>
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an auxiliary object of type fits_ids_dm for demonstration purpose
all_fits &lt;- get_example_fits_ids()
sum_obj &lt;- summary(all_fits)
print(sum_obj, round_digits = 2)

</code></pre>

<hr>
<h2 id='prm_cond_combo_2_labels'>Generate Parameter-Condition Labels</h2><span id='topic+prm_cond_combo_2_labels'></span>

<h3>Description</h3>

<p>Creates a vector of labels from a parameter-condition combination matrix,
resulting from a call to <a href="#topic+prms_cond_combo">prms_cond_combo</a>. Used, for instance, in
<a href="#topic+coef.drift_dm">coef.drift_dm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prm_cond_combo_2_labels(prms_cond_combo, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prm_cond_combo_2_labels_+3A_prms_cond_combo">prms_cond_combo</code></td>
<td>
<p>a 2-row character matrix where each column represents
a unique parameter-condition combination.</p>
</td></tr>
<tr><td><code id="prm_cond_combo_2_labels_+3A_sep">sep</code></td>
<td>
<p>Separator for parameter and condition labels (default: &quot;~&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of labels with as many entries as the columns of
<code>prms_cond_combo</code> had, combining parameter and condition (if necessary).
</p>
<p>If the parameter labels are already unique (because all parameters do not
vary across conditions or are selectively used for one condition), then
only these parameter labels are returned
</p>

<hr>
<h2 id='prms_cond_combo'>Unique Conditions-Parameter Combinations</h2><span id='topic+prms_cond_combo'></span>

<h3>Description</h3>

<p>This is a helper function. It searches through the <code>linear_internal_list</code> of
the stored <a href="#topic+flex_prms">flex_prms</a> object, and keeps the first unique appearance
of parameters. For example, when the parameter muc is equal for comp, neutral,
and incomp, the function will provide the info &quot;muc&quot; and &quot;comp&quot;, thus
dropping incomp and neutral, where the parameter is the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prms_cond_combo(drift_dm_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prms_cond_combo_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with two rows. Each column contains a combination of the
parameter name and the condition that can be considered unique. Parameter
names are stored in the first row, condition labels in the second.
</p>

<hr>
<h2 id='prms_conds_to_modify'>Extract the conditions and parameters from an instruction string</h2><span id='topic+prms_conds_to_modify'></span>

<h3>Description</h3>

<p>This function takes an instruction as a string and then extracts the
conditions and parameters, depending on what &quot;type&quot; of operation it is.
The expected structure is listed in the details docu of flex_prms()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prms_conds_to_modify(formula_instr, operation, all_conds, all_prms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prms_conds_to_modify_+3A_formula_instr">formula_instr</code></td>
<td>
<p>an instruction string</p>
</td></tr>
<tr><td><code id="prms_conds_to_modify_+3A_operation">operation</code></td>
<td>
<p>what to expect in terms of the string's structure. Can be
&quot;vary&quot;, &quot;restrain&quot;, &quot;fix&quot;, &quot;set&quot; or &quot;dependency&quot;</p>
</td></tr>
<tr><td><code id="prms_conds_to_modify_+3A_all_conds">all_conds</code></td>
<td>
<p>all potential conditions (necessary for extending missing
condition specification)</p>
</td></tr>
<tr><td><code id="prms_conds_to_modify_+3A_all_prms">all_prms</code></td>
<td>
<p>all potential paramters (necessary for extending missing
condition specification)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list prms_to_adress and conds_to_adress as character
vectors.
</p>

<hr>
<h2 id='prms_solve+26lt+3B-'>The Parameters for Deriving Model Predictions</h2><span id='topic+prms_solve+3C-'></span><span id='topic+prms_solve+3C-.drift_dm'></span><span id='topic+prms_solve'></span><span id='topic+prms_solve.drift_dm'></span><span id='topic+prms_solve.fits_ids_dm'></span>

<h3>Description</h3>

<p>Functions to get or set the &quot;solver settings&quot; of an object. This includes the
diffusion constant and the discretization of the time and evidence space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prms_solve(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
prms_solve(object, ..., eval_model = FALSE) &lt;- value

prms_solve(object, ...)

## S3 method for class 'drift_dm'
prms_solve(object, ...)

## S3 method for class 'fits_ids_dm'
prms_solve(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prms_solve+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code>
(see <a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="prms_solve+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments (i.e., <code>eval_model</code>).</p>
</td></tr>
<tr><td><code id="prms_solve+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a named numeric vector providing new values for the <code>prms_solve</code>
vector (see <code><a href="#topic+drift_dm">drift_dm()</a></code>).</p>
</td></tr>
<tr><td><code id="prms_solve+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating the solver settings (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>).
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prms_solve()</code> is a generic accessor function, and <code style="white-space: pre;">&#8288;prms_solve&lt;-()&#8288;</code> is a
generic replacement function. The default methods get and set the &quot;solver
settings&quot;.
</p>
<p>It is possible to update parts of the &quot;solver setttings&quot; (i.e., parts of the
underlying <code>prms_solve</code> vector). However, modifying <code>"nx"</code> or <code>"nt"</code> is not
allowed! Any attempts to modify the respective entries will silently fail
(no explicit error/warning etc. is thrown).
</p>


<h3>Value</h3>

<p>For <code>prms_solve()</code> the vector <code>prms_solve</code> (see <code><a href="#topic+drift_dm">drift_dm()</a></code>).
</p>
<p>For <code style="white-space: pre;">&#8288;prms_solve&lt;-()&#8288;</code> the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>


<h3>Note</h3>

<p>There is only a replacement function for <a href="#topic+drift_dm">drift_dm</a> objects. This is
because replacing the solver settings after the model has been fitted (i.e.,
for a <code>fits_ids_dm</code> object) doesn't make sense.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get some default model to demonstrate the prms_solve() functions
my_model &lt;- ratcliff_dm()
# show the discretization and scaling of the model
prms_solve(my_model)
# partially modify these settings
prms_solve(my_model)[c("dx", "dt")] &lt;- c(0.005)
prms_solve(my_model)

# accessor method also available for fits_ids_dm objects
# (see estimate_model_ids)
# get an exemplary fits_ids_dm object
fits &lt;- get_example_fits_ids()
prms_solve(fits)

</code></pre>

<hr>
<h2 id='prms_to_str'>Format Parameters as String</h2><span id='topic+prms_to_str'></span>

<h3>Description</h3>

<p>Converts parameter values into a formatted string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prms_to_str(x, prms = NULL, round_digits = NULL, sep = "=&gt;", collapse = "\n")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prms_to_str_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+drift_dm">drift_dm</a>object or character vector for labels.</p>
</td></tr>
<tr><td><code id="prms_to_str_+3A_prms">prms</code></td>
<td>
<p>Numeric vector of values (used if <code>x</code> is character).</p>
</td></tr>
<tr><td><code id="prms_to_str_+3A_round_digits">round_digits</code></td>
<td>
<p>Rounding precision (default set by
<code><a href="#topic+drift_dm_default_rounding">drift_dm_default_rounding()</a></code>).</p>
</td></tr>
<tr><td><code id="prms_to_str_+3A_sep">sep</code></td>
<td>
<p>Separator between names and values (default: &quot;=&gt;&quot;).</p>
</td></tr>
<tr><td><code id="prms_to_str_+3A_collapse">collapse</code></td>
<td>
<p>String to separate each name-value pair (default: &quot;\n&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single formatted string with parameter names and values.
(e.g., &quot;a =&gt; 0 \n b =&gt; 1&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.drift_dm">coef.drift_dm()</a></code>, as the numeric
vector provided by this call is used when <code>x</code> is of type <a href="#topic+drift_dm">drift_dm</a>
</p>

<hr>
<h2 id='ratcliff_dm'>Create a Basic Diffusion Model</h2><span id='topic+ratcliff_dm'></span>

<h3>Description</h3>

<p>This function creates a <a href="#topic+drift_dm">drift_dm</a> model that corresponds to the
basic Ratcliff Diffusion Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratcliff_dm(
  var_non_dec = FALSE,
  var_start = FALSE,
  var_drift = FALSE,
  instr = NULL,
  obs_data = NULL,
  sigma = 1,
  t_max = 3,
  dt = 0.001,
  dx = 0.001,
  solver = "kfe",
  b_coding = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ratcliff_dm_+3A_var_non_dec">var_non_dec</code>, <code id="ratcliff_dm_+3A_var_start">var_start</code>, <code id="ratcliff_dm_+3A_var_drift">var_drift</code></td>
<td>
<p>logical, indicating whether the model
should have a (uniform) variable non-decision time, starting point, or
(normally-distributed) variable drift rate.
(see also <code>nt_uniform</code> and <code>x_uniform</code> in <a href="#topic+component_shelf">component_shelf</a>)</p>
</td></tr>
<tr><td><code id="ratcliff_dm_+3A_instr">instr</code></td>
<td>
<p>optional string with &quot;instructions&quot;, see
<code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code>.</p>
</td></tr>
<tr><td><code id="ratcliff_dm_+3A_obs_data">obs_data</code></td>
<td>
<p>data.frame, an optional data.frame with the observed data.
See <a href="#topic+obs_data">obs_data</a>.</p>
</td></tr>
<tr><td><code id="ratcliff_dm_+3A_sigma">sigma</code>, <code id="ratcliff_dm_+3A_t_max">t_max</code>, <code id="ratcliff_dm_+3A_dt">dt</code>, <code id="ratcliff_dm_+3A_dx">dx</code></td>
<td>
<p>numeric, providing the settings for the diffusion
constant and discretization (see <a href="#topic+drift_dm">drift_dm</a>)</p>
</td></tr>
<tr><td><code id="ratcliff_dm_+3A_solver">solver</code></td>
<td>
<p>character, specifying the <a href="#topic+solver">solver</a>.</p>
</td></tr>
<tr><td><code id="ratcliff_dm_+3A_b_coding">b_coding</code></td>
<td>
<p>list, an optional list with the boundary encoding (see
<a href="#topic+b_coding">b_coding</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical Ratcliff Diffusion Model is a diffusion model with a constant
drift rate <code>muc</code> and a constant boundary <code>b</code>. If <code>var_non_dec = FALSE</code>,  a
constant non-decision time <code>non_dec</code> is assumed, otherwise a uniform
non-decision time with mean <code>non_dec</code> and range <code>range_non_dec</code>. If
<code>var_start = FALSE</code>,  a constant starting point centered between the
boundaries is assumed (i.e., a dirac delta over 0), otherwise a uniform
starting point with mean 0 and range <code>range_start</code>. If <code>var_drift = FALSE</code>,
a constant drift rate is assumed, otherwise a normally distributed drift rate
with mean <code>mu_c</code> and standard deviation <code>sd_muc</code> (can be computationally
intensive). Important: Variable drift rate is only possible with dRiftDM's
<code>mu_constant</code> function. No custom drift rate is yet possible in this case.
</p>


<h3>Value</h3>

<p>An object of type <code>drift_dm</code> (parent class) and <code>ratcliff_dm</code> (child class),
created by the function <code><a href="#topic+drift_dm">drift_dm()</a></code>.
</p>


<h3>References</h3>

<p>Ratcliff R (1978).
&ldquo;A theory of memory retrieval.&rdquo;
<em>Psychological Review</em>, <b>85</b>(2), 59&ndash;108.
<a href="https://doi.org/10.1037/0033-295X.85.2.59">doi:10.1037/0033-295X.85.2.59</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+component_shelf">component_shelf()</a></code>, <code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the model with default settings
my_model &lt;- ratcliff_dm()

# the model with a variable non-decision time and with a more coarse
# discretization
my_model &lt;- ratcliff_dm(
  var_non_dec = TRUE,
  t_max = 1.5,
  dx = .005,
  dt = .005
)

</code></pre>

<hr>
<h2 id='ratcliff_synth_data'>A synthetic data set with one condition</h2><span id='topic+ratcliff_synth_data'></span>

<h3>Description</h3>

<p>This dataset was simulated by using the classical Ratcliff diffusion model
(see  <code><a href="#topic+ratcliff_dm">ratcliff_dm()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratcliff_synth_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows and 3 columns:
</p>

<dl>
<dt>RT</dt><dd><p>Response Times</p>
</dd>
<dt>Error</dt><dd><p>Error Coding (Error Response = 1; Correct Response = 0)</p>
</dd>
<dt>Cond</dt><dd><p>Condition ('null')</p>
</dd>
</dl>


<hr>
<h2 id='re_evaluate_model'>Re-evaluate the model</h2><span id='topic+re_evaluate_model'></span>

<h3>Description</h3>

<p>Updates the PDFs of a model. If <a href="#topic+obs_data">obs_data</a> are set to the model, the
log-likelihood is also updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_evaluate_model(drift_dm_obj, eval_model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="re_evaluate_model_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="re_evaluate_model_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be evaluated or not.
If <code>FALSE</code>, PDFs and the log-likelihood value are deleted from the model.
Default is <code>True</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More in-depth information about the mathematical details for
deriving the PDFs can be found in
Richter et al. (2023)
</p>


<h3>Value</h3>

<p>Returns the passed <code>drift_dm_obj</code> object, after (re-)calculating
the PDFs and (if observed data is set) the log-likelihood.
</p>

<ul>
<li><p> the PDFs an be addressed via <code>drift_dm_obj$pdfs</code>
</p>
</li>
<li><p> the log-likelihood can be addressed via <code>drift_dm_obj$log_like_val</code>
</p>
</li></ul>

<p>Note that if <code>re_evaluate</code> model is called before observed data was set,
the function silently updates the <code>pdfs</code>, but not <code>log_like_val</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># choose a pre-built model (e.g., the Ratcliff model)
# and set the discretization as needed
my_model &lt;- ratcliff_dm(t_max = 1.5, dx = .005, dt = .005)

# then calculate the model's predicted PDF
my_model &lt;- re_evaluate_model(my_model)
str(my_model$pdfs) # show the structure of the attached pdfs

# if you want the log_likelihood, make sure some data is attached to the
# model (see also the documentation of obs_data())
obs_data(my_model) &lt;- ratcliff_synth_data # this data set comes with dRiftDM
my_model &lt;- re_evaluate_model(my_model)
str(my_model$pdfs)
print(my_model$log_like_val)

</code></pre>

<hr>
<h2 id='set_default_colors'>Set Default Colors</h2><span id='topic+set_default_colors'></span>

<h3>Description</h3>

<p>This function assigns default colors if none are provided or adjusts the
color vector to match the number of conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_default_colors(colors, unique_conds, default_colors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_default_colors_+3A_colors">colors</code></td>
<td>
<p>character vector, specifying colors for conditions. If NULL,
<code>default_colors</code> is used.</p>
</td></tr>
<tr><td><code id="set_default_colors_+3A_unique_conds">unique_conds</code></td>
<td>
<p>character vector, listing unique conditions to match
color assignments (only the length counts).</p>
</td></tr>
<tr><td><code id="set_default_colors_+3A_default_colors">default_colors</code></td>
<td>
<p>character vector, default colors to use if <code>colors</code> is
not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of colors, matching the length of <code>unique_conds</code>.
</p>

<hr>
<h2 id='set_one_solver_setting'>Set one specific aspect of the solver settings</h2><span id='topic+set_one_solver_setting'></span>

<h3>Description</h3>

<p>Internal function to update one aspect of <code>prms_solve</code> or <code>solver</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_one_solver_setting(drift_dm_obj, name_prm_solve, value_prm_solve)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_one_solver_setting_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="set_one_solver_setting_+3A_name_prm_solve">name_prm_solve</code></td>
<td>
<p>which aspect to address? (&quot;sigma&quot;, &quot;t_max&quot;, &quot;dx&quot;, &quot;dt&quot;,
&quot;solver&quot;)</p>
</td></tr>
<tr><td><code id="set_one_solver_setting_+3A_value_prm_solve">value_prm_solve</code></td>
<td>
<p>either a single numeric or character string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ensures that the supplied values are reasonable and that <code>nx</code> and <code>nt</code> are
updated. The functions <a href="#topic+prms_solve+3C-">prms_solve&lt;-</a> and
<a href="#topic+solver+3C-">solver&lt;-</a> pass their arguments forward to this function.
</p>


<h3>Value</h3>

<p>the updated un-evaluated (!) drift_dm_obj object
</p>

<hr>
<h2 id='set_plot_limits'>Set Plot Limits</h2><span id='topic+set_plot_limits'></span>

<h3>Description</h3>

<p>This function determines plot limits, using <code>default_lim</code> if <code>lim</code> is not
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_plot_limits(lim, default_lim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_plot_limits_+3A_lim">lim</code></td>
<td>
<p>numeric vector of length 2, specifying the desired plot limits.</p>
</td></tr>
<tr><td><code id="set_plot_limits_+3A_default_lim">default_lim</code></td>
<td>
<p>numeric vector of length 2, default limits to use if
<code>lim</code> is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2, specifying the plot limits.
</p>

<hr>
<h2 id='simulate_data'>Simulate Synthetic Responses</h2><span id='topic+simulate_data'></span><span id='topic+simulate_data.drift_dm'></span>

<h3>Description</h3>

<p>This function simulates data based on the provided model. To this end,
random samples from the predicted PDFs are drawn via approximate inverse CDF
sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_data(object, ...)

## S3 method for class 'drift_dm'
simulate_data(
  object,
  ...,
  n,
  k = 1,
  lower = NULL,
  upper = NULL,
  df_prms = NULL,
  seed = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_data_+3A_object">object</code></td>
<td>
<p>an object inheriting from <a href="#topic+drift_dm">drift_dm</a>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_...">...</code></td>
<td>
<p>further arguments passed on to other functions, including the
function <a href="#topic+simulate_values">simulate_values</a>. If users want to use a different
distribution than uniform for <a href="#topic+simulate_values">simulate_values</a>, they must provide
the additional arguments (e.g., <code>means</code> and <code>sds</code>) in a format like
<code>lower/upper</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_n">n</code></td>
<td>
<p>numeric, the number of trials per condition to draw. If a single
numeric, then each condition will have <code>n</code> trials. Can be a (named) numeric
vector with the same length as there are conditions to allow a different
number of trials per condition.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_k">k</code></td>
<td>
<p>numeric larger than 0, indicating how many data sets shall
be simulated. If &gt; 1, then it is only effective when specifying
<code>lower/upper</code>.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_lower">lower</code>, <code id="simulate_data_+3A_upper">upper</code></td>
<td>
<p>vectors or a list, specifying the simulation space for
each parameter of the model (see Details). Only relevant for <code>k &gt; 1</code></p>
</td></tr>
<tr><td><code id="simulate_data_+3A_df_prms">df_prms</code></td>
<td>
<p>an optional data.frame providing the parameters
that should be used for simulating the data. <code>df_prms</code> must provide column
names matching with (<code>coef(object, select_unique = TRUE)</code>), plus a column
<code>ID</code> that will identify each simulated data set.</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_seed">seed</code></td>
<td>
<p>a single numeric, an optional seed for reproducible sampling</p>
</td></tr>
<tr><td><code id="simulate_data_+3A_verbose">verbose</code></td>
<td>
<p>an integer, indicating if information about the progress
should be displayed. 0 -&gt; no information, 1 -&gt; a progress bar.
Default is 1. Only effective when <code>k &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simulate_data</code> is a generic function for simulating data based on
approximate inverse CDF sampling. CDFs are derived from the model's PDFs and
data is drawn by mapping samples from a uniform distribution
(in <code class="reqn">[0, 1]</code>) to the values of the CDF. Note that sampled response times
will correspond to the values of the time space (i.e., they will correspond
to <code>seq(0, t_max, dt)</code>, see <a href="#topic+drift_dm">drift_dm</a>).
</p>
<p>For <code>drift_dm</code> objects, the behavior of <code>simulate_data</code> depends on <code>k</code>. If
<code>k = 1</code> and no <code>lower/upper</code> or <code>df_prms</code> arguments are supplied, then the
parameters currently set to the model are used to generate
the synthetic data. If <code>k &gt; 1</code>, then <code>k</code> parameter combinations are either
randomly drawn via <a href="#topic+simulate_values">simulate_values</a> or gathered from the provided
data.frame <code>df_prms</code>, and then data is simulated for each parameter
combination.
</p>
<p>When specifying <code>lower/upper</code>, parameter combinations are simulated via
<a href="#topic+simulate_values">simulate_values</a>. This comes in handy for simple parameter recovery
exercises. If <code>df_prms</code> is specified, then the parameter combinations from
this <a href="base.html#topic+data.frame">data.frame</a> is used. Note that the column names in <code>df_prms</code> must match
with the (unique) parameter combinations of the model
(see <code>print(coef(object))</code>)
</p>


<h4>Details on how to specify <code>lower/upper</code>.</h4>

<p>When users want to simulate data with <code>k &gt; 1</code> and <code>lower/upper</code>, then
parameter values have to be drawn. One great aspect about the
<a href="#topic+flex_prms">flex_prms</a> object within each <a href="#topic+drift_dm">drift_dm</a> model, is that
users can easily allow certain parameters to vary freely across conditions.
Consequently, the actual number of parameters varies with the settings of
the <a href="#topic+flex_prms">flex_prms</a> object. In many cases, however, the simulation space
for a parameter is the same across conditions. For instance, in a model, the
parameter &quot;mu&quot; may vary across the conditions &quot;easy&quot;, &quot;medium&quot;, or &quot;hard&quot;,
but the lower/upper limits are the same across conditions.
To avoid that users always have to re-specify the simulation space via the
<code>lower/upper</code> arguments, the <code>lower</code> and <code>upper</code> arguments refer to the
parameter labels, and <code>dRiftDM</code> figures out how to map these to all
parameters that vary across conditions.
</p>
<p>Here is an example: Assume you have the model with parameters
&quot;A&quot; and &quot;B&quot;, and the conditions &quot;foo&quot; and &quot;bar&quot;. Now assume that &quot;A&quot; is
allowed to vary for &quot;foo&quot; and &quot;bar&quot;. Thus, there are actually three
parameters; &quot;A~foo&quot;, &quot;A~bar&quot;, and &quot;B&quot;. <code>dRiftDM</code>, however, can help with
this. If we provide <code>lower = c(A = 1, B = 2)</code>, <code>upper = c(A = 3, B = 4)</code>,
<code>simulate_data</code> checks the model, and creates the vectors
<code>temp_lower = c(1,1,2)</code> and <code>temp_upper = c(3,3,4)</code> as a basis to simulate
the parameters.
</p>
<p>Users have three options to specify the simulation space:
</p>

<ul>
<li><p> Plain numeric vectors (not very much recommended). In this case,
<code>lower/upper</code> must be sorted in accordance with the free parameters in the
<code>flex_prms_obj</code> object (call <code style="white-space: pre;">&#8288;print(&lt;model&gt;)&#8288;</code> and have a look at the
<code style="white-space: pre;">&#8288;Unique Parameters&#8288;</code> output)
</p>
</li>
<li><p> Named numeric vectors. In this case <code>lower/upper</code> have to provide labels
in accordance with the parameters that are considered &quot;free&quot; at least once
across conditions.
</p>
</li>
<li><p> The most flexible way is when <code>lower/upper</code> are lists. In this case, the
list requires an entry called &quot;default_values&quot; which specifies the named or
plain numeric vectors as above. If the list only contains this entry, then
the behavior is as if <code>lower/upper</code> were already numeric vectors. However,
the <code>lower/upper</code> lists can also provide entries labeled as specific
conditions, which contain named (!) numeric vectors with parameter labels.
This will modify the value for the upper/lower parameter space with respect
to the specified parameters in the respective condition.
</p>
</li></ul>




<h3>Value</h3>

<p>The return value depends on whether a user specifies <code>lower/upper</code> or
<code>df_prms</code>. If none of these are specified and if <code>k = 1</code>, then a
<a href="base.html#topic+data.frame">data.frame</a> containing the columns <code>RT</code>, <code>Error</code>, and <code>Cond</code> is returned.
</p>
<p>If <code>lower/upper</code> or <code>df_prms</code> are provided, then a list with entries
<code>synth_data</code> and <code>prms</code> is returned. The entry <code>synth_data</code> contains a
<a href="base.html#topic+data.frame">data.frame</a>, with the columns <code>RT</code>, <code style="white-space: pre;">&#8288;&lt;b_column&gt;&#8288;</code>, <code>Cond</code>, and <code>ID</code> (the name
of the second column, <code style="white-space: pre;">&#8288;&lt;b_column&gt;&#8288;</code>, depends on the <a href="#topic+b_coding">b_coding</a> of the
model object). The entry <code>prms</code> contains a data.frame with an <code>ID</code> column and
the parameters used for simulating each synthetic data set.
</p>


<h3>Note</h3>

<p>A function for <code>fits_ids_dm</code> will be provided in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ----------------------------------------------------------------
# get a pre-built model for demonstration
a_model &lt;- ratcliff_dm(t_max = 1.5, dx = .005, dt = .005)

# define a lower and upper simulation space
lower &lt;- c(1, 0.4, 0.1)
upper &lt;- c(6, 0.9, 0.5)

# now simulate 5 data sets with each 100 trials
data_prms &lt;- simulate_data(a_model,
  n = 100, k = 5, lower = lower,
  upper = upper, seed = 1, verbose = 0
)
head(data_prms$synth_data)
head(data_prms$prms)

# Example 2 ----------------------------------------------------------------
# more flexibility when defining lists for lower and upper
# get a pre-built model, and allow muc to vary across conditions
a_model &lt;- dmc_dm(t_max = 1.5, dx = .005, dt = .005, instr = "muc ~ ")

# define a lower and upper simulation space
# let muc vary between 2 and 6, but in incomp conditions, let it vary
# between 1 and 4
lower &lt;- list(
  default_values = c(
    muc = 2, b = 0.4, non_dec = 0.1,
    sd_non_dec = 0.01, tau = 0.02, A = 0.05,
    alpha = 3
  ),
  incomp = c(muc = 1)
)
upper &lt;- list(
  default_values = c(
    muc = 6, b = 0.9, non_dec = 0.4,
    sd_non_dec = 0.15, tau = 0.15, A = 0.15,
    alpha = 7
  ),
  incomp = c(muc = 4)
)

data_prms &lt;- simulate_data(a_model,
  n = 100, k = 5, lower = lower,
  upper = upper, seed = 1, verbose = 0
)
range(data_prms$prms$muc.comp)
range(data_prms$prms$muc.incomp)

</code></pre>

<hr>
<h2 id='simulate_one_data_set'>Simulate one data set</h2><span id='topic+simulate_one_data_set'></span>

<h3>Description</h3>

<p>Function that simulates a single data based on a model (using the prms set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_one_data_set(drift_dm_obj, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_one_data_set_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>a <a href="#topic+drift_dm">drift_dm</a> object</p>
</td></tr>
<tr><td><code id="simulate_one_data_set_+3A_n">n</code></td>
<td>
<p>numeric, specifying the number of trials per condition. Can be
single numeric, or a (named) numeric vector with the same length as
conds(drift_dm_obj)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns &quot;RT&quot;, &quot;&lt;b_column&gt;&quot;, and &quot;Cond&quot;; and
with n rows.
</p>

<hr>
<h2 id='simulate_traces'>Simulate Trajectories/Traces of a Model</h2><span id='topic+simulate_traces'></span><span id='topic+simulate_traces.drift_dm'></span><span id='topic+simulate_traces.fits_ids_dm'></span><span id='topic+print.traces_dm_list'></span><span id='topic+print.traces_dm'></span>

<h3>Description</h3>

<p>Simulates single trajectories/traces of a model
(i.e., evidence accumulation processes) using forward Euler.
</p>
<p>Might come in handy when exploring the model's behavior or when
creating figures (see also <a href="#topic+plot.traces_dm_list">plot.traces_dm_list</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_traces(object, k, ...)

## S3 method for class 'drift_dm'
simulate_traces(
  object,
  k,
  ...,
  conds = NULL,
  add_x = FALSE,
  sigma = NULL,
  seed = NULL,
  unpack = FALSE
)

## S3 method for class 'fits_ids_dm'
simulate_traces(object, k, ...)

## S3 method for class 'traces_dm_list'
print(x, ..., round_digits = drift_dm_default_rounding(), print_steps = 5)

## S3 method for class 'traces_dm'
print(
  x,
  ...,
  round_digits = drift_dm_default_rounding(),
  print_steps = 5,
  print_k = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_traces_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code> (see
<a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_k">k</code></td>
<td>
<p>numeric, the number of traces to simulate per condition. Can be a
named numeric vector, to specify different number of traces per condition.</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward to the respective method.</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_conds">conds</code></td>
<td>
<p>optional character vector, conditions for which traces shall be
simulated. If <code>NULL</code>, then traces for all conditions are simulated.</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_add_x">add_x</code></td>
<td>
<p>logical, indicating whether traces should contain a
variable starting point. If <code>TRUE</code>, samples from <code>x_fun</code> (see
<a href="#topic+comp_vals">comp_vals</a>) are added to each trace. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_sigma">sigma</code></td>
<td>
<p>optional numeric, providing a value &gt;= 0 for the diffusion
constant &quot;sigma&quot; to temporally override <a href="#topic+prms_solve">prms_solve</a>. Useful for
exploring the model without noise.</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_seed">seed</code></td>
<td>
<p>optional numerical, a seed for reproducible sampling</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_unpack">unpack</code></td>
<td>
<p>logical, indicating if the traces shall be &quot;unpacked&quot; (see
also <a href="#topic+unpack_obj">unpack_obj</a> and the return value below).</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_x">x</code></td>
<td>
<p>an object of type <code>traces_dm_list</code> or <code>traces_dm</code>, resulting from a
call to <code>simulate_traces</code>.</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, indicating the number of decimal places (round)
to be used when printing out the traces (default is 3).</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_print_steps">print_steps</code></td>
<td>
<p>integer, indicating the number of steps to show when
printing out traces (default is 5).</p>
</td></tr>
<tr><td><code id="simulate_traces_+3A_print_k">print_k</code></td>
<td>
<p>integer, indicating how many traces shall be shown when
printing out traces (default is 4).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simulate_traces()</code> is a generic function, applicable to objects of type
<a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code> (see <a href="#topic+load_fits_ids">load_fits_ids</a>).
</p>
<p>For <a href="#topic+drift_dm">drift_dm</a> objects, <code>simulate_traces()</code> performs the simulation
on the parameter values currently set (see
<code><a href="#topic+coef.drift_dm">coef.drift_dm()</a></code>).
</p>
<p>For <code>fits_ids_dm</code> objects, <code>simulate_traces()</code> first extracts the model and
all parameter values for all IDs (see <code><a href="#topic+coef.fits_ids_dm">coef.fits_ids_dm()</a></code>).
Subsequently, simulations are based on the averaged parameter values.
</p>
<p>The algorithm for simulating traces is forward euler. See
Richter et al. (2023) and
Ulrich et al. (2015) (Appendix A) for more
information.
</p>


<h3>Value</h3>

<p><code>simulate_traces()</code> returns either a list of type <code>traces_dm_list</code>, or
directly the plain traces as matrices across conditions (if <code>unpack = TRUE</code>).
If the model has only one condition (and <code>unpack = TRUE</code>), then the matrix of
traces for this one condition is directly returned.
</p>
<p>The returned list has as many entries as conditions requested. For example,
if only one condition is requested via the <code>conds</code> argument, then the list is
of length 1 (if <code>unpack = FALSE</code>). If <code>conds</code> is set to <code>NULL</code> (default),
then the list will have as many entries as conditions specified in the
supplied <code>object</code> (see also <a href="#topic+conds">conds</a>). If <code>unpack = FALSE</code>, the list
contains an additional attribute with the time space.
</p>
<p>Each matrix of traces has <code>k</code> rows and <code>nt + 1</code> columns, stored as an
array of size (<code>k</code>, <code>nt + 1</code>). Note that <code>nt</code> is the number of steps in the
discretization of time; see <a href="#topic+drift_dm">drift_dm</a>. If <code>unpack = FALSE</code>, the
array is of type <code>traces_dm</code>. It contains some additional attributes about
the time space, the drift rate, the boundary, the added starting values,
if starting values were added, the original model class and parameters, the
boundary coding, and the solver settings.
</p>
<p>The print methods <code>print.traces_dm_list()</code> and <code>print.traces_dm()</code> each
invisibly return the supplied object <code>x</code>.
</p>


<h3>Note</h3>

<p>Evidence values with traces beyond the boundary of the model are set to NA
before passing them back.
</p>
<p>The reason why <code>simulate_traces</code> passes back an object of type
<code>traces_dm_list</code> (instead of simply a list of arrays) is to provide a
<a href="#topic+plot.traces_dm_list">plot.traces_dm_list</a> and <a href="#topic+print.traces_dm_list">print.traces_dm_list</a> function.
</p>
<p>Users can unpack the traces even after calling <code>simulate_traces()</code> using
<code><a href="#topic+unpack_obj">unpack_obj()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unpack_obj">unpack_obj()</a></code>, <code><a href="#topic+plot.traces_dm_list">plot.traces_dm_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model to demonstrate the function
my_model &lt;- dmc_dm()
some_traces &lt;- simulate_traces(my_model, k = 1, seed = 1)
print(some_traces)

# a method is also available for fits_ids_dm objects
# (see estimate_model_ids)
# get an exemplary fits_ids_dm object
fits &lt;- get_example_fits_ids()
some_traces &lt;- simulate_traces(fits, k = 1, seed = 1)
print(some_traces)

# we can also print only the traces of one condition
print(some_traces$comp)

</code></pre>

<hr>
<h2 id='simulate_traces_one_cond'>Simulate Traces for One Conditions</h2><span id='topic+simulate_traces_one_cond'></span>

<h3>Description</h3>

<p>The function simulates traces with forward Euler. It is the backend function
to <code>simulate_traces</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_traces_one_cond(drift_dm_obj, k, one_cond, add_x, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_traces_one_cond_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>a model of type <a href="#topic+drift_dm">drift_dm</a></p>
</td></tr>
<tr><td><code id="simulate_traces_one_cond_+3A_k">k</code></td>
<td>
<p>a single numeric, the number of traces to simulate</p>
</td></tr>
<tr><td><code id="simulate_traces_one_cond_+3A_one_cond">one_cond</code></td>
<td>
<p>a single character string, specifying which condition shall
be simulated</p>
</td></tr>
<tr><td><code id="simulate_traces_one_cond_+3A_add_x">add_x</code></td>
<td>
<p>a single logical, indicating if starting values shall be added
or not. Sometimes, when visualizing the model, one does not want to have
the starting values.</p>
</td></tr>
<tr><td><code id="simulate_traces_one_cond_+3A_sigma">sigma</code></td>
<td>
<p>a single numeric, to override the &quot;sigma&quot; in
<a href="#topic+prms_solve">prms_solve</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of size k times <code>nt + 1</code>. The array becomes an object of type
<code>traces_dm</code>, which allows for easier printing with <a href="#topic+print.traces_dm">print.traces_dm</a>.
Furthermore, each object has the additional attributes:
</p>

<ul>
<li><p> &quot;t_vec&quot; -&gt; the time space from 0 to t_max
</p>
</li>
<li><p> &quot;mu_vals&quot; -&gt; the drift rate values by mu_fun
</p>
</li>
<li><p> &quot;b_vals&quot; -&gt; the boundary values by b_fun
</p>
</li>
<li><p> &quot;samp_x&quot; -&gt; the values of the starting points (which are always added to
the traces in the array.
</p>
</li>
<li><p> &quot;add_x&quot; -&gt; boolean, indicating if the starting values were added or not
</p>
</li>
<li><p> &quot;orig_model_class&quot; -&gt; the class label of the original model
</p>
</li>
<li><p> &quot;orig_prms&quot; -&gt; the parameters with which the traces were simulated (for
the respective condition)
</p>
</li>
<li><p> &quot;b_coding&quot; -&gt; the boundary coding
</p>
</li>
<li><p> &quot;prms_solve&quot; -&gt; the solver settings with which the traces were simulated
</p>
</li></ul>


<hr>
<h2 id='simulate_values'>Simulate Values</h2><span id='topic+simulate_values'></span>

<h3>Description</h3>

<p>Draw values, most likely model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_values(
  lower,
  upper,
  k,
  distr = NULL,
  cast_to_data_frame = TRUE,
  add_id_column = "numeric",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_values_+3A_lower">lower</code>, <code id="simulate_values_+3A_upper">upper</code></td>
<td>
<p>Numeric vectors, indicating the lower/upper boundary of
the drawn values.</p>
</td></tr>
<tr><td><code id="simulate_values_+3A_k">k</code></td>
<td>
<p>Numeric, the number of values to be drawn for each value pair of
lower/upper. If named numeric, the labels are used for the column names
of the returned object</p>
</td></tr>
<tr><td><code id="simulate_values_+3A_distr">distr</code></td>
<td>
<p>Character, indicating which distribution to draw from. Currently
available are: <code>"unif"</code> for a uniform distribution or <code>"tnorm"</code> for a
truncated normal distribution. <code>NUll</code> will lead to <code>"unif"</code> (default).</p>
</td></tr>
<tr><td><code id="simulate_values_+3A_cast_to_data_frame">cast_to_data_frame</code></td>
<td>
<p>Logical, controls whether the returned object
is of type data.frame (TRUE) or matrix (FALSE). Default is TRUE</p>
</td></tr>
<tr><td><code id="simulate_values_+3A_add_id_column">add_id_column</code></td>
<td>
<p>Character, controls whether an ID column should be
added. Options are &quot;numeric&quot;, &quot;character&quot;, or &quot;none&quot;. If &quot;numeric&quot; or
&quot;character&quot; the column ID provides values from 1 to k of the respective type.
If none, no column is added. Note that &quot;character&quot; casts all simulated values
to character if the argument <code>cast_to_data_frame</code> is set to FALSE.</p>
</td></tr>
<tr><td><code id="simulate_values_+3A_seed">seed</code></td>
<td>
<p>Numeric, optional seed for making the simulation reproducable
(see details)</p>
</td></tr>
<tr><td><code id="simulate_values_+3A_...">...</code></td>
<td>
<p>Further arguments relevant for the distribution to draw from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When drawing from a truncated normal distribution, users must provide values
for the arguments <code>means</code> and <code>sds</code>. These are numeric vectors of the same
size as <code>lower</code> and <code>upper</code>, and indicate the mean and the standard deviation
of the normal distributions.
</p>


<h3>Value</h3>

<p>If <code>cast_to_data_frame</code> is TRUE, a data.frame with <code>k</code> rows and at least
<code>length(lower);length(upper)</code> columns. Otherwise a matrix with
the same number of rows and columns. Columns are labeled either from V1 to
Vk or in case <code>lower</code> and <code>upper</code> are named numeric vectors using the
labels of both vectors.
</p>
<p>If <code>add_id_column</code> is not &quot;none&quot;, an ID column is provided of the respective
data type.
</p>
<p>The data type of the parameters will be numeric, unless <code>add_id_column</code>
is &quot;character&quot; and <code>cast_to_data_frame</code> is FALSE. In this case the returned
matrix will be of type character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Draw from uniform distributions ------------------------------
lower &lt;- c(a = 1, b = 1, c = 1)
upper &lt;- c(a = 3, b = 4, c = 5)
values &lt;- simulate_values(
  lower = lower,
  upper = upper,
  k = 50,
  add_id_column = "none"
)
summary(values)

# Example 2: Draw from truncated normal distributions ---------------------
lower &lt;- c(a = 1, b = 1, c = 1)
upper &lt;- c(a = 3, b = 4, c = 5)
means &lt;- c(a = 2, b = 2.5, c = 3)
sds &lt;- c(a = 0.5, b = 0.5, c = 0.5)
values &lt;- simulate_values(
  lower = lower,
  upper = upper,
  distr = "tnorm",
  k = 5000,
  add_id_column = "none",
  means = means,
  sds = sds
)
quantile(values$a, probs = c(0.025, 0.5, 0.975))
quantile(values$b, probs = c(0.025, 0.5, 0.975))
quantile(values$c, probs = c(0.025, 0.5, 0.975))

</code></pre>

<hr>
<h2 id='solver+26lt+3B-'>The Solver for Deriving Model Predictions</h2><span id='topic+solver+3C-'></span><span id='topic+solver+3C-.drift_dm'></span><span id='topic+solver'></span><span id='topic+solver.drift_dm'></span><span id='topic+solver.fits_ids_dm'></span>

<h3>Description</h3>

<p>Functions to get or set the &quot;solver&quot; of an object. The &quot;solver&quot; controls
the method for deriving the model's first passage time (i.e., its predicted
PDFs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solver(object, ...) &lt;- value

## S3 replacement method for class 'drift_dm'
solver(object, ..., eval_model = FALSE) &lt;- value

solver(object, ...)

## S3 method for class 'drift_dm'
solver(object, ...)

## S3 method for class 'fits_ids_dm'
solver(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solver+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object of type <a href="#topic+drift_dm">drift_dm</a> or <code>fits_ids_dm</code>
(see <a href="#topic+load_fits_ids">load_fits_ids</a>).</p>
</td></tr>
<tr><td><code id="solver+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments (i.e., <code>eval_model</code>).</p>
</td></tr>
<tr><td><code id="solver+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a single character string, providing the new &quot;solver&quot; (i.e.,
approach to derive the first passage time; see <code><a href="#topic+drift_dm">drift_dm()</a></code>).</p>
</td></tr>
<tr><td><code id="solver+2B26lt+2B3B-_+3A_eval_model">eval_model</code></td>
<td>
<p>logical, indicating if the model should be re-evaluated or
not when updating the solver (see <a href="#topic+re_evaluate_model">re_evaluate_model</a>). Default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>solver()</code> is a generic accessor function, and <code style="white-space: pre;">&#8288;solver&lt;-()&#8288;</code> is a
generic replacement function. The default methods get and set the &quot;solver&quot;.
</p>
<p>The &quot;solver&quot; indicates the approach with which the PDFs of a model are
calculated. Supported options are &quot;kfe&quot; and &quot;im_zero&quot; (method based on the
Kolmogorov-Forward-Equation or on integral equations, respectively). Note
that &quot;im_zero&quot; is only supported for models that assume a fixed starting
point from 0.
</p>


<h3>Value</h3>

<p>For <code>solve()</code> the string <code>solver</code> (see <code><a href="#topic+drift_dm">drift_dm()</a></code>).
</p>
<p>For <code style="white-space: pre;">&#8288;solver&lt;-()&#8288;</code> the updated <a href="#topic+drift_dm">drift_dm</a> object.
</p>


<h3>Note</h3>

<p>There is only a replacement function for <a href="#topic+drift_dm">drift_dm</a> objects. This is
because replacing the approach for deriving PDFs after the model has been
fitted (i.e., for a <code>fits_ids_dm</code> object) doesn't make sense.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drift_dm">drift_dm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get some default model to demonstrate the solver() functions
my_model &lt;- ratcliff_dm()
solver(my_model)
# change to the integral approach
solver(my_model) &lt;- "im_zero"
solver(my_model)

# accessor method also available for fits_ids_dm objects
# (see estimate_model_ids)
# get an exemplary fits_ids_dm object
fits &lt;- get_example_fits_ids()
solver(fits)

</code></pre>

<hr>
<h2 id='sort_one_internal_entry'>Sorts the numbers in ascending order</h2><span id='topic+sort_one_internal_entry'></span>

<h3>Description</h3>

<p>.... within one entry (i.e., one prm
across all conditions, such as when calling <code>internal_list[["A"]]</code>); which
is a list. Used to ensure that parameter ordering remains logical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_one_internal_entry(one_internal_entry)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_one_internal_entry_+3A_one_internal_entry">one_internal_entry</code></td>
<td>
<p>one entry of a (linearized) internal_list, must be
named</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entries of the internal list are either digits (0-x) or expressions.
</p>


<h3>Value</h3>

<p>the newly sorted entry as a list
</p>

<hr>
<h2 id='ssp_dm'>Create the Shrinking Spotlight Model</h2><span id='topic+ssp_dm'></span>

<h3>Description</h3>

<p>This function creates a <a href="#topic+drift_dm">drift_dm</a> object that corresponds to a
simple version of the shrinking spotlight model by
White et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp_dm(
  instr = NULL,
  obs_data = NULL,
  sigma = 1,
  t_max = 3,
  dt = 0.001,
  dx = 0.001,
  b_coding = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssp_dm_+3A_instr">instr</code></td>
<td>
<p>optional string with additional &quot;instructions&quot;, see
<code><a href="#topic+modify_flex_prms">modify_flex_prms()</a></code> and the Details below.</p>
</td></tr>
<tr><td><code id="ssp_dm_+3A_obs_data">obs_data</code></td>
<td>
<p>data.frame, an optional data.frame with the observed data.
See <a href="#topic+obs_data">obs_data</a>.</p>
</td></tr>
<tr><td><code id="ssp_dm_+3A_sigma">sigma</code>, <code id="ssp_dm_+3A_t_max">t_max</code>, <code id="ssp_dm_+3A_dt">dt</code>, <code id="ssp_dm_+3A_dx">dx</code></td>
<td>
<p>numeric, providing the settings for the diffusion
constant and discretization (see <a href="#topic+drift_dm">drift_dm</a>)</p>
</td></tr>
<tr><td><code id="ssp_dm_+3A_b_coding">b_coding</code></td>
<td>
<p>list, an optional list with the boundary encoding (see
<a href="#topic+b_coding">b_coding</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shrinking spotlight model is a model developed for the flanker task.
</p>
<p>It has the following properties (see <a href="#topic+component_shelf">component_shelf</a>):
</p>

<ul>
<li><p> a constant boundary (parameter <code>b</code>)
</p>
</li>
<li><p> a constant starting point in between the decision boundaries
</p>
</li>
<li><p> an evidence accumulation process that is driven by an attentional
spotlight that covers both the flankers and the target. The area that covers
the flankers and target is modeled by normal distribution with mean 0:
</p>

<ul>
<li><p> At the beginning of the trial attention is wide-spread, and the width
at t=0 is the standard deviation <code>sd_0</code>
</p>
</li>
<li><p> As the trial progresses in time, the attentional spotlight narrows,
reflected by a linear decline of the standard deviation with rate <code>r</code>
(to a minimum of 0.001).
</p>
</li>
<li><p> the attention attributed to both the flankers and the target is scaled
by <code>p</code> which controls the strength of evidence accumulation
</p>
</li></ul>

</li>
<li><p> A non-decision time that follows a truncated normal distribution with
mean <code>non_dec</code> and standard deviation <code>sd_non_dec</code>.
</p>
</li>
<li><p> The model also contains the auxiliary parameter <code>sign</code>, which is used to
control the influence of the flankers across conditions. It is not really
a parameter and should not be estimated!
</p>
</li></ul>

<p>Per default, the parameter <code>r</code> is assumed to be fixed (i.e., is not estimated
freely). The model also contains the custom parameter <code>interf_t</code>, quantifying
the interference time (<code>sd_0 / r</code>).
</p>


<h3>Value</h3>

<p>An object of type <code>drift_dm</code> (parent class) and <code>ssp_dm</code> (child class),
created by the function <code><a href="#topic+drift_dm">drift_dm()</a></code>.
</p>


<h3>References</h3>

<p>White CN, Ratcliff R, Starns JJ (2011).
&ldquo;Diffusion models of the flanker task: Discrete versus gradual attentional selection.&rdquo;
<em>Cognitive psychology</em>, <b>63</b>(4), 210&ndash;238.
<a href="https://doi.org/10.1016/j.cogpsych.2011.08.001">doi:10.1016/j.cogpsych.2011.08.001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the model with default settings
my_model &lt;- ssp_dm()

# the model with a more coarse discretization
my_model &lt;- ssp_dm(
  t_max = 1.5,
  dx = .0025,
  dt = .0025
)

</code></pre>

<hr>
<h2 id='summarize_drift_dm_info'>Reads Info file</h2><span id='topic+summarize_drift_dm_info'></span>

<h3>Description</h3>

<p>Requires a path to the info file of a fit procedure (see
<a href="#topic+estimate_model_ids">estimate_model_ids</a>) and turns its main information into a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_drift_dm_info(full_name_to_file, detailed_info)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_drift_dm_info_+3A_full_name_to_file">full_name_to_file</code></td>
<td>
<p>path to the info file (.RDS)</p>
</td></tr>
<tr><td><code id="summarize_drift_dm_info_+3A_detailed_info">detailed_info</code></td>
<td>
<p>logical, if detailed info shall be provided or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string with infos about the fit procedure name, last call,
and, if detailed_info = TRUE, model, individuals, lower/upper, and seed.
</p>

<hr>
<h2 id='summary.coefs_dm'>Summary for <code>coefs_dm</code> Objects</h2><span id='topic+summary.coefs_dm'></span><span id='topic+print.summary.coefs_dm'></span>

<h3>Description</h3>

<p>Summary and corresponding printing methods for <code>coefs_dm</code> objects. These
objects result from a call to <code><a href="#topic+coef.fits_ids_dm">coef.fits_ids_dm()</a></code> (i.e., when
calling <code>coef()</code> with an object of type <code>fits_ids_dm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coefs_dm'
summary(object, ..., round_digits = drift_dm_default_rounding())

## S3 method for class 'summary.coefs_dm'
print(x, ..., show_header = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.coefs_dm_+3A_object">object</code></td>
<td>
<p>an object of type <code>coefs_dm</code>.</p>
</td></tr>
<tr><td><code id="summary.coefs_dm_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward.</p>
</td></tr>
<tr><td><code id="summary.coefs_dm_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, specifying the number of decimal places for
rounding the summary of the underlying <a href="base.html#topic+data.frame">data.frame</a>. Default is 3.</p>
</td></tr>
<tr><td><code id="summary.coefs_dm_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.coefs_dm</code>.</p>
</td></tr>
<tr><td><code id="summary.coefs_dm_+3A_show_header">show_header</code></td>
<td>
<p>logical. If <code>TRUE</code>, a header specifying the type of
statistic will be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.coefs_dm()</code> summarizes <code>coefs_dm</code> objects, returning the type,
a summary of the underlying <a href="base.html#topic+data.frame">data.frame</a> (<code>summary_dataframe</code>), and the
number of unique IDs (<code>n_ids</code>).
</p>


<h3>Value</h3>

<p>For <code>summary.coefs_dm()</code> a summary object of class <code>summary.coefs_dm</code>.
</p>
<p>For <code>print.summary.coefs_dm()</code>, the supplied object is returned
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a fits_ids object for demonstration purpose
fits_ids &lt;- get_example_fits_ids()
coefs &lt;- coef(fits_ids)
summary(coefs)

</code></pre>

<hr>
<h2 id='summary.drift_dm'>Summary for <code>drift_dm</code> Objects</h2><span id='topic+summary.drift_dm'></span><span id='topic+print.summary.drift_dm'></span>

<h3>Description</h3>

<p>Summary and corresponding printing methods for objects of the class
<code>drift_dm</code>, resulting from a call to <code><a href="#topic+drift_dm">drift_dm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drift_dm'
summary(object, ...)

## S3 method for class 'summary.drift_dm'
print(x, ..., round_digits = drift_dm_default_rounding())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.drift_dm_+3A_object">object</code></td>
<td>
<p>an object of class <code>drift_dm</code></p>
</td></tr>
<tr><td><code id="summary.drift_dm_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward.</p>
</td></tr>
<tr><td><code id="summary.drift_dm_+3A_x">x</code></td>
<td>
<p>an object of type <code>summary.drift_dm</code></p>
</td></tr>
<tr><td><code id="summary.drift_dm_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, specifying the number of decimal places for
rounding in the printed summary. Default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary.drift_dm()</code> function constructs a summary list with detailed
information about the <code>drift_dm</code> object, including:
</p>

<ul>
<li> <p><strong>class</strong>: The class type of the <code>drift_dm</code> object.
</p>
</li>
<li> <p><strong>summary_flex_prms</strong>: A summary of the <a href="#topic+flex_prms">flex_prms</a> object in the
model (see <a href="#topic+summary.flex_prms">summary.flex_prms</a>).
</p>
</li>
<li> <p><strong>prms_solve</strong>: Parameters used for solving the model (see
<a href="#topic+prms_solve">prms_solve</a>).
</p>
</li>
<li> <p><strong>solver</strong>: The solver used for model fitting.
</p>
</li>
<li> <p><strong>b_coding</strong>: The boundary coding for the model (see <a href="#topic+b_coding">b_coding</a>).
</p>
</li>
<li> <p><strong>obs_data</strong>: A summary table of observed response time data, if available,
by response type (upper/lower boundary responses). Includes sample size,
mean, and quantiles.
</p>
</li>
<li> <p><strong>fit_stats</strong>: Fit statistics, if available, including log-likelihood,
AIC, and BIC values.
</p>
</li></ul>

<p>The <code>print.summary.drift_dm()</code> function displays this summary in a formatted
way.
</p>


<h3>Value</h3>

<p><code>summary.drift_dm()</code> returns a list of class <code>summary.drift_dm</code> (see the
Details section summarizing each entry of this list).
</p>
<p><code>print.summary.drift_dm()</code> returns invisibly the <code>summary.drift_dm</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model for demonstration purpose
a_model &lt;- dmc_dm(t_max = 1.5, dx = .0025, dt = .0025)
sum_obj &lt;- summary(a_model)
print(sum_obj, round_digits = 2)

# more information is provided when we add data to the model
obs_data(a_model) &lt;- dmc_synth_data # (data set comes with dRiftDM)
summary(a_model)

# finally: fit indices are provided once we evaluate the model
a_model &lt;- re_evaluate_model(a_model)
summary(a_model)

</code></pre>

<hr>
<h2 id='summary.flex_prms'>Summarizing Flex Parameters</h2><span id='topic+summary.flex_prms'></span><span id='topic+print.summary.flex_prms'></span>

<h3>Description</h3>

<p>summary method for class &quot;flex_prms&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flex_prms'
summary(object, ...)

## S3 method for class 'summary.flex_prms'
print(
  x,
  ...,
  round_digits = drift_dm_default_rounding(),
  dependencies = TRUE,
  cust_parameters = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.flex_prms_+3A_object">object</code></td>
<td>
<p>an object of class <code>flex_prms</code>, resulting from a call to
<a href="#topic+flex_prms">flex_prms</a>.</p>
</td></tr>
<tr><td><code id="summary.flex_prms_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward to the respective method</p>
</td></tr>
<tr><td><code id="summary.flex_prms_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.flex_prms</code>; a result of a call to
<code>summary.flex_prms()</code>.</p>
</td></tr>
<tr><td><code id="summary.flex_prms_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, indicating the number of decimal places (round)
to be used (default is 3).</p>
</td></tr>
<tr><td><code id="summary.flex_prms_+3A_dependencies">dependencies</code></td>
<td>
<p>logical, controlling if a summary of the special
dependencies shall be printed (see the &quot;special dependency
instruction&quot; in the details of <a href="#topic+flex_prms">flex_prms</a>)</p>
</td></tr>
<tr><td><code id="summary.flex_prms_+3A_cust_parameters">cust_parameters</code></td>
<td>
<p>logical, controlling if a summary of the custom
parameters shall be printed (see the &quot;additional/custom parameter
instruction&quot; in the details of <a href="#topic+flex_prms">flex_prms</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary.flex_prms()</code> function creates a summary object containing:
</p>

<ul>
<li> <p><strong>prms_matrix</strong>: All parameter values across all conditions.
</p>
</li>
<li> <p><strong>unique_matrix</strong>: A character matrix, showing how parameters relate across
conditions.
</p>
</li>
<li> <p><strong>depend_strings</strong>: Special Dependencies, formatted as a string.
</p>
</li>
<li> <p><strong>cust_prms_matrix</strong>: (if they exist), a matrix containing all custom
parameters.
</p>
</li></ul>

<p>The <code>print.summary.flex_prms()</code> function displays the summary object in a
formatted manner.
</p>


<h3>Value</h3>

<p><code>summary.flex_prms()</code> returns a list of class <code>summary.flex_prms</code> (see the
Details section summarizing each entry of this list).
</p>
<p><code>print.summary.flex_prms()</code> returns invisibly the <code>summary.flex_prms</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a flex_prms object
flex_obj &lt;- flex_prms(c(a = 1, b = 2), conds = c("foo", "bar"))

sum_obj &lt;- summary(flex_obj)
print(sum_obj)

# the print function for the summary object is identical to the print
# function of the flex_prms object
print(flex_obj)

</code></pre>

<hr>
<h2 id='summary.stats_dm'>Summary for <code>stats_dm</code> Objects</h2><span id='topic+summary.stats_dm'></span><span id='topic+summary.cafs'></span><span id='topic+summary.quantiles'></span><span id='topic+summary.delta_funs'></span><span id='topic+summary.fit_stats'></span><span id='topic+summary.sum_dist'></span><span id='topic+summary.stats_dm_list'></span><span id='topic+print.summary.stats_dm'></span><span id='topic+print.summary.cafs'></span><span id='topic+print.summary.quantiles'></span><span id='topic+print.summary.delta_funs'></span><span id='topic+print.summary.fit_stats'></span><span id='topic+print.summary.sum_dist'></span><span id='topic+print.summary.stats_dm_list'></span>

<h3>Description</h3>

<p>Summary and corresponding printing methods for objects of the classes
<code>stats_dm</code>, <code>cafs</code>, <code>quantiles</code>, <code>delta_funs</code>, <code>fit_stats</code>, <code>sum_dist</code>, and
<code>stats_dm_list</code>. These object types result from a call to
<code><a href="#topic+calc_stats">calc_stats()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stats_dm'
summary(object, ..., round_digits = drift_dm_default_rounding())

## S3 method for class 'cafs'
summary(object, ...)

## S3 method for class 'quantiles'
summary(object, ...)

## S3 method for class 'delta_funs'
summary(object, ...)

## S3 method for class 'fit_stats'
summary(object, ...)

## S3 method for class 'sum_dist'
summary(object, ...)

## S3 method for class 'stats_dm_list'
summary(object, ...)

## S3 method for class 'summary.stats_dm'
print(x, ..., show_header = TRUE, drop_cols = NULL)

## S3 method for class 'summary.cafs'
print(x, ...)

## S3 method for class 'summary.quantiles'
print(x, ...)

## S3 method for class 'summary.delta_funs'
print(x, ...)

## S3 method for class 'summary.fit_stats'
print(x, ...)

## S3 method for class 'summary.sum_dist'
print(x, ...)

## S3 method for class 'summary.stats_dm_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.stats_dm_+3A_object">object</code></td>
<td>
<p>an object of class <code>stats_dm</code>, <code>cafs</code>, <code>quantiles</code>,
<code>delta_funs</code>, <code>fit_stats</code>, <code>sum_dist</code>, or <code>stats_dm_list</code>.</p>
</td></tr>
<tr><td><code id="summary.stats_dm_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward.</p>
</td></tr>
<tr><td><code id="summary.stats_dm_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, specifying the number of decimal places for
rounding the summary of the underlying <a href="base.html#topic+data.frame">data.frame</a>. Default is 3.</p>
</td></tr>
<tr><td><code id="summary.stats_dm_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.stats_dm</code>, <code>summary.cafs</code>,
<code>summary.quantiles</code>, <code>summary.delta_funs</code>, <code>summary.fit_stats</code>,
<code>summary.sum_dist</code>, or <code>summary.stats_dm_list</code>.</p>
</td></tr>
<tr><td><code id="summary.stats_dm_+3A_show_header">show_header</code></td>
<td>
<p>logical. If <code>TRUE</code>, a header specifying the type of
statistic will be displayed.</p>
</td></tr>
<tr><td><code id="summary.stats_dm_+3A_drop_cols">drop_cols</code></td>
<td>
<p>character vector, specifying which columns
of the table summarizing the underlying <a href="base.html#topic+data.frame">data.frame</a> should not be
displayed.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>summary.stats_dm()</code>: Summarizes <code>stats_dm</code> objects, returning the type,
a summary of the underlying <a href="base.html#topic+data.frame">data.frame</a> (<code>summary_dataframe</code>), and, if
possible, the number of unique IDs (<code>n_ids</code>).
</p>
</li>
<li> <p><code>summary.sum_dist()</code>: Extends <code>summary.stats_dm()</code> with additional
information about the source (<code>source</code>).
</p>
</li>
<li> <p><code>summary.cafs()</code>: Extends <code>summary.sum_dist()</code> with additional information
about the bins (<code>bins</code>) and conditions (<code>conds</code>).
</p>
</li>
<li> <p><code>summary.quantiles()</code>: Extends <code>summary.sum_dist()</code> with additional
information about the quantile levels (<code>probs</code>) and conditions (<code>conds</code>).
</p>
</li>
<li> <p><code>summary.delta_funs()</code>: Extends <code>summary.sum_dist()</code> with additional
information about the quantile levels (<code>probs</code>).
</p>
</li>
<li> <p><code>summary.fit_stats()</code>: Identical to <code>summary.stats_dm</code>.
</p>
</li>
<li> <p><code>summary.stats_dm_list()</code>: Applies the summary function to each element of
the list and returns a list of the respective summary objects.
</p>
</li></ul>

<p>Note the following class relationships and properties:
</p>

<ul>
<li> <p><code>cafs</code>, <code>quantiles</code>, and <code>delta_funs</code> are all inheriting from <code>sum_dist</code>.
</p>
</li>
<li><p> All <code>sum_dist</code> and <code>fit_stats</code> objects are inheriting from <code>stats_dm</code>.
</p>
</li>
<li><p> Each <code>stats_dm_list</code> object is just a list containing instances of
<code>stats_dm</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code style="white-space: pre;">&#8288;summary.*()&#8288;</code> methods, a summary object of class corresponding to the
input class.
</p>
<p>For <code style="white-space: pre;">&#8288;print.*()&#8288;</code> methods, the respective object is returned invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a model with data for demonstration purpose
a_model &lt;- dmc_dm(dx = .0025, dt = .0025, t_max = 2)
obs_data(a_model) &lt;- dmc_synth_data

# now get some statistics and call the summary functions
some_stats &lt;- calc_stats(a_model, type = c("quantiles", "fit_stats"))
summary(some_stats) # summary.stats_dm_list
summary(some_stats$quantiles) # summary.quantiles

</code></pre>

<hr>
<h2 id='summary.traces_dm'>Summary for traces_dm and traces_dm_list Objects</h2><span id='topic+summary.traces_dm'></span><span id='topic+print.summary.traces_dm'></span><span id='topic+summary.traces_dm_list'></span><span id='topic+print.summary.traces_dm_list'></span>

<h3>Description</h3>

<p>Summary and corresponding printing methods for <code>traces_dm</code> and
<code>traces_dm_list</code> objects, resulting from a call to
<code><a href="#topic+simulate_traces">simulate_traces()</a></code>. Here, <code>traces_dm</code> objects are entries of the
returned list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traces_dm'
summary(object, ...)

## S3 method for class 'summary.traces_dm'
print(x, ..., round_digits = drift_dm_default_rounding())

## S3 method for class 'traces_dm_list'
summary(object, ...)

## S3 method for class 'summary.traces_dm_list'
print(x, ..., round_digits = drift_dm_default_rounding())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.traces_dm_+3A_object">object</code></td>
<td>
<p>an object of class <code>traces_dm</code> or <code>traces_dm_list</code>.</p>
</td></tr>
<tr><td><code id="summary.traces_dm_+3A_...">...</code></td>
<td>
<p>additional arguments passed forward.</p>
</td></tr>
<tr><td><code id="summary.traces_dm_+3A_x">x</code></td>
<td>
<p>an object of type <code>summary.traces_dm</code> or <code>summary.traces_dm_list</code>.</p>
</td></tr>
<tr><td><code id="summary.traces_dm_+3A_round_digits">round_digits</code></td>
<td>
<p>integer, specifying the number of decimal places for
rounding in the printed summary. Default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary.traces_dm()</code> function constructs a summary list with
information about the <code>traces_dm</code> object, including:
</p>

<ul>
<li> <p><strong>k</strong>: The number of traces in the object.
</p>
</li>
<li> <p><strong>add_x</strong>: A logical, indicating whether starting values were added.
</p>
</li>
<li> <p><strong>orig_model_class</strong>: The class label of the original model.
</p>
</li>
<li> <p><strong>orig_prms</strong>: The parameters with which the traces were simulated (for
the respective condition)
</p>
</li>
<li> <p><strong>prms_solve</strong>: The solver settings with which the traces were simulated.
</p>
</li>
<li> <p><strong>fpt_desc</strong>: A summary of the first passage times, including mean,
standard deviation, and response probabilities for upper and lower
boundaries.
</p>
</li></ul>

<p>The <code>summary.traces_dm_list()</code> function constructs a summary list with
information about the <code>traces_dm_list</code> object, including:
</p>

<ul>
<li> <p><strong>k</strong>: A numeric vector, providing the number of traces per condition.
</p>
</li>
<li> <p><strong>add_x</strong>: A logical vector, indicating whether starting values were added
for each condition.
</p>
</li>
<li> <p><strong>orig_prms</strong>: A matrix, containing the original parameter values per
condition, with which the traces were simulated.
</p>
</li>
<li> <p><strong>orig_model_class</strong>: The class label of the original model
</p>
</li>
<li> <p><strong>prms_solve</strong>: A matrix of solver settings per condition.
</p>
</li>
<li> <p><strong>fpt_desc</strong>: A summary of the first passage times per condition, including
mean, standard deviation, and response probabilities for the upper or
lower boundary.
</p>
</li></ul>

<p>The <code>print.summary.traces_dm()</code> and  <code>print.summary.traces_dm_list()</code>
functions display the summary in a formatted way.
</p>


<h3>Value</h3>

<p><code>summary.traces_dm()</code> returns a list of class <code>summary.traces_dm</code> (see the
Details section summarizing each entry of this list).
</p>
<p><code>summary.traces_dm_list()</code> returns a list of class <code>summary.traces_dm_list</code>
(see the Details section summarizing each entry of this list).
</p>
<p><code>print.summary.traces_dm()</code> returns the <code>summary.traces_dm</code> object invisibly.
</p>
<p><code>print.summary.traces_dm_list()</code> returns the <code>summary.traces_dm_list</code> object
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a couple of traces a cross conditions
traces &lt;- simulate_traces(dmc_dm(), k = c(5, 10))
summary(traces)

# get a single traces object
one_traces_obj &lt;- traces[[1]]
summary(one_traces_obj)

</code></pre>

<hr>
<h2 id='try_cast_integer'>Convert Character Digits to Numeric Digits</h2><span id='topic+try_cast_integer'></span>

<h3>Description</h3>

<p>This internal function casts a character vector to integer, if the character
vector only contains digits for entries. If the input vector is not of
type character or if any entry contains a non-digit, then the vector is
returned unmodified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_cast_integer(values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_cast_integer_+3A_values">values</code></td>
<td>
<p>a vector of values to attempt conversion to integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector if conversion succeeds; otherwise, the original
vector.
</p>

<hr>
<h2 id='ulrich_flanker_data'>Exemplary Flanker Data</h2><span id='topic+ulrich_flanker_data'></span>

<h3>Description</h3>

<p>Data of the Flanker task collected in the course of the study by
Ulrich et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ulrich_flanker_data
</code></pre>


<h3>Format</h3>

<p>A data.frame with 16 individuals and the following columns:
</p>

<dl>
<dt>ID</dt><dd><p>Individual IDs</p>
</dd>
<dt>RT</dt><dd><p>Response Times</p>
</dd>
<dt>Error</dt><dd><p>Error Coding (Error Response = 1; Correct Response = 0)</p>
</dd>
<dt>Cond</dt><dd><p>Condition ('comp' and 'incomp')</p>
</dd>
</dl>


<hr>
<h2 id='ulrich_simon_data'>Exemplary Simon Data</h2><span id='topic+ulrich_simon_data'></span>

<h3>Description</h3>

<p>Data of the Simon task collected in the course of the study by
Ulrich et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ulrich_simon_data
</code></pre>


<h3>Format</h3>

<p>A data.frame with 16 individuals and the following columns:
</p>

<dl>
<dt>ID</dt><dd><p>Individual IDs</p>
</dd>
<dt>RT</dt><dd><p>Response Times</p>
</dd>
<dt>Error</dt><dd><p>Error Coding (Error Response = 1; Correct Response = 0)</p>
</dd>
<dt>Cond</dt><dd><p>Condition ('comp' and 'incomp')</p>
</dd>
</dl>


<hr>
<h2 id='unpack_obj'>Unpack/Destroy dRiftDM Objects</h2><span id='topic+unpack_obj'></span><span id='topic+unpack_obj.traces_dm'></span><span id='topic+unpack_obj.traces_dm_list'></span><span id='topic+unpack_obj.stats_dm'></span><span id='topic+unpack_obj.stats_dm_list'></span><span id='topic+unpack_obj.coefs_dm'></span>

<h3>Description</h3>

<p>When calling <code><a href="#topic+simulate_traces">simulate_traces()</a></code>, <a href="#topic+calc_stats">calc_stats</a>, or
<a href="#topic+coef.fits_ids_dm">coef.fits_ids_dm</a> the returned objects will be custom objects
(e.g., subclasses of <a href="base.html#topic+list">list</a> or <a href="base.html#topic+data.frame">data.frame</a>). The respective subclasses were
created to provide convenient plotting and printing, but they don't
really provide any additional functionality.
</p>
<p>The goal of <code>unpack_obj()</code> is to provide a convenient way to strip away
the attributes of the respective objects (revealing them as standard
<a href="base.html#topic+array">array</a>s, <a href="base.html#topic+data.frame">data.frame</a>s, or <a href="base.html#topic+list">list</a>s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_obj(object, ...)

## S3 method for class 'traces_dm'
unpack_obj(object, ..., unpack_elements = TRUE)

## S3 method for class 'traces_dm_list'
unpack_obj(object, ..., unpack_elements = TRUE, conds = NULL)

## S3 method for class 'stats_dm'
unpack_obj(object, ..., unpack_elements = TRUE)

## S3 method for class 'stats_dm_list'
unpack_obj(object, ..., unpack_elements = TRUE, type = NULL)

## S3 method for class 'coefs_dm'
unpack_obj(object, ..., unpack_elements = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpack_obj_+3A_object">object</code></td>
<td>
<p>an object of type <code>stats_dm</code>, <code>stats_dm_list</code>, <code>traces_dm</code>,
<code>traces_dm_list</code>, or <code>coefs_dm</code></p>
</td></tr>
<tr><td><code id="unpack_obj_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the respective method.</p>
</td></tr>
<tr><td><code id="unpack_obj_+3A_unpack_elements">unpack_elements</code></td>
<td>
<p>logical, indicating if the <code>traces_dm</code>,
<code>stats_dm</code>, or <code>coefs_dm</code> objects shall be unpacked. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unpack_obj_+3A_conds">conds</code></td>
<td>
<p>optional character vector, indicating specific condition(s). The
default <code>NULL</code> will lead to <code>conds = conds(object)</code>. Thus, per default all
conditions are addressed</p>
</td></tr>
<tr><td><code id="unpack_obj_+3A_type">type</code></td>
<td>
<p>optional character vector, indicating specific type(s) of
statistics. The default <code>NULL</code> will access all types of statics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unpack_obj()</code> is a generic function to strip away the custom information
and class labels of <code>stats_dm</code>, <code>stats_dm_list</code>, <code>traces_dm</code>,
<code>traces_dm_list</code>, and <code>coefs_dm</code> objects. These objects are created when
calling <code><a href="#topic+simulate_traces">simulate_traces()</a></code>, <a href="#topic+calc_stats">calc_stats</a>, or
<a href="#topic+coef.fits_ids_dm">coef.fits_ids_dm</a>.
</p>
<p>For <code>traces_dm_list</code>, <code>unpack_obj()</code> returns the
requested conditions (see the argument <code>conds</code>). The result contains
objects of type <code>traces_dm</code> if <code>unpack_elements = FALSE</code>. For
<code>unpack_elements = TRUE</code>, the result contains the plain <a href="base.html#topic+array">array</a>s with the
traces.
</p>
<p>For <code>stats_dm_list</code>, <code>unpack_obj()</code> returns the
requested statistics (see the argument <code>type</code>). The result contains
objects of type <code>stats_dm</code> if <code>unpack_elements = FALSE</code>. For
<code>unpack_elements = TRUE</code>, the result contains the plain <a href="base.html#topic+data.frame">data.frame</a>s with
the statistics.
</p>


<h3>Value</h3>

<p>For <code>traces_dm_list</code>, the returned value is a list, if <code>conds</code> specifies more
than one condition. For example, if <code>conds = c("foo", "bar")</code>, then the
returned value is a list with the two (named) entries &quot;foo&quot; and &quot;bar&quot;. If
the returned list would only have one entry (either because the
<code>traces_dm_list</code> has only one condition, see <a href="#topic+conds">conds</a>, or because a
user explicitly requested only one condition), then the underlying
<a href="base.html#topic+array">array</a> or <code>traces_dm</code> object is returned directly.
</p>
<p>For <code>stats_dm_list</code>, the returned value is a list, if <code>type</code> specifies more
than one condition. If the returned list would only have one entry, then
the underlying <a href="base.html#topic+data.frame">data.frame</a> or <code>stats_dm</code> object is returned directly.
</p>
<p>For <code>traces_dm</code>, <code>unpack_obj()</code> returns an <a href="base.html#topic+array">array</a> with the traces, if
<code>unpack=TRUE</code>. If <code>unpack=FALSE</code>, the unmodified object is returned.
</p>
<p>For <code>stats_dm</code>, <code>unpack_obj()</code> returns a <a href="base.html#topic+data.frame">data.frame</a> with the respective
statistic, if <code>unpack=TRUE</code>. If <code>unpack=FALSE</code>, the unmodified object is
returned.
</p>
<p>For <code>coefs_dm</code>, <code>unpack_obj()</code> returns a <a href="base.html#topic+data.frame">data.frame</a> with the
parameters, if <code>unpack=TRUE</code>. If <code>unpack=FALSE</code>, the unmodified object is
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a pre-built model to demonstrate the function
my_model &lt;- dmc_dm()

# get some traces ...
some_traces &lt;- simulate_traces(my_model, k = 2, seed = 1)
some_traces &lt;- some_traces$comp
class(some_traces)
# ... unpack them to get the underlying arrays
class(unpack_obj(some_traces))

# get some statistics ...
some_stats &lt;- calc_stats(my_model, type = "cafs")
class(some_stats)
class(unpack_obj(some_stats))

# get some parameters ...
some_coefs &lt;- coef(get_example_fits_ids())
class(some_coefs)
class(unpack_obj(some_coefs))

</code></pre>

<hr>
<h2 id='unpack_traces'>Unpack/Destroy Traces Objects</h2><span id='topic+unpack_traces'></span><span id='topic+unpack_traces.traces_dm'></span><span id='topic+unpack_traces.traces_dm_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>unpack_traces()</code> is deprecated. Please use the more general
<code><a href="#topic+unpack_obj">unpack_obj()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_traces(object, ...)

## S3 method for class 'traces_dm'
unpack_traces(object, ..., unpack = TRUE)

## S3 method for class 'traces_dm_list'
unpack_traces(object, ..., unpack = TRUE, conds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpack_traces_+3A_object">object</code></td>
<td>
<p>an object of type <code>traces_dm</code> or <code>traces_dm_list</code> (see
<code><a href="#topic+simulate_traces">simulate_traces()</a></code>)</p>
</td></tr>
<tr><td><code id="unpack_traces_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the respective method.</p>
</td></tr>
<tr><td><code id="unpack_traces_+3A_unpack">unpack</code></td>
<td>
<p>logical, indicating if the <code>traces_dm</code> objects
shall be unpacked. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unpack_traces_+3A_conds">conds</code></td>
<td>
<p>optional character, indicating specific condition(s). The
default <code>NULL</code> will lead to <code>conds = conds(object)</code>. Thus, per default all
conditions are accessed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unpack_traces()</code> was a generic function to strip away the &quot;unnecessary&quot;
information of <code>traces_dm_list</code> and <code>traces_dm</code> objects. These objects are
created when calling <code><a href="#topic+simulate_traces">simulate_traces()</a></code>.
</p>
<p>For <code>traces_dm_list</code>, <code>unpack_traces()</code> returns the
requested conditions (see the argument <code>conds</code>). The result contains
objects of type <code>traces_dm</code> if <code>unpack = FALSE</code>. For <code>unpack = TRUE</code>,
the result contains the plain arrays with the traces.
</p>


<h3>Value</h3>

<p>For <code>traces_dm_list</code>, the returned value is a list, if <code>conds</code> specifies more
than one condition. For example, if <code>conds = c("foo", "bar")</code>, then the
returned value is a list with the two (named) entries &quot;foo&quot; and &quot;bar&quot;. If
the returned list would only have one entry (either because the
<code>traces_dm_list</code> has only one condition, see <a href="#topic+conds">conds</a>, or because a
user explicitly requested only one condition), then the underlying
array or <code>traces_dm</code> object is returned directly.
</p>
<p>For <code>traces_dm</code>, <code>unpack_traces()</code> returns an array with the traces, if
<code>unpack=TRUE</code>. If <code>unpack=FALSE</code>, the unmodified object is returned.
</p>

<hr>
<h2 id='update_special_values'>Update all prms</h2><span id='topic+update_special_values'></span>

<h3>Description</h3>

<p>This function takes a flex_prms object and updates the prms_matrix according
to the special instructions in <code>internal_list</code> and the custom parameters
<code>cust_prms</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_special_values(flex_prms_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_special_values_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>a flex_prms object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified flex_prms_obj (i.e,. with the updated prms_matrix and
the updated cust_prms$values)
</p>

<hr>
<h2 id='validate_drift_dm'>Validate a DDM object</h2><span id='topic+validate_drift_dm'></span>

<h3>Description</h3>

<p>Performs basic checks to ensure everything is as expected with the model.
This function should be called whenever modifying a ddm object!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_drift_dm(drift_dm_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_drift_dm_+3A_drift_dm_obj">drift_dm_obj</code></td>
<td>
<p>the ddm object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks:
</p>

<ul>
<li><p> the flex_prms_object via <code><a href="#topic+validate_flex_prms">validate_flex_prms()</a></code>
</p>
</li>
<li><p> The prms_solve (that it is a named numeric vector
<code><a href="#topic+check_if_named_numeric_vector">check_if_named_numeric_vector()</a></code> with the expected entries) and
that nt, nx make sense. This may adjust t_max if t_max is smaller than
max(RT) of the observed data
</p>
</li>
<li><p> The solver string (only a single string and that it refers to something
that is actually implemented). If im_zero, then check if dirac delta
on 0.
</p>
</li>
<li><p> checks that the list comp_funs only contains functions and that each
function provides the expected arguments
</p>
</li>
<li><p> If PDFs exist, checks the names, lengths and data type
</p>
</li>
<li><p> Checks that log_like_val (if it exists) is a single numeric.
</p>
</li>
<li><p> Checks the data type name structure of obs_data
</p>
</li>
<li><p> Checks the b_coding (column, u_name_value and l_name_value).
</p>
</li></ul>



<h3>Value</h3>

<p>the unmodified ddm object, after it passed all checks
</p>

<hr>
<h2 id='validate_fits_ids'>Validate a an Object of Type fits_ids_dm</h2><span id='topic+validate_fits_ids'></span>

<h3>Description</h3>

<p>checks if all the information are in the fits_ids_dm (see
<a href="#topic+estimate_model_ids">estimate_model_ids</a>) object and ensures that nothing obviously
fishy is going on with the individual model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_fits_ids(fits_ids, progress)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_fits_ids_+3A_fits_ids">fits_ids</code></td>
<td>
<p>an object of type fits_ids_dm</p>
</td></tr>
<tr><td><code id="validate_fits_ids_+3A_progress">progress</code></td>
<td>
<p>numeric, 0, no progress, 1 basic output, 2 progress bars</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks:
</p>

<ul>
<li><p> if all names are in the info file
</p>
</li>
<li><p> and if the respective entries make sense
</p>
</li>
<li><p> if the flex_prms object of the all saved models and the overall
model is the same (except for the differences in the prm values).
</p>
</li>
<li><p> if the class, prms_solve and solver of the saved models and the
overall model is the same
</p>
</li>
<li><p> if the estimated parameters are in the parameter space
</p>
</li>
<li><p> for same  b_coding and same functions
</p>
</li>
<li><p> if the number of fits matches with the number of individuals
in the info file
</p>
</li>
<li><p> if the data in each fitted model matches with the observed data in
the info file
</p>
</li></ul>



<h3>Value</h3>

<p>the unmodified fits_ids objects after passing all tests.
</p>

<hr>
<h2 id='validate_flex_prms'>checks if a flex_prms_object is parameterized in a reasonable way</h2><span id='topic+validate_flex_prms'></span>

<h3>Description</h3>


<ul>
<li><p> checks internal_list
</p>
</li>
<li><p> checks liner_internal_list
</p>
</li>
<li><p> checks the parameter matrix
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_flex_prms(flex_prms_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_flex_prms_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>and object of type flex_prms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the unmodified flex_prms_obj object; only stop/warning statements
</p>

<hr>
<h2 id='validate_stats_dm'>Validate a stats_dm Object</h2><span id='topic+validate_stats_dm'></span><span id='topic+validate_stats_dm.cafs'></span><span id='topic+validate_stats_dm.quantiles'></span><span id='topic+validate_stats_dm.delta_funs'></span><span id='topic+validate_stats_dm.sum_dist'></span><span id='topic+validate_stats_dm.fit_stats'></span><span id='topic+validate_stats_dm.stats_dm'></span>

<h3>Description</h3>

<p><code>validate_stats_dm</code> is an internal (i.e., not exported) generic function to
ensure that <code>stats_dm</code> objects, as well as their specific subclasses
(<code>cafs</code>, <code>quantiles</code>, <code>delta_funs</code>, <code>sum_dist</code>, and <code>fit_stats</code>), meet the
necessary structural and column requirements. Each method performs
class-specific validation checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_stats_dm(stat_df)

## S3 method for class 'cafs'
validate_stats_dm(stat_df)

## S3 method for class 'quantiles'
validate_stats_dm(stat_df)

## S3 method for class 'delta_funs'
validate_stats_dm(stat_df)

## S3 method for class 'sum_dist'
validate_stats_dm(stat_df)

## S3 method for class 'fit_stats'
validate_stats_dm(stat_df)

## S3 method for class 'stats_dm'
validate_stats_dm(stat_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_stats_dm_+3A_stat_df">stat_df</code></td>
<td>
<p>A <code>data.frame</code> of class <code>stats_dm</code>, <code>cafs</code>, <code>quantiles</code>,
<code>delta_funs</code>, <code>sum_dist</code>, or <code>fit_stats</code> containing the calculated statistics
to be validated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validation process checks for required columns and structure based on the
class of <code>stat_df</code>. Each class has specific requirements:
</p>

<ul>
<li> <p><strong><code>validate_stats_dm.stats_dm</code>:</strong> Ensures <code>stat_df</code> is a <code>data.frame</code>.
</p>
</li>
<li> <p><strong><code>validate_stats_dm.cafs</code>:</strong> Checks for the presence of <code>"Bin"</code>, <code>"Cond"</code>,
and exactly one column prefixed with <code>"P_"</code>
</p>
</li>
<li> <p><strong><code>validate_stats_dm.quantiles</code>:</strong> Requires <code>"Prob"</code>, <code>"Cond"</code>, and exactly
two columns prefixed with <code>"Quant_"</code>
</p>
</li>
<li> <p><strong><code>validate_stats_dm.delta_funs</code>:</strong> Ensures <code>"Prob"</code> exists, at least two
columns prefixed with <code>"Quant_"</code>, and at least one column  each <code>Avg_</code>
and <code>Delta_</code>
</p>
</li>
<li> <p><strong><code>validate_stats_dm.sum_dist</code>:</strong> Checks for a <code>"Source"</code> column.
</p>
</li>
<li> <p><strong><code>validate_stats_dm.fit_stats</code>:</strong> Checks for <code>"Log_Like"</code>, <code>"AIC"</code>, and
<code>"BIC"</code> columns.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns the unmodified <code>stat_df</code> for convenience.
</p>

<hr>
<h2 id='x_beta'>Beta-Shaped Starting Point Distribution Centered Around Zero</h2><span id='topic+x_beta'></span>

<h3>Description</h3>

<p>Beta-Shaped Starting Point Distribution Centered Around Zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_beta(prms_model, prms_solve, x_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x_beta_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters; prm name &quot;alpha&quot; required</p>
</td></tr>
<tr><td><code id="x_beta_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="x_beta_+3A_x_vec">x_vec</code></td>
<td>
<p>evidence space</p>
</td></tr>
<tr><td><code id="x_beta_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="x_beta_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the PDF of a beta-shaped distribution for x_vec, centered
around zero and with a shape parameter &quot;alpha&quot;.
</p>

<hr>
<h2 id='x_dirac_0'>Constant Starting Point at Zero</h2><span id='topic+x_dirac_0'></span>

<h3>Description</h3>

<p>A dirac delta on zero, to provide no bias and a constant starting point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_dirac_0(prms_model, prms_solve, x_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x_dirac_0_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters; no prm name required</p>
</td></tr>
<tr><td><code id="x_dirac_0_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="x_dirac_0_+3A_x_vec">x_vec</code></td>
<td>
<p>evidence space</p>
</td></tr>
<tr><td><code id="x_dirac_0_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="x_dirac_0_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as x_vec with zeros, except for the
element in the middle of the vector
</p>

<hr>
<h2 id='x_uniform'>Uniform Starting Point Distribution Centered Around Zero</h2><span id='topic+x_uniform'></span>

<h3>Description</h3>

<p>Uniform Starting Point Distribution Centered Around Zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_uniform(prms_model, prms_solve, x_vec, one_cond, ddm_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x_uniform_+3A_prms_model">prms_model</code></td>
<td>
<p>the model parameters; prm name &quot;range_start&quot; required</p>
</td></tr>
<tr><td><code id="x_uniform_+3A_prms_solve">prms_solve</code></td>
<td>
<p>solver settings</p>
</td></tr>
<tr><td><code id="x_uniform_+3A_x_vec">x_vec</code></td>
<td>
<p>evidence space</p>
</td></tr>
<tr><td><code id="x_uniform_+3A_one_cond">one_cond</code></td>
<td>
<p>one condition</p>
</td></tr>
<tr><td><code id="x_uniform_+3A_ddm_opts">ddm_opts</code></td>
<td>
<p>optional arguments attached to an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the PDF of a uniform distribution for x_vec, centered around
zero and with a range of &quot;range_start&quot;.
</p>

<hr>
<h2 id='x2prms_vals'>Update the parameter matrix for vector inputs (internal docu)</h2><span id='topic+x2prms_vals'></span>

<h3>Description</h3>

<p>This function takes a numeric vector and maps the values to the parameter
matrix using the linearized internal list. This will also lead to an update
of the values for which special dependencies were set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x2prms_vals(x, flex_prms_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x2prms_vals_+3A_x">x</code></td>
<td>
<p>a numeric vector with new values to set</p>
</td></tr>
<tr><td><code id="x2prms_vals_+3A_flex_prms_obj">flex_prms_obj</code></td>
<td>
<p>a <a href="#topic+flex_prms">flex_prms</a> with the (linearized) internal
list and the parameter matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not perform input checks!
</p>


<h3>Value</h3>

<p>a flex_prms_obj with updated parameter matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
