<!DOCTYPE html><html><head><title>Help for package diyar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diyar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#attr_eval'><p>Sub-criteria attributes.</p></a></li>
<li><a href='#bys_funcs'><p>Vectorised approach to group operations.</p></a></li>
<li><a href='#combi'><p>Vector combinations</p></a></li>
<li><a href='#custom_sort'><p>Nested sorting</p></a></li>
<li><a href='#d_report'><p>d_report</p></a></li>
<li><a href='#delink'><p>Unlink group identifiers</p></a></li>
<li><a href='#encode'><p>Labelling in <code>diyar</code></p></a></li>
<li><a href='#epid-class'><p><code>epid</code> object</p></a></li>
<li><a href='#episodes'><p>Group dated events into episodes.</p></a></li>
<li><a href='#episodes_wf_splits'><p>Link events to chronological episodes.</p></a></li>
<li><a href='#link_wf'><p>Record linkage</p></a></li>
<li><a href='#links'><p>Multistage record linkage</p></a></li>
<li><a href='#listr'><p>Grammatical lists.</p></a></li>
<li><a href='#make_ids'><p>Convert an edge list to record identifiers.</p></a></li>
<li><a href='#make_pairs'><p>Combinations and permutations of record-sets.</p></a></li>
<li><a href='#make_s4_ids'><p>Create <code>epid</code> and <code>pid</code> objects with index of matching records</p></a></li>
<li><a href='#merge_identifiers'><p>Merge group identifiers</p></a></li>
<li><a href='#number_line'><p><code>number_line</code></p></a></li>
<li><a href='#number_line-class'><p><code>number_line</code> object</p></a></li>
<li><a href='#overlaps'><p>Overlapping number line objects</p></a></li>
<li><a href='#pane-class'><p><code>pane</code> object</p></a></li>
<li><a href='#partitions'><p>Distribute events into specified intervals.</p></a></li>
<li><a href='#pid-class'><p><code>pid</code> objects</p></a></li>
<li><a href='#predefined_tests'><p>Predefined logical tests in <b><code>diyar</code></b></p></a></li>
<li><a href='#reframe'><p>Modify <code>sub_criteria</code> objects</p></a></li>
<li><a href='#schema'><p>Schema diagram for group identifiers</p></a></li>
<li><a href='#set_operations'><p>Set operations on number line objects</p></a></li>
<li><a href='#staff_records'><p>Datasets in <code>diyar</code> package</p></a></li>
<li><a href='#sub_criteria'><p>Match criteria</p></a></li>
<li><a href='#windows'><p>Windows and lengths</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Record Linkage and Epidemiological Case Definitions in 'R'</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-12</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://olisansonwu.github.io/diyar/index.html">https://olisansonwu.github.io/diyar/index.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OlisaNsonwu/diyar/issues">https://github.com/OlisaNsonwu/diyar/issues</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Olisaeloka Nsonwu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olisaeloka Nsonwu &lt;olisa.nsonwu@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R package for iterative and batched record linkage, 
    and applying epidemiological case definitions.
    'diyar' can be used for deterministic and probabilistic record linkage, 
    or multistage record linkage combining both approaches.
    It features the implementation of nested match criteria, and mechanisms to 
    address missing data and conflicting matches during stepwise record linkage.
    Case definitions are implemented by assigning records to groups based on 
    match criteria such as person or place, and overlapping time or duration of 
    events e.g. sample collection dates or periods of hospital stays.
    Matching records are assigned a unique group ID. Index and duplicate records 
    are removed or further analyses as required.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, ggplot2, rlang</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-12 22:46:55 UTC; Olisaeloka.Nsonwu</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-12 23:13:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='attr_eval'>Sub-criteria attributes.</h2><span id='topic+attr_eval'></span>

<h3>Description</h3>

<p>Recursive evaluation of a function (<code>func</code>) on each attribute (vector) in a <b><code><a href="#topic+sub_criteria">sub_criteria</a></code></b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr_eval(x, func = length, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr_eval_+3A_x">x</code></td>
<td>
<p><code>[<a href="#topic+sub_criteria">sub_criteria</a>]</code></p>
</td></tr>
<tr><td><code id="attr_eval_+3A_func">func</code></td>
<td>
<p><code>[function]</code></p>
</td></tr>
<tr><td><code id="attr_eval_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code> (default), coerce to a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vector</code>; <code>list</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sub_criteria(rep(1, 5), rep(5 * 10, 5))
attr_eval(x)
attr_eval(x, func = max)
attr_eval(x, func = max, simplify = FALSE)
attr_eval(sub_criteria(x, x), func = max, simplify = FALSE)
</code></pre>

<hr>
<h2 id='bys_funcs'>Vectorised approach to group operations.</h2><span id='topic+bys_funcs'></span><span id='topic+bys_count'></span><span id='topic+bys_rank'></span><span id='topic+bys_position'></span><span id='topic+bys_val'></span><span id='topic+bys_nval'></span><span id='topic+bys_min'></span><span id='topic+bys_max'></span><span id='topic+bys_sum'></span><span id='topic+bys_prod'></span><span id='topic+bys_cummin'></span><span id='topic+bys_cummax'></span><span id='topic+bys_cumsum'></span><span id='topic+bys_cumprod'></span><span id='topic+bys_lag'></span><span id='topic+bys_lead'></span>

<h3>Description</h3>

<p>Vectorised approach to group operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bys_count(by)

bys_rank(..., by = NULL, from_last = FALSE)

bys_position(val, by = NULL, from_last = FALSE, ordered = TRUE)

bys_val(..., val, by = NULL, from_last = FALSE)

bys_nval(..., val, by = NULL, from_last = FALSE, n = 1, nmax = FALSE)

bys_min(val, by = NULL, na.rm = TRUE)

bys_max(val, by = NULL, na.rm = TRUE)

bys_sum(val, by = NULL, na.rm = TRUE)

bys_prod(val, by = NULL, na.rm = TRUE)

bys_cummin(val, by = NULL, na.rm = TRUE)

bys_cummax(val, by = NULL, na.rm = FALSE)

bys_cumsum(val, by = NULL, na.rm = TRUE)

bys_cumprod(val, by = NULL, na.rm = TRUE)

bys_lag(val, by = NULL, n = 1)

bys_lead(val, by = NULL, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bys_funcs_+3A_by">by</code></td>
<td>
<p><code>[atomic]</code>. Groups.</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_...">...</code></td>
<td>
<p><code>[atomic]</code>. Sort levels</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_from_last">from_last</code></td>
<td>
<p><code>[logical]</code> Sort order - <code>TRUE</code> (descending) or <code>FALSE</code> (ascending).</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_val">val</code></td>
<td>
<p><code>[atomic]</code>. Value</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_ordered">ordered</code></td>
<td>
<p>If <code>TRUE</code>, values are sequential.</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_n">n</code></td>
<td>
<p><code>[integer]</code> Position.</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_nmax">nmax</code></td>
<td>
<p><code>[logical]</code> If <code>TRUE</code>, use <code>length([by])</code> when <code>n</code> is greater than the number of records in a group.</p>
</td></tr>
<tr><td><code id="bys_funcs_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, remove <code>NA</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>[atomic]</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  group = c(2, 2, 1, 2, 1, 1, 1, 2, 1, 1),
  value = c(13, 14, 20, 9, 2, 1, 8, 18, 3, 17))

bys_count(x$group)
bys_position(x$value, by = x$group, from_last = TRUE)
bys_rank(by = x$group, val = x$value, from_last = TRUE)
bys_val(x$value, by = x$group, val = x$value, from_last = TRUE)
bys_nval(x$value, by = x$group, val = x$value, from_last = TRUE, n = 2)
bys_min(by = x$group, val = x$value)
bys_max(by = x$group, val = x$value)
bys_sum(by = x$group, val = x$value)
bys_prod(by = x$group, val = x$value)
bys_cummin(by = x$group, val = x$value)
bys_cummax(by = x$group, val = x$value)
bys_cumsum(by = x$group, val = x$value)
bys_cumprod(by = x$group, val = x$value)
bys_lag(by = x$group, val = x$value)
bys_lead(by = x$group, val = x$value)
</code></pre>

<hr>
<h2 id='combi'>Vector combinations</h2><span id='topic+combi'></span>

<h3>Description</h3>

<p>Numeric codes for unique combination of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combi(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combi_+3A_...">...</code></td>
<td>
<p><code>[atomic]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("A", "B", "A", "C", "B", "B")
y &lt;- c("X", "X", "Z", "Z", "X", "Z")
combi(x, y)

# The code above is equivalent to but quicker than the one below.
z &lt;- paste0(y, "-", x)
z &lt;- match(z, z)
z
</code></pre>

<hr>
<h2 id='custom_sort'>Nested sorting</h2><span id='topic+custom_sort'></span>

<h3>Description</h3>

<p>Returns a sort order after sorting by a vector within another vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_sort(..., decreasing = FALSE, unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_sort_+3A_...">...</code></td>
<td>
<p>Sequence of <code>atomic</code> vectors. Passed to <b><code><a href="base.html#topic+order">order</a></code></b>.</p>
</td></tr>
<tr><td><code id="custom_sort_+3A_decreasing">decreasing</code></td>
<td>
<p>Sort order. Passed to <b><code><a href="base.html#topic+order">order</a></code></b>.</p>
</td></tr>
<tr><td><code id="custom_sort_+3A_unique">unique</code></td>
<td>
<p>If <code>FALSE</code> (default), ties get the same rank. If <code>TRUE</code>, ties are broken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> sort order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- c(1, 1, 1, 2, 2)
b &lt;- c(2, 3, 2, 1, 1)

custom_sort(a, b)
custom_sort(b, a)
custom_sort(b, a, unique = TRUE)

</code></pre>

<hr>
<h2 id='d_report'>d_report</h2><span id='topic+d_report'></span><span id='topic+plot.d_report'></span><span id='topic+as.list.d_report'></span><span id='topic+as.data.frame.d_report'></span>

<h3>Description</h3>

<p>d_report
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'd_report'
plot(
  x,
  ...,
  metric = c("cumulative_duration", "duration", "max_memory", "records_checked",
    "records_skipped", "records_assigned")
)

## S3 method for class 'd_report'
as.list(x, ...)

## S3 method for class 'd_report'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_report_+3A_x">x</code></td>
<td>
<p><code>[d_report]</code>.</p>
</td></tr>
<tr><td><code id="d_report_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="d_report_+3A_metric">metric</code></td>
<td>
<p>Report information</p>
</td></tr>
</table>

<hr>
<h2 id='delink'>Unlink group identifiers</h2><span id='topic+delink'></span><span id='topic+delink.epid'></span><span id='topic+delink.pane'></span><span id='topic+delink.pid'></span>

<h3>Description</h3>

<p>Unlink records from an episode (<code><a href="#topic+epid-class">epid</a></code>), record group (<code><a href="#topic+pid-class">pid</a></code>) or pane (<code><a href="#topic+pane-class">pane</a></code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delink(x, lgk, ...)

## S3 method for class 'epid'
delink(x, lgk, ...)

## S3 method for class 'pane'
delink(x, lgk, ...)

## S3 method for class 'pid'
delink(x, lgk, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delink_+3A_x">x</code></td>
<td>
<p>[<code><a href="#topic+epid-class">epid</a>|<a href="#topic+pid-class">pid</a>|<a href="#topic+pane-class">pane</a>]</code></p>
</td></tr>
<tr><td><code id="delink_+3A_lgk">lgk</code></td>
<td>
<p><code>[logical]</code>. Subset of records to unlink.</p>
</td></tr>
<tr><td><code id="delink_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+epid-class">epid</a>; <a href="#topic+pid-class">pid</a>; <a href="#topic+pane-class">pane</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ep &lt;- episodes(1:8)
unlinked_ep &lt;- delink(ep, ep@sn %in% c(3, 8))
ep; unlinked_ep

pn &lt;- partitions(1:8, length.out = 2, separate = TRUE)
unlinked_pn &lt;- delink(pn, pn@.Data == 5)
pn; unlinked_pn

pd &lt;- links(list(c(1, 1, 1, NA, NA),
                 c(NA, NA, 2, 2, 2)))
unlinked_pd &lt;- delink(pd, pd@pid_cri == 1)
pd; unlinked_pd

# A warning is given if an index record is unlinked as this will lead to seemly impossible links.
ep2 &lt;- episodes(1:8, 2, episode_type = "rolling")
unlinked_ep2 &lt;- delink(ep2, ep2@sn %in% c(3, 5))
schema(ep2, custom_label = decode(ep2@case_nm), seed = 2)
schema(unlinked_ep2, custom_label = decode(unlinked_ep2@case_nm), seed = 2)
</code></pre>

<hr>
<h2 id='encode'>Labelling in <code>diyar</code></h2><span id='topic+encode'></span><span id='topic+decode'></span><span id='topic+encode.default'></span><span id='topic+encode.d_label'></span><span id='topic+decode.default'></span><span id='topic+decode.d_label'></span><span id='topic+rep.d_label'></span><span id='topic++5B.d_label'></span><span id='topic++5B+5B.d_label'></span>

<h3>Description</h3>

<p>Encode and decode character and numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode(x, ...)

decode(x, ...)

## Default S3 method:
encode(x, ...)

## S3 method for class 'd_label'
encode(x, ...)

## Default S3 method:
decode(x, ...)

## S3 method for class 'd_label'
decode(x, ...)

## S3 method for class 'd_label'
rep(x, ...)

## S3 method for class 'd_label'
x[i, ..., drop = TRUE]

## S3 method for class 'd_label'
x[[i, ..., drop = TRUE]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_+3A_x">x</code></td>
<td>
<p><code>[d_label|atomic]</code></p>
</td></tr>
<tr><td><code id="encode_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="encode_+3A_i">i</code></td>
<td>
<p>i</p>
</td></tr>
<tr><td><code id="encode_+3A_drop">drop</code></td>
<td>
<p>drop</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To minimise memory usage, most components of <code><a href="#topic+pid-class">pid</a></code>, <code><a href="#topic+epid-class">epid</a></code> and <code><a href="#topic+pane-class">pane</a></code> are <code>integer</code> objects with labels.
<b><code>encode()</code></b> and <b><code>decode()</code></b> translates these codes and labels as required.
</p>


<h3>Value</h3>

<p><code>d_label</code>; <code>atomic</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cds &lt;- encode(rep(LETTERS[1:5], 3))
cds

nms &lt;- decode(cds)
nms
</code></pre>

<hr>
<h2 id='epid-class'><code>epid</code> object</h2><span id='topic+epid-class'></span><span id='topic+is.epid'></span><span id='topic+as.epid'></span><span id='topic+format.epid'></span><span id='topic+unique.epid'></span><span id='topic+summary.epid'></span><span id='topic+print.epid_summary'></span><span id='topic+as.data.frame.epid'></span><span id='topic+as.list.epid'></span><span id='topic+show+2Cepid-method'></span><span id='topic+rep+2Cepid-method'></span><span id='topic++5B+2Cepid-method'></span><span id='topic++5B+5B+2Cepid-method'></span><span id='topic+c+2Cepid-method'></span>

<h3>Description</h3>

<p>S4 objects storing the result of <code><a href="#topic+episodes">episodes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.epid(x)

as.epid(x, ...)

## S3 method for class 'epid'
format(x, ...)

## S3 method for class 'epid'
unique(x, ...)

## S3 method for class 'epid'
summary(object, ...)

## S3 method for class 'epid_summary'
print(x, ...)

## S3 method for class 'epid'
as.data.frame(x, ..., decode = TRUE)

## S3 method for class 'epid'
as.list(x, ..., decode = TRUE)

## S4 method for signature 'epid'
show(object)

## S4 method for signature 'epid'
rep(x, ...)

## S4 method for signature 'epid'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'epid'
x[[i, j, ..., exact = TRUE]]

## S4 method for signature 'epid'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epid-class_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="epid-class_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="epid-class_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="epid-class_+3A_decode">decode</code></td>
<td>
<p>If <code>TRUE</code>, data is <code><a href="#topic+decode">decoded</a></code></p>
</td></tr>
<tr><td><code id="epid-class_+3A_i">i</code></td>
<td>
<p>i</p>
</td></tr>
<tr><td><code id="epid-class_+3A_j">j</code></td>
<td>
<p>j</p>
</td></tr>
<tr><td><code id="epid-class_+3A_drop">drop</code></td>
<td>
<p>drop</p>
</td></tr>
<tr><td><code id="epid-class_+3A_exact">exact</code></td>
<td>
<p>exact</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>sn</code></dt><dd><p>Unique record identifier.</p>
</dd>
<dt><code>.Data</code></dt><dd><p>Unique <code>episode</code> identifier.</p>
</dd>
<dt><code>wind_id</code></dt><dd><p>Unique reference ID for each match.</p>
</dd>
<dt><code>wind_nm</code></dt><dd><p>Type of window i.e. &quot;Case&quot; or &quot;Recurrence&quot;.</p>
</dd>
<dt><code>case_nm</code></dt><dd><p>Record type in regards to case assignment.</p>
</dd>
<dt><code>dist_wind_index</code></dt><dd><p>Unit difference between each record and its window's reference record.</p>
</dd>
<dt><code>dist_epid_index</code></dt><dd><p>Unit difference between each record and its episode's reference record.</p>
</dd>
<dt><code>epid_dataset</code></dt><dd><p>Data sources in each <code>episode</code>.</p>
</dd>
<dt><code>epid_interval</code></dt><dd><p>The start and end dates of each <code>episode</code>. A <code><a href="#topic+number_line">number_line</a></code> object.</p>
</dd>
<dt><code>epid_length</code></dt><dd><p>The duration or length of (<code>epid_interval</code>).</p>
</dd>
<dt><code>epid_total</code></dt><dd><p>The number of records in each <code>episode</code>.</p>
</dd>
<dt><code>iteration</code></dt><dd><p>The iteration when a record was matched to it's group (<code>.Data</code>).</p>
</dd>
<dt><code>options</code></dt><dd><p>Some options passed to the instance of <code><a href="#topic+episodes">episodes</a></code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># A test for `epid` objects
ep &lt;- episodes(date = 1)
is.epid(ep); is.epid(2)

ep &lt;- episodes(date = 1)
is.epid(ep); is.epid(2)

</code></pre>

<hr>
<h2 id='episodes'>Group dated events into episodes.</h2><span id='topic+episodes'></span><span id='topic+links_wf_episodes'></span><span id='topic+episodes_af_shift'></span>

<h3>Description</h3>

<p>Dated events (records) within a certain duration of an index event are assigned to a unique group.
Each group has unique ID and are described as <code>"episodes"</code>.
<code>"episodes"</code> can be <code>"fixed"</code> or <code>"rolling"</code> (<code>"recurring"</code>).
Each episodes has a <code>"Case"</code> and/or <code>"Recurrent"</code> record
while all other records within the group are either <code>"Duplicates"</code> of
the <code>"Case"</code> or <code>"Recurrent"</code> event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>episodes(
  date,
  case_length = Inf,
  episode_type = "fixed",
  recurrence_length = case_length,
  episode_unit = "days",
  strata = NULL,
  sn = NULL,
  episodes_max = Inf,
  rolls_max = Inf,
  case_overlap_methods = 8,
  recurrence_overlap_methods = case_overlap_methods,
  skip_if_b4_lengths = FALSE,
  data_source = NULL,
  data_links = "ANY",
  custom_sort = NULL,
  skip_order = Inf,
  reference_event = "last_record",
  case_for_recurrence = FALSE,
  from_last = FALSE,
  group_stats = c("case_nm", "wind", "epid_interval"),
  display = "none",
  case_sub_criteria = NULL,
  recurrence_sub_criteria = case_sub_criteria,
  case_length_total = 1,
  recurrence_length_total = case_length_total,
  skip_unique_strata = TRUE,
  splits_by_strata = 1,
  batched = "semi"
)

links_wf_episodes(
  date,
  case_length = Inf,
  episode_type = "fixed",
  strata = NULL,
  sn = NULL,
  display = "none"
)

episodes_af_shift(
  date,
  case_length = Inf,
  sn = NULL,
  strata = NULL,
  group_stats = FALSE,
  episode_type = "fixed",
  data_source = NULL,
  episode_unit = "days",
  data_links = "ANY",
  display = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="episodes_+3A_date">date</code></td>
<td>
<p><code>[date|datetime|integer|<a href="#topic+number_line">number_line</a>]</code>. Record date or period.</p>
</td></tr>
<tr><td><code id="episodes_+3A_case_length">case_length</code></td>
<td>
<p><code>[integer|<a href="#topic+number_line">number_line</a>]</code>. Duration from an index event distinguishing one <code>"Case"</code> from another.</p>
</td></tr>
<tr><td><code id="episodes_+3A_episode_type">episode_type</code></td>
<td>
<p><code>[character]</code>. Options are <code>"fixed"</code> (default) or <code>"rolling"</code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_recurrence_length">recurrence_length</code></td>
<td>
<p><code>[integer|<a href="#topic+number_line">number_line</a>]</code>. Duration from an index event distinguishing a <code>"Recurrent"</code> event from its <code>"Case"</code> or prior <code>"Recurrent"</code> event.</p>
</td></tr>
<tr><td><code id="episodes_+3A_episode_unit">episode_unit</code></td>
<td>
<p><code>[character]</code>. Unit of time for <code>case_length</code> and <code>recurrence_length</code>. Options are &quot;seconds&quot;, &quot;minutes&quot;, &quot;hours&quot;, &quot;days&quot; (default), &quot;weeks&quot;, &quot;months&quot; or &quot;years&quot;. See <code>diyar::episode_unit</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_strata">strata</code></td>
<td>
<p><code>[atomic]</code>. Subsets of the dataset. Episodes are created separately by each <code>strata</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_sn">sn</code></td>
<td>
<p><code>[integer]</code>. Unique record ID.</p>
</td></tr>
<tr><td><code id="episodes_+3A_episodes_max">episodes_max</code></td>
<td>
<p><code>[integer]</code>. Maximum number of episodes permitted within each <code>strata</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_rolls_max">rolls_max</code></td>
<td>
<p><code>[integer]</code>. Maximum number of times an index event can recur. Only used if <code>episode_type</code> is <code>"rolling"</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_case_overlap_methods">case_overlap_methods</code></td>
<td>
<p><code>[character|integer]</code>. Specific ways a period (record) most overlap with a <code>"Case"</code> event. See (<code><a href="#topic+overlaps">overlaps</a></code>).</p>
</td></tr>
<tr><td><code id="episodes_+3A_recurrence_overlap_methods">recurrence_overlap_methods</code></td>
<td>
<p><code>[character|integer]</code>. Specific ways a period (record) most overlap with a <code>"Recurrent"</code> event. See (<code><a href="#topic+overlaps">overlaps</a></code>).</p>
</td></tr>
<tr><td><code id="episodes_+3A_skip_if_b4_lengths">skip_if_b4_lengths</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code> (default), events before a lagged <code>case_length</code> or <code>recurrence_length</code> are skipped.</p>
</td></tr>
<tr><td><code id="episodes_+3A_data_source">data_source</code></td>
<td>
<p><code>[character]</code>. Source ID for each record. If provided, a list of all sources in each episode is returned. See <code><a href="#topic+epid-class">epid_dataset slot</a></code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_data_links">data_links</code></td>
<td>
<p><code>[list|character]</code>. <code>data_source</code> required in each <code><a href="#topic+epid-class">epid</a></code>. An episode without records from these <code>data_sources</code> will be <code><a href="#topic+delink">unlinked</a></code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_custom_sort">custom_sort</code></td>
<td>
<p><code>[atomic]</code>. Preferential order for selecting index events. See <code><a href="#topic+custom_sort">custom_sort</a></code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_skip_order">skip_order</code></td>
<td>
<p><code>[integer]</code>. End episode tracking in a <code>strata</code> when the an index event's <code>custom_sort</code> order is greater than the supplied <code>skip_order</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_reference_event">reference_event</code></td>
<td>
<p><code>[character]</code>. Specifies which of the records are used as index events. Options are <code>"last_record"</code> (default), <code>"last_event"</code>, <code>"first_record"</code> or <code>"first_event"</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_case_for_recurrence">case_for_recurrence</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, a <code>case_length</code> is applied to both <code>"Case"</code> and <code>"Recurrent"</code> events.
If <code>FALSE</code> (default), a <code>case_length</code> is applied to only <code>"Case"</code> events.</p>
</td></tr>
<tr><td><code id="episodes_+3A_from_last">from_last</code></td>
<td>
<p><code>[logical]</code>. Track episodes beginning from the earliest to the most recent record (<code>FALSE</code>) or vice versa (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="episodes_+3A_group_stats">group_stats</code></td>
<td>
<p><code>[character]</code>. A selection of group metrics to return for each episode. Most are added to slots of the <code><a href="#topic+epid-class">epid</a></code> object.
Options are <code>NULL</code> or any combination of <code>"case_nm"</code>, <code>"wind"</code> and <code>"epid_interval"</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_display">display</code></td>
<td>
<p><code>[character]</code>. Display progress update and/or generate a linkage report for the analysis. Options are; <code>"none"</code> (default), <code>"progress"</code>, <code>"stats"</code>, <code>"none_with_report"</code>, <code>"progress_with_report"</code> or <code>"stats_with_report"</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_case_sub_criteria">case_sub_criteria</code></td>
<td>
<p><code>[<a href="#topic+sub_criteria">sub_criteria</a>]</code>. Additional nested match criteria for events in a <code>case_length</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_recurrence_sub_criteria">recurrence_sub_criteria</code></td>
<td>
<p><code>[<a href="#topic+sub_criteria">sub_criteria</a>]</code>. Additional nested match criteria for events in a <code>recurrence_length</code>.</p>
</td></tr>
<tr><td><code id="episodes_+3A_case_length_total">case_length_total</code></td>
<td>
<p><code>[integer|<a href="#topic+number_line">number_line</a>]</code>. Minimum number of matched <code>case_lengths</code> required for an episode.</p>
</td></tr>
<tr><td><code id="episodes_+3A_recurrence_length_total">recurrence_length_total</code></td>
<td>
<p><code>[integer|<a href="#topic+number_line">number_line</a>]</code>. Minimum number of matched <code>recurrence_lengths</code> required for an episode.</p>
</td></tr>
<tr><td><code id="episodes_+3A_skip_unique_strata">skip_unique_strata</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, a strata with a single event is skipped.</p>
</td></tr>
<tr><td><code id="episodes_+3A_splits_by_strata">splits_by_strata</code></td>
<td>
<p><code>[integer]</code>. Split analysis into <code>n</code> parts. This typically lowers max memory usage but increases run time.</p>
</td></tr>
<tr><td><code id="episodes_+3A_batched">batched</code></td>
<td>
<p><code>[character]</code>. Create and compare records in batches. Options are <code>"yes"</code>, <code>"no"</code>, and <code>"semi"</code>.
typically, the (<code>"semi"</code>) option will have a higher max memory and shorter run-time while (<code>"no"</code>) will have a lower max memory but longer run-time</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>episodes()</code></b> links dated records (events) that
are within a set duration of each other in iterations.
Every record is linked to a unique group (episode; <code><a href="#topic+epid-class">epid</a></code> object).
These episodes represent occurrences of interest as specified by function's arguments and defined by a case definition.
</p>
<p>Two main type of episodes are possible;
</p>

<ul>
<li> <p><code>"fixed"</code> - An episode where all events are within a fixed duration of an index event.
</p>
</li>
<li> <p><code>"rolling"</code> - An episode where all events are within a recurring duration of an index event.
</p>
</li></ul>

<p>Every record in each episode is categorised as one of the following;
</p>

<ul>
<li> <p><code>"Case"</code> - Index event of the episode (without a nested match criteria).
</p>
</li>
<li> <p><code>"Case_CR"</code> - Index event of the episode (with a nested match criteria).
</p>
</li>
<li> <p><code>"Duplicate_C"</code> - Duplicate of the index event.
</p>
</li>
<li> <p><code>"Recurrent"</code> - Recurrence of the index event (without a nested match criteria).
</p>
</li>
<li> <p><code>"Recurrent_CR"</code> - Recurrence of the index event (with a nested match criteria).
</p>
</li>
<li> <p><code>"Duplicate_R"</code> - Duplicate of the recurrent event.
</p>
</li>
<li> <p><code>"Skipped"</code> - Skipped records.
</p>
</li></ul>

<p>If <code>data_links</code> is supplied, every element of the list must be named <code>"l"</code> (links) or <code>"g"</code> (groups).
Unnamed elements are assumed to be <code>"l"</code>.
</p>

<ul>
<li><p> If named <code>"l"</code>, groups without records from every listed <code>data_source</code> will be unlinked.
</p>
</li>
<li><p> If named <code>"g"</code>, groups without records from any listed <code>data_source</code> will be unlinked.
</p>
</li></ul>

<p>All records with a missing (<code>NA</code>) <code>strata</code> or <code>date</code> are skipped.
</p>
<p>Wrapper functions or alternative implementations of <b><code>episodes()</code></b> for specific use cases or benefits:
</p>

<ul>
<li> <p><b><code>episodes_wf_splits()</code></b> - Identical records are excluded from the main analysis.
</p>
</li>
<li> <p><b><code>episodes_af_shift()</code></b> - A mostly vectorised approach.
</p>
</li>
<li> <p><b><code>links_wf_episodes()</code></b> - The same functionality achieved with <code><a href="#topic+links">links</a></code>.
</p>
</li></ul>

<p>See <code>vignette("episodes")</code> for further details.
</p>


<h3>Value</h3>

<p><code><a href="#topic+epid-class">epid</a></code>; <code>list</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+episodes_wf_splits">episodes_wf_splits</a></code>; <code><a href="#topic+custom_sort">custom_sort</a></code>;
<code><a href="#topic+sub_criteria">sub_criteria</a></code>; <code><a href="#topic+windows">epid_length</a></code>;
<code><a href="#topic+windows">epid_window</a></code>; <code><a href="#topic+partitions">partitions</a></code>;
<code><a href="#topic+links">links</a></code>; <code><a href="#topic+overlaps">overlaps</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(infections)
data(hospital_admissions)

# One 16-day (15-day difference) fixed episode per type of infection
episodes(date = infections$date,
         strata = infections$infection,
         case_length = 15,
         episodes_max = 1,
         episode_type = "fixed")

# Multiple 16-day episodes with an 11-day recurrence period
episodes(date = infections$date,
         strata = NULL,
         case_length = 15,
         episodes_max = Inf,
         episode_type = "rolling",
         recurrence_length = 10)

# Overlapping periods of hospital stays
dfr &lt;- hospital_admissions[2:3]

dfr$admin_period &lt;-
  number_line(dfr$admin_dt,dfr$discharge_dt)

dfr$ep &lt;-
  episodes(date = dfr$admin_period,
           strata = NULL,
           case_length = index_window(dfr$admin_period),
           case_overlap_methods = "inbetween")

dfr
as.data.frame(dfr$ep)

</code></pre>

<hr>
<h2 id='episodes_wf_splits'>Link events to chronological episodes.</h2><span id='topic+episodes_wf_splits'></span>

<h3>Description</h3>

<p><code>episodes_wf_splits</code> is a wrapper function of <code><a href="#topic+episodes">episodes</a></code>.
It's designed to be more efficient with larger datasets.
Duplicate records which do not affect the case definition are excluded prior to episode tracking.
The resulting episode identifiers are then recycled for the duplicate records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>episodes_wf_splits(..., duplicates_recovered = "ANY", reframe = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="episodes_wf_splits_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+episodes">episodes</a></code>.</p>
</td></tr>
<tr><td><code id="episodes_wf_splits_+3A_duplicates_recovered">duplicates_recovered</code></td>
<td>
<p><code>[character]</code>. Determines which duplicate records are recycled.
Options are <code>"ANY"</code> (default), <code>"without_sub_criteria"</code>, <code>"with_sub_criteria"</code> or <code>"ALL"</code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="episodes_wf_splits_+3A_reframe">reframe</code></td>
<td>
<p><code>[logical]</code>. Determines if the duplicate records in a <code><a href="#topic+sub_criteria">sub_criteria</a></code> are reframed (<code>TRUE</code>) or excluded (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>episodes_wf_splits()</code></b> reduces or re-frames a dataset to
the minimum datasets required to implement a case definition.
This leads to the same outcome but with the benefit of a shorter processing time.
</p>
<p>The <code>duplicates_recovered</code> argument determines which identifiers are recycled.
Selecting the <code>"with_sub_criteria"</code> option will force only identifiers created resulting from a matched <code><a href="#topic+sub_criteria">sub_criteria</a></code> (<code>"Case_CR"</code> and <code>"Recurrent_CR"</code>) are recycled.
However, if <code>"without_sub_criteria"</code> is selected then only identifiers created that do not result from a matched <code><a href="#topic+sub_criteria">sub_criteria</a></code> (<code>"Case"</code> and <code>"Recurrent"</code>) are recycled
Excluded duplicates of <code>"Duplicate_C"</code> and <code>"Duplicate_R"</code> are always recycled.
</p>
<p>The <code>reframe</code> argument will either <code><a href="#topic+reframe">reframe</a></code> or subset a <code><a href="#topic+sub_criteria">sub_criteria</a></code>.
Both will require slightly different functions for <code>match_funcs</code> or <code>equal_funcs</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+epid-class">epid</a></code>; <code>list</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+episodes">episodes</a></code>; <code><a href="#topic+sub_criteria">sub_criteria</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># With 2,000 duplicate records of 20 events,
# `episodes_wf_splits()` will take less time than `episodes()`
dates &lt;- seq(from = as.Date("2019-04-01"), to = as.Date("2019-04-20"), by = 1)
dates &lt;- rep(dates, 2000)

system.time(
  ep1 &lt;- episodes(dates, 1)
)
system.time(
  ep2 &lt;- episodes_wf_splits(dates, 1)
)

# Both leads to the same outcome.
all(ep1 == ep2)
</code></pre>

<hr>
<h2 id='link_wf'>Record linkage</h2><span id='topic+link_wf'></span><span id='topic+links_af_probabilistic'></span><span id='topic+links_wf'></span><span id='topic+links_wf_probabilistic'></span><span id='topic+prob_score_range'></span>

<h3>Description</h3>

<p>Deterministic and probabilistic record linkage
Assign unique identifiers to records based on partial, nested or calculated probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>links_af_probabilistic(
  attribute,
  blocking_attribute = NULL,
  cmp_func = diyar::exact_match,
  attr_threshold = 1,
  probabilistic = TRUE,
  m_probability = 0.95,
  u_probability = NULL,
  score_threshold = 1,
  repeats_allowed = FALSE,
  permutations_allowed = FALSE,
  data_source = NULL,
  ignore_same_source = TRUE,
  display = "none"
)

links_wf_probabilistic(
  attribute,
  blocking_attribute = NULL,
  cmp_func = diyar::exact_match,
  attr_threshold = 1,
  probabilistic = TRUE,
  m_probability = 0.95,
  u_probability = NULL,
  score_threshold = 1,
  id_1 = NULL,
  id_2 = NULL,
  return_weights = FALSE,
  ...
)

prob_score_range(attribute, m_probability = 0.95, u_probability = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_wf_+3A_attribute">attribute</code></td>
<td>
<p><code>[atomic|list|data.frame|matrix|d_attribute]</code>. Attributes to compare.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_blocking_attribute">blocking_attribute</code></td>
<td>
<p><code>[atomic]</code>. Passed to <b><code>criteria</code></b> in <b><code><a href="#topic+links">links</a></code></b>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_cmp_func">cmp_func</code></td>
<td>
<p><code>[list|function]</code>. String comparators for each <code>attribute</code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_attr_threshold">attr_threshold</code></td>
<td>
<p><code>[list|numeric|<a href="#topic+number_line">number_line</a>]</code>. Weight-thresholds for each <code>cmp_func</code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_probabilistic">probabilistic</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, scores are assigned base on Fellegi-Sunter model for probabilistic record linkage. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_m_probability">m_probability</code></td>
<td>
<p><code>[list|numeric]</code>. The probability that a matching records are the same entity.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_u_probability">u_probability</code></td>
<td>
<p><code>[list|numeric]</code>. The probability that a matching records are not the same entity.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_score_threshold">score_threshold</code></td>
<td>
<p><code>[numeric|<a href="#topic+number_line">number_line</a>]</code>. Score-threshold for linked records. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_repeats_allowed">repeats_allowed</code></td>
<td>
<p><code>[logical]</code> Passed to <b><code>repeats_allowed</code></b> in <b><code><a href="#topic+links">links</a></code></b>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_permutations_allowed">permutations_allowed</code></td>
<td>
<p><code>[logical]</code> Passed to <b><code>permutations_allowed</code></b> in <b><code><a href="#topic+links">links</a></code></b>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_data_source">data_source</code></td>
<td>
<p><code>[character]</code>. Passed to <b><code>data_source</code></b> in <b><code><a href="#topic+links">links</a></code></b>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_ignore_same_source">ignore_same_source</code></td>
<td>
<p><code>[logical]</code> Passed to <b><code>ignore_same_source</code></b> in <b><code><a href="#topic+links">links</a></code></b>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_display">display</code></td>
<td>
<p><code>[character]</code>. Passed to <b><code>display</code></b> in <b><code><a href="#topic+links">links</a></code></b>.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_id_1">id_1</code></td>
<td>
<p><code>[list|numeric]</code>. Record id or index of one half of a record-pair.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_id_2">id_2</code></td>
<td>
<p><code>[list|numeric]</code>. Record id or index of one half of a record-pair.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_return_weights">return_weights</code></td>
<td>
<p>If <code>TRUE</code>, returns the match-weights and score-thresholds for record pairs.</p>
</td></tr>
<tr><td><code id="link_wf_+3A_...">...</code></td>
<td>
<p>Arguments passed to <b><code>links</code></b></p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>links_wf_probabilistic()</code></b> - A wrapper function of <code><a href="#topic+links">links</a></code> with a
with a specific <code><a href="#topic+sub_criteria">sub_criteria</a></code> and to achieve to achieve probabilistic record linkage
It excludes functionalities for the nested and multi-stage linkage.
<code>links_wf_probabilistic()</code> requires a <code>score_threshold</code> in advance.
To help with this, <code>prob_score_range()</code> can be used to return the range of scores attainable for a given set of <code>attribute</code>, <code>m</code> and <code>u</code>-probabilities.
Additionally, <code>id_1</code> and <code>id_2</code> can be used to link specific records pairs, aiding the review of potential scores.
</p>
<p><b><code>links_af_probabilistic()</code></b> - A simpler version of <code><a href="#topic+links">links</a></code>.
It excludes functionalities for the batched, nested and multi-stage linkage.
<code>links_af_probabilistic()</code> requires a <code>score_threshold</code> in advance,
however, since it exports the match weights, the <code>score_threshold</code>
can be changed after the analysis.
</p>


<h3>Value</h3>

<p><code><a href="#topic+pid-class">pid</a></code>; <code>list</code>
</p>


<h3>References</h3>

<p>Fellegi, I. P., &amp; Sunter, A. B. (1969). A Theory for Record Linkage. <em>Journal of the Statistical Association</em>, 64(328), 1183 - 1210. https://doi.org/10.1080/01621459.1969.10501049
</p>
<p>Asher, J., Resnick, D., Brite, J., Brackbill, R., &amp; Cone, J. (2020). An Introduction to Probabilistic Record Linkage with a Focus on Linkage Processing for WTC Registries. <em>International journal of environmental research and public health</em>, 17(18), 6937. https://doi.org/10.3390/ijerph17186937.
See <code>vignette("links")</code> for more information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+links">links</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(patient_records)
# Weighted (probabilistic) comparison of forename, middlename and surname
criteria_1 &lt;- as.list(patient_records[c("forename", "middlename", "surname")])

# Possible scores when m-probability is 0.95
prob_scores &lt;- prob_score_range(attribute = criteria_1,
                                m_probability = 0.95,
                                u_probability = NULL)
## Not run: 
# Probabilistic record linkage with 'links_af_probabilistic()'
pids_1a &lt;- links_af_probabilistic(attribute = criteria_1,
                        cmp_func = exact_match,
                        attr_threshold = 1,
                        probabilistic = TRUE,
                        m_probability = 0.95,
                        score_threshold = prob_scores$mid_scorce,
                        display = "stats")

# Equivalent with 'links_wf_probabilistic()'
pids_1b &lt;- links_wf_probabilistic(attribute = criteria_1,
                                  cmp_func = exact_match,
                                  attr_threshold = 1,
                                  probabilistic = TRUE,
                                  m_probability = 0.95,
                                  score_threshold = prob_scores$mid_scorce,
                                  display = "progress",
                                  recursive = TRUE,
                                  check_duplicates = TRUE)

# Less thorough but faster equivalent with `links_wf_probabilistic()`
pids_1c &lt;- links_wf_probabilistic(attribute = criteria_1,
                                  cmp_func = exact_match,
                                  attr_threshold = 1,
                                  probabilistic = TRUE,
                                  m_probability = 0.95,
                                  score_threshold = prob_scores$mid_scorce,
                                  display = "progress",
                                  recursive = FALSE,
                                  check_duplicates = FALSE)

# Each implementation can lead to different results
summary(pids_1a$pid)
summary(pids_1b$pid)
summary(pids_1c$pid)

## End(Not run)

# Weighted (non-probabilistic) comparison of forename, middlename and age difference
criteria_2 &lt;- as.list(patient_records[c("forename", "middlename", "dateofbirth")])
age_diff &lt;- function(x, y){
  diff &lt;- abs(as.numeric(x) - as.numeric(y))
  wgt &lt;-  diff %in% 0:(365 * 10) &amp; !is.na(diff)
  wgt
}

pids_2a &lt;- links_af_probabilistic(attribute = criteria_2,
                        blocking_attribute = patient_records$surname,
                        cmp_func = c(exact_match, exact_match, age_diff),
                        score_threshold = number_line(3, 5),
                        probabilistic = FALSE,
                        display = "stats")

# Larger weights can be assigned to particular attributes through `cmp_func`
# For example, a smaller age difference can contribute a higher score (e.g 0 to 3)
age_diff_2 &lt;- function(x, y){
  diff &lt;- as.numeric(abs(x - y))
  wgt &lt;-  diff %in% 0:(365 * 10) &amp; !is.na(diff)
  wgt[wgt] &lt;- match(as.numeric(cut(diff[wgt], 3)), 3:1)
  wgt
}
pids_2b &lt;- links_af_probabilistic(attribute = criteria_2,
                        blocking_attribute = patient_records$surname,
                        cmp_func = c(exact_match, exact_match, age_diff_2),
                        score_threshold = number_line(3, 5),
                        probabilistic = FALSE,
                        display = "stats")

head(pids_2a$pid_weights, 10)
head(pids_2b$pid_weights, 10)

</code></pre>

<hr>
<h2 id='links'>Multistage record linkage</h2><span id='topic+links'></span>

<h3>Description</h3>

<p>Assign records to unique groups based on an ordered set of match criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>links(
  criteria,
  sub_criteria = NULL,
  sn = NULL,
  strata = NULL,
  data_source = NULL,
  data_links = "ANY",
  display = "none",
  group_stats = FALSE,
  expand = TRUE,
  shrink = FALSE,
  recursive = "none",
  check_duplicates = FALSE,
  tie_sort = NULL,
  batched = "yes",
  repeats_allowed = FALSE,
  permutations_allowed = FALSE,
  ignore_same_source = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="links_+3A_criteria">criteria</code></td>
<td>
<p><code>[list|atomic]</code>. Ordered list of attributes to be compared. Each element of the list is a stage in the linkage process. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_sub_criteria">sub_criteria</code></td>
<td>
<p><code>[list|<a href="#topic+sub_criteria">sub_criteria</a>]</code>. Nested match criteria. This must be paired to a stage of the linkage process (<code>criteria</code>). See <code><a href="#topic+sub_criteria">sub_criteria</a></code></p>
</td></tr>
<tr><td><code id="links_+3A_sn">sn</code></td>
<td>
<p><code>[integer]</code>. Unique record ID.</p>
</td></tr>
<tr><td><code id="links_+3A_strata">strata</code></td>
<td>
<p><code>[atomic]</code>. Subsets of the dataset. Record-groups are created separately for each <code>strata</code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_data_source">data_source</code></td>
<td>
<p><code>[character]</code>. Source ID for each record. If provided, a list of all sources in each record-group is returned. See <code><a href="#topic+pid-class">pid_dataset slot</a></code>.</p>
</td></tr>
<tr><td><code id="links_+3A_data_links">data_links</code></td>
<td>
<p><code>[list|character]</code>. <code>data_source</code> required in each <code><a href="#topic+pid-class">pid</a></code>. A record-group without records from these <code>data_sources</code> will be <code><a href="#topic+delink">unlinked</a></code>. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_display">display</code></td>
<td>
<p><code>[character]</code>. Display progress update and/or generate a linkage report for the analysis. Options are; <code>"none"</code> (default), <code>"progress"</code>, <code>"stats"</code>, <code>"none_with_report"</code>, <code>"progress_with_report"</code> or <code>"stats_with_report"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_group_stats">group_stats</code></td>
<td>
<p><code>[character]</code>. A selection of group specific information to be return for each record-group. Most are added to slots of the <code><a href="#topic+pid-class">pid</a></code> object.
Options are <code>NULL</code> or any combination of <code>"XX"</code>, <code>"XX"</code> and <code>"XX"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_expand">expand</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, a record-group gains new records if a match is found at the next stage of the linkage process. <em>Not interchangeable with <code>shrink</code></em>.</p>
</td></tr>
<tr><td><code id="links_+3A_shrink">shrink</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, a record-group loses existing records if no match is found at the next stage of the linkage process. <em>Not interchangeable with <code>expand</code></em>.</p>
</td></tr>
<tr><td><code id="links_+3A_recursive">recursive</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, within each iteration of the process, a match can spawn new matches. Ignored when <code>batched</code> is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_check_duplicates">check_duplicates</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, within each iteration of the process, duplicates values of an attributes are not checked. The outcome of the logical test on the first instance of the value will be recycled for the duplicate values. Ignored when <code>batched</code> is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_tie_sort">tie_sort</code></td>
<td>
<p><code>[atomic]</code>. Preferential order for breaking match ties within an iteration of record linkage.</p>
</td></tr>
<tr><td><code id="links_+3A_batched">batched</code></td>
<td>
<p><code>[character]</code> Determines if record-pairs are created and compared in batches. Options are <code>"yes"</code>, <code>"no"</code> or <code>"semi"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_repeats_allowed">repeats_allowed</code></td>
<td>
<p><code>[logical]</code> If <code>TRUE</code>, pairs made up of repeat records are not created and compared. Only used when <code>batched</code> is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_permutations_allowed">permutations_allowed</code></td>
<td>
<p><code>[logical]</code> If <code>TRUE</code>, permutations of record-pairs are created and compared. Only used when <code>batched</code> is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="links_+3A_ignore_same_source">ignore_same_source</code></td>
<td>
<p><code>[logical]</code> If <code>TRUE</code>, only records-pairs from a different <code>data_source</code> are created and compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The priority of matches decreases with each subsequent stage of the linkage process.
Therefore, the attributes in <code>criteria</code> should be in an order of decreasing relevance.
</p>
<p>Records with missing data (<code>NA</code>) for each <code>criteria</code> are
skipped at the respective stage, while records with
missing data <code>strata</code> are skipped from every stage.
</p>
<p>If a record is skipped from a stage, another attempt will be made to
match the record at the next stage. If a record is still unmatched
by the last stage, it is assigned a unique group ID.
</p>
<p>A <code><a href="#topic+sub_criteria">sub_criteria</a></code> adds nested match criteria
to each stage of the linkage process. If used, only
records with a matching <code>criteria</code> and <code>sub_criteria</code> are linked.
</p>
<p>In <b><code><a href="#topic+links">links</a></code></b>, each <code><a href="#topic+sub_criteria">sub_criteria</a></code> must
be linked to a <code>criteria</code>. This is done by adding each <code><a href="#topic+sub_criteria">sub_criteria</a></code>
to a named element of a list - &quot;cr&quot; concatenated with
the corresponding stage's number.
For example, 3 <code>sub_criteria</code> linked to
<code>criteria</code> 1, 5 and 13 will be;
</p>
<p style="text-align: center;"><code class="reqn">list(cr1 = sub_criteria(...), cr5 = sub_criteria(...), cr13 = sub_criteria(...))</code>
</p>

<p>Any unlinked <code><a href="#topic+sub_criteria">sub_criteria</a></code> will be ignored.
</p>
<p>Every element in <code>data_links</code> must be named <code>"l"</code> (links) or <code>"g"</code> (groups).
Unnamed elements of <code>data_links</code> will be assumed to be <code>"l"</code>.
</p>

<ul>
<li><p> If named <code>"l"</code>, groups without records from every listed <code>data_source</code> will be unlinked.
</p>
</li>
<li><p> If named <code>"g"</code>, groups without records from any listed <code>data_source</code> will be unlinked.
</p>
</li></ul>

<p>See <code>vignette("links")</code> for more information.
</p>


<h3>Value</h3>

<p><code><a href="#topic+pid-class">pid</a></code>; <code>list</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+links_af_probabilistic">links_af_probabilistic</a></code>; <code><a href="#topic+episodes">episodes</a></code>;
<code><a href="#topic+predefined_tests">predefined_tests</a></code>; <code><a href="#topic+sub_criteria">sub_criteria</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(patient_records)
dfr &lt;- patient_records
# An exact match on surname followed by an exact match on forename
stages &lt;- as.list(dfr[c("surname", "forename")])
p1 &lt;- links(criteria = stages)

# An exact match on forename followed by an exact match on surname
p2 &lt;- links(criteria = rev(stages))

# Nested matches
# Same sex OR birth year
m.cri.1 &lt;- sub_criteria(
  format(dfr$dateofbirth, "%Y"), dfr$sex,
  operator = "or")

# Same middle name AND a 10 year age difference
age_diff &lt;- function(x, y){
  diff &lt;- abs(as.numeric(x) - as.numeric(y))
  wgt &lt;-  diff %in% 0:10 &amp; !is.na(diff)
  wgt
}
m.cri.2 &lt;- sub_criteria(
  format(dfr$dateofbirth, "%Y"), dfr$middlename,
  operator = "and",
  match_funcs = c(age_diff, exact_match))

# Nested match criteria 'm.cri.1' OR 'm.cri.2'
n.cri &lt;- sub_criteria(
  m.cri.1, m.cri.2,
  operator = "or")

# Record linkage with additional match criteria
p3 &lt;- links(
  criteria = stages,
  sub_criteria = list(cr1 = m.cri.1,
                      cr2 = m.cri.2))

# Record linkage with additonal nested match criteria
p4 &lt;- links(
  criteria = stages,
  sub_criteria = list(cr1 = n.cri,
                      cr2 = n.cri))

dfr$p1 &lt;- p1; dfr$p2 &lt;- p2
dfr$p3 &lt;- p3; dfr$p4 &lt;- p4

head(dfr)

</code></pre>

<hr>
<h2 id='listr'>Grammatical lists.</h2><span id='topic+listr'></span>

<h3>Description</h3>

<p>A convenience function to format <code>atomic</code> vectors as a written list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listr(x, sep = ", ", conj = " and ", lim = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listr_+3A_x">x</code></td>
<td>
<p><code>atomic</code> vector.</p>
</td></tr>
<tr><td><code id="listr_+3A_sep">sep</code></td>
<td>
<p>Separator.</p>
</td></tr>
<tr><td><code id="listr_+3A_conj">conj</code></td>
<td>
<p>Final separator.</p>
</td></tr>
<tr><td><code id="listr_+3A_lim">lim</code></td>
<td>
<p>Elements to include in the list. Other elements are abbreviated to <code>" ..."</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>listr(1:5)
listr(1:5, sep = "; ")
listr(1:5, sep = "; ", conj = " and")
listr(1:5, sep = "; ", conj = " and", lim = 2)

</code></pre>

<hr>
<h2 id='make_ids'>Convert an edge list to record identifiers.</h2><span id='topic+make_ids'></span>

<h3>Description</h3>

<p>Convert an edge list to record identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ids(x_pos, y_pos, id_length = max(x_pos, y_pos))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ids_+3A_x_pos">x_pos</code></td>
<td>
<p><code>[integer]</code>. Index of first half of a record-pair.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_y_pos">y_pos</code></td>
<td>
<p><code>[integer]</code>. Index of second half of a record-pair.</p>
</td></tr>
<tr><td><code id="make_ids_+3A_id_length">id_length</code></td>
<td>
<p>Length of the record identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Record groups from non-recursive links have the lowest record ID (<code>sn</code>) in the set as their group ID.
</p>


<h3>Value</h3>

<p><code>list</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_ids(x_pos = rep(7, 7), y_pos = 1:7)
make_ids(x_pos = c(1, 6), y_pos = 6:7)
make_ids(x_pos = 1:5, y_pos = c(1, 1, 2, 3, 4))
</code></pre>

<hr>
<h2 id='make_pairs'>Combinations and permutations of record-sets.</h2><span id='topic+make_pairs'></span><span id='topic+sets'></span><span id='topic+make_sets'></span><span id='topic+make_pairs_wf_source'></span>

<h3>Description</h3>

<p>Combinations and permutations of record-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sets(n, r, permutations_allowed = TRUE, repeats_allowed = TRUE)

make_sets(
  x,
  r,
  strata = NULL,
  permutations_allowed = TRUE,
  repeats_allowed = TRUE
)

make_pairs(
  x,
  strata = NULL,
  repeats_allowed = TRUE,
  permutations_allowed = FALSE
)

make_pairs_wf_source(..., data_source = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pairs_+3A_n">n</code></td>
<td>
<p><code>[integer]</code>. Size of Vector.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_r">r</code></td>
<td>
<p><code>[integer]</code>. Number of elements in a set.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_permutations_allowed">permutations_allowed</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, permutations of the same set are included.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_repeats_allowed">repeats_allowed</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, repeat values are included in each set.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_x">x</code></td>
<td>
<p><code>[atomic]</code>. Vector.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_strata">strata</code></td>
<td>
<p>Subsets of <code>x</code>. Blocking attribute. Limits the creation of combinations or permutations to those from the same <code>strata</code>.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+make_pairs">make_pairs</a></code>.</p>
</td></tr>
<tr><td><code id="make_pairs_+3A_data_source">data_source</code></td>
<td>
<p><code>[character]</code>. Data source identifier. Limits the creation of combinations or permutations to those from a different <code>data_source</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>set()</code></b> - Create <code>r</code>-set combinations or permutations of <code>n</code> observations.
</p>
<p><b><code>make_set()</code></b> - Create <code>r</code>-set combinations or permutations of vector <code>x</code>.
</p>
<p><b><code>make_pairs()</code></b> - Create <code>2</code>-set combinations or permutations of vector <code>x</code>.
</p>
<p><b><code>make_pairs_wf_source()</code></b> - Create <code>2</code>-set combinations or permutations of vector <code>x</code> that are from different sources (<code>data_source</code>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of a vector's elements and corresponding indexes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval_sub_criteria">eval_sub_criteria</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sets(4, 2)
sets(4, 2, repeats_allowed = FALSE, permutations_allowed = FALSE)
make_sets(month.abb[1:4], 2)
make_sets(month.abb[1:4], 3)

make_pairs(month.abb[1:4])
make_pairs(month.abb[1:4], strata = c(1, 1, 2, 2))
make_pairs_wf_source(month.abb[1:4], data_source = c(1, 1, 2, 2))

</code></pre>

<hr>
<h2 id='make_s4_ids'>Create <code>epid</code> and <code>pid</code> objects with index of matching records</h2><span id='topic+make_s4_ids'></span><span id='topic+make_episodes'></span><span id='topic+make_pids'></span>

<h3>Description</h3>

<p>Create <code>epid</code> and <code>pid</code> objects with index of matching records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_episodes(
  x_pos,
  y_pos,
  x_val,
  date,
  case_nm,
  wind_id,
  wind_nm,
  from_last,
  data_source,
  data_links,
  iteration,
  options,
  episode_unit
)

make_pids(
  x_pos,
  y_pos,
  x_val,
  link_id,
  pid_cri,
  data_source,
  data_links,
  iteration
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_s4_ids_+3A_x_pos">x_pos</code></td>
<td>
<p><code>[integer]</code>. Index of one half of a record pair.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_y_pos">y_pos</code></td>
<td>
<p><code>[integer]</code>. Index of one half of a record pair.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_x_val">x_val</code></td>
<td>
<p><code>[integer]</code>. Value of one half of a record pair.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_date">date</code></td>
<td>
<p><code>[date|datetime|integer|<a href="#topic+number_line">number_line</a>]</code>. Record date or period.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_case_nm">case_nm</code></td>
<td>
<p><code>[integer|character]</code> Record type in regards to case assignment (<code><a href="#topic+sub_criteria">sub_criteria</a>[Encoded]</code>).</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_wind_id">wind_id</code></td>
<td>
<p><code>[integer]</code>. Unique reference ID for each match.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_wind_nm">wind_nm</code></td>
<td>
<p><code>[list]</code>. Type of window i.e. &quot;Case&quot; or &quot;Recurrence&quot;.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_from_last">from_last</code></td>
<td>
<p><code>[logical]</code>. Chronological order of episode tracking i.e. ascending (<code>TRUE</code>) or descending (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_data_source">data_source</code></td>
<td>
<p><code>[character]</code>. Source ID for each record.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_data_links">data_links</code></td>
<td>
<p><code>[list|character]</code>. <code>data_source</code> required in each record-group. A record-group without records from these <code>data_sources</code> will be <code><a href="#topic+delink">unlinked</a></code>.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_iteration">iteration</code></td>
<td>
<p>The iteration when a record was matched to it's group (<code>.Data</code>).</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_options">options</code></td>
<td>
<p><code>[list]</code>. Some options passed to the instance of <code><a href="#topic+episodes">episodes</a></code>.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_episode_unit">episode_unit</code></td>
<td>
<p><code>[character]</code>. Time unit for <code>case_length</code> and <code>recurrence_length</code>. See <code><a href="#topic+episodes">episodes</a></code></p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_link_id">link_id</code></td>
<td>
<p><code>[integer]</code>. Unique reference ID for each match.</p>
</td></tr>
<tr><td><code id="make_s4_ids_+3A_pid_cri">pid_cri</code></td>
<td>
<p>Match stage of the step-wise linkage.</p>
</td></tr>
</table>

<hr>
<h2 id='merge_identifiers'>Merge group identifiers</h2><span id='topic+merge_identifiers'></span><span id='topic+merge_ids'></span><span id='topic+merge_ids.default'></span><span id='topic+merge_ids.pid'></span><span id='topic+merge_ids.epid'></span><span id='topic+merge_ids.pane'></span>

<h3>Description</h3>

<p>Consolidate two group identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_ids(...)

## Default S3 method:
merge_ids(id1, id2, tie_sort = NULL, expand = TRUE, shrink = FALSE, ...)

## S3 method for class 'pid'
merge_ids(id1, id2, tie_sort = NULL, expand = TRUE, shrink = FALSE, ...)

## S3 method for class 'epid'
merge_ids(id1, id2, tie_sort = NULL, expand = TRUE, shrink = FALSE, ...)

## S3 method for class 'pane'
merge_ids(id1, id2, tie_sort = NULL, expand = TRUE, shrink = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_identifiers_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id="merge_identifiers_+3A_id1">id1</code></td>
<td>
<p><code>[integer|<a href="#topic+epid-class">epid</a>|<a href="#topic+pid-class">pid</a>|<a href="#topic+pane-class">pane</a>]</code>.</p>
</td></tr>
<tr><td><code id="merge_identifiers_+3A_id2">id2</code></td>
<td>
<p><code>[integer|<a href="#topic+epid-class">epid</a>|<a href="#topic+pid-class">pid</a>|<a href="#topic+pane-class">pane</a>]</code>.</p>
</td></tr>
<tr><td><code id="merge_identifiers_+3A_tie_sort">tie_sort</code></td>
<td>
<p><code>[atomic]</code>. Preferential order for breaking tied matches.</p>
</td></tr>
<tr><td><code id="merge_identifiers_+3A_expand">expand</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, <code>id1</code> gains new records if <code>id2</code> indicates a match. <em>Not interchangeable with <code>shrink</code></em>.</p>
</td></tr>
<tr><td><code id="merge_identifiers_+3A_shrink">shrink</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, <code>id1</code> loses existing records <code>id2</code> does not indicate a match. <em>Not interchangeable with <code>expand</code></em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Groups in <code>id1</code> are expanded or shrunk by groups in <code>id2</code>.
</p>
<p>A unique group with only one record is considered a non-matching record.
</p>
<p>Note that the <code>expand</code> and <code>shrink</code> features are not interchangeable.
The outcome when <code>shrink</code> is <code>TRUE</code> is not the same when <code>expand</code> is <code>FALSE</code>.
See <code>Examples</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+links">links</a></code>; <code><a href="#topic+links_af_probabilistic">links_af_probabilistic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id1 &lt;- rep(1, 5)
id2 &lt;- c(2, 2, 3, 3, 3)
merge_ids(id1, id2, shrink = TRUE)

id1 &lt;- c(rep(1, 3), 6, 7)
id2 &lt;- c(2,2,3,3,3)
merge_ids(id1, id2, shrink = TRUE)
merge_ids(id1, id2, expand = FALSE)

id1 &lt;- rep(1, 5)
id2 &lt;- c(1:3, 4, 4)
merge_ids(id1, id2, shrink = TRUE)
merge_ids(id1, id2, expand= FALSE)

data(missing_staff_id)
dfr &lt;- missing_staff_id
id1 &lt;- links(dfr[[5]])
id2 &lt;- links(dfr[[6]])
merge_ids(id1, id2)
</code></pre>

<hr>
<h2 id='number_line'><code>number_line</code></h2><span id='topic+number_line'></span><span id='topic+as.number_line'></span><span id='topic+is.number_line'></span><span id='topic+left_point'></span><span id='topic+left_point+3C-'></span><span id='topic+right_point'></span><span id='topic+right_point+3C-'></span><span id='topic+start_point'></span><span id='topic+start_point+3C-'></span><span id='topic+end_point'></span><span id='topic+end_point+3C-'></span><span id='topic+number_line_width'></span><span id='topic+reverse_number_line'></span><span id='topic+shift_number_line'></span><span id='topic+expand_number_line'></span><span id='topic+invert_number_line'></span><span id='topic+number_line_sequence'></span>

<h3>Description</h3>

<p>A range of <code>numeric</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_line(l, r, id = NULL, gid = NULL)

as.number_line(x)

is.number_line(x)

left_point(x)

left_point(x) &lt;- value

right_point(x)

right_point(x) &lt;- value

start_point(x)

start_point(x) &lt;- value

end_point(x)

end_point(x) &lt;- value

number_line_width(x)

reverse_number_line(x, direction = "both")

shift_number_line(x, by = 1)

expand_number_line(x, by = 1, point = "both")

invert_number_line(x, point = "both")

number_line_sequence(
  x,
  by = NULL,
  length.out = 1,
  fill = TRUE,
  simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_line_+3A_l">l</code></td>
<td>
<p><code>[numeric-based]</code>. Left point of the <code>number_line</code>.</p>
</td></tr>
<tr><td><code id="number_line_+3A_r">r</code></td>
<td>
<p><code>[numeric-based]</code>. Right point of the <code>number_line</code>. Must be able to be coerced to a <code>numeric</code> object.</p>
</td></tr>
<tr><td><code id="number_line_+3A_id">id</code></td>
<td>
<p><code>[integer]</code>. Unique element identifier. Optional.</p>
</td></tr>
<tr><td><code id="number_line_+3A_gid">gid</code></td>
<td>
<p><code>[integer]</code>. Unique group identifier. Optional.</p>
</td></tr>
<tr><td><code id="number_line_+3A_x">x</code></td>
<td>
<p><code>[number_line]</code></p>
</td></tr>
<tr><td><code id="number_line_+3A_value">value</code></td>
<td>
<p>[<code>numeric</code> based]</p>
</td></tr>
<tr><td><code id="number_line_+3A_direction">direction</code></td>
<td>
<p><code>[character]</code>. Type of <code>number_line</code> reverse.
Options are; <code>"increasing"</code>, <code>"decreasing"</code> or <code>"both"</code> (default).</p>
</td></tr>
<tr><td><code id="number_line_+3A_by">by</code></td>
<td>
<p><code>[integer]</code>. Increment or decrement. Passed to <code>seq()</code> in <code>number_line_sequence()</code>.</p>
</td></tr>
<tr><td><code id="number_line_+3A_point">point</code></td>
<td>
<p><code>[character]</code>. <code>"start"</code>, <code>"end"</code>, <code>"left"</code> or <code>"right"</code> point.</p>
</td></tr>
<tr><td><code id="number_line_+3A_length.out">length.out</code></td>
<td>
<p><code>[integer]</code>. Number of splits. For example, <code>1</code> for two parts or <code>2</code> for three parts. Passed to <code>seq()</code>.</p>
</td></tr>
<tr><td><code id="number_line_+3A_fill">fill</code></td>
<td>
<p><code>[logical]</code>. Retain (<code>TRUE</code>) or drop (<code>FALSE</code>) the remainder of an uneven split.</p>
</td></tr>
<tr><td><code id="number_line_+3A_simplify">simplify</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, returns a sequence of finite numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>number_line</code> object represents a range of numbers.
It is made up of a <code>start</code> and <code>end</code> point as the lower and upper ends of the range respectively.
The location of the <code>start</code> point - <code>left</code> or <code>right</code>,
determines whether it is an <code>"increasing"</code> or <code>"decreasing"</code> <code>number_line</code>.
This is the <code>direction</code> of the <code>number_line</code>.
</p>
<p><b><code>reverse_number_line()</code></b> - reverse the direction of a <code>number_line</code>.
A reversed <code>number_line</code> has its <code>left</code> and <code>right</code> points swapped.
The <code>direction</code> argument specifies which type of <code>number_line</code> will be reversed.
<code>number_line</code> with non-finite <code>start</code> or <code>end</code> points (i.e. <code>NA</code>, <code>NaN</code> and <code>Inf</code>) can't be reversed.
</p>
<p><b><code>shift_number_line()</code></b> - Shift a <code>number_line</code> towards the positive or negative end of the number line.
</p>
<p><b><code>expand_number_line()</code></b> - Increase or decrease the width of a <code>number_line</code>.
</p>
<p><b><code>invert_number_line()</code></b> - Change the <code>left</code> or <code>right</code> points from a negative to positive value or vice versa.
</p>
<p><b><code>number_line_sequence()</code></b> - Split a <code>number_line</code> into equal parts (<code>length.out</code>) or by a fixed recurring width (<code>by</code>).
</p>


<h3>Value</h3>

<p><code>number_line</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlaps">overlaps</a></code>; <code><a href="#topic+set_operations">set_operations</a></code>; <code><a href="#topic+episodes">episodes</a></code>; <code><a href="#topic+links">links</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>number_line(-100, 100)

# Also compatible with other numeric based object classes
number_line(as.POSIXct("2019-05-15 13:15:07", tz = "UTC"),
            as.POSIXct("2019-05-15 15:17:10", tz = "UTC"))

# Coerce compatible object classes to `number_line` objects
as.number_line(5.1); as.number_line(as.Date("2019-10-21"))

# A test for number_line objects
a &lt;- number_line(as.Date("2019-04-25"), as.Date("2019-01-01"))
is.number_line(a)

# Structure of a number_line object
left_point(a); right_point(a); start_point(a); end_point(a)

# Reverse number_line objects
reverse_number_line(number_line(as.Date("2019-04-25"), as.Date("2019-01-01")))
reverse_number_line(number_line(200, -100), "increasing")
reverse_number_line(number_line(200, -100), "decreasing")

c &lt;- number_line(5, 6)
# Shift number_line objects towards the positive end of the number line
shift_number_line(x = c(c, c), by = c(2, 3))
# Shift number_line objects towards the negative end of the number line
shift_number_line(x = c(c, c), by = c(-2, -3))

# Change the duration, width or length of a number_line object
d &lt;- c(number_line(3, 6), number_line(6, 3))

expand_number_line(d, 2)
expand_number_line(d, -2)
expand_number_line(d, c(2,-1))
expand_number_line(d, 2, "start")
expand_number_line(d, 2, "end")

# Invert `number_line` objects
e &lt;- c(number_line(3, 6), number_line(-3, -6), number_line(-3, 6))
e
invert_number_line(e)
invert_number_line(e, "start")
invert_number_line(e, "end")

# Split number line objects
x &lt;- number_line(Sys.Date() - 5, Sys.Date())
x
number_line_sequence(x, by = 2)
number_line_sequence(x, by = 4)
number_line_sequence(x, by = 4, fill = FALSE)
number_line_sequence(x, length.out = 2)
</code></pre>

<hr>
<h2 id='number_line-class'><code>number_line</code> object</h2><span id='topic+number_line-class'></span><span id='topic+show+2Cnumber_line-method'></span><span id='topic+rep+2Cnumber_line-method'></span><span id='topic++5B+2Cnumber_line-method'></span><span id='topic++5B+5B+2Cnumber_line-method'></span><span id='topic++5B+3C-+2Cnumber_line-method'></span><span id='topic++5B+5B+3C-+2Cnumber_line-method'></span><span id='topic++24+2Cnumber_line-method'></span><span id='topic++24+3C-+2Cnumber_line-method'></span><span id='topic+c+2Cnumber_line-method'></span><span id='topic+unique.number_line'></span><span id='topic+seq.number_line'></span><span id='topic+sort.number_line'></span><span id='topic+format.number_line'></span><span id='topic+as.list.number_line'></span><span id='topic+as.data.frame.number_line'></span>

<h3>Description</h3>

<p>S4 objects representing a range of numeric values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'number_line'
show(object)

## S4 method for signature 'number_line'
rep(x, ...)

## S4 method for signature 'number_line'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'number_line'
x[[i, j, ..., exact = TRUE]]

## S4 replacement method for signature 'number_line'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'number_line'
x[[i, j, ...]] &lt;- value

## S4 method for signature 'number_line'
x$name

## S4 replacement method for signature 'number_line'
x$name &lt;- value

## S4 method for signature 'number_line'
c(x, ...)

## S3 method for class 'number_line'
unique(x, ...)

## S3 method for class 'number_line'
seq(x, precision = NULL, fill = FALSE, ...)

## S3 method for class 'number_line'
sort(x, decreasing = FALSE, ...)

## S3 method for class 'number_line'
format(x, ...)

## S3 method for class 'number_line'
as.list(x, ...)

## S3 method for class 'number_line'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_line-class_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_i">i</code></td>
<td>
<p>i</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_j">j</code></td>
<td>
<p>j</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_drop">drop</code></td>
<td>
<p>drop</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_exact">exact</code></td>
<td>
<p>exact</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_name">name</code></td>
<td>
<p>slot name</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_precision">precision</code></td>
<td>
<p>Round precision</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_fill">fill</code></td>
<td>
<p><code>[logical]</code>. Retain (<code>TRUE</code>) or
drop (<code>FALSE</code>) the remainder of an uneven split.</p>
</td></tr>
<tr><td><code id="number_line-class_+3A_decreasing">decreasing</code></td>
<td>
<p>If <code>TRUE</code>, sort in descending order.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>start</code></dt><dd><p>First value in the range.</p>
</dd>
<dt><code>id</code></dt><dd><p>Unique element id. Optional.</p>
</dd>
<dt><code>gid</code></dt><dd><p>Unique group id. Optional.</p>
</dd>
<dt><code>.Data</code></dt><dd><p>Length, duration or width of the range.</p>
</dd>
</dl>

<hr>
<h2 id='overlaps'>Overlapping number line objects</h2><span id='topic+overlaps'></span><span id='topic+overlap'></span><span id='topic+none'></span><span id='topic+exact'></span><span id='topic+across'></span><span id='topic+x_across_y'></span><span id='topic+y_across_x'></span><span id='topic+chain'></span><span id='topic+x_chain_y'></span><span id='topic+y_chain_x'></span><span id='topic+aligns_start'></span><span id='topic+x_aligns_start_y'></span><span id='topic+y_aligns_start_x'></span><span id='topic+aligns_end'></span><span id='topic+x_aligns_end_y'></span><span id='topic+y_aligns_end_x'></span><span id='topic+inbetween'></span><span id='topic+x_inbetween_y'></span><span id='topic+y_inbetween_x'></span><span id='topic+overlap_method'></span><span id='topic+include_overlap_method'></span><span id='topic+exclude_overlap_method'></span><span id='topic+overlap_method_codes'></span><span id='topic+overlap_method_names'></span>

<h3>Description</h3>

<p>Identify overlapping <code><a href="#topic+number_line">number_line</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlaps(x, y, methods = 8)

overlap(x, y)

none(x, y)

exact(x, y)

across(x, y)

x_across_y(x, y)

y_across_x(x, y)

chain(x, y)

x_chain_y(x, y)

y_chain_x(x, y)

aligns_start(x, y)

x_aligns_start_y(x, y)

y_aligns_start_x(x, y)

aligns_end(x, y)

x_aligns_end_y(x, y)

y_aligns_end_x(x, y)

inbetween(x, y)

x_inbetween_y(x, y)

y_inbetween_x(x, y)

overlap_method(x, y)

include_overlap_method(methods)

exclude_overlap_method(methods)

overlap_method_codes(methods)

overlap_method_names(methods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlaps_+3A_x">x</code></td>
<td>
<p><code>[<a href="#topic+number_line">number_line</a>]</code></p>
</td></tr>
<tr><td><code id="overlaps_+3A_y">y</code></td>
<td>
<p><code>[<a href="#topic+number_line">number_line</a>]</code></p>
</td></tr>
<tr><td><code id="overlaps_+3A_methods">methods</code></td>
<td>
<p><code>[charater|integer]</code>. Type of overlap. See <code>as.data.frame(diyar::overlap_methods$options)</code> for options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 6 mutually exclusive types of overlap;
</p>

<ul>
<li> <p><b><code>exact()</code></b> - identical <code><a href="#topic+start_point">start_point</a></code> and <code><a href="#topic+end_point">end_point</a></code> points.
</p>
</li>
<li> <p><b><code>inbetween()</code></b> - Both <code><a href="#topic+start_point">start_point</a></code> and <code><a href="#topic+end_point">end_point</a></code> of one <code><a href="#topic+number_line">number_line</a></code> object are within the <code><a href="#topic+start_point">start_point</a></code> and <code><a href="#topic+end_point">end_point</a></code> of another.
</p>
</li>
<li> <p><b><code>across()</code></b> - Only the <code><a href="#topic+start_point">start_point</a></code> or <code><a href="#topic+end_point">end_point</a></code> of one <code><a href="#topic+number_line">number_line</a></code> object is in between the <code><a href="#topic+start_point">start_point</a></code> and <code><a href="#topic+end_point">end_point</a></code> of another.
</p>
</li>
<li> <p><b><code>chain()</code></b> - <code><a href="#topic+end_point">end_point</a></code> of one <code><a href="#topic+number_line">number_line</a></code> object is identical to the <code><a href="#topic+start_point">start_point</a></code> of another.
</p>
</li>
<li> <p><b><code>aligns_start()</code></b> - identical <code><a href="#topic+start_point">start_point</a></code> only.
</p>
</li>
<li> <p><b><code>aligns_end()</code></b> - identical <code><a href="#topic+end_point">end_point</a></code> only.
</p>
</li></ul>

<p>Except <b><code>exact()</code></b>, each type of overlap has two variations;
</p>

<ul>
<li> <p><b><code>x_`method`_y()</code></b> - <code><a href="#topic+number_line">number_line</a></code>-<code>x</code> starts before <code><a href="#topic+number_line">number_line</a></code>-<code>y</code>.
</p>
</li>
<li> <p><b><code>y_`method`_x()</code></b> - <code><a href="#topic+number_line">number_line</a></code>-<code>y</code> starts before <code><a href="#topic+number_line">number_line</a></code>-<code>x</code>.
</p>
</li></ul>

<p>There are two mutually inclusive types of overlap;
</p>

<ul>
<li> <p><b><code>overlap()</code></b> - a convenient option to select &quot;ANY&quot; and &quot;ALL&quot; type of overlap.
</p>
</li>
<li> <p><b><code>none()</code></b> - a convenient option to select &quot;NO&quot; type of overlap.
</p>
</li></ul>

<p>Selecting multiple types of overlap;
</p>

<ul>
<li> <p><b><code>overlaps()</code></b> - select specific type(s) of overlap.
</p>
</li>
<li> <p><b><code>overlap_method()</code></b> - return the type of overlap for a pair of <code><a href="#topic+number_line">number_line</a></code> objects.
</p>
</li>
<li> <p><b><code>overlap_method_codes()</code></b> - return the corresponding overlap method code for a specific type(s) of overlap.
</p>
</li>
<li> <p><b><code>overlap_method_names()</code></b> - return the corresponding type(s) of overlap for a specific overlap code.
</p>
</li>
<li> <p><b><code>include_overlap_method()</code></b> - return a <b><code>character(1)</code></b> value for specified type(s) of overlap.
</p>
</li>
<li> <p><b><code>exclude_overlap_method()</code></b> - return a <b><code>character(1)</code></b> value for all type(s) of overlap except those specified.
</p>
</li></ul>



<h3>Value</h3>

<p><code>logical</code>; <code>character</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number_line">number_line</a></code>;  <code><a href="#topic+set_operations">set_operations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- number_line(-100, 100)
g &lt;- number_line(100, 100)
overlaps(a, g)

# It's neither an "exact" or "chain"-overlap
overlaps(a, g, methods = "exact|chain")

# It's an "aligns_end"-overlap
overlap_method(a, g)
overlaps(a, g, methods = "exact|chain|x_aligns_end_y")

# Corresponding overlap code
overlap_method_codes("exact|chain|x_aligns_end_y")
include_overlap_method(c("exact", "chain", "x_aligns_end_y"))

# Corresponding overlap name
overlap_method_names(overlap_method_codes("exact|chain|x_aligns_end_y"))

# Every other type overlap
exclude_overlap_method(c("exact", "chain", "x_aligns_end_y"))
overlap_method_names(exclude_overlap_method(c("exact", "chain", "x_aligns_end_y")))

# All the above is based on tests for each specific type of overlap as seen below
none(a, g)
exact(a, g)
across(a, g)
x_across_y(a, g)
y_across_x(a, g)
chain(a, g)
x_chain_y(a, g)
y_chain_x(a, g)
inbetween(a, g)
x_inbetween_y(a, g)
y_inbetween_x(a, g)
aligns_start(a, g)
x_aligns_start_y(a, g)
y_aligns_start_x(a, g)
aligns_end(a, g)
x_aligns_end_y(a, g)
y_aligns_end_x(a, g)

</code></pre>

<hr>
<h2 id='pane-class'><code>pane</code> object</h2><span id='topic+pane-class'></span><span id='topic+is.pane'></span><span id='topic+as.pane'></span><span id='topic+format.pane'></span><span id='topic+unique.pane'></span><span id='topic+summary.pane'></span><span id='topic+print.pane_summary'></span><span id='topic+as.data.frame.pane'></span><span id='topic+as.list.pane'></span><span id='topic+show+2Cpane-method'></span><span id='topic+rep+2Cpane-method'></span><span id='topic++5B+2Cpane-method'></span><span id='topic++5B+5B+2Cpane-method'></span><span id='topic+c+2Cpane-method'></span>

<h3>Description</h3>

<p>S4 objects storing the result of <code><a href="#topic+partitions">partitions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pane(x)

as.pane(x)

## S3 method for class 'pane'
format(x, ...)

## S3 method for class 'pane'
unique(x, ...)

## S3 method for class 'pane'
summary(object, ...)

## S3 method for class 'pane_summary'
print(x, ...)

## S3 method for class 'pane'
as.data.frame(x, ..., decode = TRUE)

## S3 method for class 'pane'
as.list(x, ..., decode = TRUE)

## S4 method for signature 'pane'
show(object)

## S4 method for signature 'pane'
rep(x, ...)

## S4 method for signature 'pane'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'pane'
x[[i, j, ..., exact = TRUE]]

## S4 method for signature 'pane'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pane-class_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="pane-class_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="pane-class_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="pane-class_+3A_decode">decode</code></td>
<td>
<p>If <code>TRUE</code>, data is <code><a href="#topic+decode">decoded</a></code></p>
</td></tr>
<tr><td><code id="pane-class_+3A_i">i</code></td>
<td>
<p>i</p>
</td></tr>
<tr><td><code id="pane-class_+3A_j">j</code></td>
<td>
<p>j</p>
</td></tr>
<tr><td><code id="pane-class_+3A_drop">drop</code></td>
<td>
<p>drop</p>
</td></tr>
<tr><td><code id="pane-class_+3A_exact">exact</code></td>
<td>
<p>exact</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>sn</code></dt><dd><p>Unique record identifier.</p>
</dd>
<dt><code>.Data</code></dt><dd><p>Unique <code>pane</code> identifier.</p>
</dd>
<dt><code>case_nm</code></dt><dd><p>Record type in regards to index assignment.</p>
</dd>
<dt><code>window_list</code></dt><dd><p>A list of considered <code>windows</code> for each <code>pane</code>.</p>
</dd>
<dt><code>dist_pane_index</code></dt><dd><p>The difference between each event and it's index event.</p>
</dd>
<dt><code>pane_dataset</code></dt><dd><p>Data sources in each <code>pane</code>.</p>
</dd>
<dt><code>pane_interval</code></dt><dd><p>The start and end dates of each <code>pane</code>. A <code><a href="#topic+number_line">number_line</a></code> object.</p>
</dd>
<dt><code>pane_length</code></dt><dd><p>The duration or length of (<code>pane_interval</code>).</p>
</dd>
<dt><code>pane_total</code></dt><dd><p>The number of records in each <code>pane</code>.</p>
</dd>
<dt><code>options</code></dt><dd><p>Some options passed to the instance of <code><a href="#topic+partitions">partitions</a></code>.</p>
</dd>
<dt><code>window_matched</code></dt><dd><p>A list of matched <code>windows</code> for each <code>pane</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># A test for pane objects
pn &lt;- partitions(date = 1, by = 1)
is.pane(pn); is.pane(2)

</code></pre>

<hr>
<h2 id='partitions'>Distribute events into specified intervals.</h2><span id='topic+partitions'></span>

<h3>Description</h3>

<p>Distribute events into groups defined by time or numerical intervals.
Each set of linked records are assigned a unique identifier with relevant group-level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitions(
  date,
  window = NULL,
  windows_total = 1,
  separate = FALSE,
  sn = NULL,
  strata = NULL,
  data_links = "ANY",
  custom_sort = NULL,
  group_stats = FALSE,
  data_source = NULL,
  by = NULL,
  length.out = NULL,
  fill = TRUE,
  display = "none",
  precision = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitions_+3A_date">date</code></td>
<td>
<p><code>[date|datetime|integer|<a href="#topic+number_line">number_line</a>]</code>. Event date or period.</p>
</td></tr>
<tr><td><code id="partitions_+3A_window">window</code></td>
<td>
<p><code>[integer|<a href="#topic+number_line">number_line</a>]</code>. Numeric or time intervals.</p>
</td></tr>
<tr><td><code id="partitions_+3A_windows_total">windows_total</code></td>
<td>
<p><code>[integer|<a href="#topic+number_line">number_line</a>]</code>. Minimum number of matched <code>windows</code> required for a pane. See <code>details</code></p>
</td></tr>
<tr><td><code id="partitions_+3A_separate">separate</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, events matched to different <code>windows</code> are not linked.</p>
</td></tr>
<tr><td><code id="partitions_+3A_sn">sn</code></td>
<td>
<p><code>[integer]</code>. Unique record identifier. Useful for creating familiar <code><a href="#topic+pane-class">pane</a></code> identifiers.</p>
</td></tr>
<tr><td><code id="partitions_+3A_strata">strata</code></td>
<td>
<p><code>[atomic]</code>. Subsets of the dataset. Panes are created separately for each <code>strata</code>.</p>
</td></tr>
<tr><td><code id="partitions_+3A_data_links">data_links</code></td>
<td>
<p><code>[list|character]</code>. A set of <code>data_sources</code> required in each <code><a href="#topic+pane-class">pane</a></code>. A <code><a href="#topic+pane-class">pane</a></code> without records from these <code>data_sources</code> will be unlinked. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="partitions_+3A_custom_sort">custom_sort</code></td>
<td>
<p><code>[atomic]</code>. Preferred order for selecting <code>"index"</code> events.</p>
</td></tr>
<tr><td><code id="partitions_+3A_group_stats">group_stats</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code> (default), the returned <code>pane</code> object will include group specific information like panes start and end dates.</p>
</td></tr>
<tr><td><code id="partitions_+3A_data_source">data_source</code></td>
<td>
<p><code>[character]</code>. Unique data source identifier. Adds the list of datasets in each pane to the <code><a href="#topic+pane-class">pane</a></code>. Useful when the data is from multiple sources.</p>
</td></tr>
<tr><td><code id="partitions_+3A_by">by</code></td>
<td>
<p><code>[integer]</code>. Width of splits.</p>
</td></tr>
<tr><td><code id="partitions_+3A_length.out">length.out</code></td>
<td>
<p><code>[integer]</code>. Number of splits.</p>
</td></tr>
<tr><td><code id="partitions_+3A_fill">fill</code></td>
<td>
<p><code>[logical]</code>. Retain (<code>TRUE</code>) or drop (<code>FALSE</code>) the remainder of an uneven split.</p>
</td></tr>
<tr><td><code id="partitions_+3A_display">display</code></td>
<td>
<p><code>[character]</code>. Display a status update. Options are; <code>"none"</code> (default), <code>"progress"</code> or <code>"stats"</code>.</p>
</td></tr>
<tr><td><code id="partitions_+3A_precision">precision</code></td>
<td>
<p>Round precision</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each assigned group is referred to as a <code><a href="#topic+pane-class">pane</a></code> A <code><a href="#topic+pane-class">pane</a></code> consists of events within a specific time or numerical intervals (<code>window</code>).
</p>
<p>Each <code>window</code> must cover a separate interval. Overlapping <code>windows</code> are merged before events are distributed into panes.
Events that occur over two <code>windows</code> are assigned to the last one listed.
</p>
<p>Alternatively, you can create <code>windows</code> by splitting a period into equal parts (<code>length.out</code>), or into a sequence of intervals with fixed widths (<code>by</code>).
</p>
<p>By default, the earliest event is taken as the <code>"Index"</code> event of the <code><a href="#topic+pane-class">pane</a></code>.
An alternative can be chosen with <code>custom_sort</code>.
Note that this is simply a convenience option because it has no bearing on how groups are assigned.
</p>
<p><b><code>partitions()</code></b> will categorise records into 3 types;
</p>

<ul>
<li> <p><code>"Index"</code> - Index event/record of the pane.
</p>
</li>
<li> <p><code>"Duplicate_I"</code> - Duplicate of the <code>"Index"</code> record.
</p>
</li>
<li> <p><code>"Skipped"</code> - Records that are not assigned to a pane.
</p>
</li></ul>

<p>Every element in <code>data_links</code> must be named <code>"l"</code> (links) or <code>"g"</code> (groups).
Unnamed elements of <code>data_links</code> will be assumed to be <code>"l"</code>.
</p>

<ul>
<li><p> If named <code>"l"</code>, only groups with records from every listed <code>data_source</code> will be retained.
</p>
</li>
<li><p> If named <code>"g"</code>, only groups with records from any listed <code>data_source</code> will be retained.
</p>
</li></ul>

<p><em><code>NA</code> values in <code>strata</code> excludes records from the partitioning process</em>.
</p>
<p>See <code>vignette("episodes")</code> for more information.
</p>


<h3>Value</h3>

<p><code><a href="#topic+pane-class">pane</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pane-class">pane</a></code>; <code><a href="#topic+number_line_sequence">number_line_sequence</a></code>; <code><a href="#topic+episodes">episodes</a></code>; <code><a href="#topic+links">links</a></code>; <code><a href="#topic+overlaps">overlaps</a></code>; <code><a href="#topic+number_line">number_line</a></code>; <code><a href="#topic+schema">schema</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>events &lt;- c(30, 2, 11, 10, 100)
windows &lt;- number_line(c(1, 9, 25), c(3, 12, 35))

events
partitions(date = events, length.out = 3, separate = TRUE)
partitions(date = events, by = 10, separate = TRUE)
partitions(date = events, window = windows, separate = TRUE)
partitions(date = events, window = windows, separate = FALSE)
partitions(date = events, window = windows, separate = FALSE, windows_total = 4)

</code></pre>

<hr>
<h2 id='pid-class'><code>pid</code> objects</h2><span id='topic+pid-class'></span><span id='topic+is.pid'></span><span id='topic+as.pid'></span><span id='topic+format.pid'></span><span id='topic+unique.pid'></span><span id='topic+summary.pid'></span><span id='topic+print.pid_summary'></span><span id='topic+as.data.frame.pid'></span><span id='topic+as.list.pid'></span><span id='topic+show+2Cpid-method'></span><span id='topic+rep+2Cpid-method'></span><span id='topic++5B+2Cpid-method'></span><span id='topic++5B+5B+2Cpid-method'></span><span id='topic+c+2Cpid-method'></span>

<h3>Description</h3>

<p>S4 objects storing the result of <code><a href="#topic+links">links</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pid(x)

as.pid(x, ...)

## S3 method for class 'pid'
format(x, ...)

## S3 method for class 'pid'
unique(x, ...)

## S3 method for class 'pid'
summary(object, ...)

## S3 method for class 'pid_summary'
print(x, ...)

## S3 method for class 'pid'
as.data.frame(x, ..., decode = TRUE)

## S3 method for class 'pid'
as.list(x, ..., decode = TRUE)

## S4 method for signature 'pid'
show(object)

## S4 method for signature 'pid'
rep(x, ...)

## S4 method for signature 'pid'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'pid'
x[[i, j, ..., exact = TRUE]]

## S4 method for signature 'pid'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pid-class_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="pid-class_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="pid-class_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="pid-class_+3A_decode">decode</code></td>
<td>
<p>If <code>TRUE</code>, data is <code><a href="#topic+decode">decoded</a></code></p>
</td></tr>
<tr><td><code id="pid-class_+3A_i">i</code></td>
<td>
<p>i</p>
</td></tr>
<tr><td><code id="pid-class_+3A_j">j</code></td>
<td>
<p>j</p>
</td></tr>
<tr><td><code id="pid-class_+3A_drop">drop</code></td>
<td>
<p>drop</p>
</td></tr>
<tr><td><code id="pid-class_+3A_exact">exact</code></td>
<td>
<p>exact</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>sn</code></dt><dd><p>Unique record identifier.</p>
</dd>
<dt><code>.Data</code></dt><dd><p>Unique group identifier.</p>
</dd>
<dt><code>link_id</code></dt><dd><p>Unique reference ID for each match.</p>
</dd>
<dt><code>pid_cri</code></dt><dd><p>Match stage of the step-wise linkage.</p>
</dd>
<dt><code>pid_dataset</code></dt><dd><p>Data sources in each group.</p>
</dd>
<dt><code>pid_total</code></dt><dd><p>The number of records in each group.</p>
</dd>
<dt><code>iteration</code></dt><dd><p>The iteration when a record was matched to it's group (<code>.Data</code>).</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># A test for pid objects
pd &lt;- links(criteria = 1)
is.pid(pd); is.pid(2)

</code></pre>

<hr>
<h2 id='predefined_tests'>Predefined logical tests in <b><code>diyar</code></b></h2><span id='topic+predefined_tests'></span><span id='topic+exact_match'></span><span id='topic+range_match'></span><span id='topic+prob_link'></span><span id='topic+true'></span><span id='topic+false'></span>

<h3>Description</h3>

<p>A collection of predefined logical tests used with <b><code><a href="#topic+sub_criteria">sub_criteria</a></code></b> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_match(x, y)

range_match(x, y, range = 10)

prob_link(
  x,
  y,
  cmp_func,
  attr_threshold,
  score_threshold,
  probabilistic,
  return_weights = FALSE
)

true(x, y)

false(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predefined_tests_+3A_x">x</code></td>
<td>
<p>Attribute(s) to be compared against.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_y">y</code></td>
<td>
<p>Attribute(s) to be compared by.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_range">range</code></td>
<td>
<p>Difference between <code>y</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_cmp_func">cmp_func</code></td>
<td>
<p>Logical tests such as string comparators. See <code><a href="#topic+links_wf_probabilistic">links_wf_probabilistic</a></code>.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_attr_threshold">attr_threshold</code></td>
<td>
<p>Matching set of weight thresholds for each result of <code>cmp_func</code>. See <code><a href="#topic+links_wf_probabilistic">links_wf_probabilistic</a></code>.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_score_threshold">score_threshold</code></td>
<td>
<p>Score threshold determining matched or linked records. See <code><a href="#topic+links_wf_probabilistic">links_wf_probabilistic</a></code>.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_probabilistic">probabilistic</code></td>
<td>
<p>If <code>TRUE</code>, matches determined through a score derived base on Fellegi-Sunter model for probabilistic linkage. See <code><a href="#topic+links_wf_probabilistic">links_wf_probabilistic</a></code>.</p>
</td></tr>
<tr><td><code id="predefined_tests_+3A_return_weights">return_weights</code></td>
<td>
<p>If <code>TRUE</code>, returns the match-weights and score-thresholds for record pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>exact_match()</code></b> - test that  <code>x == y</code>
</p>
<p><b><code>range_match()</code></b> - test that <code>x</code> <code class="reqn">\le</code> <code>y</code> <code class="reqn">\le</code> <code>(x + range)</code>
</p>
<p><b><code>prob_link()</code></b> - Test that a record-pair relate to the same entity based on Fellegi and Sunter (1969) model for deciding if two records belong to the same entity.
</p>
<p>In summary, record-pairs are created and categorised as matches and non-matches (<code>attr_threshold</code>) with user-defined functions (<code>cmp_func</code>).
If <code>probabilistic</code> is <code>TRUE</code>, two probabilities (<code>m</code> and <code>u</code>) are used to calculate weights for matches and non-matches.
The <code>m</code>-probability is the probability that matched records are actually from the same entity i.e. a true match,
while <code>u</code>-probability is the probability that matched records are not from the same entity i.e. a false match.
Record-pairs whose total score are above a certain threshold (<code>score_threshold</code>) are assumed to belong to the same entity.
</p>
<p>Agreement (match) and disagreement (non-match) scores are calculated as described by Asher et al. (2020).
</p>
<p>For each record pair, an agreement for attribute <code class="reqn">i</code> is calculated as;
</p>
<p style="text-align: center;"><code class="reqn">\log_{2}(m_{i}/u_{i})</code>
</p>

<p>For each record pair, a disagreement score for attribute <code class="reqn">i</code> is calculated as;
</p>
<p style="text-align: center;"><code class="reqn">\log_{2}((1-m_{i})/(1-u_{i}))</code>
</p>

<p>where <code class="reqn">m_{i}</code> and <code class="reqn">u_{i}</code> are the <code>m</code> and <code>u</code>-probabilities for each value of attribute <code class="reqn">i</code>.
</p>
<p>Note that each probability is calculated as a combined probability for the record pair.
For example, if the values of the record-pair have <code>u</code>-probabilities of <code>0.1</code> and <code>0.2</code> respectively,
then the <code>u</code>-probability for the pair will be <code>0.02</code>.
</p>
<p>Missing data (<code>NA</code>) are considered non-matches and assigned a <code>u</code>-probability of <code>0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>`exact_match`
exact_match(x = 1, y = 1)
exact_match(x = 1, y = 2)

`range_match`
range_match(x = 10, y = 16, range = 6)
range_match(x = 16, y = 10, range = 6)

</code></pre>

<hr>
<h2 id='reframe'>Modify <code>sub_criteria</code> objects</h2><span id='topic+reframe'></span><span id='topic+reframe.sub_criteria'></span>

<h3>Description</h3>

<p>Modify the attributes of a <code><a href="#topic+sub_criteria">sub_criteria</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reframe(x, ...)

## S3 method for class 'sub_criteria'
reframe(x, func = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reframe_+3A_x">x</code></td>
<td>
<p><code>[<a href="#topic+sub_criteria">sub_criteria</a>]</code>.</p>
</td></tr>
<tr><td><code id="reframe_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="reframe_+3A_func">func</code></td>
<td>
<p><code>[function]</code>. Transformation function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sub_criteria">sub_criteria</a></code>; <code><a href="#topic+eval_sub_criteria">eval_sub_criteria</a></code>; <code><a href="#topic+attr_eval">attr_eval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s_cri &lt;- sub_criteria(month.abb, month.name)
reframe(s_cri, func = function(x) x[12])
reframe(s_cri, func = function(x) x[12:1])
reframe(s_cri, func = function(x) attrs(x[1:6], x[7:12]))
</code></pre>

<hr>
<h2 id='schema'>Schema diagram for group identifiers</h2><span id='topic+schema'></span><span id='topic+schema.number_line'></span><span id='topic+schema.epid'></span><span id='topic+schema.pane'></span><span id='topic+schema.pid'></span>

<h3>Description</h3>

<p>Create schema diagrams for <code><a href="#topic+number_line-class">number_line</a></code>, <code><a href="#topic+epid-class">epid</a></code>, <code><a href="#topic+pid-class">pid</a></code> and <code><a href="#topic+pane-class">pane</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schema(x, ...)

## S3 method for class 'number_line'
schema(x, show_labels = c("date", "case_overlap_methods"), ...)

## S3 method for class 'epid'
schema(
  x,
  title = NULL,
  show_labels = c("length_arrow"),
  show_skipped = TRUE,
  show_non_finite = FALSE,
  theme = "dark",
  seed = NULL,
  custom_label = NULL,
  ...
)

## S3 method for class 'pane'
schema(
  x,
  title = NULL,
  show_labels = c("window_label"),
  theme = "dark",
  seed = NULL,
  custom_label = NULL,
  ...
)

## S3 method for class 'pid'
schema(
  x,
  title = NULL,
  show_labels = TRUE,
  theme = "dark",
  orientation = "by_pid",
  seed = NULL,
  custom_label = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schema_+3A_x">x</code></td>
<td>
<p><code>[<a href="#topic+number_line-class">number_line</a>|<a href="#topic+epid-class">epid</a>|<a href="#topic+pid-class">pid</a>|<a href="#topic+pane-class">pane</a>]</code></p>
</td></tr>
<tr><td><code id="schema_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="schema_+3A_show_labels">show_labels</code></td>
<td>
<p><code>[logical|character]</code>. Show/hide certain parts of the schema. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="schema_+3A_title">title</code></td>
<td>
<p><code>[character]</code>. Plot title.</p>
</td></tr>
<tr><td><code id="schema_+3A_show_skipped">show_skipped</code></td>
<td>
<p><code>[logical]</code>. Show/hide <code>"Skipped"</code> records.</p>
</td></tr>
<tr><td><code id="schema_+3A_show_non_finite">show_non_finite</code></td>
<td>
<p><code>[logical]</code>. Show/hide records with non-finite <code>date</code> values.</p>
</td></tr>
<tr><td><code id="schema_+3A_theme">theme</code></td>
<td>
<p><code>[character]</code>. Options are <code>"dark"</code> or <code>"light"</code>.</p>
</td></tr>
<tr><td><code id="schema_+3A_seed">seed</code></td>
<td>
<p><code>[integer]</code>. See <code>set.seed</code>. Used to get a consistent arrangement of items in the plot.</p>
</td></tr>
<tr><td><code id="schema_+3A_custom_label">custom_label</code></td>
<td>
<p><code>[character]</code>. Custom label for each record of the identifier.</p>
</td></tr>
<tr><td><code id="schema_+3A_orientation">orientation</code></td>
<td>
<p><code>[character]</code>. Show each record of a <code>pid</code> object within its group id (<code>"by_pid"</code>) or its <code>pid_cri</code> (<code>"by_pid_cri"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A visual aid to describe the data linkage (<code><a href="#topic+links">links</a></code>), episode tracking (<code><a href="#topic+episodes">episodes</a></code>) or partitioning process (<code><a href="#topic+partitions">partitions</a></code>).
</p>
<p><b><code>show_labels</code> options (multi-select)</b>
</p>

<ul>
<li><p> schema.epid - <b>TRUE</b>, <b>FALSE</b>, &quot;sn&quot;, &quot;epid&quot;, &quot;date&quot;, &quot;case_nm&quot;, &quot;wind_nm&quot;, &quot;length&quot;, &quot;length_arrow&quot;, &quot;case_overlap_methods&quot; or &quot;recurrence_overlap_methods&quot;
</p>
</li>
<li><p> schema.pane - <b>TRUE</b>, <b>FALSE</b>, &quot;sn&quot;, &quot;pane&quot;, &quot;date&quot;, &quot;case_nm&quot; or &quot;window_label&quot;
</p>
</li>
<li><p> schema.pid - <b>TRUE</b>, <b>FALSE</b>, &quot;sn&quot; or &quot;pid&quot;
</p>
</li></ul>



<h3>Value</h3>

<p><code>ggplot</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>schema(number_line(c(1, 2), c(2, 1)))

schema(episodes(1:10, 2))

schema(partitions(1:10, by = 2, separate = TRUE))

schema(links(list(c(1, 1, NA, NA), c(NA, 1, 1, NA))))

</code></pre>

<hr>
<h2 id='set_operations'>Set operations on number line objects</h2><span id='topic+set_operations'></span><span id='topic+union_number_lines'></span><span id='topic+intersect_number_lines'></span><span id='topic+subtract_number_lines'></span>

<h3>Description</h3>

<p>Perform set operations on a pair of <code>[<a href="#topic+number_line">number_line</a>]</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>union_number_lines(x, y)

intersect_number_lines(x, y)

subtract_number_lines(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_operations_+3A_x">x</code></td>
<td>
<p><code>[<a href="#topic+number_line">number_line</a>]</code></p>
</td></tr>
<tr><td><code id="set_operations_+3A_y">y</code></td>
<td>
<p><code>[<a href="#topic+number_line">number_line</a>]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>union_number_lines()</code></b> - Combined the range of <code>x</code> and that of <code>y</code>
</p>
<p><b><code>intersect_number_line()</code></b> - Subset of <code>x</code> that overlaps with <code>y</code> and vice versa
</p>
<p><b><code>subtract_number_lines()</code></b> - Subset of <code>x</code> that does not overlap with <code>y</code> and vice versa.
</p>
<p>The <code>direction</code> of the returned <code>[<a href="#topic+number_line">number_line</a>]</code> will be that of the widest one (<code>x</code> or <code>y</code>).
If <code>x</code> and <code>y</code> have the same length, it'll be an <code>"increasing"</code> direction.
</p>
<p>If <code>x</code> and <code>y</code> do not overlap, <code>NA</code> (<code>"NA ?? NA"</code>) is returned.
</p>


<h3>Value</h3>

<p><code>[<a href="#topic+number_line">number_line</a>]</code>; <code>list</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number_line">number_line</a></code>;  <code><a href="#topic+overlaps">overlaps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nl_1 &lt;- c(number_line(1, 5), number_line(1, 5), number_line(5, 9))
nl_2 &lt;- c(number_line(1, 2), number_line(2, 3), number_line(0, 6))

# Union
nl_1; nl_2; union_number_lines(nl_1, nl_2)


nl_3 &lt;- number_line(as.Date(c("01/01/2020", "03/01/2020","09/01/2020"), "%d/%m/%Y"),
                    as.Date(c("09/01/2020", "09/01/2020","25/12/2020"), "%d/%m/%Y"))

nl_4 &lt;- number_line(as.Date(c("04/01/2020","01/01/2020","01/01/2020"), "%d/%m/%Y"),
                    as.Date(c("05/01/2020","05/01/2020","03/01/2020"), "%d/%m/%Y"))

# Intersect
nl_3; nl_4; intersect_number_lines(nl_3, nl_4)

# Subtract
nl_3; nl_4; subtract_number_lines(nl_3, nl_4)

</code></pre>

<hr>
<h2 id='staff_records'>Datasets in <code>diyar</code> package</h2><span id='topic+staff_records'></span><span id='topic+missing_staff_id'></span><span id='topic+infections'></span><span id='topic+infections_2'></span><span id='topic+infections_3'></span><span id='topic+infections_4'></span><span id='topic+hospital_admissions'></span><span id='topic+patient_list'></span><span id='topic+patient_list_2'></span><span id='topic+hourly_data'></span><span id='topic+Opes'></span><span id='topic+episode_unit'></span><span id='topic+overlap_methods'></span><span id='topic+patient_records'></span>

<h3>Description</h3>

<p>Datasets in <code>diyar</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(staff_records)

data(missing_staff_id)

data(infections)

data(infections_2)

data(infections_3)

data(infections_4)

data(hospital_admissions)

data(patient_list)

data(patient_list_2)

data(hourly_data)

data(Opes)

data(episode_unit)

data(overlap_methods)

data(patient_records)
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>An object of class <code>data.frame</code> with 5 rows and 4 columns.
</p>
<p>data.frame
</p>
<p>data.frame
</p>
<p>list
</p>
<p>list
</p>
<p>data.frame
</p>


<h3>Details</h3>

<p>staff_records - Staff record with some missing data
</p>
<p>missing_staff_id - Staff records with missing staff identifiers
</p>
<p>infections, infections_2, infections_3 and infections_4 - Reports of bacterial infections
</p>
<p>hospital_admissions - Hospital admissions and discharges
</p>
<p>patient_list &amp; patient_list_2 - Patient list with some missing data
</p>
<p>Hourly data
</p>
<p>Opes - List of individuals with the same name
</p>
<p>Duration in seconds for each 'episode_unit'
</p>
<p>Permutations of <code><a href="#topic+number_line">number_line</a></code> overlap methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(staff_records)
data(missing_staff_id)
data(infections)
data(infections_2)
data(infections_3)
data(infections_4)
data(hospital_admissions)
data(patient_list)
data(patient_list_2)
data(hourly_data)
data(Opes)
data(episode_unit)
data(overlap_methods)
data(patient_records)
</code></pre>

<hr>
<h2 id='sub_criteria'>Match criteria</h2><span id='topic+sub_criteria'></span><span id='topic+attrs'></span><span id='topic+eval_sub_criteria'></span><span id='topic+print.sub_criteria'></span><span id='topic+format.sub_criteria'></span><span id='topic+eval_sub_criteria.sub_criteria'></span>

<h3>Description</h3>

<p>Match criteria for record linkage with <b><code><a href="#topic+links">links</a></code></b> and <b><code><a href="#topic+episodes">episodes</a></code></b>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_criteria(
  ...,
  match_funcs = c(exact = diyar::exact_match),
  equal_funcs = c(exact = diyar::exact_match),
  operator = "or"
)

attrs(..., .obj = NULL)

eval_sub_criteria(x, ...)

## S3 method for class 'sub_criteria'
print(x, ...)

## S3 method for class 'sub_criteria'
format(x, show_levels = FALSE, ...)

## S3 method for class 'sub_criteria'
eval_sub_criteria(
  x,
  x_pos = seq_len(max(attr_eval(x))),
  y_pos = rep(1L, length(x_pos)),
  check_duplicates = TRUE,
  depth = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_criteria_+3A_...">...</code></td>
<td>
<p><code>[atomic]</code> Attributes passed to or <code>eval_sub_criteria()</code> or <code>eval_sub_criteria()</code>
</p>
<p>Arguments passed to methods for <code>eval_sub_criteria()</code></p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_match_funcs">match_funcs</code></td>
<td>
<p><code>[function]</code>. User defined logical test for matches.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_equal_funcs">equal_funcs</code></td>
<td>
<p><code>[function]</code>. User defined logical test for identical record sets (all attributes of the same record).</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_operator">operator</code></td>
<td>
<p><code>[character]</code>. Options are <code>"and"</code> or <code>"or"</code>.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_.obj">.obj</code></td>
<td>
<p><code>[data.frame|list]</code>. Attributes.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_x">x</code></td>
<td>
<p><code>[sub_criteria]</code>. Attributes.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_show_levels">show_levels</code></td>
<td>
<p><code>[logical]</code>. If <code>TRUE</code>, show recursive depth for each logic statement of the match criteria.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_x_pos">x_pos</code></td>
<td>
<p><code>[integer]</code>. Index of one half of a record pair.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_y_pos">y_pos</code></td>
<td>
<p><code>[integer]</code>. Index of one half of a record pair.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_check_duplicates">check_duplicates</code></td>
<td>
<p><code>[logical]</code>. If <code>FALSE</code>, does not check duplicate values. The result of the initial check will be recycled.</p>
</td></tr>
<tr><td><code id="sub_criteria_+3A_depth">depth</code></td>
<td>
<p><code>[integer]</code>. First order of recursion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>sub_criteria()</code></b> - Create a match criteria as a <code>sub_criteria</code> object.
A <code>sub_criteria</code> object contains attributes to be compared,
logical tests for the comparisons (see <b><code><a href="#topic+predefined_tests">predefined_tests</a></code></b> for examples) and
another set of logical tests to determine identical records.
</p>
<p><b><code>attrs()</code></b> - Create a <code>d_attribute</code> object - a collection of atomic objects that can be passed to <b><code>sub_criteria()</code></b> as a single attribute.
</p>
<p><b><code>eval_sub_criteria()</code></b> - Evaluates a <code>sub_criteria</code> object.
</p>
<p>At each iteration of <code><a href="#topic+links">links</a></code> or <code><a href="#topic+episodes">episodes</a></code>, record-pairs are created from each attribute of a <code>sub_criteria</code> object.
<code>eval_sub_criteria()</code> evaluates each record-pair using the <code>match_funcs</code> and <code>equal_funcs</code> functions of a <code>sub_criteria</code> object.
See <b><code><a href="#topic+predefined_tests">predefined_tests</a></code></b> for examples of <code>match_funcs</code> and <code>equal_funcs</code>.
</p>
<p>User-defined functions are also permitted as <code>match_funcs</code> and <code>equal_funcs</code>.
Such functions must meet three requirements:
</p>

<ol>
<li><p> It must be able to compare the attributes.
</p>
</li>
<li><p> It must have two arguments named <code>`x`</code> and <code>`y`</code>, where <code>`y`</code> is the value for one observation being compared against all other observations (<code>`x`</code>).
</p>
</li>
<li><p> It must return a <code>logical</code> object i.e. <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ol>

<p><code>attrs()</code> is useful when the match criteria requires an interaction between the multiple attributes. For example, attribute 1 + attribute 2 &gt; attribute 3.
</p>
<p>Every attribute, including those in <code>attrs()</code>, must have the same length or a length of 1.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sub_criteria">sub_criteria</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predefined_tests">predefined_tests</a></code>; <code><a href="#topic+links">links</a></code>; <code><a href="#topic+episodes">episodes</a></code>; <code><a href="#topic+eval_sub_criteria">eval_sub_criteria</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attributes
attr_1 &lt;- c(30, 28, 40, 25, 25, 29, 27)
attr_2 &lt;- c("M", "F", "U", "M", "F", "U", "M")

# A match criteria
## Example 1 - A maximum difference of 10 in attribute 1
s_cri1 &lt;- sub_criteria(attr_1, match_funcs = range_match)
s_cri1

# Evaluate the match criteria
## Compare the first element of 'attr_1' against all other elements
eval_sub_criteria(s_cri1)
## Compare the second element of 'attr_1' against all other elements
x_pos_val &lt;- seq_len(max(attr_eval(s_cri1)))
eval_sub_criteria(s_cri1,
                  x_pos = x_pos_val,
                  y_pos = rep(2, length(x_pos_val)))

## Example 2 - `s_cri1` AND an exact match on attribute 2
s_cri2 &lt;- sub_criteria(
  s_cri1,
  sub_criteria(attr_2, match_funcs = exact_match),
  operator = "and")
s_cri2

## Example 3 - `s_cri1` OR an exact match on attribute 2
s_cri3 &lt;- sub_criteria(
  s_cri1,
  sub_criteria(attr_2, match_funcs = exact_match),
  operator = "or")
s_cri3

# Evaluate the match criteria
eval_sub_criteria(s_cri2)
eval_sub_criteria(s_cri3)

# Alternatively, using `attr()`
AND_func &lt;- function(x, y) range_match(x$a1, y$a1) &amp; x$a2 == y$a2
OR_func &lt;- function(x, y) range_match(x$a1, y$a1) | x$a2 == y$a2

## Create a match criteria
s_cri2b &lt;- sub_criteria(attrs(.obj = list(a1 = attr_1, a2 = attr_2)),
                        match_funcs = AND_func)
s_cri3b &lt;- sub_criteria(attrs(.obj = list(a1 = attr_1, a2 = attr_2)),
                        match_funcs = OR_func)

# Evaluate the match criteria
eval_sub_criteria(s_cri2b)
eval_sub_criteria(s_cri3b)

</code></pre>

<hr>
<h2 id='windows'>Windows and lengths</h2><span id='topic+windows'></span><span id='topic+epid_windows'></span><span id='topic+epid_lengths'></span><span id='topic+index_window'></span>

<h3>Description</h3>

<p>Covert <code>windows</code> to and from <code>case_lengths</code> and <code>recurrence_lengths</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epid_windows(date, lengths, episode_unit = "days")

epid_lengths(date, windows, episode_unit = "days")

index_window(date, from_last = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="windows_+3A_date">date</code></td>
<td>
<p>As used in <b><code><a href="#topic+episodes">episodes</a></code></b>.</p>
</td></tr>
<tr><td><code id="windows_+3A_lengths">lengths</code></td>
<td>
<p>The duration (<code>lengths</code>) between a <code>date</code> and <code>window</code>.</p>
</td></tr>
<tr><td><code id="windows_+3A_episode_unit">episode_unit</code></td>
<td>
<p>Time unit of <code>lengths</code>. Options are &quot;seconds&quot;, &quot;minutes&quot;, &quot;hours&quot;, &quot;days&quot;, &quot;weeks&quot;, &quot;months&quot; or &quot;years&quot;. See <code>diyar::episode_unit</code></p>
</td></tr>
<tr><td><code id="windows_+3A_windows">windows</code></td>
<td>
<p>The range (<code>windows</code>) relative to a <code>date</code> for a given duration (<code>length</code>).</p>
</td></tr>
<tr><td><code id="windows_+3A_from_last">from_last</code></td>
<td>
<p>As used in <b><code><a href="#topic+episodes">episodes</a></code></b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b><code>epid_windows</code></b> - returns the corresponding <code>window</code> for a given a <code>date</code>, and <code>case_length</code> or <code>recurrence_length</code>.
</p>
<p><b><code>epid_lengths</code></b> - returns the corresponding <code>case_length</code> or <code>recurrence_length</code> for a given <code>date</code> and <code>window</code>.
</p>
<p><b><code>index_window</code></b> - returns the corresponding <code>case_length</code> or <code>recurrence_length</code> for the <code>date</code> only.
</p>
<p><b><code>index_window(date = x)</code></b> is a convenience function for <b><code>epid_lengths(date = x, window = x)</code></b>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+number_line">number_line</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Which `window` will a given `length` cover?
date &lt;- Sys.Date()
epid_windows(date, 10)
epid_windows(date, number_line(5, 10))
epid_windows(date, number_line(-5, 10))
epid_windows(date, -5)


# Which `length` is required to cover a given `window`?
date &lt;- number_line(Sys.Date(), Sys.Date() + 20)
epid_lengths(date, Sys.Date() + 30)
epid_lengths(date, number_line(Sys.Date() + 25, Sys.Date() + 30))
epid_lengths(date, number_line(Sys.Date() - 10, Sys.Date() + 30))
epid_lengths(date, Sys.Date() - 10)

# Which `length` is required to cover the `date`?
index_window(20)
index_window(number_line(15, 20))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
