<!DOCTYPE html><html lang="en"><head><title>Help for package hts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hts-package'><p>Hierarchical and grouped time series</p></a></li>
<li><a href='#accuracy.gts'><p>In-sample or out-of-sample accuracy measures for forecast grouped and</p>
hierarchical model</a></li>
<li><a href='#aggts'><p>Extract selected time series from a gts object</p></a></li>
<li><a href='#allts'><p>Extract all time series from a gts object</p></a></li>
<li><a href='#combinef'><p>Optimally combine forecasts from a hierarchical or grouped time series</p></a></li>
<li><a href='#forecast.gts'><p>Forecast a hierarchical or grouped time series</p></a></li>
<li><a href='#get_groups'><p>Get nodes/groups from an hts/gts object</p></a></li>
<li><a href='#gts'><p>Create a grouped time series</p></a></li>
<li><a href='#hts'><p>Create a hierarchical time series</p></a></li>
<li><a href='#htseg1'><p>Simple examples of hierarchical time series.</p></a></li>
<li><a href='#infantgts'><p>Regional infant mortality counts across Australia from 1933 to 2003.</p></a></li>
<li><a href='#MinT'><p>Trace minimization for hierarchical or grouped time series</p></a></li>
<li><a href='#plot.gts'><p>Plot grouped or hierarchical time series</p></a></li>
<li><a href='#smatrix'><p>Summing matrix for hierarchical or grouped time series</p></a></li>
<li><a href='#window.gts'><p>Time window of a gts object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Hierarchical and Grouped Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>6.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for analysing and forecasting hierarchical and 
    grouped time series. The available forecast methods include bottom-up,
    top-down, optimal combination reconciliation (Hyndman et al. 2011) 
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2011.03.006">doi:10.1016/j.csda.2011.03.006</a>&gt;, and trace minimization reconciliation
    (Wickramasuriya et al. 2018) &lt;<a href="https://doi.org/10.1080%2F01621459.2018.1448825">doi:10.1080/01621459.2018.1448825</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), forecast (&ge; 8.12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>SparseM, Matrix, parallel, utils, methods, graphics,
grDevices, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, rmarkdown, covr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0), RcppEigen</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pkg.earo.me/hts/">https://pkg.earo.me/hts/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/earowang/hts/issues">https://github.com/earowang/hts/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-30 12:57:59 UTC; earo</td>
</tr>
<tr>
<td>Author:</td>
<td>Rob Hyndman [aut] (Package creator),
  Alan Lee [aut] (Fast computation using recursive methods),
  Earo Wang [aut, cre],
  Shanika Wickramasuriya [aut] (Reconciliation via trace minimization)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Earo Wang &lt;earo.wang@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-30 13:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='hts-package'>Hierarchical and grouped time series</h2><span id='topic+hts-package'></span>

<h3>Description</h3>

<p>This package presents functions to create, plot and forecast hierarchical
and grouped time series. In forecasting hierarchical and grouped time
series, the base methods implemented include ETS, ARIMA and the naive
(random walk) models. Forecasts for grouped time series are calibrated using
bottom-up and optimal combination methods. Forecasts for hierarchical time
series are distributed in the hierarchy using bottom-up, top-down,
middle-out and optimal combination methods. Three top-down methods are
available: the two Gross-Sohl methods and the forecast-proportion approach
of Hyndman, Ahmed, and Athanasopoulos (2011).
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman, Alan Lee, Earo Wang and Shanika L Wickramasuriya with
contributions from Roman A Ahmed and Han Lin Shang to earlier versions of the
package
</p>


<h3>References</h3>

<p>G. Athanasopoulos, R. A. Ahmed and R. J. Hyndman (2009)
Hierarchical forecasts for Australian domestic tourism, <em>International
Journal of Forecasting</em>, <b>25</b>, 146-166.
</p>
<p>R. J. Hyndman, R. A. Ahmed, G. Athanasopoulos and H.L. Shang (2011) Optimal
combination forecasts for hierarchical time series.  <em>Computational
Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>
<p>Hyndman, R. J., Lee, A., &amp; Wang, E. (2016).  Fast computation of reconciled
forecasts for hierarchical and grouped time series. <em>Computational Statistics and Data Analysis</em>,
<b>97</b>, 16-23. <a href="https://robjhyndman.com/papers/hgts7.pdf">https://robjhyndman.com/papers/hgts7.pdf</a>
</p>
<p>Wickramasuriya, S. L., Athanasopoulos, G., &amp; Hyndman, R. J. (2018).
Forecasting hierarchical and grouped time series through trace minimization.
<em>Journal of the American Statistical Association</em>, to appear <a href="https://robjhyndman.com/papers/mint.pdf">https://robjhyndman.com/papers/mint.pdf</a>
</p>

<hr>
<h2 id='accuracy.gts'>In-sample or out-of-sample accuracy measures for forecast grouped and
hierarchical model</h2><span id='topic+accuracy.gts'></span>

<h3>Description</h3>

<p>Returns a range of summary measures of the forecast accuracy. The function
measures out-of-sample forecast accuracy based on (holdout data - forecasts)
and in-sample accuracy at the bottom level when setting <code>keep.fitted =
TRUE</code> in the <code><a href="#topic+forecast.gts">forecast.gts</a></code>. All measures are defined and
discussed in Hyndman and Koehler (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gts'
accuracy(object, test, levels, ..., f = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accuracy.gts_+3A_object">object</code></td>
<td>
<p>An object of class <code>gts</code>, containing the forecasted
hierarchical or grouped time series. In-sample accuracy at the bottom level
returns when <code>test</code> is missing.</p>
</td></tr>
<tr><td><code id="accuracy.gts_+3A_test">test</code></td>
<td>
<p>An object of class <code>gts</code>, containing the holdout
hierarchical time series</p>
</td></tr>
<tr><td><code id="accuracy.gts_+3A_levels">levels</code></td>
<td>
<p>Return the specified level(s), when carrying out out-of-sample</p>
</td></tr>
<tr><td><code id="accuracy.gts_+3A_...">...</code></td>
<td>
<p>Extra arguments to be ignored</p>
</td></tr>
<tr><td><code id="accuracy.gts_+3A_f">f</code></td>
<td>
<p>Deprecated. Please use <code>object</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MASE calculation is scaled using MAE of in-sample naive forecasts for
non-seasonal time series, and in-sample seasonal naive forecasts for
seasonal time series.
</p>


<h3>Value</h3>

<p>Matrix giving forecast accuracy measures. </p>
<table role = "presentation">
<tr><td><code>ME</code></td>
<td>
<p>Mean Error</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root Mean Square Error</p>
</td></tr> <tr><td><code>MAE</code></td>
<td>
<p>Mean Absolute Error</p>
</td></tr>
<tr><td><code>MAPE</code></td>
<td>
<p>Mean Absolute Percentage Error</p>
</td></tr> <tr><td><code>MPE</code></td>
<td>
<p>Mean Percentage
Error</p>
</td></tr> <tr><td><code>MASE</code></td>
<td>
<p>Mean Absolute Scaled Error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Earo Wang
</p>


<h3>References</h3>

<p>R. J. Hyndman and A. Koehler (2006), Another look at measures of
forecast accuracy, <em>International Journal of Forecasting</em>, <b>22</b>,
679-688.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hts">hts</a></code>, <code><a href="#topic+plot.gts">plot.gts</a></code>,
<code><a href="#topic+forecast.gts">forecast.gts</a></code>, <code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- window(htseg2, start = 1992, end = 2002)
test &lt;- window(htseg2, start = 2003)
fcasts &lt;- forecast(data, h = 5, method = "bu")
accuracy(fcasts, test)
accuracy(fcasts, test, levels = 1)

</code></pre>

<hr>
<h2 id='aggts'>Extract selected time series from a gts object</h2><span id='topic+aggts'></span>

<h3>Description</h3>

<p>The time series from selected levels of a hierarchical/grouped time series
or a forecasted hierarchical/grouped time series are returned as a
multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggts(y, levels, forecasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggts_+3A_y">y</code></td>
<td>
<p>An object of class <code>{gts}</code>.</p>
</td></tr>
<tr><td><code id="aggts_+3A_levels">levels</code></td>
<td>
<p>Integer(s) or string(s) giving the specified level(s).</p>
</td></tr>
<tr><td><code id="aggts_+3A_forecasts">forecasts</code></td>
<td>
<p>If <code>y</code> contains forecasts and historical data, then
<code>forecasts</code> indicates whether to return the forecasts or the historical
data. Otherwise it is ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Earo Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allts">allts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aggts(htseg1, levels = c(0, 2))
aggts(infantgts, levels = "State")

</code></pre>

<hr>
<h2 id='allts'>Extract all time series from a gts object</h2><span id='topic+allts'></span>

<h3>Description</h3>

<p>The time series from all levels of a hierarchical/grouped time series or a
forecasted hierarchical/grouped time series are returned as a multivariate
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allts(y, forecasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allts_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="#topic+gts">gts</a></code>.</p>
</td></tr>
<tr><td><code id="allts_+3A_forecasts">forecasts</code></td>
<td>
<p>If <code>y</code> contains forecasts and historical data, then
<code>forecasts</code> indicates whether to return the forecasts or the historical
data. Otherwise it is ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggts">aggts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
allts(htseg1)

</code></pre>

<hr>
<h2 id='combinef'>Optimally combine forecasts from a hierarchical or grouped time series</h2><span id='topic+combinef'></span>

<h3>Description</h3>

<p>Using the methods of Hyndman et al. (2016) and Hyndman et al. (2011), this function optimally combines
the forecasts at all levels of a hierarchical time series. The
<code><a href="#topic+forecast.gts">forecast.gts</a></code> calls this function when the <code>comb</code> method
is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinef(
  fcasts,
  nodes = NULL,
  groups = NULL,
  weights = NULL,
  nonnegative = FALSE,
  algorithms = c("lu", "cg", "chol", "recursive", "slm"),
  keep = c("gts", "all", "bottom"),
  parallel = FALSE,
  num.cores = 2,
  control.nn = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinef_+3A_fcasts">fcasts</code></td>
<td>
<p>Matrix of forecasts for all levels of the hierarchical time
series. Each row represents one forecast horizon and each column represents
one time series from the hierarchy.</p>
</td></tr>
<tr><td><code id="combinef_+3A_nodes">nodes</code></td>
<td>
<p>If the object class is <code>hts</code>, a list contains the number
of child nodes referring to <code>hts</code>.</p>
</td></tr>
<tr><td><code id="combinef_+3A_groups">groups</code></td>
<td>
<p>If the object class is <code>gts</code>, a gmatrix is required,
which is the same as <code>groups</code> in the function <code>gts</code>.</p>
</td></tr>
<tr><td><code id="combinef_+3A_weights">weights</code></td>
<td>
<p>A numeric vector. The default is <code>NULL</code> which means that
ordinary least squares is implemented.</p>
</td></tr>
<tr><td><code id="combinef_+3A_nonnegative">nonnegative</code></td>
<td>
<p>Logical. Should the reconciled forecasts be non-negative?</p>
</td></tr>
<tr><td><code id="combinef_+3A_algorithms">algorithms</code></td>
<td>
<p>An algorithm to be used for computing reconciled
forecasts. See <code><a href="#topic+forecast.gts">forecast.gts</a></code> for details.</p>
</td></tr>
<tr><td><code id="combinef_+3A_keep">keep</code></td>
<td>
<p>Return a <code>gts</code> object or the the reconciled forecasts at
the bottom level.</p>
</td></tr>
<tr><td><code id="combinef_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Import parallel package to allow parallel processing.</p>
</td></tr>
<tr><td><code id="combinef_+3A_num.cores">num.cores</code></td>
<td>
<p>Numeric. Specify how many cores are going to be used.</p>
</td></tr>
<tr><td><code id="combinef_+3A_control.nn">control.nn</code></td>
<td>
<p>A list of control parameters to be passed on to the
block principal pivoting algorithm. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control.nn</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>ptype</code></dt><dd><p>Permutation method to be used: <code>"fixed"</code> or <code>"random"</code>. Defaults to <code>"fixed"</code>.</p>
</dd>
<dt><code>par</code></dt><dd><p>The number of full exchange rules that may be tried. Defaults to 10.</p>
</dd>
<dt><code>gtol</code></dt><dd><p>The tolerance of the convergence criteria. Defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Return the (non-negative) reconciled <code>gts</code> object or forecasts at the bottom
level.
</p>


<h3>Author(s)</h3>

<p>Alan Lee, Rob J Hyndman, Earo Wang and Shanika L Wickramasuriya
</p>


<h3>References</h3>

<p>Hyndman, R. J., Ahmed, R. A., Athanasopoulos, G., &amp; Shang, H. L.
(2011). Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589. <a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>
<p>Hyndman, R. J., Lee, A., &amp; Wang, E. (2016). Fast computation of reconciled
forecasts for hierarchical and grouped time series. <em>Computational Statistics and Data Analysis</em>,
<b>97</b>, 16&ndash;32. <a href="https://robjhyndman.com/publications/hgts/">https://robjhyndman.com/publications/hgts/</a>
</p>
<p>Wickramasuriya, S. L., Turlach, B. A., &amp; Hyndman, R. J. (to appear). Optimal non-negative forecast reconciliation.
<em>Statistics and Computing</em>. <a href="https://robjhyndman.com/publications/nnmint/">https://robjhyndman.com/publications/nnmint/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hts">hts</a></code>, <code><a href="#topic+forecast.gts">forecast.gts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# hts example
## Not run: 
h &lt;- 12
ally &lt;- aggts(htseg1)
allf &lt;- matrix(NA, nrow = h, ncol = ncol(ally))
for(i in 1:ncol(ally))
	allf[,i] &lt;- forecast(auto.arima(ally[,i]), h = h)$mean
allf &lt;- ts(allf, start = 51)
y.f &lt;- combinef(allf, get_nodes(htseg1), weights = NULL, keep = "gts", algorithms = "lu")
plot(y.f)

## End(Not run)

## Not run: 
h &lt;- 12
ally &lt;- abs(aggts(htseg2))
allf &lt;- matrix(NA, nrow = h, ncol = ncol(ally))
for(i in 1:ncol(ally))
  allf[,i] &lt;- forecast(auto.arima(ally[,i], lambda = 0, biasadj = TRUE), h = h)$mean
b.f &lt;- combinef(allf, get_nodes(htseg2), weights = NULL, keep = "bottom",
algorithms = "lu")
b.nnf &lt;- combinef(allf, get_nodes(htseg2), weights = NULL, keep = "bottom",
algorithms = "lu", nonnegative = TRUE)

## End(Not run)

# gts example
## Not run: 
abc &lt;- ts(5 + matrix(sort(rnorm(200)), ncol = 4, nrow = 50))
g &lt;- rbind(c(1,1,2,2), c(1,2,1,2))
y &lt;- gts(abc, groups = g)
h &lt;- 12
ally &lt;- aggts(y)
allf &lt;- matrix(NA,nrow = h,ncol = ncol(ally))
for(i in 1:ncol(ally))
  allf[,i] &lt;- forecast(auto.arima(ally[,i]),h = h)$mean
allf &lt;- ts(allf, start = 51)
y.f &lt;- combinef(allf, groups = get_groups(y), keep ="gts", algorithms = "lu")
plot(y.f)

## End(Not run)
</code></pre>

<hr>
<h2 id='forecast.gts'>Forecast a hierarchical or grouped time series</h2><span id='topic+forecast.gts'></span><span id='topic+forecast.hts'></span>

<h3>Description</h3>

<p>Methods for forecasting hierarchical or grouped time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gts'
forecast(
  object,
  h = ifelse(frequency(object$bts) &gt; 1L, 2L * frequency(object$bts), 10L),
  method = c("comb", "bu", "mo", "tdgsa", "tdgsf", "tdfp"),
  weights = c("wls", "ols", "mint", "nseries"),
  fmethod = c("ets", "arima", "rw"),
  algorithms = c("lu", "cg", "chol", "recursive", "slm"),
  covariance = c("shr", "sam"),
  nonnegative = FALSE,
  control.nn = list(),
  keep.fitted = FALSE,
  keep.resid = FALSE,
  positive = FALSE,
  lambda = NULL,
  level,
  FUN = NULL,
  xreg = NULL,
  newxreg = NULL,
  parallel = FALSE,
  num.cores = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.gts_+3A_object">object</code></td>
<td>
<p>Hierarchical or grouped time series object of class
<code>{gts}</code></p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_h">h</code></td>
<td>
<p>Forecast horizon</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_method">method</code></td>
<td>
<p>Method for distributing forecasts within the hierarchy. See
details</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_weights">weights</code></td>
<td>
<p>Weights used for &quot;optimal combination&quot; method:
<code>weights="ols"</code> uses an unweighted combination (as described in Hyndman
et al 2011); <code>weights="wls"</code> uses weights based on forecast variances
(as described in Hyndman et al 2016); <code>weights="mint"</code> uses a full
covariance estimate to determine the weights (as described in Wickramasuriya et al
2019); <code>weights="nseries"</code> uses weights based on the number of series
aggregated at each node.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_fmethod">fmethod</code></td>
<td>
<p>Forecasting method to use for each series.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_algorithms">algorithms</code></td>
<td>
<p>An algorithm to be used for computing the combination
forecasts (when <code>method=="comb"</code>). The combination forecasts are based
on an ill-conditioned regression model. &quot;lu&quot; indicates LU decomposition is
used; &quot;cg&quot; indicates a conjugate gradient method; &quot;chol&quot; corresponds to a
Cholesky decomposition; &quot;recursive&quot; indicates the recursive hierarchical
algorithm of Hyndman et al (2016); &quot;slm&quot; uses sparse linear regression. Note
that <code>algorithms = "recursive"</code> and <code>algorithms = "slm"</code> cannot be
used if <code>weights="mint"</code>.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_covariance">covariance</code></td>
<td>
<p>Type of the covariance matrix to be used with
<code>weights="mint"</code>: either a shrinkage estimator (<code>"shr"</code>) with
shrinkage towards the diagonal; or a sample covariance matrix
(<code>"sam"</code>).</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_nonnegative">nonnegative</code></td>
<td>
<p>Logical. Should the reconciled forecasts be non-negative?</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_control.nn">control.nn</code></td>
<td>
<p>A list of control parameters to be passed on to the
block principal pivoting algorithm. See 'Details'.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_keep.fitted">keep.fitted</code></td>
<td>
<p>If <code>TRUE</code>, keep fitted values at the bottom level.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_keep.resid">keep.resid</code></td>
<td>
<p>If <code>TRUE</code>, keep residuals at the bottom level.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_positive">positive</code></td>
<td>
<p>If <code>TRUE</code>, forecasts are forced to be strictly positive (by
setting <code>lambda=0</code>).</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_level">level</code></td>
<td>
<p>Level used for &quot;middle-out&quot; method (only used when <code>method
= "mo"</code>).</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_fun">FUN</code></td>
<td>
<p>A user-defined function that returns an object which can be
passed to the <code>forecast</code> function. It is applied to all series in order
to generate base forecasts.  When <code>FUN</code> is not <code>NULL</code>,
<code>fmethod</code>, <code>positive</code> and <code>lambda</code> are all ignored. Suitable
values for <code>FUN</code> are <code><a href="forecast.html#topic+tbats">tbats</a></code> and
<code><a href="forecast.html#topic+stlf">stlf</a></code> for example.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_xreg">xreg</code></td>
<td>
<p>When <code>fmethod = "arima"</code>, a vector or matrix of external
regressors used for modelling, which must have the same number of rows as
the original univariate time series</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_newxreg">newxreg</code></td>
<td>
<p>When <code>fmethod = "arima"</code>, a vector or matrix of external
regressors used for forecasting, which must have the same number of rows as
the <code>h</code> forecast horizon</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, import <code>parallel</code> package to allow parallel
processing.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_num.cores">num.cores</code></td>
<td>
<p>If <code>parallel = TRUE</code>, specify how many cores are going to be
used.</p>
</td></tr>
<tr><td><code id="forecast.gts_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="forecast.html#topic+ets">ets</a></code>,
<code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> or <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Base methods implemented include ETS, ARIMA and the naive (random walk)
models. Forecasts are distributed in the hierarchy using bottom-up,
top-down, middle-out and optimal combination methods.
</p>
<p>Three top-down methods are available: the two Gross-Sohl methods and the
forecast-proportion approach of Hyndman, Ahmed, and Athanasopoulos (2011).
The &quot;middle-out&quot; method <code>"mo"</code> uses bottom-up (<code>"bu"</code>) for levels
higher than <code>level</code> and top-down forecast proportions (<code>"tdfp"</code>)
for levels lower than <code>level</code>.
</p>
<p>For non-hierarchical grouped data, only bottom-up and combination methods
are possible, as any method involving top-down disaggregation requires a
hierarchical ordering of groups.
</p>
<p>When <code>xreg</code> and <code>newxreg</code> are passed, the same covariates are
applied to every series in the hierarchy.
</p>
<p>The <code>control.nn</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>ptype</code></dt><dd><p>Permutation method to be used: <code>"fixed"</code>  or <code>"random"</code>. Defaults to <code>"fixed"</code>.</p>
</dd>
<dt><code>par</code></dt><dd><p>The number of full exchange rules that may be tried. Defaults to 10.</p>
</dd>
<dt><code>gtol</code></dt><dd><p>The tolerance of the convergence criteria. Defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A forecasted hierarchical/grouped time series of class <code>gts</code>.
</p>


<h3>Note</h3>

<p>In-sample fitted values and resiuals are not returned if <code>method = "comb"</code> and <code>nonnegative = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Earo Wang, Rob J Hyndman and Shanika L Wickramasuriya
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Ahmed, R. A., &amp; Hyndman, R. J. (2009).
Hierarchical forecasts for Australian domestic tourism, <em>International
Journal of Forecasting</em>, <b>25</b>, 146-166.
</p>
<p>Hyndman, R. J., Ahmed, R. A., Athanasopoulos, G., &amp; Shang, H. L. (2011). Optimal
combination forecasts for hierarchical time series. <em>Computational
Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>
<p>Hyndman, R. J., Lee, A., &amp; Wang, E. (2016). Fast computation of reconciled
forecasts for hierarchical and grouped time series. <em>Computational
Statistics and Data Analysis</em>, <b>97</b>, 16&ndash;32.
<a href="https://robjhyndman.com/publications/hgts/">https://robjhyndman.com/publications/hgts/</a>
</p>
<p>Wickramasuriya, S. L., Athanasopoulos, G., &amp; Hyndman, R. J. (2019).
Optimal forecast reconciliation for hierarchical and grouped time series through trace minimization.
<em>Journal of the American Statistical Association</em>, <b>114</b>(526), 804&ndash;819. <a href="https://robjhyndman.com/publications/mint/">https://robjhyndman.com/publications/mint/</a>
</p>
<p>Wickramasuriya, S. L., Turlach, B. A., &amp; Hyndman, R. J. (to appear). Optimal non-negative forecast reconciliation.
<em>Statistics and Computing</em>. <a href="https://robjhyndman.com/publications/nnmint/">https://robjhyndman.com/publications/nnmint/</a>
</p>
<p>Gross, C., &amp; Sohl, J. (1990). Dissagregation methods to expedite product
line forecasting, <em>Journal of Forecasting</em>, <b>9</b>, 233&ndash;254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hts">hts</a></code>, <code><a href="#topic+gts">gts</a></code>,
<code><a href="#topic+plot.gts">plot.gts</a></code>, <code><a href="#topic+accuracy.gts">accuracy.gts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
forecast(htseg1, h = 10, method = "bu", fmethod = "arima")

## Not run: 
  forecast(
    htseg2, h = 10, method = "comb", algorithms = "lu",
    FUN = function(x) tbats(x, use.parallel = FALSE)
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='get_groups'>Get nodes/groups from an hts/gts object</h2><span id='topic+get_groups'></span><span id='topic+get_nodes'></span>

<h3>Description</h3>

<p>Get nodes/groups from an hts/gts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_groups(y)

get_nodes(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_groups_+3A_y">y</code></td>
<td>
<p>An hts or gts object
series.</p>
</td></tr>
</table>

<hr>
<h2 id='gts'>Create a grouped time series</h2><span id='topic+gts'></span><span id='topic+print.gts'></span><span id='topic+summary.gts'></span><span id='topic+is.gts'></span>

<h3>Description</h3>

<p>Method for creating grouped time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gts(y, groups, gnames = rownames(groups), characters)

is.gts(xts)

## S3 method for class 'gts'
print(x, ...)

## S3 method for class 'gts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gts_+3A_y">y</code></td>
<td>
<p>A matrix or multivariate time series contains the bottom level
series.</p>
</td></tr>
<tr><td><code id="gts_+3A_groups">groups</code></td>
<td>
<p>Group matrix indicates the group structure, with one column
for each series when completely disaggregated, and one row for each grouping
of the time series. It allows either a numerical matrix or a matrix
consisting of strings that can be used for labelling. If the argument
<code>characters</code> is used, then <code>groups</code> will be automatically
generated within the function.</p>
</td></tr>
<tr><td><code id="gts_+3A_gnames">gnames</code></td>
<td>
<p>Specify the group names.</p>
</td></tr>
<tr><td><code id="gts_+3A_characters">characters</code></td>
<td>
<p>A vector of integers, or a list containing vectors of
integers, indicating the segments in which bottom level names can be read in
order to construct the corresponding grouping matrix and its labels. A
<code>list</code> class is used when a grouped time series includes one or more
hierarchies. For example, a grouped time series may involve a geographical
grouping and a product grouping, with each of them associated with a 2-level
hierarchy. In this situation, a bottom level name such as &quot;VICMelbAB&quot; would
indicate the state &quot;VIC&quot; (3 characters) followed by the city &quot;Melb&quot; (4
characters), then the product category &quot;A&quot; (1 character) followed by the
sub-product category &quot;B&quot; (1 character). In this example, the specification
of <code>characters</code> is <code>list(c(3, 4), c(1, 1))</code>, where the first
element <code>c(3, 4)</code> corresponds to the geographical hierarchy and the
second element corresponds to the product hierarchy.  In the special case
where there is a non-hierarchical grouped time series, a vector of integers
is also possible. For example, a grouped time series may involve state, age
and sex grouping variables. In this situation, a bottom level name such as
&quot;VIC1F&quot; would indicate the state &quot;VIC&quot;, age group &quot;1&quot; and sex &quot;F&quot;. Because
none of these is hierarchical, we could specify <code>characters = list(3,
1, 1)</code>, or as a simple numeric vector: <code>characters = c(3, 1, 1)</code>. This
implies its non-hierarchical structure and its characters segments. Again,
all bottom level names must be of the same length. Currently, the use of
<code>characters</code> only supports 2-way cross-products for grouping variables.
Specifying <code>groups</code> is more general (but more complicated), as any
combination of grouping variables can be used.</p>
</td></tr>
<tr><td><code id="gts_+3A_xts">xts</code></td>
<td>
<p><code>gts</code> object.</p>
</td></tr>
<tr><td><code id="gts_+3A_x">x</code></td>
<td>
<p><code>gts</code> object.</p>
</td></tr>
<tr><td><code id="gts_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>print</code> and <code>summary</code>.</p>
</td></tr>
<tr><td><code id="gts_+3A_object">object</code></td>
<td>
<p><code>gts</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bts</code></td>
<td>
<p>Multivariate time series contains the bottom level
series</p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p>Information about the groups of a grouped time series</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>Information about the labels that are used for plotting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Earo Wang and Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R. J., Ahmed, R. A., Athanasopoulos, G., &amp; Shang, H. L.
(2011). Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hts">hts</a></code>, <code><a href="#topic+accuracy.gts">accuracy.gts</a></code>,
<code><a href="#topic+forecast.gts">forecast.gts</a></code>, <code><a href="#topic+plot.gts">plot.gts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1 illustrating the usage of the "groups" argument
abc &lt;- ts(5 + matrix(sort(rnorm(1600)), ncol = 16, nrow = 100))
sex &lt;- rep(c("female", "male"), each = 8)
state &lt;- rep(c("NSW", "VIC", "QLD", "SA", "WA", "NT", "ACT", "TAS"), 2)
gc &lt;- rbind(sex, state)  # a matrix consists of strings.
gn &lt;- rbind(rep(1:2, each = 8), rep(1:8, 2))  # a numerical matrix
rownames(gc) &lt;- rownames(gn) &lt;- c("Sex", "State")
x &lt;- gts(abc, groups = gc)
y &lt;- gts(abc, groups = gn)

# Example 2 with two simple hierarchies (geography and product) to show the argument "characters"
bnames1 &lt;- c("VICMelbAA", "VICMelbAB", "VICGeelAA", "VICGeelAB",
             "VICMelbBA", "VICMelbBB", "VICGeelBA", "VICGeelBB",
             "NSWSyndAA", "NSWSyndAB", "NSWWollAA", "NSWWollAB",
             "NSWSyndBA", "NSWSyndBB", "NSWWollBA", "NSWWollBB")
bts1 &lt;- matrix(ts(rnorm(160)), ncol = 16)
colnames(bts1) &lt;- bnames1
x1 &lt;- gts(bts1, characters = list(c(3, 4), c(1, 1)))

# Example 3 with a non-hierarchical grouped time series of 3 grouping variables (state, age and sex)
bnames2 &lt;- c("VIC1F", "VIC1M", "VIC2F", "VIC2M", "VIC3F", "VIC3M",
             "NSW1F", "NSW1M", "NSW2F", "NSW2M", "NSW3F", "NSW3M")
bts2 &lt;- matrix(ts(rnorm(120)), ncol = 12)
colnames(bts2) &lt;- bnames2
x2 &lt;- gts(bts2, characters = c(3, 1, 1))

</code></pre>

<hr>
<h2 id='hts'>Create a hierarchical time series</h2><span id='topic+hts'></span><span id='topic+is.hts'></span><span id='topic+print.hts'></span><span id='topic+summary.hts'></span>

<h3>Description</h3>

<p>Method for creating hierarchical time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hts(y, nodes, bnames = colnames(y), characters)

is.hts(xts)

## S3 method for class 'hts'
print(x, ...)

## S3 method for class 'hts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hts_+3A_y">y</code></td>
<td>
<p>A matrix or multivariate time series contain the bottom level
series.</p>
</td></tr>
<tr><td><code id="hts_+3A_nodes">nodes</code></td>
<td>
<p>A list contains the number of child nodes associated with each
level, which indicates the hierarchical structure. The default is a simple
hierarchy with only 2 levels (i.e. total and bottom). If the argument
<code>characters</code> is used, <code>nodes</code> will be automatically generated
within the function.</p>
</td></tr>
<tr><td><code id="hts_+3A_bnames">bnames</code></td>
<td>
<p>The names of the bottom time series.</p>
</td></tr>
<tr><td><code id="hts_+3A_characters">characters</code></td>
<td>
<p>Integers indicate the segments in which the bottom level
names can be read in order to construct the corresponding node structure and
its labels.  For instance, suppose one of the bottom series is named
&quot;VICMelb&quot; referring to the city of Melbourne within the state of Victoria.
Then <code>characters</code> would be specified as <code>c(3, 4)</code> referring to
states of 3 characters (e.g., &quot;VIC&quot;) and cities of 4 characters (e.g.,
&quot;Melb&quot;) All the bottom names must be of the same length, with number of
characters for each segment the same for all series.</p>
</td></tr>
<tr><td><code id="hts_+3A_xts">xts</code></td>
<td>
<p><code>hts</code> object.</p>
</td></tr>
<tr><td><code id="hts_+3A_x">x</code></td>
<td>
<p><code>hts</code> object.</p>
</td></tr>
<tr><td><code id="hts_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>print</code> and <code>summary</code>.</p>
</td></tr>
<tr><td><code id="hts_+3A_object">object</code></td>
<td>
<p><code>hts</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bts</code></td>
<td>
<p>Multivariate time series containing the bottom level
series</p>
</td></tr> <tr><td><code>nodes</code></td>
<td>
<p>Information about the nodes of a hierarchical time
series</p>
</td></tr> <tr><td><code>labels</code></td>
<td>
<p>Information about the labels that are used for
plotting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Earo Wang and Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R. J., Ahmed, R. A., Athanasopoulos, G., &amp; Shang, H. L.
(2011). Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gts">gts</a></code>, <code><a href="#topic+accuracy.gts">accuracy.gts</a></code>,
<code><a href="#topic+forecast.gts">forecast.gts</a></code>, <code><a href="#topic+plot.gts">plot.gts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# The hierarchical structure looks like 2 child nodes associated with level 1,
# which are followed by 3 and 2 sub-child nodes respectively at level 2.
nodes &lt;- list(2, c(3, 2))
abc &lt;- ts(5 + matrix(sort(rnorm(500)), ncol = 5, nrow = 100))
x &lt;- hts(abc, nodes)

# Example 2
# Suppose we've got the bottom names that can be useful for constructing the node
# structure and the labels at higher levels. We need to specify how to split them
# in the argument "characters".
library(hts)
abc &lt;- ts(5 + matrix(sort(rnorm(1000)), ncol = 10, nrow = 100))
colnames(abc) &lt;- c("A10A", "A10B", "A10C", "A20A", "A20B",
                   "B30A", "B30B", "B30C", "B40A", "B40B")
y &lt;- hts(abc, characters = c(1, 2, 1))

</code></pre>

<hr>
<h2 id='htseg1'>Simple examples of hierarchical time series.</h2><span id='topic+htseg1'></span><span id='topic+htseg2'></span>

<h3>Description</h3>

<p>These are simulated data. <code>htseg1</code> has three levels with a total of 8
series each of length 10. <code>htseg2</code> has four levels with a total of 17
series each of length 16.
</p>


<h3>Format</h3>

<p>Objects of class <code><a href="#topic+hts">hts</a></code>.
</p>


<h3>References</h3>

<p>R. J. Hyndman, R. A. Ahmed, G. Athanasopoulos and H.L. Shang
(2011) Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(htseg1)

</code></pre>

<hr>
<h2 id='infantgts'>Regional infant mortality counts across Australia from 1933 to 2003.</h2><span id='topic+infantgts'></span>

<h3>Description</h3>

<p>These are infant mortality counts. This data set is an example of
<code>gts</code>, where the total infant mortality count in Australia can be first
disaggregated by sex then by state, or vice versa.
</p>


<h3>Format</h3>

<p>Objects of class <code><a href="#topic+gts">gts</a></code>.
</p>


<h3>References</h3>

<p>R. J. Hyndman, R. A. Ahmed, G. Athanasopoulos and H.L. Shang
(2011) Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(infantgts)

</code></pre>

<hr>
<h2 id='MinT'>Trace minimization for hierarchical or grouped time series</h2><span id='topic+MinT'></span>

<h3>Description</h3>

<p>Using the method of Wickramasuriya et al. (2019), this function combines the
forecasts at all levels of a hierarchical or grouped time series. The
<code><a href="#topic+forecast.gts">forecast.gts</a></code> calls this function when the <code>MinT</code> method
is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinT(
  fcasts,
  nodes = NULL,
  groups = NULL,
  residual,
  covariance = c("shr", "sam"),
  nonnegative = FALSE,
  algorithms = c("lu", "cg", "chol"),
  keep = c("gts", "all", "bottom"),
  parallel = FALSE,
  num.cores = 2,
  control.nn = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinT_+3A_fcasts">fcasts</code></td>
<td>
<p>Matrix of forecasts for all levels of a hierarchical or
grouped time series. Each row represents one forecast horizon and each
column represents one time series of aggregated or disaggregated forecasts.</p>
</td></tr>
<tr><td><code id="MinT_+3A_nodes">nodes</code></td>
<td>
<p>If the object class is hts, a list contains the number of child
nodes referring to hts.</p>
</td></tr>
<tr><td><code id="MinT_+3A_groups">groups</code></td>
<td>
<p>If the object is gts, a gmatrix is required, which is the same
as groups in the function gts.</p>
</td></tr>
<tr><td><code id="MinT_+3A_residual">residual</code></td>
<td>
<p>Matrix of insample residuals for all the aggregated and
disaggregated time series. The columns must be in the same order as
<code>fcasts</code>.</p>
</td></tr>
<tr><td><code id="MinT_+3A_covariance">covariance</code></td>
<td>
<p>Type of the covariance matrix to be used. Shrinking
towards a diagonal unequal variances (<code>"shr"</code>) or sample covariance matrix
(<code>"sam"</code>).</p>
</td></tr>
<tr><td><code id="MinT_+3A_nonnegative">nonnegative</code></td>
<td>
<p>Logical. Should the reconciled forecasts be non-negative?</p>
</td></tr>
<tr><td><code id="MinT_+3A_algorithms">algorithms</code></td>
<td>
<p>Algorithm used to compute inverse of the matrices.</p>
</td></tr>
<tr><td><code id="MinT_+3A_keep">keep</code></td>
<td>
<p>Return a gts object or the reconciled forecasts at the bottom
level.</p>
</td></tr>
<tr><td><code id="MinT_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Import parallel package to allow parallel processing.</p>
</td></tr>
<tr><td><code id="MinT_+3A_num.cores">num.cores</code></td>
<td>
<p>Numeric. Specify how many cores are going to be used.</p>
</td></tr>
<tr><td><code id="MinT_+3A_control.nn">control.nn</code></td>
<td>
<p>A list of control parameters to be passed on to the
block principal pivoting algorithm. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control.nn</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>ptype</code></dt><dd><p>Permutation method to be used: <code>"fixed"</code> or <code>"random"</code>. Defaults to <code>"fixed"</code>.</p>
</dd>
<dt><code>par</code></dt><dd><p>The number of full exchange rules that may be tried. Defaults to 10.</p>
</dd>
<dt><code>gtol</code></dt><dd><p>The tolerance of the convergence criteria. Defaults to <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Return the reconciled <code>gts</code> object or forecasts at the bottom
level.
</p>


<h3>Author(s)</h3>

<p>Shanika L Wickramasuriya
</p>


<h3>References</h3>

<p>Wickramasuriya, S. L., Athanasopoulos, G., &amp; Hyndman, R. J. (2019).
Optimal forecast reconciliation for hierarchical and grouped time series through trace minimization.
<em>Journal of the American Statistical Association</em>, <b>114</b>(526), 804&ndash;819. <a href="https://robjhyndman.com/publications/mint/">https://robjhyndman.com/publications/mint/</a>
</p>
<p>Wickramasuriya, S. L., Turlach, B. A., &amp; Hyndman, R. J. (to appear). Optimal non-negative forecast reconciliation.
<em>Statistics and Computing</em>. <a href="https://robjhyndman.com/publications/nnmint/">https://robjhyndman.com/publications/nnmint/</a>
</p>
<p>Hyndman, R. J., Lee, A., &amp; Wang, E. (2016).  Fast computation of reconciled
forecasts for hierarchical and grouped time series.  <em>Computational
Statistics and Data Analysis</em>, <b>97</b>, 16&ndash;32.
<a href="https://robjhyndman.com/publications/hgts/">https://robjhyndman.com/publications/hgts/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hts">hts</a></code>, <code><a href="#topic+gts">gts</a></code>,
<code><a href="#topic+forecast.gts">forecast.gts</a></code>, <code><a href="#topic+combinef">combinef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# hts example
## Not run: 
h &lt;- 12
ally &lt;- aggts(htseg1)
n &lt;- nrow(ally)
p &lt;- ncol(ally)
allf &lt;- matrix(NA, nrow = h, ncol = p)
res &lt;- matrix(NA, nrow = n, ncol = p)
for(i in 1:p)
{
  fit &lt;- auto.arima(ally[, i])
  allf[, i] &lt;- forecast(fit, h = h)$mean
  res[, i] &lt;- na.omit(ally[, i] - fitted(fit))
}
allf &lt;- ts(allf, start = 51)
y.f &lt;- MinT(allf, get_nodes(htseg1), residual = res, covariance = "shr",
  keep = "gts", algorithms = "lu")
plot(y.f)
y.f_cg &lt;- MinT(allf, get_nodes(htseg1), residual = res, covariance = "shr",
  keep = "all", algorithms = "cg")

## End(Not run)

## Not run: 
h &lt;- 12
ally &lt;- abs(aggts(htseg2))
allf &lt;- matrix(NA, nrow = h, ncol = ncol(ally))
res &lt;- matrix(NA, nrow = nrow(ally), ncol = ncol(ally))
for(i in 1:ncol(ally)) {
  fit &lt;- auto.arima(ally[, i], lambda = 0, biasadj = TRUE)
  allf[,i] &lt;- forecast(fit, h = h)$mean
  res[,i] &lt;- na.omit(ally[, i] - fitted(fit))
}
b.f &lt;- MinT(allf, get_nodes(htseg2), residual = res, covariance = "shr",
  keep = "bottom", algorithms = "lu")
b.nnf &lt;-  MinT(allf, get_nodes(htseg2), residual = res, covariance = "shr",
  keep = "bottom", algorithms = "lu", nonnegative = TRUE, parallel = TRUE)

## End(Not run)

# gts example
## Not run: 
abc &lt;- ts(5 + matrix(sort(rnorm(200)), ncol = 4, nrow = 50))
g &lt;- rbind(c(1,1,2,2), c(1,2,1,2))
y &lt;- gts(abc, groups = g)
h &lt;- 12
ally &lt;- aggts(y)
n &lt;- nrow(ally)
p &lt;- ncol(ally)
allf &lt;- matrix(NA,nrow = h,ncol = ncol(ally))
res &lt;- matrix(NA, nrow = n, ncol = p)
for(i in 1:p)
{
  fit &lt;- auto.arima(ally[, i])
  allf[, i] &lt;- forecast(fit, h = h)$mean
  res[, i] &lt;- na.omit(ally[, i] - fitted(fit))
}
allf &lt;- ts(allf, start = 51)
y.f &lt;- MinT(allf, groups = get_groups(y), residual = res, covariance = "shr",
  keep = "gts", algorithms = "lu")
plot(y.f)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.gts'>Plot grouped or hierarchical time series</h2><span id='topic+plot.gts'></span>

<h3>Description</h3>

<p>Method for plotting grouped or hierarchical time series and their forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gts'
plot(x, include, levels, labels = TRUE, col = NULL, color_lab = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+gts">gts</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_include">include</code></td>
<td>
<p>Number of values from historical time series to include in
the plot of forecasted group/hierarchical time series.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_levels">levels</code></td>
<td>
<p>Integer(s) or string(s) giving the specified levels(s) to be
plotted</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_labels">labels</code></td>
<td>
<p>If <code>TRUE</code>, plot the labels next to each series</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_col">col</code></td>
<td>
<p>Vector of colours, passed to <code>plot.ts</code> and to <code>lines</code></p>
</td></tr>
<tr><td><code id="plot.gts_+3A_color_lab">color_lab</code></td>
<td>
<p>If <code>TRUE</code>, colour the direct labels to match line
colours.  If <code>FALSE</code> will be as per <code>par()$fg</code>.</p>
</td></tr>
<tr><td><code id="plot.gts_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Earo Wang
</p>


<h3>References</h3>

<p>Hyndman, R. J., Ahmed, R. A., Athanasopoulos, G., &amp; Shang, H. L.
(2011). Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggts">aggts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(htseg1, levels = c(0, 2))
plot(infantgts, include = 10, levels = "State")
plot(infantgts, include = 10, levels = "State",
    col = colours()[100:107], lty = 1:8, color_lab = TRUE)

</code></pre>

<hr>
<h2 id='smatrix'>Summing matrix for hierarchical or grouped time series</h2><span id='topic+smatrix'></span>

<h3>Description</h3>

<p>This function returns the summing matrix for a hierarchical or grouped time
series, as defined in Hyndman et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smatrix(xts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smatrix_+3A_xts">xts</code></td>
<td>
<p>Hierarchical or grouped time series of class <code>gts</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical matrix.
</p>


<h3>Author(s)</h3>

<p>Earo Wang
</p>


<h3>References</h3>

<p>Hyndman, R. J., Ahmed, R. A., Athanasopoulos, G., &amp; Shang, H. L.
(2011). Optimal combination forecasts for hierarchical time series.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(9), 2579&ndash;2589.
<a href="https://robjhyndman.com/publications/hierarchical/">https://robjhyndman.com/publications/hierarchical/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hts">hts</a></code>, <code><a href="#topic+gts">gts</a></code>,
<code><a href="#topic+combinef">combinef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
smatrix(htseg1)

</code></pre>

<hr>
<h2 id='window.gts'>Time window of a gts object</h2><span id='topic+window.gts'></span>

<h3>Description</h3>

<p>Extracts a subset of the time series from a grouped time series object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gts'
window(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window.gts_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+gts">gts</a></code>.</p>
</td></tr>
<tr><td><code id="window.gts_+3A_...">...</code></td>
<td>
<p>All other arguments are passed to <code><a href="stats.html#topic+window.ts">window.ts</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
window(htseg2, start = 2000, end = 2001)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
