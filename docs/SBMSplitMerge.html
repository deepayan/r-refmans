<!DOCTYPE html><html><head><title>Help for package SBMSplitMerge</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SBMSplitMerge}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accept'><p>accept <code>propsbm</code> with the acceptance probability alpha</p></a></li>
<li><a href='#addblock'><p>Add a block move</p></a></li>
<li><a href='#ARI'><p>Adjusted Rand Index</p></a></li>
<li><a href='#blockmat'><p>Block matrix</p></a></li>
<li><a href='#blockmat.blocks'><p>Block matrix</p></a></li>
<li><a href='#blockmat.numeric'><p>Block matrix</p></a></li>
<li><a href='#blockmat.sbm'><p>Block matrix</p></a></li>
<li><a href='#blockmod'><p>Block Model</p></a></li>
<li><a href='#blocks'><p>Blocks object</p></a></li>
<li><a href='#blocktrace'><p>plot a trace of the blocks from MCMC samples</p></a></li>
<li><a href='#crp'><p>Chinese Restaurant Process</p></a></li>
<li><a href='#ddirichlet'><p>Dirichlet distribution</p></a></li>
<li><a href='#dedges'><p>Density of edges</p></a></li>
<li><a href='#dedges.numeric'><p>likelihood of edges</p></a></li>
<li><a href='#dedges.sbm'><p>Density of edges</p></a></li>
<li><a href='#delblock'><p>Delete a block move</p></a></li>
<li><a href='#dma'><p>Dirichlet Multinomial Allocation</p></a></li>
<li><a href='#drawblock.dp'><p>Draw block membership</p></a></li>
<li><a href='#drawblock.gibbs'><p>Gibbs-like reassignment of nodes to the current set of blocks</p></a></li>
<li><a href='#drawblocks.dp'><p>Draw block memberships</p></a></li>
<li><a href='#drawblocks.gibbs'><p>Gibbs-like reassignment of nodes to the current set of blocks</p></a></li>
<li><a href='#drawparams'><p>Metropolis updates by drawing parameters</p></a></li>
<li><a href='#edgemod'><p>Class for edge models</p></a></li>
<li><a href='#edges'><p>Class for edge data</p></a></li>
<li><a href='#edges_bern'><p>Bernoulli edge model</p></a></li>
<li><a href='#edges_nbin'><p>Negative-Binomial edge model</p></a></li>
<li><a href='#edges_norm'><p>Normal edge model</p></a></li>
<li><a href='#edges_pois'><p>Poisson edge model</p></a></li>
<li><a href='#Enron'><p>The Enron data set as extracted from <code>igraph</code> using the script in data-raw</p></a></li>
<li><a href='#eval_plots'><p>get a set of evaluation plots from MCMC samples</p></a></li>
<li><a href='#is.sbm'><p>is.sbm</p></a></li>
<li><a href='#Macaque'><p>The Macaque data set as extracted from <code>igraph</code> using the script in data-raw</p></a></li>
<li><a href='#marglike_bern'><p>Marginal likelihood model for Bernoulli distributed edges</p></a></li>
<li><a href='#marglike_norm'><p>Marginal likelihood model for Normal distributed edges</p></a></li>
<li><a href='#marglike_pois'><p>Marginal likelihood model for Poisson distributed edges</p></a></li>
<li><a href='#mergeavg'><p>Merge blocks</p></a></li>
<li><a href='#mergeblocks'><p>merge move block merging</p></a></li>
<li><a href='#mergeparams'><p>merge parameters</p></a></li>
<li><a href='#mergeparams.default'><p>Merge step: parameters</p></a></li>
<li><a href='#mergeparams.numeric'><p>Merge step - parameter merging</p></a></li>
<li><a href='#modeblocks'><p>modal block assignments from MCMC samples</p></a></li>
<li><a href='#multinom'><p>Multinomial block assignment</p></a></li>
<li><a href='#nodelike'><p>Likelihood of node assignment</p></a></li>
<li><a href='#numblockstrace'><p>plot a trace of the number of blocks from MCMC samples</p></a></li>
<li><a href='#param_beta'><p>Beta parameter model</p></a></li>
<li><a href='#param_gamma'><p>Gamma parameter model</p></a></li>
<li><a href='#param_nbin'><p>Parameter model for Negative Binomial</p></a></li>
<li><a href='#param_norm'><p>Parameter model for Normal Model</p></a></li>
<li><a href='#parammat'><p>Parameter Matrix</p></a></li>
<li><a href='#parammat.blocks'><p>Parameter Matrix</p></a></li>
<li><a href='#parammat.matrix'><p>Parameter Matrix</p></a></li>
<li><a href='#parammat.params'><p>Parameter Matrix</p></a></li>
<li><a href='#parammat.sbm'><p>Parameter Matrix</p></a></li>
<li><a href='#parammod'><p>Parameter Model</p></a></li>
<li><a href='#params'><p><code>params</code> S3 object</p></a></li>
<li><a href='#paramtrace'><p>plot a trace of parameter values from MCMC samples</p></a></li>
<li><a href='#plot.blocks'><p>Plot blocks</p></a></li>
<li><a href='#plot.edges'><p>Plot</p></a></li>
<li><a href='#plot.sbm'><p>Plot for <code>sbm</code> object</p></a></li>
<li><a href='#plotpostpairs'><p>helper function for trace plots</p></a></li>
<li><a href='#postpairs'><p>mean proportion of times two nodes were in the same block under MCMC samples</p></a></li>
<li><a href='#rcat'><p>Draw draw Categorical distribution</p></a></li>
<li><a href='#rdirichlet'><p>Dirichlet distribution</p></a></li>
<li><a href='#redges'><p>Simulate edges</p></a></li>
<li><a href='#rw'><p>Random Walk</p></a></li>
<li><a href='#sampler'><p>top level sampler function</p></a></li>
<li><a href='#sampler.conj'><p>Conjugate model sampler</p></a></li>
<li><a href='#sampler.dp'><p>Dirichlet process sampler</p></a></li>
<li><a href='#sampler.gibbs'><p>Gibbs sampling for node assignments</p></a></li>
<li><a href='#sampler.rj'><p>reversible jump Markov chain Monte Carlo split-merge sampler</p></a></li>
<li><a href='#sbm'><p>Class <code>sbm</code></p></a></li>
<li><a href='#sbmmod'><p>Stochastic block model object</p></a></li>
<li><a href='#splitavg'><p>split move using average to merge parameters</p></a></li>
<li><a href='#splitblocks'><p>split move: blocks</p></a></li>
<li><a href='#splitparams'><p>split move: parameters</p></a></li>
<li><a href='#splitparams.numeric'><p>split move: <code>params</code></p></a></li>
<li><a href='#splitparams.params'><p>split move: <code>params</code></p></a></li>
<li><a href='#StackOverflow'><p>The Stack-Overflow data set as extracted from <code>igraph</code> using the script in data-raw</p>
Extracted on 27/8/2019 from Kaggle (login required) using:
<code>library(rvest)</code>
<code>read_html("https://www.kaggle.com/stackoverflow/stack-overflow-tag-network/downloads/stack_network_links.csv/1")</code></a></li>
<li><a href='#updateblock'><p>Update the block assignment of a node</p></a></li>
<li><a href='#updateblock.blocks'><p>Update the block assignment of a node</p></a></li>
<li><a href='#updateblock.sbm'><p>Update the block assignment of a node</p></a></li>
<li><a href='#vmeasure'><p>V-measure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Inference for a Generalised SBM with a Split Merge Sampler</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Inference in a Bayesian framework for a generalised stochastic block model. The generalised stochastic block model (SBM) can capture group structure in network data without requiring conjugate priors on the edge-states. Two sampling methods are provided to perform inference on edge parameters and block structure: a split-merge Markov chain Monte Carlo algorithm and a Dirichlet process sampler. Green, Richardson (2001) &lt;<a href="https://doi.org/10.1111%2F1467-9469.00242">doi:10.1111/1467-9469.00242</a>&gt;; Neal (2000) &lt;<a href="https://doi.org/10.1080%2F10618600.2000.10474879">doi:10.1080/10618600.2000.10474879</a>&gt;; Ludkin (2019) &lt;<a href="https://arxiv.org/abs/1909.09421">arXiv:1909.09421</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, scales, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-01 14:00:01 UTC; ludkinm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Ludkin [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Ludkin &lt;m.ludkin1@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-04 13:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='accept'>accept <code>propsbm</code> with the acceptance probability alpha</h2><span id='topic+accept'></span>

<h3>Description</h3>

<p>accept <code>propsbm</code> with the acceptance probability alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept(currsbm, propsbm, edges, sbmmod, logjac = 0, logu = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accept_+3A_currsbm">currsbm</code></td>
<td>
<p>current <code>sbm</code> state</p>
</td></tr>
<tr><td><code id="accept_+3A_propsbm">propsbm</code></td>
<td>
<p>proposed <code>sbm</code> state</p>
</td></tr>
<tr><td><code id="accept_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="accept_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="accept_+3A_logjac">logjac</code></td>
<td>
<p>log Jacobian of transformation of variables</p>
</td></tr>
<tr><td><code id="accept_+3A_logu">logu</code></td>
<td>
<p>log density for auxiliary variables</p>
</td></tr>
<tr><td><code id="accept_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>dedges</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code>sbm</code> object
</p>

<hr>
<h2 id='addblock'>Add a block move</h2><span id='topic+addblock'></span>

<h3>Description</h3>

<p>proposes adding an empty block labelled <code>kappa+</code>1 to <code>sbm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addblock(sbm, edges, sbmmod, rho = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addblock_+3A_sbm">sbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="addblock_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="addblock_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="addblock_+3A_rho">rho</code></td>
<td>
<p>probability of choosing to add a block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated <code>sbm</code> object
</p>

<hr>
<h2 id='ARI'>Adjusted Rand Index</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Calculate the Adjusted Rand Index between two clusterings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(z, truez)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARI_+3A_z">z</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="ARI_+3A_truez">truez</code></td>
<td>
<p>reference vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted Rand Index of <code>z</code> against <code>truez</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ARI(c(1,1,2,2,3,3), c(2,2,1,1,3,3)) ## 1 - doesn't care for labels
ARI(c(1,1,2,2,3,3), c(1,1,1,1,2,2)) ## 0.444
</code></pre>

<hr>
<h2 id='blockmat'>Block matrix</h2><span id='topic+blockmat'></span>

<h3>Description</h3>

<p>converts <code>x</code> to a matrix of block assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockmat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockmat_+3A_x">x</code></td>
<td>
<p>object for dispatch</p>
</td></tr>
<tr><td><code id="blockmat_+3A_...">...</code></td>
<td>
<p>additional arguments for method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of block assignment indicators
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blockmat.sbm">blockmat.sbm</a></code> <code><a href="#topic+blockmat.blocks">blockmat.blocks</a></code> <code><a href="#topic+blockmat.numeric">blockmat.numeric</a></code>
</p>

<hr>
<h2 id='blockmat.blocks'>Block matrix</h2><span id='topic+blockmat.blocks'></span>

<h3>Description</h3>

<p>converts block assignments of a <code>blocks</code> object to a matrix of block assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blocks'
blockmat(blocks, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockmat.blocks_+3A_blocks">blocks</code></td>
<td>
<p>a <code>blocks</code> object</p>
</td></tr>
<tr><td><code id="blockmat.blocks_+3A_kappa">kappa</code></td>
<td>
<p>number of blocks in matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with <code>kappa</code> rows and a 1 at <code>(k,i)</code> if node <code>i</code> is in block <code>k</code> under <code>blocks</code>
</p>

<hr>
<h2 id='blockmat.numeric'>Block matrix</h2><span id='topic+blockmat.numeric'></span><span id='topic+blockmat.factor'></span>

<h3>Description</h3>

<p>converts a vector of block assignments to a matrix of block assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
blockmat(x, kappa)

## S3 method for class 'factor'
blockmat(x, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockmat.numeric_+3A_x">x</code></td>
<td>
<p>a numeric-vector of node-to-block assignments</p>
</td></tr>
<tr><td><code id="blockmat.numeric_+3A_kappa">kappa</code></td>
<td>
<p>number of blocks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with <code>kappa</code> rows and a 1 at <code>(k,i)</code> if node <code>i</code> is in block <code>k</code> under <code>x</code>
</p>

<hr>
<h2 id='blockmat.sbm'>Block matrix</h2><span id='topic+blockmat.sbm'></span>

<h3>Description</h3>

<p>converts block assignments of an <code>sbm</code> object to a matrix of block assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbm'
blockmat(SBM, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockmat.sbm_+3A_sbm">SBM</code></td>
<td>
<p>an <code>sbm</code> object</p>
</td></tr>
<tr><td><code id="blockmat.sbm_+3A_kappa">kappa</code></td>
<td>
<p>number of blocks in matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with <code>kappa</code> rows and a 1 at <code>(k,i)</code> if node <code>i</code> is in block <code>k</code> under <code>SBM</code>
</p>

<hr>
<h2 id='blockmod'>Block Model</h2><span id='topic+blockmod'></span>

<h3>Description</h3>

<p>create a <code>blockmod</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockmod(fixkappa, logd, dcond, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockmod_+3A_fixkappa">fixkappa</code></td>
<td>
<p>Logical - is kappa fixed or can it vary under the model?</p>
</td></tr>
<tr><td><code id="blockmod_+3A_logd">logd</code></td>
<td>
<p><code>function(blocks)</code> - log density for <code>blocks</code></p>
</td></tr>
<tr><td><code id="blockmod_+3A_dcond">dcond</code></td>
<td>
<p><code>function(blocks, i)</code> - conditional density for the block assignment <code>i</code> in <code>blocks</code></p>
</td></tr>
<tr><td><code id="blockmod_+3A_r">r</code></td>
<td>
<p><code>function(n), sorted=FALSE</code> - samples a blocks object from the model</p>
</td></tr>
<tr><td><code id="blockmod_+3A_...">...</code></td>
<td>
<p>parameters of the model for use in <code>r</code>, <code>logd</code>, <code>dcond</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A block model is a probability model for a <code>blocks</code> object.
This class creates a closure with three functions:
- a random method for sampling block a structure from the model with <code>n</code> nodes; a
- a log-density method for computing the log-density of a given block structure in a <code>blocks</code> object
- a conditional density function that takes a <code>blocks</code> object and a node <code>i</code>
</p>


<h3>Value</h3>

<p>a <code>blockmod</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinom">multinom</a></code> <code><a href="#topic+dma">dma</a></code> <code><a href="#topic+crp">crp</a></code> <code><a href="#topic+blocks">blocks</a></code>
</p>

<hr>
<h2 id='blocks'>Blocks object</h2><span id='topic+blocks'></span>

<h3>Description</h3>

<p>create a blocks object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks(z, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocks_+3A_z">z</code></td>
<td>
<p>vector of block labels for each node</p>
</td></tr>
<tr><td><code id="blocks_+3A_kappa">kappa</code></td>
<td>
<p>maximum number of blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>stores the block allocations and total number of blocks for a stochastic block model
</p>


<h3>Value</h3>

<p>a <code>blocks</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Assign six nodes to four blocks:
b &lt;- blocks(c(1,1,2,3,4,4), 4)
print(b)
plot(b) ## shows id two nodes are members of the same block
</code></pre>

<hr>
<h2 id='blocktrace'>plot a trace of the blocks from MCMC samples</h2><span id='topic+blocktrace'></span>

<h3>Description</h3>

<p>plot a trace of the blocks from MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocktrace(postz, burnin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocktrace_+3A_postz">postz</code></td>
<td>
<p>output from sampler</p>
</td></tr>
<tr><td><code id="blocktrace_+3A_burnin">burnin</code></td>
<td>
<p>which iterations to plot? defaults to all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ggplot2' object
</p>

<hr>
<h2 id='crp'>Chinese Restaurant Process</h2><span id='topic+crp'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+blockmod">blockmod</a></code> for the Chinese restaurant process (CRP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crp(gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crp_+3A_gamma">gamma</code></td>
<td>
<p>concentration parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CRP posits that each node arrives in turn. The first node joins the first block. Each subsequent node starts a new block with probability 'gamma' or joins an existing block proportional to the block size.
</p>


<h3>Value</h3>

<p>a block model representing a <code>CRP(gamma)</code> distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate from a CRP(5) prior
m &lt;- crp(5)
print(m)
m$r(10)
</code></pre>

<hr>
<h2 id='ddirichlet'>Dirichlet distribution</h2><span id='topic+ddirichlet'></span>

<h3>Description</h3>

<p>Density of Dirichlet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, gam, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddirichlet_+3A_x">x</code></td>
<td>
<p>random variable in the d-dimensional simplex</p>
</td></tr>
<tr><td><code id="ddirichlet_+3A_gam">gam</code></td>
<td>
<p>a length K concentration parameter</p>
</td></tr>
<tr><td><code id="ddirichlet_+3A_log">log</code></td>
<td>
<p>return the log-probability instead?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- rep(2,5)
p &lt;- rdirichlet(1, g) ## a length-5 probability vector
ddirichlet(p, g)
</code></pre>

<hr>
<h2 id='dedges'>Density of edges</h2><span id='topic+dedges'></span>

<h3>Description</h3>

<p>Compute the probability density for an <code><a href="#topic+edges">edges</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dedges(x, edges, edgemod, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dedges_+3A_x">x</code></td>
<td>
<p>an R object for dispatch</p>
</td></tr>
<tr><td><code id="dedges_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="dedges_+3A_edgemod">edgemod</code></td>
<td>
<p>an <code><a href="#topic+edgemod">edgemod</a></code> object</p>
</td></tr>
<tr><td><code id="dedges_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NAs when calculating?</p>
</td></tr>
<tr><td><code id="dedges_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix same size as <code>edges$E</code> with density of each edge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dedges.sbm">dedges.sbm</a></code> <code><a href="#topic+dedges.sbm">dedges.sbm</a></code>
</p>

<hr>
<h2 id='dedges.numeric'>likelihood of edges</h2><span id='topic+dedges.numeric'></span>

<h3>Description</h3>

<p>likelihood of edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
dedges(x, edges, edgemod, na.rm = na.rm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dedges.numeric_+3A_x">x</code></td>
<td>
<p>a matrix of parameters (with same size as <code>edges$E</code>)</p>
</td></tr>
<tr><td><code id="dedges.numeric_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="dedges.numeric_+3A_edgemod">edgemod</code></td>
<td>
<p>an <code><a href="#topic+edgemod">edgemod</a></code> object</p>
</td></tr>
<tr><td><code id="dedges.numeric_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NAs when calculating?</p>
</td></tr>
<tr><td><code id="dedges.numeric_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>edgemod$logd</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>likelihood of edges under the <code><a href="#topic+edgemod">edgemod</a></code> using parameters in matrix <code>pmat</code>
</p>

<hr>
<h2 id='dedges.sbm'>Density of edges</h2><span id='topic+dedges.sbm'></span>

<h3>Description</h3>

<p>Compute the probability density for an <code><a href="#topic+edges">edges</a></code> object under an <code><a href="#topic+sbm">sbm</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbm'
dedges(x, edges, edgemod, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dedges.sbm_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="dedges.sbm_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="dedges.sbm_+3A_edgemod">edgemod</code></td>
<td>
<p>an <code><a href="#topic+edgemod">edgemod</a></code> object</p>
</td></tr>
<tr><td><code id="dedges.sbm_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NAs when calculating?</p>
</td></tr>
<tr><td><code id="dedges.sbm_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>dedges.params</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix same size as <code>edges$E</code> with density of each edge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make an sbm model, sample data then plot and print:
model &lt;- sbmmod(dma(2,5), param_beta(1,1,1,1), edges_bern())
s &lt;- model$r(100)
e &lt;- redges(s, model$edge)
dedges(s, e, model$edge)
</code></pre>

<hr>
<h2 id='delblock'>Delete a block move</h2><span id='topic+delblock'></span>

<h3>Description</h3>

<p>proposes deleting an empty block (chosen at random among empty Blocks)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delblock(sbm, edges, sbmmod, rho = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delblock_+3A_sbm">sbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="delblock_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="delblock_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="delblock_+3A_rho">rho</code></td>
<td>
<p>probability of choosing to add a block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated <code>sbm</code> object
</p>

<hr>
<h2 id='dma'>Dirichlet Multinomial Allocation</h2><span id='topic+dma'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+blockmod">blockmod</a></code> for Dirichlet Multinomial Allocation (DMA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dma(gamma, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dma_+3A_gamma">gamma</code></td>
<td>
<p>parameter for Dirichlet component</p>
</td></tr>
<tr><td><code id="dma_+3A_delta">delta</code></td>
<td>
<p>parameter for Poison component</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model posits:
</p>
<p style="text-align: center;"><code class="reqn">kappa-1 ~ Pois(delta)</code>
</p>

<p style="text-align: center;"><code class="reqn">omega|kappa, gamma ~ Dirichlet(gamma)</code>
</p>

<p style="text-align: center;"><code class="reqn">Z_i|omega ~ Multinomial(omega) for i=1 .. n</code>
</p>



<h3>Value</h3>

<p>a block model representing a <code>dma(gamma, delta)</code> distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate from a DMA(2, 5) prior
## This models the `number of blocks-1` as Poisson(5)
## and block assignments as Dirichlet-Multinomial(2, 2, ...)
m &lt;- dma(2, 5)
print(m)
m$r(10)
</code></pre>

<hr>
<h2 id='drawblock.dp'>Draw block membership</h2><span id='topic+drawblock.dp'></span>

<h3>Description</h3>

<p>Draw block membership in a Dirichlet process sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawblock.dp(i, currsbm, edges, sbmmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawblock.dp_+3A_i">i</code></td>
<td>
<p>node to update</p>
</td></tr>
<tr><td><code id="drawblock.dp_+3A_currsbm">currsbm</code></td>
<td>
<p>current <code>sbm</code> object</p>
</td></tr>
<tr><td><code id="drawblock.dp_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="drawblock.dp_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sample a new block assignment for i under a Dirichlet process.
Care needs to be taken with singleton blocks to update the parameter model in <code>currsbm</code>.
</p>


<h3>Value</h3>

<p>updated <code>sbm</code> object
</p>


<h3>See Also</h3>

<p>For full algorithm details see <a href="http://doi.org/10.17635/lancaster/thesis/296">http://doi.org/10.17635/lancaster/thesis/296</a>
</p>

<hr>
<h2 id='drawblock.gibbs'>Gibbs-like reassignment of nodes to the current set of blocks</h2><span id='topic+drawblock.gibbs'></span>

<h3>Description</h3>

<p>Reassign node 'i'  to the current set of blocks given the current number of blocks and the other block assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawblock.gibbs(i, currsbm, edges, sbmmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawblock.gibbs_+3A_i">i</code></td>
<td>
<p>the node to reassign</p>
</td></tr>
<tr><td><code id="drawblock.gibbs_+3A_currsbm">currsbm</code></td>
<td>
<p>an <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="drawblock.gibbs_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="drawblock.gibbs_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code>sbm</code> object with new block assignment for i
</p>

<hr>
<h2 id='drawblocks.dp'>Draw block memberships</h2><span id='topic+drawblocks.dp'></span>

<h3>Description</h3>

<p>Draw block memberships in a Dirichlet process sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawblocks.dp(currsbm, edges, sbmmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawblocks.dp_+3A_currsbm">currsbm</code></td>
<td>
<p>current <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="drawblocks.dp_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="drawblocks.dp_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>iteratively updates the block  assignment of each node using a Dirichlet process update move
</p>


<h3>Value</h3>

<p>updated <code>sbm</code> object
</p>

<hr>
<h2 id='drawblocks.gibbs'>Gibbs-like reassignment of nodes to the current set of blocks</h2><span id='topic+drawblocks.gibbs'></span>

<h3>Description</h3>

<p>Sweep through the set of nodes and reassign to the current set of blocks given the current number of blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawblocks.gibbs(currsbm, edges, sbmmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawblocks.gibbs_+3A_currsbm">currsbm</code></td>
<td>
<p>an <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="drawblocks.gibbs_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="drawblocks.gibbs_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code><a href="#topic+sbm">sbm</a></code> object with new block assignments
</p>

<hr>
<h2 id='drawparams'>Metropolis updates by drawing parameters</h2><span id='topic+drawparams'></span>

<h3>Description</h3>

<p>Simulate parameters for the given model with a Metropolis-Hastings step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawparams(sbm, edges, sbmmod, sigma = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawparams_+3A_sbm">sbm</code></td>
<td>
<p>current <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="drawparams_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code></p>
</td></tr>
<tr><td><code id="drawparams_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code></p>
</td></tr>
<tr><td><code id="drawparams_+3A_sigma">sigma</code></td>
<td>
<p>parameter for <code>drawparam</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>iterate through the parameters in <code>currsbm</code> and update.
</p>


<h3>Value</h3>

<p>updated <code>sbm</code> object
</p>

<hr>
<h2 id='edgemod'>Class for edge models</h2><span id='topic+edgemod'></span>

<h3>Description</h3>

<p>A class with a random and density method for <code>edges</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgemod(logd, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgemod_+3A_logd">logd</code></td>
<td>
<p>function(e, p) to calculate likelihood of edge an edge e given parameter array p</p>
</td></tr>
<tr><td><code id="edgemod_+3A_r">r</code></td>
<td>
<p>function(p) - simulate an edge given a parameter p (optional)</p>
</td></tr>
<tr><td><code id="edgemod_+3A_...">...</code></td>
<td>
<p>additional arguments to append to <code>edgemod</code> internal list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>edgemod</code> object
</p>


<h3>Note</h3>

<p>the parameter for <code>logd</code> is an array of c(dimension of theta, dim(E)) e.g. from <code><a href="#topic+parammat">parammat</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edges_bern">edges_bern</a></code> <code><a href="#topic+edges_pois">edges_pois</a></code> <code><a href="#topic+edges_norm">edges_norm</a></code>
</p>

<hr>
<h2 id='edges'>Class for edge data</h2><span id='topic+edges'></span>

<h3>Description</h3>

<p>A class to hold edge data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(e, sym, loops, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_e">e</code></td>
<td>
<p>a matrix or array representing the raw edge-state data</p>
</td></tr>
<tr><td><code id="edges_+3A_sym">sym</code></td>
<td>
<p>is the network symmetric? (<code>e[ji] = e[ji]</code>)</p>
</td></tr>
<tr><td><code id="edges_+3A_loops">loops</code></td>
<td>
<p>does the network contain self-loops? (edges from node i to i)</p>
</td></tr>
<tr><td><code id="edges_+3A_...">...</code></td>
<td>
<p>additional arguments to append to edges internal list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an edges object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make an sbm model, sample data then plot and print:
model &lt;- sbmmod(dma(2,5), param_beta(1,1,1,1), edges_bern())
s &lt;- model$r(100)
e &lt;- redges(s, model$edge)
plot(e)
plot(e, s)
print(e)
</code></pre>

<hr>
<h2 id='edges_bern'>Bernoulli edge model</h2><span id='topic+edges_bern'></span>

<h3>Description</h3>

<p>Make an <code>edgemod</code> model with Bernoulli edge-states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_bern(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_bern_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>rbinom</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>edgemod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eb &lt;- edges_bern() ## makes `eb` an edgemod for Bernoulli edge-states
</code></pre>

<hr>
<h2 id='edges_nbin'>Negative-Binomial edge model</h2><span id='topic+edges_nbin'></span>

<h3>Description</h3>

<p>Make an <code>edgemod</code> model with Negative-Binomial edge-states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_nbin(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_nbin_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>rnbinom</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>edgemod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enb &lt;- edges_nbin() ## makes `enb` an edgemod for Negative-Binomial edge-states
</code></pre>

<hr>
<h2 id='edges_norm'>Normal edge model</h2><span id='topic+edges_norm'></span>

<h3>Description</h3>

<p>Make an <code>edgemod</code> model with Normal edge-states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_norm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_norm_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>rnorm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>edgemod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>en &lt;- edges_norm() ## makes `en` an edgemod for Normal edge-states
</code></pre>

<hr>
<h2 id='edges_pois'>Poisson edge model</h2><span id='topic+edges_pois'></span>

<h3>Description</h3>

<p>Make an <code>edgemod</code> model with Poisson edge-states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_pois(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_pois_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>rpois</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>edgemod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ep &lt;- edges_pois() ## makes `ep` an edgemod for Poisson edge-states
</code></pre>

<hr>
<h2 id='Enron'>The Enron data set as extracted from <code>igraph</code> using the script in data-raw</h2><span id='topic+Enron'></span>

<h3>Description</h3>

<p>A data set of counts of emails between email addresses
This is a non-symmetric network.
Nodes represent email address.
The edge-state ij between two email addresses i and j is the number of emails sent from i to j
The Groups vector is the node label from the igraph attribute &quot;notes&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Enron
</code></pre>


<h3>Format</h3>

<p>A list containing
</p>

<dl>
<dt>Edges</dt><dd><p>an edges object with each edge-state representing the number of emails between two email addresses</p>
</dd>
<dt>Groups</dt><dd><p>A vector giving a group name to which the email address belong. The order matches the edges such that Edges[i,j] is the edge-state between the nodes i and nodes j who are members of Groups[i] and Groups[j] respectively</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://cran.r-project.org/package=igraphdata">https://cran.r-project.org/package=igraphdata</a>
</p>

<hr>
<h2 id='eval_plots'>get a set of evaluation plots from MCMC samples</h2><span id='topic+eval_plots'></span>

<h3>Description</h3>

<p>get a set of evaluation plots from MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_plots(output, burnin, theta_index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_plots_+3A_output">output</code></td>
<td>
<p>from sampler</p>
</td></tr>
<tr><td><code id="eval_plots_+3A_burnin">burnin</code></td>
<td>
<p>burn-in period (a vector of iteration numbers to subset outputs)</p>
</td></tr>
<tr><td><code id="eval_plots_+3A_theta_index">theta_index</code></td>
<td>
<p>which set of thetas to plot?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of ggplot objects (with descriptive names)
</p>

<hr>
<h2 id='is.sbm'>is.sbm</h2><span id='topic+is.sbm'></span>

<h3>Description</h3>

<p>Logical check if an object is an <code><a href="#topic+sbm">sbm</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sbm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sbm_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating if <code>x</code> is an <code><a href="#topic+sbm">sbm</a></code> object
</p>

<hr>
<h2 id='Macaque'>The Macaque data set as extracted from <code>igraph</code> using the script in data-raw</h2><span id='topic+Macaque'></span>

<h3>Description</h3>

<p>The Macaque data set as extracted from <code>igraph</code> using the script in data-raw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Macaque
</code></pre>


<h3>Format</h3>

<p>An <code>edges</code> object of activation counts between brain regions in a Macaque
</p>


<h3>See Also</h3>

<p>igraph
</p>

<hr>
<h2 id='marglike_bern'>Marginal likelihood model for Bernoulli distributed edges</h2><span id='topic+marglike_bern'></span>

<h3>Description</h3>

<p>calculate the marginal likelihood for a node for samplers using conjugate models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marglike_bern(znoi, ei, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marglike_bern_+3A_znoi">znoi</code></td>
<td>
<p>a matrix of block assignments without node i</p>
</td></tr>
<tr><td><code id="marglike_bern_+3A_ei">ei</code></td>
<td>
<p>edge-states incident to i</p>
</td></tr>
<tr><td><code id="marglike_bern_+3A_parammod">parammod</code></td>
<td>
<p>a <code>parammod</code> object representing the Bernoulli-Beta model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-probability of node i belonging to each block
</p>

<hr>
<h2 id='marglike_norm'>Marginal likelihood model for Normal distributed edges</h2><span id='topic+marglike_norm'></span>

<h3>Description</h3>

<p>calculate the marginal likelihood for a node for samplers using conjugate models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marglike_norm(znoi, ei, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marglike_norm_+3A_znoi">znoi</code></td>
<td>
<p>a matrix of block assignments without node i</p>
</td></tr>
<tr><td><code id="marglike_norm_+3A_ei">ei</code></td>
<td>
<p>edge-states incident to i</p>
</td></tr>
<tr><td><code id="marglike_norm_+3A_parammod">parammod</code></td>
<td>
<p>a <code>parammod</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-probability of node i belonging to each block
</p>

<hr>
<h2 id='marglike_pois'>Marginal likelihood model for Poisson distributed edges</h2><span id='topic+marglike_pois'></span>

<h3>Description</h3>

<p>calculate the marginal likelihood for a node for samplers using conjugate models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marglike_pois(znoi, ei, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marglike_pois_+3A_znoi">znoi</code></td>
<td>
<p>a matrix of block assignments without node i</p>
</td></tr>
<tr><td><code id="marglike_pois_+3A_ei">ei</code></td>
<td>
<p>edge-states incident to i</p>
</td></tr>
<tr><td><code id="marglike_pois_+3A_parammod">parammod</code></td>
<td>
<p>a <code>parammod</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-probability of node i belonging to each block
</p>

<hr>
<h2 id='mergeavg'>Merge blocks</h2><span id='topic+mergeavg'></span>

<h3>Description</h3>

<p>Merge-move using an average to merge parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeavg(sbm, edges, sbmmod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeavg_+3A_sbm">sbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="mergeavg_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="mergeavg_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="mergeavg_+3A_...">...</code></td>
<td>
<p>additional parameter to 'accept'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the blocks are chosen at random, the nodes reassigned to the block with the smallest index, then the parameters are combined using the average on the transformed scale
</p>


<h3>Value</h3>

<p>an updated <code>sbm</code> object
</p>

<hr>
<h2 id='mergeblocks'>merge move block merging</h2><span id='topic+mergeblocks'></span>

<h3>Description</h3>

<p>merge move block merging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeblocks(currblocks, propparams, edges, sbmmod, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeblocks_+3A_currblocks">currblocks</code></td>
<td>
<p>current blocks</p>
</td></tr>
<tr><td><code id="mergeblocks_+3A_propparams">propparams</code></td>
<td>
<p>proposed parameters</p>
</td></tr>
<tr><td><code id="mergeblocks_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="mergeblocks_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="mergeblocks_+3A_k">k</code></td>
<td>
<p>Blocks to merge</p>
</td></tr>
<tr><td><code id="mergeblocks_+3A_l">l</code></td>
<td>
<p>Blocks to merge</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed block structure, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='mergeparams'>merge parameters</h2><span id='topic+mergeparams'></span>

<h3>Description</h3>

<p>merge parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeparams(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeparams_+3A_x">x</code></td>
<td>
<p>an object to dispatch on</p>
</td></tr>
<tr><td><code id="mergeparams_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>merged parameters from <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeparams.default">mergeparams.default</a></code> <code><a href="#topic+mergeparams.numeric">mergeparams.numeric</a></code>
</p>

<hr>
<h2 id='mergeparams.default'>Merge step: parameters</h2><span id='topic+mergeparams.default'></span>

<h3>Description</h3>

<p>Merge step: parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mergeparams(params, k, l, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeparams.default_+3A_params">params</code></td>
<td>
<p>a <code>params object</code></p>
</td></tr>
<tr><td><code id="mergeparams.default_+3A_k">k</code></td>
<td>
<p>Blocks to merge</p>
</td></tr>
<tr><td><code id="mergeparams.default_+3A_l">l</code></td>
<td>
<p>Blocks to merge</p>
</td></tr>
<tr><td><code id="mergeparams.default_+3A_parammod">parammod</code></td>
<td>
<p>a <code>parammod</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed_params, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='mergeparams.numeric'>Merge step - parameter merging</h2><span id='topic+mergeparams.numeric'></span>

<h3>Description</h3>

<p>Merge step - parameter merging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
mergeparams(thetak, thetal, x, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeparams.numeric_+3A_thetak">thetak</code>, <code id="mergeparams.numeric_+3A_thetal">thetal</code></td>
<td>
<p>parameters to merge</p>
</td></tr>
<tr><td><code id="mergeparams.numeric_+3A_x">x</code></td>
<td>
<p>auxiliary parameter</p>
</td></tr>
<tr><td><code id="mergeparams.numeric_+3A_parammod">parammod</code></td>
<td>
<p>a <code>parammod</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed_params, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='modeblocks'>modal block assignments from MCMC samples</h2><span id='topic+modeblocks'></span>

<h3>Description</h3>

<p>modal block assignments from MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeblocks(postz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeblocks_+3A_postz">postz</code></td>
<td>
<p>output from sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a blocks object with the modal block assignments under <code>postz</code>
</p>

<hr>
<h2 id='multinom'>Multinomial block assignment</h2><span id='topic+multinom'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+blockmod">blockmod</a></code> for Multinomial allocation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom(gamma, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinom_+3A_gamma">gamma</code></td>
<td>
<p>parameter for Dirichlet component <code class="reqn">Dirichlet(gamma, ..., gamma)</code></p>
</td></tr>
<tr><td><code id="multinom_+3A_kappa">kappa</code></td>
<td>
<p>the number of blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model posits that: for <code>i=1:n</code>
</p>
<p style="text-align: center;"><code class="reqn">Z_i ~ Multinomial(omega)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">omega ~ Dirichlet(gamma)</code>
</p>



<h3>Value</h3>

<p>a block model representing a <code>Multinomial(gamma)</code> distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A fixed number of blocks with multinomial assignment of nodes
m &lt;- multinom(1, 4)
print(m)
m$r(10) ## simulate a blocks object with 10 nodes
</code></pre>

<hr>
<h2 id='nodelike'>Likelihood of node assignment</h2><span id='topic+nodelike'></span>

<h3>Description</h3>

<p>Calculate the likelihood of a nod belonging to each of block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodelike(blocks, params, edges, i, sbmmod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodelike_+3A_blocks">blocks</code></td>
<td>
<p>an <code><a href="#topic+blocks">blocks</a></code> object</p>
</td></tr>
<tr><td><code id="nodelike_+3A_params">params</code></td>
<td>
<p>an <code><a href="#topic+params">params</a></code> object</p>
</td></tr>
<tr><td><code id="nodelike_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="nodelike_+3A_i">i</code></td>
<td>
<p>the node of interest</p>
</td></tr>
<tr><td><code id="nodelike_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> object</p>
</td></tr>
<tr><td><code id="nodelike_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>nodelike.blocks</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>the number of blocks considered is either the number of blocks in <code>sbm (kappa)</code> or <code>kappa+1</code> when <code>sbmmod</code> has a variable number of blocks.
care is taken for data which is directed and with loops.
</p>


<h3>Value</h3>

<p>likelihood of edges emanating from node i
</p>

<hr>
<h2 id='numblockstrace'>plot a trace of the number of blocks from MCMC samples</h2><span id='topic+numblockstrace'></span>

<h3>Description</h3>

<p>plot a trace of the number of blocks from MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numblockstrace(postk, burnin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numblockstrace_+3A_postk">postk</code></td>
<td>
<p>output from sampler</p>
</td></tr>
<tr><td><code id="numblockstrace_+3A_burnin">burnin</code></td>
<td>
<p>which iterations to plot? defaults to all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ggplot2' object
</p>

<hr>
<h2 id='param_beta'>Beta parameter model</h2><span id='topic+param_beta'></span>

<h3>Description</h3>

<p>A <code>parammod</code> with beta-distributed parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_beta(a0, a1, b0, b1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_beta_+3A_a0">a0</code></td>
<td>
<p><code>theta_0 ~ Beta(a0,a1)</code></p>
</td></tr>
<tr><td><code id="param_beta_+3A_a1">a1</code></td>
<td>
<p><code>theta_0 ~ Beta(a0,a1)</code></p>
</td></tr>
<tr><td><code id="param_beta_+3A_b0">b0</code></td>
<td>
<p><code>theta_k ~ Beta(b0,b1)</code></p>
</td></tr>
<tr><td><code id="param_beta_+3A_b1">b1</code></td>
<td>
<p><code>theta_k ~ Beta(b0,b1)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model represents a prior on theta with:
</p>
<p style="text-align: center;"><code class="reqn">theta_0 ~ Beta(a0,a1)</code>
</p>

<p style="text-align: center;"><code class="reqn">theta_k ~ Beta(b0,b1)</code>
</p>
<p> for k = 1 ... kappa
</p>


<h3>Value</h3>

<p>a <code>parammod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theta0 ~ Beta(1,9); thetak ~ Beta(9,1)
pb &lt;- param_beta(1,9,9,1)
pb$r(5) ## a draw with 5 within-block parameters
</code></pre>

<hr>
<h2 id='param_gamma'>Gamma parameter model</h2><span id='topic+param_gamma'></span>

<h3>Description</h3>

<p>A <code>parammod</code> with gamma-distributed parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_gamma(a0, a1, b0, b1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_gamma_+3A_a0">a0</code></td>
<td>
<p><code>theta_0 ~ Gamma(a0,a1)</code></p>
</td></tr>
<tr><td><code id="param_gamma_+3A_a1">a1</code></td>
<td>
<p><code>theta_0 ~ Gamma(a0,a1)</code></p>
</td></tr>
<tr><td><code id="param_gamma_+3A_b0">b0</code></td>
<td>
<p><code>theta_k ~ Gamma(b0,b1)</code></p>
</td></tr>
<tr><td><code id="param_gamma_+3A_b1">b1</code></td>
<td>
<p><code>theta_k ~ Gamma(b0,b1)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model represents a prior on theta with:
</p>
<p style="text-align: center;"><code class="reqn">theta_0 ~ Gamma(a0,a1)</code>
</p>

<p style="text-align: center;"><code class="reqn">theta_k ~ Gamma(b0,b1)</code>
</p>
<p> for k = 1 ... kappa
</p>


<h3>Value</h3>

<p>a <code>parammod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theta0 ~ Gamma(1,1); thetak ~ Gamma(5,5)
pg &lt;- param_gamma(1,1,5,5)
pg$r(5) ## a draw with 5 within-block parameters
</code></pre>

<hr>
<h2 id='param_nbin'>Parameter model for Negative Binomial</h2><span id='topic+param_nbin'></span>

<h3>Description</h3>

<p>Negative Binomial parameter model:
<code>theta_0 = (mu0, sigma0)</code>
<code>theta_k = (muk, sigmak)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_nbin(a0, a1, b0, b1, c0, c1, d0, d1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_nbin_+3A_a0">a0</code>, <code id="param_nbin_+3A_a1">a1</code></td>
<td>
<p><code>mu0 ~ Gamma(a0,a1)</code></p>
</td></tr>
<tr><td><code id="param_nbin_+3A_b0">b0</code>, <code id="param_nbin_+3A_b1">b1</code></td>
<td>
<p><code>sig_0 ~ Beta(b0,b1)</code></p>
</td></tr>
<tr><td><code id="param_nbin_+3A_c0">c0</code>, <code id="param_nbin_+3A_c1">c1</code></td>
<td>
<p><code>muk ~ Gamma(c0, c1)</code></p>
</td></tr>
<tr><td><code id="param_nbin_+3A_d0">d0</code>, <code id="param_nbin_+3A_d1">d1</code></td>
<td>
<p><code>sig_k ~ Beta(d0,d1)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parammod</code> representing Negative-Binomial distributed parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theta0 = (r0, p0); r0~Gamma(1,1); p0 ~ Beta(1,1);
## thetak = (rk, pk); rk~Gamma(3,3); pk ~ Beta(5,5);
pn &lt;- param_nbin(1,1,1,1,3,3,5,5)
pn$r(5) ## a draw with 5 within-block parameters
</code></pre>

<hr>
<h2 id='param_norm'>Parameter model for Normal Model</h2><span id='topic+param_norm'></span>

<h3>Description</h3>

<p>Normal parameter model:
<code>theta_0 = (mu0, sigma0)</code>
<code>theta_k = (muk, sigmak)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param_norm(a0, a1, b0, b1, c0, c1, d0, d1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_norm_+3A_a0">a0</code>, <code id="param_norm_+3A_a1">a1</code></td>
<td>
<p><code>mu0 ~ Normal(a0,a1)</code></p>
</td></tr>
<tr><td><code id="param_norm_+3A_b0">b0</code>, <code id="param_norm_+3A_b1">b1</code></td>
<td>
<p><code>sig_0 ~ Gamma(b0,b1)</code></p>
</td></tr>
<tr><td><code id="param_norm_+3A_c0">c0</code>, <code id="param_norm_+3A_c1">c1</code></td>
<td>
<p><code>muk ~ Normal(c0, c1)</code></p>
</td></tr>
<tr><td><code id="param_norm_+3A_d0">d0</code>, <code id="param_norm_+3A_d1">d1</code></td>
<td>
<p><code>sig_k ~ Gamma(d0,d1)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parammod</code> representing Normal distributed parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## theta0 = (mu0, sigma0); mu0~Normal(0,5); sigma0 ~ Gamma(1,1);
## thetak = (muk, sigmak); muk~Normal(0,3); sigmak ~ Gamma(5,2);
pn &lt;- param_norm(0,5,1,1,0,3,5,2)
pn$r(5) ## a draw with 5 within-block parameters
</code></pre>

<hr>
<h2 id='parammat'>Parameter Matrix</h2><span id='topic+parammat'></span>

<h3>Description</h3>

<p>Make a matrix of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parammat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parammat_+3A_x">x</code></td>
<td>
<p>object for dispatch</p>
</td></tr>
<tr><td><code id="parammat_+3A_...">...</code></td>
<td>
<p>additional arguments for method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parameter matrix object
</p>

<hr>
<h2 id='parammat.blocks'>Parameter Matrix</h2><span id='topic+parammat.blocks'></span>

<h3>Description</h3>

<p>Make a matrix of parameters from a <code>blocks</code> and <code>params</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blocks'
parammat(x, params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parammat.blocks_+3A_x">x</code></td>
<td>
<p>a <code>blocks</code> object</p>
</td></tr>
<tr><td><code id="parammat.blocks_+3A_params">params</code></td>
<td>
<p>a <code>params</code> object</p>
</td></tr>
<tr><td><code id="parammat.blocks_+3A_...">...</code></td>
<td>
<p>(unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>NxN</code> matrix <code>P</code>, with <code>P[i,j] = </code> the parameter governing edge <code>ij</code>
</p>

<hr>
<h2 id='parammat.matrix'>Parameter Matrix</h2><span id='topic+parammat.matrix'></span>

<h3>Description</h3>

<p>Make a matrix of parameters from a matrix of block assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
parammat(zleft, zright, params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parammat.matrix_+3A_zleft">zleft</code></td>
<td>
<p>block assignment matrix on the left</p>
</td></tr>
<tr><td><code id="parammat.matrix_+3A_zright">zright</code></td>
<td>
<p>block assignment matrix on the right</p>
</td></tr>
<tr><td><code id="parammat.matrix_+3A_params">params</code></td>
<td>
<p>the parameters object</p>
</td></tr>
<tr><td><code id="parammat.matrix_+3A_...">...</code></td>
<td>
<p>(unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of parameters of size |<code>zleft</code>| x |<code>zright</code>|
</p>

<hr>
<h2 id='parammat.params'>Parameter Matrix</h2><span id='topic+parammat.params'></span>

<h3>Description</h3>

<p>Make a matrix of parameters from a <code>params</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'params'
parammat(x, kappa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parammat.params_+3A_x">x</code></td>
<td>
<p>a <code>params</code> object</p>
</td></tr>
<tr><td><code id="parammat.params_+3A_kappa">kappa</code></td>
<td>
<p>- number of blocks to compute for matrix (optional)</p>
</td></tr>
<tr><td><code id="parammat.params_+3A_...">...</code></td>
<td>
<p>(unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of parameters
</p>

<hr>
<h2 id='parammat.sbm'>Parameter Matrix</h2><span id='topic+parammat.sbm'></span>

<h3>Description</h3>

<p>Make a matrix of parameters from an <code>sbm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbm'
parammat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parammat.sbm_+3A_x">x</code></td>
<td>
<p>an <code>sbm</code> object</p>
</td></tr>
<tr><td><code id="parammat.sbm_+3A_...">...</code></td>
<td>
<p>(unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of parameters
</p>

<hr>
<h2 id='parammod'>Parameter Model</h2><span id='topic+parammod'></span>

<h3>Description</h3>

<p>create a <code>parammod</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parammod(logd, r, t, invt, loggradt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parammod_+3A_logd">logd</code></td>
<td>
<p><code>function(params)</code> - log-density function for parameters</p>
</td></tr>
<tr><td><code id="parammod_+3A_r">r</code></td>
<td>
<p><code>function(kappa)</code> - random function to draw parameters</p>
</td></tr>
<tr><td><code id="parammod_+3A_t">t</code></td>
<td>
<p>mapping parameter space to real line</p>
</td></tr>
<tr><td><code id="parammod_+3A_invt">invt</code></td>
<td>
<p>mapping real line to parameter space</p>
</td></tr>
<tr><td><code id="parammod_+3A_loggradt">loggradt</code></td>
<td>
<p>log of the gradient of mapping <code>t</code></p>
</td></tr>
<tr><td><code id="parammod_+3A_...">...</code></td>
<td>
<p>additional arguments to store in the <code>parammod</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A parameter model is a probability model for a <code>params</code> object.
This class creates a closure with five functions:
- a random method for sampling a <code>params</code> object
- a log-density method for computing the log-density of a given <code>params</code> object
- a transformation function <code>t</code> that maps a parameter value to the real line
- the inverse of t
- the log-gradient of t
</p>


<h3>Value</h3>

<p>a <code>parammod</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+param_beta">param_beta</a></code> <code><a href="#topic+param_gamma">param_gamma</a></code> <code><a href="#topic+param_nbin">param_nbin</a></code> <code><a href="#topic+param_norm">param_norm</a></code>
</p>

<hr>
<h2 id='params'><code>params</code> S3 object</h2><span id='topic+params'></span>

<h3>Description</h3>

<p>make a <code>params</code> object from the between-block parameter <code>theta0</code> and a vector of within block parameters <code>thetak</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params(theta0, thetak)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_+3A_theta0">theta0</code></td>
<td>
<p>between block parameters - a vector of length 'dimension of theta'</p>
</td></tr>
<tr><td><code id="params_+3A_thetak">thetak</code></td>
<td>
<p>within block parameters - a matrix with <code>ncol=kappa</code> and <code>nrow=dimension of theta</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>params</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- params(0.1, c(0.2,0.4,0.5))
p
</code></pre>

<hr>
<h2 id='paramtrace'>plot a trace of parameter values from MCMC samples</h2><span id='topic+paramtrace'></span>

<h3>Description</h3>

<p>plot a trace of parameter values from MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramtrace(theta, range, burnin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramtrace_+3A_theta">theta</code></td>
<td>
<p>output from sampler</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_range">range</code></td>
<td>
<p>which thetas to plot? defaults to all.</p>
</td></tr>
<tr><td><code id="paramtrace_+3A_burnin">burnin</code></td>
<td>
<p>which iterations to plot? defaults to all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ggplot2' object
</p>

<hr>
<h2 id='plot.blocks'>Plot blocks</h2><span id='topic+plot.blocks'></span><span id='topic+image.blocks'></span>

<h3>Description</h3>

<p>plots a block object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blocks'
plot(x, col, xaxt = "n", yaxt = "n", xlab = "Nodes", ylab = "Nodes", ...)

## S3 method for class 'blocks'
image(x, col, xaxt = "n", yaxt = "n", xlab = "Nodes", ylab = "Nodes", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.blocks_+3A_x">x</code></td>
<td>
<p>a blocks object to plot</p>
</td></tr>
<tr><td><code id="plot.blocks_+3A_col">col</code></td>
<td>
<p>colours for the plot</p>
</td></tr>
<tr><td><code id="plot.blocks_+3A_xaxt">xaxt</code></td>
<td>
<p>override <code>image</code> parameters</p>
</td></tr>
<tr><td><code id="plot.blocks_+3A_yaxt">yaxt</code></td>
<td>
<p>override <code>image</code> parameters</p>
</td></tr>
<tr><td><code id="plot.blocks_+3A_xlab">xlab</code></td>
<td>
<p>override <code>image</code> parameters</p>
</td></tr>
<tr><td><code id="plot.blocks_+3A_ylab">ylab</code></td>
<td>
<p>override <code>image</code> parameters</p>
</td></tr>
<tr><td><code id="plot.blocks_+3A_...">...</code></td>
<td>
<p>additional parameters for <code>image</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot the block assignments in a <code>blocks</code> object as a matrix, color-coded by block membership
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Assign six nodes to four blocks:
b &lt;- blocks(c(1,1,2,3,4,4), 4)
plot(b)
## note that the lower left corner has one 2x2 red square
## indicating node 1 and 2 belong to the same block
</code></pre>

<hr>
<h2 id='plot.edges'>Plot</h2><span id='topic+plot.edges'></span><span id='topic+image.edges'></span>

<h3>Description</h3>

<p>plots an <code><a href="#topic+edges">edges</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edges'
plot(x, Blocks, sorted = TRUE, xlab = "Node", ylab = "Node", ...)

## S3 method for class 'edges'
image(x, Blocks, sorted = TRUE, xlab = "Node", ylab = "Node", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.edges_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="plot.edges_+3A_blocks">Blocks</code></td>
<td>
<p>a blocks object or <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="plot.edges_+3A_sorted">sorted</code></td>
<td>
<p>sort by block membership in <code><a href="#topic+sbm">sbm</a></code> before plotting?</p>
</td></tr>
<tr><td><code id="plot.edges_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="plot.edges_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="plot.edges_+3A_...">...</code></td>
<td>
<p>parameters for <code>image</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> plot of edges in a raster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make an sbm model, sample data then plot and print:
model &lt;- sbmmod(dma(2,5), param_beta(1,1,1,1), edges_bern())
s &lt;- model$r(100)
e &lt;- redges(s, model$edge)
plot(e)
plot(e, s)
print(e)
</code></pre>

<hr>
<h2 id='plot.sbm'>Plot for <code><a href="#topic+sbm">sbm</a></code> object</h2><span id='topic+plot.sbm'></span><span id='topic+image.sbm'></span>

<h3>Description</h3>

<p>plot an <code><a href="#topic+sbm">sbm</a></code> object as an <code>image</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbm'
plot(x, col, ...)

## S3 method for class 'sbm'
image(x, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sbm_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="plot.sbm_+3A_col">col</code></td>
<td>
<p>colours for each block - if missing, <code>rainbow</code> is used</p>
</td></tr>
<tr><td><code id="plot.sbm_+3A_...">...</code></td>
<td>
<p>additional arguments for plot</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>plot.default
</p>

<hr>
<h2 id='plotpostpairs'>helper function for trace plots</h2><span id='topic+plotpostpairs'></span>

<h3>Description</h3>

<p>helper function for trace plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpostpairs(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpostpairs_+3A_mat">mat</code></td>
<td>
<p>matrix to plot as an image using ggplot2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'ggplot2' plot objecy
</p>

<hr>
<h2 id='postpairs'>mean proportion of times two nodes were in the same block under MCMC samples</h2><span id='topic+postpairs'></span>

<h3>Description</h3>

<p>mean proportion of times two nodes were in the same block under MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postpairs(postz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postpairs_+3A_postz">postz</code></td>
<td>
<p>output from sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix P with P[i,j] = proportion of times i and j are in the same block under <code>postz</code>
</p>

<hr>
<h2 id='rcat'>Draw draw Categorical distribution</h2><span id='topic+rcat'></span>

<h3>Description</h3>

<p>Draw draw Categorical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcat(n, p, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcat_+3A_n">n</code></td>
<td>
<p>number of draws</p>
</td></tr>
<tr><td><code id="rcat_+3A_p">p</code></td>
<td>
<p>a length-d probability vector</p>
</td></tr>
<tr><td><code id="rcat_+3A_replace">replace</code></td>
<td>
<p>should the categories be replaced? If so n &lt; p required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a draw from Categorical(p)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcat(1, 1) ## returns 1 with probability 1
rcat(1, rep(1/6,6)) ## a dice roll
</code></pre>

<hr>
<h2 id='rdirichlet'>Dirichlet distribution</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Draw from Dirichlet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(n, gam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdirichlet_+3A_n">n</code></td>
<td>
<p>number of variates to draw</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_gam">gam</code></td>
<td>
<p>a vector of concentration parameters of length <code>K</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix dimension <code>n*k</code> of samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdirichlet(1, rep(2,5)) ## a length-5 probability vector
</code></pre>

<hr>
<h2 id='redges'>Simulate edges</h2><span id='topic+redges'></span>

<h3>Description</h3>

<p>Simulate edges from an <code><a href="#topic+sbm">sbm</a></code> object with a given <code><a href="#topic+edgemod">edgemod</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redges(SBM, edgemod, sym = TRUE, loops = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redges_+3A_sbm">SBM</code></td>
<td>
<p>an <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="redges_+3A_edgemod">edgemod</code></td>
<td>
<p>an <code><a href="#topic+edgemod">edgemod</a></code> object</p>
</td></tr>
<tr><td><code id="redges_+3A_sym">sym</code></td>
<td>
<p>should the network be symmetric?</p>
</td></tr>
<tr><td><code id="redges_+3A_loops">loops</code></td>
<td>
<p>should the network have self-loops?</p>
</td></tr>
<tr><td><code id="redges_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>edgemod$r</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>None
</p>


<h3>Value</h3>

<p>an <code>edges</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make an sbm model, sample data then plot and print:
model &lt;- sbmmod(dma(2,5), param_beta(1,1,1,1), edges_bern())
s &lt;- model$r(100)
e &lt;- redges(s, model$edge)
plot(e)
plot(e, s)
print(e)
</code></pre>

<hr>
<h2 id='rw'>Random Walk</h2><span id='topic+rw'></span>

<h3>Description</h3>

<p>performs a random walk on a parameter value with a given parameter model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw(p, pm, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw_+3A_p">p</code></td>
<td>
<p>a parameter</p>
</td></tr>
<tr><td><code id="rw_+3A_pm">pm</code></td>
<td>
<p>a <code>parammod</code> object</p>
</td></tr>
<tr><td><code id="rw_+3A_sigma">sigma</code></td>
<td>
<p>- scale of random walk</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ist(proposed parameter, locjacobian)</code>
</p>

<hr>
<h2 id='sampler'>top level sampler function</h2><span id='topic+sampler'></span>

<h3>Description</h3>

<p>top level sampler function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler(
  edges,
  sbmmod,
  nSteps = 1000,
  algorithm = "rj",
  sigma = 0.5,
  statusfreq,
  currsbm,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="sampler_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="sampler_+3A_nsteps">nSteps</code></td>
<td>
<p>number of steps to run sampler</p>
</td></tr>
<tr><td><code id="sampler_+3A_algorithm">algorithm</code></td>
<td>
<p>choice of algorithm options are: <code>"conjugate", "gibbs", "dp", "rj"</code></p>
</td></tr>
<tr><td><code id="sampler_+3A_sigma">sigma</code></td>
<td>
<p>random walk parameter for <code>theta</code></p>
</td></tr>
<tr><td><code id="sampler_+3A_statusfreq">statusfreq</code></td>
<td>
<p>print the elapsed number of iterations every <code>statusfreq</code> iterations</p>
</td></tr>
<tr><td><code id="sampler_+3A_currsbm">currsbm</code></td>
<td>
<p>initial state for <code>sbm</code> object (optional - one is drawn from <code>sbmmod</code> if not supplied)</p>
</td></tr>
<tr><td><code id="sampler_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to step</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>postz</code> traces for block assignments <code>z</code>
</p>
<p><code>postt</code> traces for <code>theta</code>
</p>
<p><code>postk</code> traces for number of blocks <code>kappa</code>
</p>
<p><code>postn</code> traces for number of occupied blocks
</p>
<p><code>nsteps</code> number of iterations of chain
</p>
<p><code>algorithm</code> choice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see vignette("Weibull-edges")
</code></pre>

<hr>
<h2 id='sampler.conj'>Conjugate model sampler</h2><span id='topic+sampler.conj'></span>

<h3>Description</h3>

<p>Conjugate model sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler.conj(currsbm, edges, sbmmod, sigma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler.conj_+3A_currsbm">currsbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="sampler.conj_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="sampler.conj_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="sampler.conj_+3A_sigma">sigma</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="sampler.conj_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>sbmmod$marglike</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>next state of <code>currsbm</code> object
</p>


<h3>Note</h3>

<p>If using the CRP as the block model, then this is the IRM sampler of Schmidt or Morup (Schmidt, M.N. and Morup, M., 2013. Nonparametric Bayesian modeling of complex networks: An introduction. IEEE Signal Processing Magazine, 30(3), pp.110-128.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- sbmmod(crp(3), param_beta(1,1,1,1), edges_bern(), marglike=marglike_bern)
trueSBM &lt;- model$r(100)
Edges &lt;- redges(trueSBM, model$edge)
out &lt;- sampler(Edges, model, 10, "conjugate")
</code></pre>

<hr>
<h2 id='sampler.dp'>Dirichlet process sampler</h2><span id='topic+sampler.dp'></span>

<h3>Description</h3>

<p>Dirichlet process sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler.dp(currsbm, edges, sbmmod, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler.dp_+3A_currsbm">currsbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="sampler.dp_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="sampler.dp_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="sampler.dp_+3A_sigma">sigma</code></td>
<td>
<p>random walk parameter for theta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>next state of <code>currsbm</code> object
</p>


<h3>See Also</h3>

<p>For full algorithm details see <a href="http://doi.org/10.17635/lancaster/thesis/296">http://doi.org/10.17635/lancaster/thesis/296</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- sbmmod(crp(4), param_norm(0,0,1,1,3,3,1,1), edges_norm())
trueSBM &lt;- model$r(100)
Edges &lt;- redges(trueSBM, model$edge)
dp_out &lt;- sampler(Edges, model, 25, "dp", sigma=0.1)
</code></pre>

<hr>
<h2 id='sampler.gibbs'>Gibbs sampling for node assignments</h2><span id='topic+sampler.gibbs'></span>

<h3>Description</h3>

<p>Gibbs sampling for node assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler.gibbs(currsbm, edges, sbmmod, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler.gibbs_+3A_currsbm">currsbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="sampler.gibbs_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="sampler.gibbs_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="sampler.gibbs_+3A_sigma">sigma</code></td>
<td>
<p>random walk parameter for theta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>next state of <code>currsbm</code> object
</p>


<h3>Note</h3>

<p>This requires a block model with a fixed kappa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- sbmmod(multinom(1, 3), param_gamma(1,1,1,1), edges_pois())
trueSBM &lt;- model$r(10)
Edges &lt;- redges(trueSBM, model$edge)
gibbs_out &lt;- sampler(Edges, model, algorithm="gibbs", 10, sigma=0.1)
eval_plots(gibbs_out)
</code></pre>

<hr>
<h2 id='sampler.rj'>reversible jump Markov chain Monte Carlo split-merge sampler</h2><span id='topic+sampler.rj'></span>

<h3>Description</h3>

<p>reversible jump Markov chain Monte Carlo split-merge sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler.rj(currsbm, edges, sbmmod, sigma, rho = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler.rj_+3A_currsbm">currsbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="sampler.rj_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="sampler.rj_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="sampler.rj_+3A_sigma">sigma</code></td>
<td>
<p>random walk parameter for <code>theta</code></p>
</td></tr>
<tr><td><code id="sampler.rj_+3A_rho">rho</code></td>
<td>
<p>propensity to add a block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>next state of <code>currsbm</code> object
</p>


<h3>See Also</h3>

<p>For full algorithm details see <a href="http://doi.org/10.17635/lancaster/thesis/296">http://doi.org/10.17635/lancaster/thesis/296</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- sbmmod(dma(1,10), param_nbin(1,1,4,4,0.5,0.5,0.5,0.5), edges_nbin())
trueSBM &lt;- model$r(100)
Edges &lt;- redges(trueSBM, model$edge)
rj_out &lt;- sampler(Edges, model, 10, "rj", sigma=0.1)
</code></pre>

<hr>
<h2 id='sbm'>Class <code>sbm</code></h2><span id='topic+sbm'></span>

<h3>Description</h3>

<p>Class <code>sbm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbm(blocks, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbm_+3A_blocks">blocks</code></td>
<td>
<p>a <code>blocks</code> object</p>
</td></tr>
<tr><td><code id="sbm_+3A_params">params</code></td>
<td>
<p>a <code>params</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>sbm</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sbm(blocks(c(1,1,2,2,3,3)), params(0.1, c(0.4,0.5,0.6)))
</code></pre>

<hr>
<h2 id='sbmmod'>Stochastic block model object</h2><span id='topic+sbmmod'></span>

<h3>Description</h3>

<p>A wrapper for a block and parameter model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbmmod(blockmod, parammod, edgemod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbmmod_+3A_blockmod">blockmod</code></td>
<td>
<p>a <code><a href="#topic+blockmod">blockmod</a></code> object</p>
</td></tr>
<tr><td><code id="sbmmod_+3A_parammod">parammod</code></td>
<td>
<p>a <code><a href="#topic+parammod">parammod</a></code> object</p>
</td></tr>
<tr><td><code id="sbmmod_+3A_edgemod">edgemod</code></td>
<td>
<p>an <code><a href="#topic+edgemod">edgemod</a></code> object</p>
</td></tr>
<tr><td><code id="sbmmod_+3A_...">...</code></td>
<td>
<p>additional arguments to store in the <code>sbmmod</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple wrapper for the block and parameter model for an <code>sbm</code> object
</p>


<h3>Value</h3>

<p>an <code>sbmmod</code> object with a method 'r(n)' sampling an <code>sbm</code> object with <code>n</code> nodes from the model and a method <code>logd(sbm)</code> computing the log-density of <code>sbm</code> under the model
</p>


<h3>Author(s)</h3>

<p>Matthew Ludkin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blockmod">blockmod</a></code> <code><a href="#topic+parammod">parammod</a></code> <code><a href="#topic+edgemod">edgemod</a></code>
</p>

<hr>
<h2 id='splitavg'>split move using average to merge parameters</h2><span id='topic+splitavg'></span>

<h3>Description</h3>

<p>split move using average to merge parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitavg(sbm, edges, sbmmod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitavg_+3A_sbm">sbm</code></td>
<td>
<p>the current state of the sampler</p>
</td></tr>
<tr><td><code id="splitavg_+3A_edges">edges</code></td>
<td>
<p>an <code><a href="#topic+edges">edges</a></code> object</p>
</td></tr>
<tr><td><code id="splitavg_+3A_sbmmod">sbmmod</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> model</p>
</td></tr>
<tr><td><code id="splitavg_+3A_...">...</code></td>
<td>
<p>additional parameter to 'accept'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated <code>sbm</code> object
</p>

<hr>
<h2 id='splitblocks'>split move: blocks</h2><span id='topic+splitblocks'></span>

<h3>Description</h3>

<p>split move: blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitblocks(currblocks, propparams, edges, sbmmod, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitblocks_+3A_currblocks">currblocks</code></td>
<td>
<p>current blocks</p>
</td></tr>
<tr><td><code id="splitblocks_+3A_propparams">propparams</code></td>
<td>
<p>proposed parameters</p>
</td></tr>
<tr><td><code id="splitblocks_+3A_edges">edges</code></td>
<td>
<p>an <code>edges</code> object</p>
</td></tr>
<tr><td><code id="splitblocks_+3A_sbmmod">sbmmod</code></td>
<td>
<p>a model list</p>
</td></tr>
<tr><td><code id="splitblocks_+3A_k">k</code></td>
<td>
<p>block to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed block structure, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='splitparams'>split move: parameters</h2><span id='topic+splitparams'></span>

<h3>Description</h3>

<p>split move: parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitparams(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitparams_+3A_x">x</code></td>
<td>
<p>object for dispatch</p>
</td></tr>
<tr><td><code id="splitparams_+3A_...">...</code></td>
<td>
<p>additional arguments for method</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed_params, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='splitparams.numeric'>split move: <code>params</code></h2><span id='topic+splitparams.numeric'></span>

<h3>Description</h3>

<p>split move: <code>params</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
splitparams(theta, u, x, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitparams.numeric_+3A_theta">theta</code></td>
<td>
<p>a parameter to split</p>
</td></tr>
<tr><td><code id="splitparams.numeric_+3A_u">u</code></td>
<td>
<p>auxiliary variable</p>
</td></tr>
<tr><td><code id="splitparams.numeric_+3A_x">x</code></td>
<td>
<p>auxiliary variable</p>
</td></tr>
<tr><td><code id="splitparams.numeric_+3A_parammod">parammod</code></td>
<td>
<p><code>parammod</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed_params, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='splitparams.params'>split move: <code>params</code></h2><span id='topic+splitparams.params'></span>

<h3>Description</h3>

<p>split move: <code>params</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'params'
splitparams(params, k, parammod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitparams.params_+3A_params">params</code></td>
<td>
<p>a <code>params</code> object to split</p>
</td></tr>
<tr><td><code id="splitparams.params_+3A_k">k</code></td>
<td>
<p>block to split</p>
</td></tr>
<tr><td><code id="splitparams.params_+3A_parammod">parammod</code></td>
<td>
<p><code>parammod</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list(proposed_params, log-acceptance-prob)</code>
</p>

<hr>
<h2 id='StackOverflow'>The Stack-Overflow data set as extracted from <code>igraph</code> using the script in data-raw
Extracted on 27/8/2019 from Kaggle (login required) using:
<code>library(rvest)</code>
<code>read_html("https://www.kaggle.com/stackoverflow/stack-overflow-tag-network/downloads/stack_network_links.csv/1")</code></h2><span id='topic+StackOverflow'></span>

<h3>Description</h3>

<p>The Stack-Overflow data set as extracted from <code>igraph</code> using the script in data-raw
Extracted on 27/8/2019 from Kaggle (login required) using:
<code>library(rvest)</code>
<code>read_html("https://www.kaggle.com/stackoverflow/stack-overflow-tag-network/downloads/stack_network_links.csv/1")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StackOverflow
</code></pre>


<h3>Format</h3>

<p>An <code>edges</code> object of activation counts between brain regions in a Macaque
</p>


<h3>Source</h3>

<p><a href="https://www.kaggle.com/stackoverflow/stack-overflow-tag-network/">https://www.kaggle.com/stackoverflow/stack-overflow-tag-network/</a>
</p>


<h3>See Also</h3>

<p>igraph
</p>

<hr>
<h2 id='updateblock'>Update the block assignment of a node</h2><span id='topic+updateblock'></span>

<h3>Description</h3>

<p>change the block assignment in <code>x</code> of a node to a new block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateblock(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateblock_+3A_x">x</code></td>
<td>
<p>object for dispatch</p>
</td></tr>
<tr><td><code id="updateblock_+3A_...">...</code></td>
<td>
<p>additional arguments for method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object like 'x' with updated block structure
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateblock.blocks">updateblock.blocks</a></code> <code><a href="#topic+updateblock.sbm">updateblock.sbm</a></code>
</p>

<hr>
<h2 id='updateblock.blocks'>Update the block assignment of a node</h2><span id='topic+updateblock.blocks'></span>

<h3>Description</h3>

<p>change the block assignment in an <code>blocks</code> object to a new block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blocks'
updateblock(blocks, i, newblock)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateblock.blocks_+3A_blocks">blocks</code></td>
<td>
<p>a <code><a href="#topic+blocks">blocks</a></code> object</p>
</td></tr>
<tr><td><code id="updateblock.blocks_+3A_i">i</code></td>
<td>
<p>the node to update</p>
</td></tr>
<tr><td><code id="updateblock.blocks_+3A_newblock">newblock</code></td>
<td>
<p>the new block for node i</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new <code>blocks</code> object
</p>

<hr>
<h2 id='updateblock.sbm'>Update the block assignment of a node</h2><span id='topic+updateblock.sbm'></span>

<h3>Description</h3>

<p>change the block assignment in an <code>sbm</code> object to a new block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbm'
updateblock(currsbm, i, newblock, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateblock.sbm_+3A_currsbm">currsbm</code></td>
<td>
<p>an <code><a href="#topic+sbm">sbm</a></code> object</p>
</td></tr>
<tr><td><code id="updateblock.sbm_+3A_i">i</code></td>
<td>
<p>the node to update</p>
</td></tr>
<tr><td><code id="updateblock.sbm_+3A_newblock">newblock</code></td>
<td>
<p>the new block for node i</p>
</td></tr>
<tr><td><code id="updateblock.sbm_+3A_model">model</code></td>
<td>
<p>an <code><a href="#topic+sbmmod">sbmmod</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new <code>sbm</code> object
</p>


<h3>Note</h3>

<p>If adding a new block, this draws from the prior
</p>

<hr>
<h2 id='vmeasure'>V-measure</h2><span id='topic+vmeasure'></span>

<h3>Description</h3>

<p>Calculate the V-measure of two clusterings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmeasure(z, truez, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmeasure_+3A_z">z</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="vmeasure_+3A_truez">truez</code></td>
<td>
<p>reference vector</p>
</td></tr>
<tr><td><code id="vmeasure_+3A_beta">beta</code></td>
<td>
<p>parameter <code>beta=1</code> gives equal weight to homogeneity and completeness</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An information based measure of similarity between two clusterings
</p>


<h3>Value</h3>

<p>v-measure of z against <code>truez</code>
</p>


<h3>See Also</h3>

<p>Rosenberg, A., &amp; Hirschberg, J. (2007, June). V-measure: A conditional entropy-based external cluster evaluation measure. In Proceedings of the 2007 joint conference on empirical methods in natural language processing and computational natural language learning (EMNLP-CoNLL) (pp. 410-420).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vmeasure(c(1,1,2,2,3,3), c(2,2,1,1,3,3)) ## 1 - doesn't care for labels
vmeasure(c(1,1,2,2,3,3), c(1,1,2,2,2,2)) ## 0.7333
vmeasure(c(1,1,2,2,3,3), c(1,1,2,2,3,4)) ## 0.904
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
