<!DOCTYPE html><html lang="en"><head><title>Help for package ResultModelManager</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ResultModelManager}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ResultModelManager-package'><p>ResultModelManager: Result Model Manager</p></a></li>
<li><a href='#ConnectionHandler'><p>ConnectionHandler</p></a></li>
<li><a href='#createQueryNamespace'><p>Create query namespace</p></a></li>
<li><a href='#createResultExportManager'><p>Create Result Export Manager</p></a></li>
<li><a href='#DataMigrationManager'><p>DataMigrationManager (DMM)</p></a></li>
<li><a href='#deleteAllRowsForDatabaseId'><p>Delete all rows for database id</p></a></li>
<li><a href='#deleteAllRowsForPrimaryKey'><p>Delete results rows for primary key values from database server tables</p></a></li>
<li><a href='#generateSqlSchema'><p>Schema generator</p></a></li>
<li><a href='#grantTablePermissions'><p>Grant Table Permissions</p></a></li>
<li><a href='#loadResultsDataModelSpecifications'><p>Get specifications from a given file path</p></a></li>
<li><a href='#PooledConnectionHandler'><p>Pooled Connection Handler</p></a></li>
<li><a href='#QueryNamespace'><p>QueryNamespace</p></a></li>
<li><a href='#ResultExportManager'><p>Result Set Export Manager</p></a></li>
<li><a href='#unzipResults'><p>Unzips a results.zip file and enforces standards required by</p>
<code>uploadResults</code></a></li>
<li><a href='#uploadResults'><p>Upload results to the database server.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Result Model Manager</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Database data model management utilities for R packages in the Observational Health Data Sciences and
    Informatics program <a href="https://ohdsi.org">https://ohdsi.org</a>. 'ResultModelManager' provides utility functions to allow package
    maintainers to migrate existing SQL database models, export and import results in consistent patterns.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OHDSI/ResultModelManager">https://github.com/OHDSI/ResultModelManager</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OHDSI/ResultModelManager/issues">https://github.com/OHDSI/ResultModelManager/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), R6, DatabaseConnector (&ge; 6.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>SqlRender, ParallelLogger, checkmate, DBI, pool, readr, zip,
dplyr, dbplyr, rlang, lubridate, fastmap, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), RSQLite, duckdb, knitr, rmarkdown,
keyring, devtools, pkgdown, remotes, styler, Andromeda</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-18 17:04:52 UTC; jgilber2</td>
</tr>
<tr>
<td>Author:</td>
<td>Jamie Gilbert [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jamie Gilbert &lt;gilbert@ohdsi.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-19 05:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ResultModelManager-package'>ResultModelManager: Result Model Manager</h2><span id='topic+ResultModelManager'></span><span id='topic+ResultModelManager-package'></span>

<h3>Description</h3>

<p>Database data model management utilities for R packages in the Observational Health Data Sciences and Informatics program <a href="https://ohdsi.org">https://ohdsi.org</a>. 'ResultModelManager' provides utility functions to allow package maintainers to migrate existing SQL database models, export and import results in consistent patterns.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jamie Gilbert <a href="mailto:gilbert@ohdsi.org">gilbert@ohdsi.org</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OHDSI/ResultModelManager">https://github.com/OHDSI/ResultModelManager</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OHDSI/ResultModelManager/issues">https://github.com/OHDSI/ResultModelManager/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ConnectionHandler'>ConnectionHandler</h2><span id='topic+ConnectionHandler'></span>

<h3>Description</h3>

<p>Class for handling DatabaseConnector:connection objects with consistent R6 interfaces for pooled and non-pooled connections.
Allows a connection to cleanly be opened and closed and stored within class/object variables
</p>


<h3>Value</h3>

<p>DatabaseConnector Connection instance
close Connection
</p>
<p>boolean TRUE if connection is valid
queryDb
</p>
<p>boolean TRUE if connection is valid
executeSql
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>connectionDetails</code></dt><dd><p>DatabaseConnector connectionDetails object</p>
</dd>
<dt><code>con</code></dt><dd><p>DatabaseConnector connection object</p>
</dd>
<dt><code>isActive</code></dt><dd><p>Is connection active or not#'</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConnectionHandler-new"><code>ConnectionHandler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-dbms"><code>ConnectionHandler$dbms()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-tbl"><code>ConnectionHandler$tbl()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-renderTranslateSql"><code>ConnectionHandler$renderTranslateSql()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-initConnection"><code>ConnectionHandler$initConnection()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-getConnection"><code>ConnectionHandler$getConnection()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-closeConnection"><code>ConnectionHandler$closeConnection()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-finalize"><code>ConnectionHandler$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-dbIsValid"><code>ConnectionHandler$dbIsValid()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-queryDb"><code>ConnectionHandler$queryDb()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-executeSql"><code>ConnectionHandler$executeSql()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-queryFunction"><code>ConnectionHandler$queryFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-executeFunction"><code>ConnectionHandler$executeFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-ConnectionHandler-clone"><code>ConnectionHandler$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ConnectionHandler-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$new(
  connectionDetails,
  loadConnection = TRUE,
  snakeCaseToCamelCase = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connectionDetails</code></dt><dd><p>DatabaseConnector::connectionDetails class</p>
</dd>
<dt><code>loadConnection</code></dt><dd><p>Boolean option to load connection right away</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)
get dbms</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-dbms"></a>



<h4>Method <code>dbms()</code></h4>

<p>Get the dbms type of the connection
get table
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$dbms()</pre></div>


<hr>
<a id="method-ConnectionHandler-tbl"></a>



<h4>Method <code>tbl()</code></h4>

<p>get a dplyr table object (i.e. lazy loaded)
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$tbl(table, databaseSchema = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>table</code></dt><dd><p>table name</p>
</dd>
<dt><code>databaseSchema</code></dt><dd><p>databaseSchema to which table belongs
Render Translate Sql.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-renderTranslateSql"></a>



<h4>Method <code>renderTranslateSql()</code></h4>

<p>Masked call to SqlRender
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$renderTranslateSql(sql, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>Sql query string</p>
</dd>
<dt><code>...</code></dt><dd><p>Elipsis
initConnection</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-initConnection"></a>



<h4>Method <code>initConnection()</code></h4>

<p>Load connection
Get Connection
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$initConnection()</pre></div>


<hr>
<a id="method-ConnectionHandler-getConnection"></a>



<h4>Method <code>getConnection()</code></h4>

<p>Returns connection for use with standard DatabaseConnector calls.
Connects automatically if it isn't yet loaded
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$getConnection()</pre></div>


<hr>
<a id="method-ConnectionHandler-closeConnection"></a>



<h4>Method <code>closeConnection()</code></h4>

<p>Closes connection (if active)
close Connection
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$closeConnection()</pre></div>


<hr>
<a id="method-ConnectionHandler-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Closes connection (if active)
db Is Valid
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$finalize()</pre></div>


<hr>
<a id="method-ConnectionHandler-dbIsValid"></a>



<h4>Method <code>dbIsValid()</code></h4>

<p>Masks call to DBI::dbIsValid. Returns False if connection is NULL
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$dbIsValid()</pre></div>


<hr>
<a id="method-ConnectionHandler-queryDb"></a>



<h4>Method <code>queryDb()</code></h4>

<p>query database and return the resulting data.frame
</p>
<p>If environment variable LIMIT_ROW_COUNT is set Returned rows are limited to this value (no default)
Limit row count is intended for web applications that may cause a denial of service if they consume too many
resources.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$queryDb(
  sql,
  snakeCaseToCamelCase = self$snakeCaseToCamelCase,
  overrideRowLimit = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)</p>
</dd>
<dt><code>overrideRowLimit</code></dt><dd><p>(Optional) Boolean. In some cases, where row limit is enforced on the system
You may wish to ignore it.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional query parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-executeSql"></a>



<h4>Method <code>executeSql()</code></h4>

<p>execute set of database queries
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$executeSql(sql, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional query parameters
query Function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-queryFunction"></a>



<h4>Method <code>queryFunction()</code></h4>

<p>queryFunction that can be overriden with subclasses (e.g. use different base function or intercept query)
Does not translate or render sql.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$queryFunction(
  sql,
  snakeCaseToCamelCase = self$snakeCaseToCamelCase,
  connection = self$getConnection()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)</p>
</dd>
<dt><code>connection</code></dt><dd><p>(Optional) connection object
execute Function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-executeFunction"></a>



<h4>Method <code>executeFunction()</code></h4>

<p>exec query Function that can be overriden with subclasses (e.g. use different base function or intercept query)
Does not translate or render sql.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$executeFunction(sql, connection = self$getConnection())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>connection</code></dt><dd><p>connection object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConnectionHandler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConnectionHandler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='createQueryNamespace'>Create query namespace</h2><span id='topic+createQueryNamespace'></span>

<h3>Description</h3>

<p>Create a QueryNamespace instance from either a connection handler or a connectionDetails object
Allows construction with various options not handled by QueryNamespace$new
</p>
<p>Note - currently not supported is having multiple table prefixes for multiple table namespaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createQueryNamespace(
  connectionDetails = NULL,
  connectionHandler = NULL,
  usePooledConnection = FALSE,
  tableSpecification = NULL,
  resultModelSpecificationPath = NULL,
  tablePrefix = "",
  snakeCaseToCamelCase = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createQueryNamespace_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package.</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_connectionhandler">connectionHandler</code></td>
<td>
<p>ResultModelManager ConnectionHandler or PooledConnectionHandler instance</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_usepooledconnection">usePooledConnection</code></td>
<td>
<p>Use Pooled database connection instead of standard DatabaseConnector single
connection.</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_tablespecification">tableSpecification</code></td>
<td>
<p>Table specfication data.frame</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_resultmodelspecificationpath">resultModelSpecificationPath</code></td>
<td>
<p>(optional) csv file or files for tableSpecifications - must conform to table spec
format.</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>String to prefix table names with - default is empty string</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_snakecasetocamelcase">snakeCaseToCamelCase</code></td>
<td>
<p>convert snakecase results to camelCase field names (TRUE by default)</p>
</td></tr>
<tr><td><code id="createQueryNamespace_+3A_...">...</code></td>
<td>
<p>Elipsis - use for any additional string keys to replace</p>
</td></tr>
</table>

<hr>
<h2 id='createResultExportManager'>Create Result Export Manager</h2><span id='topic+createResultExportManager'></span>

<h3>Description</h3>

<p>For a give table specification file, create an export manager instance for creating results data sets that conform
to the data model.
</p>
<p>This checks that, at export time, internal validity is assured for the data (e.g. primary keys are valid, data types
are compatible
</p>
<p>In addition this utility will create a manifest object that can be used to maintain the validity of data.
</p>
<p>If an instance of a DataMigrationManager is present and available a packageVersion reference (where applicable)
and migration set will be referenced. Allowing data to be imported into a database schema at a specific version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createResultExportManager(
  tableSpecification,
  exportDir,
  minCellCount = getOption("ohdsi.minCellCount", default = 5),
  databaseId = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createResultExportManager_+3A_tablespecification">tableSpecification</code></td>
<td>
<p>Table specification data.frame</p>
</td></tr>
<tr><td><code id="createResultExportManager_+3A_exportdir">exportDir</code></td>
<td>
<p>Directory files are being exported to</p>
</td></tr>
<tr><td><code id="createResultExportManager_+3A_mincellcount">minCellCount</code></td>
<td>
<p>Minimum cell count - reccomended that you set with
options(&quot;ohdsi.minCellCount&quot; = count) in all R projects. Default is 5</p>
</td></tr>
<tr><td><code id="createResultExportManager_+3A_databaseid">databaseId</code></td>
<td>
<p>database identifier - required when exporting according to many specs</p>
</td></tr>
</table>

<hr>
<h2 id='DataMigrationManager'>DataMigrationManager (DMM)</h2><span id='topic+DataMigrationManager'></span>

<h3>Description</h3>

<p>R6 class for management of database migration
</p>


<h3>Value</h3>

<p>data frame all migrations, including file name, order and execution status
Get connection handler
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>migrationPath</code></dt><dd><p>Path migrations exist in</p>
</dd>
<dt><code>databaseSchema</code></dt><dd><p>Path migrations exist in</p>
</dd>
<dt><code>packageName</code></dt><dd><p>packageName, can be null</p>
</dd>
<dt><code>tablePrefix</code></dt><dd><p>tablePrefix, can be empty character vector</p>
</dd>
<dt><code>packageTablePrefix</code></dt><dd><p>packageTablePrefix, can be empty character vector</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataMigrationManager-new"><code>DataMigrationManager$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-migrationTableExists"><code>DataMigrationManager$migrationTableExists()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-getMigrationsPath"><code>DataMigrationManager$getMigrationsPath()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-getStatus"><code>DataMigrationManager$getStatus()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-getConnectionHandler"><code>DataMigrationManager$getConnectionHandler()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-check"><code>DataMigrationManager$check()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-executeMigrations"><code>DataMigrationManager$executeMigrations()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-isPackage"><code>DataMigrationManager$isPackage()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-finalize"><code>DataMigrationManager$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMigrationManager-clone"><code>DataMigrationManager$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DataMigrationManager-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$new(
  connectionDetails,
  databaseSchema,
  tablePrefix = "",
  packageTablePrefix = "",
  migrationPath,
  packageName = NULL,
  migrationRegexp = .defaultMigrationRegexp
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connectionDetails</code></dt><dd><p>DatabaseConnector connection details object</p>
</dd>
<dt><code>databaseSchema</code></dt><dd><p>Database Schema to execute on</p>
</dd>
<dt><code>tablePrefix</code></dt><dd><p>Optional table prefix for all tables (e.g. plp, cm, cd etc)</p>
</dd>
<dt><code>packageTablePrefix</code></dt><dd><p>A table prefix when used in conjunction with other package results schema,
e.g. &quot;cd_&quot;, &quot;sccs_&quot;, &quot;plp_&quot;, &quot;cm_&quot;</p>
</dd>
<dt><code>migrationPath</code></dt><dd><p>Path to location of migration sql files. If in package mode, this should just
be a folder (e.g. &quot;migrations&quot;) that lives in the location &quot;sql/sql_server&quot; (and)
other database platforms.
If in folder model, the folder must include &quot;sql_server&quot; in the relative path,
(e.g if  migrationPath = 'migrations' then the folder 'migrations/sql_server' should exists)</p>
</dd>
<dt><code>packageName</code></dt><dd><p>If in package mode, the name of the R package</p>
</dd>
<dt><code>migrationRegexp</code></dt><dd><p>(Optional) regular expression pattern default is <code style="white-space: pre;">&#8288;(Migration_([0-9]+))-(.+).sql&#8288;</code>
Migration table exists</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataMigrationManager-migrationTableExists"></a>



<h4>Method <code>migrationTableExists()</code></h4>

<p>Check if migration table is present in schema
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$migrationTableExists()</pre></div>



<h5>Returns</h5>

<p>boolean
Get path of migrations
</p>


<hr>
<a id="method-DataMigrationManager-getMigrationsPath"></a>



<h4>Method <code>getMigrationsPath()</code></h4>

<p>Get path to sql migration files
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$getMigrationsPath(dbms = "sql server")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dbms</code></dt><dd><p>Optionally specify the dbms that the migration fits under
Get status of result model</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataMigrationManager-getStatus"></a>



<h4>Method <code>getStatus()</code></h4>

<p>Get status of all migrations (executed or not)
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$getStatus()</pre></div>


<hr>
<a id="method-DataMigrationManager-getConnectionHandler"></a>



<h4>Method <code>getConnectionHandler()</code></h4>

<p>Return connection handler instance
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$getConnectionHandler()</pre></div>



<h5>Returns</h5>

<p>ConnectionHandler instance
Check migrations in folder
</p>


<hr>
<a id="method-DataMigrationManager-check"></a>



<h4>Method <code>check()</code></h4>

<p>Check if file names are valid for migrations
Execute Migrations
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$check()</pre></div>


<hr>
<a id="method-DataMigrationManager-executeMigrations"></a>



<h4>Method <code>executeMigrations()</code></h4>

<p>Execute any unexecuted migrations
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$executeMigrations(stopMigrationVersion = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stopMigrationVersion</code></dt><dd><p>(Optional) Migrate to a specific migration number
isPackage</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DataMigrationManager-isPackage"></a>



<h4>Method <code>isPackage()</code></h4>

<p>is a package folder structure or not
finalize
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$isPackage()</pre></div>


<hr>
<a id="method-DataMigrationManager-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>close database connection
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$finalize()</pre></div>


<hr>
<a id="method-DataMigrationManager-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DataMigrationManager$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="#topic+ConnectionHandler">ConnectionHandler</a> for information on returned class
</p>

<hr>
<h2 id='deleteAllRowsForDatabaseId'>Delete all rows for database id</h2><span id='topic+deleteAllRowsForDatabaseId'></span>

<h3>Description</h3>

<p>Delete all rows for database id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteAllRowsForDatabaseId(
  connection,
  schema,
  tableName,
  databaseId,
  idIsInt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteAllRowsForDatabaseId_+3A_connection">connection</code></td>
<td>
<p>DatabaseConnector connection instance</p>
</td></tr>
<tr><td><code id="deleteAllRowsForDatabaseId_+3A_schema">schema</code></td>
<td>
<p>The schema on the postgres server where the results table exists</p>
</td></tr>
<tr><td><code id="deleteAllRowsForDatabaseId_+3A_tablename">tableName</code></td>
<td>
<p>Database table name</p>
</td></tr>
<tr><td><code id="deleteAllRowsForDatabaseId_+3A_databaseid">databaseId</code></td>
<td>
<p>Results source database identifier</p>
</td></tr>
<tr><td><code id="deleteAllRowsForDatabaseId_+3A_idisint">idIsInt</code></td>
<td>
<p>Identified is a numeric type? If not character is used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only PostgreSQL servers are supported.
</p>

<hr>
<h2 id='deleteAllRowsForPrimaryKey'>Delete results rows for primary key values from database server tables</h2><span id='topic+deleteAllRowsForPrimaryKey'></span>

<h3>Description</h3>

<p>Delete results rows for primary key values from database server tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteAllRowsForPrimaryKey(connection, schema, tableName, keyValues)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteAllRowsForPrimaryKey_+3A_connection">connection</code></td>
<td>
<p>DatabaseConnector connection instance</p>
</td></tr>
<tr><td><code id="deleteAllRowsForPrimaryKey_+3A_schema">schema</code></td>
<td>
<p>The schema on the postgres server where the results table exists</p>
</td></tr>
<tr><td><code id="deleteAllRowsForPrimaryKey_+3A_tablename">tableName</code></td>
<td>
<p>Database table name</p>
</td></tr>
<tr><td><code id="deleteAllRowsForPrimaryKey_+3A_keyvalues">keyValues</code></td>
<td>
<p>Key values of results rows to be deleted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only PostgreSQL servers are supported.
</p>

<hr>
<h2 id='generateSqlSchema'>Schema generator</h2><span id='topic+generateSqlSchema'></span>

<h3>Description</h3>

<p>Take a csv schema definition and create a basic sql script with it.
returns string containing the sql for the table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSqlSchema(
  csvFilepath = NULL,
  schemaDefinition = NULL,
  sqlOutputPath = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateSqlSchema_+3A_csvfilepath">csvFilepath</code></td>
<td>
<p>Path to schema file. Csv file must have the columns:
&quot;table_name&quot;, &quot;column_name&quot;, &quot;data_type&quot;, &quot;primary_key&quot;</p>
</td></tr>
<tr><td><code id="generateSqlSchema_+3A_schemadefinition">schemaDefinition</code></td>
<td>
<p>A schemaDefintiion data.frame' with the columns:
tableName, columnName, dataType, isRequired, primaryKey</p>
</td></tr>
<tr><td><code id="generateSqlSchema_+3A_sqloutputpath">sqlOutputPath</code></td>
<td>
<p>File to write sql to.</p>
</td></tr>
<tr><td><code id="generateSqlSchema_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean - overwrite existing file?</p>
</td></tr>
</table>

<hr>
<h2 id='grantTablePermissions'>Grant Table Permissions</h2><span id='topic+grantTablePermissions'></span>

<h3>Description</h3>

<p>Grant a given permission for all tables on a given tableSpecification
</p>
<p>Very useful if you're hosting studies on data.ohdsi.org or other postgresql instances
</p>
<p>NOTE: only tested on postgresql, users' of other platforms may have Sql translation issues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grantTablePermissions(
  connectionDetails = NULL,
  connection = NULL,
  tableSpecification,
  databaseSchema,
  tablePrefix = "",
  permissions = "SELECT",
  user
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grantTablePermissions_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package.</p>
</td></tr>
<tr><td><code id="grantTablePermissions_+3A_connection">connection</code></td>
<td>
<p>DatabaseConnector connection instance</p>
</td></tr>
<tr><td><code id="grantTablePermissions_+3A_tablespecification">tableSpecification</code></td>
<td>
<p>data.frame conforming to table spec (must contain tableName field)</p>
</td></tr>
<tr><td><code id="grantTablePermissions_+3A_databaseschema">databaseSchema</code></td>
<td>
<p>database schema to run this on</p>
</td></tr>
<tr><td><code id="grantTablePermissions_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>String to prefix table names with - default is empty string</p>
</td></tr>
<tr><td><code id="grantTablePermissions_+3A_permissions">permissions</code></td>
<td>
<p>permissions to generate must be one of SELECT, INSERT, DELETE or UPDATE</p>
</td></tr>
<tr><td><code id="grantTablePermissions_+3A_user">user</code></td>
<td>
<p>database user to grant permissions to</p>
</td></tr>
</table>

<hr>
<h2 id='loadResultsDataModelSpecifications'>Get specifications from a given file path</h2><span id='topic+loadResultsDataModelSpecifications'></span>

<h3>Description</h3>

<p>Get specifications from a given file path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadResultsDataModelSpecifications(filePath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadResultsDataModelSpecifications_+3A_filepath">filePath</code></td>
<td>
<p>path to a valid csv file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble data frame object with specifications
</p>

<hr>
<h2 id='PooledConnectionHandler'>Pooled Connection Handler</h2><span id='topic+PooledConnectionHandler'></span>

<h3>Description</h3>

<p>Transparently works the same way as a standard connection handler but stores pooled connections.
Useful for long running applications that serve multiple concurrent requests.
Note that a side effect of using this is that each call to this increments the .GlobalEnv attribute <code>RMMPooledHandlerCount</code>
</p>


<h3>Value</h3>

<p>boolean TRUE if connection is valid
executeSql
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConnectionHandler">ResultModelManager::ConnectionHandler</a></code> -&gt; <code>PooledConnectionHandler</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PooledConnectionHandler-new"><code>PooledConnectionHandler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-initConnection"><code>PooledConnectionHandler$initConnection()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-getCheckedOutConnectionPath"><code>PooledConnectionHandler$getCheckedOutConnectionPath()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-getConnection"><code>PooledConnectionHandler$getConnection()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-dbms"><code>PooledConnectionHandler$dbms()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-closeConnection"><code>PooledConnectionHandler$closeConnection()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-queryDb"><code>PooledConnectionHandler$queryDb()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-executeSql"><code>PooledConnectionHandler$executeSql()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-queryFunction"><code>PooledConnectionHandler$queryFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-executeFunction"><code>PooledConnectionHandler$executeFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-PooledConnectionHandler-clone"><code>PooledConnectionHandler$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="ResultModelManager" data-topic="ConnectionHandler" data-id="dbIsValid"><a href='../../ResultModelManager/html/ConnectionHandler.html#method-ConnectionHandler-dbIsValid'><code>ResultModelManager::ConnectionHandler$dbIsValid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ResultModelManager" data-topic="ConnectionHandler" data-id="finalize"><a href='../../ResultModelManager/html/ConnectionHandler.html#method-ConnectionHandler-finalize'><code>ResultModelManager::ConnectionHandler$finalize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ResultModelManager" data-topic="ConnectionHandler" data-id="renderTranslateSql"><a href='../../ResultModelManager/html/ConnectionHandler.html#method-ConnectionHandler-renderTranslateSql'><code>ResultModelManager::ConnectionHandler$renderTranslateSql()</code></a></span></li>
<li><span class="pkg-link" data-pkg="ResultModelManager" data-topic="ConnectionHandler" data-id="tbl"><a href='../../ResultModelManager/html/ConnectionHandler.html#method-ConnectionHandler-tbl'><code>ResultModelManager::ConnectionHandler$tbl()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PooledConnectionHandler-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$new(
  connectionDetails = NULL,
  snakeCaseToCamelCase = TRUE,
  loadConnection = TRUE,
  dbConnectArgs = NULL,
  forceJdbcConnection = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connectionDetails</code></dt><dd><p>DatabaseConnector::connectionDetails class</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)</p>
</dd>
<dt><code>loadConnection</code></dt><dd><p>Boolean option to load connection right away</p>
</dd>
<dt><code>dbConnectArgs</code></dt><dd><p>Optional arguments to call pool::dbPool overrides default usage of connectionDetails</p>
</dd>
<dt><code>forceJdbcConnection</code></dt><dd><p>Force JDBC connection (requires using DatabaseConnector ConnectionDetails)
initialize pooled db connection</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-initConnection"></a>



<h4>Method <code>initConnection()</code></h4>

<p>Overrides ConnectionHandler Call
Used for getting a checked out connection from a given environment (if one exists)
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$initConnection()</pre></div>


<hr>
<a id="method-PooledConnectionHandler-getCheckedOutConnectionPath"></a>



<h4>Method <code>getCheckedOutConnectionPath()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$getCheckedOutConnectionPath()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>.deferedFrame</code></dt><dd><p>defaults to the parent frame of the calling block.
Get Connection</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-getConnection"></a>



<h4>Method <code>getConnection()</code></h4>

<p>Returns a connection from the pool
When the desired frame exits, the connection will be returned to the pool
As a side effect, the connection is stored as an attribute within the calling frame (e.g. the same function) to prevent multiple
connections being spawned, which limits performance.
</p>
<p>If you call this somewhere you need to think about returning the object or you may create a connection that
is never returned to the pool.
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$getConnection(.deferedFrame = parent.frame(n = 2))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>.deferedFrame</code></dt><dd><p>defaults to the parent frame of the calling block.
get dbms</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-dbms"></a>



<h4>Method <code>dbms()</code></h4>

<p>Get the dbms type of the connection
Close Connection
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$dbms()</pre></div>


<hr>
<a id="method-PooledConnectionHandler-closeConnection"></a>



<h4>Method <code>closeConnection()</code></h4>

<p>Overrides ConnectionHandler Call - closes all active connections called with getConnection
queryDb
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$closeConnection()</pre></div>


<hr>
<a id="method-PooledConnectionHandler-queryDb"></a>



<h4>Method <code>queryDb()</code></h4>

<p>query database and return the resulting data.frame
</p>
<p>If environment variable LIMIT_ROW_COUNT is set Returned rows are limited to this value (no default)
Limit row count is intended for web applications that may cause a denial of service if they consume too many
resources.
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$queryDb(
  sql,
  snakeCaseToCamelCase = self$snakeCaseToCamelCase,
  overrideRowLimit = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)</p>
</dd>
<dt><code>overrideRowLimit</code></dt><dd><p>(Optional) Boolean. In some cases, where row limit is enforced on the system
You may wish to ignore it.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional query parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-executeSql"></a>



<h4>Method <code>executeSql()</code></h4>

<p>execute set of database queries
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$executeSql(sql, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional query parameters
query Function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-queryFunction"></a>



<h4>Method <code>queryFunction()</code></h4>

<p>Overrides ConnectionHandler Call. Does not translate or render sql.
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$queryFunction(
  sql,
  snakeCaseToCamelCase = self$snakeCaseToCamelCase,
  connection
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>snakeCaseToCamelCase</code></dt><dd><p>(Optional) Boolean. return the results columns in camel case (default)
query Function</p>
</dd>
<dt><code>connection</code></dt><dd><p>db connection assumes pooling is handled outside of call</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-executeFunction"></a>



<h4>Method <code>executeFunction()</code></h4>

<p>Overrides ConnectionHandler Call. Does not translate or render sql.
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$executeFunction(sql, connection)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>sql query string</p>
</dd>
<dt><code>connection</code></dt><dd><p>DatabaseConnector connection. Assumes pooling is handled outside of call</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PooledConnectionHandler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PooledConnectionHandler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='QueryNamespace'>QueryNamespace</h2><span id='topic+QueryNamespace'></span>

<h3>Description</h3>

<p>Given a results specification and ConnectionHandler instance - this class allow queries to be namespaced within
any tables specified within a list of pre-determined tables. This allows the encapsulation of queries, using specific
table names in a consistent manner that is striaghtforward to maintain over time.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>tablePrefix</code></dt><dd><p>tablePrefix to use</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QueryNamespace-new"><code>QueryNamespace$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-setConnectionHandler"><code>QueryNamespace$setConnectionHandler()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-getConnectionHandler"><code>QueryNamespace$getConnectionHandler()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-addReplacementVariable"><code>QueryNamespace$addReplacementVariable()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-addTableSpecification"><code>QueryNamespace$addTableSpecification()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-render"><code>QueryNamespace$render()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-queryDb"><code>QueryNamespace$queryDb()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-executeSql"><code>QueryNamespace$executeSql()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-getVars"><code>QueryNamespace$getVars()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-finalize"><code>QueryNamespace$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-QueryNamespace-clone"><code>QueryNamespace$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QueryNamespace-new"></a>



<h4>Method <code>new()</code></h4>

<p>initialize class
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$new(
  connectionHandler = NULL,
  tableSpecification = NULL,
  tablePrefix = "",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connectionHandler</code></dt><dd><p>ConnectionHandler instance @seealso<a href="#topic+ConnectionHandler">ConnectionHandler</a></p>
</dd>
<dt><code>tableSpecification</code></dt><dd><p>tableSpecification data.frame</p>
</dd>
<dt><code>tablePrefix</code></dt><dd><p>constant string to prefix all tables with</p>
</dd>
<dt><code>...</code></dt><dd><p>additional replacement variables e.g. database_schema, vocabulary_schema etc
Set Connection Handler</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-setConnectionHandler"></a>



<h4>Method <code>setConnectionHandler()</code></h4>

<p>set connection handler object for object
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$setConnectionHandler(connectionHandler)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connectionHandler</code></dt><dd><p>ConnectionHandler instance
Get connection handler</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-getConnectionHandler"></a>



<h4>Method <code>getConnectionHandler()</code></h4>

<p>get connection handler obeject or throw error if not set
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$getConnectionHandler()</pre></div>


<hr>
<a id="method-QueryNamespace-addReplacementVariable"></a>



<h4>Method <code>addReplacementVariable()</code></h4>

<p>add a variable to automatically be replaced in query strings (e.g. @database_schema.@table_name becomes 'database_schema.table_1')
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$addReplacementVariable(key, value, replace = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>variable name string (without @) to be replaced, eg. &quot;table_name&quot;</p>
</dd>
<dt><code>value</code></dt><dd><p>atomic value for replacement</p>
</dd>
<dt><code>replace</code></dt><dd><p>if a variable of the same key is found, overwrite it
add table specification</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-addTableSpecification"></a>



<h4>Method <code>addTableSpecification()</code></h4>

<p>add a variable to automatically be replaced in query strings (e.g. @database_schema.@table_name becomes
'database_schema.table_1')
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$addTableSpecification(
  tableSpecification,
  useTablePrefix = TRUE,
  tablePrefix = self$tablePrefix,
  replace = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tableSpecification</code></dt><dd><p>table specification data.frame conforming to column names tableName, columnName, dataType and primaryKey</p>
</dd>
<dt><code>useTablePrefix</code></dt><dd><p>prefix the results with the tablePrefix (TRUE)</p>
</dd>
<dt><code>tablePrefix</code></dt><dd><p>prefix string - defaults to class variable set during initialization</p>
</dd>
<dt><code>replace</code></dt><dd><p>replace existing variables of the same name
Render</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-render"></a>



<h4>Method <code>render()</code></h4>

<p>Call to SqlRender::render replacing names stored in this class
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$render(sql, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>query string</p>
</dd>
<dt><code>...</code></dt><dd><p>additional variables to be passed to SqlRender::render - will overwrite anything in namespace
query Sql</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-queryDb"></a>



<h4>Method <code>queryDb()</code></h4>

<p>Call to
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$queryDb(sql, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>query string</p>
</dd>
<dt><code>...</code></dt><dd><p>additional variables to send to SqlRender::render
execute Sql</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-executeSql"></a>



<h4>Method <code>executeSql()</code></h4>

<p>Call to execute sql within namespaced queries
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$executeSql(sql, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sql</code></dt><dd><p>query string</p>
</dd>
<dt><code>...</code></dt><dd><p>additional variables to send to SqlRender::render
get vars</p>
</dd>
</dl>

</div>


<hr>
<a id="method-QueryNamespace-getVars"></a>



<h4>Method <code>getVars()</code></h4>

<p>returns full list of variables that will be replaced
Destruct object
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$getVars()</pre></div>


<hr>
<a id="method-QueryNamespace-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Close connections etc
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$finalize()</pre></div>


<hr>
<a id="method-QueryNamespace-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueryNamespace$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
library(ResultModelManager)

# Create some junk test data
connectionDetails &lt;-
  DatabaseConnector::createConnectionDetails(
    server = "test_db.sqlite",
    dbms = "sqlite"
  )

conn &lt;- DatabaseConnector::connect(connectionDetails)
DatabaseConnector::insertTable(
  connection = conn,
  tableName = "cd_cohort",
  data = data.frame(
    cohort_id = c(1, 2, 3),
    cohort_name = c("cohort one", "cohort two", "cohort three"),
    json = "{}",
    sql = "SELECT 1"
  )
)
DatabaseConnector::disconnect(conn)

connectionHandler &lt;- ConnectionHandler$new(connectionDetails = connectionDetails)
tableSpecification &lt;- data.frame(
  tableName = "cohort",
  columnName = c(
    "cohort_id",
    "cohort_name",
    "json",
    "sql"
  ),
  primaryKey = c(TRUE, FALSE, FALSE, FALSE),
  dataType = c("int", "varchar", "varchar", "varchar")
)

cohortNamespace &lt;- QueryNamespace$new(
  connectionHandler = connectionHandler,
  tableSpecification = tableSpecification,
  result_schema = "main",
  tablePrefix = "cd_"
)
sql &lt;- "SELECT * FROM @result_schema.@cohort WHERE cohort_id = @cohort_id"
# Returns : "SELECT * FROM main.cd_cohort WHERE cohort_id = @cohort_id"
print(cohortNamespace$render(sql))
# Returns query result
result &lt;- cohortNamespace$queryDb(sql, cohort_id = 1)
# cleanup test data
unlink("test_db.sqlite")
</code></pre>

<hr>
<h2 id='ResultExportManager'>Result Set Export Manager</h2><span id='topic+ResultExportManager'></span>

<h3>Description</h3>

<p>EXPERIMENTAL - this feature is still in design stage and it is not reccomended that you implement this for your
package at this stage.
Utility for simplifying export of results to files from sql queries
</p>
<p>Note that this utility is not strictly thread safe though seperate processes can export separate tables
without issue. When exporting a the same table across multiple threads primary key checks may create
issues.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>exportDir</code></dt><dd><p>direcotry path to export files to
Init</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResultExportManager-new"><code>ResultExportManager$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-getTableSpec"><code>ResultExportManager$getTableSpec()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-getMinColValues"><code>ResultExportManager$getMinColValues()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-checkRowTypes"><code>ResultExportManager$checkRowTypes()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-listTables"><code>ResultExportManager$listTables()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-checkPrimaryKeys"><code>ResultExportManager$checkPrimaryKeys()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-exportDataFrame"><code>ResultExportManager$exportDataFrame()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-exportQuery"><code>ResultExportManager$exportQuery()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-getManifestList"><code>ResultExportManager$getManifestList()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-writeManifest"><code>ResultExportManager$writeManifest()</code></a>
</p>
</li>
<li> <p><a href="#method-ResultExportManager-clone"><code>ResultExportManager$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ResultExportManager-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a class for exporting results from a study in a standard, consistend manner
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$new(
  tableSpecification,
  exportDir,
  minCellCount = getOption("ohdsi.minCellCount", default = 5),
  databaseId = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tableSpecification</code></dt><dd><p>Table specification data.frame</p>
</dd>
<dt><code>exportDir</code></dt><dd><p>Directory files are being exported to</p>
</dd>
<dt><code>minCellCount</code></dt><dd><p>Minimum cell count - reccomended that you set with
options(&quot;ohdsi.minCellCount&quot; = count) in all R projects. Default is 5</p>
</dd>
<dt><code>databaseId</code></dt><dd><p>database identifier - required when exporting according to many specs
get table spec</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-getTableSpec"></a>



<h4>Method <code>getTableSpec()</code></h4>

<p>Get specification of table
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$getTableSpec(exportTableName)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>exportTableName</code></dt><dd><p>table name
Get min col values</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-getMinColValues"></a>



<h4>Method <code>getMinColValues()</code></h4>

<p>Columns to convert to minimum for a given table name
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$getMinColValues(rows, exportTableName)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p>data.frame of rows</p>
</dd>
<dt><code>exportTableName</code></dt><dd><p>stering table name - must be defined in spec
Check row types</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-checkRowTypes"></a>



<h4>Method <code>checkRowTypes()</code></h4>

<p>Check types of rows before exporting
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$checkRowTypes(rows, exportTableName)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p>data.frame of rows to export</p>
</dd>
<dt><code>exportTableName</code></dt><dd><p>table name
List tables</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-listTables"></a>



<h4>Method <code>listTables()</code></h4>

<p>list all tables in schema
Check primary keys of exported data
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$listTables()</pre></div>


<hr>
<a id="method-ResultExportManager-checkPrimaryKeys"></a>



<h4>Method <code>checkPrimaryKeys()</code></h4>

<p>Checks to see if the rows conform to the valid primary keys
If the same table has already been checked in the life of this object set
&quot;invalidateCache&quot; to TRUE as the keys will be cached in a temporary file
on disk.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$checkPrimaryKeys(
  rows,
  exportTableName,
  invalidateCache = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p>data.frame to export</p>
</dd>
<dt><code>exportTableName</code></dt><dd><p>Table name (must be in spec)</p>
</dd>
<dt><code>invalidateCache</code></dt><dd><p>logical - if starting a fresh export use this to delete cache of primary keys
Export data frame</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-exportDataFrame"></a>



<h4>Method <code>exportDataFrame()</code></h4>

<p>This method is intended for use where exporting a data.frame and not a query from a rdbms table
For example, if you perform a transformation in R this method will check primary keys, min cell counts and
data types before writing the file to according to the table spec
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$exportDataFrame(rows, exportTableName, append = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p>Rows to export</p>
</dd>
<dt><code>exportTableName</code></dt><dd><p>Table name</p>
</dd>
<dt><code>append</code></dt><dd><p>logical - if true will append the result to a file, otherwise the file will be overwritten
Export Data table with sql query</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-exportQuery"></a>



<h4>Method <code>exportQuery()</code></h4>

<p>Writes files in batch to stop overflowing system memory
Checks primary keys on write
Checks minimum cell count
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$exportQuery(
  connection,
  sql,
  exportTableName,
  transformFunction = NULL,
  transformFunctionArgs = list(),
  append = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connection</code></dt><dd><p>DatabaseConnector connection instance</p>
</dd>
<dt><code>sql</code></dt><dd><p>OHDSI sql string to export tables</p>
</dd>
<dt><code>exportTableName</code></dt><dd><p>Name of table to export (in snake_case format)</p>
</dd>
<dt><code>transformFunction</code></dt><dd><p>(optional) transformation of the data set callback.
must take two paramters - rows and pos
</p>
<div class="sourceCode"><pre>   Following this transformation callback, results will be verified against data model,
   Primary keys will be checked and minCellValue rules will be enforced
</pre></div></dd>
<dt><code>transformFunctionArgs</code></dt><dd><p>arguments to be passed to the transformation function</p>
</dd>
<dt><code>append</code></dt><dd><p>Logical add results to existing file, if FALSE (default) creates a new file and removes primary
key validation cache</p>
</dd>
<dt><code>...</code></dt><dd><p>extra parameters passed to sql
get manifest list</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-getManifestList"></a>



<h4>Method <code>getManifestList()</code></h4>

<p>Create a meta data set for each collection of result files with sha256 has for all files
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$getManifestList(
  packageName = NULL,
  packageVersion = NULL,
  migrationsPath = NULL,
  migrationRegexp = .defaultMigrationRegexp
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>packageName</code></dt><dd><p>if an R analysis package, specify the name</p>
</dd>
<dt><code>packageVersion</code></dt><dd><p>if an analysis package, specify the version</p>
</dd>
<dt><code>migrationsPath</code></dt><dd><p>path to sql migrations (use top level folder (e.g. sql/sql_server/migrations)</p>
</dd>
<dt><code>migrationRegexp</code></dt><dd><p>(optional) regular expression to search for sql files. It is not reccomended to change the default.
Write manifest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-writeManifest"></a>



<h4>Method <code>writeManifest()</code></h4>

<p>Write manifest json
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$writeManifest(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>@seealso getManifestList</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResultExportManager-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResultExportManager$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='unzipResults'>Unzips a results.zip file and enforces standards required by
<code>uploadResults</code></h2><span id='topic+unzipResults'></span>

<h3>Description</h3>

<p>This function will unzip the zipFile to the resultsFolder and assert
that the file resultsDataModelSpecification.csv exists in the resultsFolder
to ensure that it will work with <code>uploadResults</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unzipResults(zipFile, resultsFolder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unzipResults_+3A_zipfile">zipFile</code></td>
<td>
<p>The location of the .zip file that holds the results to upload</p>
</td></tr>
<tr><td><code id="unzipResults_+3A_resultsfolder">resultsFolder</code></td>
<td>
<p>The folder to use when unzipping the .zip file. If this folder
does not exist, this function will attempt to create the folder.</p>
</td></tr>
</table>

<hr>
<h2 id='uploadResults'>Upload results to the database server.</h2><span id='topic+uploadResults'></span>

<h3>Description</h3>

<p>Requires the results data model tables have been created using following the specifications, generateSqlSchema function.
</p>
<p>Results files should be in the snake_case format for table headers and not camelCase
</p>
<p>Set the POSTGRES_PATH environmental variable to the path to the folder containing the psql executable to enable
bulk upload (recommended).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uploadResults(
  connection = NULL,
  connectionDetails = NULL,
  schema,
  resultsFolder,
  tablePrefix = "",
  forceOverWriteOfSpecifications = FALSE,
  purgeSiteDataBeforeUploading = TRUE,
  databaseIdentifierFile = "cdm_source_info.csv",
  runCheckAndFixCommands = FALSE,
  warnOnMissingTable = TRUE,
  purgeDataModel = FALSE,
  specifications
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uploadResults_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_schema">schema</code></td>
<td>
<p>The schema on the postgres server where the tables have been created.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_resultsfolder">resultsFolder</code></td>
<td>
<p>The path to the folder containing the results to upload.
See <code>unzipResults</code> for more information.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>String to prefix table names with - default is empty string</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_forceoverwriteofspecifications">forceOverWriteOfSpecifications</code></td>
<td>
<p>If TRUE, specifications of the phenotypes, cohort definitions, and analysis
will be overwritten if they already exist on the database. Only use this if these specifications
have changed since the last upload.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_purgesitedatabeforeuploading">purgeSiteDataBeforeUploading</code></td>
<td>
<p>If TRUE, before inserting data for a specific databaseId all the data for
that site will be dropped. This assumes the results folder contains the full data for that
data site.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_databaseidentifierfile">databaseIdentifierFile</code></td>
<td>
<p>File contained that references databaseId field (used when purgeSiteDataBeforeUploading == TRUE). You may
specify a relative path for the cdmSourceFile and the function will assume it resides in the resultsFolder.
Alternatively, you can provide a path outside of the resultsFolder for this file.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_runcheckandfixcommands">runCheckAndFixCommands</code></td>
<td>
<p>If TRUE, the upload code will attempt to fix column names, data types and
duplicate rows. This parameter is kept for legacy reasons - it is strongly recommended
that you correct errors in your results where those results are assembled instead of
relying on this option to try and fix it during upload.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_warnonmissingtable">warnOnMissingTable</code></td>
<td>
<p>Boolean, print a warning if a table file is missing.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_purgedatamodel">purgeDataModel</code></td>
<td>
<p>This function will purge all data from the tables in the specification prior to upload.
Use with care. If interactive this will require further input.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_specifications">specifications</code></td>
<td>
<p>A tibble data frame object with specifications.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
