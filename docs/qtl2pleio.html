<!DOCTYPE html><html><head><title>Help for package qtl2pleio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtl2pleio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_pmap'><p>Add physical map contents to tibble</p></a></li>
<li><a href='#boot_pvl'><p>Perform bootstrap sampling and calculate test statistic for each bootstrap sample</p></a></li>
<li><a href='#calc_Bhat'><p>Calculate estimated allele effects, B matrix</p></a></li>
<li><a href='#calc_covs'><p>Calculate Vg and Ve from d-variate phenotype and kinship</p></a></li>
<li><a href='#calc_invsqrt_mat'><p>Calculate matrix inverse square root for a covariance matrix</p></a></li>
<li><a href='#calc_lrt_tib'><p>Calculate a likelihood ratio test statistic from the output of scan_pvl()</p></a></li>
<li><a href='#calc_profile_lods'><p>Calculate profile lods for all traits</p></a></li>
<li><a href='#calc_Sigma'><p>Calculate the phenotypes covariance matrix Sigma</p></a></li>
<li><a href='#calc_sqrt_mat'><p>Calculate matrix square root for a covariance matrix</p></a></li>
<li><a href='#check_identical'><p>Check whether a vector, x, has all its entries equal to its first entry</p></a></li>
<li><a href='#check_missingness'><p>Check for missingness in phenotypes or covariates</p></a></li>
<li><a href='#convert_to_scan1_output'><p>Convert 'scan_multi_oneqtl' output of 'qtl2::scan1' output</p></a></li>
<li><a href='#find_pleio_peak_tib'><p>Find the marker index corresponding to the peak of the pleiotropy trace in a tibble where the last column contains log likelihood values and the first d columns contain marker ids</p></a></li>
<li><a href='#fit1_pvl'><p>Fit a model for a specified d-tuple of markers</p></a></li>
<li><a href='#get_effects'><p>Extract founder allele effects at a single marker from output of qtl2::scan1coef</p></a></li>
<li><a href='#make_id2keep'><p>Identify shared subject ids among all inputs: covariates, allele probabilities array, kinship, and phenotypes</p></a></li>
<li><a href='#plot_pvl'><p>Plot tidied results of a pvl scan</p></a></li>
<li><a href='#prep_mytab'><p>Prepare mytab object for use within scan_pvl R code</p></a></li>
<li><a href='#prep_X_list'><p>Create a list of component X matrices for input to stagger_mats, to ultimately create design matrix</p></a></li>
<li><a href='#process_inputs'><p>Process inputs to scan functions</p></a></li>
<li><a href='#qtl2pleio'><p>qtl2pleio.</p></a></li>
<li><a href='#rcpp_calc_Bhat'><p>Estimate allele effects matrix, B hat, with Rcpp functions</p></a></li>
<li><a href='#rcpp_calc_Bhat2'><p>Estimate allele effects matrix, B hat, with Rcpp functions</p></a></li>
<li><a href='#rcpp_log_dmvnorm2'><p>Calculate log likelihood for a multivariate normal</p></a></li>
<li><a href='#scan_multi_onechr'><p>Perform multivariate, one-QTL model fitting for markers on one chromosome</p></a></li>
<li><a href='#scan_multi_oneqtl'><p>Perform multivariate, one-QTL model fitting for markers on all chromosomes</p></a></li>
<li><a href='#scan_multi_oneqtl_perm'><p>Permute the phenotypes matrix and then scan the genome. Record the genomewide greatest LOD score for each permuted data set.</p></a></li>
<li><a href='#scan_pvl'><p>Perform model fitting for all ordered pairs of markers in a genomic region of interest</p></a></li>
<li><a href='#sim1'><p>Simulate a single multivariate data set consisting of n subjects and d phenotypes for each</p></a></li>
<li><a href='#subset_input'><p>Subset an input object - allele probabilities array or phenotypes matrix or covariates matrix. Kinship has its own subset function</p></a></li>
<li><a href='#subset_kinship'><p>Subset a kinship matrix to include only those subjects present in all inputs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Testing Pleiotropy in Multiparental Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>We implement an
    adaptation of Jiang &amp; Zeng's (1995) <a href="https://www.genetics.org/content/140/3/1111">https://www.genetics.org/content/140/3/1111</a> likelihood ratio test for testing
    the null hypothesis of pleiotropy against the alternative hypothesis,
    two separate quantitative trait loci. The test differs from that in Jiang &amp; Zeng (1995) <a href="https://www.genetics.org/content/140/3/1111">https://www.genetics.org/content/140/3/1111</a> 
    and that in Tian et al. (2016) &lt;<a href="https://doi.org/10.1534%2Fgenetics.115.183624">doi:10.1534/genetics.115.183624</a>&gt; in
    that our test accommodates multiparental populations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fboehm/qtl2pleio">https://github.com/fboehm/qtl2pleio</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fboehm/qtl2pleio/issues">https://github.com/fboehm/qtl2pleio/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, gemma2, ggplot2, magrittr, MASS, Rcpp, rlang, tibble,
parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, mvtnorm, knitr, rmarkdown, testthat, broman, devtools,
qtl2, parallelly</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-01 21:53:16 UTC; fred</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederick J Boehm <a href="https://orcid.org/0000-0002-1644-5931"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederick J Boehm &lt;frederick.boehm@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-02 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_pmap'>Add physical map contents to tibble</h2><span id='topic+add_pmap'></span>

<h3>Description</h3>

<p>Add physical map contents to tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pmap(tib, pmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pmap_+3A_tib">tib</code></td>
<td>
<p>a tibble with 3 columns: marker, trace, and profile lod values, typically outputted by calc_profile_lods()</p>
</td></tr>
<tr><td><code id="add_pmap_+3A_pmap">pmap</code></td>
<td>
<p>a physical map for a single chromosome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with 4 columns: marker, trait, profile_lod, marker_position
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm &lt;- 1:3
names(pm) &lt;- as.character(paste0('m', 1:3))
expand.grid(paste0('m', 1:3), paste0('m', 1:3)) %&gt;%
    tibble::as_tibble() %&gt;%
    dplyr::mutate(log10lik = rgamma(9, 5)) %&gt;%
    calc_profile_lods() %&gt;%
    add_pmap(pm)
</code></pre>

<hr>
<h2 id='boot_pvl'>Perform bootstrap sampling and calculate test statistic for each bootstrap sample</h2><span id='topic+boot_pvl'></span>

<h3>Description</h3>

<p>Create a bootstrap sample, perform multivariate QTL scan, and calculate log10 LRT statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_pvl(
  probs,
  pheno,
  addcovar = NULL,
  kinship = NULL,
  start_snp = 1,
  n_snp,
  pleio_peak_index,
  nboot = 1,
  max_iter = 10000,
  max_prec = 1/1e+08,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_pvl_+3A_probs">probs</code></td>
<td>
<p>founder allele probabilities three-dimensional array for one chromosome only (not a list)</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_pheno">pheno</code></td>
<td>
<p>n by d matrix of phenotypes</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_addcovar">addcovar</code></td>
<td>
<p>n by c matrix of additive numeric covariates</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix, not a list</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_start_snp">start_snp</code></td>
<td>
<p>positive integer indicating index within probs for start of scan</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_n_snp">n_snp</code></td>
<td>
<p>number of (consecutive) markers to use in scan</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_pleio_peak_index">pleio_peak_index</code></td>
<td>
<p>positive integer index indicating genotype matrix for bootstrap sampling. Typically acquired by using 'find_pleio_peak_tib'.</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples to acquire and scan</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations for EM algorithm</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_max_prec">max_prec</code></td>
<td>
<p>stepwise precision for EM algorithm. EM stops once incremental difference in log likelihood is less than max_prec</p>
</td></tr>
<tr><td><code id="boot_pvl_+3A_cores">cores</code></td>
<td>
<p>number of cores to use when calling mclapply to parallelize the bootstrap analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a parametric bootstrap method to calibrate test statistic values in the test of
pleiotropy vs. separate QTL. It begins by inferring parameter values at
the 'pleio_peak_index' index value in the object 'probs'. It then uses
these inferred parameter values in sampling from a multivariate normal
distribution. For each of the 'nboot' sampled phenotype vectors, a two-dimensional QTL
scan, starting at the marker indexed by 'start_snp' within the object
'probs' and extending for a total of 'n_snp' consecutive markers. The
two-dimensional scan is performed via the function 'scan_pvl_clean'. For each
two-dimensional scan, a log10 likelihood ratio test statistic is calculated. The
outputted object is a vector of 'nboot' log10 likelihood ratio test
statistics from 'nboot' distinct bootstrap samples.
</p>


<h3>Value</h3>

<p>numeric vector of (log) likelihood ratio test statistics from 'nboot_per_job' bootstrap samples
</p>


<h3>References</h3>

<p>Knott SA, Haley CS (2000) Multitrait
least squares for quantitative trait loci detection.
Genetics 156: 899–911.
</p>
<p>Walling GA, Visscher PM, Haley CS (1998) A comparison of
bootstrap methods to construct confidence intervals in QTL mapping.
Genet. Res. 71: 171–180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 50
pheno &lt;- matrix(rnorm(2 * n), ncol = 2)
rownames(pheno) &lt;- paste0("s", 1:n)
colnames(pheno) &lt;- paste0("tr", 1:2)
probs &lt;- array(dim = c(n, 2, 5))
probs[ , 1, ] &lt;- rbinom(n * 5, size = 1, prob = 0.2)
probs[ , 2, ] &lt;- 1 - probs[ , 1, ]
rownames(probs) &lt;- paste0("s", 1:n)
colnames(probs) &lt;- LETTERS[1:2]
dimnames(probs)[[3]] &lt;- paste0("m", 1:5)
boot_pvl(probs = probs, pheno = pheno,
        start_snp = 1, n_snp = 5, pleio_peak_index = 3, nboot = 1, cores = 1)


</code></pre>

<hr>
<h2 id='calc_Bhat'>Calculate estimated allele effects, B matrix</h2><span id='topic+calc_Bhat'></span>

<h3>Description</h3>

<p>Calculate estimated allele effects, B matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Bhat(X, Sigma_inv, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_Bhat_+3A_x">X</code></td>
<td>
<p>dn by df block-diagonal design matrix that incorporates genetic info for d markers. Note that we can use the same marker data twice.</p>
</td></tr>
<tr><td><code id="calc_Bhat_+3A_sigma_inv">Sigma_inv</code></td>
<td>
<p>dn by dn inverse covariance matrix, often composed as the inverse of <code class="reqn">K \otimes V_g + I_n \otimes V_e</code></p>
</td></tr>
<tr><td><code id="calc_Bhat_+3A_y">Y</code></td>
<td>
<p>dn by 1 matrix, ie, a column vector, of d phenotypes' measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a df by 1 matrix of GLS-estimated allele effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- as.matrix(rbinom(n = 100, size = 1, prob = 1 / 2))
X &lt;- gemma2::stagger_mats(X1, X1)
Sigma_inv &lt;- diag(200)
Y &lt;- runif(200)
calc_Bhat(X, Sigma_inv, Y)
</code></pre>

<hr>
<h2 id='calc_covs'>Calculate Vg and Ve from d-variate phenotype and kinship</h2><span id='topic+calc_covs'></span>

<h3>Description</h3>

<p>Calculate Vg and Ve from d-variate phenotype and kinship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_covs(
  pheno,
  kinship,
  X1pre = rep(1, nrow(kinship)),
  max_iter = 1e+06,
  max_prec = 1/1e+08,
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_covs_+3A_pheno">pheno</code></td>
<td>
<p>n by d matrix of phenotypes</p>
</td></tr>
<tr><td><code id="calc_covs_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix, n by n</p>
</td></tr>
<tr><td><code id="calc_covs_+3A_x1pre">X1pre</code></td>
<td>
<p>n by c design matrix. c = 1 to ignore genotypes</p>
</td></tr>
<tr><td><code id="calc_covs_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of EM iterations</p>
</td></tr>
<tr><td><code id="calc_covs_+3A_max_prec">max_prec</code></td>
<td>
<p>maximum precision for stepwise increments in EM algorithm</p>
</td></tr>
<tr><td><code id="calc_covs_+3A_covariates">covariates</code></td>
<td>
<p>a n by n.cov matrix of numeric covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 2 named components, Vg and Ve. Each is a d by d covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_covs(pheno = matrix(data = rnorm(100), nrow = 50, ncol = 2), kinship = diag(50))
</code></pre>

<hr>
<h2 id='calc_invsqrt_mat'>Calculate matrix inverse square root for a covariance matrix</h2><span id='topic+calc_invsqrt_mat'></span>

<h3>Description</h3>

<p>Calculate matrix inverse square root for a covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_invsqrt_mat(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_invsqrt_mat_+3A_a">A</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='calc_lrt_tib'>Calculate a likelihood ratio test statistic from the output of scan_pvl()</h2><span id='topic+calc_lrt_tib'></span>

<h3>Description</h3>

<p>Calculate a likelihood ratio test statistic from the output of scan_pvl()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_lrt_tib(scan_pvl_out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_lrt_tib_+3A_scan_pvl_out">scan_pvl_out</code></td>
<td>
<p>outputted tibble from scan_pvl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number, the (log) likelihood ratio test statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rep(paste0('Marker', 1:3), times = 3) -&gt; marker1
rep(paste0('Marker', 1:3), each = 3) -&gt; marker2
runif(9, -1, 0) -&gt; ll
tibble::tibble(marker1, marker2, ll) -&gt; scan_out
calc_lrt_tib(scan_out)
</code></pre>

<hr>
<h2 id='calc_profile_lods'>Calculate profile lods for all traits</h2><span id='topic+calc_profile_lods'></span>

<h3>Description</h3>

<p>Calculate profile lods for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_profile_lods(scan_pvl_out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_profile_lods_+3A_scan_pvl_out">scan_pvl_out</code></td>
<td>
<p>tibble outputted from scan_pvl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with 3 columns, indicating 'marker identity, trace (pleiotropy or profile1, profile2, etc.), and value of the profile lod (base 10) for that trace at that marker.
</p>

<hr>
<h2 id='calc_Sigma'>Calculate the phenotypes covariance matrix Sigma</h2><span id='topic+calc_Sigma'></span>

<h3>Description</h3>

<p>Calculate the phenotypes covariance matrix Sigma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Sigma(Vg, Ve, kinship = NULL, n_mouse = nrow(kinship))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_Sigma_+3A_vg">Vg</code></td>
<td>
<p>d by d genetic covariance matrix for the d phenotypes</p>
</td></tr>
<tr><td><code id="calc_Sigma_+3A_ve">Ve</code></td>
<td>
<p>d by d error covariance matrix for the d phenotypes</p>
</td></tr>
<tr><td><code id="calc_Sigma_+3A_kinship">kinship</code></td>
<td>
<p>optional n by n kinship matrix. if NULL, Vg is not used.</p>
</td></tr>
<tr><td><code id="calc_Sigma_+3A_n_mouse">n_mouse</code></td>
<td>
<p>number of subjects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dn by dn covariance matrix
</p>

<hr>
<h2 id='calc_sqrt_mat'>Calculate matrix square root for a covariance matrix</h2><span id='topic+calc_sqrt_mat'></span>

<h3>Description</h3>

<p>Calculate matrix square root for a covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sqrt_mat(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sqrt_mat_+3A_a">A</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='check_identical'>Check whether a vector, x, has all its entries equal to its first entry</h2><span id='topic+check_identical'></span>

<h3>Description</h3>

<p>Check whether a vector, x, has all its entries equal to its first entry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_identical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_identical_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical indicating whether all vector entries are the same
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
check_identical(x)
y &lt;- rep(1, 5)
check_identical(y)
</code></pre>

<hr>
<h2 id='check_missingness'>Check for missingness in phenotypes or covariates</h2><span id='topic+check_missingness'></span>

<h3>Description</h3>

<p>We use 'is.finite' from base R to identify those subjects that have one or
more missing values in 'input_matrix'. We then return a character vector of subjects
that have no missingness in 'input_matrix'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_missingness(input_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_missingness_+3A_input_matrix">input_matrix</code></td>
<td>
<p>phenotypes or covariates matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of subjects that have no missingness
</p>

<hr>
<h2 id='convert_to_scan1_output'>Convert 'scan_multi_oneqtl' output of 'qtl2::scan1' output</h2><span id='topic+convert_to_scan1_output'></span>

<h3>Description</h3>

<p>We convert output of 'scan_multi_oneqtl' into format outputted by 'qtl2::scan1'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_scan1_output(sm_output, trait_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_scan1_output_+3A_sm_output">sm_output</code></td>
<td>
<p>tibble output from scan_multi_oneqtl for one chromosome only</p>
</td></tr>
<tr><td><code id="convert_to_scan1_output_+3A_trait_name">trait_name</code></td>
<td>
<p>character vector (of length one) specifying the trait names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class 'scan1'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- qtl2::read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- qtl2::insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- qtl2::calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- qtl2::get_x_covar(iron)

aprobs &lt;- qtl2::genoprob_to_alleleprob(probs)
sm_out &lt;- scan_multi_oneqtl(probs = aprobs, pheno = pheno)
sm_to_s1 &lt;- convert_to_scan1_output(sm_out[[1]], trait_name = "tr1and2")

# 95% Bayes credible interval for QTL on chr 7, first phenotype
qtl2::bayes_int(sm_to_s1, map)

</code></pre>

<hr>
<h2 id='find_pleio_peak_tib'>Find the marker index corresponding to the peak of the pleiotropy trace in a tibble where the last column contains log likelihood values and the first d columns contain marker ids</h2><span id='topic+find_pleio_peak_tib'></span>

<h3>Description</h3>

<p>Find the marker index corresponding to the peak of the pleiotropy trace in a tibble where the last column contains log likelihood values and the first d columns contain marker ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_pleio_peak_tib(tib, start_snp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_pleio_peak_tib_+3A_tib">tib</code></td>
<td>
<p>a (d+1) column tibble with first d columns containing marker ids and the last containing log likelihood values. Typically this is the output from 'scan_pvl'.</p>
</td></tr>
<tr><td><code id="find_pleio_peak_tib_+3A_start_snp">start_snp</code></td>
<td>
<p>positive integer, from the two-dimensional scan, that indicates where the scan started on the chromosome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>positive integer indicating marker index for maximum value of log lik under pleiotropy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marker1 &lt;- rep(paste0('SNP', 1:3), times = 3)
marker2 &lt;- rep(paste0('SNP', 1:3), each = 3)
loglik &lt;- runif(9, -5, 0)
tibble::tibble(marker1, marker2, loglik) -&gt; tib
find_pleio_peak_tib(tib, start_snp = 1)
</code></pre>

<hr>
<h2 id='fit1_pvl'>Fit a model for a specified d-tuple of markers</h2><span id='topic+fit1_pvl'></span>

<h3>Description</h3>

<p>'fit1_pvl' uses several functions in the package qtl2pleio to fit the
linear mixed effects model for a single d-tuple of markers.
Creation of 'fit1_pvl' - from code that originally resided in 'scan_pvl', enabled
parallelization via the 'parallel' R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit1_pvl(indices, start_snp, probs, addcovar, inv_S, S, pheno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit1_pvl_+3A_indices">indices</code></td>
<td>
<p>a vector of indices for extracting elements of 'probs' array</p>
</td></tr>
<tr><td><code id="fit1_pvl_+3A_start_snp">start_snp</code></td>
<td>
<p>an integer to specify the index of the marker where the scan - in call to scan_pvl - starts. This argument is needed because 'mytab' has only relative indices (relative to the 'start_snp' marker)</p>
</td></tr>
<tr><td><code id="fit1_pvl_+3A_probs">probs</code></td>
<td>
<p>founder allele probabilities array</p>
</td></tr>
<tr><td><code id="fit1_pvl_+3A_addcovar">addcovar</code></td>
<td>
<p>additive covariates matrix</p>
</td></tr>
<tr><td><code id="fit1_pvl_+3A_inv_s">inv_S</code></td>
<td>
<p>inverse covariance matrix for the vectorized phenotype</p>
</td></tr>
<tr><td><code id="fit1_pvl_+3A_s">S</code></td>
<td>
<p>covariance matrix for the vectorized phenotype, ie, the inverse of inv_S. By making this a function input, we avoid inverting the matrix many many times.</p>
</td></tr>
<tr><td><code id="fit1_pvl_+3A_pheno">pheno</code></td>
<td>
<p>a n by d phenotypes matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number, the log-likelihood for the specified model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
pheno &lt;- matrix(rnorm(2 * n), ncol = 2)
Vg &lt;- diag(2)
Ve &lt;- diag(2)
Sigma &lt;- calc_Sigma(Vg, Ve, diag(n))
Sigma_inv &lt;- solve(Sigma)
probs &lt;- array(dim = c(n, 2, 5))
probs[ , 1, ] &lt;- rbinom(n * 5, size = 1, prob = 0.2)
probs[ , 2, ] &lt;- 1 - probs[ , 1, ]
mytab &lt;- prep_mytab(d_size = 2, n_snp = 5)
fit1_pvl(mytab[1, ], start_snp = 1,
probs = probs, addcovar = NULL, inv_S = Sigma_inv,
S = Sigma,
pheno = pheno
)
</code></pre>

<hr>
<h2 id='get_effects'>Extract founder allele effects at a single marker from output of qtl2::scan1coef</h2><span id='topic+get_effects'></span>

<h3>Description</h3>

<p>Extract founder allele effects at a single marker from output of qtl2::scan1coef
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_effects(marker_index, allele_effects_matrix, map, columns = 1:8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_effects_+3A_marker_index">marker_index</code></td>
<td>
<p>an integer indicating where in the 'map' object the peak position (or position of interest) is located</p>
</td></tr>
<tr><td><code id="get_effects_+3A_allele_effects_matrix">allele_effects_matrix</code></td>
<td>
<p>output of 'qtl2::scan1coef' for a single chromosome</p>
</td></tr>
<tr><td><code id="get_effects_+3A_map">map</code></td>
<td>
<p>a map object for the chromosome of interest</p>
</td></tr>
<tr><td><code id="get_effects_+3A_columns">columns</code></td>
<td>
<p>which columns to choose within the 'allele_effects_matrix'. Default is 1:8 to reflect 8 founder alleles of Diversity Outbred mice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of 8 founder allele effects at a single marker
</p>
<p>a vector of founder allele effects at a single marker
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up allele effects matrix
ae &lt;- matrix(dat = rnorm(100 * 8), ncol = 8, nrow = 100)
ae[, 8] &lt;- - rowSums(ae[, 1:7])
colnames(ae) &lt;- LETTERS[1:8]
rownames(ae) &lt;- paste0(1, "_", 1:100)
# set up map
map &lt;- 1:100
names(map) &lt;- rownames(ae)
# call get_effects
get_effects(marker_index = 15, allele_effects_matrix = ae, map = map)
</code></pre>

<hr>
<h2 id='make_id2keep'>Identify shared subject ids among all inputs: covariates, allele probabilities array, kinship, and phenotypes</h2><span id='topic+make_id2keep'></span>

<h3>Description</h3>

<p>We consider only those inputs that are not NULL. We then use 'intersect' on pairs
of inputs' rownames to identify those subjects are shared among all non-NULL inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_id2keep(probs, pheno, addcovar = NULL, kinship = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_id2keep_+3A_probs">probs</code></td>
<td>
<p>an allele probabilities array</p>
</td></tr>
<tr><td><code id="make_id2keep_+3A_pheno">pheno</code></td>
<td>
<p>a phenotypes matrix</p>
</td></tr>
<tr><td><code id="make_id2keep_+3A_addcovar">addcovar</code></td>
<td>
<p>a covariates matrix</p>
</td></tr>
<tr><td><code id="make_id2keep_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of subject IDs common to all (non-null) inputs
</p>

<hr>
<h2 id='plot_pvl'>Plot tidied results of a pvl scan</h2><span id='topic+plot_pvl'></span>

<h3>Description</h3>

<p>Plot tidied results of a pvl scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pvl(
  dat,
  units = "Mb",
  palette = c("#999999", "#E69F00", "#56B4E9"),
  linetype = c("solid", "longdash", "dotted")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pvl_+3A_dat">dat</code></td>
<td>
<p>a profile lod tibble</p>
</td></tr>
<tr><td><code id="plot_pvl_+3A_units">units</code></td>
<td>
<p>a character vector of length one to indicate units for physical or genetic map</p>
</td></tr>
<tr><td><code id="plot_pvl_+3A_palette">palette</code></td>
<td>
<p>a character vector of length 3 containing strings for colors</p>
</td></tr>
<tr><td><code id="plot_pvl_+3A_linetype">linetype</code></td>
<td>
<p>a character vector of length 3 specifying the linetype values for the 3 traces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object with profile LODs
</p>

<hr>
<h2 id='prep_mytab'>Prepare mytab object for use within scan_pvl R code</h2><span id='topic+prep_mytab'></span>

<h3>Description</h3>

<p>Prepare mytab object for use within scan_pvl R code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_mytab(d_size, n_snp, pvl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_mytab_+3A_d_size">d_size</code></td>
<td>
<p>an integer, the number of traits</p>
</td></tr>
<tr><td><code id="prep_mytab_+3A_n_snp">n_snp</code></td>
<td>
<p>an integer, the number of markers</p>
</td></tr>
<tr><td><code id="prep_mytab_+3A_pvl">pvl</code></td>
<td>
<p>logical indicating whether to output dataframe with all d-tuples for a d-QTL scan, or only those models that examine one marker at a time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with d_size + 1 columns and (n_snp)^d_size rows. Last column is NA and named loglik.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep_mytab(2, 10)
</code></pre>

<hr>
<h2 id='prep_X_list'>Create a list of component X matrices for input to stagger_mats, to ultimately create design matrix</h2><span id='topic+prep_X_list'></span>

<h3>Description</h3>

<p>Create a list of component X matrices for input to stagger_mats, to ultimately create design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_X_list(indices, start_snp, probs, covariates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_X_list_+3A_indices">indices</code></td>
<td>
<p>a vector of integers</p>
</td></tr>
<tr><td><code id="prep_X_list_+3A_start_snp">start_snp</code></td>
<td>
<p>an integer denoting the index (within genotype probabilities array) where the scan should start</p>
</td></tr>
<tr><td><code id="prep_X_list_+3A_probs">probs</code></td>
<td>
<p>a three-dimensional array of genotype probabilities for a single chromosome</p>
</td></tr>
<tr><td><code id="prep_X_list_+3A_covariates">covariates</code></td>
<td>
<p>a matrix of covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of design matrices, ultimately useful when constructing the (multi-locus) design matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pp &lt;- array(rbinom(n = 200, size = 1, prob = 0.5), dim = c(10, 2, 10))
prep_X_list(1:3, 1, probs = pp, covariates = NULL)
</code></pre>

<hr>
<h2 id='process_inputs'>Process inputs to scan functions</h2><span id='topic+process_inputs'></span>

<h3>Description</h3>

<p>Process inputs to scan functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_inputs(
  probs,
  pheno,
  addcovar,
  kinship,
  n_snp = dim(probs)[3],
  start_snp = 1,
  max_iter = 10^4,
  max_prec = 1/10^8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_inputs_+3A_probs">probs</code></td>
<td>
<p>a three-dimensional array of founder allele probabilities</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_pheno">pheno</code></td>
<td>
<p>a matrix of d trait values</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_addcovar">addcovar</code></td>
<td>
<p>a matrix of covariates</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_n_snp">n_snp</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_start_snp">start_snp</code></td>
<td>
<p>index number of start position in the probs object.</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_max_iter">max_iter</code></td>
<td>
<p>max number of iterations for EM</p>
</td></tr>
<tr><td><code id="process_inputs_+3A_max_prec">max_prec</code></td>
<td>
<p>max precision for stopping EM</p>
</td></tr>
</table>

<hr>
<h2 id='qtl2pleio'>qtl2pleio.</h2><span id='topic+qtl2pleio'></span>

<h3>Description</h3>

<p>Testing pleiotropy vs. separate QTL in multiparental populations
</p>

<hr>
<h2 id='rcpp_calc_Bhat'>Estimate allele effects matrix, B hat, with Rcpp functions</h2><span id='topic+rcpp_calc_Bhat'></span>

<h3>Description</h3>

<p>Estimate allele effects matrix, B hat, with Rcpp functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_Bhat(X, Sigma_inv, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_Bhat_+3A_x">X</code></td>
<td>
<p>dn by df block-diagonal design matrix that incorporates genetic info for two markers. Note that we can use the same marker data twice.</p>
</td></tr>
<tr><td><code id="rcpp_calc_Bhat_+3A_sigma_inv">Sigma_inv</code></td>
<td>
<p>dn by dn inverse covariance matrix, where its inverse, ie, Sigma, is often composed as <code class="reqn">K \otimes V_g + I_n \otimes V_e</code></p>
</td></tr>
<tr><td><code id="rcpp_calc_Bhat_+3A_y">Y</code></td>
<td>
<p>dn by 1 matrix, ie, a column vector, of d phenotypes' measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a df by 1 matrix of GLS-estimated allele effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- as.matrix(rbinom(n = 100, size = 1, prob = 1 / 2))
X &lt;- gemma2::stagger_mats(X1, X1)
Sigma_inv &lt;- diag(200)
Y &lt;- runif(200)
rcpp_calc_Bhat(X = X, Sigma_inv = Sigma_inv, Y = Y)
</code></pre>

<hr>
<h2 id='rcpp_calc_Bhat2'>Estimate allele effects matrix, B hat, with Rcpp functions</h2><span id='topic+rcpp_calc_Bhat2'></span>

<h3>Description</h3>

<p>Estimate allele effects matrix, B hat, with Rcpp functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_calc_Bhat2(X, Y, Sigma_inv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_calc_Bhat2_+3A_x">X</code></td>
<td>
<p>dn by df block-diagonal design matrix that incorporates genetic info for two markers. Note that we can use the same marker data twice.</p>
</td></tr>
<tr><td><code id="rcpp_calc_Bhat2_+3A_y">Y</code></td>
<td>
<p>dn by 1 matrix, ie, a column vector, of d phenotypes' measurements</p>
</td></tr>
<tr><td><code id="rcpp_calc_Bhat2_+3A_sigma_inv">Sigma_inv</code></td>
<td>
<p>dn by dn inverse covariance matrix, often composed as inverse of <code class="reqn">K \otimes V_g + I_n \otimes V_g</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a df by 1 matrix of GLS-estimated allele effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- as.matrix(rbinom(n = 100, size = 1, prob = 1 / 2))
X &lt;- gemma2::stagger_mats(X1, X1)
Sigma_inv &lt;- diag(200)
Y &lt;- runif(200)
rcpp_calc_Bhat2(X = X, Y = Y, Sigma_inv = Sigma_inv)
</code></pre>

<hr>
<h2 id='rcpp_log_dmvnorm2'>Calculate log likelihood for a multivariate normal</h2><span id='topic+rcpp_log_dmvnorm2'></span>

<h3>Description</h3>

<p>Calculate log likelihood for a multivariate normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_log_dmvnorm2(inv_S, mu, x, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_log_dmvnorm2_+3A_inv_s">inv_S</code></td>
<td>
<p>inverse covariance matrix</p>
</td></tr>
<tr><td><code id="rcpp_log_dmvnorm2_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="rcpp_log_dmvnorm2_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="rcpp_log_dmvnorm2_+3A_s">S</code></td>
<td>
<p>covariance matrix, ie, the inverse of inv_S</p>
</td></tr>
</table>

<hr>
<h2 id='scan_multi_onechr'>Perform multivariate, one-QTL model fitting for markers on one chromosome</h2><span id='topic+scan_multi_onechr'></span>

<h3>Description</h3>

<p>'scan_multi_onechr' calculates log likelihood for d-variate phenotype model fits. Inputted parameter 'start_snp' indicates where in the 'probs' object to start the scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_multi_onechr(
  probs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  start_snp = 1,
  n_snp = dim(probs)[3],
  max_iter = 10000,
  max_prec = 1/1e+08,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_multi_onechr_+3A_probs">probs</code></td>
<td>
<p>an array of founder allele probabilities for a single chromosome</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_pheno">pheno</code></td>
<td>
<p>a matrix of phenotypes</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix for one chromosome</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_addcovar">addcovar</code></td>
<td>
<p>a matrix, n subjects by c additive covariates</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_start_snp">start_snp</code></td>
<td>
<p>index of where to start the scan within probs</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_n_snp">n_snp</code></td>
<td>
<p>the number of (consecutive) markers to include in the scan</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations for EM algorithm</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_max_prec">max_prec</code></td>
<td>
<p>stepwise precision for EM algorithm. EM stops once incremental difference in log likelihood is less than max_prec</p>
</td></tr>
<tr><td><code id="scan_multi_onechr_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with d + 1 columns. First d columns indicate the genetic data (by listing the marker ids) used in the design matrix; last is log10 likelihood
</p>


<h3>References</h3>

<p>Knott SA, Haley CS (2000) Multitrait
least squares for quantitative trait loci detection.
Genetics 156: 899–911.
</p>
<p>Jiang C, Zeng ZB (1995) Multiple trait analysis
of genetic mapping for quantitative trait loci.
Genetics 140: 1111-1127.
</p>
<p>Zhou X, Stephens M (2014) Efficient multivariate linear
mixed model algorithms for genome-wide association studies.
Nature methods 11:407-409.
</p>
<p>Broman KW, Gatti DM, Simecek P, Furlotte NA, Prins P, Sen S, Yandell BS, Churchill GA (2019)
R/qtl2: software for mapping quantitative trait loci with high-dimensional data and
multi-parent populations. GENETICS https://www.genetics.org/content/211/2/495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
n &lt;- 50
pheno &lt;- matrix(rnorm(2 * n), ncol = 2)
rownames(pheno) &lt;- paste0("s", 1:n)
colnames(pheno) &lt;- paste0("tr", 1:2)
probs &lt;- array(dim = c(n, 2, 5))
probs[ , 1, ] &lt;- rbinom(n * 5, size = 1, prob = 0.2)
probs[ , 2, ] &lt;- 1 - probs[ , 1, ]
rownames(probs) &lt;- paste0("s", 1:n)
colnames(probs) &lt;- LETTERS[1:2]
dimnames(probs)[[3]] &lt;- paste0("m", 1:5)
scan_multi_onechr(probs = probs, pheno = pheno, kinship = NULL, cores = 1)

</code></pre>

<hr>
<h2 id='scan_multi_oneqtl'>Perform multivariate, one-QTL model fitting for markers on all chromosomes</h2><span id='topic+scan_multi_oneqtl'></span>

<h3>Description</h3>

<p>The function first discards individuals with one or more missing phenotypes or missing covariates.
It then infers variance components, Vg and Ve. Both Vg and Ve
are d by d covariance matrices. It uses an expectation maximization algorithm, as
implemented in the 'gemma2' R package. 'gemma2' R package is an R implementation of the
GEMMA algorithm for multivariate variance component estimation (Zhou &amp; Stephens 2014 Nature methods).
Note that variance components are fitted on a model that uses the d-variate phenotype
but contains no genetic information. This model does, however,
use the specified covariates (after dropping dependent columns
in the covariates matrix).
These inferred covariance matrices, <code class="reqn">\hat{Vg}</code> and <code class="reqn">\hat{Ve}</code>,
are then used in subsequent model fitting via
generalized least squares.
Generalized least squares model fitting is applied to every marker on
every chromosome.
For a single marker, we fit the model:
</p>
<p style="text-align: center;"><code class="reqn">vec(Y) = Xvec(B) + vec(G) + vec(E)</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">G \sim MN(0, K, \hat{Vg})</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">E \sim MN(0, I, \hat{Ve})</code>
</p>
<p> where <code class="reqn">MN</code> denotes the matrix-variate
normal distribution with three parameters: mean matrix, covariance among rows, and
covariance among columns. <code class="reqn">vec</code> denotes the vectorization operation, ie, stacking by columns.
<code class="reqn">K</code> is a kinship matrix, typically calculated by leave-one-chromosome-out methods.
<code class="reqn">Y</code> is the n by d phenotypes matrix. <code class="reqn">X</code> is a block-diagonal nd by fd matrix consisting of
d blocks each of dimension n by f. Each n by f block (on the diagonal) contains a matrix of
founder allele probabilities for the n subjects at a single marker. The off-diagonal blocks
have only zero entries.
The log-likelihood is returned for each model. The outputted object is a tibble with
d + 1 columns. The first d columns specify the markers used in the corresponding model fit, while
the last column specifies the log-likelihood value at that d-tuple of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_multi_oneqtl(
  probs_list,
  pheno,
  kinship_list = NULL,
  addcovar = NULL,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_multi_oneqtl_+3A_probs_list">probs_list</code></td>
<td>
<p>an list of arrays of founder allele probabilities</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_+3A_pheno">pheno</code></td>
<td>
<p>a matrix of phenotypes</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_+3A_kinship_list">kinship_list</code></td>
<td>
<p>a list of kinship matrices, one for each chromosome</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_+3A_addcovar">addcovar</code></td>
<td>
<p>a matrix, n subjects by c additive covariates</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallelization via parallel::mclapply()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with d + 1 columns. First d columns indicate the genetic data (by listing the marker ids) used in the design matrix; last is log10 likelihood
</p>


<h3>References</h3>

<p>Knott SA, Haley CS (2000) Multitrait
least squares for quantitative trait loci detection.
Genetics 156: 899–911.
</p>
<p>Jiang C, Zeng ZB (1995) Multiple trait analysis
of genetic mapping for quantitative trait loci.
Genetics 140: 1111-1127.
</p>
<p>Zhou X, Stephens M (2014) Efficient multivariate linear
mixed model algorithms for genome-wide association studies.
Nature methods 11:407-409.
</p>
<p>Broman KW, Gatti DM, Simecek P, Furlotte NA, Prins P, Sen S, Yandell BS, Churchill GA (2019)
R/qtl2: software for mapping quantitative trait loci with high-dimensional data and
multi-parent populations. GENETICS https://www.genetics.org/content/211/2/495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
n &lt;- 50
pheno &lt;- matrix(rnorm(2 * n), ncol = 2)
rownames(pheno) &lt;- paste0("s", 1:n)
colnames(pheno) &lt;- paste0("tr", 1:2)
probs &lt;- array(dim = c(n, 2, 5))
probs[ , 1, ] &lt;- rbinom(n * 5, size = 1, prob = 0.2)
probs[ , 2, ] &lt;- 1 - probs[ , 1, ]
rownames(probs) &lt;- paste0("s", 1:n)
colnames(probs) &lt;- LETTERS[1:2]
dimnames(probs)[[3]] &lt;- paste0("m", 1:5)
scan_multi_oneqtl(probs_list = list(probs, probs), pheno = pheno, cores = 1)

</code></pre>

<hr>
<h2 id='scan_multi_oneqtl_perm'>Permute the phenotypes matrix and then scan the genome. Record the genomewide greatest LOD score for each permuted data set.</h2><span id='topic+scan_multi_oneqtl_perm'></span>

<h3>Description</h3>

<p>Permute the phenotypes matrix and then scan the genome. Record the genomewide greatest LOD score for each permuted data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_multi_oneqtl_perm(
  probs_list,
  pheno,
  kinship_list = NULL,
  addcovar = NULL,
  n_perm = 1,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_multi_oneqtl_perm_+3A_probs_list">probs_list</code></td>
<td>
<p>a list of founder allele probabilities, one array per chromosome</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_perm_+3A_pheno">pheno</code></td>
<td>
<p>a matrix of trait values</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_perm_+3A_kinship_list">kinship_list</code></td>
<td>
<p>a list of kinship matrices, one per chromosome</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_perm_+3A_addcovar">addcovar</code></td>
<td>
<p>a matrix of covariate values</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_perm_+3A_n_perm">n_perm</code></td>
<td>
<p>positive integer for the number of permuted data sets to scan.</p>
</td></tr>
<tr><td><code id="scan_multi_oneqtl_perm_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of 'n_perm' max lod statistics
</p>

<hr>
<h2 id='scan_pvl'>Perform model fitting for all ordered pairs of markers in a genomic region of interest</h2><span id='topic+scan_pvl'></span>

<h3>Description</h3>

<p>'scan_pvl' calculates log likelihood for d-variate phenotype model fits. Inputted parameter 'start_snp' indicates where in the 'probs' object to start the scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_pvl(
  probs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  start_snp = 1,
  n_snp,
  max_iter = 10000,
  max_prec = 1/1e+08,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_pvl_+3A_probs">probs</code></td>
<td>
<p>an array of founder allele probabilities for a single chromosome</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_pheno">pheno</code></td>
<td>
<p>a matrix of phenotypes</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix for one chromosome</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_addcovar">addcovar</code></td>
<td>
<p>a matrix, n subjects by c additive covariates</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_start_snp">start_snp</code></td>
<td>
<p>index of where to start the scan within probs</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_n_snp">n_snp</code></td>
<td>
<p>the number of (consecutive) markers to include in the scan</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations for EM algorithm</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_max_prec">max_prec</code></td>
<td>
<p>stepwise precision for EM algorithm. EM stops once incremental difference in log likelihood is less than max_prec</p>
</td></tr>
<tr><td><code id="scan_pvl_+3A_cores">cores</code></td>
<td>
<p>number of cores to use when parallelizing via parallel::mclapply. Set to 1 for no parallelization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first discards individuals with one or more missing phenotypes or missing covariates.
It then infers variance components, Vg and Ve. Both Vg and Ve
are d by d covariance matrices. It uses an expectation maximization algorithm, as
implemented in the 'gemma2' R package. 'gemma2' R package is an R implementation of the
GEMMA algorithm for multivariate variance component estimation (Zhou &amp; Stephens 2014 Nature methods).
Note that variance components are fitted on a model that uses the d-variate phenotype
but contains no genetic information. This model does, however,
use the specified covariates (after dropping dependent columns
in the covariates matrix).
These inferred covariance matrices, <code class="reqn">\hat{Vg}</code> and <code class="reqn">\hat{Ve}</code>,
are then used in subsequent model fitting via
generalized least squares.
Generalized least squares model fitting is applied to every d-tuple of
markers within the specified genomic region for 'scan_pvl'.
For a single d-tuple of markers, we fit the model:
</p>
<p style="text-align: center;"><code class="reqn">vec(Y) = Xvec(B) + vec(G) + vec(E)</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">G \sim MN(0, K, \hat{Vg})</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">E \sim MN(0, I, \hat{Ve})</code>
</p>
<p> where <code class="reqn">MN</code> denotes the matrix-variate
normal distribution with three parameters: mean matrix, covariance among rows, and
covariance among columns. <code class="reqn">vec</code> denotes the vectorization operation, ie, stacking by columns.
<code class="reqn">K</code> is a kinship matrix, typically calculated by leave-one-chromosome-out methods.
<code class="reqn">Y</code> is the n by d phenotypes matrix. <code class="reqn">X</code> is a block-diagonal nd by fd matrix consisting of
d blocks each of dimension n by f. Each n by f block (on the diagonal) contains a matrix of
founder allele probabilities for the n subjects at a single marker. The off-diagonal blocks
have only zero entries.
The log-likelihood is returned for each model. The outputted object is a tibble with
d + 1 columns. The first d columns specify the markers used in the corresponding model fit, while
the last column specifies the log-likelihood value at that d-tuple of markers.
</p>


<h3>Value</h3>

<p>a tibble with d + 1 columns. First d columns indicate the genetic data (by listing the marker ids) used in the design matrix; last is log10 likelihood
</p>


<h3>References</h3>

<p>Knott SA, Haley CS (2000) Multitrait
least squares for quantitative trait loci detection.
Genetics 156: 899–911.
</p>
<p>Jiang C, Zeng ZB (1995) Multiple trait analysis
of genetic mapping for quantitative trait loci.
Genetics 140: 1111-1127.
</p>
<p>Zhou X, Stephens M (2014) Efficient multivariate linear
mixed model algorithms for genome-wide association studies.
Nature methods 11:407-409.
</p>
<p>Broman KW, Gatti DM, Simecek P, Furlotte NA, Prins P, Sen S, Yandell BS, Churchill GA (2019)
R/qtl2: software for mapping quantitative trait loci with high-dimensional data and
multi-parent populations. GENETICS https://www.genetics.org/content/211/2/495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
n &lt;- 50
pheno &lt;- matrix(rnorm(2 * n), ncol = 2)
rownames(pheno) &lt;- paste0("s", 1:n)
colnames(pheno) &lt;- paste0("tr", 1:2)
probs &lt;- array(dim = c(n, 2, 5))
probs[ , 1, ] &lt;- rbinom(n * 5, size = 1, prob = 0.2)
probs[ , 2, ] &lt;- 1 - probs[ , 1, ]
rownames(probs) &lt;- paste0("s", 1:n)
colnames(probs) &lt;- LETTERS[1:2]
dimnames(probs)[[3]] &lt;- paste0("m", 1:5)
scan_pvl(probs = probs, pheno = pheno, kinship = NULL,
start_snp = 1, n_snp = 5, cores = 1)
</code></pre>

<hr>
<h2 id='sim1'>Simulate a single multivariate data set consisting of n subjects and d phenotypes for each</h2><span id='topic+sim1'></span>

<h3>Description</h3>

<p>Simulate a single multivariate data set consisting of n subjects and d phenotypes for each
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim1(X, B, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim1_+3A_x">X</code></td>
<td>
<p>design matrix (incorporating genotype probabilities from two loci), dn by df</p>
</td></tr>
<tr><td><code id="sim1_+3A_b">B</code></td>
<td>
<p>a matrix of allele effects, f rows by d columns</p>
</td></tr>
<tr><td><code id="sim1_+3A_sigma">Sigma</code></td>
<td>
<p>dn by dn covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length dn. The first n entries are for trait 1, the second n for trait 2, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_mouse &lt;- 20
geno &lt;- rbinom(n = n_mouse, size = 1, prob = 1 / 2)
X &lt;- gemma2::stagger_mats(geno, geno)
B &lt;- matrix(c(1, 2), ncol = 2, nrow = 1)
sim1(X, B, Sigma = diag(2 * n_mouse))
</code></pre>

<hr>
<h2 id='subset_input'>Subset an input object - allele probabilities array or phenotypes matrix or covariates matrix. Kinship has its own subset function</h2><span id='topic+subset_input'></span>

<h3>Description</h3>

<p>An inputted matrix or 3-dimensional array is first subsetted - by rownames - to remove
those subjects who are not in &lsquo;id2keep'. After that, the object&rsquo;s rows
are ordered to match the ordering of subject ids in the vector 'id2keep'. This
(possibly reordered) object is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_input(input, id2keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_input_+3A_input">input</code></td>
<td>
<p>a matrix of either phenotypes or covariates or array of allele probabilities</p>
</td></tr>
<tr><td><code id="subset_input_+3A_id2keep">id2keep</code></td>
<td>
<p>a character vector of subject ids to identify those subjects that are shared by all inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object resulting from subsetting of 'input'. Its rows are ordered per 'id2keep'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define s_id
s_id &lt;- paste0("s", 1:10)
# set up input matrix
foo &lt;- matrix(data = rnorm(10 * 3), nrow = 10, ncol = 3)
rownames(foo) &lt;- s_id
subset_input(input = foo, id2keep = s_id)
</code></pre>

<hr>
<h2 id='subset_kinship'>Subset a kinship matrix to include only those subjects present in all inputs</h2><span id='topic+subset_kinship'></span>

<h3>Description</h3>

<p>Since a kinship matrix has subject ids in both rownames and colnames, so we need to
remove rows and columns according to names in 'id2keep'. We first remove rows and
columns of subjects that are not in 'id2keep'. We then order rows and columns of the
resulting matrix by the ordering in 'id2keep'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_kinship(kinship, id2keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_kinship_+3A_kinship">kinship</code></td>
<td>
<p>a kinship matrix</p>
</td></tr>
<tr><td><code id="subset_kinship_+3A_id2keep">id2keep</code></td>
<td>
<p>a character vector of subject ids to identify those subjects that are shared by all inputs</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
