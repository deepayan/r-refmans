<!DOCTYPE html><html><head><title>Help for package metamer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metamer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#metamer-package'><p>metamer: Create Data with Identical Statistics</p></a></li>
<li><a href='#clear_minimize'><p>Set metamer parameters</p></a></li>
<li><a href='#delayed_with'><p>Apply expressions to data.frames</p></a></li>
<li><a href='#densify'><p>Increase resolution of data</p></a></li>
<li><a href='#draw_data'><p>Freehand drawing</p></a></li>
<li><a href='#mean_dist_to'><p>Mean minimum distance</p></a></li>
<li><a href='#mean_dist_to_sf'><p>Mean distance to an sf object</p></a></li>
<li><a href='#mean_self_proximity'><p>Inverse of the mean self distance</p></a></li>
<li><a href='#metamerise'><p>Create metamers</p></a></li>
<li><a href='#moments_n'><p>Compute moments</p></a></li>
<li><a href='#n_tries'><p>Stop conditions</p></a></li>
<li><a href='#truncate_to'><p>Rounding functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create Data with Identical Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates data with identical statistics (metamers) using an iterative 
   algorithm proposed by Matejka &amp; Fitzmaurice (2017) &lt;<a href="https://doi.org/10.1145%2F3025453.3025912">doi:10.1145/3025453.3025912</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://eliocamp.github.io/metamer/">https://eliocamp.github.io/metamer/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eliocamp/metamer/issues">https://github.com/eliocamp/metamer/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, progress (&ge; 1.2.0), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>shiny, miniUI, testthat (&ge; 2.1.0), data.table, covr, sf</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-23 19:55:43 UTC; elio</td>
</tr>
<tr>
<td>Author:</td>
<td>Elio Campitelli <a href="https://orcid.org/0000-0002-7742-9230"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elio Campitelli &lt;elio.campitelli@cima.fcen.uba.ar&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-23 20:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='metamer-package'>metamer: Create Data with Identical Statistics</h2><span id='topic+metamer'></span><span id='topic+metamer-package'></span>

<h3>Description</h3>

<p>Creates data with identical statistics (metamers) using an iterative algorithm proposed by Matejka &amp; Fitzmaurice (2017) <a href="https://doi.org/10.1145/3025453.3025912">doi:10.1145/3025453.3025912</a>.
</p>


<h3>Overview</h3>

<p>Create metamers with the <code><a href="#topic+metamerize">metamerize()</a></code> function.
</p>
<p>Some helper functions included:
</p>

<ul>
<li> <p><code><a href="#topic+draw_data">draw_data()</a></code> for drawing 2D datasets by hand and <code><a href="#topic+densify">densify()</a></code> for increasing
the point density of those drawings.
</p>
</li>
<li> <p><code><a href="#topic+delayed_with">delayed_with()</a></code> for defining statistics to preserve.
</p>
</li>
<li> <p><code><a href="#topic+moments_n">moments_n()</a></code> for preserving moments of order n.
</p>
</li>
<li> <p><code><a href="#topic+mean_dist_to">mean_dist_to()</a></code> for minimizing the mean distance to a known target dataset.
</p>
</li></ul>

<p>The <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>/<code style="white-space: pre;">&#8288;[data.table::as.data.table()] methods included will turn a &#8288;</code>metamer_list' into a tidy
data.frame.
</p>
<p>Inspired by Matejka &amp; Fitzmaurice (2017) awesome paper.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Elio Campitelli <a href="mailto:elio.campitelli@cima.fcen.uba.ar">elio.campitelli@cima.fcen.uba.ar</a> (<a href="https://orcid.org/0000-0002-7742-9230">ORCID</a>)
</p>


<h3>References</h3>

<p>Matejka, J., &amp; Fitzmaurice, G. (2017). Same Stats, Different Graphs. Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems  - CHI ’17, 1290–1294. https://doi.org/10.1145/3025453.3025912
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://eliocamp.github.io/metamer/">https://eliocamp.github.io/metamer/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/eliocamp/metamer/issues">https://github.com/eliocamp/metamer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='clear_minimize'>Set metamer parameters</h2><span id='topic+clear_minimize'></span><span id='topic+clear_minimise'></span><span id='topic+set_minimise'></span><span id='topic+set_minimize'></span><span id='topic+get_last_metamer'></span><span id='topic+set_annealing'></span><span id='topic+set_perturbation'></span><span id='topic+set_start_probability'></span><span id='topic+set_K'></span><span id='topic+set_change'></span>

<h3>Description</h3>

<p>Set metamer parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_minimize(metamer_list)

clear_minimise(metamer_list)

set_minimise(metamer_list, minimize)

set_minimize(metamer_list, minimize)

get_last_metamer(metamer_list)

set_annealing(metamer_list, annealing)

set_perturbation(metamer_list, perturbation)

set_perturbation(metamer_list, perturbation)

set_start_probability(metamer_list, start_probability)

set_K(metamer_list, K)

set_change(metamer_list, change)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_minimize_+3A_metamer_list">metamer_list</code></td>
<td>
<p>A <code>metamer_list</code> object.</p>
</td></tr>
<tr><td><code id="clear_minimize_+3A_minimize">minimize</code></td>
<td>
<p>An optional function to minimize in the process. Must take
the data as argument and return a single numeric.</p>
</td></tr>
<tr><td><code id="clear_minimize_+3A_annealing">annealing</code></td>
<td>
<p>Logical indicating whether to perform annealing.</p>
</td></tr>
<tr><td><code id="clear_minimize_+3A_perturbation">perturbation</code></td>
<td>
<p>Numeric with the magnitude of the random perturbations.
Can be of length 1 or <code>length(change)</code>.</p>
</td></tr>
<tr><td><code id="clear_minimize_+3A_start_probability">start_probability</code></td>
<td>
<p>initial probability of rejecting bad solutions.</p>
</td></tr>
<tr><td><code id="clear_minimize_+3A_k">K</code></td>
<td>
<p>speed/quality tradeoff parameter.</p>
</td></tr>
<tr><td><code id="clear_minimize_+3A_change">change</code></td>
<td>
<p>A character vector with the names of the columns that need to be
changed.</p>
</td></tr>
</table>

<hr>
<h2 id='delayed_with'>Apply expressions to data.frames</h2><span id='topic+delayed_with'></span>

<h3>Description</h3>

<p>Creates a function that evaluates expressions in a future data.frame. Is like
<code>with()</code>, but the data argument is passed at a later step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delayed_with(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delayed_with_+3A_...">...</code></td>
<td>
<p>Expressions that will be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each expression in <code>...</code> must return a single numeric value. They can be named or
return named vectors.
</p>


<h3>Value</h3>

<p>A function that takes a <code>data.frame</code> and returns the expressions in <code>...</code>
evaluated in an environment constructed from it.
</p>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>some_stats &lt;- delayed_with(mean_x = mean(x), mean(y), sd(x), coef(lm(x ~ y)))
data &lt;- data.frame(x = rnorm(20) , y = rnorm(20))
some_stats(data)

</code></pre>

<hr>
<h2 id='densify'>Increase resolution of data</h2><span id='topic+densify'></span>

<h3>Description</h3>

<p>Interpolates between the output of <code><a href="#topic+draw_data">draw_data()</a></code> and increases the point
density of each stroke.Useful for avoiding sparse targets that result in
clumping of points when metamerizing. It only has an effect on strokes (made
by double clicking).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densify(data, res = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densify_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with columns <code>x</code>, <code>y</code> and <code>.group</code>.</p>
</td></tr>
<tr><td><code id="densify_+3A_res">res</code></td>
<td>
<p>A numeric indicating the multiplicative resolution (i.e. 2 =
double resolution).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the <code>x</code> and <code>y</code> values of your data and a <code>.group</code> column
that identifies each stroke.
</p>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>

<hr>
<h2 id='draw_data'>Freehand drawing</h2><span id='topic+draw_data'></span>

<h3>Description</h3>

<p>Opens up a dialogue that lets you draw your data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_data(data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_data_+3A_data">data</code></td>
<td>
<p>Optional <code>data.frame</code> with x and y values that can used as
background to guide your drawing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the <code>x</code> and <code>y</code> values of your data and a <code>.group</code> column
that identifies each stroke.
</p>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>

<hr>
<h2 id='mean_dist_to'>Mean minimum distance</h2><span id='topic+mean_dist_to'></span>

<h3>Description</h3>

<p>Creates a function to get the mean minimum distance between two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_dist_to(target, squared = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_dist_to_+3A_target">target</code></td>
<td>
<p>A <code>data.frame</code> with all numeric columns.</p>
</td></tr>
<tr><td><code id="mean_dist_to_+3A_squared">squared</code></td>
<td>
<p>Logical indicating whether to compute the mean squared
distance (if <code>TRUE</code>) or the mean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes a <code>data.frame</code> with the same number of columns as
<code>target</code> and then returns the mean minimum distance between them.
</p>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target &lt;- data.frame(x = rnorm(100), y = rnorm(100))
data &lt;- data.frame(x = rnorm(100), y = rnorm(100))
distance &lt;- mean_dist_to(target)
distance(data)

</code></pre>

<hr>
<h2 id='mean_dist_to_sf'>Mean distance to an sf object</h2><span id='topic+mean_dist_to_sf'></span>

<h3>Description</h3>

<p>Mean distance to an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_dist_to_sf(target, coords = c("x", "y"), buffer = 0, squared = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_dist_to_sf_+3A_target">target</code></td>
<td>
<p>An sf object.</p>
</td></tr>
<tr><td><code id="mean_dist_to_sf_+3A_coords">coords</code></td>
<td>
<p>Character vector with the columns of the data object
that define de coordinates.</p>
</td></tr>
<tr><td><code id="mean_dist_to_sf_+3A_buffer">buffer</code></td>
<td>
<p>Buffer around the sf object. Distances smaller
than <code>buffer</code> are replaced with 0.</p>
</td></tr>
<tr><td><code id="mean_dist_to_sf_+3A_squared">squared</code></td>
<td>
<p>Logical indicating whether to compute the mean squared
distance (if <code>TRUE</code>) or the mean distance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>

<hr>
<h2 id='mean_self_proximity'>Inverse of the mean self distance</h2><span id='topic+mean_self_proximity'></span>

<h3>Description</h3>

<p>Returns the inverse of the mean minimum distance between different pairs of points.
It's intended to be used as a minimizing function to, then, maximize the distance between
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_self_proximity(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_self_proximity_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>

<hr>
<h2 id='metamerise'>Create metamers</h2><span id='topic+metamerise'></span><span id='topic+metamerize'></span><span id='topic+new_metamer'></span>

<h3>Description</h3>

<p>Produces very dissimilar datasets with the same statistical properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metamerise(
  data,
  preserve,
  minimize = NULL,
  change = colnames(data),
  round = truncate_to(2),
  stop_if = n_tries(100),
  keep = NULL,
  annealing = TRUE,
  K = 0.02,
  start_probability = 0.5,
  perturbation = 0.08,
  name = "",
  verbose = interactive()
)

metamerize(
  data,
  preserve,
  minimize = NULL,
  change = colnames(data),
  round = truncate_to(2),
  stop_if = n_tries(100),
  keep = NULL,
  annealing = TRUE,
  K = 0.02,
  start_probability = 0.5,
  perturbation = 0.08,
  name = "",
  verbose = interactive()
)

new_metamer(data, preserve, round = truncate_to(2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metamerise_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with the starting data or a <code>metamer_list</code> object returned
by a previous call to the function.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_preserve">preserve</code></td>
<td>
<p>A function whose result must be kept exactly the same.
Must take the data as argument and return a numeric vector.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_minimize">minimize</code></td>
<td>
<p>An optional function to minimize in the process. Must take
the data as argument and return a single numeric.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_change">change</code></td>
<td>
<p>A character vector with the names of the columns that need to be
changed.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_round">round</code></td>
<td>
<p>A function to apply to the result of <code>preserve</code> to round
numbers. See <a href="#topic+truncate_to">truncate_to</a>.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_stop_if">stop_if</code></td>
<td>
<p>A stopping criterium. See <a href="#topic+n_tries">n_tries</a>.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_keep">keep</code></td>
<td>
<p>Max number of metamers to return.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_annealing">annealing</code></td>
<td>
<p>Logical indicating whether to perform annealing.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_k">K</code></td>
<td>
<p>speed/quality tradeoff parameter.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_start_probability">start_probability</code></td>
<td>
<p>initial probability of rejecting bad solutions.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_perturbation">perturbation</code></td>
<td>
<p>Numeric with the magnitude of the random perturbations.
Can be of length 1 or <code>length(change)</code>.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_name">name</code></td>
<td>
<p>Character for naming the metamers.</p>
</td></tr>
<tr><td><code id="metamerise_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to show a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It follows Matejka &amp; Fitzmaurice (2017) method of constructing metamers.
Beginning from a starting dataset, it iteratively adds a small perturbation,
checks if <code>preserve</code> returns the same value (up to <code>signif</code> significant digits)
and if <code>minimize</code> has been lowered, and accepts the solution for the next
round. If <code>annealing</code> is <code>TRUE</code>, it also accepts solutions with bigger
<code>minimize</code> with an ever decreasing probability to help the algorithm avoid
local minimums.
</p>
<p>The annealing scheme is adapted from de Vicente et al. (2003).
</p>
<p>If <code>data</code> is a <code>metamer_list</code>, the function will start the algorithm from the
last metamer of the list. Furthermore, if <code>preserve</code> and/or <code>minimize</code>
are missing, the previous functions will be carried over from the previous call.
</p>
<p><code>minimize</code> can be also a <em>vector</em> of functions. In that case, the process minimizes
the product of the functions applied to the data.
</p>


<h3>Value</h3>

<p>A <code>metamer_list</code> object (a list of data.frames).
</p>


<h3>References</h3>

<p>Matejka, J., &amp; Fitzmaurice, G. (2017). Same Stats, Different Graphs. Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems  - CHI ’17, 1290–1294. https://doi.org/10.1145/3025453.3025912
de Vicente, Juan, Juan Lanchares, and Román Hermida. (2003). ‘Placement by Thermodynamic Simulated Annealing’. Physics Letters A 317(5): 415–23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delayed_with">delayed_with()</a></code> for a convenient way of making functions suitable for
<code>preserve</code>, <code><a href="#topic+mean_dist_to">mean_dist_to()</a></code> for a convenient way of minimizing the distance
to a known target in <code>minimize</code>, <code><a href="#topic+mean_self_proximity">mean_self_proximity()</a></code> for maximizing the
&quot;self distance&quot; to prevent data clumping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cars)
# Metamers of `cars` with the same mean speed and dist, and correlation
# between the two.
means_and_cor &lt;- delayed_with(mean_speed = mean(speed),
                              mean_dist = mean(dist),
                              cor = cor(speed, dist))
set.seed(42)  # for reproducibility.
metamers &lt;- metamerize(cars,
                       preserve = means_and_cor,
                       round = truncate_to(2),
                       stop_if = n_tries(1000))
print(metamers)

last &lt;- tail(metamers)

# Confirm that the statistics are the same
cbind(original = means_and_cor(cars),
      metamer = means_and_cor(last))

# Visualize
plot(tail(metamers))
points(cars, col = "red")

</code></pre>

<hr>
<h2 id='moments_n'>Compute moments</h2><span id='topic+moments_n'></span>

<h3>Description</h3>

<p>Returns a function that will return uncentered moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments_n(orders, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments_n_+3A_orders">orders</code></td>
<td>
<p>Numeric with the order of the uncentered moments that will
be computed.</p>
</td></tr>
<tr><td><code id="moments_n_+3A_cols">cols</code></td>
<td>
<p>Character vector with the name of the columns of the data for which
moments will be computed. If <code>NULL</code>, will use all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes a <code>data.frame</code> and return a named numeric vector of the
uncentered moments of the columns.
</p>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+truncate_to">truncate_to</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(x = rnorm(100), y = rnorm(100))
moments_3 &lt;- moments_n(1:3)

moments_3(data)

moments_3 &lt;- moments_n(1:3, "x")
moments_3(data)

</code></pre>

<hr>
<h2 id='n_tries'>Stop conditions</h2><span id='topic+n_tries'></span><span id='topic+n_metamers'></span><span id='topic+minimize_ratio'></span>

<h3>Description</h3>

<p>Stop conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_tries(n)

n_metamers(n)

minimize_ratio(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_tries_+3A_n">n</code></td>
<td>
<p>integer number of tries or metamers.</p>
</td></tr>
<tr><td><code id="n_tries_+3A_r">r</code></td>
<td>
<p>Ratio of minimize value to shoot for. If <code>0.5</code>,
the stop condition is that the iteration will stop if the value
to minimize gets to one-half of the starting value.</p>
</td></tr>
</table>

<hr>
<h2 id='truncate_to'>Rounding functions</h2><span id='topic+truncate_to'></span><span id='topic+round_to'></span>

<h3>Description</h3>

<p>Rounding functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate_to(digits)

round_to(digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncate_to_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>
</p>
<p>Other helper functions: 
<code><a href="#topic+delayed_with">delayed_with</a>()</code>,
<code><a href="#topic+densify">densify</a>()</code>,
<code><a href="#topic+draw_data">draw_data</a>()</code>,
<code><a href="#topic+mean_dist_to_sf">mean_dist_to_sf</a>()</code>,
<code><a href="#topic+mean_dist_to">mean_dist_to</a>()</code>,
<code><a href="#topic+mean_self_proximity">mean_self_proximity</a>()</code>,
<code><a href="#topic+moments_n">moments_n</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
