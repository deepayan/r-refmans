<!DOCTYPE html><html><head><title>Help for package transport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {transport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aha'>
<p>Solve Transportation Problem by Aurenhammer&ndash;Hoffmann&ndash;Aronov Method</p></a></li>
<li><a href='#all.equal (transport objects)'>
<p>Methods for Judging Near Equality of Objects of Class pgrid, pp or wpp</p></a></li>
<li><a href='#compatible'>
<p>Test whether Two Objects are Compatible</p></a></li>
<li><a href='#matimage'><p>Plotting Matrices as Images</p></a></li>
<li><a href='#methods'>
<p>Print and Summary Methods for Objects of Class pgrid, pp and wpp</p></a></li>
<li><a href='#pgrid'>
<p>Constructor for the pgrid Class</p></a></li>
<li><a href='#pgrid-object'>
<p>Class of Pixel Grids</p></a></li>
<li><a href='#plot'>
<p>Methods for Plotting Objects of Class pgrid, pp and wpp</p></a></li>
<li><a href='#plot_apollonius'><p>Plot Apollonius Diagram</p></a></li>
<li><a href='#plot.ut_pgrid'><p>Plot Unbalanced Transport Information</p></a></li>
<li><a href='#plot.ut_wpp'><p>Plot Unbalanced Transport Information</p></a></li>
<li><a href='#power_diagram'>
<p>Compute the Power Diagram of Weighted Sites in 2-Dimensional Space</p></a></li>
<li><a href='#pp'>
<p>Constructor for the pp Class</p></a></li>
<li><a href='#pp-object'>
<p>Class of (Unweighted) Point Patterns</p></a></li>
<li><a href='#random'>
<p>Images to Illustrate the Use of transport.pgrid</p></a></li>
<li><a href='#ret_message'><p>Return Text Strings for lbfgs Return Codes</p></a></li>
<li><a href='#semidiscrete'>
<p>Find Optimal Transport Partition Between pgrid and wpp.</p></a></li>
<li><a href='#semidiscrete1'><p>Compute Semidiscrete Optimal Transport for Euclidean Distance Cost</p></a></li>
<li><a href='#shielding'><p>Compute Optimal Transport (Cost/Plan) Using the Multiscale Shielding Method</p></a></li>
<li><a href='#starting solutions'>
<p>Compute starting solution for the transportation problem</p></a></li>
<li><a href='#subwasserstein'><p>Approximate Computation of Wasserstein Distances via Subsampling.</p></a></li>
<li><a href='#transport'>
<p>Find Optimal Transport Plan Between Two Objects</p></a></li>
<li><a href='#transport_track'>
<p>Create a Dynamic Visualization of a Transference Plan Between Two pgrids</p></a></li>
<li><a href='#transport-internal'>
<p>Internal Functions in Package &lsquo;transport&rsquo;</p></a></li>
<li><a href='#transport-package'>
<p>Optimal Transport in Various Forms</p></a></li>
<li><a href='#trcontrol'>
<p>Set the Control Parameters Used by <code>transport</code>.</p></a></li>
<li><a href='#unbalanced'><p>Unbalanced Optimal Transport Between Two Objects</p></a></li>
<li><a href='#wasserstein'>
<p>Compute the Wasserstein Distance Between Two Objects</p></a></li>
<li><a href='#wasserstein1d'>
<p>Compute the Wasserstein Distance Between Two Univariate Samples</p></a></li>
<li><a href='#wpp'>
<p>Constructor for the wpp Class</p></a></li>
<li><a href='#wpp-object'>
<p>Class of Weighted Point Patterns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.15-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Computation of Optimal Transport Plans and Wasserstein Distances</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Schuhmacher &lt;dominic.schuhmacher@mathematik.uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, stats, Rcpp (&ge; 0.12.10),
data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>animation, ks, testthat, WSGeometry</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Solve optimal transport problems. Compute Wasserstein distances (a.k.a. Kantorovitch, Fortet&ndash;Mourier, Mallows, Earth Mover's, or minimal L_p distances), return the corresponding transference plans, and display them graphically. Objects that can be compared include grey-scale images, (weighted) point patterns, and mass vectors.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dschuhm1.pages.gwdg.de/software">https://dschuhm1.pages.gwdg.de/software</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 17:34:50 UTC; schumi</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominic Schuhmacher [aut, cre],
  Björn Bähre [aut] (aha and power diagrams),
  Nicolas Bonneel [aut] (networkflow),
  Carsten Gottschlich [aut] (simplex and shortlist),
  Valentin Hartmann [aut] (semidiscrete1),
  Florian Heinemann [aut] (transport_track and networkflow integration),
  Bernhard Schmitzer [aut] (shielding),
  Jörn Schrieber [aut] (subsampling),
  Timo Wilm [ctb] (wpp)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aha'>
Solve Transportation Problem by Aurenhammer&ndash;Hoffmann&ndash;Aronov Method
</h2><span id='topic+aha'></span><span id='topic+transport_apply'></span><span id='topic+transport_error'></span>

<h3>Description</h3>

<p>Solve transportation problem by Aurenhammer&ndash;Hoffmann&ndash;Aronov Method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aha(a, b, nscales = 1, scmult = 2, factr = 1e+05, maxit = 10000, powerdiag=FALSE,
    wasser = FALSE, wasser.spt = NA, approx=FALSE, ...)
transport_apply(a, tplan)
transport_error(a, b, tplan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aha_+3A_a">a</code></td>
<td>

<p>an <code class="reqn">m \times n</code> matrix. <code>a</code> is treated as a measure on <code class="reqn">[0,m] \times [0,n]</code> with constant density on each unit square <code class="reqn">[i,i+1) \times [j,j+1)</code>.
</p>
</td></tr>
<tr><td><code id="aha_+3A_b">b</code></td>
<td>

<p>either a matrix such that <code>dim(a)==dim(b)</code> and <code>sum(a)==sum(b)</code> or a data frame with three variables named <code>x</code>, <code>y</code> and <code>mass</code> such that <code>sum(a)==sum(b$mass)</code>,
representing a discrete measure on <code class="reqn">[0,m]) \times [0,n]</code>.
</p>
</td></tr>
<tr><td><code id="aha_+3A_tplan">tplan</code></td>
<td>

<p>a transference plan from a (to b), typically an optimal transference plan obtained by a call to <code>aha</code>.  	
</p>
</td></tr>
<tr><td><code id="aha_+3A_nscales">nscales</code>, <code id="aha_+3A_scmult">scmult</code></td>
<td>

<p>the number of scales to use for the multiscale approach (the default is <code class="reqn">1</code> meaning no multiscale approach), and the factor
by which the number of pixels in each dimension is multiplied to get from a coarser to the next finer scale.
</p>
</td></tr>
<tr><td><code id="aha_+3A_factr">factr</code>, <code id="aha_+3A_maxit">maxit</code></td>
<td>

<p>parameters passed to the underlying L-BFGS-B algorithm (via the argument <code>control</code> in the R-function <code><a href="stats.html#topic+optim">optim</a></code>).
</p>
</td></tr>
<tr><td><code id="aha_+3A_powerdiag">powerdiag</code></td>
<td>

<p>logical. Instead of an optimal transference plan, should the parameters for the optimal power diagram be returned? 
</p>
</td></tr>
<tr><td><code id="aha_+3A_wasser">wasser</code></td>
<td>

<p>logical. Instead of an optimal transference plan, should only the <code class="reqn">L_2</code>-Wasserstein-distance between <code>a</code> and <code>b</code> be returned?
</p>
</td></tr>
<tr><td><code id="aha_+3A_wasser.spt">wasser.spt</code></td>
<td>

<p>the number of support points used to approximate the discrete measure <code>b</code>. Defaults to <code>NA</code> meaning the full set of support
points of <code>b</code> is used. If this argument is not <code>NA</code>, <code>wasser</code> is set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="aha_+3A_approx">approx</code></td>
<td>

<p>logical. If <code>TRUE</code>, an approximation to the objective function is used during optimization.
</p>
</td></tr>
<tr><td><code id="aha_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code><a href="stats.html#topic+optim">optim</a></code> via its argument <code>control</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>aha</code> implements the algorithm by Aurenhammer, Hoffmann and Aronov (1998) for finding optimal transference plans in terms
of the squared Euclidean distance in two dimensions. It follows the more detailed description given in Mérigot (2011) and also implements
the multiscale version presented in the latter paper.
</p>
<p>The functions <code>transport_apply</code> and <code>transport_error</code> serve for checking the accuracy of the transference plan obtained by <code>aha</code>.
Since this transference plan is obtained by continuous optimization it will not transport exactly to the measure <code>b</code>, but to the measure
<code>transport_apply(a, tplan)</code>. By <code>transport_error(a, b, tplan)</code> the sum of absolut errors between the transported <code>a</code>-measure and the <code>b</code>-measure is obtained.
</p>


<h3>Value</h3>

<p>If <code>powerdiag</code> and <code>wasser</code> are both <code>FALSE</code>, a data frame with columns <code>from</code>, <code>to</code> and <code>mass</code>, which specify from which knot to which other knot what amount of mass is sent in the optimal transference plan. Knots are given as indices in terms of the usual column major enumeration of the matrices <code>a</code> and <code>b</code>. There are <code><a href="#topic+plot.pgrid">plot</a></code> methods for the classes <code><a href="#topic+pgrid">pgrid</a></code> and <code><a href="#topic+pp">pp</a></code>, which can plot this solution.
</p>
<p>If <code>powerdiag</code> is TRUE and <code>wasser</code> is <code>FALSE</code>, a list with components <code>xi</code>, <code>eta</code>, <code>w</code> and <code>rect</code>, which specify the parameters for the optimal power diagram in the same format as needed for the function <code><a href="#topic+power_diagram">power_diagram</a></code>. Note that rect is always <code>c(0,m,0,n)</code>. Since version 0.10-0 the list has a further component <code>wasser.dist</code> containing the Wasserstein distance.
</p>
<p>If <code>wasser</code> is <code>TRUE</code>, a data frame with columns <code>wasser.dist</code> and <code>error.bound</code> of length one, where <code>error.bound</code> gives a bound on the absolute error in the Wasserstein distance due to approximating the measure <code>b</code> by a measure on a smaller number of support points.
</p>


<h3>Author(s)</h3>

<p>Björn Bähre <a href="mailto:bjobae@gmail.com">bjobae@gmail.com</a> <br />
(slightly modified by Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>)
</p>


<h3>References</h3>

<p>F. Aurenhammer, F. Hoffmann and B. Aronov (1998). Minkowski-type theorems and least-squares clustering. Algorithmica 20(1), 61&ndash;76.
</p>
<p>Q. Mérigot (2011). A multiscale approach to optimal transport. Eurographics Symposium on Geometry Processing 30(5), 1583&ndash;1592.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transport">transport</a></code>, which is a convenient wrapper function for various optimal transportation algorithms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is one particular testing configuration on MacOS where the following
# command does not return (to be investigated)
# res &lt;- aha(random32a$mass, random32b$mass)
# plot(random32a, random32b, res, lwd=0.75)

aha(random64a$mass, random64b$mass, nscales=3, scmult=5, wasser.spt=512, approx=TRUE)
</code></pre>

<hr>
<h2 id='all.equal+20+28transport+20objects+29'>
Methods for Judging Near Equality of Objects of Class pgrid, pp or wpp
</h2><span id='topic+all.equal.pgrid'></span><span id='topic+all.equal.pp'></span><span id='topic+all.equal.wpp'></span>

<h3>Description</h3>

<p>Methods for judging near equality of objects of class pgrid or pp or wpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgrid'
all.equal(target, current, ...)
## S3 method for class 'pp'
all.equal(target, current, ...)
## S3 method for class 'wpp'
all.equal(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal+2B20+2B28transport+2B20objects+2B29_+3A_target">target</code>, <code id="all.equal+2B20+2B28transport+2B20objects+2B29_+3A_current">current</code></td>
<td>

<p>the objects of the same class to be compared.
</p>
</td></tr>
<tr><td><code id="all.equal+2B20+2B28transport+2B20objects+2B29_+3A_...">...</code></td>
<td>

<p>currently without effect.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>TRUE</code> or a vector of <code><a href="base.html#topic+mode">mode</a></code> &ldquo;character&rdquo; describing the differences between target and current.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+all.equal">all.equal (base)</a></code>, <code><a href="#topic+compatible">compatible</a></code>
</p>

<hr>
<h2 id='compatible'>
Test whether Two Objects are Compatible
</h2><span id='topic+compatible'></span><span id='topic+compatible.pgrid'></span><span id='topic+compatible.pp'></span><span id='topic+compatible.wpp'></span>

<h3>Description</h3>

<p>Test whether two objects of the same class are &lsquo;of similar shape&rsquo; so that
the function <code><a href="#topic+transport">transport</a></code> can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compatible(target, current, ...)
## S3 method for class 'pgrid'
compatible(target, current, ...)
## S3 method for class 'pp'
compatible(target, current, ...)
## S3 method for class 'wpp'
compatible(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatible_+3A_target">target</code>, <code id="compatible_+3A_current">current</code></td>
<td>

<p>to objects of the same class to be compared.
</p>
</td></tr>
<tr><td><code id="compatible_+3A_...">...</code></td>
<td>

<p>currently without effect.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+all.equal.pgrid">all.equal</a></code>
</p>

<hr>
<h2 id='matimage'>Plotting Matrices as Images</h2><span id='topic+matimage'></span>

<h3>Description</h3>

<p>A simple wrapper to the image function with a more convenient syntax for plotting 
matrices &quot;the right way round&quot; as pixel images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matimage(z, x = 1:dim(z)[1], y = 1:dim(z)[2], rot = TRUE, asp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matimage_+3A_z">z</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="matimage_+3A_x">x</code>, <code id="matimage_+3A_y">y</code></td>
<td>
<p>(optional) coordinates of the pixels.</p>
</td></tr>
<tr><td><code id="matimage_+3A_rot">rot</code></td>
<td>
<p>logical. Whether to plot the matrix &quot;the right way round&quot; so that the pixel
position in the image corresponds to the pixel position in the matrix obtained by <code>print</code>.</p>
</td></tr>
<tr><td><code id="matimage_+3A_asp">asp</code></td>
<td>
<p>the aspect ratio parameter of <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="matimage_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (invisible NULL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:36,6,6)
image(z=m, col = heat.colors(36))
matimage(m, col = heat.colors(36))
</code></pre>

<hr>
<h2 id='methods'>
Print and Summary Methods for Objects of Class pgrid, pp and wpp
</h2><span id='topic+print.pgrid'></span><span id='topic+print.pp'></span><span id='topic+print.wpp'></span><span id='topic+summary.pgrid'></span><span id='topic+summary.pp'></span><span id='topic+summary.wpp'></span>

<h3>Description</h3>

<p>Prints a brief description of a pixel grid or a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgrid'
print(x, ...)
## S3 method for class 'pp'
print(x, ...)
## S3 method for class 'wpp'
print(x, ...)
## S3 method for class 'pgrid'
summary(object, ...)
## S3 method for class 'pp'
summary(object, ...)
## S3 method for class 'wpp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods_+3A_x">x</code>, <code id="methods_+3A_object">object</code></td>
<td>

<p>an object of class pgrid or pp or wpp.
</p>
</td></tr>
<tr><td><code id="methods_+3A_...">...</code></td>
<td>

<p>additional arguments. Currently without effect.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there is no difference between print and summary.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a> <br />
Timo Wilm <a href="mailto:timo.wilm@stud.uni-goettingen.de">timo.wilm@stud.uni-goettingen.de</a>
</p>

<hr>
<h2 id='pgrid'>
Constructor for the pgrid Class
</h2><span id='topic+pgrid'></span>

<h3>Description</h3>

<p>Construct an object of class <code>"pgrid"</code> from a matrix or a higher-dimensional array. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pgrid(mass, boundary, gridtriple, generator, structure) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgrid_+3A_mass">mass</code></td>
<td>

<p>a matrix or higher-dimensional array specifing the masses in each pixel / at each pixel centre.
</p>
</td></tr>
<tr><td><code id="pgrid_+3A_boundary">boundary</code>, <code id="pgrid_+3A_gridtriple">gridtriple</code>, <code id="pgrid_+3A_generator">generator</code></td>
<td>

<p>arguments specifying the positions of the pixels. At most one of these can be specified.
</p>
</td></tr>
<tr><td><code id="pgrid_+3A_structure">structure</code></td>
<td>

<p>optional character string specifying the structure of the grid.
Currently only <code>"square"</code> and <code>"rectangular"</code> make sense, and are derrived automatically
from the dimensions of <code>mass</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more detailed explanations of the arguments and other components of the derived object of class <code>"pgrid"</code>, see 
<code><a href="#topic+pgrid-object">pgrid-object</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p>Description of <a href="#topic+pgrid-object">pgrid objects</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:20, 4, 5)
a &lt;- pgrid(m)
print(a)
print.default(a)

## Not run:   
  plot(a, rot=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='pgrid-object'>
Class of Pixel Grids
</h2><span id='topic+pgrid-object'></span>

<h3>Description</h3>

<p>The class <code>"pgrid"</code> (for pixel grid) represents regular quantizations of measures on
(bounded subsets of) <code class="reqn">R^d</code>. Currently only square quantizations of measures on a rectangles
are supported, which in 2-d can be thought of as grey scale images. 
</p>


<h3>Details</h3>

<p>Objects of class <code>"pgrid"</code> can be created by the function 
<code><a href="#topic+pgrid">pgrid</a></code>, and are most commonly used as input to the function
<code><a href="#topic+transport">transport</a></code>. There are methods <code><a href="#topic+plot.pgrid">plot</a></code>, <code><a href="#topic+print.pgrid">print</a></code> and
<code><a href="#topic+summary.pgrid">summary</a></code> for this class.
</p>
<p>An object of class <code>"pgrid"</code> contains the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>structure</code> </td><td style="text-align: left;">
    the structure of the grid. Currently only <code>"square"</code> and <code>"rectangular"</code> are supported.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dimension</code> </td><td style="text-align: left;">
    the dimension <code class="reqn">d</code> of the space in which the grid is embedded. Must be <code class="reqn">\geq 2</code>.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
        <code>n</code> </td><td style="text-align: left;">
    the number of pixels along the various coordinates, a vector of length <code>dimension</code>.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>N</code> </td><td style="text-align: left;">
    the total number of pixels.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>boundary</code> </td><td style="text-align: left;">
    the outer boundary of the "picture" (i.e. of the support of the measure). A vector of </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
    length <code>2*dimension</code>, where the odd entries contain the left and the even entries </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
    contain the right endpoints of the various coordinates.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gridtriple</code> </td><td style="text-align: left;">
    the rule for generating the pixel centres along the various coordinates. </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
    A <code>dim</code> by <code>3</code> matrix where each row is of the form <code>c(start, end, step)</code>.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>generators</code> </td><td style="text-align: left;">
    the pixel centres along the various coordinates. A list of length <code>dim</code> where the </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
    <code>i</code>-th element is a vector of length <code>n[i]</code>. 
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>mass</code> </td><td style="text-align: left;">
    the array of masses in each pixel / at each pixel centre. In 2-d orientation corresponds </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
    to the standard orientation of images, see e.g. <code><a href="Matrix.html#topic+image">image</a></code>. This means that </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
    pixels are arranged on coordinate axes in the order of their indices.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
  


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p>Constructor function <code><a href="#topic+pgrid">pgrid</a></code>.
</p>

<hr>
<h2 id='plot'>
Methods for Plotting Objects of Class pgrid, pp and wpp
</h2><span id='topic+plot.pgrid'></span><span id='topic+plot.pp'></span><span id='topic+plot.wpp'></span>

<h3>Description</h3>

<p>Methods for plotting objects of class pgrid, pp and wpp,
possibly together with a transference plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pgrid'
plot(x, y = NULL, tplan = NULL, mass = c("colour", "thickness"),
    length = 0.1, angle = 5, acol, bcol = 4, pcol="goldenrod2", lwd, pmass=TRUE,
    rot = FALSE, overlay = FALSE, static.mass =TRUE, ...)
  ## S3 method for class 'pp'
plot(x, y = NULL, tplan = NULL, cols = c(4, 2), cex = 0.8,
    acol = grey(0.3), lwd = 1, overlay = TRUE, ...)
  ## S3 method for class 'wpp'
plot(x, y = NULL, tplan = NULL, pmass=TRUE, tmass=TRUE, cols = c(4, 2),
    cex = 0.8, aglevel = 0.4, acol = grey(0.3), lwd = 1, overlay = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code>, <code id="plot_+3A_y">y</code></td>
<td>

<p>one or two objects of class <code>pgrid</code> or class <code>pp</code> to be plotted.
</p>
</td></tr>
<tr><td><code id="plot_+3A_tplan">tplan</code></td>
<td>

<p>a transference plan between the two objects <code>x</code> and <code>y</code>,
typically an optimal transference plan obtained by a call to <code><a href="#topic+transport">transport</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_mass">mass</code>, <code id="plot_+3A_pmass">pmass</code>, <code id="plot_+3A_tmass">tmass</code></td>
<td>

<p>for <code>pgrid</code> objects with a <code>tplan</code>:
if <code>mass == "colour"</code>, the mass transferred is depicted by heatmap colours;
if <code>mass == "thickness"</code>, it is depicted by the line widths of the arrows.<br />
For <code>wpp</code> objects:
<code>pmass, tmass</code> are logicals controlling whether the <em>amount</em> of mass
associated with the points and the mass transferred should be depicted in
the plot.
</p>
</td></tr>
<tr><td><code id="plot_+3A_length">length</code></td>
<td>

<p>the length of the arrow heads in inches.
</p>
</td></tr>
<tr><td><code id="plot_+3A_aglevel">aglevel</code></td>
<td>

<p>for <code>wpp</code> objects with <code>tmass = TRUE</code>: the grey level
chosen for depicting the transport of an average amount of mass.
</p>
</td></tr>
<tr><td><code id="plot_+3A_acol">acol</code></td>
<td>

<p>the colour of the arrows/lines of the transference plan. Ignored for <code>pgrid</code>
objects if <code>mass = "colour"</code> and for <code>wpp</code> objects if <code>tmass</code>
is <code>TRUE</code>.  
</p>
</td></tr>   
<tr><td><code id="plot_+3A_angle">angle</code></td>
<td>

<p>the angle of the arrow heads.  
</p>
</td></tr>   
<tr><td><code id="plot_+3A_bcol">bcol</code></td>
<td>

<p>the colour of the cell boundaries for a semidiscrete transport plan. Ignored
in all other instances.  
</p>
</td></tr>  
<tr><td><code id="plot_+3A_pcol">pcol</code></td>
<td>

<p>the colour of the points representing the discrete masses for a semidiscrete
transport plan. Ignored in all other instances.  
</p>
</td></tr>    
<tr><td><code id="plot_+3A_cols">cols</code></td>
<td>

<p>for <code>pp</code> objects:
A vector of size 2 specifying the colours of the two <code>pp</code> objects.
</p>
</td></tr>
<tr><td><code id="plot_+3A_cex">cex</code>, <code id="plot_+3A_lwd">lwd</code>, <code id="plot_+3A_...">...</code></td>
<td>

<p>further graphic parameters used by plot. Note that for pgrid objects
<code>acol</code> is ignored for <code>mass == "colour"</code>, and <code>lwd</code> is ignored
for <code>mass == "thickness"</code>. Setting any of these parameters is optional.
</p>
</td></tr>
<tr><td><code id="plot_+3A_rot">rot</code></td>
<td>

<p>logical. Whether the mass matrices of pgrid objects should be rotated before calling
<code><a href="Matrix.html#topic+image">image</a></code> so that the orientation of the ploted pixelgrid and the orientation
of the mass matrix are the same. Otherwise plotting follows the usual convention of
<code><a href="Matrix.html#topic+image">image</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_overlay">overlay</code></td>
<td>

<p>in the case of two objects <code>x</code> and <code>y</code> whether they should be plotted on top
of one another (for pgrid objects the difference <code>x-y</code> is plotted) or not. In the
presence of a transference plan <code>overlay</code> is forced to be true.
</p>
</td></tr>
<tr><td><code id="plot_+3A_static.mass">static.mass</code></td>
<td>

<p>for a transference plan that explicitly lists the &ldquo;static mass transports&rdquo; (i.e.
mass that stays at the same site), should these transports also be plotted as disks
with colours/sizes corresponding to the amount of mass that stays?<br />
Note that it is wrong to assume that an optimal transference plan obtained by one of
the algorithms will automatically list static mass transports. It is not the
case for <code class="reqn">p=1</code>, where static mass transport at site <code class="reqn">i</code> is trivially equal
to the minimum of source mass and target mass, and it is currently not the case
for results obtained by <code>method="aha"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for its side effect.  
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>

<hr>
<h2 id='plot_apollonius'>Plot Apollonius Diagram</h2><span id='topic+plot_apollonius'></span>

<h3>Description</h3>

<p>Plots the Apollonius diagram, a.k.a. (additively) weighted Voronoi diagram, based
on a matrix of points (centers) in 2d and their weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_apollonius(
  points,
  weights,
  show_points = TRUE,
  show_weights = TRUE,
  add_to_weights = 0,
  add = FALSE,
  col = 4,
  lwd = 1.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_apollonius_+3A_points">points</code></td>
<td>
<p>A two-column matrix containing the 2d points.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_weights">weights</code></td>
<td>
<p>A vector of weights for the points.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_show_points">show_points</code></td>
<td>
<p>Logical. Should the points be displayed in the plot?
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_show_weights">show_weights</code></td>
<td>
<p>Logical. Should the weights be displayed in the plot?
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_add_to_weights">add_to_weights</code></td>
<td>
<p>A value added to the weights to make the plot
more informative.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_add">add</code></td>
<td>
<p>Logical. Should the plot be added to the current device?
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_col">col</code></td>
<td>
<p>The colour for the cell boundaries.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_lwd">lwd</code></td>
<td>
<p>The line width for the cell boundaries.</p>
</td></tr>
<tr><td><code id="plot_apollonius_+3A_...">...</code></td>
<td>
<p>Further parameters to the base plot if <code>add</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For points <code class="reqn">x_1, \ldots, x_n</code> with weights <code class="reqn">w_1, \ldots, w_n</code>
The $i$-th cell of the Apollonius diagram contains all the points x that satisfy
</p>
<p style="text-align: center;"><code class="reqn">\|x-x_i\|-w_i &lt; \|x-x_j\|-w_j</code>
</p>
 
<p>for all  <code class="reqn">j \neq i</code>. Its boundaries are hyperbola segments.
</p>
<p>If <code>show_weights</code> is <code>TRUE</code>, grey circles of radii <code>weights + add_to_weights</code>
are plotted around the points. Negative radii are set to zero.
</p>


<h3>Note</h3>

<p>This function requires the Computational Geometry Algorithms Library (CGAL),
available at <a href="https://www.cgal.org">https://www.cgal.org</a>. Adapt the file src/Makevars according
to the instructions given there and re-install from source.
</p>


<h3>Author(s)</h3>

<p>Valentin Hartmann <a href="mailto:valentin.hartmann@epfl.ch">valentin.hartmann@epfl.ch</a> (most of the code)<br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a> (R-port)
</p>


<h3>References</h3>

<p>Menelaos Karavelas and Mariette Yvinec. 2D Apollonius Graphs 
(Delaunay Graphs of Disks). In CGAL User and Reference Manual.
CGAL Editorial Board, 4.12 edition, 2018
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
w &lt;- c(0.731, 0.0372, 0.618, 0.113, 0.395, 0.222, 0.124, 0.101, 0.328, 0)
points &lt;- matrix(runif(20), 10, 2)
plot_apollonius(points, w, add_to_weights = -0.1)
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.ut_pgrid'>Plot Unbalanced Transport Information</h2><span id='topic+plot.ut_pgrid'></span>

<h3>Description</h3>

<p>Graphic representation of components of the list returned by <code><a href="#topic+unbalanced">unbalanced</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ut_pgrid'
plot(x, what = c("plan", "extra", "trans", "inplace"), axes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ut_pgrid_+3A_x">x</code></td>
<td>
<p>the list returned by <code><a href="#topic+unbalanced">unbalanced</a></code> with option <code>output="all"</code>.</p>
</td></tr>
<tr><td><code id="plot.ut_pgrid_+3A_what">what</code></td>
<td>
<p>character. The aspect of the unbalanced transport information to display.</p>
</td></tr>
<tr><td><code id="plot.ut_pgrid_+3A_axes">axes</code></td>
<td>
<p>logical. Whether to plot axes (ignored for <code>what="plan"</code>).</p>
</td></tr>
<tr><td><code id="plot.ut_pgrid_+3A_...">...</code></td>
<td>
<p>further graphics parameters passed to <code><a href="#topic+plot.pgrid">plot.pgrid</a></code> for 
<code>what="plan"</code> and passed to <code><a href="#topic+matimage">matimage</a></code> in all other cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Used for the side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- unbalanced( random32a, random32b, p=1, C=0.2, output="all" )
plot( res, what="plan", lwd=1.5, angle=20 )
plot( res, what="trans" )
plot( res, what="extra" )
plot( res, what="inplace" )
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ut_wpp'>Plot Unbalanced Transport Information</h2><span id='topic+plot.ut_wpp'></span>

<h3>Description</h3>

<p>Graphic representation of components of the list returned by <code><a href="#topic+unbalanced">unbalanced</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ut_wpp'
plot(
  x,
  what = c("plan", "extra", "trans"),
  axes = FALSE,
  xlim = c(0, 1),
  ylim = c(0, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ut_wpp_+3A_x">x</code></td>
<td>
<p>the list returned by <code><a href="#topic+unbalanced">unbalanced</a></code> with option <code>output="all"</code>.</p>
</td></tr>
<tr><td><code id="plot.ut_wpp_+3A_what">what</code></td>
<td>
<p>character. The aspect of the unbalanced transport information to display.</p>
</td></tr>
<tr><td><code id="plot.ut_wpp_+3A_axes">axes</code></td>
<td>
<p>logical. Whether to plot axes (ignored for <code>what="plan"</code>).</p>
</td></tr>
<tr><td><code id="plot.ut_wpp_+3A_xlim">xlim</code>, <code id="plot.ut_wpp_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2. The x- and y-limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.ut_wpp_+3A_...">...</code></td>
<td>
<p>further graphics parameters passed to <code><a href="#topic+plot.pgrid">plot.pgrid</a></code> for 
<code>what="plan"</code> and passed to <code><a href="#topic+matimage">matimage</a></code> in all other cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Used for the side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(33)
m &lt;- 50
n &lt;- 20
massa &lt;- rexp(m)
massb &lt;- rexp(n)
a &lt;- wpp( matrix(runif(2*m), m, 2), massa)
b &lt;- wpp( matrix(runif(2*n), n, 2), massb)
res &lt;- unbalanced(a,b,1,0.3,output="all")
plot(res, what="plan")
plot(res, what="trans")
plot(res, what="extra")
## End(Not run)
</code></pre>

<hr>
<h2 id='power_diagram'>
Compute the Power Diagram of Weighted Sites in 2-Dimensional Space
</h2><span id='topic+power_diagram'></span><span id='topic+plot.power_diagram'></span>

<h3>Description</h3>

<p>Compute the power diagram of weighted sites in 2-dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_diagram(xi, eta, w, rect = NA)
## S3 method for class 'power_diagram'
plot(x, weights=FALSE, add=FALSE, col=4, lwd=1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_diagram_+3A_xi">xi</code>, <code id="power_diagram_+3A_eta">eta</code>, <code id="power_diagram_+3A_w">w</code></td>
<td>

<p>vectors of equal length, where <code>xi</code>, <code>eta</code> are the coordinates of the sites and <code>w</code> are the corresponding weights.
</p>
</td></tr>
<tr><td><code id="power_diagram_+3A_rect">rect</code></td>
<td>

<p>vetor of length <code>4</code>. To get a finite representation of the power diagram, it will be intersected with the rectangle 
<code class="reqn">[rect[1],rect[2]] \times [rect[3],rect[4]]</code>. Defaults to <code>c(min(xi),max(xi),min(eta),max(eta))</code>.
</p>
</td></tr>
<tr><td><code id="power_diagram_+3A_x">x</code></td>
<td>

<p>a power diagram as returned from <code><a href="#topic+power_diagram">power_diagram</a></code>.
</p>
</td></tr>
<tr><td><code id="power_diagram_+3A_weights">weights</code></td>
<td>

<p>logical. If <code>TRUE</code>, weights of non-redundant sites with non-negative weight are represented as circles whose radii
are equal to the square roots of the corresponding weights.
</p>
</td></tr>
<tr><td><code id="power_diagram_+3A_add">add</code></td>
<td>

<p>logical. Should the power diagram be plotted on top of current graphics?
</p>
</td></tr>
<tr><td><code id="power_diagram_+3A_col">col</code></td>
<td>

<p>the color of the cell boundaries.
</p>
</td></tr>
<tr><td><code id="power_diagram_+3A_lwd">lwd</code>, <code id="power_diagram_+3A_...">...</code></td>
<td>

<p>further arguments graphic parameters used by <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>power_diagram</code> implements an algorithm by Edelsbrunner and Shah (1996) which computes 
regular triangulations and thus its dual representation, the power diagram. For point location, an algorithm 
devised by Devillers (2002) is used.
</p>


<h3>Author(s)</h3>

<p>Björn Bähre <a href="mailto:bjobae@gmail.com">bjobae@gmail.com</a> <br />
(slightly modified by Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>)
</p>


<h3>References</h3>

<p>H. Edelsbrunner, N. R. Shah (1996), Incremental Topological Flipping Works for Regular Triangulations, Algorithmica 15, 223&ndash;241.
</p>
<p>O. Devillers (2002), The Delaunay Hierarchy, International Journal of Foundations of Computer Science 13, 163&ndash;180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    xi &lt;- runif(100)
    eta &lt;- runif(100)
    w &lt;- runif(100,0,0.005)
    x &lt;- power_diagram(xi,eta,w,rect=c(0,1,0,1))
    plot(x,weights=TRUE)
</code></pre>

<hr>
<h2 id='pp'>
Constructor for the pp Class
</h2><span id='topic+pp'></span>

<h3>Description</h3>

<p>Construct an object of class <code>"pp"</code> from a matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pp(coordinates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_+3A_coordinates">coordinates</code></td>
<td>

<p>a matrix specifying the coordinates of the points. Each row corresponds to a point.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more detailed explanations of the arguments and other components of the derived object of class <code>"pp"</code>, see 
<code><a href="#topic+pp-object">pp-object</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p>Description of <a href="#topic+pp-object">pp objects</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1,1,2,2,3,1,4,2),4,2)
a &lt;- pp(m)
print(a)
print.default(a)

## Not run:   
  plot(a)
## End(Not run)
</code></pre>

<hr>
<h2 id='pp-object'>
Class of (Unweighted) Point Patterns
</h2><span id='topic+pp-object'></span>

<h3>Description</h3>

<p>The class <code>"pp"</code> represents discrete measures with some fixed mass at any of finitely many locations.
</p>


<h3>Details</h3>

<p>Objects of class <code>"pp"</code> may be created by the function 
<code><a href="#topic+pp">pp</a></code>, and are most commonly used as input to the function
<code><a href="#topic+transport">transport</a></code>. There are methods <code><a href="#topic+plot.pp">plot</a></code>, <code><a href="#topic+print.pp">print</a></code> and
<code><a href="#topic+summary.pp">summary</a></code> for this class.
</p>
<p>An object of class <code>"pp"</code> contains the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>dimension</code> </td><td style="text-align: left;">
    the dimension of the Euclidean space in which the patterns live. Must be <code class="reqn">\geq 2</code>.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>N</code> </td><td style="text-align: left;">
    the total number of points.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coordinates</code> </td><td style="text-align: left;">
    the coordinates of the points. An <code>N</code> <code class="reqn">\times</code> <code>dimension</code> matrix, where each row
    corresponds to a point.
  </td>
</tr>

</table>
  


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p>Constructor function <code><a href="#topic+pp">pp</a></code>.
</p>

<hr>
<h2 id='random'>
Images to Illustrate the Use of transport.pgrid
</h2><span id='topic+random32'></span><span id='topic+random64'></span><span id='topic+random128'></span><span id='topic+random32a'></span><span id='topic+random32b'></span><span id='topic+random64a'></span><span id='topic+random64b'></span><span id='topic+random128a'></span><span id='topic+random128b'></span>

<h3>Description</h3>

<p>32 x 32, 64 x 64 and 128 x 128 images to illustrate the use of <code><a href="#topic+transport.pgrid">transport.pgrid</a></code>. These are objects of 
class <code>"pgrid"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random32a

random32b

random64a

random64b

random128a

random128b
</code></pre>


<h3>Format</h3>

<p>Objects of class &lsquo;pgrid&rsquo;.
</p>


<h3>Source</h3>

<p>Randomly generated using the package <code>RandomFields</code>.
</p>

<hr>
<h2 id='ret_message'>Return Text Strings for lbfgs Return Codes</h2><span id='topic+ret_message'></span>

<h3>Description</h3>

<p>Given a vector of return codes, give back the corresponding vector of 
return strings from the lbfgs library. Nonexistant codes are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ret_message(n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ret_message_+3A_n">n</code></td>
<td>
<p>The vector of return codes or <code>NULL</code> meaning the whole list
shall be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of the corresponding return strings.
</p>


<h3>Note</h3>

<p>Code 0 is ignored, since for technical reasons it is never returned by
the function <code><a href="#topic+semidiscrete1">semidiscrete1</a></code>.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semidiscrete1">semidiscrete1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ret_message()
ret_message(c(2,-1023,-1019))

</code></pre>

<hr>
<h2 id='semidiscrete'>
Find Optimal Transport Partition Between pgrid and wpp.
</h2><span id='topic+semidiscrete'></span>

<h3>Description</h3>

<p>Given an object <code>a</code> of class <code><a href="#topic+pgrid-object">pgrid</a></code> specifying an image and an object <code>b</code>
of class <code><a href="#topic+wpp-object">wpp</a></code> specifiying a more flexible mass distribution at finitely many points,
find the partition of the image (and hence the optimal transport map) that minimizes the total transport cost
for going from <code>a</code> to <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  semidiscrete(a, b, p = 2, method = c("aha"), control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semidiscrete_+3A_a">a</code></td>
<td>

<p>an object of class <code><a href="#topic+pgrid-object">pgrid</a></code> usually representing an image or the discretization of a measure.
</p>
</td></tr>
<tr><td><code id="semidiscrete_+3A_b">b</code></td>
<td>

<p>an object of class <code><a href="#topic+wpp-object">wpp</a></code> usually having the same total mass as <code>a</code>.   	
</p>
</td></tr>
<tr><td><code id="semidiscrete_+3A_p">p</code></td>
<td>

<p>the power <code class="reqn">\geq 1</code> to which the Euclidean distance between points is taken in order
to compute costs. Only <code class="reqn">p \in \{1,2\}</code> is implemented.
</p>
</td></tr>
<tr><td><code id="semidiscrete_+3A_method">method</code></td>
<td>

<p>the name of the algorithm to use. Currently only <code>aha</code> is supported.
</p>
</td></tr>
<tr><td><code id="semidiscrete_+3A_control">control</code></td>
<td>

<p>a named list of parameters for the chosen method or the result of a call to <code><a href="#topic+trcontrol">trcontrol</a></code>. Currently only
the parameters <code>factr</code> and <code>maxit</code> can be set.
</p>
</td></tr>
<tr><td><code id="semidiscrete_+3A_...">...</code></td>
<td>

<p>currently without effect.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for the functions <code><a href="#topic+aha">aha</a></code> and <code><a href="#topic+semidiscrete1">semidiscrete1</a></code>. In the former the
Aurenhammer&ndash;Hoffmann&ndash;Aronov (1998) method for <code class="reqn">p=2</code> is implemented in the multiscale variant presented
in Mérigot (2011). In the latter an adapted Aurenhammer&ndash;Hoffmann&ndash;Aronov method for <code class="reqn">p=1</code> is used that
was presented in Hartmann and Schuhmacher (2018).
</p>
<p>The present function is automatically called by <code><a href="#topic+transport">transport</a></code> if the
first argument is of class <code>pgrid</code> and the second argument is of class <code>wpp</code>.
</p>


<h3>Value</h3>

<p>An object describing the optimal transport partition for <code>a</code> and <code>b</code>.
</p>
<p>If <code>p=1</code> an object of class <code>apollonius_diagram</code> having components <code>sites</code> and <code>weights</code>,
as well as (optionally) <code>wasserstein_dist</code> and <code>ret_code</code> (the return code from the call to
<code><a href="#topic+semidiscrete1">semidiscrete1</a></code>).
</p>
<p>If <code>p=2</code> an objectof class <code>power_diagram</code> having components <code>sites</code> and <code>cells</code>,
as well as (optionally) <code>wasserstein_dist</code>. <code>sites</code> is here a data.frame with columns <code>xi</code>,
<code>eta</code> and <code>w</code> (the weights for the power diagram). <code>cells</code> is a list with as many
2-column matrix components as there are sites, each describing the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates
of the polygonal cell associated with the corresponding site or <code>NULL</code> if the cell of the site is empty.
</p>
<p>Plotting methods exist for objects of class <code>apollonius_diagram</code>, <code>power_diagram</code> and
for <a href="#topic+plot.pgrid">optimal transport maps represented by either of the two</a>.
</p>


<h3>Note</h3>

<p>For <code>p=1</code> this function requires the Computational Geometry Algorithms Library (CGAL), available at <a href="https://www.cgal.org">https://www.cgal.org</a>. Adapt the file src/Makevars according to the instructions given there and re-install from source.
</p>
<p>Internally the code from liblbfgs 1.10 by Naoaki Okazaki (2010) is used.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a> <br />  
Björn Bähre <a href="mailto:bjobae@gmail.com">bjobae@gmail.com</a> <br />  
Valentin Hartmann <a href="mailto:valentin.hartmann@epfl.ch">valentin.hartmann@epfl.ch</a>
</p>


<h3>References</h3>

<p>F. Aurenhammer, F. Hoffmann and B. Aronov (1998). Minkowski-type theorems and least-squares clustering. Algorithmica 20(1), 61&ndash;76.
</p>
<p>V. Hartmann and D. Schuhmacher (2017). Semi-discrete optimal transport &mdash; the case p=1. Preprint <a href="https://arxiv.org/abs/1706.07650">arXiv:1706.07650</a>
</p>
<p>M. Karavelas and M. Yvinec. 2D Apollonius Graphs 
(Delaunay Graphs of Disks). In CGAL User and Reference Manual.
CGAL Editorial Board, 4.12 edition, 2018
</p>
<p>Q. Mérigot (2011). A multiscale approach to optimal transport. Computer Graphics Forum 30(5), 1583&ndash;1592. <a href="https://doi.org/10.1111/j.1467-8659.2011.02032.x">doi:10.1111/j.1467-8659.2011.02032.x</a>
</p>
<p>Naoaki Okazaki (2010). libLBFGS: a library of Limited-memory
Broyden-Fletcher-Goldfarb-Shanno (L-BFGS). Version 1.10
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pgrid">plot</a></code>, <code><a href="#topic+transport">transport</a></code>, <code><a href="#topic+aha">aha</a></code>, <code><a href="#topic+semidiscrete1">semidiscrete1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  See examples for function transport</code></pre>

<hr>
<h2 id='semidiscrete1'>Compute Semidiscrete Optimal Transport for Euclidean Distance Cost</h2><span id='topic+semidiscrete1'></span>

<h3>Description</h3>

<p>Computes the weight vector of the Apollonius diagram describing the semidiscrete
optimal transport plan for the Euclidean distance cost function and the associated
Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semidiscrete1(
  source,
  target,
  xrange = c(0, 1),
  yrange = c(0, 1),
  verbose = FALSE,
  reg = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semidiscrete1_+3A_source">source</code></td>
<td>
<p>A matrix specifing the source measure.</p>
</td></tr>
<tr><td><code id="semidiscrete1_+3A_target">target</code></td>
<td>
<p>A three-column matrix specifing the target measure in the form
x-coordinate, y-coordinate, mass.</p>
</td></tr>
<tr><td><code id="semidiscrete1_+3A_xrange">xrange</code>, <code id="semidiscrete1_+3A_yrange">yrange</code></td>
<td>
<p>Vectors with two components defining the window on which 
the source measure lives. Defaults to <code class="reqn">[0,1] \times [0,1]</code>.
<code>source</code> is interpreted as an image of equally sized quadratic pixels
on this window.</p>
</td></tr>
<tr><td><code id="semidiscrete1_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Shall information about multiscale progress and L-BFGS return
codes be printed?</p>
</td></tr>
<tr><td><code id="semidiscrete1_+3A_reg">reg</code></td>
<td>
<p>A non-negative regularization parameter. It is usually not
necessary to deviate from the default 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list describing the solution. The components are
</p>
<table>
<tr><td><code>weights</code></td>
<td>
<p>A vector of length equal to the first dimension of <code>target</code>
containing the weights for the Apollonius diagram discribing the
optimal semidiscrete transport from source to target.</p>
</td></tr>
<tr><td><code>wasserstein_dist</code></td>
<td>
<p>The <code class="reqn">L_1</code>-Wasserstein distance between source and target.</p>
</td></tr>
<tr><td><code>ret_code</code></td>
<td>
<p>A return code. Equal to 1 if everything is OK, since our code
interrupts the usual lbfgs code. Other values can be converted to the
corresponding return message by using <code><a href="#topic+ret_message">ret_message</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the Computational Geometry Algorithms Library (CGAL),
available at <a href="https://www.cgal.org">https://www.cgal.org</a>. Adapt the file src/Makevars according
to the instructions given there and re-install from source.
</p>
<p>Internally the code from liblbfgs 1.10 by Naoaki Okazaki (2010) is used.
See <a href="http://www.chokkan.org/software/liblbfgs/">http://www.chokkan.org/software/liblbfgs/</a>.
</p>
<p>A stand-alone version of the C++ code of this function is available
at <a href="https://github.com/valentin-hartmann-research/semi-discrete-transport">https://github.com/valentin-hartmann-research/semi-discrete-transport</a>.
</p>


<h3>Author(s)</h3>

<p>Valentin Hartmann <a href="mailto:valentin.hartmann@epfl.ch">valentin.hartmann@epfl.ch</a> (stand-alone C++ code)<br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a> (R-port)
</p>


<h3>References</h3>

<p>V. Hartmann and D. Schuhmacher (2017).
Semi-discrete optimal transport &mdash; the case p=1.
Preprint <a href="https://arxiv.org/abs/1706.07650">arXiv:1706.07650</a>
</p>
<p>Menelaos Karavelas and Mariette Yvinec. 2D Apollonius Graphs 
(Delaunay Graphs of Disks). In CGAL User and Reference Manual.
CGAL Editorial Board, 4.12 edition, 2018
</p>
<p>Naoaki Okazaki (2010). libLBFGS: a library of Limited-memory
Broyden-Fletcher-Goldfarb-Shanno (L-BFGS). Version 1.10
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ret_message">ret_message</a></code>, <code><a href="#topic+semidiscrete">semidiscrete</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# the following function rotates a matrix m clockwise, so
# that image(rococlock(m)) has the same orientation as print(m):
roclock &lt;- function(m) t(m)[, nrow(m):1]

set.seed(30)
n &lt;- 20
nu &lt;- matrix(c(runif(2*n), rgamma(n,3,1)), n, 3)
pixelbdry &lt;- seq(0,1,length=33)
image(pixelbdry, pixelbdry, roclock(random32a$mass), asp=1, col = grey(seq(0,1,length.out=32)))
points(nu[,1], nu[,2], pch=16, cex=sqrt(nu[,3])/2, col=2)

res &lt;- semidiscrete1(random32a$mass, nu)
plot_apollonius(nu[,1:2], res$weights, show_weights = FALSE, add = TRUE)
points(nu[,1], nu[,2], pch=16, cex=sqrt(nu[,3])/2, col=2)
## End(Not run)


</code></pre>

<hr>
<h2 id='shielding'>Compute Optimal Transport (Cost/Plan) Using the Multiscale Shielding Method</h2><span id='topic+shielding'></span>

<h3>Description</h3>

<p>Runs the multiscale version of the Shielding Method (a.k.a. Short Cut Method) for computing the optimal transport
(cost/plan) on a rectangular grid in <code class="reqn">d</code> dimensions for the squared Euclidean distance as cost function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shielding(
  a,
  b,
  nscales = 2,
  startscale = 1,
  flood = 0,
  measureScale = 1e-06,
  verbose = FALSE,
  basisKeep = 1,
  basisRefine = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shielding_+3A_a">a</code>, <code id="shielding_+3A_b">b</code></td>
<td>
<p>arrays with <code class="reqn">d</code> coordinates representing source and target measure, respectively.
The entries must be all positive.</p>
</td></tr>
<tr><td><code id="shielding_+3A_nscales">nscales</code></td>
<td>
<p>the number of scales generated in the multiscale algorithm.</p>
</td></tr>
<tr><td><code id="shielding_+3A_startscale">startscale</code></td>
<td>
<p>the first scale on which the problem is solved.</p>
</td></tr>
<tr><td><code id="shielding_+3A_flood">flood</code></td>
<td>
<p>a real number. If positive, take the maximum of entry and <code>flood</code> for each
entry of <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code id="shielding_+3A_measurescale">measureScale</code></td>
<td>
<p>the required precision for the entries. Computations are performed on
<code>round(a/measureScale)</code> and the same for <code>b</code> using integer arithmetics.</p>
</td></tr>
<tr><td><code id="shielding_+3A_verbose">verbose</code></td>
<td>
<p>logical. Toggles output to the console about the progress of the algorithm.</p>
</td></tr>
<tr><td><code id="shielding_+3A_basiskeep">basisKeep</code>, <code id="shielding_+3A_basisrefine">basisRefine</code></td>
<td>
<p>internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>a</code> and <code>b</code> do not have the same sum, they are normalized to sum 1 <em>before</em>
<code>flood</code> and <code>measureScale</code> transformations are applied.
</p>


<h3>Value</h3>

<p>A list of components
</p>
<table>
<tr><td><code>err</code></td>
<td>
<p>error code. 0 if everything is ok.</p>
</td></tr> 
<tr><td><code>a_used</code>, <code>b_used</code></td>
<td>
<p>the vectorized arrays that were actually used by the algorithm. <code>a</code>, <code>b</code> after
applying <code>flood</code> and <code>measureScale</code>.</p>
</td></tr>  
<tr><td><code>coupling</code></td>
<td>
<p>a vectorized coupling describing the optimal transport from a_used to b_used</p>
</td></tr>
<tr><td><code>basis</code></td>
<td>
<p>a matrix with two columns describing the basis obtained for the optimal transport</p>
</td></tr>
<tr><td><code>u</code>, <code>v</code></td>
<td>
<p>vectors of optimal values in the dual problem</p>
</td></tr>
</table>


<h3>Use of CPLEX</h3>

<p>For larger problems (thousands of grid points) there are considerable speed improvements when <code>shielding</code>
can use the CPLEX numerical solver for the underlying constrained optimization problems.
If a local installation of CPLEX is available, the transport package can be linked against it during installation.
See the file src/Makevars in the source package for instructions.
</p>


<h3>Author(s)</h3>

<p>Bernhard Schmitzer <a href="mailto:schmitzer@uni-muenster.de">schmitzer@uni-muenster.de</a> and<br />
Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a><br />
(based on C++ code by Bernhard Schmitzer)
</p>


<h3>References</h3>

<p>B. Schmitzer (2016). A sparse multiscale algorithm for dense optimal transport. J. Math. Imaging Vision 56(2), 238&ndash;259. <a href="https://arxiv.org/abs/1510.05466">https://arxiv.org/abs/1510.05466</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transport">transport</a></code>, which calls this function if appropriate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
shielding(random64a$mass,random64b$mass,nscales=6,measureScale=1) 
## End(Not run)

</code></pre>

<hr>
<h2 id='starting+20solutions'>
Compute starting solution for the transportation problem
</h2><span id='topic+northwestcorner'></span><span id='topic+russell'></span>

<h3>Description</h3>

<p>Compute a feasible transference plan between two mass vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>northwestcorner(a, b)
russell(a, b, costm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="starting+2B20solutions_+3A_a">a</code>, <code id="starting+2B20solutions_+3A_b">b</code></td>
<td>

<p>Two numeric vectors (typically containing natural numbers) of length <code class="reqn">m</code> and <code class="reqn">n</code>, describing mass distributions.
</p>
</td></tr>
<tr><td><code id="starting+2B20solutions_+3A_costm">costm</code></td>
<td>

<p>A <code class="reqn">m</code> by <code class="reqn">n</code> matrix of costs for moving one unit of mass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose components are <code class="reqn">m</code> by <code class="reqn">n</code> matrices, viz.
</p>
<table>
<tr><td><code>assignment</code></td>
<td>
<p>containing as <code class="reqn">(i,j)</code>-th entry the mass assigned from origin <code class="reqn">i</code> to destination <code class="reqn">j</code>;</p>
</td></tr>
<tr><td><code>basis</code></td>
<td>
<p>containing as <code class="reqn">(i,j)</code>-th entry a <code class="reqn">1</code> if it is a basic entry and a <code class="reqn">0</code> otherwise.</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>The current implementations are in R. Computations may be slow for larger vectors <code>a</code> and <code>b</code>.<br />
The computed starting solution may be degenerate, i.e. there may be basic entries where zero mass is assigned.</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transport">transport</a></code>
</p>

<hr>
<h2 id='subwasserstein'>Approximate Computation of Wasserstein Distances via Subsampling.</h2><span id='topic+subwasserstein'></span>

<h3>Description</h3>

<p>Samples <code>S</code> elements each of a source and a target measure and
computes the Wasserstein distance between the samples.
The mean distance out of <code>K</code> tries is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subwasserstein(
  source,
  target,
  S,
  K = 1,
  p = 1,
  costM = NULL,
  prob = TRUE,
  precompute = FALSE,
  method = "networkflow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subwasserstein_+3A_source">source</code></td>
<td>
<p>The source measure has to be either a weight vector or an object
of one of the classes <code>"pgrid"</code>, <code>"wpp"</code> or <code>"pp"</code>.</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_target">target</code></td>
<td>
<p>The target measure needs to be of the same type as the source measure.</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_s">S</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_k">K</code></td>
<td>
<p>The number of tries. Defaults to 1.</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_p">p</code></td>
<td>
<p>The order of the Wasserstein metric (i.e. the power of the distances). Defaults to 1.</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_costm">costM</code></td>
<td>
<p>The cost matrix between the source and target measures. Ignored unless source
and target are weight vectors.</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_prob">prob</code></td>
<td>
<p>logical. Should the objects a, b be interpreted as probability measures, i.e. their
total mass be normalized to 1?</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_precompute">precompute</code></td>
<td>
<p>logical. Should the cost matrix for the large problem be precomputed?</p>
</td></tr>
<tr><td><code id="subwasserstein_+3A_method">method</code></td>
<td>
<p>A string with the name of the method used for optimal transport distance computation.
Options are &quot;revsimplex&quot;, &quot;shortsimplex&quot; and &quot;primaldual&quot;. Defaults to &quot;revsimplex&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For larger problems setting <code>precompute</code> to <code>TRUE</code> is not recommended.
</p>


<h3>Value</h3>

<p>The mean of the K values of the Wasserstein distances between
the subsampled measures.
</p>


<h3>Author(s)</h3>

<p>Jörn Schrieber <a href="mailto:joern.schrieber-1@mathematik.uni-goettingen.de">joern.schrieber-1@mathematik.uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>M. Sommerfeld, J. Schrieber, Y. Zemel and A. Munk (2018)
Optimal Transport: Fast Probabilistic Approximation with Exact Solvers
preprint: <a href="https://arxiv.org/abs/1802.05570">arXiv:1802.05570</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
subwasserstein(random64a, random64b, S=1000)
wasserstein(random64a, random64b)

## End(Not run)

</code></pre>

<hr>
<h2 id='transport'>
Find Optimal Transport Plan Between Two Objects
</h2><span id='topic+transport'></span><span id='topic+transport.default'></span><span id='topic+transport.pgrid'></span><span id='topic+transport.pp'></span><span id='topic+transport.wpp'></span>

<h3>Description</h3>

<p>Given two objects <code>a</code> and <code>b</code> that specify distributions of mass and an object that specifies (a way to compute) costs,
find the transport plan for going from <code>a</code> to <code>b</code> that minimizes the total cost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport(a, b, ...)
## Default S3 method:
transport(a, b, costm, method = c("networkflow", "shortsimplex", "revsimplex",
"primaldual"), fullreturn=FALSE, control = list(), threads=1, ...)
## S3 method for class 'pgrid'
transport(a, b, p = NULL, method = c("auto", "networkflow", "revsimplex", "shortsimplex",
  "shielding", "aha", "primaldual"), fullreturn=FALSE,
  control = list(), threads=1,...)
## S3 method for class 'pp'
transport(a, b, p = 1, method = c("auction", "auctionbf", "networkflow", "shortsimplex",
  "revsimplex", "primaldual"), fullreturn=FALSE, control = list(), threads=1, ...)
## S3 method for class 'wpp'
transport(a, b, p = 1, method = c("networkflow", "revsimplex", "shortsimplex",
  "primaldual"), fullreturn=FALSE, control = list(), threads=1, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transport_+3A_a">a</code>, <code id="transport_+3A_b">b</code></td>
<td>

<p>two objects that describe mass distributions, between which the optimal transport map is to be computed. For the default
method these are vectors of non-negative values. For the other three methods these are objects of the respective classes.
It is also possible to have <code>a</code> of class <code>pgrid</code> and <code>b</code> of class <code>wpp</code>.
</p>
</td></tr>
<tr><td><code id="transport_+3A_costm">costm</code></td>
<td>

<p>for the default method a <code>length(a)</code> by <code>length(b)</code> matrix specifying the cost of transporting single
units of mass between the corresponding source and destination points. 
</p>
</td></tr>
<tr><td><code id="transport_+3A_p">p</code></td>
<td>

<p>for the three specialized methods the power <code class="reqn">\geq 1</code> to which the Euclidean distance between points is taken in order
to compute costs.
</p>
</td></tr>
<tr><td><code id="transport_+3A_method">method</code></td>
<td>

<p>the name of the algorithm to use. See details below.
</p>
</td></tr>
<tr><td><code id="transport_+3A_fullreturn">fullreturn</code></td>
<td>

<p>A boolean specifying whether the output of the function should also include the dual solution, the optimal transport cost between a and b and the transport plan in matrix form should be returned as well.
</p>
</td></tr>
<tr><td><code id="transport_+3A_control">control</code></td>
<td>

<p>a named list of parameters for the chosen method or the result of a call to <code><a href="#topic+trcontrol">trcontrol</a></code>. Any parameters
that are not set by the control argument will get reasonable (sometimes problem specific) defaults.
</p>
</td></tr>
<tr><td><code id="transport_+3A_threads">threads</code></td>
<td>
<p> An Integer specifying the number of threads used in parallel computing. Currently only
available for the method &quot;networkflow&quot;.</p>
</td></tr>
<tr><td><code id="transport_+3A_...">...</code></td>
<td>

<p>currently without effect.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a number of algorithms that are currently implemented and more will be added in future versions of the package. 
The following is a brief description of each key word used. Much more details can be found in the cited references 
and in a forthcoming package vignette.
</p>
<p><code>aha</code>: The Aurenhammer&ndash;Hoffmann&ndash;Aronov (1998) method with the multiscale approach presented in Mérigot (2011). The original theory was limited to <code class="reqn">p=2</code>. We refer by <code>aha</code> also to the extension of the same idea for <code class="reqn">p=1</code> as presented in Hartmann and Schuhmacher (2017) and for more general <code class="reqn">p</code> (currently not implemented).
</p>
<p><code>auction</code>: The auction algorithm by Bertsekas (1988) with epsilon-scaling, see Bertsekas (1992).
</p>
<p><code>auctionbf</code>: A refined auction algorithm that combines forward and revers auction, see Bertsekas (1992).
</p>
<p><code>networkflow</code>: The fast implementation of the network simplex algorithm by Nicolas Bonneel based on the LEMON Library (see citations below).
</p>
<p><code>primaldual</code>: The primal-dual algorithm as described in Luenberger (2003, Section 5.9).
</p>
<p><code>revsimplex</code>: The revised simplex algorithm as described in Luenberger and Ye (2008, Section 6.4) with various speed improvements, including a multiscale approach.
</p>
<p><code>shielding</code>: The shielding (or shortcut) method, as described in Schmitzer (2016).
</p>
<p><code>shortsimplex</code>: The shortlist method based an a revised simplex algorithm, as described in Gottschlich and Schuhmacher (2014).
</p>
<p>The order of the <em>default</em> key words specified for the argument <code>method</code> gives a rough idea of the relative efficiency of the algorithms for the corresponding class of objects. For a given <code>a</code> and <code>b</code> the actual computation times may deviate significantly from this order.
For class <code>pgrid</code> the default method is <code>"auto"</code>, which resolves to <code>"revsimplex"</code> if <code>p</code> is not 2 or the problem is very small, and to <code>"shielding"</code> otherwise.
</p>
<p>The following table gives information about the applicability of the various algorithms (or sometimes rather
their current implementations).
</p>

<table>
<tr>
 <td style="text-align: left;">
  	                 </td><td style="text-align: left;"> default </td><td style="text-align: left;"> pgrid </td><td style="text-align: left;">  pp  </td><td style="text-align: left;">  wpp   </td>
</tr>
<tr>
 <td style="text-align: left;">
  	aha (p=1 or 2!)  </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   @   </td>
</tr>
<tr>
 <td style="text-align: left;">
    auction          </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   -   </td>
</tr>
<tr>
 <td style="text-align: left;">
    auctionbf        </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   -   </td>
</tr>
<tr>
 <td style="text-align: left;">
    networkflow      </td><td style="text-align: left;">   +     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   +   </td>
</tr>
<tr>
 <td style="text-align: left;">  
    primaldual       </td><td style="text-align: left;">   *     </td><td style="text-align: left;">   *   </td><td style="text-align: left;">   *   </td><td style="text-align: left;">   +   </td>
</tr>
<tr>
 <td style="text-align: left;">  
    revsimplex       </td><td style="text-align: left;">   +     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   *   </td><td style="text-align: left;">   +   </td>
</tr>
<tr>
 <td style="text-align: left;">      
    shielding (p=2!) </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   -   </td>
</tr>
<tr>
 <td style="text-align: left;">
    shortsimplex     </td><td style="text-align: left;">   +     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   *   </td><td style="text-align: left;">   +   </td>
</tr>
<tr>
 <td style="text-align: left;">  
  </td>
</tr>

</table>
 
<p>where: + recommended, * applicable (may be slow), - no implementation planned or combination does not make sense; @ indicates that the aha algorithm is available in the special combination where <code>a</code> is a <code>pgrid</code> object and <code>b</code> is a <code>wpp</code> object (and <code>p</code> is 2). For more details on this combination see the function <code><a href="#topic+semidiscrete">semidiscrete</a></code>.   
</p>
<p>Each algorithm has certain parameters supplied by the <code>control</code> argument. The following table gives an overview of parameter names and 
their applicability.
</p>

<table>
<tr>
 <td style="text-align: left;">
  	                               </td><td style="text-align: left;"> <code>start</code> </td><td style="text-align: left;"> multiscale </td><td style="text-align: left;"> individual parameters    </td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>aha</code> (<code class="reqn">p=2</code>!)        </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">   <code>factr</code>, <code>maxit</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">  	                        
  	<code>auction</code>                 </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   <code>lasteps</code>, <code>epsfac</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>auctionbf</code>               </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   <code>lasteps</code>, <code>epsfac</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>networkflow</code>             </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">      </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>primaldual</code>              </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">      </td>
</tr>
<tr>
 <td style="text-align: left;">
  	<code>revsimplex</code>              </td><td style="text-align: left;">   +     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">      </td>
</tr>
<tr>
 <td style="text-align: left;">  
  	<code>shielding</code> (<code class="reqn">p=2</code>!)  </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   +   </td><td style="text-align: left;">      </td>
</tr>
<tr>
 <td style="text-align: left;">  
    <code>shortsimplex</code>            </td><td style="text-align: left;">   -     </td><td style="text-align: left;">   -   </td><td style="text-align: left;">   <code>slength</code>, <code>kfound</code>, <code>psearched</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">  
  </td>
</tr>

</table>
 
<p><code>start</code> specifies the algorithm for computing a starting solution (if needed). Currently the Modified Row Minimum Rule
(<code>start="modrowmin"</code>), the North-West Corner Rule (<code>start="nwcorner"</code>) and the method by Russell (1969) (<code>start="russell"</code>)
are implemented. When <code>start="auto"</code> (the default) the ModRowMin Rule is chosen. However,
for <code>transport.pgrid</code> and <code>p</code> larger than 1, there are two cases where an automatic multiscale procedure is also performed, i.e. the optimal transport is first computed on coarser grids and information from these solutions is then used for the finer girds.
This happens for 
<code>method = "revsimplex"</code>, where a single coarsening at factor <code>scmult=2</code> is performed, and for <code>method = "shielding"</code>, where a number of coarsenings adapted to the dimensions of the array is performed.   
</p>
<p>For <code>p=1</code> and <code>method="revsimplex"</code>, as well as <code>p=2</code> and <code>method="aha"</code> there are multiscale versions of
the corresponding algorithms that allows for finer control via the parameters
<code>nscales</code>, <code>scmult</code> and <code>returncoarse</code>. The default value of <code>nscales=1</code> suppresses
the multiscale version. For larger problems it is advisable to use the multiscale version, which currently is only implemented for
square pgrids in two dimensions. The algorithm proceeds then by coarsening the pgrid <code>nscales-1</code> times, summarizing
each time <code>scmult^2</code> pixels into one larger pixels, and then solving the various transport problems starting from the coarsest and
using each previous problem to compute a starting solution to the next finer problem. If <code>returncoarse</code> is <code>TRUE</code>, the coarser
problems and their solutions are returned as well (<code>revsimplex</code> only).
</p>
<p><code>factr</code>, <code>maxit</code> are the corresponding components of the <code>control</code> argument in the <code><a href="stats.html#topic+optim">optim</a></code> L-BFGS-B method.
</p>
<p><code>lasteps</code>, <code>epsfac</code> are parameters used for epsilon scaling in the auction algortihm. The algorithm starts with a &ldquo;transaction cost&rdquo; per bid of <code>epsfac^k * lasteps</code> for some reasonable <code>k</code> generating finer and finer approximate solutions as the <code>k</code> counts down to zero. Note that in order for the procedure to make sense, <code>epsfac</code> should be larger than one (typically two- to three-digit) and in order for the final solution to be exact <code>lasteps</code> should be smaller than <code>1/n</code>, where <code>n</code> is the total number of points in either of the point patterns.
<code>slength</code>, <code>kfound</code>, <code>psearched</code> are the shortlist length, the number of pivot candidates needed, and the percentage of
shortlists searched, respectively.
</p>


<h3>Value</h3>

<p>A data frame with columns <code>from</code>, <code>to</code> and <code>mass</code> that specifies from which element of <code>a</code> to which element of <code>b</code> what amount of mass is sent in the optimal transport plan. For class <code>pgrid</code> elements are specified as vector indices in terms of the usual column major enumeration of the matrices <code>a$mass</code> and <code>b$mass</code>. There are <code><a href="#topic+plot.pgrid">plot</a></code> methods for the classes <code>pgrid</code> and <code>pp</code>, which can plot this solution.
</p>
<p>If <code>returncoarse</code> is <code>TRUE</code> for the <code>revsimplex</code> method, a list with components <code>sol</code> and <code>prob</code> giving the solutions and problems on the various scales considered. The solution on the finest scale (i.e. the output we obtain when setting <code>returncoarse</code> to <code>FALSE</code>) is in <code>sol[[1]]</code>.
</p>
<p>If <code>a</code> is of class <code>pgrid</code> and <code>b</code> of class <code>wpp</code> (and <code>p=2</code>), an object of class <code>power_diagram</code> as described in the help for the function <code><a href="#topic+semidiscrete">semidiscrete</a></code>. The <code><a href="#topic+plot.pgrid">plot</a></code> method for class <code>pgrid</code> can plot this solution.
</p>


<h3>Use of CPLEX</h3>

<p>The combination of the shielding-method with the CPLEX numerical solver outperforms the other algorithms by an order of magnitude for large problems (only applicable for <code>p=2</code> and objects of class <code>"pgrid"</code>). If a local installation of CPLEX is available, the transport package can be linked against it during installation. See the file src/Makevars in the source package for instructions.
</p>


<h3>Use of CGAL</h3>

<p>The combination of the aha-method with <code>p=1</code> requires the use of CGAL (the Computational Geometry Algorithms Library) for dealing with Apollonius diagrams. If you require this functionality, install it from https://www.cgal.org/download.html and adapt the file src/Makevars of this package according to the instructions given in that file. Then re-install 'transport' from source as usual.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>
<p>Björn Bähre <a href="mailto:bjobae@gmail.com">bjobae@gmail.com</a> (code for <code><a href="#topic+aha">aha</a></code>-method for <code>p=2</code>)
</p>
<p>Nicolas Bonneel <a href="mailto:nicolas.bonneel@liris.cnrs.fr">nicolas.bonneel@liris.cnrs.fr</a> <br /> (adaption of LEMON code for fast <code>networkflow</code> method)
</p>
<p>Carsten Gottschlich <a href="mailto:gottschlich@math.uni-goettingen.de">gottschlich@math.uni-goettingen.de</a> <br /> (original java code for <code>shortlist</code> and <code>revsimplex</code> methods)
</p>
<p>Valentin Hartmann <a href="mailto:valentin.hartmann@epfl.ch">valentin.hartmann@epfl.ch</a> (code for <code><a href="#topic+semidiscrete1">aha</a></code> method for <code>p=1</code>)
</p>
<p>Florian Heinemann <a href="mailto:florian.heinemann@uni-goettingen.de">florian.heinemann@uni-goettingen.de</a> <br /> (integration of <code>networkflow</code> method)
</p>
<p>Bernhard Schmitzer <a href="mailto:schmitzer@uni-muenster.de">schmitzer@uni-muenster.de</a> (code for <code><a href="#topic+shielding">shielding</a></code>-method)
</p>


<h3>References</h3>

<p>F. Aurenhammer, F. Hoffmann and B. Aronov (1998). Minkowski-type theorems and least-squares clustering. Algorithmica 20(1), 61&ndash;76.
</p>
<p>D. P. Bertsekas (1988). The auction algorithm: a distributed relaxation method for the assignment problem. Annals of Operations Research 14(1), 105&ndash;123.
</p>
<p>D. P. Bertsekas (1992). Auction algorithms for network flow problems: a tutorial introduction. Computational Optimization and Applications 1, 7&ndash;66. 
</p>
<p>N. Bonneel (2018). Fast Network Simplex for Optimal Transport. Github repository, <a href="https://github.com/nbonneel/network_simplex">nbonneel/network_simplex</a>.
</p>
<p>N. Bonneel, M. van de Panne, S. Paris and W. Heidrich (2011). Displacement interpolation using Lagrangian mass transport. ACM Transactions on Graphics (SIGGRAPH ASIA 2011) 30(6).
</p>
<p>Egervary Research Group on Combinatorial Optimization, EGRES (2014). LEMON Graph Library v1.3.1.
<a href="https://lemon.cs.elte.hu/trac/lemon">lemon.cs.elte.hu/trac/lemon</a>.
</p>
<p>C. Gottschlich and D. Schuhmacher (2014). The shortlist method for fast computation of the earth mover's distance and finding optimal solutions to transportation problems. PLOS ONE 9(10), e110214. <a href="https://doi.org/10.1371/journal.pone.0110214">doi:10.1371/journal.pone.0110214</a>
</p>
<p>V. Hartmann and D. Schuhmacher (2020). Semi-discrete optimal transport: a solution procedure for the unsquared Euclidean distance case, Mathematical Methods of Operations Research 92, 133&ndash;163. <a href="https://doi.org/10.1007/s00186-020-00703-z">doi:10.1007/s00186-020-00703-z</a>
</p>
<p>D.G. Luenberger (2003). Linear and nonlinear programming, 2nd ed. Kluwer.
</p>
<p>D.G. Luenberger and Y. Ye (2008). Linear and nonlinear programming, 3rd ed. Springer.
</p>
<p>Q. Mérigot (2011). A multiscale approach to optimal transport. Computer Graphics Forum 30(5), 1583&ndash;1592. <a href="https://doi.org/10.1111/j.1467-8659.2011.02032.x">doi:10.1111/j.1467-8659.2011.02032.x</a>
</p>
<p>B. Schmitzer (2016). A sparse multiscale algorithm for dense optimal transport. J. Math. Imaging Vision 56(2), 238&ndash;259. <a href="https://arxiv.org/abs/1510.05466">https://arxiv.org/abs/1510.05466</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="#topic+wasserstein">wasserstein</a></code>,
<code><a href="#topic+unbalanced">unbalanced</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# example for the default method
#
a &lt;- c(100, 200, 80, 150, 50, 140, 170, 30, 10, 70)
b &lt;- c(60, 120, 150, 110, 40, 90, 160, 120, 70, 80)
set.seed(24)
costm &lt;- matrix(sample(1:20, 100, replace=TRUE), 10, 10)  
res &lt;- transport(a,b,costm)

# pretty-print solution in matrix form for very small problems:
transp &lt;- matrix(0,10,10)
transp[cbind(res$from,res$to)] &lt;- res$mass
rownames(transp) &lt;- paste(ifelse(nchar(a)==2," ",""),a,sep="")
colnames(transp) &lt;- paste(ifelse(nchar(b)==2," ",""),b,sep="")
print(transp)	

	
#
# example for class 'pgrid'
#
dev.new(width=9, height=4.5)
par(mfrow=c(1,2), mai=rep(0.1,4))
image(random32a$mass, col = grey(0:200/200), axes=FALSE)
image(random32b$mass, col = grey(0:200/200), axes=FALSE)
res &lt;- transport(random32a,random32b)
dev.new()
par(mai=rep(0,4))
plot(random32a,random32b,res,lwd=1)


#
# example for class 'pp'
#
set.seed(27)
x &lt;- pp(matrix(runif(400),200,2))
y &lt;- pp(matrix(runif(400),200,2))
res &lt;- transport(x,y)
dev.new()
par(mai=rep(0.02,4))
plot(x,y,res)


#
# example for class 'wpp'
#
set.seed(30)
m &lt;- 30
n &lt;- 60
massx &lt;- rexp(m)
massx &lt;- massx/sum(massx)
massy &lt;- rexp(n)
massy &lt;- massy/sum(massy)
x &lt;- wpp(matrix(runif(2*m),m,2),massx)
y &lt;- wpp(matrix(runif(2*n),n,2),massy)
res &lt;- transport(x,y,method="revsimplex")
plot(x,y,res)


#
# example for semidiscrete transport between class
# 'pgrid' and class 'wpp' (p=2)
#
set.seed(33)
n &lt;- 100
massb &lt;- rexp(n)
massb &lt;- massb/sum(massb)*1e5
b &lt;- wpp(matrix(runif(2*n),n,2),massb)
res &lt;- transport(random32a,b,p=2)
plot(random32a,b,res)


#
# example for semidiscrete transport between class
# 'pgrid' and class 'wpp' (p=1)
#
if (transport:::cgal_present()) {
  set.seed(33)
  n &lt;- 30
  massb &lt;- rexp(n)
  massb &lt;- massb/sum(massb)*1e5
  b &lt;- wpp(matrix(runif(2*n),n,2),massb)
  res &lt;- transport(random32a,b,p=1)
  plot(random32a,b,res)
}
</code></pre>

<hr>
<h2 id='transport_track'>
Create a Dynamic Visualization of a Transference Plan Between Two pgrids
</h2><span id='topic+transport_track'></span>

<h3>Description</h3>

<p>Given two objects <code>source</code> and <code>target</code> of class <code>pgrid</code> and a transference plan, typically
the result of a call to <code><a href="#topic+transport">transport</a></code>, create an animation of the dynamic transference plan
(a.k.a. displacement interpolation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  transport_track(source, target, tplan, K = 50, scmult = 1, smooth = FALSE,
     H = matrix(c(1,0,0,1),2,2), create.file = c("none","gif_im"), 
     file.name = "Rtransport.gif", fps = 20, cut = FALSE,
     col=grey((0:1000)/1000),width=800,height=800)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transport_track_+3A_source">source</code>, <code id="transport_track_+3A_target">target</code></td>
<td>

<p>objects of class <code>pgrid</code>.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_tplan">tplan</code></td>
<td>

<p>a transference plan between <code>source</code> and <code>target</code>, typically an optimal transference plan
obtained by a call to <code><a href="#topic+transport">transport</a></code>.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_k">K</code></td>
<td>

<p>the number of intermediate frames to be produced between <code>source</code> and <code>target</code>. 
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_scmult">scmult</code></td>
<td>

<p>the factor by which the number of pixels in each dimension is multiplied to obtain a smoother rendering 
of the dynamic transference plan.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_smooth">smooth</code></td>
<td>

<p>logical. Whether a kernel smoothing or a linear binning procedure is used to generate the images. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_h">H</code></td>
<td>

<p>the bandwith matrix used to perform the two dimensional kernel density estimation or the linear binning respectively.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_create.file">create.file</code></td>
<td>

<p>the file type to be created or <code>"none"</code> to return only an array of intermediate mass distributions.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_file.name">file.name</code></td>
<td>

<p>the path for the output file. Ignored if <code>create.file</code> is <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_fps">fps</code></td>
<td>

<p>the number of frames per second in the generated gif. The default is 20 frames per second.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_cut">cut</code></td>
<td>

<p>logical. Whether the boundary pixels are cut off. Currently the only way to deal with the edge effect (see Details).
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_col">col</code></td>
<td>

<p>the vector of RGB colours which is used to generate the gif, if create.file is not &quot;none&quot;. See the 
documentation of image for more details.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_width">width</code></td>
<td>

<p>interger specifying the width of the images used to generate the output gif, if create.file is not &quot;none&quot;.
</p>
</td></tr>
<tr><td><code id="transport_track_+3A_height">height</code></td>
<td>

<p>interger specifying the width of the images used to generate the output gif, if create.file is not &quot;none&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intermediate frames are produced by the interpolation formula <code class="reqn">[(1-t)\mathrm{pr}_1 + t\mathrm{pr}_2]_{\#} \pi</code>, 
where <code class="reqn">\pi</code> is the transference plan, <code class="reqn">\mathrm{pr}_1</code> and <code class="reqn">\mathrm{pr}_2</code> are the first and second coordinate projections of <code class="reqn">\mathbf{R}^2 \times \mathbf{R}^2</code> onto <code class="reqn">\mathbf{R}^2</code>, and <code class="reqn">t \in \{0,1/(K+1), \ldots, K/(K+1),1\}</code>. If <code class="reqn">\pi</code> is an optimal transference plan this yields the displacement interpolation, at least if we assume 
as underlying cost function the Euclidean metric to the <code class="reqn">p</code>-th power, where <code class="reqn">p = 1,2</code>.
</p>
<p>The kernel smoothing procedure gives usually nicer animations, but takes several orders of magnitudes longer. 
</p>
<p>There are currently visible edge effects in both the kernel smoothing and the linear binning procedure that lead to darker pixels at the boundary of the image. The cut parameter may be used to remove the boundary pixels completely and thus produce a smaller output. The edge will be dealt with more adequatly in future versions.
</p>
<p>Conversion to an animated gif is performed by a system call to the convert tool of ImageMagick. The latter may have to be 
installed first.
</p>


<h3>Value</h3>

<p>An array containing the various interpolation images.
</p>
<p>Unless <code>create.file="none"</code>, the function is mainly used for its side effect (saving a file to the specified path).
So the array is returned invisibly.
</p>


<h3>Warning</h3>

<p>Running this function with <code>smooth=TRUE</code> and even moderate <code>K</code> can take a long time!</p>


<h3>Author(s)</h3>

<p>Florian Heinemann <a href="mailto:florian.heinemann@uni-goettingen.de">florian.heinemann@uni-goettingen.de</a> <br />
(slightly modified by Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>)
</p>


<h3>See Also</h3>

<p><code>Function <a href="#topic+transport">transport</a></code> for computing optimal transference plans.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ks", quietly = TRUE)) {
  tplan &lt;- transport(random32a,random32b)
  series &lt;- transport_track(random32a, random32b, tplan, scmult=3, create.file="none")
  dev.new(width=16,height=8)
  oldpar &lt;- par(mfrow=c(5,10), mai=rep(0.01,4))
  for (i in 1:50) { 
    image(series[,,i], col=grey(seq(0,1,0.005)), asp=1, axes=FALSE,zlim=c(min(series),max(series)))
  }
  par(oldpar)
}
</code></pre>

<hr>
<h2 id='transport-internal'>
Internal Functions in Package &lsquo;transport&rsquo;
</h2><span id='topic+dedegenerate'></span><span id='topic+findblocks'></span><span id='topic+fudge'></span><span id='topic+image2'></span><span id='topic+image3'></span><span id='topic+gif.generate'></span><span id='topic+plot_pgrid_wpp'></span><span id='topic+refinesol'></span><span id='topic+triangulate'></span>

<h3>Description</h3>

<p>Internal functions in package &lsquo;transport&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dedegenerate(basis)



findblocks(tbasis)


fudge(temp, N = 1e+09)


gif.generate(M.save, M.source, M.target, K, file.name, fps, new.l, 
             gif_type,out.col= grey(0:1000/1000),width=800,height=800)

image2(x, y, z, rot = FALSE, ...)
image3(z, x=1:dim(z)[1], y=1:dim(z)[2], rot=TRUE, ...)

plot_pgrid_wpp(x, y, tplan, pmass=TRUE, cex=0.8, length=0.1, acol="#996699",
  bcol = 4, pcol = "goldenrod2", lwd = 1.5, rot = TRUE, ...)


refinesol(a1, b1, a2, b2, assig1, basis1, mult = 2)


triangulate(basis)

</code></pre>


<h3>Details</h3>

<p>These internal functions should usually not be called directly by the user.
They perform more elementary tasks, do little to no checks of their inputs,
and may change from one package version to the next without notice.
Also, most of these functions are not exported, so call them by
<code>transport:::name_of_fun</code> if you must.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a> <br />
Florian Heinemann <a href="mailto:florian.heinemann@stud.uni-goettingen.de">florian.heinemann@stud.uni-goettingen.de</a> (gif.generate)
</p>

<hr>
<h2 id='transport-package'>
Optimal Transport in Various Forms
</h2><span id='topic+transport-package'></span>

<h3>Description</h3>

<p>Solve optimal transport problems. Compute Wasserstein distances (a.k.a. Kantorovitch, Fortet&ndash;Mourier, Mallows, Earth Mover's, or minimal <code class="reqn">L_p</code> distances), return the corresponding transport plans, and display them graphically. Objects that can be compared include grey-scale images, (weighted) point patterns, and mass vectors.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> transport</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.12-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-08-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main end-user function is <code><a href="#topic+transport">transport</a></code>. It computes optimal transport plans between images (class <code><a href="#topic+pgrid">pgrid</a></code>), point patterns (class <code><a href="#topic+pp">pp</a></code>), weighted point patterns (class <code><a href="#topic+wpp">wpp</a></code>) and mass vectors, based on various algorithms. These transport plans can be <code><a href="#topic+plot.pgrid">plot</a></code>ed. The function <code><a href="#topic+wasserstein">wasserstein</a></code> allows for the numerical computation of <code class="reqn">p</code>-th order Wasserstein distances.
</p>
<p>Most functions in this package are designed for data in two and higher dimensions. A quick tool for computing the <code class="reqn">p</code>-th order Wasserstein distance between univariate samples is <code><a href="#topic+wasserstein1d">wasserstein1d</a></code>.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>
<p>Björn Bähre <a href="mailto:bjobae@gmail.com">bjobae@gmail.com</a> (code for <code><a href="#topic+aha">aha</a></code>-method)
</p>
<p>Nicolas Bonneel <a href="mailto:nicolas.bonneel@liris.cnrs.fr">nicolas.bonneel@liris.cnrs.fr</a> <br /> (adaptation of LEMON code for fast <code><a href="#topic+transport">networkflow</a></code> method)
</p>
<p>Carsten Gottschlich <a href="mailto:gottschlich@math.uni-goettingen.de">gottschlich@math.uni-goettingen.de</a> <br /> (original java code for <code><a href="#topic+transport">shortlist</a></code> and <code><a href="#topic+transport">revsimplex</a></code> methods)
</p>
<p>Valentin Hartmann <a href="mailto:valentin.hartmann@epfl.ch">valentin.hartmann@epfl.ch</a> (code for <code><a href="#topic+semidiscrete1">aha</a></code> method for <code>p=1</code>)
</p>
<p>Florian Heinemann <a href="mailto:florian.heinemann@uni-goettingen.de">florian.heinemann@uni-goettingen.de</a> <br /> (integration of <code><a href="#topic+transport">networkflow</a></code> method)
</p>
<p>Bernhard Schmitzer <a href="mailto:schmitzer@uni-muenster.de">schmitzer@uni-muenster.de</a> (<code><a href="#topic+shielding">shielding</a></code> method)
</p>
<p>Jörn Schrieber <a href="mailto:joern.schrieber-1@mathematik.uni-goettingen.de">joern.schrieber-1@mathematik.uni-goettingen.de</a> (<code><a href="#topic+subwasserstein">subsampling</a></code> method)
</p>
<p>Maintainer: Dominic Schuhmacher <a href="mailto:dominic.schuhmacher@mathematik.uni-goettingen.de">dominic.schuhmacher@mathematik.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>See help page for the function <code><a href="#topic+transport">transport</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  See examples for function transport
</code></pre>

<hr>
<h2 id='trcontrol'>
Set the Control Parameters Used by <code>transport</code>.
</h2><span id='topic+trcontrol'></span>

<h3>Description</h3>

<p>Set the control parameters for the algorithm used by the function <code><a href="#topic+transport">transport</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trcontrol(method = c("networkflow", "revsimplex", "shortsimplex", "primaldual", "aha",
          "shielding", "auction", "auctionbf"), para = list(),
          start = c("auto",          "modrowmin", "nwcorner", "russell"), 
          nscales = 1, scmult = 2,returncoarse = FALSE, a = NULL,
          b = NULL, M = NULL, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trcontrol_+3A_method">method</code></td>
<td>

<p>The algorithm to be used to compute the optimal transference plan. See details for the function <code><a href="#topic+transport.pgrid">transport.pgrid</a></code>.
</p>
</td></tr>
<tr><td><code id="trcontrol_+3A_para">para</code></td>
<td>

<p>A list of parameters that are specific to the chosen method. See the table on the help page of the function <code><a href="#topic+transport">transport</a></code>.
</p>
</td></tr>
<tr><td><code id="trcontrol_+3A_start">start</code></td>
<td>

<p>If <code>method == "revsimplex"</code>, the method for computing a starting solution.
</p>
</td></tr>
<tr><td><code id="trcontrol_+3A_nscales">nscales</code>, <code id="trcontrol_+3A_scmult">scmult</code>, <code id="trcontrol_+3A_returncoarse">returncoarse</code></td>
<td>

<p>The parameters for the multiscale versions of certain algorithms. See the help on <code><a href="#topic+transport">transport</a></code>.
</p>
</td></tr>
<tr><td><code id="trcontrol_+3A_a">a</code>, <code id="trcontrol_+3A_b">b</code>, <code id="trcontrol_+3A_m">M</code>, <code id="trcontrol_+3A_n">N</code></td>
<td>

<p>The two objects <code>a</code> and <code>b</code> for which the transportation problem is to be solved <em>or</em> the sizes <code>M</code>
and <code>N</code> of these objects. Based on the information available here, <code>trcontrol</code> tries hard to find reasonable values
for the control parameters of the algorithm not specified directly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details about the parameters of the individual algorithms see the help page for <code><a href="#topic+transport">transport</a></code>.
</p>


<h3>Value</h3>

<p>A list with components <code>method</code>, <code>para</code>, <code>start</code>, <code>nscales</code>, <code>scmult</code>, <code>returncoarse</code> as
entered or adapted/computed based on the arguments <code>method</code>, <code>a</code>, <code>b</code>, <code>M</code>, <code>N</code>.
</p>


<h3>Note</h3>

<p>This function is typically only called by the user to check what the parameter settings used
by the function <code><a href="#topic+transport">transport</a></code> are for a given problem.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transport">transport</a></code>
</p>

<hr>
<h2 id='unbalanced'>Unbalanced Optimal Transport Between Two Objects</h2><span id='topic+unbalanced'></span><span id='topic+unbalanced.pgrid'></span><span id='topic+unbalanced.wpp'></span>

<h3>Description</h3>

<p>Compute optimal transport between unnormalized images / mass distributions on grids 
(<code>pgrid</code> objects) or between mass distributions on general point patterns
(<code>wpp</code> objects) under the option that mass can be dispose of. Transport cost
per unit is the Euclidean distance of the transport to the <code>p</code>-th power.
Disposal cost per unit is <code>C^p</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbalanced(a, b, ...)

## S3 method for class 'pgrid'
unbalanced(
  a,
  b,
  p = 1,
  C = NULL,
  method = c("networkflow", "revsimplex"),
  output = c("dist", "all", "rawres"),
  threads = 1,
  ...
)

## S3 method for class 'wpp'
unbalanced(
  a,
  b,
  p = 1,
  C = NULL,
  method = c("networkflow", "revsimplex"),
  output = c("dist", "all", "rawres"),
  threads = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbalanced_+3A_a">a</code>, <code id="unbalanced_+3A_b">b</code></td>
<td>
<p>objects of class <code><a href="#topic+pgrid">pgrid</a></code> or <code><a href="#topic+wpp">wpp</a></code> that are compatible.</p>
</td></tr>
<tr><td><code id="unbalanced_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="unbalanced_+3A_p">p</code></td>
<td>
<p>a power <code class="reqn">\geq 1</code> applied to the transport and disposal costs. The order
of the resulting unbalanced Wasserstein metric.</p>
</td></tr>
<tr><td><code id="unbalanced_+3A_c">C</code></td>
<td>
<p>The base disposal cost (without the power <code>p</code>)</p>
</td></tr>
<tr><td><code id="unbalanced_+3A_method">method</code></td>
<td>
<p>one of <code>"networkflow"</code> and <code>"revsimplex"</code>, specifing the algorithm used. See details.</p>
</td></tr>
<tr><td><code id="unbalanced_+3A_output">output</code></td>
<td>
<p>character. One of &quot;dist&quot;, &quot;all&quot; and &quot;rawres&quot;. Determines what the function
returns: only the unbalanced Wasserstein distance; all available information about the 
transport plan and the extra mass; or the raw result obtained by the networkflow algorithm.
The latter is the same format as in the <code>transport</code> function with option <code>fullreturn=TRUE</code>.
The choice <code>output = "rawres"</code> is mainly intended for internal use.</p>
</td></tr>
<tr><td><code id="unbalanced_+3A_threads">threads</code></td>
<td>
<p>an integer specifying the number of threads for parallel computing in connection with
the networkflow method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two non-negative mass distributions <code class="reqn">a=(a_x)_{x \in S}</code>, <code class="reqn">b=(a_y)_{y \in S}</code>
on a set <code class="reqn">S</code> (a pixel grid / image if <code>a</code>, <code>b</code> are of class <code>pgrid</code> or a more
general weighted point pattern if <code>a</code>, <code>b</code> are of class <code>wpp</code>), this function minimizes the functional
</p>
<p style="text-align: center;"><code class="reqn">\sum_{x,y \in S} \pi_{x,y} d(x,y)^p + C^p \bigl( \sum_{x \in S} (a_x - \pi^{(1)}_x) + \sum_{y \in S} (b_y - \pi^{(2)}_y) \bigr)</code>
</p>

<p>over all <code class="reqn">(\pi_{x,y})_{x,y \in S}</code> satisfying
</p>
<p style="text-align: center;"><code class="reqn">0 \leq \pi^{(1)}_x := \sum_{y \in S} \pi_{x,y} \leq a_x \ \textrm{and} \ 0 \leq \pi^{(2)}_y := \sum_{x \in S} \pi_{x,y} \leq b_y.</code>
</p>

<p>Thus <code class="reqn">\pi_{x,y}</code> denotes the amount of mass transported from <code class="reqn">x</code> to <code class="reqn">y</code>, whereas <code class="reqn">\pi^{(1)}_x</code>
and <code class="reqn">\pi^{(2)}_y</code> are the total mass transported away from <code class="reqn">x</code> and total mass transported to <code class="reqn">y</code>, respectively.
Accordingly <code class="reqn">\sum_{x \in S} (a_x - \pi^{(1)}_x)</code> and <code class="reqn">\sum_{y \in S} (b_y - \pi^{(2)}_y)</code> are the total
amounts of mass of <code class="reqn">a</code> and <code class="reqn">b</code>, respectively, that need to be disposed of.
</p>
<p>The minimal value of the functional above taken to the <code class="reqn">1/p</code> is what we refer to as unbalanced
<code class="reqn">(p,C)</code>-Wasserstein metric. This metric is used, in various variants, in an number of research papers.
See Heinemann et al. (2022) and the references therein and Müller et al. (2022), Remark 3. We follow the
convention of the latter paper regarding the parametrization and the use of the term <em>unbalanced Wasserstein metric</em>.
</p>
<p>The practical difference between the two methods &quot;networkflow&quot; and &quot;revsimplex&quot; can 
roughly described as follows. The former is typically faster for large examples (for <code>pgrid</code> objects 64x64
and beyond), especially if several threads are used. The latter is typically faster
for smaller examples (which may be relevant if pairwise transports between many objects
are computed) and it guarantees a sparse(r) solution, i.e. at most <code class="reqn">m+n+1</code> individual
transports, where <code class="reqn">m</code> and <code class="reqn">n</code> are the numbers of non-zero masses in <code>a</code> and <code>b</code>, respectively).
Note however that due to the implementation the revsimplex algorithm is a little less
precise (roughly within 1e-7 tolerance). For more details on the algorithms see <code><a href="#topic+transport">transport</a></code>.
</p>


<h3>Value</h3>

<p>If <code>output = "dist"</code> a single numeric, the unbalanced <code class="reqn">(p,C)</code>-Wasserstein distance.
Otherwise a list. If <code>output = "all"</code> the list is of class <code>ut_pgrid</code> or <code>ut_wpp</code> according
to the class of the objects <code>a</code> and <code>b</code>. It has <code>a</code>, <code>b</code>, <code>p</code>, <code>C</code> as attributes and 
the following components:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>same as for <code>output = "dist"</code>.</p>
</td></tr>
<tr><td><code>plan</code></td>
<td>
<p>an optimal transport plan. This is a data frame with columns <code>from</code>, <code>to</code> and <code>mass</code>
that specifies from which element of <code>a</code> to which element of <code>b</code> what amount of mass is sent.
<code>from</code> and <code>to</code> are specified as vector indices in terms of the usual column major enumeration
of the matrices a$mass and b$mass. The plan can be plotted via <code>plot.pgrid(a, b, plan)</code>.</p>
</td></tr>
<tr><td><code>atrans</code>, <code>btrans</code></td>
<td>
<p>matrices (pgrid) or vectors (wpp) specifying the masses transported from each point and to each point,
respectively. Corresponds to <code class="reqn">(\pi^{(1)}_x)_{x \in S}</code> and <code class="reqn">(\pi^{(2)}_y)_{y \in S}</code> above.</p>
</td></tr>
<tr><td><code>aextra</code>, <code>bextra</code></td>
<td>
<p>matrices (pgrid) or vectors (wpp) specifying the amount of mass at each point of <code>a</code> and <code>b</code>,
respectively, that cannot be transported and needs to be disposed of. Corresponds to
<code class="reqn">(a_x - \pi^{(1)}_x)_{x \in S}</code> and <code class="reqn">(b_y - \pi^{(2)}_y)_{y \in S}</code>.</p>
</td></tr>
<tr><td><code>inplace</code></td>
<td>
<p>(pgrid only) a matrix specifying the amount of mass at each point that can stay in place. Corresponds
to <code class="reqn">(\pi_{x,x})_{x \in S}</code>.</p>
</td></tr>
</table>
<p>Note that <code>atrans + aextra + inplace</code> (pgrid) or <code>atrans + aextra</code> (wpp)must be equal
to <code>a$mass</code> and likewise for b.
A warning occurs if this is not the case (which may indeed happen from time to time for method
revsimplex, but the error reported should be very small).
</p>


<h3>References</h3>

<p>Florian Heinemann, Marcel Klatt and Axel Munk (2022).<br />
Kantorovich-Rubinstein distance and barycenter for finitely supported measures: Foundations and Algorithms.<br />
Arxiv preprint.<br />
<a href="https://doi.org/10.48550/arXiv.2112.03581">doi:10.48550/arXiv.2112.03581</a><br />
<br />
Raoul Müller, Dominic Schuhmacher and Jorge Mateu (2020).<br />
Metrics and barycenters for point pattern data
Statistics and Computing 30, 953-972.<br />
<a href="https://doi.org/10.1007/s11222-020-09932-y">doi:10.1007/s11222-020-09932-y</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ut_pgrid">plot.ut_pgrid</a></code> and <code><a href="#topic+plot.ut_wpp">plot.ut_wpp</a></code>, which can plot the various components of the list obtained for <code>output="all"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- pgrid(matrix(1:12, 3, 4))
b &lt;- pgrid(matrix(c(9:4, 12:7), 3, 4))
res1 &lt;- unbalanced(a, b, 1, 0.5, output="all")
res2 &lt;- unbalanced(a, b, 1, 0.3, output="all")
plot(a, b, res1$plan, angle=20, rot=TRUE)
plot(a, b, res2$plan, angle=20, rot=TRUE)
par(mfrow=c(1,2))
matimage(res2$aextra, x = a$generator[[1]], y = a$generator[[2]])
matimage(res2$bextra, x = b$generator[[1]], y = b$generator[[2]])

set.seed(31)
a &lt;- wpp(matrix(runif(8),4,2), 3:6)
b &lt;- wpp(matrix(runif(10),5,2), 1:5)
res1 &lt;- unbalanced(a, b, 1, 0.5, output="all")
res2 &lt;- unbalanced(a, b, 1, 0.3, output="all")
plot(a, b, res1$plan)
plot(a, b, res2$plan)

</code></pre>

<hr>
<h2 id='wasserstein'>
Compute the Wasserstein Distance Between Two Objects
</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p>Given two objects <code>a</code> and <code>b</code> that specify measures in <code class="reqn">R^d</code>, compute the Wasserstein distance of
order <code>p</code> between the objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(a, b, p=1, tplan=NULL, costm=NULL, prob=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_a">a</code>, <code id="wasserstein_+3A_b">b</code></td>
<td>

<p>two objects that describe mass distributions in <code class="reqn">R^d</code>. Either both of class <code><a href="#topic+pgrid">pgrid</a></code> or <code><a href="#topic+pp">pp</a></code>
or <code><a href="#topic+wpp">wpp</a></code> or <code>numeric</code>. For the first three the dimension <code class="reqn">d</code> of the structures must be at least 2; see function <code><a href="#topic+wasserstein1d">wasserstein1d</a></code> for <code class="reqn">d=1</code>.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>

<p>the power <code class="reqn">\geq 1</code> to which the Euclidean distance between points is taken in order to
compute transportation costs.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_tplan">tplan</code></td>
<td>

<p>an optional transference plan in the format returned by the function <code><a href="#topic+transport">transport</a></code>. If <code>NULL</code> an optimal
transference plan based on <code>a</code>, <code>b</code> and <code>p</code> is computed by a call to <code><a href="#topic+transport">transport</a></code>.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_costm">costm</code></td>
<td>

<p>the matrix of costs between the support points of the measures. Ignored unless <code>a</code> and <code>b</code> are numeric vectors.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_prob">prob</code></td>
<td>

<p>logical. Should the objects <code>a</code>, <code>b</code> be interpreted as probability measures, i.e. their total mass be normalized to 1?
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_...">...</code></td>
<td>

<p>further parameters passed to <code><a href="#topic+transport">transport</a></code> if <code>tplan</code> is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wasserstein distance of order <code>p</code> is defined as the <code>p</code>-th root of the total cost incurred when transporting measure <code>a</code>
to measure <code>b</code> in an optimal way, where the cost of transporting a unit of mass from <code class="reqn">x</code> to <code class="reqn">y</code> is given as the <code>p</code>-th 
power <code class="reqn">\|x-y\|^p</code> of the Euclidean distance. 
</p>
<p>If <code>tplan</code> is supplied by the user, no checks are performed whether it is optimal for the given problem. So this
function may be used to compare different (maybe suboptimal) transference plans with regard to their total costs.
</p>
<p>For further details on the algorithms used, see help of <code><a href="#topic+transport">transport</a></code>. 
</p>


<h3>Value</h3>

<p>A single number, the Wasserstein distance for the specified problem.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pgrid">plot</a></code>, <code><a href="#topic+transport">transport</a></code>, <code><a href="#topic+wasserstein1d">wasserstein1d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# example for class 'pgrid'
#
wasserstein(random32a,random32b,p=1)
res &lt;- transport(random32a,random32b,p=2)
wasserstein(random32a,random32b,p=1,res)
# is larger than above:
# the optimal transport for p=2 is not optimal for p=1

#
# example for class 'pp'
#
set.seed(27)
x &lt;- pp(matrix(runif(500),250,2))
y &lt;- pp(matrix(runif(500),250,2))
wasserstein(x,y,p=1)
wasserstein(x,y,p=2)
</code></pre>

<hr>
<h2 id='wasserstein1d'>
Compute the Wasserstein Distance Between Two Univariate Samples
</h2><span id='topic+wasserstein1d'></span>

<h3>Description</h3>

<p>Given two vectors <code>a</code> and <code>b</code>, compute the Wasserstein distance of
order <code>p</code> between their empirical distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein1d(a, b, p = 1, wa = NULL, wb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein1d_+3A_a">a</code>, <code id="wasserstein1d_+3A_b">b</code></td>
<td>

<p>two vectors.
</p>
</td></tr>
<tr><td><code id="wasserstein1d_+3A_p">p</code></td>
<td>

<p>a positive number. The order of the Wasserstein distance.
</p>
</td></tr>
<tr><td><code id="wasserstein1d_+3A_wa">wa</code>, <code id="wasserstein1d_+3A_wb">wb</code></td>
<td>

<p>optional vectors of non-negative weights for <code>a</code> and <code>b</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wasserstein distance of order <code>p</code> is defined as the <code>p</code>-th root of the total cost incurred when transporting a pile of mass into another pile of mass in an optimal way, where the cost of transporting a unit of mass from <code class="reqn">x</code> to <code class="reqn">y</code> is given as the <code>p</code>-th power <code class="reqn">\|x-y\|^p</code> of the Euclidean distance. 
</p>
<p>In the present function the vector <code>a</code> represents the locations on the real line of <code class="reqn">m</code> deposits of mass <code class="reqn">1/m</code> and the vector <code>b</code> the locations of <code class="reqn">n</code> deposits of mass <code class="reqn">1/n</code>. If the user specifies weights <code>wa</code> and <code>wb</code>, these default masses are replaced by <code>wa/sum(wa)</code> and <code>wb/sum(wb)</code>, respectively.
</p>
<p>In terms of the empirical distribution function <code class="reqn">F(t) = \sum_{i=1}^m w^{(a)}_i 1\{a_i \leq t\}</code> of locations <code class="reqn">a_i</code> with normalized weights <code class="reqn">w^{(a)}_i</code>, and the corresponding function <code class="reqn">G(t) = \sum_{j=1}^n w^{(b)}_j 1\{b_j \leq t\}</code> for <code>b</code>, the Wasserstein distance in 1-d is given as
</p>
<p style="text-align: center;"><code class="reqn">W_p(F,G) = \left(\int_0^1 |F^{-1}(u)-G^{-1}(u)|^p \; du \right)^{1/p},</code>
</p>

<p>where <code class="reqn">F^{-1}</code> and <code class="reqn">G^{-1}</code> are generalized inverses. If <code class="reqn">p=1</code>, we also have </p>
<p style="text-align: center;"><code class="reqn">W_1(F,G) = \int_{-\infty}^{\infty} |F(x)-G(x)| \; dx.</code>
</p>



<h3>Value</h3>

<p>A single number, the Wasserstein distance for the specified data.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wasserstein">wasserstein</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(200)
  y &lt;- rnorm(150,2)
  wasserstein1d(x,y)
</code></pre>

<hr>
<h2 id='wpp'>
Constructor for the wpp Class
</h2><span id='topic+wpp'></span>

<h3>Description</h3>

<p>Construct an object of class <code>"wpp"</code> from a matrix of points and a vector of masses. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wpp(coordinates, mass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpp_+3A_coordinates">coordinates</code></td>
<td>

<p>a matrix specifying the coordinates of the points. Each row corresponds to a point.
</p>
</td></tr>
<tr><td><code id="wpp_+3A_mass">mass</code></td>
<td>

<p>a vector of non-negative values specifying the masses at these points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more detailed explanations of the arguments and other components of the returned object of class <code>"wpp"</code>, see 
<code><a href="#topic+wpp-object">wpp-object</a></code>. 
</p>
<p>It is legitimate to assign mass 0 to individual points in the arguments. However, when constructing the <code>wpp</code>-object such points are deleted. The coordinates of the deleted points can still be accessed via the attribute <code>zeropoints</code>. 
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a> <br />
Timo Wilm <a href="mailto:timo.wilm@stud.uni-goettingen.de">timo.wilm@stud.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p>Description of <a href="#topic+pp-object">pp objects</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1,1,2,2,3,1,4,2),4,2)
a &lt;- pp(m)
print(a)
print.default(a)

## Not run:   
  plot(a)
## End(Not run)
</code></pre>

<hr>
<h2 id='wpp-object'>
Class of Weighted Point Patterns
</h2><span id='topic+wpp-object'></span>

<h3>Description</h3>

<p>The class <code>"wpp"</code> represents discrete measures with positive mass at any of finitely many locations.
</p>


<h3>Details</h3>

<p>Objects of class <code>"wpp"</code> may be created by the function 
<code><a href="#topic+wpp">wpp</a></code>, and are most commonly used as input to the function
<code><a href="#topic+transport">transport</a></code>. There are methods <code><a href="#topic+plot.wpp">plot</a></code>, <code><a href="#topic+print.wpp">print</a></code> and
<code><a href="#topic+summary.wpp">summary</a></code> for this class.
</p>
<p>An object of class <code>"wpp"</code> contains the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>dimension</code> </td><td style="text-align: left;">
    the dimension of the Euclidean space in which the patterns live. Must be <code class="reqn">\geq 2</code>.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>N</code> </td><td style="text-align: left;">
    the total number of point.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coordinates</code> </td><td style="text-align: left;">
    the coordinates of the points. An <code>N</code> <code class="reqn">\times</code> <code>dimension</code> matrix, where each row
    corresponds to a point.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>mass</code> </td><td style="text-align: left;">
    the masses at these points. A vector of length <code>N</code> of positive numbers.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>totmass</code> </td><td style="text-align: left;">
    the total mass of the point pattern.
  </td>
</tr>

</table>
  


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:dschuhm1@uni-goettingen.de">dschuhm1@uni-goettingen.de</a> <br />
Timo Wilm <a href="mailto:timo.wilm@stud.uni-goettingen.de">timo.wilm@stud.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p>Constructor function <code><a href="#topic+wpp">wpp</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
