<!DOCTYPE html><html><head><title>Help for package iSFun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iSFun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#iscca'><p>Integrative sparse canonical correlation analysis</p></a></li>
<li><a href='#iscca.cv'><p>Cross-validation for iscca</p></a></li>
<li><a href='#iscca.plot'><p>Plot the results of iscca</p></a></li>
<li><a href='#ispca'><p>Integrative sparse principal component analysis</p></a></li>
<li><a href='#ispca.cv'><p>Cross-validation for ispca</p></a></li>
<li><a href='#ispca.plot'><p>Plot the results of ispca</p></a></li>
<li><a href='#ispls'><p>Integrative sparse partial least squares</p></a></li>
<li><a href='#ispls.cv'><p>Cross-validation for ispls</p></a></li>
<li><a href='#ispls.plot'><p>Plot the results of ispls</p></a></li>
<li><a href='#meta.scca'><p>Meta-analytic sparse canonical correlation analysis method in integrative study</p></a></li>
<li><a href='#meta.spca'><p>Meta-analytic sparse principal component analysis method in integrative study</p></a></li>
<li><a href='#meta.spls'><p>Meta-analytic sparse partial least squares method in integrative study</p></a></li>
<li><a href='#preview.cca'><p>Statistical description before using function iscca</p></a></li>
<li><a href='#preview.pca'><p>Statistical description before using function ispca</p></a></li>
<li><a href='#preview.pls'><p>Statistical description before using function ispls</p></a></li>
<li><a href='#scca'><p>Sparse canonical correlation analysis</p></a></li>
<li><a href='#simData.cca'><p>Example data for method iscca</p></a></li>
<li><a href='#simData.pca'><p>Example data for method ispca</p></a></li>
<li><a href='#simData.pls'><p>Example data for method ispls</p></a></li>
<li><a href='#spca'><p>Sparse principal component analysis</p></a></li>
<li><a href='#spls'><p>Sparse partial least squares</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Integrative Dimension Reduction Analysis for Multi-Source Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rui Ren &lt;xmurr@stu.xmu.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The implement of integrative analysis methods based on a two-part penalization, which realizes dimension reduction analysis and mining the heterogeneity and association of multiple studies with compatible designs. The software package provides the integrative analysis methods including integrative sparse principal component analysis (Fang et al., 2018), integrative sparse partial least squares (Liang et al., 2021) and integrative sparse canonical correlation analysis, as well as corresponding individual analysis and meta-analysis versions. References: (1) Fang, K., Fan, X., Zhang, Q., and Ma, S. (2018). Integrative sparse principal component analysis. Journal of Multivariate Analysis, &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2018.02.002">doi:10.1016/j.jmva.2018.02.002</a>&gt;. (2) Liang, W., Ma, S., Zhang, Q., and Zhu, T. (2021). Integrative sparse partial least squares. Statistics in Medicine, &lt;<a href="https://doi.org/10.1002%2Fsim.8900">doi:10.1002/sim.8900</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, graphics, grDevices, irlba, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-03 16:25:41 UTC; renrui</td>
</tr>
<tr>
<td>Author:</td>
<td>Kuangnan Fang [aut],
  Rui Ren [aut, cre],
  Qingzhao Zhang [aut],
  Shuangge Ma [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-03 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='iscca'>Integrative sparse canonical correlation analysis</h2><span id='topic+iscca'></span>

<h3>Description</h3>

<p>This function provides a penalty-based integrative sparse canonical correlation analysis method to handle the multiple datasets with high dimensions generated under similar protocols, which consists of two built-in penalty items for selecting the important variables for users to choose, and two contrasted penalty functions for eliminating the diffierence (magnitude or sign) between estimators within each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iscca(x, y, L, mu1, mu2, mu3, mu4, eps = 1e-04, pen1 = "homogeneity",
  pen2 = "magnitude", scale.x = TRUE, scale.y = TRUE, maxstep = 50,
  submaxstep = 10, trace = FALSE, draw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iscca_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="iscca_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="iscca_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="iscca_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter for vector u.</p>
</td></tr>
<tr><td><code id="iscca_+3A_mu2">mu2</code></td>
<td>
<p>numeric, contrasted penalty parameter for vector u.</p>
</td></tr>
<tr><td><code id="iscca_+3A_mu3">mu3</code></td>
<td>
<p>numeric, sparsity penalty parameter for vector v.</p>
</td></tr>
<tr><td><code id="iscca_+3A_mu4">mu4</code></td>
<td>
<p>numeric, contrasted penalty parameter for vector v.</p>
</td></tr>
<tr><td><code id="iscca_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="iscca_+3A_pen1">pen1</code></td>
<td>
<p>character, &quot;homogeneity&quot; or &quot;heterogeneity&quot; type of the sparsity structure. If not specified, the default is homogeneity.</p>
</td></tr>
<tr><td><code id="iscca_+3A_pen2">pen2</code></td>
<td>
<p>character, &quot;magnitude&quot; or &quot;sign&quot; based contrasted penalty. If not specified, the default is magnitude.</p>
</td></tr>
<tr><td><code id="iscca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="iscca_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="iscca_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="iscca_+3A_submaxstep">submaxstep</code></td>
<td>
<p>numeric, maximum iteration steps in the sub-iterations. The default value is 10.</p>
</td></tr>
<tr><td><code id="iscca_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
<tr><td><code id="iscca_+3A_draw">draw</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, plot the convergence path of loadings and the heatmap of coefficient beta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'iscca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>loading.x: the estimated canonical vector of variables x.
</p>
</li>
<li><p>loading.y: the estimated canonical vector of variables y.
</p>
</li>
<li><p>variable.x: the screening results of variables x. 
</p>
</li>
<li><p>variable.y: the screening results of variables y.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+preview.cca">preview.cca</a></code>, <code><a href="#topic+iscca.cv">iscca.cv</a></code>, <code><a href="#topic+meta.scca">meta.scca</a></code>, <code><a href="#topic+scca">scca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a list with 3 data sets
library(iSFun)
data("simData.cca")
x &lt;- simData.cca$x
y &lt;- simData.cca$y
L &lt;- length(x)
mu1 &lt;- mu3 &lt;- 0.4
mu2 &lt;- mu4 &lt;- 2.5

prev_cca &lt;- preview.cca(x = x, y = y, L = L, scale.x = TRUE, scale.y = TRUE)
res_homo_m &lt;- iscca(x = x, y = y, L = L, mu1 = mu1, mu2 = mu2, mu3 = mu3, mu4 = mu4,
                    eps = 5e-2, maxstep = 50, submaxstep = 10, trace = TRUE, draw = TRUE)


res_homo_s &lt;- iscca(x = x, y = y, L = L, mu1 = mu1, mu2 = mu2, mu3 = mu3, mu4 = mu4,
                    eps = 5e-2, pen1 = "homogeneity", pen2 = "sign", scale.x = TRUE,
                    scale.y = TRUE, maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

mu1 &lt;- mu3 &lt;- 0.3
mu2 &lt;- mu4 &lt;- 2
res_hete_m &lt;- iscca(x = x, y = y, L = L, mu1 = mu1, mu2 = mu2, mu3 = mu3, mu4 = mu4,
                    eps = 5e-2, pen1 = "heterogeneity", pen2 = "magnitude", scale.x = TRUE,
                    scale.y = TRUE, maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

res_hete_s &lt;- iscca(x = x, y = y, L = L, mu1 = mu1, mu2 = mu2, mu3 = mu3, mu4 = mu4,
                    eps = 5e-2, pen1 = "heterogeneity", pen2 = "sign", scale.x = TRUE,
                    scale.y = TRUE, maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

</code></pre>

<hr>
<h2 id='iscca.cv'>Cross-validation for iscca</h2><span id='topic+iscca.cv'></span>

<h3>Description</h3>

<p>Performs K-fold cross validation for the integrative sparse canonical correlation analysis over a grid of values for the regularization parameter mu1, mu2, mu3 and mu4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iscca.cv(x, y, L, K = 5, mu1, mu2, mu3, mu4, eps = 1e-04,
  pen1 = "homogeneity", pen2 = "magnitude", scale.x = TRUE,
  scale.y = TRUE, maxstep = 50, submaxstep = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iscca.cv_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_k">K</code></td>
<td>
<p>numeric, number of cross-validation folds. Default is 5.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_mu1">mu1</code></td>
<td>
<p>numeric, the feasible set of sparsity penalty parameter for vector u.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_mu2">mu2</code></td>
<td>
<p>numeric, the feasible set of contrasted penalty parameter for vector u.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_mu3">mu3</code></td>
<td>
<p>numeric, the feasible set of sparsity penalty parameter for vector v.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_mu4">mu4</code></td>
<td>
<p>numeric, the feasible set of contrasted penalty parameter for vector v.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_pen1">pen1</code></td>
<td>
<p>character, &quot;homogeneity&quot; or &quot;heterogeneity&quot; type of the sparsity structure. If not specified, the default is homogeneity.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_pen2">pen2</code></td>
<td>
<p>character, &quot;magnitude&quot; or &quot;sign&quot; based contrasted penalty. If not specified, the default is magnitude.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="iscca.cv_+3A_submaxstep">submaxstep</code></td>
<td>
<p>numeric, maximum iteration steps in the sub-iterations. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'iscca.cv' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>mu1: the sparsity penalty parameter selected from the feasible set of parameter mu1 provided by users.
</p>
</li>
<li><p>mu2: the contrasted penalty parameter selected from the feasible set of parameter mu2 provided by users.
</p>
</li>
<li><p>mu3: the sparsity penalty parameter selected from the feasible set of parameter mu3 provided by users.
</p>
</li>
<li><p>mu4: the contrasted penalty parameter selected from the feasible set of parameter mu4 provided by users.
</p>
</li>
<li><p>fold: The fold assignments for cross-validation for each observation.
</p>
</li>
<li><p>loading.x: the estimated canonical vector of variables x with selected tuning parameters.
</p>
</li>
<li><p>loading.y: the estimated canonical vector of variables y with selected tuning parameters.
</p>
</li>
<li><p>variable.x: the screening results of variables x.
</p>
</li>
<li><p>variable.y: the screening results of variables y.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+iscca">iscca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a list with 3 data sets
library(iSFun)
data("simData.cca")
x &lt;- simData.cca$x
y &lt;- simData.cca$y
L &lt;- length(x)
mu1 &lt;- c(0.2, 0.4)
mu3 &lt;- 0.4
mu2 &lt;- mu4 &lt;- 2.5

res_homo_m &lt;- iscca.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, mu3 = mu3,
                       mu4 = mu4, eps = 1e-2, pen1 = "homogeneity", pen2 = "magnitude",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

res_homo_s &lt;- iscca.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, mu3 = mu3,
                       mu4 = mu4, eps = 1e-2, pen1 = "homogeneity", pen2 = "sign",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

mu1 &lt;- mu3 &lt;- c(0.1, 0.3)
mu2 &lt;- mu4 &lt;- 2
res_hete_m &lt;- iscca.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, mu3 = mu3,
                       mu4 = mu4, eps = 1e-2, pen1 = "heterogeneity", pen2 = "magnitude",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

res_hete_s &lt;- iscca.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, mu3 = mu3,
                       mu4 = mu4, eps = 1e-2, pen1 = "heterogeneity", pen2 = "sign",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

</code></pre>

<hr>
<h2 id='iscca.plot'>Plot the results of iscca</h2><span id='topic+iscca.plot'></span>

<h3>Description</h3>

<p>Plot the convergence path graph in the integrative sparse canonical correlation analysis method or show the the first pair of canonical vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iscca.plot(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iscca.plot_+3A_x">x</code></td>
<td>
<p>list of &quot;iscca&quot;, which is the result of command &quot;iscca&quot;.</p>
</td></tr>
<tr><td><code id="iscca.plot_+3A_type">type</code></td>
<td>
<p>character, &quot;path&quot; or &quot;loading&quot; type, if &quot;path&quot;, plot the the convergence path graph of vector u and v in the integrative sparse canonical correlation analysis method, if &quot;loading&quot;, show the the first pair of canonical vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in <code><a href="#topic+iscca">iscca</a></code>.
</p>


<h3>Value</h3>

<p>the convergence path graph or the scatter diagrams of the first pair of canonical vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.cca")
x &lt;- simData.cca$x
y &lt;- simData.cca$y
L &lt;- length(x)
mu1 &lt;- mu3 &lt;- 0.4
mu2 &lt;- mu4 &lt;- 2.5

res_homo_m &lt;- iscca(x = x, y = y, L = L, mu1 = mu1, mu2 = mu2, mu3 = mu3,
                    mu4 = mu4, eps = 5e-2, maxstep = 100, trace = FALSE, draw = FALSE)
iscca.plot(x = res_homo_m, type = "path")
iscca.plot(x = res_homo_m, type = "loading")
</code></pre>

<hr>
<h2 id='ispca'>Integrative sparse principal component analysis</h2><span id='topic+ispca'></span>

<h3>Description</h3>

<p>This function provides a penalty-based integrative sparse principal component analysis method to obtain the direction of first principal component of the multiple datasets with high dimensions generated under similar protocols, which consists of two built-in penalty items for selecting the important variables for users to choose, and two contrasted penalty functions for eliminating the diffierence (magnitude or sign) between estimators within each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispca(x, L, mu1, mu2, eps = 1e-04, pen1 = "homogeneity",
  pen2 = "magnitude", scale.x = TRUE, maxstep = 50,
  submaxstep = 10, trace = FALSE, draw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ispca_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="ispca_+3A_l">L</code></td>
<td>
<p>numeric, number of data sets.</p>
</td></tr>
<tr><td><code id="ispca_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="ispca_+3A_mu2">mu2</code></td>
<td>
<p>numeric, contrasted penalty parameter.</p>
</td></tr>
<tr><td><code id="ispca_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="ispca_+3A_pen1">pen1</code></td>
<td>
<p>character, &quot;homogeneity&quot; or &quot;heterogeneity&quot; type of the sparsity structure. If not specified, the default is homogeneity.</p>
</td></tr>
<tr><td><code id="ispca_+3A_pen2">pen2</code></td>
<td>
<p>character, &quot;magnitude&quot; or &quot;sign&quot; based contrasted penalty. If not specified, the default is magnitude.</p>
</td></tr>
<tr><td><code id="ispca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="ispca_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="ispca_+3A_submaxstep">submaxstep</code></td>
<td>
<p>numeric, maximum iteration steps in the sub-iterations. The default value is 10.</p>
</td></tr>
<tr><td><code id="ispca_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
<tr><td><code id="ispca_+3A_draw">draw</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, plot the convergence path of loadings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'ispca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>eigenvalue: the estimated first eigenvalue.
</p>
</li>
<li><p>eigenvector: the estimated first eigenvector.
</p>
</li>
<li><p>component: the estimated first component.
</p>
</li>
<li><p>variable: the screening results of variables.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Fang K, Fan X, Zhang Q, et al. Integrative sparse principal component analysis[J]. Journal of Multivariate Analysis, 2018, 166: 1-16.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+preview.pca">preview.pca</a></code>, <code><a href="#topic+ispca.cv">ispca.cv</a></code>, <code><a href="#topic+meta.spca">meta.spca</a></code>, <code><a href="#topic+spca">spca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a list with 3 data sets
library(iSFun)
data("simData.pca")
x &lt;- simData.pca$x
L &lt;- length(x)

prev_pca &lt;- preview.pca(x = x, L = L, scale.x = TRUE)
res_homo_m &lt;- ispca(x = x, L = L, mu1 = 0.5, mu2 = 0.002, trace = TRUE, draw = TRUE)


res_homo_s &lt;- ispca(x = x, L = L, mu1 = 0.5, mu2 = 0.002,
                    pen1 = "homogeneity", pen2 = "sign", scale.x = TRUE,
                    maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

res_hete_m &lt;- ispca(x = x, L = L, mu1 = 0.1, mu2 = 0.05,
                    pen1 = "heterogeneity", pen2 = "magnitude", scale.x = TRUE,
                    maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

res_hete_s &lt;- ispca(x = x, L = L, mu1 = 0.1, mu2 = 0.05,
                    pen1 = "heterogeneity", pen2 = "sign", scale.x = TRUE,
                    maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

</code></pre>

<hr>
<h2 id='ispca.cv'>Cross-validation for ispca</h2><span id='topic+ispca.cv'></span>

<h3>Description</h3>

<p>Performs K-fold cross validation for the integrative sparse principal component analysis over a grid of values for the regularization parameter mu1 and mu2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispca.cv(x, L, K = 5, mu1, mu2, eps = 1e-04, pen1 = "homogeneity",
  pen2 = "magnitude", scale.x = TRUE, maxstep = 50,
  submaxstep = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ispca.cv_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_k">K</code></td>
<td>
<p>numeric, number of cross-validation folds. Default is 5.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_mu1">mu1</code></td>
<td>
<p>numeric, the feasible set of sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_mu2">mu2</code></td>
<td>
<p>numeric, the feasible set of contrasted penalty parameter.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_pen1">pen1</code></td>
<td>
<p>character, &quot;homogeneity&quot; or &quot;heterogeneity&quot; type of the sparsity structure. If not specified, the default is homogeneity.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_pen2">pen2</code></td>
<td>
<p>character, &quot;magnitude&quot; or &quot;sign&quot; based contrasted penalty. If not specified, the default is magnitude.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="ispca.cv_+3A_submaxstep">submaxstep</code></td>
<td>
<p>numeric, maximum iteration steps in the sub-iterations. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'ispca.cv' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>mu1: the sparsity penalty parameter selected from the feasible set of parameter mu1 provided by users.
</p>
</li>
<li><p>mu2: the contrasted penalty parameter selected from the feasible set of parameter mu2 provided by users.
</p>
</li>
<li><p>fold: The fold assignments for cross-validation for each observation.
</p>
</li>
<li><p>eigenvalue: the estimated first eigenvalue with selected tuning parameters mu1 and mu2.
</p>
</li>
<li><p>eigenvector: the estimated first eigenvector with selected tuning parameters mu1 and mu2.
</p>
</li>
<li><p>component: the estimated first component with selected tuning parameters mu1 and mu2.
</p>
</li>
<li><p>variable: the screening results of variables.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Fang K, Fan X, Zhang Q, et al. Integrative sparse principal component analysis[J]. Journal of Multivariate Analysis, 2018, 166: 1-16.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispca">ispca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a list with 3 data sets
library(iSFun)
data("simData.pca")
x &lt;- simData.pca$x
L &lt;- length(x)
mu1 &lt;- c(0.3, 0.5)
mu2 &lt;- 0.002

res_homo_m &lt;- ispca.cv(x = x, L = L, K = 5, mu1 = mu1, mu2 = mu2, pen1 = "homogeneity",
                       pen2 = "magnitude", scale.x = TRUE, maxstep = 50, submaxstep = 10)

res_homo_s &lt;- ispca.cv(x = x, L = L, K = 5, mu1 = mu1, mu2 = mu2, pen1 = "homogeneity",
                       pen2 = "sign", scale.x = TRUE, maxstep = 50, submaxstep = 10)

mu1 &lt;- c(0.1, 0.15)
mu2 &lt;- 0.05
res_hete_m &lt;- ispca.cv(x = x, L = L, K = 5, mu1 = mu1, mu2 = mu2, pen1 = "heterogeneity",
                       pen2 = "magnitude", scale.x = TRUE, maxstep = 50, submaxstep = 10)

res_hete_s &lt;- ispca.cv(x = x, L = L, K = 5, mu1 = mu1, mu2 = mu2, pen1 = "heterogeneity",
                       pen2 = "sign", scale.x = TRUE, maxstep = 50, submaxstep = 10)

</code></pre>

<hr>
<h2 id='ispca.plot'>Plot the results of ispca</h2><span id='topic+ispca.plot'></span>

<h3>Description</h3>

<p>Plot the convergence path graph or estimated value of the first eigenvector u in the integrative sparse principal component analysis method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispca.plot(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ispca.plot_+3A_x">x</code></td>
<td>
<p>list of &quot;ispca&quot;, which is the result of command &quot;ispca&quot;.</p>
</td></tr>
<tr><td><code id="ispca.plot_+3A_type">type</code></td>
<td>
<p>character, &quot;path&quot; or &quot;loading&quot; type, if &quot;path&quot;, plot the the convergence path graph of the first eigenvector u in the integrative sparse principal component analysis method, if &quot;loading&quot;, plot the first eigenvector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in <code><a href="#topic+ispca">ispca</a></code>.
</p>


<h3>Value</h3>

<p>the convergence path graph or the scatter diagrams of the first eigenvector u.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pca")
x &lt;- simData.pca$x
L &lt;- length(x)

res_homo_m &lt;- ispca(x = x, L = L, mu1 = 0.5, mu2 = 0.002, trace = FALSE, draw = FALSE)
ispca.plot(x = res_homo_m, type = "path")
ispca.plot(x = res_homo_m, type = "loading")
</code></pre>

<hr>
<h2 id='ispls'>Integrative sparse partial least squares</h2><span id='topic+ispls'></span>

<h3>Description</h3>

<p>This function provides a penalty-based integrative sparse partial least squares method to handle the multiple datasets with high dimensions generated under similar protocols, which consists of two built-in penalty items for selecting the important variables for users to choose, and two contrasted penalty functions for eliminating the diffierence (magnitude or sign) between estimators within each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispls(x, y, L, mu1, mu2, eps = 1e-04, kappa = 0.05,
  pen1 = "homogeneity", pen2 = "magnitude", scale.x = TRUE,
  scale.y = TRUE, maxstep = 50, submaxstep = 10, trace = FALSE,
  draw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ispls_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="ispls_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="ispls_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="ispls_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="ispls_+3A_mu2">mu2</code></td>
<td>
<p>numeric, contrasted penalty parameter.</p>
</td></tr>
<tr><td><code id="ispls_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="ispls_+3A_kappa">kappa</code></td>
<td>
<p>numeric, 0 &lt; kappa &lt; 0.5 and the parameter reduces the effect of the concave part of objective function.</p>
</td></tr>
<tr><td><code id="ispls_+3A_pen1">pen1</code></td>
<td>
<p>character, &quot;homogeneity&quot; or &quot;heterogeneity&quot; type of the sparsity structure. If not specified, the default is homogeneity.</p>
</td></tr>
<tr><td><code id="ispls_+3A_pen2">pen2</code></td>
<td>
<p>character, &quot;magnitude&quot; or &quot;sign&quot; based contrasted penalty. If not specified, the default is magnitude.</p>
</td></tr>
<tr><td><code id="ispls_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="ispls_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="ispls_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="ispls_+3A_submaxstep">submaxstep</code></td>
<td>
<p>numeric, maximum iteration steps in the sub-iterations. The default value is 10.</p>
</td></tr>
<tr><td><code id="ispls_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
<tr><td><code id="ispls_+3A_draw">draw</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, plot the convergence path of loadings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'ispls' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>betahat: the estimated regression coefficients.
</p>
</li>
<li><p>loading: the estimated first direction vector.
</p>
</li>
<li><p>variable: the screening results of variables x.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Liang W, Ma S, Zhang Q, et al. Integrative sparse partial least squares[J]. Statistics in Medicine, 2021, 40(9): 2239-2256.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+preview.pls">preview.pls</a></code>, <code><a href="#topic+ispls.cv">ispls.cv</a></code>, <code><a href="#topic+meta.spls">meta.spls</a></code>, <code><a href="#topic+spls">spls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a list with 3 data sets
library(iSFun)
data("simData.pls")
x &lt;- simData.pls$x
y &lt;- simData.pls$y
L &lt;- length(x)

prev_pls &lt;- preview.pls(x, y, L, scale.x = TRUE, scale.y = TRUE)
res_homo_m &lt;- ispls(x = x, y = y, L = L, mu1 = 0.05, mu2 = 0.25,
                    eps = 5e-2, trace = TRUE, draw = TRUE)


res_homo_s &lt;- ispls(x = x, y = y, L = L, mu1 = 0.05, mu2 = 0.25,
                    eps = 5e-2, kappa = 0.05, pen1 = "homogeneity",
                    pen2 = "sign", scale.x = TRUE, scale.y = TRUE,
                    maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

res_hete_m &lt;- ispls(x = x, y = y, L = L, mu1 = 0.05, mu2 = 0.25,
                    eps = 5e-2, kappa = 0.05, pen1 = "heterogeneity",
                    pen2 = "magnitude", scale.x = TRUE, scale.y = TRUE,
                    maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

res_hete_s &lt;- ispls(x = x, y = y, L = L, mu1 = 0.05, mu2 = 0.25,
                    eps = 5e-2, kappa = 0.05, pen1 = "heterogeneity",
                    pen2 = "sign", scale.x = TRUE, scale.y = TRUE,
                    maxstep = 50, submaxstep = 10, trace = FALSE, draw = FALSE)

</code></pre>

<hr>
<h2 id='ispls.cv'>Cross-validation for ispls</h2><span id='topic+ispls.cv'></span>

<h3>Description</h3>

<p>Performs K-fold cross validation for the integrative sparse partial least squares over a grid of values for the regularization parameter mu1 and mu2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispls.cv(x, y, L, K, mu1, mu2, eps = 1e-04, kappa = 0.05,
  pen1 = "homogeneity", pen2 = "magnitude", scale.x = TRUE,
  scale.y = TRUE, maxstep = 50, submaxstep = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ispls.cv_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_k">K</code></td>
<td>
<p>numeric, number of cross-validation folds. Default is 5.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_mu1">mu1</code></td>
<td>
<p>numeric, the feasible set of sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_mu2">mu2</code></td>
<td>
<p>numeric, the feasible set of contrasted penalty parameter.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_kappa">kappa</code></td>
<td>
<p>numeric, 0 &lt; kappa &lt; 0.5 and the parameter reduces the effect of the concave part of objective function.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_pen1">pen1</code></td>
<td>
<p>character, &quot;homogeneity&quot; or &quot;heterogeneity&quot; type of the sparsity structure. If not specified, the default is homogeneity.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_pen2">pen2</code></td>
<td>
<p>character, &quot;magnitude&quot; or &quot;sign&quot; based contrasted penalty. If not specified, the default is magnitude.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="ispls.cv_+3A_submaxstep">submaxstep</code></td>
<td>
<p>numeric, maximum iteration steps in the sub-iterations. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'ispls.cv' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>mu1: the sparsity penalty parameter selected from the feasible set of parameter mu1 provided by users.
</p>
</li>
<li><p>mu2: the contrasted penalty parameter selected from the feasible set of parameter mu2 provided by users.
</p>
</li>
<li><p>fold: The fold assignments for cross-validation for each observation.
</p>
</li>
<li><p>betahat: the estimated regression coefficients with selected tuning parameters mu1 and mu2.
</p>
</li>
<li><p>loading: the estimated first direction vector with selected tuning parameters mu1 and mu2.
</p>
</li>
<li><p>variable: the screening results of variables x.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Liang W, Ma S, Zhang Q, et al. Integrative sparse partial least squares[J]. Statistics in Medicine, 2021, 40(9): 2239-2256.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispls">ispls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a list with 3 data sets
library(iSFun)
data("simData.pls")
x &lt;- simData.pls$x
y &lt;- simData.pls$y
L &lt;- length(x)
mu1 &lt;- c(0.04, 0.05)
mu2 &lt;- 0.25

res_homo_m &lt;- ispls.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, eps = 1e-2,
                       kappa = 0.05, pen1 = "homogeneity", pen2 = "magnitude",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

res_homo_s &lt;- ispls.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, eps = 1e-2,
                       kappa = 0.05, pen1 = "homogeneity", pen2 = "sign",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

res_hete_m &lt;- ispls.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, eps = 1e-2,
                       kappa = 0.05, pen1 = "heterogeneity", pen2 = "magnitude",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

res_hete_s &lt;- ispls.cv(x = x, y = y, L = L, K = 5, mu1 = mu1, mu2 = mu2, eps = 1e-2,
                       kappa = 0.05, pen1 = "heterogeneity", pen2 = "sign",
                       scale.x = TRUE, scale.y = TRUE, maxstep = 50, submaxstep = 10)

</code></pre>

<hr>
<h2 id='ispls.plot'>Plot the results of ispls</h2><span id='topic+ispls.plot'></span>

<h3>Description</h3>

<p>Plot the convergence path graph of the first direction vector w in the integrative sparse partial least squares model or show the regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispls.plot(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ispls.plot_+3A_x">x</code></td>
<td>
<p>list of &quot;ispls&quot;, which is the result of command &quot;ispls&quot;.</p>
</td></tr>
<tr><td><code id="ispls.plot_+3A_type">type</code></td>
<td>
<p>character, &quot;path&quot;, &quot;loading&quot; or &quot;heatmap&quot; type, if &quot;path&quot;, plot the the convergence path graph of vector w in the integrative sparse partial least squares model, if &quot;loading&quot;, plot the the first direction vectors, if &quot;heatmap&quot;, show the heatmap of regression coefficients among different datasets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in <code><a href="#topic+ispls">ispls</a></code>.
</p>


<h3>Value</h3>

<p>show the convergence path graph of the first direction vector w or the regression coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pls")
x &lt;- simData.pls$x
y &lt;- simData.pls$y
L &lt;- length(x)

res_homo_m &lt;- ispls(x = x, y = y, L = L, mu1 = 0.05, mu2 = 0.25,
                    eps = 5e-2, trace = FALSE, draw = FALSE)
ispls.plot(x = res_homo_m, type = "path")
ispls.plot(x = res_homo_m, type = "loading")
ispls.plot(x = res_homo_m, type = "heatmap")
</code></pre>

<hr>
<h2 id='meta.scca'>Meta-analytic sparse canonical correlation analysis method in integrative study</h2><span id='topic+meta.scca'></span>

<h3>Description</h3>

<p>This function provides penalty-based sparse canonical correlation meta-analytic method to handle the multiple datasets with high dimensions generated under similar protocols, which is based on the principle of maximizing the summary statistics S.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.scca(x, y, L, mu1, mu2, eps = 1e-04, scale.x = TRUE,
  scale.y = TRUE, maxstep = 50, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta.scca_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter for vector u.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_mu2">mu2</code></td>
<td>
<p>numeric, sparsity penalty parameter for vector v.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="meta.scca_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'meta.scca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>loading.x: the estimated canonical vector of variables x.
</p>
</li>
<li><p>loading.y: the estimated canonical vector of variables y.
</p>
</li>
<li><p>variable.x: the screening results of variables x.
</p>
</li>
<li><p>variable.y: the screening results of variables y.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Cichonska A, Rousu J, Marttinen P, et al. metaCCA: summary statistics-based multivariate meta-analysis of genome-wide association studies using canonical correlation analysis[J]. Bioinformatics, 2016, 32(13): 1981-1989.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+iscca">iscca</a></code>, <code><a href="#topic+scca">scca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a list with 3 data sets
library(iSFun)
data("simData.cca")
x &lt;- simData.cca$x
y &lt;- simData.cca$y
L &lt;- length(x)
mu1 &lt;- 0.08
mu2 &lt;- 0.08

res &lt;- meta.scca(x = x, y = y, L = L, mu1 = mu1, mu2 = mu2, trace = TRUE)
</code></pre>

<hr>
<h2 id='meta.spca'>Meta-analytic sparse principal component analysis method in integrative study</h2><span id='topic+meta.spca'></span>

<h3>Description</h3>

<p>This function provides penalty-based sparse principal component meta-analytic method to handle the multiple datasets with high dimensions generated under similar protocols, which is based on the principle of maximizing the summary statistics S.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.spca(x, L, mu1, eps = 1e-04, scale.x = TRUE, maxstep = 50,
  trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta.spca_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="meta.spca_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="meta.spca_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="meta.spca_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="meta.spca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="meta.spca_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="meta.spca_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'meta.spca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>eigenvalue: the estimated first eigenvalue.
</p>
</li>
<li><p>eigenvector: the estimated first eigenvector.
</p>
</li>
<li><p>component: the estimated first component.
</p>
</li>
<li><p>variable: the screening results of variables.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Kim S H, Kang D, Huo Z, et al. Meta-analytic principal component analysis in integrative omics application[J]. Bioinformatics, 2018, 34(8): 1321-1328.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispca">ispca</a></code>, <code><a href="#topic+spca">spca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pca")
x &lt;- simData.pca$x
L &lt;- length(x)

res &lt;- meta.spca(x = x, L = L, mu1 = 0.5, trace = TRUE)
</code></pre>

<hr>
<h2 id='meta.spls'>Meta-analytic sparse partial least squares method in integrative study</h2><span id='topic+meta.spls'></span>

<h3>Description</h3>

<p>This function provides penalty-based sparse canonical correlation meta-analytic method to handle the multiple datasets with high dimensions generated under similar protocols, which is based on the principle of maximizing the summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.spls(x, y, L, mu1, eps = 1e-04, kappa = 0.05, scale.x = TRUE,
  scale.y = TRUE, maxstep = 50, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta.spls_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_kappa">kappa</code></td>
<td>
<p>numeric, 0 &lt; kappa &lt; 0.5 and the parameter reduces the effect of the concave part of objective function.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="meta.spls_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'meta.spls' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>betahat: the estimated regression coefficients.
</p>
</li>
<li><p>loading: the estimated first direction vector.
</p>
</li>
<li><p>variable: the screening results of variables x.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispls">ispls</a></code>, <code><a href="#topic+spls">spls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pls")
x &lt;- simData.pls$x
y &lt;- simData.pls$y
L &lt;- length(x)

res &lt;- meta.spls(x = x, y = y, L = L, mu1 = 0.03, trace = TRUE)
</code></pre>

<hr>
<h2 id='preview.cca'>Statistical description before using function iscca</h2><span id='topic+preview.cca'></span>

<h3>Description</h3>

<p>The function describes the basic statistical information of the data, including sample mean, sample variance of X and Y, and the first pair of canonical vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview.cca(x, y, L, scale.x = TRUE, scale.y = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preview.cca_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="preview.cca_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="preview.cca_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="preview.cca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="preview.cca_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'preview.cca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>loading.x: the estimated canonical vector of variables x.
</p>
</li>
<li><p>loading.y: the estimated canonical vector of variables y.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+iscca">iscca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a list with 3 data sets
library(iSFun)
data("simData.cca")
x &lt;- simData.cca$x
y &lt;- simData.cca$y
L &lt;- length(x)

prev_cca &lt;- preview.cca(x = x, y = y, L = L, scale.x = TRUE, scale.y = TRUE)

</code></pre>

<hr>
<h2 id='preview.pca'>Statistical description before using function ispca</h2><span id='topic+preview.pca'></span>

<h3>Description</h3>

<p>The function describes the basic statistical information of the data, including sample mean, sample co-variance of X and Y, the first eigenvector, eigenvalue and principal component, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview.pca(x, L, scale.x = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preview.pca_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="preview.pca_+3A_l">L</code></td>
<td>
<p>numeric, number of data sets.</p>
</td></tr>
<tr><td><code id="preview.pca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'preview.pca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>eigenvalue: the estimated first eigenvalue.
</p>
</li>
<li><p>eigenvector: the estimated first eigenvector.
</p>
</li>
<li><p>component: the estimated first component.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispca">ispca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a list with 3 data sets
library(iSFun)
data("simData.pca")
x &lt;- simData.pca$x
L &lt;- length(x)

prev.pca &lt;- preview.pca(x = x, L = L, scale.x = TRUE)

</code></pre>

<hr>
<h2 id='preview.pls'>Statistical description before using function ispls</h2><span id='topic+preview.pls'></span>

<h3>Description</h3>

<p>The function describes the basic statistical information of the data, including sample mean, sample variance of X and Y, the first direction of partial least squares method, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview.pls(x, y, L, scale.x = TRUE, scale.y = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preview.pls_+3A_x">x</code></td>
<td>
<p>list of data matrices, L datasets of explanatory variables.</p>
</td></tr>
<tr><td><code id="preview.pls_+3A_y">y</code></td>
<td>
<p>list of data matrices, L datasets of dependent variables.</p>
</td></tr>
<tr><td><code id="preview.pls_+3A_l">L</code></td>
<td>
<p>numeric, number of datasets.</p>
</td></tr>
<tr><td><code id="preview.pls_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="preview.pls_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'preview.pls' object that contains the list of the following items.
</p>

<ul>
<li><p>x: list of data matrices, L datasets of explanatory variables with centered columns. If scale.x is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: list of data matrices, L datasets of dependent variables with centered columns. If scale.y is TRUE, the columns of L datasets are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>loading: the estimated first direction vector.
</p>
</li>
<li><p>meanx: list of numeric vectors, column mean of the original datasets x.
</p>
</li>
<li><p>normx: list of numeric vectors, column standard deviation of the original datasets x.
</p>
</li>
<li><p>meany: list of numeric vectors, column mean of the original datasets y.
</p>
</li>
<li><p>normy: list of numeric vectors, column standard deviation of the original datasets y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispls">ispls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pls")
x &lt;- simData.pls$x
y &lt;- simData.pls$y
L &lt;- length(x)

prev_pls &lt;- preview.pls(x = x, y = y, L = L, scale.x = TRUE, scale.y = TRUE)
</code></pre>

<hr>
<h2 id='scca'>Sparse canonical correlation analysis</h2><span id='topic+scca'></span>

<h3>Description</h3>

<p>This function provides penalty-based sparse canonical correlation analysis to get the first pair of canonical vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scca(x, y, mu1, mu2, eps = 1e-04, scale.x = TRUE, scale.y = TRUE,
  maxstep = 50, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scca_+3A_x">x</code></td>
<td>
<p>data matrix of explanatory variables</p>
</td></tr>
<tr><td><code id="scca_+3A_y">y</code></td>
<td>
<p>data matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="scca_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter for vector u.</p>
</td></tr>
<tr><td><code id="scca_+3A_mu2">mu2</code></td>
<td>
<p>numeric, sparsity penalty parameter for vector v.</p>
</td></tr>
<tr><td><code id="scca_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="scca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="scca_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="scca_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="scca_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'scca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: data matrix of explanatory variables with centered columns. If scale.x is TRUE, the columns of data matrix are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: data matrix of dependent variables with centered columns. If scale.y is TRUE, the columns of data matrix are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>loading.x: the estimated canonical vector of variables x.
</p>
</li>
<li><p>loading.y: the estimated canonical vector of variables y.
</p>
</li>
<li><p>variable.x: the screening results of variables x.
</p>
</li>
<li><p>variable.y: the screening results of variables y.
</p>
</li>
<li><p>meanx: column mean of the original dataset x.
</p>
</li>
<li><p>normx: column standard deviation of the original dataset x.
</p>
</li>
<li><p>meany: column mean of the original dataset y.
</p>
</li>
<li><p>normy: column standard deviation of the original dataset y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+iscca">iscca</a></code>, <code><a href="#topic+meta.scca">meta.scca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.cca")
x.scca &lt;- do.call(rbind, simData.cca$x)
y.scca &lt;- do.call(rbind, simData.cca$y)
res_scca &lt;- scca(x = x.scca, y = y.scca, mu1 = 0.1, mu2 = 0.1, eps = 1e-3,
                 scale.x = TRUE, scale.y = TRUE, maxstep = 50, trace = FALSE)
</code></pre>

<hr>
<h2 id='simData.cca'>Example data for method iscca</h2><span id='topic+simData.cca'></span>

<h3>Description</h3>

<p>Example data for users to apply the method iscca, iscca.cv, meta.scca or scca.
</p>


<h3>Format</h3>

<p>list</p>

<hr>
<h2 id='simData.pca'>Example data for method ispca</h2><span id='topic+simData.pca'></span>

<h3>Description</h3>

<p>Example data for users to apply the method ispca, ispca.cv, meta.spca or spca.
</p>


<h3>Format</h3>

<p>list</p>

<hr>
<h2 id='simData.pls'>Example data for method ispls</h2><span id='topic+simData.pls'></span>

<h3>Description</h3>

<p>Example data for users to apply the method ispls, ispls.cv, meta.spls or spls.
</p>


<h3>Format</h3>

<p>list</p>

<hr>
<h2 id='spca'>Sparse principal component analysis</h2><span id='topic+spca'></span>

<h3>Description</h3>

<p>This function provides penalty-based integrative sparse principal component analysis to obtain the direction of first principal component of a given dataset with high dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spca(x, mu1, eps = 1e-04, scale.x = TRUE, maxstep = 50,
  trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spca_+3A_x">x</code></td>
<td>
<p>data matrix of explanatory variables.</p>
</td></tr>
<tr><td><code id="spca_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="spca_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="spca_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="spca_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="spca_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'spca' object that contains the list of the following items.
</p>

<ul>
<li><p>x: data matrix of explanatory variables with centered columns. If scale.x is TRUE, the columns of data matrix are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>eigenvalue: the estimated first eigenvalue.
</p>
</li>
<li><p>eigenvector: the estimated first eigenvector.
</p>
</li>
<li><p>component: the estimated first principal component.
</p>
</li>
<li><p>variable: the screening results of variables.
</p>
</li>
<li><p>meanx: column mean of the original dataset x.
</p>
</li>
<li><p>normx: column standard deviation of the original dataset x.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispca">ispca</a></code>, <code><a href="#topic+meta.spca">meta.spca</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pca")
x.spca &lt;- do.call(rbind, simData.pca$x)
res_spca &lt;- spca(x = x.spca, mu1 = 0.08, eps = 1e-3, scale.x = TRUE,
                 maxstep = 50, trace = FALSE)
</code></pre>

<hr>
<h2 id='spls'>Sparse partial least squares</h2><span id='topic+spls'></span>

<h3>Description</h3>

<p>This function provides penalty-based sparse partial least squares analysis for single dataset with high dimensions., which aims to have the direction of the first loading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spls(x, y, mu1, eps = 1e-04, kappa = 0.05, scale.x = TRUE,
  scale.y = TRUE, maxstep = 50, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spls_+3A_x">x</code></td>
<td>
<p>matrix of explanatory variables.</p>
</td></tr>
<tr><td><code id="spls_+3A_y">y</code></td>
<td>
<p>matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="spls_+3A_mu1">mu1</code></td>
<td>
<p>numeric, sparsity penalty parameter.</p>
</td></tr>
<tr><td><code id="spls_+3A_eps">eps</code></td>
<td>
<p>numeric, the threshold at which the algorithm terminates.</p>
</td></tr>
<tr><td><code id="spls_+3A_kappa">kappa</code></td>
<td>
<p>numeric, 0 &lt; kappa &lt; 0.5 and the parameter reduces the effect of the concave part of objective function.</p>
</td></tr>
<tr><td><code id="spls_+3A_scale.x">scale.x</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables x. The default is TRUE.</p>
</td></tr>
<tr><td><code id="spls_+3A_scale.y">scale.y</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;, whether or not to scale the variables y. The default is TRUE.</p>
</td></tr>
<tr><td><code id="spls_+3A_maxstep">maxstep</code></td>
<td>
<p>numeric, maximum iteration steps. The default value is 50.</p>
</td></tr>
<tr><td><code id="spls_+3A_trace">trace</code></td>
<td>
<p>character, &quot;TRUE&quot; or &quot;FALSE&quot;. If TRUE, prints out its screening results of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'spls' object that contains the list of the following items.
</p>

<ul>
<li><p>x: data matrix of explanatory variables with centered columns. If scale.x is TRUE, the columns of data matrix are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>y: data matrix of dependent variables with centered columns. If scale.y is TRUE, the columns of data matrix are standardized to have mean 0 and standard deviation 1.
</p>
</li>
<li><p>betahat: the estimated regression coefficients.
</p>
</li>
<li><p>loading: the estimated first direction vector.
</p>
</li>
<li><p>variable: the screening results of variables.
</p>
</li>
<li><p>meanx: column mean of the original dataset x.
</p>
</li>
<li><p>normx: column standard deviation of the original dataset x.
</p>
</li>
<li><p>meany: column mean of the original dataset y.
</p>
</li>
<li><p>normy: column standard deviation of the original dataset y.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Also as <code><a href="#topic+ispls">ispls</a></code>, <code><a href="#topic+meta.spls">meta.spls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(iSFun)
data("simData.pls")
x.spls &lt;- do.call(rbind, simData.pls$x)
y.spls &lt;- do.call(rbind, simData.pls$y)
res_spls &lt;- spls(x = x.spls, y = y.spls, mu1 = 0.05, eps = 1e-3, kappa = 0.05,
                 scale.x = TRUE, scale.y = TRUE, maxstep = 50, trace = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
