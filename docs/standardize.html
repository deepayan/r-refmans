<!DOCTYPE html><html><head><title>Help for package standardize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {standardize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fac_and_contr'><p>Create a factor and specify contrasts.</p></a></li>
<li><a href='#is.standardized'><p>Determine if an object has class <code>standardized</code>.</p></a></li>
<li><a href='#makepredictcall.scaledby'><p>S3 <code>makepredictcall</code> method for class <code>scaledby</code>.</p></a></li>
<li><a href='#named_contr_sum'><p>Create named sum contrasts for an unordered factor.</p></a></li>
<li><a href='#predict.standardized'><p>Place new data into an already existing standardized space.</p></a></li>
<li><a href='#print.standardized'><p>S3 <code>print</code> method for class <code>standardized</code>.</p></a></li>
<li><a href='#ptk'><p>Duration and voicing measures of voiceless plosives in Spanish</p></a></li>
<li><a href='#scale_by'><p>Center and scale a continuous variable conditioning on factors.</p></a></li>
<li><a href='#scaled_contr_poly'><p>Create scaled orthogonal polynomial contrasts for an ordered factor.</p></a></li>
<li><a href='#standardize'><p>Standardize a formula and data frame for regression.</p></a></li>
<li><a href='#standardize-package'><p>standardize: Tools for Standardizing Variables for Regression in R.</p></a></li>
<li><a href='#standardize.news'><p>Print the version history of the <code>standardize</code> package.</p></a></li>
<li><a href='#standardized-class'><p>Class <code>standardized</code> containing regression variables in a standardized space.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Standardizing Variables for Regression in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools which allow regression variables to be placed on similar
    scales, offering computational benefits as well as easing interpretation of
    regression output.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lme4, MASS, methods, stats, stringr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CDEager/standardize">https://github.com/CDEager/standardize</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CDEager/standardize/issues">https://github.com/CDEager/standardize/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>afex, emmeans, knitr, lmerTest, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-04 11:41:23 UTC; coreml</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher D. Eager [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher D. Eager &lt;eager.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-05 06:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='fac_and_contr'>Create a factor and specify contrasts.</h2><span id='topic+fac_and_contr'></span>

<h3>Description</h3>

<p>The <code>fac_and_contr</code> function is a convenience function which coerces
<code>x</code> to a factor with specified <code>levels</code> and <code>contrasts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac_and_contr(x, levels, contrasts, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac_and_contr_+3A_x">x</code></td>
<td>
<p>An object coercible to <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="fac_and_contr_+3A_levels">levels</code></td>
<td>
<p>A character vector of levels for the factor.</p>
</td></tr>
<tr><td><code id="fac_and_contr_+3A_contrasts">contrasts</code></td>
<td>
<p>A matrix of <code><a href="stats.html#topic+contrasts">contrasts</a></code> for the factor.</p>
</td></tr>
<tr><td><code id="fac_and_contr_+3A_ordered">ordered</code></td>
<td>
<p>A logical indicating whether or not the factor is ordered
(default <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+named_contr_sum">named_contr_sum</a></code> (unordered factors) and
<code><a href="#topic+scaled_contr_poly">scaled_contr_poly</a></code> (ordered factors).
</p>

<hr>
<h2 id='is.standardized'>Determine if an object has class <code><a href="#topic+standardized-class">standardized</a></code>.</h2><span id='topic+is.standardized'></span>

<h3>Description</h3>

<p>Determine if an object has class <code><a href="#topic+standardized-class">standardized</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.standardized(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.standardized_+3A_object">object</code></td>
<td>
<p>Any R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>object</code> is the result of a <code><a href="#topic+standardize">standardize</a></code>
call and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>

<hr>
<h2 id='makepredictcall.scaledby'>S3 <code><a href="stats.html#topic+makepredictcall">makepredictcall</a></code> method for class <code>scaledby</code>.</h2><span id='topic+makepredictcall.scaledby'></span>

<h3>Description</h3>

<p>Allows <code><a href="#topic+scale_by">scale_by</a></code> to be used within a regression
<code><a href="stats.html#topic+formula">formula</a></code> and ensures that the <code>predvars</code> attribute
makes the correct call to <code>scale_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scaledby'
makepredictcall(var, call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makepredictcall.scaledby_+3A_var">var</code>, <code id="makepredictcall.scaledby_+3A_call">call</code></td>
<td>
<p>See <code><a href="stats.html#topic+makepredictcall">makepredictcall</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>

<hr>
<h2 id='named_contr_sum'>Create named sum contrasts for an unordered factor.</h2><span id='topic+named_contr_sum'></span>

<h3>Description</h3>

<p><code>named_contr_sum</code> creates sum contrasts for a factor which are named
with the levels of the factor rather than with numbers (e.g. if a factor
<code>f1</code> has levels <code>A</code>, <code>B</code>, and <code>C</code>, then rather than
creating contrast columns <code>f11</code> and <code>f12</code>, it creates columns
<code>f1A</code> and <code>f1B</code>).  The absolute value of the non-zero elements
of the matrix can also be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_contr_sum(x, scale = 1, return_contr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="named_contr_sum_+3A_x">x</code></td>
<td>
<p>An object coercible to factor or a numeric or character vector of
levels.</p>
</td></tr>
<tr><td><code id="named_contr_sum_+3A_scale">scale</code></td>
<td>
<p>A positive number by which the entire contrast
matrix returned by <code><a href="stats.html#topic+contr.sum">contr.sum</a></code> is multiplied.  See
'Details'.</p>
</td></tr>
<tr><td><code id="named_contr_sum_+3A_return_contr">return_contr</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default), a contrast
matrix is returned. If <code>FALSE</code>, <code>x</code> is converted to an unordered
factor with the contrast matrix applied, and the factor is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, <code>x</code> is coerced to factor, and its levels (excluding <code>NA</code>)
are sorted alphabetically.  If there are two unique values, and they are
equal to (ignoring case) &quot;F&quot; and &quot;T&quot;, &quot;FALSE&quot; and &quot;TRUE&quot;, &quot;N&quot; and &quot;Y&quot;,
&quot;NO&quot; and &quot;YES&quot;, or &quot;0&quot; and &quot;1&quot;, then their order is reversed (this makes it
so the positive level gets the dummy coefficient rather than the negative
level, yielding a more intuitive interpretation for coefficients).  Then
<code><a href="stats.html#topic+contr.sum">contr.sum</a></code> is called, and the column names of the
resulting contrast matrix are set using the character vector of unique values
(excluding the final element that gets coded as <code>-1</code> for all dummy
variables).  This entire matrix is then multiplied by <code>scale</code>; with
the default value of <code>1</code>, this does not change the matrix; if, for
example, <code>scale = 0.5</code>, then rather than each column containing values
in <code>-1, 0, 1</code>, each column would contain values in <code>-0.5, 0, 0.5</code>.
If <code>return_contr = TRUE</code>, then this contrast matrix is
returned.  If <code>return_contr = FALSE</code>, then <code>x</code> is converted to an
unordered factor with the named sum contrasts and returned. <code>NA</code> is never
assigned as a level in the contrast matrix or in the factor returned by the
function, but <code>NA</code> values in <code>x</code> are not removed in the factor
returned when <code>return_contr = FALSE</code>. See the examples.
</p>


<h3>Value</h3>

<p>If <code>return_contr = TRUE</code>, a contrast matrix obtained from
<code><a href="stats.html#topic+contr.sum">contr.sum</a></code> with named columns rather than numbered
columns and deviations with magnitude <code>scale</code>.
If <code>return_contr = FALSE</code>, then <code>x</code> is returned
as an unordered factor with the named sum contrasts applied.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scaled_contr_poly">scaled_contr_poly</a></code> for ordered factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- factor(rep(c("a", "b", "c", NA), 2), levels = c("b", "c", "a"))
f &lt;- addNA(f)
levels(f)  # NA listed as factor level
contrasts(f)  # NA included in contrast matrix
named_contr_sum(f)  # named sum contrasts (NA dropped; levels alphabetized)
named_contr_sum(levels(f))  # same output
named_contr_sum(f, return_contr = FALSE)  # factor with named sum contrasts
named_contr_sum(f, 0.5)  # deviations of magniude 0.5

f &lt;- c(TRUE, FALSE, FALSE, TRUE)
class(f)  # logical
named_contr_sum(f)  # TRUE gets the dummy variable
f &lt;- named_contr_sum(f, return_contr = FALSE)
class(f)  # factor

named_contr_sum(letters[1:5])  # character argument
named_contr_sum(rep(letters[1:5], 2), return_contr = FALSE)  # creates factor

# ordered factors are converted to unordered factors, so use with caution
f &lt;- factor(rep(1:3, 2), ordered = TRUE)
is.ordered(f)  # TRUE
f
f &lt;- named_contr_sum(f, return_contr = FALSE)
is.ordered(f)  # FALSE
f

## Not run: 
# error from stats::contr.sum because only one unique non-NA value
named_contr_sum(5)
named_contr_sum(rep(c("a", NA), 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.standardized'>Place new data into an already existing standardized space.</h2><span id='topic+predict.standardized'></span>

<h3>Description</h3>

<p>To put new data into the same standardized space as the data in the
<code><a href="#topic+standardized-class">standardized</a></code> object,
<code>predict</code> can be used with the <code>standardized</code> object as the first
argument.  The <code>predict</code> method also allows logicals <code>response</code>,
<code>fixed</code>, and <code>random</code> to be used to specify which elements of the
original data frame are present in <code>newdata</code>.  A regression model
fit with the <code>formula</code> and <code>data</code> elements of a
<code><a href="#topic+standardized-class">standardized</a></code> object cannot be used to
directly predict the response variable for new data.  The new data must
first be placed into the standardized space. If offsets were included
in the <code>formula</code> argument used to create the <code>standardized</code> object,
then when <code>fixed = TRUE</code> the offset variables must be in <code>newdata</code>.
If an offset was passed to the <code>offset</code> argument in the call to
<code><a href="#topic+standardize">standardize</a></code>, then the offset cannot be passed to <code>predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'standardized'
predict(
  object,
  newdata = NULL,
  response = FALSE,
  fixed = TRUE,
  random = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.standardized_+3A_object">object</code></td>
<td>
<p>An object of class <code>standardized</code>.</p>
</td></tr>
<tr><td><code id="predict.standardized_+3A_newdata">newdata</code></td>
<td>
<p>Data to be placed into the same standardized space as the
data in the call to <code><a href="#topic+standardize">standardize</a></code> which produced the
<code><a href="#topic+standardized-class">standardized</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.standardized_+3A_response">response</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether
<code>newdata</code> contains the response variable.</p>
</td></tr>
<tr><td><code id="predict.standardized_+3A_fixed">fixed</code></td>
<td>
<p>A logical (default <code>TRUE</code>) indicating whether
<code>newdata</code> contains variables pertaining to the fixed effects.</p>
</td></tr>
<tr><td><code id="predict.standardized_+3A_random">random</code></td>
<td>
<p>A logical (default <code>TRUE</code>) indicating whether
<code>newdata</code> contains variables pertaining to the random effects.</p>
</td></tr>
<tr><td><code id="predict.standardized_+3A_...">...</code></td>
<td>
<p>Ignored with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the <code>newdata</code> standardized using the
<code>pred</code> element of the <code><a href="#topic+standardized-class">standardized</a></code>
object.
</p>


<h3>Note</h3>

<p>You may see a warning &quot;contrasts dropped from factor &lt;x&gt;&quot; for
each factor when predicting new data with a fitted model object, but this
warning can be ignored (the actual predictions will still be correct).
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
train &lt;- subset(mydata, train)
test &lt;- subset(mydata, !train)
train.s &lt;- standardize(y ~ x1 + f1 + (1 | g1), train)
mod &lt;- lmer(train.s$formula, train.s$data)
test.s &lt;- predict(train.s, test, response = TRUE)
preds &lt;- predict(mod, newdata = test.s)  # can ignore warning about dropped contrasts
res &lt;- test.s$y - preds

## End(Not run)
</code></pre>

<hr>
<h2 id='print.standardized'>S3 <code>print</code> method for class <code><a href="#topic+standardized-class">standardized</a></code>.</h2><span id='topic+print.standardized'></span>

<h3>Description</h3>

<p>S3 <code>print</code> method for class <code><a href="#topic+standardized-class">standardized</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'standardized'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.standardized_+3A_x">x</code></td>
<td>
<p>An object of class <code>standardized</code>.</p>
</td></tr>
<tr><td><code id="print.standardized_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>

<hr>
<h2 id='ptk'>Duration and voicing measures of voiceless plosives in Spanish</h2><span id='topic+ptk'></span>

<h3>Description</h3>

<p>A dataset containing measures of total duration and voiceless period duration
for instances of intervocalic Spanish /p/, /t/, and /k/.  The data are taken
from 18 speakers in the task dialogues in the Spanish portion of the Glissando
Corpus (the speakers are university students in Valladolid, Spain).
If you analyze the <code>ptk</code> dataset in a publication, please cite Eager
(2017) from the references section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptk
</code></pre>


<h3>Format</h3>

<p>A data frame with 751 rows and 11 variables:
</p>

<dl>
<dt>cdur</dt><dd><p>Total plosive duration, measured from preceding vowel intensity
maximum to following vowel intensity maximum, in milliseconds.</p>
</dd>
<dt>vdur</dt><dd><p>Duration of the period of voicelessness in the
vowel-consonant-vowel sequence in milliseconds.</p>
</dd>
<dt>place</dt><dd><p>Place of articulation (Bilabial, Dental, or Velar).</p>
</dd>
<dt>stress</dt><dd><p>Syllabic stress context (Tonic, Post-Tonic, or Unstressed).</p>
</dd>
<dt>prevowel</dt><dd><p>Preceding vowel phoneme identity (a, e, i, o, or u).</p>
</dd>
<dt>posvowel</dt><dd><p>Following vowel phoneme identity (a, e, i, o, or u).</p>
</dd>
<dt>wordpos</dt><dd><p>Position of the plosive in the word (Initial or Medial).</p>
</dd>
<dt>wordfreq</dt><dd><p>Number of times the word containing the plosive occurs in
the CREA corpus.</p>
</dd>
<dt>speechrate</dt><dd><p>Local speech rate around the consonant in nuclei per
second.</p>
</dd>
<dt>sex</dt><dd><p>The speaker's sex (Female or Male).</p>
</dd>
<dt>speaker</dt><dd><p>Speaker identifier (s01 through s18).</p>
</dd>
</dl>



<h3>References</h3>

<p>Eager, Christopher D. (2017). Contrast preservation and constraints on
individual phonetic variation. Doctoral thesis. University of Illinois at
Urbana-Champaign.
</p>
<p>Garrido, J. M., Escudero, D., Aguilar, L., Cardeñoso, V., Rodero, E.,
de-la-Mota, C., … Bonafonte, A. (2013). Glissando: a corpus for
multidisciplinary prosodic studies in Spanish and Catalan. Language Resources
and Evaluation, 47(4), 945–971.
</p>
<p>Real Academia Española. Corpus de referencia del español actual (CREA). Banco
de Datos. Retrieved from http://www.rae.es
</p>
<p>De Jong, N. H., &amp; Wempe, T. (2009). Praat script to detect syllable nuclei
and measure speech rate automatically. Behavior Research Methods, 41(2),
385–390.
</p>

<hr>
<h2 id='scale_by'>Center and scale a continuous variable conditioning on factors.</h2><span id='topic+scale_by'></span>

<h3>Description</h3>

<p><code>scale_by</code> centers and scales a numeric variable within each level
of a factor (or the interaction of several factors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_by(object = NULL, data = NULL, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_by_+3A_object">object</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> whose left hand side indicates
a numeric variable to be scaled and whose right hand side indicates
factors to condition this scaling on; or the result of a previous call
to <code>scale_by</code> or the <code>pred</code> attribute of a previous call.
See 'Details'.</p>
</td></tr>
<tr><td><code id="scale_by_+3A_data">data</code></td>
<td>
<p>A data.frame containing the numeric variable to be scaled and
the factors to condition on.</p>
</td></tr>
<tr><td><code id="scale_by_+3A_scale">scale</code></td>
<td>
<p>Numeric (default 1).  The desired standard deviation for the
numeric variable within-factor-level.  If the numeric variable is a matrix,
then <code>scale</code> must have either one element (used for all columns),
or as many elements as there are columns in the numeric variable. To center
the numeric variable without scaling, set <code>scale</code> to <code>0</code>.
See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the behavior when <code>object</code> is a formula and <code>scale = 1</code>
is described.
The left hand side of the formula must indicate a numeric variable
to be scaled.  The full interaction of the variables on the right hand side
of the formula is taken as the factor to condition scaling on (i.e.
it doesn't matter whether they are separated with <code>+</code>, <code>:</code>, or
<code>*</code>).  For the remainder of this section, the numeric variable will
be referred to as <code>x</code> and the full factor interaction term will be
referred to as <code>facs</code>.
</p>
<p>First, if <code>facs</code> has more than one element, then a new factor is
created as their full interaction term.  When a factor has <code>NA</code> values,
<code>NA</code> is treated as a level.  For each level of the factor which has
at least two unique non-<code>NA</code> <code>x</code> values, the mean of <code>x</code>
is recorded as the level's center and the standard deviation of <code>x</code>
is recorded as the level's scale. The mean of these
centers is recorded as <code>new_center</code> and the mean of these scales
is recorded as <code>new_scale</code>, and <code>new_center</code> and
<code>new_scale</code> are used as the center and scale for factor levels with
fewer than two unique non-<code>NA</code> <code>x</code> values. Then for each level of
the factor, the level's center is subtracted from its <code>x</code> values, and
the result is divided by the level's scale.
The result is that any level with more than two unique non-<code>NA</code> <code>x</code>
values now has mean <code>0</code> and standard deviation <code>1</code>, and levels
with fewer than two are placed on a similar scale (though their standard
deviation is undefined).  Note that the overall standard deviation of the
resulting variable (or standard deviations if <code>x</code> is a matrix) will not
be exactly <code>1</code> (but will be close).  The interpretation of the
variable is how far an observation is from its level's average value for
<code>x</code> in terms of within-level standard deviations.
</p>
<p>If <code>scale = 0</code>, then only centering (but not scaling) is performed.
If <code>scale</code> is neither <code>0</code> nor <code>1</code>, then <code>x</code> is scaled
such that the standard deviation within-level is <code>scale</code>.  Note that
this is different than the <code>scale</code> argument to <code><a href="base.html#topic+scale">scale</a></code>
which specifies the number the centered variable is divided by (which is
the inverse of the use here).  If <code>x</code> is a matrix with more than
one column, then <code>scale</code> must either be a vector with an element for
each column of <code>x</code> or a single number which will be used for all
columns.  If any element of <code>scale</code> is <code>0</code>, then all elements are
treated as <code>0</code>.  No element in <code>scale</code> can be negative.
</p>
<p>If <code>object</code> is not a formula, it must be a numeric variable which
resulted from a previous <code>scale_by</code> call, or the <code>pred</code> attribute
of such a numeric variable. In this case, <code>scale</code>
is ignored, and <code>x</code> in <code>data</code> is scaled
using the <code>formula</code>, <code>centers</code> and <code>scales</code> in <code>object</code>
(with new levels treated using <code>new_center</code> and <code>new_scale</code>).
</p>


<h3>Value</h3>

<p>A numeric variable which is conditionally scaled within each level
of the conditioning factor(s), with standard deviation <code>scale</code>.  It has
an additional class <code>scaledby</code>, as well as an attribute
<code>pred</code> with class <code>scaledby_pred</code>, which is a list containing
the formula, the centers and scales for known factor levels, and the
center and scale to be applied to new factor levels.  The variable returned
can be used as the <code>object</code> argument in future calls to
<code>scale_by</code>, as can its <code>pred</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
  f1 = rep(c("a", "b", "c"), c(5, 10, 20)),
  x1 = rnorm(35, rep(c(1, 2, 3), c(5, 10, 20)),
    rep(c(.5, 1.5, 3), c(5, 10, 20))))

dat$x1_scaled &lt;- scale(dat$x1)
dat$x1_scaled_by_f1 &lt;- scale_by(x1 ~ f1, dat)

mean(dat$x1)
sd(dat$x1)
with(dat, tapply(x1, f1, mean))
with(dat, tapply(x1, f1, sd))

mean(dat$x1_scaled)
sd(dat$x1_scaled)
with(dat, tapply(x1_scaled, f1, mean))
with(dat, tapply(x1_scaled, f1, sd))

mean(dat$x1_scaled_by_f1)
sd(dat$x1_scaled_by_f1)
with(dat, tapply(x1_scaled_by_f1, f1, mean))
with(dat, tapply(x1_scaled_by_f1, f1, sd))

newdata &lt;- data.frame(
  f1 = c("a", "b", "c", "d"),
  x1 = rep(1, 4))

newdata$x1_pred_scaledby &lt;- scale_by(dat$x1_scaled_by_f1, newdata)

newdata
</code></pre>

<hr>
<h2 id='scaled_contr_poly'>Create scaled orthogonal polynomial contrasts for an ordered factor.</h2><span id='topic+scaled_contr_poly'></span>

<h3>Description</h3>

<p>The function <code><a href="stats.html#topic+contr.poly">contr.poly</a></code> creates orthogonal polynomial
contrasts for an ordered factor, with the standard deviations of the
columns in the contrast matrix determined by the number of columns.  The
<code>scaled_contr_poly</code> function takes this contrast matrix and alters
the scale so that the standard deviations of the columns all equal
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_contr_poly(x, scale = 1, return_contr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaled_contr_poly_+3A_x">x</code></td>
<td>
<p>A factor, a numeric or character vector of levels ordered least to
greatest, or a single integer greater than or equal to <code>3</code>.
See 'Details'.</p>
</td></tr>
<tr><td><code id="scaled_contr_poly_+3A_scale">scale</code></td>
<td>
<p>A single positive number indicating the standard deviation
for the columns of the contrast matrix. Default is 1.</p>
</td></tr>
<tr><td><code id="scaled_contr_poly_+3A_return_contr">return_contr</code></td>
<td>
<p>A logical indicating whether the contrast matrix should
be returned, or <code>x</code> as an ordered factor with the contrasts applied.
See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a factor, then the non-<code>NA</code> levels of <code>x</code> are used
as the levels for the contrast matrix.  If <code>x</code> is a vector,
then the unique non-<code>NA</code> values in <code>x</code> in the order in which
they appear in <code>x</code> are used as the levels for the contrast matrix.
If <code>x</code> is a single integer greater than or equal to <code>3</code>, then
the numbers <code>1:x</code> are used as the levels for the contrast matrix.  Any
other value for <code>x</code> results in an error (if <code>x = 2</code>, then
polynomial contrasts are technically possible, but all binary predictors
should be treated as unordered factors and coded with sum contrasts).
<code><a href="stats.html#topic+contr.poly">contr.poly</a></code> is then called to obtain an orthogonal
polynomial contrast matrix of the appropriate degree. The contrast matrix is
is put on unit scale and then multiplied by the <code>scale</code> argument,
resulting in an orthogonal polynomial contrast matrix where
each column has standard deviation <code>scale</code>.  If
<code>return_contr = TRUE</code>, the contrast matrix is returned.  If
<code>return_contr = FALSE</code>, then <code>x</code> is coerced to
an ordered factor with the contrast matrix applied, and <code>x</code> is returned.
<code>NA</code> is never
assigned as a level in the contrast matrix or in the factor returned by the
function, but <code>NA</code> values in <code>x</code> are not removed in the factor
returned when <code>return_contr = FALSE</code>.
</p>


<h3>Value</h3>

<p>If <code>return_contr = TRUE</code> a scaled orthogonal polynomial contrast
matrix is returned.  If <code>return_contr = FALSE</code>, then a factor with the
scaled orthogonal polynomial contrasts is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+named_contr_sum">named_contr_sum</a></code> for unordered factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- factor(rep(c("a", "b", "c"), 5), ordered = TRUE)
contrasts(f) &lt;- contr.poly(3)

# difference in contrasts
contrasts(f)
scaled_contr_poly(f)
scaled_contr_poly(f, scale = 0.5)

# different options for 'x'
scaled_contr_poly(levels(f))
scaled_contr_poly(3)
scaled_contr_poly(c(2, 5, 6))

# return factor
f2 &lt;- scaled_contr_poly(f, return_contr = FALSE)
f2
</code></pre>

<hr>
<h2 id='standardize'>Standardize a formula and data frame for regression.</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+standardized-class">standardized</a></code> object which places
all variables in <code>data</code> on the same scale based on <code>formula</code>,
making regression output easier to interpret.
For mixed effects regressions, this also offers computational benefits, and
for Bayesian regressions, it also makes determining reasonable priors easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(formula, data, family = gaussian, scale = 1, offset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_formula">formula</code></td>
<td>
<p>A regression <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="standardize_+3A_data">data</code></td>
<td>
<p>A data.frame containing the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="standardize_+3A_family">family</code></td>
<td>
<p>A regression <code><a href="stats.html#topic+family">family</a></code> (default gaussian).</p>
</td></tr>
<tr><td><code id="standardize_+3A_scale">scale</code></td>
<td>
<p>The desired scale for the regression frame. Must be a single
positive number. See 'Details'.</p>
</td></tr>
<tr><td><code id="standardize_+3A_offset">offset</code></td>
<td>
<p>An optional <code><a href="stats.html#topic+offset">offset</a></code> vector. Offsets can
also be included in the <code>formula</code> (e.g. <code>y ~ x + offset(o)</code>), but
if this is done, then the column <code>o</code> (in this example) must be in any
data frame passed as the <code>newdata</code> argument to
<code><a href="#topic+predict.standardized">predict</a></code>.</p>
</td></tr>
<tr><td><code id="standardize_+3A_...">...</code></td>
<td>
<p>Currently unused.  If <code>na.action</code> is specified in <code>...</code>
and is anything other than <code>na.pass</code>, a warning is issued and the argument
argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First <code><a href="stats.html#topic+model.frame">model.frame</a></code> is called. Then,
if <code>family = gaussian</code>, the response is checked to ensure that it is
numeric and has more than two unique values.  If <code><a href="#topic+scale_by">scale_by</a></code> is
used on the response in <code>formula</code>, then the <code>scale</code> argument to
<code>scale_by</code> is ignored and forced to <code>1</code>.  If <code><a href="#topic+scale_by">scale_by</a></code>
is not called, then <code><a href="base.html#topic+scale">scale</a></code> is used with default arguments.
The result is that gaussian responses are on unit scale (i.e. have mean
<code>0</code> and standard deviation <code>1</code>), or, if <code><a href="#topic+scale_by">scale_by</a></code> is
used on the left hand side of <code>formula</code>, unit scale within each
level of the specified conditioning factor.
Offsets in gaussian models are divided by the standard deviation of the
the response prior to scaling (within-factor-level if <code><a href="#topic+scale_by">scale_by</a></code>
is used on the response).  In this way, if the transformed offset is added
to the transformed response, and then placed back on the response's original
scale, the result would be the same as if the un-transformed offset had
been added to the un-transformed response.
For all other values for <code>family</code>, the response and offsets are not checked.
If offsets are used within the <code>formula</code>, then they will be in the
<code>formula</code> and <code>data</code> elements of the <code><a href="#topic+standardized-class">standardized</a></code>
object.  If the <code>offset</code> argument to the <code>standardize</code> function is
used, then the offset provided in the argument will be
in the <code>offset</code> element of the <code><a href="#topic+standardized-class">standardized</a></code> object
(scaled if <code>family = gaussian</code>).
</p>
<p>For the other predictors in the formula, first any random effects grouping factors
in the formula are coerced to factor and unused levels are dropped.  The
levels of the resulting factor are then recorded in the <code>groups</code> element.
Then for the remaining predictors, regardless of their original
class, if they have only two unique non-<code>NA</code> values, they are coerced
to unordered factors.  Then, <code><a href="#topic+named_contr_sum">named_contr_sum</a></code> and
<code><a href="#topic+scaled_contr_poly">scaled_contr_poly</a></code> are called for unordered and ordered factors,
respectively, using the <code>scale</code> argument provided in the call
to <code>standardize</code> as the <code>scale</code> argument to the contrast
functions.  For numeric variables, if the variable contains a call to
<code><a href="#topic+scale_by">scale_by</a></code>, then, regardless of whether the call to
<code><a href="#topic+scale_by">scale_by</a></code> specifies <code>scale</code>, the value of <code>scale</code>
in the call to <code>standardize</code> is used.  If the numeric variable
does not contain a call to <code><a href="#topic+scale_by">scale_by</a></code>, then
<code><a href="base.html#topic+scale">scale</a></code> is called, ensuring that the result has
standard deviation <code>scale</code>.
</p>
<p>With the default value of <code>scale = 1</code>, the result is a
<code><a href="#topic+standardized-class">standardized</a></code> object which contains a formula and data
frame (and offset vector if the <code>offset</code> argument to the
<code>standardize</code> function was used) which can be used to fit regressions
where the predictors are all on a similar scale.  Its data frame
has numeric variables on unit scale, unordered factors with named sum
sum contrasts, and ordered factors with orthogonal polynomial contrasts
on unit scale.  For gaussian regressions, the response is also placed on
unit scale.  If <code>scale = 0.5</code> (for example),
then gaussian responses would still
be placed on unit scale, but unordered factors' named sum contrasts would
take on values -0.5, 0, 0.5 rather than -1, 0, 1, the standard deviation
of each column in the contrast matrices for ordered factors would be
<code>0.5</code> rather than <code>1</code>, and the standard deviation of numeric
variables would be <code>0.5</code> rather than <code>1</code> (within-factor-level
in the case of <code><a href="#topic+scale_by">scale_by</a></code> calls).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+standardized-class">standardized</a></code> object. The
<code>formula</code>, <code>data</code>, and <code>offset</code> elements of the object can
be used in calls to regression functions.
</p>


<h3>Note</h3>

<p>The <code><a href="#topic+scale_by">scale_by</a></code>
function is supported so long as it is not nested within other function
calls.  The <code><a href="stats.html#topic+poly">poly</a></code> function is supported so long as
it is either not nested within other function calls, or is nested as the
transformation of the numeric variable in a <code><a href="#topic+scale_by">scale_by</a></code> call.
If <code><a href="stats.html#topic+poly">poly</a></code> is used, then the <code>lsmeans</code> function
will yield misleading results (as would normally be the case).
</p>
<p>In previous versions of <code>standardize</code> (v0.2.0 and earlier),
<code>na.action</code> could be specified.  Starting with v0.2.1, specifying
something other than <code>na.pass</code> is ignored with a warning.  Use of
<code>na.omit</code> and <code>na.exclude</code> should be done when calling regression
fitting functions using the elements returned in the
<code><a href="#topic+standardized-class">standardized</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>For scaling and contrasts, see <code><a href="base.html#topic+scale">scale</a></code>,
<code><a href="#topic+scale_by">scale_by</a></code>, <code><a href="#topic+named_contr_sum">named_contr_sum</a></code>, and
<code><a href="#topic+scaled_contr_poly">scaled_contr_poly</a></code>. For putting new data into the same space
as the standardized data, see <code><a href="#topic+predict.standardized">predict</a></code>.
For the elements in the returned object, see
<code><a href="#topic+standardized-class">standardized</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- expand.grid(ufac = letters[1:3], ofac = 1:3)
dat &lt;- as.data.frame(lapply(dat, function(n) rep(n, 60)))
dat$ofac &lt;- factor(dat$ofac, ordered = TRUE)
dat$x &lt;- rpois(nrow(dat), 5)
dat$z &lt;- rnorm(nrow(dat), rep(rnorm(30), each = 18), rep(runif(30), each = 18))
dat$subj &lt;- rep(1:30, each = 18)
dat$y &lt;- rnorm(nrow(dat), -2, 5)

sobj &lt;- standardize(y ~ log(x + 1) + scale_by(z ~ subj) + ufac + ofac +
  (1 | subj), dat)

sobj
sobj$formula
head(dat)
head(sobj$data)
sobj$contrasts
sobj$groups
mean(sobj$data$y)
sd(sobj$data$y)
mean(sobj$data$log_x.p.1)
sd(sobj$data$log_x.p.1)
with(sobj$data, tapply(z_scaled_by_subj, subj, mean))
with(sobj$data, tapply(z_scaled_by_subj, subj, sd))

sobj &lt;- standardize(y ~ log(x + 1) + scale_by(z ~ subj) + ufac + ofac +
  (1 | subj), dat, scale = 0.5)

sobj
sobj$formula
head(dat)
head(sobj$data)
sobj$contrasts
sobj$groups
mean(sobj$data$y)
sd(sobj$data$y)
mean(sobj$data$log_x.p.1)
sd(sobj$data$log_x.p.1)
with(sobj$data, tapply(z_scaled_by_subj, subj, mean))
with(sobj$data, tapply(z_scaled_by_subj, subj, sd))

## Not run: 
mod &lt;- lmer(sobj$formula, sobj$data)
# this next line causes warnings about contrasts being dropped, but
# these warnings can be ignored (i.e. the statement still evaluates to TRUE)
all.equal(predict(mod, newdata = predict(sobj, dat)), fitted(mod))

## End(Not run)
</code></pre>

<hr>
<h2 id='standardize-package'>standardize: Tools for Standardizing Variables for Regression in R.</h2><span id='topic+standardize-package'></span>

<h3>Description</h3>

<p>The <code>standardize</code> package provides tools for standardizing variables
prior to regression (i.e. placing all of the variables to be used in a
regression on similar scales).
When all of the predictors in a regression are on a similar scale, it makes
the interpretation of their effect sizes more comparable. In the case of
gaussian regression, placing the response on unit scale also eases
interpretation.  Standardizing regression variables also has computational
benefits in the case of mixed effects regressions, and makes determining
reasonable priors in Bayesian regressions simpler.  To view the package
vignette, call <code>vignette("using-standardize", package = "standardize")</code>.
To see the version history, call <code>standardize.news()</code>.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+named_contr_sum">named_contr_sum</a></code> function gives named sum contrasts to
unordered factors, and allows the absolute value of the non-zero cells in
contrast matrix to be specified through its <code>scale</code> argument. The
<code><a href="#topic+scaled_contr_poly">scaled_contr_poly</a></code> function gives orthogonal polynomial
contrasts to ordered factors, and allows the standard deviation of the
columns in the contrast matrix to be specified through its <code>scale</code>
argument. The <code><a href="#topic+scale_by">scale_by</a></code> function allows numeric variables
to be scaled conditioning on factors, such that the numeric variable has
the same mean and standard deviation within each level of a factor (or the
interaction of several factors), with the standard deviation specified
through its <code>scale</code> argument.
</p>
<p>The <code><a href="#topic+standardize">standardize</a></code> function creates a
<code><a href="#topic+standardized-class">standardized</a></code> object whose elements
can be used in regression fitting functions, ensuring
that all of the predictors are on the
same scale.  This is done by passing the function's <code>scale</code> argument
to <code><a href="#topic+named_contr_sum">named_contr_sum</a></code> for all unordered factors (and also
any predictor with only two unique values regardless of its original class),
to <code><a href="#topic+scaled_contr_poly">scaled_contr_poly</a></code> for all ordered factors, and to
<code><a href="#topic+scale_by">scale_by</a></code> for numeric variables which contain calls to the
function.  For numeric predictors not contained in a <code><a href="#topic+scale_by">scale_by</a></code>
call, <code><a href="base.html#topic+scale">scale</a></code> is called, ensuring that the result has
standard deviation equal to the <code>scale</code> argument to
<code><a href="#topic+standardize">standardize</a></code>.  Gaussian responses are always placed on
unit scale, using <code><a href="base.html#topic+scale">scale</a></code> (or <code><a href="#topic+scale_by">scale_by</a></code> if
the function was used on the left hand side of the regression formula).
Offsets for gaussian models are divided by the standard deviation of the
raw response (within-factor-level if <code><a href="#topic+scale_by">scale_by</a></code> is used on
the response).
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>

<hr>
<h2 id='standardize.news'>Print the version history of the <code>standardize</code> package.</h2><span id='topic+standardize.news'></span>

<h3>Description</h3>

<p>Print the version history of the <code>standardize</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize.news()
</code></pre>


<h3>Value</h3>

<p>The function prints the changes and new features for each version
of the package (starting with the newest version).
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>standardize.news()

</code></pre>

<hr>
<h2 id='standardized-class'>Class <code>standardized</code> containing regression variables in a standardized space.</h2><span id='topic+standardized-class'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+standardize">standardize</a></code> function returns a list of class
<code>standardized</code>, which has a <code>print</code> method,
and which can additionally be used to place new data into the same
standardized space as the data passed in the call to <code><a href="#topic+standardize">standardize</a></code>
using the <code><a href="#topic+predict.standardized">predict</a></code> function.
The <code>standardized</code> list contains the following elements.
</p>


<h3>Details</h3>


<dl>
<dt>call</dt><dd><p>The call to <code><a href="#topic+standardize">standardize</a></code> which created the
object.</p>
</dd>
<dt>scale</dt><dd><p>The <code>scale</code> argument to <code><a href="#topic+standardize">standardize</a></code>.</p>
</dd>
<dt>formula</dt><dd><p>The regression formula in standardized space (with new
names) which can be used along with the <code>data</code> element to fit
regressions.  It has an attribute <code>standardized.scale</code> which is the
same as the <code>scale</code> element of the object (this allows users and
package developers to write regression-fitting functions which can tell
if the input is from a <code>standardized</code> object).</p>
</dd>
<dt>family</dt><dd><p>The regression family.</p>
</dd>
<dt>data</dt><dd><p>A data frame containing the regression variables in a
standardized space (renamed to have valid variable names corresponding
to those in the <code>formula</code> element).</p>
</dd>
<dt>offset</dt><dd><p>The offset passed through the <code>offset</code> argument to
<code><a href="#topic+standardize">standardize</a></code> (scaled if <code>family = gaussian</code>), or
<code>NULL</code> if the <code>offset</code> argument was not used.</p>
</dd>
<dt>pred</dt><dd><p>A list containing unevaluated calls which allow the
<code><a href="#topic+predict.standardized">predict</a></code> method to work.</p>
</dd>
<dt>variables</dt><dd><p>A data frame with the name of the original variable,
the corresponding name in the standardized data frame and formula,
and the class of the variable in the standardized data frame.</p>
</dd>
<dt>contrasts</dt><dd><p>A named list of contrasts for all factors included as
predictors, or <code>NULL</code> if no predictors are factors.</p>
</dd>
<dt>groups</dt><dd><p>A named list of levels for random effects grouping factors,
or <code>NULL</code> if there are no random effects.</p>
</dd>
</dl>

<p>In the <code>variables</code> data frame, the <code>Variable</code> column contains the
name of the variable in the original formula passed to <code><a href="#topic+standardize">standardize</a></code>.
The <code>Standardized Name</code> column contains the name of the variable in the standardized
formula and data frame. The original variable name is altered such that the
original name is still recoverable but is also a valid variable name for
regressions run using the <code>formula</code> and <code>data</code> elements of the
<code>standardized</code> object.  For example, <code>exp(x)</code> would become
<code>exp_x</code> and <code>log(x + 1)</code> would become <code>log_x.p.1</code>.  If
the indicator function is used, this can lead to a long and possibly
difficult to interpret name; e.g. <code>I(x1 &gt; 0 &amp; x2 &lt; 0)</code> would become
<code>I_x1.g.0.a.x2.l.0</code>. In such cases, it is better to create the variable
explicitly in the data frame and give it a meaningful name; in this case,
something like <code>mydata$x1Pos_x2Neg &lt;- mydata$x1 &gt; 0 &amp; mydata$x2 &lt; 0</code>,
and then use <code>x1Pos_x2Neg</code> in the call to <code><a href="#topic+standardize">standardize</a></code>.
The <code>Class</code> column in the <code>variables</code> data frame takes the
following values (except for non-gaussian responses, which are left
unaltered, and so may have a different class; the class for the response is
always preceded by <code>response.</code>).
</p>

<dl>
<dt>numeric</dt><dd><p>A numeric vector.</p>
</dd>
<dt>poly</dt><dd><p>A numeric matrix resulting from a call to
<code><a href="stats.html#topic+poly">poly</a></code>.</p>
</dd>
<dt>scaledby</dt><dd><p>A numeric vector resulting from a call to
<code><a href="#topic+scale_by">scale_by</a></code>.</p>
</dd>
<dt>scaledby.poly</dt><dd><p>A numeric matrix resulting from a call to
<code><a href="stats.html#topic+poly">poly</a></code> nested within a call to
<code><a href="#topic+scale_by">scale_by</a></code>.</p>
</dd>
<dt>factor</dt><dd><p>An unordered factor.</p>
</dd>
<dt>ordered</dt><dd><p>An ordered factor.</p>
</dd>
<dt>group</dt><dd><p>A random effects grouping factor.</p>
</dd>
<dt>offset</dt><dd><p>If the offset function was used within the formula passed to
<code><a href="#topic+standardize">standardize</a></code>, then the variable is numeric and labeled as
<code>offset</code>.  The <code>formula</code> element of the <code>standardize</code>
object contains offset calls to ensure regression fitting functions use
them properly.  If the <code>offset</code> argument was used in the call to
<code><a href="#topic+standardize">standardize</a></code> (rather than putting offset calls in the
formula), then the offset is not in the <code>variables</code> data frame (it
is in the <code>offset</code> element of the <code>standardized</code> object).</p>
</dd>
</dl>

<p>The <code>standardized</code> object has a printing method which displays the call,
formula, and variable frame along with an explanation of the
standardization.  The <code><a href="#topic+is.standardized">is.standardized</a></code> function returns
<code>TRUE</code> if an object is the result of a call to <code><a href="#topic+standardize">standardize</a></code>
and <code>FALSE</code> otherwise.  The <code><a href="#topic+predict.standardized">predict</a></code>
method places new data into the same standardized space as the data
passed to the original <code><a href="#topic+standardize">standardize</a></code> call.
</p>


<h3>Author(s)</h3>

<p>Christopher D. Eager &lt;eager.stats@gmail.com&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
