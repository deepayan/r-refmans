<!DOCTYPE html><html><head><title>Help for package robustvarComp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robustvarComp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#summary.varComprob'>
<p>Summary Method for &quot;varComprob&quot; Objects</p></a></li>
<li><a href='#varComprob'>
<p>Fitting variance component models using robust procedures</p></a></li>
<li><a href='#varComprob.control'>
<p>Tuning Parameters for <code>varComprob()</code> and Auxiliaries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Robust Estimation of Variance Component Models</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Claudio Agostinelli &lt;claudio.agostinelli@unitn.it&gt; and Victor J. Yohai &lt;victoryohai@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claudio Agostinelli &lt;claudio.agostinelli@unitn.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>robustbase, GSE, numDeriv, robust, plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nlme, Matrix, mvtnorm, WWGbook</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust Estimation of Variance Component Models by classic and composite robust procedures. The composite procedures are robust against outliers generated by the Independent Contamination Model.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-14 10:02:29 UTC; claudio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-15 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='summary.varComprob'>
Summary Method for &quot;varComprob&quot; Objects
</h2><span id='topic+summary.varComprob'></span>

<h3>Description</h3>

<p>Summary method for <span class="rlang"><b>R</b></span> object of class <code>"varComprob"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'varComprob'
summary(object, print.outliers = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.varComprob_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>varComprob</code>, typically created by
<code><a href="#topic+varComprob">varComprob</a></code>.</p>
</td></tr>
<tr><td><code id="summary.varComprob_+3A_print.outliers">print.outliers</code></td>
<td>
<p>logical. If <code>TRUE</code> three tables are also
printed, summarizing the presence of cell, couple and row outliers
in the data set.
</p>
</td></tr>
<tr><td><code id="summary.varComprob_+3A_...">...</code></td>
<td>
<p>potentially more arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary(object)</code> returns an object of S3 class
<code>"summary.varComprob"</code>, basically a <code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Victor J. Yohai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (!require(nlme))
    stop()
  data(Orthodont)

  z1 &lt;- rep(1, 4)
  z2 &lt;- c(8,10,12,14)
  K &lt;- list()
  K[[1]] &lt;- tcrossprod(z1,z1) ## Int
  K[[2]] &lt;- tcrossprod(z1,z2) + tcrossprod(z2,z1) ## Int:age
  K[[3]] &lt;- tcrossprod(z2,z2) ## age
  names(K) &lt;- c("Int", "Int:age", "age")
  p &lt;- 4
  n &lt;- 27
  groups &lt;- cbind(rep(1:p, each=n), rep((1:n), p))

  ## Composite Tau
  OrthodontCompositeTau &lt;- varComprob(distance ~ age*Sex, groups = groups,
    data = Orthodont, varcov = K,
    control=varComprob.control(lower=c(0,-Inf,0)))

  summary(OrthodontCompositeTau, print.outliers=TRUE)
</code></pre>

<hr>
<h2 id='varComprob'>
Fitting variance component models using robust procedures
</h2><span id='topic+varComprob'></span><span id='topic+varComprob.fit'></span>

<h3>Description</h3>

<p><code>varComprob</code> and <code>varComprob.fit</code> fit linear mixed-effect models where the marginal variance-covariance matrix is linear in known positive semidefinite matrices. <code>varComprob</code> uses a formula interface, whereas <code>varComprob.fit</code> is the underlying working horse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varComprob(fixed, data, random, groups, varcov, weights, subset,
  family = stats::gaussian("identity"), na.action, offset,
  control = varComprob.control(...), doFit = TRUE,
  normalizeTrace = FALSE, contrasts = NULL,
  model = TRUE, X = TRUE, Y = TRUE, K = TRUE, ...)

varComprob.fit(Y, X, V, control = varComprob.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varComprob_+3A_fixed">fixed</code></td>
<td>
<p>A two-sided formula specifying the fixed effects of the
model. This is the same as in <code><a href="stats.html#topic+lm">stats::lm</a></code>.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment containing the variables in the model. If not found in data, the variables are taken from <code>environment(fixed)</code>, typically the environment from which <code>varComprob</code> is called. This is the same as the <code>data</code> argument of <code><a href="stats.html#topic+lm">stats::lm</a></code>.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_random">random</code></td>
<td>
<p>This argument is not yet used.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_groups">groups</code></td>
<td>
<p>a numeric matrix with two columns which is used to group
appropriately the observations according to subject. See details below
and the example.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_varcov">varcov</code></td>
<td>
<p>An list of symmetric positive semidefinite matrices. The
weighted sum of these matrices represent the contribution of random
effects to the marginal variance of the response variable, with
unknown weights representing variance components.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_weights">weights</code></td>
<td>
<p>This argument is not yet used.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_family">family</code></td>
<td>
<p>The same as the <code>family</code> argument of
<code><a href="stats.html#topic+glm">stats::glm</a></code>. However, only
<code>gaussian('identity')</code> is supported currently.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_na.action">na.action</code></td>
<td>
<p>The same as in <code><a href="stats.html#topic+lm">stats::lm</a></code>.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_offset">offset</code></td>
<td>
<p>The same as in
<code><a href="stats.html#topic+glm">stats::glm</a></code>. These offsets are assumed as
known fixed effects.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_control">control</code></td>
<td>
<p>Usually an object from calling <code><a href="#topic+varComprob.control">varComprob.control</a></code>.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_dofit">doFit</code></td>
<td>
<p>This argument is not yet used.</p>
</td></tr>
<tr><td><code id="varComprob_+3A_normalizetrace">normalizeTrace</code></td>
<td>
<p>A logical scalar, indicating whether the
individual variance-covariance matrices should be normalized such
that variance components are on the same scale.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_contrasts">contrasts</code></td>
<td>
<p>The same as in <code><a href="stats.html#topic+lm">stats::lm</a></code>.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_model">model</code></td>
<td>
<p>A logical scalar, indicating whether the model frame will
be included in the result.
</p>
</td></tr> 
<tr><td><code id="varComprob_+3A_x">X</code></td>
<td>
<p>For <code>varComprob</code>, this is a logical scalar, indicating
whether the fixed-effect design matrix should be included in the
result. For <code>varComprob.fit</code> this is the optional numeric array
containing the fixed effect design matrix for the model, see details
below. If <code>X</code>  is missing or an array with zero dimension, it
is assumed that <code>Y</code> has zero mean.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_y">Y</code></td>
<td>
<p>For <code>varComprob</code>, this is a logical scalar, indicating
whether the response variable should be included in the result. For
<code>varComprob.fit</code>, this is a numeric matrix of response
variables. See details below.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_k">K</code></td>
<td>
<p>This is a logical scalar, indicating
whether the list of variance-covariance matrices should be included
in the result. These matrices are those specified by
<code>varcov</code>. See details below.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_v">V</code></td>
<td>
<p>This is a numeric array containing the variance-covariance
matrices. See details below.
</p>
</td></tr>
<tr><td><code id="varComprob_+3A_...">...</code></td>
<td>
<p>When <code>control</code> is given, this is ignored. Otherwise,
these arguments are passed to <code><a href="#topic+varComprob.control">varComprob.control</a></code> and the
result will be used as the <code>control</code> argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance component model is of form </p>
<p style="text-align: center;"><code class="reqn">\mathbf{y} =
    \mathbf{X}\boldsymbol{\beta} + \mathbf{e}</code>
</p>
<p> where
<code class="reqn">\mathbf{e}</code> is multivariate normally distributed with mean
zero and variance-covariance matrix <code class="reqn">\mathbf{\Sigma}</code> being
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{\Sigma} = \sum_{j=1}^R \sigma_j^2 \mathbf{K}_j +
    \sigma_e^2 \mathbf{I}</code>
</p>

<p>in which <code class="reqn">\mathbf{K}_j</code> are known positive semidefinite
matrices and <code class="reqn">\mathbf{I}</code> is the identity matrix. 
</p>
<p>In the <code>varComprob</code> formula interface, the <code class="reqn">\mathbf{X}</code>
matrix and response variable are specified by the <code>fixed</code>
argument. The <code>varcov</code> argument specifies each
variance-covariance matrix in a list. 
</p>
<p>In <code>varComprob.fit</code>, let <code class="reqn">p</code> the number of observations,
<code class="reqn">n</code> the number of independent replicates and <code class="reqn">k</code> the number of
regressors. Then <code>Y</code> must be a matrix of dimension <code class="reqn">p
    \times n</code>, <code>X</code> must be an array of dimension <code class="reqn">p
    \times n \times k</code> and <code>V</code> must be an array of
dimension <code class="reqn">p \times p \times R</code>, where <code class="reqn">R</code> is the number
of variance-covariance matrices.
</p>
<p>The model fitting process is performed by a robust procedures. See
references for more details.
</p>
<p>See <code><a href="#topic+varComprob.control">varComprob.control</a></code> for arguments controlling the
modeling fitting.
</p>


<h3>Value</h3>

<p>The value of any of the two functions is a list with class
<code>varComprob</code> or <code>varComprob.fit</code> respectively.
The following elements are present in both
</p>

<ul>
<li><p><code>call</code>: the actual call.
</p>
</li>
<li><p><code>beta</code>: a named numeric vector of parameter
estimates. These are the estimated of the fixed effect parameters. 
</p>
</li>
<li><p><code>vcov.beta</code>: estimated variance-covariance matrix of the
estimated fixed effects parameters.
</p>
</li>
<li><p><code>eta</code>: a named numeric vector of parameter
estimates. These are the estimated variance components.
</p>
</li>
<li><p><code>vcov.eta</code>: estimated variance-covariance matrix of the
estimated random effects variance parameters.
</p>
</li>
<li><p><code>gamma</code>: a named numeric vector of parameter estimates. These are the estimated ratio of each variance component relative to the error variance.
</p>
</li>
<li><p><code>vcov.gamma</code>: estimated variance-covariance matrix of the
estimated ratio of random effects variance parameters with respect
the estimated error variance.
</p>
</li>
<li><p><code>eta0</code>: the estimated error variance.
</p>
</li>
<li><p><code>resid</code>: residuals in matrix form <code class="reqn">p \times n</code>.
</p>
</li>
<li><p><code>weights</code>: final weights of the iterative fixed point equations.
</p>
</li>
<li><p><code>dotweights</code>: another type of weight. See references for details.
</p>
</li>
<li><p><code>Sigma</code>: an estimates of the variance-covariance
marginal matrix.
</p>
</li>
<li><p><code>scales</code>: the scales in case of composite robust
procedures otherwise <code>NULL</code>.    
</p>
</li>
<li><p><code>scale</code>: the scale in case of classical robust
procedures otherwise <code>NULL</code>.
</p>
</li>
<li><p><code>min</code>: the minimum attains by the goal function.
</p>
</li>
<li><p><code>scale0</code>:
</p>
</li>
<li><p><code>initial.values</code>: a list with the following components:
<code>beta</code>: initial value for the fixed parameters;
<code>gamma</code>: initial value for the ratio of each variance
component relative to the error variance;
<code>eta0</code>: initial value for the errot variance;
<code>scales</code>: initial value for the scales in case of composite
robust methods otherwise is not available;
<code>scale</code>: initial value for the scale in case of classic
robust methods otherwise is not available.
</p>
</li>
<li><p><code>iterations</code>: number of iterations.   
</p>
</li>
<li><p><code>control</code>: the <code>control</code> argument. 
</p>
</li>
<li><p><code>method</code>: the robust method used to perform the estimation.  
</p>
</li></ul>

<p>The function <code>varComprob</code> returns also   
</p>

<ul>
<li> <p><code>fixed</code>: the same as <code>beta</code>.
</p>
</li>
<li> <p><code>parms</code>: the same as <code>gamma</code>.
</p>
</li>
<li> <p><code>sigma2</code>: the same as <code>eta0</code>.
</p>
</li>
<li> <p><code>nobs</code>: the number of observations.
</p>
</li>
<li> <p><code>na.action</code>: the <code>na.action</code> used in the model frame. 
</p>
</li>
<li> <p><code>offset</code>: the same as input. 
</p>
</li>
<li> <p><code>contrasts</code>: the contrast used in the fixed-effect design matrix.
</p>
</li>
<li> <p><code>random.labels</code>: the labels used to differentiate random
effects. Note that the error variance is not included here. It is safe
to check the number of variance components specified by the model by
checking the length of <code>random.labels</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claudio Agostinelli and Victor J. Yohai
</p>


<h3>References</h3>

<p>C. Agostinelli and V.J. Yohai (2014) Composite Robust Estimators for
Linear Mixed Models. arXiv:1407.2176.
</p>
<p>M.P. Victoria-Feser and Copt (2006) High Breakdown Inference in the
Mixed Linear Model. Journal of American Statistical Association, 101,
292-300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (!require(nlme))
    stop()
  data(Orthodont)

  z1 &lt;- rep(1, 4)
  z2 &lt;- c(8,10,12,14)
  K &lt;- list()
  K[[1]] &lt;- tcrossprod(z1,z1) ## Int
  K[[2]] &lt;- tcrossprod(z1,z2) + tcrossprod(z2,z1) ## Int:age
  K[[3]] &lt;- tcrossprod(z2,z2) ## age
  names(K) &lt;- c("Int", "Int:age", "age")
  p &lt;- 4
  n &lt;- 27
  groups &lt;- cbind(rep(1:p, each=n), rep((1:n), p))

  ## Not run: 

  ## Composite S
  OrthodontCompositeS &lt;- varComprob(distance ~ age*Sex, groups = groups,
      data = Orthodont, varcov = K,
      control=varComprob.control(method="compositeS", lower=c(0,-Inf,0)))
  
## End(Not run)

  ## Composite Tau
  OrthodontCompositeTau &lt;- varComprob(distance ~ age*Sex, groups = groups,
      data = Orthodont, varcov = K,
      control=varComprob.control(lower=c(0,-Inf,0)))

  ## Not run: 

  summary(OrthodontCompositeTau)

  ## Classic S
  OrthodontS &lt;- varComprob(distance ~ age*Sex, groups = groups,
      data = Orthodont, varcov = K,
      control=varComprob.control(lower=c(0,-Inf,0),
      method="S", psi="rocke"))

  summary(OrthodontS)
  
## End(Not run)
  ## Not run: 

  if (!require(WWGbook))
    stop()
  if (!require(nlme))
    stop()
  data(autism)
  autism &lt;- autism[complete.cases(autism),]
  completi &lt;- table(autism$childid)==5
  completi &lt;- names(completi[completi])
  indici &lt;- as.vector(unlist(sapply(completi,
              function(x) which(autism$childid==x))))
  ind &lt;- rep(FALSE, nrow(autism))
  ind[indici] &lt;- TRUE
  autism &lt;- subset(autism, subset=ind) ## complete cases 41
  attach(autism)
  sicdegp.f &lt;- factor(sicdegp)
  age.f &lt;- factor(age)
  age.2 &lt;- age - 2
  sicdegp2 &lt;- sicdegp
  sicdegp2[sicdegp == 3] &lt;- 0
  sicdegp2[sicdegp == 2] &lt;- 2 
  sicdegp2[sicdegp == 1] &lt;- 1
  sicdegp2.f &lt;- factor(sicdegp2)
  autism.updated &lt;- subset(data.frame(autism, 
                    sicdegp2.f, age.2), !is.na(vsae))
  autism.grouped &lt;- groupedData(vsae ~ age.2 | childid, 
                    data=autism.updated, order.groups = FALSE)
  p &lt;- 5
  n &lt;- 41
  z1 &lt;- rep(1, p)
  z2 &lt;- c(0, 1, 3, 7, 11)
  z3 &lt;- z2^2
  K &lt;- list()
  K[[1]] &lt;- tcrossprod(z1,z1)
  K[[2]] &lt;- tcrossprod(z2,z2)
  K[[3]] &lt;- tcrossprod(z3,z3)
  K[[4]] &lt;- tcrossprod(z1,z2) + tcrossprod(z2,z1)
  K[[5]] &lt;- tcrossprod(z1,z3) + tcrossprod(z3,z1)
  K[[6]] &lt;- tcrossprod(z3,z2) + tcrossprod(z2,z3)
  names(K) &lt;- c("Int", "age", "age2", "Int:age", "Int:age2", "age:age2")

  groups &lt;- cbind(rep(1:p, each=n), rep((1:n), p))

  ## Composite Tau
  AutismCompositeTau &lt;- varComprob(vsae ~ age.2 + I(age.2^2)
    + sicdegp2.f + age.2:sicdegp2.f + I(age.2^2):sicdegp2.f, 
    groups = groups,
    data = autism.grouped, varcov = K,
    control=varComprob.control(
    lower=c(0.01,0.01,0.01,-Inf,-Inf,-Inf)))

  summary(AutismCompositeTau)

  ## Classic S
  AutismS &lt;- varComprob(vsae ~ age.2 + I(age.2^2)
    + sicdegp2.f + age.2:sicdegp2.f + I(age.2^2):sicdegp2.f, 
    groups = groups,
    data = autism.grouped, varcov = K,
    control=varComprob.control(
    method="S", psi="rocke", cov.init="covOGK",
    lower=c(0.01,0.01,0.01,-Inf,-Inf,-Inf)))
  summary(AutismS)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='varComprob.control'>
Tuning Parameters for <code>varComprob()</code> and Auxiliaries
</h2><span id='topic+varComprob.control'></span>

<h3>Description</h3>

<p>Tuning Parameters for <code>varComprob()</code> which performs S, composite S and
Tau estimators for variance component models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varComprob.control(init = NULL, lower = 0, upper = Inf, epsilon = 0.001,
  tuning.chi = NULL, bb = 0.5, tuning.psi = NULL,
  arp.chi = 0.1, arp.psi = NULL, max.it = 100,
  rel.tol.beta = 1e-06, rel.tol.gamma = 1e-05, rel.tol.scale = 1e-05,
  trace.lev = 0,
  method = c("compositeTau", "compositeS", "compositeMM",
    "Tau", "S", "MM"),
  psi = c("optimal", "bisquare", "rocke"),
  beta.univ = FALSE, gamma.univ = FALSE,
  fixed.init = c("lmrob.S", "lmRob"),
  cov.init = c("TSGS", "2SGS", "covOGK"),
  cov = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varComprob.control_+3A_init">init</code></td>
<td>
<p>A list with initial values. The only components used are
<code>beta</code>, <code>gamma</code>, <code>eta0</code>, <code>scales</code> (in case of
composite methods), <code>scale</code> (in case of classic methods) and
<code>Sigma</code>. If one of the components is empty a suitable automatic
initial values is calculated.    
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_lower">lower</code></td>
<td>
<p>A numeric vector with length equals to <code>gamma</code>. This
parameter is passed to the <code>optim</code> function.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_upper">upper</code></td>
<td>
<p>A numeric vector with length equals to <code>gamma</code>. This
parameter is passed to the <code>optim</code> function.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric scalar. This value is set to the non
negative elements of <code>gamma</code> (checked by <code>lower</code>) when the
automatic initial values are negative. 
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_tuning.chi">tuning.chi</code></td>
<td>
<p>tuning constant vector for the rho_1 function. If
<code>NULL</code>, as by default, this is set, depending on &quot;psi&quot; (for now only
&quot;bisquare&quot; and &quot;optimal&quot;), to a suitable value.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_bb">bb</code></td>
<td>
<p>expected value under the normal model of the rho function
with tuning constant equal to <code>tuning.chi</code>.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_tuning.psi">tuning.psi</code></td>
<td>
<p>tuning constant vector for the rho_2 function. If
<code>NULL</code>, as by default, this is set, depending on &quot;psi&quot; (for now only
&quot;bisquare&quot; and &quot;optimal&quot;), to a suitable value.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_arp.chi">arp.chi</code></td>
<td>
<p>tuning constant vector for the rho_1 function in case
<code>psi</code> is set to &quot;rocke&quot;.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_arp.psi">arp.psi</code></td>
<td>
<p>tuning constant vector for the rho_2 function in case
<code>psi</code> is set to &quot;rocke&quot;.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_max.it">max.it</code></td>
<td>
<p>integer specifying the maximum number of IRWLS
iterations.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_rel.tol.beta">rel.tol.beta</code></td>
<td>
<p>(for the RWLS iterations algorithm of the fixed
parameters): relative convergence tolerance for the parameter vector.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_rel.tol.gamma">rel.tol.gamma</code></td>
<td>
<p>(for the <code>optim</code> function used in the
estimation procedure of the random variance parameters): relative
convergence tolerance for the parameter vector.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_rel.tol.scale">rel.tol.scale</code></td>
<td>
<p>relative convergence tolerance for the scale
vector.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_trace.lev">trace.lev</code></td>
<td>
<p>integer indicating if the progress of the algorithm
should be traced (increasingly); default 'trace.lev = 0' does
no tracing.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_method">method</code></td>
<td>
<p>string specifying the estimator-chain. For now available
procedures are 'compositeS', 'compositeTau' and 'S'. Default
is set to 'compositeTau'.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_psi">psi</code></td>
<td>
<p>string specifying the type psi-function used. Available
choices for the composite methods are &quot;bisquare&quot; and &quot;optimal&quot;. For
classic methods &quot;rocke&quot;, &quot;bisquare&quot; and &quot;optimal&quot;.
Defaut is set to &quot;optimal&quot;.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_beta.univ">beta.univ</code></td>
<td>
<p>logical. If <code>TRUE</code> a robust simple regression is
performed for each explanatory variable in order to get starting
values for the fixed effect parameters.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_gamma.univ">gamma.univ</code></td>
<td>
<p>logical. If <code>TRUE</code> a simple regression is
performed for each explanatory variable in order to get starting
values for the random variance parameters.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_fixed.init">fixed.init</code></td>
<td>
<p>string with function name to be used to calculate
initial value of the fixed effect parameters. Possible values are
&quot;lmrob.S&quot; and &quot;lmRob&quot;.    
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_cov.init">cov.init</code></td>
<td>
<p>function or string with function name to be used to calculate
initial covariance matrix estimate if necessary. Possible string
value is &quot;TSGS&quot;, &quot;2SGS&quot; and &quot;covOGK&quot;. Default is
set to &quot;TSGS&quot;.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_cov">cov</code></td>
<td>
<p>logical. If <code>TRUE</code> the estimated variance-covariance
matrix for the fixed and random parameters is reported.
</p>
</td></tr>
<tr><td><code id="varComprob.control_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a named 'list' with over twenty components, corresponding
to the arguments.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Victor J. Yohai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Show the default settings:
     str(varComprob.control())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
