<!DOCTYPE html><html><head><title>Help for package RHclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RHclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BinaryClass'><p>Binary Classification</p></a></li>
<li><a href='#SimData'><p>GE, CPG, SNP, and Covariate Simulated Data</p></a></li>
<li><a href='#VIP'><p>Vector in Partition</p></a></li>
<li><a href='#VIPcov'><p>Vector in Partition with covariates</p></a></li>
<li><a href='#VIPnoCPG'><p>Vector in Partition without CPG data</p></a></li>
<li><a href='#VIPnoSNP'><p>Vector in Partition without SNP data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vector in Partition</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Handwerker &lt;jkhndwrk@memphis.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Non-parametric clustering of joint pattern multi-genetic/epigenetic factors. This package contains functions designed to cluster subjects based on gene features including single nucleotide polymorphisms (SNPs), DNA methylation (CPG), gene expression (GE), and covariate data. The novel concept follows the general K-means (Hartigan and Wong (1979) &lt;<a href="https://doi.org/10.2307%2F2346830">doi:10.2307/2346830</a>&gt; framework but uses weighted Euclidean distances across the gene features to cluster subjects. This approach is unique in that it attempts to capture all pairwise interactions in an effort to cluster based on their complex biological interactions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Runuran,graphics,stats,utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-14 23:28:36 UTC; 19018</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Handwerker [aut, cre],
  Lauren Sobral [ctb],
  Meredith Ray [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-15 07:20:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='BinaryClass'>Binary Classification</h2><span id='topic+BinaryClass'></span>

<h3>Description</h3>

<p>A confusion matrix but allows for anaylsis of non-equal level data classifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryClass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryClass_+3A_x">x</code></td>
<td>
<p>Can be a data frame dimensions at least 2 rows and 2 columns meant to represent observed and predicted values where the observed (true) values are in the first column and predicted columns in the second column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BinaryClass() is similar to a confusion matrix with binary classification outputs. The true positive values per column are identified based on the maximum number of assignments per category.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Table</code></td>
<td>
<p>the results of 'table()' on 'x'</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>overall accuracy of classification</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>confidence interval of overall accuracy using Clopper-Pearson Interval</p>
</td></tr>
<tr><td><code>Group Measures</code></td>
<td>
<p>the sensitivity, specificity, positive predictive value, negative predictive value, prevelance detection rate, detection prevalence, and balanced accuracy for each class</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>jkhndwrk@memphis.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic example
true = c(rep(1,5), rep(2,5), rep(3,5), rep(4,5))
pred = c(rep(1,4),4,rep(2,5),2,rep(3,4),1,rep(4,4))
df = cbind(true,pred)
BinaryClass(df)


true = c(rep(1,5), rep(2,5), rep(3,5), rep(4,5))
pred = c(rep(1,5),rep(2,5),rep(3,10))
df = cbind(true,pred)
BinaryClass(df)



sd = SimData(k = c(10,40,50))
out = VIP(sd, v = 3, optimize = 'elbow', nstart = 5)
df = out$`BC Test`
BinaryClass(df)


## Looping through different clusters

sd = SimData(seed = 1, gene = 1)
acc = NULL
for (i in 1:5){
 out = VIP(sd, v = i, optimize = 'off', nstart = 5)
 acc[i] = BinaryClass(out$`BC Test`)$Accuracy
}

plot(acc, type = 'b', main = 'Accuracy Comparison', xlab = 'Clusters', ylab = 'Acc')

</code></pre>

<hr>
<h2 id='SimData'>GE, CPG, SNP, and Covariate Simulated Data</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>Simulated data generator containing continuous variables representing gene expression (GE) data and DNA methylation data as M-values (GPG), and  categorical variable representing single nucleotide polymorphisms (SNP). GE and CPG data are simulated from a normal distribution and SNP data is simulated from a multinomial distribution. Covariate data can have uniformly distributed data or normally distributed. Cluster separation can also be distinct or non-distinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimData(seed = NULL, gene = 36,
        k = c(33,33,34),
        GEbar = 5, GEsd = 0.5,
        CPGbar = 4, CPGsd = 0.5,
        SameCPG = FALSE, SameSNP = FALSE,
        ProbDist = NULL, SameGeneDist = TRUE,
        distinct=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimData_+3A_seed">seed</code></td>
<td>
<p>Set specified seed for reproducibility</p>
</td></tr>
<tr><td><code id="SimData_+3A_gene">gene</code></td>
<td>
<p>Numeric input that specifies the number genes</p>
</td></tr>
<tr><td><code id="SimData_+3A_k">k</code></td>
<td>
<p>Cluster pattern/distribution across subjects formatted as a vector, i.e. c(33,33,34) representing 33 subjects in the first cluster, 33 in the second cluster, and 34 in the third cluster.</p>
</td></tr>
<tr><td><code id="SimData_+3A_gebar">GEbar</code></td>
<td>
<p>Optional numeric input to change the mean distribution of GE data</p>
</td></tr>
<tr><td><code id="SimData_+3A_gesd">GEsd</code></td>
<td>
<p>Optional numeric input to change the standard deviation of GE data</p>
</td></tr>
<tr><td><code id="SimData_+3A_cpgbar">CPGbar</code></td>
<td>
<p>Optional numeric input to change the mean distribution of CPG data</p>
</td></tr>
<tr><td><code id="SimData_+3A_cpgsd">CPGsd</code></td>
<td>
<p>Optional numeric input to change the standard deviation of CPG data</p>
</td></tr>
<tr><td><code id="SimData_+3A_samecpg">SameCPG</code></td>
<td>
<p>Logical value that if set to True sets the distribution of each CPG cluster around the same mean</p>
</td></tr>
<tr><td><code id="SimData_+3A_samesnp">SameSNP</code></td>
<td>
<p>Logical value that if set to True changes the probability distribution of SNPs to be the same per cluster</p>
</td></tr>
<tr><td><code id="SimData_+3A_probdist">ProbDist</code></td>
<td>
<p>Optional list input that allows the change of SNP probability distributions per cluster. Default list stops at 5 cluster distributions. Default ProbDist = list(c(0.50,0.25,0.25), c(0.20,0.55,0.25), c(0.30,0.15,0.55), c(0.20,0.50,0.30), c(0.45,0.20,0.35))</p>
</td></tr>
<tr><td><code id="SimData_+3A_samegenedist">SameGeneDist</code></td>
<td>
<p>Logical that set the covariates to follow the genetic clustering scheme where the data is uniformly distributed amongst each subgroup in each cluster. Or if set to FALSE sets the covariates to be noisy and have no discernible groups.</p>
</td></tr>
<tr><td><code id="SimData_+3A_distinct">distinct</code></td>
<td>
<p>Logical that sets the covariate data clusters to be distinct at default, or non-distance when set to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SimData creates simulated data that aims to represent real world data for gene expression (GE), DNA methylations (CPG),
and single neucleotide polymorphisms (SNP). Covariate data is used to represent other potentially useful health data to further weight the genetics data. The goal of this function is to allow the user the ability to manipulate their data for testing of the VIP() or VIPcov() functions.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Clusters</code></td>
<td>
<p>Vector of cluster assignment for each subject.</p>
</td></tr>
<tr><td><code>Vec</code></td>
<td>
<p>Numeric representation of values per cluster used for sensitivity measures.</p>
</td></tr>
<tr><td><code>GE</code></td>
<td>
<p>Simulated continuous data for GE. Means of each cluster changes by a factor of 5 with default standard deviation of 0.5.</p>
</td></tr>
<tr><td><code>CPG</code></td>
<td>
<p>Simulated continuous data for CPG. Means of each cluster changes by a factor of 4 with default standard deviation of 0.5.</p>
</td></tr>
<tr><td><code>SNP</code></td>
<td>
<p>Simulated categorical data for SNP.</p>
</td></tr>
<tr><td><code>GE_Index</code></td>
<td>
<p>Index names for GE.</p>
</td></tr>
<tr><td><code>CPG_Index</code></td>
<td>
<p>Index names for CPG.</p>
</td></tr>
<tr><td><code>SNP_Index</code></td>
<td>
<p>Index names for SNP.</p>
</td></tr>
<tr><td><code>Covariates</code></td>
<td>
<p>Simulated data for covariate data. By default contains 10 columns of cateogrical data and 10 columns of numeric data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>jkhndwrk@memphis.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating simulated data
sd = SimData()

## Specifying seed, genes, and clusters
# sd = SimData(seed = 42, gene = 18, c(10,40,50))

# Specifying probability distribution of SNP data
l = list( c(10, 35, 55),
          c(60, 20, 20),
          c(25, 50, 25))
sd = SimData(1, g = 36, ProbDist = l)

sd = SimData(1, g = 36, c(33,33,34))

# Same SNP distribution across 2 clusters
ssnp = SimData(g = 36, k = c(10,90), SameSNP = TRUE)

# Same CpG distribution across 2 cluster
scpg = SimData(g = 36, k = c(10,90), SameCPG = TRUE)

</code></pre>

<hr>
<h2 id='VIP'>Vector in Partition</h2><span id='topic+VIP'></span>

<h3>Description</h3>

<p>Clustering of subjects based on similar patterns of gene expression, DNA methylation, and SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIP(Simulated = NULL, SNP = NULL, CPG = NULL, GE = NULL,
                SNPname = NULL, CPGname = NULL, GEname = NULL, v,
                optimize = c('off','min','slope','elbow'),
                iter_max = 1000, nstart = 5, fit = c('aic','bic'),
                seed = NULL, type = c('Default','NoCPG','NoSNP'),
                ct = c('mean','median'), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VIP_+3A_simulated">Simulated</code></td>
<td>
<p>set to name of simulated data built from SimData(), else set to NULL for real data.</p>
</td></tr>
<tr><td><code id="VIP_+3A_snp">SNP</code></td>
<td>
<p>Data frame or data matrix containing categorical SNP data. Input must be in form of N x M, with N rows of subjects and M columns of SNPs. Rownames are permitted. Run SimData()$SNP for examples.</p>
</td></tr>
<tr><td><code id="VIP_+3A_cpg">CPG</code></td>
<td>
<p>Data frame or data matrix containing numeric CPG data. Input must be in form of N x M, with N rows of subjects and M columns of CPG. Rownames are permitted. Run SimData()$CPG for examples.</p>
</td></tr>
<tr><td><code id="VIP_+3A_ge">GE</code></td>
<td>
<p>Data frame or data matrix containing numeric GE data. Input must be in form of N x M, with N rows of subjects and M columns of GE. Rownames are permitted. Run SimData()$GE for examples.</p>
</td></tr>
<tr><td><code id="VIP_+3A_snpname">SNPname</code></td>
<td>
<p>Names for SNP data. Data must be a data frame of Nx2 dimensions with SNP sites as column 1, and GE indexes in column 2. Order of SNPs must match the order of the SNP columns in the argument SNP. See SimData()$SNP_Index for examples.</p>
</td></tr>
<tr><td><code id="VIP_+3A_cpgname">CPGname</code></td>
<td>
<p>Names for CPG data. Data must be a data frame of Nx2 dimensions with CPG sites as column 1, and GE indexes in column 2. Order of CPGs must match the order of the CPG columns in the argument GE. See SimData()$CPG_Index for examples.</p>
</td></tr>
<tr><td><code id="VIP_+3A_gename">GEname</code></td>
<td>
<p>Names for GE data. Data must be a data frame of Nx2 dimensions with GE sites as column 1, and GE indexes in column 2. Order of GEs must match the order of the GE columns in the argument GE. See SimData()$GE_Index for examples.</p>
</td></tr>
<tr><td><code id="VIP_+3A_v">v</code></td>
<td>
<p>Numeric scalar or vector of number for clusters, or a range of clusters with format c(l,u) for cluster l:u</p>
</td></tr>
<tr><td><code id="VIP_+3A_optimize">optimize</code></td>
<td>
<p>Returned the optimal number of clusters. Input 'min' returns cluster assignment with lowest WSS for clusters in v. Input 'slope' indicates whether the algorithm should pick the lowest WSS value based on the first increasing slope. Input 'elbow' fits a line between the first and last fitted WSS and finds the corresponding cluster with the maximum distance to that line. All but 'slope' return plots.</p>
</td></tr>
<tr><td><code id="VIP_+3A_iter_max">iter_max</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="VIP_+3A_nstart">nstart</code></td>
<td>
<p>If nstart &gt; 1, repetitive computations with random initializations are computed and the result with minimum tot_dist is returned.</p>
</td></tr>
<tr><td><code id="VIP_+3A_fit">fit</code></td>
<td>
<p>Penalizing factor for WSS of clusters. Can be set to either 'aic' or 'bic'.</p>
</td></tr>
<tr><td><code id="VIP_+3A_seed">seed</code></td>
<td>
<p>Optional input to sample the same initial cluster centers.</p>
</td></tr>
<tr><td><code id="VIP_+3A_type">type</code></td>
<td>
<p>Optional input for special cases for data without CPGs or SNP inputs. Options include &quot;Default&quot;, &quot;NoSNP&quot;, or &quot;NoCPG&quot;</p>
</td></tr>
<tr><td><code id="VIP_+3A_ct">ct</code></td>
<td>
<p>Central tendency option for cluster assignment. Options include 'mean' or 'median'.</p>
</td></tr>
<tr><td><code id="VIP_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether information about the cluster procedure should be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to k-means and k-proto clustering, this algorithm computes clusters based on weighted factors of mixed data relative to genetic/epigenetic data. Clusters are assigned using sumed euclidean distance of numerics (<em>GE</em> and <em>CPG</em>) weighted by matching categorical (<em>SNP</em>) data. Central tendancy of numeric data can be set to either mean or median with input <em>ct</em>.
</p>
<p>Data must be ordered such that rows in each data set correspond to the same subject and order of the indexes match the order of the columns in the data. The current algorithm does not allow for any missing data. The aim is for <em>GE</em>, <em>CPG</em>, and <em>SNP</em> data to be clustered into <em>v</em> groups such that within sum of squares is minimized. If groups of clusters are close, the algorithm may not converge correctly and signals a warning if cluster size is reduced.
</p>
<p>Optimization functionality was used for simulated data analysis, but is allowed for user exploratory analysis as well. <em>'min'</em> simply returns the lowest fitted WSS <em>fit</em> parameter. <em>'slope'</em> loops through clusters in <em>v</em> and returns the cluster based on the first increasing slope of fitted WSS. For example, if AIC output is c(100,80,35,50), cluster 3 would be returned since the slope increases from 3 to 4. If there is no increasing slope, the <em>'min'</em> optimizer will be returned. <em>'elbow'</em> seeks to find the elbow of the plot based on saturation point. This worked the best for simulation studies but requires more clusters to make proper predictions, in our case it required a range of at least 5 clusters c(1,5) to search to correctly identify the 3 simulated clusters. . For ease of exploratory analysis, <em>v</em>=1 is allowed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>size</code></td>
<td>
<p>Number of subjects assigned to each cluster.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Vector of cluster assignment.</p>
</td></tr>
<tr><td><code>GECenters</code></td>
<td>
<p>Matrix of cluster centers for GE.</p>
</td></tr>
<tr><td><code>CPGCenters</code></td>
<td>
<p>Matrix of cluster centers for CPG.</p>
</td></tr>
<tr><td><code>SNPCenters</code></td>
<td>
<p>Matrix of cluster centers for SNP.</p>
</td></tr>
<tr><td><code>within</code></td>
<td>
<p>Vector of within cluster sum of squares with one component per cluster.</p>
</td></tr>
<tr><td><code>tot_within</code></td>
<td>
<p>Sumed total of within-cluster sum of squares.</p>
</td></tr>
<tr><td><code>Moved</code></td>
<td>
<p>Number of iterations before convergence.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Value of tot_within with aic penalizer.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Value of tot_within with bic penalizer.</p>
</td></tr>
<tr><td><code>outputPlot</code></td>
<td>
<p>Returns the tot_within, aic, bic, and v values for ploting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>jkhndwrk@memphis.edu
</p>


<h3>References</h3>

<p>Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means clustering algorithm. Applied Statistics, 28, 100&ndash;108. 10.2307/2346830.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple output of 3 clusters assignments
sd = SimData(1, g = 36, c(33,33,34))
VIPout = VIP(sd, v = 3)

# loop through clusters 1-10 and outputs plot of WSS, AIC, and BIC
VIPout = VIP(sd, v = c(1,10))

# loop through clusters 1-10 but picks first instance of increasing slope
VIPout = VIP(sd, v = c(1,10), optimize = 'slope')


# Individual inputs
sd = SimData(1, g = 36, k = c(33,33,34))
VIPout = VIP(SNP = sd$SNP, CPG = sd$CPG, GE = sd$GE,
            SNPname = sd$SNP_Index, CPGname = sd$CPG_Index,
            GEname = sd$GE_Index,
            v = c(1,5), optimize = 'off', nstart = 5)


## Varying clusters
sd = SimData(k = c(10,40,50))
out = VIP(sd, v = c(1,6), optimize = 'elbow', nstart = 30)


</code></pre>

<hr>
<h2 id='VIPcov'>Vector in Partition with covariates</h2><span id='topic+VIPcov'></span>

<h3>Description</h3>

<p>Clustering of subjects based on similar patterns of gene expression, DNA methylation, and SNPs weighted by covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIPcov(Simulated = NULL, SNP = NULL, CPG = NULL, GE = NULL,
                SNPname = NULL, CPGname = NULL, GEname = NULL,
                covariates = NULL, v, lambda = NULL, gamma = 1,
                optimize = c('off','min','slope','elbow'),
                iter_max = 1000, nstart = 5, fit = c('aic','bic'),
                seed = NULL, type = c('Default','NoCPG','NoSNP'),
                ct = c('mean','median'), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VIPcov_+3A_simulated">Simulated</code></td>
<td>
<p>set to name of simulated data built from SimData(), else set to NULL for real data.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_snp">SNP</code></td>
<td>
<p>Data frame or data matrix containing categorical SNP data. Input must be in form of N x M, with N rows of subjects and M columns of SNPs. Rownames are permitted. Run SimData()$SNP for examples.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_cpg">CPG</code></td>
<td>
<p>Data frame or data matrix containing numeric CPG data. Input must be in form of N x M, with N rows of subjects and M columns of CPG. Rownames are permitted. Run SimData()$CPG for examples.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_ge">GE</code></td>
<td>
<p>Data frame or data matrix containing numeric GE data. Input must be in form of N x M, with N rows of subjects and M columns of GE. Rownames are permitted. Run SimData()$GE for examples.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_snpname">SNPname</code></td>
<td>
<p>Names for SNP data. Data must be a data frame of Nx2 dimensions with SNP sites as column 1, and GE indexes in column 2. Order of SNPs must match the order of the SNP columns in the argument SNP. See SimData()$SNP_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_cpgname">CPGname</code></td>
<td>
<p>Names for CPG data. Data must be a data frame of Nx2 dimensions with CPG sites as column 1, and GE indexes in column 2. Order of CPGs must match the order of the CPG columns in the argument GE. See SimData()$CPG_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_gename">GEname</code></td>
<td>
<p>Names for GE data. Data must be a data frame of Nx2 dimensions with GE sites as column 1, and GE indexes in column 2. Order of GEs must match the order of the GE columns in the argument GE. See SimData()$GE_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_covariates">covariates</code></td>
<td>
<p>Data frame or matrix containing numeric and or categorical variables used for weighting the distance matrix of the genetics data.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_v">v</code></td>
<td>
<p>Numeric scalar or vector of number for clusters, or a range of clusters with format c(l,u) for cluster l:u</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_lambda">lambda</code></td>
<td>
<p>Weighting factor for the covariate data. The default value is calculated by taking the average variance of the numeric variables divided by the average concentraion of the factors for the categorical variables. When non-mixed type data are used, the value is set to 1 unless specified otherwise.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_gamma">gamma</code></td>
<td>
<p>Weighting factor for the genetics distance measure. Default is set to 1</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_optimize">optimize</code></td>
<td>
<p>Returned the optimal number of clusters. Input 'min' returns cluster assignment with lowest WSS for clusters in v. Input 'slope' indicates whether the algorithm should pick the lowest WSS value based on the first increasing slope. Input 'elbow' fits a line between the first and last fitted WSS and finds the corresponding cluster with the maximum distance to that line. All but 'slope' return plots.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_iter_max">iter_max</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_nstart">nstart</code></td>
<td>
<p>If nstart &gt; 1, repetitive computations with random initializations are computed and the result with minimum tot_dist is returned.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_fit">fit</code></td>
<td>
<p>Penalizing factor for WSS of clusters. Can be set to either 'aic' or 'bic'.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_seed">seed</code></td>
<td>
<p>Optional input to sample the same initial cluster centers.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_type">type</code></td>
<td>
<p>Optional input for special cases for data without CPGs or SNP inputs. Options include &quot;Default&quot;, &quot;NoSNP&quot;, or &quot;NoCPG&quot;</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_ct">ct</code></td>
<td>
<p>Central tendency option for cluster assignment. Options include 'mean' or 'median'.</p>
</td></tr>
<tr><td><code id="VIPcov_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether information about the cluster procedure should be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is an extension of the VIP() function and allows for the clustering method to be further weighted by the covarite distance. The covariate distance measure is similar to that seen in <em>kproto()</em> where the euclidian measure of the numerics data is weighted by matching categorical variables and a weighting factor. Clsuters are assigned based on these two distance measures where the Central tendancy of numeric data can be set to either mean or median with input <em>ct</em>.
</p>
<p>Data must be ordered such that rows in each data set correspond to the same subject and order of the indexes match the order of the columns in the data. The current algorithm does not allow for any missing data. The aim is for <em>GE</em>, <em>CPG</em>, and <em>SNP</em> data to be clustered into <em>v</em> groups after being weighted by covariates such that within sum of squares is minimized. If groups of clusters are close, the algorithm may not converge correctly and signals a warning if cluster size is reduced.
</p>
<p>Optimization functionality was used for simulated data analysis, but is allowed for user exploratory analysis as well. <em>'min'</em> simply returns the lowest fitted WSS <em>fit</em> parameter. <em>'slope'</em> loops through clusters in <em>v</em> and returns the cluster based on the first increasing slope of fitted WSS. For example, if AIC output is c(100,80,35,50), cluster 3 would be returned since the slope increases from 3 to 4. If there is no increasing slope, the <em>'min'</em> optimizer will be returned. <em>'elbow'</em> seeks to find the elbow of the plot based on saturation point. This worked the best for simulation studies but requires more clusters to make proper predictions, in our case it required a range of at least 5 clusters c(1,5) to search to correctly identify the 3 simulated clusters. For ease of exploratory analysis, <em>v</em>=1 is allowed. <em>'lambda'</em> is used as a weighting factor for the covariate distance measure, while <em>'gamma'</em> is the weighting factor for the genetics distance.
</p>


<h3>Value</h3>

<table>
<tr><td><code>size</code></td>
<td>
<p>Number of subjects assigned to each cluster.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Vector of cluster assignment.</p>
</td></tr>
<tr><td><code>GECenters</code></td>
<td>
<p>Matrix of cluster centers for GE.</p>
</td></tr>
<tr><td><code>CPGCenters</code></td>
<td>
<p>Matrix of cluster centers for CPG.</p>
</td></tr>
<tr><td><code>SNPCenters</code></td>
<td>
<p>Matrix of cluster centers for SNP.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Logical if the genetics distance measure is weighted by covariates.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>Lambda value used to weight the covariate distance measure.</p>
</td></tr>
<tr><td><code>within</code></td>
<td>
<p>Vector of within cluster sum of squares with one component per cluster.</p>
</td></tr>
<tr><td><code>tot_within</code></td>
<td>
<p>Sumed total of within-cluster sum of squares.</p>
</td></tr>
<tr><td><code>Moved</code></td>
<td>
<p>Number of iterations before convergence.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Value of tot_within with aic penalizer.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Value of tot_within with bic penalizer.</p>
</td></tr>
<tr><td><code>outputPlot</code></td>
<td>
<p>Returns the tot_within, aic, bic, and v values for ploting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>jkhndwrk@memphis.edu
</p>


<h3>References</h3>

<p>Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means clustering algorithm. Applied Statistics, 28, 100&ndash;108. 10.2307/2346830.
</p>
<p>Z. Huang. (1998) Extensions to the k-means algorithm for clustering large data sets with categorical variables.
Data Mining and Knowledge Discovery, 2:283–304, doi: 10.1023/A:1009769707641.
</p>
<p>Szepannek G (2018). “clustMixType: User-Friendly Clustering of Mixed-Type Data in R.” The R Journal, 200-208. doi:10.32614/RJ-2018-048, https://doi.org/10.32614/RJ-2018-048.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple output of 3 clusters assignments
sd = SimData(1, g = 36, c(33,33,34))
VIPout = VIPcov(sd, v = 3, covariates = sd$Covariates)

# loop through clusters 1-10 and outputs plot of WSS, AIC, and BIC
VIPout = VIPcov(sd, v = c(1,10), covariates = sd$Covariates)

# loop through clusters 1-10 but picks first instance of increasing slope
VIPout = VIPcov(sd, v = c(1,10), optimize = 'slope', covariates = sd$Covariates)


# Individual inputs
sd = SimData(1, g = 36, k = c(33,33,34))
VIPout = VIPcov(SNP = sd$SNP, CPG = sd$CPG, GE = sd$GE,
            SNPname = sd$SNP_Index, CPGname = sd$CPG_Index,
            GEname = sd$GE_Index,
            v = c(1,5), optimize = 'off', nstart = 5, covariates = sd$Covariates)


## Varying clusters
sd = SimData(k = c(10,40,50))
out = VIPcov(sd, v = c(1,6), optimize = 'elbow', nstart = 30, covariates = sd$Covariates)


</code></pre>

<hr>
<h2 id='VIPnoCPG'>Vector in Partition without CPG data</h2><span id='topic+VIPnoCPG'></span>

<h3>Description</h3>

<p>Clustering of subjects based on similar patterns of gene expression and SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIPnoCPG(Simulated = NULL, SNP = NULL, GE = NULL,
                SNPname = NULL, GEname = NULL, v,
                optimize = c('off','min','slope','elbow'),
                iter_max = 1000, nstart = 5, fit = c('aic','bic'),
                seed = NULL, ct = c('mean','median'), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VIPnoCPG_+3A_simulated">Simulated</code></td>
<td>
<p>set to name of simulated data built from SimData(), else set to NULL for real data.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_snp">SNP</code></td>
<td>
<p>Data frame or data matrix containing categorical SNP data. Input must be in form of N x M, with N rows of subjects and M columns of SNPs. Rownames are permitted. Run SimData()$SNP for examples.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_ge">GE</code></td>
<td>
<p>Data frame or data matrix containing numeric GE data. Input must be in form of N x M, with N rows of subjects and M columns of GE. Rownames are permitted. Run SimData()$GE for examples.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_snpname">SNPname</code></td>
<td>
<p>Names for SNP data. Data must be a data frame of Nx2 dimensions with SNP sites as column 1, and GE indexes in column 2. Order of SNPs must match the order of the SNP columns in the argument SNP. See SimData()$SNP_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_gename">GEname</code></td>
<td>
<p>Names for GE data. Data must be a data frame of Nx2 dimensions with GE sites as column 1, and GE indexes in column 2. Order of GEs must match the order of the GE columns in the argument GE. See SimData()$GE_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_v">v</code></td>
<td>
<p>Numeric scalar or vector of number for clusters, or a range of clusters with format c(l,u) for cluster l:u</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_optimize">optimize</code></td>
<td>
<p>Returned the optimal number of clusters. Input 'min' returns cluster assignment with lowest WSS for clusters in v. Input 'slope' indicates whether the algorithm should pick the lowest WSS value based on the first increasing slope. Input 'elbow' fits a line between the first and last fitted WSS and finds the corresponding cluster with the maximum distance to that line. All but 'slope' return plots.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_iter_max">iter_max</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_nstart">nstart</code></td>
<td>
<p>If nstart &gt; 1, repetitive computations with random initializations are computed and the result with minimum tot_dist is returned.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_fit">fit</code></td>
<td>
<p>Penalizing factor for WSS of clusters. Can be set to either 'aic' or 'bic'.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_seed">seed</code></td>
<td>
<p>Optional input to sample the same initial cluster centers.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_ct">ct</code></td>
<td>
<p>Central tendency option for cluster assignment. Options include 'mean' or 'median'.</p>
</td></tr>
<tr><td><code id="VIPnoCPG_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether information about the cluster procedure should be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details are outlined in the main VIP() function. The only difference in this function is the absence of CPG data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>size</code></td>
<td>
<p>Number of subjects assigned to each cluster.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Vector of cluster assignment.</p>
</td></tr>
<tr><td><code>GECenters</code></td>
<td>
<p>Matrix of cluster centers for GE.</p>
</td></tr>
<tr><td><code>SNPCenters</code></td>
<td>
<p>Matrix of cluster centers for SNP.</p>
</td></tr>
<tr><td><code>within</code></td>
<td>
<p>Vector of within cluster sum of squares with one component per cluster.</p>
</td></tr>
<tr><td><code>tot_within</code></td>
<td>
<p>Sumed total of within-cluster sum of squares.</p>
</td></tr>
<tr><td><code>Moved</code></td>
<td>
<p>Number of iterations before convergence.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Value of tot_within with aic penalizer.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Value of tot_within with bic penalizer.</p>
</td></tr>
<tr><td><code>outputPlot</code></td>
<td>
<p>Returns the tot_within, aic, bic, and v values for ploting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>jkhndwrk@memphis.edu
</p>


<h3>References</h3>

<p>Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means clustering algorithm. Applied Statistics, 28, 100&ndash;108. 10.2307/2346830.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# No CPG data
sd = SimData()
noCPGout = VIP(sd, v = c(1,5), optimize = 'off', nstart = 30, type = 'NoCPG')

noCPGout = VIPnoCPG(sd, v = c(1,5), optimize = 'off', nstart = 30)

</code></pre>

<hr>
<h2 id='VIPnoSNP'>Vector in Partition without SNP data</h2><span id='topic+VIPnoSNP'></span>

<h3>Description</h3>

<p>Clustering of subjects based on similar patterns of gene expression and DNA methylation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIPnoSNP(Simulated = NULL, CPG = NULL, GE = NULL,
                CPGname = NULL, GEname = NULL, v,
                optimize = c('off','min','slope','elbow'),
                iter_max = 1000, nstart = 5, fit = c('aic','bic'),
                seed = NULL, ct = c('mean','median'), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VIPnoSNP_+3A_simulated">Simulated</code></td>
<td>
<p>set to name of simulated data built from SimData(), else set to NULL for real data.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_cpg">CPG</code></td>
<td>
<p>Data frame or data matrix containing numeric CPG data. Input must be in form of N x M, with N rows of subjects and M columns of CPG. Rownames are permitted. Run SimData()$CPG for examples.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_ge">GE</code></td>
<td>
<p>Data frame or data matrix containing numeric GE data. Input must be in form of N x M, with N rows of subjects and M columns of GE. Rownames are permitted. Run SimData()$GE for examples.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_cpgname">CPGname</code></td>
<td>
<p>Names for CPG data. Data must be a data frame of Nx2 dimensions with CPG sites as column 1, and GE indexes in column 2. Order of CPGs must match the order of the CPG columns in the argument GE. See SimData()$CPG_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_gename">GEname</code></td>
<td>
<p>Names for GE data. Data must be a data frame of Nx2 dimensions with GE sites as column 1, and GE indexes in column 2. Order of GEs must match the order of the GE columns in the argument GE. See SimData()$GE_Index for examples.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_v">v</code></td>
<td>
<p>Numeric scalar or vector of number for clusters, or a range of clusters with format c(l,u) for cluster l:u</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_optimize">optimize</code></td>
<td>
<p>Returned the optimal number of clusters. Input 'min' returns cluster assignment with lowest WSS for clusters in v. Input 'slope' indicates whether the algorithm should pick the lowest WSS value based on the first increasing slope. Input 'elbow' fits a line between the first and last fitted WSS and finds the corresponding cluster with the maximum distance to that line. All but 'slope' return plots.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_iter_max">iter_max</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_nstart">nstart</code></td>
<td>
<p>If nstart &gt; 1, repetitive computations with random initializations are computed and the result with minimum tot_dist is returned.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_fit">fit</code></td>
<td>
<p>Penalizing factor for WSS of clusters. Can be set to either 'aic' or 'bic'.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_seed">seed</code></td>
<td>
<p>Optional input to sample the same initial cluster centers.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_ct">ct</code></td>
<td>
<p>Central tendency option for cluster assignment. Options include 'mean' or 'median'.</p>
</td></tr>
<tr><td><code id="VIPnoSNP_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether information about the cluster procedure should be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details are outlined in the main VIP() function. The only difference in this function is the absence of SNP data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>size</code></td>
<td>
<p>Number of subjects assigned to each cluster.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Vector of cluster assignment.</p>
</td></tr>
<tr><td><code>GECenters</code></td>
<td>
<p>Matrix of cluster centers for GE.</p>
</td></tr>
<tr><td><code>CPGCenters</code></td>
<td>
<p>Matrix of cluster centers for CPG.</p>
</td></tr>
<tr><td><code>within</code></td>
<td>
<p>Vector of within cluster sum of squares with one component per cluster.</p>
</td></tr>
<tr><td><code>tot_within</code></td>
<td>
<p>Sumed total of within-cluster sum of squares.</p>
</td></tr>
<tr><td><code>Moved</code></td>
<td>
<p>Number of iterations before convergence.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Value of tot_within with aic penalizer.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Value of tot_within with bic penalizer.</p>
</td></tr>
<tr><td><code>outputPlot</code></td>
<td>
<p>Returns the tot_within, aic, bic, and v values for ploting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>jkhndwrk@memphis.edu
</p>


<h3>References</h3>

<p>Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means clustering algorithm. Applied Statistics, 28, 100&ndash;108. 10.2307/2346830.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# No SNP data
sd = SimData()
noSNPout = VIP(sd, v = c(1,5), optimize = 'off', nstart = 30, type = 'NoSNP')

noSNPout = VIPnoSNP(sd, v = c(1,5), optimize = 'off', nstart = 30)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
