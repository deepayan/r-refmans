<!DOCTYPE html><html lang="en"><head><title>Help for package HAC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HAC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate.hac'><p>Aggregation of variables</p></a></li>
<li><a href='#copMult'><p><code class="reqn">d</code>-dim copula</p></a></li>
<li><a href='#dHAC+2C+20pHAC+2C+20rHAC'><p>pdf, cdf and random sampling</p></a></li>
<li><a href='#emp.copula'><p>Empirical copula</p></a></li>
<li><a href='#estimate.copula'><p>Estimation of Hierarchical Archimedean Copulae</p></a></li>
<li><a href='#finData'><p>Financial data</p></a></li>
<li><a href='#get.params'><p>Dependency parameters of a HAC</p></a></li>
<li><a href='#hac'><p>Construction of <span class="env">hac</span> objects</p></a></li>
<li><a href='#par.pairs'><p>Parameter of the HAC</p></a></li>
<li><a href='#phi+2C+20phi.inv'><p>Generator function</p></a></li>
<li><a href='#plot.hac'><p>Plot of a HAC</p></a></li>
<li><a href='#theta2tau+2C+20tau2theta'><p>Kendall's rank correlation coefficient</p></a></li>
<li><a href='#to.logLik'><p>log-likelihood</p></a></li>
<li><a href='#tree2str'><p>String structure of HAC</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation, Simulation and Visualization of Hierarchical
Archimedean Copulae (HAC)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gong Chen &lt;gong.chen1@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), copula</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Package provides the estimation of the structure and the parameters, sampling methods and structural plots of Hierarchical Archimedean Copulae (HAC).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tu-dresden.de/bu/verkehr/ivw/osv/die-professur/inhaber-in">https://tu-dresden.de/bu/verkehr/ivw/osv/die-professur/inhaber-in</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-13 15:55:49 UTC; gongchen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-16 11:00:02 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Ostap Okhrin [aut],
  Alexander Ristig [aut],
  Gong Chen [cre]</td>
</tr>
</table>
<hr>
<h2 id='aggregate.hac'>Aggregation of variables
</h2><span id='topic+aggregate.hac'></span>

<h3>Description</h3>

<p><code>aggregate</code> tests, whether the absolute difference of the parameters of two subsequent nodes is smaller than a constant, i.e. <code class="reqn">\vert \theta_{2} - \theta_{1} \vert &lt; \epsilon</code>, where <code class="reqn">\theta_{i}</code> denotes the dependency parameter with <code class="reqn">\theta_{2} &lt; \theta_{1}</code>, <code class="reqn">\epsilon \geq 0</code>. If the absolute difference is smaller than the constant, the variables of the nodes are aggregated in a single node with new dependency parameter, e.g. <code class="reqn"> \theta_{new} = (\theta_{1} + \theta_{2})/2</code>. This procedure is applied to all consecutive nodes of the HAC <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hac'
aggregate(x, epsilon = 0, method = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate.hac_+3A_x">x</code></td>
<td>

<p>an object of the class <span class="env">hac</span>.
</p>
</td></tr>
<tr><td><code id="aggregate.hac_+3A_epsilon">epsilon</code></td>
<td>

<p>scalar <code class="reqn">\geq 0</code>.
</p>
</td></tr>
<tr><td><code id="aggregate.hac_+3A_method">method</code></td>
<td>

<p>determines, whether the new parameter is the <code>"mean"</code>, <code>"min"</code> or <code>"max"</code> of the fused parameters.
</p>
</td></tr>
<tr><td><code id="aggregate.hac_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the class <span class="env">hac</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hac">hac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:
# an object of the class hac is constructed, whose parameters are close
copula = hac(type = 1, tree = list("X1", list("X2", "X3", 2.05), 2))

# the function aggregate returns a simple Archimedean copula

copula_ag = aggregate(copula, epsilon = 0.1)
tree2str(copula_ag) # [1] "(X1.X2.X3)_{2.02}"

# the structure does not change for a smaller epsilon

copula_ag = aggregate(copula, epsilon = 0.01)
tree2str(copula_ag) # [1] "((X2.X3)_{2.05}.X1)_{2}"

# Example 2:
# consider the binary tree

Object = hac.full(type = 1, y = c("X1", "X2", "X3", "X4", "X5"), 
theta = c(1.01, 1.02, 2, 2.01))

tree2str(Object) # [1] "((((X5.X4)_{2.01}.X3)_{2}.X2)_{1.02}.X1)_{1.01}"

# applying aggregate.hac with epsilon = 0.02 leads to

Object_ag = aggregate(Object, 0.02)
tree2str(Object_ag) # [1] "((X3.X5.X4)_{2}.X1.X2)_{1.02}"
</code></pre>

<hr>
<h2 id='copMult'><code class="reqn">d</code>-dim copula
</h2><span id='topic+copMult'></span>

<h3>Description</h3>

<p>This function returns the values for <code class="reqn">d</code>-dimensional Archimedean copulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copMult(X, theta, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copMult_+3A_x">X</code></td>
<td>

<p>a <code class="reqn">n \times d</code> matrix, where <code class="reqn">d</code> refers to the dimension of the copula.
</p>
</td></tr>
<tr><td><code id="copMult_+3A_theta">theta</code></td>
<td>

<p>the parameter of the copula.
</p>
</td></tr>
<tr><td><code id="copMult_+3A_type">type</code></td>
<td>

<p>all copula-types produced by Archimedean generators, see <code><a href="#topic+phi">phi</a></code> for an overview of implemented families.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If warnings are returned, see <code><a href="#topic+phi">phi</a></code>.
</p>


<h3>Value</h3>

<p>A vector containing the values of the copula.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pHAC">pHAC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># the arguments are defined
X = matrix(runif(300), ncol = 3)

# the values are computed
cop = copMult(X, theta = 1.5, type = 1)
</code></pre>

<hr>
<h2 id='dHAC+2C+20pHAC+2C+20rHAC'>pdf, cdf and random sampling
</h2><span id='topic+dHAC'></span><span id='topic+pHAC'></span><span id='topic+rHAC'></span>

<h3>Description</h3>

<p><code>dHAC</code> and <code>pHAC</code> compute the values of the copula's density and cumulative distribution function respectively. <code>rHAC</code> samples from HAC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHAC(X, hac, eval = TRUE, margins = NULL, na.rm = FALSE, ...)
pHAC(X, hac, margins = NULL, na.rm = FALSE, ...)
rHAC(n, hac)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_x">X</code></td>
<td>

<p>a data matrix. The number of columns and the corresponding names have to coincide with the specifications of the copula model <code>hac</code>.
</p>
</td></tr> 
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_hac">hac</code></td>
<td>

<p>an object of the class <code><a href="#topic+hac">hac</a></code>.
</p>
</td></tr>
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr>
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_margins">margins</code></td>
<td>

<p>specifies the margins. The data matrix <code>X</code> is assumed to contain the values of the marginal distributions by default, i.e. <code>margins = NULL</code>. If raw data are used, the margins can be determined nonparametrically, <code>"edf"</code>, or in parametric way, e.g. <code>"norm"</code>. See <code><a href="#topic+estimate.copula">estimate.copula</a></code> for a detailed explanation.
</p>
</td></tr>
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_na.rm">na.rm</code></td>
<td>

<p>boolean. If <code>na.rm = TRUE</code>, missing values, <code>NA</code>, contained in <code>X</code> are removed.
</p>
</td></tr>
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_eval">eval</code></td>
<td>

<p>boolean. If <code>eval = FALSE</code>, a non-evaluated <code><a href="base.html#topic+function">function</a></code> is returned. Note, that <code><a href="base.html#topic+attr">attr</a></code> <code>"gradient"</code> of the returned function corresponds to the values density.
</p>
</td></tr>
<tr><td><code id="dHAC+2B2C+2B20pHAC+2B2C+2B20rHAC_+3A_...">...</code></td>
<td>

<p>arguments to be passed to <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sampling schemes of hierarchical and densities of simple Archimedean copula are based on functions of the <span class="env">copula</span> package.
</p>


<h3>Value</h3>

<p><code>rHAC</code> retruns a <code class="reqn">n \times d</code> matrix, where <code class="reqn">d</code> refers to the dimension of the HAC. <code>dHAC</code> and <code>pHAC</code> return vectors. The computation of the density might be time consuming for high-dimensions, since the density is defined as <code class="reqn">d</code>-th derivative of the HAC with respect to its arguments <code class="reqn">u_1, \ldots, u_d</code>. 
</p>


<h3>References</h3>

<p>Hofert, M. 2011, Efficiently Sampling Nested Archimedean Copulas, <em>Computational Statistics &amp; Data Analysis</em> 55, 57-70.
</p>
<p>Joe, H. 1997, Multivariate Models and Dependence Concepts, <em>Chapman &amp; Hall</em>.
</p>
<p>McNeil, A. J. 2008, Sampling Nested Archimedean Copulas, <em>Journal of Statistical Computation and Simulation</em> 78, 567-581.
</p>
<p>Nelsen, R. B. 2006, An Introduction to Copulas, <em>Spinger</em>, 2nd Edition.
</p>
<p>Okhrin, O. and Ristig, A. 2014, Hierarchical Archimedean Copulae: The <code style="white-space: pre;">&#8288;HAC&#8288;</code> Package&quot;, <em>Journal of Statistical Software</em>, 58(4), 1-20, <a href="https://doi.org/10.18637/jss.v058.i04">doi:10.18637/jss.v058.i04</a>.
</p>
<p>Savu, C. and Trede, M. 2010, Hierarchies of Archimedean copulas, <em>Quantitative Finance</em> 10, 295-304.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.copula">estimate.copula</a></code>, <code><a href="#topic+to.logLik">to.logLik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AC example
# define the underlying model
model = hac(type = 4, tree = list("X1", "X2", 2))

# sample from model
sample = rHAC(100, model)

# returns the pdf/cdf at each vector of the sample
d.values = dHAC(sample, model)
p.values = pHAC(sample, model)

# HAC example
# the underlying model
y = c("X1", "X2", "X3")
theta = c(1.5, 3)
model = hac.full(type = 1, y, theta)

# define sample from copula model
sample = rHAC(100, model)

# returns the pdf/cdf at each point of the sample
d.values = dHAC(sample, model)
p.values = pHAC(sample, model)

# construct a hac-model
tree = list(list("X1", "X5", 3), list("X2", "X3", "X4", 4), 2)
model = hac(type = 1, tree = tree)

# sample from copula model
sample = rHAC(1000, model)

# check the accurancy of the estimation procedure
result1 = estimate.copula(sample)
result2 = estimate.copula(sample, epsilon = 0.2)
</code></pre>

<hr>
<h2 id='emp.copula'>Empirical copula </h2><span id='topic+emp.copula'></span><span id='topic+emp.copula.self'></span>

<h3>Description</h3>

<p><code>emp.copula</code> and <code>emp.copula.self</code> compute the empirical copula for a given sample. The difference between these 
functions is, that <code>emp.copula.self</code> does not require a matrix <code>u</code>, at which the function is evaluated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp.copula(u, x, proc = "M", sort = "none", margins = NULL, 
na.rm = FALSE, ...)
emp.copula.self(x, proc = "M", sort = "none", margins = NULL, 
na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emp.copula_+3A_u">u</code></td>
<td>

<p>a matrix, at which the function is evaluated. According to the dimension of the data matrix <code>x</code>, it can be a scalar, a vector or a matrix. The entries of <code>u</code> should be within the interval <code class="reqn">[0, 1]</code>. </p>
</td></tr>  <tr><td><code id="emp.copula_+3A_x">x</code></td>
<td>
 
<p>denotes the matrix of marginal distributions, if <code>margins = NULL</code>. The number of columns should be equal the dimension <code class="reqn">d</code>, whereas the number of rows should be equal to the number of observations 
<code class="reqn">n</code>, with <code class="reqn">n &gt; d</code>. </p>
</td></tr> 
<tr><td><code id="emp.copula_+3A_proc">proc</code></td>
<td>

<p>enables the user to choose between two different methods. It is recommended to use the default method, <code>"M"</code>, because it takes only a small fraction of the computational time of method <code>"A"</code>. However, method 
<code>"M"</code> is sensitive with respect to the size of the working memory and therefore, non-applicable for very large datasets.</p>
</td></tr> 
<tr><td><code id="emp.copula_+3A_sort">sort</code></td>
<td>

<p>defines, whether the output is ordered. <code>sort = "asc"</code> refers to ascending values, which might be interesting for plotting and <code>sort = "desc"</code> refers to descending values.
</p>
</td></tr>
<tr><td><code id="emp.copula_+3A_margins">margins</code></td>
<td>

<p>specifies the margins. The data matrix is assumed to contain the values of the marginal distributions by default, i.e. <code>margins = NULL</code>. If raw data are used, the margins can be determined nonparametrically, <code>"edf"</code>, or in parametric way, e.g. <code>"norm"</code>. See <code><a href="#topic+estimate.copula">estimate.copula</a></code> for a detailed explanation.
</p>
</td></tr>
<tr><td><code id="emp.copula_+3A_na.rm">na.rm</code></td>
<td>

<p>boolean. If <code>na.rm = TRUE</code>, missing values, <code>NA</code>, contained in <code>x</code> and <code>u</code> are removed.
</p>
</td></tr>
<tr><td><code id="emp.copula_+3A_...">...</code></td>
<td>

<p>arguments to be passed to <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated copula follows the formula </p>
<p style="text-align: center;"><code class="reqn">\widehat{C} \left(u_{1}, \dots, u_{d} \right) = n^{-1} \sum_{i=1}^{n} \prod_{j=1}^{d} \mathbf{I} \left\{ \widehat{F}_{j} \left( X_{ij} \right) \leq u_{j} \right\},</code>
</p>
<p> where <code class="reqn">\widehat{F}_{j}</code> denotes the empirical marginal distribution function of variable <code class="reqn">X_{j}</code>.
</p>


<h3>Value</h3>

<p>A vector containing the values of the empirical copula.
</p>


<h3>References</h3>

<p>Okhrin, O. and Ristig, A. 2014, Hierarchical Archimedean Copulae: The <code style="white-space: pre;">&#8288;HAC&#8288;</code> Package&quot;, <em>Journal of Statistical Software</em>, 58(4), 1-20, <a href="https://doi.org/10.18637/jss.v058.i04">doi:10.18637/jss.v058.i04</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pHAC">pHAC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = seq(-4, 4, 0.05)
X = cbind(matrix(pt(v, 1), 161, 1), matrix(pnorm(v), 161, 1))

# both methods lead to the same result 
z = emp.copula.self(X, proc = "M") 
which(((emp.copula.self(X[1:100, ], proc = "M") - emp.copula.self(X[1:100, ],
proc = "A")) == 0) == "FALSE")
# integer(0)

# the contour plot
out = outer(z, z)
contour(x = X[,1], y = X[,2], out, main = "Contour Plot", 
xlab = "Cauchy Margin", ylab = "Standard Normal Margin", 
labcex = 1, lwd = 1.5, nlevels = 15)
</code></pre>

<hr>
<h2 id='estimate.copula'>Estimation of Hierarchical Archimedean Copulae
</h2><span id='topic+estimate.copula'></span>

<h3>Description</h3>

<p>The function estimates the parameters and determines the structure of Hierarchical Archimedean Copulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.copula(X, type = 1, method = 1, hac = NULL, epsilon = 0, 
agg.method = "mean", margins = NULL, na.rm = FALSE, max.min = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.copula_+3A_x">X</code></td>
<td>

<p>a <code class="reqn">n \times d</code> matrix. If there are no <code>colnames</code> provided, the names <code>X1, X2, ...</code> will be given.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_type">type</code></td>
<td>

<p>defines the copula family, see <code><a href="#topic+phi">phi</a></code> for an overview of implemented families.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_method">method</code></td>
<td>

<p>the estimation method. Select between quasi Maximum Likelihood <code>1</code>, full Maximum Likelihood <code>2</code>, recursive Maximum Likelihood <code>3</code> and penalized Maximum Likelihood <code>4</code>.
</p>
</td></tr>  
<tr><td><code id="estimate.copula_+3A_hac">hac</code></td>
<td>

<p>a <code><a href="#topic+hac">hac</a></code> object, which determines the structure and provides initial values. An object must be provided, if <code>method = 2</code> referring to the full Maximum Likelihood procedure.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_epsilon">epsilon</code></td>
<td>

<p>scalar <code class="reqn">\geq 0</code>. The variables of consecutive nodes are aggregated, if the difference of the dependency parameters is smaller than <code>epsilon</code>. For a detailed explanation see also <code><a href="#topic+aggregate.hac">aggregate.hac</a></code>.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_agg.method">agg.method</code></td>
<td>

<p>if <code class="reqn">\epsilon &gt; 0</code>, the new dependency parameter can be determined by <code>"mean"</code>, <code>"min"</code> or <code>"max"</code> of the two parameters, see <code><a href="#topic+aggregate.hac">aggregate.hac</a></code>.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_margins">margins</code></td>
<td>

<p>specifies the margins. The data matrix is assumed to contain the values of the marginal distributions by default, i.e. <code>margins = NULL</code>. If raw data are used, the margins can be determined nonparametrically, <code>"edf"</code>, or in a parametric way, e.g. <code>"norm"</code>. Following the latter approach, the parameters of the distributions are estimated by Maximum Likelihood. Building on these estimates the values of the univariate margins are computed. If the argument is defined as scalar, all margins are computed according to this specification. Otherwise, different margins can be defined, e.g. <code>c("norm", "t", "edf")</code> for a 3-dimensional sample. Almost all continuous functions of <code><a href="stats.html#topic+Distributions">Distributions</a></code> are available. Inappropriate usage of this argument might lead to misspecified margins, e.g. application of <code>"exp"</code> even though the sample contains negative values.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_na.rm">na.rm</code></td>
<td>

<p>boolean. If <code>na.rm = TRUE</code>, missing values, <code>NA</code>, contained in <code>X</code> are removed.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_max.min">max.min</code></td>
<td>

<p>boolean. If <code>max.min = TRUE</code> and an element of <code>X</code> is <code class="reqn">\geq 1</code> or <code class="reqn">\leq 0</code>, it is set to <code class="reqn">1-10^{-8}</code> and <code class="reqn">10^{-8}</code> respectively.
</p>
</td></tr>
<tr><td><code id="estimate.copula_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods, e.g. <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <span class="env">hac</span> object is returned.
</p>


<h3>References</h3>

<p>Genest, C., Ghoudi, K., and Rivest, L. P. 1995, A Semiparametric Estimation Procedure of Dependence Parameters in Multivariate Families of Distributions, <em>Biometrika</em> 82, 543-552.
</p>
<p>Gorecki, J., Hofert, M. and Holena, M. 2014, On the Consistency of an Estimator for Hierarchical Archimedean Copulas, In Talaysova, J., Stoklasa, J., Talaysek, T. (Eds.) <em>32nd International Conference on Mathematical Methods in Economics, Olomouc: Palacky University</em>, 239-244.
</p>
<p>Joe, H. 2005, Asymptotic Efficiency of the Two-Stage Estimation Method for Copula-Based Models, <em>Journal of Multivariate Analysis</em> 94(2), 401-419.
</p>
<p>Okhrin, O., Okhrin, Y. and Schmid, W. 2013, On the Structure and Estimation of Hierarchical Archimedean Copulas, <em>Journal of Econometrics</em> 173, 189-204.
</p>
<p>Okhrin, O. and Ristig, A. 2014, Hierarchical Archimedean Copulae: The <code style="white-space: pre;">&#8288;HAC&#8288;</code> Package&quot;, <em>Journal of Statistical Software</em>, 58(4), 1-20, <a href="https://doi.org/10.18637/jss.v058.i04">doi:10.18637/jss.v058.i04</a>.
</p>
<p>Okhrin, O., Ristig, A., Sheen J. and Trueck, S. 2015, Conditional Systemic Risk with Penalized Copula, <em>SFB 649 Discussion Paper 2015-038, Sonderforschungsbereich 649, Humboldt University, Germany</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define the copula model
tree = list(list("X1", "X5", 3), list("X2", "X3", "X4", 4), 2)
model = hac(type = 1, tree = tree)

# sample from copula model
x = rHAC(100, model)

# in the following case the true model is binary approximated
est.obj = estimate.copula(x, type = 1, method = 1, epsilon = 0)
plot(est.obj)

# consider also the aggregation of the variables
est.obj = estimate.copula(x, type = 1, method = 1, epsilon = 0.2)
plot(est.obj)

# full ML estimation to yield more precise parameter
est.obj.full = estimate.copula(x, type = 1, method = 2, hac = est.obj)

# recursive ML estimation leads to almost identical results
est.obj.r = estimate.copula(x, type = 1, method = 3)
</code></pre>

<hr>
<h2 id='finData'>Financial data</h2><span id='topic+finData'></span>

<h3>Description</h3>

<p>This data set contains the standardized residuals of the filtered daily log-returns of four oil corporations: Chevron Corporation (<code>CVX</code>), Exxon Mobil Corporation (<code>XOM</code>), Royal Dutch Shell (<code>RDSA</code>) and Total (<code>FP</code>), covering <code class="reqn">n = 283</code> observations from 2011-02-02 to 2012-03-19. Intertemporal dependence is removed by usual ARMA-GARCH models, whose standardized residuals are used as <code>finData</code>.
</p>


<h3>Format</h3>

<p>A matrix containing 283 observations of 4 stocks. The tickers of the stocks are presented as <code>colnames</code>.
</p>


<h3>Source</h3>

<p>Yahoo! Finance</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the data
data(finData)
</code></pre>

<hr>
<h2 id='get.params'>Dependency parameters of a HAC
</h2><span id='topic+get.params'></span>

<h3>Description</h3>

<p>This function returns the copula parameter(s). They are ordered from top to down and left to right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.params(hac, sort.v = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.params_+3A_hac">hac</code></td>
<td>

<p>an object of the class <span class="env">hac</span>.
</p>
</td></tr>
<tr><td><code id="get.params_+3A_sort.v">sort.v</code></td>
<td>

<p>boolean. If <code>sort.v = TRUE</code>, the output is sorted.
</p>
</td></tr>
<tr><td><code id="get.params_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code><a href="base.html#topic+sort">sort</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tree2str">tree2str</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a copula model
tree = list(list("X1", "X5", "X2", 4), list("X3", "X4", "X6", 3), 2)
model = hac(type = 1, tree)

# return the parameter
get.params(model) # [1] 2 4 3
get.params(model, sort.v = TRUE, decreasing = TRUE) # [1] 4 3 2
</code></pre>

<hr>
<h2 id='hac'>Construction of <span class="env">hac</span> objects
</h2><span id='topic+hac'></span><span id='topic+hac.full'></span><span id='topic+print.hac'></span><span id='topic+hac2nacopula'></span><span id='topic+nacopula2hac'></span>

<h3>Description</h3>

<p><span class="env">hac</span> objects are required as input argument for several functions, e.g. <code><a href="#topic+plot.hac">plot.hac</a></code> and <code><a href="#topic+rHAC">rHAC</a></code>. They can be constructed by <code>hac</code> and <code>hac.full</code>. The latter function produces only fully nested Archimedean copulae, whereas <code>hac</code> can construct arbitrary dependence structures for a given family. Moreover, the functions <code>hac2nacopula</code> and <code>nacopula2hac</code> ensure the compatability with the <span class="env">copula</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hac(type, tree)
hac.full(type, y, theta)
## S3 method for class 'hac'
print(x, digits = 2, ...)
hac2nacopula(x)
nacopula2hac(outer_nacopula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hac_+3A_y">y</code></td>
<td>

<p>a vector containing the variables, which are denoted by a <code><a href="base.html#topic+character">character</a></code>, e.g. <code>"X1"</code>.
</p>
</td></tr>
<tr><td><code id="hac_+3A_theta">theta</code></td>
<td>

<p>a vector containing the HAC parameters, which should be ordered from top to down. The length of <code>theta</code> must be equal to <code>length(y) - 1</code>.
</p>
</td></tr>
<tr><td><code id="hac_+3A_tree">tree</code></td>
<td>

<p>a <code><a href="base.html#topic+list">list</a></code> object of the general structure <code>list(..., numeric(1))</code>. The last argument of the list, <code>numeric(1)</code>, denotes the dependency parameter. The arguments <code>...</code> are either of the same structure or of the class <code><a href="base.html#topic+character">character</a></code>. The character objects denote variables and embedded lists refer to nested subcopulae.
</p>
</td></tr>
<tr><td><code id="hac_+3A_type">type</code></td>
<td>

<p>all copula-types are admissible, see <code><a href="#topic+phi">phi</a></code> for an overview of implemented families.
</p>
</td></tr>
<tr><td><code id="hac_+3A_x">x</code></td>
<td>

<p>a <span class="env">hac</span> object.
</p>
</td></tr>
<tr><td><code id="hac_+3A_outer_nacopula">outer_nacopula</code></td>
<td>

<p>an <code>nacopula</code> object. The variables of the <code>outer_nacopula</code> object <code>1, 2, ...</code> are translated into the <code><a href="base.html#topic+character">character</a></code>s <code>"X1", "X2", ...</code>.
</p>
</td></tr>
<tr><td><code id="hac_+3A_digits">digits</code></td>
<td>

<p>specifies the digits, see <code><a href="#topic+tree2str">tree2str</a></code>.
</p>
</td></tr>
<tr><td><code id="hac_+3A_...">...</code></td>
<td>

<p>arguments to be passed to <code><a href="base.html#topic+cat">cat</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <span class="env">hac</span> object is returned.
</p>
<table role = "presentation">
<tr><td><code>type</code></td>
<td>
<p>the specified copula type.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>the structure of the HAC.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hofert, M. and Maechler, M. 2011, Nested Archimedean Copulas Meet R: The <code style="white-space: pre;">&#8288;nacopula&#8288;</code> Package, <em>Journal of Statistical Software</em>, 39(9), 1-20, <a href="https://doi.org/10.18637/jss.v039.i09">doi:10.18637/jss.v039.i09</a>.
</p>
<p>Hofert, M., Kojadinovic, I., Maechler, M. and Yan, J. 2015, <code style="white-space: pre;">&#8288;copula&#8288;</code>: Multivariate Dependence with Copulas, <em>R package version 0.999-14</em>, <a href="https://CRAN.R-project.org/package=copula">https://CRAN.R-project.org/package=copula</a>.
</p>
<p>Kojadinovic, I., Yan, J. 2010, Modeling Multivariate Distributions with Continuous Margins Using the <code style="white-space: pre;">&#8288;copula&#8288;</code> R Package, <em>Journal of Statistical Software</em>, 34(9), 1-20. <a href="https://doi.org/10.18637/jss.v034.i09">doi:10.18637/jss.v034.i09</a>.
</p>
<p>Okhrin, O. and Ristig, A. 2014, Hierarchical Archimedean Copulae: The <code style="white-space: pre;">&#8288;HAC&#8288;</code> Package&quot;, <em>Journal of Statistical Software</em>, 58(4), 1-20, <a href="https://doi.org/10.18637/jss.v058.i04">doi:10.18637/jss.v058.i04</a>.
</p>
<p>Yan, J. 2007, Enjoy the Joy of Copulas: With a Package <code style="white-space: pre;">&#8288;copula&#8288;</code>, <em>Journal of Statistical Software</em>, 21(4), 1-21, <a href="https://doi.org/10.18637/jss.v021.i04">doi:10.18637/jss.v021.i04</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># it might be helpful to plot the hac objects
# Example 1: 4-dim AC
tree = list("X1", "X2", "X3", "X4", 2)
AC = hac(type = 1, tree = tree)

# Example 2: 4-dim HAC
y = c("X1", "X4", "X3", "X2")
theta = c(2, 3, 4)

HAC1 = hac.full(type = 1, y = y, theta = theta)
HAC2 = hac(type = 1, tree = list(list(list("X2", "X3", 4), 
"X4", 3), "X1", 2))
tree2str(HAC1) == tree2str(HAC2) # [1] TRUE

# Example 3: 9-dim HAC

HAC = hac(type = 1, tree = list("X6", "X5", list("X2", "X4", "X3", 4.4),
list("X1", "X7", 3.3), list("X8", "X9", 4), 2.3))
plot(HAC)
</code></pre>

<hr>
<h2 id='par.pairs'>Parameter of the HAC
</h2><span id='topic+par.pairs'></span>

<h3>Description</h3>

<p>This function returns a matrix of HAC parameters. They are pairwise ordered, so that the parameters correspond to the lowest node, at which the variables are joined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.pairs(hac, FUN = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par.pairs_+3A_hac">hac</code></td>
<td>

<p>an object of the class <span class="env">hac</span>.
</p>
</td></tr>
<tr><td><code id="par.pairs_+3A_fun">FUN</code></td>
<td>

<p>the parameters of the HAC are returned by default. If <code>FUN = "TAU"</code>, <code><a href="#topic+theta2tau">theta2tau</a></code> is applied to the parameters. <code>FUN</code> can also be a self-defined <code><a href="base.html#topic+function">function</a></code>.
</p>
</td></tr>
<tr><td><code id="par.pairs_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get.params">get.params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a copula model
tree = list(list("X1", "X5", "X2", 4), list("X3", "X4", "X6", 3), 2)
model = hac(type = 1, tree)

# returns the pairwise parameter
par.pairs(model)

# Kendall's TAU
par.pairs(model, FUN = "TAU")

# sqrt of the parameter
par.pairs(model, function(r)sqrt(r))
</code></pre>

<hr>
<h2 id='phi+2C+20phi.inv'>Generator function
</h2><span id='topic+phi'></span><span id='topic+phi.inv'></span>

<h3>Description</h3>

<p>The Archimedean generator function and its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(x, theta, type)
phi.inv(x, theta, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phi+2B2C+2B20phi.inv_+3A_x">x</code></td>
<td>

<p>a scalar, vector or matrix at which the function is evaluated. The support of the functions has to be taken into account, i.e. <code class="reqn">x \in [0, \infty]</code> for the generator function and <code class="reqn">x \in [0, 1]</code> for its inverse.
</p>
</td></tr>
<tr><td><code id="phi+2B2C+2B20phi.inv_+3A_theta">theta</code></td>
<td>

<p>the feasible copula parameter, i.e. <code class="reqn">\theta \in [1, \infty)</code> for the Gumbel and Joe family, <code class="reqn">\theta \in (0, \infty)</code> for the Clayton and Frank family and <code class="reqn">\theta \in [0, 1)</code> for the Ali-Mikhail-Haq family.
</p>
</td></tr>
<tr><td><code id="phi+2B2C+2B20phi.inv_+3A_type">type</code></td>
<td>

<p>select between the following integer numbers for specifying the <code>type</code> of the hierarchical Archimedean copula (HAC) or Archimedean copula (AC):
</p>

<ul>
<li> <p><code> 1</code> = HAC Gumbel
</p>
</li>
<li> <p><code> 2</code> = AC Gumbel
</p>
</li>
<li> <p><code> 3</code> = HAC Clayton
</p>
</li>
<li> <p><code> 4</code> = AC Clayton
</p>
</li>
<li> <p><code> 5</code> = HAC Frank
</p>
</li>
<li> <p><code> 6</code> = AC Frank
</p>
</li>
<li> <p><code> 7</code> = HAC Joe
</p>
</li>
<li> <p><code> 8</code> = AC Joe
</p>
</li>
<li> <p><code> 9</code> = HAC Ali-Mikhail-Haq
</p>
</li>
<li> <p><code>10</code> = AC Ali-Mikhail-Haq
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = runif(100, min = 0, max = 100)
phi(x, theta = 1.2, type = 1)

# do not run
# phi(x, theta = 0.8, type = 1) 
# In phi(x, theta = 0.8, type = 1) : theta &gt;= 1 is required.
</code></pre>

<hr>
<h2 id='plot.hac'>Plot of a HAC
</h2><span id='topic+plot.hac'></span>

<h3>Description</h3>

<p>The function plots the structure of Hierarchical Archimedean Copulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'hac'
plot(x, xlim = NULL, ylim = NULL, xlab = "", ylab = "", 
col = "black", fg = "black", bg = "white", col.t = "black", lwd = 2, 
index = FALSE, numbering = FALSE, theta = TRUE, h = 0.4, l = 1.2, 
circles = 0.25, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hac_+3A_x">x</code></td>
<td>

<p>a <span class="env">hac</span> object. It can be constructed by <code><a href="#topic+hac">hac</a></code> or be the result of <code><a href="#topic+estimate.copula">estimate.copula</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_xlim">xlim</code>, <code id="plot.hac_+3A_ylim">ylim</code></td>
<td>

<p>numeric vectors of length 2, giving the limits of the x and y axes. The default values adjust the size of the coordinate plane automatically with respect to the dimension of the HAC.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_xlab">xlab</code>, <code id="plot.hac_+3A_ylab">ylab</code></td>
<td>

<p>titles for the x and y axes.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_col">col</code></td>
<td>

<p>defines the color of the lines, which connect the circles and rectangles.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_fg">fg</code></td>
<td>

<p>defines the color of the lines of the rectangles and circles equivalent to the color settings in <span class="env">R</span>.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_bg">bg</code></td>
<td>

<p>defines the background color of the rectangles and circles equivalent to the color settings in <span class="env">R</span>.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_col.t">col.t</code></td>
<td>

<p>defines the text color equivalent to the color settings in <span class="env">R</span>.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_lwd">lwd</code></td>
<td>

<p>the width of the lines.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_index">index</code></td>
<td>

<p>boolean. If <code>index = TRUE</code>, strings, which illustrate the subcopulae of the nodes, are used as subsrcipts of the dependency parameters.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_numbering">numbering</code></td>
<td>

<p>boolean. If <code>index = TRUE</code> and <code>numbering = TRUE</code>, the dependency parameters are numbered. If <code>x</code> is returned by <code>estimate.copula</code>, the numbers correpsond to the estimation stages. 
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_theta">theta</code></td>
<td>

<p>boolean. Determines, whether the dependency parameter <code class="reqn">\theta</code> or Kendall's rank correlation coefficient <code class="reqn">\tau</code> is printed. 
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_h">h</code></td>
<td>

<p>the height of the rectangles.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_l">l</code></td>
<td>

<p>the width of the rectangles.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_circles">circles</code></td>
<td>

<p>a positive number giving the radius of the circles.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_digits">digits</code></td>
<td>

<p>an integer specifying the number of digits of the dependence parameter.
</p>
</td></tr>
<tr><td><code id="plot.hac_+3A_...">...</code></td>
<td>

<p>arguments to be passed to methods, e.g. graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Okhrin, O. and Ristig, A. 2014, Hierarchical Archimedean Copulae: The <code style="white-space: pre;">&#8288;HAC&#8288;</code> Package&quot;, <em>Journal of Statistical Software</em>, 58(4), 1-20, <a href="https://doi.org/10.18637/jss.v058.i04">doi:10.18637/jss.v058.i04</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate.copula">estimate.copula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a hac object is created

tree = list(list("X1", "X5", 3), list("X2", "X3", "X4", 4), 2)
model = hac(type = 1, tree = tree)
plot(model)

# the same procedure works for an estimated object

sample = rHAC(2000, model)
est.obj = estimate.copula(sample, epsilon = 0.2)
plot(est.obj)
</code></pre>

<hr>
<h2 id='theta2tau+2C+20tau2theta'>Kendall's rank correlation coefficient
</h2><span id='topic+theta2tau'></span><span id='topic+tau2theta'></span>

<h3>Description</h3>

<p>Kendall's rank correlation coefficient and its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2tau(theta, type)
tau2theta(tau, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta2tau+2B2C+2B20tau2theta_+3A_theta">theta</code></td>
<td>
<p>the dependency parameter. It can be either a scalar, a vector or a matrix and has to lie within a certain interval, i.e. <code class="reqn">\theta \in [1, \infty)</code> for the Gumbel and Joe family, <code class="reqn">\theta \in (0, \infty)</code> for the Clayton and Frank family and <code class="reqn">\theta \in [0, 1)</code> for the Ali-Mikhail-Haq family.
</p>
</td></tr>
<tr><td><code id="theta2tau+2B2C+2B20tau2theta_+3A_tau">tau</code></td>
<td>
<p>Kendall's rank correlation coefficient. It can be either a scalar, a vector or a matrix and it is to ensure, that <code class="reqn">\tau \in [0,1)</code>.
</p>
</td></tr>
<tr><td><code id="theta2tau+2B2C+2B20tau2theta_+3A_type">type</code></td>
<td>
<p>all types are available, see <code><a href="#topic+phi">phi</a></code> for an overview of implemented families.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># computation of the dependency parameter
x = runif(10)
theta = tau2theta(x, type = 1)

# computation of kendall's tau
y = runif(10, 1, 100)
tau = theta2tau(y, type = 1)
</code></pre>

<hr>
<h2 id='to.logLik'>log-likelihood
</h2><span id='topic+to.logLik'></span>

<h3>Description</h3>

<p><code>to.logLik</code> returns either the log-likehood function depending on a vector <code>theta</code> for a given sample <code>X</code> or the value of the log-likelihood, if <code>eval = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.logLik(X, hac, eval = FALSE, margins = NULL, sum.log = TRUE, 
na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to.logLik_+3A_x">X</code></td>
<td>

<p>a data matrix. The number of columns and the corresponding names have to coincide with the specifications of the copula model <code>hac</code>. The sample <code>X</code> has to contain at least <code class="reqn">2</code> rows (observations), as the values of the underlying density cannot be computed otherwise.
</p>
</td></tr> 
<tr><td><code id="to.logLik_+3A_hac">hac</code></td>
<td>

<p>an object of the class <code><a href="#topic+hac">hac</a></code>.
</p>
</td></tr>
<tr><td><code id="to.logLik_+3A_eval">eval</code></td>
<td>

<p>boolean. If <code>eval = FALSE</code>, the non-evaluated log-likelihood function depending on a parameter vector <code>theta</code> is returned and one default argument, the <code>density</code>, is returned. The values of <code>theta</code> are increasingly ordered.
</p>
</td></tr>
<tr><td><code id="to.logLik_+3A_margins">margins</code></td>
<td>

<p>specifies the margins. The data matrix <code>X</code> is assumed to contain the values of the marginal distributions by default, i.e. <code>margins = NULL</code>. If raw data are used, the margins can be determined nonparametrically, <code>"edf"</code>, or in parametric way, e.g. <code>"norm"</code>. See <code><a href="#topic+estimate.copula">estimate.copula</a></code> for a detailed explanation.
</p>
</td></tr>
<tr><td><code id="to.logLik_+3A_sum.log">sum.log</code></td>
<td>

<p>boolean. If <code>sum.log = FALSE</code>, the values of the individual log-likelihood contributions are returned.
</p>
</td></tr>
<tr><td><code id="to.logLik_+3A_na.rm">na.rm</code></td>
<td>

<p>boolean. If <code>na.rm = TRUE</code>, missing values, <code>NA</code>, contained in <code>X</code> are removed.
</p>
</td></tr>
<tr><td><code id="to.logLik_+3A_...">...</code></td>
<td>

<p>arguments to be passed to <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dHAC">dHAC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a hac-model
tree = list(list("X1", "X5", 3), list("X2", "X3", "X4", 4), 2)
model = hac(type = 1, tree = tree)

# sample from copula model
sample = rHAC(1000, model)

# check the accurancy of the estimation procedure
ll = to.logLik(sample, model)
ll.value = to.logLik(sample, model, eval = TRUE)

ll(c(2, 3, 4)) == ll.value # [1] TRUE
</code></pre>

<hr>
<h2 id='tree2str'>String structure of HAC
</h2><span id='topic+tree2str'></span>

<h3>Description</h3>

<p>The function prints the structure of HAC as string, so that the important characteristics of the copula can be identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree2str(hac, theta = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree2str_+3A_hac">hac</code></td>
<td>

<p>an object of the class <span class="env">hac</span>.
</p>
</td></tr>
<tr><td><code id="tree2str_+3A_theta">theta</code></td>
<td>

<p>boolean. Determines, whether the values of the dependency parameter(s) are printed (<code>TRUE</code>) or not (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="tree2str_+3A_digits">digits</code></td>
<td>

<p>a non-negative integer value specifying the number of digits of the dependency parameter(s).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string of the class <code><a href="base.html#topic+character">character</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.hac">plot.hac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a hac object
tree = list(list("X1", "X5", "X2", 3), list("X3", "X4", "X6", 4), 2)
model = hac(type = 1, tree = tree)

# the parameters are returned within the curly brackets
# variables nested at the same node are separated by a dot

tree2str(model) # [1] "((X1.X5.X2)_{3}.(X3.X4.X6)_{4})_{2}"

# (X1.X5.X2)_{3} and (X3.X4.X6)_{4} are the two variables nested at the
# initial node with dependency parameter 2

tree2str(model, theta = FALSE) # [1] "((X1.X5.X2).(X3.X4.X6))"

# if theta = FALSE, only the structure of the variables is returned

# alternatively consider the following nested AC

tree = list("X1", list("X5", "X2", 3), list("X3", "X4", "X6", 4), 1.01)
model = hac(type = 1, tree = tree)

tree2str(model) # [1] "(X1.(X5.X2)_{3}.(X3.X4.X6)_{4})_{1.01}"

# _{1.01} represents the initial node
# the first three variables are given by the subtrees (X3.X4.X6)_{4},
# (X5.X2)_{3} and X1
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
