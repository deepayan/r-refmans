<!DOCTYPE html><html><head><title>Help for package VoxR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VoxR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#axis_angle'><p>Computes points angle with an axis (X, Y or Z) and the origin of the 3D cartesian coordinates system.</p></a></li>
<li><a href='#axis_distance'><p>Computes points distance to an axis of the cartesian coordinates system.</p></a></li>
<li><a href='#axis.angle'><p>Deprecated function</p></a></li>
<li><a href='#axis.distance'><p>Deprecated function</p></a></li>
<li><a href='#box_counting'><p>Computes fractal dimension using the box counting method.</p></a></li>
<li><a href='#ck_conv_dat'><p>Check point cloud suitability.</p></a></li>
<li><a href='#ck_conv_vox'><p>Check voxel cloud suitability</p></a></li>
<li><a href='#distance_clustering'><p>Clustering of non connected objects in a point cloud.</p></a></li>
<li><a href='#filled_voxel_cloud'><p>Produces a filled voxel cloud.</p></a></li>
<li><a href='#filter_noise'><p>Statistical filtering of a point cloud.</p></a></li>
<li><a href='#filter_point_density'><p>Retains one point of the original point cloud within a voxel of given size.</p></a></li>
<li><a href='#guess_resolution'><p>Guess the voxel resolution in a voxel cloud</p></a></li>
<li><a href='#level'><p>Deprecated function</p></a></li>
<li><a href='#obj.rec'><p>Deprecated function</p></a></li>
<li><a href='#plot_projection'><p>Visualization of a projected voxel cloud.</p></a></li>
<li><a href='#plot_voxels'><p>Voxel cloud visualization.</p></a></li>
<li><a href='#plot_voxels_full_grid'><p>Voxel cloud visualization when voxel cloud includes the empty voxels.</p></a></li>
<li><a href='#point_distance'><p>Computes the distance of a set of points to a user defined point.</p></a></li>
<li><a href='#point.distance'><p>Deprecated function</p></a></li>
<li><a href='#project'><p>Deprecated function</p></a></li>
<li><a href='#project_voxels'><p>Project a voxel cloud in a 2D plan formed by two axes of the cartesian coordiantes system.</p></a></li>
<li><a href='#raster.proj'><p>Deprecated function</p></a></li>
<li><a href='#sub.obj'><p>Deprecated function</p></a></li>
<li><a href='#substract_point_clouds'><p>Point clouds substraction: identification of changes between two measuring times.</p></a></li>
<li><a href='#surface'><p>Deprecated function</p></a></li>
<li><a href='#tree_metrics'><p>Estimates a set of morphological parameters from a tls point cloud of a tree.</p></a></li>
<li><a href='#vox'><p>Voxelisation of 3D point cloud recording the number of points within each voxels.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Trees Geometry and Morphology from Unstructured TLS Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for 3D point cloud voxelisation, projection, geometrical and morphological description of trees (DBH, height, volume, crown diameter), analyses of temporal changes between different measurement times, distance based clustering and visualisation of 3D voxel clouds and 2D projection. Most analyses and algorithms provided in the package are based on the concept of space exploration and are described in Lecigne et al. (2018, &lt;<a href="https://doi.org/10.1093%2Faob%2Fmcx095">doi:10.1093/aob/mcx095</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, FNN, Rfast, circular, dplyr, fastcluster,
geometry, raster, rgl, grDevices</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Blecigne/VoxR">https://github.com/Blecigne/VoxR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Blecigne/VoxR/issues">https://github.com/Blecigne/VoxR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-28 22:27:39 UTC; bastienlecigne</td>
</tr>
<tr>
<td>Author:</td>
<td>Bastien Lecigne <a href="https://orcid.org/0000-0002-1496-202X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bastien Lecigne &lt;lecignebastien@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-30 08:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='axis_angle'>Computes points angle with an axis (X, Y or Z) and the origin of the 3D cartesian coordinates system.</h2><span id='topic+axis_angle'></span>

<h3>Description</h3>

<p>Computes points angle with an axis (X, Y or Z) and the origin of the 3D cartesian coordinates system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_angle(data, axis, project, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_angle_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud or voxel cloud.</p>
</td></tr>
<tr><td><code id="axis_angle_+3A_axis">axis</code></td>
<td>
<p>charecter. Specifying the reference axis to compute the angles: &quot;X&quot;, &quot;Y&quot; or &quot;Z&quot;.</p>
</td></tr>
<tr><td><code id="axis_angle_+3A_project">project</code></td>
<td>
<p>character. If specifyed the point cloud is projected into a 2D plan before computing the angles.
Can be &quot;xy&quot;, &quot;yz&quot; or &quot;xz&quot;. Default is without projection.</p>
</td></tr>
<tr><td><code id="axis_angle_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.
</p>
<p>@references Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the angle values of the points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- compute angle with the Z axis
tls[,angle_z:=VoxR::axis_angle(tls,axis = "Z")]

#- compute angle with the X axis with projection in the xy plan
tls[,angle_x:=VoxR::axis_angle(tls,axis = "X",project = "xy")]

#- round angle values for visualization
tls[,angle_z:=round(angle_z)]
tls[,angle_x:=round(angle_x)]

#- plot the angle with Z axis
cols=rev(rainbow(max(tls$angle_z)+1,end=4/6)) # color scale
rgl::open3d()
rgl::plot3d(tls,col=cols[tls$angle_z+1],add=TRUE)

#- plot the angle with X axis
cols=rev(rainbow(max(tls$angle_x)+1,end=4/6)) # color scale
rgl::open3d()
rgl::plot3d(tls,col=cols[tls$angle_x+1],add=TRUE)
</code></pre>

<hr>
<h2 id='axis_distance'>Computes points distance to an axis of the cartesian coordinates system.</h2><span id='topic+axis_distance'></span>

<h3>Description</h3>

<p>Computes points distance to an axis of the cartesian coordinates system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_distance(data, axis, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_distance_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud or voxel cloud.</p>
</td></tr>
<tr><td><code id="axis_distance_+3A_axis">axis</code></td>
<td>
<p>charecter. Specifying the reference axis to compute the distance: &quot;X&quot;, &quot;Y&quot; or &quot;Z&quot;.</p>
</td></tr>
<tr><td><code id="axis_distance_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the distance values of the points
</p>


<h3>References</h3>

<p>Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- compute distance to the Z axis
tls[,dist:=VoxR::axis_distance(tls,"Z")]

#- round distance values for visualization
tls[,dist:=round(dist*100)]

#- plot the distance to the Z axis
cols=rev(rainbow(max(tls$dist)+1,end=4/6)) # color scale
rgl::open3d()
rgl::plot3d(tls,col=cols[tls$dist+1],add=TRUE)
</code></pre>

<hr>
<h2 id='axis.angle'>Deprecated function</h2><span id='topic+axis.angle'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis.angle(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis.angle_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='axis.distance'>Deprecated function</h2><span id='topic+axis.distance'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis.distance(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis.distance_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='box_counting'>Computes fractal dimension using the box counting method.</h2><span id='topic+box_counting'></span>

<h3>Description</h3>

<p>Computes fractal dimension using the box counting method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_counting(data, min_vox_size, store_fit, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_counting_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud.</p>
</td></tr>
<tr><td><code id="box_counting_+3A_min_vox_size">min_vox_size</code></td>
<td>
<p>numeric. The minimum size of a voxel. Default = 0.01.</p>
</td></tr>
<tr><td><code id="box_counting_+3A_store_fit">store_fit</code></td>
<td>
<p>logical. If TRUE, the parameters linear model's fit are returned. Default = FALSE.</p>
</td></tr>
<tr><td><code id="box_counting_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>store_fit = FALSE</code> only the fractal dimension is returned. If <code>store_fit = TRUE</code>
the parameters of the linear model used to estimate the fractal dimension and
a table containing the number of boxes (i.e. voxels) at any resolution are
returned in a list in addition to the fractal dimension.
</p>


<h3>References</h3>

<p>Seidel, D. (2018). A holistic approach to determine tree structural complexity based on laser
scanning data and fractal analysis. Ecology and evolution, 8(1), 128-134.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- box counting
FD = VoxR::box_counting(tls,store_fit = TRUE)

#- fractal dimension
FD$fractal_dim
#- linear model fit
FD$fit_summary
#- plot fit
plot(log(FD$fit_table$N)~log(1/FD$fit_table$res))
abline(FD$fit_summary)
</code></pre>

<hr>
<h2 id='ck_conv_dat'>Check point cloud suitability.</h2><span id='topic+ck_conv_dat'></span>

<h3>Description</h3>

<p>Check point cloud suitability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_conv_dat(data, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_conv_dat_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data converted to data.table and a logical value indicating if the input data was a base R data.frame or a data.table.
</p>

<hr>
<h2 id='ck_conv_vox'>Check voxel cloud suitability</h2><span id='topic+ck_conv_vox'></span>

<h3>Description</h3>

<p>Check voxel cloud suitability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck_conv_vox(data, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_conv_vox_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table.</p>
</td></tr>
<tr><td><code id="ck_conv_vox_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data converted to data.table and a logical value indicating if the input data was a base R data.frame or a data.table.
</p>

<hr>
<h2 id='distance_clustering'>Clustering of non connected objects in a point cloud.</h2><span id='topic+distance_clustering'></span>

<h3>Description</h3>

<p>Clustering objects with non common points: two points located within a user defined distance from each other are considered
as the parts of a unique object. This function is well suited to be applied to the outputs of the
<a href="#topic+substract_point_clouds">substract_point_clouds</a> function.
</p>
<p>Clustering objects with non common points: two points located within a user defined distance from each other are considered
as the parts of a unique object. This function is well suited to be applied to the outputs of the
<a href="#topic+substract_point_clouds">substract_point_clouds</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_clustering(data, d_clust, method, C_size, message)

distance_clustering(data, d_clust, method, C_size, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_clustering_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud or voxel cloud.</p>
</td></tr>
<tr><td><code id="distance_clustering_+3A_d_clust">d_clust</code></td>
<td>
<p>numeric. The distance required to consider two points as being part of two different clusters. Default = 0.02.</p>
</td></tr>
<tr><td><code id="distance_clustering_+3A_method">method</code></td>
<td>
<p>character. The algorithm to use for clustering. Can be either &quot;D_mat&quot; or &quot;Iter&quot;, see details. Default = &quot;D_mat&quot;.</p>
</td></tr>
<tr><td><code id="distance_clustering_+3A_c_size">C_size</code></td>
<td>
<p>(optional) numeric. If <code>method = "Iter"</code>, sets the maximal size of a cluster (in distance unit).</p>
</td></tr>
<tr><td><code id="distance_clustering_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method == "D_mat"</code> the clustering process is based on building a matrix distance. This is time efficient but use a lot of memory.
If <code>method == "Iter"</code> a slower but memory efficient iterative process is used. In some cases, D_clust can help to speed up the process.
</p>


<h3>Value</h3>

<p>The input data with an additionnal field containing the cluster ID.
</p>
<p>The input data with an additionnal field containing the cluster ID.
</p>


<h3>References</h3>

<p>Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import datasets
t0=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))
t1=data.table::fread(system.file("extdata", "Tree_t1.asc", package="VoxR"))

#- keep only the tree crown
t0 = t0[z&gt;=0,]
t1 = t1[z&gt;=0,]

#- substract t0 to t1 with the hull method
diff = VoxR::substract_point_clouds(t0 = t0,t1 = t1, method = "hull")

#- clustering the difference between t0 and t1
clust = VoxR::distance_clustering(diff,d_clust = 0.03)

#- plot the result (NOTE that colors are redundant)
rgl::open3d()
rgl::plot3d(clust,col=clust$cluster,add=TRUE)
#- import datasets
t0=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))
t1=data.table::fread(system.file("extdata", "Tree_t1.asc", package="VoxR"))

#- keep only the tree crown
t0 = t0[z&gt;=0,]
t1 = t1[z&gt;=0,]

#- substract t0 to t1 with the hull method
diff = VoxR::substract_point_clouds(t0 = t0,t1 = t1, method = "hull")

#- clustering the difference between t0 and t1 with the matrix distance based method
clust = VoxR::distance_clustering(diff,d_clust = 0.03)

#- plot the result (NOTE that colors are redundant)
rgl::open3d()
rgl::plot3d(clust,col=clust$cluster,add=TRUE)

#- clustering the difference between t0 and t1 with the iterative method
clust = VoxR::distance_clustering(diff,d_clust = 0.03,method = "Iter")

#- plot the result (NOTE that colors are redundant)
rgl::open3d()
rgl::plot3d(clust,col=clust$cluster,add=TRUE)

#- clustering the difference between t0 and t1 with the iterative method with maximum object size
clust = VoxR::distance_clustering(diff,d_clust = 0.03,method = "Iter",C_size = 1)

#- plot the result (NOTE that colors are redundant)
rgl::open3d()
rgl::plot3d(clust,col=clust$cluster,add=TRUE)

</code></pre>

<hr>
<h2 id='filled_voxel_cloud'>Produces a filled voxel cloud.</h2><span id='topic+filled_voxel_cloud'></span>

<h3>Description</h3>

<p>This function produces a filled voxel cloud of a tree, i.e. a voxels cloud within which
empty objects (e.g. trunk and large branches) are filled. The algorithm was inspired from
the one described by Vonderach et al. (2012) with some modifications. First, the point cloud is
is voxelized with a given (<code>res</code>) voxel resolution. The voxel cloud is then sliced into one voxel
tick layers. Within a single layer different objects are then clustered based on their
distance to each other (see the <a href="#topic+distance_clustering">distance_clustering</a> function for more details). Each
cluster is then filled by addind voxels along the range of Y for each X value of the cluster and reversly along
the range of X for each Y of the cluster. All unique voxels are then returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filled_voxel_cloud(data, res, d_clust, estimate_volume, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filled_voxel_cloud_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud.</p>
</td></tr>
<tr><td><code id="filled_voxel_cloud_+3A_res">res</code></td>
<td>
<p>numeric. Resolution of a voxel.</p>
</td></tr>
<tr><td><code id="filled_voxel_cloud_+3A_d_clust">d_clust</code></td>
<td>
<p>numeric. The distance to use for clustering, see the <a href="#topic+distance_clustering">distance_clustering</a> for more details.</p>
</td></tr>
<tr><td><code id="filled_voxel_cloud_+3A_estimate_volume">estimate_volume</code></td>
<td>
<p>logical. If TRUE the tree volume is computed as done in Vonderach et al. (2012).</p>
</td></tr>
<tr><td><code id="filled_voxel_cloud_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>estimate_volume = FLASE</code> a data.frame or data.table containing the voxels coordinates is returned. If
<code>estimate_volume = TRUE</code> a list containing the voxels coordinates and the estimated tree volume
is returned.
</p>


<h3>References</h3>

<p>Vonderach, C., Voegtle, T., &amp; Adler, P. (2012). Voxel-based approach for estimating urban tree volume from
terrestrial laser scanning data. International Archives of Photogrammetry, Remote Sensing and Spatial Information Sciences,
39, 451-456.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t1.asc", package="VoxR"))

#- keep the tree trunk
tls=tls[z&lt;=0]

#- run filled voxel voxelisation
filled = VoxR::filled_voxel_cloud(tls,0.02)

#- run usual voxelisation
voxels = VoxR::vox(tls,0.02)

#- compare filled voxel cloud to empty voxel cloud
VoxR::plot_voxels(filled,res = 0.02)
VoxR::plot_voxels(voxels,res = 0.02)

#- compare the volume estimate from Vonderach et al. 2012 to estimate based on voxel volume
#- run filled voxel voxelisation with volume estimation
filled = VoxR::filled_voxel_cloud(tls,0.01,estimate_volume = TRUE)

#- compare volumes
filled$estimated_volume # Vonderach
nrow(filled$filled_voxels)*0.01^3 # voxel based
</code></pre>

<hr>
<h2 id='filter_noise'>Statistical filtering of a point cloud.</h2><span id='topic+filter_noise'></span>

<h3>Description</h3>

<p>Implements the Statistical Outliers Removal (SOR) filter available in
<a href="https://www.cloudcompare.org/doc/wiki/index.php?title=SOR_filter">CloudCompare</a>.
Computes the distance of each point to its <code>k</code> nearest neighbours and considers
a point as noise if it is further than the average distance (for the entire point cloud)
plus <code>sigma</code> times the standard deviation away from other points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_noise(data, k, sigma, store_noise, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_noise_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud.</p>
</td></tr>
<tr><td><code id="filter_noise_+3A_k">k</code></td>
<td>
<p>numeric. The number of nearest neighbours to use. Default = 5.</p>
</td></tr>
<tr><td><code id="filter_noise_+3A_sigma">sigma</code></td>
<td>
<p>numeric. The multiplier of standard deviation to consider a point as noise. Default = 1.5.</p>
</td></tr>
<tr><td><code id="filter_noise_+3A_store_noise">store_noise</code></td>
<td>
<p>logical. Should the noisy points be retained ? Default = FALSE.</p>
</td></tr>
<tr><td><code id="filter_noise_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>store_noise = TRUE</code> the input data is returned with an additional field (&quot;Noise&quot;)
where points that are classified as noise points are labaled with 2 and the points not classified as noise are labeled as 1.
If <code>store_noise = FALSE</code> only the points that were not classified as noise are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- run noise filter
clean=VoxR::filter_noise(tls,store_noise = TRUE)

#- plot the result (noise in red)
rgl::open3d()
rgl::plot3d(clean,col=clean$Noise,add=TRUE)
</code></pre>

<hr>
<h2 id='filter_point_density'>Retains one point of the original point cloud within a voxel of given size.</h2><span id='topic+filter_point_density'></span>

<h3>Description</h3>

<p>Retains one point of the original point cloud within a voxel of given size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_point_density(data, res, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_point_density_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud.</p>
</td></tr>
<tr><td><code id="filter_point_density_+3A_res">res</code></td>
<td>
<p>numeric. The voxel resolution.</p>
</td></tr>
<tr><td><code id="filter_point_density_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame or data.table with reduced point sensity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- keep one point in 2cm voxels
filtered=VoxR::filter_point_density(tls,0.02)
rgl::open3d()
rgl::plot3d(filtered,add=TRUE)

#- keep one point in 10cm voxels
filtered=VoxR::filter_point_density(tls,0.1)
rgl::open3d()
rgl::plot3d(filtered,add=TRUE)
</code></pre>

<hr>
<h2 id='guess_resolution'>Guess the voxel resolution in a voxel cloud</h2><span id='topic+guess_resolution'></span>

<h3>Description</h3>

<p>measure the distance to the nearest neighbour for <code>N_sample</code> voxels and guess the resolution:
the majority wins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_resolution(data, N_sample, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_resolution_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a voxel cloud.</p>
</td></tr>
<tr><td><code id="guess_resolution_+3A_n_sample">N_sample</code></td>
<td>
<p>numeric. The number of voxels to sample. Default = 100.</p>
</td></tr>
<tr><td><code id="guess_resolution_+3A_message">message</code></td>
<td>
<p>logical. FALSE desables the message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the guessed resolution.
</p>

<hr>
<h2 id='level'>Deprecated function</h2><span id='topic+level'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>level(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="level_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='obj.rec'>Deprecated function</h2><span id='topic+obj.rec'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.rec(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.rec_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='plot_projection'>Visualization of a projected voxel cloud.</h2><span id='topic+plot_projection'></span>

<h3>Description</h3>

<p>Visualization of a projected voxel cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_projection(data, var, th, palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_projection_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the output of the <a href="#topic+project_voxels">project_voxels</a> function:
x, y, number of voxels, number of points and ratio of a projected voxel cloud.</p>
</td></tr>
<tr><td><code id="plot_projection_+3A_var">var</code></td>
<td>
<p>character. The variable to plot: &quot;nvox&quot; for the number of voxels per pixel, &quot;npts&quot; for
the number of points or &quot;ratio&quot; for the ratio npts/nvox. Default is &quot;nvox&quot;.</p>
</td></tr>
<tr><td><code id="plot_projection_+3A_th">th</code></td>
<td>
<p>numeric between 0 and 1. A quantile threshold that defines the maximum value of <code>var</code>
to be plotted. Values &gt; th are replaced by the value of th. Desabled by default.</p>
</td></tr>
<tr><td><code id="plot_projection_+3A_palette">palette</code></td>
<td>
<p>a color palette to use for plotting.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- voxelisation
voxels = VoxR::vox(tls,0.05)

#- project into the xy plan
project = VoxR::project_voxels(voxels,"xy")

#- plot the number of voxels
VoxR::plot_projection(project,var = "nvox")

#- plot the number of points
VoxR::plot_projection(project,var = "npts")

#- plot the ratio npts/nvox
VoxR::plot_projection(project,var = "ratio")

#- plot the number of voxels with different color palette
VoxR::plot_projection(project,palette = terrain.colors)

#- plot the number of voxels with a 95% percentile threshold
VoxR::plot_projection(project,th = 0.95)
</code></pre>

<hr>
<h2 id='plot_voxels'>Voxel cloud visualization.</h2><span id='topic+plot_voxels'></span>

<h3>Description</h3>

<p>Voxel cloud visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_voxels(data, res, type, lcol, fcol, lwd, alpha, plot, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_voxels_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing at least the voxel cloud x, y, z coordinates.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_res">res</code></td>
<td>
<p>numeric. The voxel resolution. If not provided, the function will guess it.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_type">type</code></td>
<td>
<p>character. How to represent a voxel ? If &quot;w&quot; only the voxel hedges are plotted,
if &quot;p&quot; plain voxels are plotted, if &quot;b&quot; both hedges and plain voxels are plotted. Default = &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_lcol">lcol</code></td>
<td>
<p>the line color for <code>type</code> = &quot;w&quot; or &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_fcol">fcol</code></td>
<td>
<p>the facets color for <code>type</code> = &quot;p&quot; or &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_lwd">lwd</code></td>
<td>
<p>numeric. The line width for <code>type</code> = &quot;w&quot; or &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The transparency of the voxel faces for <code>type</code> = &quot;p&quot; or &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the voxels ? See return for mesh capture. Default = TRUE.</p>
</td></tr>
<tr><td><code id="plot_voxels_+3A_message">message</code></td>
<td>
<p>logical. Removes the message from the resolution guessing. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, the 3D plot of voxels is plotted. At anytime the mesh object that enables
to plot the voxels can be captured and to be plotted using the
<code><a href="rgl.html#topic+shade3d">shade3d</a></code> function from rgl.
The returned object is a list containing the 3D mesh of the voxel cloud and all additionnal fields
of the input data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- voxelisation
voxels = VoxR::vox(tls,res=0.05)

#- plot the voxels
VoxR::plot_voxels(voxels)

#- capture the voxels mesh to plot with color scale
###- number of points in the voxel
voxels_mesh = VoxR::plot_voxels(voxels,plot = FALSE) # capture the mesh
colors=rev(rainbow(max(voxels_mesh$additionnal$npts),end=4/6)) # color scale
rgl::open3d()
rgl::shade3d(voxels_mesh$mesh,col=colors[round(voxels_mesh$additionnal$npts)]
             ,lit=FALSE,alpha=0.5) # plot

###- distance from the crow center
# compute distnce
voxels[,distance:=round(VoxR::point_distance(voxels[,1:3],c(mean(x),mean(y),mean(z)))*100)]
voxels_mesh = VoxR::plot_voxels(voxels,plot = FALSE) # capture mesh
cols=rev(rainbow(max(voxels_mesh$additionnal$distance),end=4/6)) # color scale
rgl::open3d()
rgl::shade3d(voxels_mesh$mesh,col=cols[round(voxels_mesh$additionnal$distance)]
             ,lit=FALSE,alpha=0.5) # plot
</code></pre>

<hr>
<h2 id='plot_voxels_full_grid'>Voxel cloud visualization when voxel cloud includes the empty voxels.</h2><span id='topic+plot_voxels_full_grid'></span>

<h3>Description</h3>

<p>Voxel cloud visualization when voxel cloud includes the empty voxels.
Filled voxels are plotted as plain vertices and only the edges of empty voxels are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_voxels_full_grid(data, res, ecol, fcol, lwd, alpha, plot, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_voxels_full_grid_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing at least the voxel cloud x, y, z coordinates.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_res">res</code></td>
<td>
<p>numeric. The voxel resolution. If not provided, the function will guess it.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_ecol">ecol</code></td>
<td>
<p>color for the edges of empty voxels.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_fcol">fcol</code></td>
<td>
<p>color for the facets of filled voxels.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_lwd">lwd</code></td>
<td>
<p>numeric. The line width for the edges of empty voxels.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The transparency of the voxel facets for filled voxels.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the voxels ? See return for mesh capture. Default = TRUE.</p>
</td></tr>
<tr><td><code id="plot_voxels_full_grid_+3A_message">message</code></td>
<td>
<p>logical. If FALSE removes the message from the resolution guessing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>At anytime the mesh object that enables to plot the voxels can be captured to plot it using
the <code><a href="rgl.html#topic+shade3d">shade3d</a></code> function from rgl. The returned object is a list containing
the 3D mesh of filled and empty voxels separately.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- voxelisation with full.grid option
voxels=VoxR::vox(tls,0.3,full.grid = TRUE)

#- plot the voxels
VoxR::plot_voxels_full_grid(voxels)
</code></pre>

<hr>
<h2 id='point_distance'>Computes the distance of a set of points to a user defined point.</h2><span id='topic+point_distance'></span>

<h3>Description</h3>

<p>Computes the distance of a set of points to a user defined point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_distance(data, point, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_distance_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud or voxel cloud.</p>
</td></tr>
<tr><td><code id="point_distance_+3A_point">point</code></td>
<td>
<p>a vector of length 3 containing the x, y and z coordintes of the reference point.</p>
</td></tr>
<tr><td><code id="point_distance_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the distance values of the points.
</p>


<h3>References</h3>

<p>Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- compute distance to the crown centre
tls[,dist:=VoxR::point_distance(tls,c(mean(x),mean(y),mean(z)))]

#- round distance values for visualization
tls[,dist:=round(dist*100)]

#- plot the distance to crown centre
cols=rev(rainbow(max(tls$dist)+1,end=4/6)) # color scale
rgl::open3d()
rgl::plot3d(tls,col=cols[tls$dist+1],add=TRUE)
</code></pre>

<hr>
<h2 id='point.distance'>Deprecated function</h2><span id='topic+point.distance'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point.distance(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point.distance_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='project'>Deprecated function</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='project_voxels'>Project a voxel cloud in a 2D plan formed by two axes of the cartesian coordiantes system.</h2><span id='topic+project_voxels'></span>

<h3>Description</h3>

<p>Project a voxel cloud in a 2D plan formed by two axes of the cartesian coordiantes system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_voxels(data, plan, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_voxels_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a voxel cloud.</p>
</td></tr>
<tr><td><code id="project_voxels_+3A_plan">plan</code></td>
<td>
<p>character. Defines the projection plan: &quot;xy&quot;, &quot;xz&quot; or &quot;yz&quot;. Default = &quot;xy&quot;.</p>
</td></tr>
<tr><td><code id="project_voxels_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of a 2D point cloud containing : x, y coordinates of the pixels and the
number of voxels (nvox), number of points (npts), ratio npts/nvox contained in each pixel.
</p>


<h3>References</h3>

<p>Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- voxelisation
voxels = VoxR::vox(tls,0.05)

#- project into the xy plan
project_xy = VoxR::project_voxels(voxels,"xy")
VoxR::plot_projection(project_xy) # plot projection

#- project into the xz plan
project_xy = VoxR::project_voxels(voxels,"xz")
VoxR::plot_projection(project_xy) # plot projection
</code></pre>

<hr>
<h2 id='raster.proj'>Deprecated function</h2><span id='topic+raster.proj'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster.proj(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.proj_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='sub.obj'>Deprecated function</h2><span id='topic+sub.obj'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub.obj(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub.obj_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='substract_point_clouds'>Point clouds substraction: identification of changes between two measuring times.</h2><span id='topic+substract_point_clouds'></span>

<h3>Description</h3>

<p>Identify the point that are unique to one of two point clouds
to detect the changes that occured between two measuring times (e.g. growth,
branches losses, branch motion). Two methods are available (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substract_point_clouds(t0, t1, method, dist, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substract_point_clouds_+3A_t0">t0</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud or voxel cloud
acquired at time 0.</p>
</td></tr>
<tr><td><code id="substract_point_clouds_+3A_t1">t1</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud or voxel cloud
acquired at time 1.</p>
</td></tr>
<tr><td><code id="substract_point_clouds_+3A_method">method</code></td>
<td>
<p>character. The method to use to identify the difference between t0 and t1. Can be either &quot;hull&quot; or
&quot;distance&quot;, see details.</p>
</td></tr>
<tr><td><code id="substract_point_clouds_+3A_dist">dist</code></td>
<td>
<p>numeric. The threshold distance to consider a point is unique to t1 if <code>method = "distance"</code>.</p>
</td></tr>
<tr><td><code id="substract_point_clouds_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "hull"</code>, the convex hull that wraps t0 is constructed and the difference between t1 and t0 are
the points outside the convex hull. If <code>method = "distance"</code>, the points in t1 that are distant (i.e. further than
<code>dist</code>) from the points in t0 are returned.
</p>


<h3>Value</h3>

<p>a data.frame or data.table containing the x, y, z, ... coordinates of points that are unique to t1.
</p>


<h3>Note</h3>

<p><code>t0</code> and <code>t1</code> must be registered in the same coordinates system.
</p>
<p>@references Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import datasets
t0=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))
t1=data.table::fread(system.file("extdata", "Tree_t1.asc", package="VoxR"))

#- keep only the tree crown
t0 = t0[z&gt;=0,]
t1 = t1[z&gt;=0,]

####- substract t0 to t1 with the hull method
diff = VoxR::substract_point_clouds(t0 = t0,t1 = t1, method = "hull")
#- plot the result (t0 in black, the difference between t1 and t0 in red)
rgl::open3d()
rgl::plot3d(t0,add=TRUE)
rgl::plot3d(diff,col="red",add=TRUE)

####- substract t0 to t1 with the distance based method
diff = substract_point_clouds(t0 = t0,t1 = t1, method = "distance",dist = 0.1)
#- plot the result (t0 in black, the difference between t1 and t0 in red)
rgl::open3d()
rgl::plot3d(t0,add=TRUE)
rgl::plot3d(diff,col="red",add=TRUE)
</code></pre>

<hr>
<h2 id='surface'>Deprecated function</h2><span id='topic+surface'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>

<hr>
<h2 id='tree_metrics'>Estimates a set of morphological parameters from a tls point cloud of a tree.</h2><span id='topic+tree_metrics'></span>

<h3>Description</h3>

<p>Estimates a set of morphological parameters from a tls point cloud of a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_metrics(
  data,
  dbh,
  height,
  crown_diameter,
  crown_proj_area,
  volume,
  message
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_metrics_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud.</p>
</td></tr>
<tr><td><code id="tree_metrics_+3A_dbh">dbh</code></td>
<td>
<p>numeric and optional. Estimate tree DBH ?</p>
</td></tr>
<tr><td><code id="tree_metrics_+3A_height">height</code></td>
<td>
<p>numeric and optional. Estimate tree height ?</p>
</td></tr>
<tr><td><code id="tree_metrics_+3A_crown_diameter">crown_diameter</code></td>
<td>
<p>numeric and optional. Estimate tree average crown diameter ?</p>
</td></tr>
<tr><td><code id="tree_metrics_+3A_crown_proj_area">crown_proj_area</code></td>
<td>
<p>numeric and optional. Estimate tree crown projected area ?</p>
</td></tr>
<tr><td><code id="tree_metrics_+3A_volume">volume</code></td>
<td>
<p>numeric and optional. Estimate tree volume ?</p>
</td></tr>
<tr><td><code id="tree_metrics_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Selecting parameters to compute</h4>

<p>If none of <code>dbh</code>,<code>height</code>,<code>crown_diameter</code>,
<code>crown_proj_area</code> and <code>volume</code> are passed, all parameters are computed. However, the
user can select a set of parameters by declaring wich parameters should be computed (all other are not).</p>



<h4>Parameters estimates</h4>

<p>The tree DBH is estimated as the diameter of a circle fitted to the point cloud between
1.2m and 1.4m above the ground. The tree height is computed as the elevation difference between the lowest and
the highest points of the point cloud. Two values are provided for crown parameter. First a 2D convex hull
is used to identify the external points of the crown. Then, a first estimate of the crown diameter (&quot;distant_points&quot;)
is computed as the average distance of each point to the further point. A second estimate (&quot;circle_fitting&quot;) correspond
to the diameter of a circle fitted to the crown external points. The crown projected area is computed as the area of a
2D convex hull that wraps the projected crown. The volume is computed as the volume of a 3D convex hull that wraps the point cloud.</p>



<h3>Value</h3>

<p>a list containing the estimated value for each parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#- import tls data
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- compute all metrics
VoxR::tree_metrics(tls)

#- compute DBH only
VoxR::tree_metrics(tls,dbh = TRUE)

#- compute DBH and height
VoxR::tree_metrics(tls,dbh = TRUE,height = TRUE)
</code></pre>

<hr>
<h2 id='vox'>Voxelisation of 3D point cloud recording the number of points within each voxels.</h2><span id='topic+vox'></span>

<h3>Description</h3>

<p>Voxelisation of 3D point cloud recording the number of points within each voxels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vox(data, res, full.grid, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vox_+3A_data">data</code></td>
<td>
<p>a data.frame or data.table containing the x, y, z, ... coordinates of a point cloud.</p>
</td></tr>
<tr><td><code id="vox_+3A_res">res</code></td>
<td>
<p>numeric. Resolution of a voxel.</p>
</td></tr>
<tr><td><code id="vox_+3A_full.grid">full.grid</code></td>
<td>
<p>logical. If TRUE empty voxels contained in the tree bounding box are returned.
If FALSE, only filled voxels are returned. Default = FALSE.</p>
</td></tr>
<tr><td><code id="vox_+3A_message">message</code></td>
<td>
<p>logical. If FALSE, messages are disabled. Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or data.table containing the x, y, z coordinates of the voxel center and
the number of points within each voxel of a voxel cloud.
</p>


<h3>References</h3>

<p>Lecigne, B., Delagrange, S., &amp; Messier, C. (2018). Exploring trees in three dimensions: VoxR, a novel voxel-based R package dedicated to
analysing the complex arrangement of tree crowns. Annals of botany, 121(4), 589-601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#- import file
tls=data.table::fread(system.file("extdata", "Tree_t0.asc", package="VoxR"))

#- resolution = 0.02m
voxels_002 = VoxR::vox(tls,res=0.02) # voxelisation
VoxR::plot_voxels(voxels_002) # voxels plot

#- resolution = 0.2m
voxels_02 = VoxR::vox(tls,res=0.2) # voxelisation
VoxR::plot_voxels(voxels_02) # voxels plot
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
