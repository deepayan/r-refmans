<!DOCTYPE html><html><head><title>Help for package Rage</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rage}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#age_from_stage'><p>Calculate age-specific traits from a matrix population model</p></a></li>
<li><a href='#entropy_d'><p>Calculate Demetrius' entropy from trajectories of age-specific survivorship</p>
and fecundity</a></li>
<li><a href='#entropy_k'><p>Calculate Keyfitz's entropy from a trajectory of age-specific survivorship</p></a></li>
<li><a href='#gen_time'><p>Calculate generation time from a matrix population model</p></a></li>
<li><a href='#is_leslie_matrix'><p>Determine if a matrix is a Leslie matrix population model</p></a></li>
<li><a href='#leslie_collapse'><p>Aggregate a Leslie matrix</p></a></li>
<li><a href='#leslie_mpm1'><p>Example Leslie matrix population model (MPM)</p></a></li>
<li><a href='#life_expect_mean'><p>Calculate mean and variance of life expectancy from a matrix population model</p></a></li>
<li><a href='#lifetable_convert'><p>Convert between age-specific survivorship, survival, or mortality hazard</p></a></li>
<li><a href='#longevity'><p>Calculate longevity from a matrix population model</p></a></li>
<li><a href='#mpm_collapse'><p>Collapse a matrix population model to a smaller number of stages</p></a></li>
<li><a href='#mpm_rearrange'><p>Rearrange stages of a matrix population model to segregate reproductive and</p>
non-reproductive stages</a></li>
<li><a href='#mpm_split'><p>Convert matrix population model into U, F and C matrices</p></a></li>
<li><a href='#mpm_standardize'><p>Transform a matrix population model to a standardized form</p></a></li>
<li><a href='#mpm_to_table'><p>Generate a life table from a matrix population model</p></a></li>
<li><a href='#mpm1'><p>Example matrix population model (MPM)</p></a></li>
<li><a href='#name_stages'><p>Add stage names to matrices</p></a></li>
<li><a href='#net_repro_rate'><p>Calculate net reproductive rate (R0) from a matrix population model</p></a></li>
<li><a href='#perturb_matrix'><p>Perturbation analysis of a matrix population model</p></a></li>
<li><a href='#perturb_stochastic'><p>Calculate stochastic elasticities from a time-series of matrix population</p>
models and corresponding population vectors</a></li>
<li><a href='#perturb_trans'><p>Perturbation analysis of transition types within a matrix population model</p></a></li>
<li><a href='#perturb_vr'><p>Perturbation analysis of vital rates in a matrix population model</p></a></li>
<li><a href='#plot_life_cycle'><p>Plot a life cycle diagram from a matrix population model</p></a></li>
<li><a href='#pop_vectors'><p>Derive a hypothetical set of population vectors corresponding to a</p>
time-series of matrix population models</a></li>
<li><a href='#qsd_converge'><p>Calculate time to reach quasi-stationary stage distribution</p></a></li>
<li><a href='#Rage-package'><p>Rage: Life History Metrics from Matrix Population Models</p></a></li>
<li><a href='#repro_maturity'><p>Age of reproductive maturity</p></a></li>
<li><a href='#repro_stages'><p>Identify which stages in a matrix population model are reproductive</p></a></li>
<li><a href='#shape_rep'><p>Calculate shape of reproduction over age</p></a></li>
<li><a href='#shape_surv'><p>Calculate shape of survival over age</p></a></li>
<li><a href='#standard_stages'><p>Identify stages corresponding to different parts of the reproductive life</p>
cycle</a></li>
<li><a href='#vital_rates'><p>Derive mean vital rates from a matrix population model</p></a></li>
<li><a href='#vr'><p>Derive mean vital rates from a matrix population model</p></a></li>
<li><a href='#vr_mat'><p>Derive survival-independent vital rates for growth, stasis, shrinkage, and</p>
reproduction</a></li>
<li><a href='#vr_vec'><p>Derive stage-specific vital rates from a matrix population model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Life History Metrics from Matrix Population Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for calculating life history metrics using matrix
    population models ('MPMs'). Described in Jones et al. (2021)
    &lt;<a href="https://doi.org/10.1101%2F2021.04.26.441330">doi:10.1101/2021.04.26.441330</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonesor/Rage">https://github.com/jonesor/Rage</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonesor/Rage/issues">https://github.com/jonesor/Rage/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DiagrammeR, expm, MASS, popdemo, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, Rcompadre, rmarkdown, spelling, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-29 17:40:01 UTC; jones</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Barks <a href="https://orcid.org/0000-0002-5947-8151"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Danny Buss [ctb],
  Pol Capdevila <a href="https://orcid.org/0000-0002-2842-4302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Hal Caswell <a href="https://orcid.org/0000-0003-4394-6894"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Judy P. Che-Castaldo
    <a href="https://orcid.org/0000-0002-9118-9202"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Richard A. Hinrichsen
    <a href="https://orcid.org/0000-0003-0761-3005"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  John Jackson <a href="https://orcid.org/0000-0002-4563-2840"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tamora James <a href="https://orcid.org/0000-0003-1363-4742"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Owen Jones <a href="https://orcid.org/0000-0001-5720-4686"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Sam Levin <a href="https://orcid.org/0000-0002-3289-9925"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  William K. Petry <a href="https://orcid.org/0000-0002-5230-5987"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Roberto Salguero-Gomez
    <a href="https://orcid.org/0000-0002-6085-4433"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Caroline Schuette <a href="https://orcid.org/0000-0002-2063-8736"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Iain Stott <a href="https://orcid.org/0000-0003-2724-7436"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Chelsea C. Thomas <a href="https://orcid.org/0000-0002-8155-9353"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christina M. Hern√°ndez
    <a href="https://orcid.org/0000-0002-7188-8217"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Owen Jones &lt;jones@biology.sdu.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-29 18:02:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='age_from_stage'>Calculate age-specific traits from a matrix population model</h2><span id='topic+age_from_stage'></span><span id='topic+mpm_to_mx'></span><span id='topic+mpm_to_lx'></span><span id='topic+mpm_to_px'></span><span id='topic+mpm_to_hx'></span>

<h3>Description</h3>

<p>These functions use age-from-stage decomposition methods to calculate
age-specific survivorship (<code>lx</code>), survival probability (<code>px</code>),
mortality hazard (<code>hx</code>), or reproduction (<code>mx</code>) from a matrix
population model (MPM). A detailed description of these methods can be found
in sections 5.3.1 and 5.3.2 of Caswell (2001). A separate function
<code><a href="#topic+mpm_to_table">mpm_to_table</a></code> uses the same methods to calculate a full life
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_to_mx(matU, matR, start = 1L, xmax = 1000, lx_crit = 0.01, tol = 1e-04)

mpm_to_lx(matU, start = 1L, xmax = 1000, lx_crit = 0.01, tol = 1e-04)

mpm_to_px(matU, start = 1L, xmax = 1000, lx_crit = 0.01, tol = 1e-04)

mpm_to_hx(matU, start = 1L, xmax = 1000, lx_crit = 0.01, tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_from_stage_+3A_matu">matU</code></td>
<td>
<p>The survival component of a MPM (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression). Optionally with named rows and
columns indicating the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="age_from_stage_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a MPM (i.e., a
square projection matrix reflecting transitions due to reproduction; either
sexual, clonal, or both). Optionally with named rows and columns indicating
the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="age_from_stage_+3A_start">start</code></td>
<td>
<p>The index (or stage name) of the first stage at which the author
considers the beginning of life. Defaults to <code>1</code>. Alternately, a
numeric vector giving the starting population vector (in which case
<code>length(start)</code> must match <code>ncol(matU))</code>. See section
<em>Starting from multiple stages</em>.</p>
</td></tr>
<tr><td><code id="age_from_stage_+3A_xmax">xmax</code></td>
<td>
<p>Maximum age to which age-specific traits will be calculated
(defaults to <code>1000</code>).</p>
</td></tr>
<tr><td><code id="age_from_stage_+3A_lx_crit">lx_crit</code></td>
<td>
<p>Minimum value of <code>lx</code> to which age-specific traits will
be calculated (defaults to <code>0.01</code>).</p>
</td></tr>
<tr><td><code id="age_from_stage_+3A_tol">tol</code></td>
<td>
<p>To account for floating point errors that occasionally lead to
values of <code>lx</code> slightly greater than 1, values of <code>lx</code> within the
open interval (<code>1</code>, <code>1 + tol</code>) are coerced to 1. Defaults to
<code>0.0001</code>. To prevent coercion, set <code>tol</code> to <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>


<h3>Starting from multiple stages</h3>

<p>Rather than specifying argument <code>start</code> as a single stage class from
which all individuals start life, it may sometimes be desirable to allow for
multiple starting stage classes. For example, if users want to start their
calculation of age-specific traits from reproductive maturity (i.e., first
reproduction), they should account for the possibility that there may be
multiple stage classes in which an individual could first reproduce.
</p>
<p>To specify multiple starting stage classes, users should specify argument
<code>start</code> as the desired starting population vector (<strong>n1</strong>), giving
the proportion of individuals starting in each stage class (the length of
<code>start</code> should match the number of columns in the relevant MPM).
</p>
<p>See function <code><a href="#topic+mature_distrib">mature_distrib</a></code> for calculating the proportion of
individuals achieving reproductive maturity in each stage class.
</p>


<h3>Note</h3>

<p>Note that the units of time for the returned vectors (i.e., <code>x</code>)
are the same as the projection interval (<code>ProjectionInterval</code>) of the
MPM.
</p>
<p>The output vector is calculated recursively until the age class
(<code>x</code>) reaches <code>xmax</code> or survivorship (<code>lx</code>) falls below
<code>lx_crit</code>, whichever comes first. To force calculation to <code>xmax</code>,
set <code>lx_crit</code> to <code>0</code>. Conversely, to force calculation to
<code>lx_crit</code>, set <code>xmax</code> to <code>Inf</code>.
</p>
<p>Note that the units of time in returned values (i.e., <code>x</code>) are the
same as the projection interval ('ProjectionInterval') of the MPM.
</p>


<h3>Author(s)</h3>

<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>
<p>Roberto Salguero-G√≥mez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Hal Caswell &lt;h.caswell@uva.nl&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction, Analysis, and
Interpretation. Sinauer Associates; 2nd edition. ISBN: 978-0878930968
</p>
<p>Jones O. R. 2021. Life tables: Construction and interpretation In:
Demographic Methods Across the Tree of Life. Edited by Salguero-Gomez R &amp;
Gamelon M. Oxford University Press. Oxford, UK. ISBN: 9780198838609
</p>
<p>Preston, S., Heuveline, P., &amp; Guillot, M. 2000. Demography: Measuring and
Modeling Population Processes. Wiley. ISBN: 9781557864512
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lifetable_convert">lifetable_convert</a></code>
</p>
<p>Other life tables: 
<code><a href="#topic+lifetable_convert">lifetable_convert</a></code>,
<code><a href="#topic+mpm_to_table">mpm_to_table</a>()</code>,
<code><a href="#topic+qsd_converge">qsd_converge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# age-specific survivorship
mpm_to_lx(mpm1$matU)
mpm_to_lx(mpm1$matU, start = 2) # starting from stage 2
mpm_to_lx(mpm1$matU, start = "small") # equivalent using named life stages
mpm_to_lx(mpm1$matU, xmax = 10) # to a maximum age of 10
mpm_to_lx(mpm1$matU, lx_crit = 0.05) # to a minimum lx of 0.05

# age-specific survival probability
mpm_to_px(mpm1$matU)

# age-specific mortality hazard
mpm_to_hx(mpm1$matU)

# age-specific fecundity
mpm_to_mx(mpm1$matU, mpm1$matF)


### starting from first reproduction
repstages &lt;- repro_stages(mpm1$matF)
n1 &lt;- mature_distrib(mpm1$matU, start = 2, repro_stages = repstages)

mpm_to_lx(mpm1$matU, start = n1)
mpm_to_px(mpm1$matU, start = n1)
mpm_to_hx(mpm1$matU, start = n1)
mpm_to_mx(mpm1$matU, mpm1$matF, start = n1)

</code></pre>

<hr>
<h2 id='entropy_d'>Calculate Demetrius' entropy from trajectories of age-specific survivorship
and fecundity</h2><span id='topic+entropy_d'></span>

<h3>Description</h3>

<p>This function calculates Demetrius' entropy from vectors of age-specific
survivorship (<code>lx</code>) and fecundity (<code>mx</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy_d(lx, mx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_d_+3A_lx">lx</code></td>
<td>
<p>Either a survivorship trajectory (a vector of
monotonically-declining values in the interval [0,1]), or submatrix U from
a matrix population model.</p>
</td></tr>
<tr><td><code id="entropy_d_+3A_mx">mx</code></td>
<td>
<p>Either an age-specific fecundity trajectory (a vector of
non-negative values), or submatrix U from a matrix population model.</p>
</td></tr>
<tr><td><code id="entropy_d_+3A_...">...</code></td>
<td>
<p>Additional variables passed to 'mpm_to_lx' and 'mpm_to_mx' if the
data are supplied as matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Demetrius' entropy.
</p>


<h3>Warning</h3>

<p>Note that this function may produce unexpected results if
used on partial survivorship and fecundity trajectories. In addition, it is
sensitive to the length of the these vectors. We direct users to the
functions '<code><a href="#topic+shape_surv">shape_surv</a></code>' and '<code><a href="#topic+shape_rep">shape_rep</a></code>' which
are relatively robust to these issues.
</p>


<h3>Author(s)</h3>

<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Demetrius, L., &amp; Gundlach, V. M. 2014. Directionality theory and
the entropic principle of natural selection. Entropy 16: 5428-5522.
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# derive trajectories of lx and mx, starting from stage 2
lx &lt;- mpm_to_lx(mpm1$matU, start = 2)
mx &lt;- mpm_to_mx(mpm1$matU, mpm1$matF, start = 2)

# calculate Demetrius' entropy
entropy_d(lx, mx)

# calculate Demetrius' entropy directly from MPM
entropy_d(lx = mpm1$matU, mx = mpm1$matF, start = 2)

</code></pre>

<hr>
<h2 id='entropy_k'>Calculate Keyfitz's entropy from a trajectory of age-specific survivorship</h2><span id='topic+entropy_k'></span>

<h3>Description</h3>

<p>Calculate Keyfitz's entropy from a vector of age-specific survivorship
(<code>lx</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy_k(lx, trapeze = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_k_+3A_lx">lx</code></td>
<td>
<p>Either a survivorship trajectory (a vector of
monotonically-declining values in the interval [0,1]), or submatrix U from
a matrix population model.</p>
</td></tr>
<tr><td><code id="entropy_k_+3A_trapeze">trapeze</code></td>
<td>
<p>A logical argument indicating whether the composite trapezoid
approximation should be used for approximating the definite integral.</p>
</td></tr>
<tr><td><code id="entropy_k_+3A_...">...</code></td>
<td>
<p>Additional variables passed to 'mpm_to_lx' if data are supplied as
a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Keyfitz's life table entropy.
</p>


<h3>Warning</h3>

<p>Note that this function may produce unexpected results if used on partial
survivorship trajectories. In addition, it is sensitive to the length of the
survivorship vector. We direct users to the function
'<code><a href="#topic+shape_surv">shape_surv</a></code>' which is relatively robust to these issues.
</p>


<h3>Author(s)</h3>

<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>
<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Keyfitz, N. 1977. Applied Mathematical Demography. New York:
Wiley.
</p>
<p>Demetrius, L., &amp; Gundlach, V. M. 2014. Directionality theory and
the entropic principle of natural selection. Entropy 16: 5428-5522.
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# derive lx trajectory, starting from stage 2
lx &lt;- mpm_to_lx(mpm1$matU, start = 2)

# calculate Keyfitz' entropy
entropy_k(lx)

# use trapezoid approximation for definite integral
entropy_k(lx, trapeze = TRUE)

# calculate directly from the matrix
entropy_k(mpm1$matU)

</code></pre>

<hr>
<h2 id='gen_time'>Calculate generation time from a matrix population model</h2><span id='topic+gen_time'></span>

<h3>Description</h3>

<p>Calculate generation time from a matrix population model. Multiple
definitions of the generation time are supported: the time required for a
population to increase by a factor of R0 (the net reproductive rate; Caswell
(2001), section 5.3.5), the average parent-offspring age difference (Bienvenu
&amp; Legendre (2015)), or the expected age at reproduction for a cohort (Coale
(1972), p. 18-19).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_time(matU, matR, method = c("R0", "age_diff", "cohort"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_time_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression).</p>
</td></tr>
<tr><td><code id="gen_time_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a matrix population model (i.e., a
square projection matrix only reflecting transitions due to reproduction;
either sexual, clonal, or both).</p>
</td></tr>
<tr><td><code id="gen_time_+3A_method">method</code></td>
<td>
<p>The method used to calculate generation time. Defaults to &quot;R0&quot;.
See Details for explanation of calculations.</p>
</td></tr>
<tr><td><code id="gen_time_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>net_repro_rate</code> when
<code>method = "R0"</code> or <code>mpm_to_*</code> when <code>method = "cohort"</code>.
Ignored when <code>method = "age_diff"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are multiple definitions of generation time, three of which are
implemented by this function:
</p>
<p>1. <code>"R0"</code> (default): This is the number of time steps required for the
population to grow by a factor of its net reproductive rate, equal to
<code>log(R0) / log(lambda)</code>. Here, <code>R0</code> is the net reproductive rate
(the per-generation population growth rate; Caswell 2001, Sec. 5.3.4), and
<code>lambda</code> is the population growth rate per unit time (the dominant
eigenvalue of <code>matU + matR</code>).
</p>
<p>2. <code>"age_diff"</code>: This is the average age difference between parents and
offspring, equal to <code>(lambda v w) / (v matR w)</code> (Bienvenu &amp; Legendre
(2015)). Here, <code>lambda</code> is the population growth rate per unit time (the
dominant eigenvalue of <code>matU + matR</code>), <code>v</code> is a row vector of
stage-specific reproductive values (the left eigenvector corresponding to
<code>lambda</code>), and <code>w</code> is a column vector of the stable stage
distribution (the right eigenvector corresponding to <code>lambda</code>).
</p>
<p>3. <code>"cohort"</code>: This is the age at which members of a cohort are expected
to reproduce, equal to <code>sum(x lx mx) / sum(lx mx)</code> (Coale (1972), p.
18-19). Here, <code>x</code> is age, <code>lx</code> is age-specific survivorship, and
<code>mx</code> is age-specific fertility. See functions <code>mpm_to_lx</code> and
<code>mpm_to_mx</code> for details about the conversion of matrix population models
to life tables.
</p>


<h3>Value</h3>

<p>Returns generation time. If <code>matU</code> is singular (often indicating
infinite life expectancy), returns <code>NA</code>.
</p>


<h3>Note</h3>

<p>Note that the units of time in returned values are the same as the
projection interval ('ProjectionInterval') of the MPM.
</p>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>
<p>William Petry &lt;wpetry@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Bienvenu, F. &amp; Legendre, S. 2015. A New Approach to the
Generation Time in Matrix Population Models. The American Naturalist 185
(6): 834‚Äì843. doi:10.1086/681104.
</p>
<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>
<p>Coale, A.J. 1972. The Growth and Structure of Human Populations. Princeton
University Press. ISBN: 978-0691093574
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# calculate generation time
gen_time(matU = mpm1$matU, matR = mpm1$matF) # defaults to "R0" method
gen_time(matU = mpm1$matU, matR = mpm1$matF, method = "age_diff")
gen_time(
  matU = mpm1$matU, matR = mpm1$matF, method = "cohort", lx_crit =
    0.001
)

</code></pre>

<hr>
<h2 id='is_leslie_matrix'>Determine if a matrix is a Leslie matrix population model</h2><span id='topic+is_leslie_matrix'></span>

<h3>Description</h3>

<p>Checks if a given matrix is a Leslie matrix.
A matrix is determined to be a Leslie matrix if it satisfies the following
conditions:
* All elements of A are non-negative.
* The subdiagonal elements of A, excluding the last column, are all between 0
and 1.
* The sum of the elements in the first row (representing reproduction) of A
is positive.
* The upper triangle of A, excluding the first row, contains only 0s.
* The diagonal of A, excluding the top-left and bottom-right corners contain
only 0s.
* The lower triangle of A, excluding the subdiagonal, contains only 0s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_leslie_matrix(A, includes_mat_F = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_leslie_matrix_+3A_a">A</code></td>
<td>
<p>Matrix to be tested</p>
</td></tr>
<tr><td><code id="is_leslie_matrix_+3A_includes_mat_f">includes_mat_F</code></td>
<td>
<p>A logical argument (default 'TRUE') indicating whether
A is expected to include fecundity. The idea here is that A may not include
fertility, but could still be a valid Leslie matrix if fertility was truly
measured to be 0, or if fertility was not measured at all. Thus, this
argument relaxes the test for the first row of A summing to a positive
value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the matrix is a Leslie matrix or
not
</p>


<h3>Author(s)</h3>

<p>Owen Jones &lt;jones@biology.sdu.dk&gt;
</p>


<h3>See Also</h3>

<p>Other transformation: 
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(
  0.1, 1.2, 1.1,
  0.1, 0.0, 0.0,
  0.0, 0.2, 0.3
), nrow = 3, byrow = TRUE)
is_leslie_matrix(A) # true
A &lt;- matrix(c(
  0.1, 1.2, 1.1,
  0.1, 0.2, 0.1,
  0.2, 0.3, 0.3
), nrow = 3, byrow = TRUE)
is_leslie_matrix(A) # false

data(leslie_mpm1)
A &lt;- leslie_mpm1$matU + leslie_mpm1$matF
is_leslie_matrix(A) # false

</code></pre>

<hr>
<h2 id='leslie_collapse'>Aggregate a Leslie matrix</h2><span id='topic+leslie_collapse'></span>

<h3>Description</h3>

<p>Takes a Leslie matrix and aggregates it to a desired dimension m using least
squares weights equal to the stable age distribution. The output includes the
aggregated matrix, the weight matrix, the original (or expanded) Leslie
matrix raised to the k power, the partitioning matrix, the size of the
original (or expanded) Leslie matrix, the size of the aggregated matrix, the
quotient of the original size divided by the aggregated size, and the
effectiveness of aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leslie_collapse(A, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leslie_collapse_+3A_a">A</code></td>
<td>
<p>a Leslie matrix</p>
</td></tr>
<tr><td><code id="leslie_collapse_+3A_m">m</code></td>
<td>
<p>the dimensionality of the desired aggregated matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the following elements:
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>The aggregated matrix</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The weight matrix</p>
</td></tr>
<tr><td><code>Ak</code></td>
<td>
<p>The original (or expanded) Leslie matrix raised to the k power</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The partitioning matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The size of the original (or expanded) Leslie matrix</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The size of the aggregated matrix</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The quotient of the original size divided by the aggregated size</p>
</td></tr>
<tr><td><code>EFF</code></td>
<td>
<p>The effectiveness of aggregation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard A. Hinrichsen &lt;rich@hinrichsenenvironmental.com&gt;
</p>


<h3>References</h3>

<p>Hinrichsen, R. A. (2023). Aggregation of Leslie matrix models
with application to ten diverse animal species. Population Ecology, 1‚Äì21.
https://doi.org/10.1002/1438-390X.12149
</p>


<h3>See Also</h3>

<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leslie_mpm1)
A &lt;- leslie_mpm1$matU + leslie_mpm1$matF
leslie_collapse(A, 4)

</code></pre>

<hr>
<h2 id='leslie_mpm1'>Example Leslie matrix population model (MPM)</h2><span id='topic+leslie_mpm1'></span>

<h3>Description</h3>

<p>An example Leslie matrix population model (MPM) used for demonstration and
testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leslie_mpm1
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>

<dl>
<dt>matU</dt><dd><p>The survival-related component of the MPM.</p>
</dd>
<dt>matF</dt><dd><p>The sexual reproduction component of the MPM.</p>
</dd>
</dl>


<hr>
<h2 id='life_expect_mean'>Calculate mean and variance of life expectancy from a matrix population model</h2><span id='topic+life_expect_mean'></span><span id='topic+life_expect_var'></span>

<h3>Description</h3>

<p>Applies Markov chain approaches to obtain mean and variance of life
expectancy from a matrix population model (MPM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>life_expect_mean(matU, mixdist = NULL, start = 1L)

life_expect_var(matU, mixdist = NULL, start = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="life_expect_mean_+3A_matu">matU</code></td>
<td>
<p>The survival component of a MPM (i.e., a square projection matrix
reflecting survival-related transitions; e.g., progression, stasis, and
retrogression). Optionally with named rows and columns indicating the
corresponding life stage names.</p>
</td></tr>
<tr><td><code id="life_expect_mean_+3A_mixdist">mixdist</code></td>
<td>
<p>A vector with a length equal to the dimension of the MPM
defining how the function should average the output over the. possible
starting states. See section <em>Starting from multiple stages</em>. If this
argument is used, 'start' must be set to 'NULL'.</p>
</td></tr>
<tr><td><code id="life_expect_mean_+3A_start">start</code></td>
<td>
<p>The index (or stage name) of the first stage of the life cycle
which the user considers to be the beginning of life. Defaults to <code>1</code>.
If set to 'NULL' the function returns mean life expectancy from each of the
stages of the MPM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns life expectancy in the units of the projection interval
('ProjectionInterval') of the MPM. If <code>matU</code> is singular (often
indicating infinite life expectancy), returns <code>NA</code>.
</p>


<h3>Starting from multiple stages</h3>

<p>Sometimes, it is necessary to calculate life expectancy considering multiple
starting stage classes instead of just a single stage from which all
individuals begin their lives. This scenario arises when there are several
possible stages at which an individual can start a particular life event,
such as reproductive maturity.
To handle such cases, the function provides support for multiple starting
stage classes. When calculating life expectancy in this context, the outputs
should be averaged using weights determined by the distribution of
individuals across these stages. To achieve this, the 'start' argument should
be set to 'NULL', indicating that the starting stage is not specified, and
the 'mixdist' argument should be utilized.
In the context described, The 'mixdist' argument expects a vector that
represents the proportion of individuals with their first reproduction in
each stage of the MPM. By providing this distribution, the function
calculates the mean lifespan by appropriately weighting the life expectancies
corresponding to each starting stage.
For a practical example that demonstrates this usage, please refer to the
code example below.
</p>


<h3>Author(s)</h3>

<p>Christine M. Hern√°ndez &lt;cmh352@cornell.edu&gt;
</p>
<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# mean life expectancy starting from stage class 2
life_expect_mean(mpm1$matU, start = 2)

# equivalent using named life stages
life_expect_mean(mpm1$matU, start = "small")

# mean life expectancies starting from each of the stages
life_expect_mean(mpm1$matU, start = NULL)

# mean life expectancy starting from first reproduction, where this varies
# across individuals
rep_stages &lt;- repro_stages(mpm1$matF)
(n1 &lt;- mature_distrib(mpm1$matU, start = 2, repro_stages = rep_stages))
life_expect_mean(mpm1$matU, mixdist = n1, start = NULL)

# variance of life expectancy from stage class 1
life_expect_var(mpm1$matU, start = 1)

# variance of life expectancy from stage class 1
life_expect_var(mpm1$matU, start = "seed")

# variance of life expectancy from each stage class
life_expect_var(mpm1$matU, start = NULL)

# variance of life expectancies with a set mixing distribution
life_expect_var(mpm1$matU, mixdist = c(0.0, 0.1, 0.3, 0.1, 0.5), start = NULL)

# setting mixdist to ignore all but one stage should produce the same result
# as setting the start argument to that stage
life_expect_mean(mpm1$matU, start = 3)
life_expect_mean(mpm1$matU, mixdist = c(0, 0, 1, 0, 0), start = NULL)

</code></pre>

<hr>
<h2 id='lifetable_convert'>Convert between age-specific survivorship, survival, or mortality hazard</h2><span id='topic+lifetable_convert'></span><span id='topic+lx_to_px'></span><span id='topic+lx_to_hx'></span><span id='topic+px_to_lx'></span><span id='topic+px_to_hx'></span><span id='topic+hx_to_lx'></span><span id='topic+hx_to_px'></span>

<h3>Description</h3>

<p>Convert between vectors of age-specific survivorship (<code>lx</code>), survival
probability (<code>px</code>), or mortality hazard (<code>hx</code>). Input vectors must
be arranged in order of increasing age, starting with age 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lx_to_px(lx)

lx_to_hx(lx)

px_to_lx(px)

px_to_hx(px)

hx_to_lx(hx)

hx_to_px(hx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lifetable_convert_+3A_lx">lx</code></td>
<td>
<p>Vector of age-specific survivorship.</p>
</td></tr>
<tr><td><code id="lifetable_convert_+3A_px">px</code></td>
<td>
<p>Vector of age-specific survival probabilities.</p>
</td></tr>
<tr><td><code id="lifetable_convert_+3A_hx">hx</code></td>
<td>
<p>Vector of age-specific mortality hazards.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lx</code> gives the proportional survivorship to the start of age
class <code>x</code> (where survivorship at first age class is defined as 1),
<code>px</code> gives the probability of survival between age <code>x</code> and
<code>x+1</code>, and <code>hx</code> gives the time-averaged mortality hazard (also
called force of mortality) between age <code>x</code> and <code>x+1</code>.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Note</h3>

<p>Note that the units of time for the returned vectors (i.e., <code>x</code>)
are the same as the (<code>ProjectionInterval</code>) of the MPM.
</p>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction, Analysis, and
Interpretation. Sinauer Associates; 2nd edition. ISBN: 978-0878930968
</p>
<p>Caswell, H. 2006. Applications of Markov chains in demography. pp. 319-334 in
A.N. Langville and W.J. Stewart (editors) MAM2006: Markov Anniversary
Meeting. Boson Books, Raleigh, North Caroline, USA
</p>
<p>Ergon, T., Borgan, √ò., Nater, C. R., &amp; Vindenes, Y. 2018. The utility of
mortality hazard rates in population analyses. Methods in Ecology and
Evolution, 9, 2046-2056. &lt;doi:10.1111/2041-210X.13059&gt;
</p>
<p>Horvitz, C. &amp; Tuljapurkar, S. 2008. Stage dynamics, period survival, and
mortality plateaus. The American Naturalist 172: 203-2015.
&lt;doi:10.1086/589453&gt;
</p>
<p>Jones, O. R., Scheuerlein, A., Salguero-Gomez, R., Camarda, C. G., Schaible,
R., Casper, B. B., Dahlgren, J. P., Ehrl√©n, J., Garc√≠a, M. B., Menges, E.,
Quintana-Ascencio, P. F., Caswell, H., Baudisch, A. &amp; Vaupel, J. 2014.
Diversity of ageing across the tree of life. Nature 505, 169-173.
&lt;doi:10.1038/nature12789&gt;
</p>
<p>Jones O. R. 2021. Life tables: Construction and interpretation In:
Demographic Methods Across the Tree of Life. Edited by Salguero-Gomez R &amp;
Gamelon M. Oxford University Press. Oxford, UK. ISBN: 9780198838609
</p>
<p>Preston, S., Heuveline, P., &amp; Guillot, M. 2000. Demography: Measuring and
Modeling Population Processes. Wiley. ISBN: 9781557864512
</p>


<h3>See Also</h3>

<p>Other life tables: 
<code><a href="#topic+age_from_stage">age_from_stage</a></code>,
<code><a href="#topic+mpm_to_table">mpm_to_table</a>()</code>,
<code><a href="#topic+qsd_converge">qsd_converge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lx &lt;- c(1, 0.8, 0.7, 0.5, 0.3, 0.1)

# convert from lx
px &lt;- lx_to_px(lx)
hx &lt;- lx_to_hx(lx)

# convert from px
lx &lt;- px_to_lx(px)
hx &lt;- px_to_hx(px)

# convert from hx
lx &lt;- hx_to_lx(hx)
px &lt;- hx_to_px(hx)

</code></pre>

<hr>
<h2 id='longevity'>Calculate longevity from a matrix population model</h2><span id='topic+longevity'></span>

<h3>Description</h3>

<p>Calculate longevity (the age <em>x</em> at which survivorship for a synthetic
cohort falls below some critical proportion) from a matrix population model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longevity(matU, start = 1L, x_max = 1000, lx_crit = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longevity_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression). Optionally with named rows and
columns indicating the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="longevity_+3A_start">start</code></td>
<td>
<p>The index (or stage name) of the first stage at which the author
considers the beginning of life. Defaults to <code>1</code>. Alternately, a
numeric vector giving the starting population vector (in which case
<code>length(start)</code> must match <code>ncol(matU))</code>. See section
<em>Starting from multiple stages</em>.</p>
</td></tr>
<tr><td><code id="longevity_+3A_x_max">x_max</code></td>
<td>
<p>The maximum age, in units of the MPM projection interval, to
which survivorship will be calculated. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="longevity_+3A_lx_crit">lx_crit</code></td>
<td>
<p>Proportion of initial cohort remaining before all are
considered dead (a value between 0 and 1). Defaults to <code>0.01</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns longevity, the integer age at which expected survivorship
falls below <code>lx_crit</code>. If survivorship doesn't reach <code>lx_crit</code> by
<code>x_max</code>, returns <code>NA</code> and prints a warning message.
</p>


<h3>Starting from multiple stages</h3>

<p>Rather than specifying argument <code>start</code> as a single stage class from
which all individuals start life, it may sometimes be desirable to allow for
multiple starting stage classes. For example, if we want to start our
calculation of longevity from reproductive maturity (i.e., first
reproduction), we should account for the possibility that there may be
multiple stage classes in which an individual could first reproduce.
</p>
<p>To specify multiple starting stage classes, specify argument <code>start</code> as
the desired starting population vector, giving the proportion
of individuals starting in each stage class (the length of <code>start</code>
should match the number of columns in the relevant MPM).
</p>


<h3>Note</h3>

<p>Note that the units of time in returned values are the same as the
(<code>ProjectionInterval</code>) of the MPM.
</p>


<h3>Author(s)</h3>

<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Hal Caswell &lt;hcaswell@whoi.edu&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>
<p>Morris, W. F. &amp; Doak, D. F. 2003. Quantitative Conservation Biology:
Theory and Practice of Population Viability Analysis. Sinauer Associates,
Sunderland, Massachusetts, USA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mature_distrib">mature_distrib</a></code> for calculating the proportion of
individuals achieving reproductive maturity in each stage class.
</p>
<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

longevity(mpm1$matU, start = 2)
longevity(mpm1$matU, start = "small") # equivalent using named life stages
longevity(mpm1$matU, start = 2, lx_crit = 0.05)

# starting from first reproduction
repstages &lt;- repro_stages(mpm1$matF)
n1 &lt;- mature_distrib(mpm1$matU, start = 2, repro_stages = repstages)
longevity(mpm1$matU, start = n1)

</code></pre>

<hr>
<h2 id='mpm_collapse'>Collapse a matrix population model to a smaller number of stages</h2><span id='topic+mpm_collapse'></span>

<h3>Description</h3>

<p>Collapse a matrix population model to a smaller number of stages. For
instance, to compare properties of multiple projection matrices with
different numbers of stages, one might first collapse those matrices to a
standardized set of stages (e.g., propagule, pre-reproductive, reproductive,
and post-reproductive). The transition rates in the collapsed matrix are a
weighted average of the transition rates from the relevant stages of the
original matrix, weighted by the relative proportion of each stage class
expected at the stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_collapse(matU, matF, matC = NULL, collapse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_collapse_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression)</p>
</td></tr>
<tr><td><code id="mpm_collapse_+3A_matf">matF</code></td>
<td>
<p>The sexual component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to sexual reproduction)</p>
</td></tr>
<tr><td><code id="mpm_collapse_+3A_matc">matC</code></td>
<td>
<p>The clonal component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to clonal reproduction).
Defaults to <code>NULL</code>, indicating no clonal reproduction (i.e.,
<code>matC</code> is a matrix of zeros).</p>
</td></tr>
<tr><td><code id="mpm_collapse_+3A_collapse">collapse</code></td>
<td>
<p>A list giving the mapping between stages of the original
matrix and the desired stages of the collapsed matrix (e.g., <code>list(1,
  2:3, 4)</code>). Original stages may be passed as either indices or stage names
corresponding to stage index or name in <code>matU</code>, <code>matF</code> and
<code>matC</code>). Names given to the elements of <code>collapse</code> are used as
stage names in the new, collapsed matrix.
</p>
<p>See <em>Missing Stages</em> for handling of <code>NA</code> within <code>collapse</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements:
</p>
<table>
<tr><td><code>matA</code></td>
<td>
<p>Collapsed projection matrix</p>
</td></tr>
<tr><td><code>matU</code></td>
<td>
<p>Survival component of the collapsed projection matrix</p>
</td></tr>
<tr><td><code>matF</code></td>
<td>
<p>Sexual reproduction component of the collapsed projection
matrix</p>
</td></tr>
<tr><td><code>matC</code></td>
<td>
<p>Clonal reproduction component of the collapsed projection
matrix</p>
</td></tr>
</table>


<h3>Missing Stages</h3>

<p>The collapsed matrix will always be of dimension <code>length(collapse)</code>,
even if one or more elements of the <code>collapse</code> argument is <code>NA</code>
(corresponding to a desired stage of the collapsed matrix that is not present
in the original matrix). In the collapsed matrix, any row/column
corresponding to a missing stage will be coerced to <code>NA</code>.
</p>


<h3>Note</h3>

<p>This method of collapsing a matrix population model preserves the
equilibrium population growth rate (<code class="reqn">lambda</code>) and relative stable
distribution, but is not expected to preserve other traits such as relative
reproductive values, sensitivities, net reproductive rates, life
expectancy, etc.
</p>


<h3>Author(s)</h3>

<p>Rob Salguero-G√≥mez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>William K. Petry &lt;wpetry@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Salguero-Gomez, R. &amp; Plotkin, J. B. 2010. Matrix dimensions bias
demographic inferences: implications for comparative plant demography. The
American Naturalist 176, 710-722. &lt;doi:10.1086/657044&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_standardize">mpm_standardize</a></code>
</p>
<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# check which stages reproductive
repro_stages(matR = mpm1$matF)

# collapse reproductive stages (3 and 4) into single stage
mpm_collapse(
  matU = mpm1$matU, matF = mpm1$matF,
  collapse = list(1, 2, 3:4, 5)
)

# use stage names instead, and name stages in the collapsed matrix
mpm_collapse(
  matU = mpm1$matU, matF = mpm1$matF,
  collapse = list(
    seed = "seed", vegetative = "small",
    flowering = c("medium", "large"),
    dormant = "dormant"
  )
)

</code></pre>

<hr>
<h2 id='mpm_rearrange'>Rearrange stages of a matrix population model to segregate reproductive and
non-reproductive stages</h2><span id='topic+mpm_rearrange'></span>

<h3>Description</h3>

<p>Rearrange stages of a matrix population model so that all inter-reproductive
stages fall in the final rows/columns of the matrix. This is a preparatory
step to collapsing the matrix model into a standardized set of stages (e.g.,
propagule, pre-reproductive, reproductive, and post-reproductive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_rearrange(matU, matF, matC = NULL, repro_stages, matrix_stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_rearrange_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression)</p>
</td></tr>
<tr><td><code id="mpm_rearrange_+3A_matf">matF</code></td>
<td>
<p>The sexual component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to sexual reproduction)</p>
</td></tr>
<tr><td><code id="mpm_rearrange_+3A_matc">matC</code></td>
<td>
<p>The clonal component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to clonal reproduction).
Defaults to <code>NULL</code>, indicating no clonal reproduction (i.e.,
<code>matC</code> is a matrix of zeros).</p>
</td></tr>
<tr><td><code id="mpm_rearrange_+3A_repro_stages">repro_stages</code></td>
<td>
<p>Logical vector of length <code>ncol(matU)</code> indicating
which stages are reproductive. Alternatively, a vector of stage indices or
stage names of the reproductive classes.</p>
</td></tr>
<tr><td><code id="mpm_rearrange_+3A_matrix_stages">matrix_stages</code></td>
<td>
<p>A character vector identifying organized matrix stages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with 6 elements:
</p>
<table>
<tr><td><code>matU</code></td>
<td>
<p>Rearranged survival matrix</p>
</td></tr>
<tr><td><code>matF</code></td>
<td>
<p>Rearranged sexual reproduction matrix</p>
</td></tr>
<tr><td><code>matC</code></td>
<td>
<p>Rearranged clonal reproduction matrix</p>
</td></tr>
<tr><td><code>matrix_stages</code></td>
<td>
<p>Rearranged vector of organized matrix stages</p>
</td></tr>
<tr><td><code>repro_stages</code></td>
<td>
<p>Rearranged logical vector of reproductive stages</p>
</td></tr>
<tr><td><code>nonRepInterRep</code></td>
<td>
<p>Numeric index for any rearranged inter-reproductive
stages</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob Salguero-G√≥mez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_standardize">mpm_standardize</a></code>
</p>
<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0, 0),
  c(0, 0.3, 0.3, 0.1, 0),
  c(0, 0, 0.4, 0.4, 0.1),
  c(0, 0, 0, 0.1, 0.4)
)

matF &lt;- rbind(
  c(0, 1.1, 0, 1.6, 0),
  c(0, 0.8, 0, 0.4, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0)
)

repro_stages &lt;- c(2, 4)
matrix_stages &lt;- c("prop", "active", "active", "active", "active")

mpm_rearrange(matU, matF,
  repro_stages = repro_stages,
  matrix_stages = matrix_stages
)

</code></pre>

<hr>
<h2 id='mpm_split'>Convert matrix population model into U, F and C matrices</h2><span id='topic+mpm_split'></span>

<h3>Description</h3>

<p>Splits a matrix population model into three constituent matrices, <b>U</b>
(growth and survival processes), <b>F</b> (sexual reproduction) and <b>C</b>
(clonal reproduction). <strong>Warning!</strong> The functionality is very basic: it
assumes that sexual reproduction is located in the top row of the matrix, and
that everything else is growth or survival (i.e. the <b>U</b> matrix).
Clonality is assumed to be non-existent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_split(matA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_split_+3A_mata">matA</code></td>
<td>
<p>A matrix population model (i.e., a square projection matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three matrices: <code>matU</code>,<code>matF</code> and <code>matC</code>.
<code>matC</code> will always contain only zeros.
</p>


<h3>Author(s)</h3>

<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>


<h3>See Also</h3>

<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matA &lt;- rbind(
  c(0.1, 0, 5.3, 4.2),
  c(0.5, 0.2, 0.1, 0),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.6)
)

mpm_split(matA)

</code></pre>

<hr>
<h2 id='mpm_standardize'>Transform a matrix population model to a standardized form</h2><span id='topic+mpm_standardize'></span><span id='topic+mpm_standardise'></span>

<h3>Description</h3>

<p>Transform a matrix population model to a standardized set of stage classes
(e.g., propagule, pre-reproductive, reproductive, and post-reproductive). The
transition rates in the standardized matrix are a weighted mean of the
transition rates and per-capita reproductive values from the relevant stages
of the original matrix, weighted by the relative proportion of each stage
class expected at the stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_standardize(matU, matF, matC = NULL, repro_stages, matrix_stages)

mpm_standardise(matU, matF, matC = NULL, repro_stages, matrix_stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_standardize_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.
progression, stasis, and retrogression).</p>
</td></tr>
<tr><td><code id="mpm_standardize_+3A_matf">matF</code></td>
<td>
<p>The sexual component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to sexual reproduction).</p>
</td></tr>
<tr><td><code id="mpm_standardize_+3A_matc">matC</code></td>
<td>
<p>The clonal component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to clonal reproduction).
Defaults to <code>NULL</code>, indicating no clonal reproduction (i.e.,
<code>matC</code> is a matrix of zeros).</p>
</td></tr>
<tr><td><code id="mpm_standardize_+3A_repro_stages">repro_stages</code></td>
<td>
<p>Logical vector of length <code>ncol(matU)</code> indicating
which stages are reproductive. Alternatively, a vector of stage indices or
stage names of the reproductive classes.</p>
</td></tr>
<tr><td><code id="mpm_standardize_+3A_matrix_stages">matrix_stages</code></td>
<td>
<p>Character vector of matrix stage types (e.g.,
&quot;propagule&quot;, &quot;active&quot;, or &quot;dormant&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the functions
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a></code>, <code><a href="#topic+standard_stages">standard_stages</a></code> and
<code><a href="#topic+mpm_collapse">mpm_collapse</a></code>, which it calls in sequence.
</p>


<h3>Value</h3>

<p>A list with four elements reflecting the standardized matrix and
its components:
</p>
<table>
<tr><td><code>matA</code></td>
<td>
<p>Standardized projection matrix</p>
</td></tr>
<tr><td><code>matU</code></td>
<td>
<p>Survival component of the standardized projection matrix</p>
</td></tr>
<tr><td><code>matF</code></td>
<td>
<p>Sexual reproduction component of the standardized projection
matrix</p>
</td></tr>
<tr><td><code>matC</code></td>
<td>
<p>Clonal reproduction component of the standardized projection
matrix</p>
</td></tr>
</table>


<h3>Missing Stages</h3>

<p>The returned standardized matrix will always be of dimension <code>4</code>, even
if one or more standardized stages is missing from the original matrix
population model. If a standardized stage is missing, the corresponding
row/column of the standardized matrix will be coerced to <code>NA</code>.
</p>


<h3>Note</h3>

<p>The method used by this function to collapse a matrix population model
preserves the equilibrium population growth rate (<code class="reqn">\lambda</code>) and
relative stable distribution, but is not expected to preserve other
demographic characteristics such as relative reproductive value,
sensitivities, net reproductive rate, life expectancy, etc.
</p>


<h3>Author(s)</h3>

<p>Rob Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>


<h3>See Also</h3>

<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0, 0),
  c(0, 0.3, 0.3, 0.1, 0),
  c(0, 0, 0.4, 0.4, 0.1),
  c(0, 0, 0, 0.1, 0.4)
)

matF &lt;- rbind(
  c(0, 1.1, 0, 1.6, 0),
  c(0, 0.8, 0, 0.4, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0)
)

matC &lt;- rbind(
  c(0, 0.6, 0, 0.5, 0),
  c(0, 0.1, 0, 0.3, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0)
)

repro_stages &lt;- c(2, 4)
matrix_stages &lt;- c("prop", "active", "active", "active", "active")

mpm_standardize(matU, matF, matC, repro_stages, matrix_stages)

</code></pre>

<hr>
<h2 id='mpm_to_table'>Generate a life table from a matrix population model</h2><span id='topic+mpm_to_table'></span>

<h3>Description</h3>

<p>This function uses age-from-stage decomposition methods to generate a life
table from a matrix population model. A detailed description of these methods
can be found in section 5.3 &quot;Age-specific traits from stage-specific models&quot;
of Caswell (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_to_table(
  matU,
  matF = NULL,
  matC = NULL,
  start = 1L,
  xmax = 1000,
  lx_crit = 0.01,
  radix = 1,
  remove_final = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_to_table_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and/or retrogression). Optionally with named rows and
columns indicating the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_matf">matF</code></td>
<td>
<p>(Optional) The sexual component of a matrix population model
(i.e., a square projection matrix reflecting transitions due to sexual
reproduction). Optionally with named rows and columns indicating the
corresponding life stage names.</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_matc">matC</code></td>
<td>
<p>(Optional) The clonal component of a matrix population model
(i.e., a square projection matrix reflecting transitions due to clonal
reproduction). Optionally with named rows and columns indicating the
corresponding life stage names.</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_start">start</code></td>
<td>
<p>The index (or stage name) of the first stage at which the author
considers the beginning of life. Defaults to <code>1</code>. Alternately, a
numeric vector giving the starting population vector (in which case
<code>length(start)</code> must match <code>ncol(matU))</code>. See section
<em>Starting from multiple stages</em>.</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_xmax">xmax</code></td>
<td>
<p>Maximum age to which the life table will be calculated (defaults
to <code>1000</code>). Time steps are in the same units as the matrix population
model (see MatrixPeriodicity metadata variable COM(P)ADRE).</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_lx_crit">lx_crit</code></td>
<td>
<p>Minimum value of lx to which age-specific traits will be
calculated (defaults to <code>0.01</code>).</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_radix">radix</code></td>
<td>
<p>The starting number of individuals in the synthetic life table
(defaults to <code>1</code>). If <code>radix</code> is set to 1, a simplified life
table is produced.</p>
</td></tr>
<tr><td><code id="mpm_to_table_+3A_remove_final">remove_final</code></td>
<td>
<p>Life table calculations typically assume that the final
age class is closed and that all individuals die in that age class. This
can mean that mortality/hazard is artificially inflated for this age class.
Users can prevent this by setting 'remove_final' to 'TRUE' (the default is
'FALSE').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing a variable number columns, depending
on input variables. Columns include:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>age at the start of the age interval <code>[x, x+1)</code></p>
</td></tr>
<tr><td><code>Nx</code></td>
<td>
<p>The number of individuals alive at age x. The initial number is
set with <code>radix</code></p>
</td></tr>
<tr><td><code>Dx</code></td>
<td>
<p>proportion of original cohort dying during the age interval
<code>[x, x+1)</code></p>
</td></tr>
<tr><td><code>lx</code></td>
<td>
<p>survivorship, defined as the proportion of initial cohort
surviving to the start of age interval <code>[x, x+1)</code></p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>proportion of original cohort dying in the age interval <code>[x,
  x+1)</code></p>
</td></tr>
<tr><td><code>ax</code></td>
<td>
<p>The average time survived within the interval by those that die
during the age interval <code>[x, x+1)</code>. Assumed to be 0.5</p>
</td></tr>
<tr><td><code>hx</code></td>
<td>
<p>force of mortality (hazard) during the age interval <code>[x,
  x+1)</code></p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>probability of death during the interval <code>[x, x+1)</code> for
those entering the interval</p>
</td></tr>
<tr><td><code>px</code></td>
<td>
<p>probability of survival for the interval <code>[x, x+1)</code> for
those entering the interval</p>
</td></tr>
<tr><td><code>Lx</code></td>
<td>
<p>total person-years lived during the interval <code>[x, x+1)</code></p>
</td></tr>
<tr><td><code>Tx</code></td>
<td>
<p>total person years lived beyond age x</p>
</td></tr>
<tr><td><code>ex</code></td>
<td>
<p>remaining life expectancy at age x</p>
</td></tr>
</table>
<p>If <code>matF</code> is provided, also includes:
</p>
<table>
<tr><td><code>mx</code></td>
<td>
<p>per-capita rate of sexual reproduction during the interval
<code>[x, x+1)</code> </p>
</td></tr>
<tr><td><code>lxmx</code></td>
<td>
<p>expected number of sexual offspring per original
cohort member produced during the interval <code>[x, x+1)</code></p>
</td></tr>
</table>
<p>If <code>matC</code> is provided, also includes:
</p>
<table>
<tr><td><code>cx</code></td>
<td>
<p>per-capita rate of clonal reproduction  during the interval
<code>[x, x+1)</code></p>
</td></tr>
<tr><td><code>lxcx</code></td>
<td>
<p>expected number of clonal offspring per original
cohort member produced during the interval <code>[x, x+1)</code></p>
</td></tr>
</table>
<p>If both <code>matF</code> and <code>matC</code> are provided, also includes:
</p>
<table>
<tr><td><code>mxcx</code></td>
<td>
<p>per-capita rate of total reproduction (sexual + clonal) during
the interval <code>[x, x+1)</code></p>
</td></tr>
<tr><td><code>lxmxcx</code></td>
<td>
<p>expected number of total offspring (sexual + clonal) per
original cohort member produced during the interval <code>[x, x+1)</code></p>
</td></tr>
</table>


<h3>Starting from multiple stages</h3>

<p>Rather than specifying argument
<code>start</code> as a single stage class from which all individuals start life,
it may sometimes be desirable to allow for multiple starting stage classes.
For example, if the user wants to start the calculation of age-specific
traits from reproductive maturity (i.e., first reproduction), the user
should account for the possibility that there may be multiple stage classes
in which an individual could first reproduce.
</p>
<p>To specify multiple starting stage classes, specify argument <code>start</code> as
the desired starting population vector (<strong>n1</strong>), giving the proportion
of individuals starting in each stage class (the length of <code>start</code>
should match the number of columns in the relevant MPM).
</p>
<p>See function <code><a href="#topic+mature_distrib">mature_distrib</a></code> for calculating the proportion of
individuals achieving reproductive maturity in each stage class.
</p>


<h3>Note</h3>

<p>The life table is calculated recursively until the age class (x)
reaches <code>xmax</code> or survivorship (lx) falls below <code>lx_crit</code> ‚Äî
whichever comes first. To force calculation to <code>xmax</code>, set
<code>lx_crit = 0</code>. Conversely, to force calculation to <code>lx_crit</code>, set
<code>xmax = Inf</code>.
</p>
<p>The life table calculations assume that the final age interval is
closed and that all remaining individuals die in this interval. Therefore,
for this interval, the probability of death <code>qx</code> is 1, the probability
of survival <code>px</code> is 0 and, because we assume that deaths are evenly
distributed during the interval, the remaining life expectancy for
individuals at the start of the interval is 0.5. Depending on analyses, it
may be a good idea to remove the final row of the table.
</p>
<p>If <code>lx_crit</code> is sufficiently small that only a very small proportion
of the cohort reach this age (i.e., &lt; 0.05), this should have minimal
impact on results. Nevertheless, for many analyses, the final row of the
life table should be treated with caution and perhaps removed from
subsequent analyses.
</p>
<p>Note that the units of time (e.g.. 'x' and 'ex') in the returned life
table are the same as the projection interval ('ProjectionInterval') of the
MPM.
</p>


<h3>Author(s)</h3>

<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>
<p>Roberto Salguero-G√≥mez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Hal Caswell &lt;h.caswell@uva.nl&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction, Analysis, and
Interpretation. Sinauer Associates; 2nd edition. ISBN: 978-0878930968
</p>
<p>Caswell, H. 2006. Applications of Markov chains in demography. pp. 319-334 in
A.N. Langville and W.J. Stewart (editors) MAM2006: Markov Anniversary
Meeting. Boson Books, Raleigh, North Caroline, USA
</p>
<p>Horvitz, C. &amp; Tuljapurkar, S. 2008. Stage dynamics, period survival, and
mortality plateaus. The American Naturalist 172: 203-2015.
&lt;doi:10.1086/589453&gt;
</p>
<p>Jones, O. R., Scheuerlein, A., Salguero-Gomez, R., Camarda, C. G., Schaible,
R., Casper, B. B., Dahlgren, J. P., Ehrl√©n, J., Garc√≠a, M. B., Menges, E.,
Quintana-Ascencio, P. F., Caswell, H., Baudisch, A. &amp; Vaupel, J. 2014.
Diversity of ageing across the tree of life. Nature 505, 169-173.
&lt;doi:10.1038/nature12789&gt;
</p>
<p>Jones O. R. 2021. Life tables: Construction and interpretation In:
Demographic Methods Across the Tree of Life. Edited by Salguero-Gomez R &amp;
Gamelon M. Oxford University Press. Oxford, UK. ISBN: 9780198838609
</p>
<p>Preston, S., Heuveline, P., &amp; Guillot, M. 2000. Demography: Measuring and
Modeling Population Processes. Wiley. ISBN: 9781557864512
</p>


<h3>See Also</h3>

<p>Other life tables: 
<code><a href="#topic+age_from_stage">age_from_stage</a></code>,
<code><a href="#topic+lifetable_convert">lifetable_convert</a></code>,
<code><a href="#topic+qsd_converge">qsd_converge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

mpm_to_table(matU = mpm1$matU, start = 2, xmax = 15)

# equivalent using named life stages
mpm_to_table(matU = mpm1$matU, start = "small", xmax = 15)
mpm_to_table(matU = mpm1$matU, matF = mpm1$matF, start = 2, xmax = 15)

### starting from first reproduction
repStages &lt;- repro_stages(mpm1$matF)
n1 &lt;- mature_distrib(matU = mpm1$matU, start = 2, repro_stages = repStages)
mpm_to_table(matU = mpm1$matU, start = n1)
</code></pre>

<hr>
<h2 id='mpm1'>Example matrix population model (MPM)</h2><span id='topic+mpm1'></span>

<h3>Description</h3>

<p>An example matrix population model (MPM) used for demonstration and testing
purposes. The MPM consists of five stage classes: 'seed', 'small', 'medium',
'large', and 'dormant'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm1
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>

<dl>
<dt>matU</dt><dd><p>The survival-related component of the MPM.</p>
</dd>
<dt>matF</dt><dd><p>The sexual reproduction component of the MPM.</p>
</dd>
</dl>


<hr>
<h2 id='name_stages'>Add stage names to matrices</h2><span id='topic+name_stages'></span>

<h3>Description</h3>

<p>Adds user-supplied or automatically-generated stage names to a matrix
population model (MPM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_stages(mat, names = NULL, prefix = "stage_", left_pad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_stages_+3A_mat">mat</code></td>
<td>
<p>An MPM, either as a single matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="name_stages_+3A_names">names</code></td>
<td>
<p>A character vector specifying the name of each life stage, in
order. If provided, <code>prefix</code> and <code>left_pad</code> arguments are
ignored.</p>
</td></tr>
<tr><td><code id="name_stages_+3A_prefix">prefix</code></td>
<td>
<p>A string to be pre-pended to the stage number when
automatically naming stages. Defaults to <code>stage_</code>.</p>
</td></tr>
<tr><td><code id="name_stages_+3A_left_pad">left_pad</code></td>
<td>
<p>Logical, whether to pre-pend <code>0</code> to stage names such
that all stage numbers have equal length, enabling lexicographic sorting.
For example, stage <code>1</code> becomes <code>01</code> for matrices with 10-99
stages, <code>001</code> for matrices with 100-999 stages, and so on. Defaults to
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input matrix or matrices with named rows and columns.
</p>


<h3>Author(s)</h3>

<p>William K. Petry &lt;wpetry@ncsu.edu&gt;
</p>


<h3>See Also</h3>

<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.0, 0.0, 0.0),
  c(0.3, 0.1, 0.0),
  c(0.0, 0.5, 0.8)
)
# (semi)automated naming
name_stages(matU)
name_stages(matU, prefix = "s")
# custom stage names
name_stages(matU, names = c("small", "medium", "large"))
# overwrite existing stage names
data(mpm1)
name_stages(mpm1)

</code></pre>

<hr>
<h2 id='net_repro_rate'>Calculate net reproductive rate (R0) from a matrix population model</h2><span id='topic+net_repro_rate'></span>

<h3>Description</h3>

<p>Calculate net reproductive rate (R0) from a matrix population model. The net
reproduction rate (R0) is the mean number of recruits produced during the
mean life expectancy of an individual. See section 5.3.5 of Caswell (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_repro_rate(matU, matR, start = 1, method = "generation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_repro_rate_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.
progression, stasis, and retrogression). Optionally with named rows and
columns indicating the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="net_repro_rate_+3A_matr">matR</code></td>
<td>
<p>The fertility component of a matrix population model.</p>
</td></tr>
<tr><td><code id="net_repro_rate_+3A_start">start</code></td>
<td>
<p>Index (or stage name) of the first stage at which the author
considers the beginning of life. Only used if <code>method = "start"</code>.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="net_repro_rate_+3A_method">method</code></td>
<td>
<p>The method used to calculate net reproductive rate, either
<code>"generation"</code> or <code>"start"</code>. Defaults to <code>"generation"</code>.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument controls how net reproductive rate is calculated.
</p>
<p>If <code>method = "generation"</code>, net reproductive rate is calculated as the
per-generation population growth rate (i.e., the dominant eigenvalue of
<code>matR %*% N</code>, where <code>N</code> is the fundamental matrix). See Caswell
(2001) Section 5.3.4.
</p>
<p>If <code>method = "start"</code>, net reproductive rate is calculated as the
expected lifetime production of offspring that start life in stage
<code>start</code>, by an individual also starting life in stage <code>start</code>
(i.e., <code>(matR %*% N)[start,start]</code>).
</p>
<p>If offspring only arise in stage <code>start</code>, the two methods give the
same result.
</p>


<h3>Value</h3>

<p>Returns the net reproductive rate. If <code>matU</code> is singular (often
indicating infinite life expectancy), returns <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Hal Caswell &lt;h.caswell@uva.nl&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

net_repro_rate(mpm1$matU, mpm1$matF)

# calculate R0 using the start method, specifying either the life stage index
# or name
net_repro_rate(mpm1$matU, mpm1$matF, method = "start", start = 2)
net_repro_rate(mpm1$matU, mpm1$matF, method = "start", start = "small")

</code></pre>

<hr>
<h2 id='perturb_matrix'>Perturbation analysis of a matrix population model</h2><span id='topic+perturb_matrix'></span>

<h3>Description</h3>

<p>Perturbs elements within a matrix population model and measures the response
(sensitivity or elasticity) of the per-capita population growth rate at
equilibrium (<code class="reqn">\lambda</code>), or, with a user-supplied function, any other
demographic statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb_matrix(
  matA,
  pert = 1e-06,
  type = "sensitivity",
  demog_stat = "lambda",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_matrix_+3A_mata">matA</code></td>
<td>
<p>A matrix population model (i.e., a square projection matrix).</p>
</td></tr>
<tr><td><code id="perturb_matrix_+3A_pert">pert</code></td>
<td>
<p>Magnitude of the perturbation. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="perturb_matrix_+3A_type">type</code></td>
<td>
<p>Whether to return <code>sensitivity</code> or <code>elasticity</code> values.</p>
</td></tr>
<tr><td><code id="perturb_matrix_+3A_demog_stat">demog_stat</code></td>
<td>
<p>The demographic statistic to be used, as in &quot;the
sensitivity/elasticity of <code>demog_stat</code> to matrix element
perturbations.&quot; Defaults to the per-capita population growth rate at
equilibrium (<code class="reqn">\lambda</code>). Also accepts a user-supplied function that
performs a calculation on a projection matrix and returns a single numeric
value.</p>
</td></tr>
<tr><td><code id="perturb_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code>demog_stat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sensitivity or elasticity matrix.
</p>


<h3>Author(s)</h3>

<p>Rob Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>


<h3>See Also</h3>

<p>Other perturbation analysis: 
<code><a href="#topic+perturb_stochastic">perturb_stochastic</a>()</code>,
<code><a href="#topic+perturb_trans">perturb_trans</a>()</code>,
<code><a href="#topic+perturb_vr">perturb_vr</a>()</code>,
<code><a href="#topic+pop_vectors">pop_vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matA &lt;- rbind(
  c(0.1, 0, 1.5, 4.6),
  c(0.5, 0.2, 0.1, 0),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.6)
)

perturb_matrix(matA)

# use a larger perturbation than the default
perturb_matrix(matA, pert = 0.01)

# calculate the sensitivity/elasticity of the damping ratio to perturbations
damping &lt;- function(matA) { # define function for damping ratio
  eig &lt;- eigen(matA)$values
  dm &lt;- rle(Mod(eig))$values
  return(dm[1] / dm[2])
}

perturb_matrix(matA, demog_stat = "damping")

</code></pre>

<hr>
<h2 id='perturb_stochastic'>Calculate stochastic elasticities from a time-series of matrix population
models and corresponding population vectors</h2><span id='topic+perturb_stochastic'></span>

<h3>Description</h3>

<p>Calculate stochastic elasticities given a time-series of matrix population
models and corresponding population vectors, using the method described in
Haridas et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb_stochastic(X_t, u_t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_stochastic_+3A_x_t">X_t</code></td>
<td>
<p>A list of matrix population models</p>
</td></tr>
<tr><td><code id="perturb_stochastic_+3A_u_t">u_t</code></td>
<td>
<p>A list of corresponding population vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three matrices:
</p>
<table>
<tr><td><code>E</code></td>
<td>
<p>matrix of stochastic elasticities</p>
</td></tr>
<tr><td><code>E_mu</code></td>
<td>
<p>matrix of stochastic elasticities to mean transition rates</p>
</td></tr>
<tr><td><code>E_sigma</code></td>
<td>
<p>matrix of stochastic elasticities to the variance in
transition rates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haridas, C. V., Tuljapurkar, S., &amp; Coulson, T. 2009. Estimating
stochastic elasticities directly from longitudinal data. Ecology Letters,
12, 806-812. &lt;doi:10.1111/j.1461-0248.2009.01330.x&gt;
</p>


<h3>See Also</h3>

<p>Other perturbation analysis: 
<code><a href="#topic+perturb_matrix">perturb_matrix</a>()</code>,
<code><a href="#topic+perturb_trans">perturb_trans</a>()</code>,
<code><a href="#topic+perturb_vr">perturb_vr</a>()</code>,
<code><a href="#topic+pop_vectors">pop_vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate list of random MPMs
N &lt;- 20 # number of years
s &lt;- 3 # matrix dimension
X &lt;- list() # matrix population model at time t
u &lt;- list() # population vector at time t

for (t in 1:N) {
  X[[t]] &lt;- matrix(runif(s^2), nrow = s, ncol = s)
}

# derive corresponding series of population vectors
u &lt;- pop_vectors(X)

# calculate stochastic elasticities
perturb_stochastic(X, u)

</code></pre>

<hr>
<h2 id='perturb_trans'>Perturbation analysis of transition types within a matrix population model</h2><span id='topic+perturb_trans'></span>

<h3>Description</h3>

<p>Calculates the summed sensitivities or elasticities for various
transition types within a matrix population model (MPM), including stasis,
retrogression, progression, fecundity, and clonality.
</p>
<p>Sensitivities or elasticities are calculated by perturbing elements of the
MPM and measuring the response of the per-capita population growth rate at
equilibrium (<code class="reqn">\lambda</code>), or, with a user-supplied function, any other
demographic statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb_trans(
  matU,
  matF,
  matC = NULL,
  posU = matU &gt; 0,
  posF = matF &gt; 0,
  posC = matC &gt; 0,
  exclude_row = NULL,
  exclude_col = NULL,
  pert = 1e-06,
  type = "sensitivity",
  demog_stat = "lambda",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_trans_+3A_matu">matU</code></td>
<td>
<p>The survival component submatrix of a MPM (i.e., a square
projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression).</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_matf">matF</code></td>
<td>
<p>The sexual component submatrix of a MPM (i.e., a square
projection matrix reflecting transitions due to sexual reproduction).</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_matc">matC</code></td>
<td>
<p>The clonal component submatrix of a MPM (i.e., a square
projection matrix reflecting transitions due to clonal reproduction).
Defaults to <code>NULL</code>, indicating no clonal reproduction possible.</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_posu">posU</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matU</code>, with
elements indicating whether a given <code>matU</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matU &gt; 0</code> (see
Details).</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_posf">posF</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matF</code>, with
elements indicating whether a given <code>matF</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matF &gt; 0</code> (see
Details).</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_posc">posC</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matC</code>, with
elements indicating whether a given <code>matC</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matC &gt; 0</code> (see
Details).</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_exclude_row">exclude_row</code></td>
<td>
<p>A vector of row indices or stages names indicating stages
for which transitions <em>to</em> the stage should be excluded from
perturbation analysis. Alternatively, a logical vector of length
<code>nrow(matU)</code> indicating which stages to include <code>TRUE</code> or exclude
<code>FALSE</code> from the calculation. See section <em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_exclude_col">exclude_col</code></td>
<td>
<p>A vector of column indices or stages names indicating
stages for which transitions <em>to</em> the stage should be excluded from
perturbation analysis. Alternatively, a logical vector of length
<code>ncol(matU)</code> indicating which stages to include <code>TRUE</code> or exclude
<code>FALSE</code> from the calculation. See section <em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_pert">pert</code></td>
<td>
<p>The magnitude of the perturbation (defaults to <code>1e-6</code>).</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_type">type</code></td>
<td>
<p>An argument defining whether to return 'sensitivity' or
'elasticity' values. Defaults to 'sensitivity'.</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_demog_stat">demog_stat</code></td>
<td>
<p>An argument defining which demographic statistic should be
used, as in &quot;the sensitivity/elasticity of <code>demog_stat</code> to matrix
element perturbations.&quot; Defaults to the per-capita population growth rate
at equilibrium (<code class="reqn">lambda</code>). Also accepts a user-supplied function that
performs a calculation on a MPM and returns a single numeric value.</p>
</td></tr>
<tr><td><code id="perturb_trans_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code>demog_stat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A transition rate of <code>0</code> within a matrix population model can
either indicate that the transition is not possible in the given life cycle
(e.g., tadpoles never revert to eggs), or that the transition is possible but
was estimated to be <code>0</code> in the relevant population and time period.
Because transition rates of zero <em>do</em> generally yield non-zero
sensitivities, it is important to distinguish between structural (i.e.
impossible) zeros and sampled zeros when summing multiple sensitivities for a
given process (e.g., progression/growth).
</p>
<p>By default, the <code>perturb_</code> functions assume that a transition rate of
<code>0</code> indicates an impossible transition, in which case the sensitivity
for that transition will not be included in any calculation. Specifically,
the arguments <code>posX</code> are specified by the logical expression <code>(matX
&gt; 0)</code>. If the matrix population model includes transitions that are possible
but estimated to be <code>0</code>, users should specify the <code>posX</code>
argument(s) manually.
</p>
<p>If there are no possible transitions for a given process (e.g., clonality, in
many species), the value of sensitivity or elasticity returned for that
process will be <code>NA</code>.
</p>


<h3>Value</h3>

<p>A list with 5 elements: </p>
<table>
<tr><td><code>stasis</code></td>
<td>
<p>The sensitivity or elasticity
of <code>demog_stat</code> to stasis.</p>
</td></tr> <tr><td><code>retrogression</code></td>
<td>
<p>The sensitivity or
elasticity of <code>demog_stat</code> to retrogression.</p>
</td></tr> <tr><td><code>progression</code></td>
<td>
<p>The
sensitivity or elasticity of <code>demog_stat</code> to progression.</p>
</td></tr>
<tr><td><code>fecundity</code></td>
<td>
<p>The sensitivity or elasticity of <code>demog_stat</code> to
sexual fecundity.</p>
</td></tr> <tr><td><code>clonality</code></td>
<td>
<p>The sensitivity or elasticity of
<code>demog_stat</code> to clonality.</p>
</td></tr>
</table>


<h3>Excluding stages</h3>

<p>It may be desirable to exclude one or more stages
from the calculation. For instance, we might not believe that 'progression'
to a dormant stage class truly reflects progression. In this case we could
exclude transitions <em>to</em> the dormant stage class using the argument
<code>exclude_row</code>. We may or may not want to ignore progression
transitions <em>from</em> the dormant stage class, which can be done in a
similar way using the argument <code>exclude_col</code>. The <code>exclude_</code>
arguments simply set the relevant row or column of the <code>posX</code>
arguments to <code>FALSE</code>, to prevent those transitions from being used in
subsequent calculations.
</p>


<h3>Author(s)</h3>

<p>Rob Salguero-G√≥mez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Other perturbation analysis: 
<code><a href="#topic+perturb_matrix">perturb_matrix</a>()</code>,
<code><a href="#topic+perturb_stochastic">perturb_stochastic</a>()</code>,
<code><a href="#topic+perturb_vr">perturb_vr</a>()</code>,
<code><a href="#topic+pop_vectors">pop_vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.6)
)

matF &lt;- rbind(
  c(0, 0, 1.1, 1.6),
  c(0, 0, 0.8, 0.4),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)


perturb_trans(matU, matF)

# Use a larger perturbation than the default of 1e-6.
perturb_trans(matU, matF, pert = 0.01)

# Calculate the sensitivity/elasticity of the damping ratio to perturbations.
# First, define function for damping ratio:
damping &lt;- function(matA) {
  eig &lt;- eigen(matA)$values
  dm &lt;- rle(Mod(eig))$values
  return(dm[1] / dm[2])
}

# Second, run the perturbation analysis using demog_stat = "damping".
perturb_trans(matU, matF, demog_stat = "damping")

</code></pre>

<hr>
<h2 id='perturb_vr'>Perturbation analysis of vital rates in a matrix population model</h2><span id='topic+perturb_vr'></span>

<h3>Description</h3>

<p>Perturbs lower-level vital rates within a matrix population model and
measures the response (sensitivity or elasticity) of the per-capita
population growth rate at equilibrium (<code class="reqn">\lambda</code>), or, with a
user-supplied function, any other demographic statistic.
</p>
<p>These decompositions assume that all transition rates are products of a
stage-specific survival term (column sums of <code>matU</code>) and a lower level
vital rate that is conditional on survival (growth, shrinkage, stasis,
dormancy, or reproduction). Reproductive vital rates that are not conditional
on survival (i.e., within a stage class from which there is no survival) are
also allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb_vr(
  matU,
  matF,
  matC = NULL,
  pert = 1e-06,
  type = "sensitivity",
  demog_stat = "lambda",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_vr_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression).</p>
</td></tr>
<tr><td><code id="perturb_vr_+3A_matf">matF</code></td>
<td>
<p>The sexual component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to sexual reproduction).</p>
</td></tr>
<tr><td><code id="perturb_vr_+3A_matc">matC</code></td>
<td>
<p>The clonal component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to clonal reproduction).
Defaults to <code>NULL</code>, indicating no clonal reproduction (i.e.,
<code>matC</code> is a matrix of zeros).</p>
</td></tr>
<tr><td><code id="perturb_vr_+3A_pert">pert</code></td>
<td>
<p>Magnitude of the perturbation. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="perturb_vr_+3A_type">type</code></td>
<td>
<p>Whether to return <code>sensitivity</code> or <code>elasticity</code> values.
Defaults to <code>sensitivity</code>.</p>
</td></tr>
<tr><td><code id="perturb_vr_+3A_demog_stat">demog_stat</code></td>
<td>
<p>The demographic statistic to be used, as in &quot;the
sensitivity/elasticity of <code>demog_stat</code> to vital rate perturbations.&quot;
Defaults to the per-capita population growth rate at equilibrium
(<code class="reqn">\lambda</code>). Also accepts a user-supplied function that performs a
calculation on a projection matrix and returns a single numeric value.</p>
</td></tr>
<tr><td><code id="perturb_vr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function <code>demog_stat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 5 elements:
</p>
<table>
<tr><td><code>survival</code></td>
<td>
<p>sensitivity or elasticity of <code>demog_stat</code> to survival</p>
</td></tr>
<tr><td><code>growth</code></td>
<td>
<p>sensitivity or elasticity of <code>demog_stat</code> to growth</p>
</td></tr>
<tr><td><code>shrinkage</code></td>
<td>
<p>sensitivity or elasticity of <code>demog_stat</code> to shrinkage</p>
</td></tr>
<tr><td><code>fecundity</code></td>
<td>
<p>sensitivity or elasticity of <code>demog_stat</code> to sexual
fecundity</p>
</td></tr>
<tr><td><code>clonality</code></td>
<td>
<p>sensitivity or elasticity of <code>demog_stat</code> to clonality</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Other perturbation analysis: 
<code><a href="#topic+perturb_matrix">perturb_matrix</a>()</code>,
<code><a href="#topic+perturb_stochastic">perturb_stochastic</a>()</code>,
<code><a href="#topic+perturb_trans">perturb_trans</a>()</code>,
<code><a href="#topic+pop_vectors">pop_vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.6)
)

matF &lt;- rbind(
  c(0, 0, 1.1, 1.6),
  c(0, 0, 0.8, 0.4),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

perturb_vr(matU, matF)

# use elasticities rather than sensitivities
perturb_vr(matU, matF, type = "elasticity")

# use a larger perturbation than the default
perturb_vr(matU, matF, pert = 0.01)

# calculate the sensitivity/elasticity of the damping ratio to vital rate
#  perturbations
damping &lt;- function(matA) { # define function for damping ratio
  eig &lt;- eigen(matA)$values
  dm &lt;- rle(Mod(eig))$values
  return(dm[1] / dm[2])
}

perturb_vr(matU, matF, demog_stat = "damping")

</code></pre>

<hr>
<h2 id='plot_life_cycle'>Plot a life cycle diagram from a matrix population model</h2><span id='topic+plot_life_cycle'></span>

<h3>Description</h3>

<p>Plots the life cycle diagram illustrated by a matrix population model. This
function processes the matrix model and passes the information to the
graphViz function in DiagrammeR. See
<a href="http://rich-iannone.github.io/DiagrammeR/">http://rich-iannone.github.io/DiagrammeR/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_life_cycle(
  matA,
  stages,
  title = NULL,
  shape = "egg",
  fontsize = 10,
  nodefontsize = 12,
  edgecol = "grey",
  node_order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_life_cycle_+3A_mata">matA</code></td>
<td>
<p>A matrix population model (i.e., a square projection matrix)</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_stages">stages</code></td>
<td>
<p>Optional vector of stage class labels. If missing, it first
attempts to infer them from <code>dimnames(matA)</code>. If these are also
<code>NULL</code>, then reverts to integers <code>1:ncol(A)</code>.</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_title">title</code></td>
<td>
<p>Optional title for the plot. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_shape">shape</code></td>
<td>
<p>The shape to be used for the stages of the diagram. Any node
shape accepted by <code>graphViz</code> is acceptable.</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_fontsize">fontsize</code></td>
<td>
<p>Size of the font used in the diagram.</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_nodefontsize">nodefontsize</code></td>
<td>
<p>Size of the font used in the node part of the diagram.</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_edgecol">edgecol</code></td>
<td>
<p>Colour of the arrows in the diagram.</p>
</td></tr>
<tr><td><code id="plot_life_cycle_+3A_node_order">node_order</code></td>
<td>
<p>An optional numeric vector giving the order that the nodes
should be presented in the plot. Default is 'NULL' whereby the order is the
same as 'stages', or row/column names, of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grViz</code> representing the life cycle diagram
</p>


<h3>Author(s)</h3>

<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matA &lt;- rbind(
  c(0.1, 0, 0, 0, 1.4),
  c(0.5, 0.2, 0, 0, 0),
  c(0, 0.3, 0.3, 0, 0),
  c(0, 0, 0.4, 0.4, 0.1),
  c(0, 0, 0, 0.1, 0.4)
)

plot_life_cycle(matA)

# Change the order of the nodes and give them names
plot_life_cycle(matA,
  stages = c("A", "B", "C", "D", "E"),
  node_order = 5:1
)

</code></pre>

<hr>
<h2 id='pop_vectors'>Derive a hypothetical set of population vectors corresponding to a
time-series of matrix population models</h2><span id='topic+pop_vectors'></span>

<h3>Description</h3>

<p>Derive a hypothetical set of population vectors (i.e. population size
distributions across stages) given a time-series of matrix population models
(MPMs), by taking the stable stage distribution of the mean matrix as the
starting vector (or optionally, a uniform or random starting vector), and
deriving subsequent vectors through recursive population projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_vectors(A, start = "stable.stage")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_vectors_+3A_a">A</code></td>
<td>
<p>A list of MPMs (i.e., square population projection matrices).</p>
</td></tr>
<tr><td><code id="pop_vectors_+3A_start">start</code></td>
<td>
<p>Method to derive the first population vector in the series.
Either <code>stable.stage</code> to use the stable stage distribution of the mean
matrix as the starting vector, <code>uniform</code> to use a uniform starting
vector (all elements equal), or <code>random</code> to use a randomly-generated
starting vector. Defaults to the stable stage distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for providing population vectors as input to the
<code><a href="#topic+perturb_stochastic">perturb_stochastic</a></code> function which calculates stochastic
elasticities given a time-series of matrix population models and
corresponding population vectors, using the method described in Haridas et
al. (2009).
</p>


<h3>Value</h3>

<p>A list of population vectors
</p>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haridas, C. V., Tuljapurkar, S., &amp; Coulson, T. 2009. Estimating
stochastic elasticities directly from longitudinal data. Ecology Letters,
12, 806-812. &lt;doi:10.1111/j.1461-0248.2009.01330.x&gt;
</p>


<h3>See Also</h3>

<p>Other perturbation analysis: 
<code><a href="#topic+perturb_matrix">perturb_matrix</a>()</code>,
<code><a href="#topic+perturb_stochastic">perturb_stochastic</a>()</code>,
<code><a href="#topic+perturb_trans">perturb_trans</a>()</code>,
<code><a href="#topic+perturb_vr">perturb_vr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate list of matrices
matA_l &lt;- replicate(5, matrix(runif(9), 3, 3), simplify = FALSE)

# calculate corresponding population vectors
pop_vectors(matA_l)
pop_vectors(matA_l, start = "uniform")
pop_vectors(matA_l, start = "random")

</code></pre>

<hr>
<h2 id='qsd_converge'>Calculate time to reach quasi-stationary stage distribution</h2><span id='topic+qsd_converge'></span>

<h3>Description</h3>

<p>Calculates the time for a cohort projected with a matrix population
model to reach a defined quasi-stationary stage distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsd_converge(mat, start = 1L, conv = 0.01, N = 100000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsd_converge_+3A_mat">mat</code></td>
<td>
<p>A matrix population model, or component thereof (i.e., a square
projection matrix). Optionally with named rows and columns indicating the
corresponding life stage names.</p>
</td></tr>
<tr><td><code id="qsd_converge_+3A_start">start</code></td>
<td>
<p>The index (or stage name) of the first stage at which the author
considers the beginning of life. Defaults to <code>1</code>. Alternately, a
numeric vector giving the starting population vector (in which case
<code>length(start)</code> must match <code>ncol(matU))</code>. See section
<em>Starting from multiple stages</em>.</p>
</td></tr>
<tr><td><code id="qsd_converge_+3A_conv">conv</code></td>
<td>
<p>Proportional distance threshold from the stationary stage
distribution indicating convergence. For example, this value should be
<code>0.01</code> if the user wants to obtain the time step when the stage
distribution is within a distance of 1% of the stationary stage
distribution.</p>
</td></tr>
<tr><td><code id="qsd_converge_+3A_n">N</code></td>
<td>
<p>Maximum number of time steps over which the population will be
projected. Time steps are in the same units as the matrix population model
(see <code>AnnualPeriodicity</code> column in COM(P)ADRE metadata). Defaults to
<code>100,000</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some matrix population models are parameterised with a stasis loop at the
largest/most-developed stage class, which can lead to artefactual plateaus
in the mortality or fertility trajectories derived from such models. These
plateaus occur as a projected cohort approaches its stationary stage
distribution (SSD). Though there is generally no single time point at which
the SSD is reached, we can define a quasi-stationary stage distribution (QSD)
based on a given distance threshold from the SSD, and calculate the number of
time steps required for a cohort to reach the QSD. This quantity can then be
used to subset age trajectories of mortality or fertility to periods earlier
than the QSD, so as to avoid artefactual plateaus in mortality or fertility.
</p>
<p><strong>Starting from multiple stages</strong>
</p>
<p>Rather than specifying argument <code>start</code> as a single stage class from
which all individuals start life, it may sometimes be desirable to allow for
multiple starting stage classes. For example, if we want to start our
calculation of QSD from reproductive maturity (i.e., first reproduction), we
should account for the possibility that there may be multiple stage classes
in which an individual could first reproduce.
</p>
<p>To specify multiple starting stage classes, specify argument <code>start</code> as
the desired starting population vector, giving the proportion
of individuals starting in each stage class (the length of <code>start</code>
should match the number of columns in the relevant MPM).
</p>


<h3>Value</h3>

<p>An integer indicating the first time step at which the
quasi-stationary stage distribution is reached (or an <code>NA</code> and a
warning if the quasi-stationary distribution is not reached).
</p>


<h3>Note</h3>

<p>The time required for a cohort to reach its QSD depends on the initial
population vector of the cohort (for our purposes, the starting stage
class), and so does not fundamentally require an ergodic matrix (where the
long-term equilibrium traits are independent of the initial population
vector). However, methods for efficiently calculating the stationary stage
distribution (SSD) generally do require ergodicity.
</p>
<p>If the supplied matrix (<code>mat</code>) is non-ergodic, <code>qsd_converge</code>
first checks for stage classes with no connection (of any degree) from the
starting stage class specified by argument <code>start</code>, and strips such
stages from the matrix. These unconnected stages have no impact on
age-specific traits that we might derive from the matrix (given the
specified starting stage), but often lead to non-ergodicity and therefore
prevent the reliable calculation of SSD. If the reduced matrix is ergodic,
the function internally updates the starting stage class and continues with
the regular calculation. Otherwise, if the matrix cannot be made ergodic,
the function will return <code>NA</code> with a warning.
</p>


<h3>Author(s)</h3>

<p>Hal Caswell &lt;h.caswell@uva.nl&gt;
</p>
<p>Owen Jones &lt;jones@biology.sdu.dk&gt;
</p>
<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction, Analysis, and
Interpretation. Sinauer Associates; 2nd edition. ISBN: 978-0878930968
</p>
<p>Horvitz, C. C., &amp; Tuljapurkar, S. 2008. Stage dynamics, period survival, and
mortality plateaus. The American Naturalist, 172(2), 203‚Äì215.
</p>
<p>Jones, O. R., Scheuerlein, A., Salguero-Gomez, R., Camarda, C. G., Schaible,
R., Casper, B. B., Dahlgren, J. P., Ehrl√©n, J., Garc√≠a, M. B., Menges, E.,
Quintana-Ascencio, P. F., Caswell, H., Baudisch, A. &amp; Vaupel, J. 2014.
Diversity of ageing across the tree of life. Nature 505, 169-173.
&lt;doi:10.1038/nature12789&gt;
</p>
<p>Salguero-Gomez R. 2018. Implications of clonality for ageing research.
Evolutionary Ecology, 32, 9-28. &lt;doi:10.1007/s10682-017-9923-2&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mature_distrib">mature_distrib</a></code> for calculating the proportion of
individuals achieving reproductive maturity in each stage class.
</p>
<p>Other life tables: 
<code><a href="#topic+age_from_stage">age_from_stage</a></code>,
<code><a href="#topic+lifetable_convert">lifetable_convert</a></code>,
<code><a href="#topic+mpm_to_table">mpm_to_table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

# starting stage = 2 (i.e., "small")
qsd_converge(mpm1$matU, start = 2)
qsd_converge(mpm1$matU, start = "small") # equivalent using named life stages

# convergence threshold = 0.001
qsd_converge(mpm1$matU, start = 2, conv = 0.001)

# starting from first reproduction
repstages &lt;- repro_stages(mpm1$matF)
n1 &lt;- mature_distrib(mpm1$matU, start = 2, repro_stages = repstages)
qsd_converge(mpm1$matU, start = n1)

</code></pre>

<hr>
<h2 id='Rage-package'>Rage: Life History Metrics from Matrix Population Models</h2><span id='topic+Rage'></span><span id='topic+Rage-package'></span>

<h3>Description</h3>

<p>Functions for calculating life history metrics using matrix population models ('MPMs'). Described in Jones et al. (2021) <a href="https://doi.org/10.1101/2021.04.26.441330">doi:10.1101/2021.04.26.441330</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a> (<a href="https://orcid.org/0000-0001-5720-4686">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Patrick Barks <a href="mailto:barks@biology.sdu.dk">barks@biology.sdu.dk</a> (<a href="https://orcid.org/0000-0002-5947-8151">ORCID</a>)
</p>
</li>
<li><p> Pol Capdevila <a href="mailto:pcapdevila.pc@gmail.com">pcapdevila.pc@gmail.com</a> (<a href="https://orcid.org/0000-0002-2842-4302">ORCID</a>)
</p>
</li>
<li><p> Hal Caswell <a href="mailto:h.caswell@uva.nl">h.caswell@uva.nl</a> (<a href="https://orcid.org/0000-0003-4394-6894">ORCID</a>)
</p>
</li>
<li><p> Judy P. Che-Castaldo <a href="mailto:jchecastaldo@lpzoo.org">jchecastaldo@lpzoo.org</a> (<a href="https://orcid.org/0000-0002-9118-9202">ORCID</a>)
</p>
</li>
<li><p> Richard A. Hinrichsen <a href="mailto:rich@hinrichsenenvironmental.com">rich@hinrichsenenvironmental.com</a> (<a href="https://orcid.org/0000-0003-0761-3005">ORCID</a>)
</p>
</li>
<li><p> John Jackson <a href="mailto:jjackson0308@gmail.com">jjackson0308@gmail.com</a> (<a href="https://orcid.org/0000-0002-4563-2840">ORCID</a>)
</p>
</li>
<li><p> Tamora James <a href="mailto:tamoradjames@protonmail.com">tamoradjames@protonmail.com</a> (<a href="https://orcid.org/0000-0003-1363-4742">ORCID</a>)
</p>
</li>
<li><p> Sam Levin <a href="mailto:levisc8@gmail.com">levisc8@gmail.com</a> (<a href="https://orcid.org/0000-0002-3289-9925">ORCID</a>)
</p>
</li>
<li><p> William K. Petry <a href="mailto:wpetry@ncsu.edu">wpetry@ncsu.edu</a> (<a href="https://orcid.org/0000-0002-5230-5987">ORCID</a>)
</p>
</li>
<li><p> Roberto Salguero-Gomez <a href="mailto:rob.salguero@zoo.ox.ac.uk">rob.salguero@zoo.ox.ac.uk</a> (<a href="https://orcid.org/0000-0002-6085-4433">ORCID</a>)
</p>
</li>
<li><p> Iain Stott <a href="mailto:stott@biology.sdu.dk">stott@biology.sdu.dk</a> (<a href="https://orcid.org/0000-0003-2724-7436">ORCID</a>)
</p>
</li>
<li><p> Chelsea C. Thomas <a href="mailto:esochels@gmail.com">esochels@gmail.com</a> (<a href="https://orcid.org/0000-0002-8155-9353">ORCID</a>)
</p>
</li>
<li><p> Christina M. Hern√°ndez <a href="mailto:cmh352@cornell.edu">cmh352@cornell.edu</a> (<a href="https://orcid.org/0000-0002-7188-8217">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Danny Buss <a href="mailto:dlb50@cam.ac.uk">dlb50@cam.ac.uk</a> [contributor]
</p>
</li>
<li><p> Caroline Schuette <a href="mailto:cschuette17@gmail.com">cschuette17@gmail.com</a> (<a href="https://orcid.org/0000-0002-2063-8736">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jonesor/Rage">https://github.com/jonesor/Rage</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jonesor/Rage/issues">https://github.com/jonesor/Rage/issues</a>
</p>
</li></ul>


<hr>
<h2 id='repro_maturity'>Age of reproductive maturity</h2><span id='topic+repro_maturity'></span><span id='topic+mature_prob'></span><span id='topic+mature_age'></span><span id='topic+mature_distrib'></span>

<h3>Description</h3>

<p>Apply Markov chain approaches to compute age-specific
trajectory of reproduction for individuals in a matrix population model.
Includes functions to calculate the probability of achieving reproductive
maturity (<code>mature_prob</code>), mean age at first reproduction
(<code>mature_age</code>), and distribution of individuals first achieving
reproductive maturity among stage class (<code>mature_distrib</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mature_prob(matU, matR, start = 1L)

mature_age(matU, matR, start = 1L)

mature_distrib(matU, start = 1L, repro_stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repro_maturity_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.
progression, stasis, and retrogression). Optionally with named rows and
columns indicating the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="repro_maturity_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a matrix population model (i.e., a
square projection matrix reflecting transitions due to reproduction; either
sexual, clonal, or both). Optionally with named rows and columns indicating
the corresponding life stage names.</p>
</td></tr>
<tr><td><code id="repro_maturity_+3A_start">start</code></td>
<td>
<p>The index (or stage name) of the first stage at which the author
considers the beginning of life. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="repro_maturity_+3A_repro_stages">repro_stages</code></td>
<td>
<p>A vector of stage names or indices indicating which
stages are reproductive. Alternatively, a logical vector of length
<code>ncol(matU)</code> indicating whether each stage is reproductive
(<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>mature_distrib</code>, a vector giving the proportion of
individuals that first reproduce within each stage class. For all others, a
scalar trait value.
</p>


<h3>Note</h3>

<p>Note that the units of time in returned values are the same as the
<code>ProjectionInterval</code> of the MPM.
</p>


<h3>Author(s)</h3>

<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Hal Caswell &lt;hcaswell@whoi.edu&gt;
</p>
<p>Owen R. Jones &lt;jones@biology.sdu.dk&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mpm1)

mature_prob(mpm1$matU, mpm1$matF, start = 2)
mature_age(mpm1$matU, mpm1$matF, start = 2)

### distribution of first reproductive maturity among stage classes
repstage &lt;- repro_stages(mpm1$matF)
mature_distrib(mpm1$matU, start = 2, repro_stages = repstage)

</code></pre>

<hr>
<h2 id='repro_stages'>Identify which stages in a matrix population model are reproductive</h2><span id='topic+repro_stages'></span>

<h3>Description</h3>

<p>Takes a reproductive matrix and returns a vector of logical values
(<code>TRUE</code>/<code>FALSE</code>) indicating which stages are reproductive (i.e.,
exhibit any positive values for reproduction). This function is a preparatory
step to collapsing the matrix model into a standardized set of stage classes
using the function <code><a href="#topic+mpm_standardize">mpm_standardize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repro_stages(matR, na_handling = "return.true")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repro_stages_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a matrix population model (i.e., a
square projection matrix reflecting transitions due to reproduction; either
sexual (e.g., <code>matF</code>), clonal (e.g., <code>matC</code>), or both).</p>
</td></tr>
<tr><td><code id="repro_stages_+3A_na_handling">na_handling</code></td>
<td>
<p>One of <code>"return.na"</code>, <code>"return.true"</code>, or
<code>"return.false"</code>. Determines how values of <code>NA</code> within
<code>matR</code> should be handled. See Value for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length <code>ncol(matR)</code>, with values of
<code>FALSE</code> corresponding to non-reproductive stages and values of
<code>TRUE</code> corresponding to reproductive stages.<br /><br /> For a given matrix
stage (i.e., column of <code>matR</code>), if there are any positive values of
reproduction, the function will return <code>TRUE</code>. However, for a given
stage, if there are no positive values of reproduction and one or more
values of <code>NA</code>, the function will return <code>NA</code> if
<code>na_handling == "return.na"</code>, <code>TRUE</code> if <code>na_handling ==
  "return.true"</code>, or <code>FALSE</code> if <code>na_handling == "return.false"</code>.
</p>


<h3>Author(s)</h3>

<p>Rob Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>
<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+standard_stages">standard_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matR1 &lt;- rbind(
  c(0, 0.2, 0, 0.5),
  c(0, 0.3, 0, 0.6),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

matR2 &lt;- rbind(
  c(NA, NA, NA, 1.1),
  c(0, 0, 0.3, 0.7),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

repro_stages(matR1)

# compare different methods for handling NA
repro_stages(matR2, na_handling = "return.na")
repro_stages(matR2, na_handling = "return.true")
repro_stages(matR2, na_handling = "return.false")
</code></pre>

<hr>
<h2 id='shape_rep'>Calculate shape of reproduction over age</h2><span id='topic+shape_rep'></span>

<h3>Description</h3>

<p>Calculates a 'shape' value of distribution of reproduction over age by
comparing the area under a cumulative reproduction curve (over age) with the
area under a cumulative function describing constant reproduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_rep(rep, surv = NULL, xmin = NULL, xmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_rep_+3A_rep">rep</code></td>
<td>
<p>Either 1) a numeric vector describing reproduction over age (mx),
2) a <code>data.frame</code> / <code>list</code> with one column / element titled 'mx'
describing a reproduction over age, optionally a column / element 'x'
containing age classes (each element a number representing the age at the
start of the class), or 3) a matrix, specifically the reproduction
submatrix (e.g. F matrix) of a matrix population model. If <code>rep</code> is
provided as a matrix, then <code>surv</code> must be provided as the U submatrix
of the matrix population model.
</p>
<p>In case (2), if x is not supplied, the function will assume age classes
starting at 0 with time steps of unit. If x ends at maximum longevity,
<code>mx[which.max(x)]</code> should equal 0; however it is possible to supply
partial reproduction schedules.</p>
</td></tr>
<tr><td><code id="shape_rep_+3A_surv">surv</code></td>
<td>
<p>An optional argument to be used if rep is provided as a matrix
(the reproduction submatrix of the matrix population model.) If <code>rep</code>
is provided as a matrix, then <code>surv</code> should also be provided as a the
U submatrix of the matrix population model.</p>
</td></tr>
<tr><td><code id="shape_rep_+3A_xmin">xmin</code>, <code id="shape_rep_+3A_xmax">xmax</code></td>
<td>
<p>The minimum and maximum age respectively over which to
evaluate shape. If not given, these default to <code>min(x)</code> and
<code>max(x)</code> respectively.</p>
</td></tr>
<tr><td><code id="shape_rep_+3A_...">...</code></td>
<td>
<p>Additional variables passed to 'mpm_to_mx' when the data are
provided as matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a shape value describing symmetry of reproduction over age by
comparing the area under a cumulative reproduction curve over age with the
area under constant reproduction. May take any real value between -0.5 and
+0.5. A value of 0 indicates negligible ageing (neither generally
increasing nor generally decreasing reproduction with age); positive values
indicate senescence (generally decreasing reproduction with age); negative
values indicate negative senescence (generally increasing reproduction with
age). A value of +0.5 indicates that (hypothetically) all individuals are
born to individuals of age 0; a value of -0.5 indicates that all
individuals are born at the age of maximum longevity.
</p>


<h3>Author(s)</h3>

<p>Iain Stott &lt;iainmstott@gmail.com&gt;
</p>


<h3>References</h3>

<p>Baudisch, A, Stott, I. 2019. A pace and shape perspective on
fertility. Methods Ecol Evol. 10: 1941‚Äì 1951.
&lt;https://doi.org/10.1111/2041-210X.13289&gt;
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_surv">shape_surv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># increasing mx yields negative shape
mx &lt;- c(0, 0, 0.3, 0.4, 0.5, 0.6)
shape_rep(mx)

# decreasing mx yields positive shape
mx &lt;- c(1.1, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4)
shape_rep(mx)

# constant mx yields shape = 0
mx &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
shape_rep(mx)

# calculate mx trajectory first
mpm_to_mx(matU = mpm1$matU, matR = mpm1$matF)


# providing the matrices directly
data(mpm1)
shape_rep(rep = mpm1$matF, surv = mpm1$matU)

</code></pre>

<hr>
<h2 id='shape_surv'>Calculate shape of survival over age</h2><span id='topic+shape_surv'></span>

<h3>Description</h3>

<p>Calculates a 'shape' value of survival lifespan inequality by comparing the
area under a survival curve (over age) with the area under a constant
survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_surv(surv, xmin = NULL, xmax = NULL, trunc = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_surv_+3A_surv">surv</code></td>
<td>
<p>Either 1) a numeric vector describing a survival curve (lx), 2) a
<code>data.frame</code> / <code>list</code> with one column / element titled 'lx'
describing a survival curve, optionally a column / element 'x' containing
age classes (each element a number representing the age at the start of the
class), or 3), a <code>matrix</code>, specifically the U submatrix of a matrix
population model (A).
</p>
<p>In case (2) If <code>x</code> is not supplied, the function will assume age
classes starting at <code>0</code> with time steps of <code>1</code> unit of the
<code>ProjectionInterval</code>. If <code>x</code> begins at <code>0</code> then <code>lx[1]</code>
should equal <code>1</code>. If <code>x</code> ends at maximum longevity, then
<code>lx[which.max(x)]</code> should equal <code>0</code>; however it is possible to
supply partial survivorship curves.</p>
</td></tr>
<tr><td><code id="shape_surv_+3A_xmin">xmin</code>, <code id="shape_surv_+3A_xmax">xmax</code></td>
<td>
<p>The minimum and maximum age respectively over which to
evaluate shape. If not given, these default to <code>min(x)</code> and
<code>max(x)</code> respectively.</p>
</td></tr>
<tr><td><code id="shape_surv_+3A_trunc">trunc</code></td>
<td>
<p>logical determining whether to truncate life tables or not when
any <code>lx == 0</code>. Usually this is the case only for the final value of
<code>lx</code>. As the function calculates <code>log(lx)</code>, these value(s) cannot
be handled. <code>trunc == TRUE</code> strips out the zero value(s). An
alternative to this is to transform the zeroes to something approximating
zero (e.g., 1e-7).</p>
</td></tr>
<tr><td><code id="shape_surv_+3A_...">...</code></td>
<td>
<p>Additional variables passed to 'mpm_to_lx', if data are supplied
as a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a shape value describing lifespan inequality by comparing the area
under a survival (<code>lx</code>) curve over age with the area under a constant
(Type II) survival function. The shape value may take any real value
between -0.5 and +0.5. A value of 0 indicates negligible ageing (neither
generally increasing nor generally decreasing survival with age); negative
values indicate negative senescence (generally increasing survival with
age); positive values indicate senescence (generally decreasing survival
with age). A value of +0.5 indicates that all individuals die at age of
maximum longevity; a value of -0.5 indicates that (hypothetically) all
individuals die at birth.
</p>


<h3>Author(s)</h3>

<p>Iain Stott &lt;iainmstott@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Other life history traits: 
<code><a href="#topic+entropy_d">entropy_d</a>()</code>,
<code><a href="#topic+entropy_k">entropy_k</a>()</code>,
<code><a href="#topic+gen_time">gen_time</a>()</code>,
<code><a href="#topic+life_expect_mean">life_expect_mean</a>()</code>,
<code><a href="#topic+longevity">longevity</a>()</code>,
<code><a href="#topic+net_repro_rate">net_repro_rate</a>()</code>,
<code><a href="#topic+repro_maturity">repro_maturity</a></code>,
<code><a href="#topic+shape_rep">shape_rep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># exponential decline in lx yields shape = 0
lx &lt;- 0.7^(0:20)
shape_surv(lx)

data(mpm1)
shape_surv(mpm1$matU)

lx &lt;- mpm_to_lx(mpm1$matU, start = 1)
shape_surv(lx)

</code></pre>

<hr>
<h2 id='standard_stages'>Identify stages corresponding to different parts of the reproductive life
cycle</h2><span id='topic+standard_stages'></span>

<h3>Description</h3>

<p>Identify the stages of a matrix population model that correspond to
different parts of the reproductive life cycle, namely propagule,
pre-reproductive, reproductive and post-reproductive. These classifications
are used to standardise matrices to allow comparisons across species with
different life cycle structures, see <code><a href="#topic+mpm_standardize">mpm_standardize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_stages(matF, repro_stages, matrix_stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_stages_+3A_matf">matF</code></td>
<td>
<p>The sexual component of a matrix population model (i.e., a square
projection matrix reflecting transitions only due to <em>sexual</em>
reproduction). It assumes that it has been rearranged so that
non-reproductive stages are in the final rows/columns.</p>
</td></tr>
<tr><td><code id="standard_stages_+3A_repro_stages">repro_stages</code></td>
<td>
<p>Logical vector identifying which stages are reproductive.</p>
</td></tr>
<tr><td><code id="standard_stages_+3A_matrix_stages">matrix_stages</code></td>
<td>
<p>(character) vector of stages, values are <code>prop</code>
(propagule), <code>active</code>, and <code>dorm</code> (dormant).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that fecundity and mean fecundity matrices have been
rearranged so that non-reproductive stages are in the final rows/columns.
Output indicates groupings to be used when collapsing the matrix model.
</p>


<h3>Value</h3>

<p>A list with four elements:
</p>
<table>
<tr><td><code>propStages</code></td>
<td>
<p>Position of the propagule stages</p>
</td></tr>
<tr><td><code>preRepStages</code></td>
<td>
<p>Position of the pre-reproductive stages</p>
</td></tr>
<tr><td><code>repStages</code></td>
<td>
<p>Position of the reproductive stages</p>
</td></tr>
<tr><td><code>postRepStages</code></td>
<td>
<p>Position of the post-reproductive stages</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Dormant stages are not currently handled.
</p>


<h3>Author(s)</h3>

<p>Rob Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_standardize">mpm_standardize</a></code>
</p>
<p>Other transformation: 
<code><a href="#topic+is_leslie_matrix">is_leslie_matrix</a>()</code>,
<code><a href="#topic+leslie_collapse">leslie_collapse</a>()</code>,
<code><a href="#topic+mpm_collapse">mpm_collapse</a>()</code>,
<code><a href="#topic+mpm_rearrange">mpm_rearrange</a>()</code>,
<code><a href="#topic+mpm_split">mpm_split</a>()</code>,
<code><a href="#topic+mpm_standardize">mpm_standardize</a>()</code>,
<code><a href="#topic+name_stages">name_stages</a>()</code>,
<code><a href="#topic+repro_stages">repro_stages</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0, 0),
  c(0, 0.3, 0.3, 0.1, 0),
  c(0, 0, 0.4, 0.4, 0.1),
  c(0, 0, 0, 0.1, 0.4)
)

matF &lt;- rbind(
  c(0, 1.1, 0, 1.6, 0),
  c(0, 0.8, 0, 0.4, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0),
  c(0, 0, 0, 0, 0)
)

repro_stages &lt;- c(FALSE, TRUE, FALSE, TRUE, FALSE)
matrix_stages &lt;- c("prop", "active", "active", "active", "active")

r &lt;- mpm_rearrange(matU, matF,
  repro_stages = repro_stages,
  matrix_stages = matrix_stages
)

standard_stages(r$matF, r$repro_stages, r$matrix_stages)

</code></pre>

<hr>
<h2 id='vital_rates'>Derive mean vital rates from a matrix population model</h2><span id='topic+vital_rates'></span>

<h3>Description</h3>

<p>Derive mean vital rates corresponding to separate demographic processes from
a matrix population model. Specifically, this function decomposes vital rates
of survival, progression, retrogression, sexual reproduction and clonal
reproduction, with various options for weighting and grouping stages of the
life cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vital_rates(
  matU,
  matF,
  matC = NULL,
  weights = NULL,
  splitStages = "all",
  matrixStages = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vital_rates_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.
progression, stasis, and retrogression).</p>
</td></tr>
<tr><td><code id="vital_rates_+3A_matf">matF</code></td>
<td>
<p>The sexual component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to sexual reproduction)</p>
</td></tr>
<tr><td><code id="vital_rates_+3A_matc">matC</code></td>
<td>
<p>The clonal component of a matrix population model (i.e., a square
projection matrix reflecting transitions due to clonal reproduction).
Defaults to <code>NULL</code>, indicating no clonal reproduction (i.e.
<code>matC</code> is a matrix of zeros).</p>
</td></tr>
<tr><td><code id="vital_rates_+3A_weights">weights</code></td>
<td>
<p>Vector of stage-specific weights to apply while averaging
vital rates. Default is <code>NULL</code> reflecting equal weighting for all
stages. May also be <code>"SSD"</code> to weight vital rates by the stable
distribution of <code>matA</code>.</p>
</td></tr>
<tr><td><code id="vital_rates_+3A_splitstages">splitStages</code></td>
<td>
<p>What groups should vital rates be averaged over. Either:
</p>
<p><code>"all"</code>: all stages grouped.
</p>
<p><code>"ontogeny"</code>: group juvenile stages (all stages prior to the first stage
with sexual reproduction) and adult stages.
</p>
<p><code>"matrixStages"</code>: group according to a standardized set of stage classes
(propagule, active, and dormant). If <code>splitStages = "matrixStages"</code>,
must also specify separate argument <code>matrixStages</code>.</p>
</td></tr>
<tr><td><code id="vital_rates_+3A_matrixstages">matrixStages</code></td>
<td>
<p>Vector of stage-specific standardized matrix classes
(&quot;prop&quot; for propagule, &quot;active&quot;, and/or &quot;dorm&quot; for dormant). Only used if
<code>splitStages = "matrixClass"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of averaged vital rates.
</p>


<h3>Author(s)</h3>

<p>Roberto Salguero-Gomez &lt;rob.salguero@zoo.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>


<h3>See Also</h3>

<p>Other vital rates: 
<code><a href="#topic+vr_mat">vr_mat</a></code>,
<code><a href="#topic+vr_vec">vr_vec</a></code>,
<code><a href="#topic+vr">vr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.6)
)

matF &lt;- rbind(
  c(0, 0, 1.1, 1.6),
  c(0, 0, 0.8, 0.4),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

matC &lt;- rbind(
  c(0, 0, 0.4, 0.5),
  c(0, 0, 0.3, 0.1),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

# Vital rate outputs without weights
vital_rates(matU, matF, matC, splitStages = "all")
vital_rates(matU, matF, matC, splitStages = "ontogeny")

# Group vital rates according to specified matrixStages
ms &lt;- c("prop", "active", "active", "active")
vital_rates(matU, matF, matC,
  splitStages = "matrixStages",
  matrixStages = ms
)

# Vital rate outputs weighted by the stable stage distribution of 'matA'
vital_rates(matU, matF, matC, splitStages = "all", weights = "SSD")

</code></pre>

<hr>
<h2 id='vr'>Derive mean vital rates from a matrix population model</h2><span id='topic+vr'></span><span id='topic+vr_survival'></span><span id='topic+vr_growth'></span><span id='topic+vr_shrinkage'></span><span id='topic+vr_stasis'></span><span id='topic+vr_dorm_enter'></span><span id='topic+vr_dorm_exit'></span><span id='topic+vr_fecundity'></span>

<h3>Description</h3>

<p>Derive mean vital rates of survival, growth (or development), shrinkage (or
de-development), stasis, dormancy, or reproduction from a matrix population
model, by averaging across stage classes. These functions include optional
arguments for custom weighting of different stage classes (see
<em>Weighting stages</em>), excluding certain stage classes from the
calculation (see <em>Excluding stages</em>), and defining the set of
biologically-possible transitions (see <em>Possible transitions</em>).
</p>
<p>These decompositions assume that all transition rates are products of a
stage-specific survival term (column sums of <code>matU</code>) and a lower level
vital rate that is conditional on survival (growth/development,
shrinkage/de-development, stasis, dormancy, or a/sexual reproduction).
Reproductive vital rates that are not conditional on survival (i.e., within a
stage class from which there is no survival) are also allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vr_survival(matU, posU = matU &gt; 0, exclude_col = NULL, weights_col = NULL)

vr_growth(
  matU,
  posU = matU &gt; 0,
  exclude = NULL,
  exclude_row = NULL,
  exclude_col = NULL,
  weights_col = NULL,
  surv_only_na = TRUE
)

vr_shrinkage(
  matU,
  posU = matU &gt; 0,
  exclude = NULL,
  exclude_row = NULL,
  exclude_col = NULL,
  weights_col = NULL,
  surv_only_na = TRUE
)

vr_stasis(
  matU,
  posU = matU &gt; 0,
  exclude = NULL,
  weights_col = NULL,
  surv_only_na = TRUE
)

vr_dorm_enter(matU, posU = matU &gt; 0, dorm_stages, weights_col = NULL)

vr_dorm_exit(matU, posU = matU &gt; 0, dorm_stages, weights_col = NULL)

vr_fecundity(
  matU,
  matR,
  posR = matR &gt; 0,
  exclude_col = NULL,
  weights_row = NULL,
  weights_col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vr_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.,
progression, stasis, and retrogression)</p>
</td></tr>
<tr><td><code id="vr_+3A_posu">posU</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matU</code>, with
elements indicating whether a given <code>matU</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matU &gt; 0</code> (see
<em>Possible transitions</em>).</p>
</td></tr>
<tr><td><code id="vr_+3A_exclude_col">exclude_col</code></td>
<td>
<p>Integer, character or logical vector indicating stages for
which transitions both <em>to</em> and <em>from</em> the stage should be
excluded from the calculation of vital rates. See section
<em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="vr_+3A_weights_col">weights_col</code></td>
<td>
<p>Vector of stage-specific weights to apply while averaging
vital rates across columns. See section <em>Weighting stages</em>.</p>
</td></tr>
<tr><td><code id="vr_+3A_exclude">exclude</code></td>
<td>
<p>Integer, character or logical vector indicating stages for
which transitions both <em>to</em> and <em>from</em> the stage should be
excluded from the calculation of vital rates. See section
<em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="vr_+3A_exclude_row">exclude_row</code></td>
<td>
<p>Integer, character or logical vector indicating stages for
which transitions both <em>to</em> and <em>from</em> the stage should be
excluded from the calculation of vital rates. See section
<em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="vr_+3A_surv_only_na">surv_only_na</code></td>
<td>
<p>If there is only one possible <code>matU</code> transition in a
given column, should that transition be attributed exclusively to survival?
If <code>TRUE</code>, the vital rate of growth/stasis/shrinkage in that column
will be coerced to <code>NA</code>. If <code>FALSE</code>, dividing the single
transition by the stage-specific survival probability will always yield a
value of <code>1</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vr_+3A_dorm_stages">dorm_stages</code></td>
<td>
<p>Integer or character vector indicating dormant stage
classes.</p>
</td></tr>
<tr><td><code id="vr_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a matrix population model (i.e., a
square projection matrix reflecting transitions due to reproduction; either
sexual, clonal, or both)</p>
</td></tr>
<tr><td><code id="vr_+3A_posr">posR</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matR</code>, with
elements indicating whether a given <code>matR</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matR &gt; 0</code> (see
<em>Possible transitions</em>).</p>
</td></tr>
<tr><td><code id="vr_+3A_weights_row">weights_row</code></td>
<td>
<p>Vector of stage-specific weights to apply while summing
vital rates across rows within columns. See section <em>Weighting
stages</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of vital rates. Vital rates corresponding to impossible
transitions are coerced to <code>NA</code> (see <em>Possible transitions</em>).
</p>


<h3>Possible transitions</h3>

<p>A transition rate of <code>0</code> within a matrix population model may indicate
that the transition is not possible in the given life cycle (e.g., tadpoles
never revert to eggs), or that the transition rate is possible but was
estimated to be <code>0</code> in the relevant population and time period. If vital
rates are to be averaged across multiple stage classes, or compared across
populations, it may be important to distinguish between these two types of
zeros.
</p>
<p>By default, the <code>vr_</code> functions assume that a transition rate of
<code>0</code> indicates an impossible transition, in which case a value of
<code>NA</code> will be used in relevant calculations. Specifically, the arguments
<code>posU</code> and <code>posR</code> are specified by the logical expressions
<code>(matU &gt; 0)</code> and <code>(matR &gt; 0)</code>, respectively. If the matrix
population model includes transitions that are estimated to be <code>0</code> but
still in fact possible, one should specify the <code>posU</code> and/or <code>posR</code>
arguments manually.
</p>


<h3>Weighting stages</h3>

<p>In averaging vital rates across stages, it may be desirable to weight stage
classes differently (e.g., based on reproductive values or stable
distributions). Weights are generally applied when averaging across columns,
i.e., across transitions <em>from</em> a set of stage classes (e.g., averaging
stage-specific survival probabilities across multiple stages). All <code>vr_</code>
functions therefore include an optional argument <code>weights_from</code>.
</p>
<p>In principle, particularly for vital rates of reproduction, the user can also
apply weights when summing across rows within columns, i.e., across
reproductive transitions <em>to</em> a set of stage classes (e.g., summing the
production of different types of offspring, such as seeds vs. seedlings). The
function <code>vr_fecundity</code> therefore also includes an optional
argument <code>weights_to</code>.
</p>
<p>If supplied, <code>weights_from</code> will automatically be scaled to sum to 1
over the set of possible transitions, whereas <code>weights_to</code> will not be
rescaled because we wish to enable the use of reproductive values here, which
do not naturally sum to 1.
</p>


<h3>Excluding stages</h3>

<p>It may be desirable to exclude one or more stages from the calculation of
certain vital rates. For instance, we might not believe that 'growth' to a
dormant stage class really reflects biological growth, in which case we could
exclude transitions <em>to</em> the dormant stage class using the argument
<code>exclude_row</code>. We may or may not want to ignore 'growth' transitions
<em>from</em> the dormant stage class, which can be done using
<code>exclude_col</code>. To exclude transitions both <em>to and from</em> a given
set of stages, use argument <code>exclude</code>.
</p>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Other vital rates: 
<code><a href="#topic+vital_rates">vital_rates</a>()</code>,
<code><a href="#topic+vr_mat">vr_mat</a></code>,
<code><a href="#topic+vr_vec">vr_vec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create example MPM (stage 4 is dormant)
matU &lt;- rbind(
  c(0.1, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0.1),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.4)
)

matF &lt;- rbind(
  c(0, 0.7, 1.1, 0),
  c(0, 0.3, 0.8, 0),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

vr_survival(matU, exclude_col = 4)
vr_growth(matU, exclude = 4)
vr_shrinkage(matU, exclude = 4)
vr_stasis(matU, exclude = 4)

# `exclude*` and `*_stages` arguments can accept stage names
matU &lt;- name_stages(matU)
matF &lt;- name_stages(matF)
vr_dorm_enter(matU, dorm_stages = "stage_4")
vr_dorm_exit(matU, dorm_stages = 4)

vr_fecundity(matU, matF, exclude_col = 4)

</code></pre>

<hr>
<h2 id='vr_mat'>Derive survival-independent vital rates for growth, stasis, shrinkage, and
reproduction</h2><span id='topic+vr_mat'></span><span id='topic+vr_mat_U'></span><span id='topic+vr_mat_R'></span>

<h3>Description</h3>

<p>Divides columns of a matrix population model by the corresponding
stage-specific survival probability, to obtain lower-level vital rates for
growth, stasis, shrinkage, and reproduction. Vital rates corresponding to
biologically impossible transitions are coerced to <code>NA</code>.
</p>
<p>These decompositions assume that all transition rates are products of a
stage-specific survival term (column sums of <code>matU</code>) and a lower level
vital rate that is conditional on survival (growth, shrinkage, stasis, or
reproduction). Reproductive vital rates that are not conditional on survival
(i.e., within a stage class from which there is no survival) are also
allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vr_mat_U(matU, posU = matU &gt; 0, surv_only_na = TRUE)

vr_mat_R(matU, matR, posR = matR &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vr_mat_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix reflecting survival-related transitions; e.g.
progression, stasis, and retrogression)</p>
</td></tr>
<tr><td><code id="vr_mat_+3A_posu">posU</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matU</code>, with
elements indicating whether a given <code>matU</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matU &gt; 0</code> (see
Details).</p>
</td></tr>
<tr><td><code id="vr_mat_+3A_surv_only_na">surv_only_na</code></td>
<td>
<p>If there is only one possible <code>matU</code> transition in a
given column, should that transition be attributed exclusively to survival?
If <code>TRUE</code>, the vital rate of growth/stasis/shrinkage in that column
will be coerced to <code>NA</code>. If <code>FALSE</code>, dividing the single
transition by the stage-specific survival probability will always yield a
value of <code>1</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vr_mat_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a matrix population model (i.e., a
square projection matrix reflecting transitions due to reproduction; either
sexual, clonal, or both)</p>
</td></tr>
<tr><td><code id="vr_mat_+3A_posr">posR</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matR</code>, with
elements indicating whether a given <code>matR</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matR &gt; 0</code> (see
Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A transition rate of <code>0</code> within a matrix population model may indicate
that the transition is not possible in the given life cycle (e.g., tadpoles
never revert to eggs), or that the transition is possible but was estimated
to be <code>0</code> in the relevant population and time period. If vital rates are
to be averaged across multiple stage classes, or compared across populations,
it may be important to distinguish between these two types of zeros.
</p>
<p>By default, <code>vr_mat</code> assumes that a transition rate of
<code>0</code> indicates an impossible transition, in which case a value of
<code>NA</code> will be returned in the relevant matrix cell. Specifically, the
arguments <code>posU</code> and <code>posR</code> are specified by the logical
expressions <code>(matU &gt; 0)</code> and <code>(matR &gt; 0)</code>, respectively. If the
matrix population model includes transitions that are possible but estimated
to be <code>0</code>, one should specify the <code>posU</code> and/or <code>posR</code>
arguments manually.
</p>


<h3>Value</h3>

<p>A matrix of vital rates. Vital rates corresponding to impossible
transitions will be coerced to <code>NA</code> (see Details).
</p>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix Population Models: Construction,
Analysis, and Interpretation. Sinauer Associates; 2nd edition. ISBN:
978-0878930968
</p>


<h3>See Also</h3>

<p>Other vital rates: 
<code><a href="#topic+vital_rates">vital_rates</a>()</code>,
<code><a href="#topic+vr_vec">vr_vec</a></code>,
<code><a href="#topic+vr">vr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matU &lt;- rbind(
  c(0.1, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.6)
)

matR &lt;- rbind(
  c(0, 0, 1.1, 1.6),
  c(0, 0, 0.8, 0.4),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

# extract vital rates of survival from matU
vr_mat_U(matU)

# extract vital rates of reproduction from matR
vr_mat_R(matU, matR)

</code></pre>

<hr>
<h2 id='vr_vec'>Derive stage-specific vital rates from a matrix population model</h2><span id='topic+vr_vec'></span><span id='topic+vr_vec_survival'></span><span id='topic+vr_vec_growth'></span><span id='topic+vr_vec_shrinkage'></span><span id='topic+vr_vec_stasis'></span><span id='topic+vr_vec_dorm_enter'></span><span id='topic+vr_vec_dorm_exit'></span><span id='topic+vr_vec_reproduction'></span>

<h3>Description</h3>

<p>Derive a vector of stage-specific vital rates of survival, growth, shrinkage,
stasis, dormancy, or reproduction from a matrix population model. These
functions include optional arguments for excluding certain stage classes from
the calculation (see <em>Excluding stages</em>), and defining the set of
biologically-possible transitions (see <em>Possible transitions</em>).
</p>
<p>This decomposition assume that all transition rates are products of a
stage-specific survival term (column sums of <code>matU</code>) and a lower level
vital rate that is conditional on survival (growth, shrinkage, stasis,
dormancy, or reproduction). Reproductive vital rates that are not conditional
on survival (i.e., within a stage class from which there is no survival) are
also allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vr_vec_survival(matU, posU = matU &gt; 0, exclude_col = NULL)

vr_vec_growth(
  matU,
  posU = matU &gt; 0,
  exclude = NULL,
  exclude_row = NULL,
  exclude_col = NULL,
  surv_only_na = TRUE
)

vr_vec_shrinkage(
  matU,
  posU = matU &gt; 0,
  exclude = NULL,
  exclude_row = NULL,
  exclude_col = NULL,
  surv_only_na = TRUE
)

vr_vec_stasis(matU, posU = matU &gt; 0, exclude = NULL, surv_only_na = TRUE)

vr_vec_dorm_enter(matU, posU = matU &gt; 0, dorm_stages)

vr_vec_dorm_exit(matU, posU = matU &gt; 0, dorm_stages)

vr_vec_reproduction(
  matU,
  matR,
  posR = matR &gt; 0,
  exclude_col = NULL,
  weights_row = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vr_vec_+3A_matu">matU</code></td>
<td>
<p>The survival component of a matrix population model (i.e., a
square projection matrix only containing survival-related transitions;
progression, stasis, and retrogression).</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_posu">posU</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matU</code>, with
elements indicating whether a given <code>matU</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matU &gt; 0</code> (see
Details).</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_exclude_col">exclude_col</code></td>
<td>
<p>Integer, character or logical vector indicating stages for
which transitions both <em>to</em> and <em>from</em> the stage should be
excluded from the calculation of vital rates. See section
<em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_exclude">exclude</code></td>
<td>
<p>Integer, character or logical vector indicating stages for
which transitions both <em>to</em> and <em>from</em> the stage should be
excluded from the calculation of vital rates. See section
<em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_exclude_row">exclude_row</code></td>
<td>
<p>Integer, character or logical vector indicating stages for
which transitions both <em>to</em> and <em>from</em> the stage should be
excluded from the calculation of vital rates. See section
<em>Excluding stages</em>.</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_surv_only_na">surv_only_na</code></td>
<td>
<p>If there is only one possible <code>matU</code> transition in a
given column, should that transition be attributed exclusively to survival?
If <code>TRUE</code>, the vital rate of growth/stasis/shrinkage in that column
will be coerced to <code>NA</code>. If <code>FALSE</code>, dividing the single
transition by the stage-specific survival probability will always yield a
value of <code>1</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_dorm_stages">dorm_stages</code></td>
<td>
<p>Integer or character vector indicating dormant stage
classes.</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_matr">matR</code></td>
<td>
<p>The reproductive component of a matrix population model (i.e., a
square projection matrix only reflecting transitions due to reproduction;
either sexual, clonal, or both).</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_posr">posR</code></td>
<td>
<p>A logical matrix of the same dimension as <code>matR</code>, with
elements indicating whether a given <code>matR</code> transition is possible
(<code>TRUE</code>) or not (<code>FALSE</code>). Defaults to <code>matR &gt; 0</code> (see
Details).</p>
</td></tr>
<tr><td><code id="vr_vec_+3A_weights_row">weights_row</code></td>
<td>
<p>Vector of stage-specific weights to apply while summing
vital rates across rows within columns (e.g., reproductive value vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of vital rates. Vital rates corresponding to impossible
transitions are coerced to <code>NA</code> (see <em>Possible transitions</em>).
</p>


<h3>Possible transitions</h3>

<p>A transition rate of <code>0</code> within a matrix population model may indicate
that the transition is not possible in the given life cycle (e.g., tadpoles
never revert to eggs), or that the transition rate is possible but was
estimated to be <code>0</code> in the relevant population and time period. If vital
rates are to be averaged across multiple stage classes, or compared across
populations, it may be important to distinguish between these two types of
zeros.
</p>
<p>By default, the <code>vitals_</code> functions assume that a transition rate of
<code>0</code> indicates an impossible transition, in which case a value of
<code>NA</code> will be used in relevant calculations. Specifically, the arguments
<code>posU</code> and <code>posR</code> are specified by the logical expressions
<code>(matU &gt; 0)</code> and <code>(matR &gt; 0)</code>, respectively. If the matrix
population model includes transitions that are estimated to be <code>0</code> but
still in fact possible, one should specify the <code>posU</code> and/or <code>posR</code>
arguments manually.
</p>


<h3>Excluding stages</h3>

<p>It may be desirable to exclude one or more stages from the calculation of
certain vital rates. For instance, a user might not believe that 'growth' to
a dormant stage class really reflects biological growth, in which case the
user could exclude transitions <em>to</em> the dormant stage class using the
argument <code>exclude_row</code>. The user may or may not want to ignore 'growth'
transitions <em>from</em> the dormant stage class, which can be done using
<code>exclude_col</code>. The argument <code>exclude_col</code> effectively just coerces
the respective vital rate to <code>NA</code>, to prevent it from getting used in
subsequent calculations. To exclude transitions both <em>to and from</em> a
given set of stages, use argument <code>exclude</code>.
</p>


<h3>Author(s)</h3>

<p>Patrick Barks &lt;patrick.barks@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Other vital rates: 
<code><a href="#topic+vital_rates">vital_rates</a>()</code>,
<code><a href="#topic+vr_mat">vr_mat</a></code>,
<code><a href="#topic+vr">vr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create example MPM (stage 4 is dormant)
matU &lt;- rbind(
  c(0.1, 0, 0, 0),
  c(0.5, 0.2, 0.1, 0.1),
  c(0, 0.3, 0.3, 0.1),
  c(0, 0, 0.5, 0.4)
)

matR &lt;- rbind(
  c(0, 0.7, 1.1, 0),
  c(0, 0.3, 0.8, 0),
  c(0, 0, 0, 0),
  c(0, 0, 0, 0)
)

vr_vec_survival(matU, exclude_col = 4)
vr_vec_growth(matU, exclude = 4)

# `exclude*` and `*_stages` arguments can accept stage names
matU &lt;- name_stages(matU)
matR &lt;- name_stages(matR)
vr_vec_shrinkage(matU, exclude = 4)
vr_vec_stasis(matU, exclude = "stage_4")

vr_vec_dorm_enter(matU, dorm_stages = 4)
vr_vec_dorm_exit(name_stages(matU), dorm_stages = "stage_4")

vr_vec_reproduction(matU, matR, exclude_col = "stage_4")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
