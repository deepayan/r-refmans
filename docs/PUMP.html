<!DOCTYPE html><html><head><title>Help for package PUMP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PUMP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PUMP-package'><p>PUMP: Power Under Multiplicity Project</p></a></li>
<li><a href='#adjp_wysd'><p>Westfall Young Step Down Function</p></a></li>
<li><a href='#adjp_wyss'><p>Westfall-Young Single Step Adjustment Function</p></a></li>
<li><a href='#calc_df'><p>Calculate degrees of freedom (support function)</p></a></li>
<li><a href='#calc_J'><p>This function calculates needed J to achieve a given (unadjusted) power</p></a></li>
<li><a href='#calc_K'><p>Calculates K, the number of districts</p></a></li>
<li><a href='#calc_MT'><p>Caculate multiplier for MDE calculation</p></a></li>
<li><a href='#calc_nbar'><p>This function calculates needed nbar to achieve a given power</p></a></li>
<li><a href='#calc_pval'><p>Calculates p-values from t-values</p></a></li>
<li><a href='#calc_SE'><p>Computes Q_m, the standard error of the effect size estimate</p></a></li>
<li><a href='#check_cor'><p>Check correlation of test statistics (simulation function)</p></a></li>
<li><a href='#comp_rawp_sd'><p>Helper function for Westfall Young Step Down</p></a></li>
<li><a href='#comp_rawp_ss'><p>Helper function for Westfall Young Single Step</p></a></li>
<li><a href='#convert_params'><p>Converts model params into DGP params (simulation function)</p></a></li>
<li><a href='#estimate_power_curve'><p>Calculate a power curve for sample size or mdes.</p></a></li>
<li><a href='#find_best'><p>Determine next point to check for correct power level.</p></a></li>
<li><a href='#fit_bounded_logistic'><p>Fit a bounded logistic curve</p></a></li>
<li><a href='#gen_base_sim_data'><p>Generate base simulated multi-level data (simulation</p>
function)</a></li>
<li><a href='#gen_cluster_ids'><p>Generates school and district assignments (simulation</p>
function)</a></li>
<li><a href='#gen_corr_matrix'><p>Generate correlation matrix (simulation function)</p></a></li>
<li><a href='#gen_cov_matrix'><p>generate covariance matrix between two variables</p></a></li>
<li><a href='#gen_RE_cov_matrix'><p>generate a parameterized covariance matrix from the provided 3 blocks</p></a></li>
<li><a href='#gen_sim_data'><p>Generate simulated multi-level data (simulation function)</p></a></li>
<li><a href='#gen_T.x'><p>Generate treatment assignment vector (simulation function)</p></a></li>
<li><a href='#gen_Yobs'><p>Generate observed outcomes (simulation function)</p></a></li>
<li><a href='#get_adjp_minp'><p>Helper function for Westfall Young</p></a></li>
<li><a href='#get_power_results'><p>Calculates different definitions of power (support function)</p></a></li>
<li><a href='#get_pval_tstat'><p>Function: get_pval_tstat</p>
</p>
<p>extracts p-value and t statistics from a given fitted model.</p></a></li>
<li><a href='#get_rawpt'><p>Function: get_rawpt</p></a></li>
<li><a href='#interacted_linear_estimators'><p>Interacted linear regression models</p></a></li>
<li><a href='#make_model'><p>Function: make.model</p></a></li>
<li><a href='#makelist_samp'><p>Convert multi-outcome data structure to dataframe for each outcome.</p></a></li>
<li><a href='#optimize_power'><p>Optimizes power to help in search for MDES or SS</p></a></li>
<li><a href='#parse_d_m'><p>Return characteristics of a given context/d_m code (support function)</p></a></li>
<li><a href='#parse_power_definition'><p>Parse the power definition</p></a></li>
<li><a href='#plot_power_curve'><p>Examine a power curve (result function)</p></a></li>
<li><a href='#plot_power_search'><p>Examine search path of a power search (result function)</p></a></li>
<li><a href='#plot.pumpgridresult'><p>Plot a pumpgridresult object (result function)</p></a></li>
<li><a href='#plot.pumpgridresult.mdes'><p>Plot a grid pump mdes object</p></a></li>
<li><a href='#plot.pumpgridresult.power'><p>Plot a grid pump power object</p></a></li>
<li><a href='#plot.pumpgridresult.sample'><p>Plot a grid pump sample object</p></a></li>
<li><a href='#plot.pumpresult'><p>Plot a pumpresult object (result function)</p></a></li>
<li><a href='#power_curve'><p>Obtain a power curve for a range of sample size or MDES values</p></a></li>
<li><a href='#print_context'><p>Print context (design, model, parameter values) of</p>
pumpresult or pumpgridresult (result function)</a></li>
<li><a href='#print_search'><p>Print the search history of a pump result object (result function)</p></a></li>
<li><a href='#pump_info'><p>Provides details about supported package features (core function)</p></a></li>
<li><a href='#pump_mdes'><p>Estimate the minimum detectable effect size (MDES) (core function)</p></a></li>
<li><a href='#pump_mdes_grid'><p>Run pump_mdes on varying values of parameters (grid function)</p></a></li>
<li><a href='#pump_power'><p>Estimate power across definitions (core function)</p></a></li>
<li><a href='#pump_power_exact'><p>Calculate power theoretically for M=1 situations</p></a></li>
<li><a href='#pump_power_grid'><p>Run pump_power on varying values of parameters (grid</p>
function)</a></li>
<li><a href='#pump_sample'><p>Estimate the required sample size (core function)</p></a></li>
<li><a href='#pump_sample_grid'><p>Run pump_sample on varying values of parameters (grid function)</p></a></li>
<li><a href='#pump_sample_raw'><p>Calculating Needed Sample Size for Raw (Unadjusted) Power</p></a></li>
<li><a href='#pumpgridresult'><p>Result object for results of grid power calculations</p></a></li>
<li><a href='#pumpresult'><p>pumpresult object for results of power calculations</p></a></li>
<li><a href='#run_grid'><p>Run grid across any of the core pump functions</p></a></li>
<li><a href='#setup_default_parallel_plan'><p>Setup parallel processing</p></a></li>
<li><a href='#strip_SEs'><p>Remove SE and df columns from (wide) power table</p></a></li>
<li><a href='#transpose_power_table'><p>Convert power table from wide to long (result function)</p></a></li>
<li><a href='#update_grid'><p>Update a single pump call to a grid call (grid function)</p></a></li>
<li><a href='#update.pumpgridresult'><p>Update a pump grid call, tweaking some parameters (core</p>
function)</a></li>
<li><a href='#update.pumpresult'><p>Update a pump call, tweaking some parameters (core function)</p></a></li>
<li><a href='#validate_d_m'><p>Validate d_m string</p></a></li>
<li><a href='#validate_inputs'><p>Validates user inputs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Power Under Multiplicity Project</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates power, minimum detectable effect size (MDES) and sample size requirements. The context is multilevel randomized experiments with multiple outcomes. The estimation takes into account the use of multiple testing procedures. Development of this package was supported by a grant from the Institute of Education Sciences (R305D170030). For a full package description, including a detailed technical appendix, see &lt;<a href="https://doi.org/10.18637%2Fjss.v108.i06">doi:10.18637/jss.v108.i06</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MDRCNY/PUMP">https://github.com/MDRCNY/PUMP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MDRCNY/PUMP/issues">https://github.com/MDRCNY/PUMP/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, ggpubr, glue, future, lme4, magrittr, methods,
mvtnorm, parallel, purrr, randomizr, readr, rlang, stats,
stringr, tibble, tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>furrr, here, kableExtra, knitr, PowerUpR (&ge; 1.1.0), testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 11:28:33 UTC; lmiratrix</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristin Porter [aut],
  Luke Miratrix <a href="https://orcid.org/0000-0002-0078-1906"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kristen Hunter <a href="https://orcid.org/0000-0002-5678-4620"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Zarni Htet [aut],
  MDRC [cph],
  Institute of Education Sciences [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Miratrix &lt;luke_miratrix@gse.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 13:02:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='PUMP-package'>PUMP: Power Under Multiplicity Project</h2><span id='topic+PUMP'></span><span id='topic+PUMP-package'></span>

<h3>Description</h3>

<p>Estimates power, minimum detectable effect size (MDES) and sample size requirements. The context is multilevel randomized experiments with multiple outcomes. The estimation takes into account the use of multiple testing procedures. Development of this package was supported by a grant from the Institute of Education Sciences (R305D170030). For a full package description, including a detailed technical appendix, see <a href="https://doi.org/10.18637/jss.v108.i06">doi:10.18637/jss.v108.i06</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luke Miratrix <a href="mailto:luke_miratrix@gse.harvard.edu">luke_miratrix@gse.harvard.edu</a> (<a href="https://orcid.org/0000-0002-0078-1906">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kristin Porter <a href="mailto:kristin.porter@keporterconsulting.com">kristin.porter@keporterconsulting.com</a>
</p>
</li>
<li><p> Kristen Hunter <a href="mailto:kristenbhunter@gmail.com">kristenbhunter@gmail.com</a> (<a href="https://orcid.org/0000-0002-5678-4620">ORCID</a>)
</p>
</li>
<li><p> Zarni Htet <a href="mailto:zarni.htet@mdrc.org">zarni.htet@mdrc.org</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> MDRC [copyright holder]
</p>
</li>
<li><p> Institute of Education Sciences [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/MDRCNY/PUMP">https://github.com/MDRCNY/PUMP</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MDRCNY/PUMP/issues">https://github.com/MDRCNY/PUMP/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adjp_wysd'>Westfall Young Step Down Function</h2><span id='topic+adjp_wysd'></span>

<h3>Description</h3>

<p>This adjustment function utilizes the comp_rawp_ss helper 
function to compare each row of the matrix sample p-values under
alternative hypothesis to all the rows in the matrix of the p-values
under the complete null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjp_wysd(
  rawp.mat,
  B,
  Sigma,
  t.df,
  two.tailed,
  cl = NULL,
  verbose = TRUE,
  updateProgress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjp_wysd_+3A_rawp.mat">rawp.mat</code></td>
<td>
<p>a matrix of raw p-values under H1. 
dimension: nrow = tnum, ncol = M</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_b">B</code></td>
<td>
<p>numer of WY permutations</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_sigma">Sigma</code></td>
<td>
<p>correlation matrix of null p-values</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_t.df">t.df</code></td>
<td>
<p>degrees of freedom of null p-values</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_two.tailed">two.tailed</code></td>
<td>
<p>one or two-tailed test</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_cl">cl</code></td>
<td>
<p>cluster object for parallel computing</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_verbose">verbose</code></td>
<td>
<p>whether to print out messaging</p>
</td></tr>
<tr><td><code id="adjp_wysd_+3A_updateprogress">updateProgress</code></td>
<td>
<p>function to update progress bar 
(only used for PUMP shiny app)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of adjusted p-values
</p>

<hr>
<h2 id='adjp_wyss'>Westfall-Young Single Step Adjustment Function</h2><span id='topic+adjp_wyss'></span>

<h3>Description</h3>

<p>This adjustment function utilizes the comp_rawp_ss 
helper function to compare
each row of the matrix sample p-values under
alternative hypothesis to all the rows in the matrix of the p-values
under the complete null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjp_wyss(
  rawp.mat,
  B,
  Sigma,
  t.df,
  two.tailed,
  verbose = TRUE,
  updateProgress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjp_wyss_+3A_rawp.mat">rawp.mat</code></td>
<td>
<p>a matrix of raw p-values under H1. 
dimension: nrow = tnum, ncol = M</p>
</td></tr>
<tr><td><code id="adjp_wyss_+3A_b">B</code></td>
<td>
<p>numer of WY permutations</p>
</td></tr>
<tr><td><code id="adjp_wyss_+3A_sigma">Sigma</code></td>
<td>
<p>correlation matrix of null p-values</p>
</td></tr>
<tr><td><code id="adjp_wyss_+3A_t.df">t.df</code></td>
<td>
<p>degrees of freedom of null p-values</p>
</td></tr>
<tr><td><code id="adjp_wyss_+3A_two.tailed">two.tailed</code></td>
<td>
<p>one or two-tailed test</p>
</td></tr>
<tr><td><code id="adjp_wyss_+3A_verbose">verbose</code></td>
<td>
<p>whether to print out messaging</p>
</td></tr>
<tr><td><code id="adjp_wyss_+3A_updateprogress">updateProgress</code></td>
<td>
<p>function to update progress bar 
(only used for PUMP shiny app)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of adjusted p-values
</p>

<hr>
<h2 id='calc_df'>Calculate degrees of freedom (support function)</h2><span id='topic+calc_df'></span>

<h3>Description</h3>

<p>Given sample sizes, return the used degrees of freedom
(frequently conservative) for the design and model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_df(d_m, J, K, nbar, numCovar.1, numCovar.2, numCovar.3, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_df_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="calc_df_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="calc_df_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="calc_df_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="calc_df_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="calc_df_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="calc_df_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="calc_df_+3A_validate">validate</code></td>
<td>
<p>logical; whether or not to validate
if output df is &lt;= 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar; degrees of freedom for the context.
</p>

<hr>
<h2 id='calc_J'>This function calculates needed J to achieve a given (unadjusted) power</h2><span id='topic+calc_J'></span>

<h3>Description</h3>

<p>This function calculates needed J to achieve a given (unadjusted) power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_J(
  d_m,
  MT = 2.8,
  MDES,
  K = NULL,
  nbar,
  Tbar,
  R2.1,
  R2.2,
  R2.3,
  ICC.2,
  ICC.3,
  omega.2,
  omega.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_J_+3A_d_m">d_m</code></td>
<td>
<p>a single RCT design (see list/naming convention)</p>
</td></tr>
<tr><td><code id="calc_J_+3A_mt">MT</code></td>
<td>
<p>Number of approximate effect-size unit SEs
(adjusted for degrees of freedom issues) that the MDES
needs to be to achieve desired power.  E.g., 2.8 for normal theory.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_mdes">MDES</code></td>
<td>
<p>scalar; the MDES values for each outcome</p>
</td></tr>
<tr><td><code id="calc_J_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="calc_J_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="calc_J_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>J, the number of schools needed
</p>

<hr>
<h2 id='calc_K'>Calculates K, the number of districts</h2><span id='topic+calc_K'></span>

<h3>Description</h3>

<p>Calculates K, the number of districts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_K(
  d_m,
  MT = 2.8,
  MDES,
  J,
  nbar,
  Tbar,
  R2.1,
  R2.2,
  R2.3,
  ICC.2,
  ICC.3,
  omega.2,
  omega.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_K_+3A_d_m">d_m</code></td>
<td>
<p>a single RCT d_m (see list/naming convention)</p>
</td></tr>
<tr><td><code id="calc_K_+3A_mt">MT</code></td>
<td>
<p>multiplier</p>
</td></tr>
<tr><td><code id="calc_K_+3A_mdes">MDES</code></td>
<td>
<p>scalar; the MDES value for all outcomes</p>
</td></tr>
<tr><td><code id="calc_K_+3A_j">J</code></td>
<td>
<p>scalar; the number of schools</p>
</td></tr>
<tr><td><code id="calc_K_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of units per school</p>
</td></tr>
<tr><td><code id="calc_K_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that
are assigned to the treatment</p>
</td></tr>
<tr><td><code id="calc_K_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M;
percent of variation explained by Level 1 covariates for each outcome</p>
</td></tr>
<tr><td><code id="calc_K_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M;
percent of variation explained by Level 2 covariates for each outcome</p>
</td></tr>
<tr><td><code id="calc_K_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M;
percent of variation explained by Level 3 covariates for each outcome</p>
</td></tr>
<tr><td><code id="calc_K_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar; school intraclass correlation</p>
</td></tr>
<tr><td><code id="calc_K_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar; district intraclass correlation</p>
</td></tr>
<tr><td><code id="calc_K_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar; ratio of school effect
size variability to random effects
variability</p>
</td></tr>
<tr><td><code id="calc_K_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar; ratio of district
effect size variability to random effects
variability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>K, the number of districts
</p>

<hr>
<h2 id='calc_MT'>Caculate multiplier for MDE calculation</h2><span id='topic+calc_MT'></span>

<h3>Description</h3>

<p>Caculate multiplier for MDE calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_MT(df, alpha, two.tailed, target.power)
</code></pre>

<hr>
<h2 id='calc_nbar'>This function calculates needed nbar to achieve a given power</h2><span id='topic+calc_nbar'></span>

<h3>Description</h3>

<p>This function calculates needed nbar to achieve a given power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_nbar(
  d_m,
  MT = 2.8,
  MDES,
  J = NULL,
  K = NULL,
  Tbar,
  R2.1,
  R2.2 = NULL,
  ICC.2 = NULL,
  omega.2 = NULL,
  R2.3 = NULL,
  ICC.3 = NULL,
  omega.3 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_nbar_+3A_d_m">d_m</code></td>
<td>
<p>a single RCT design (see list/naming convention)</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_mt">MT</code></td>
<td>
<p>Number of approximate effect-size unit SEs
(adjusted for degrees of freedom issues) that the MDES
needs to be to achieve desired power.  E.g., 2.8 for normal theory.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_mdes">MDES</code></td>
<td>
<p>scalar; the MDES values for each outcome</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_j">J</code></td>
<td>
<p>scalar; the number of schools</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="calc_nbar_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nbar, the number of individuals needed,
or NA if not possible given design
</p>

<hr>
<h2 id='calc_pval'>Calculates p-values from t-values</h2><span id='topic+calc_pval'></span>

<h3>Description</h3>

<p>Calculates p-values from t-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_pval(rawt, t.df, two.tailed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_pval_+3A_rawt">rawt</code></td>
<td>
<p>vector of t statistics</p>
</td></tr>
<tr><td><code id="calc_pval_+3A_t.df">t.df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="calc_pval_+3A_two.tailed">two.tailed</code></td>
<td>
<p>whether to calculate 1 or 2-tailed p-values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>power results for individual, minimum, complete power
</p>

<hr>
<h2 id='calc_SE'>Computes Q_m, the standard error of the effect size estimate</h2><span id='topic+calc_SE'></span>

<h3>Description</h3>

<p>Function to calculate the theoretical true (unadjusted) standard
error of the ATE estimate for a given d_m and model, in effect size units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_SE(
  d_m,
  J,
  K,
  nbar,
  Tbar,
  R2.1,
  R2.2,
  R2.3,
  ICC.2,
  ICC.3,
  omega.2,
  omega.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_SE_+3A_d_m">d_m</code></td>
<td>
<p>a single RCT d_m (see list/naming convention).</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_j">J</code></td>
<td>
<p>scalar; the number of schools</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_k">K</code></td>
<td>
<p>scalar; the number of districts</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of units per school</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to the
treatment</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation explained by
Level 1 covariates for each outcome</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation explained by
Level 2 covariates for each outcome</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation explained by
Level 3 covariates for each outcome</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; school intraclass correlation</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector of length M; district intraclass correlation</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of school effect size
variability to random effects variability</p>
</td></tr>
<tr><td><code id="calc_SE_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of district effect size
variability to random effects variability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector; the standard error of the effect size estimate
</p>

<hr>
<h2 id='check_cor'>Check correlation of test statistics (simulation function)</h2><span id='topic+check_cor'></span>

<h3>Description</h3>

<p>Estimates the pairwise correlations
between test statistics for all outcomes.
</p>
<p>Takes in two options:
- a pumpresult object
OR
- a list of necessary data-generating parameters
- the context (d_m)
- Tbar
</p>
<p>Note that this function can take several minutes to run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cor(
  pump.object = NULL,
  rho.V = NULL,
  rho.w0 = NULL,
  rho.w1 = NULL,
  rho.X = NULL,
  rho.u0 = NULL,
  rho.u1 = NULL,
  rho.C = NULL,
  rho.r = NULL,
  d_m = NULL,
  model.params.list = NULL,
  Tbar = 0.5,
  n.sims = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cor_+3A_pump.object">pump.object</code></td>
<td>
<p>A pumpresult object.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.v">rho.V</code></td>
<td>
<p>matrix; correlation matrix of level 3 covariates.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.w0">rho.w0</code></td>
<td>
<p>matrix; correlation matrix of level 3 random effects.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.w1">rho.w1</code></td>
<td>
<p>matrix; correlation matrix of level 3 random impacts.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.x">rho.X</code></td>
<td>
<p>matrix; correlation matrix of level 2 covariates.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.u0">rho.u0</code></td>
<td>
<p>matrix; correlation matrix of level 2 random effects.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.u1">rho.u1</code></td>
<td>
<p>matrix; correlation matrix of level 2 random impacts.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.c">rho.C</code></td>
<td>
<p>matrix; correlation matrix of level 1 covariates.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_rho.r">rho.r</code></td>
<td>
<p>matrix; correlation matrix of level 1 residuals.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_model.params.list">model.params.list</code></td>
<td>
<p>list; model parameters such as ICC, R2, etc. See
simulation vignette for details.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="check_cor_+3A_n.sims">n.sims</code></td>
<td>
<p>numeric; Number of simulated datasets to generate.
More datasets will achieve a more accurate result
but also increase computation time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix; M x M correlation matrix between test statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pp &lt;- pump_power( d_m = "d3.2_m3ff2rc",
                  MTP = "BF",
                  MDES = rep( 0.10, 2 ),
                  M = 2,
                  J = 4, # number of schools/block
                  K = 10, # number RA blocks
                  nbar = 50,
                  Tbar = 0.50, # prop Tx
                  alpha = 0.05, # significance level
                  numCovar.1 = 5, numCovar.2 = 3,
                  R2.1 = 0.1, R2.2 = 0.7,
                  ICC.2 = 0.05, ICC.3 = 0.4,
                  rho = 0.4, # how correlated test statistics are
                  tnum = 200
)
cor.tstat &lt;- check_cor(
    pump.object = pp, n.sims = 4
)
est.cor &lt;- mean(cor.tstat[lower.tri(cor.tstat)])
</code></pre>

<hr>
<h2 id='comp_rawp_sd'>Helper function for Westfall Young Step Down</h2><span id='topic+comp_rawp_sd'></span>

<h3>Description</h3>

<p>Helper function for Westfall Young Step Down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_rawp_sd(nullp, rawp, rawp.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_rawp_sd_+3A_nullp">nullp</code></td>
<td>
<p>a vector of p-values under H0</p>
</td></tr>
<tr><td><code id="comp_rawp_sd_+3A_rawp">rawp</code></td>
<td>
<p>a vector of p-values under H1</p>
</td></tr>
<tr><td><code id="comp_rawp_sd_+3A_rawp.order">rawp.order</code></td>
<td>
<p>order vector of raw p-values in ascending order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of 1s and 0s with lengths of M outcomes
</p>

<hr>
<h2 id='comp_rawp_ss'>Helper function for Westfall Young Single Step</h2><span id='topic+comp_rawp_ss'></span>

<h3>Description</h3>

<p>Used for the Westfall-Young single-step multiple
testing procedure (MTP).
It compares whether any of the null values across outcomes
exceeds each raw value for each outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_rawp_ss(nullp, rawp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_rawp_ss_+3A_nullp">nullp</code></td>
<td>
<p>a vector of p values under H0</p>
</td></tr>
<tr><td><code id="comp_rawp_ss_+3A_rawp">rawp</code></td>
<td>
<p>a vector of raw p values under H1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of 1s and 0s with length of M outcomes
</p>

<hr>
<h2 id='convert_params'>Converts model params into DGP params (simulation function)</h2><span id='topic+convert_params'></span>

<h3>Description</h3>

<p>Converts user-provided parameters such as ICC and
omega into data-generating parameters for the multilevel random
effects model used to produce simulated data, such as variance
values and covariate coefficients.
</p>
<p>This function is beyond the main scope of calculating power, and
is instead used for simulating data. For more info on use, see
the simulation vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_params(param.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_params_+3A_param.list">param.list</code></td>
<td>
<p>list; model parameters such as ICC, R2, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list; data-generating parameters.
</p>

<hr>
<h2 id='estimate_power_curve'>Calculate a power curve for sample size or mdes.</h2><span id='topic+estimate_power_curve'></span>

<h3>Description</h3>

<p>For a grid of points based on a passed sample or mdes pumpresult, estimate
power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_power_curve(
  p,
  low = NULL,
  high = NULL,
  high.max = 1000,
  grid.size = 5,
  tnum = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_power_curve_+3A_p">p</code></td>
<td>
<p>pumpresult object</p>
</td></tr>
<tr><td><code id="estimate_power_curve_+3A_low">low</code></td>
<td>
<p>Low end of grid</p>
</td></tr>
<tr><td><code id="estimate_power_curve_+3A_high">high</code></td>
<td>
<p>High end of grid</p>
</td></tr>
<tr><td><code id="estimate_power_curve_+3A_high.max">high.max</code></td>
<td>
<p>If no high provided, maximum possible high</p>
</td></tr>
<tr><td><code id="estimate_power_curve_+3A_grid.size">grid.size</code></td>
<td>
<p>Number of points in grid</p>
</td></tr>
<tr><td><code id="estimate_power_curve_+3A_tnum">tnum</code></td>
<td>
<p>the number of test statistics (samples)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of powers for grid of points.
</p>

<hr>
<h2 id='find_best'>Determine next point to check for correct power level.</h2><span id='topic+find_best'></span>

<h3>Description</h3>

<p>Extract roots from power curve fit to given evaluated points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best(test.pts, target.power, gamma = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_best_+3A_test.pts">test.pts</code></td>
<td>
<p>power evaluated at different points</p>
</td></tr>
<tr><td><code id="find_best_+3A_target.power">target.power</code></td>
<td>
<p>goal power</p>
</td></tr>
<tr><td><code id="find_best_+3A_gamma">gamma</code></td>
<td>
<p>Number &gt; 1. The amount we can extend our search range up (gamma)
or down (1/gamma) if we want to search outside our current boundaries.  1
means do not extend (which will potentially cause search to stall, not
recommended).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of estimate of when curve reaches target.power, derivative of
curve at that point, and parameters of the fit curve.
</p>

<hr>
<h2 id='fit_bounded_logistic'>Fit a bounded logistic curve</h2><span id='topic+fit_bounded_logistic'></span>

<h3>Description</h3>

<p>Curve is of form f(y) = pmin + (pmax-pmin) * logistic( beta0 + beta1*x )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_bounded_logistic(x, y, wt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_bounded_logistic_+3A_x">x</code></td>
<td>
<p>The vector of covariate values of the logistics</p>
</td></tr>
<tr><td><code id="fit_bounded_logistic_+3A_y">y</code></td>
<td>
<p>The proportion of 1s for a given value of x.  Same length as x.</p>
</td></tr>
<tr><td><code id="fit_bounded_logistic_+3A_wt">wt</code></td>
<td>
<p>The weight to place on a given x-y pair.  Same length as x, or
scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(logistic as defined by plogis)
Note that a logistic curve is not a perfect fit for the functional
form of the power curve, but is a useful approximation for
the search procedure.
</p>


<h3>Value</h3>

<p>Vector of four estimated parameters for the logistic curve: beta0,
beta1, pmin, pmax
</p>

<hr>
<h2 id='gen_base_sim_data'>Generate base simulated multi-level data (simulation
function)</h2><span id='topic+gen_base_sim_data'></span>

<h3>Description</h3>

<p>Generates simulated data for multi-level RCTs for
pump-supported designs and models for both unobserved potential
outcomes. This function does not generate treatment assignments
or observed outcomes&ndash;see gen_sim_data() for that.
</p>
<p>This method takes in a list of necessary data-generating
parameters, following the rest of the package.
</p>
<p>This function is beyond the main scope of calculating power, and
is instead used for simulating data. For more info on use, see
the simulation vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_base_sim_data(
  param.list,
  pump.object = NULL,
  return.as.dataframe = TRUE,
  no.list = TRUE,
  dgp.params = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_base_sim_data_+3A_param.list">param.list</code></td>
<td>
<p>list; model parameters such as ICC, R2, etc. See
simulation vignette for details.</p>
</td></tr>
<tr><td><code id="gen_base_sim_data_+3A_pump.object">pump.object</code></td>
<td>
<p>A pumpresult object.</p>
</td></tr>
<tr><td><code id="gen_base_sim_data_+3A_return.as.dataframe">return.as.dataframe</code></td>
<td>
<p>TRUE means return list of dataframes,
one for each outcome.  FALSE means return components of the
covariates, etc., in a list.</p>
</td></tr>
<tr><td><code id="gen_base_sim_data_+3A_no.list">no.list</code></td>
<td>
<p>Only relevant if return.as.dataframe=TRUE.
no.list=TRUE means if M=1 return the dataframe, not a list of
length 1.  FALSE means return a list of length 1, even if there
is only 1 outcome.</p>
</td></tr>
<tr><td><code id="gen_base_sim_data_+3A_dgp.params">dgp.params</code></td>
<td>
<p>TRUE means param.list is already converted to DGP
parameters, FALSE means it needs to be converted via
'convert_params()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list; potential outcomes given control y0, treatment y1,
covariates V.k, X.jk, C.ijk, or list of dataframes if
return.as.dataframe = TRUE.
</p>


<h3>See Also</h3>

<p>gen_sim_data
</p>

<hr>
<h2 id='gen_cluster_ids'>Generates school and district assignments (simulation
function)</h2><span id='topic+gen_cluster_ids'></span>

<h3>Description</h3>

<p>Generates simple default schools and districts IDs for
individual students for the purpose of simulations. This assumes
equal sized schools in equal sized districts.
</p>
<p>This function is beyond the main scope of calculating power, and
is instead used for simulating data. For more info on use, see
the simulation vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_cluster_ids(nbar, J, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_cluster_ids_+3A_nbar">nbar</code></td>
<td>
<p>scalar; number of individuals per school.</p>
</td></tr>
<tr><td><code id="gen_cluster_ids_+3A_j">J</code></td>
<td>
<p>scalar; number of schools per district.</p>
</td></tr>
<tr><td><code id="gen_cluster_ids_+3A_k">K</code></td>
<td>
<p>scalar; number of districts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list; school and district assignments (S.id, D.id) for each
individual.
</p>

<hr>
<h2 id='gen_corr_matrix'>Generate correlation matrix (simulation function)</h2><span id='topic+gen_corr_matrix'></span>

<h3>Description</h3>

<p>Generate correlation matrix (simulation function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_corr_matrix(M, rho.scalar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_corr_matrix_+3A_m">M</code></td>
<td>
<p>scalar; dimension of matrix.</p>
</td></tr>
<tr><td><code id="gen_corr_matrix_+3A_rho.scalar">rho.scalar</code></td>
<td>
<p>scalar; rho value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix; M x M correlation matrix
with rho.scalar as diagonal.
</p>

<hr>
<h2 id='gen_cov_matrix'>generate covariance matrix between two variables</h2><span id='topic+gen_cov_matrix'></span>

<h3>Description</h3>

<p>generate covariance matrix between two variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_cov_matrix(D, var1.vec, var2.vec, rho.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_cov_matrix_+3A_d">D</code></td>
<td>
<p>dimension of matrix</p>
</td></tr>
<tr><td><code id="gen_cov_matrix_+3A_var1.vec">var1.vec</code></td>
<td>
<p>vector of variances of first variable</p>
</td></tr>
<tr><td><code id="gen_cov_matrix_+3A_var2.vec">var2.vec</code></td>
<td>
<p>vector of variances of second variable</p>
</td></tr>
<tr><td><code id="gen_cov_matrix_+3A_rho.matrix">rho.matrix</code></td>
<td>
<p>matrix of correlations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sigma matrix of covariance
</p>

<hr>
<h2 id='gen_RE_cov_matrix'>generate a parameterized covariance matrix from the provided 3 blocks</h2><span id='topic+gen_RE_cov_matrix'></span>

<h3>Description</h3>

<p>generate a parameterized covariance matrix from the provided 3 blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_RE_cov_matrix(Sigma.w, Sigma.z, Sigma.wz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_RE_cov_matrix_+3A_sigma.w">Sigma.w</code></td>
<td>
<p>level 3 covariance matrix</p>
</td></tr>
<tr><td><code id="gen_RE_cov_matrix_+3A_sigma.z">Sigma.z</code></td>
<td>
<p>level 2 covariance matrix</p>
</td></tr>
<tr><td><code id="gen_RE_cov_matrix_+3A_sigma.wz">Sigma.wz</code></td>
<td>
<p>covariance between level 2 and level 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2M x 2M matrix for generating correlated pairs of random effects
</p>

<hr>
<h2 id='gen_sim_data'>Generate simulated multi-level data (simulation function)</h2><span id='topic+gen_sim_data'></span>

<h3>Description</h3>

<p>Generates simulated data for multi-level RCTs for
pump-suppored designs and models for both unobserved and observed
potential outcomes.
</p>
<p>Takes in two options: - a pumpresult object OR - a list of
necessary data-generating parameters - the context (d_m) - Tbar
(proportion assigned to treatment)
</p>
<p>This function is beyond the main scope of calculating power, and
is instead used for simulating data. For more info on use, see
the simulation vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_sim_data(
  d_m = NULL,
  param.list = NULL,
  Tbar = 0.5,
  pump.object = NULL,
  return.as.dataframe = TRUE,
  no.list = TRUE,
  include_POs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_sim_data_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="gen_sim_data_+3A_param.list">param.list</code></td>
<td>
<p>list; model parameters such as ICC, R2, etc. See
simulation vignette for details.</p>
</td></tr>
<tr><td><code id="gen_sim_data_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="gen_sim_data_+3A_pump.object">pump.object</code></td>
<td>
<p>A pumpresult object.</p>
</td></tr>
<tr><td><code id="gen_sim_data_+3A_return.as.dataframe">return.as.dataframe</code></td>
<td>
<p>TRUE means return list of dataframes,
one for each outcome.  FALSE means return components of the
covariates, etc., in a list.</p>
</td></tr>
<tr><td><code id="gen_sim_data_+3A_no.list">no.list</code></td>
<td>
<p>Only relevant if return.as.dataframe=TRUE.
no.list=TRUE means if M=1 return the dataframe, not a list of
length 1.  FALSE means return a list of length 1, even if there
is only 1 outcome.</p>
</td></tr>
<tr><td><code id="gen_sim_data_+3A_include_pos">include_POs</code></td>
<td>
<p>Include columns for the potential outcomes in
addition to the observed outcome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list; potential outcomes, covariates, observed outcomes,
and treatment assignment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pp &lt;- pump_power( d_m = "d3.2_m3ff2rc",
                  MTP = "BF",
                  MDES = rep( 0.10, 3 ),
                  M = 3,
                  J = 3, # number of schools/block
                  K = 21, # number RA blocks
                  nbar = 258,
                  Tbar = 0.50, # prop Tx
                  alpha = 0.05, # significance level
                  numCovar.1 = 5, numCovar.2 = 3,
                  R2.1 = 0.1, R2.2 = 0.7,
                  ICC.2 = 0.05, ICC.3 = 0.4,
                  rho = 0.4,
                  tnum = 200
)
sim.data &lt;- gen_sim_data(pump.object = pp)

</code></pre>

<hr>
<h2 id='gen_T.x'>Generate treatment assignment vector (simulation function)</h2><span id='topic+gen_T.x'></span>

<h3>Description</h3>

<p>Given a RCT design and supporting information,
generates treatment assignments for each student.
</p>
<p>This function is beyond the main scope of calculating power,
and is instead used for simulating data.
For more info on use, see the simulation vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_T.x(d_m, S.id, D.id, Tbar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_T.x_+3A_d_m">d_m</code></td>
<td>
<p>string; design and model.</p>
</td></tr>
<tr><td><code id="gen_T.x_+3A_s.id">S.id</code></td>
<td>
<p>vector; school assignments.</p>
</td></tr>
<tr><td><code id="gen_T.x_+3A_d.id">D.id</code></td>
<td>
<p>vector; district assignments.</p>
</td></tr>
<tr><td><code id="gen_T.x_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; probability of treatment assignment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector; treatment assignments for each unit.
</p>

<hr>
<h2 id='gen_Yobs'>Generate observed outcomes (simulation function)</h2><span id='topic+gen_Yobs'></span>

<h3>Description</h3>

<p>Takes in a full dataset of both observed and latent
potential outcomes and the treatment assignment vector, and
returns only the observed outcomes.
</p>
<p>This function is beyond the main scope of calculating power, and
is instead used for simulating data. For more info on use, see
the simulation vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_Yobs(full.data, T.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_Yobs_+3A_full.data">full.data</code></td>
<td>
<p>data.frame; full dataset of potential outcomes.</p>
</td></tr>
<tr><td><code id="gen_Yobs_+3A_t.x">T.x</code></td>
<td>
<p>vector; binary assignment to treat/control.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector; observed outcomes
</p>

<hr>
<h2 id='get_adjp_minp'>Helper function for Westfall Young</h2><span id='topic+get_adjp_minp'></span>

<h3>Description</h3>

<p>enforces monotonicity in p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adjp_minp(ind.B, rawp.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adjp_minp_+3A_ind.b">ind.B</code></td>
<td>
<p>matrix of indicator variables for 
if each raw test statistic exceeds
the null test statistics. 
dimensions: nrow = tnum, ncol = M.</p>
</td></tr>
<tr><td><code id="get_adjp_minp_+3A_rawp.order">rawp.order</code></td>
<td>
<p>order of raw p-values in ascending order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns adjusted p-value matrix
</p>

<hr>
<h2 id='get_power_results'>Calculates different definitions of power (support function)</h2><span id='topic+get_power_results'></span>

<h3>Description</h3>

<p>This function takes in a matrix of adjusted p-values
and unadjusted p-values and outputs different types of power.
</p>
<p>This function is mostly for internal use, but may be of interest
to users who wish to calculate power on their own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_power_results(
  adj.pval.mat,
  unadj.pval.mat,
  ind.nonzero,
  alpha,
  drop.zero.outcomes = TRUE,
  adj = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_power_results_+3A_adj.pval.mat">adj.pval.mat</code></td>
<td>
<p>matrix; adjusted p-values, columns are outcomes</p>
</td></tr>
<tr><td><code id="get_power_results_+3A_unadj.pval.mat">unadj.pval.mat</code></td>
<td>
<p>matrix; unadjusted p-values, columns are
outcomes</p>
</td></tr>
<tr><td><code id="get_power_results_+3A_ind.nonzero">ind.nonzero</code></td>
<td>
<p>vector; which outcomes correspond to nonzero
effects.</p>
</td></tr>
<tr><td><code id="get_power_results_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="get_power_results_+3A_drop.zero.outcomes">drop.zero.outcomes</code></td>
<td>
<p>logical; whether to report power results
for outcomes with MDES = 0.</p>
</td></tr>
<tr><td><code id="get_power_results_+3A_adj">adj</code></td>
<td>
<p>logical; whether p-values are unadjusted or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame; power results for individual, minimum, complete
power.
</p>

<hr>
<h2 id='get_pval_tstat'>Function: get_pval_tstat	                                       
extracts p-value and t statistics from a given fitted model.</h2><span id='topic+get_pval_tstat'></span>

<h3>Description</h3>

<p>Function: get_pval_tstat	                                       
</p>
<p>extracts p-value and t statistics from a given fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pval_tstat(mod, d_m, model.params.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pval_tstat_+3A_mod">mod</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="get_pval_tstat_+3A_d_m">d_m</code></td>
<td>
<p>design/model</p>
</td></tr>
<tr><td><code id="get_pval_tstat_+3A_model.params.list">model.params.list</code></td>
<td>
<p>list of model parameters</p>
</td></tr>
</table>

<hr>
<h2 id='get_rawpt'>Function: get_rawpt</h2><span id='topic+get_rawpt'></span>

<h3>Description</h3>

<p>Fits models to each of a series of datasets, and extracts p values
and t statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rawpt(dat.all, d_m, model.params.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rawpt_+3A_dat.all">dat.all</code></td>
<td>
<p>list of datasets (of length M)</p>
</td></tr>
<tr><td><code id="get_rawpt_+3A_d_m">d_m</code></td>
<td>
<p>design/model</p>
</td></tr>
<tr><td><code id="get_rawpt_+3A_model.params.list">model.params.list</code></td>
<td>
<p>list of model parameters</p>
</td></tr>
</table>

<hr>
<h2 id='interacted_linear_estimators'>Interacted linear regression models</h2><span id='topic+interacted_linear_estimators'></span>

<h3>Description</h3>

<p>Code taken from:
https://github.com/lmiratrix/blkvar/blob_master/R/linear_model_method.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interacted_linear_estimators(
  Yobs,
  Z,
  B,
  siteID = NULL,
  data = NULL,
  control_formula = NULL,
  use.lmer = FALSE
)
</code></pre>


<h3>Details</h3>

<p>These linear models have block by treatment interaction terms.  
The final ATE estimates are then weighted average of the block (site) 
specific ATE estimates.
</p>
<p>If siteID passed, it will weight the RA blocks within site and then average
these site estimates.
</p>
<p>SEs come from the overall variance-covariance matrix.
</p>


<h3>Value</h3>

<p>Dataframe of the different versions of this estimator (person and
site weighted)
</p>

<hr>
<h2 id='make_model'>Function: make.model</h2><span id='topic+make_model'></span>

<h3>Description</h3>

<p>Function to generate and fit a model to a simulated dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_model(dat.m, d_m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_model_+3A_dat.m">dat.m</code></td>
<td>
<p>a data frame for a single outcome</p>
</td></tr>
<tr><td><code id="make_model_+3A_d_m">d_m</code></td>
<td>
<p>design/model</p>
</td></tr>
</table>

<hr>
<h2 id='makelist_samp'>Convert multi-outcome data structure to dataframe for each outcome.</h2><span id='topic+makelist_samp'></span>

<h3>Description</h3>

<p>Given the simulated multi-outcome structure, make a list of
complete (tidy) rectangular datasets, one for each outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makelist_samp(samp.obs, T.x = NULL, include_POs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makelist_samp_+3A_samp.obs">samp.obs</code></td>
<td>
<p>a single iteration of observed data</p>
</td></tr>
<tr><td><code id="makelist_samp_+3A_t.x">T.x</code></td>
<td>
<p>vector of treatment assignments</p>
</td></tr>
<tr><td><code id="makelist_samp_+3A_include_pos">include_POs</code></td>
<td>
<p>Include columns for the potential outcomes in
addition to the observed outcome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of dataframes.
</p>

<hr>
<h2 id='optimize_power'>Optimizes power to help in search for MDES or SS</h2><span id='topic+optimize_power'></span>

<h3>Description</h3>

<p>Optimizes power to help in search for MDES or SS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_power(
  d_m,
  search.type,
  MTP,
  target.power,
  power.definition,
  tol,
  start.low,
  start.high,
  MDES = NULL,
  J = NULL,
  K = 1,
  nbar = NULL,
  M = M,
  numZero = numZero,
  Tbar = Tbar,
  alpha,
  two.tailed,
  numCovar.1 = 0,
  numCovar.2 = 0,
  numCovar.3 = 0,
  R2.1 = 0,
  R2.2 = 0,
  R2.3 = 0,
  ICC.2 = 0,
  ICC.3 = 0,
  omega.2 = 0,
  omega.3 = 0,
  rho,
  B = NULL,
  parallel.WY.cores = 1,
  max.steps = 20,
  tnum = 1000,
  start.tnum = round(tnum/10),
  final.tnum = 4 * tnum,
  give.warnings = FALSE,
  grid.only = FALSE,
  grid.size = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_power_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_search.type">search.type</code></td>
<td>
<p>type of optimization search being conducted.
Options: K, J, nbar, mdes</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_target.power">target.power</code></td>
<td>
<p>target power for search algorithm.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_power.definition">power.definition</code></td>
<td>
<p>see pump_info() for
possible power definitions.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_tol">tol</code></td>
<td>
<p>tolerance for target power, defaults to 0.01 (1
This parameter controls when the search is done:
when estimated power (checked with 'final.tnum' iterations)
is within 'tol', the search stops.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_start.low">start.low</code></td>
<td>
<p>lower bound for optimization procedure</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_start.high">start.high</code></td>
<td>
<p>upper bound for optimization procedure</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_mdes">MDES</code></td>
<td>
<p>scalar or vector; the desired MDES values for each
outcome. Please provide a scalar, a vector of length M, or vector
of values for non-zero outcomes.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_two.tailed">two.tailed</code></td>
<td>
<p>scalar; TRUE/FALSE for two-tailed or one-tailed
power calculation.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_b">B</code></td>
<td>
<p>scalar; the number of permutations for Westfall-Young
procedures.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_parallel.wy.cores">parallel.WY.cores</code></td>
<td>
<p>number of cores to use for parallel
processing of WY-SD.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_max.steps">max.steps</code></td>
<td>
<p>how many steps allowed before terminating.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_tnum">tnum</code></td>
<td>
<p>scalar; the number of test statistics to draw.
Increasing tnum increases precision and computation time.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_start.tnum">start.tnum</code></td>
<td>
<p>number of samples to start search
(this will increase with each step).</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_final.tnum">final.tnum</code></td>
<td>
<p>number of samples for final draw.</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_give.warnings">give.warnings</code></td>
<td>
<p>whether to return optimizer warnings</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_grid.only">grid.only</code></td>
<td>
<p>TRUE means generate a grid from start.low to start.high, 
but do not do iterative search. (Useful for mapping out the power 
curve rather than identifying a point of particular power.)</p>
</td></tr>
<tr><td><code id="optimize_power_+3A_grid.size">grid.size</code></td>
<td>
<p>Number of points to check in initial search grid.
Grid will be spaced as a quadratic sequence 
(e.g., 0, 1, 4, 9, 16 for a 0-16 span).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>power
</p>

<hr>
<h2 id='parse_d_m'>Return characteristics of a given context/d_m code (support function)</h2><span id='topic+parse_d_m'></span>

<h3>Description</h3>

<p>Returns number of levels and model at each level.
See pump_info()$Context to get a list of supported d_ms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_d_m(d_m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_d_m_+3A_d_m">d_m</code></td>
<td>
<p>string; context to parse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list; list of features including number of levels,
level of randomization, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>supported &lt;- pump_info(comment = FALSE)$Context
parse_d_m( supported$d_m[4] )

</code></pre>

<hr>
<h2 id='parse_power_definition'>Parse the power definition</h2><span id='topic+parse_power_definition'></span>

<h3>Description</h3>

<p>Parse the power definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_power_definition(power.definition, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_power_definition_+3A_power.definition">power.definition</code></td>
<td>
<p>i.e. D1indiv, min1, complete</p>
</td></tr>
<tr><td><code id="parse_power_definition_+3A_m">M</code></td>
<td>
<p>number of outcomes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>information about power type
</p>

<hr>
<h2 id='plot_power_curve'>Examine a power curve (result function)</h2><span id='topic+plot_power_curve'></span>

<h3>Description</h3>

<p>This will give a plot of power vs. MDES or sample size. It can
be useful to see how quickly power changes as a function of these design
parameters. Can be useful to diagnose relatively flat power curves, where
power changes little as a function of MDES or sample size, and can also be
useful to gauge where convergence went poorly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_power_curve(
  pwr,
  plot.points = TRUE,
  all = TRUE,
  low = NULL,
  high = NULL,
  grid.size = 5,
  tnum = 2000,
  breaks = grid.size,
  fit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_power_curve_+3A_pwr">pwr</code></td>
<td>
<p>pumpresult object or data.frame; result from calling 
pump_sample or pump_mdes (or data frame from, e.g., power_curve()).</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_plot.points">plot.points</code></td>
<td>
<p>logical; whether to plot individually 
tested points on curve.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_all">all</code></td>
<td>
<p>logical; if TRUE, merge in the search path from the
original search.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_low">low</code></td>
<td>
<p>scalar; low range for curve.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_high">high</code></td>
<td>
<p>scalar; high range for the curve.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_grid.size">grid.size</code></td>
<td>
<p>scalar; number of points to calculate power for.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_tnum">tnum</code></td>
<td>
<p>scalar; number of iterations to calculate power at each
grid point.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_breaks">breaks</code></td>
<td>
<p>scalar; the desired number of tick marks on the axes.</p>
</td></tr>
<tr><td><code id="plot_power_curve_+3A_fit">fit</code></td>
<td>
<p>a four parameter bounded logistic curve 
(if NULL will fit one to passed points).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot; a ggplot object of power across values.
</p>

<hr>
<h2 id='plot_power_search'>Examine search path of a power search (result function)</h2><span id='topic+plot_power_search'></span>

<h3>Description</h3>

<p>This will give triple-plots about 
how the search narrowed down into the
final estimate.  Can be useful to gauge where 
convergence went poorly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_power_search(pwr, fit = NULL, target.line = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_power_search_+3A_pwr">pwr</code></td>
<td>
<p>pumpresult object; result from a 
pump_sample or pump_mdes call.</p>
</td></tr>
<tr><td><code id="plot_power_search_+3A_fit">fit</code></td>
<td>
<p>a fitted curve to the search.</p>
</td></tr>
<tr><td><code id="plot_power_search_+3A_target.line">target.line</code></td>
<td>
<p>scalar; if non-NULL, add a reference line 
for the true power (if known, e.g., from a pump_power call).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot; a ggplot object
(a ggpubr arrangement of 3 plots, technically) of the
search path.
</p>

<hr>
<h2 id='plot.pumpgridresult'>Plot a pumpgridresult object (result function)</h2><span id='topic+plot.pumpgridresult'></span>

<h3>Description</h3>

<p>Plots grid results across values of a single parameter, specified by
the user using var.vary, for a single definition of power, specified
by power.definition.
</p>
<p>If multiple things vary in the grid, the outcome (power, mdes, or
sample size) will be averaged (marginalized) across the other
varying factors. This treats the grid as a multifactor simulation,
with this showing the &quot;main effect&quot; of the specified parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpgridresult'
plot(
  x,
  power.definition = NULL,
  var.vary = NULL,
  color = "MTP",
  lines = TRUE,
  include.title = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pumpgridresult_+3A_x">x</code></td>
<td>
<p>pumpgridresult object.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult_+3A_power.definition">power.definition</code></td>
<td>
<p>string; definition of power to plot. If
NULL, plot all definitions as a facet wrap.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult_+3A_var.vary">var.vary</code></td>
<td>
<p>string; variable to vary on X axis. If NULL, and
only one thing varies, then it will default to single varying
parameter.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult_+3A_color">color</code></td>
<td>
<p>string; Group lines by this element to make an
interaction plot (default &quot;MTP&quot;, giving one curve for each MTP).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult_+3A_lines">lines</code></td>
<td>
<p>logical; TRUE means connect dots with lines on the
plots. FALSE means no lines.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult_+3A_include.title">include.title</code></td>
<td>
<p>logical; whether to include/exclude title (if
planning a facet wrap, for example).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot; a ggplot object of outcome across parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- pump_power_grid( d_m = "d3.2_m3ff2rc", MTP = c( "HO", "BF" ),
 MDES = 0.10, J = seq(5, 10, 1), M = 5, K = 7, nbar = 58,
 Tbar = 0.50, alpha = 0.15, numCovar.1 = 1,
 numCovar.2 = 1, R2.1 = 0.1, R2.2 = 0.7,
 ICC.2 = 0.25, ICC.3 = 0.25, rho = 0.4, tnum = 200)
plot(g, power.definition = 'min1')
</code></pre>

<hr>
<h2 id='plot.pumpgridresult.mdes'>Plot a grid pump mdes object</h2><span id='topic+plot.pumpgridresult.mdes'></span>

<h3>Description</h3>

<p>Plot a grid pump mdes object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpgridresult.mdes'
plot(
  x,
  power.definition = NULL,
  var.vary,
  color = "MTP",
  lines = TRUE,
  include.title = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_x">x</code></td>
<td>
<p>pumpgridresult object.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_power.definition">power.definition</code></td>
<td>
<p>string; definition of power to plot. If
NULL, plot all definitions as a facet wrap.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_var.vary">var.vary</code></td>
<td>
<p>string; variable to vary on X axis. If NULL, and
only one thing varies, then it will default to single varying
parameter.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_color">color</code></td>
<td>
<p>string; Group lines by this element to make an
interaction plot (default &quot;MTP&quot;, giving one curve for each MTP).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_lines">lines</code></td>
<td>
<p>logical; TRUE means connect dots with lines on the
plots. FALSE means no lines.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_include.title">include.title</code></td>
<td>
<p>logical; whether to include/exclude title (if
planning a facet wrap, for example).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.mdes_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.pumpgridresult.power'>Plot a grid pump power object</h2><span id='topic+plot.pumpgridresult.power'></span>

<h3>Description</h3>

<p>Plot a grid pump power object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpgridresult.power'
plot(
  x,
  power.definition = NULL,
  var.vary = NULL,
  lines = TRUE,
  include.title = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pumpgridresult.power_+3A_x">x</code></td>
<td>
<p>pumpgridresult object.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.power_+3A_power.definition">power.definition</code></td>
<td>
<p>string; definition of power to plot. If
NULL, plot all definitions as a facet wrap.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.power_+3A_var.vary">var.vary</code></td>
<td>
<p>string; variable to vary on X axis. If NULL, and
only one thing varies, then it will default to single varying
parameter.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.power_+3A_lines">lines</code></td>
<td>
<p>logical; TRUE means connect dots with lines on the
plots. FALSE means no lines.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.power_+3A_include.title">include.title</code></td>
<td>
<p>logical; whether to include/exclude title (if
planning a facet wrap, for example).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.power_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot; a ggplot object
</p>

<hr>
<h2 id='plot.pumpgridresult.sample'>Plot a grid pump sample object</h2><span id='topic+plot.pumpgridresult.sample'></span>

<h3>Description</h3>

<p>Plot a grid pump sample object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpgridresult.sample'
plot(
  x,
  power.definition = NULL,
  var.vary,
  color = "MTP",
  lines = TRUE,
  include.title = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pumpgridresult.sample_+3A_x">x</code></td>
<td>
<p>pumpgridresult object.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.sample_+3A_power.definition">power.definition</code></td>
<td>
<p>string; definition of power to plot. If
NULL, plot all definitions as a facet wrap.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.sample_+3A_var.vary">var.vary</code></td>
<td>
<p>string; variable to vary on X axis. If NULL, and
only one thing varies, then it will default to single varying
parameter.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.sample_+3A_color">color</code></td>
<td>
<p>string; Group lines by this element to make an
interaction plot (default &quot;MTP&quot;, giving one curve for each MTP).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.sample_+3A_lines">lines</code></td>
<td>
<p>logical; TRUE means connect dots with lines on the
plots. FALSE means no lines.</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.sample_+3A_include.title">include.title</code></td>
<td>
<p>logical; whether to include/exclude title (if
planning a facet wrap, for example).</p>
</td></tr>
<tr><td><code id="plot.pumpgridresult.sample_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.pumpresult'>Plot a pumpresult object (result function)</h2><span id='topic+plot.pumpresult'></span>

<h3>Description</h3>

<p>For the object returned by pump_power(), visualizes
different definitions of power across MTPs. For the object
returned by pump_mdes() or pump_sample(), plot a power curve as a
function of MDES or sample size, respectively.  This latter call
will calculate power over a passed range from low to high to
generate this curve.
</p>
<p>Several of the passed parameters only apply to the mdes or sample
versions, and are for controlling the grid search and plot.
</p>
<p>For pump_power, will include standard errors of uncertainty on
calculated power. These depend on number of iterations (tnum)
used in the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpresult'
plot(
  x,
  type = "power",
  all = TRUE,
  low = NULL,
  high = NULL,
  grid.size = 5,
  breaks = grid.size,
  include_SE = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pumpresult_+3A_x">x</code></td>
<td>
<p>pumpresult object.</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_type">type</code></td>
<td>
<p>string; &quot;power&quot; or &quot;search&quot;. Specifies whether to plot
the default power graph, or the search path. The search path is
only valid for MDES and SS results.</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_all">all</code></td>
<td>
<p>Logical. If TRUE, merge in the search path from the
original search to the estimated power curve, for MDES or sample
plots.</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_low">low</code></td>
<td>
<p>Low range of x-axis and curve calculation for sample or
MDES plots.  (Optional.)</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_high">high</code></td>
<td>
<p>High range of x-axis and curve calculation. (Optional.)</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_grid.size">grid.size</code></td>
<td>
<p>If calculating curve for sample or MDES plot, how
many grid points?</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_breaks">breaks</code></td>
<td>
<p>If plotting a curve for sample or MDES, where to put
the grid points?</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_include_se">include_SE</code></td>
<td>
<p>Include (approximate) SEs on the power estimates,
if they are naturally calculated.</p>
</td></tr>
<tr><td><code id="plot.pumpresult_+3A_...">...</code></td>
<td>
<p>additional parameters, such as, in case of sample or
mdes objects, tnum for setting number of replicates or all
(logical) for determining whether to include original points in
the estimated curve, or include.points  (logical) for including
points on the plot itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot; a ggplot object of power across different
definitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pp1 &lt;- pump_power(d_m = "d2.2_m2rc", MTP = 'HO',
 nbar = 50, J = 20, M = 8, numZero = 5,
 MDES = 0.30, Tbar = 0.5, alpha = 0.05, two.tailed = FALSE,
 numCovar.1 = 1, numCovar.2 = 1, R2.1 = 0.1, R2.2 = 0.7,
 ICC.2 = 0.05, rho = 0.2, tnum = 200)

plot(pp1)

J &lt;- pump_sample(d_m = "d2.1_m2fc",
   MTP = 'HO', power.definition = 'D1indiv',
   typesample = 'J', target.power = 0.6,
   nbar = 50, M = 3, MDES = 0.125,
   Tbar = 0.5, alpha = 0.05,
   numCovar.1 = 1, R2.1 = 0.1, ICC.2 = 0.05,
   rho = 0.2, tnum = 500)
plot(J)
plot(J, type = "search")

</code></pre>

<hr>
<h2 id='power_curve'>Obtain a power curve for a range of sample size or MDES values</h2><span id='topic+power_curve'></span>

<h3>Description</h3>

<p>This is used to see how power changes as a function of
sample size or MDES.  It takes a fit pumpresult and calculates a power
curve based on that scenario coupled with a passed range of
values to make the curve over.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_curve(
  x,
  all = FALSE,
  low = NULL,
  high = NULL,
  grid.size = 5,
  tnum = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_curve_+3A_x">x</code></td>
<td>
<p>a pumpresult object.</p>
</td></tr>
<tr><td><code id="power_curve_+3A_all">all</code></td>
<td>
<p>logical; if TRUE, merge in the search path from the
original search.</p>
</td></tr>
<tr><td><code id="power_curve_+3A_low">low</code></td>
<td>
<p>scalar; low range for curve.</p>
</td></tr>
<tr><td><code id="power_curve_+3A_high">high</code></td>
<td>
<p>scalar; high range for the curve.</p>
</td></tr>
<tr><td><code id="power_curve_+3A_grid.size">grid.size</code></td>
<td>
<p>scalar; number of points to calculate power for.</p>
</td></tr>
<tr><td><code id="power_curve_+3A_tnum">tnum</code></td>
<td>
<p>scalar; number of iterations to calculate power at each
grid point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of power results.
</p>

<hr>
<h2 id='print_context'>Print context (design, model, parameter values) of 
pumpresult or pumpgridresult (result function)</h2><span id='topic+print_context'></span>

<h3>Description</h3>

<p>Print out the context (design and model, with parameter values) of 
given pump result or pump grid result object.  
The &quot;***&quot; denotes varying values in the
printout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_context(x, insert_results = FALSE, insert_control = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_context_+3A_x">x</code></td>
<td>
<p>A pumpresult object or pumpgridresult object.</p>
</td></tr>
<tr><td><code id="print_context_+3A_insert_results">insert_results</code></td>
<td>
<p>Include actual results in the printout.</p>
</td></tr>
<tr><td><code id="print_context_+3A_insert_control">insert_control</code></td>
<td>
<p>Include the optimizer control parameter information.</p>
</td></tr>
<tr><td><code id="print_context_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to print.pumpresult.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; prints results.
</p>

<hr>
<h2 id='print_search'>Print the search history of a pump result object (result function)</h2><span id='topic+print_search'></span>

<h3>Description</h3>

<p>For pump_mdes and pump_sample, print the 
(abbreviated) search history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_search(x, n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_search_+3A_x">x</code></td>
<td>
<p>a pumpresult object (except for is.pumpresult, 
where it is a generic object to check).</p>
</td></tr>
<tr><td><code id="print_search_+3A_n">n</code></td>
<td>
<p>Number of lines of search path to print, max.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; prints results.
</p>

<hr>
<h2 id='pump_info'>Provides details about supported package features (core function)</h2><span id='topic+pump_info'></span>

<h3>Description</h3>

<p>List user options:
designs and models (d_m), including what
parameters are relevant for each context;
multiple testing procedures;
types of power;
design and model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_info(
  topic = c("all", "context", "adjustment", "power", "parameters"),
  comment = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_info_+3A_topic">topic</code></td>
<td>
<p>string; what kind of info. One of:
all, context, adjustment, power, parameters.</p>
</td></tr>
<tr><td><code id="pump_info_+3A_comment">comment</code></td>
<td>
<p>logical; prints out
long description of
each design and method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list; a list of data frames with
information about each topic.
</p>


<h3>See Also</h3>

<p>For more detailed information about user choices,
see the manuscript &lt;doi:10.18637/jss.v108.i06&gt;,
which includes a detailed Technical Appendix
including information about the designs and models
and parameters.
</p>

<hr>
<h2 id='pump_mdes'>Estimate the minimum detectable effect size (MDES) (core function)</h2><span id='topic+pump_mdes'></span>

<h3>Description</h3>

<p>The user chooses the context (d_m), MTP,
power definition, and choices of all relevant design parameters.
</p>
<p>The functions performs a search algorithm,
and returns the MDES value within the specified tolerance.
For a list of choices for specific parameters, see pump_info().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_mdes(
  d_m,
  MTP = NULL,
  numZero = NULL,
  propZero = NULL,
  M = 1,
  nbar,
  J = 1,
  K = 1,
  Tbar,
  alpha = 0.05,
  two.tailed = TRUE,
  target.power = 0.8,
  power.definition,
  tol = 0.02,
  numCovar.1 = 0,
  numCovar.2 = 0,
  numCovar.3 = 0,
  R2.1 = 0,
  R2.2 = 0,
  R2.3 = 0,
  ICC.2 = 0,
  ICC.3 = 0,
  omega.2 = 0,
  omega.3 = 0,
  rho = NULL,
  rho.matrix = NULL,
  B = 1000,
  max.steps = 20,
  tnum = 1000,
  start.tnum = round(tnum/10),
  final.tnum = 4 * tnum,
  parallel.WY.cores = 1,
  updateProgress = NULL,
  give.optimizer.warnings = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_mdes_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_propzero">propZero</code></td>
<td>
<p>scalar; proportion of outcomes assumed to be zero
(alternative specification to numZero).  length(MDES) should be 1
or equal to (1-propZero)*M.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_two.tailed">two.tailed</code></td>
<td>
<p>scalar; TRUE/FALSE for two-tailed or one-tailed
power calculation.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_target.power">target.power</code></td>
<td>
<p>target power for search algorithm.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_power.definition">power.definition</code></td>
<td>
<p>see pump_info() for
possible power definitions.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_tol">tol</code></td>
<td>
<p>tolerance for target power, defaults to 0.01 (1
This parameter controls when the search is done:
when estimated power (checked with 'final.tnum' iterations)
is within 'tol', the search stops.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_rho.matrix">rho.matrix</code></td>
<td>
<p>matrix; alternate specification allowing a full
matrix of correlations between test statistics. Must specify
either rho or rho.matrix, but not both.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_b">B</code></td>
<td>
<p>scalar; the number of permutations for Westfall-Young
procedures.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_max.steps">max.steps</code></td>
<td>
<p>how many steps allowed before terminating.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_tnum">tnum</code></td>
<td>
<p>max number of samples for first iteration
of search algorithm.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_start.tnum">start.tnum</code></td>
<td>
<p>number of samples to start search
(this will increase with each step).</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_final.tnum">final.tnum</code></td>
<td>
<p>number of samples for final draw.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_parallel.wy.cores">parallel.WY.cores</code></td>
<td>
<p>number of cores to use for parallel
processing of WY-SD.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_updateprogress">updateProgress</code></td>
<td>
<p>function to update progress bar (only used
for PUMP shiny app).</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_give.optimizer.warnings">give.optimizer.warnings</code></td>
<td>
<p>whether to return
verbose optimizer warnings.</p>
</td></tr>
<tr><td><code id="pump_mdes_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE; Print out diagnostics of time, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpresult object containing MDES results.
</p>


<h3>See Also</h3>

<p>For more detailed information about this function
and the user choices,
see the manuscript &lt;doi:10.18637/jss.v108.i06&gt;,
which includes a detailed Technical Appendix
including information about the designs and models
and parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdes &lt;-  pump_mdes(
  d_m = "d3.1_m3rr2rr",
  MTP = 'HO',
  power.definition = 'D1indiv',
  target.power = 0.6,
  J = 30,
  K = 15,
  nbar = 50,
  M = 3,
  Tbar = 0.5, alpha = 0.05,
  two.tailed = FALSE,
  numCovar.1 = 1, numCovar.2 = 1,
  R2.1 = 0.1, R2.2 = 0.1,
  ICC.2 = 0.2, ICC.3 = 0.2,
  omega.2 = 0.1, omega.3 = 0.1,
  rho = 0.5, tnum = 2000)
</code></pre>

<hr>
<h2 id='pump_mdes_grid'>Run pump_mdes on varying values of parameters (grid function)</h2><span id='topic+pump_mdes_grid'></span>

<h3>Description</h3>

<p>See pump_power_grid() for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_mdes_grid(
  d_m,
  MTP = NULL,
  M = 1,
  target.power,
  power.definition,
  tol = 0.01,
  propZero = NULL,
  numZero = NULL,
  nbar,
  J = 1,
  K = 1,
  Tbar,
  alpha,
  numCovar.1 = NULL,
  numCovar.2 = NULL,
  numCovar.3 = NULL,
  R2.1 = NULL,
  R2.2 = NULL,
  R2.3 = NULL,
  ICC.2 = NULL,
  ICC.3 = NULL,
  omega.2 = NULL,
  omega.3 = NULL,
  rho = NULL,
  verbose = FALSE,
  drop.unique.columns = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_mdes_grid_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_target.power">target.power</code></td>
<td>
<p>target power for search algorithm.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_power.definition">power.definition</code></td>
<td>
<p>see pump_info() for
possible power definitions.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_tol">tol</code></td>
<td>
<p>tolerance for target power, defaults to 0.01 (1
This parameter controls when the search is done:
when estimated power (checked with 'final.tnum' iterations)
is within 'tol', the search stops.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_propzero">propZero</code></td>
<td>
<p>scalar; proportion of outcomes assumed to be zero
(alternative specification to numZero).  length(MDES) should be 1
or equal to (1-propZero)*M.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE; Print out diagnostics of time, etc.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_drop.unique.columns">drop.unique.columns</code></td>
<td>
<p>logical; drop all parameter columns that
did not vary across the grid.</p>
</td></tr>
<tr><td><code id="pump_mdes_grid_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the underlying pump_power,
pump_sample, or pump_mdes functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpgridresult object containing MDES results.
</p>


<h3>See Also</h3>

<p>Other grid functions: 
<code><a href="#topic+pump_power_grid">pump_power_grid</a>()</code>,
<code><a href="#topic+pump_sample_grid">pump_sample_grid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- pump_mdes_grid(d_m = "d3.2_m3ff2rc", MTP = "HO",
  target.power = c( 0.50, 0.80 ), power.definition = "D1indiv",
  tol = 0.05, M = 5, J = c( 3, 9 ), K = 7, nbar = 58,
  Tbar = 0.50, alpha = 0.15, numCovar.1 = 1, numCovar.2 = 1,
  R2.1 = 0.1, R2.2 = 0.7, ICC.2 = 0.05, ICC.3 = 0.9,
  rho = 0.4, tnum = 200)
</code></pre>

<hr>
<h2 id='pump_power'>Estimate power across definitions (core function)</h2><span id='topic+pump_power'></span>

<h3>Description</h3>

<p>The user chooses the context (d_m), MTP, MDES, and
choices of all relevant design parameters.
</p>
<p>The functions returns power for all definitions of power for any
MTP. For a list of choices for specific parameters, see
pump_info().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_power(
  d_m,
  MTP = NULL,
  MDES,
  numZero = NULL,
  propZero = NULL,
  M = 1,
  nbar,
  J = 1,
  K = 1,
  Tbar,
  alpha = 0.05,
  two.tailed = TRUE,
  numCovar.1 = 0,
  numCovar.2 = 0,
  numCovar.3 = 0,
  R2.1 = 0,
  R2.2 = 0,
  R2.3 = 0,
  ICC.2 = 0,
  ICC.3 = 0,
  omega.2 = 0,
  omega.3 = 0,
  rho = NULL,
  rho.matrix = NULL,
  tnum = 10000,
  B = 1000,
  parallel.WY.cores = 1,
  drop.zero.outcomes = TRUE,
  updateProgress = NULL,
  validate.inputs = TRUE,
  long.table = FALSE,
  verbose = FALSE,
  exact.where.possible = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_power_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_mdes">MDES</code></td>
<td>
<p>scalar or vector; the desired MDES values for each
outcome. Please provide a scalar, a vector of length M, or vector
of values for non-zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_propzero">propZero</code></td>
<td>
<p>scalar; proportion of outcomes assumed to be zero
(alternative specification to numZero).  length(MDES) should be 1
or equal to (1-propZero)*M.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_power_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_power_+3A_two.tailed">two.tailed</code></td>
<td>
<p>scalar; TRUE/FALSE for two-tailed or one-tailed
power calculation.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_rho.matrix">rho.matrix</code></td>
<td>
<p>matrix; alternate specification allowing a full
matrix of correlations between test statistics. Must specify
either rho or rho.matrix, but not both.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_tnum">tnum</code></td>
<td>
<p>scalar; the number of test statistics to draw.
Increasing tnum increases precision and computation time.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_b">B</code></td>
<td>
<p>scalar; the number of permutations for Westfall-Young
procedures.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_parallel.wy.cores">parallel.WY.cores</code></td>
<td>
<p>number of cores to use for parallel
processing of WY-SD.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_drop.zero.outcomes">drop.zero.outcomes</code></td>
<td>
<p>whether to report power results for
outcomes with MDES = 0.  If ALL MDES = 0, then the first outcome
will not be dropped.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_updateprogress">updateProgress</code></td>
<td>
<p>function to update progress bar (only used
for PUMP shiny app).</p>
</td></tr>
<tr><td><code id="pump_power_+3A_validate.inputs">validate.inputs</code></td>
<td>
<p>TRUE/FALSE; whether or not to check whether
parameters are valid given the choice of d_m.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_long.table">long.table</code></td>
<td>
<p>TRUE for table with power as rows, correction as
columns, and with more verbose names. See
'transpose_power_table'.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE; Print out diagnostics of time, etc.</p>
</td></tr>
<tr><td><code id="pump_power_+3A_exact.where.possible">exact.where.possible</code></td>
<td>
<p>TRUE/FALSE; whether to do exact
calculations when M=1, or use simulation.  Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpresult object containing power results.
</p>


<h3>See Also</h3>

<p>For more detailed information about this function and the
user choices, see the manuscript &lt;doi:10.18637/jss.v108.i06&gt;,
which includes a detailed Technical Appendix including
information about the designs and models and parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pp &lt;- pump_power(
   d_m = "d3.2_m3ff2rc",
   MTP = 'HO',
   nbar = 50,
   J = 30,
   K = 10,
   M = 5,
   MDES = 0.125,
   Tbar = 0.5, alpha = 0.05,
   numCovar.1 = 1, numCovar.2 = 1,
   R2.1 = 0.1, R2.2 = 0.1,
   ICC.2 = 0.2, ICC.3 = 0.2,
   omega.2 = 0, omega.3 = 0.1,
   rho = 0.5)

</code></pre>

<hr>
<h2 id='pump_power_exact'>Calculate power theoretically for M=1 situations</h2><span id='topic+pump_power_exact'></span>

<h3>Description</h3>

<p>Calculate power theoretically for M=1 situations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_power_exact(MDES, SE, df, alpha, two.tailed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_power_exact_+3A_mdes">MDES</code></td>
<td>
<p>MDES (single number)</p>
</td></tr>
<tr><td><code id="pump_power_exact_+3A_se">SE</code></td>
<td>
<p>Calculated SE of the estimator</p>
</td></tr>
<tr><td><code id="pump_power_exact_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the estimator (often approximated).</p>
</td></tr>
<tr><td><code id="pump_power_exact_+3A_alpha">alpha</code></td>
<td>
<p>Alpha for the planned test.</p>
</td></tr>
<tr><td><code id="pump_power_exact_+3A_two.tailed">two.tailed</code></td>
<td>
<p>TRUE/FALSE  Two- or one-sided test?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row Tibble with columns or power, SE, and DF.  MTP
column with value of &quot;None&quot;.
</p>

<hr>
<h2 id='pump_power_grid'>Run pump_power on varying values of parameters (grid
function)</h2><span id='topic+pump_power_grid'></span>

<h3>Description</h3>

<p>This extension of 'pump_power()' will take lists of
parameter values and run 'pump_power()' on all combinations of
these values.
</p>
<p>It can only assume the same MDES value for all outcomes due to
this.  (I.e., a vector of MDES values will be interpreted as a
sequence of calls to pump_power, one for each MDES value given).
</p>
<p>Each parameter in the parameter list can be a list, not scalar.
It will cross all combinations of the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_power_grid(
  d_m,
  MTP = NULL,
  MDES,
  M = 1,
  nbar,
  J = 1,
  K = 1,
  propZero = NULL,
  numZero = NULL,
  Tbar,
  alpha = 0.05,
  numCovar.1 = NULL,
  numCovar.2 = NULL,
  numCovar.3 = NULL,
  R2.1 = NULL,
  R2.2 = NULL,
  R2.3 = NULL,
  ICC.2 = NULL,
  ICC.3 = NULL,
  omega.2 = NULL,
  omega.3 = NULL,
  rho = NULL,
  long.table = FALSE,
  verbose = FALSE,
  drop.unique.columns = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_power_grid_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_mdes">MDES</code></td>
<td>
<p>vector of numeric; This is *not* a list of MDES for
each outcome, but rather a list of MDES to explore. Each value
will be assumed held constant across all M outcomes.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_propzero">propZero</code></td>
<td>
<p>Proportion of outcomes that have 0 impact (this
will be used to override numZero, only one can be defined)</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_long.table">long.table</code></td>
<td>
<p>TRUE for table with power as rows, correction as
columns, and with more verbose names. See
'transpose_power_table'.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_verbose">verbose</code></td>
<td>
<p>logical; TRUE means print out some text as calls
processed.  FALSE do not.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_drop.unique.columns">drop.unique.columns</code></td>
<td>
<p>logical; drop all parameter columns that
did not vary across the grid.</p>
</td></tr>
<tr><td><code id="pump_power_grid_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the underlying pump_power,
pump_sample, or pump_mdes functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpgridresult object containing power results.
</p>


<h3>See Also</h3>

<p>Other grid functions: 
<code><a href="#topic+pump_mdes_grid">pump_mdes_grid</a>()</code>,
<code><a href="#topic+pump_sample_grid">pump_sample_grid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- pump_power_grid( d_m = "d3.2_m3ff2rc", MTP = c( "HO", "BF" ),
 MDES = 0.10, J = seq(5, 10, 1), M = 5, K = 7, nbar = 58,
 Tbar = 0.50, alpha = 0.15, numCovar.1 = 1,
 numCovar.2 = 1, R2.1 = 0.1, R2.2 = 0.7,
 ICC.2 = 0.25, ICC.3 = 0.25, rho = 0.4, tnum = 1000)
</code></pre>

<hr>
<h2 id='pump_sample'>Estimate the required sample size (core function)</h2><span id='topic+pump_sample'></span>

<h3>Description</h3>

<p>The user chooses the context (d_m), MTP,
type of sample size,
MDES,
power definition, and choices of all relevant design parameters.
</p>
<p>The functions performs a search algorithm,
and returns the sample size value within the specified tolerance.
For a list of choices for specific parameters, see pump_info().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_sample(
  d_m,
  MTP = NULL,
  typesample,
  MDES,
  M = 1,
  numZero = NULL,
  nbar = NULL,
  J = NULL,
  K = NULL,
  target.power,
  power.definition,
  alpha,
  two.tailed = TRUE,
  Tbar,
  numCovar.1 = 0,
  numCovar.2 = 0,
  numCovar.3 = 0,
  R2.1 = 0,
  R2.2 = 0,
  R2.3 = 0,
  ICC.2 = 0,
  ICC.3 = 0,
  rho = NULL,
  rho.matrix = NULL,
  omega.2 = 0,
  omega.3 = 0,
  B = 1000,
  max.steps = 20,
  tnum = 1000,
  start.tnum = tnum/10,
  final.tnum = 4 * tnum,
  parallel.WY.cores = 1,
  updateProgress = NULL,
  max_sample_size_nbar = 10000,
  max_sample_size_JK = 1000,
  tol = 0.01,
  give.optimizer.warnings = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_sample_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_typesample">typesample</code></td>
<td>
<p>string; type of sample size to
calculate: &quot;nbar&quot;, &quot;J&quot;, or &quot;K&quot;.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_mdes">MDES</code></td>
<td>
<p>scalar or vector; the desired MDES values for each
outcome. Please provide a scalar, a vector of length M, or vector
of values for non-zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_target.power">target.power</code></td>
<td>
<p>target power for search algorithm.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_power.definition">power.definition</code></td>
<td>
<p>see pump_info() for
possible power definitions.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_two.tailed">two.tailed</code></td>
<td>
<p>scalar; TRUE/FALSE for two-tailed or one-tailed
power calculation.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_rho.matrix">rho.matrix</code></td>
<td>
<p>matrix; alternate specification allowing a full
matrix of correlations between test statistics. Must specify
either rho or rho.matrix, but not both.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_b">B</code></td>
<td>
<p>scalar; the number of permutations for Westfall-Young
procedures.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_max.steps">max.steps</code></td>
<td>
<p>how many steps allowed before terminating.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_tnum">tnum</code></td>
<td>
<p>max number of samples for first iteration
of search algorithm.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_start.tnum">start.tnum</code></td>
<td>
<p>number of samples to start search
(this will increase with each step).</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_final.tnum">final.tnum</code></td>
<td>
<p>number of samples for final draw.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_parallel.wy.cores">parallel.WY.cores</code></td>
<td>
<p>number of cores to use for parallel
processing of WY-SD.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_updateprogress">updateProgress</code></td>
<td>
<p>function to update progress bar (only used
for PUMP shiny app).</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_max_sample_size_nbar">max_sample_size_nbar</code></td>
<td>
<p>scalar; default upper bound for nbar
for search algorithm.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_max_sample_size_jk">max_sample_size_JK</code></td>
<td>
<p>scalar; default upper bound for J or K
for search algorithm.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_tol">tol</code></td>
<td>
<p>tolerance for target power, defaults to 0.01 (1
This parameter controls when the search is done:
when estimated power (checked with 'final.tnum' iterations)
is within 'tol', the search stops.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_give.optimizer.warnings">give.optimizer.warnings</code></td>
<td>
<p>whether to return
verbose optimizer warnings.</p>
</td></tr>
<tr><td><code id="pump_sample_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE; Print out diagnostics of time, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpresult object containing sample size results.
</p>


<h3>See Also</h3>

<p>For more detailed information about this function
and the user choices,
see the manuscript &lt;doi:10.18637/jss.v108.i06&gt;,
which includes a detailed Technical Appendix
including information about the designs and models
and parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- pump_sample(
  d_m = 'd2.1_m2fc',
  MTP = 'HO',
  power.definition = 'D1indiv',
  typesample = 'J',
  target.power = 0.8,
  nbar = 50,
  M = 3,
  MDES = 0.125,
  Tbar = 0.5, alpha = 0.05,
  numCovar.1 = 1,
  R2.1 = 0.1, ICC.2 = 0.05, rho = 0.2,
  tnum = 1000)
</code></pre>

<hr>
<h2 id='pump_sample_grid'>Run pump_sample on varying values of parameters (grid function)</h2><span id='topic+pump_sample_grid'></span>

<h3>Description</h3>

<p>See pump_power_grid() for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_sample_grid(
  d_m,
  MTP = NULL,
  M = 1,
  target.power,
  power.definition,
  tol = 0.01,
  MDES = NULL,
  propZero = NULL,
  numZero = NULL,
  typesample,
  nbar = NULL,
  J = NULL,
  K = NULL,
  Tbar,
  alpha,
  numCovar.1 = NULL,
  numCovar.2 = NULL,
  numCovar.3 = NULL,
  R2.1 = NULL,
  R2.2 = NULL,
  R2.3 = NULL,
  ICC.2 = NULL,
  ICC.3 = NULL,
  omega.2 = NULL,
  omega.3 = NULL,
  rho = NULL,
  verbose = FALSE,
  drop.unique.columns = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_sample_grid_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_m">M</code></td>
<td>
<p>scalar; the number of hypothesis tests (outcomes),
including zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_target.power">target.power</code></td>
<td>
<p>target power for search algorithm.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_power.definition">power.definition</code></td>
<td>
<p>see pump_info() for
possible power definitions.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_tol">tol</code></td>
<td>
<p>tolerance for target power, defaults to 0.01 (1
This parameter controls when the search is done:
when estimated power (checked with 'final.tnum' iterations)
is within 'tol', the search stops.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_mdes">MDES</code></td>
<td>
<p>scalar or vector; the desired MDES values for each
outcome. Please provide a scalar, a vector of length M, or vector
of values for non-zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_propzero">propZero</code></td>
<td>
<p>Proportion of outcomes that have 0 impact (this
will be used to override numZero, only one can be defined)</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_numzero">numZero</code></td>
<td>
<p>scalar; additional number of outcomes assumed to be
zero. Please provide NumZero + length(MDES) = M, if length(MDES)
is not 1.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_typesample">typesample</code></td>
<td>
<p>string; type of sample size to
calculate: &quot;nbar&quot;, &quot;J&quot;, or &quot;K&quot;.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_rho">rho</code></td>
<td>
<p>scalar; assumed correlation between all pairs of test
statistics.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_verbose">verbose</code></td>
<td>
<p>TRUE/FALSE; Print out diagnostics of time, etc.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_drop.unique.columns">drop.unique.columns</code></td>
<td>
<p>logical; drop all parameter columns that
did not vary across the grid.</p>
</td></tr>
<tr><td><code id="pump_sample_grid_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the underlying pump_power,
pump_sample, or pump_mdes functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpgridresult object containing sample results.
</p>


<h3>See Also</h3>

<p>Other grid functions: 
<code><a href="#topic+pump_mdes_grid">pump_mdes_grid</a>()</code>,
<code><a href="#topic+pump_power_grid">pump_power_grid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- pump_sample_grid(d_m = "d3.2_m3ff2rc", typesample = "J",
  MTP = "HO", MDES = 0.10, target.power = c( 0.50, 0.80 ),
  power.definition = "min1", tol = 0.03,
  M = 5, K = 7, nbar = 58, Tbar = 0.50,
  alpha = 0.15, numCovar.1 = 1, numCovar.2 = 1,
  R2.1 = 0.1, R2.2 = 0.7, ICC.2 = 0.25, ICC.3 = 0.25,
  rho = 0.4, tnum = 400)
 
</code></pre>

<hr>
<h2 id='pump_sample_raw'>Calculating Needed Sample Size for Raw (Unadjusted) Power</h2><span id='topic+pump_sample_raw'></span>

<h3>Description</h3>

<p>This is a helper function for getting a needed Sample Size when no
adjustments has been made to the test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pump_sample_raw(
  d_m,
  MTP,
  typesample,
  MDES,
  nbar = NULL,
  J = NULL,
  K = NULL,
  target.power,
  Tbar,
  alpha = 0.05,
  two.tailed,
  numCovar.1 = 0,
  numCovar.2 = 0,
  numCovar.3 = 0,
  R2.1,
  R2.2 = NULL,
  R2.3 = NULL,
  ICC.2 = NULL,
  ICC.3 = NULL,
  omega.2 = NULL,
  omega.3 = NULL,
  max.steps = 100,
  warn.small = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pump_sample_raw_+3A_d_m">d_m</code></td>
<td>
<p>string; a single context, which is a design and model
code. See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_mtp">MTP</code></td>
<td>
<p>string, or vector of strings; multiple testing
procedure(s). See pump_info() for list of choices.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_typesample">typesample</code></td>
<td>
<p>type of sample size to calculate: J, K, or nbar</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_mdes">MDES</code></td>
<td>
<p>scalar or vector; the desired MDES values for each
outcome. Please provide a scalar, a vector of length M, or vector
of values for non-zero outcomes.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_nbar">nbar</code></td>
<td>
<p>scalar; the harmonic mean of the number of level 1
units per level 2 unit (students per school). Note that this is
not the total number of level 1 units, but instead the number of
level 1 units nested within each level 2 unit, so the total
number of level 1 units is nbar x J x K.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_j">J</code></td>
<td>
<p>scalar; the harmonic mean of number of level 2 units per
level 3 unit (schools per district). Note that this is not the
total number of level 2 units, but instead the number of level 2
units nested within each level 3 unit, so the total number of
level 2 units is J x K.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_k">K</code></td>
<td>
<p>scalar; the number of level 3 units (districts).</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_target.power">target.power</code></td>
<td>
<p>target power to arrive at</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_tbar">Tbar</code></td>
<td>
<p>scalar; the proportion of samples that are assigned to
the treatment.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_alpha">alpha</code></td>
<td>
<p>scalar; the family wise error rate (FWER).</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_two.tailed">two.tailed</code></td>
<td>
<p>scalar; TRUE/FALSE for two-tailed or one-tailed
power calculation.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_numcovar.1">numCovar.1</code></td>
<td>
<p>scalar; number of level 1 (individual)
covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_numcovar.2">numCovar.2</code></td>
<td>
<p>scalar; number of level 2 (school) covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_numcovar.3">numCovar.3</code></td>
<td>
<p>scalar; number of level 3 (district) covariates.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_r2.1">R2.1</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 1 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_r2.2">R2.2</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 2 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_r2.3">R2.3</code></td>
<td>
<p>scalar, or vector of length M; percent of variation
explained by level 3 covariates for each outcome.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_icc.2">ICC.2</code></td>
<td>
<p>scalar, or vector of length M; level 2 (school)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_icc.3">ICC.3</code></td>
<td>
<p>scalar, or vector length M; level 3 (district)
intraclass correlation.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_omega.2">omega.2</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 2 average impacts to variance of level 2 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_omega.3">omega.3</code></td>
<td>
<p>scalar, or vector of length M; ratio of variance of
level 3 average impacts to variance of level 3 random intercepts.</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_max.steps">max.steps</code></td>
<td>
<p>how many steps allowed before terminating</p>
</td></tr>
<tr><td><code id="pump_sample_raw_+3A_warn.small">warn.small</code></td>
<td>
<p>Warn if degrees of freedom issues are causing inability to
achieve target power for sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is for a single, individual outcome.  It only takes scalar values for all
its arguments, and does not have an M argument (for number of outcomes).
</p>
<p>It requires iteration because we do not know the degrees of freedom, and so
we guess and then calculate sample size, and then recalculate df based on
sample size, until we converge.
</p>
<p>It is possible that the returned sample size will be the minimum sample size
required to have at least 1 degree of freedom (even if this provides higher
than target level power).
</p>


<h3>Value</h3>

<p>Requisite sample size (as integer) and associated degrees of freedom.
</p>

<hr>
<h2 id='pumpgridresult'>Result object for results of grid power calculations</h2><span id='topic+pumpgridresult'></span><span id='topic+is.pumpgridresult'></span><span id='topic+print.pumpgridresult'></span><span id='topic+summary.pumpgridresult'></span>

<h3>Description</h3>

<p>The pumpgridresult object is an S3 class that holds the results from
'pump_power_grid()', 'pump_sample_grid()', and 'pump_mdes_grid()'.
</p>
<p>It has several methods that pull different information from this object, and
some printing methods for getting nicely formatted results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pumpgridresult(x)

## S3 method for class 'pumpgridresult'
print(x, header = TRUE, ...)

## S3 method for class 'pumpgridresult'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pumpgridresult_+3A_x">x</code></td>
<td>
<p>a pumpgridresult object 
(except for is.pumpgridresult, where it is a generic object to check).</p>
</td></tr>
<tr><td><code id="pumpgridresult_+3A_header">header</code></td>
<td>
<p>logical; FALSE means skip some 
header info on the result, just print
the data.frame of actual results.</p>
</td></tr>
<tr><td><code id="pumpgridresult_+3A_...">...</code></td>
<td>
<p>extra options passed to print.pumpgridresult</p>
</td></tr>
<tr><td><code id="pumpgridresult_+3A_object">object</code></td>
<td>
<p>object to summarize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is.pumpgridresult: TRUE if object is a pumpgridresult object.
</p>
<p>print: No return value; prints results.
</p>
<p>summary: No return value; prints results.
</p>

<hr>
<h2 id='pumpresult'>pumpresult object for results of power calculations</h2><span id='topic+pumpresult'></span><span id='topic+params'></span><span id='topic+d_m'></span><span id='topic+design'></span><span id='topic+search_path'></span><span id='topic+pump_type'></span><span id='topic+is.pumpresult'></span><span id='topic++5B.pumpresult'></span><span id='topic++5B+5B.pumpresult'></span><span id='topic+dim.pumpresult'></span><span id='topic+summary.pumpresult'></span><span id='topic+print.pumpresult'></span><span id='topic+as.data.frame.pumpresult'></span>

<h3>Description</h3>

<p>The pumpresult object is an S3 class that holds the results from
'pump_power()', 
'pump_sample()', and 'pump_mdes()'.
</p>
<p>It has several methods that pull different information from this object, and
some printing methods for getting nicely formatted results.
</p>
<p>Pump result objects are also data.frames, so they can be easily manipulated
and combined.  The return values from the 'grid' functions will just return
data frames in general.
</p>
<p>Returns whether call was power, mdes, or sample.
</p>
<p>Calls the print_context method with results and control both set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params(x, ...)

d_m(x, ...)

design(x, ...)

search_path(x, ...)

pump_type(x)

is.pumpresult(x)

## S3 method for class 'pumpresult'
x[...]

## S3 method for class 'pumpresult'
x[[...]]

## S3 method for class 'pumpresult'
dim(x, ...)

## S3 method for class 'pumpresult'
summary(object, ...)

## S3 method for class 'pumpresult'
print(x, n = 10, header = TRUE, search = FALSE, ...)

## S3 method for class 'pumpresult'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pumpresult_+3A_x">x</code></td>
<td>
<p>a pumpresult object (except for is.pumpresult, 
where it is a generic object to check).</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the 
as.data.frame.list methods.</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_object">object</code></td>
<td>
<p>Object to summarize.</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_n">n</code></td>
<td>
<p>Number of lines of search path to print, max.</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_header">header</code></td>
<td>
<p>FALSE means skip some header info on the result, just print
the data.frame of actual results.</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_search">search</code></td>
<td>
<p>FALSE means don't print the search path for a result for
mdes or sample.</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the 
row names for the data frame.</p>
</td></tr>
<tr><td><code id="pumpresult_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and 
converting column names is optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>params: List of design parameters used.
</p>
<p>d_m: Context (d_m) used (as string).
</p>
<p>design (the randomization and levels) as string.
</p>
<p>search_path: Dataframe describing search path, 
if it was saved in the pumpresult object.
</p>
<p>pump_type: power, mdes, or sample, as a string.
</p>
<p>is.pumpresult: TRUE if object is a pumpresult object.
</p>
<p>'[': pull out rows and columns of the dataframe.
</p>
<p>'[[': pull out single element of dataframe.
</p>
<p>dim: Dimension of pumpresult (as matrix)
</p>
<p>summary: No return value; prints results.
</p>
<p>print: No return value; prints results.
</p>
<p>as.data.frame: pumpresult object as a clean 
dataframe (no more attributes from pumpresult).
</p>


<h3>See Also</h3>

<p>update
</p>
<p>update_grid
</p>
<p>print_context
</p>
<p>print_context
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pp &lt;- pump_power(d_m = "d3.2_m3ff2rc",
  MTP = 'HO', nbar = 50, J = 30, K = 10,
  M = 5, MDES = 0.125, Tbar = 0.5, alpha = 0.05,
  numCovar.1 = 1, numCovar.2 = 1,
  R2.1 = 0.1, R2.2 = 0.1, ICC.2 = 0.2, ICC.3 = 0.2,
  omega.2 = 0, omega.3 = 0.1, rho = 0.5, tnum = 1000)
  
print(pp)
params(pp)
print_context(pp)
d_m(pp)
pump_type(pp)
is.pumpresult(pp)
as.data.frame(pp)
dim(pp)
summary(pp)
transpose_power_table(pp)

J &lt;- pump_sample(d_m = "d2.1_m2fc",
  MTP = 'HO', power.definition = 'D1indiv',
  typesample = 'J', target.power = 0.7,
  nbar = 50, M = 3, MDES = 0.125,
  Tbar = 0.5, alpha = 0.05, numCovar.1 = 1,
  R2.1 = 0.1, ICC.2 = 0.05, rho = 0.2, tnum = 1000)
  
search_path(J)
power_curve(J)   
</code></pre>

<hr>
<h2 id='run_grid'>Run grid across any of the core pump functions</h2><span id='topic+run_grid'></span>

<h3>Description</h3>

<p>Run grid across any of the core pump functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_grid(
  args,
  pum_function,
  verbose = FALSE,
  drop.unique.columns,
  ...,
  use.furrr = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_grid_+3A_args">args</code></td>
<td>
<p>list of scenario arguments</p>
</td></tr>
<tr><td><code id="run_grid_+3A_pum_function">pum_function</code></td>
<td>
<p>pump_mdes, pump_sample, pump_power</p>
</td></tr>
<tr><td><code id="run_grid_+3A_verbose">verbose</code></td>
<td>
<p>print out detailed diagnostics</p>
</td></tr>
<tr><td><code id="run_grid_+3A_drop.unique.columns">drop.unique.columns</code></td>
<td>
<p>logical; drop all parameter columns 
that did not vary across the grid.</p>
</td></tr>
<tr><td><code id="run_grid_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the underlying pump_power, pump_sample,
or pump_mdes functions.</p>
</td></tr>
<tr><td><code id="run_grid_+3A_use.furrr">use.furrr</code></td>
<td>
<p>not currently implemented; whether to use furr package
for parallelization</p>
</td></tr>
</table>

<hr>
<h2 id='setup_default_parallel_plan'>Setup parallel processing</h2><span id='topic+setup_default_parallel_plan'></span>

<h3>Description</h3>

<p>Set up furrr to use all but one core
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_default_parallel_plan()
</code></pre>

<hr>
<h2 id='strip_SEs'>Remove SE and df columns from (wide) power table</h2><span id='topic+strip_SEs'></span>

<h3>Description</h3>

<p>This is used to reduce the info on a power table before pivoting to
long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_SEs(power_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_SEs_+3A_power_table">power_table</code></td>
<td>
<p>Dataframe (power result object).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Changed dataframe with all columns starting with SE or df
dropped.
</p>

<hr>
<h2 id='transpose_power_table'>Convert power table from wide to long (result function)</h2><span id='topic+transpose_power_table'></span>

<h3>Description</h3>

<p>Transform table returned from pump_power 
to a long format table or to a wide format table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose_power_table(power_table, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_power_table_+3A_power_table">power_table</code></td>
<td>
<p>pumpresult object for a power result 
(not mdes or sample). (It can also take a raw dataframe of the wide table 
to convert to long, as an internal helper method.)</p>
</td></tr>
<tr><td><code id="transpose_power_table_+3A_m">M</code></td>
<td>
<p>scalar; set if power_table is a data.frame 
without set number of outcomes. Usually ignore this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of power results in long format.
</p>

<hr>
<h2 id='update_grid'>Update a single pump call to a grid call (grid function)</h2><span id='topic+update_grid'></span>

<h3>Description</h3>

<p>Take a pumpresult and provide lists 
of parameters to explore various versions 
of the initial scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_grid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_grid_+3A_x">x</code></td>
<td>
<p>pump result object.</p>
</td></tr>
<tr><td><code id="update_grid_+3A_...">...</code></td>
<td>
<p>list of parameters to expand into a grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpgridresult object; 
result of calling corresponding grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pp &lt;- pump_power(d_m = "d2.1_m2fc", MTP = "HO",
  nbar = 200, J = 20, MDES = 0.2, M = 3,
  Tbar = 0.50, alpha = 0.05, numCovar.1 = 5,
  R2.1 = 0.1, ICC.2 = 0.05, rho = 0, tnum = 500)

gd &lt;- update_grid( pp, J = c( 10, 20, 30 ) )

</code></pre>

<hr>
<h2 id='update.pumpgridresult'>Update a pump grid call, tweaking some parameters (core
function)</h2><span id='topic+update.pumpgridresult'></span>

<h3>Description</h3>

<p>Works on objects returned by 'update_grid()'; calls
'update_grid()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpgridresult'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.pumpgridresult_+3A_object">object</code></td>
<td>
<p>A pumpgridresult object.</p>
</td></tr>
<tr><td><code id="update.pumpgridresult_+3A_...">...</code></td>
<td>
<p>Additional arguments, i.e., the arguments you would pass to the 'pump_power()', 'pump_mdes()' and 'pump_sample()', that will replace the existing parameters of the object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>[update_grid()]
</p>

<hr>
<h2 id='update.pumpresult'>Update a pump call, tweaking some parameters (core function)</h2><span id='topic+update.pumpresult'></span>

<h3>Description</h3>

<p>Works on objects returned by
pump_power(), pump_mdes(), or pump_sample().
One of the optional parameters can 
be a 'type = something' argument, where
the &quot;something&quot; is either &quot;power&quot;, &quot;sample&quot;, or &quot;mdes&quot;, 
if the call should be
shifted to a different pump call 
(pump_power, pump_sample, or pump_mdes,
respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pumpresult'
update(object, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.pumpresult_+3A_object">object</code></td>
<td>
<p>pump result object.</p>
</td></tr>
<tr><td><code id="update.pumpresult_+3A_type">type</code></td>
<td>
<p>string; can be &quot;power&quot;, &quot;mdes&quot; or &quot;sample&quot;, sets the 
type of the updated call (can be different from original).</p>
</td></tr>
<tr><td><code id="update.pumpresult_+3A_...">...</code></td>
<td>
<p>parameters as specified in 'pump_power', 'pump_mdes', and
'pump_sample' that should be overwritten.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pumpresult object: results of a new call 
using parameters of old object with newly 
specified parameters replaced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ss &lt;- pump_sample( d_m = "d2.1_m2fc", MTP = "HO",
  typesample = "J", nbar = 200, power.definition = "min1",
  M = 5, MDES = 0.05, target.power = 0.5, tol = 0.05,
  Tbar = 0.50, alpha = 0.05, numCovar.1 = 5, R2.1 = 0.1,
  ICC.2 = 0.15, rho = 0, final.tnum = 1000 )

up &lt;- update(ss, nbar = 40, tnum = 2000 )

</code></pre>

<hr>
<h2 id='validate_d_m'>Validate d_m string</h2><span id='topic+validate_d_m'></span>

<h3>Description</h3>

<p>Ensure d_m is a supported pair of design and model.
If d_m is just a design, select a default model.
Convert PowerUp! names to our naming system as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_d_m(d_m)
</code></pre>


<h3>Value</h3>

<p>Full d_m string that will be found in 'pump_info()'
</p>

<hr>
<h2 id='validate_inputs'>Validates user inputs</h2><span id='topic+validate_inputs'></span>

<h3>Description</h3>

<p>This functions takes in a list of user inputs. Depending on the inputs,
it produces errors or warnings, and at times modifies inputs if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_inputs(
  d_m,
  params.list,
  power.call = FALSE,
  mdes.call = FALSE,
  ss.call = FALSE,
  verbose = TRUE,
  multi.MTP.ok = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_inputs_+3A_d_m">d_m</code></td>
<td>
<p>a single RCT d_m (see list/naming convention)</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_params.list">params.list</code></td>
<td>
<p>a list of parameters input by a user</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_power.call">power.call</code></td>
<td>
<p>flag for power estimation</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_mdes.call">mdes.call</code></td>
<td>
<p>flag for MDES estimation</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_ss.call">ss.call</code></td>
<td>
<p>flag for sample size estimation</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_verbose">verbose</code></td>
<td>
<p>whether to print out warnings</p>
</td></tr>
<tr><td><code id="validate_inputs_+3A_multi.mtp.ok">multi.MTP.ok</code></td>
<td>
<p>whether validation allows for multiple MTPs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>params.list
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
