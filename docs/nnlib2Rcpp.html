<!DOCTYPE html><html><head><title>Help for package nnlib2Rcpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nnlib2Rcpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nnlib2Rcpp-package'><p>A collection of Neural Networks and tools to create custom models</p></a></li>
<li><a href='#Autoencoder'>
<p>Autoencoder NN</p></a></li>
<li><a href='#BP-class'><p>Class <code>"BP"</code></p></a></li>
<li><a href='#LVQs_recall'>
<p>Classify Data Using LVQs Code-Book Vectors</p></a></li>
<li><a href='#LVQs_train'>
<p>Train a Supervised LVQ</p></a></li>
<li><a href='#LVQs-class'><p>Class <code>"LVQs"</code></p></a></li>
<li><a href='#LVQu'>
<p>Unsupervised LVQ</p></a></li>
<li><a href='#MAM-class'><p>Class <code>"MAM"</code></p></a></li>
<li><a href='#NN_component_names'><p>Names of available NN components</p></a></li>
<li><a href='#NN_R_components'><p>Custom NN components defined using R</p></a></li>
<li><a href='#NN-class'><p>Class <code>"NN"</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Tool for Creating Custom Neural Networks in C++ and using Them
in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Vasilis Nikolaidis
    <a href="https://orcid.org/0000-0003-1471-8788"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vasilis Nikolaidis &lt;v.nikolaidis@uop.gr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains a module to define neural networks from custom components and versions of Autoencoder, BP, LVQ, MAM NN.</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp , methods, graphics, utils, class</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/VNNikolaidis/nnlib2Rcpp">https://github.com/VNNikolaidis/nnlib2Rcpp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/VNNikolaidis/nnlib2Rcpp/issues">https://github.com/VNNikolaidis/nnlib2Rcpp/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-10 15:54:10 UTC; Billy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-10 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nnlib2Rcpp-package'>A collection of Neural Networks and tools to create custom models</h2><span id='topic+nnlib2Rcpp'></span><span id='topic+nnlib2Rcpp-package'></span>

<h3>Description</h3>

<p>This package provides a module (NN module) to define and control neural networks containing predefined or custom components (layers, sets of connnections etc.). These components may have been derived from nnlib2 NN components (written in C++) or defined using R.
</p>
<p>It also contains a small collection of ready-to-use Neural Networks (NN), i.e. versions of Autoencoder, Back-Propagation, Learning Vector Quantization and Matrix Associative Memory NN. More information and examples for each of the above can be found in its documentation (see below).
</p>


<h3>Ready-to-use Neural Networks:</h3>


<ul>
<li><p> Plain Back-Propagation (BP-supervised) (<code><a href="#topic+BP">BP</a></code>)
</p>
</li>
<li><p> Learning Vector Quantization (LVQ-supervised) (<code><a href="#topic+LVQs">LVQs</a></code>)
</p>
</li>
<li><p> Learning Vector Quantization (LVQ-unsupervised) (<code><a href="#topic+LVQu">LVQu</a></code>)
</p>
</li>
<li><p> Matrix Associative Memory (MAM-supervised) (<code><a href="#topic+MAM">MAM</a></code>)
</p>
</li>
<li><p> Autoencoder (unsupervised) (<code><a href="#topic+Autoencoder">Autoencoder</a></code>)
</p>
</li></ul>


<h3>Custom Neural Networks:</h3>


<ul>
<li><p> NN module (<code><a href="#topic+NN">NN</a></code>)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Author/Maintainer:
</p>

<ul>
<li><p> Vasilis Nikolaidis <a href="mailto:vnnikolaidis@gmail.com">vnnikolaidis@gmail.com</a>
</p>
</li></ul>

<p>Contributors:
</p>

<ul>
<li><p> Arfon Smith [contributor]
</p>
</li>
<li><p> Dirk Eddelbuettel [contributor]
</p>
</li></ul>



<h3>References</h3>


<ul>
<li>
<p>Nikolaidis, V. N., (2021). The nnlib2 library and nnlib2Rcpp R package for implementing neural networks. Journal of Open Source Software, 6(61), 2876, <a href="https://doi.org/10.21105/joss.02876">doi:10.21105/joss.02876</a>.
</p>
</li></ul>

<p>References for the ready-to-use NN models (can also be found in related documentation):
</p>

<ul>
<li>
<p>Kohonen, T (1988). Self-Organization and Associative Memory, Springer-Verlag.; Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press.
</p>
</li>
<li>
<p>Pao Y (1989). Adaptive Pattern Recognition and Neural Networks. Reading, MA (US); Addison-Wesley Publishing Co., Inc.
</p>
</li>
<li>
<p>Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press.
</p>
</li>
<li>
<p>Philippidis, TP &amp; Nikolaidis, VN &amp; Kolaxis, JG. (1999). Unsupervised pattern recognition techniques for the prediction of composite failure. Journal of acoustic emission. 17. 69-81.
</p>
</li>
<li>
<p>Nikolaidis V.N., Makris I.A, Stavroyiannis S, &quot;ANS-based preprocessing of company performance indicators.&quot; Global Business and Economics Review 15.1 (2013): 49-58, <a href="https://doi.org/10.1504/GBER.2013.050667">doi:10.1504/GBER.2013.050667</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>More information and examples on using the package can be found in the following vignette:
</p>
<p><code>vignette("manual", package='nnlib2Rcpp')</code>
</p>
<p>Related links:
</p>

<ul>
<li> <p><a href="https://github.com/VNNikolaidis/nnlib2Rcpp">https://github.com/VNNikolaidis/nnlib2Rcpp</a>
</p>
</li>
<li><p> Package manual in PDF format at <a href="https://github.com/VNNikolaidis/nnlib2Rcpp/blob/master/support/manual.pdf">https://github.com/VNNikolaidis/nnlib2Rcpp/blob/master/support/manual.pdf</a>)
</p>
</li>
<li><p> Report bugs, issues and suggestions at <a href="https://github.com/VNNikolaidis/nnlib2Rcpp/issues">https://github.com/VNNikolaidis/nnlib2Rcpp/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Autoencoder'>
Autoencoder NN
</h2><span id='topic+Autoencoder'></span>

<h3>Description</h3>

<p>A neural network for autoencoding data, projects data to a new set of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Autoencoder(
  data_in,
  desired_new_dimension,
  number_of_training_epochs,
  learning_rate,
  num_hidden_layers = 1L,
  hidden_layer_size = 5L,
  show_nn = FALSE,
  error_type = "MAE",
  acceptable_error_level = 0,
  display_rate = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Autoencoder_+3A_data_in">data_in</code></td>
<td>

<p>data to be autoencoded, a numeric matrix, (2d, cases in rows, variables in columns).  It is recommended to be in [0 1] range.
</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_desired_new_dimension">desired_new_dimension</code></td>
<td>

<p>number of new variables to be produced. This is effectively the size (length) of the special hidden layer that outputs the new variable values, thus the dimension of the output vector space.
</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_number_of_training_epochs">number_of_training_epochs</code></td>
<td>

<p>number of training epochs, aka presentations of all training data to ANN during training.
</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_learning_rate">learning_rate</code></td>
<td>

<p>the learning rate parameter of the Back-Propagation (BP) NN.
</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_num_hidden_layers">num_hidden_layers</code></td>
<td>

<p>number of hidden layers on each side of the special layer.
</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_hidden_layer_size">hidden_layer_size</code></td>
<td>
<p>number of nodes (processing elements or PEs) in each of the hidden layers. In this implementation of Autoencoder all hidden layers are of the same length (defined here), except for the special hidden layer (whose size is defined by <code>desired_new_dimension</code> above).</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_show_nn">show_nn</code></td>
<td>
<p>boolean, option to display the (trained) ANN internal structure.</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_error_type">error_type</code></td>
<td>
<p>string, error to display and possibly use to stop training (must be 'MSE' or 'MAE').</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_acceptable_error_level">acceptable_error_level</code></td>
<td>
<p>stops training when error is below this level.</p>
</td></tr>
<tr><td><code id="Autoencoder_+3A_display_rate">display_rate</code></td>
<td>
<p>number of epochs that pass before current error level is displayed (0 = never display current error).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix containing the projected data.
</p>


<h3>Note</h3>

<p>This Autoencoder NN employs a <code><a href="#topic+BP">BP</a></code>-type NN to perform a data pre-processing step baring similarities to PCA since it too can be used for dimensionality reduction (Kramer 1991)(DeMers and Cottrell 1993)(Hinton and Salakhutdinov 2006). Unlike PCA, an autoencoding NN can also expand the feature-space dimensions (as feature expansion methods do). The NN maps input vectors to themselves via a special hidden layer (the coding layer, usually of different size than the input vector length) from which the new data vectors are produced. Note:
The internal BP PEs in computing layers apply the logistic sigmoid threshold function, and their output is in [0 1] range. It is recommended to use this range in your data as well. More for this particular autoencoder implementation can be found in (Nikolaidis, Makris, and Stavroyiannis 2013). The method is not deterministic and the mappings may be non-linear, depending on the NN topology.
</p>
<p>(This function uses Rcpp to employ 'bpu_autoencoder_nn' class in nnlib2.)
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Nikolaidis V.N., Makris I.A, Stavroyiannis S, &quot;ANS-based preprocessing of company performance indicators.&quot; Global Business and Economics Review 15.1 (2013): 49-58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BP">BP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_s &lt;- as.matrix(scale(iris[1:4]))
output_dim &lt;- 2
epochs &lt;- 100
learning_rate &lt;- 0.73
num_hidden_layers &lt;-2
hidden_layer_size &lt;- 5

out_data &lt;-  Autoencoder( iris_s, output_dim,
                          epochs, learning_rate,
                          num_hidden_layers, hidden_layer_size, FALSE)

plot( out_data,pch=21,
      bg=c("red","green3","blue")[unclass(iris$Species)],
      main="Randomly autoencoded Iris data")
</code></pre>

<hr>
<h2 id='BP-class'>Class <code>"BP"</code></h2><span id='topic+BP-class'></span><span id='topic+BP'></span><span id='topic+Rcpp_BP'></span><span id='topic+Rcpp_BP-class'></span>

<h3>Description</h3>

<p>Supervised Back-Propagation (BP) NN module, for encoding input-output mappings.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+RcppClass-class">RcppClass</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>.CppObject</code>:</dt><dd><p>Object of class <code>C++Object</code> ~~ </p>
</dd>
<dt><code>.CppClassDef</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
<dt><code>.CppGenerator</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>encode( data_in, data_out, learning_rate, training_epochs, hidden_layers, hidden_layer_size )</code>:</dt><dd><p> Setup a new BP NN and encode input-output data pairs. Parameters are:
</p>

<ul>
<li><p><code>data_in</code>: numeric matrix, containing input vectors as rows. . It is recommended that these values are in 0 to 1 range.
</p>
</li>
<li><p><code>data_out</code>: numeric matrix, containing corresponding (desired) output vectors. It is recommended that these values are in 0 to 1 range.
</p>
</li>
<li><p><code>learning_rate</code>: a number (preferably greater than 0 and less than 1) used in training.
</p>
</li>
<li><p><code>training_epochs</code>: number of training epochs, aka single presentation iterations of all training data pairs to the NN during training.
</p>
</li>
<li><p><code>hidden_layers</code>: number of hidden layers to be created between input and output layers.
</p>
</li>
<li><p><code>hidden_layer_size</code>: number of nodes (processing elements or PEs) in each of the hidden layers (all hidden layers are of the same length in this implementation of BP).
</p>
</li></ul>

<p>Note: to encode additional input-output vector pairs in an existing BP, use <code>train_single</code> or <code>train_multiple</code> methods (see below).
</p>
</dd>
<dt><code>recall(data_in)</code>:</dt><dd><p> Get output for a dataset (numeric matrix <code>data_in</code>) from the (trained) BP NN. </p>
</dd>
<dt><code>setup(input_dim, output_dim, learning_rate, hidden_layers, hidden_layer_size)</code>:</dt><dd><p> Setup the BP NN so it can be trained and used. Note: this is not needed if using <code>encode</code>. Parameters are:
</p>

<ul>
<li><p><code>input_dim</code>: integer length of input vectors.
</p>
</li>
<li><p><code>output_dim</code>: integer length of output vectors.
</p>
</li>
<li><p><code>learning_rate</code>: a number (preferably greater than 0 and less than 1) used in training.
</p>
</li>
<li><p><code>hidden_layers</code>: number of hidden layers to be created between input and output layers.
</p>
</li>
<li><p><code>hidden_layer_size</code>: number of nodes (processing elements or PEs) in each of the hidden layers (all hidden layers are of the same length in this implementation of BP).
</p>
</li></ul>

</dd>
<dt><code>train_single (data_in, data_out)</code>:</dt><dd><p> Encode an input-output vector pair in the BP NN. Only performs a single training iteration (multiple may be required for proper encoding). Vector sizes should be compatible to the current NN (as resulted from the <code>encode</code> or <code>setup</code> methods). Returns error level indicator value.</p>
</dd>
<dt><code>train_multiple (data_in, data_out, training_epochs)</code>:</dt><dd><p> Encode multiple input-output vector pairs stored in corresponding datasets. Performs multiple iterations in epochs (see <code>encode</code>). Vector sizes should be compatible to the current NN (as resulted from the <code>encode</code> or <code>setup</code> methods). Returns error level indicator value.</p>
</dd>
<dt><code>set_error_level(error_type, acceptable_error_level)</code>:</dt><dd><p> Set options that stop training when an acceptable error level has been reached (when a subsequent <code>encode</code> or <code>train_multiple</code> is performed). Parameters are:
</p>

<ul>
<li><p><code>error_type</code>: string, error type to display and use to stop training (must be 'MSE' or 'MAE').
</p>
</li>
<li><p><code>acceptable_error_level</code>: training stops when error is below this level.
</p>
</li></ul>

</dd>
<dt><code>mute(on)</code>:</dt><dd><p> Disable output of current error level when training (if parameter <code>on</code> is TRUE). </p>
</dd>
<dt><code>print()</code>:</dt><dd><p> Print NN structure. </p>
</dd>
<dt><code>show()</code>:</dt><dd><p> Print NN structure. </p>
</dd>
<dt><code>load(filename)</code>:</dt><dd><p> Retrieve the NN from specified file. </p>
</dd>
<dt><code>save(filename)</code>:</dt><dd><p> Save the NN to specified file. </p>
</dd>
</dl>

<p>The following methods are inherited (from the corresponding class):
objectPointer (&quot;RcppClass&quot;), initialize (&quot;RcppClass&quot;), show (&quot;RcppClass&quot;)
</p>


<h3>Note</h3>

<p>This R module maintains an internal Back-Propagation (BP) multilayer perceptron NN (described in Simpson (1991) as the vanilla back-propagation algorithm), which can be used to store input-output vector pairs. Since the nodes (PEs) in computing layers of this BP implementation apply the logistic sigmoid threshold function, their output is in [0 1] range (and so should the desired output vector values).
</p>
<p>(This object uses Rcpp to employ 'bp_nn' class in nnlib2.)</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Autoencoder">Autoencoder</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data...
iris_s                  &lt;- as.matrix(scale(iris[1:4]))

# use a randomly picked subset of (scaled) iris data for training.
training_cases          &lt;- sample(1:nrow(iris_s), nrow(iris_s)/2,replace=FALSE)
train_set               &lt;- iris_s[training_cases,]
train_class_ids         &lt;- as.integer(iris$Species[training_cases])
train_num_cases         &lt;- nrow(train_set)
train_num_variables     &lt;- ncol(train_set)
train_num_classes       &lt;- max(train_class_ids)

# create output dataset to be used for training.
# Here we encode class as 0s and 1s (one-hot encoding).

train_set_data_out &lt;- matrix(
          data = 0,
          nrow = train_num_cases,
          ncol = train_num_classes)

# now for each case, assign a 1 to the column corresponding to its class, 0 otherwise
# (note: there are better R ways to do this in R)
for(r in 1:train_num_cases) train_set_data_out[r,train_class_ids[r]]=1

# done with data, let's use BP...
bp&lt;-new("BP")

bp$encode(train_set,train_set_data_out,0.8,10000,2,4)

# let's test by recalling the original training set...
bp_output &lt;- bp$recall(train_set)

cat("- Using this demo's encoding, recalled class is:\n")
print(apply(bp_output,1,which.max))
cat("- BP success in recalling correct class is: ",
  sum(apply(bp_output,1,which.max)==train_class_ids)," out of ",
  train_num_cases, "\n")

# Let's see how well it recalls the entire Iris set:
bp_output &lt;- bp$recall(iris_s)

# show output
cat("\n- Recalling entire Iris set returns:\n")
print(bp_output)
cat("- Using this demo's encoding, original class is:\n")
print(as.integer(iris$Species))
cat("- Using this demo's encoding, recalled class is:\n")
bp_classification &lt;- apply(bp_output,1,which.max)
print(bp_classification)
cat("- BP success in recalling correct class is: ",
  sum(apply(bp_output,1,which.max)==as.integer(iris$Species)),
  "out of ", nrow(iris_s), "\n")
plot(iris_s, pch=bp_classification, main="Iris classified by a partialy trained BP (module)")
</code></pre>

<hr>
<h2 id='LVQs_recall'>
Classify Data Using LVQs Code-Book Vectors
</h2><span id='topic+LVQs_recall'></span>

<h3>Description</h3>

<p>This function simplifies applying a trained supervised Learning Vector Quantizer Neural Network (LVQ NN) to data (as compared to using the <code><a href="#topic+LVQs">LVQs</a></code> module directly). It uses the codebook vector information returned by <code><a href="#topic+LVQs_train">LVQs_train</a></code> to assign data to classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LVQs_recall(codebook_info,
			data,
			k = 1,
			recall_rewards_limit = 1,
			verbose = FALSE,
			...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LVQs_recall_+3A_codebook_info">codebook_info</code></td>
<td>

<p>LVQ codebook vector information (as returned by <code><a href="#topic+LVQs_train">LVQs_train</a></code>).
</p>
</td></tr>
<tr><td><code id="LVQs_recall_+3A_data">data</code></td>
<td>

<p>data to be classified, numeric matrix (2d, cases in rows, variables in columns).
</p>
</td></tr>
<tr><td><code id="LVQs_recall_+3A_k">k</code></td>
<td>

<p>number of neighbours (codebook vectors) considered. See <code>help("knn",package = class)</code>.
</p>
</td></tr>
<tr><td><code id="LVQs_recall_+3A_recall_rewards_limit">recall_rewards_limit</code></td>
<td>

<p>do not use codebook vectors that were rewarded less that this limit during training.
</p>
</td></tr>
<tr><td><code id="LVQs_recall_+3A_verbose">verbose</code></td>
<td>

<p>show extra information and plots.
</p>
</td></tr>
<tr><td><code id="LVQs_recall_+3A_...">...</code></td>
<td>

<p>additional parameters for k-Nearest Neighbour Classification function (<code>class::knn</code>), see <code>help("knn",package = class)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a k-Nearest Neighbor Classifier (employs <code>class::knn</code>), customized for LVQs codebook vectors.
</p>


<h3>Value</h3>

<p>Factor of classifications ids for <code>data</code> (as returned by function <code>class::knn</code>, see <code>help("knn",package = class)</code>).
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press. p.88.
</p>
<p>Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with S.
Fourth Edition. Springer, New York. ISBN 0-387-95457-0
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LVQs_train">LVQs_train</a></code>, <code><a href="#topic+LVQs">LVQs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with the well-know iris dataset:

DATA &lt;- iris[,1:4]
CLASS &lt;- as.factor(iris$Species)

# Randomly split the data into training and testing sets:

indices &lt;- sample(1:nrow(DATA), size = .5 * nrow(DATA))

train_data  &lt;- DATA[indices, ]
train_class &lt;- CLASS[indices]

test_data  &lt;- DATA[-indices, ]
test_class &lt;- CLASS[-indices]

# train LVQ using train data and class:

cv &lt;- LVQs_train(train_data,
				 train_class,
				 number_of_output_nodes_per_class = 4)

# recall (classify) test data:

cl &lt;- LVQs_recall(cv, test_data)

# Compare known and returned test data classifications:

print(table(test_class, cl))
</code></pre>

<hr>
<h2 id='LVQs_train'>
Train a Supervised LVQ
</h2><span id='topic+LVQs_train'></span>

<h3>Description</h3>

<p>This function simplifies training a supervised Learning Vector Quantizer Neural Network (LVQ NN), as compared to using the <code><a href="#topic+LVQs">LVQs</a></code> module directly. Once the NN is trained, the function returns a matrix containing the codebook vector information. This matrix can then be used by <code><a href="#topic+LVQs_recall">LVQs_recall</a></code> to classify other data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LVQs_train(	train_data,
			train_class,
			iterations = 1000,
			number_of_output_nodes_per_class = 1,
			reward_coef = +0.2,
			punish_coef = -0.2,
			training_order = "reorder_once",
			initialization_method = "sample",
			recall_train_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LVQs_train_+3A_train_data">train_data</code></td>
<td>

<p>training data, numeric matrix (2d, cases in rows, variables in columns).
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_train_class">train_class</code></td>
<td>

<p>vector of integers or factor containing the desired class id for each training data case (row). Expected ids start from 1.
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_iterations">iterations</code></td>
<td>

<p>integer, number of training epochs, i.e. number of times the entire training data set will be presented to the NN during training. Maximum allowed is 10000.
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_number_of_output_nodes_per_class">number_of_output_nodes_per_class</code></td>
<td>

<p>integer, number of output nodes (and thus codebook vectors) to be used per class. A single value is expected, all classes are assigned this (same) number of output nodes.
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_reward_coef">reward_coef</code></td>
<td>

<p>coefficient used when a output node (and thus codebook vector) is rewarded (has been correctly selected when a training data vector is encoded) and is adjusted closer to the data. For more, see <code>set_encoding_coefficients</code> method of <code><a href="#topic+LVQs">LVQs</a></code>
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_punish_coef">punish_coef</code></td>
<td>

<p>coefficient used when a output node (and thus codebook vector) is punished (has been incorrectly selected when a training data vector is encoded) and is adjusted away from the data. For more, see <code>set_encoding_coefficients</code> method of <code><a href="#topic+LVQs">LVQs</a></code>
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_training_order">training_order</code></td>
<td>

<p>order by which the data set vectors will be presented to LVQs for encoding during each training iteration (epoch). Options are: <code>'original'</code> (vectors are presented in the order in which they are stored, i.e. first row to last), <code>'reorder_once'</code> (vectors are randomly reordered once, then presented in this same order in all iterations), and <code>'reorder'</code> (vectors are randomly reordered before each iteration).
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_initialization_method">initialization_method</code></td>
<td>

<p>defines how the connections weights (codebook vectors) will be initialized. Options are: <code>'0to1'</code> (random values in [0 1] range, note: internal training data will also be scaled to the same range), <code>'means'</code> codebook vectors will be the corresponding class's mean vector), <code>'first'</code> (the first vector(s) of each class will be used as initial codebook vector(s), randomly re-selected if not enough are available), and <code>'sample'</code> (randomly selected vectors of each class will be used as initial codebook vectors, with replacement if not enough are available).
</p>
</td></tr>
<tr><td><code id="LVQs_train_+3A_recall_train_data">recall_train_data</code></td>
<td>

<p>once training completes, recall the training data and show accuracy and confusion matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function which internally employs an instance of the <code><a href="#topic+LVQs">LVQs</a></code> module. For more details, see  <code><a href="#topic+LVQs">LVQs</a></code>.
</p>


<h3>Value</h3>

<p>A numeric matrix containing the codebook vector coordinates, the number of times each vector was rewarded during encoding (second from last column named <code>'Rewards'</code>, ) and the class it corresponds to  (last column, named <code>'Class'</code>). This matrix can be used by <code><a href="#topic+LVQs_recall">LVQs_recall</a></code> function to classify other data.
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press. p.88.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LVQs_recall">LVQs_recall</a></code>, <code><a href="#topic+LVQs">LVQs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start with the well-know iris dataset:

DATA &lt;- iris[,1:4]
CLASS &lt;- as.factor(iris$Species)

# Randomly split the data into training and testing sets:

indices &lt;- sample(1:nrow(DATA), size = .5 * nrow(DATA))

train_data  &lt;- DATA[indices, ]
train_class &lt;- CLASS[indices]

test_data  &lt;- DATA[-indices, ]
test_class &lt;- CLASS[-indices]

# train LVQ using train data and class:

cv &lt;- LVQs_train(train_data,
				 train_class,
				 number_of_output_nodes_per_class = 4)

# recall (classify) test data:

cl &lt;- LVQs_recall(cv, test_data)

# Compare known and returned test data classifications:

print(table(test_class, cl))
</code></pre>

<hr>
<h2 id='LVQs-class'>Class <code>"LVQs"</code></h2><span id='topic+LVQs-class'></span><span id='topic+Rcpp_LVQs-class'></span><span id='topic+LVQs'></span>

<h3>Description</h3>

<p>Supervised Learning Vector Quantization (LVQ) NN module, for data classification.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+RcppClass-class">RcppClass</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>.CppObject</code>:</dt><dd><p>Object of class <code>C++Object</code> ~~ </p>
</dd>
<dt><code>.CppClassDef</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
<dt><code>.CppGenerator</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>encode(data, desired_class_ids, training_epochs)</code>:</dt><dd><p> Encode input and output (classification) for a dataset using a LVQ NN (which sets up accordingly if required). Parameters are:</p>
</dd>
</dl>

<ul>
<li><p><code>data</code>: training data, a numeric matrix, (2d, cases in rows, variables in columns). Data should be in 0 to 1 range.
</p>
</li>
<li><p><code>desired_class_ids</code> : vector of integers containing a desired class id for each training data case (row). Should contain integers in 0 to n-1 range, where n is the number of classes.
</p>
</li>
<li><p><code>training_epochs</code>: integer, number of training epochs, aka presentations of all training data to the NN during training.
</p>
</li></ul>

<dl>
<dt><code>recall(data_in, min_rewards)</code>:</dt><dd><p> Get output (classification) for a dataset (numeric matrix <code>data_in</code>) from the (trained) LVQ NN. The <code>data_in</code> dataset should be 2-d containing  data cases (rows) to be presented to the NN and is expected to have same number or columns as the original training data. Returns a vector of integers containing a class id for each case (row).Parameters are:
</p>

<ul>
<li><p><code>data_in</code>: numeric 2-d matrix containing  data cases (as rows).
</p>
</li>
<li><p><code>min_rewards</code>: (optional) integer, ignore output nodes that (during encoding/training) were rewarded less times that this number (default is 0, i.e. use all nodes).
</p>
</li></ul>

</dd>
<dt><code>setup( input_length, int number_of_classes, number_of_nodes_per_class )</code>:</dt><dd><p>Setup an untrained supervised LVQ for given input data vector dimension and number of classes. Parameters are:
</p>

<ul>
<li><p><code>input_length</code>: integer, dimension (length) of input data vectors.
</p>
</li>
<li><p><code>number_of_classes</code>: integer, number of classes in data (including empty ones).
</p>
</li>
<li><p><code>number_of_nodes_per_class</code>: (optional) integer, number of output nodes (PE) to be used per class. Default is 1.
</p>
</li></ul>

</dd>
<dt><code>train_single (data_in, class_id, epoch)</code>:</dt><dd><p> Encode a single [input vector,class] pair in the LVQ NN. Only performs a single training iteration (multiple may be required for proper encoding). Vector length and class id should be compatible to the current NN (as resulted from the <code>encode</code>, <code>setup</code> or <code>load</code> methods). Returns <code>TRUE</code> if succesfull, <code>FALSE</code> otherwise. Parameters are:
</p>

<ul>
<li><p><code>data_in</code>: numeric, data vector to be encoded.
</p>
</li>
<li><p><code>class_id</code>: integer, id of class corresponding to the data vector.(ids start from 0).
</p>
</li>
<li><p><code>epoch</code>: integer, presumed epoch during which this encoding occurs (learning rate decreases with epochs in supervised LVQ).
</p>
</li></ul>

</dd>
<dt><code>get_weights()</code>:</dt><dd><p>Get the current weights (codebook vector coordinates) of the 2nd component (<code>connection_set</code>). If successful, returns NumericVector of connection weights (otherwise vector of zero length).
</p>
</dd>
<dt><code>set_weights( data_in )</code>:</dt><dd><p>Set the weights of the 2nd component (<code>connection_set</code>), i.e. directly define the LVQ's codebook vectors. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>data_in</code>: NumericVector, data to be used for new values in <code>weight</code> registers of connections (sizes must match).
</p>
</li></ul>

</dd>
<dt><code>set_number_of_nodes_per_class( n )</code>:</dt><dd><p>Set the number of nodes in the output layer (and thus incoming connections whose weights form codebook vectors) that will be used per class. Default is 1, i.e. each class in the data to be encoded in the NN corresponds to a single node (PE) in it's output layer. This method affects how the new NN topology will be created, therefore this method should be used before the NN has been set up (either by <code>encode</code> or <code>setup</code>) or after a NN topology (and NN state) has been loaded from file via <code>load</code>). Returns number of nodes to be used per class. Parameters are:
</p>

<ul>
<li><p><code>n</code>: integer, number of nodes to be used per each class.
</p>
</li></ul>

</dd>
<dt><code>get_number_of_nodes_per_class( )</code>:</dt><dd><p>Get the number of nodes in the output layer that are used per class.</p>
</dd>
<dt><code>enable_punishment( )</code>:</dt><dd><p> Enables negative reinfoncement. During encoding incorrect winner nodes will be notified and incoming weights will be adjusted accordingly. Returns TRUE if punishment is enabled, FALSE otherwise. </p>
</dd>
<dt><code>disable_punishment( )</code>:</dt><dd><p> Disables negative reinfoncement. During encoding incorrect winner nodes will not be notified, thus incoming weights will not be adjusted accordingly. Adjustments will only occur in correct winning nodes. Returns TRUE if punishment is enabled, FALSE otherwise. </p>
</dd>
<dt><code>get_number_of_rewards( )</code>:</dt><dd><p> Get the number of times an output node was positively reinforced during data encoding. Returns NumericVector containing results per output node. </p>
</dd>
<dt><code>set_weight_limits(  min, max )</code>:</dt><dd><p>Define the minimum and maximum values that will be allowed in connection weights during encoding (limiting results of punishment). The NN must have been set up before using this method (either by <code>encode</code>, <code>setup</code> or <code>load</code>). Parameters are:
</p>

<ul>
<li><p><code>min</code>: numeric, minimum weight allowed.
</p>
</li>
<li><p><code>max</code>: numeric, maximum weight allowed.
</p>
</li></ul>

</dd>
<dt><code>set_encoding_coefficients( reward, punish )</code>:</dt><dd><p>Define coefficients used for reward and punishment during encoding. In this version, the actual learning rate a(t) also depends on the epoch t, i.e. a(t) = coefficient * (1 - (t/10000)). The NN must have been set up before using this method (either by <code>encode</code>, <code>setup</code> or <code>load</code>). Parameters are:
</p>

<ul>
<li><p><code>reward</code>: numeric, coefficient used to reward a node that classified data correctly (usually positive, e.g. 0.2).
</p>
</li>
<li><p><code>punish</code>: numeric, coefficient used to punish a node that classified data incorrectly (usually negative, e.g. -0.2).
</p>
</li></ul>

</dd>
<dt><code>print()</code>:</dt><dd><p> print NN structure. </p>
</dd>
<dt><code>show()</code>:</dt><dd><p> print NN structure. </p>
</dd>
<dt><code>load(filename)</code>:</dt><dd><p> Retrieve the state of the NN from specified file. Note: parameters such as number of nodes per class or reward/punish coefficients are not retrieved. </p>
</dd>
<dt><code>save(filename)</code>:</dt><dd><p> Store the state of the current NN to specified file. Note: parameters such as number of nodes per class or reward/punish coefficients are not stored.</p>
</dd>
</dl>

<p>The following methods are inherited (from the corresponding class):
objectPointer (&quot;RcppClass&quot;), initialize (&quot;RcppClass&quot;), show (&quot;RcppClass&quot;)
</p>


<h3>Note</h3>

<p>This module uses Rcpp to employ 'lvq_nn' class in nnlib2.
The NN used in this module uses supervised training for data classification (described as Supervised Learning LVQ in Simpson (1991)). By default, initial weights are random values (uniform distribution) in 0 to 1 range. As these weights represent vector coordinates (forming the class reference, prototype or codebook vectors), it is important that input data is also scaled to 0 to 1 range.
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press. p.88.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LVQs_train">LVQs_train</a></code>, <code><a href="#topic+LVQs_recall">LVQs_recall</a></code> (LVQs helper functions) and <code><a href="#topic+LVQu">LVQu</a></code> (unsupervised LVQ function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some compatible data (here, from iris data set):

# Data should be in 0 to 1 range if random values in that range are used
# as initial weights (the default method).
# Thus, LVQ expects data in 0 to 1 range, scale the (numeric) data...

DATA &lt;- as.matrix(iris[1:4])
c_min &lt;- apply(DATA, 2, FUN = "min")
c_max &lt;- apply(DATA, 2, FUN = "max")
c_rng &lt;- c_max - c_min
DATA &lt;- sweep(DATA, 2, FUN = "-", c_min)
DATA &lt;- sweep(DATA, 2, FUN = "/", c_rng)
NUM_VARIABLES &lt;- ncol(DATA)

# create a vector of desired class ids (consecutive ids, starting from 0):
CLASS &lt;- as.integer(iris$Species) - 1
NUM_CLASSES &lt;- length(unique(CLASS))

# avoid using data with NA or other special values:
if (sum(is.na(DATA)) &gt; 0)
  stop("NAs found in DATA")
if (sum(is.na(CLASS)) &gt; 0)
  stop("NAs found in CLASS")

# Example 1:
# (Note: the example uses DATA and CLASS variables defined earlier).

  # use half of the data to train, the other half to evaluate how well LVQ was
  # trained (interlaced half is used to select members of these data sets):

  l1_train_dataset &lt;- DATA[c(TRUE, FALSE),]
  l1_train_class   &lt;- CLASS[c(TRUE, FALSE)]
  l1_test_dataset &lt;- DATA[c(FALSE, TRUE),]
  l1_test_class   &lt;- CLASS[c(FALSE, TRUE)]

  # now create the NN:
  l1 &lt;- new("LVQs")

  # train it:
  l1$encode(l1_train_dataset, l1_train_class, 100)

  # recall the same data (a simple check of how well the LVQ was trained):
  l1_recalled_class_ids &lt;- l1$recall(l1_test_dataset)

  # show results:
  cat(
    "Example 1 results: Correct ",
    sum(l1_recalled_class_ids == l1_test_class),
    "out of",
    nrow(l1_test_dataset),
    ".\n"
  )

# Example 2: (playing around with some optional settings)
# (Note: the example uses DATA, CLASS, NUM_CLASSES variables defined earlier).

  # create the NN:
  l2 &lt;- new("LVQs")

  # Optionally, the output layer could be expanded, e.g. use 2 nodes per each class:
  l2$set_number_of_nodes_per_class(2)

  # Optionally, for experimentation negative reinforcement can be disabled:
  l2$disable_punishment()

  # train it:
  l2$encode(DATA, CLASS, 100)

  # recall the same data (a simple check of how well the LVQ was trained):
  l2_recalled_class_ids &lt;- l2$recall(DATA)

  # Done. Optional part for further examining results of training:

  # collect the connection weights (codebook vector coordinates), number
  # of rewards per node and corresponding class:

  l2_codebook_vector_info &lt;-
    cbind(
      matrix(l2$get_weights(),
             ncol = ncol(DATA),
             byrow = TRUE),
      l2$get_number_of_rewards(),
      rep(
        0:(NUM_CLASSES - 1),
        rep(l2$get_number_of_nodes_per_class(),
            NUM_CLASSES)
      )
    )

  colnames(l2_codebook_vector_info) &lt;-
    c(colnames(DATA), "Rewarded", "Class")

  print(l2_codebook_vector_info)

  # plot recalled classification:

  plot(
    DATA,
    pch = l2_recalled_class_ids,
    main = "LVQ recalled clusters (LVQs module)",
    xlim = c(-0.2, 1.2),
    ylim = c(-0.2, 1.2)
  )

  # plot connection weights (a.k.a codebook vectors):
  # the big circles are codebook vectors, (crossed-out if they were never used
  # to assign a training data point to the correct class, i.e. never rewarded)

  points(
    l2_codebook_vector_info[, 1:2],
    cex = 4,
    pch = ifelse(l2_codebook_vector_info[, "Rewarded"] &gt; 0,	1, 13),
    col  = l2_codebook_vector_info[, "Class"] + 10
  )

  # show results:
  cat(
    "Example 2 results: Correct ",
    sum(l2_recalled_class_ids == CLASS),
    "out of",
    nrow(DATA),
    ".\n"
  )

# Example 3 (demonstrate 'setup' and some other methods it allows):
# (Note: uses DATA, CLASS, NUM_VARIABLES, NUM_CLASSES defined earlier).

  # create the NN:
  l3 &lt;- new("LVQs")

  l3_number_of_output_nodes_per_class &lt;- 3

  # setup the LVQ:
  l3$setup(NUM_VARIABLES,
           NUM_CLASSES,
           l3_number_of_output_nodes_per_class)
  l3$set_weight_limits(-0.5 , 1.5)
  l3$set_encoding_coefficients(0.2,-sum(CLASS == 0) / length(CLASS))

  # experiment with setting initial weights (codebook vectors) per output node;
  # here, weights are set to the mean vector of the training set data for the
  # class the output node corresponds to:

  class_means &lt;- aggregate(DATA, list(CLASS), FUN = mean)
  class_means &lt;- t(class_means)[-1,]
  l3_initial_weights &lt;- NULL
  for (i in 1:l3_number_of_output_nodes_per_class)
    l3_initial_weights &lt;- rbind(l3_initial_weights, class_means)

  l3$set_weights(as.vector(l3_initial_weights))

  # now train it:
  l3$encode(DATA, CLASS, 100)

  # recall the same data (a simple check of how well the LVQ was trained):
  l3_recalled_class_ids &lt;- l3$recall(DATA, 0)

  # show results:
  cat(
    "Example 3 results: Correct ",
    sum(l3_recalled_class_ids == CLASS),
    "out of",
    nrow(DATA),
    ".\n"
  )
</code></pre>

<hr>
<h2 id='LVQu'>
Unsupervised LVQ
</h2><span id='topic+LVQu'></span><span id='topic+SOM'></span>

<h3>Description</h3>

<p>Unsupervised (clustering) Learning Vector Quantization (LVQ) NN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LVQu(
  data,
  max_number_of_desired_clusters,
  number_of_training_epochs,
  neighborhood_size,
  show_nn )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LVQu_+3A_data">data</code></td>
<td>

<p>data to be clustered, a numeric matrix, (2d, cases in rows, variables in columns). By default, initial weights are set to random values in [0 1], so data should also be in 0 to 1 range.
</p>
</td></tr>
<tr><td><code id="LVQu_+3A_max_number_of_desired_clusters">max_number_of_desired_clusters</code></td>
<td>

<p>clusters to be produced (at most)
</p>
</td></tr>
<tr><td><code id="LVQu_+3A_number_of_training_epochs">number_of_training_epochs</code></td>
<td>

<p>number of training epochs, aka presentations of all training data to ANN during training.
</p>
</td></tr>
<tr><td><code id="LVQu_+3A_neighborhood_size">neighborhood_size</code></td>
<td>

<p>integer &gt;=1, specifies affected neighbor output nodes during training. if 1 (Single Winner) the ANN is somewhat similar to k-means.
</p>
</td></tr>
<tr><td><code id="LVQu_+3A_show_nn">show_nn</code></td>
<td>

<p>boolean, option to display the (trained) ANN internal structure.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of integers containing a cluster id for each data case (row).
</p>


<h3>Note</h3>

<p>Function LVQu employs an unsupervised LVQ for clustering data (Kohonen 1988). This LVQ variant is described as Unsupervised Learning LVQ in Simpson (1991) and is a simplified 1-D version of Self-Organizing-Map (SOM). Its parameter <code>neighborhood_size</code> controls the encoding mode (where <code>neighborhood_size</code>=1 is Single-Winner Unsupervised encoding, similar to k-means, while an odd valued <code>neighborhood_size</code> &gt; 1 means Multiple-Winner Unsupervised encoding mode). Initial weights are random (uniform distribution) in 0 to 1 range. As these weights represent cluster center coordinates (the class reference vector), it is important that input data is also scaled to this range.
</p>
<p>(This function uses Rcpp to employ 'som_nn' class in nnlib2.)
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Kohonen, T (1988). Self-Organization and Associative Memory, Springer-Verlag.; Simpson, P. K. (1991). Artificial neural systems: Foundations, paradigms, applications, and implementations. New York: Pergamon Press.
</p>
<p>Philippidis, TP &amp; Nikolaidis, VN &amp; Kolaxis, JG. (1999). Unsupervised pattern recognition techniques for the prediction of composite failure. Journal of acoustic emission. 17. 69-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LVQs">LVQs</a></code> (supervised LVQ module),
</p>


<h3>Examples</h3>

<pre><code class='language-R'># LVQ expects data in 0 to 1 range, so scale...
iris_s&lt;-as.matrix(iris[1:4])
c_min&lt;-apply(iris_s,2,FUN = "min")
c_max&lt;-apply(iris_s,2,FUN = "max")
c_rng&lt;-c_max-c_min
iris_s&lt;-sweep(iris_s,2,FUN="-",c_min)
iris_s&lt;-sweep(iris_s,2,FUN="/",c_rng)

cluster_ids&lt;-LVQu(iris_s,5,100)
plot(iris_s, pch=cluster_ids, main="LVQ-clustered Iris data")
</code></pre>

<hr>
<h2 id='MAM-class'>Class <code>"MAM"</code></h2><span id='topic+MAM-class'></span><span id='topic+MAM'></span><span id='topic+Rcpp_MAM'></span><span id='topic+Rcpp_MAM-class'></span>

<h3>Description</h3>

<p>A single Matrix Associative Memory (MAM) implemented as a (supervised) NN.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+RcppClass-class">RcppClass</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>.CppObject</code>:</dt><dd><p>Object of class <code>C++Object</code> ~~ </p>
</dd>
<dt><code>.CppClassDef</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
<dt><code>.CppGenerator</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>encode( data_in, data_out )</code>:</dt><dd><p> Setup a new MAM NN and encode input-output data pairs. Parameters are:
</p>

<ul>
<li><p><code>data_in</code>: numeric matrix, input data to be encoded in MAM, a numeric matrix (2d, of n rows). Each row will be paired to the corresponding data_out row, forming an input-output vector pair.
</p>
</li>
<li><p><code>data_out</code>: numeric matrix, output data to be encoded in MAM, a numeric matrix (2d, also of n rows). Each row will be paired to the corresponding data_in row, forming an input-output vector pair.
</p>
</li></ul>

<p>Note: to encode additional input-output vector pairs in an existing MAM, use <code>train_single</code> method (see below).
</p>
</dd>
<dt><code>recall(data)</code>:</dt><dd><p> Get output for a dataset (numeric matrix <code>data</code>) from the (trained) MAM NN. </p>
</dd>
<dt><code>train_single (data_in, data_out)</code>:</dt><dd><p> Encode an input-output vector pair in the MAM NN. Vector sizes should be compatible to the current NN (as resulted from the <code>encode</code> method).</p>
</dd>
<dt><code>print()</code>:</dt><dd><p> print NN structure. </p>
</dd>
<dt><code>show()</code>:</dt><dd><p> print NN structure. </p>
</dd>
<dt><code>load(filename)</code>:</dt><dd><p> retrieve the NN from specified file. </p>
</dd>
<dt><code>save(filename)</code>:</dt><dd><p> save the NN to specified file. </p>
</dd>
</dl>

<p>The following methods are inherited (from the corresponding class):
objectPointer (&quot;RcppClass&quot;), initialize (&quot;RcppClass&quot;), show (&quot;RcppClass&quot;)
</p>


<h3>Note</h3>

<p>The NN in this module uses supervised training to store input-output vector pairs.
</p>
<p>(This function uses Rcpp to employ 'mam_nn' class in nnlib2.)
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pao Y (1989). Adaptive Pattern Recognition and Neural Networks. Reading, MA (US); Addison-Wesley Publishing Co., Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BP">BP</a>,<a href="#topic+LVQs">LVQs</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_s            &lt;- as.matrix(scale(iris[1:4]))
class_ids         &lt;- as.integer(iris$Species)
num_classes       &lt;- max(class_ids)

# create output dataset to be used for training, Here we encode class as -1s and 1s
iris_data_out &lt;- matrix( data = -1, nrow = nrow(iris_s), ncol = num_classes)

# now for each case, assign a 1 to the column corresponding to its class
for(r in 1:nrow(iris_data_out)) iris_data_out[r,class_ids[r]]=1

# Finally apply MAM:
# Encode train pairs in MAM and then get output dataset by recalling the test data.

mam &lt;- new("MAM")

mam$encode(iris_s,iris_data_out)

# test the encoding by recalling the original input data...
mam_data_out &lt;- mam$recall(iris_s)

# find which MAM output has the largest value and use this as the final cluster tag.
mam_recalled_cluster_ids = apply(mam_data_out,1,which.max)

plot(iris_s, pch=mam_recalled_cluster_ids, main="MAM recalled Iris data classes")

cat("MAM recalled these IDs:\n")
print(mam_recalled_cluster_ids)
</code></pre>

<hr>
<h2 id='NN_component_names'>Names of available NN components</h2><span id='topic+NN_component_names'></span>

<h3>Description</h3>

<p>A quick summary of names that can be used for adding NN components in a <code><a href="#topic+NN">NN</a></code> module. These names are available in the current package version. More components can be defined by the user or may be added in future versions.</p>


<h3>Current names for layers:</h3>

<p>Layer names currently available include:
</p>

<ul>
<li><p><code>generic</code>: a layer of generic Processing Elements (PEs).
</p>
</li>
<li><p><code>generic_d</code>: same as above.
</p>
</li>
<li><p><code>pe</code>: same as above.
</p>
</li>
<li><p><code>pass-through</code>: a layer with PEs that simply pass input to output.
</p>
</li>
<li><p><code>which-max</code>: a layer with PEs that return the index of one of their inputs whose value is maximum.
</p>
</li>
<li><p><code>MAM</code>: a layer with PEs for Matrix-Associative-Memory NNs (see vignette).
</p>
</li>
<li><p><code>LVQ-input</code>: LVQ input layer (see vignette).
</p>
</li>
<li><p><code>LVQ-output</code>: LVQ output layer (see vignette).
</p>
</li>
<li><p><code>BP-hidden</code>: Back-Propagation hidden layer (see vignette).
</p>
</li>
<li><p><code>BP-output</code>: Back-Propagation output layer (see vignette).
</p>
</li>
<li><p><code>R-layer</code>: A layer whose encode and recall (map) functionality is defined in R (see <a href="#topic+NN_R_components">NN_R_components</a>).
</p>
</li></ul>

<p>Additional (user-defined) layers currently available include:
</p>

<ul>
<li><p><code>JustAdd10</code>: a layer where PEs output the sum of their inputs plus 10 (created for use as example in vingnette).
</p>
</li>
<li><p><code>perceptron</code>: a classic perceptron layer (created for use as example in <a href="https://www.r-bloggers.com/2020/07/creating-custom-neural-networks-with-nnlib2rcpp/">in this post</a>).
</p>
</li>
<li><p><code>MEX</code>: a layer created for use as example in vingnette.
</p>
</li>
<li><p><code>example_layer_0</code>: a layer created to be used as a simple code example for users creating custom layers.
</p>
</li>
<li><p><code>example_layer_1</code>: as above.
</p>
</li>
<li><p><code>example_layer_2</code>: as above.
</p>
</li>
<li><p><code>BP-hidden-softmax</code>: Back-Propagation hidden layer that performs softmax on its output (when recalling).
</p>
</li>
<li><p><code>BP-output-softmax</code>: Back-Propagation output layer that performs softmax on its output (when recalling).
</p>
</li>
<li><p><code>softmax</code>: a layer that (during recall) sums its inputs and outputs the softmax values.
</p>
</li>
<li><p><code>R-connections</code>: A set of connections whose encode and recall (map) functionality is defined in R (see <a href="#topic+NN_R_components">NN_R_components</a>).
</p>
</li></ul>



<h3>Current names for sets of connections:</h3>

<p>Names for connection sets that are currently available include:
</p>

<ul>
<li><p><code>generic</code>: a set of generic connections.
</p>
</li>
<li><p><code>pass-through</code>: connections that pass data through with no modification.
</p>
</li>
<li><p><code>wpass-through</code>: connections that pass data multiplied by weight.
</p>
</li>
<li><p><code>MAM</code>: connections for Matrix-Associative-Memory NNs (see vignette).
</p>
</li>
<li><p><code>LVQ</code>: connections for LVQ NNs (see vignette).
</p>
</li>
<li><p><code>BP</code>: connections for Back-Propagation (see vignette).
</p>
</li></ul>

<p>Additional (user-defined) connection sets currently available include:
</p>

<ul>
<li><p><code>perceptron</code>: connections for perceptron (created for use as example in <a href="https://www.r-bloggers.com/2020/07/creating-custom-neural-networks-with-nnlib2rcpp/">in this post</a>).
</p>
</li>
<li><p><code>MEX</code>: a connection set created for use as example in vingnette.
</p>
</li>
<li><p><code>example_connection_set_0</code>: a connection set created to be used as a simple code example for users creating custom types of connection sets.
</p>
</li>
<li><p><code>example_connection_set_1</code>: as above.
</p>
</li>
<li><p><code>example_connection_set_2</code>: as above.
</p>
</li></ul>



<h3>Note</h3>

<p>These are component names that can be currently used to add components to a NN  using the methods provided by <code><a href="#topic+NN">NN</a></code> module. Such methods include <code>add_layer</code>, <code>add_connection_set</code>, <code>connect_layers_at</code>, <code>fully_connect_layers_at</code> etc. Some of these components may be experimental or created for use in examples and may change or be removed in future versions, while other components may be added.
</p>
<p>More information on expanding the library with new, user-defined types of NN components (nodes, layers, connections etc) and models, can be found in the package's vignette as well as the related <a href="https://github.com/VNNikolaidis/nnlib2Rcpp">repository on Github</a>). A quick example can also be found <a href="https://www.r-bloggers.com/2020/07/creating-custom-neural-networks-with-nnlib2rcpp/">in this post</a>. Please consider submitting any useful components you create, to enrich  future versions of the package.
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NN">NN</a></code>, <a href="#topic+NN_R_components">NN_R_components</a>.</p>

<hr>
<h2 id='NN_R_components'>Custom NN components defined using R</h2><span id='topic+NN_R_components'></span>

<h3>Description</h3>

<p>Custom NN components (to be employed in <code><a href="#topic+NN">NN</a></code> module neural networks) usually have their functionality defined using corresponding <span class="pkg">nnlib2</span> C++ classes. Alternatively, custom NN components can be defined using only R code.</p>


<h3>Introduction</h3>

<p>In addition to NN components defined using the provided <span class="pkg">nnlib2</span> C++ classes and class-templates (see Notes in <a href="#topic+NN">NN</a>), custom, user-defined NN components also can be created in R code (without any need for C++). Regardless of how they are defined, such components can be added to neural networks created in R via <code><a href="#topic+NN">NN</a></code> module and cooperate with each other.</p>


<h3>1. Layers</h3>

<p>Layers of nodes (aka Processing Elements or PEs) whose encode/recall behavior is to be defined using R can be added to the NN via the <code>add_layer</code> <code><a href="#topic+NN">NN</a></code> method. The call to <code>add_layer</code> should have a single parameter, a <code>list</code> containing four named elements:
</p>

<ul>
<li><p><code>name</code>: always equal to <code>"R-layer"</code>.
</p>
</li>
<li><p><code>size</code>: the number of nodes in the new layer.
</p>
</li>
<li><p><code>encode_FUN</code>: the name of the R function to be called when the layer is encoding data (or <code>""</code> if none).
</p>
</li>
<li><p><code>recall_FUN</code>: the name of the R function to be called when the layer is recalling data (or <code>""</code> if none).
</p>
</li></ul>

<p>For example: <br /><br /><code>p$add_layer(list(name="R-layer", size=100, encode_FUN="", recall_FUN="rfun"))</code> <br /><br /> adds a layer to a NN topology (here the NN is named <code>p</code>). The new layer will contain 100 nodes, no R function will be used when the layer is encoding, some R function (here named <code>rfun</code>) will be used when the layer is recalling (mapping) data.<br /><br />
The R functions specified as <code>encode_FUN</code> and <code>recall_FUN</code> for layers will have to be defined so that they accept (zero or more) of the following parameters:
</p>

<ul>
<li><p><code>INPUT</code>: vector of the current incoming numeric values (one per node, length equals size of the layer).
</p>
</li>
<li><p><code>INPUT_Q</code>: matrix where each column contains the numeric values that have been sent to the corresponding node.
</p>
</li>
<li><p><code>BIAS</code>: vector with the numeric value stored as 'bias' of each node (length equals size of the layer).
</p>
</li>
<li><p><code>MISC</code>: vector with the numeric value stored in each node's 'misc' register (length equals size of the layer).
</p>
</li>
<li><p><code>OUTPUT</code>: vector with the current output of the layer (length equals size of the layer).
</p>
</li></ul>

<p>In particular, for layers the R functions should have the following characteristics:
</p>

<ul>
<li><p> Encode function: the R function to be called when the layer is encoding data may use any of the parameters listed above and must return a <code>list</code> containing named items with the new (adjusted) values for <code>BIAS</code>, <code>MISC</code> and / or <code>OUTPUT</code>. If no changes are made by the R function, it may return an empty list.
</p>
</li>
<li><p> Recall function: the R function to be called when the layer is recalling (mapping) data may use any of the parameters listed above and must return a vector containing the layer's new <code>OUTPUT</code>.</p>
</li></ul>

<p>Note: The two variations of input (<code>INPUT</code> and <code>INPUT_Q</code>) are provided for flexibility in various implementations. Some connection set implementations may only send a single (final) input value to each node. These values are found in <code>INPUT</code>. Other connection set types may send the individual values from each individual connection, so that they can be processed by the node's <code>input_function</code>; these values will be found in <code>INPUT_Q</code>. Furthermore, there may be designs where a combination of the two is used (not recommended), or several different connection sets are connected and sending data to the same destination layer, etc. Also note that direct access to <code>INPUT</code> may be removed is future versions.
</p>


<h3>2. Set of connections</h3>

<p>Connection sets whose encode/recall behavior is to be defined using R can be added to the NN via the <code>add_connection_set</code> or <code>fully_connect_layers_at</code> <code><a href="#topic+NN">NN</a></code> methods. The call to <code>add_connection_set</code> should have a single parameter, a <code>list</code> containing named elements:
</p>

<ul>
<li><p><code>name</code>: always equal to <code>"R-connections".</code>
</p>
</li>
<li><p><code>encode_FUN</code>: the name of the R function to be called when the connection set is encoding data (or <code>""</code> if none).
</p>
</li>
<li><p><code>recall_FUN</code>: the name of the R function to be called when the connection set is recalling data (or <code>""</code> if none).
</p>
</li>
<li><p><code>requires_misc</code>: (optional) logical, if TRUE each connection will be provided with an extra 'misc' data register.
</p>
</li></ul>

<p>For example: <br /><br /> <code>p$add_connection_set(list(name="R-connections",encode_FUN="ef",recall_FUN="rf"))</code> <br /><br /> adds a set of connections to the NN topology (here the NN is named <code>p</code>). The new connection set will use some R function (here named <code>ef</code>) when encoding data and another R function (here named <code>rf</code>) when recalling (mapping) data.<br /><br />
Note that for sets of connections defined using R (as described here), each set maintains the connection weights and (if required) misc values in matrices. During encode or recall (map) operations, the connection weights matrix, misc values matrix (if any) and other data from the connected layers are sent for processing to the two R functions. No <span class="pkg">nnlib2</span> C++ classes (<code>connection_set</code> and <code>connection</code>) are employed in this process, and all processing is done in R. The R functions specified as <code>encode_FUN</code> and <code>recall_FUN</code> for connection sets will have to be defined so that they accept (zero or more) of the following parameters:
</p>

<ul>
<li><p><code>WEIGHTS</code>: numeric matrix (s rows, d columns). This matrix contains the current connection weights..
</p>
</li>
<li><p><code>SOURCE_INPUT</code>: numeric vector (length s) containing the current input values of the nodes in the source layer (note: nodes often reset this values after they have processed them).
</p>
</li>
<li><p><code>SOURCE_OUTPUT</code>: numeric vector (length s) containing the current output values of the nodes in the source layer.
</p>
</li>
<li><p><code>SOURCE_MISC</code>: numeric vector (length s) with the numeric value stored in 'misc' registers of each node in the source layer.
</p>
</li>
<li><p><code>DESTINATION_INPUT</code>: numeric vector (length d) containing the current input values of the nodes in the destination layer (note: nodes often reset this values after they have processed them).
</p>
</li>
<li><p><code>DESTINATION_OUTPUT</code>: numeric vector (length d) containing the current output values of the nodes in the destination layer.
</p>
</li>
<li><p><code>DESTINATION_MISC</code>: numeric vector (length d) with the numeric value stored in 'misc' registers of each node in the destination layer.
</p>
</li>
<li><p><code>MISC</code>: numeric matrix (s rows, d columns). If not used, this is a matrix of 0 rows and 0 columns, otherwise it contains the values of  the 'misc' register in each connection.
</p>
</li></ul>

<p>where s is the number of nodes (length) of the source layer and d the number nodes in the destination layer.<br />
</p>
<p>The R functions for connection sets should have the following characteristics:
</p>

<ul>
<li><p> Encode function: the R function to be called when the connection set is encoding data may use any of the parameters listed above, but must return a <code>list</code> containing the new (adjusted) connection weights (named <code>WEIGHTS</code>, numeric matrix of s rows, d columns) and possibly the new connection 'misc' values (named <code>MISC</code>, numeric matrix of s rows, d columns). If no changes were made by the R function, it may return an empty list.
</p>
</li>
<li><p> Recall function: the R function to be called when the connection set is recalling or mapping data may use any of the parameters listed above and must return a numeric matrix of d columns. Each column of this matrix should contain the data values to be sent to the corresponding node (PE) in the destination layer. (Note: this matrix is similar to the <code>INPUT_Q</code> used in layers, see above).
</p>
</li></ul>



<h3>3. Control components</h3>

<p>Other special control or processing components can be added using <code><a href="#topic+NN">NN</a></code> module's <code>add_R_forwarding</code>, <code>add_R_pipelining</code>, <code>add_R_ignoring</code>, and <code>add_R_function</code> methods. See <code><a href="#topic+NN">NN</a></code> module.</p>


<h3>Note</h3>

<p>Defining NN components with custom behavior in R does have a cost in terms of run-time performance. It also, to a certain degree, defies some of the reasons for using C++ classes. However, it may be useful for experimentation, prototyping, education purposes etc.
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NN">NN</a></code>, <a href="#topic+NN_component_names">NN_component_names</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#-------------------------------------------------------------------------------
# 1. LAYER EXAMPLE:

# Example R function to be used when the layer is encoding:
# Version for when the final input (a single value per PE) is directly sent to
# the layer (by set_input or some connection set).
# Outputs difference from current bias values, stores current input as new bias:

LAYERenc1 &lt;- function(INPUT,BIAS,...)
{
	i &lt;- INPUT				# get values directly injected as input to the PE.
	o &lt;- i-BIAS				# subtract old bias from input.
	# update layer's output and biases:
	return(list(OUTPUT=o, BIAS=INPUT))
}

# Example R function to be used when the layer is recalling (mapping):
# Version for when the final input (a single value per PE) is directly sent to
# the layer (by set_input or some connection set).
# Outputs difference from current bias values:

LAYERrec1 &lt;- function(INPUT,BIAS,...)
{
	i &lt;- INPUT				# get values directly injected as input to the PE.
	o &lt;- i-BIAS				# subtract old bias from input.
	return(o)				# return this as output.
}

# Example R function to be used when the layer is encoding (same as above):
# Version for cases where a connection set is designed to send multiple
# values (one for each incoming connection) to each PE in the layer so that
# the PE can process them as needed. - typically via its 'input_function'.
# (also works when set_input is used)
# INPUT_Q is a matrix where each column contains the values that have been sent
# to the corresponding node (PE).
# Outputs difference from current bias values, stores current input as new bias:

LAYERenc2 &lt;- function(INPUT_Q,BIAS,...)
{
	i &lt;- colSums(INPUT_Q)	# summate incoming values to produce final input.
	o &lt;- i-BIAS				# subtract old bias from that input.
	# update layer's output and biases:
	return(list(OUTPUT=o, BIAS=i))
}

# Example R function to be used when the layer is recalling/mapping (same as above):
# version for cases where a connection set is designed to send multiple
# values (one for each incoming connection) to each PE in the layer so that
# the PE can process them as needed - typically via its 'input_function'.
# (also works when set_input is used)
# INPUT_Q is a matrix where each column contains the values that have been sent
# to the corresponding node (PE).
# Outputs difference from current bias values:

LAYERrec2 &lt;- function(INPUT_Q,BIAS,...)
{
	i &lt;- colSums(INPUT_Q)	# summate incoming values to produce final input.
	o &lt;- i-BIAS				# subtract old bias from that input.
	return(o)				# return this as output.
}

# create and setup a "NN".

n&lt;-new("NN")
n$add_layer(list(name="R-layer", size=4,
				 encode_FUN="LAYERenc1", recall_FUN="LAYERrec1"))

# test the layer:

n$set_input_at(1,c(1,0,5,5))
n$encode_at(1)
print(n$get_biases_at(1))

n$set_input_at(1,c(20,20,20,20))
n$recall_at(1)
print(n$get_output_at(1))
n$set_input_at(1,c(10,0,10,0))
n$recall_at(1)
print(n$get_output_at(1))

#-------------------------------------------------------------------------------
# 2. CONNECTION SET EXAMPLE:

# This simple connection set will encode data by adding to each connection
# weight the output of the source node.

CSenc &lt;- function(WEIGHTS, SOURCE_OUTPUT,...)
{
	x &lt;- WEIGHTS + SOURCE_OUTPUT
	return(list(WEIGHTS=x))
}

# When recalling, this simple connection set multiplies source data by weights.
# this version sends multiple values (the products) to each destination node.
# Typical (s.a. generic) nodes add these values to process them.

CSrec1 &lt;- function(WEIGHTS, SOURCE_OUTPUT,...)
{
	x &lt;- WEIGHTS * SOURCE_OUTPUT
	return(x)
}

# When recalling, this simple connection set multiplies source data by weights.
# this version sends a single value (the sum of the products) to each
# destination node.

CSrec2 &lt;- function(WEIGHTS, SOURCE_OUTPUT,...)
{
	x &lt;-  SOURCE_OUTPUT %*% WEIGHTS
	return(x)
}

# create and setup a "NN".

n&lt;-new("NN")
n$add_layer("generic",4)
n$add_connection_set(list(name="R-connections",encode_FUN="CSenc",recall_FUN="CSrec2"))
n$add_layer("generic",2)
n$create_connections_in_sets(0,0)

# test the NN:

n$set_input_at(1,c(0,1,5,10))
n$encode_all_fwd()
n$set_input_at(1,c(1,1,1,1))
n$encode_all_fwd()

# see if weights were modified:
print(n$get_weights_at(2))

n$set_input_at(1,c(20,20,20,20))
n$recall_all_fwd()
print(n$get_output_at(3))

#-------------------------------------------------------------------------------
# 3. A COMPLETE EXAMPLE (simple single layer perceptron-like NN):

# Function for connections, when recalling/mapping:
# Use any one of the two functions below.
# Each column of the returned matrix contains the data that will be sent to the
# corresponding destination node.

# version 1: sends multiple values (product) for destination nodes to summate.

CSmap1 &lt;- function(WEIGHTS, SOURCE_OUTPUT,...)  WEIGHTS * SOURCE_OUTPUT

# version 2: sends corresponding value (dot product) to destination node.

CSmap2 &lt;- function(WEIGHTS, SOURCE_OUTPUT,...) SOURCE_OUTPUT %*% WEIGHTS

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Function for connections, when encoding data:

learning_rate &lt;- 0.3

CSenc &lt;- function(WEIGHTS, SOURCE_OUTPUT, DESTINATION_MISC, DESTINATION_OUTPUT, ...)
{
  a &lt;- learning_rate *
          (DESTINATION_MISC - DESTINATION_OUTPUT)   # desired output is in misc registers.
  a &lt;- outer( SOURCE_OUTPUT, a , "*" )              # compute weight adjustments.
  w &lt;- WEIGHTS + a                                  # compute adjusted weights.
  return(list(WEIGHTS=w))                           # return new (adjusted) weights.
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Function for layer, when recalling/mapping:
# (note: no encode function is used for the layer in this example)

LAmap &lt;- function(INPUT_Q,...)
{
	x &lt;- colSums(INPUT_Q)		# input function is summation.
	x &lt;- ifelse(x&gt;0,1,0)		# threshold function is step.
	return(x)
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# prepare some data based on iris data set:

data_in &lt;- as.matrix(iris[1:4])
iris_cases &lt;- nrow((data_in))
# make a "one-hot" encoding matrix for iris species
desired_data_out &lt;- matrix(data=0, nrow=iris_cases, ncol=3)
desired_data_out[cbind(1:iris_cases,unclass(iris[,5]))]=1

# create the NN and define its components:
# (first generic layer simply accepts input and transfers it to the connections)

p &lt;- new("NN")

p$add_layer("generic",4)

p$add_connection_set(list(name="R-connections",
                          encode_FUN="CSenc",
                          recall_FUN="CSmap2"))

p$add_layer(list(name="R-layer",
                 size=3,
                 encode_FUN="",
                 recall_FUN="LAmap"))

p$create_connections_in_sets(0,0)

# encode data and desired output (for 50 training epochs):

for(i in 1:50)
	for(c in 1:iris_cases)
	{
		p$input_at(1,data_in[c,])
		p$set_misc_values_at(3,desired_data_out[c,])  # put desired output in misc registers
		p$recall_all_fwd();
		p$encode_at(2)
	}

# Recall the data and show NN's output:

for(c in 1:iris_cases)
{
	p$input_at(1,data_in[c,])
	p$recall_all_fwd()
	cat("iris case ",c,", desired = ", desired_data_out[c,],
		" returned = ", p$get_output_from(3),"\n")
}


## End(Not run)
</code></pre>

<hr>
<h2 id='NN-class'>Class <code>"NN"</code></h2><span id='topic+NN-class'></span><span id='topic+Rcpp_NN'></span><span id='topic+Rcpp_NN-class'></span><span id='topic+NN'></span><span id='topic+nn-class'></span><span id='topic+C+2B+2BObject-class'></span><span id='topic+RcppClass-class'></span>

<h3>Description</h3>

<p>NN module, for defining and manipulating custom neural networks.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+RcppClass-class">RcppClass</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>.CppObject</code>:</dt><dd><p>Object of class <code>C++Object</code> ~~ </p>
</dd>
<dt><code>.CppClassDef</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
<dt><code>.CppGenerator</code>:</dt><dd><p>Object of class <code>activeBindingFunction</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>add_layer( name, size, optional_parameter )</code>:</dt><dd></dd>
<dt><code>add_layer( parameters )</code>:</dt><dd><p>Setup a new <code>layer</code> component (a layer of processing nodes) and append it to the NN topology. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>name</code>: string, containing name (that also Specifies type) of new layer. Names of predefined layers currently include <code>'pe'</code>(same as <code>'generic'</code>), <code>'pass-through'</code>, <code>'which-max'</code>, <code>'MAM'</code>, <code>'LVQ-input'</code>, <code>'LVQ-output'</code>, <code>'BP-hidden'</code>, <code>'BP-output'</code>, <code>'perceptron'</code> (Some of the available names are listed in <a href="#topic+NN_component_names">NN_component_names</a>, additional names for user-defined components may be added, see note.)
</p>
</li>
<li><p><code>size</code>: integer, layer size i.e. number of <code>pe</code> (Processing Elements or nodes) to create in the layer.
</p>
</li>
<li><p><code>optional_parameter</code>: (optional) double, parameter to be used by specific layer implementations (for example, BP layer implementations <code>'BP-hidden'</code> and <code>'BP-output'</code> interpret it is as the layer's learning rate). Note: for more optional parameters use <code>parameters</code> below.
</p>
</li>
<li><p><code>parameters</code>: list, containing named parameters to be used in creating the layer. Must include an element named <code>name</code> and an element called <code>size</code> (similar to the corresponding standalone parameters described above).
</p>
</li></ul>

</dd>
<dt><code>add_connection_set( name, optional_parameter )</code>:</dt><dd></dd>
<dt><code>add_connection_set( parameters )</code>:</dt><dd><p>Create a new empty <code>connection_set</code> component (a set of connections between two layers). It does not connect any layers nor contain any connections between specific layer nodes. The set is appended to the NN topology. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>name</code>: string, containing name (that also specifies type) of new empty connection set. Names of predefined connection sets currently include <code>'generic', 'pass-through'</code>(which does not multiply weights), <code>'wpass-through'</code>(which does multiply weights), <code>'MAM'</code>, <code>'LVQ'</code>, <code>'BP'</code>, <code>'perceptron'</code> (Some of the available names are listed in <a href="#topic+NN_component_names">NN_component_names</a>, additional names for user-defined components may be added, see note.).
</p>
</li>
<li><p><code>optional_parameter</code>: (optional) double, parameter to be used by specific connection set implementations (for example, <code>'BP'</code> connection sets interpret it is as the learning rate to be used when adjusting weights, <code>'LVQ'</code> connection sets use it to count iterations for decreasing weight adjustments, etc). Note: for more optional parameters use <code>parameters</code> below.
</p>
</li>
<li><p><code>parameters</code>: list, containing named parameters to be used in creating the connection set. Must include an element named <code>name</code> which contains the name (that also specifies type) of new empty connection set (similar to the corresponding standalone parameter described above).
</p>
</li></ul>

</dd>
<dt><code>create_connections_in_sets( min_random_weight, max_random_weight )</code>:</dt><dd><p>Find empty, unconnected <code>connection_set</code> components that are between two  <code>layer</code>s in the topology, and set them up to connect the adjacent layers, adding connections to fully connect their nodes (n x m connections created, n and m the number of nodes at each layer respectively). Assumes top layer is source and bottom layer is destination. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>min_random_weight</code>: double, minimum value for random initial connection weights.
</p>
</li>
<li><p><code>max_random_weight</code>: double, maximum value for random initial connection weights.
</p>
</li></ul>

</dd>
<dt><code>connect_layers_at( source_pos, destin_pos, name, optional_parameter )</code>:</dt><dd></dd>
<dt><code>connect_layers_at( source_pos, destin_pos, parameters )</code>:</dt><dd><p>Insert a new empty <code>connection_set</code> component (a set of connections between two layers) between the layers at specified topology positions, and prepare it to be filled with connections between them. No actual connections between any layer nodes are created. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>source_pos</code>: integer, position in topology of source layer.
</p>
</li>
<li><p><code>destin_pos</code>: integer, position in topology of destination layer.
</p>
</li>
<li><p><code>name</code>: string, containing name (that also specifies type) of new connection set (see above).
</p>
</li>
<li><p><code>optional_parameter</code>: (optional) double, parameter to be used by specific connection set implementations (for example, <code>'BP'</code> connection sets interpret it is as the learning rate to be used when adjusting weights, <code>'LVQ'</code> connection sets use it to count iterations for decreasing weight adjustments, etc). Note: for more optional parameters use <code>parameters</code> below.
</p>
</li>
<li><p><code>parameters</code>: list, containing named parameters to be used in creating the connection set. Must include an element named <code>name</code> which contains the name (that also specifies type) of new empty connection set (similar to the corresponding standalone parameter described above).
</p>
</li></ul>

</dd>
<dt><code>fully_connect_layers_at( source_pos, destin_pos, name, min_random_weight, max_random_weight, optional_parameter )</code>:</dt><dd></dd>
<dt><code>fully_connect_layers_at( source_pos, destin_pos, parameters, min_random_weight, max_random_weight )</code>:</dt><dd><p>Same as <code>connect_layers_at</code> but also fills the new <code>connection_set</code> with connections between the nodes of the two layers, fully connecting the layers (n x m connections are created, with n and m the number of nodes at each layer respectively). Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>source_pos</code>: integer, position in topology of source layer.
</p>
</li>
<li><p><code>destin_pos</code>: integer, position in topology of destination layer.
</p>
</li>
<li><p><code>name</code>: string, containing name (that also specifies type) of new connection set (see above).
</p>
</li>
<li><p><code>min_random_weight</code>: double, minimum value for random initial connection weights.
</p>
</li>
<li><p><code>max_random_weight</code>: double, maximum value for random initial connection weights.
</p>
</li>
<li><p><code>optional_parameter</code>: (optional) double, parameter to be used by specific connection set implementations (for example, <code>'BP'</code> connection sets interpret it is as the learning rate to be used when adjusting weights, <code>'LVQ'</code> connection sets use it to count iterations for decreasing weight adjustments, etc). Note: for more optional parameters use <code>parameters</code> below.
</p>
</li>
<li><p><code>parameters</code>: list, containing named parameters to be used in creating the connection set. Must include an element named <code>name</code> which contains the name (that also specifies type) of new empty connection set (similar to the corresponding standalone parameter described above).
</p>
</li></ul>

</dd>
<dt><code>add_single_connection( pos, source_pe, destin_pe, weight )</code>:</dt><dd>
<p>Add a connection to a <code>connection_set</code> that already connects two layers. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position in topology of <code>connection_set</code> to which the new connection will be added.
</p>
</li>
<li><p><code>source_pe</code>: integer, <code>pe</code> in source layer to connect.
</p>
</li>
<li><p><code>destin_pe</code>: integer, <code>pe</code> in destination layer to connect.
</p>
</li>
<li><p><code>weight</code>: double, value for initial connection weight.
</p>
</li></ul>

</dd>
<dt><code>remove_single_connection( pos, con )</code>:</dt><dd>
<p>Remove a connection from a <code>connection_set</code>. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position in topology of <code>connection_set</code>.
</p>
</li>
<li><p><code>con</code>: integer, connection to remove (note: numbering starts from 0).
</p>
</li></ul>

</dd>
<dt><code>size()</code>:</dt><dd><p>Returns neural network size, i.e. the number of components its topology.</p>
</dd>
<dt><code>sizes()</code>:</dt><dd><p>Returns sizes of components in topology.</p>
</dd>
<dt><code>component_ids()</code>:</dt><dd><p>Returns an integer vector containing the ids of the components in topology (these ids are created at run-time and identify each NN component).</p>
</dd>
<dt><code>encode_at( pos )</code>:</dt><dd><p>Trigger the encoding operation of the component at specified topology index (note: depending on implementation, an 'encode' operation usually collects inputs, processes the data, adjusts internal state variables and/or weights, and possibly produces output). Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to perform encoding.
</p>
</li></ul>

</dd>
<dt><code>encode_all( fwd )</code>:</dt><dd><p>Trigger the encoding operation of all the components in the NN topology. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>fwd</code>: logical, set to TRUE to trigger encoding forwards (first-to-last component), FALSE to trigger encoding backwards (last-to-first component).
</p>
</li></ul>

</dd>
<dt><code>encode_all_fwd( )</code>:</dt><dd><p>Trigger the encoding operation of all the components in the NN topology following a forward (top-to-bottom) direction. Returns TRUE if successful.     </p>
</dd>
<dt><code>encode_all_bwd( )</code>:</dt><dd><p>Trigger the encoding operation of all the components in the NN topology following a backward (bottom-to-top) direction. Returns TRUE if successful.     </p>
</dd>
<dt><code>encode_dataset_unsupervised( data, pos, epochs, fwd )</code>:</dt><dd><p>Encode a dataset using unsupervised training. A faster method to encode a data set. All the components in the NN topology will perform 'encode' in specified direction. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>data</code>: numeric matrix, containing input vectors as rows.
</p>
</li>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to receive input vectors.
</p>
</li>
<li><p><code>epochs</code>: integer, number of training epochs (encoding repetitions of the entire dataset).
</p>
</li>
<li><p><code>fwd</code>: logical, indicates direction, TRUE to trigger encoding forwards (first-to-last component), FALSE to encode backwards (last-to-first component).
</p>
</li></ul>

</dd>
<dt><code>encode_datasets_supervised( i_data, i_pos, j_data, j_pos, j_destination_register, epochs, fwd )</code>:</dt><dd><p>Encode multiple (i,j) vector pairs stored in two corresponding data sets, using supervised training. A faster method to encode the data. All the components in the NN topology will perform 'encode' in specified direction. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>i_data</code>: numeric matrix, data set, each row is a vector i of vector-pair (i,j).
</p>
</li>
<li><p><code>i_pos</code>: integer, position (in NN's topology) of component to receive i vectors.
</p>
</li>
<li><p><code>j_data</code>: numeric matrix, data set, each row is a corresponding vector j of vector-pair (i,j).
</p>
</li>
<li><p><code>j_pos</code>: integer, position (in NN's topology) of component to receive j vectors.
</p>
</li>
<li><p><code>j_destination_selector</code>: integer, selects which internal node (pe) registers will receive vector j, i.e. if 0 internal node register '<code>input</code>' will be used (j will become the layer's input), if 1 register '<code>output</code>' will be used (j will become the layer's output), if 2 register '<code>misc</code>' will be used (implementations may use this as an alternative way to transfer data to nodes without altering current input or output).
</p>
</li>
<li><p><code>epochs</code>: integer, number of training epochs (encoding repetitions of the entire data).
</p>
</li>
<li><p><code>fwd</code>: logical, indicates direction, TRUE to trigger encoding forwards (first-to-last component), FALSE to encode backwards (last-to-first component).
</p>
</li></ul>

</dd>
<dt><code>recall_at( pos )</code>:</dt><dd><p>Trigger the recall (mapping, data retrieval) operation of the component at specified topology index (note: depending on implementation, a 'recall' operation usually collects input(s), processes the data, produces output and resets input to 0). Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to perform recall.
</p>
</li></ul>

</dd>
<dt><code>recall_all( fwd )</code>:</dt><dd><p>Trigger the recall (mapping, data retrieval) operation of all the components in the NN topology. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>fwd</code>: logical, set to TRUE to trigger recall forwards (first-to-last component), FALSE to trigger recall backwards (last-to-first component).
</p>
</li></ul>

</dd>
<dt><code>recall_all_fwd( )</code>:</dt><dd><p>Trigger the recall (mapping, data retrieval) operation of all the components in the NN topology following a forward (top-to-bottom) direction. Returns TRUE if successful.     </p>
</dd>
<dt><code>recall_all_bwd( )</code>:</dt><dd><p>Trigger the recall (mapping, data retrieval) operation of all the components in the NN topology following a backward (bottom-to-top) direction. Returns TRUE if successful.     </p>
</dd>
<dt><code>recall_dataset( data_in, input_pos, output_pos, fwd )</code>:</dt><dd><p>Recall (map, retrieve output for) a dataset. A faster method to recall an entire data set. All the components in the NN topology will perform 'recall' in specified direction. Returns numeric matrix containing corresponding output. Parameters are:
</p>

<ul>
<li><p><code>data_in</code>: numeric matrix, containing input vectors as rows.
</p>
</li>
<li><p><code>input_pos</code>: integer, position (in NN's topology) of component to receive input vectors.
</p>
</li>
<li><p><code>output_pos</code>: integer, position (in NN's topology) of component to produce output.
</p>
</li>
<li><p><code>fwd</code>: logical, indicates direction, TRUE to trigger 'recall' (mapping) forwards (first-to-last component), FALSE to recall backwards (last-to-first component).
</p>
</li></ul>

</dd>
<dt><code>input_at( pos, data_in )</code>:</dt><dd><p>Input a data vector to the component (<code>layer</code>) at specified topology index. Returns TRUE if successful. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to receive input.
</p>
</li>
<li><p><code>data_in</code>: NumericVector, data to be sent as input to component (sizes must match).
</p>
</li></ul>

</dd>
<dt><code>set_input_at( pos, data_in )</code>:</dt><dd><p>Same as <code>input_at</code> (see above)</p>
</dd>
<dt><code>get_input_at( pos )</code>:</dt><dd><p>Get the current input for the component at specified topology index. Currently applicable to <code>connection_set</code> (returning for each connection the output of corresponding source PE), or <code>layer</code> (returning a preview of current PE inputs; note: many PE implementations clear their inputs once they have processed them and produced the corresponding output). If successful, returns NumericVector, otherwise vector of zero length. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li></ul>

</dd>
<dt><code>get_output_from( pos )</code>:</dt><dd><p>Get the current output of the component at specified topology index. If successful, returns NumericVector of output values (otherwise vector of zero length). Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li></ul>

</dd>
<dt><code>get_output_at( pos )</code>:</dt><dd><p>Same as <code>get_output_from</code>, see above.</p>
</dd>
<dt><code>set_output_at( pos, data_in )</code>:</dt><dd><p>Set the values in the <code>output</code> data register that <code>pe</code> objects maintain, for <code>layer</code> at specified topology index (currently only <code>layer</code> components are supported). If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>data_in</code>: NumericVector, data to be used for new values in <code>misc</code> registers (sizes must match).
</p>
</li></ul>

</dd>
<dt><code>get_weights_at( pos )</code>:</dt><dd><p>Get the current weights of the component (<code>connection_set</code>) at specified topology index. If successful, returns NumericVector of connection weights (otherwise vector of zero length). Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li></ul>

</dd>
<dt><code>set_weights_at( pos )</code>:</dt><dd><p>Set the weights of the component (<code>connection_set</code>) at specified topology index. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>data_in</code>: NumericVector, data to be used for new values in <code>weight</code> registers of connections (sizes must match).
</p>
</li></ul>

</dd>
<dt><code>get_weight_at( pos, connection )</code>:</dt><dd><p>Get the current weight of a connection in component (<code>connection_set</code>) at specified topology index. If successful, returns weight, otherwise 0 (note: this might change in future versions). Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>connection</code>: integer, connection to use (note: numbering starts from 0).
</p>
</li></ul>

</dd>
<dt><code>set_weight_at( pos, connection, value )</code>:</dt><dd><p>Set the weight of a connection in component (<code>connection_set</code>) at specified topology index. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>connection</code>: integer, connection to use (note: numbering starts from 0).
</p>
</li>
<li><p><code>value</code>: new weight for connection.
</p>
</li></ul>

</dd>
<dt><code>get_misc_values_at( pos )</code>:</dt><dd><p>Get the values in the <code>misc</code> data register that <code>pe</code> and <code>connection</code> objects maintain, for objects at specified topology index. If successful, returns NumericVector of the values (otherwise vector of zero length). Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li></ul>

</dd>
<dt><code>set_misc_values_at( pos, data_in )</code>:</dt><dd><p>Set the values in the <code>misc</code> data register that <code>pe</code> and <code>connection</code> objects maintain, for objects at specified topology index. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>data_in</code>: NumericVector, data to be used for new values in <code>misc</code> registers (sizes must match).
</p>
</li></ul>

</dd>
<dt><code>get_biases_at( pos )</code>:</dt><dd><p>Get the values in the <code>bias</code> register that <code>pe</code> (Processing Elements or nodes) maintain, for <code>layer</code> at specified topology index (only <code>layer</code> components are supported). If successful, returns NumericVector of bias values (otherwise vector of zero length). Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li></ul>

</dd>
<dt><code>set_biases_at( pos, data_in )</code>:</dt><dd><p>Set the values in the <code>bias</code> register that <code>pe</code> (Processing Elements or nodes) maintain, for <code>layer</code> at specified topology index (only <code>layer</code> components are supported). If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>data_in</code>: NumericVector, data to be used for new values in <code>bias</code> registers (sizes must match).
</p>
</li></ul>

</dd>
<dt><code>get_bias_at( pos, pe )</code>:</dt><dd><p>Get the bias of a <code>pe</code> (Processing Element or node) in component (<code>layer</code>) at specified topology index. If successful, returns bias otherwise 0 (note: this might change in future versions). Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>pe</code>: integer, Processing Element (node) in <code>layer</code> to use (note: numbering starts from 0).
</p>
</li></ul>

</dd>
<dt><code>set_bias_at( pos, pe, value )</code>:</dt><dd><p>Set the bias of a <code>pe</code> (Processing Element or node) in component (<code>layer</code>) at specified topology index. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>pos</code>: integer, position (in NN's topology) of component to use.
</p>
</li>
<li><p><code>pe</code>: integer, Processing Element (node) in <code>layer</code> to use (note: numbering starts from 0).
</p>
</li>
<li><p><code>value</code>: new value for bias at the specified <code>pe</code>.
</p>
</li></ul>

</dd>
<dt><code>add_R_forwarding( trigger, FUN )</code>:</dt><dd><p>Adds a control component which will invoke an R function. The R function will receive (as its first argument) a vector of values containing the output of the previous component in the topology. The object returned by the function will be fed as input to the next (in forward direction) component in the topology. Notes: (a) once the R function is invoked, its result will be maintained as this component's output; (b) the component will fail to perform processing if the R function's result cannot be converted to a numeric vector. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>trigger</code>: string, specifies when to invoke the R function. Valid options are <code>"on encode"</code>, <code>"on recall"</code>, <code>"always"</code> or <code>"never"</code>.
</p>
</li>
<li><p><code>FUN</code>: string, the R function to be invoked. If <code>""</code>, no R function is invoked and data is transferred unmodified.
</p>
</li></ul>
</dd>
<dt><code>add_R_pipelining( trigger, FUN, fwd )</code>:</dt><dd><p>Adds a control component which will invoke an R function. The R function will process  (as its first argument)  a vector of values which are the output of a neighboring component in the topology; The result of invoking the function will be fed as input to the other neighboring component in the topology. The components are selected according to the value of parameter <code>fwd</code> (see below). Notes: (a) once the R function is invoked, its result will be maintained as this component's output; (b) the component will fail to perform processing if the R function's result cannot be converted to a numeric vector. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>trigger</code>: string, specifies when to invoke the R function. Valid options are <code>"on encode"</code>, <code>"on recall"</code>, <code>"always"</code> or <code>"never"</code>.
</p>
</li>
<li><p><code>FUN</code>: string, the R function to be invoked. If <code>""</code>, no R function is invoked and data is transferred unmodified.
</p>
</li>
<li><p><code>fwd</code>: logical, set to TRUE if encoding or recalling in forward, top-to-bottom, direction and need to read from previous component in the topology feeding the result as input to the next (same as <code>add_R_forwarding</code>). If FALSE, reads from next component in the topology and feeds the result as input to the previous (useful when encoding/recalling in backward, bottom-to-top, direction).
</p>
</li></ul>
</dd>
<dt><code>add_R_ignoring( trigger, FUN, i_mode, input_from )</code>:</dt><dd><p>Adds a control component which will invoke an R function ignoring its result. The R function will process (as its first argument)  a vector of values taken from a specified component in the topology, but the function's result will be ignored. This is suitable for invoking functions such as <code>print</code>, <code>plot</code> etc. Note: the component maintains the original values as its output values but does not send to any other component neither these original values nor the result of the R function. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>trigger</code>: string, specifies when to invoke the R function. Valid options are <code>"on encode"</code>, <code>"on recall"</code>, <code>"always"</code> or <code>"never"</code>.
</p>
</li>
<li><p><code>FUN</code>: string, the R function to be invoked. If <code>""</code>, no R function is invoked and data is transferred unmodified.
</p>
</li>
<li><p><code>i_mode</code>: string, specifies the source of data to be retrieved and processed by the R function. Valid options are <code>"none"</code>, <code>"input of"</code>, <code>"output of"</code>, <code>"weights at"</code>, <code>"biases at"</code> and <code>"misc at"</code>.
</p>
</li>
<li><p><code>input_from</code>: integer, position (in NN's topology) of component to retrieve data from.
</p>
</li></ul>
</dd>
<dt><code>add_R_function( trigger, FUN, i_mode, input_from, o_mode, output_to, ignore_result )</code>:</dt><dd><p>Adds a control component which will invoke an R function. The R function will process process (as its first argument) a vector of values taken from a specified component and feed the results to another component. Notes: (a) once the R function is invoked, its result will be maintained as this component's output (unless <code>ignore_result</code> is set to TRUE, in which case the original values will be maintained); (b) the component will fail to perform processing if the R function's result cannot be converted to a numeric vector and <code>ignore_result</code> is FALSE. If successful, returns TRUE. Parameters are:
</p>

<ul>
<li><p><code>trigger</code>: string, specifies when to invoke the R function. Valid options are <code>"on encode"</code>, <code>"on recall"</code>, <code>"always"</code> or <code>"never"</code>.
</p>
</li>
<li><p><code>FUN</code>: string, the R function to be invoked. If <code>""</code>, no R function is invoked and data is transferred unmodified.
</p>
</li>
<li><p><code>i_mode</code>: string, specifies the source of data to be retrieved and processed by the R function. Valid options are <code>"none"</code>, <code>"input of"</code>, <code>"output of"</code>, <code>"weights at"</code>, <code>"biases at"</code> and <code>"misc at"</code>.
</p>
</li>
<li><p><code>input_from</code>: integer, position (in NN's topology) of component to retrieve data from.
</p>
</li>
<li><p><code>o_mode</code>: string, specifies the destination for the result returned by the R function. Valid options are <code>"none"</code>, <code>"to input"</code>, <code>"to output"</code>, <code>"to weights"</code>, <code>"to biases"</code> and <code>"to misc"</code>.
</p>
</li>
<li><p><code>output_to</code>: integer, position (in NN's topology) of component to receive the resulting data.
</p>
</li>
<li><p><code>ignore_result</code>: logical, if TRUE, the R function's results are ignored and original (incoming) values are maintained and (possibly) sent to the <code>output_to</code> component. If FALSE, the values used are those returned by the R function.
</p>
</li></ul>
</dd>
<dt><code>outline()</code>:</dt><dd><p>Print a summary description of all components in topology.</p>
</dd>
<dt><code>print()</code>:</dt><dd><p>Print internal NN state, including all components in topology.</p>
</dd>
<dt><code>show()</code>:</dt><dd><p>Print summary description and  internal NN state.</p>
</dd>
<dt><code>get_topology_info()</code>:</dt><dd><p>Returns <code>data.frame</code> with topology information.</p>
</dd>
</dl>

<p>The following methods are inherited (from the corresponding class):
objectPointer (&quot;RcppClass&quot;), initialize (&quot;RcppClass&quot;), show (&quot;RcppClass&quot;).
</p>


<h3>Note</h3>

<p>This R module maintains a generic neural network that can be manipulated using the provided methods. In addition to predefined components already existing in the package, new neural network components can be defined and then employed by the <code>"NN"</code> module. In doing so, it is recommended to use the provided C++ base classes and class-templates. This requires the package source code (which includes the <span class="pkg">nnlib2</span> C++ library of neural network base classes) and the ability to compile the package. The steps for defining new types of components using C++ are outlined below:
</p>

<ul>
<li><p> Any new component type or class definition should be added to the header file called &quot;<code>additional_parts.h</code>&quot; which is included in the package source (src) directory, or in files accessible by the functions in &quot;<code>additional_parts.h</code>&quot;. Therefore, all new components to be employed by the <code>NN</code> module must be defined in &quot;<code>additional_parts.h</code>&quot; or in files that this file includes via <code>#include</code>.
</p>
</li>
<li><p> New <code>layer</code>, <code>connection_set</code>, <code>pe</code> or <code>connection</code> definitions must comply (at least loosely) to the <span class="pkg">nnlib2</span> base class hierarchy and structure and follow the related guidelines. Note: some minimal examples of class and type definitions can be found in the &quot;<code>additional_parts.h</code>&quot; file itself.
</p>
</li>
<li><p> A textual name must be assigned to any new <code>layer</code> or <code>connection_set</code>, to be used as parameter in <code>NN</code> module methods that require a name to create a component. This can be as simple as a single line of code where given the textual name the corresponding component object is created and returned. This code must be added (as appropriate) to either <code>generate_custom_layer()</code> or <code>generate_custom_connection_set()</code> functions found in the same &quot;<code>additional_parts.h</code>&quot; header file. Note: example entries can be found in these functions at the &quot;<code>additional_parts.h</code>&quot; file. Some of the available names are listed in <a href="#topic+NN_component_names">NN_component_names</a>.
</p>
</li></ul>

<p>Alternatively, NN components can also be defined using only R code (see <a href="#topic+NN_R_components">NN_R_components</a>). More information on expanding the library with new types of NN components (nodes, layers, connections etc) and models, can be found in the package's  vignette as well as the related <a href="https://github.com/VNNikolaidis/nnlib2Rcpp">repository on Github</a>). Please consider submitting any useful components you create, to enrich  future versions of the package.
</p>


<h3>Author(s)</h3>

<p>Vasilis N. Nikolaidis &lt;vnnikolaidis@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BP">BP</a></code>, <code><a href="#topic+LVQs">LVQs</a></code>, <code><a href="#topic+MAM">MAM</a></code>, <a href="#topic+NN_component_names">NN_component_names</a>, <a href="#topic+NN_R_components">NN_R_components</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:

# (1.A) create new 'NN' object:

n &lt;- new("NN")

# (1.B) Add topology components:

# 1. add a layer of 4 generic nodes:
n$add_layer("generic",4)
# 2. add a set for connections that pass data unmodified:
n$add_connection_set("pass-through")
# 3. add another layer of 2 generic nodes:
n$add_layer("generic",2)
# 4. add a set for connections that pass data x weight:
n$add_connection_set("wpass-through")
# 5. add a layer of 1 generic node:
n$add_layer("generic",1)
# Create actual full connections in sets, random initial weights in [0,1]:
n$create_connections_in_sets(0,1)
# Optionaly, show an outline of the topology:
n$outline()

# (1.C) use the network.

# input some data, and create output for it:
n$input_at(1,c(10,20,30,40))
n$recall_all(TRUE)
# the final output:
n$get_output_from(5)

# (1.D) optionally, examine the network:

# the input for set of connections at position 2:
n$get_input_at(2)
# Data is passed unmodified through connections at position 2,
# and (by default) summed together at each node of layer at position 3.
# Final output from layer in position 3:
n$get_output_from(3)
# Data is then passed multiplied by the random weights through
# connections at position 4. The weights of these connections:
n$get_weights_at(4)
# Data is finally summed together at the node of layer at position 5,
# producing the final output, which (again) is:
n$get_output_from(5)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Example 2: A simple MAM NN

# (2.A) Preparation:

# Create data pairs

iris_data    &lt;- as.matrix( scale( iris[1:4] ) )
iris_species &lt;- matrix(data=-1, nrow=nrow(iris_data), ncol=3)
for(r in 1:nrow(iris_data))
 iris_species[r ,as.integer( iris$Species )[r]]=1

# Create the NN and its components:

m &lt;- new( "NN" )
m$add_layer( "generic" , 4 )
m$add_layer( "generic" , 3 )
m$fully_connect_layers_at(1, 2, "MAM", 0, 0)

# (2.B) Use the NN to store iris (data,species) pair:

# encode pairs in NN:

m$encode_datasets_supervised(
	iris_data,1,
	iris_species,3,0,
	1,TRUE)

# (2.C) Recall iris species from NN:

recalled_data &lt;- m$recall_dataset(iris_data,1,3,TRUE)

# (2.D) Convert recalled data to ids and plot results:

recalled_ids &lt;- apply(recalled_data, 1, which.max)
plot(iris_data, pch=recalled_ids)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Example 3: Using add_R_... methods in a NN:

# (3.A) add_R_ignoring, for functions whose result will be ignored by the NN:

a&lt;-new("NN")
a$add_layer("pass-through",4)
a$add_R_ignoring("on recall","print","output of",1)
a$add_connection_set("pass-through")
a$add_R_ignoring("on recall","print","input of",3)
a$add_layer("pass-through",2)
a$add_R_ignoring("on recall","print","output of",5)
a$create_connections_in_sets(0,0)

# below a fwd recall. During it, the NN will print the output
# of layer @1, then print the input of connections @3, and
# finally print the output of layer @5:

a$set_input_at(1,1:4)
a$recall_all(TRUE)

# (3.B) add_R_forwarding is used to read output of component above,
# apply an R function and send result as input to component below.
# (Due to current limitations of various component types, place the
# add_R_forwarding between two layers and connect other components
# two those layers)

a&lt;-new("NN")
a$add_layer("pass-through",4)
a$add_R_forwarding("on recall","sin")
a$add_layer("pass-through",4)

# during a fwd recall, the R component @2 will get the output
# of layer @1, apply an R function (here function sin) and send
# the result as input to layer @3.

a$set_input_at(1,1:4)
a$recall_all(TRUE)
a$get_output_from(3)

# (3.C) add_R_pipelining is similar to add_R_forwarding but allows reading
# the output of component below, and feed result to component above
# (for encode/recalls in backwards direction)

a&lt;-new("NN")
a$add_layer("pass-through",4)
a$add_R_pipelining("on recall","sin",FALSE)
a$add_layer("pass-through",4)

# below is a recall backwards, the R component @2 will get the output
# of layer @3, apply R function and send the its as input to layer @1.

a$set_input_at(3,1:4)
a$recall_all(FALSE)
a$get_output_from(1)

# (3.D) add_R_function allows us to define the destination for the function's
# results. This may include destinations such as PE biases, connection
# weights etc.

a&lt;-new("NN")
a$add_layer("pass-through",4)
a$add_R_function("on recall","sum","output of",1,"to input",3, FALSE)
a$add_layer("pass-through",1)

# below, in a typical forward recall, the R component @2 will get the output
# of layer @1, apply an R function (here function sum) and send it as
# input of layer @3.

a$set_input_at(1,1:4)
a$recall_all(TRUE)
a$get_output_from(3)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Example 4: A more complete example where a NN similar to that of help(LVQs)
# is implemented via 'NN'. It is a (supervised) LVQ. This version
# also allows using multiple output nodes per class.
# Note: while this is similar to LVQs, learning rate is NOT affected by epoch.
# Obviously (as goes for most NN, especially simple ones like this), one could
# easily create the model using just a matrix and some R code processing it;
# more elaborately, it could be implemented via R components (see help(NN_R_components));
# but how could one then be able to use all that fancy NN terminology? :)

# some options:

# define how many output nodes will be implicitly assigned for each class,
# i.e. groups of connections / prototype vectors / codebook vectors per class:

number_of_output_pes_per_class &lt;- 3

# plot results?

plot_result = FALSE

# also use a mechanism to store weights (so we can plot them later)?

record_weights_at_each_iteration &lt;- FALSE

# Next, prepare some data (based on iris).
# LVQ expects data in 0 to 1 range, so scale some numeric data...

DATA &lt;- as.matrix(iris[1:4])
c_min &lt;- apply(DATA, 2, FUN = "min")
c_max &lt;- apply(DATA, 2, FUN = "max")
c_rng &lt;- c_max - c_min
DATA &lt;- sweep(DATA, 2, FUN = "-", c_min)
DATA &lt;- sweep(DATA, 2, FUN = "/", c_rng)

# create a vector of desired class ids:

desired_class_ids &lt;- as.integer(iris$Species)

# defined just to make names more general (independent from iris):

input_length      &lt;- ncol(DATA)
number_of_classes &lt;- length(unique(desired_class_ids))

# Next, setup the LVQ NN.
# output layer may be expanded to accommodate multiple PEs per class:

output_layer_size &lt;-
	number_of_classes * number_of_output_pes_per_class

# next, implement a supervised LVQ using NN module:

LVQ_PUNISH_PE &lt;- 10   # as defined in the C++ LVQ code.
LVQ_DEACTI_PE &lt;- 20   # as defined in the C++ LVQ code.
LVQ_REWARD_PE &lt;- 30   # as defined in the C++ LVQ code.
LVQ_RND_MIN &lt;-    0   # as defined in the C++ LVQ code.
LVQ_RND_MAX &lt;-   +1   # as defined in the C++ LVQ code.

# create a typical LVQ topology for this problem:

n &lt;- new('NN')
n$add_layer('pass-through', input_length)
n$add_connection_set('LVQ', 0)
n$add_layer('LVQ-output', output_layer_size)
n$create_connections_in_sets(LVQ_RND_MIN, LVQ_RND_MAX)

# optional, store current weights (so we can plot them later):

if (record_weights_at_each_iteration)
	cvs &lt;- n$get_weights_at(2)

# an ugly (nested loop) encoding code:

for (epoch in 1:5)
	for (i in 1:nrow(DATA))
	{
		# recall a data vector:

		n$input_at(1, DATA[i, ])
		n$recall_all_fwd()

		# find which output node is best for input vector (has smallest distance)
		current_winner_pe &lt;- which.min(n$get_output_at(3))

		# translate winning node to class id:
		returned_class &lt;-
			ceiling(current_winner_pe / number_of_output_pes_per_class)

		# now check if the correct class was recalled (and reward)
		# or an incorrect (and punish):

		# in LVQ layers, the 'bias' node (PE) register is used to indicate if
		# positive (reward) or negative (punishment) should be applied.

		new_output_flags &lt;- rep(LVQ_DEACTI_PE, output_layer_size)
		new_output_flags[current_winner_pe] &lt;- LVQ_PUNISH_PE
		if (returned_class == desired_class_ids[i])
			new_output_flags[current_winner_pe] &lt;- LVQ_REWARD_PE
		n$set_biases_at(3, new_output_flags)

		# note: for this example (and unlike LVQs) learning rate is constant,
		# NOT dicreasing as epochs increase.

		n$encode_at(2)

		# optional, store current weights (so we can plot them later):

		if (record_weights_at_each_iteration)
			cvs &lt;- rbind(cvs, n$get_weights_at(2))
	}

# done encoding.

# recall all data:

lvq_recalled_winning_nodes &lt;-
	apply(n$recall_dataset(DATA, 1, 3, TRUE), 1, which.min)

# translate winning node to class id:
lvq_recalled_class_ids &lt;-
	ceiling(lvq_recalled_winning_nodes / number_of_output_pes_per_class)

correct &lt;- lvq_recalled_class_ids == desired_class_ids
cat("Correct:", sum(correct), "\n")
cat("Number of produced classes:", length(unique(lvq_recalled_class_ids)), "\n")

# plot results if requested (here only columns 1 and 2 are displayed):

if (plot_result)
{
	plot(data, pch = lvq_recalled_class_ids,
		 main = "LVQ recalled clusters (module)")

	# optional, if weights were stored, plot them later:

	if (record_weights_at_each_iteration)
	{
		for (cv in 0:(output_layer_size - 1))
			lines(cvs[, (cv * input_length + 1):(cv * input_length + 2)],
				  lwd = 2, col = cv + 1)
	}
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
