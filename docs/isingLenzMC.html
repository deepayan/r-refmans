<!DOCTYPE html><html><head><title>Help for package isingLenzMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {isingLenzMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#flipConfig1D'><p>Given Flip a site randomly</p></a></li>
<li><a href='#flipConfig1D_R'><p>Given Flip a site randomly</p></a></li>
<li><a href='#flipConfig1Dmany'><p>Flip a single site randomly many times</p></a></li>
<li><a href='#genConfig1D'><p>Generate one dimensional spin sites randomly</p></a></li>
<li><a href='#genConfig1D_R'><p>Generate one dimensional spin sites randomly</p></a></li>
<li><a href='#genUniform'><p>Get uniformly a spin state</p></a></li>
<li><a href='#isPerform1D'><p>Perform metropolis MC on 1D Ising model</p></a></li>
<li><a href='#isStep1D'><p>Carry one step Metropolis Monte Carlo on 1D ising model</p></a></li>
<li><a href='#lattice1DenergyNN'><p>Nearest-Neighbour energy in periodic boundary conditions in 1D</p></a></li>
<li><a href='#lattice1DenergyNN_R'><p>Nearest-Neighbour energy in periodic boundary conditions in 1D</p></a></li>
<li><a href='#sumVec'><p>Sum given vector</p></a></li>
<li><a href='#sumVec_R'><p>Sum given vector</p></a></li>
<li><a href='#totalEnergy1D'><p>Total energy in periodic boundary conditions in 1D</p></a></li>
<li><a href='#totalEnergy1D_R'><p>Total energy in periodic boundary conditions in 1D</p></a></li>
<li><a href='#transferMatrix'><p>Compute theoretical transfer matrix</p></a></li>
<li><a href='#transitionProbability1D'><p>Compute transition probability using Boltzmann distribution.</p></a></li>
<li><a href='#transitionProbability1D_R'><p>Compute transition probability using Boltzmann distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-04-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Monte Carlo for Classical Ising Model</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Classical Ising Model is a land mark system in statistical physics.The model explains the physics of spin glasses and magnetic materials, and cooperative phenomenon in general, for example phase transitions and neural networks.This package provides utilities to simulate one dimensional Ising Model with Metropolis and Glauber Monte Carlo with single flip dynamics in periodic boundary conditions. Utility functions for exact solutions are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-07-01 14:24:29 UTC; msuzen</td>
</tr>
<tr>
<td>Author:</td>
<td>Mehmet Suzen [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-07-02 03:03:29</td>
</tr>
</table>
<hr>
<h2 id='flipConfig1D'>Given Flip a site randomly</h2><span id='topic+flipConfig1D'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, flip any of the site randomly. The function uses default 
RNG (Marsienne-Twister) unless changed by the user, within R, to generate 
a vector that contains 1s or -1s. This function calls 'flipConfig1D' C function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  flipConfig1D(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipConfig1D_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector that contains 1s or -1s. 
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10 # 10 spin sites
  mySites    &lt;- genConfig1D(n) # Generate sites
  # now flip 
  mySitesNew &lt;- flipConfig1D(mySites)
</code></pre>

<hr>
<h2 id='flipConfig1D_R'>Given Flip a site randomly</h2><span id='topic+flipConfig1D_R'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, flip any of the site randomly. The function uses default 
RNG (Marsienne-Twister) unless changed by the user, within R, to generate 
a vector that contains 1s or -1s. This function is a pure R implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  flipConfig1D_R(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipConfig1D_R_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector that contains 1s or -1s. 
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10 # 10 spin sites
  mySites    &lt;- genConfig1D_R(n) # Generate sites
  # now flip 
  mySitesNew &lt;- flipConfig1D_R(mySites)
</code></pre>

<hr>
<h2 id='flipConfig1Dmany'>Flip a single site randomly many times</h2><span id='topic+flipConfig1Dmany'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, flip any of the site randomly, repeat it many times. 
The function uses default RNG (Marsienne-Twister) unless changed by the user, 
within R, to generate a vector that contains 1s or -1s. This function calls 
'flipConfig1Dmany' C function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  flipConfig1Dmany(x, upperF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipConfig1Dmany_+3A_x">x</code></td>
<td>
<p>1D spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="flipConfig1Dmany_+3A_upperf">upperF</code></td>
<td>
<p>The number of times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector that contains 1s or -1s. 
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10 # 10 spin sites
  mySites    &lt;- genConfig1D(n) # Generate sites
  # now flip 100 times
  mySitesNew &lt;- flipConfig1Dmany(mySites, 100)
</code></pre>

<hr>
<h2 id='genConfig1D'>Generate one dimensional spin sites randomly</h2><span id='topic+genConfig1D'></span>

<h3>Description</h3>

<p>The function uses default RNG (Marsienne-Twister) unless changed by the 
user, within R, to generate a vector that contains 1 or -1. This reflects
spin sites. This function calls 'genConfig1D' C function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  genConfig1D(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genConfig1D_+3A_n">n</code></td>
<td>
<p>The number of spin sites on the lattice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector that contains 1s or -1s. 
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n &lt;- 10 # 10 spin sites
  genConfig1D(n)
</code></pre>

<hr>
<h2 id='genConfig1D_R'>Generate one dimensional spin sites randomly</h2><span id='topic+genConfig1D_R'></span>

<h3>Description</h3>

<p>The function uses default RNG (Marsienne-Twister) unless changed by the 
user, within R, to generate a vector that contains 1 or -1. This reflects
spin sites. This function is pure R implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  genConfig1D_R(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genConfig1D_R_+3A_n">n</code></td>
<td>
<p>The number of spin sites on the lattice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector that contains 1s or -1s. 
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n &lt;- 10 # 10 spin sites
  genConfig1D_R(n)
</code></pre>

<hr>
<h2 id='genUniform'>Get uniformly a spin state</h2><span id='topic+genUniform'></span>

<h3>Description</h3>

<p>Generate a single spin state from uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  genUniform(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genUniform_+3A_n">n</code></td>
<td>
<p>dummy argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns randomly 1 or -1 from uniform distribution.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> genUniform()
</code></pre>

<hr>
<h2 id='isPerform1D'>Perform metropolis MC on 1D Ising model</h2><span id='topic+isPerform1D'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, and an other flip sites, perform Metropolis Monte Carlo
applying periodic boundary conditions, i.e., cyclic. 
This function calls the C function 'isPerform1D'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isPerform1D(ikBT, x, J, H, nstep, ensembleM, probSel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPerform1D_+3A_ikbt">ikBT</code></td>
<td>
<p>1/kB*T (Boltzmann factor)</p>
</td></tr>
<tr><td><code id="isPerform1D_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="isPerform1D_+3A_j">J</code></td>
<td>
<p>Interaction strength</p>
</td></tr>
<tr><td><code id="isPerform1D_+3A_h">H</code></td>
<td>
<p>External field</p>
</td></tr>
<tr><td><code id="isPerform1D_+3A_nstep">nstep</code></td>
<td>
<p>Number of MC steps requested</p>
</td></tr>
<tr><td><code id="isPerform1D_+3A_ensemblem">ensembleM</code></td>
<td>
<p>Value of the theoretical magnetization (could be thermodynamic limit value)</p>
</td></tr>
<tr><td><code id="isPerform1D_+3A_probsel">probSel</code></td>
<td>
<p>Which transition probability to use. 1 for Metropolis 2 for Glauber</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a pair list containing values for omegaM, Fluctuating metric vector for Magnetisation (length of naccept),
naccept, number of MC steps accepted and  nreject, number of MC steps rejected and times as accepted time steps.
Times corresponds to times where flips occur, this is so-called transition times ('metropolis time' or 'single flip time') 
to judge the timings between two accepted steps.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n        &lt;- 10 # 10 spin sites
  mySites  &lt;- genConfig1D(n) # Generate sites
  output   &lt;- isPerform1D(1.0, mySites, 1.0, 0.0, 10, 0.5, 1) # Metropolis
  output   &lt;- isPerform1D(1.0, mySites, 1.0, 0.0, 10, 0.5, 2) # Glauber
</code></pre>

<hr>
<h2 id='isStep1D'>Carry one step Metropolis Monte Carlo on 1D ising model</h2><span id='topic+isStep1D'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively and the usual thermodynamic parameters ikBt, J and H.
Perform 1 step metropolis Monte Carlo, applying periodic boundary conditions, 
i.e., cyclic. This function calls the C function 'isStep1D'. Importance sampling 
is applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isStep1D(ikBT, x, J, H, probSel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isStep1D_+3A_ikbt">ikBT</code></td>
<td>
<p>1/kB*T (Boltzmann factor)</p>
</td></tr>
<tr><td><code id="isStep1D_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="isStep1D_+3A_j">J</code></td>
<td>
<p>Interaction strength</p>
</td></tr>
<tr><td><code id="isStep1D_+3A_h">H</code></td>
<td>
<p>External field</p>
</td></tr>
<tr><td><code id="isStep1D_+3A_probsel">probSel</code></td>
<td>
<p>Which transition probability to use. 1 for Metropolis 2 for Glauber</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pair list, flip states (vec) and if step is accepted (accept).
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n             &lt;- 10 # 10 spin sites
  mySites       &lt;- genConfig1D(n) # Generate sites
  # only short-range part
  isStep1D(1.0, mySites, 1.0, 0.0, 1) # Metropolis
  isStep1D(1.0, mySites, 1.0, 0.0, 2) # Glauber
</code></pre>

<hr>
<h2 id='lattice1DenergyNN'>Nearest-Neighbour energy in periodic boundary conditions in 1D</h2><span id='topic+lattice1DenergyNN'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, return nearest neighbour energy, applying periodic boundary
conditions, i.e., cyclic. This function calls the C function 'lattice1DenergyNN'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lattice1DenergyNN(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lattice1DenergyNN_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the nearest neighbour energy.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10 # 10 spin sites
  mySites    &lt;- genConfig1D(n) # Generate sites
  # now flip 
  mySitesNew &lt;- lattice1DenergyNN(mySites)
</code></pre>

<hr>
<h2 id='lattice1DenergyNN_R'>Nearest-Neighbour energy in periodic boundary conditions in 1D</h2><span id='topic+lattice1DenergyNN_R'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, return nearest neighbour energy, applying periodic boundary
conditions, i.e., cyclic. This function is a pure R implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lattice1DenergyNN_R(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lattice1DenergyNN_R_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the nearest neighbour energy.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10 # 10 spin sites
  mySites    &lt;- genConfig1D_R(n) # Generate sites
  nnEnergy &lt;- lattice1DenergyNN(mySites)
</code></pre>

<hr>
<h2 id='sumVec'>Sum given vector</h2><span id='topic+sumVec'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, return the sum.  This function calls the C function 'sumVec'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sumVec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumVec_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sum, corresponding the long-range part.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10 # 10 spin sites
  mySites    &lt;- genConfig1D(n) # Generate sites
  sumVecs    &lt;- sumVec(mySites)
</code></pre>

<hr>
<h2 id='sumVec_R'>Sum given vector</h2><span id='topic+sumVec_R'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, return the sum.  This function calls the C function 'sumVec'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sumVec_R(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumVec_R_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sum, corresponding the long-range part.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n          &lt;- 10             # 10 spin sites
  mySites    &lt;- genConfig1D_R(n) # Generate sites
  sumVecs    &lt;- sumVec_R(mySites)
</code></pre>

<hr>
<h2 id='totalEnergy1D'>Total energy in periodic boundary conditions in 1D</h2><span id='topic+totalEnergy1D'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, return total energy, applying periodic boundary
conditions, i.e., cyclic. This function calls the C function 'totalEnergy1D'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  totalEnergy1D(x, J, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totalEnergy1D_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="totalEnergy1D_+3A_j">J</code></td>
<td>
<p>The strength of interaction.</p>
</td></tr>
<tr><td><code id="totalEnergy1D_+3A_h">H</code></td>
<td>
<p>The value of the external field.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the total energy.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n             &lt;- 10 # 10 spin sites
  mySites       &lt;- genConfig1D(n) # Generate sites
  # only short-range part
  myTotalEnergy &lt;- totalEnergy1D(mySites, 1.0, 0.0)
</code></pre>

<hr>
<h2 id='totalEnergy1D_R'>Total energy in periodic boundary conditions in 1D</h2><span id='topic+totalEnergy1D_R'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, return total energy, applying periodic boundary
conditions, i.e., cyclic. This function is pure R implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  totalEnergy1D_R(x, J, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totalEnergy1D_R_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="totalEnergy1D_R_+3A_j">J</code></td>
<td>
<p>The strength of interaction.</p>
</td></tr>
<tr><td><code id="totalEnergy1D_R_+3A_h">H</code></td>
<td>
<p>The value of the external field.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the total energy.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n             &lt;- 10 # 10 spin sites
  mySites       &lt;- genConfig1D_R(n) # Generate sites
  # only short-range part
  myTotalEnergy &lt;- totalEnergy1D_R(mySites, 1.0, 0.0)
</code></pre>

<hr>
<h2 id='transferMatrix'>Compute theoretical transfer matrix</h2><span id='topic+transferMatrix'></span>

<h3>Description</h3>

<p>Compute transfer matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  transferMatrix(ikBt, J, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transferMatrix_+3A_ikbt">ikBt</code></td>
<td>
<p>1/kB*T (Boltzmann factor)</p>
</td></tr>
<tr><td><code id="transferMatrix_+3A_j">J</code></td>
<td>
<p>Interaction strength</p>
</td></tr>
<tr><td><code id="transferMatrix_+3A_h">H</code></td>
<td>
<p>External field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns transfer matrix and its eigenvalues in a pair list.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  transferMatrix(1.0, 1.0, 0)
</code></pre>

<hr>
<h2 id='transitionProbability1D'>Compute transition probability using Boltzmann distribution.</h2><span id='topic+transitionProbability1D'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, and an other flip sites, return the transition probability, 
applying periodic boundary conditions, i.e., cyclic. 
This function calls the C function 'transitionProbability1D'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   transitionProbability1D(ikBT, x, xflip, J, H, probSel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionProbability1D_+3A_ikbt">ikBT</code></td>
<td>
<p>1/kB*T (Boltzmann factor)</p>
</td></tr>
<tr><td><code id="transitionProbability1D_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="transitionProbability1D_+3A_xflip">xflip</code></td>
<td>
<p>1D Spin sites on the lattice: after a flip.</p>
</td></tr>
<tr><td><code id="transitionProbability1D_+3A_j">J</code></td>
<td>
<p>Interaction strength</p>
</td></tr>
<tr><td><code id="transitionProbability1D_+3A_h">H</code></td>
<td>
<p>External field</p>
</td></tr>
<tr><td><code id="transitionProbability1D_+3A_probsel">probSel</code></td>
<td>
<p>Which transition probability to use. 1 for Metropolis 2 for Glauber</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns transition probability.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n             &lt;- 10             # 10 spin sites
  mySites       &lt;- genConfig1D(n) # Generate sites
  mySitesNew    &lt;- flipConfig1D(mySites)
  # only short-range part
  transitionProbability1D(1.0, mySites, mySitesNew, 1.0, 0.0, 1) # Metropolis
  transitionProbability1D(1.0, mySites, mySitesNew, 1.0, 0.0, 2) # Glauber
</code></pre>

<hr>
<h2 id='transitionProbability1D_R'>Compute transition probability using Boltzmann distribution.</h2><span id='topic+transitionProbability1D_R'></span>

<h3>Description</h3>

<p>Given a vector of flip sites, 1s or -1s, representing up and down spins 
respectively, and an other flip sites, return the transition probability, 
applying periodic boundary conditions, i.e., cyclic. 
This function is pure R implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  transitionProbability1D_R(ikBT, x, xFlip, J, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionProbability1D_R_+3A_ikbt">ikBT</code></td>
<td>
<p>1/kB*T (Boltzmann factor)</p>
</td></tr>
<tr><td><code id="transitionProbability1D_R_+3A_x">x</code></td>
<td>
<p>1D Spin sites on the lattice.</p>
</td></tr>
<tr><td><code id="transitionProbability1D_R_+3A_xflip">xFlip</code></td>
<td>
<p>1D Spin sites on the lattice: after a flip.</p>
</td></tr>
<tr><td><code id="transitionProbability1D_R_+3A_j">J</code></td>
<td>
<p>Interaction strength</p>
</td></tr>
<tr><td><code id="transitionProbability1D_R_+3A_h">H</code></td>
<td>
<p>External field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns transition probability.
</p>


<h3>Author(s)</h3>

<p>Mehmet Suzen &lt;mehmet.suzen@physics.org&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n             &lt;- 10 # 10 spin sites
  mySites       &lt;- genConfig1D_R(n) # Generate sites
  mySitesNew    &lt;- flipConfig1D_R(mySites)
  # only short-range part
  transitionProbability1D_R(1.0, mySites, mySitesNew, 1.0, 0.0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
