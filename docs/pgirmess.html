<!DOCTYPE html><html><head><title>Help for package pgirmess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pgirmess}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bbox2sf'><p>Convert a bounding box into a sf object.</p></a></li>
<li><a href='#CI'><p>Confidence interval of percentages</p></a></li>
<li><a href='#classnum'><p> Gives an index vector of the class category of each value of a numerical vector</p></a></li>
<li><a href='#cormat'><p> Gives a correlation matrix and the probability of Ho for each correlation</p></a></li>
<li><a href='#correlog'><p> Computes Moran's or Geary's coefficients on distance classes</p></a></li>
<li><a href='#date2winter'><p> Convert a POSIXt date into categories corresponding to a autumn/winter/spring sequence</p></a></li>
<li><a href='#diag2edge'><p> Computes the edge of a square from its diagonal</p></a></li>
<li><a href='#difshannonbio'><p> Empirical confidence interval of the bootstrap of the difference between two Shannon indices</p></a></li>
<li><a href='#dirProj'><p> Computes new coordinates given bearings and distances.</p></a></li>
<li><a href='#dirSeg'><p> Computes segment directions.</p></a></li>
<li><a href='#distNNeigh'><p> Computes distances to the nearest neighbour</p></a></li>
<li><a href='#distNode'><p> Computes the distances between each nodes of a polyline.</p></a></li>
<li><a href='#distSeg'><p> Computes distances between the top coordinates of segments.</p></a></li>
<li><a href='#distTot'><p> Computes the total length of a polyline.</p></a></li>
<li><a href='#expandpoly'><p> Homothetia (size expansion) of a polygon</p></a></li>
<li><a href='#findR'><p> Computes the distance between the centroid and the most distant coordinate of a geographical coordinate set</p></a></li>
<li><a href='#friedmanmc'><p> Multiple comparisons after Friedman test</p></a></li>
<li><a href='#kruskalmc'><p> Multiple comparison test after Kruskal-Wallis</p></a></li>
<li><a href='#ks.gof'><p> Kolmogorof-Smirnov goodness of fit test to normal distribution</p></a></li>
<li><a href='#mergeTrackObs'><p>Count the nearest observations to points corresponding to track intervals</p></a></li>
<li><a href='#pairsrp'><p>Produces a matrix of scatterplot, regression coefficient and p(Ho)</p></a></li>
<li><a href='#pave'><p>Provide square polygons or their node coordinates along a segment</p></a></li>
<li><a href='#permcont'><p> Random permutation of a contingency table n row x 2 columns</p></a></li>
<li><a href='#PermTest'><p> Permutation test for lm, lme and glm (binomial and Poisson) objects</p></a></li>
<li><a href='#piankabio'><p> Computes the Pianka's index of niche overlap</p></a></li>
<li><a href='#piankabioboot'><p> Bootstrap Pianka's index</p></a></li>
<li><a href='#polycirc'><p> Computes the polygon coordinates of a circle</p></a></li>
<li><a href='#polycirc2'><p> Computes the polygon coordinates of a circle sector</p></a></li>
<li><a href='#preybiom'><p>  Jackal and Genet diet in Algeria</p></a></li>
<li><a href='#print.mc'><p> print method for objects of class 'mc'</p></a></li>
<li><a href='#Segments'><p> Draw line segments between pairs of points.</p></a></li>
<li><a href='#selMod'><p> Model selection according to information theoretic methods</p></a></li>
<li><a href='#shannon'><p> Computes Shannon's and equitability indices</p></a></li>
<li><a href='#shannonbio'><p> Computes Shannon's and equitability indices from a data frame of dietary analysis (n, biomass,...)</p></a></li>
<li><a href='#shannonbioboot'><p> Boostrap Shannon's and equitability indices</p></a></li>
<li><a href='#siegelp179'><p> Data on rats training</p></a></li>
<li><a href='#st_thintrack'><p> Thin a track just keeping the points separated by a user defined minimal distance</p></a></li>
<li><a href='#tabcont2categ'><p> Convert a contingency table (data.frame) into a presence/absence table of categories</p></a></li>
<li><a href='#trans2pix'><p> Convert a transect coordinate file with some waypoints separated by NA into a matrix with intermediate coordinates replacing NA.</p></a></li>
<li><a href='#trans2seg'><p> Convert a transect coordinate file into a matrix with segment coordinates.</p></a></li>
<li><a href='#transLines2pix'><p>Convert MULTILINESTRING and/or LINESTRING into POINT geometry with points at regular distance between nodes</p></a></li>
<li><a href='#TukeyHSDs'><p> Simplify the list of a TukeyHSD object keeping the significant differences only.</p></a></li>
<li><a href='#val4symb'><p> Center a numerical vector on a parameter position and provides absolute values and colors according to negative and positive values</p></a></li>
<li><a href='#write.delim'><p> Write a data.frame</p></a></li>
<li><a href='#writecn.delim'><p> Write a data.frame that has Chinese characters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Analysis and Data Mining for Field Ecologists</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-24</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot (&ge; 1.3-4), sf (&ge; 1.0-4), sp (&ge; 0.9-97), spdep (&ge;
1.1-7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS (&ge; 7.3-1), nlme (&ge; 3.1-120)</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools for reading, writing and transforming spatial and seasonal data, model selection and specific statistical tests for ecologists. It includes functions to interpolate regular positions of points between landmarks, to discretize polylines into regular point positions, link distant observations to points and convert a bounding box in a spatial object. It also provides miscellaneous functions for field ecologists such as spatial statistics and inference on diversity indexes, writing data.frame with Chinese characters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pgiraudoux/pgirmess">https://github.com/pgiraudoux/pgirmess</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Giraudoux <a href="https://orcid.org/0000-0003-2376-0136"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jean-Philippe Antonietti [ctb],
  Colin Beale [ctb],
  Ulrike Groemping [ctb],
  Renaud Lancelot [ctb],
  David Pleydell [ctb],
  Mike Treglia [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Giraudoux &lt;patrick.giraudoux@univ-fcomte.fr&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 06:31:41 UTC; pgiraudo2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 07:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='bbox2sf'>Convert a bounding box into a sf object.</h2><span id='topic+bbox2sf'></span>

<h3>Description</h3>

<p>Convert a bounding box into a sf object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox2sf(n,s,w,e,bbox=NA,crs=4326)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox2sf_+3A_n">n</code></td>
<td>
<p>the top north latitude</p>
</td></tr>
<tr><td><code id="bbox2sf_+3A_s">s</code></td>
<td>
<p>the bottom south latitude</p>
</td></tr>
<tr><td><code id="bbox2sf_+3A_w">w</code></td>
<td>
<p>the most western longitude</p>
</td></tr>
<tr><td><code id="bbox2sf_+3A_e">e</code></td>
<td>
<p>the most eastern longitude</p>
</td></tr>
<tr><td><code id="bbox2sf_+3A_bbox">bbox</code></td>
<td>
<p>a bounding box 2 x 2 matrix as produced e.g. by  <code><a href="sp.html#topic+bbox">bbox</a></code>, with first row = w, e and second row = s, n, or a numeric vector with xmin, ymin, xmax, ymax in this order as produced by <code><a href="sf.html#topic+st_bbox">st_bbox</a></code></p>
</td></tr>
<tr><td><code id="bbox2sf_+3A_crs">crs</code></td>
<td>
<p>the ID number of a coordinate reference system as defined in the EPSG system <a href="https://epsg.io/">https://epsg.io/</a> (default 4326, WGS84)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a set of coordinates limiting a bounding box into a an object of class &quot;sfc_POLYGON&quot;  (see <code><a href="sf.html#topic+st_sfc">st_sfc</a></code>). It can be used for instance to clip a subset of a larger spatial object (e.g. using <code><a href="sf.html#topic+st_intersection">st_intersection</a></code>)
</p>


<h3>Value</h3>

 
<p>A simple feature geometry of class &quot;sfc_POLYGON&quot; with a coordinate reference system, see <code><a href="sf.html#topic+st_sfc">st_sfc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-79
s&lt;--54
w&lt;--166
e&lt;-178


myPoly1&lt;-bbox2sf(n,s,e,w)
plot(myPoly1)

# bbox as a 2 x 2 matrix as produced by sp:bbox
mybbox&lt;-matrix(c(w,e,s,n),nrow=2,byrow=TRUE)
myPoly2&lt;-bbox2sf(bbox=mybbox)
plot(myPoly2,border="red")

# bbox as produced by sf:st_bbox
if (require(sf)) {
myPoly3&lt;-bbox2sf(bbox=st_bbox(myPoly2))
plot(myPoly3,border="blue")
}

</code></pre>

<hr>
<h2 id='CI'>Confidence interval of percentages</h2><span id='topic+CI'></span>

<h3>Description</h3>

<p>Computes the lower limit and upper limit of the 95 percent confidence interval of percentage estimates 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CI_+3A_x">x</code></td>
<td>
<p> a two-dimensional table, matrix or data.frame with 2 columns, giving the counts of successes and failures, respectively </p>
</td></tr>
<tr><td><code id="CI_+3A_...">...</code></td>
<td>
<p> other arguments to pass to <code><a href="stats.html#topic+prop.test">prop.test</a></code>, eg <code>conf.level</code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple wrapper of <code><a href="stats.html#topic+prop.test">prop.test</a></code>. The default confidence interval is 95 percent, but can be modified passing values to <code><a href="stats.html#topic+prop.test">prop.test</a></code> by the <code>conf.level</code> argument.
</p>


<h3>Value</h3>

<p>A 3 column matrix. 
</p>

<ul>
<li><p> Column 1: percentage estimate
</p>
</li>
<li><p> Column 2: lower limit of the confidence interval
</p>
</li>
<li><p> column 3: upper limit of the confidence interval
</p>
</li></ul>



<h3>See Also</h3>

 <p><code><a href="stats.html#topic+prop.test">prop.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(2,10,7,8,7) # eg: number of positive cases
y&lt;-c(56,22,7,20,5)# eg: number of negative cases
CI(cbind(x,y))
CI(cbind(x,y), conf.level=0.99)

</code></pre>

<hr>
<h2 id='classnum'> Gives an index vector of the class category of each value of a numerical vector </h2><span id='topic+classnum'></span><span id='topic+print.clnum'></span>

<h3>Description</h3>

<p>Gives an index vector of the class category of each value of a numerical vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classnum(x, breaks = "Sturges")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classnum_+3A_x">x</code></td>
<td>
<p> a vector of values for which the indices are desired </p>
</td></tr>
<tr><td><code id="classnum_+3A_breaks">breaks</code></td>
<td>
<p> one of: 
</p>

<ul>
<li><p> a vector giving the breakpoints between bins,
</p>
</li>
<li><p> a single number giving the number of bins,
</p>
</li>
<li><p> a character string naming an algorithm to compute the number of cells (see Details).
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>The default for 'breaks' is '&quot;Sturges&quot;': see 'nclass.Sturges'. Other names for which algorithms are supplied are '&quot;Scott&quot;' and
'&quot;FD&quot;' for '&quot;Friedman-Diaconis&quot;' (with corresponding functions 'nclass.scott' and 'nclass.FD'). Case is ignored and partial matching is used.
Breaks and labels are stored as attributes. </p>


<h3>Value</h3>

<p>A vector of the same length as x, with the index of the class which each value of x belongs to
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="classInt.html#topic+classIntervals">classIntervals</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rnorm(30)
classnum(x)
classnum(x,breaks="fd")
classnum(x, breaks=c(-1,0,1))
classnum(x,breaks=5)
</code></pre>

<hr>
<h2 id='cormat'> Gives a correlation matrix and the probability of Ho for each correlation </h2><span id='topic+cormat'></span>

<h3>Description</h3>

<p>Gives a correlation matrix and the probability of Ho for each correlation estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cormat(donnees, method = "spearman", sep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cormat_+3A_donnees">donnees</code></td>
<td>
<p> a data frame of numerics </p>
</td></tr>
<tr><td><code id="cormat_+3A_method">method</code></td>
<td>
<p> a string of characters among 'pearson', 'spearman' (default), 'kendall' </p>
</td></tr>
<tr><td><code id="cormat_+3A_sep">sep</code></td>
<td>
<p> If true, gives the results in two matrices (default = F)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for 'cor' and 'cor.test'. The results can be given in one or two matrices.
</p>


<h3>Value</h3>

<p>If sep = F (default) a list including:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>The method used</p>
</td></tr>
<tr><td><code>prob.cor</code></td>
<td>
<p>Upper triangle, the correlations; lower triangle, the probability of Ho</p>
</td></tr>
</table>
<p>If sep = T  a list including:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>The method used</p>
</td></tr>
<tr><td><code>coef.estimates</code></td>
<td>
<p>The correlation matrix</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The Ho probability matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cor">cor</a></code>, <code><a href="stats.html#topic+cor.test">cor.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>cormat(longley)
cormat(longley,sep=TRUE)
</code></pre>

<hr>
<h2 id='correlog'> Computes Moran's or Geary's coefficients on distance classes </h2><span id='topic+correlog'></span><span id='topic+plot.correlog'></span><span id='topic+print.correlog'></span>

<h3>Description</h3>

<p>Computes Moran's or Geary's coefficients on distance classes from a set of spatial coordinates and corresponding z values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlog(coords, z, method="Moran", nbclass = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlog_+3A_coords">coords</code></td>
<td>
<p>a two columns array, data.frame or matrix of spatial coordinates. Column 1 = X, Column 2 = Y. </p>
</td></tr>
<tr><td><code id="correlog_+3A_z">z</code></td>
<td>
<p> a vector for the values at each location. Must have the same length as the row number of coords </p>
</td></tr>
<tr><td><code id="correlog_+3A_method">method</code></td>
<td>
<p> the method used. Must be &quot;Moran&quot; (default) or &quot;Geary&quot; </p>
</td></tr>
<tr><td><code id="correlog_+3A_nbclass">nbclass</code></td>
<td>
<p>number of bins. If NULL Sturges method is used to compute an optimal number</p>
</td></tr>
<tr><td><code id="correlog_+3A_...">...</code></td>
<td>
<p>further arguments to pass to e.g. <code><a href="spdep.html#topic+moran.test">moran.test</a></code> or <code><a href="spdep.html#topic+geary.test">geary.test</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the library spdep including <code><a href="spdep.html#topic+moran.test">moran.test</a></code> or <code><a href="spdep.html#topic+geary.test">geary.test</a></code>. Distances are euclidian and in the same unit as the spatial coordinates.  Moran's Ho: I values larger than 0 due to chance; Geary's Ho: C values lesser than 1 due to chance. Correlog has print and plot methods; statistically significant values (p&lt;0.05) are plotted in red.
</p>


<h3>Value</h3>

<p>An object of class &quot;correlog&quot;, a matrix including:
</p>
<table>
<tr><td><code>class</code></td>
<td>
<p>bin centers</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>the coefficient values</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>probability of Ho </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of pairs</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Computing can take a long time for large data sets</p>


<h3>Author(s)</h3>

<p>Patrick Giraudoux pgiraudo@univ-fcomte.fr, Colin Beale c.beale@macaulay.ac.uk and Mike Treglia mike-treglia@utulsa.edu </p>


<h3>References</h3>

<p> see library spdep </p>


<h3>See Also</h3>

 <p><code><a href="spdep.html#topic+geary.test">geary.test</a></code>, <code><a href="spdep.html#topic+moran.test">moran.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spdep)
data(oldcol)
attach(COL.OLD)
coords&lt;-cbind(X,Y)
res&lt;-correlog(coords,CRIME)
plot(res)

res&lt;-correlog(coords,CRIME,method="Geary")
plot(res)

</code></pre>

<hr>
<h2 id='date2winter'> Convert a POSIXt date into categories corresponding to a autumn/winter/spring sequence  </h2><span id='topic+date2winter'></span>

<h3>Description</h3>

<p>Convert a POSIXt date into categories corresponding to the time spanning from the late months of a year to the early months of the following year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date2winter(x, first = 10, last=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date2winter_+3A_x">x</code></td>
<td>
<p> a vector of POSIXt dates </p>
</td></tr>
<tr><td><code id="date2winter_+3A_first">first</code></td>
<td>
<p>number of the first month to include (default 10, October)</p>
</td></tr>
<tr><td><code id="date2winter_+3A_last">last</code></td>
<td>
<p>number of the last month to include (default 4, April)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In ecology, time data must often be analysed on a time span category covering two successive years (e.g. the winter period). This function convert POSIXt dates into categories corresponding to the time span stretching from a user defined month of a given year (by default October) to a user-defined month of the following year (by default April). If date month is out of the user defined time span the value 'Excluded' is returned.
</p>


<h3>Value</h3>

<p>A vector of the same length as x, with the time span category each value belongs to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dates &lt;- strptime(c("02/12/2002", "15/01/2003","15/10/2003","15/6/2003",NA),"%d/%m/%Y")
 date2winter(dates)
</code></pre>

<hr>
<h2 id='diag2edge'> Computes the edge of a square from its diagonal</h2><span id='topic+diag2edge'></span>

<h3>Description</h3>

<p>Computes the edge of a square from its diagonal. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag2edge(cordseg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag2edge_+3A_cordseg">cordseg</code></td>
<td>
<p> The diagonal coordinates. This can be a vector c(x1,y1,x2,y2), a 2 x 2 matrix or a data.frame (each line a coordinate) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first point coordinates are the left top of the diagonal. The other coordinates computed are the  other
top of the square edge. Can be used e.g. to pass a square edge to <code><a href="#topic+pave">pave</a></code> in order
to compute a sampling grid.
</p>


<h3>Value</h3>

<p>A 2x2 matrix of points coordinates
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pave">pave</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# diagonal sloping up
coord&lt;-matrix(c(20,20,90,90),nr=2,byrow=TRUE)
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord,lty=2)
# square edge
lines(diag2edge(coord),col="red")

# diagonal sloping down
coord&lt;-matrix(c(20,90,90,20),nr=2,byrow=TRUE)
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord,lty=2)
# square edge
lines(diag2edge(coord),col="red")

# diagonal vertical
coord&lt;-matrix(c(20,90,20,20),nr=2,byrow=TRUE)
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord,lty=2)
# square edge
lines(diag2edge(coord),col="red")

</code></pre>

<hr>
<h2 id='difshannonbio'> Empirical confidence interval of the bootstrap of the difference between two Shannon indices </h2><span id='topic+difshannonbio'></span>

<h3>Description</h3>

<p>Computes the empirical confidence interval of the bootstrap of the difference between two Shannon indices 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difshannonbio(dat1, dat2, R = 1000, probs = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difshannonbio_+3A_dat1">dat1</code></td>
<td>
<p> a data.frame of two columns; column = category, column 2 = biomass </p>
</td></tr>
<tr><td><code id="difshannonbio_+3A_dat2">dat2</code></td>
<td>
<p> a data.frame of two columns; column = category, column 2 = biomass </p>
</td></tr>
<tr><td><code id="difshannonbio_+3A_r">R</code></td>
<td>
<p> number of permutations </p>
</td></tr>
<tr><td><code id="difshannonbio_+3A_probs">probs</code></td>
<td>
<p> the limits of the confidence interval </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designated to compare the difference between two Shannon's indices computed from two data frames. In each data frame, the first column is the category of prey item, and the second column the estimated biomass.
</p>


<h3>Value</h3>

<p>A list with the confidence interval of H' and J'
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+shannonbio">shannonbio</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preybiom)
attach(preybiom)
jackal&lt;-preybiom[site=="Y" &amp; sp=="C",5:6]
genet&lt;-preybiom[site=="Y" &amp; sp=="G",5:6]

difshannonbio(jackal,genet,R=150)
  </code></pre>

<hr>
<h2 id='dirProj'> Computes new coordinates given bearings and distances. </h2><span id='topic+dirProj'></span>

<h3>Description</h3>

<p>Computes new coordinates from bearings (North = 0) and distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirProj(df,deg=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirProj_+3A_df">df</code></td>
<td>
<p> a matrix or data frame of 4 columns giving x, y coordinates, bearings and distances </p>
</td></tr>
<tr><td><code id="dirProj_+3A_deg">deg</code></td>
<td>
<p> if TRUE (default) bearings are in degree, otherwise in radian </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computings are based on euclidian distance. Therefore, the coordinates should be given in a projected (plan) system (e.g. UTM, Lambert, etc.) and the distance in the same units as the projection system (e.g. meters).
</p>


<h3>Value</h3>

<p>a matrix of two columns with the projected coordinates
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+distSeg">distSeg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
df&lt;-data.frame(x1=0,y1=0,alpha=runif(3,0,360),d=runif(3,0,1))
df
plot(-1:1,-1:1,type="n")
points(0,0,pch=19)
points(dirProj(df))
text(dirProj(df)[,1],dirProj(df)[,2],1:3,pos=4)
</code></pre>

<hr>
<h2 id='dirSeg'> Computes segment directions. </h2><span id='topic+dirSeg'></span>

<h3>Description</h3>

<p>Computes the direction of segments from the first top clockwise (North = 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirSeg(x,deg=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirSeg_+3A_x">x</code></td>
<td>
<p> a matrix or data frame of 4 columns giving the coordinates of each segment tops x1, y1, x2, y2 </p>
</td></tr>
<tr><td><code id="dirSeg_+3A_deg">deg</code></td>
<td>
<p> if TRUE (default) the output is in degrees, otherwise in radians </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two colomns give the first top coordinates, x then y, and the next two the second top coordinates.
</p>


<h3>Value</h3>

<p>A vector of directions
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dirProj">dirProj</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x2&lt;-rnorm(10)
y2&lt;-rnorm(10)
mydata&lt;-cbind(0,0,x2,y2)
dirs&lt;-dirSeg(mydata)
dirs

plot(range(mydata[,c(1,3)]),range(mydata[,c(2,4)]),type="n")
Segments(mydata)
text(mydata[,3],mydata[,4],paste(round(dirs,0),"\u00b0"),cex=0.7)
  </code></pre>

<hr>
<h2 id='distNNeigh'> Computes distances to the nearest neighbour </h2><span id='topic+distNNeigh'></span>

<h3>Description</h3>

<p>Computes distances to the nearest neighbour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distNNeigh(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distNNeigh_+3A_db">db</code></td>
<td>
<p> A matrix or data.frame of points coordinates column 1 = x,column 2 = y. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes distances to the nearest neighbour for each line of a matrix of points coordinates
</p>


<h3>Value</h3>

<p>A vector of distances
</p>


<h3>See Also</h3>

 <p><code><a href="spdep.html#topic+knearneigh">knearneigh</a></code>, <code><a href="spdep.html#topic+knn2nb">knn2nb</a></code>, <code><a href="spdep.html#topic+nbdists">nbdists</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>distNNeigh(cbind(rnorm(30),rnorm(30)))
</code></pre>

<hr>
<h2 id='distNode'> Computes the distances between each nodes of a polyline. </h2><span id='topic+distNode'></span>

<h3>Description</h3>

<p>Computes the distances between each nodes of a polyline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distNode(pts,decdeg=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distNode_+3A_pts">pts</code></td>
<td>
<p> A matrix or data.frame of the node coordinates column 1 = x,column 2 = y. </p>
</td></tr>
<tr><td><code id="distNode_+3A_decdeg">decdeg</code></td>
<td>
<p> TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in meters  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If degdec is FALSE (default), distance computed is Euclidian. Units depends on the coordinate systems.
If decdeg = TRUE, D = 1852 * 60 * (180/pi) * acos ( sin(la1) * sin(la2) + cos(la1) * cos(la2) * cos(abs(lg1 - lg2)).
This method calculates the great circle distance, is based on spherical trigonometry, and assumes that:
</p>

<ul>
<li><p> 1 minute of arc is 1 nautical mile 
</p>
</li>
<li><p> 1 nautical mile is 1.852 km
</p>
</li></ul>



<h3>Value</h3>

<p>A vector of distances
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+distTot">distTot</a></code>, <code><a href="#topic+distSeg">distSeg</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c(10,56,100)
y&lt;-c(23,32,150)
distNode(cbind(x,y))
</code></pre>

<hr>
<h2 id='distSeg'> Computes distances between the top coordinates of segments. </h2><span id='topic+distSeg'></span>

<h3>Description</h3>

<p>Computes the distances between the top coordinates of segments.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distSeg(mydata,decdeg=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distSeg_+3A_mydata">mydata</code></td>
<td>
<p> A matrix or data frame of 4 columns giving the coordinates of each segment tops x1, y1, x2, y2 </p>
</td></tr>
<tr><td><code id="distSeg_+3A_decdeg">decdeg</code></td>
<td>
<p> TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in meters  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If degdec is FALSE (default), distance computed is Euclidian. Units depends on the coordinate systems.
If decdeg = TRUE, D = 1852 * 60 * (180/pi) * acos ( sin(la1) * sin(la2) + cos(la1) * cos(la2) * cos(abs(lg1 - lg2)).
This method calculates the great circle distance, is based on spherical trigonometry, and assumes that:
</p>

<ul>
<li><p> 1 minute of arc is 1 nautical mile 
</p>
</li>
<li><p> 1 nautical mile is 1.852 km
</p>
</li></ul>

<p>When computing with decdeg=TRUE duplicated coordinates strictly identical can lead to produce NaN. The corresponding distance is coerced to zero with warnings and if so, an attribute 'NaNcoerced2zero' with the row numbers of the distances that have been coerced to zero is created
</p>


<h3>Value</h3>

<p>A vector of distances, possibly with the attribute 'NaNcoerced2zero' with the row numbers of the distances that have been coerced to zero if any.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distNode">distNode</a></code>, <code><a href="#topic+distTot">distTot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x1&lt;-rnorm(20)
y1&lt;-rnorm(20)
x2&lt;-rnorm(20)
y2&lt;-rnorm(20)
mydata&lt;-cbind(x1,y1,x2,y2)
distSeg(mydata)
</code></pre>

<hr>
<h2 id='distTot'> Computes the total length of a polyline.  </h2><span id='topic+distTot'></span>

<h3>Description</h3>

<p>Computes the total length of a polyline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distTot(pts,decdeg=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distTot_+3A_pts">pts</code></td>
<td>
<p> A matrix or data.frame of the node coordinates column 1 = x,column 2 = y. </p>
</td></tr>
<tr><td><code id="distTot_+3A_decdeg">decdeg</code></td>
<td>
<p> TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in meters  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If degdec is FALSE (default), distance computed is Euclidian. Units depends on the coordinate systems.
If decdeg = TRUE, D = 1852 * 60 * (180/pi) * acos ( sin(la1) * sin(la2) + cos(la1) * cos(la2) * cos(abs(lg1 - lg2)).
This method calculates the great circle distance, is based on spherical trigonometry, and assumes that:
</p>

<ul>
<li><p> 1 minute of arc is 1 nautical mile 
</p>
</li>
<li><p> 1 nautical mile is 1.852 km
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric distance.
</p>


<h3>See Also</h3>

<p> , <code><a href="#topic+distNode">distNode</a></code>, <code><a href="#topic+distSeg">distSeg</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-c(10,56,100)
y&lt;-c(23,32,150)
distTot(cbind(x,y))
  </code></pre>

<hr>
<h2 id='expandpoly'> Homothetia (size expansion) of a polygon</h2><span id='topic+expandpoly'></span>

<h3>Description</h3>

<p>Compute the new coordinates of polygon expanded by a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandpoly(mypol, fact)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandpoly_+3A_mypol">mypol</code></td>
<td>
<p>matrix or data.frame of polygon coordinates </p>
</td></tr>
<tr><td><code id="expandpoly_+3A_fact">fact</code></td>
<td>
<p>expansion factor </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The polygon area obtained after expansion is equal to <code class="reqn">fact^2</code> times the original polygon area 
</p>


<h3>Value</h3>

<p>A matrix of polygon coordinates
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+polygon">polygon</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(-5,-4.5,0,10,5)
y&lt;-c(-10,0,5,5,-8)
poly&lt;-cbind(x,y)
plot(-10:20,-20:10,type="n")
polygon(poly)
polygon(expandpoly(poly,1.5),border="red")
polygon(expandpoly(poly,0.5),border="blue")

</code></pre>

<hr>
<h2 id='findR'> Computes the distance between the centroid and the most distant coordinate of a geographical coordinate set</h2><span id='topic+findR'></span>

<h3>Description</h3>

<p>Computes the distance between the centroid and the most distant coordinate of a geographical coordinate set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findR(coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findR_+3A_coords">coords</code></td>
<td>
<p> A matrix or data frame of 2 columns of geographical coordinates </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polycirc">polycirc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydata&lt;-cbind(x=rnorm(20),y=rnorm(20))
radius&lt;-findR(mydata)
centroid&lt;-matrix(colMeans(mydata),ncol=2)
plot(mydata,asp=1)
points(centroid,pch=19,col="red",cex=2)
polygon(polycirc(radius,centroid),border="red")
</code></pre>

<hr>
<h2 id='friedmanmc'> Multiple comparisons after Friedman test </h2><span id='topic+friedmanmc'></span>

<h3>Description</h3>

<p>Test of multiple comparison after Friedman test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>friedmanmc(y, groups, blocks,alpha=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="friedmanmc_+3A_y">y</code></td>
<td>
<p> a numeric vector of data values, or a data matrix </p>
</td></tr>
<tr><td><code id="friedmanmc_+3A_groups">groups</code></td>
<td>
<p> a vector giving the group for the corresponding elements of 'y' if this is a vector;  ignored if 'y' is a matrix.  If not a factor object, it is coerced to one. </p>
</td></tr>
<tr><td><code id="friedmanmc_+3A_blocks">blocks</code></td>
<td>
<p> a vector giving the block for the corresponding elements of 'y' if this is a vector;  ignored if 'y' is a matrix.  If not a factor object, it is coerced to one. </p>
</td></tr>
<tr><td><code id="friedmanmc_+3A_alpha">alpha</code></td>
<td>
<p> the significiance level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method for formula still not implemented. Formula 7.5a (Siegel &amp; Castellan, 1988 p 180-181) can lead to p-values larger than 1 when differences between groups are small. Eventually, they are set to NA and a warning is generated. 
</p>


<h3>Value</h3>

<p>A list of class 'mc' with the following items:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>statistics used</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the significance level</p>
</td></tr>
<tr><td><code>dif.com</code></td>
<td>
<p>a data.frame with observed and critical differences, statistical significance at the alpha risk (true/false) and p-value</p>
</td></tr>
</table>


<h3>References</h3>

<p> Siegel &amp; Castellan (1988) Non parametric statistics for the behavioural sciences. Mc Graw Hill Int. Edt.  </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+friedman.test">friedman.test</a></code>; for other functions about median multiple comparison see package 'PMCMRplus'</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(siegelp179)
  attach(siegelp179)
  
  friedman.test(score,treatment,block)
  friedmanmc(score,treatment,block)
  friedmanmc(score,treatment,block,alpha=0.01)
  
  mymatrix&lt;-matrix(score,nc=3)
  friedman.test(mymatrix)
  friedmanmc(mymatrix)
  detach(siegelp179)
  
</code></pre>

<hr>
<h2 id='kruskalmc'> Multiple comparison test after Kruskal-Wallis </h2><span id='topic+kruskalmc'></span><span id='topic+kruskalmc.default'></span><span id='topic+kruskalmc.formula'></span>

<h3>Description</h3>

<p>Multiple comparison test between treatments or treatments versus control after Kruskal-Wallis test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kruskalmc(resp,...)
## Default S3 method:
kruskalmc(resp, categ, alpha = 0.05, cont=NULL,...)
## S3 method for class 'formula'
kruskalmc(resp,data=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kruskalmc_+3A_resp">resp</code></td>
<td>
<p> a numeric vector of data values or a formula of the type 'response~category'. </p>
</td></tr>
<tr><td><code id="kruskalmc_+3A_categ">categ</code></td>
<td>
<p> a factor object giving the group for the corresponding elements of 'x' </p>
</td></tr>
<tr><td><code id="kruskalmc_+3A_alpha">alpha</code></td>
<td>
<p> the significance level</p>
</td></tr>
<tr><td><code id="kruskalmc_+3A_cont">cont</code></td>
<td>
<p> NULL (default) for multiple comparison between treatments; 'one-tailed' or 'two-tailed'  for corresponding multiple comparisons treatments versus control; partial matching allowed</p>
</td></tr>
<tr><td><code id="kruskalmc_+3A_data">data</code></td>
<td>
<p> a data.frame including the variables used in the formula </p>
</td></tr>  
<tr><td><code id="kruskalmc_+3A_...">...</code></td>
<td>
<p> other parameters to be passed as arguments (not used here) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the value of a Kruskal-Wallis test is significant, it indicates that at least one of the groups is different from at least one of the others. This test helps determining which groups are different with pairwise comparisons adjusted appropriately for multiple comparisons. Those pairs of groups which have observed differences larger than a critical value are considered statistically different at a given significance level. Three types of multiple comparisons are implemented: comparisons between treatments, 'one-tailed' and 'two-tailed' comparison treatments versus control.  The first factor level is considered the control. NAs are omitted from data before processing.
</p>
<p>For further details please consider the refence below where the method is fully described, or visit <a href="https://giraudoux.pagesperso-orange.fr/#pgirmess">https://giraudoux.pagesperso-orange.fr/#pgirmess</a> where a copy of the corresponding book section can be downloaded.
</p>


<h3>Value</h3>

<p>A list of class 'mc' with the following items:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>statistics used</p>
</td></tr>
<tr><td><code>signif.level</code></td>
<td>
<p>the significance level</p>
</td></tr>
<tr><td><code>dif.com</code></td>
<td>
<p>a data.frame with observed and critical differences</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Alternative methods are proposed in the section 'see also', on FranÃ§ois Gillet's suggestion. The three methods do not give necessarily the same results, and the why is still to investigate</p>


<h3>References</h3>

<p> Siegel and Castellan (1988) Non parametric statistics for the behavioural sciences. MacGraw Hill Int., New York. pp 213-214  </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code>; to reorder factor levels see <code><a href="stats.html#topic+relevel">relevel</a></code>; for other functions about median multiple comparison see package 'PMCMRplus'; <code><a href="agricolae.html#topic+kruskal">kruskal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>resp&lt;-c(0.44,0.44,0.54,0.32,0.21,0.28,0.7,0.77,0.48,0.64,0.71,0.75,0.8,0.76,0.34,0.80,0.73,0.8)
categ&lt;-as.factor(rep(c("A","B","C"),times=1,each=6))
kruskalmc(resp, categ)
kruskalmc(resp, categ, alpha=0.01)
kruskalmc(resp, categ, cont="one-tailed")
kruskalmc(resp, categ, cont="two-tailed")

kruskalmc(resp~categ)
kruskalmc(resp~categ, alpha=0.01)
kruskalmc(resp~categ, cont="one-tailed")
kruskalmc(resp~categ, cont="two-tailed")
</code></pre>

<hr>
<h2 id='ks.gof'> Kolmogorof-Smirnov goodness of fit test to normal distribution</h2><span id='topic+ks.gof'></span>

<h3>Description</h3>

<p>Kolmogorof-Smirnov goodness of fit test to normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks.gof(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks.gof_+3A_var">var</code></td>
<td>
<p> a numeric vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper of ks.test()
</p>


<h3>Value</h3>

<p>A list with class '&quot;htest&quot;' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p> a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p> see ks.test </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+ks.test">ks.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rnorm(50)
ks.gof(x)
 </code></pre>

<hr>
<h2 id='mergeTrackObs'>Count the nearest observations to points corresponding to track intervals </h2><span id='topic+mergeTrackObs'></span>

<h3>Description</h3>

<p>Count the nearest observations to points corresponding to track intervals (e.g. observation counts along a road discretized into points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeTrackObs(sppdfInt,sppdfObs,obscol=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTrackObs_+3A_sppdfint">sppdfInt</code></td>
<td>
 <p><code><a href="sf.html#topic+sfc">sfc</a></code> object containing points (POINT) (the track)</p>
</td></tr>
<tr><td><code id="mergeTrackObs_+3A_sppdfobs">sppdfObs</code></td>
<td>
<p><code><a href="sf.html#topic+sfc">sfc</a></code> object containing points (POINT) (the observations) </p>
</td></tr>
<tr><td><code id="mergeTrackObs_+3A_obscol">obscol</code></td>
<td>
<p>The column number in which the number of observations at this point can be found in sppdfObs, if any (default=NULL, no such data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Road side counts and faeces collections are often carried out along tracks (paths, roads, transects, trails, etc.). Tracks can be discretized in regular intervals e.g. with <code><a href="#topic+transLines2pix">transLines2pix</a></code> or <code><a href="#topic+st_thintrack">st_thintrack</a></code>, each point being the center of a track interval. mergeTrackobs computes the number of observations that are the closest to each interval (compare to the other intervals) and give it in the column 'nObs'. if the argument 'obscol' is NULL, observations are considered presence/absence. If the number of observations is a true count (0 or any positive number) the argument 'obscol' can be used to identify the column of 'sppdfObs' where those counts must be found. Coordinate reference systems must be the identical.
</p>


<h3>Value</h3>

<p>A <code><a href="sf.html#topic+sfc">sfc</a></code> object, of POINT geometry, with the following columns:
</p>
 
<ul>
<li><p> ID, ID number
</p>
</li>
<li><p> nObs, The number of observations in the interval
</p>
</li>
<li><p> geometry, POINT geometry
</p>
</li></ul>



<h3>See Also</h3>

 <p><code><a href="#topic+transLines2pix">transLines2pix</a></code>, <code><a href="#topic+st_thintrack">st_thintrack</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(require(sf)){
# track

sl&lt;-st_sfc(st_linestring(cbind(c(1,2,3),c(1,1.5,1))))
plot(sl, col = "blue")

    #observations
     obs &lt;- structure(list(ID = 1:15, long = c(1.04609377280342, 1.0890625305741, 
1.08125002916125, 1.24921880953755, 1.34687507719818, 1.50312510545521, 
1.88984392539134, 2.37812526369453, 2.39375026652023, 2.36640651157525, 
2.38593776510738, 2.62031280749291, 2.69843782162142, 2.85078159917202, 
2.90546910906198), lat = c(1.04062476682306, 1.05624976964876, 
1.03671851611663, 1.13828103448369, 1.16562478942867, 1.26718730779574, 
1.43124983746561, 1.32968731909855, 1.32187481768569, 1.30624981485999, 
1.28281231062144, 1.20468729649293, 1.13828103448369, 1.08749977530016, 
1.03671851611663)), .Names = c("ID", "long", "lat"), row.names = c(NA, 
-15L), class = "data.frame")
points(obs[,2:3],col="red")

obs&lt;-st_as_sf(obs,coords=c(2:3))
# possibly a count (number of individuals observed) on each location
obs$n&lt;-c(3,4,0,1,1,5,6,4,3,4,4,7,2,2,1) 

# examples

# Presence/absence on each observation
track&lt;-transLines2pix(sl,0.1)
trackObs&lt;-mergeTrackObs(track,obs)

par(mfrow=c(1,2))
plot(sl,reset=FALSE)
plot(track,add=TRUE,col="blue")
plot(st_geometry(obs),add=TRUE,col="red",pch=1)

plot(sl,reset=FALSE)
plot(track,add=TRUE,col="blue")
plot(trackObs,cex=trackObs$nObs,pch=19, col="red",add=TRUE)


# 0 or more observations on each location
head(obs)
st_drop_geometry(obs) # the counts are in column "n" (column 2 in the data.frame)

trackObs&lt;-mergeTrackObs(track,obs,obscol="n")

par(mfrow=c(1,2))
plot(sl,reset=TRUE)
plot(track,add=TRUE,col="blue")
plot(st_geometry(obs),add=TRUE,col="red",pch=1)

plot(sl)
plot(track,add=TRUE,col="blue")
plot(st_geometry(trackObs),cex=trackObs$nObs/3,pch=19, col="red",add=TRUE)


}
     
</code></pre>

<hr>
<h2 id='pairsrp'>Produces a matrix of scatterplot, regression coefficient and p(Ho) </h2><span id='topic+pairsrp'></span>

<h3>Description</h3>

<p>Produces a matrix with scatterplot, regression line and a loess smooth in the upper right panel;
correlation coefficient (Pearson, Spearman or Kendall) and the probability of Ho in the lower left panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairsrp(dataframe, meth = "spearman", pansmo = FALSE, abv = FALSE, lwt.cex = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairsrp_+3A_dataframe">dataframe</code></td>
<td>
<p> a data.frame of numeric values </p>
</td></tr>
<tr><td><code id="pairsrp_+3A_meth">meth</code></td>
<td>
<p> a character string indicating which correlation coefficient is to be computed.  One of 'pearson', 'kendall', or 'spearman'(default). Can be abbreviated. </p>
</td></tr>
<tr><td><code id="pairsrp_+3A_pansmo">pansmo</code></td>
<td>
<p> True if a loess smooth is to be plotted. Default to False. </p>
</td></tr>
<tr><td><code id="pairsrp_+3A_abv">abv</code></td>
<td>
<p> True if the variable names must be abbreviates. Default to False. </p>
</td></tr>
<tr><td><code id="pairsrp_+3A_lwt.cex">lwt.cex</code></td>
<td>
<p> character size expansion in the lower panel. </p>
</td></tr>
<tr><td><code id="pairsrp_+3A_...">...</code></td>
<td>
<p> graphical parameters can be given as arguments to 'plot'. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for pairs() and cor()
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+pairs">pairs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
pairsrp(iris[,1:4],meth="pears",pansmo=TRUE,abv=TRUE)
 </code></pre>

<hr>
<h2 id='pave'>Provide square polygons or their node coordinates along a segment</h2><span id='topic+pave'></span>

<h3>Description</h3>

<p>Provide a user-defined cell grid of polygon squares (or square node points) along a segment. This can be used to define a sampling grid for spatial analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pave(cordseg, yc, xc, fix.edge=NULL, ydown = TRUE, output = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pave_+3A_cordseg">cordseg</code></td>
<td>
<p> the segment coordinates. This can be a vector c(x1,y1,x2,y2), a 2 x 2 matrix or a data.frame (each line a coordinate)</p>
</td></tr>
<tr><td><code id="pave_+3A_yc">yc</code></td>
<td>
<p> the number of segment divisions (y cells) </p>
</td></tr>
<tr><td><code id="pave_+3A_xc">xc</code></td>
<td>
<p> the number of columns (x cells)</p>
</td></tr>
<tr><td><code id="pave_+3A_fix.edge">fix.edge</code></td>
<td>
<p> the edge length of a cell (user specified, default to NULL)</p>
</td></tr>
<tr><td><code id="pave_+3A_ydown">ydown</code></td>
<td>
<p> if TRUE (default) squares are computed decreasing y </p>
</td></tr>
<tr><td><code id="pave_+3A_output">output</code></td>
<td>
<p> a character string indicating which output is required. One of &quot;list&quot;, &quot;points&quot; or &quot;spdf&quot;. Partial match allowed </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The segment must have x1 &lt; x2. If not, it is automatically reordered. When &quot;spdf&quot; is selected the output is an object of class
<code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code>. The value of the edge length of a cell can passed with the argument fix.edge. In this case, the coordinates of the segment right top are re-computed to adjust the cell edge to an user defined fixed value. 
</p>


<h3>Value</h3>

<p>According to the output selected, a list of polygon coordinates, a 2 column matrix with the nodes coordinates or a <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+over">over</a></code>, <code><a href="#topic+diag2edge">diag2edge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# segment sloping up
coord&lt;-matrix(c(20,20,90,90),nr=2,byrow=TRUE)
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord)
# point grids
gr&lt;-pave(coord,20,4,output="points") # y decreasing
points(gr)
gr&lt;-pave(coord,20,4,output="points",ydown=FALSE) # y increasing
points(gr,col="blue")
# square polygon grids
gr&lt;-pave(coord,20,4) # y decreasing
for (i in 1:length(gr)) polygon(gr[[i]])
gr&lt;-pave(coord,20,4,ydown=FALSE) # y increasing
for (i in 1:length(gr)) polygon(gr[[i]],border="blue")

# segment sloping down
coord&lt;-matrix(c(20,90,90,20),nr=2,byrow=TRUE)
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord)

# point grids
gr&lt;-pave(coord,20,4,output="points")  # y decreasing
points(gr)
gr&lt;-pave(coord,20,4,output="points",ydown=FALSE) # y increasing
points(gr,col="blue")

# fixed edge
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord)
gr&lt;-pave(coord,20,4,fix.edge=4,output="points")
points(gr,col="blue")

plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord)
gr&lt;-pave(coord,20,4,fix.edge=5.5,output="points")
points(gr,col="red")

# square polygon grids
coord&lt;-matrix(c(20,90,90,20),nr=2,byrow=TRUE)
plot(coord,type="n",xlim=c(0,100),ylim=c(0,110),asp=1)
lines(coord,lwd=2)
gr&lt;-pave(coord,20,4)# y decreasing
for (i in 1:length(gr)) polygon(gr[[i]]) 
gr&lt;-pave(coord,20,4,ydown=FALSE) # y increasing
for (i in 1:length(gr)) polygon(gr[[i]],border="blue")

# geting a SpatialPolygonsDataFrame
gr&lt;-pave(coord,20,4,output="spdf") # y decreasing

</code></pre>

<hr>
<h2 id='permcont'> Random permutation of a contingency table n row x 2 columns</h2><span id='topic+permcont'></span>

<h3>Description</h3>

<p>Return a random permutation of a contingency table n rows x 2 columns keeping the marginal totals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcont(Table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcont_+3A_table">Table</code></td>
<td>
<p> a contingency table </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contingency table is split in a two colums table of 0/1 categories, sampled and re-organised with the function table()
</p>


<h3>Value</h3>

 
<p>A matrix with the permuted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab&lt;-cbind(n1=c(10,12,8,7,5),n2=c(4,5,8,10,12))
tab
permcont(tab)
</code></pre>

<hr>
<h2 id='PermTest'> Permutation test for lm, lme and glm (binomial and Poisson) objects </h2><span id='topic+PermTest'></span><span id='topic+PermTest.lm'></span><span id='topic+PermTest.lme'></span><span id='topic+PermTest.glm'></span><span id='topic+print.PermTest'></span>

<h3>Description</h3>

<p>Permutation test for lm, lme and glm (binomial and Poisson) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    PermTest(obj, B=1000,...)

    ## S3 method for class 'lm'
PermTest(obj, B=1000,...)
    ## S3 method for class 'lme'
PermTest(obj, B=1000,...)
    ## S3 method for class 'glm'
PermTest(obj, B=1000,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PermTest_+3A_obj">obj</code></td>
<td>
<p>an object of class lm, lme, or glm</p>
</td></tr>
<tr><td><code id="PermTest_+3A_b">B</code></td>
<td>
<p>number of permutations, default = 1000</p>
</td></tr>
<tr><td><code id="PermTest_+3A_...">...</code></td>
<td>
<p>used to pass other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For glm, when the response is a two-column matrix with the columns giving the numbers of successes and failures, PermTest.glm uses permcont(); PermTest.lme requires the library nlme.
</p>


<h3>Value</h3>

<p>A list object of class PermTest including:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p value obtained</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>This generic function is implemented in R language, thus can be quite slow. 
</p>


<h3>Note</h3>

<p>The implementation of PermTest.lme has been helped by Renaud Lancelot</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(MASS)){
mylm&lt;-lm(Postwt~Prewt,data=anorexia)
PermTest(mylm,B=250)


## Dobson (1990) Page 93: Randomized Controlled Trial :
    counts &lt;- c(18,17,15,20,10,20,25,13,12)
    outcome &lt;- gl(3,1,9)
    treatment &lt;- gl(3,3)
    glm.D93 &lt;- glm(counts ~ outcome + treatment, family=poisson)
    PermTest(glm.D93,B=100)
    }

if(require(nlme)){
fm2 &lt;- lme(distance ~ age + Sex, data = Orthodont, random = ~ 1)
PermTest(fm2,B=100)
}

  </code></pre>

<hr>
<h2 id='piankabio'> Computes the Pianka's index of niche overlap </h2><span id='topic+piankabio'></span>

<h3>Description</h3>

<p>Computes the Pianka's index of niche overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piankabio(dataframe1, dataframe2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piankabio_+3A_dataframe1">dataframe1</code></td>
<td>
<p> a data frame of two columns: column 1 = dietary category, column 2 = biomass </p>
</td></tr>
<tr><td><code id="piankabio_+3A_dataframe2">dataframe2</code></td>
<td>
<p> a data frame of two columns: column 1 = dietary category, column 2 = biomass  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Pianka's index of niche overlap
</p>


<h3>Value</h3>

<p>Return the Pianka's index
</p>


<h3>References</h3>

<p>Pianka R.D. 1973 The scructure of lizard communities. Annual Review of Ecology and Systematics, 4: 53-74.
</p>
<p>Amroun M., Giraudoux P., Delattre P. 2006 Comparative study of the diets of two sympatric carnivores - the Jackal (Canis aureus) and the Genet (Genetta genetta) - at two sites in Kabylia, Algeria. Mammalia, 70 (3): 247-254
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+piankabioboot">piankabioboot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(preybiom)
attach(preybiom)
jackal&lt;-preybiom[site=="Y" &amp; sp=="C",5:6]
genet&lt;-preybiom[site=="Y" &amp; sp=="G",5:6]

piankabio(jackal,genet)
  
</code></pre>

<hr>
<h2 id='piankabioboot'> Bootstrap Pianka's index </h2><span id='topic+piankabioboot'></span>

<h3>Description</h3>

<p>Bootstrap Pianka's index and return the limits of the empirical confidence interval specified with probs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piankabioboot(dataframe1, dataframe2, B = 1000, probs = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piankabioboot_+3A_dataframe1">dataframe1</code></td>
<td>
<p> a data frame of two columns: column 1 = dietary category, column 2 = biomass </p>
</td></tr>
<tr><td><code id="piankabioboot_+3A_dataframe2">dataframe2</code></td>
<td>
<p> a data frame of two columns: column 1 = dietary category, column 2 = biomass </p>
</td></tr>
<tr><td><code id="piankabioboot_+3A_b">B</code></td>
<td>
<p> number of permutations </p>
</td></tr>
<tr><td><code id="piankabioboot_+3A_probs">probs</code></td>
<td>
<p> the limits of the confidence interval </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap Pianka's index and return the limits of the empirical confidence interval sepcified with probs
</p>


<h3>Value</h3>

<p>a vector of the two CI limits
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+piankabio">piankabio</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preybiom)
attach(preybiom)
jackal&lt;-preybiom[site=="Y" &amp; sp=="C",5:6]
genet&lt;-preybiom[site=="Y" &amp; sp=="G",5:6]

piankabioboot(jackal,genet,B=100)
  
</code></pre>

<hr>
<h2 id='polycirc'> Computes the polygon coordinates of a circle </h2><span id='topic+polycirc'></span>

<h3>Description</h3>

<p>Computes the polygon coordinates of a circle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polycirc(radius, pts = c(0, 0), nbr = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polycirc_+3A_radius">radius</code></td>
<td>
<p> the length of the radius. </p>
</td></tr>
<tr><td><code id="polycirc_+3A_pts">pts</code></td>
<td>
<p> the coordinates of the center. </p>
</td></tr>
<tr><td><code id="polycirc_+3A_nbr">nbr</code></td>
<td>
<p> the number of segments required to draw the perimeter  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix of coordinates  can then be used with the function polygon
</p>


<h3>Value</h3>

<p>A matrix of coordinates.
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+polygon">polygon</a></code>,<code><a href="#topic+findR">findR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(1:10,1:10,type="n",asp=1)
polygon(polycirc(5),col="blue")
polygon(polycirc(2,c(5,5)), col="red")

</code></pre>

<hr>
<h2 id='polycirc2'> Computes the polygon coordinates of a circle sector </h2><span id='topic+polycirc2'></span>

<h3>Description</h3>

<p>Computes the polygon coordinates of a circle sector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polycirc2(radius = 1, center = c(0, 0), edges = 50, init = pi/2, angle = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polycirc2_+3A_radius">radius</code></td>
<td>
<p> the circle radius </p>
</td></tr>
<tr><td><code id="polycirc2_+3A_center">center</code></td>
<td>
<p> the centre coordinates (defaut to x=0, y=0) </p>
</td></tr>
<tr><td><code id="polycirc2_+3A_edges">edges</code></td>
<td>
<p> the circular outline of the sector is approximated by a polygon with this many edges</p>
</td></tr>
<tr><td><code id="polycirc2_+3A_init">init</code></td>
<td>
<p>  number (in radian) specifying the starting angle</p>
</td></tr>
<tr><td><code id="polycirc2_+3A_angle">angle</code></td>
<td>
<p> number (in radian) specifying the sector angle </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix of coordinates obtained is intended to be passed to the function <code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Value</h3>

<p> A matrix of coordinates</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+polygon">polygon</a></code>,<code><a href="#topic+polycirc">polycirc</a></code>, <code><a href="plotrix.html#topic+floating.pie">floating.pie</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(-1,+1),c(-1,+1),type="n",asp=1)
polygon(polycirc2(),col="red")
polygon(polycirc2(init=pi,angle=pi/4),col="green")
polygon(polycirc2(init=1.5*pi,angle=pi/4),col="violet")
polygon(polycirc2(radius=0.5,center=c(0.5,1)),col="blue")

polycirc2(init=pi,angle=pi/4)
</code></pre>

<hr>
<h2 id='preybiom'>  Jackal and Genet diet in Algeria </h2><span id='topic+preybiom'></span>

<h3>Description</h3>

<p>This data set gives the results of dietary analysis performed by Amroun Mansour in two sites of Kabylie, Algeria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(preybiom)</code></pre>


<h3>Format</h3>

<p>A data frame with 2196 observations on the following variables.
</p>

<dl>
<dt><code>faeces</code></dt><dd><p>a factor for faeces corresponding to faeces identification numbers</p>
</dd>
<dt><code>site</code></dt><dd><p>a factor for study sites with levels <code>S</code> Sebaou <code>Y</code> Yacouren </p>
</dd>
<dt><code>saison</code></dt><dd><p>a factor for seasons with levels <code>H</code> <code>HD</code> <code>HP</code> <code>S</code> <code>SD</code> <code>SP</code></p>
</dd>
<dt><code>sp</code></dt><dd><p>a factor for species with levels <code>C</code> Jackal <code>G</code> Genet </p>
</dd>
<dt><code>category</code></dt><dd><p>a factor for dietary items with levels <code>dech</code> <code>ind</code> <code>ins</code> <code>mam</code> <code>mol</code> <code>oisauv</code> <code>oisdom</code> <code>rept</code> <code>vege</code> <code>vegn</code></p>
</dd>
<dt><code>biomasse</code></dt><dd><p>a numeric vector for the weight of each dietary item</p>
</dd>
</dl>



<h3>References</h3>

<p>M. Amroun, P. Giraudoux and P. Delattre 2006 Comparative study of the diets of two sympatric carnivores - the Jackal (Canis aureus) and the Genet (Genetta genetta) - at two sites in Kabylia, Algeria. Mammalia, 70 (3/4): 247-254.
</p>

<hr>
<h2 id='print.mc'> print method for objects of class 'mc' </h2><span id='topic+print.mc'></span>

<h3>Description</h3>

<p>print method for objects of class 'mc'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'mc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mc_+3A_x">x</code></td>
<td>
<p> an object of class 'mc' </p>
</td></tr>
<tr><td><code id="print.mc_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to or from other methods. They are ignored in this function </p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+kruskalmc">kruskalmc</a></code>, <code><a href="#topic+friedmanmc">friedmanmc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>resp&lt;-c(0.44,0.44,0.54,0.32,0.21,0.28,0.7,0.77,0.48,0.64,0.71,0.75,0.8,0.76,0.34,0.80,0.73,0.8)
categ&lt;-as.factor(rep(c("A","B","C"),times=1,each=6))
kruskalmc(resp, categ)
</code></pre>

<hr>
<h2 id='Segments'> Draw line segments between pairs of points. </h2><span id='topic+Segments'></span>

<h3>Description</h3>

<p>Draw line segments between pairs of points from a vector, matrix or data frame of 4 points coordinates x0, y0, x1, y1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Segments(mydata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Segments_+3A_mydata">mydata</code></td>
<td>
<p> a vector, matrix or data frame </p>
</td></tr>
<tr><td><code id="Segments_+3A_...">...</code></td>
<td>
<p> further graphical parameters (from 'par') </p>
</td></tr>
</table>


<h3>Details</h3>

<p>a wrapper to 'segments' to handle coordinates passed as vector, matrix or data frame. Any vector is turned into a matrix of four columns.
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+segments">segments</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> mydata&lt;-cbind(rnorm(20),rnorm(20),rnorm(20),rnorm(20))
 plot(range(rbind(mydata[,1],mydata[,3])),range(rbind(mydata[,2],mydata[,4])),
 type="n",xlab="",ylab="")
 Segments(mydata,col=rainbow(20))
 
 myvec&lt;-rnorm(4)
 plot(myvec[c(1,3)],myvec[c(2,4)],type="n",xlab="",ylab="")
 Segments(myvec)
 
 myvec&lt;-rnorm(16)
 plot(myvec,myvec,type="n",xlab="",ylab="")
 Segments(myvec)
  </code></pre>

<hr>
<h2 id='selMod'> Model selection according to information theoretic methods </h2><span id='topic+selMod'></span><span id='topic+selMod.lm'></span><span id='topic+selMod.glm'></span><span id='topic+selMod.list'></span>

<h3>Description</h3>

<p>Handles lm, glm and list of  e.g. lm, glm, nls, lme and nlme objects and provides parameters to compare models according to Anderson et al. (2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    selMod(aModel, Order = "AICc", ...)

    ## S3 method for class 'lm'
selMod(aModel, Order = "AICc", dropNull = FALSE, selconv=TRUE, ...)
    ## S3 method for class 'list'
selMod(aModel, Order = "AICc", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selMod_+3A_amodel">aModel</code></td>
<td>
<p> a lm or glm model or a list of relevant models (see details) </p>
</td></tr>
<tr><td><code id="selMod_+3A_dropnull">dropNull</code></td>
<td>
<p> if TRUE, drops the simplest model (e.g. y<code class="reqn">~</code>1)  </p>
</td></tr>
<tr><td><code id="selMod_+3A_order">Order</code></td>
<td>
<p> if set to &quot;AICc&quot; (default) sort the models on this parameter, otherwise &quot;AIC&quot; is allowed </p>
</td></tr>
<tr><td><code id="selMod_+3A_selconv">selconv</code></td>
<td>
<p> if TRUE (default) keep the models for which convergence is obtained (glm object only) and with no anova singularity (lm and glm) </p>
</td></tr>
<tr><td><code id="selMod_+3A_...">...</code></td>
<td>
<p> other parameters to be passed as arguments (not used here) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides parameters used in the information theoretic methods for model comparisons.
</p>
 
<ul>
<li><p> lm and glm objects can be passed directly as the upper scope of term addition (all terms added). 
Every model from y<code class="reqn">\sim</code>1 is computed adding one term at a time until the upper scope model is derived. This is a stepwise analysis where the terms are added sequentially and this does NOT provide all combinations of terms and interactions. Offset terms cannot be proceeded here.
</p>
</li>
<li><p> A list of user specified lm, glm, nls, lme or nlme objects (actually any object for which AIC and logLik functions are applicable) to compare can alternately be passed.
</p>
</li></ul>



<h3>Value</h3>

<p>A dataframe including:
</p>

<ul>
<li><p> LL, the maximized log-likelihood
</p>
</li>
<li><p> K, the number of estimated parameters
</p>
</li>
<li><p> N2K, the number of observations/K
</p>
</li>
<li><p> AIC, the Akaike index criterion
</p>
</li>
<li><p> deltAIC,the difference between AIC and the lowest AIC value
</p>
</li>
<li><p> w_i, the Akaike weights
</p>
</li>
<li><p> deltAICc, the difference between AICc and the lowest AICc value; advised to be used when n2K <code class="reqn">&lt;</code> 40
</p>
</li>
<li><p> w_ic, the AICc weights
</p>
</li></ul>

<p>The models examined from first to last are stored as attribute
</p>


<h3>Author(s)</h3>

<p> Patrick Giraudoux and David Pleydell: pgiraudo@univ-fcomte.fr, david.pleydell@inra.fr </p>


<h3>References</h3>

 

<ul>
<li><p> Anderson, D.R., Link, W.A., Johnson, D.H. and Burnham, K.P. (2001). Suggestions for presenting the results of data analyses. Journal of Wildlife Management, 65, 373-378
</p>
</li>
<li><p> Burnham, K.P. and Anderson, D.R. (2002) Model Selection and Multimodel Inference: a Practical Information-Theoretic Approach, 2nd edn., Springer-Verlag, New York. 353 pp
</p>
</li></ul>



<h3>See Also</h3>

 <p><code><a href="stats.html#topic+AIC">AIC</a></code>,<code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="AICcmodavg.html#topic+aictab">aictab</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> if(require(MASS)){
 anorex.1 &lt;- lm(Postwt ~ Prewt*Treat, data = anorexia)
 selMod(anorex.1)
 anorex.2 &lt;- glm(Postwt ~ Prewt*Treat, family=gaussian,data = anorexia)
 selMod(anorex.2)
 anorex.3&lt;-lm(Postwt ~ Prewt+Treat, data = anorexia)
 mycomp&lt;-selMod(list(anorex.1,anorex.2,anorex.3))
 mycomp
 attributes(mycomp)$models
 }
</code></pre>

<hr>
<h2 id='shannon'> Computes Shannon's and equitability indices</h2><span id='topic+shannon'></span>

<h3>Description</h3>

<p>Computes Shannon's and equitability indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannon(vect, base=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shannon_+3A_vect">vect</code></td>
<td>
<p> a probability vector whose sum = 1 or a frequency vector</p>
</td></tr>
<tr><td><code id="shannon_+3A_base">base</code></td>
<td>
<p> logarithm base used (default=2) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes Shannon's and equitability indices. The vector passed can be a probability vector whose sum equal 1 or a vector of frequencies (e.g. the number of food item of each category). 
</p>


<h3>Value</h3>

<p>A vector of two values: Shannon's and equitability indices. The base logarithm used is stored as attribute
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+shannonbio">shannonbio</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(0.1,0.5,0.2,0.1,0.1)
sum(x)
shannon(x)

x&lt;-rpois(10,6)
shannon(x, base=exp(1))

</code></pre>

<hr>
<h2 id='shannonbio'> Computes Shannon's and equitability indices from a data frame of dietary analysis (n, biomass,...)  </h2><span id='topic+shannonbio'></span>

<h3>Description</h3>

<p>Computes Shannon's and equitability indices from a data frame of two columns: column 1, dietary category; column 2, abundance (n, biomass,...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannonbio(data1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shannonbio_+3A_data1">data1</code></td>
<td>
<p> a data frame of two columns: column 1, dietary category; column 2, abundance (n, biomass,...) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes Shannon's and equitability indices from a data frame of two columns: column 1, dietary category; column 2, abundance (n, biomass,...)
</p>


<h3>Value</h3>

<p>A vector of two values: Shannon's and equitability indices
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+shannon">shannon</a></code>, <code><a href="#topic+difshannonbio">difshannonbio</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(preybiom)
shannonbio(preybiom[,5:6])

</code></pre>

<hr>
<h2 id='shannonbioboot'> Boostrap Shannon's and equitability indices 
</h2><span id='topic+shannonbioboot'></span>

<h3>Description</h3>

<p>Boostrap Shannon's and equitability indices and return an object of class boot. Confidence intervals can be computed with boot.ci().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannonbioboot(data1, B = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shannonbioboot_+3A_data1">data1</code></td>
<td>
<p> a data frame of two columns: column 1, dietary category; column 2, abundance (n, biomass,...) </p>
</td></tr>
<tr><td><code id="shannonbioboot_+3A_b">B</code></td>
<td>
<p> number of permutations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Boostrap Shannon\'s and equitability indices and return an object of class boot. Confidence intervals can be computed with boot.ci(). Requires the boot library.
</p>


<h3>Value</h3>

<p>An object of class boot including the bootstrap statistics for H' (t1*) and J' (t2*)
</p>


<h3>See Also</h3>

 <p><code><a href="boot.html#topic+boot">boot</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>, <code><a href="#topic+shannonbio">shannonbio</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preybiom)
myboot&lt;-shannonbioboot(preybiom[,5:6],B=100)
library(boot)
boot.ci(myboot, index=1,type=c("norm","basic","perc")) # confidence intervals for H'
boot.ci(myboot, index=2,type=c("norm","basic","perc")) # confidence intervals for J'
</code></pre>

<hr>
<h2 id='siegelp179'> Data on rats training </h2><span id='topic+siegelp179'></span>

<h3>Description</h3>

<p>Ranks of 18 matched groups of rats after training under three methods of reinforcement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(siegelp179)</code></pre>


<h3>Format</h3>

<p>A data frame with 54 observations on the following 3 variables.
</p>

<dl>
<dt>block</dt><dd><p>Group (each of three litter mates)</p>
</dd>
<dt>treatment</dt><dd><p>A factor for the type of reinforcement with levels <code>RR</code> <code>RU</code> <code>UR</code></p>
</dd>
<dt>score</dt><dd><p>Speed of transfer to another behaviour (the lower, the better the learning)</p>
</dd>
</dl>



<h3>Details</h3>

<p>18 blocks made of three rats of the same litter, each being given a different learning pattern (RR, RU or UR)
</p>


<h3>Source</h3>

<p>Grosslight J.H. and Radlow R. (1956) Patterning effect of the nonreinforcement-reinforcement sequence in a discrimination situation. Journal of Comparative and Physiological Psychology, 49: 542-546 in Siegel &amp; Castellan 1988. Non parametric statistics for the behavioural sciences. Mc Graw Hill Int. Edt.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(siegelp179)
</code></pre>

<hr>
<h2 id='st_thintrack'> Thin a track just keeping the points separated by a user defined minimal distance </h2><span id='topic+st_thintrack'></span>

<h3>Description</h3>

<p>Thin a track stored as a <code><a href="sf.html#topic+sf">sf</a></code> POINT object, just keeping the points separated by a user defined minimal distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_thintrack(spdf,mindist=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_thintrack_+3A_spdf">spdf</code></td>
<td>
<p>a <code><a href="sf.html#topic+sf">sf</a></code> of POINT tracks </p>
</td></tr>
<tr><td><code id="st_thintrack_+3A_mindist">mindist</code></td>
<td>
<p> minimal distance requested between two points (default = 100)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tracks downloaded from GPS often provide an unnecessary large density of points at irregular distances. This function starts reading from the first point of the track and removes all points within a user specified radius (USR), then reads the next point and removes all points within the USR, and so on...
</p>


<h3>Value</h3>

<p>A <code><a href="sf.html#topic+sf">sf</a></code> POINT object of the track thinned.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mergeTrackObs">mergeTrackObs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(sf)){

mySPDF&lt;-structure(list(x = c(748775, 748807, 748834, 748854, 748871, 
748873, 748880, 748910, 748919, 748917, 748921, 748923, 748924, 
748921, 748921, 748921, 748922, 748915, 748616, 748613, 748612, 
748613, 748613, 748615, 748613, 748616, 748615, 748618, 748615, 
748619, 748618, 748620, 748586, 748553, 748494, 748444, 748424, 
748366, 748305, 748305), y = c(105716, 105761, 105808, 105856, 
105911, 105964, 106019, 106065, 106114, 106167, 106219, 106274, 
106329, 106385, 106441, 106494, 106550, 106571, 105835, 105779, 
105723, 105665, 105600, 105537, 105473, 105412, 105350, 105293, 
105234, 105180, 105123, 105070, 105023, 104960, 104956, 104947, 
104906, 104905, 104901, 104904), ID = 1:40), .Names = c("x", 
"y", "ID"), row.names = c("1", "2", "3", "4", "5", "6", "7", 
"8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", 
"19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", 
"30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40"
), class = "data.frame")

mySPDF&lt;-st_as_sf(mySPDF,coords=c("x","y"))

plot(st_geometry(mySPDF),pch=19,cex=0.5)
plot(st_thintrack(mySPDF),pch=19,cex=0.7,col="red",add=TRUE)

plot(mySPDF,pch=19,cex=0.5)
plot(st_thintrack(mySPDF,min=200),pch=19,cex=0.7,col="red",add=TRUE)

}
</code></pre>

<hr>
<h2 id='tabcont2categ'> Convert a contingency table (data.frame) into a presence/absence table of categories
</h2><span id='topic+tabcont2categ'></span>

<h3>Description</h3>

<p>Convert a contingency table (data frame) into a data.frame of factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabcont2categ(tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabcont2categ_+3A_tab">tab</code></td>
<td>
<p> A data.frame (contingency table) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert a contingency table (data frame) into a data.frame of factors
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata&lt;-as.data.frame(matrix(rpois(9,5),nr=3,nc=3))
names(mydata)&lt;-LETTERS[1:3]
row.names(mydata)&lt;-letters[1:3]

tabcont2categ(mydata)
</code></pre>

<hr>
<h2 id='trans2pix'> Convert a transect coordinate file with some waypoints separated by NA into a matrix with intermediate coordinates replacing NA. </h2><span id='topic+trans2pix'></span>

<h3>Description</h3>

<p>Convert a transect coordinate file with some waypoints separated by NA into a matrix with intermediate coordinates replacing NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans2pix(vect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans2pix_+3A_vect">vect</code></td>
<td>
<p> A two column matrix or data.frame </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If vect has more than two column the two first column only are read. This function computes the intermediate coordinates between two waypoints replacing NA values.
</p>


<h3>Value</h3>

<p>A matrix with the intermediate coordinates computed.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+trans2seg">trans2seg</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(10,NA, NA, NA,56,NA,NA,100)
y&lt;-c(23,NA, NA, NA,32,NA,NA,150)
cols=c("red","blue","blue","blue","red","blue","blue","red")
plot(x,y,col=cols,pch=19)
plot(trans2pix(cbind(x,y)),col=cols,pch=19)

</code></pre>

<hr>
<h2 id='trans2seg'> Convert a transect coordinate file into a matrix with segment coordinates. </h2><span id='topic+trans2seg'></span>

<h3>Description</h3>

<p>Convert a transect coordinate file (e.g.: waypoints) into a matrix with segment coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans2seg(vect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans2seg_+3A_vect">vect</code></td>
<td>
<p> A two column matrix or data.frame </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument passed is a matrix or data.frame of two columns each row is a transect interval; each column must start (first row) and end (last row) with a landmark ; intermediate waypoints must have coordinates in the two columns of the row. Other rows must be NA values.
</p>


<h3>Value</h3>

<p>A matrix of 4 columns to be passed e.g. to functions as &quot;segments&quot;.
</p>


<h3>See Also</h3>

<p> trans2pix </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(10,NA, NA, NA,56,NA,NA,100)
y&lt;-c(23,NA, NA, NA,32,NA,NA,150)
cols=c("red","blue","blue","blue","red","blue","blue","red")
plot(x,y,col=cols,pch=19)
mysegs&lt;-trans2seg(cbind(x,y))
segments(mysegs[,1],mysegs[,2],mysegs[,3],mysegs[,4])
</code></pre>

<hr>
<h2 id='transLines2pix'>Convert MULTILINESTRING and/or LINESTRING into POINT geometry with points at regular distance between nodes </h2><span id='topic+transLines2pix'></span>

<h3>Description</h3>

<p>Convert a simple feature geometry made of MULTILINESTRING and/or LINESTRING into a  POINT geometry with points at regular distance between nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transLines2pix(spldf,mindist=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transLines2pix_+3A_spldf">spldf</code></td>
<td>
<p>A <code><a href="sf.html#topic+sfc">sfc</a></code> object containing MULTILINESTRING or LINESTRING  or both, exclusively</p>
</td></tr>
<tr><td><code id="transLines2pix_+3A_mindist">mindist</code></td>
<td>
<p>the distance between two points (default to 100)  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used e.g to discretize track lines (roads, paths, transects, etc.) into series of regular points. Each point is the centre of one interval. Beware that if mindist is larger than the distance between nodes, the output file will keep the nodes. Furthermore, mindist might not be fully respected in some spatial configurations. In such cases to filter points using <code><a href="#topic+st_thintrack">st_thintrack</a></code> complementarily is advised.
</p>


<h3>Value</h3>

<p>A <code><a href="sf.html#topic+sf">sf</a> object</code> with a POINT geometry type.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+trans2pix">trans2pix</a></code>, <code><a href="#topic+st_thintrack">st_thintrack</a></code>,  <code><a href="#topic+mergeTrackObs">mergeTrackObs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(sf)) {
l1 = st_linestring(cbind(c(1,2,3),c(3,2,2)))
S1&lt;-st_multilinestring(list(l1,cbind(l1[,1]+.05,l1[,2]+.05)))
S2&lt;-st_linestring(cbind(c(1,2,3),c(1,1.5,1)))
sl&lt;-st_sfc(list(S1,S2))
plot(sl, col = c("red", "blue"),reset=FALSE)

trpt&lt;-transLines2pix(sl,mindist=0.1)

plot(st_geometry(trpt),add=TRUE)
}

</code></pre>

<hr>
<h2 id='TukeyHSDs'> Simplify the list of a TukeyHSD object keeping the significant differences only. </h2><span id='topic+TukeyHSDs'></span>

<h3>Description</h3>

<p>Simplify the list of a TukeyHSD object keeping the significant differences only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TukeyHSDs(TukeyHSD.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TukeyHSDs_+3A_tukeyhsd.object">TukeyHSD.object</code></td>
<td>
<p> An object of calls &quot;TukeyHSD&quot; </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When TukeyHSD is used on a fitted model with large numbers of categories, the number of pairwise comparisons is extremely large (n(n-1)/2). 
TukeyHSDs simplify the TukeyHSD object keeping the significant pairwise comparisons only. A plot method exists for TukeyHSD objects.
</p>


<h3>Value</h3>

<p>An object of class &quot;multicomp&quot; and &quot;TukeyHSD&quot;
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
     summary(fm1 &lt;- aov(breaks ~ wool + tension, data = warpbreaks))
     myobject&lt;-TukeyHSD(fm1, "tension", ordered = TRUE)
     myobject
     TukeyHSDs(myobject)
  </code></pre>

<hr>
<h2 id='val4symb'> Center a numerical vector on a parameter position and provides absolute values and colors according to negative and positive values</h2><span id='topic+val4symb'></span>

<h3>Description</h3>

<p>Center a numerical vector on a parameter position and provides absolute values and colors according to negative and positive values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val4symb(x, FUN=mean, col = c("blue", "red"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val4symb_+3A_x">x</code></td>
<td>
<p> a numerical vector</p>
</td></tr>
<tr><td><code id="val4symb_+3A_fun">FUN</code></td>
<td>
<p> a function computing a position parameter, typically <code><a href="base.html#topic+mean">mean</a></code> or <code><a href="stats.html#topic+median">median</a></code>. Default to <code><a href="base.html#topic+mean">mean</a></code></p>
</td></tr>
<tr><td><code id="val4symb_+3A_col">col</code></td>
<td>
<p> a character vector of 2 values, default=c(&quot;blue&quot;,&quot;red&quot;), blue for &lt;0, red for &gt;=0 </p>
</td></tr>
<tr><td><code id="val4symb_+3A_...">...</code></td>
<td>
<p> optional arguments to 'FUN' </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>size</code></td>
<td>
<p>the absolute values of the difference to the position parameter (eg mean, median)</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>a character vector with 2 colors, each corresponding to positive or negative values</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+symbols">symbols</a></code>, <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+median">median</a></code>, <code><a href="base.html#topic+scale">scale</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rnorm(30)
y&lt;-rnorm(30)

z&lt;-val4symb(rnorm(30))
symbols(x,y,circle=z$size,inches=0.2,bg=z$col)

z&lt;-val4symb(scale(rnorm(30)))
symbols(x,y,circle=z$size,inches=0.2,bg=z$col)

z&lt;-val4symb(rnorm(30),col=c("green","violet"))
symbols(x,y,circle=z$size,inches=0.2,bg=z$col)

z&lt;-val4symb(rnorm(30),trim=0.025)
symbols(x,y,circle=z$size,inches=0.2,bg=z$col)

z&lt;-val4symb(rnorm(30),median)
symbols(x,y,circle=z$size,inches=0.2,bg=z$col)

myfun&lt;-function(x) 20 # passes an arbitrary constant
z&lt;-val4symb(1:30,myfun)
symbols(x,y,circle=z$size,inches=0.2,bg=z$col)


</code></pre>

<hr>
<h2 id='write.delim'> Write a data.frame</h2><span id='topic+write.delim'></span>

<h3>Description</h3>

<p>Write a simple data.frame into a text file with header, no row.names, fields separated by tab. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.delim(x, file = "", row.names = FALSE, quote = FALSE, sep = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.delim_+3A_x">x</code></td>
<td>
<p> a data.frame </p>
</td></tr>
<tr><td><code id="write.delim_+3A_file">file</code></td>
<td>
<p> a character string for file name </p>
</td></tr>
<tr><td><code id="write.delim_+3A_row.names">row.names</code></td>
<td>
<p> either a logical value indicating whether the row names of 'x' are to be written along with 'x', or a character vector of row names to be written </p>
</td></tr>
<tr><td><code id="write.delim_+3A_quote">quote</code></td>
<td>
<p> a logical value or a numeric vector.  If 'TRUE', any character or factor columns will be surrounded by double quotes.  If a numeric vector, its elements are taken as the indices of the columns to quote.  In both cases, row and column names are quoted if they are written. If 'FALSE', nothing is quoted. </p>
</td></tr>
<tr><td><code id="write.delim_+3A_sep">sep</code></td>
<td>
<p> the field separator string.  Values within each row of 'x' are separated by this string. </p>
</td></tr>
<tr><td><code id="write.delim_+3A_...">...</code></td>
<td>
<p> additional arguments accepted by write.table </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple wrapper of write.table.
</p>


<h3>Value</h3>

<p>A tab delimited text file.
</p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+write.table">write.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> data(preybiom)
 write.delim(preybiom[1:10,]) # output to the console
 
## Not run: 
 write.delim(preybiom[1:10,],file="Myfile.txt") # write a file in the working directory

## End(Not run)
 </code></pre>

<hr>
<h2 id='writecn.delim'> Write a data.frame that has Chinese characters</h2><span id='topic+writecn.delim'></span>

<h3>Description</h3>

<p>Handle a data.frame with Chinese characters and write it into a UTF-8 text file with header, no row.names, tab delimited fields. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writecn.delim(db, file = "",row.names = FALSE, quote = FALSE, sep = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writecn.delim_+3A_db">db</code></td>
<td>
<p> a data.frame </p>
</td></tr>
<tr><td><code id="writecn.delim_+3A_file">file</code></td>
<td>
<p> file name (character string)</p>
</td></tr>
<tr><td><code id="writecn.delim_+3A_row.names">row.names</code></td>
<td>
<p> either a logical value indicating whether the row names of 'x' are to be written along with 'x', or a character vector of row names to be written </p>
</td></tr>
<tr><td><code id="writecn.delim_+3A_quote">quote</code></td>
<td>
<p> a logical value or a numeric vector.  If 'TRUE', any character or factor columns will be surrounded by double quotes.  If a numeric vector, its elements are taken as the indices of the columns to quote.  In both cases, row and column names are quoted if they are written. If 'FALSE', nothing is quoted. </p>
</td></tr>
<tr><td><code id="writecn.delim_+3A_sep">sep</code></td>
<td>
<p> the field separator string.  Values within each row of 'x' are separated by this string. </p>
</td></tr>
<tr><td><code id="writecn.delim_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="utils.html#topic+write.table">write.table</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writing a data.frame into text files can be quite cumbersome if the system locale is not Chinese. This function set up the locale to Chinese, write the data.frame using <code><a href="utils.html#topic+write.table">write.table</a></code> with fileEncoding = &quot;UTF-8&quot;, then restore the original locale.
</p>


<h3>Value</h3>

<p>An ascii text file, tab delimited.
</p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+write.table">write.table</a></code>, <code><a href="base.html#topic+Sys.setlocale">Sys.setlocale</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
