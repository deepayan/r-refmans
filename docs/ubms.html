<!DOCTYPE html><html><head><title>Help for package ubms</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ubms}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[,ubmsFit,character,missing,missing-method'><p>Extract a Submodel from a ubmsFit Model</p></a></li>
<li><a href='#[,ubmsSubmodelList,character,missing,missing-method'><p>Extract a ubmsSubmodel From a ubmsSubmodelList Object</p></a></li>
<li><a href='#coef,ubmsFit-method'><p>Extract Coefficient Values From a ubmsFit Model</p></a></li>
<li><a href='#extract_log_lik'><p>Extract Pointwise Log-likelihood From Model</p></a></li>
<li><a href='#extract,ubmsFit-method'><p>Extract Samples From a ubmsFit Model</p></a></li>
<li><a href='#fitList,ubmsFit-method'><p>Create a List of ubmsFit Models</p></a></li>
<li><a href='#fitted,ubmsFit-method'><p>Extract Fitted Values</p></a></li>
<li><a href='#get_elapsed_time,ubmsFit-method'><p>Get Model Runtime</p></a></li>
<li><a href='#get_stancode,ubmsFit-method'><p>Get Stan Code From Model</p></a></li>
<li><a href='#getY,ubmsFit-method'><p>Extract y, the Response Variable, From a ubmsFit Model</p></a></li>
<li><a href='#gof'><p>Check model goodness-of-fit</p></a></li>
<li><a href='#kfold,ubmsFit-method'><p>K-fold Cross-validation of a ubmsFit Model</p></a></li>
<li><a href='#loo,ubmsFit-method'><p>Leave-one-out Cross Validation</p></a></li>
<li><a href='#modSel,ubmsFitList-method'><p>Model Selection For a List of ubmsFit Models</p></a></li>
<li><a href='#names,ubmsFit-method'><p>Get Parameter Names From a ubmsFit Model</p></a></li>
<li><a href='#names,ubmsFitList-method'><p>Get Names of Models in a ubmsFitList</p></a></li>
<li><a href='#nsamples,ubmsFit-method'><p>Get number of Posterior Samples Stored in a ubmsFit Model</p></a></li>
<li><a href='#plot_effects,ubmsFit-method'><p>Plot Marginal Effects of Covariates</p></a></li>
<li><a href='#plot_posteriors,ubmsFit-method'><p>Plot Posterior Distributions</p></a></li>
<li><a href='#plot_residuals,ubmsFit-method'><p>Plot Model Residuals</p></a></li>
<li><a href='#plot_spatial'><p>Plot A Map of the State Parameter Based on a Spatial ubms Model</p></a></li>
<li><a href='#plot,ubmsFit,ANY-method'><p>Plot Residuals For All Submodels in a ubmsFit Model</p></a></li>
<li><a href='#posterior_linpred,ubmsFit-method'><p>Posterior Distribution of the Linear Predictor</p></a></li>
<li><a href='#posterior_predict,ubmsFit-method'><p>Draw from the posterior predictive distribution</p></a></li>
<li><a href='#predict,ubmsFit-method'><p>Predict parameter values from a fitted model</p></a></li>
<li><a href='#priors'><p>Prior distributions</p></a></li>
<li><a href='#projected'><p>Projected Occupancy Trajectories</p></a></li>
<li><a href='#ranef,ubmsFit-method'><p>Extract Random Effects</p></a></li>
<li><a href='#residuals,ubmsFit-method'><p>Extract Model Residuals</p></a></li>
<li><a href='#RSR'><p>Get Information for a Restricted Spatial Regression Model</p></a></li>
<li><a href='#stan_colext'><p>Fit the MacKenzie et al. (2003) Dynamic Occupancy Model</p></a></li>
<li><a href='#stan_distsamp'><p>Fit the Royle et al. (2004) Distance Sampling Model</p></a></li>
<li><a href='#stan_multinomPois'><p>Fit the Multinomial-Poisson Mixture Model</p></a></li>
<li><a href='#stan_occu'><p>Fit the MacKenzie et al. (2002) Occupancy Model</p></a></li>
<li><a href='#stan_occuRN'><p>Fit the Occupancy Model of Royle and Nichols (2003)</p></a></li>
<li><a href='#stan_occuTTD'><p>Fit Time-to-detection Occupancy Models</p></a></li>
<li><a href='#stan_pcount'><p>Fit the N-mixture model of Royle (2004)</p></a></li>
<li><a href='#summary,ubmsFit-method'><p>Extract Summary Statistics from a ubmsFit Model</p></a></li>
<li><a href='#traceplot,ubmsFit-method'><p>Markov Chain Traceplots</p></a></li>
<li><a href='#turnover'><p>Turnover Probability</p></a></li>
<li><a href='#ubms'><p>ubms</p></a></li>
<li><a href='#ubmsFitList-extractors'><p>Extractors for ubmsFitList objects</p>
Extract parts of ubmsFitList objects.</a></li>
<li><a href='#waic,ubmsFit-method'><p>Widely Applicable Information Criterion (WAIC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Models for Data from Unmarked Animals using 'Stan'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), unmarked</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 2.0.0), gridExtra, lme4, loo, Matrix (&ge; 1.5-0),
methods, pbapply, Rcpp (&ge; 0.12.0), rlang, RSpectra, rstan (&ge;
2.26.0), rstantools (&ge; 2.0.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, devtools, knitr, pkgdown, raster, rmarkdown, roxygen2,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian hierarchical models of animal abundance and occurrence
    via the 'rstan' package, the R interface to the 'Stan' C++ library.
    Supported models include single-season occupancy, dynamic occupancy, and
    N-mixture abundance models. Covariates on model parameters are specified
    using a formula-based interface similar to package 'unmarked', while also
    allowing for estimation of random slope and intercept terms. References:
    Carpenter et al. (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i01">doi:10.18637/jss.v076.i01</a>&gt;;
    Fiske and Chandler (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v043.i10">doi:10.18637/jss.v043.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kenkellner.com/ubms/">https://kenkellner.com/ubms/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kenkellner/ubms/issues">https://github.com/kenkellner/ubms/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppArmadillo (&ge;
0.9.300.2.0), RcppEigen (&ge; 0.3.3.3.0), rstan (&ge; 2.26.0),
StanHeaders (&ge; 2.26.0), RcppParallel (&ge; 5.0.2)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'submodel.R' 'response.R' 'inputs.R' 'fit.R'
'posterior_predict.R' 'posterior_linpred.R' 'fitted.R' 'gof.R'
'occu.R' 'colext.R' 'missing.R' 'distsamp.R' 'fitlist.R'
'kfold.R' 'occuTTD.R' 'multinomPois.R' 'occuRN.R' 'pcount.R'
'loglik.R' 'mb_chisq.R' 'plot_effects.R' 'plot_posteriors.R'
'predict.R' 'priors.R' 'ranef.R' 'residuals.R' 'spatial.R'
'stanmodels.R' 'test-helpers.R' 'ubms-package.R'
'ubmsFit-methods.R' 'ubmsFitList-methods.R' 'umf.R' 'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 16:01:30 UTC; ken</td>
</tr>
<tr>
<td>Author:</td>
<td>Ken Kellner [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ken Kellner &lt;contact@kenkellner.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+2CubmsFit+2Ccharacter+2Cmissing+2Cmissing-method'>Extract a Submodel from a ubmsFit Model</h2><span id='topic++5B+2CubmsFit+2Ccharacter+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extract a Submodel from a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit,character,missing,missing'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CubmsFit+2B2Ccharacter+2B2Cmissing+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CubmsFit+2B2Ccharacter+2B2Cmissing+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>The name of a submodel to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ubmsSubmodel</code>.
</p>

<hr>
<h2 id='+5B+2CubmsSubmodelList+2Ccharacter+2Cmissing+2Cmissing-method'>Extract a ubmsSubmodel From a ubmsSubmodelList Object</h2><span id='topic++5B+2CubmsSubmodelList+2Ccharacter+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extract a ubmsSubmodel From a ubmsSubmodelList Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsSubmodelList,character,missing,missing'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CubmsSubmodelList+2B2Ccharacter+2B2Cmissing+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>Object of class <code>ubmsSubmodelList</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B2CubmsSubmodelList+2B2Ccharacter+2B2Cmissing+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>The name of a submodel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ubmsSubmodel</code>.
</p>

<hr>
<h2 id='coef+2CubmsFit-method'>Extract Coefficient Values From a ubmsFit Model</h2><span id='topic+coef+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Extract Coefficient Values From a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="coef+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of coefficient values for all submodels.
</p>

<hr>
<h2 id='extract_log_lik'>Extract Pointwise Log-likelihood From Model</h2><span id='topic+extract_log_lik'></span><span id='topic+extract_log_lik+2CubmsFit-method'></span><span id='topic+extract_log_lik+2CubmsFitDistsamp-method'></span>

<h3>Description</h3>

<p>Extracts the pointwise log-likelihood matrix or array from a model.
This is useful as an input for functions in the <code>loo</code> package.
If called on a <code>ubmsFit</code> object, the log-likelihood matrix or array
is calculated using the posterior distributions of the parameters; the
log-likelihood values are not actually saved inside the model object.
If called on a <code>stanfit</code> object, <code>loo::extract_log_lik</code> is used.
In this case, the log-likelihood must be saved as one of the output
parameters in Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_log_lik(object, parameter_name = "log_lik", merge_chains = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_log_lik_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> or <code>stanfit</code> object</p>
</td></tr>
<tr><td><code id="extract_log_lik_+3A_parameter_name">parameter_name</code></td>
<td>
<p>The name of the log-likelihood parameter in the
Stan output; ignored when <code>object</code> is a <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="extract_log_lik_+3A_merge_chains">merge_chains</code></td>
<td>
<p>If <code>TRUE</code> (the default), all Markov chains are
merged together (i.e., stacked) and a matrix is returned. If ‘FALSE’
they are kept separate and an array is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (samples x sites) or array (samples x chains x sites)
</p>

<hr>
<h2 id='extract+2CubmsFit-method'>Extract Samples From a ubmsFit Model</h2><span id='topic+extract+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Extract samples from a <code>ubmsFit</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
extract(object, pars, permuted = TRUE, inc_warmup = FALSE, include = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> object</p>
</td></tr>
<tr><td><code id="extract+2B2CubmsFit-method_+3A_pars">pars</code></td>
<td>
<p>An optional character vector providing parameter
names of interest. If not specified, all parameters are used</p>
</td></tr>
<tr><td><code id="extract+2B2CubmsFit-method_+3A_permuted">permuted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, draws are permuted
and merged; if <code>FALSE</code>, the original order is kept</p>
</td></tr>
<tr><td><code id="extract+2B2CubmsFit-method_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Logical. If <code>TRUE</code>, warmup iterations
are included; if <code>FALSE</code> they are discarded.</p>
</td></tr>
<tr><td><code id="extract+2B2CubmsFit-method_+3A_include">include</code></td>
<td>
<p>Logical. If <code>TRUE</code> provided parameter names
in <code>pars</code> are kept; if <code>FALSE</code> they are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>permuted=TRUE</code>, a list; if <code>permuted=FALSE</code>,
an array.
</p>

<hr>
<h2 id='fitList+2CubmsFit-method'>Create a List of ubmsFit Models</h2><span id='topic+fitList+2CubmsFit-method'></span><span id='topic+fitList'></span><span id='topic+fitList+2Clist-method'></span>

<h3>Description</h3>

<p>Create a list of ubmsFit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
fitList(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitList+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p><code>ubmsFit</code> model objects, preferably named, or a list
of such models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ubmsFitList</code> containing the list of models
</p>

<hr>
<h2 id='fitted+2CubmsFit-method'>Extract Fitted Values</h2><span id='topic+fitted+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Extract fitted values for a given submodel from a <code>ubmsFit</code> object.
Fitted values are calculated separately for each submodel
using the posterior predictive distribution of the latent state z,
following Wright et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
fitted(object, submodel, draws = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="fitted+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>Submodel to get fitted values for, options are <code>"state"</code>
or <code>"det"</code></p>
</td></tr>
<tr><td><code id="fitted+2B2CubmsFit-method_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of draws to return. The
default and maximum number of draws is the size of the posterior sample.</p>
</td></tr>
<tr><td><code id="fitted+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of fitted values with dimension <code>draws</code> by
observations. Note that calculation of fitted values
for the detection submodel is conditional on <code class="reqn">z &gt; 0</code>, so fitted values
for an observation in a posterior draw where <code class="reqn">z = 0</code> are assigned
value <code>NA</code> (Wright et al. 2019).
</p>


<h3>References</h3>

<p>Wright, W. J., Irvine, K. M., &amp; Higgs, M. D. (2019). Identifying
occupancy model inadequacies: can residuals separately assess detection
and presence? Ecology, 100(6), e02703.
</p>

<hr>
<h2 id='get_elapsed_time+2CubmsFit-method'>Get Model Runtime</h2><span id='topic+get_elapsed_time+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Get warmup and sampling time from a <code>ubmsFit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
get_elapsed_time(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_elapsed_time+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> object</p>
</td></tr>
<tr><td><code id="get_elapsed_time+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>rstan::get_elapsed_time</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one row per chain and two columns, containing
the warmup time and sampling time, respectively, in seconds
</p>

<hr>
<h2 id='get_stancode+2CubmsFit-method'>Get Stan Code From Model</h2><span id='topic+get_stancode+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Get the Stan code used to run a model as a character string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
get_stancode(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stancode+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> object</p>
</td></tr>
<tr><td><code id="get_stancode+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>rstan::get_stancode</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pass the result of <code>get_stancode</code> to <code>cat</code> to get the
code in a more readable format. Note that the output in most cases
is Stan code that can be used to fit several types of models, and not
all Stan code will be used in all models.
</p>


<h3>Value</h3>

<p>A character string with the model code
</p>

<hr>
<h2 id='getY+2CubmsFit-method'>Extract y, the Response Variable, From a ubmsFit Model</h2><span id='topic+getY+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Extract y, the Response Variable, From a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
getY(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getY+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the response variable <code>y</code>.
</p>

<hr>
<h2 id='gof'>Check model goodness-of-fit</h2><span id='topic+gof'></span><span id='topic+plot+2CubmsGOF+2CANY-method'></span><span id='topic+gof+2CubmsFitOccu-method'></span><span id='topic+gof+2CubmsFitAbun-method'></span>

<h3>Description</h3>

<p>Goodness-of-fit tests for <code>ubmsFit</code> models using posterior predictive
checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, draws = NULL, ...)

## S4 method for signature 'ubmsFitOccu'
gof(object, draws = NULL, quiet = FALSE, ...)

## S4 method for signature 'ubmsFitAbun'
gof(object, draws = NULL, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="gof_+3A_draws">draws</code></td>
<td>
<p>Number of draws from the posterior to use in the check</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="gof_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ubmsGOF</code> containing statistics calculated
from the posterior predictive distribution.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gof(ubmsFitOccu)</code>: Applies the MacKenzie-Bailey chi-square goodness of fit test for
ocupancy models (MacKenzie and Bailey 2004).
</p>
</li>
<li> <p><code>gof(ubmsFitAbun)</code>: A goodness-of-fit test for N-mixture type models based on Pearson's chi-square.
</p>
</li></ul>


<h3>References</h3>

<p>MacKenzie, D. I., &amp; Bailey, L. L. (2004). Assessing the
fit of site-occupancy models. Journal of Agricultural, Biological,
and Environmental Statistics, 9(3), 300-318.
</p>

<hr>
<h2 id='kfold+2CubmsFit-method'>K-fold Cross-validation of a ubmsFit Model</h2><span id='topic+kfold+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Randomly partition data into K subsets of equal size (by site). Re-fit the model
K times, each time leaving out one of the subsets. Calculate the log-likelihood
for each of the sites that was left out. This function is an alternative
to <code>loo</code> (leave-one-out cross validation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
kfold(x, K = 10, folds = NULL, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold+2B2CubmsFit-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="kfold+2B2CubmsFit-method_+3A_k">K</code></td>
<td>
<p>Number of folds into which the data will be partitioned</p>
</td></tr>
<tr><td><code id="kfold+2B2CubmsFit-method_+3A_folds">folds</code></td>
<td>
<p>An optional vector with length equal to the number of sites in the data and containing integers from 1 to K, to manually assign sites to folds. You should use this if you plan to compare multiple models, since the folds for each model should be identical. You can use <code>loo::kfold_split_random</code> to generate this vector</p>
</td></tr>
<tr><td><code id="kfold+2B2CubmsFit-method_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress progress bar</p>
</td></tr>
<tr><td><code id="kfold+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>elpd_generic</code> that is compatible with <code>loo::loo_compare</code>
</p>

<hr>
<h2 id='loo+2CubmsFit-method'>Leave-one-out Cross Validation</h2><span id='topic+loo+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Leave-one-out Cross Validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
loo(x, ..., cores = getOption("mc.cores", 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo+2B2CubmsFit-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="loo+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="loo+2B2CubmsFit-method_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class <code>loo</code> with estimates of
the expected log predictive density and other parameters used
for model comparison. See <code>?loo::loo</code> for more information.
</p>

<hr>
<h2 id='modSel+2CubmsFitList-method'>Model Selection For a List of ubmsFit Models</h2><span id='topic+modSel+2CubmsFitList-method'></span>

<h3>Description</h3>

<p>Construct a model selection table from a <code>ubmsFitList</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFitList'
modSel(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modSel+2B2CubmsFitList-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>ubmsFitList</code></p>
</td></tr>
<tr><td><code id="modSel+2B2CubmsFitList-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of model fit information with one row per
model in the input <code>ubmsFitList</code>. Models are ranked in descending
order by expected log pointwise predictive density (<code>elpd</code>).
</p>


<h3>See Also</h3>

<p><code><a href="loo.html#topic+loo">loo</a></code>, <code><a href="loo.html#topic+loo_compare">loo_compare</a></code>
</p>

<hr>
<h2 id='names+2CubmsFit-method'>Get Parameter Names From a ubmsFit Model</h2><span id='topic+names+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Get Parameter Names From a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2CubmsFit-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parameter names.
</p>

<hr>
<h2 id='names+2CubmsFitList-method'>Get Names of Models in a ubmsFitList</h2><span id='topic+names+2CubmsFitList-method'></span>

<h3>Description</h3>

<p>Get Names of Models in a ubmsFitList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFitList'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2CubmsFitList-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFitList</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of model names.
</p>

<hr>
<h2 id='nsamples+2CubmsFit-method'>Get number of Posterior Samples Stored in a ubmsFit Model</h2><span id='topic+nsamples+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Get number of Posterior Samples Stored in a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
nsamples(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsamples+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="nsamples+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer representing the number of posterior samples
</p>

<hr>
<h2 id='plot_effects+2CubmsFit-method'>Plot Marginal Effects of Covariates</h2><span id='topic+plot_effects+2CubmsFit-method'></span><span id='topic+plot_effects'></span><span id='topic+plot_marginal'></span><span id='topic+plot_marginal+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Generates marginal fixed effects plots of one or more covariates from a
<code>ubmsFit</code> submodel. For each plot, the focal covariate is allowed to
vary across its range (or possible discrete values, for a factor), while
the other covariates are held at their medians or reference levels.
Random effects are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
plot_effects(
  object,
  submodel,
  covariate = NULL,
  level = 0.95,
  draws = 1000,
  smooth = NULL,
  ...
)

## S4 method for signature 'ubmsFit'
plot_marginal(
  object,
  submodel,
  covariate = NULL,
  level = 0.95,
  draws = 1000,
  smooth = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>Submodel to get plots for, for example <code>"det"</code></p>
</td></tr>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_covariate">covariate</code></td>
<td>
<p>Plot a specific covariate; provide the name as a string</p>
</td></tr>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_level">level</code></td>
<td>
<p>Probability mass to include in the uncertainty interval</p>
</td></tr>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_draws">draws</code></td>
<td>
<p>Number of draws from the posterior to use when generating the
plots. If fewer than <code>draws</code> are available, they are all used</p>
</td></tr>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_smooth">smooth</code></td>
<td>
<p>Smoother span (f) value used for LOWESS smoothing of the
upper and lower credible interval bounds for a continuous covariate.
No smoothing is done if <code>NULL</code>. A reasonable value to try is 0.05.
The larger the value, the smoother the curve. As with all smoothing, use
with caution</p>
</td></tr>
<tr><td><code id="plot_effects+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> if a single covariate is plotted, or an object
of class <code>grob</code> if there are multiple covariates/panels
</p>

<hr>
<h2 id='plot_posteriors+2CubmsFit-method'>Plot Posterior Distributions</h2><span id='topic+plot_posteriors+2CubmsFit-method'></span><span id='topic+plot_posteriors'></span>

<h3>Description</h3>

<p>Plot posterior distributions for selected parameters. Posteriors can be
represented as density plots or histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
plot_posteriors(object, pars = NULL, density = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_posteriors+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="plot_posteriors+2B2CubmsFit-method_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names to include in the plot
Look at <code>names(object@stanfit)</code> for the complete list of possible
parameter names. If <code>NULL</code>, posteriors are shown for all parameters
in the model summary output</p>
</td></tr>
<tr><td><code id="plot_posteriors+2B2CubmsFit-method_+3A_density">density</code></td>
<td>
<p>If <code>TRUE</code>, show posteriors as density plots (one per
chain). If <code>FALSE</code>, show posteriors as histograms of samples from
all chains combined</p>
</td></tr>
<tr><td><code id="plot_posteriors+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>ggplot2::stat_density</code> for density
plots, or <code>ggplot2::geom_histogram</code> for histograms. For example, you
can supply argument <code>bins</code> to control the number of histogram bins</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code>
</p>

<hr>
<h2 id='plot_residuals+2CubmsFit-method'>Plot Model Residuals</h2><span id='topic+plot_residuals+2CubmsFit-method'></span><span id='topic+plot_residuals'></span>

<h3>Description</h3>

<p>Plot residuals for a submodel from a <code>ubmsFit</code> object, for multiple
posterior draws. By default, residuals are plotted against fitted values.
When the submodel has a binomial response (e.g., detection models), regular
residual plots are not typically informative. Instead, the residuals and
fitted values are divided into bins based on fitted value and the averages
are plotted. For a count response (e.g., Poisson), Pearson residuals are
calculated. To plot residuals against values of a particular covariate instead
of the fitted values, supply the name of the covariate (as a string) to the
<code>covariate</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
plot_residuals(
  object,
  submodel,
  covariate = NULL,
  draws = 9,
  nbins = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_residuals+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="plot_residuals+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>Submodel to plot residuals for, for example <code>"det"</code></p>
</td></tr>
<tr><td><code id="plot_residuals+2B2CubmsFit-method_+3A_covariate">covariate</code></td>
<td>
<p>If specified, plot residuals against values of a covariate.
Covariate name should be provided as a string. If <code>NULL</code>,
residuals are plotted against predicted values.</p>
</td></tr>
<tr><td><code id="plot_residuals+2B2CubmsFit-method_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of posterior draws to use.
Separate plots are generated for each draw, so this number should be
relatively small. The default and maximum number of draws is the size of
the posterior sample.</p>
</td></tr>
<tr><td><code id="plot_residuals+2B2CubmsFit-method_+3A_nbins">nbins</code></td>
<td>
<p>For submodels with a binomial response, manually set the number
of bins to use</p>
</td></tr>
<tr><td><code id="plot_residuals+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> of residuals vs. fitted values or covariate values,
with one panel per posterior draw. For binned residual plots, the shaded area
represents plus/minus two standard deviations around the mean residual.
If the model is true, we would expect about 95
fall within this area.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>
</p>

<hr>
<h2 id='plot_spatial'>Plot A Map of the State Parameter Based on a Spatial ubms Model</h2><span id='topic+plot_spatial'></span>

<h3>Description</h3>

<p>Plot A Map of the State Parameter Based on a Spatial ubms Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spatial(object, param = c("state", "eta"), sites = TRUE, cell_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spatial_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> model with a spatial random effect</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_param">param</code></td>
<td>
<p>The parameter to plot, either <code>"state"</code> for, e.g.,
mean occupancy or abundance, or <code>"eta"</code> for the random effect itself</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_sites">sites</code></td>
<td>
<p>If <code>TRUE</code>, also plot the locations of sites that
were sampled on the map and if had a detection of the species</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_cell_size">cell_size</code></td>
<td>
<p>The size of each side of the (square) cells drawn in the map,
in the same units as the coordinates. If <code>NULL</code>, <code>ubms</code> will try
to pick a reasonable cell size for you</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CubmsFit+2CANY-method'>Plot Residuals For All Submodels in a ubmsFit Model</h2><span id='topic+plot+2CubmsFit+2CANY-method'></span>

<h3>Description</h3>

<p>Plot Residuals For All Submodels in a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CubmsFit+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="plot+2B2CubmsFit+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="plot+2B2CubmsFit+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object of class <code>gtable</code> with one panel per submodel.
</p>

<hr>
<h2 id='posterior_linpred+2CubmsFit-method'>Posterior Distribution of the Linear Predictor</h2><span id='topic+posterior_linpred+2CubmsFit-method'></span><span id='topic+posterior_linpred'></span>

<h3>Description</h3>

<p>Extract posterior draws of the linear predictor for a <code>ubmsFit</code>
submodel, possibly transformed by the inverse-link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
posterior_linpred(
  object,
  transform = FALSE,
  submodel,
  newdata = NULL,
  draws = NULL,
  re.form = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_transform">transform</code></td>
<td>
<p>Should the linear predictor be transformed using the
inverse link function?</p>
</td></tr>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>The name of the submodel, as a character string, for
which to calculate the linear predictor</p>
</td></tr>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame of newdata to use when calculating the linear
predictor. If not provided, the model matrix is used.</p>
</td></tr>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of draws to return. The
default and maximum number of draws is the size of the posterior sample.</p>
</td></tr>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_re.form">re.form</code></td>
<td>
<p>If <code>NULL</code>, any estimated group-level parameters (&quot;random
effects&quot;) are included. If <code>NA</code>, they are ignored</p>
</td></tr>
<tr><td><code id="posterior_linpred+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulations from the posterior predictive distribution
of the linear predictor. The dimensions are <code>draws</code> by number of
linear predictor values (e.g., number of sites or number of observations).
</p>

<hr>
<h2 id='posterior_predict+2CubmsFit-method'>Draw from the posterior predictive distribution</h2><span id='topic+posterior_predict+2CubmsFit-method'></span><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Draw from the posterior predictive distribution after fitting a model.
You can draw from the posterior of the observed outcome <code class="reqn">y</code> or
the latent unobserved state <code class="reqn">z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
posterior_predict(
  object,
  param = c("y", "z"),
  draws = NULL,
  re.form = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="posterior_predict+2B2CubmsFit-method_+3A_param">param</code></td>
<td>
<p>Either <code>"y"</code> for the observed outcome or <code>"z"</code>
for the unobserved latent state</p>
</td></tr>
<tr><td><code id="posterior_predict+2B2CubmsFit-method_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of draws to return. The
default and maximum number of draws is the size of the posterior sample.</p>
</td></tr>
<tr><td><code id="posterior_predict+2B2CubmsFit-method_+3A_re.form">re.form</code></td>
<td>
<p>If <code>NULL</code>, any estimated group-level parameters (&quot;random
effects&quot;) are included. If <code>NA</code>, they are ignored</p>
</td></tr>
<tr><td><code id="posterior_predict+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of simulations from the posterior predictive distribution.
If <code>param = "z"</code>, the dimensions are <code>draws</code> by number of sites
(or sites x primary periods in site-major order for dynamic models). If
<code>param = "y"</code>, the dimensions are <code>draws</code> by sites x observations
(or sites x primary periods x observations for dynamic models).
</p>

<hr>
<h2 id='predict+2CubmsFit-method'>Predict parameter values from a fitted model</h2><span id='topic+predict+2CubmsFit-method'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>This method generates predicted parameter values for the original dataset
or a new dataset using the posterior distribution. Standard deviation and
a customizable uncertainty interval are also calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
predict(
  object,
  submodel,
  newdata = NULL,
  transform = TRUE,
  re.form = NULL,
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>Submodel to predict from, for example <code>"det"</code></p>
</td></tr>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame or RasterStack of covariates to generate
predictions from. If not provided (the default), predictions are
generated from the original data</p>
</td></tr>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_transform">transform</code></td>
<td>
<p>If <code>TRUE</code>, back-transform the predictions to their
original scale</p>
</td></tr>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_re.form">re.form</code></td>
<td>
<p>If <code>NULL</code>, any estimated group-level parameters (&quot;random
effects&quot;) are included. If <code>NA</code>, they are ignored</p>
</td></tr>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_level">level</code></td>
<td>
<p>Probability mass to include in the uncertainty interval</p>
</td></tr>
<tr><td><code id="predict+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>newdata</code> was a data frame: A data frame with one row per
prediction and four columns:
1) Predicted point estimates (posterior means),
2) Standard deviation of the posterior,
3-4) Lower and upper bounds of the specified uncertainty interval
</p>
<p>For parameters with more than one dimension, the rows are in site-major
order, or site-year-observation for dynamic models.
</p>
<p>If <code>newdata</code> was a RasterStack, returns a RasterStack with four
layers corresponding to the four columns above with the same projection
as the original RasterStack.
</p>


<h3>See Also</h3>

<p>posterior_linpred, posterior_interval
</p>

<hr>
<h2 id='priors'>Prior distributions</h2><span id='topic+priors'></span><span id='topic+normal'></span><span id='topic+uniform'></span><span id='topic+student_t'></span><span id='topic+logistic'></span><span id='topic+cauchy'></span><span id='topic+gamma'></span><span id='topic+laplace'></span>

<h3>Description</h3>

<p>Specify prior distributions and associated parameters for use in
<code>ubms</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(location = 0, scale = 2.5, autoscale = TRUE)

uniform(lower = -5, upper = 5)

student_t(df = 1, location = 0, scale = 2.5, autoscale = TRUE)

logistic(location = 0, scale = 1)

cauchy(location = 0, scale = 2.5, autoscale = TRUE)

gamma(shape = 1, rate = 1)

laplace(location = 0, scale = 2.5, autoscale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>The mean of the distribution. If setting the priors for
regression coefficients, this can be a single value, or multiple values,
one per coefficient</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>The standard deviation of the distribution. If setting the priors
for regression coefficients, this can be a single value, or multiple values,
one per coefficient</p>
</td></tr>
<tr><td><code id="priors_+3A_autoscale">autoscale</code></td>
<td>
<p>If <code>TRUE</code>, ubms will automatically adjust priors
for each regression coefficient relative to its corresponding covariate x.
Specifically, the prior for a given coefficient will be divided by
sd(x). This helps account for covariates with very different magnitudes
in the same model. If your data are already standardized (e.g. with use of
<code>scale()</code>), this will have minimal effect as sd(x) will be
approximately 1. Standardizing your covariates is highly recommended.</p>
</td></tr>
<tr><td><code id="priors_+3A_lower">lower</code></td>
<td>
<p>The lower bound for the uniform distribution</p>
</td></tr>
<tr><td><code id="priors_+3A_upper">upper</code></td>
<td>
<p>The upper bound for the uniform distribution</p>
</td></tr>
<tr><td><code id="priors_+3A_df">df</code></td>
<td>
<p>The number of degrees of freedom for the Student-t distribution</p>
</td></tr>
<tr><td><code id="priors_+3A_shape">shape</code></td>
<td>
<p>The gamma distribution shape parameter</p>
</td></tr>
<tr><td><code id="priors_+3A_rate">rate</code></td>
<td>
<p>The gamma distribution rate parameter (1/scale)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing prior settings used internally by <code>ubms</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normal()

</code></pre>

<hr>
<h2 id='projected'>Projected Occupancy Trajectories</h2><span id='topic+projected'></span><span id='topic+projected+2CubmsFitColext-method'></span>

<h3>Description</h3>

<p>Generate posterior draws of occupancy probability for all sites and primary
periods, i.e. the projected trajectory (Weir et al. 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projected(object, ...)

## S4 method for signature 'ubmsFitColext'
projected(object, draws = NULL, re.form = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projected_+3A_object">object</code></td>
<td>
<p>A fitted dynamic occupancy model of class inheriting <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="projected_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="projected_+3A_draws">draws</code></td>
<td>
<p>Number of draws from the posterior to use in the check</p>
</td></tr>
<tr><td><code id="projected_+3A_re.form">re.form</code></td>
<td>
<p>If <code>NULL</code>, any estimated group-level parameters (&quot;random
effects&quot;) are included. If <code>NA</code>, they are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of occupancy values from the posterior predictive distribution.
The dimensions are <code>draws</code> by number of sites x primary periods
in site-major order.
</p>


<h3>References</h3>

<p>Weir LA, Fiske IJ, Royle J. 2009. Trends in Anuran
Occupancy from Northeastern States of the North American Amphibian
Monitoring Program. Herpetological Conservation and Biology.
4: 389-402.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_colext">stan_colext</a></code>
</p>

<hr>
<h2 id='ranef+2CubmsFit-method'>Extract Random Effects</h2><span id='topic+ranef+2CubmsFit-method'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Extract random effects from a <code>ubmsFit</code> model. Note that this function
works like <code>ranef</code> for <code>merMod</code> objects from <code>lme4</code>, not like
<code>ranef</code> for <code>unmarkedFit</code> objects. To get functionality similar
to that of <code>unmarkedFit</code>, use <code>posterior_predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
ranef(object, submodel, summary = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="ranef+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>The name of the submodel, as a character string, for
which to generate the random effects</p>
</td></tr>
<tr><td><code id="ranef+2B2CubmsFit-method_+3A_summary">summary</code></td>
<td>
<p>If <code>TRUE</code>, calculate mean, SD, and 95
for each random effect term</p>
</td></tr>
<tr><td><code id="ranef+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>summary=FALSE</code>, a list of random effect values; if
<code>TRUE</code>, a data frame with columns for random effect mean, SD, and
95
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+ranef">ranef</a></code>, <code><a href="#topic+posterior_predict">posterior_predict</a></code>
</p>

<hr>
<h2 id='residuals+2CubmsFit-method'>Extract Model Residuals</h2><span id='topic+residuals+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Extract residuals for a given submodel from a <code>ubmsFit</code> object.
Residuals are calculated separately for each submodel
using the posterior predictive distribution of the latent state z,
following Wright et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
residuals(object, submodel, draws = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A fitted model of class <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="residuals+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>Submodel to get residuals for, for example <code>"det"</code></p>
</td></tr>
<tr><td><code id="residuals+2B2CubmsFit-method_+3A_draws">draws</code></td>
<td>
<p>An integer indicating the number of draws to return. The
default and maximum number of draws is the size of the posterior sample.</p>
</td></tr>
<tr><td><code id="residuals+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of residual values with dimension <code>draws</code> by
observations. Note that calculation of residuals
for the detection submodel is conditional on <code class="reqn">z &gt; 0</code>, so residuals
for an observation in a posterior draw where <code class="reqn">z = 0</code> are assigned
value <code>NA</code> (Wright et al. 2019).
</p>


<h3>References</h3>

<p>Wright, W. J., Irvine, K. M., &amp; Higgs, M. D. (2019). Identifying
occupancy model inadequacies: can residuals separately assess detection
and presence? Ecology, 100(6), e02703.
</p>

<hr>
<h2 id='RSR'>Get Information for a Restricted Spatial Regression Model</h2><span id='topic+RSR'></span>

<h3>Description</h3>

<p>A call to <code>RSR</code> in the formula for a state process adds an autocorrelated
spatial random effect to the model in the form of a Restricted Spatial
Regression (RSR). For examples of RSRs applied to ecological data, see
Johnson et al. (2013) and Broms et al. (2014).
The function can also be used outside a formula to visualize the spatial
relationships between sites in your data and choose an appropriate
distance threshold below which two sites will be considered neighbors, and
thus potentially correlated, for the RSR model. For more details, see the example vignette:
<code>vignette("spatial-models", package = "ubms")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSR(x, y = NULL, threshold, moran_cut = NULL, plot_site = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSR_+3A_x">x</code></td>
<td>
<p>A vector of coordinates (should be projected)</p>
</td></tr>
<tr><td><code id="RSR_+3A_y">y</code></td>
<td>
<p>An (optional) second vector of coordinates</p>
</td></tr>
<tr><td><code id="RSR_+3A_threshold">threshold</code></td>
<td>
<p>The distance cutoff below which two sites will be
considered neighbors. Should be the same units as the coordinates.</p>
</td></tr>
<tr><td><code id="RSR_+3A_moran_cut">moran_cut</code></td>
<td>
<p>The number of eigenvectors to use in the RSR. The possible
range of values is between 1 and the number of sites. Smaller numbers will
result in faster runtime and smoother map output, and vice-versa. If
not provided (the default), the number of eigenvectors will be set as
10% of the number of sites which is usually appropriate.</p>
</td></tr>
<tr><td><code id="RSR_+3A_plot_site">plot_site</code></td>
<td>
<p>If a site number (as an integer) is supplied, the function
returns a plot showing that site and its neighbors under the current settings.
Useful for deciding what to set your threshold at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list of spatial matrices used for the RSR (only useful
internally to ubms), or if <code>plot_site</code> is an integer, a <code>ggplot</code> object.
</p>


<h3>References</h3>

<p>Broms KM, Johnson DS, Altwegg R, Conquest LL. 2014. Spatial
occupancy models applied to atlas data show Southern Ground Hornbills strongly
depend on protected areas. Ecological Applications 24: 363-374.
</p>
<p>Johnson DS, Conn PB, Hooten MB, Ray JC, Pond BA. 2013. Spatial occupancy
models for large data sets. Ecology 94: 801-808.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates
x &lt;- runif(100,0,10)
y &lt;- runif(100,0,10)
# Show neighbors of site 10 when threshold is 3 units
RSR(x, y, threshold=3, plot_site=10)

</code></pre>

<hr>
<h2 id='stan_colext'>Fit the MacKenzie et al. (2003) Dynamic Occupancy Model</h2><span id='topic+stan_colext'></span>

<h3>Description</h3>

<p>This function fits the dynamic occupancy model of
MacKenzie et al. (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_colext(
  psiformula = ~1,
  gammaformula = ~1,
  epsilonformula = ~1,
  pformula = ~1,
  data,
  prior_intercept_psi = logistic(0, 1),
  prior_coef_psi = logistic(0, 1),
  prior_intercept_gamma = logistic(0, 1),
  prior_coef_gamma = logistic(0, 1),
  prior_intercept_eps = logistic(0, 1),
  prior_coef_eps = logistic(0, 1),
  prior_intercept_det = logistic(0, 1),
  prior_coef_det = logistic(0, 1),
  prior_sigma = gamma(1, 1),
  log_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_colext_+3A_psiformula">psiformula</code></td>
<td>
<p>Right-hand sided formula for the initial probability of
occupancy at each site</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_gammaformula">gammaformula</code></td>
<td>
<p>Right-hand sided formula for colonization probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_epsilonformula">epsilonformula</code></td>
<td>
<p>Right-hand sided formula for extinction probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_pformula">pformula</code></td>
<td>
<p>Right-hand sided formula for detection probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_data">data</code></td>
<td>
<p>A <code><a href="unmarked.html#topic+unmarkedMultFrame">unmarkedMultFrame</a></code> object</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_intercept_psi">prior_intercept_psi</code></td>
<td>
<p>Prior distribution for the intercept of the
psi (initial occupancy probability) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_coef_psi">prior_coef_psi</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the psi model</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_intercept_gamma">prior_intercept_gamma</code></td>
<td>
<p>Prior distribution on intercept for
colonization probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_coef_gamma">prior_coef_gamma</code></td>
<td>
<p>Prior distribution on regression coefficients for
colonization probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_intercept_eps">prior_intercept_eps</code></td>
<td>
<p>Prior distribution on intercept for
extinction probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_coef_eps">prior_coef_eps</code></td>
<td>
<p>Prior distribution on regression coefficients for
extinction probability</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
detection probability model</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the detection model</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_log_lik">log_lik</code></td>
<td>
<p>If <code>TRUE</code>, Stan will save pointwise log-likelihood values
in the output. This can greatly increase the size of the model. If
<code>FALSE</code>, the values are calculated post-hoc from the posteriors</p>
</td></tr>
<tr><td><code id="stan_colext_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitColext</code> object describing the model fit.
</p>


<h3>References</h3>

<p>MacKenzie DI, Nicholas JD, Hines JE, Knutson MG, Franklin AB.
2003. Ecology 84: 2200-2207.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+colext">colext</a></code>, <code><a href="unmarked.html#topic+unmarkedMultFrame">unmarkedMultFrame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(frogs)
umf &lt;- formatMult(masspcru)
umf@y[umf@y &gt; 1] &lt;- 1 #convert counts to presence/absence
umf &lt;- umf[1:100,] #Use only 100 sites

fit_frog &lt;- stan_colext(~1, ~1, ~1, ~1, umf, chains=3, iter=300)


</code></pre>

<hr>
<h2 id='stan_distsamp'>Fit the Royle et al. (2004) Distance Sampling Model</h2><span id='topic+stan_distsamp'></span>

<h3>Description</h3>

<p>This function fits the hierarchical distance sampling model of Royle
et al. (2004) to line or point transect data recorded in discerete
distance intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_distsamp(
  formula,
  data,
  keyfun = c("halfnorm", "exp", "hazard"),
  output = c("density", "abund"),
  unitsOut = c("ha", "kmsq"),
  prior_intercept_state = normal(0, 5),
  prior_coef_state = normal(0, 2.5),
  prior_intercept_det = normal(0, 5),
  prior_coef_det = normal(0, 2.5),
  prior_intercept_scale = normal(0, 2.5),
  prior_sigma = gamma(1, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_distsamp_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and occupancy in that order</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_data">data</code></td>
<td>
<p>A <code><a href="unmarked.html#topic+unmarkedFrameDS">unmarkedFrameDS</a></code> object</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_keyfun">keyfun</code></td>
<td>
<p>One of the following detection functions:
<code>"halfnorm"</code> for half-normal, <code>"exp"</code> for negative exponential,
or <code>"hazard"</code> for hazard-rate (see warning below)</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_output">output</code></td>
<td>
<p>Model either density <code>"density"</code> or abundance <code>"abund"</code></p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_unitsout">unitsOut</code></td>
<td>
<p>Units of density. Either <code>"ha"</code> or <code>"kmsq"</code> for
hectares and square kilometers, respectively</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_prior_intercept_state">prior_intercept_state</code></td>
<td>
<p>Prior distribution for the intercept of the
state (abundance) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_prior_coef_state">prior_coef_state</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the state model</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
detection probability model</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the detection model</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_prior_intercept_scale">prior_intercept_scale</code></td>
<td>
<p>Prior distribution for the intercept of the
scale parameter (i.e., log(scale)) for Hazard-rate models</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_distsamp_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitDistsamp</code> object describing the model fit.
</p>


<h3>Warning</h3>

<p>Use of the hazard-rate key function (<code>"hazard"</code>)
typically requires a large sample size in order to get good parameter
estimates. If you have a relatively small number of points/transects (&lt;100),
you should be cautious with the resulting models. Check your results against
estimates from <code>unmarked</code>, which doesn't require as much data to get
good estimates of the hazard-rate shape and scale parameters.
</p>


<h3>Note</h3>

<p>Values of 'dist.breaks' in the 'unmarkedFrameDS' should be as small
as possible (&lt;10) to facilitate convergence. Consider converting 'unitsIn' from
meters to kilometers, for example. See example below.
</p>


<h3>References</h3>

<p>Royle, J. A., Dawson, D. K., &amp; Bates, S. (2004). Modeling
abundance effects in distance sampling. Ecology 85: 1591-1597.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+distsamp">distsamp</a></code>, <code><a href="unmarked.html#topic+unmarkedFrameDS">unmarkedFrameDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(issj)
#Note use of km instead of m for distance breaks
jayUMF &lt;- unmarkedFrameDS(y=as.matrix(issj[,1:3]),
                          siteCovs=issj[,c("elevation","forest")],
                          dist.breaks=c(0,0.1,0.2,0.3),
                          unitsIn="km", survey="point")

fm_jay &lt;- stan_distsamp(~1~scale(elevation), jayUMF, chains=3, iter=300)


</code></pre>

<hr>
<h2 id='stan_multinomPois'>Fit the Multinomial-Poisson Mixture Model</h2><span id='topic+stan_multinomPois'></span>

<h3>Description</h3>

<p>This function fits the multinomial-Poisson mixture model, useful for
data collected via survey methods such as removal or double observer sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_multinomPois(
  formula,
  data,
  prior_intercept_state = normal(0, 5),
  prior_coef_state = normal(0, 2.5),
  prior_intercept_det = logistic(0, 1),
  prior_coef_det = logistic(0, 1),
  prior_sigma = gamma(1, 1),
  log_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_multinomPois_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and abundance in that order</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_data">data</code></td>
<td>
<p>A <code><a href="unmarked.html#topic+unmarkedFrameMPois">unmarkedFrameMPois</a></code> object</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_prior_intercept_state">prior_intercept_state</code></td>
<td>
<p>Prior distribution for the intercept of the
state (abundance) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_prior_coef_state">prior_coef_state</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the state model</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
detection probability model</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the detection model</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_log_lik">log_lik</code></td>
<td>
<p>If <code>TRUE</code>, Stan will save pointwise log-likelihood values
in the output. This can greatly increase the size of the model. If
<code>FALSE</code>, the values are calculated post-hoc from the posteriors</p>
</td></tr>
<tr><td><code id="stan_multinomPois_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitMultinomPois</code> object describing the model fit.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+multinomPois">multinomPois</a></code>, <code><a href="unmarked.html#topic+unmarkedFrameMPois">unmarkedFrameMPois</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ovendata)
ovenFrame &lt;- unmarkedFrameMPois(ovendata.list$data,
                                siteCovs=ovendata.list$covariates,
                                type="removal")

oven_fit &lt;- stan_multinomPois(~1~scale(ufc), ovenFrame, chains=3, iter=300)


</code></pre>

<hr>
<h2 id='stan_occu'>Fit the MacKenzie et al. (2002) Occupancy Model</h2><span id='topic+stan_occu'></span>

<h3>Description</h3>

<p>This function fits the single season occupancy model of
MacKenzie et al. (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_occu(
  formula,
  data,
  prior_intercept_state = logistic(0, 1),
  prior_coef_state = logistic(0, 1),
  prior_intercept_det = logistic(0, 1),
  prior_coef_det = logistic(0, 1),
  prior_sigma = gamma(1, 1),
  log_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_occu_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and occupancy in that order</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_data">data</code></td>
<td>
<p>A <code><a href="unmarked.html#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> object</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_prior_intercept_state">prior_intercept_state</code></td>
<td>
<p>Prior distribution for the intercept of the
state (occupancy probability) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_prior_coef_state">prior_coef_state</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the state model</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
detection probability model</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the detection model</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_log_lik">log_lik</code></td>
<td>
<p>If <code>TRUE</code>, Stan will save pointwise log-likelihood values
in the output. This can greatly increase the size of the model. If
<code>FALSE</code>, the values are calculated post-hoc from the posteriors</p>
</td></tr>
<tr><td><code id="stan_occu_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitOccu</code> object describing the model fit.
</p>


<h3>References</h3>

<p>MacKenzie DI, Nichols JD, Lachman GB, Droege S, Royle JA,
Langtimm CA. 2002. Estimating site occupancy rates when detection
probabilities are less than one. Ecology 83: 2248-2255.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+occu">occu</a></code>, <code><a href="unmarked.html#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(frogs)
pferUMF &lt;- unmarkedFrameOccu(pfer.bin)

#Add some covariates
siteCovs(pferUMF) &lt;- data.frame(cov1=rnorm(numSites(pferUMF)))

#Fit model
(fm &lt;- stan_occu(~1~cov1, pferUMF, chains=3, iter=300))


</code></pre>

<hr>
<h2 id='stan_occuRN'>Fit the Occupancy Model of Royle and Nichols (2003)</h2><span id='topic+stan_occuRN'></span>

<h3>Description</h3>

<p>Fit the occupancy model of Royle and Nichols (2003), which relates
probability of detection of the species to the number of individuals
available for detection at each site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_occuRN(
  formula,
  data,
  K = 20,
  prior_intercept_state = normal(0, 5),
  prior_coef_state = normal(0, 2.5),
  prior_intercept_det = logistic(0, 1),
  prior_coef_det = logistic(0, 1),
  prior_sigma = gamma(1, 1),
  log_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_occuRN_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and abundance in that order</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_data">data</code></td>
<td>
<p>A <code><a href="unmarked.html#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code> object</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_k">K</code></td>
<td>
<p>Integer upper index of integration for N-mixture. This should be
set high enough so that it does not affect the parameter estimates.
Note that computation time will increase with K.</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_prior_intercept_state">prior_intercept_state</code></td>
<td>
<p>Prior distribution for the intercept of the
state (abundance) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_prior_coef_state">prior_coef_state</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the state model</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
detection probability model</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the detection model</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_log_lik">log_lik</code></td>
<td>
<p>If <code>TRUE</code>, Stan will save pointwise log-likelihood values
in the output. This can greatly increase the size of the model. If
<code>FALSE</code>, the values are calculated post-hoc from the posteriors</p>
</td></tr>
<tr><td><code id="stan_occuRN_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitOccuRN</code> object describing the model fit.
</p>


<h3>References</h3>

<p>Royle JA, Nichols JD. 2003. Estimating abundance from
repeated presence-absence data or point counts. Ecology 84: 777-790.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+occuRN">occuRN</a></code>, <code><a href="unmarked.html#topic+unmarkedFrameOccu">unmarkedFrameOccu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(birds)
woodthrushUMF &lt;- unmarkedFrameOccu(woodthrush.bin)
#Add a site covariate
siteCovs(woodthrushUMF) &lt;- data.frame(cov1=rnorm(numSites(woodthrushUMF)))

(fm_wood &lt;- stan_occuRN(~1~cov1, woodthrushUMF, chains=3, iter=300))


</code></pre>

<hr>
<h2 id='stan_occuTTD'>Fit Time-to-detection Occupancy Models</h2><span id='topic+stan_occuTTD'></span>

<h3>Description</h3>

<p>Fit time-to-detection occupancy models of Garrard et al.
(2008, 2013). Time-to-detection can be modeled with either an exponential
or Weibull distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_occuTTD(
  psiformula = ~1,
  gammaformula = ~1,
  epsilonformula = ~1,
  detformula = ~1,
  data,
  ttdDist = c("exp", "weibull"),
  linkPsi = c("logit"),
  prior_intercept_state = logistic(0, 1),
  prior_coef_state = logistic(0, 1),
  prior_intercept_det = normal(0, 5),
  prior_coef_det = normal(0, 2.5),
  prior_intercept_shape = normal(0, 2.5),
  prior_sigma = gamma(1, 1),
  log_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_occuTTD_+3A_psiformula">psiformula</code></td>
<td>
<p>Right-hand sided formula for the initial probability of
occupancy at each site.</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_gammaformula">gammaformula</code></td>
<td>
<p>Right-hand sided formula for colonization probability.
Currently ignored as dynamic models are not yet supported.</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_epsilonformula">epsilonformula</code></td>
<td>
<p>Right-hand sided formula for extinction probability.
Currently ignored as dynamic models are not yet supported.</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_detformula">detformula</code></td>
<td>
<p>Right-hand sided formula for mean time-to-detection.</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_data">data</code></td>
<td>
<p><code>unmarkedFrameOccuTTD</code> object that supplies the data
(see <code><a href="unmarked.html#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code>).</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_ttddist">ttdDist</code></td>
<td>
<p>Distribution to use for time-to-detection; either
<code>"exp"</code> for the exponential, or <code>"weibull"</code> for the Weibull,
which adds an additional shape parameter <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_linkpsi">linkPsi</code></td>
<td>
<p>Link function for the occupancy model. Only option is
<code>"logit"</code> for now, in the future <code>"cloglog"</code>
will be supported for the complimentary log-log link.</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_prior_intercept_state">prior_intercept_state</code></td>
<td>
<p>Prior distribution for the intercept of the
state (occupancy probability) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_prior_coef_state">prior_coef_state</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the state model</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
time-to-detection model</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the time-to-detection model</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_prior_intercept_shape">prior_intercept_shape</code></td>
<td>
<p>Prior distribution for the intercept of the
shape parameter (i.e., log(shape)) for Weibull TTD models</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_log_lik">log_lik</code></td>
<td>
<p>If <code>TRUE</code>, Stan will save pointwise log-likelihood values
in the output. This can greatly increase the size of the model. If
<code>FALSE</code>, the values are calculated post-hoc from the posteriors</p>
</td></tr>
<tr><td><code id="stan_occuTTD_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitOccuTTD</code> object describing the model fit.
</p>


<h3>References</h3>

<p>Garrard, G.E., Bekessy, S.A., McCarthy, M.A. and Wintle, B.A. 2008.
When have we looked hard enough? A novel method for setting minimum survey effort
protocols for flora surveys. Austral Ecology 33: 986-998.
</p>
<p>Garrard, G.E., McCarthy, M.A., Williams, N.S., Bekessy, S.A. and Wintle,
B.A. 2013. A general model of detectability using species traits. Methods in
Ecology and Evolution 4: 45-52.
</p>
<p>Kery, Marc, and J. Andrew Royle. 2016. Applied Hierarchical Modeling in
Ecology, Volume 1. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+occuTTD">occuTTD</a></code>, <code><a href="unmarked.html#topic+unmarkedFrameOccuTTD">unmarkedFrameOccuTTD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulate data
N &lt;- 500; J &lt;- 1
scovs &lt;- data.frame(elev=c(scale(runif(N, 0,100))),
                    forest=runif(N,0,1),
                    wind=runif(N,0,1))
beta_psi &lt;- c(-0.69, 0.71, -0.5)
psi &lt;- plogis(cbind(1, scovs$elev, scovs$forest) %*% beta_psi)
z &lt;- rbinom(N, 1, psi)

Tmax &lt;- 10 #Same survey length for all observations
beta_lam &lt;- c(-2, -0.2, 0.7)
rate &lt;- exp(cbind(1, scovs$elev, scovs$wind) %*% beta_lam)
ttd &lt;- rexp(N, rate)
ttd[z==0] &lt;- Tmax #Censor at unoccupied sites
ttd[ttd&gt;Tmax] &lt;- Tmax #Censor when ttd was greater than survey length

#Build unmarkedFrame
umf &lt;- unmarkedFrameOccuTTD(y=ttd, surveyLength=Tmax, siteCovs=scovs)

#Fit model
(fit &lt;- stan_occuTTD(psiformula=~elev+forest, detformula=~elev+wind,
                     data=umf, chains=3, iter=300))


</code></pre>

<hr>
<h2 id='stan_pcount'>Fit the N-mixture model of Royle (2004)</h2><span id='topic+stan_pcount'></span>

<h3>Description</h3>

<p>This function fits the single season N-mixture model of
Royle et al. (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_pcount(
  formula,
  data,
  K = NULL,
  mixture = "P",
  prior_intercept_state = normal(0, 5),
  prior_coef_state = normal(0, 2.5),
  prior_intercept_det = logistic(0, 1),
  prior_coef_det = logistic(0, 1),
  prior_sigma = gamma(1, 1),
  log_lik = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_pcount_+3A_formula">formula</code></td>
<td>
<p>Double right-hand side formula describing covariates of
detection and abundance in that order</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_data">data</code></td>
<td>
<p>A <code><a href="unmarked.html#topic+unmarkedFramePCount">unmarkedFramePCount</a></code> object</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_k">K</code></td>
<td>
<p>Integer upper index of integration for N-mixture. This should be
set high enough so that it does not affect the parameter estimates.
Note that computation time will increase with K.</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_mixture">mixture</code></td>
<td>
<p>Character specifying mixture: &quot;P&quot; is only option currently.</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_prior_intercept_state">prior_intercept_state</code></td>
<td>
<p>Prior distribution for the intercept of the
state (abundance) model; see <code>?priors</code> for options</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_prior_coef_state">prior_coef_state</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the state model</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_prior_intercept_det">prior_intercept_det</code></td>
<td>
<p>Prior distribution for the intercept of the
detection probability model</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_prior_coef_det">prior_coef_det</code></td>
<td>
<p>Prior distribution for the regression coefficients of
the detection model</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>Prior distribution on random effect standard deviations</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_log_lik">log_lik</code></td>
<td>
<p>If <code>TRUE</code>, Stan will save pointwise log-likelihood values
in the output. This can greatly increase the size of the model. If
<code>FALSE</code>, the values are calculated post-hoc from the posteriors</p>
</td></tr>
<tr><td><code id="stan_pcount_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code><a href="rstan.html#topic+stan">stan</a></code> call, such as
number of chains <code>chains</code> or iterations <code>iter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ubmsFitPcount</code> object describing the model fit.
</p>


<h3>References</h3>

<p>Royle JA. 2004. N-mixture models for estimating populaiton size
from spatially replicated counts. Biometrics 60: 105-108.
</p>


<h3>See Also</h3>

<p><code><a href="unmarked.html#topic+pcount">pcount</a></code>, <code><a href="unmarked.html#topic+unmarkedFramePCount">unmarkedFramePCount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mallard)
mallardUMF &lt;- unmarkedFramePCount(mallard.y, siteCovs=mallard.site)

(fm_mallard &lt;- stan_pcount(~1~elev+forest, mallardUMF, K=30,
                           chains=3, iter=300))


</code></pre>

<hr>
<h2 id='summary+2CubmsFit-method'>Extract Summary Statistics from a ubmsFit Model</h2><span id='topic+summary+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Extract Summary Statistics from a ubmsFit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
summary(object, submodel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="summary+2B2CubmsFit-method_+3A_submodel">submodel</code></td>
<td>
<p>Name of submodel to summarize</p>
</td></tr>
<tr><td><code id="summary+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> containing summary statistics
for posterior distributions of parameters from the chosen submodel.
</p>

<hr>
<h2 id='traceplot+2CubmsFit-method'>Markov Chain Traceplots</h2><span id='topic+traceplot+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Draws traceplots for chains from a <code>ubmsFit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
traceplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot+2B2CubmsFit-method_+3A_object">object</code></td>
<td>
<p>A <code>ubmsFit</code> object</p>
</td></tr>
<tr><td><code id="traceplot+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>rstan::traceplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='turnover'>Turnover Probability</h2><span id='topic+turnover'></span><span id='topic+turnover+2CubmsFitColext-method'></span>

<h3>Description</h3>

<p>Generate posterior draws of turnover probability from dynamic occupancy models.
Turnover is calculated for each site and each primary period after the first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnover(object, ...)

## S4 method for signature 'ubmsFitColext'
turnover(object, draws, re.form = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turnover_+3A_object">object</code></td>
<td>
<p>A fitted dynamic occupancy model of class inheriting <code>ubmsFit</code></p>
</td></tr>
<tr><td><code id="turnover_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="turnover_+3A_draws">draws</code></td>
<td>
<p>Number of draws from the posterior to use in the check</p>
</td></tr>
<tr><td><code id="turnover_+3A_re.form">re.form</code></td>
<td>
<p>If <code>NULL</code>, any estimated group-level parameters (&quot;random
effects&quot;) are included. If <code>NA</code>, they are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of turnover values from the posterior predictive distribution.
The dimensions are <code>draws</code> by number of sites x (primary periods - 1)
in site-major order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_colext">stan_colext</a></code>
</p>

<hr>
<h2 id='ubms'>ubms</h2><span id='topic+ubms'></span><span id='topic+ubms-package'></span>

<h3>Description</h3>

<p>Unmarked Bayesian Models using Stan
</p>


<h3>Author(s)</h3>

<p>Ken Kellner
</p>

<hr>
<h2 id='ubmsFitList-extractors'>Extractors for ubmsFitList objects
Extract parts of ubmsFitList objects.</h2><span id='topic+ubmsFitList-extractors'></span><span id='topic++24+2CubmsFitList-method'></span><span id='topic++5B+5B+2CubmsFitList+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CubmsFitList+2Cnumeric+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extractors for ubmsFitList objects
Extract parts of ubmsFitList objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFitList'
x$name

## S4 method for signature 'ubmsFitList,numeric,missing'
x[[i]]

## S4 method for signature 'ubmsFitList,numeric,missing,missing'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ubmsFitList-extractors_+3A_x">x</code></td>
<td>
<p>A list of <code>ubmsFit</code> models of class <code>ubmsFitList</code></p>
</td></tr>
<tr><td><code id="ubmsFitList-extractors_+3A_name">name</code>, <code id="ubmsFitList-extractors_+3A_i">i</code></td>
<td>
<p>The names or indices of <code>ubmsFit</code> models in the <code>ubmsFitList</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ubmsFit</code> object or list of such objects.
</p>

<hr>
<h2 id='waic+2CubmsFit-method'>Widely Applicable Information Criterion (WAIC)</h2><span id='topic+waic+2CubmsFit-method'></span>

<h3>Description</h3>

<p>Widely Applicable Information Criterion (WAIC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ubmsFit'
waic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waic+2B2CubmsFit-method_+3A_x">x</code></td>
<td>
<p>A <code>ubmsFit</code> model</p>
</td></tr>
<tr><td><code id="waic+2B2CubmsFit-method_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>waic</code> containing an estimate of WAIC and
other parameters useful for model comparison. See <code>?loo::waic</code> for
more information.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
