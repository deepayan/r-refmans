<!DOCTYPE html><html><head><title>Help for package splitSelect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splitSelect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.cv.splitSelect'><p>Coefficients for splitSelect object</p></a></li>
<li><a href='#coef.splitSelect'><p>Coefficients for splitSelect object</p></a></li>
<li><a href='#cv.splitSelect'><p>Split Selection Modeling for Low-Dimensional Data - Cross-Validation</p></a></li>
<li><a href='#generate_partitions'><p>Generate Splits Partitions Possibilities</p></a></li>
<li><a href='#generate_splits'><p>Generate Splits Possibilities</p></a></li>
<li><a href='#nsplit'><p>Compute Total Number of Possible Splits</p></a></li>
<li><a href='#predict.cv.splitSelect'><p>Predictions for cv.splitSelect object</p></a></li>
<li><a href='#predict.splitSelect'><p>Predictions for splitSelect object</p></a></li>
<li><a href='#rsplit'><p>Generate Samples of Splits Possibilities</p></a></li>
<li><a href='#splitSelect'><p>Best Split Selection Modeling for Low-Dimensional Data</p></a></li>
<li><a href='#splitSelect_coef'><p>Split Selection for Regression - Coefficients Generation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Best Split Selection Modeling for Low-Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Christidis &lt;anthony.christidis@stat.ubc.ca&gt;,
    Stefan Van Aelst &lt;stefan.vanaelst@kuleuven.be&gt;,
    Ruben Zamar &lt;ruben@stat.ubc.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Christidis &lt;anthony.christidis@stat.ubc.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to generate or sample from all possible splits of features or variables
             into a number of specified groups. Also computes the best split selection estimator 
             (for low-dimensional data) as defined in Christidis, Van Aelst and Zamar (2019) 
             &lt;<a href="https://arxiv.org/abs/1812.05678">arXiv:1812.05678</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>multicool, glmnet, parallel, doParallel, foreach</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mvnfast</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-09 04:02:22 UTC; antho</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-09 06:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.cv.splitSelect'>Coefficients for splitSelect object</h2><span id='topic+coef.cv.splitSelect'></span>

<h3>Description</h3>

<p><code>coef.cv.splitSelect</code> returns the coefficients for a cv.splitSelect for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.splitSelect'
coef(object, optimal.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.splitSelect_+3A_object">object</code></td>
<td>
<p>An object of class cv.splitSelect.</p>
</td></tr>
<tr><td><code id="coef.cv.splitSelect_+3A_optimal.only">optimal.only</code></td>
<td>
<p>A boolean variable (TRUE default) to indicate if only the coefficient of the optimal split are returned.</p>
</td></tr>
<tr><td><code id="coef.cv.splitSelect_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the coefficients of the <code>cv.splitSelect</code> object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitSelect">splitSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 4
n &lt;- 30
n.test &lt;- 5000
beta &lt;- rep(5,4)
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)

# Generating the coefficients for a fixed split

split.out &lt;- cv.splitSelect(x.train, y.train, G=2, use.all=TRUE,
                            fix.partition=list(matrix(c(2,2), 
                                               ncol=2, byrow=TRUE)), 
                            fix.split=NULL,
                            intercept=TRUE, group.model="glmnet", alphas=0, nfolds=10)
coef(split.out)


</code></pre>

<hr>
<h2 id='coef.splitSelect'>Coefficients for splitSelect object</h2><span id='topic+coef.splitSelect'></span>

<h3>Description</h3>

<p><code>coef.splitSelect</code> returns the coefficients for a splitSelect object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitSelect'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.splitSelect_+3A_object">object</code></td>
<td>
<p>An object of class splitSelect.</p>
</td></tr>
<tr><td><code id="coef.splitSelect_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the coefficients of the <code>splitSelect</code> object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitSelect">splitSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 4
n &lt;- 30
n.test &lt;- 5000
beta &lt;- rep(5,4)
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)

# Generating the coefficients for a fixed partition of the variables

split.out &lt;- splitSelect(x.train, y.train, G=2, use.all=TRUE,
                         fix.partition=list(matrix(c(2,2), ncol=2, byrow=TRUE)), fix.split=NULL,
                         intercept=TRUE, group.model="glmnet", alphas=0)     
coef(split.out)


</code></pre>

<hr>
<h2 id='cv.splitSelect'>Split Selection Modeling for Low-Dimensional Data - Cross-Validation</h2><span id='topic+cv.splitSelect'></span>

<h3>Description</h3>

<p><code>cv.splitSelect</code> performs the best split selection algorithm with cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.splitSelect(
  x,
  y,
  intercept = TRUE,
  G,
  use.all = TRUE,
  family = c("gaussian", "binomial")[1],
  group.model = c("glmnet", "LS", "Logistic")[1],
  alphas = 0,
  nsample = NULL,
  fix.partition = NULL,
  fix.split = NULL,
  nfolds = 10,
  parallel = FALSE,
  cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.splitSelect_+3A_x">x</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_intercept">intercept</code></td>
<td>
<p>Boolean variable to determine if there is intercept (default is TRUE) or not.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_g">G</code></td>
<td>
<p>Number of groups into which the variables are split. Can have more than one value.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_use.all">use.all</code></td>
<td>
<p>Boolean variable to determine if all variables must be used (default is TRUE).</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_family">family</code></td>
<td>
<p>Description of the error distribution and link function to be used for the model. Must be one of &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_group.model">group.model</code></td>
<td>
<p>Model used for the groups. Must be one of &quot;glmnet&quot; or &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_alphas">alphas</code></td>
<td>
<p>Elastic net mixing parameter. Should be between 0 (default) and 1.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_nsample">nsample</code></td>
<td>
<p>Number of sample splits for each value of G. If NULL, then all splits will be considered (unless there is overflow).</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_fix.partition">fix.partition</code></td>
<td>
<p>Optional list with G elements indicating the partitions (in each row) to be considered for the splits.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_fix.split">fix.split</code></td>
<td>
<p>Optional matrix with p columns indicating the groups (in each row) to be considered for the splits.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for the cross-validation procedure.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_parallel">parallel</code></td>
<td>
<p>Boolean variable to determine if parallelization of the function. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv.splitSelect_+3A_cores">cores</code></td>
<td>
<p>Number of cores for the parallelization for the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class cv.splitSelect.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.cv.splitSelect">coef.cv.splitSelect</a></code>, <code><a href="#topic+predict.cv.splitSelect">predict.cv.splitSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 4
n &lt;- 30
n.test &lt;- 5000
beta &lt;- rep(5,4)
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)

# Generating the coefficients for a fixed partition of the variables

split.out &lt;- cv.splitSelect(x.train, y.train, G=2, use.all=TRUE,
                            fix.partition=list(matrix(c(2,2), 
                                               ncol=2, byrow=TRUE)), 
                            fix.split=NULL,
                            intercept=TRUE, group.model="glmnet", alphas=0, nfolds=10)


</code></pre>

<hr>
<h2 id='generate_partitions'>Generate Splits Partitions Possibilities</h2><span id='topic+generate_partitions'></span>

<h3>Description</h3>

<p><code>generate_partitions</code> returns a matrix with the number of possible objects in each group using splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_partitions(p, G, use.all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_partitions_+3A_p">p</code></td>
<td>
<p>Number of variables or objects to split.</p>
</td></tr>
<tr><td><code id="generate_partitions_+3A_g">G</code></td>
<td>
<p>Number of groups into which the variables are split.</p>
</td></tr>
<tr><td><code id="generate_partitions_+3A_use.all">use.all</code></td>
<td>
<p>Boolean variable to determine if all variables must be used (default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or list with the number of possible objects in each group using splits.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating the possible split partitions of 6 variables in 3 groups
# Using all the variables
split.3groups.all &lt;- generate_partitions(6, 3)
split.3groups.all
# Without using all the variables
split.3groups &lt;- generate_partitions(6, 3, use.all=FALSE)
split.3groups

</code></pre>

<hr>
<h2 id='generate_splits'>Generate Splits Possibilities</h2><span id='topic+generate_splits'></span>

<h3>Description</h3>

<p><code>generate_splits</code> returns a matrix with the different splits of the variables in reach row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_splits(p, G, use.all = TRUE, fix.partition = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_splits_+3A_p">p</code></td>
<td>
<p>Number of variables or objects to split.</p>
</td></tr>
<tr><td><code id="generate_splits_+3A_g">G</code></td>
<td>
<p>Number of groups into which the variables are split.</p>
</td></tr>
<tr><td><code id="generate_splits_+3A_use.all">use.all</code></td>
<td>
<p>Boolean variable to determine if all variables must be used (default is TRUE).</p>
</td></tr>
<tr><td><code id="generate_splits_+3A_fix.partition">fix.partition</code></td>
<td>
<p>Optional matrix with G columns (or list if more than one value of G) indicating the partitions (in each row) to be considered for the splits.</p>
</td></tr>
<tr><td><code id="generate_splits_+3A_verbose">verbose</code></td>
<td>
<p>Boolean variable to determine if console output for cross-validation progress is printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the different splits of the variables in the groups.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating the possible splits of 6 variables in 3 groups
# Using all the variables
split.3groups.all &lt;- generate_splits(6, 3)
split.3groups.all
# Without using all the variables
split.3groups &lt;- generate_splits(6, 3, use.all=FALSE)
split.3groups

</code></pre>

<hr>
<h2 id='nsplit'>Compute Total Number of Possible Splits</h2><span id='topic+nsplit'></span>

<h3>Description</h3>

<p><code>nsplits</code> returns the total number of possible splits of variables into groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsplit(p, G, use.all = TRUE, fix.partition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsplit_+3A_p">p</code></td>
<td>
<p>Number of variables or objects to split.</p>
</td></tr>
<tr><td><code id="nsplit_+3A_g">G</code></td>
<td>
<p>Number of groups into which the variables are split.</p>
</td></tr>
<tr><td><code id="nsplit_+3A_use.all">use.all</code></td>
<td>
<p>Boolean variable to determine if all variables must be used (default is TRUE).</p>
</td></tr>
<tr><td><code id="nsplit_+3A_fix.partition">fix.partition</code></td>
<td>
<p>Optional matrix with G columns (or list if more than one value of G) indicating the partitions (in each row) to be considered for the splits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the total number of possible splits.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the total number of possible splits of 6 variables into 3 groups
# We use all the variables
out.n.splits.all &lt;- nsplit(p=6, G=3, use.all=TRUE)
out.n.splits.all
# We don't enforce using all the variables
out.n.splits &lt;- nsplit(p=6, G=3, use.all=FALSE)
out.n.splits

</code></pre>

<hr>
<h2 id='predict.cv.splitSelect'>Predictions for cv.splitSelect object</h2><span id='topic+predict.cv.splitSelect'></span>

<h3>Description</h3>

<p><code>predict.cv.splitSelect</code> returns the prediction for cv.splitSelect for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.splitSelect'
predict(object, newx, optimal.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.splitSelect_+3A_object">object</code></td>
<td>
<p>An object of class cv.splitSelect.</p>
</td></tr>
<tr><td><code id="predict.cv.splitSelect_+3A_newx">newx</code></td>
<td>
<p>A matrix with the new data.</p>
</td></tr>
<tr><td><code id="predict.cv.splitSelect_+3A_optimal.only">optimal.only</code></td>
<td>
<p>A boolean variable (TRUE default) to indicate if only the predictions of the optimal split are returned.</p>
</td></tr>
<tr><td><code id="predict.cv.splitSelect_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the predictions of the <code>cv.splitSelect</code> object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.splitSelect">cv.splitSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 4
n &lt;- 30
n.test &lt;- 5000
beta &lt;- rep(5,4)
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)
x.test &lt;- mvnfast::rmvn(n.test, mu=rep(0,p), sigma=Sigma.rho)
y.test &lt;- 1 + x.test %*% beta + rnorm(n.test, sd=sigma.epsilon)

# Generating the coefficients for a fixed split

split.out &lt;- cv.splitSelect(x.train, y.train, G=2, use.all=TRUE,
                            fix.partition=list(matrix(c(2,2), 
                                               ncol=2, byrow=TRUE)), 
                            fix.split=NULL,
                            intercept=TRUE, group.model="glmnet", alphas=0)
predict(split.out, newx=x.test)


</code></pre>

<hr>
<h2 id='predict.splitSelect'>Predictions for splitSelect object</h2><span id='topic+predict.splitSelect'></span>

<h3>Description</h3>

<p><code>predict.splitSelect</code> returns the prediction for splitSelect for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitSelect'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.splitSelect_+3A_object">object</code></td>
<td>
<p>An object of class splitSelect.</p>
</td></tr>
<tr><td><code id="predict.splitSelect_+3A_newx">newx</code></td>
<td>
<p>A matrix with the new data.</p>
</td></tr>
<tr><td><code id="predict.splitSelect_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the predictions of the <code>splitSelect</code> object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitSelect">splitSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 4
n &lt;- 30
n.test &lt;- 5000
beta &lt;- rep(5,4)
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)
x.test &lt;- mvnfast::rmvn(n.test, mu=rep(0,p), sigma=Sigma.rho)
y.test &lt;- 1 + x.test %*% beta + rnorm(n.test, sd=sigma.epsilon)

# Generating the coefficients for a fixed split

split.out &lt;- splitSelect(x.train, y.train, G=2, use.all=TRUE,
                         fix.partition=list(matrix(c(2,2), ncol=2, byrow=TRUE)), fix.split=NULL,
                         intercept=TRUE, group.model="glmnet", alphas=0)
predict(split.out, newx=x.test)


</code></pre>

<hr>
<h2 id='rsplit'>Generate Samples of Splits Possibilities</h2><span id='topic+rsplit'></span>

<h3>Description</h3>

<p><code>rsplit</code> returns a matrix with random splits of the variables in groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsplit(n, p, G, use.all = TRUE, fix.partition = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsplit_+3A_n">n</code></td>
<td>
<p>Number of sample splits.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_p">p</code></td>
<td>
<p>Number of variables or objects to split.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_g">G</code></td>
<td>
<p>Number of groups into which the variables are split.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_use.all">use.all</code></td>
<td>
<p>Boolean variable to determine if all variables must be used (default is TRUE).</p>
</td></tr>
<tr><td><code id="rsplit_+3A_fix.partition">fix.partition</code></td>
<td>
<p>Optional matrix with G columns indicating the partitions (in each row) to be considered for the splits.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_verbose">verbose</code></td>
<td>
<p>Boolean variable to determine if console output for cross-validation progress is printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or list with the number of possible objects in each group using splits.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating sample splits of 6 variables in 3 groups
# Using all the variables
random.splits &lt;- rsplit(100, 6, 3)
# Using fixed partitions
random.splits.fixed &lt;- rsplit(100, 6, 3, fix.partition=matrix(c(2,2,2), nrow=1))

</code></pre>

<hr>
<h2 id='splitSelect'>Best Split Selection Modeling for Low-Dimensional Data</h2><span id='topic+splitSelect'></span>

<h3>Description</h3>

<p><code>splitSelect</code> performs the best split selection algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitSelect(
  x,
  y,
  intercept = TRUE,
  G,
  use.all = TRUE,
  family = c("gaussian", "binomial")[1],
  group.model = c("glmnet", "LS", "Logistic")[1],
  lambdas = NULL,
  alphas = 0,
  nsample = NULL,
  fix.partition = NULL,
  fix.split = NULL,
  parallel = FALSE,
  cores = getOption("mc.cores", 2L),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitSelect_+3A_x">x</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_intercept">intercept</code></td>
<td>
<p>Boolean variable to determine if there is intercept (default is TRUE) or not.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_g">G</code></td>
<td>
<p>Number of groups into which the variables are split. Can have more than one value.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_use.all">use.all</code></td>
<td>
<p>Boolean variable to determine if all variables must be used (default is TRUE).</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_family">family</code></td>
<td>
<p>Description of the error distribution and link function to be used for the model. Must be one of &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_group.model">group.model</code></td>
<td>
<p>Model used for the groups. Must be one of &quot;glmnet&quot; or &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_lambdas">lambdas</code></td>
<td>
<p>The shinkrage parameters for the &quot;glmnet&quot; regularization. If NULL (default), optimal values are chosen.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_alphas">alphas</code></td>
<td>
<p>Elastic net mixing parameter. Should be between 0 (default) and 1.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_nsample">nsample</code></td>
<td>
<p>Number of sample splits for each value of G. If NULL, then all splits will be considered (unless there is overflow).</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_fix.partition">fix.partition</code></td>
<td>
<p>Optional list with G elements indicating the partitions (in each row) to be considered for the splits.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_fix.split">fix.split</code></td>
<td>
<p>Optional matrix with p columns indicating the groups (in each row) to be considered for the splits.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_parallel">parallel</code></td>
<td>
<p>Boolean variable to determine if parallelization of the function. Default is FALSE.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_cores">cores</code></td>
<td>
<p>Number of cores for the parallelization for the function.</p>
</td></tr>
<tr><td><code id="splitSelect_+3A_verbose">verbose</code></td>
<td>
<p>Boolean variable to determine if console output for cross-validation progress is printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class splitSelect.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.splitSelect">coef.splitSelect</a></code>, <code><a href="#topic+predict.splitSelect">predict.splitSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 4
n &lt;- 30
n.test &lt;- 5000
beta &lt;- rep(5,4)
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)

# Generating the coefficients for a fixed partition of the variables

split.out &lt;- splitSelect(x.train, y.train, G=2, use.all=TRUE,
                         fix.partition=list(matrix(c(2,2), 
                                             ncol=2, byrow=TRUE)), 
                         fix.split=NULL,
                         intercept=TRUE, group.model="glmnet", alphas=0)


</code></pre>

<hr>
<h2 id='splitSelect_coef'>Split Selection for Regression - Coefficients Generation</h2><span id='topic+splitSelect_coef'></span>

<h3>Description</h3>

<p><code>splitSelect_coef</code> generates the coefficients for a particular split of variables into groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitSelect_coef(
  x,
  y,
  variables.split,
  intercept = TRUE,
  family = c("gaussian", "binomial")[1],
  group.model = c("glmnet", "LS", "Logistic")[1],
  lambdas = NULL,
  alphas = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitSelect_coef_+3A_x">x</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_variables.split">variables.split</code></td>
<td>
<p>A vector with the split of the variables into groups as values.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_intercept">intercept</code></td>
<td>
<p>Boolean variable to determine if there is intercept (default is TRUE) or not.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_family">family</code></td>
<td>
<p>Description of the error distribution and link function to be used for the model. Must be one of &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_group.model">group.model</code></td>
<td>
<p>Model used for the groups. Must be one of &quot;glmnet&quot; or &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_lambdas">lambdas</code></td>
<td>
<p>The shinkrage parameters for the &quot;glmnet&quot; regularization. If NULL (default), optimal values are chosen.</p>
</td></tr>
<tr><td><code id="splitSelect_coef_+3A_alphas">alphas</code></td>
<td>
<p>Elastic net mixing parameter. Should be between 0 (default) and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the regression coefficients for the split.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the parameters
p &lt;- 6
n &lt;- 30
n.test &lt;- 5000
group.beta &lt;- -3
beta &lt;- c(rep(1, 2), rep(group.beta, p-2))
rho &lt;- 0.1
r &lt;- 0.9
SNR &lt;- 3
# Creating the target matrix with "kernel" set to rho
target_cor &lt;- function(r, p){
  Gamma &lt;- diag(p)
  for(i in 1:(p-1)){
    for(j in (i+1):p){
      Gamma[i,j] &lt;- Gamma[j,i] &lt;- r^(abs(i-j))
    }
  }
  return(Gamma)
}
# AR Correlation Structure
Sigma.r &lt;- target_cor(r, p)
Sigma.rho &lt;- target_cor(rho, p)
sigma.epsilon &lt;- as.numeric(sqrt((t(beta) %*% Sigma.rho %*% beta)/SNR))
# Simulate some data
x.train &lt;- mvnfast::rmvn(30, mu=rep(0,p), sigma=Sigma.r)
y.train &lt;- 1 + x.train %*% beta + rnorm(n=n, mean=0, sd=sigma.epsilon)
x.test &lt;- mvnfast::rmvn(n.test, mu=rep(0,p), sigma=Sigma.rho)
y.test &lt;- 1 + x.test %*% beta + rnorm(n.test, sd=sigma.epsilon)

# Generating the coefficients for a fixed split
splitSelect_coef(x.train, y.train, variables.split=matrix(c(1,2,1,2,1,2), nrow=1))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
