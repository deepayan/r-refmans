<!DOCTYPE html><html><head><title>Help for package rang</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rang}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apptainerize'><p>Create an Apptainer/Singularity Definition File of The Resolved Result</p></a></li>
<li><a href='#as_pkgrefs'><p>Convert Data Structures into Package References</p></a></li>
<li><a href='#convert_edgelist'><p>Convert Data Structures to rang edgelist</p></a></li>
<li><a href='#create_turing'><p>Create executable research compendium according to the Turing Way</p></a></li>
<li><a href='#dockerize'><p>Dockerize The Resolved Result</p></a></li>
<li><a href='#export_rang'><p>Export The Resolved Result As Installation Script</p></a></li>
<li><a href='#export_renv'><p>Export The Resolved Result As a renv Lockfile</p></a></li>
<li><a href='#generate_installation_order'><p>Create a Data Frame of The Resolved Result</p>
This function exports the results from <code>resolve()</code> to a data frame, which each row represents one installation step. The order of rows is the installation order. By installing packages in the specified order, one can install all the resolved packages without conflicts.</a></li>
<li><a href='#query_sysreqs'><p>Query for System Requirements</p></a></li>
<li><a href='#recipes'><p>Recipes for Building Container Images</p></a></li>
<li><a href='#resolve'><p>Resolve Dependencies Of R Packages</p></a></li>
<li><a href='#use_rang'><p>Setup rang for a directory</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Reconstructing Reproducible R Computational Environments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Resolve the dependency graph of R packages at a specific time point based on the information from various 'R-hub' web services <a href="https://blog.r-hub.io/">https://blog.r-hub.io/</a>. The dependency graph can then be used to reconstruct the R computational environment with 'Rocker' <a href="https://rocker-project.org">https://rocker-project.org</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gesistsa/rang">https://github.com/gesistsa/rang</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gesistsa/rang/issues">https://github.com/gesistsa/rang/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>parsedate, fastmap, jsonlite, memoise, pkgsearch, remotes,
utils, httr, vctrs, renv, here</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-08 13:29:24 UTC; chainsawriot</td>
</tr>
<tr>
<td>Author:</td>
<td>Chung-hong Chan <a href="https://orcid.org/0000-0002-6232-7530"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Egor Kotov <a href="https://orcid.org/0000-0001-6690-5345"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chung-hong Chan &lt;chainsawtiney@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-08 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apptainerize'>Create an Apptainer/Singularity Definition File of The Resolved Result</h2><span id='topic+apptainerize'></span><span id='topic+apptainerize_rang'></span><span id='topic+apptainerise'></span><span id='topic+apptainerise_rang'></span><span id='topic+singularize'></span><span id='topic+singularize_rang'></span><span id='topic+singularise'></span><span id='topic+singularise_rang'></span>

<h3>Description</h3>

<p>This function exports the result from <code><a href="#topic+resolve">resolve()</a></code> to an Apptainer/Singularity definition file. For R version &gt;= 3.1.0, the file is based on the versioned Rocker Docker image.
For R version &lt; 3.1.0, the Apptainer/Singularity definition is based on Debian and it compiles R from source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apptainerize(
  rang,
  output_dir,
  materials_dir = NULL,
  post_installation_steps = NULL,
  image = c("r-ver", "rstudio", "tidyverse", "verse", "geospatial"),
  rang_as_comment = TRUE,
  cache = FALSE,
  verbose = TRUE,
  lib = NA,
  cran_mirror = "https://cran.r-project.org/",
  check_cran_mirror = TRUE,
  bioc_mirror = "https://bioconductor.org/packages/",
  no_rocker = FALSE,
  debian_version = c("lenny", "squeeze", "wheezy", "jessie", "stretch"),
  skip_r17 = TRUE,
  insert_readme = TRUE,
  copy_all = FALSE
)

apptainerize_rang(...)

apptainerise(...)

apptainerise_rang(...)

singularize(...)

singularize_rang(...)

singularise(...)

singularise_rang(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apptainerize_+3A_rang">rang</code></td>
<td>
<p>output from <code><a href="#topic+resolve">resolve()</a></code></p>
</td></tr>
<tr><td><code id="apptainerize_+3A_output_dir">output_dir</code></td>
<td>
<p>character, where to put the Apptainer/Singularity definition file and associated content</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_materials_dir">materials_dir</code></td>
<td>
<p>character, path to the directory containing additional resources (e.g. analysis scripts) to be copied into <code>output_dir</code> and in turn into the Apptainer/Singularity container</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_post_installation_steps">post_installation_steps</code></td>
<td>
<p>character, additional steps to be added before the in the end of <code style="white-space: pre;">&#8288;%post&#8288;</code> section the Apptainer/Singularity definition file, see an example below</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_image">image</code></td>
<td>
<p>character, which versioned Rocker image to use. Can only be &quot;r-ver&quot;, &quot;rstudio&quot;, &quot;tidyverse&quot;, &quot;verse&quot;, &quot;geospatial&quot;
This applies only to R version &gt;= 3.1</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_rang_as_comment">rang_as_comment</code></td>
<td>
<p>logical, whether to write resolved result and the steps to reproduce
the file to <code>path</code> as comment</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_cache">cache</code></td>
<td>
<p>logical, whether to cache the packages now. Please note that the system requirements are not cached. For query with non-CRAN packages, this option is strongly recommended. For query with local packages, this must be TRUE regardless of R version. For R version &lt; 3.1, this must be also TRUE if there is any non-CRAN packages.</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_verbose">verbose</code></td>
<td>
<p>logical, pass to <code><a href="utils.html#topic+install.packages">install.packages()</a></code>, the negated value is also passed as <code>quiet</code> to both <code><a href="utils.html#topic+install.packages">install.packages()</a></code>
and <code><a href="utils.html#topic+download.file">download.file()</a></code>.</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_lib">lib</code></td>
<td>
<p>character, pass to <code><a href="utils.html#topic+install.packages">install.packages()</a></code>. By default, it is NA (to install the packages to the default location)</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_cran_mirror">cran_mirror</code></td>
<td>
<p>character, which CRAN mirror to use</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_check_cran_mirror">check_cran_mirror</code></td>
<td>
<p>logical, whether to check the CRAN mirror</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_bioc_mirror">bioc_mirror</code></td>
<td>
<p>character, which Bioconductor mirror to use</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_no_rocker">no_rocker</code></td>
<td>
<p>logical, whether to skip using Rocker images even when an appropriate version is available. Please keep this as <code>TRUE</code> unless you know what you are doing</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_debian_version">debian_version</code></td>
<td>
<p>when Rocker images are not used, which EOL version of Debian to use. Can only be &quot;lenny&quot;, &quot;etch&quot;, &quot;squeeze&quot;, &quot;wheezy&quot;, &quot;jessie&quot;, &quot;stretch&quot;. Please keep this as default &quot;lenny&quot; unless you know what you are doing</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_skip_r17">skip_r17</code></td>
<td>
<p>logical, whether to skip R 1.7.x. Currently, it is not possible to compile R 1.7.x (R 1.7.0 and R 1.7.1) with the method provided by  <code>rang</code>. It affects <code>snapshot_date</code> from 2003-04-16 to 2003-10-07. When <code>skip_r17</code> is TRUE and <code>snapshot_date</code> is within the aforementioned range, R 1.8.0 is used instead</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_insert_readme">insert_readme</code></td>
<td>
<p>logical, whether to insert a README file</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_copy_all">copy_all</code></td>
<td>
<p>logical, whether to copy everything in the current directory into the container. If <code>inst/rang</code> is detected in <code>output_dir</code>, this is coerced to TRUE.</p>
</td></tr>
<tr><td><code id="apptainerize_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>apptainerize</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea behind this is to determine the installation order of R packages locally. Then, the installation script can be deployed to another
fresh R session to install R packages. <code><a href="#topic+dockerize">dockerize()</a></code> and <code><a href="#topic+apptainerize">apptainerize()</a></code> are more reasonable ways because a fresh R session with all system requirements
is provided. The current approach does not work in R &lt; 2.1.0.
</p>


<h3>Value</h3>

<p><code>output_dir</code>, invisibly
</p>


<h3>References</h3>

<p><a href="https://apptainer.org/">Apptainer / Singularity</a>
</p>
<p>Kurtzer, G. M., Sochat, V., &amp; Bauer, M. W. (2017) Singularity: Scientific containers for mobility of compute. PLOS ONE, 12(5):e0177459. <a href="https://doi.org/10.1371/journal.pone.0177459">doi:10.1371/journal.pone.0177459</a>
</p>
<p><a href="https://rocker-project.org">The Rocker Project</a>
</p>
<p>Ripley, B. (2005) <a href="https://cran.r-project.org/doc/Rnews/Rnews_2005-1.pdf">Packages and their Management in R 2.1.0.</a> R News, 5(1):8&ndash;11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resolve">resolve()</a></code>, <code><a href="#topic+export_rang">export_rang()</a></code>, <code><a href="#topic+use_rang">use_rang()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(
        pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
        snapshot_date = "2020-01-16"
    )
    apptainerize(graph, ".")
    ## An example of using post_installation_steps to install quarto
    install_quarto &lt;- c("apt-get install -y curl git &amp;&amp; \\
    curl -LO https://quarto.org/download/latest/quarto-linux-amd64.deb &amp;&amp; \\
    dpkg -i quarto-linux-amd64.deb &amp;&amp; \\
    quarto install tool tinytex")
    apptainerize(graph, ".", post_installation_steps = install_quarto)
}

</code></pre>

<hr>
<h2 id='as_pkgrefs'>Convert Data Structures into Package References</h2><span id='topic+as_pkgrefs'></span><span id='topic+as_pkgrefs.default'></span><span id='topic+as_pkgrefs.character'></span><span id='topic+as_pkgrefs.sessionInfo'></span>

<h3>Description</h3>

<p>This generic function converts several standard data structures into a vector of package references, which in turn
can be used as the first argument of the function <code><a href="#topic+resolve">resolve()</a></code>. This function guessimates the possible sources of the
packages. But we strongly recommend manually reviewing the detected packages before using them for <code><a href="#topic+resolve">resolve()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_pkgrefs(x, ...)

## Default S3 method:
as_pkgrefs(x, ...)

## S3 method for class 'character'
as_pkgrefs(x, bioc_version = NULL, no_enhances = TRUE, no_suggests = TRUE, ...)

## S3 method for class 'sessionInfo'
as_pkgrefs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_pkgrefs_+3A_x">x</code></td>
<td>
<p>currently supported data structure(s) are: output from <code><a href="utils.html#topic+sessionInfo">sessionInfo()</a></code>, a character vector of package names</p>
</td></tr>
<tr><td><code id="as_pkgrefs_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="as_pkgrefs_+3A_bioc_version">bioc_version</code></td>
<td>
<p>character. When x is a character vector, version of Bioconductor to search for package names. NULL indicates not
search for Bioconductor.</p>
</td></tr>
<tr><td><code id="as_pkgrefs_+3A_no_enhances">no_enhances</code></td>
<td>
<p>logical, when parsing DESCRIPTION, whether to ignore packages in the &quot;Enhances&quot; field</p>
</td></tr>
<tr><td><code id="as_pkgrefs_+3A_no_suggests">no_suggests</code></td>
<td>
<p>logical, when parsing DESCRIPTION, whether to ignore packages in the &quot;Suggests&quot; field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of package references
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_pkgrefs(sessionInfo())
if (interactive()) {
   require(rang)
   graph &lt;- resolve(as_pkgrefs(sessionInfo()))
   as_pkgrefs(c("rtoot"))
   as_pkgrefs(c("rtoot", "S4Vectors")) ## this gives cran::S4Vectors and is not correct.
   as_pkgrefs(c("rtoot", "S4Vectors"), bioc_version = "3.3") ## This gives bioc::S4Vectors
}
</code></pre>

<hr>
<h2 id='convert_edgelist'>Convert Data Structures to rang edgelist</h2><span id='topic+convert_edgelist'></span><span id='topic+convert_edgelist.default'></span><span id='topic+convert_edgelist.ranglet'></span><span id='topic+convert_edgelist.rang'></span>

<h3>Description</h3>

<p>This generic function converts several data structures provided by rang into an edgelist of package dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_edgelist(x, ...)

## Default S3 method:
convert_edgelist(x, ...)

## S3 method for class 'ranglet'
convert_edgelist(x, ...)

## S3 method for class 'rang'
convert_edgelist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_edgelist_+3A_x">x</code></td>
<td>
<p>supported data structures are <code>rang</code> and <code>ranglet</code> S3 objects</p>
</td></tr>
<tr><td><code id="convert_edgelist_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the resulting data frame can be converted to an igraph object for plotting and analysis via the function <code><a href="igraph.html#topic+graph_from_data_frame">igraph::graph_from_data_frame()</a></code>
</p>


<h3>Value</h3>

<p>a data frame of directed edges of dependencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                snapshot_date = "2020-01-16")
                
    # dependency edgelist of a single package
    convert_edgelist(graph$ranglets[[1]])
    
    # full dependency edgelist
    convert_edgelist(graph)
}

</code></pre>

<hr>
<h2 id='create_turing'>Create executable research compendium according to the Turing Way</h2><span id='topic+create_turing'></span>

<h3>Description</h3>

<p>This <code>usethis</code>-style function creates an executable research compendium according to the Turing Way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_turing(
  path,
  add_rang = TRUE,
  add_makefile = TRUE,
  add_here = TRUE,
  verbose = TRUE,
  force = FALSE,
  apptainer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_turing_+3A_path">path</code></td>
<td>
<p>character, path to the project root</p>
</td></tr>
<tr><td><code id="create_turing_+3A_add_rang">add_rang</code></td>
<td>
<p>logical, whether to run <code><a href="#topic+use_rang">use_rang()</a></code> to <code>path</code></p>
</td></tr>
<tr><td><code id="create_turing_+3A_add_makefile">add_makefile</code></td>
<td>
<p>logical, whether to insert a barebone <code>Makefile</code> in the project root.</p>
</td></tr>
<tr><td><code id="create_turing_+3A_add_here">add_here</code></td>
<td>
<p>logical, whether to insert a hidden <code>.here</code> file in the project root</p>
</td></tr>
<tr><td><code id="create_turing_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print out messages</p>
</td></tr>
<tr><td><code id="create_turing_+3A_force">force</code></td>
<td>
<p>logical, whether to overwrite files (<code>inst/rang/update.R</code>, <code>Makefile</code>, <code>.here</code>) if they
exist.</p>
</td></tr>
<tr><td><code id="create_turing_+3A_apptainer">apptainer</code></td>
<td>
<p>logical, whether to use apptainer. <code>FALSE</code> indicates using Docker</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the Turing Way, an executable research compendium should have the following properties
</p>

<ol>
<li><p> Files should be organized in a conventional folder structure;
</p>
</li>
<li><p> Data, methods, and output should be clearly separated;
</p>
</li>
<li><p> The computational environment should be specified.
</p>
</li></ol>

<p>We use the structure suggested by the Turing Way:
</p>

<ul>
<li> <p><code>data_raw</code>: a directory to hold the raw data
</p>
</li>
<li> <p><code>data_clean</code>: a directory to hold the processed data
</p>
</li>
<li> <p><code>code</code>: a directory to hold computer code
</p>
</li>
<li> <p><code>CITATION</code>: a file holding citation information
</p>
</li>
<li> <p><code>paper.Rmd</code>: a manuscript
This function provides the a clearly separated organizational structure. Components can be changed. For example, the manuscript can be in another format (e.g. quarto, sweave) or even optional. With <code>add_rang</code>, the computational environment can be recorded and reconstructed later.
</p>
</li></ul>



<h3>Value</h3>

<p>path, invisibly
</p>


<h3>References</h3>

<p><a href="https://the-turing-way.netlify.app/reproducible-research/compendia.html">The Turing Way: Research Compendia</a>
Gorman, KB, Williams TD. and Fraser WR (2014). Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3):e90081. <a href="https://doi.org/10.1371/journal.pone.0090081">doi:10.1371/journal.pone.0090081</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use_rang">use_rang()</a></code>
</p>

<hr>
<h2 id='dockerize'>Dockerize The Resolved Result</h2><span id='topic+dockerize'></span><span id='topic+dockerize_rang'></span><span id='topic+dockerise'></span><span id='topic+dockerise_rang'></span>

<h3>Description</h3>

<p>This function exports the result from <code><a href="#topic+resolve">resolve()</a></code> to a Docker file. For R version &gt;= 3.1.0, the Dockerfile is based on the versioned Rocker image.
For R version &lt; 3.1.0, the Dockerfile is based on Debian and it compiles R from source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dockerize(
  rang,
  output_dir,
  materials_dir = NULL,
  post_installation_steps = NULL,
  image = c("r-ver", "rstudio", "tidyverse", "verse", "geospatial"),
  rang_as_comment = TRUE,
  cache = FALSE,
  verbose = TRUE,
  lib = NA,
  cran_mirror = "https://cran.r-project.org/",
  check_cran_mirror = TRUE,
  bioc_mirror = "https://bioconductor.org/packages/",
  no_rocker = FALSE,
  debian_version = c("lenny", "squeeze", "wheezy", "jessie", "stretch"),
  skip_r17 = TRUE,
  insert_readme = TRUE,
  copy_all = FALSE
)

dockerize_rang(...)

dockerise(...)

dockerise_rang(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dockerize_+3A_rang">rang</code></td>
<td>
<p>output from <code><a href="#topic+resolve">resolve()</a></code></p>
</td></tr>
<tr><td><code id="dockerize_+3A_output_dir">output_dir</code></td>
<td>
<p>character, where to put the Docker file and associated content</p>
</td></tr>
<tr><td><code id="dockerize_+3A_materials_dir">materials_dir</code></td>
<td>
<p>character, path to the directory containing additional resources (e.g. analysis scripts) to be copied into <code>output_dir</code> and in turn into the Docker container</p>
</td></tr>
<tr><td><code id="dockerize_+3A_post_installation_steps">post_installation_steps</code></td>
<td>
<p>character, additional steps to be added before the <code>CMD</code> part of the Dockerfile, see an example below</p>
</td></tr>
<tr><td><code id="dockerize_+3A_image">image</code></td>
<td>
<p>character, which versioned Rocker image to use. Can only be &quot;r-ver&quot;, &quot;rstudio&quot;, &quot;tidyverse&quot;, &quot;verse&quot;, &quot;geospatial&quot;
This applies only to R version &gt;= 3.1</p>
</td></tr>
<tr><td><code id="dockerize_+3A_rang_as_comment">rang_as_comment</code></td>
<td>
<p>logical, whether to write resolved result and the steps to reproduce
the file to <code>path</code> as comment</p>
</td></tr>
<tr><td><code id="dockerize_+3A_cache">cache</code></td>
<td>
<p>logical, whether to cache the packages now. Please note that the system requirements are not cached. For query with non-CRAN packages, this option is strongly recommended. For query with local packages, this must be TRUE regardless of R version. For R version &lt; 3.1, this must be also TRUE if there is any non-CRAN packages.</p>
</td></tr>
<tr><td><code id="dockerize_+3A_verbose">verbose</code></td>
<td>
<p>logical, pass to <code><a href="utils.html#topic+install.packages">install.packages()</a></code>, the negated value is also passed as <code>quiet</code> to both <code><a href="utils.html#topic+install.packages">install.packages()</a></code>
and <code><a href="utils.html#topic+download.file">download.file()</a></code>.</p>
</td></tr>
<tr><td><code id="dockerize_+3A_lib">lib</code></td>
<td>
<p>character, pass to <code><a href="utils.html#topic+install.packages">install.packages()</a></code>. By default, it is NA (to install the packages to the default location)</p>
</td></tr>
<tr><td><code id="dockerize_+3A_cran_mirror">cran_mirror</code></td>
<td>
<p>character, which CRAN mirror to use</p>
</td></tr>
<tr><td><code id="dockerize_+3A_check_cran_mirror">check_cran_mirror</code></td>
<td>
<p>logical, whether to check the CRAN mirror</p>
</td></tr>
<tr><td><code id="dockerize_+3A_bioc_mirror">bioc_mirror</code></td>
<td>
<p>character, which Bioconductor mirror to use</p>
</td></tr>
<tr><td><code id="dockerize_+3A_no_rocker">no_rocker</code></td>
<td>
<p>logical, whether to skip using Rocker images even when an appropriate version is available. Please keep this as <code>TRUE</code> unless you know what you are doing</p>
</td></tr>
<tr><td><code id="dockerize_+3A_debian_version">debian_version</code></td>
<td>
<p>when Rocker images are not used, which EOL version of Debian to use. Can only be &quot;lenny&quot;, &quot;etch&quot;, &quot;squeeze&quot;, &quot;wheezy&quot;, &quot;jessie&quot;, &quot;stretch&quot;. Please keep this as default &quot;lenny&quot; unless you know what you are doing</p>
</td></tr>
<tr><td><code id="dockerize_+3A_skip_r17">skip_r17</code></td>
<td>
<p>logical, whether to skip R 1.7.x. Currently, it is not possible to compile R 1.7.x (R 1.7.0 and R 1.7.1) with the method provided by  <code>rang</code>. It affects <code>snapshot_date</code> from 2003-04-16 to 2003-10-07. When <code>skip_r17</code> is TRUE and <code>snapshot_date</code> is within the aforementioned range, R 1.8.0 is used instead</p>
</td></tr>
<tr><td><code id="dockerize_+3A_insert_readme">insert_readme</code></td>
<td>
<p>logical, whether to insert a README file</p>
</td></tr>
<tr><td><code id="dockerize_+3A_copy_all">copy_all</code></td>
<td>
<p>logical, whether to copy everything in the current directory into the container. If <code>inst/rang</code> is detected in <code>output_dir</code>, this is coerced to TRUE.</p>
</td></tr>
<tr><td><code id="dockerize_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>dockerize</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea behind this is to determine the installation order of R packages locally. Then, the installation script can be deployed to another
fresh R session to install R packages. <code><a href="#topic+dockerize">dockerize()</a></code> and <code><a href="#topic+apptainerize">apptainerize()</a></code> are more reasonable ways because a fresh R session with all system requirements
is provided. The current approach does not work in R &lt; 2.1.0.
</p>


<h3>Value</h3>

<p><code>output_dir</code>, invisibly
</p>


<h3>References</h3>

<p><a href="https://rocker-project.org">The Rocker Project</a>
Ripley, B. (2005) <a href="https://cran.r-project.org/doc/Rnews/Rnews_2005-1.pdf">Packages and their Management in R 2.1.0.</a> R News, 5(1):8&ndash;11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resolve">resolve()</a></code>, <code><a href="#topic+export_rang">export_rang()</a></code>, <code><a href="#topic+use_rang">use_rang()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                    snapshot_date = "2020-01-16")
    dockerize(graph, ".")
    ## An example of using post_installation_steps to install quarto
    install_quarto &lt;- c("RUN apt-get install -y curl git &amp;&amp; \\
    curl -LO https://quarto.org/download/latest/quarto-linux-amd64.deb &amp;&amp; \\
    dpkg -i quarto-linux-amd64.deb &amp;&amp; \\
    quarto install tool tinytex")
    dockerize(graph, ".", post_installation_steps = install_quarto)
}

</code></pre>

<hr>
<h2 id='export_rang'>Export The Resolved Result As Installation Script</h2><span id='topic+export_rang'></span>

<h3>Description</h3>

<p>This function exports the results from <code><a href="#topic+resolve">resolve()</a></code> to an installation script that can be run in a fresh R environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_rang(
  rang,
  path,
  rang_as_comment = TRUE,
  verbose = TRUE,
  lib = NA,
  cran_mirror = "https://cran.r-project.org/",
  check_cran_mirror = TRUE,
  bioc_mirror = "https://bioconductor.org/packages/"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_rang_+3A_rang">rang</code></td>
<td>
<p>output from <code><a href="#topic+resolve">resolve()</a></code></p>
</td></tr>
<tr><td><code id="export_rang_+3A_path">path</code></td>
<td>
<p>character, path of the exported installation script</p>
</td></tr>
<tr><td><code id="export_rang_+3A_rang_as_comment">rang_as_comment</code></td>
<td>
<p>logical, whether to write resolved result and the steps to reproduce
the file to <code>path</code> as comment</p>
</td></tr>
<tr><td><code id="export_rang_+3A_verbose">verbose</code></td>
<td>
<p>logical, pass to <code><a href="utils.html#topic+install.packages">install.packages()</a></code>, the negated value is also passed as <code>quiet</code> to both <code><a href="utils.html#topic+install.packages">install.packages()</a></code>
and <code><a href="utils.html#topic+download.file">download.file()</a></code>.</p>
</td></tr>
<tr><td><code id="export_rang_+3A_lib">lib</code></td>
<td>
<p>character, pass to <code><a href="utils.html#topic+install.packages">install.packages()</a></code>. By default, it is NA (to install the packages to the default location)</p>
</td></tr>
<tr><td><code id="export_rang_+3A_cran_mirror">cran_mirror</code></td>
<td>
<p>character, which CRAN mirror to use</p>
</td></tr>
<tr><td><code id="export_rang_+3A_check_cran_mirror">check_cran_mirror</code></td>
<td>
<p>logical, whether to check the CRAN mirror</p>
</td></tr>
<tr><td><code id="export_rang_+3A_bioc_mirror">bioc_mirror</code></td>
<td>
<p>character, which Bioconductor mirror to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea behind this is to determine the installation order of R packages locally. Then, the installation script can be deployed to another
fresh R session to install R packages. <code><a href="#topic+dockerize">dockerize()</a></code> and <code><a href="#topic+apptainerize">apptainerize()</a></code> are more reasonable ways because a fresh R session with all system requirements
is provided. The current approach does not work in R &lt; 2.1.0.
</p>


<h3>Value</h3>

<p><code>path</code>, invisibly
</p>


<h3>References</h3>

<p>Ripley, B. (2005) <a href="https://cran.r-project.org/doc/Rnews/Rnews_2005-1.pdf">Packages and their Management in R 2.1.0.</a> R News, 5(1):8&ndash;11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_installation_order">generate_installation_order()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                    snapshot_date = "2020-01-16")
    export_rang(graph, "rang.R")
}

</code></pre>

<hr>
<h2 id='export_renv'>Export The Resolved Result As a renv Lockfile</h2><span id='topic+export_renv'></span>

<h3>Description</h3>

<p>This function exports the results from <code><a href="#topic+resolve">resolve()</a></code> to a renv lockfile that can be used as an alternative to a docker container.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_renv(rang, path = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_renv_+3A_rang">rang</code></td>
<td>
<p>output from <code><a href="#topic+resolve">resolve()</a></code></p>
</td></tr>
<tr><td><code id="export_renv_+3A_path">path</code></td>
<td>
<p>character, path of the exported renv lockfile</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A renv lockfile is easier to handle than a docker container, but it cannot always reliably reproduce the exact computational environment,especially for very old code.
</p>


<h3>Value</h3>

<p><code>path</code>, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                    snapshot_date = "2020-01-16")
    export_renv(graph, ".")
}

</code></pre>

<hr>
<h2 id='generate_installation_order'>Create a Data Frame of The Resolved Result
This function exports the results from <code><a href="#topic+resolve">resolve()</a></code> to a data frame, which each row represents one installation step. The order of rows is the installation order. By installing packages in the specified order, one can install all the resolved packages without conflicts.</h2><span id='topic+generate_installation_order'></span>

<h3>Description</h3>

<p>Create a Data Frame of The Resolved Result
This function exports the results from <code><a href="#topic+resolve">resolve()</a></code> to a data frame, which each row represents one installation step. The order of rows is the installation order. By installing packages in the specified order, one can install all the resolved packages without conflicts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_installation_order(rang)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_installation_order_+3A_rang">rang</code></td>
<td>
<p>output from <code><a href="#topic+resolve">resolve()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame ordered by installation order.
</p>


<h3>References</h3>

<p>Ripley, B. (2005) <a href="https://cran.r-project.org/doc/Rnews/Rnews_2005-1.pdf">Packages and their Management in R 2.1.0.</a> R News, 5(1):8&ndash;11.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                    snapshot_date = "2020-01-16")
    generate_installation_order(graph)
}

</code></pre>

<hr>
<h2 id='query_sysreqs'>Query for System Requirements</h2><span id='topic+query_sysreqs'></span>

<h3>Description</h3>

<p>This function takes an S3 object returned from <code><a href="#topic+resolve">resolve()</a></code> and (re)queries the System Requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_sysreqs(rang, os = "ubuntu-20.04")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_sysreqs_+3A_rang">rang</code></td>
<td>
<p>output from <code><a href="#topic+resolve">resolve()</a></code></p>
</td></tr>
<tr><td><code id="query_sysreqs_+3A_os">os</code></td>
<td>
<p>character, which OS to query for system requirements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>rang</code> S3 object with the following items
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>original function call</p>
</td></tr>
<tr><td><code>ranglets</code></td>
<td>
<p>List of dependency graphs of all packages in <code>pkgs</code></p>
</td></tr>
<tr><td><code>snapshot_date</code></td>
<td>
<p><code>snapshot_date</code></p>
</td></tr>
<tr><td><code>no_enhances</code></td>
<td>
<p><code>no_enhances</code></p>
</td></tr>
<tr><td><code>no_suggests</code></td>
<td>
<p><code>no_suggests</code></p>
</td></tr>
<tr><td><code>unresolved_pkgsrefs</code></td>
<td>
<p>Packages that can't be resolved</p>
</td></tr>
<tr><td><code>sysreqs</code></td>
<td>
<p>System requirements as Linux commands</p>
</td></tr>
<tr><td><code>r_version</code></td>
<td>
<p>The latest R version as of <code>snapshot_date</code></p>
</td></tr>
<tr><td><code>os</code></td>
<td>
<p><code>os</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+resolve">resolve()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                snapshot_date = "2020-01-16", query_sysreqs = FALSE)
    graph$sysreqs
    graph2 &lt;- query_sysreqs(graph, os = "ubuntu-20.04")
    graph2$sysreqs
}

</code></pre>

<hr>
<h2 id='recipes'>Recipes for Building Container Images</h2><span id='topic+recipes'></span>

<h3>Description</h3>

<p>A list containing several useful recipes for container building. Useful for the <code>post_installation_steps</code> argument of <code><a href="#topic+dockerize">dockerize()</a></code>. Available recipes are:
</p>

<ul>
<li> <p><code>texlive</code>: install pandoc and LaTeX, useful for rendering RMarkdown
</p>
</li>
<li> <p><code>texlivefull</code>: Similar to the above, but install the full distribution of TeX Live (~ 3GB)
</p>
</li>
<li> <p><code>quarto</code>: install quarto and tinytex
</p>
</li>
<li> <p><code>clean</code>: clean up the container image by removing cache
</p>
</li>
<li> <p><code>make</code>: install GNU make
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>recipes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                    snapshot_date = "2020-01-16")
    ## install texlive
    dockerize(graph, ".", post_installation_steps = recipes[['texlive']])
}

</code></pre>

<hr>
<h2 id='resolve'>Resolve Dependencies Of R Packages</h2><span id='topic+resolve'></span>

<h3>Description</h3>

<p>This function recursively queries dependencies of R packages at a specific snapshot time. The dependency graph can then be used to recreate the computational environment. The data on dependencies are provided by R-hub.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve(
  pkgs = ".",
  snapshot_date,
  no_enhances = TRUE,
  no_suggests = TRUE,
  query_sysreqs = TRUE,
  os = "ubuntu-20.04",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_+3A_pkgs">pkgs</code></td>
<td>
<p><code>pkgs</code> can be 1) a character vector of R packages to resolve, 2) a path to a <a href="https://rstudio.github.io/renv/articles/lockfile.html"><code>renv</code> lockfile</a>, or 3) a data structure that <code><a href="#topic+as_pkgrefs">as_pkgrefs()</a></code> can convert to a character vector of package references. For 1) <code>pkgs</code> can be either in shorthands, e.g. &quot;rtoot&quot;, &quot;ropensci/readODS&quot;, or in package references, e.g. &quot;cran::rtoot&quot;, &quot;github::ropensci/readODS&quot;. Please refer to the <a href="https://r-lib.github.io/pkgdepends/reference/pkg_refs.html">Package References documentation</a> of <code>pak</code> for details. Currently, this package supports only cran and github packages. For 2) <code><a href="#topic+as_pkgrefs">as_pkgrefs()</a></code> support the output of <code><a href="utils.html#topic+sessionInfo">sessionInfo()</a></code>, a renv lockfile or a single directory. If it is a single directory, all R scripts are scanned for R packages used using <code><a href="renv.html#topic+dependencies">renv::dependencies()</a></code>. Currently, the default is to scan the R scripts in the current working directory. Please also note that this scanning only assumes there are CRAN and Bioconductor packages. We strongly recommend checking whether this is really the case (see example below).</p>
</td></tr>
<tr><td><code id="resolve_+3A_snapshot_date">snapshot_date</code></td>
<td>
<p>Snapshot date, if not specified, assume to be a month ago</p>
</td></tr>
<tr><td><code id="resolve_+3A_no_enhances">no_enhances</code></td>
<td>
<p>logical, whether to ignore packages in the &quot;Enhances&quot; field</p>
</td></tr>
<tr><td><code id="resolve_+3A_no_suggests">no_suggests</code></td>
<td>
<p>logical, whether to ignore packages in the &quot;Suggests&quot; field</p>
</td></tr>
<tr><td><code id="resolve_+3A_query_sysreqs">query_sysreqs</code></td>
<td>
<p>logical, whether to query for System Requirements. Important: Archived CRAN can't be queried for system requirements. Those
packages are assumed to have no system requirement.</p>
</td></tr>
<tr><td><code id="resolve_+3A_os">os</code></td>
<td>
<p>character, which OS to query for system requirements</p>
</td></tr>
<tr><td><code id="resolve_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>rang</code> S3 object with the following items
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>original function call</p>
</td></tr>
<tr><td><code>ranglets</code></td>
<td>
<p>List of dependency graphs of all packages in <code>pkgs</code></p>
</td></tr>
<tr><td><code>snapshot_date</code></td>
<td>
<p><code>snapshot_date</code></p>
</td></tr>
<tr><td><code>no_enhances</code></td>
<td>
<p><code>no_enhances</code></p>
</td></tr>
<tr><td><code>no_suggests</code></td>
<td>
<p><code>no_suggests</code></p>
</td></tr>
<tr><td><code>unresolved_pkgsrefs</code></td>
<td>
<p>Packages that can't be resolved</p>
</td></tr>
<tr><td><code>sysreqs</code></td>
<td>
<p>System requirements as Linux commands</p>
</td></tr>
<tr><td><code>r_version</code></td>
<td>
<p>The latest R version as of <code>snapshot_date</code></p>
</td></tr>
<tr><td><code>os</code></td>
<td>
<p><code>os</code></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://r-lib.github.io/pkgdepends/reference/pkg_refs.html">Package References</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dockerize">dockerize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    graph &lt;- resolve(pkgs = c("openNLP", "LDAvis", "topicmodels", "quanteda"),
                snapshot_date = "2020-01-16")
    graph
    ## to resolve github packages
    gh_graph &lt;- resolve(pkgs = c("https://github.com/schochastics/rtoot"),
                   snapshot_date = "2022-11-28")
    gh_graph
    ## scanning
    graph &lt;- resolve(snapshot_date = "2022-11-28")
    ## But we recommend this:
    pkgs &lt;- as_pkgrefs(".")
    pkgs ## check the accuracy
    graph &lt;- resolve(pkgs, snapshot_date = "2022-11-28")
}

</code></pre>

<hr>
<h2 id='use_rang'>Setup rang for a directory</h2><span id='topic+use_rang'></span>

<h3>Description</h3>

<p>This <code>usethis</code>-style function adds the infrastructure in a directory (presumably with R scripts
and data) for (re)constructing the computational environment.
Specifically, this function inserts <code>inst/rang</code> into the directory, which contains
all components for the reconstruction. Optionally, <code>Makefile</code> and <code>.here</code> are also inserted
to ease the development of analytic code.
By default, (re)running this function does not overwrite any file. One can change this by setting
<code>force</code> to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_rang(
  path = ".",
  add_makefile = TRUE,
  add_here = TRUE,
  verbose = TRUE,
  force = FALSE,
  apptainer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_rang_+3A_path">path</code></td>
<td>
<p>character, path to the project root</p>
</td></tr>
<tr><td><code id="use_rang_+3A_add_makefile">add_makefile</code></td>
<td>
<p>logical, whether to insert a barebone <code>Makefile</code> in the project root.</p>
</td></tr>
<tr><td><code id="use_rang_+3A_add_here">add_here</code></td>
<td>
<p>logical, whether to insert a hidden <code>.here</code> file in the project root</p>
</td></tr>
<tr><td><code id="use_rang_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print out messages</p>
</td></tr>
<tr><td><code id="use_rang_+3A_force">force</code></td>
<td>
<p>logical, whether to overwrite files (<code>inst/rang/update.R</code>, <code>Makefile</code>, <code>.here</code>) if they
exist.</p>
</td></tr>
<tr><td><code id="use_rang_+3A_apptainer">apptainer</code></td>
<td>
<p>logical, whether to use apptainer. <code>FALSE</code> indicates using Docker</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The infrastructure being added to your path consists of:
</p>

<ul>
<li> <p><code>inst/rang</code> directory in the project root
</p>
</li>
<li> <p><code>update.R</code> file inside the directory
</p>
</li>
<li> <p><code>.here</code> in the project root (if <code>add_here</code> is TRUE)
</p>
</li>
<li> <p><code>Makefile</code> in the project root (if <code>add_makefile</code> is TRUE)
You might need to edit <code>update.R</code> manually. The default is to scan the whole project for
used R packages and assume they are either on CRAN or Bioconductor. If you have used other R packages,
you might need to edit this manually.
</p>
</li></ul>



<h3>Value</h3>

<p>path, invisibly
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
