<!DOCTYPE html><html><head><title>Help for package SFSI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SFSI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#1.+20Save+2Fread+20binary+20files'><p>Save/read binary files</p></a></li>
<li><a href='#2.+20Covariance+20matrix+20transformations'><p>Conversion of a covariance matrix to a distance/correlation matrix</p></a></li>
<li><a href='#3.+20Solve+20an+20Elastic-Net+20problem'><p>Coordinate Descent algorithm to solve Elastic-Net-type problems</p></a></li>
<li><a href='#4.+20Least+20Angle+20Regression+20+28LARS+29'><p>Least Angle Regression to solve LASSO-type problems</p></a></li>
<li><a href='#5.+20Sparse+20Genomic+20Prediction+20+28SGP+29'><p>Sparse Genomic Prediction</p></a></li>
<li><a href='#6.+20BLUP+20estimation+20from+20Linear+20Mixed+20Model'><p>Fitting a Linear Mixed model to calculate BLUP</p></a></li>
<li><a href='#7.+20Genetic+20covariances+20computation'><p>Pairwise Genetic Covariance</p></a></li>
<li><a href='#8.+20SGP+20accuracy+20vs+20penalization+20plot'><p>Accuracy vs penalization plot</p></a></li>
<li><a href='#Create+20partitions'><p>Data partition into folds of the same size</p></a></li>
<li><a href='#Graphical+20Network+20from+20a+20numeric+20matrix'><p>Graphical Network</p></a></li>
<li><a href='#Graphical+20network+20plot'><p>Plotting a network</p></a></li>
<li><a href='#Multi-trait+20SGP+20accuracy+20vs+20penalization+20plot'><p>Accuracy vs penalization from multi-trait SGP</p></a></li>
<li><a href='#R-squared+20pruning'><p>R-squared pruning</p></a></li>
<li><a href='#Reading+20and+20combining+20SGP+20outputs'><p>Read and combine SGP outputs</p></a></li>
<li><a href='#Regression+20coefficients+20and+20predicted+20values+20in+20LASSO-type+20problems'><p>LASSO methods</p></a></li>
<li><a href='#Regression+20coefficients+20path'><p>Coefficients path plot</p></a></li>
<li><a href='#Regression+20coefficients+2C+20predicted+20values+20and+20summary+20in+20SGP+20problems'><p>SGP methods</p></a></li>
<li><a href='#Wheat+20data+20set'><p>Wheat dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sparse Family and Selection Index</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Here we provide tools for the estimation of coefficients in penalized regressions when the (co)variance matrix of predictors and the covariance vector between predictors and response, are provided. These methods are extended to the context of a Selection Index (commonly used for breeding value prediction). The approaches offer opportunities such as the integration of high-throughput traits in genetic evaluations ('Lopez-Cruz et al., 2020') &lt;<a href="https://doi.org/10.1038%2Fs41598-020-65011-2">doi:10.1038/s41598-020-65011-2</a>&gt; and solutions for training set optimization in Genomic Prediction ('Lopez-Cruz &amp; de los Campos, 2021') &lt;<a href="https://doi.org/10.1093%2Fgenetics%2Fiyab030">doi:10.1093/genetics/iyab030</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MarcooLopez/SFSI">https://github.com/MarcooLopez/SFSI</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, scales, tensorEVD (&ge; 0.1.3), parallel, reshape2,
viridis, igraph, stringr, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BGLR, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-25 04:41:59 UTC; marco</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Lopez-Cruz [aut, cre],
  Gustavo de los Campos [aut],
  Paulino Perez-Rodriguez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Lopez-Cruz &lt;maraloc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 14:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='1.+20Save+2Fread+20binary+20files'>Save/read binary files</h2><span id='topic+readBinary'></span><span id='topic+saveBinary'></span>

<h3>Description</h3>

<p>Save/read a numeric data as a fortran-formatted binary file at a defined precision (single or double).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveBinary(X, file = paste0(tempdir(), "/file.bin"), 
           precision.format = c("double","single"), 
           verbose = TRUE)
  
readBinary(file = paste0(tempdir(), "/file.bin"), 
           rows = NULL, cols = NULL, 
           drop = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_x">X</code></td>
<td>
<p>(numeric matrix) Data to save</p>
</td></tr>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_file">file</code></td>
<td>
<p>(character) Name of the binary file to save/read</p>
</td></tr>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_precision.format">precision.format</code></td>
<td>
<p>(character) Either 'single' or 'double' for numeric precision and memory occupancy (4 bytes/32-bit or 8 bytes/64-bit, respectively) of the matrix to save</p>
</td></tr>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_rows">rows</code></td>
<td>
<p>(integer vector) Which rows are to be read from the file. Default <code>rows=NULL</code> will read all the rows</p>
</td></tr>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_cols">cols</code></td>
<td>
<p>(integer vector) Which columns are to be read from the file. Default <code>cols=NULL</code> will read all the columns</p>
</td></tr>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_drop">drop</code></td>
<td>
<p>Either <code>TRUE</code> or <code>FALSE</code> to whether return a uni-dimensional vector when data is a matrix with either 1 row or 1 column</p>
</td></tr>
<tr><td><code id="1.+2B20Save+2B2Fread+2B20binary+2B20files_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether printing file information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function 'saveBinary' does not return any value but print a description of the file saved. 
</p>
<p>Function 'readBinary' returns the data that was read.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  
  # A numeric matrix
  X = matrix(rnorm(500*100), ncol=100)
  
  # Save matrix as double-precision
  filename1 = paste0(tempdir(),"/Matrix1.bin")
  saveBinary(X, filename1, precision.format="double")
  
  # Save matrix as single-precision
  filename2 = paste0(tempdir(),"/Matrix2.bin")
  saveBinary(X, filename2, precision.format="single")

  # Read the double-precision matrix
  X2 = readBinary(filename1)
  max(abs(X-X2))             # No loss of precision
  file.info(filename1)$size  # Size of the file

  # Read the single-precision matrix
  X3 = readBinary(filename2)
  max(abs(X-X3))             # Loss of precision
  file.info(filename2)$size  # But smaller-size file

  # Read specific rows and columns
  rows = c(2,4,5,8,10)
  cols = c(1,2,5)
  (X2 = readBinary(filename1, rows=rows, cols=cols))
  # Equal to: 
  X[rows,cols]

</code></pre>

<hr>
<h2 id='2.+20Covariance+20matrix+20transformations'>Conversion of a covariance matrix to a distance/correlation matrix</h2><span id='topic+cov2dist'></span><span id='topic+cov2cor2'></span>

<h3>Description</h3>

<p>Transformation into correlation matrix or distance matrix from a covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov2dist(A, a = 1, inplace = FALSE)

cov2cor2(A, a = 1, inplace = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="2.+2B20Covariance+2B20matrix+2B20transformations_+3A_a">A</code></td>
<td>
<p>(numeric matrix) Variance-covariance matrix</p>
</td></tr>
<tr><td><code id="2.+2B20Covariance+2B20matrix+2B20transformations_+3A_inplace">inplace</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether operate directly on the input matrix.
When <code>TRUE</code> no result is produced but the input <code>A</code> is modified. Default <code>inplace=FALSE</code></p>
</td></tr>
<tr><td><code id="2.+2B20Covariance+2B20matrix+2B20transformations_+3A_a">a</code></td>
<td>
<p>(numeric) A number to multiply the whole resulting matrix by. Default <code>a = 1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any variables
X<sub>i</sub> and
X<sub>j</sub> with mean zero and with sample vectors
<b>x</b><sub>i</sub> = (x<sub>i1</sub>,...,x<sub>in</sub>)' and
<b>x</b><sub>j</sub> = (x<sub>j1</sub>,...,x<sub>jn</sub>)'
, their (sample) variances are equal (up-to a constant) to their cross-products, this is,
var(X<sub>i</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>i</sub> and
var(X<sub>j</sub>) = <b>x</b>'<sub>j</sub><b>x</b><sub>j</sub>.
Likewise, the covariance is
cov(X<sub>i</sub>,X<sub>j</sub>) = <b>x</b>'<sub>i</sub><b>x</b><sub>j</sub>.
</p>
<b>Distance.</b>
<p>The Euclidean distance
d(X<sub>i</sub>,X<sub>j</sub>)
between the variables expressed in terms of cross-products is
</p>
<p style='text-align:center'>d(X<sub>i</sub>,X<sub>j</sub>) = (<b>x</b>'<sub>i</sub><b>x</b><sub>i</sub> + <b>x</b>'<sub>j</sub><b>x</b><sub>j</sub> - 2<b>x</b>'<sub>i</sub><b>x</b><sub>j</sub>)<sup>1/2</sup></p>
<p>Therefore, the output distance matrix will contain as off-diagonal entries
</p>
<p style='text-align:center'>d(X<sub>i</sub>,X<sub>j</sub>) = (var(X<sub>i</sub>) + var(X<sub>j</sub>) - 2cov(X<sub>i</sub>,X<sub>j</sub>))<sup>1/2</sup></p>
<p>while in the diagonal, the distance between one variable with itself is
d(X<sub>i</sub>,X<sub>i</sub>) = 0
</p>
<b>Correlation.</b>
<p>The correlation between the variables is obtained from variances and covariances as
</p>
<p style='text-align:center'>cor(X<sub>i</sub>,X<sub>j</sub>) = cov(X<sub>i</sub>,X<sub>j</sub>)/(sd(X<sub>i</sub>)sd(X<sub>j</sub>))</p>
<p>where sd(X<sub>i</sub>)=sqrt(var(X<sub>i</sub>)); while in the diagonal, the correlation between one variable with itself is
cor(X<sub>i</sub>,X<sub>i</sub>) = 1
</p>
<p>Variances are obtained from the diagonal values while covariances are obtained from the out-diagonal.
</p>


<h3>Value</h3>

<p>Function 'cov2dist' returns a matrix containing the Euclidean distances. Function 'cov2cor2' returns a correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  X = scale(M)[1:100,]/sqrt(ncol(M))
  A = tcrossprod(X)        # A 100x100 covariance matrix 
  
  # Covariance matrix to distance matrix
  D = cov2dist(A)
  # (it must equal (but faster) to:)
  D0 = as.matrix(dist(X))
  max(D-D0)
  
  # Covariance to a correlation matrix
  R = cov2cor2(A)
  # (it must equal (but faster) to:)
  R0 = cov2cor(A)
  max(R-R0)
  
  # Inplace calculation
  A[1:5,1:5]
  cov2dist(A, inplace=TRUE)
  A[1:5,1:5]  # notice that A was modified
  
</code></pre>

<hr>
<h2 id='3.+20Solve+20an+20Elastic-Net+20problem'>Coordinate Descent algorithm to solve Elastic-Net-type problems</h2><span id='topic+solveEN'></span>

<h3>Description</h3>

<p>Computes the entire Elastic-Net solution for the regression coefficients for all
values of the penalization parameter, via the Coordinate Descent (CD) algorithm (Friedman, 2007). It uses as inputs a variance matrix among predictors and a covariance vector between response and predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveEN(Sigma, Gamma, alpha = 1, lambda = NULL, nlambda = 100, 
        lambda.min = .Machine$double.eps^0.5, lambda.max = NULL,
        common.lambda = TRUE, beta0 = NULL, nsup.max = NULL, 
        scale = TRUE, sdx = NULL, tol = 1E-5, maxiter = 1000, 
        mc.cores = 1L, save.at = NULL, fileID = NULL,
        precision.format = c("double","single"), verbose = FALSE)
        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_sigma">Sigma</code></td>
<td>
<p>(numeric matrix) Variance-covariance matrix of predictors</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_gamma">Gamma</code></td>
<td>
<p>(numeric matrix) Covariance between response variable and predictors. If it contains more than one column, the algorithm is applied to each column separately as different response variables</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_lambda">lambda</code></td>
<td>
<p>(numeric vector) Penalization parameter sequence. Default is <code>lambda = NULL</code>, in this case a decreasing grid of
<code>'nlambda'</code> lambdas will be generated starting from a maximum equal to
</p>
<p style='text-align:center;font-family:courier'>max(abs(Gamma)/alpha)</p>
<p>to a minimum equal to zero. If <code>alpha = 0</code> the grid is generated starting from a maximum equal to 5</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_nlambda">nlambda</code></td>
<td>
<p>(integer) Number of lambdas generated when <code>lambda = NULL</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_lambda.min">lambda.min</code>, <code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_lambda.max">lambda.max</code></td>
<td>
<p>(numeric) Minimum and maximum value of lambda that are generated when <code>lambda = NULL</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_common.lambda">common.lambda</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether computing the coefficients for a grid of lambdas common to all columns of <code>Gamma</code>
or for a grid of lambdas specific to each column of <code>Gamma</code>. Default is <code>common.lambda = TRUE</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_beta0">beta0</code></td>
<td>
<p>(numeric vector) Initial value for the regression coefficients that the algorithm will update for <code>maxiter</code> iterations. If <code>beta0 = NULL</code> a vector of zeros will be considered. These values will be used as starting values for the first lambda value</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) Value between 0 and 1 for the weights given to the L1 and L2-penalties</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_scale">scale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to scale matrix <code>Sigma</code> for variables with unit variance and scale <code>Gamma</code> by the standard deviation (<code>sdx</code>) of the corresponding predictor
taken from the diagonal of <code>Sigma</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_sdx">sdx</code></td>
<td>
<p>(numeric vector) Scaling factor that will be used to scale the regression coefficients. When <code>scale = TRUE</code> this scaling factor vector is set to the squared root of the diagonal of <code>Sigma</code>, otherwise a provided value is used assuming that <code>Sigma</code> and <code>Gamma</code> are scaled</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_tol">tol</code></td>
<td>
<p>(numeric) Maximum error between two consecutive solutions of the CD algorithm to declare convergence</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_maxiter">maxiter</code></td>
<td>
<p>(integer) Maximum number of iterations to run the CD algorithm at each lambda step before convergence is reached</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_nsup.max">nsup.max</code></td>
<td>
<p>(integer) Maximum number of non-zero coefficients in the last solution.
Default <code>nsup.max = NULL</code> will calculate solutions for the entire lambda grid</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_mc.cores">mc.cores</code></td>
<td>
<p>(integer) Number of cores used. When <code>mc.cores</code> &gt; 1, the analysis is run in parallel for each column of <code>Gamma</code>. Default is <code>mc.cores = 1</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_save.at">save.at</code></td>
<td>
<p>(character) Path where regression coefficients are to be saved (this may include a prefix added to the files). Default <code>save.at = NULL</code> will no save the regression coefficients and they are returned in the output object</p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_fileid">fileID</code></td>
<td>
<p>(character) Suffix added to the file name where regression coefficients are to be saved. Default <code>fileID = NULL</code> will automatically add sequential integers from 1 to the number of columns of <code>Gamma</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_precision.format">precision.format</code></td>
<td>
<p>(character) Either 'single' or 'double' for numeric precision and memory occupancy (4 or 8 bytes, respectively) of the regression coefficients. This is only used when <code>save.at</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="3.+2B20Solve+2B20an+2B20Elastic-Net+2B20problem_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether printing progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds solutions for the regression coefficients in a linear model
</p>
<p style='text-align:center'>y<sub>i</sub> = <b>x</b>'<sub>i</sub> <b>&beta;</b> + e<sub>i</sub></p>
<p>where
y<sub>i</sub> is the response for the i<sup>th</sup> observation,
<b>x</b><sub>i</sub> = (x<sub>i1</sub>,...,x<sub>ip</sub>)'
is a vector of <code class="reqn">p</code> predictors assumed to have unit variance,
<b>&beta;</b> = (&beta;<sub>1</sub>,...,&beta;<sub>p</sub>)'
is a vector of regression coefficients, and
e<sub>i</sub>
is a residual.
</p>
<p>The regression coefficients
<b>&beta;</b>
are estimated as function of the variance matrix among
predictors (<b>&Sigma;</b>) and the covariance vector between response and predictors (<b>&Gamma;</b>) by minimizing the penalized mean squared error function
</p>
<p style='text-align:center'>-<b>&Gamma;</b>' <b>&beta;</b> + 1/2 <b>&beta;</b>' <b>&Sigma;</b> <b>&beta;</b> + &lambda; J(<b>&beta;</b>)</p>
<p>where &lambda;
is the penalization parameter and
J(<b>&beta;</b>)
is a penalty function given by
</p>
<p style='text-align:center'>1/2(1-&alpha;)||<b>&beta;</b>||<sub>2</sub><sup>2</sup> + &alpha;||<b>&beta;</b>||<sub>1</sub></p>
<p>where 0 &le; &alpha; &le; 1, and
||<b>&beta;</b>||<sub>1</sub> = &sum;<sub>j=1</sub>|&beta;<sub>j</sub>| and
||<b>&beta;</b>||<sub>2</sub><sup>2</sup> = &sum;<sub>j=1</sub>&beta;<sub>j</sub><sup>2</sup> are the L1 and (squared) L2-norms, respectively.
</p>
<p>The &quot;partial residual&quot; excluding the contribution of the predictor
x<sub>ij</sub> is
</p>
<p style='text-align:center'>e<sub>i</sub><sup>(j)</sup> = y<sub>i</sub> - <b>x</b>'<sub>i</sub> <b>&beta;</b> + x<sub>ij</sub>&beta;<sub>j</sub></p>
<p>then the ordinary least-squares (OLS) coefficient of
x<sub>ij</sub>
on this residual is (up-to a constant)
</p>
<p style='text-align:center'>&beta;<sub>j</sub><sup>(ols)</sup> = &Gamma;<sub>j</sub> - <b>&Sigma;</b>'<sub>j</sub> <b>&beta;</b> + &beta;<sub>j</sub></p>
<p>where
&Gamma;<sub>j</sub>
is the j<sup>th</sup> element of
<b>&Gamma;</b> and
<b>&Sigma;</b><sub>j</sub>
is the j<sup>th</sup> column of the matrix
<b>&Sigma;</b>.
</p>
<p>Coefficients are updated for each <code class="reqn">j=1,...,p</code> from their current value
&beta;<sub>j</sub>
to a new value
&beta;<sub>j</sub>(&alpha;,&lambda;),
given &alpha; and
&lambda;,
by &quot;soft-thresholding&quot; their OLS estimate until convergence as fully described in Friedman (2007).
</p>


<h3>Value</h3>

<p>Returns a list object containing the elements:
</p>

<ul>
<li> <p><code>lambda</code>: (vector) all the sequence of values of the penalty.
</p>
</li>
<li> <p><code>beta</code>: (matrix) regression coefficients for each predictor (in rows) associated to each value of the penalization parameter lambda (in columns).
</p>
</li>
<li> <p><code>nsup</code>: (vector) number of non-zero predictors associated to each value of lambda.
</p>
</li></ul>

<p>The returned object is of the class 'LASSO' for which methods <code>coef</code> and <code>fitted</code> exist. Function 'path.plot' can be also used
</p>


<h3>References</h3>

<p>Friedman J, Hastie T, Höfling H, Tibshirani R (2007). Pathwise coordinate optimization. <em>The Annals of Applied Statistics</em>, <b>1</b>(2), 302–332.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  y = as.vector(Y[,"E1"])  # Response variable
  X = scale(X_E1)          # Predictors

  # Training and testing sets
  tst = which(Y$trial %in% 1:10)
  trn = seq_along(y)[-tst]

  # Calculate covariances in training set
  XtX = var(X[trn,])
  Xty = cov(X[trn,],y[trn])
  
  # Run the penalized regression
  fm = solveEN(XtX,Xty,alpha=0.5,nlambda=100) 
  
  # Regression coefficients
  dim(coef(fm))
  dim(coef(fm, ilambda=50)) # Coefficients associated to the 50th lambda
  dim(coef(fm, nsup=25))    # Coefficients with around nsup=25 are non-zero

  # Predicted values
  yHat1 = predict(fm, X=X[trn,])  # training data
  yHat2 = predict(fm, X=X[tst,])  # testing data
  
  # Penalization vs correlation
  plot(-log(fm$lambda[-1]),cor(y[trn],yHat1[,-1]), main="training", type="l")
  plot(-log(fm$lambda[-1]),cor(y[tst],yHat2[,-1]), main="testing", type="l")
</code></pre>

<hr>
<h2 id='4.+20Least+20Angle+20Regression+20+28LARS+29'>Least Angle Regression to solve LASSO-type problems</h2><span id='topic+LARS'></span>

<h3>Description</h3>

<p>Computes the entire LASSO solution for the regression coefficients, starting from zero, to the
least-squares estimates, via the Least Angle Regression (LARS) algorithm (Efron, 2004). It uses as inputs
a variance matrix among predictors and a covariance vector between response and predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LARS(Sigma, Gamma, method = c("LAR","LASSO"),
     nsup.max = NULL, eps = .Machine$double.eps*100,
     scale = TRUE, sdx = NULL, mc.cores = 1L, save.at = NULL,
     precision.format = c("double","single"),
     fileID = NULL, verbose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_sigma">Sigma</code></td>
<td>
<p>(numeric matrix) Variance-covariance matrix of predictors</p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_gamma">Gamma</code></td>
<td>
<p>(numeric matrix) Covariance between response variable and predictors. If it contains more than one column, the algorithm is applied to each column separately as different response variables</p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_method">method</code></td>
<td>
<p>(character) Either:
</p>

<ul>
<li> <p><code>'LAR'</code>: Computes the entire sequence of all coefficients. Values of lambdas are calculated at each step.
</p>
</li>
<li> <p><code>'LASSO'</code>: Similar to <code>'LAR'</code> but solutions when a predictor leaves the solution are also returned.
</p>
</li></ul>

<p>Default is <code>method = 'LAR'</code></p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_nsup.max">nsup.max</code></td>
<td>
<p>(integer) Maximum number of non-zero coefficients in the last LARS solution.
Default <code>nsup.max = NULL</code> will calculate solutions for the entire lambda sequence</p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_eps">eps</code></td>
<td>
<p>(numeric) An effective zero. Default is the machine precision</p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_scale">scale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to scale matrix <code>Sigma</code> for variables with unit variance and scale <code>Gamma</code> by the standard deviation (<code>sdx</code>) of the corresponding predictor
taken from the diagonal of <code>Sigma</code></p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_sdx">sdx</code></td>
<td>
<p>(numeric vector) Scaling factor that will be used to scale the regression coefficients. When <code>scale = TRUE</code> this scaling factor vector is set to the squared root of the diagonal of <code>Sigma</code>, otherwise a provided value is used assuming that <code>Sigma</code> and <code>Gamma</code> are scaled</p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_mc.cores">mc.cores</code></td>
<td>
<p>(integer) Number of cores used. When <code>mc.cores</code> &gt; 1, the analysis is run in parallel for each column of <code>Gamma</code>. Default is <code>mc.cores = 1</code></p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_save.at">save.at</code></td>
<td>
<p>(character) Path where regression coefficients are to be saved (this may include a prefix added to the files). Default <code>save.at = NULL</code> will no save the regression coefficients and they are returned in the output object</p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_fileid">fileID</code></td>
<td>
<p>(character) Suffix added to the file name where regression coefficients are to be saved. Default <code>fileID = NULL</code> will automatically add sequential integers from 1 to the number of columns of <code>Gamma</code></p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_precision.format">precision.format</code></td>
<td>
<p>(character) Either 'single' or 'double' for numeric precision and memory occupancy (4 or 8 bytes, respectively) of the regression coefficients. This is only used when <code>save.at</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="4.+2B20Least+2B20Angle+2B20Regression+2B20+2B28LARS+2B29_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether printing each LARS step</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds solutions for the regression coefficients in a linear model
</p>
<p style='text-align:center'>y<sub>i</sub> = <b>x</b>'<sub>i</sub> <b>&beta;</b> + e<sub>i</sub></p>
<p>where
y<sub>i</sub> is the response for the i<sup>th</sup> observation,
<b>x</b><sub>i</sub> = (x<sub>i1</sub>,...,x<sub>ip</sub>)'
is a vector of <code class="reqn">p</code> predictors assumed to have unit variance,
<b>&beta;</b> = (&beta;<sub>1</sub>,...,&beta;<sub>p</sub>)'
is a vector of regression coefficients, and
e<sub>i</sub>
is a residual.
</p>
<p>The regression coefficients
<b>&beta;</b>
are estimated as function of the variance matrix among
predictors (<b>&Sigma;</b>) and the covariance vector between response and predictors (<b>&Gamma;</b>) by minimizing the penalized mean squared error function
</p>
<p style='text-align:center'>-<b>&Gamma;</b>' <b>&beta;</b> + 1/2 <b>&beta;</b>'<b>&Sigma;</b><b>&beta;</b> + 1/2 &lambda; ||<b>&beta;</b>||<sub>1</sub></p>
<p>where &lambda;
is the penalization parameter and
||<b>&beta;</b>||<sub>1</sub> = &sum;<sub>j=1</sub>|&beta;<sub>j</sub>|
is the L1-norm.
</p>
<p>The algorithm to find solutions for each &beta;<sub>j</sub> is fully described in Efron (2004) in which the &quot;current correlation&quot; between the predictor
x<sub>ij</sub>
and the residual
e<sub>i</sub> = y<sub>i</sub> - <b>x</b>'<sub>i</sub> <b>&beta;</b>
is expressed (up-to a constant) as
</p>
<p style='text-align:center'>r<sub>j</sub> = &Gamma;<sub>j</sub> - <b>&Sigma;</b>'<sub>j</sub> <b>&beta;</b></p>
<p>where
&Gamma;<sub>j</sub>
is the j<sup>th</sup> element of
<b>&Gamma;</b> and
<b>&Sigma;</b><sub>j</sub>
is the j<sup>th</sup> column of the matrix
<b>&Sigma;</b>
</p>


<h3>Value</h3>

<p>Returns a list object with the following elements:
</p>

<ul>
<li> <p><code>lambda</code>: (vector) all the sequence of values of the LASSO penalty.
</p>
</li>
<li> <p><code>beta</code>: (matrix) regression coefficients for each predictor (in rows) associated to each value of the penalization parameter lambda (in columns).
</p>
</li>
<li> <p><code>nsup</code>: (vector) number of non-zero predictors associated to each value of lambda.
</p>
</li></ul>

<p>The returned object is of the class 'LASSO' for which methods <code>coef</code> and <code>predict</code> exist. Function 'path.plot' can be also used
</p>


<h3>Author(s)</h3>

<p>Adapted from the 'lars' function in package 'lars' (Hastie &amp; Efron, 2013)
</p>


<h3>References</h3>

<p>Efron B, Hastie T, Johnstone I, Tibshirani R (2004). Least angle regression. <em>The Annals of Statistics</em>, <b>32</b>(2), 407–499.
</p>
<p>Hastie T, Efron B (2013). lars: least angle regression, Lasso and forward stagewise. <a href="https://cran.r-project.org/package=lars">https://cran.r-project.org/package=lars</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  y = as.vector(Y[,"E1"])   # Response variable
  X = scale(X_E1)           # Predictors

  # Training and testing sets
  tst = which(Y$trial %in% 1:10)
  trn = seq_along(y)[-tst]

  # Calculate covariances in training set
  XtX = var(X[trn,])
  Xty = cov(X[trn,],y[trn])
  
  # Run the penalized regression
  fm = LARS(XtX, Xty, method="LASSO")  
  
  # Regression coefficients
  dim(coef(fm))
  dim(coef(fm, ilambda=50)) # Coefficients associated to the 50th lambda
  dim(coef(fm, nsup=25))    # Coefficients with around nsup=25 are non-zero

  # Predicted values
  yHat1 = predict(fm, X=X[trn,])  # training data
  yHat2 = predict(fm, X=X[tst,])  # testing data
  
  # Penalization vs correlation
  plot(-log(fm$lambda[-1]),cor(y[trn],yHat1[,-1]), main="Training", type="l")
  plot(-log(fm$lambda[-1]),cor(y[tst],yHat2[,-1]), main="Testing", type="l")
</code></pre>

<hr>
<h2 id='5.+20Sparse+20Genomic+20Prediction+20+28SGP+29'>Sparse Genomic Prediction</h2><span id='topic+SGP'></span><span id='topic+SGP.CV'></span>

<h3>Description</h3>

<p>Computes the entire Elastic-Net solution for the regression coefficients of a Selection Index for a grid of values of the penalization parameter.
</p>
<p>An optimal penalization can be chosen using cross-validation (CV) within a specific training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SGP(y = NULL, X = NULL, b = NULL, Z = NULL, K = NULL,
    trn = NULL, tst = NULL, varU = NULL, varE = NULL,
    ID_geno = NULL, ID_trait = NULL, intercept = TRUE,
    alpha = 1, lambda = NULL, nlambda = 100,
    lambda.min = .Machine$double.eps^0.5,
    common.lambda = TRUE, subset = NULL, tol = 1E-4,
    maxiter = 500, method = c("REML","ML"), tag = NULL,
    save.at = NULL, precision.format = c("single","double"),
    mc.cores = 1L, verbose = 2)
    
SGP.CV(y, X = NULL, b = NULL, Z = NULL, K,
       trn = NULL, varU = NULL, varE = NULL,
       ID_geno = NULL, ID_trait = NULL,
       intercept = TRUE, alpha = 1, lambda = NULL,
       nlambda = 100, lambda.min = .Machine$double.eps^0.5,
       common.lambda = TRUE, nfolds = 5, nCV = 1L,
       folds = NULL, seed = NULL, subset = NULL, tol = 1E-4,
       maxiter = 500, method = c("REML","ML"), tag = NULL,
       save.at = NULL, mc.cores = 1L, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_y">y</code></td>
<td>
<p>(numeric vector) Response variable. It can be a matrix with each column representing a different response variable. If it is passed to the 'SGP' function, predicted values for testing data are computed using phenotypes from training data</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_x">X</code></td>
<td>
<p>(numeric matrix) Design matrix for fixed effects. When <code>X = NULL</code>, a vector of ones is constructed only for the intercept (default)</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_b">b</code></td>
<td>
<p>(numeric vector) Fixed effects. When <code>b = NULL</code>, only the intercept is estimated from training data using generalized least squares (default)</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_k">K</code></td>
<td>
<p>(numeric matrix) Kinship relationship matrix</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_z">Z</code></td>
<td>
<p>(numeric matrix) Design matrix for random effects. When <code>Z = NULL</code> an identity matrix is considered (default) thus <b>G</b> = <b>K</b>; otherwise <b>G</b> = <b>Z K Z'</b> is used</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_varu">varU</code>, <code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_vare">varE</code></td>
<td>
<p>(numeric) Genetic and residual variances. When either <code>varU = NULL</code> or <code>varE = NULL</code> (default), they are calculated from training data using the function 'fitBLUP' (see <code>help(fitBLUP)</code>) for single-trait analysis or using the function 'getGenCov' for multi-trait analysis</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_id_geno">ID_geno</code></td>
<td>
<p>(character/integer) For multi-trait analysis only, vector with either names or indices mapping entries of the vector <code>y</code> to rows/columns of matrix <code>G</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_id_trait">ID_trait</code></td>
<td>
<p>(character/integer) For multi-trait analysis only, vector with either names or indices mapping entries of the vector <code>y</code> to rows/columns of matrices <code>varU</code> and <code>varE</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_intercept">intercept</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether fit an intercept. When <code>FALSE</code>, the model assumes a null intercept</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_trn">trn</code>, <code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_tst">tst</code></td>
<td>
<p>(integer vector) Which elements from vector <code>y</code> are in training and testing sets, respectively. When both <code>trn = NULL</code> and <code>tst = NULL</code>, non-NA entries in vector <code>y</code> will be used as training set</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_subset">subset</code></td>
<td>
<p>(integer vector) <code class="reqn">c(m,M)</code> to fit the model only for the m<sup>th</sup>
subset out of <code class="reqn">M</code> subsets that the testing set will be divided into. Results can be automatically saved as per the <code>save.at</code> argument and can be retrieved later using function 'read_SGP' (see <code>help(read_SGP)</code>). In cross-validation, it should has format <code class="reqn">c(fold,CV)</code> to fit the model for a given fold within partition</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) Value between 0 and 1 for the weights given to the L1 and L2-penalties</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_lambda">lambda</code></td>
<td>
<p>(numeric vector) Penalization parameter sequence. Default is <code>lambda = NULL</code>, in this case a decreasing grid of <code>nlambda</code> lambdas will be generated
starting from a maximum equal to
</p>
<p style='text-align:center;font-family:courier'>max(abs(G[trn,tst])/alpha)</p>
<p>to a minimum equal to zero. If <code>alpha = 0</code> the grid is generated starting from a maximum equal to 5</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_nlambda">nlambda</code></td>
<td>
<p>(integer) Number of lambdas generated when <code>lambda = NULL</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_lambda.min">lambda.min</code></td>
<td>
<p>(numeric) Minimum value of lambda in the generated grid when <code>lambda = NULL</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_nfolds">nfolds</code></td>
<td>
<p>(integer/character) Either 2,3,5,10 or 'n' indicating the number of non-overlapping folds in which the data is split into to do cross-validation. When <code>nfolds = 'n'</code> a leave-one-out CV is performed</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_seed">seed</code></td>
<td>
<p>(numeric vector) Seed to fix randomization when creating folds for cross-validation. If it is a vector, a number equal to its length of CV repetitions are performed</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_ncv">nCV</code></td>
<td>
<p>(integer) Number of CV repetitions to be performed. Default is <code>nCV = 1</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_folds">folds</code></td>
<td>
<p>(integer matrix) A matrix with <code>nTRN</code> rows and <code>nCV</code> columns where each column represents a different partition with <code>nfolds</code> folds. It can be created using the function 'get_folds'</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_common.lambda">common.lambda</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether computing the coefficients for a grid of lambdas common to all individuals in testing set
or for a grid of lambdas specific to each individual in testing set. Default is <code>common.lambda = TRUE</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_mc.cores">mc.cores</code></td>
<td>
<p>(integer) Number of cores used. When <code>mc.cores</code> &gt; 1, the analysis is run in parallel for each testing set individual. Default is <code>mc.cores = 1</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_tol">tol</code></td>
<td>
<p>(numeric) Maximum error between two consecutive solutions of the CD algorithm to declare convergence</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_maxiter">maxiter</code></td>
<td>
<p>(integer) Maximum number of iterations to run the CD algorithm at each lambda step before convergence is reached</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_save.at">save.at</code></td>
<td>
<p>(character) Path where files (regression coefficients and output object) are to be saved (this may include a prefix added to the files). Default <code>save.at = NULL</code> will no save any results and they are returned in the output object. No regression coefficients are saved for function 'SGP.CV'</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_precision.format">precision.format</code></td>
<td>
<p>(character) Either 'single' or 'double' for numeric precision and memory occupancy (4 or 8 bytes, respectively) of the regression coefficients. This is only used when <code>save.at</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_method">method</code></td>
<td>
<p>(character) Either 'REML' (Restricted Maximum Likelihood) or 'ML' (Maximum Likelihood) to calculate variance components as per the function 'fitBLUP'</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_tag">tag</code></td>
<td>
<p>(character) Name given to the output for tagging purposes. Default <code>tag = NULL</code> will give the name of the method used</p>
</td></tr>
<tr><td><code id="5.+2B20Sparse+2B20Genomic+2B20Prediction+2B20+2B28SGP+2B29_+3A_verbose">verbose</code></td>
<td>
<p>(integer) If greater than zero analysis details will be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic linear mixed model that relates phenotypes with genetic values is of the form
</p>
<p style='text-align:center'><b>y</b> = <b>X b</b> + <b>Z g</b> + <b>e</b></p>
<p>where
<b>y</b> is a vector with the response,
<b>b</b> is the vector of fixed effects,
<b>g</b> is the vector of the genetic values of the genotypes,
<b>e</b> is the vector of environmental residuals, and
<b>X</b> and <b>Z</b> are design matrices for the fixed and genetic effects, respectively. Genetic effects are assumed to follow a Normal distribution as
<b>g</b> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>u</sub><b>K</b>), and environmental terms are assumed
<b>e</b> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>e</sub><b>I</b>).
</p>
<p>The resulting vector of genetic values
<b>u</b> = <b>Z g</b> will therefore follow 
<b>u</b> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>u</sub><b>G</b>) where
<b>G</b> = <b>Z K Z'</b>.
In the un-replicated case, <b>Z</b> = <b>I</b> is an identity matrix, and hence 
<b>u</b> = <b>g</b> and
<b>G</b> = <b>K</b>.
</p>
<p>The values <b>u</b><sub>tst</sub> = {u<sub>i</sub>},
i = 1,2,...,n<sub>tst</sub>, for a testing set are estimated individual-wise using (as predictors) all available observations in a training set as
</p>
<p style='text-align:center'>u<sub>i</sub> = <b>&beta;</b>'<sub>i</sub> (<b>y</b><sub>trn</sub> - <b>X</b><sub>trn</sub><b>b</b>)</p>
<p>where <b>&beta;</b><sub>i</sub>
is a vector of weights that are found separately for each individual in the testing set, by minimizing the penalized mean squared error function
</p>
<p style='text-align:center'>-&sigma;<sup>2</sup><sub>u</sub><b>G</b>'<sub>trn,tst(i)</sub> <b>&beta;</b><sub>i</sub> + 1/2 <b>&beta;</b>'<sub>i</sub>(&sigma;<sup>2</sup><sub>u</sub><b>G</b><sub>trn</sub> + &sigma;<sup>2</sup><sub>e</sub><b>I</b>)<b>&beta;</b><sub>i</sub> + &lambda; J(<b>&beta;</b><sub>i</sub>)</p>
<p>where
<b>G</b><sub>trn,tst(i)</sub>
is the i<sup>th</sup> column of the
sub-matrix of <b>G</b> whose rows correspond to the training set and columns to the testing set;
<b>G</b><sub>trn</sub>
is the sub-matrix corresponding to the training set; &lambda; is the penalization parameter; and
J(<b>&beta;</b><sub>i</sub>)
is a penalty function given by
</p>
<p style='text-align:center'>1/2(1-&alpha;)||<b>&beta;</b><sub>i</sub>||<sub>2</sub><sup>2</sup> + &alpha;||<b>&beta;</b><sub>i</sub>||<sub>1</sub></p>
<p>where 0 &le; &alpha; &le; 1, and
||<b>&beta;</b><sub>i</sub>||<sub>1</sub> = &sum;<sub>j=1</sub>|&beta;<sub>ij</sub>| and
||<b>&beta;</b><sub>i</sub>||<sub>2</sub><sup>2</sup> = &sum;<sub>j=1</sub>&beta;<sub>ij</sub><sup>2</sup> are the L1 and (squared) L2-norms, respectively.
</p>
<p>Function 'SGP' calculates each individual solution using the function 'solveEN' (via the Coordinate Descent algorithm, see <code>help(solveEN)</code>) by setting the argument <code>Sigma</code> equal to
&sigma;<sup>2</sup><sub>u</sub><b>G</b><sub>trn</sub> + &sigma;<sup>2</sup><sub>e</sub><b>I</b>
and <code>Gamma</code> equal to
&sigma;<sup>2</sup><sub>u</sub><b>G</b><sub>trn,tst(i)</sub>.
</p>
<p>Function 'SGP.CV' performs cross-validation within the training data specified in argument <code>trn</code>. Training data is divided into <code class="reqn">k</code> folds and the SGP is sequentially derived for (all individuals in) one fold (as testing set) using information from the remaining folds (as training set).
</p>


<h3>Value</h3>

<p>Function 'SGP' returns a list object of the class 'SGP' for which methods <code>coef</code>, <code>predict</code>, <code>plot</code>, and <code>summary</code> exist. Functions 'net.plot' and 'path.plot' can be also used. It contains the elements:
</p>

<ul>
<li> <p><code>b</code>: (vector) fixed effects solutions (including the intercept).
</p>
</li>
<li> <p><code>Xb</code>: (vector) total fixed values (<b>X b</b>).
</p>
</li>
<li> <p><code>u</code>: (matrix) total genetic values (<b>u</b> = <b>Z g</b>)
for testing individuals (in rows) associated to each value of lambda (in columns).
</p>
</li>
<li> <p><code>varU</code>, <code>varE</code>, <code>h2</code>: variance components solutions.
</p>
</li>
<li> <p><code>alpha</code>: value for the elastic-net weights used.
</p>
</li>
<li> <p><code>lambda</code>: (matrix) sequence of values of lambda used (in columns) for each testing individual (in rows).
</p>
</li>
<li> <p><code>nsup</code>: (matrix) number of non-zero predictors at each solution given by lambda for each testing individual (in rows).
</p>
</li>
<li> <p><code>file_beta</code>: path where regression coefficients are saved.
</p>
</li></ul>

<p>Function 'SGP.CV' returns a list object of length <code>nCV</code> of the class 'SGP'. Optimal cross-validated penalization values can be obtained using the<code>summary</code> method. Method <code>plot</code> is also available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  index = which(Y$trial %in% 1:12)    # Use only a subset of data
  Y = Y[index,]
  M = scale(M[index,])/sqrt(ncol(M))  # Subset and scale markers
  G = tcrossprod(M)                   # Genomic relationship matrix
  Y0 = scale(as.matrix(Y[,4:6]))      # Response variable
  
  #---------------------------------------------------
  # Single-trait model
  #---------------------------------------------------
  y = Y0[,1]    
  
  # Training and testing sets
  tst = which(Y$trial %in% 2:3)
  trn = seq_along(y)[-tst]
  
  # Sparse genomic prediction
  fm1 = SGP(y, K=G, trn=trn, tst=tst)
  
  uHat = predict(fm1)        # Predicted values for each testing element
  out = summary(fm1)         # Useful function to get results
  corTST = out$accuracy      # Testing set accuracy (correlation cor(y,yHat))
  out$optCOR                 # SGP with maximum accuracy
  B = coef(fm1)              # Regression coefficients for all tst
  B = coef(fm1, iy=1)        # Coefficients for first tst (tst[1])
  B = coef(fm1, ilambda=10)  # Coefficients associated to the 10th lambda
  B = coef(fm1, nsup=10)     # Coefficients for which nsup=10
  
  plot(fm1)                  # Penalization vs accuracy plot
  plot(fm1, y.stat="MSE", ylab='Mean Square Error', xlab='Sparsity')     
  
  varU = fm1$varU
  varE = fm1$varE
  b = fm1$b
  
  #---------------------------------------------------
  # Predicting a testing set using a value of lambda
  # obtained from cross-validation in a traning set
  #---------------------------------------------------
  # Run a cross validation in training set
  fm2 = SGP.CV(y, K=G, varU=varU, varE=varE, b=b, trn=trn, nfolds=5, tag="1 5CV")
  lambda = summary(fm2)$optCOR["lambda"]

  # Fit the index with the obtained lambda
  fm3 = SGP(y, K=G, varU=varU, varE=varE, b=b, trn=trn, tst=tst, lambda=lambda)
  summary(fm3)$accuracy        # Testing set accuracy

  # Compare the accuracy with that of the non-sparse index (G-BLUP)
  summary(fm1)$accuracy[fm1$nlambda,1] # we take the last one
  
  #---------------------------------------------------
  # Multi-trait SGP
  #---------------------------------------------------
  ID_geno = as.vector(row(Y0))
  ID_trait = as.vector(col(Y0))
  y = as.vector(Y0)
  
  # Training and testing sets
  tst = c(which(ID_trait==1)[Y$trial %in% 2:3],
          which(ID_trait==2)[Y$trial %in% 2],
          which(ID_trait==3)[Y$trial %in% 3])
  trn = seq_along(y)[-tst]
  
  fmMT = SGP(y=y, K=G, ID_geno=ID_geno, ID_trait=ID_trait,
             trn=trn, tst=tst)
  
  multitrait.plot(fmMT)
  
</code></pre>

<hr>
<h2 id='6.+20BLUP+20estimation+20from+20Linear+20Mixed+20Model'>Fitting a Linear Mixed model to calculate BLUP</h2><span id='topic+fitBLUP'></span>

<h3>Description</h3>

<p>Solves the Linear Mixed Model and calculates the Best Linear Unbiased Predictor (BLUP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitBLUP(y, X = NULL, Z = NULL, K = NULL, trn = NULL,
        EVD = NULL, varU = NULL, varE = NULL,
        ID_geno = NULL, ID_trait = NULL, intercept = TRUE,
        BLUP = TRUE, method = c("REML","ML"),
        interval = c(1E-9,1E9), tol = 1E-8, maxiter = 1000,
        n.regions = 10, verbose = TRUE)
            
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_y">y</code></td>
<td>
<p>(numeric vector) Response variable. It can be a matrix with each column representing a different response variable</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_x">X</code></td>
<td>
<p>(numeric matrix) Design matrix for fixed effects. When <code>X=NULL</code> a vector of ones is constructed only for the intercept (default)</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_z">Z</code></td>
<td>
<p>(numeric matrix) Design matrix for random effects. When <code>Z=NULL</code> an identity matrix is considered (default) thus <b>G</b> = <b>K</b>; otherwise <b>G</b> = <b>Z K Z'</b> is used</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_k">K</code></td>
<td>
<p>(numeric matrix) Kinship relationship matrix</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_trn">trn</code></td>
<td>
<p>(integer vector) Which elements from vector <code>y</code> are to be used for training. When <code>trn = NULL</code>, non-NA entries in vector <code>y</code> will be used as training set</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_evd">EVD</code></td>
<td>
<p>(list) Eigenvectors and eigenvalues from eigenvalue decomposition (EVD) of <b>G</b> corresponding to training data</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_id_geno">ID_geno</code></td>
<td>
<p>(character/integer) For within-trait analysis only, vector with either names or indices mapping entries of the vector <code>y</code> to rows/columns of matrix <code>G</code></p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_id_trait">ID_trait</code></td>
<td>
<p>(character/integer) For within-trait analysis only, vector with either names or indices mapping entries of the vector <code>y</code> to different traits</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_varu">varU</code>, <code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_vare">varE</code></td>
<td>
<p>(numeric) Genetic and residual variances. When both <code>varU</code> and <code>varE</code> are not <code>NULL</code> they are not calculated; otherwise, the likelihood function (REML or ML) is optimized to search for the genetic/residual variances ratio</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_intercept">intercept</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether fit an intercept. When <code>FALSE</code>, the model assumes a null intercept</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_blup">BLUP</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether return the random effects estimates</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_method">method</code></td>
<td>
<p>(character) Either 'REML' (Restricted Maximum Likelihood) or 'ML' (Maximum Likelihood)</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_tol">tol</code></td>
<td>
<p>(numeric) Maximum error between two consecutive solutions (convergence tolerance) when finding the root of the log-likelihood's first derivative</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_maxiter">maxiter</code></td>
<td>
<p>(integer) Maximum number of iterations to run before convergence is reached</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_interval">interval</code></td>
<td>
<p>(numeric vector) Range of values in which the root is searched</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_n.regions">n.regions</code></td>
<td>
<p>(numeric) Number of regions in which the searched 'interval' is divided for local optimization</p>
</td></tr>
<tr><td><code id="6.+2B20BLUP+2B20estimation+2B20from+2B20Linear+2B20Mixed+2B20Model_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether show progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic linear mixed model that relates phenotypes with genetic values is of the form
</p>
<p style='text-align:center'><b>y</b> = <b>X b</b> + <b>Z g</b> + <b>e</b></p>
<p>where
<b>y</b> is a vector with the response,
<b>b</b> is the vector of fixed effects,
<b>u</b> is the vector of the (random) genetic effects of the genotypes,
<b>e</b> is the vector of environmental residuals (random error), and
<b>X</b> and <b>Z</b> are design matrices for the fixed and genetic effects, respectively. Genetic effects are assumed to follow a Normal distribution as
<b>g</b> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>u</sub><b>K</b>), and the error terms are assumed
<b>e</b> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>e</sub><b>I</b>).
</p>
<p>The vector of total genetic values
<b>u</b> = <b>Z g</b> will therefore follow 
<b>u</b> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>u</sub><b>G</b>) where
<b>G</b> = <b>Z K Z'</b>.
In the un-replicated case, <b>Z</b> = <b>I</b> is an identity matrix, and hence 
<b>u</b> = <b>g</b> and
<b>G</b> = <b>K</b>.
</p>
<p>The predicted values <b>u</b><sub>trn</sub> = {u<sub>i</sub>},
i = 1,2,...,n<sub>trn</sub>, corresponding to observed data (training set) are derived as
</p>
<p style='text-align:center'><b>u</b><sub>trn</sub> = <b>B</b> (<b>y</b><sub>trn</sub> - <b>X</b><sub>trn</sub><b>b</b>)</p>
<p>where <b>B</b>
is a matrix of weights given by
</p>
<p style='text-align:center'><b>B</b> = &sigma;<sup>2</sup><sub>u</sub><b>G</b><sub>trn</sub> (&sigma;<sup>2</sup><sub>u</sub><b>G</b><sub>trn</sub> + &sigma;<sup>2</sup><sub>e</sub><b>I</b>)<sup>-1</sup></p>
<p>where <b>G</b><sub>trn</sub>
is the sub-matrix corresponding to the training set. This matrix can be rewritten as
</p>
<p style='text-align:center'><b>B</b> = <b>G</b><sub>trn</sub> (<b>G</b><sub>trn</sub> + &theta;<b>I</b>)<sup>-1</sup></p>
<p>where &theta; = &sigma;<sup>2</sup><sub>e</sub>/&sigma;<sup>2</sup><sub>u</sub> is the residual/genetic variances ratio representing a ridge-like shrinkage parameter.
</p>
<p>The matrix <b>H</b> = <b>G</b><sub>trn</sub> + &theta;<b>I</b>
in the above equation can be used to obtain predictions corresponding to un-observed data (testing set),
<b>u</b><sub>tst</sub> = {u<sub>i</sub>},
i = 1,2,...,n<sub>tst</sub>, by  
</p>
<p style='text-align:center'><b>B</b> = <b>G</b><sub>tst,trn</sub> (<b>G</b><sub>trn</sub> + &theta;<b>I</b>)<sup>-1</sup></p>
<p>where
<b>G</b><sub>tst,trn</sub>
is the sub-matrix of <b>G</b> corresponding to the testing set (in rows) and training set (in columns).  
</p>
<p>Solutions are found using the GEMMA (Genome-wide Efficient Mixed Model Analysis) approach (Zhou &amp; Stephens, 2012). First, the Brent's method is implemented to solve for the genetic/residual variances ratio (i.e., 1/&theta;) from the first derivative of the log-likelihood (either REML or ML). Then, variances &sigma;<sup>2</sup><sub>u</sub> and &sigma;<sup>2</sup><sub>e</sub> are calculated. Finally, <b>b</b> is obtained using Generalized Least Squares.
</p>


<h3>Value</h3>

<p>Returns a list object that contains the elements:
</p>

<ul>
<li> <p><code>b</code>: (vector) fixed effects solutions (including the intercept).
</p>
</li>
<li> <p><code>u</code>: (vector) total genetic values (<b>u</b> = <b>Z g</b>).
</p>
</li>
<li> <p><code>g</code>: (vector) genetic effects solutions.
</p>
</li>
<li> <p><code>varU</code>: random effect variance.
</p>
</li>
<li> <p><code>varE</code>: residual variance.
</p>
</li>
<li> <p><code>h2</code>: heritability.
</p>
</li>
<li> <p><code>convergence</code>: (logical) whether Brent's method converged.
</p>
</li>
<li> <p><code>method</code>: either 'REML' or 'ML' method used.
</p>
</li></ul>



<h3>References</h3>

<p>Zhou X, Stephens M (2012). Genome-wide efficient mixed-model analysis for association studies. <em>Nature Genetics</em>, <b>44</b>(7), 821-824
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  index = which(Y$trial %in% 1:20)    # Use only a subset of data
  Y = Y[index,]
  M = scale(M[index,])/sqrt(ncol(M))  # Subset and scale markers
  G = tcrossprod(M)                   # Genomic relationship matrix
  Y0 = scale(as.matrix(Y[,4:6]))      # Response variable
  
  #---------------------------------------------------
  # Single-trait model
  #---------------------------------------------------
  y = Y0[,1]     
  
  # Training and testing sets
  tst = which(Y$trial %in% 1:3)
  trn = seq_along(y)[-tst]
  
  # Kinship-based model
  fm1 = fitBLUP(y, K=G, trn=trn)
  
  head(fm1$g)                  # Genetic effects
  plot(y[tst],fm1$yHat[tst])   # Predicted vs observed values in testing set
  cor(y[tst],fm1$yHat[tst])    # Prediction accuracy in testing set
  cor(y[trn],fm1$yHat[trn])    # Prediction accuracy in training set
  fm1$varU                     # Genetic variance
  fm1$varE                     # Residual variance
  fm1$h2                       # Heritability
  fm1$b                        # Fixed effects
  
  # Markers-based model
  fm2 = fitBLUP(y, Z=M, trn=trn)
  head(fm2$g)                   # Marker effects
  all.equal(fm1$yHat, fm2$yHat)
  fm2$varU                      # Genetic variance
  fm2$varU*sum(apply(M,2,var))
  
  #---------------------------------------------------
  # Multiple response variables
  #---------------------------------------------------
  ID_geno = as.vector(row(Y0))
  ID_trait = as.vector(col(Y0))
  y = as.vector(Y0)
  
  # Training and testing sets
  tst = c(which(ID_trait==1)[Y$trial %in% 1:3],
          which(ID_trait==2)[Y$trial %in% 1:3],
          which(ID_trait==3)[Y$trial %in% 1:3])
  trn = seq_along(y)[-tst]
  
  # Across traits model
  fm3 = fitBLUP(y, K=G, ID_geno=ID_geno, trn=trn)
  plot(fm1$yHat,fm3$yHat[ID_trait==1])  # different from the single-trait model
  
  # Within traits model: pass an index for traits
  fm4 = fitBLUP(y, K=G, ID_geno=ID_geno, ID_trait=ID_trait, trn=trn)
  plot(fm1$yHat,fm4$yHat[ID_trait==1])  # equal to the single-trait model
  
</code></pre>

<hr>
<h2 id='7.+20Genetic+20covariances+20computation'>Pairwise Genetic Covariance</h2><span id='topic+getGenCov'></span>

<h3>Description</h3>

<p>Pairwise genetic covariances for variables with the same experimental design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenCov(y, X = NULL, Z = NULL, K = NULL, trn = NULL,
          EVD = NULL, ID_geno, ID_trait, scale = TRUE,
          pairwise = TRUE, verbose = TRUE, ...)
          
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_y">y</code></td>
<td>
<p>(numeric matrix) Response variable vector. It can be a matrix with each column representing a different response variable</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_x">X</code></td>
<td>
<p>(numeric matrix) Design matrix for fixed effects. When <code>X=NULL</code> a vector of ones is constructed only for the intercept (default)</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_z">Z</code></td>
<td>
<p>(numeric matrix) Design matrix for random effects. When <code>Z=NULL</code> an identity matrix is considered (default) thus <b>G</b> = <b>K</b>; otherwise <b>G</b> = <b>Z K Z'</b> is used</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_k">K</code></td>
<td>
<p>(numeric matrix) Kinship relationship matrix</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_trn">trn</code></td>
<td>
<p>(integer vector) Which elements from vector <code>y</code> are to be used for training. When <code>trn = NULL</code>, non-NA entries in vector <code>y</code> will be used as training set</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_evd">EVD</code></td>
<td>
<p>(list) Eigenvectors and eigenvalues from eigenvalue decomposition (EVD) of <b>G</b> corresponding to training data</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_id_geno">ID_geno</code></td>
<td>
<p>(character/integer) Vector with either names or indices mapping entries of the vector <code>y</code> to rows/columns of matrix <code>G</code></p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_id_trait">ID_trait</code></td>
<td>
<p>(character/integer) Vector with either names or indices mapping entries of the vector <code>y</code> to different traits</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_scale">scale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to scale each column of <code>y</code> by their corresponding standard deviations so the resulting variables will have unit variance</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_pairwise">pairwise</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to calculate pairwise genetic covariances for all columns in <code>y</code>. When <code>pairwise = FALSE</code> (default) covariances of the first column in <code>y</code> with the remaining columns (2,...,<code>ncol(y)</code>) are calculated</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether show progress</p>
</td></tr>
<tr><td><code id="7.+2B20Genetic+2B20covariances+2B20computation_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function 'fitBLUP'</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Assumes that both <b>y</b><sub>1</sub> and
<b>y</b><sub>2</sub> follow the basic linear mixed model that relates phenotypes with genetic values of the form
</p>
<div style='text-align:center'><b>y</b><sub>1</sub> = <b>X b</b><sub>1</sub> + <b>Z g</b><sub>1</sub> + <b>e</b><sub>1</sub></div>
<div style='text-align:center'><b>y</b><sub>2</sub> = <b>X b</b><sub>2</sub> + <b>Z g</b><sub>2</sub> + <b>e</b><sub>2</sub></div>
<p>where
<b>b</b><sub>1</sub> and 
<b>b</b><sub>2</sub> are the specific fixed effects,
<b>g</b><sub>1</sub> and 
<b>g</b><sub>2</sub> are the specific genetic effects of the genotypes,
<b>e</b><sub>1</sub> and 
<b>e</b><sub>2</sub> are the vectors of specific environmental residuals, and
<b>X</b> and <b>Z</b> are common design matrices for the fixed and genetic effects, respectively. Genetic effects are assumed to follow a Normal distribution as
<b>g</b><sub>1</sub> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>u1</sub><b>K</b>) and 
<b>g</b><sub>2</sub> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>u2</sub><b>K</b>), and environmental terms are assumed
<b>e</b><sub>1</sub> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>e1</sub><b>I</b>) and
<b>e</b><sub>2</sub> ~ N(<b>0</b>,&sigma;<sup>2</sup><sub>e2</sub><b>I</b>).
</p>
<p>The genetic covariance 
&sigma;<sup>2</sup><sub>u1,u2</sub>
is estimated from the formula for the variance for the sum of two variables as 
</p>
<div style='text-align:center'>&sigma;<sup>2</sup><sub>u1,u2</sub> = 1/2(&sigma;<sup>2</sup><sub>u3</sub> - &sigma;<sup>2</sup><sub>u1</sub> - &sigma;<sup>2</sup><sub>u2</sub>)</div>
<p>where &sigma;<sup>2</sup><sub>u3</sub>
is the genetic variance of the variable 
<b>y</b><sub>3</sub> = <b>y</b><sub>1</sub> + <b>y</b><sub>2</sub> that also follows the same model as for 
<b>y</b><sub>1</sub> and
<b>y</b><sub>2</sub>.
</p>
<p>Likewise, the environmental covariance 
&sigma;<sup>2</sup><sub>e1,e2</sub>
is estimated as 
</p>
<div style='text-align:center'>&sigma;<sup>2</sup><sub>e1,e2</sub> = 1/2(&sigma;<sup>2</sup><sub>e3</sub> - &sigma;<sup>2</sup><sub>e1</sub> - &sigma;<sup>2</sup><sub>e2</sub>)</div>
<p>where &sigma;<sup>2</sup><sub>e3</sub>
is the error variance of the variable 
<b>y</b><sub>3</sub>.
</p>
<p>Solutions are found using the function 'fitBLUP' (see <code>help(fitBLUP)</code>) to sequentialy fit mixed models for all the variables <b>y</b><sub>1</sub>, <b>y</b><sub>2</sub> and
<b>y</b><sub>3</sub>.
</p>


<h3>Value</h3>

<p>Returns a list object that contains the elements:
</p>

<ul>
<li> <p><code>varU</code>: (vector) genetic variances.
</p>
</li>
<li> <p><code>varE</code>: (vector) error variances.
</p>
</li>
<li> <p><code>covU</code>: (vector) genetic covariances between response variable 1 and the rest.
</p>
</li>
<li> <p><code>covE</code>: (vector) environmental covariances between response variable 1 and the rest.
</p>
</li></ul>

<p>When <code>pairwise = TRUE</code>, <code>varU</code> and <code>varE</code> are matrices containing all variances (diagonal) and pairwise covariances (off diagonal)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  index = which(Y$trial %in% 1:10)    # Use only a subset of data
  Y = Y[index,]
  M = scale(M[index,])/sqrt(ncol(M))  # Subset and scale markers
  G = tcrossprod(M)                   # Genomic relationship matrix
  Y0 = scale(as.matrix(Y[,4:7]))      # Response variable
  
  ID_geno = as.vector(row(Y0))
  ID_trait = as.vector(col(Y0))
  y = as.vector(Y0)
  
  # Pairwise covariance for all columns in y
  fm = getGenCov(y=y, K=G, ID_geno=ID_geno, ID_trait=ID_trait)
  fm$varU           # Genetic variances
  fm$varE           # Residual variances
  fm$varU+fm$varE   # Phenotypic covariance
  var(Y0)           # Sample phenotypic covariance
  
  # Covariances between the first and the rest: y[,1] and y[,2:4]
  fm = getGenCov(y=y, K=G, ID_geno=ID_geno, ID_trait=ID_trait, pairwise=FALSE)
  fm$covU           # Genetic covariance between y[,1] and y[,2:4]
  
  # Containing some missing values:
  # The model is estimated from common training data
  YNA = Y0
  YNA[Y$trial %in% 1:2, 1] = NA
  YNA[Y$trial %in% 2:3, 3] = NA
  y = as.vector(YNA)
  
  fm = getGenCov(y=y, K=G, ID_geno=ID_geno, ID_trait=ID_trait)
  fm$varU 
  fm$varE
  
</code></pre>

<hr>
<h2 id='8.+20SGP+20accuracy+20vs+20penalization+20plot'>Accuracy vs penalization plot</h2><span id='topic+plot.SGP'></span>

<h3>Description</h3>

<p>Accuracy as a function of the penalization plot for an object of the class 'SGP'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SGP'
plot(..., x.stat = c("nsup","lambda"),
          y.stat = c("accuracy","MSE"),
          label = x.stat, nbreaks.x = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="8.+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed: 
</p>

<ul>
<li><p> One or more objects of the class 'SGP'
</p>
</li>
<li><p> Optional arguments for method <code>plot</code>: 'xlab', 'ylab', 'main', 'lwd', 'xlim', 'ylim'
</p>
</li>
<li><p> For multi-trait SGP, optional argument 'trait' to plot results for a specific trait
</p>
</li></ul>

</td></tr>
<tr><td><code id="8.+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_x.stat">x.stat</code></td>
<td>
<p>(character) Either 'nsup' (number of non-zero regression coefficients entering in the prediction of a given testing individual) or 'lambda' (penalization parameter in log scale) to plot in the x-axis</p>
</td></tr>
<tr><td><code id="8.+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_y.stat">y.stat</code></td>
<td>
<p>(character) Either 'accuracy' (correlation between observed and predicted values) or 'MSE' (mean squared error) to plot in the y-axis</p>
</td></tr>
<tr><td><code id="8.+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_label">label</code></td>
<td>
<p>(character) Similar to <code>x.stat</code> but to show the value in x-axis for which the y-axis is maximum</p>
</td></tr>
<tr><td><code id="8.+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_nbreaks.x">nbreaks.x</code></td>
<td>
<p>(integer) Number of breaks in the x-axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of either accuracy or MSE versus either the support set size (average number of predictors with non-zero regression coefficient) or versus lambda. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See examples in
  # help(SGP, package="SFSI")
</code></pre>

<hr>
<h2 id='Create+20partitions'>Data partition into folds of the same size</h2><span id='topic+get_folds'></span>

<h3>Description</h3>

<p>Create a random data partition of size <code>n</code> into <code>k</code> non-overlapping folds of approximately the same size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_folds(n, k = 5L, nCV = 1L, seed = NULL)
        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Create+2B20partitions_+3A_n">n</code></td>
<td>
<p>(integer) Sample size</p>
</td></tr>
<tr><td><code id="Create+2B20partitions_+3A_k">k</code></td>
<td>
<p>(integer) Number of folds</p>
</td></tr>
<tr><td><code id="Create+2B20partitions_+3A_ncv">nCV</code></td>
<td>
<p>(integer) Number of different partitions to be created</p>
</td></tr>
<tr><td><code id="Create+2B20partitions_+3A_seed">seed</code></td>
<td>
<p>(integer vector) Optional seed for randomization (see <code>help(set.seed)</code>). It has to be of length equal to <code>nCV</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code>n</code> rows and <code>nCV</code> columns. Each column contains a partition with <code>k</code> folds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  
  # Create 5 different partitions into 10 folds
  # for a sample size equal to 115
  out = get_folds(n=115, k=10, nCV=5)
  
  # Size of folds at first partition
  table(out[,1])
  
</code></pre>

<hr>
<h2 id='Graphical+20Network+20from+20a+20numeric+20matrix'>Graphical Network</h2><span id='topic+net'></span>

<h3>Description</h3>

<p>Obtain a Graphical Network representation from a matrix where nodes are subjects in the rows and columns, and edges are obtained from the matrix entries 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net(object, K = NULL,
    nsup = NULL, p.radius = 1.7,
    delta = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Graphical+2B20Network+2B20from+2B20a+2B20numeric+2B20matrix_+3A_object">object</code></td>
<td>
<p>Either a numeric matrix <code>X</code> or an object of the 'SGP' class. When the object is of the 'SGP' class the regression coefficients are used as <code>X</code></p>
</td></tr>
<tr><td><code id="Graphical+2B20Network+2B20from+2B20a+2B20numeric+2B20matrix_+3A_k">K</code></td>
<td>
<p>(numeric matrix) Kinship relationship matrix among nodes</p>
</td></tr>
<tr><td><code id="Graphical+2B20Network+2B20from+2B20a+2B20numeric+2B20matrix_+3A_nsup">nsup</code></td>
<td>
<p>(numeric) For a SGP, average number of training individuals contributing to the prediction (with non-zero regression coefficient) of testing individuals. Default <code>nsup = NULL</code> will use the value of <code>nsup</code> that yielded the optimal accuracy</p>
</td></tr>
<tr><td><code id="Graphical+2B20Network+2B20from+2B20a+2B20numeric+2B20matrix_+3A_p.radius">p.radius</code></td>
<td>
<p>(numeric) For a multi-trait SGP, a factor (x-folds radius) to separate each trait from the origin</p>
</td></tr>
<tr><td><code id="Graphical+2B20Network+2B20from+2B20a+2B20numeric+2B20matrix_+3A_delta">delta</code></td>
<td>
<p>(numeric) Minumum value to determine nodes to be connected. Default is the machine precision (numerical zero)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a numeric matrix <b>X</b>={x<sub>ij</sub>} with <code>m</code> rows and <code>n</code> columns, a graphical network with <code>m</code> + <code>n</code> nodes is obtained by defining edges connecting subjects in rows with those in columns. An edge between subject in row <code>i</code> and subject in column <code>j</code> is
determined if the corresponding (absolute) entry matrix is larger than certain value, i.e., |x<sub>ij</sub>|&gt;&delta;.
</p>
<p>For a symmetric matrix, only <code>m</code>=<code>n</code> nodes are considered with edges determined by the above diagonal entries of the matrix.
</p>
<p>Nodes and edges are plotted in the cartesian plane according to the Fruchterman-Reingold algorithm. When a matrix <b>K</b> is provided, nodes are plotted according to the top 2 eigenvectors from the spectral value decomposition of <b>K</b> = <b>U D U'</b>.
</p>
<p>When the object is a 'SGP' class object the edges are taken from the regression coefficients (associated to a specific <code>nsup</code> value) are used as matrix <b>X</b> with testing subjects in rows and training subjects in columns.  
</p>


<h3>Value</h3>

<p>Returns a plottable object of the class 'net' that can be visualized using 'plot' method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  #--------------------------------------
  # Net for an SGP object
  #--------------------------------------
  index = which(Y$trial %in% 1:6)     # Use only a subset of data
  Y = Y[index,]
  M = scale(M[index,])/sqrt(ncol(M))  # Subset and scale markers
  G = tcrossprod(M)                   # Genomic relationship matrix
  y = as.vector(scale(Y[,"E1"]))      # Scale response variable
  
  # Training and testing sets
  tst = which(Y$trial %in% 2)
  trn = seq_along(y)[-tst]

  fm = SGP(y, K=G, trn=trn, tst=tst)
  
  nt = net(fm)          # Get the net
  plot(nt)              # Plot the net
  plot(nt, i=c(1,5))    # Show the first and fifth tst elements
  plot(net(fm, nsup=10), show.names=c(TRUE,TRUE,FALSE))
  
  #--------------------------------------
  # Net for a numeric matrix
  #--------------------------------------
  B = as.matrix(coef(fm, nsup=10))
  plot(net(B), curve=TRUE, set.size=c(3.5,1.5,1))
  
  #--------------------------------------
  # Net for a symmetric numeric matrix
  #--------------------------------------
  X = X_E1[,seq(1,ncol(X_E1),by=5)]
  R2 = cor(X)^2  # An R2 matrix
  plot(net(R2, delta=0.9))
  
</code></pre>

<hr>
<h2 id='Graphical+20network+20plot'>Plotting a network</h2><span id='topic+plot.net'></span>

<h3>Description</h3>

<p>Plot a Graphical Network obtained from a numeric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'net'
plot(x, i = NULL, show.names = FALSE,
        group = NULL, group.shape = NULL,
        set.color = NULL, set.size = NULL,
        axis.labels = TRUE, curve = FALSE,
        bg.color = "white", unified = TRUE, ni = 36,
        line.color = "gray70", line.tick = 0.3,
        legend.pos = "right", point.color = "gray20",
        sets = c("Testing","Supporting","Non-active"),
        circle = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_x">x</code></td>
<td>
<p>An object of the 'net' class as per the <code>net</code> function</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_i">i</code></td>
<td>
<p>(integer vector) Index subjects in rows to be shown in plot. Default <code>i=NULL</code> will consider all elements in rows</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_show.names">show.names</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether show node names given by the row/column names of the matrix used to make the net (see <code>help(net)</code>)</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_group">group</code></td>
<td>
<p>(data.frame) Column grouping for the subjects</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_group.shape">group.shape</code></td>
<td>
<p>(integer vector) Shape of each level of the grouping column provided as <code>group</code></p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_bg.color">bg.color</code></td>
<td>
<p>(character) Plot background color</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_line.color">line.color</code></td>
<td>
<p>(character) Color of lines connecting nodes in rows with those in columns</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_line.tick">line.tick</code></td>
<td>
<p>(numeric) Tick of lines connecting nodes in rows with those in columns</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_curve">curve</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether draw curve lines connecting nodes in rows with those in columns</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_set.color">set.color</code></td>
<td>
<p>(character vector) Color point of each type of node: row, 'active' column, and 'non-active' column, respectively</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_set.size">set.size</code></td>
<td>
<p>(numeric vector) Size of each type of node: row, 'active' column, and 'non-active' column, respectively</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_axis.labels">axis.labels</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether show labels in both axes</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_unified">unified</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether show an unified plot or separated for each individual in 'testing'</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_point.color">point.color</code></td>
<td>
<p>(character) Color of the points in the plot</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_ni">ni</code></td>
<td>
<p>(integer) Maximum number of row nodes that are plotted separated as indicated by <code>unified=FALSE</code></p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>(character) Either &quot;right&quot;, topright&quot;,&quot;bottomleft&quot;,&quot;bottomright&quot;,&quot;topleft&quot;, or &quot;none&quot; indicating where the legend is positioned in the plot</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_sets">sets</code></td>
<td>
<p>(character vector) Names of the types of node: row, 'active' column, and 'non-active' column, respectively</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_circle">circle</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether draw a circle for each trait in a multi-trait 'SGP'</p>
</td></tr>
<tr><td><code id="Graphical+2B20network+2B20plot_+3A_...">...</code></td>
<td>
<p>Other arguments for method <code>plot</code>: 'xlab', 'ylab', 'main'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot a Graphical Network from a matrix where nodes are subjects in the rows and columns, and edges are obtained from the matrix entries. This Network is obtained using <code>net</code> function 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See examples in
  # help(net, package="SFSI")
</code></pre>

<hr>
<h2 id='Multi-trait+20SGP+20accuracy+20vs+20penalization+20plot'>Accuracy vs penalization from multi-trait SGP</h2><span id='topic+multitrait.plot'></span>

<h3>Description</h3>

<p>Visualizing results from an object of the class 'SGP'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multitrait.plot(object, trait_names = NULL,
                x.stat = c("nsup","lambda"),
                y.stat = c("accuracy","MSE"), label = x.stat,
                line.color = "orange", point.color = line.color,
                point.size = 1.2, nbreaks.x = 6, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_object">object</code></td>
<td>
<p>An object of the class 'SGP' for a multi-trait case</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_x.stat">x.stat</code></td>
<td>
<p>(character) Either 'nsup' (number of non-zero regression coefficients entering in the prediction of a given testing individual) or 'lambda' (penalization parameter in log scale) to plot in the x-axis</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_y.stat">y.stat</code></td>
<td>
<p>(character) Either 'accuracy' (correlation between observed and predicted values) or 'MSE' (mean squared error) to plot in the y-axis</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_label">label</code></td>
<td>
<p>(character) Similar to <code>x.stat</code> but to show the value in x-axis for which the y-axis is maximum across traits</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_point.color">point.color</code>, <code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_line.color">line.color</code></td>
<td>
<p>(character) Color of the points and lines</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_point.size">point.size</code></td>
<td>
<p>(numeric) Size of the points showing the maximum accuracy</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_nbreaks.x">nbreaks.x</code></td>
<td>
<p>(integer) Number of breaks in the x-axis</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_trait_names">trait_names</code></td>
<td>
<p>(character) Names of traits to be shown in the plot</p>
</td></tr>
<tr><td><code id="Multi-trait+2B20SGP+2B20accuracy+2B20vs+2B20penalization+2B20plot_+3A_...">...</code></td>
<td>
<p>Other arguments for method <code>plot</code>: 'xlab', 'ylab', 'main', 'lwd', 'xlim', 'ylim'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot of either accuracy or MSE versus either the support set size (average number of predictors with non-zero regression coefficient) or versus lambda. This is done separately for each trait 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See examples in
  # help(SGP, package="SFSI")
</code></pre>

<hr>
<h2 id='R-squared+20pruning'>R-squared pruning</h2><span id='topic+Prune'></span>

<h3>Description</h3>

<p>Pruning features using an R-squared threshold and maximum distance 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prune(X, alpha = 0.95, 
      pos = NULL, d.max = NULL, 
      centered = FALSE, scaled = FALSE,
      verbose = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R-squared+2B20pruning_+3A_x">X</code></td>
<td>
<p>(numeric matrix) A matrix with observations in rows and features (e.g., SNPs) in columns</p>
</td></tr>
<tr><td><code id="R-squared+2B20pruning_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) R-squared threshold used to determine connected sets</p>
</td></tr>
<tr><td><code id="R-squared+2B20pruning_+3A_pos">pos</code></td>
<td>
<p>(numeric vector) Optional vector with positions (e.g., bp) of features</p>
</td></tr>
<tr><td><code id="R-squared+2B20pruning_+3A_d.max">d.max</code></td>
<td>
<p>(numeric) Maximum distance that connected sets are apart</p>
</td></tr>
<tr><td><code id="R-squared+2B20pruning_+3A_centered">centered</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> whether columns in <code>X</code> are centered with mean zero</p>
</td></tr>
<tr><td><code id="R-squared+2B20pruning_+3A_scaled">scaled</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> whether columns in <code>X</code> are scaled with unit standard deviation</p>
</td></tr>
<tr><td><code id="R-squared+2B20pruning_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether show progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm identifies sets of connected features as those that share an 
R<sup>2</sup> > &alpha; and retains
only one feature (first appearance) for each set.
</p>
<p>The sets can be limited to lie within a distance less or equal to a <code>d.max</code> value.
</p>


<h3>Value</h3>

<p>Returns a list object that contains the elements:
</p>

<ul>
<li> <p><code>prune.in</code>: (vector) indices of selected (unconnected) features.
</p>
</li>
<li> <p><code>prune.out</code>: (vector) indices of dropped out features.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  index = c(154:156,201:205,306:312,381:387,540:544)
  X = M[,index]          # Subset markers
  colnames(X) = 1:ncol(X)
  
  # See connected sets using R^2=0.8
  R2thr = 0.8
  R2 = cor(X)^2
  nw1 = net(R2, delta=R2thr) 
  plot(nw1, show.names=TRUE)

  # Get pruned features
  res = Prune(X, alpha=R2thr)

  # See selected (unconnected) features
  nw2 = net(R2[res$prune.in,res$prune.in], delta=R2thr) 
  nw2$xy = nw1$xy[res$prune.in,]
  plot(nw2, show.names=TRUE)

</code></pre>

<hr>
<h2 id='Reading+20and+20combining+20SGP+20outputs'>Read and combine SGP outputs</h2><span id='topic+read_SGP'></span><span id='topic+read_summary'></span>

<h3>Description</h3>

<p>Read the output generated by the 'SGP' or 'SGP.CV' functions saved at the provided <code>save.at</code> parameter. It merges all partial files when data was splited according to argument <code>subset</code>. Function 'read_summary' reads the output generated after calling the method <code>summary</code>; multiple outputs are read if argument <code>path</code> is a vector and in this case, they are combined by averaging across all outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_SGP(path = ".", type = NULL,
         file.ext = ".RData", verbose = TRUE)

read_summary(path = ".", type = NULL,
             file.ext = ".RData", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reading+2B20and+2B20combining+2B20SGP+2B20outputs_+3A_path">path</code></td>
<td>
<p>(character) Path where output files were saved. This may include a prefix</p>
</td></tr>
<tr><td><code id="Reading+2B20and+2B20combining+2B20SGP+2B20outputs_+3A_type">type</code></td>
<td>
<p>(character) Either 'SGP' or 'SGP.CV' to collect results generated by either function of the same name</p>
</td></tr>
<tr><td><code id="Reading+2B20and+2B20combining+2B20SGP+2B20outputs_+3A_file.ext">file.ext</code></td>
<td>
<p>(character) This is the file extension at which file was saved as per the argument <code>save.at</code></p>
</td></tr>
<tr><td><code id="Reading+2B20and+2B20combining+2B20SGP+2B20outputs_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether printing details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class 'SGP' for which methods <code>predict</code>, <code>plot</code> and <code>summary</code> exist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  index = which(Y$trial %in% 1:10)    # Use only a subset of data
  Y = Y[index,]
  M = scale(M[index,])/sqrt(ncol(M))  # Subset and scale markers
  G = tcrossprod(M)                   # Genomic relationship matrix
  y = as.vector(scale(Y[,"E1"]))      # Scale response variable
  
  # Training and testing sets
  tst = which(Y$trial %in% 1:3)
  trn = seq_along(y)[-tst]
  
  path = paste0(tempdir(),"/testSGP_")
  
  # Run the analysis into 4 subsets and save them at a given path
  SGP(y, K=G, trn=trn, tst=tst, subset=c(1,4), save.at=path)
  SGP(y, K=G, trn=trn, tst=tst, subset=c(2,4), save.at=path)
  SGP(y, K=G, trn=trn, tst=tst, subset=c(3,4), save.at=path)
  SGP(y, K=G, trn=trn, tst=tst, subset=c(4,4), save.at=path)

  # Collect all results after completion
  fm = read_SGP(path)
  
  # Generate and save summary 
  summary(fm, save.at=path)
  fm2 = read_summary(path)
</code></pre>

<hr>
<h2 id='Regression+20coefficients+20and+20predicted+20values+20in+20LASSO-type+20problems'>LASSO methods</h2><span id='topic+coef.LASSO'></span><span id='topic+predict.LASSO'></span>

<h3>Description</h3>

<p>Retrieving regression coefficients and predicted values from the 'solveEN' and 'LARS' functions' outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LASSO'
coef(object, ...)

## S3 method for class 'LASSO'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Regression+2B20coefficients+2B20and+2B20predicted+2B20values+2B20in+2B20LASSO-type+2B20problems_+3A_object">object</code></td>
<td>
<p>An object of the class 'LASSO' returned either by the function 'LARS' or 'solveEN'</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20and+2B20predicted+2B20values+2B20in+2B20LASSO-type+2B20problems_+3A_...">...</code></td>
<td>
<p>Other arguments: 
</p>

<ul>
<li> <p><code>X</code> (numeric matrix) scores for as many predictors there are in <code>ncol(object$beta)</code>  (in columns) for a desired number <code>n</code>  of observations (in rows)
</p>
</li>
<li> <p><code>iy</code> (integer vector) Optional index of columns of the matrix 'Gamma' to be returned in <code>coef</code> function
</p>
</li>
<li> <p><code>ilambda</code> (integer) Optional to return regression coefficients associated to a specific penalty position
</p>
</li>
<li> <p><code>nsup</code> (numeric) Optional to return regression coefficients associated to a given penalty that yield approximately 'nsup' non-zero coefficients
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>Method <code>coef</code> returns a matrix that contains the regression coefficients (in rows) associated to each value of lambda (in columns). When the regression was applied to an object <code>Gamma</code> with more than one column, method <code>coef</code> returns a list
</p>
<p>Method <code>predict</code> returns a matrix with predicted values
X&beta; (in rows)
for each value of lambda (in columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See examples in
  # help(solveEN, package="SFSI")
  # help(LARS, package="SFSI")
</code></pre>

<hr>
<h2 id='Regression+20coefficients+20path'>Coefficients path plot</h2><span id='topic+path.plot'></span>

<h3>Description</h3>

<p>Coefficients evolution path plot from an object of the class 'LASSO' or 'SGP'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.plot(object, K = NULL, i = NULL,
          prune = FALSE, cor.max = 0.97,
          lambda.min = .Machine$double.eps^0.5,
          nbreaks.x = 6, npaths.max = 5000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_object">object</code></td>
<td>
<p>An object of the 'LASSO' or 'SGP' class</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_k">K</code></td>
<td>
<p>(numeric matrix) Kinship relationships. Only needed for an object of the class 'SGP'</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_i">i</code></td>
<td>
<p>(integer vector) Index a response variable (columns of matrix <code>Gamma</code>) for an object of the class 'LASSO'. Index testing elements (stored in <code>object$tst</code>) for an object of the class 'SGP'. Default <code>i = NULL</code> will consider either all columns in matrix <code>Gamma</code> or all elements in <code>object$tst</code>, respectively</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_prune">prune</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether prune within groups of correlated coefficients, keeping only one per group. A group of coefficients that are highly correlated are likely to overlap in the plot</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_cor.max">cor.max</code></td>
<td>
<p>(numeric) Correlation threshold to prune within groups of correlated coefficients</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_lambda.min">lambda.min</code></td>
<td>
<p>(numeric) Minimum value of lambda to show in the plot as <code>-log(lambda)</code>. This prevents <code>-log(lambda)</code> going to infinite for near-zero lambda values</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_nbreaks.x">nbreaks.x</code></td>
<td>
<p>(integer) Number of breaks in the x-axis</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_npaths.max">npaths.max</code></td>
<td>
<p>(integer) Maximum number of paths defined by the number of predictors times the number of columns of matrix <code>Gamma</code> for an object of the class 'LASSO'. This correspond to the number of training elements (stored in <code>object$trn</code>) times the number of testing elements (stored in <code>object$tst</code>) for an object of the class 'SGP'</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B20path_+3A_...">...</code></td>
<td>
<p>Other arguments for method <code>plot</code>: 'xlab', 'ylab', 'main', 'lwd'
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the plot of the coefficients' evolution path along the regularization parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  require(SFSI)
  data(wheatHTP)
  
  index = which(Y$trial %in% 1:6)       # Use only a subset of data
  Y = Y[index,]
  X = scale(X_E1[index,])               # Reflectance data
  M = scale(M[index,])/sqrt(ncol(M))    # Subset and scale markers
  G = tcrossprod(M)                     # Genomic relationship matrix
  y = as.vector(scale(Y[,'E1']))        # Subset response variable
  
  # Sparse phenotypic regression
  fm = LARS(var(X),cov(X,y))
  
  path.plot(fm)
  
  # Sparse Genomic Prediction
  fm = SGP(y, K=G, trn=12:length(y), tst=1:11)
  
  path.plot(fm, prune=TRUE)
  path.plot(fm, K=G, prune=TRUE, cor.max=0.9)
  
  # Path plot for the first individual in testing set for the SGP
  path.plot(fm, K=G, i=1)
</code></pre>

<hr>
<h2 id='Regression+20coefficients+2C+20predicted+20values+20and+20summary+20in+20SGP+20problems'>SGP methods</h2><span id='topic+summary.SGP'></span><span id='topic+coef.SGP'></span><span id='topic+predict.SGP'></span>

<h3>Description</h3>

<p>Useful methods for retrieving and summarizing important results from the 'SGP' function's output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SGP'
coef(object, ...)

## S3 method for class 'SGP'
predict(object, ...)

## S3 method for class 'SGP'
summary(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Regression+2B20coefficients+2B2C+2B20predicted+2B20values+2B20and+2B20summary+2B20in+2B20SGP+2B20problems_+3A_object">object</code></td>
<td>
<p>An object of the class 'SGP'</p>
</td></tr>
<tr><td><code id="Regression+2B20coefficients+2B2C+2B20predicted+2B20values+2B20and+2B20summary+2B20in+2B20SGP+2B20problems_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>coef</code> method: 
</p>

<ul>
<li> <p><code>nsup</code>: (numeric) Average (across testing individuals) number of non-zero regression coefficients. Only the coefficients for the lambda associated to <code>nsup</code> are returned as a 'matrix' with testing individuals in rows
</p>
</li>
<li> <p><code>iy</code>: (integer vector) Index testing elements (stored in <code>object$tst</code>) to be considered. Only coefficients corresponding to the testing individuals <code>object$tst[iy]</code> are returned
</p>
</li></ul>

<p>For <code>predict</code> and <code>summary</code> methods:
</p>

<ul>
<li> <p><code>y</code>: (numeric vector) An optional response vector
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>Method <code>predict</code> returns a matrix with the predicted values for each individual in the testing set (in rows) for each value of lambda (in columns).
</p>
<p>Method <code>coef</code> (list of matrices) returns the regression coefficients for each testing set individual (elements of the list). Each matrix contains the coefficients for each value of lambda (in rows) associated to each training set individual (in columns). 
</p>
<p>Method <code>summary</code> returns a list object containing:
</p>

<ul>
<li> <p><code>lambda</code>: (vector) sequence of values of lambda used in the coefficients' estimation.
</p>
</li>
<li> <p><code>nsup</code>: (vector) Number of non-zero coefficients (across testing individuals) at each solution associated to each value of lambda.
</p>
</li>
<li> <p><code>accuracy</code>: (vector) correlation between observed and predicted values associated to each value of lambda.
</p>
</li>
<li> <p><code>MSE</code>: (vector) mean squared error associated to each value of lambda.
</p>
</li>
<li> <p><code>optCOR</code>: (vector) summary of the optimal SGP with maximum accuracy.
</p>
</li>
<li> <p><code>optMSE</code>: (vector) summary of the optimal SGP with minimum MSE.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # See examples in
  # help(SGP, package="SFSI")
</code></pre>

<hr>
<h2 id='Wheat+20data+20set'>Wheat dataset</h2><span id='topic+wheatHTP'></span><span id='topic+Y'></span><span id='topic+X_E1'></span><span id='topic+VI_E1'></span><span id='topic+M'></span><span id='topic+genCOV_xy'></span><span id='topic+genCOV_yy'></span><span id='topic+resCOV_yy'></span>

<h3>Description</h3>

<p>The dataset consists of 1,092 inbred wheat lines grouped into 39 trials and grown during the 2013-2014 season at the Norman Borlaug experimental research station in Ciudad Obregon, Sonora, Mexico. Each trial consisted of 28 breeding lines that were arranged in an alpha-lattice design with three replicates and six sub-blocks. The trials were grown in four different environments:
</p>

<ul>
<li><p> E1: Flat-Drought (sowing in flat with irrigation of 180 mm through drip system)
</p>
</li>
<li><p> E2: Bed-2IR (sowing in bed with 2 irrigations approximately 250 mm)
</p>
</li>
<li><p> E3: Bed-5IR (bed sowing with 5 normal irrigations)
</p>
</li>
<li><p> E4: Bed-EHeat (bed sowing 30 days before optimal planting date with 5 normal irrigations approximately 500 mm)
</p>
</li></ul>

<b>1. Phenotypic data.</b>
<p>Measurements of grain yield (YLD) were reported as the total plot yield after maturity. Records for YLD are reported as adjusted means from which trial, replicate and sub-block effects were removed. Measurements for days to heading (DTH), days to maturity (DTM), and plant height (PH) were recorded only in the first replicate at each trial and thus no phenotype adjustment was made.
</p>
<b>2. Reflectance data.</b>
<p>Reflectance data was collected from the fields using both infrared and hyper-spectral cameras mounted on an aircraft on 9 different dates (time-points) between January 10 and March 27th, 2014. During each flight, data from 250 wavelengths ranging from 392 to 850 nm were collected for each pixel in the pictures. The average reflectance of all the pixels for each wavelength was calculated from each of the geo-referenced trial plots and reported as each line reflectance. Data for reflectance and Green NDVI and Red NDVI are reported as adjusted phenotypes from which trial, replicate and sub-block effects were removed. Each data-point matches to each data-point in phenotypic data.
</p>
<b>3. Marker data.</b> 
<p>Lines were sequenced for GBS at 192-plexing on Illumina HiSeq2000 or HiSeq2500 with 1 x 100 bp reads. SNPs were called across all lines anchored to the genome assembly of Chinese Spring (International Wheat Genome Sequencing Consortium 2014). Next, SNP were extracted and filtered so that lines &gt;50% missing data were removed. Markers were recoded as –1, 0, and 1, corresponding to homozygous for the minor allele, heterozygous, and homozygous for the major allele, respectively. Next, markers with a minor allele frequency &lt;0.05 and &gt;15% of missing data were removed. Remaining SNPs with missing values were imputed using the mean of the observed marker genotypes at a given locus.
</p>
<b>Adjusted un-replicated data.</b>
<p>The <code>SFSI</code> R-package includes the <code>wheatHTP</code> dataset containing (un-replicated) only YLD from all environments E1,...,E4, and reflectance (latest time-point only) data from the environment E1 only. Marker data is also included in the dataset. The phenotypic and reflectance data are averages (line effects from mixed models) for 776 lines evaluated in 28 trials (with at least 26 lines each) for which marker information on 3,438 SNPs is available.
</p>
<p>The full (replicated) data for all four environments, all traits, and all time-points can be found in the repository <a href="https://github.com/MarcooLopez/Data_for_Lopez-Cruz_et_al_2020">https://github.com/MarcooLopez/Data_for_Lopez-Cruz_et_al_2020</a>.
</p>
<b>Cross-validation partitions.</b>
<p>One random partition of 4-folds was created for the 776 individuals (distributed into 28 trials). Data from 7 entire trials (25% of 28 the trials) were arbitrarily assigned to each of the 4 folds. The partition consist of an array of length 776 with indices 1, 2, 3, and 4 denoting the fold. 
</p>
<b>Genetic covariances.</b>
<p>Multi-variate Gaussian mixed models were fitted to phenotypes. Bi-variate models were fitted to YLD with each of the 250 wavelengths from environment E1. Tetra-variate models were fitted for YLD from all environments. All models were fitted within each fold (provided partition) using scaled (null mean and unit variance) phenotypes from the remaining 3 folds as training data. Bayesian models were implemented using the 'Multitrait' function from the <code>BGLR</code> R-package with 40,000 iterations discarding 5,000 runs for burning. A marker-derived relationships matrix as in VanRaden (2008) was used to model between-individuals genetic effects. Between-traits genetic covariances were assumed unstructured, while residual covariances were assumed diagonal. 
</p>
<p>Genetic covariances between YLD and each wavelength (environment E1) are storaged in a matrix of 250 rows and 4 columns (folds). Genetic and residual covariances matrices among YLD within each environment are storaged in a list with 4 elements (folds). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(wheatHTP)
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>Y</code>: (matrix) phenotypic data for YLD in environments E1, E2, E3, and E4; and columns 'trial' and 'CV' (indicating the 4-folds partition). 
</p>
</li>
<li> <p><code>M</code>: (matrix) marker data with SNPs in columns.
</p>
</li>
<li> <p><code>X_E1</code>: (matrix) reflectance data for time-point 9 in environment E1.
</p>
</li>
<li> <p><code>VI_E1</code>: (matrix) green and red NDVI for time-point 9 in environment E1. 
</p>
</li>
<li> <p><code>genCOV_xy</code>: (matrix) genetic covariances between YLD and each reflectance trait, for each fold (in columns). 
</p>
</li>
<li> <p><code>genCOV_yy</code>: (4-dimensional list) genetic covariances matrices for YLD among environments, for each fold.
</p>
</li>
<li> <p><code>resCOV_yy</code>: (4-dimensional list) residual covariances matrices for YLD among environments, for each fold.
</p>
</li></ul>



<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>


<h3>References</h3>

<p>Perez-Rodriguez P, de los Campos G (2014). Genome-wide regression and prediction with the BGLR statistical package. <em>Genetics</em>, <b>198</b>, 483–495.
</p>
<p>VanRaden PM (2008). Efficient methods to compute genomic predictions. <em>Journal of Dairy Science</em>, <b>91</b>(11), 4414–4423.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
