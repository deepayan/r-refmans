<!DOCTYPE html><html lang="en"><head><title>Help for package SynchWave</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SynchWave}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#curve_ext'><p>Extract a Maximum Energy / Minimum Curvature Curve</p></a></li>
<li><a href='#curve_ext_multi'><p>Extract a Maximum Energy / Minimum Curvature Curves</p></a></li>
<li><a href='#curve_ext_recon'><p>Reconstruct Curves</p></a></li>
<li><a href='#cwt_fw'><p>Forward Continuous Wavelet Transform</p></a></li>
<li><a href='#cwt_iw'><p>Inverse Wavelet Transform</p></a></li>
<li><a href='#est_riskshrink_thresh'><p>Estimate the RiskShrink Hard Thresholding Level</p></a></li>
<li><a href='#fftshift'><p>FFT Shift</p></a></li>
<li><a href='#ifftshift'><p>Inverse FFT Shift</p></a></li>
<li><a href='#SynchWave-internal'><p>Internal SynchWave Functions</p></a></li>
<li><a href='#synsq_cwt_fw'><p>Synchrosqueezing Transform</p></a></li>
<li><a href='#synsq_cwt_iw'><p>Invese Synchrosqueezing Transform</p></a></li>
<li><a href='#synsq_filter_pass'><p>Filtering of the Synchrosqueezing Representation</p></a></li>
<li><a href='#wfiltfn'><p>Wavelet Transform Function of the Wavelet Filter</p></a></li>
<li><a href='#wfilth'><p>FFT of Wavelet Transform Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Synchrosqueezed Wavelet Transform</td>
</tr>
<tr>
<td>Author:</td>
<td>Matlab original by Eugene Brevdo; R port by Dongik Jang, Hee-Seok Oh and Donghoh Kim</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Donghoh Kim &lt;donghoh.kim@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13), fields (&ge; 6.7.6)</td>
</tr>
<tr>
<td>Description:</td>
<td>The synchrosqueezed wavelet transform is implemented. The package is a translation of MATLAB Synchrosqueezing Toolbox, version 1.1 originally developed by Eugene Brevdo (2012). The C code for curve_ext was authored by Jianfeng Lu, and translated to Fortran by Dongik Jang. Synchrosqueezing is based on the papers: [1] Daubechies, I., Lu, J. and Wu, H. T. (2011) Synchrosqueezed wavelet transforms: An empirical mode decomposition-like tool. Applied and Computational Harmonic Analysis, 30. 243-261. [2] Thakur, G., Brevdo, E., Fukar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: Robustness properties and new paleoclimate applications. Signal Processing, 93, 1079-1094.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-07 11:01:18 UTC; donghohkim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-07 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='curve_ext'>Extract a Maximum Energy / Minimum Curvature Curve</h2><span id='topic+curve_ext'></span>

<h3>Description</h3>

<p>This function extracts a maximum energy / minimum curvature curve from
Synchrosqueezed Representation.
This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_ext(Tx, fs, lambda=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curve_ext_+3A_tx">Tx</code></td>
<td>
<p>synchrosqueezed output of x (columns associated with time t)</p>
</td></tr>
<tr><td><code id="curve_ext_+3A_fs">fs</code></td>
<td>
<p>frequencies associated with rows of <code>Tx</code></p>
</td></tr>
<tr><td><code id="curve_ext_+3A_lambda">lambda</code></td>
<td>
<p>lambda should be greater than or equal to 0. Default: lambda=0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts a maximum energy, minimum curvature, curve from
Synchrosqueezed Representation. Note, energy is given as:
<code>abs(Tx)^2</code>.
</p>
<p>This implements the solution to Eq. (8) of [1].
</p>
<p>Original Author: Jianfeng Lu
</p>


<h3>Value</h3>

  
<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>the curve locations (indices)</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>the (logarithmic) energy of the curve</p>
</td></tr> 
</table>


<h3>References</h3>

 
<p>[1] Thakur, G., Brevdo, E., Fuckar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: 
Robustness properties and new paleoclimate applications. 
<em>Signal Processing</em>, <b>93</b>, 1079&ndash;1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synsq_cwt_fw">synsq_cwt_fw</a></code>, <code><a href="#topic+curve_ext_multi">curve_ext_multi</a></code>, <code><a href="#topic+curve_ext_recon">curve_ext_recon</a></code>.
</p>

<hr>
<h2 id='curve_ext_multi'>Extract a Maximum Energy / Minimum Curvature Curves</h2><span id='topic+curve_ext_multi'></span>

<h3>Description</h3>

<p>This function consecutively extracts maximum energy / minimum curvature curves
from a synchrosqueezing representation.
This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_ext_multi(Tx, fs, nc, lambda = 1e3, clwin = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curve_ext_multi_+3A_tx">Tx</code></td>
<td>
<p>same as input to <code>curve_ext</code>. synchrosqueezed output of <code>x</code> (columns associated with time <code>t</code>)</p>
</td></tr>
<tr><td><code id="curve_ext_multi_+3A_fs">fs</code></td>
<td>
<p>same as input to <code>curve_ext</code>. frequencies associated with rows of <code>Tx</code></p>
</td></tr>
<tr><td><code id="curve_ext_multi_+3A_nc">nc</code></td>
<td>
<p>Number of curves to extract</p>
</td></tr>
<tr><td><code id="curve_ext_multi_+3A_lambda">lambda</code></td>
<td>
<p>same as input to <code>curve_ext</code>. lambda default = 1e3.</p>
</td></tr>
<tr><td><code id="curve_ext_multi_+3A_clwin">clwin</code></td>
<td>
<p>frequency clearing window; after curve extraction, a window
of frequencies (<code>Cs[,i]-clwin) : (Cs[,i]+clwin)</code> is removed from the
original representation. (default = 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function consecutively extracts maximum energy / minimum curvature curves
from a synchrosqueezing representation. As curves are extracted,
their associated energies are zeroed out in the synsq
representation. Curve extraction is then again performed on
the remaining representaton.
</p>
<p>For more details, see help <code>curve_ext</code> and Sec. IIID of [1].
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>Cs</code></td>
<td>
<p><code>[N x nc]</code> matrix of curve indices (<code>N=ncol(Tx)</code>)</p>
</td></tr>
<tr><td><code>Es</code></td>
<td>
<p><code>[nc x 1]</code> vector of associated (logarithmic) energies</p>
</td></tr> 
</table>


<h3>References</h3>

<p>[1] Thakur, G., Brevdo, E., Fuckar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: 
Robustness properties and new paleoclimate applications. 
<em>Signal Processing</em>, <b>93</b>, 1079&ndash;1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synsq_cwt_fw">synsq_cwt_fw</a></code>, <code><a href="#topic+curve_ext">curve_ext</a></code>, <code><a href="#topic+curve_ext_recon">curve_ext_recon</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
tt &lt;- seq(0, 10, , 1024)
nv &lt;- 32
f0 &lt;- (1+0.6*cos(2*tt))*cos(4*pi*tt+1.2*tt^2)
sigma &lt;- 0.5
f &lt;- f0 + sigma*rnorm(length(tt))

# Continuous wavelet transform
opt &lt;- list(type = "bump")
cwtfit &lt;- cwt_fw(f, opt$type, nv, tt[2]-tt[1], opt)

# Hard thresholing
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0

# Denoised signal
opt$gamma &lt;- thresh
fr &lt;- cwt_iw(cwtfit$Wx, opt$type, opt)

# Synchrosqueezed wavelet transform using denoised signal
sstfit2 &lt;- synsq_cwt_fw(tt, fr, nv, opt)

# Ridge extraction
lambda &lt;- 1e+04
nw &lt;- 16
imtfit &lt;- curve_ext_multi(sstfit2$Tx, log2(sstfit2$fs), 1, lambda, nw)

# Reconstruction
curvefit &lt;- curve_ext_recon(sstfit2$Tx, sstfit2$fs, imtfit$Cs, opt, nw)

par(mfrow=c(2,1))
image.plot(list(x=tt, y=sstfit2$fs, z=t(abs(sstfit2$Tx))), log="y", 
    xlab="Time", ylab="Frequency", main="Time-Frequency Representation by SST", 
    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=c(0.5, 25))
lines(tt, sstfit2$fs[imtfit$Cs[,1]], col="red", lty=3, lwd=2)

plot(tt, f0, type="l")
lines(tt, curvefit, lty=2)
</code></pre>

<hr>
<h2 id='curve_ext_recon'>Reconstruct Curves</h2><span id='topic+curve_ext_recon'></span>

<h3>Description</h3>

<p>This function reconstructs the curves given by <code>curve_ext</code> or <code>curve_ext_multi</code>.
</p>
<p>This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_ext_recon(Tx, fs, Cs, opt=NULL, clwin=4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curve_ext_recon_+3A_tx">Tx</code></td>
<td>
<p>same as input to <code>curve_ext_multi</code>. synchrosqueezed output of <code>x</code> (columns associated with time <code>t</code>)</p>
</td></tr>
<tr><td><code id="curve_ext_recon_+3A_fs">fs</code></td>
<td>
<p>same as input to <code>curve_ext_multi</code>. frequencies associated with rows of <code>Tx</code></p>
</td></tr>
<tr><td><code id="curve_ext_recon_+3A_opt">opt</code></td>
<td>
<p>same as input to <code>synsq_cwt_fw</code> and <code>synsq_cwt_iw</code></p>
</td></tr>
<tr><td><code id="curve_ext_recon_+3A_cs">Cs</code></td>
<td>
<p>same as output to <code>curve_ext_multi</code>. <code>[N x nc]</code> matrix of curve indices (<code>N=ncol(Tx)</code>)</p>
</td></tr>
<tr><td><code id="curve_ext_recon_+3A_clwin">clwin</code></td>
<td>
<p>same as input to <code>curve_ext_multi</code>. frequency clearing window; after curve extraction, a window
of frequencies <code>(Cs[,i]-clwin) : (Cs[,i]+clwin)</code> is removed from the
original representation. (default = 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reconstructs the curves given by <code>curve_ext</code> or <code>curve_ext_multi</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>xrs</code></td>
<td>
<p><code>[n x Nc]</code> matrix - the <code>Nc</code> reconstructed signals (each length <code>n</code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] Thakur, G., Brevdo, E., Fuckar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: 
Robustness properties and new paleoclimate applications. 
<em>Signal Processing</em>, <b>93</b>, 1079&ndash;1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synsq_cwt_fw">synsq_cwt_fw</a></code>, <code><a href="#topic+curve_ext">curve_ext</a></code>, <code><a href="#topic+curve_ext_multi">curve_ext_multi</a></code>, <code><a href="#topic+curve_ext_recon">curve_ext_recon</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
tt &lt;- seq(0, 10, , 1024)
nv &lt;- 32
f0 &lt;- (1+0.6*cos(2*tt))*cos(4*pi*tt+1.2*tt^2)
sigma &lt;- 0.5
f &lt;- f0 + sigma*rnorm(length(tt))

# Continuous wavelet transform
opt &lt;- list(type = "bump")
cwtfit &lt;- cwt_fw(f, opt$type, nv, tt[2]-tt[1], opt)

# Hard thresholing
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0

# Denoised signal
opt$gamma &lt;- thresh
fr &lt;- cwt_iw(cwtfit$Wx, opt$type, opt)

# Synchrosqueezed wavelet transform using denoised signal
sstfit2 &lt;- synsq_cwt_fw(tt, fr, nv, opt)

# Ridge extraction
lambda &lt;- 1e+04
nw &lt;- 16
imtfit &lt;- curve_ext_multi(sstfit2$Tx, log2(sstfit2$fs), 1, lambda, nw)

# Reconstruction
curvefit &lt;- curve_ext_recon(sstfit2$Tx, sstfit2$fs, imtfit$Cs, opt, nw)

par(mfrow=c(2,1))
image.plot(list(x=tt, y=sstfit2$fs, z=t(abs(sstfit2$Tx))), log="y", 
    xlab="Time", ylab="Frequency", main="Time-Frequency Representation by SST", 
    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=c(0.5, 25))
lines(tt, sstfit2$fs[imtfit$Cs[,1]], col="red", lty=3, lwd=2)

plot(tt, f0, type="l")
lines(tt, curvefit, lty=2)
</code></pre>

<hr>
<h2 id='cwt_fw'>Forward Continuous Wavelet Transform</h2><span id='topic+cwt_fw'></span>

<h3>Description</h3>

<p>This function performs 
forward continuous wavelet transform, discretized, as described
in Sec. 4.3.3 of [1] and Sec. IIIA of [2]. 
This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwt_fw(x, type, nv, dt, opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cwt_fw_+3A_x">x</code></td>
<td>
<p>input signal vector, length <code>n</code> (need not be dyadic length)</p>
</td></tr>
<tr><td><code id="cwt_fw_+3A_type">type</code></td>
<td>
<p>wavelet type, string (see <code>wfiltfn</code>)</p>
</td></tr>
<tr><td><code id="cwt_fw_+3A_nv">nv</code></td>
<td>
<p>number of voices (suggest <code>nv &gt;= 32</code>)</p>
</td></tr>
<tr><td><code id="cwt_fw_+3A_dt">dt</code></td>
<td>
<p>sampling period (default, <code>dt = 1</code>)</p>
</td></tr>
<tr><td><code id="cwt_fw_+3A_opt">opt</code></td>
<td>
<p>list of options. <code>opt$padtype</code>: type of padding, &lsquo;symmetric&rsquo;, &lsquo;replicate&rsquo;, or &lsquo;circular&rsquo; (default = &lsquo;symmetric&rsquo;).
<code>opt$rpadded</code>: return padded <code>Wx</code> and <code>dWx</code>?  (default = 0).
<code>opt$s</code>, <code>opt$mu</code>, etc: wavelet options (see <code>wfiltfn</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs 
forward continuous wavelet transform, discretized, as described
in Sec. 4.3.3 of [1] and Sec. IIIA of [2].  This algorithm uses
the FFT and samples the wavelet atoms in the fourier domain.
Options such as padding of the original signal are allowed.
Returns the vector of scales and, if requested, the analytic
time-derivative of the wavelet transform (as described in
Sec. IIIB of [2].
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>Wx</code></td>
<td>
<p><code>[na x n]</code> size matrix (rows = scales, cols = times) containing samples of the CWT of <code>x</code>.</p>
</td></tr>
<tr><td><code>asc</code></td>
<td>
<p><code>na</code> length vector containing the associated scales.</p>
</td></tr>
<tr><td><code>dWx</code></td>
<td>
<p><code>[na x n]</code> size matrix containing
samples of the time-derivatives of the CWT of <code>x</code>.</p>
</td></tr> 
</table>


<h3>References</h3>

<p>[1] Mallat, S (2009) <em>A Wavelet Tour of Signal Processing</em>, New York: Academic Press.
</p>
<p>[2] Thakur, G., Brevdo, E., Fuckar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: 
Robustness properties and new paleoclimate applications. 
<em>Signal Processing</em>, <b>93</b>, 1079&ndash;1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cwt_iw">cwt_iw</a></code>, <code><a href="#topic+wfiltfn">wfiltfn</a></code>, <code><a href="#topic+est_riskshrink_thresh">est_riskshrink_thresh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 10, , 1024)
f0 &lt;- (1+0.6*cos(2*tt))*cos(4*pi*tt+1.2*tt^2)
sigma &lt;- 0.5
f &lt;- f0 + sigma*rnorm(length(tt))

# Continuous wavelet transform
nv &lt;- 32
opt &lt;- list(type = "bump")
cwtfit &lt;- cwt_fw(f, opt$type, nv, tt[2]-tt[1], opt)
</code></pre>

<hr>
<h2 id='cwt_iw'>Inverse Wavelet Transform</h2><span id='topic+cwt_iw'></span>

<h3>Description</h3>

<p>This function performs 
the inverse wavelet transform of signal <code>Wx</code>.
</p>
<p>This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwt_iw(Wx, type, opt=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cwt_iw_+3A_wx">Wx</code></td>
<td>
<p>wavelet transform of a signal, see <code>cwt_fw</code>.</p>
</td></tr>
<tr><td><code id="cwt_iw_+3A_type">type</code></td>
<td>
<p>wavelet used to take the wavelet transform,
see <code>cwt_fw</code> and <code>wfiltfn</code>.</p>
</td></tr>
<tr><td><code id="cwt_iw_+3A_opt">opt</code></td>
<td>
<p>options list used for forward wavelet transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs 
the inverse wavelet transform of signal <code>Wx</code>, and 
implements Eq. (4.67) of [1].
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the signal, as reconstructed from <code>Wx</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] Mallat, S (2009) <em>A Wavelet Tour of Signal Processing</em>, New York: Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cwt_fw">cwt_fw</a></code>, <code><a href="#topic+wfiltfn">wfiltfn</a></code>, <code><a href="#topic+est_riskshrink_thresh">est_riskshrink_thresh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 10, , 1024)
nv &lt;- 32
f0 &lt;- (1+0.6*cos(2*tt))*cos(4*pi*tt+1.2*tt^2)
sigma &lt;- 0.5
f &lt;- f0 + sigma*rnorm(length(tt))

# Continuous wavelet transform
opt &lt;- list(type = "bump")
cwtfit &lt;- cwt_fw(f, opt$type, nv, tt[2]-tt[1], opt)

# Hard thresholing
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0

# Reconstruction 
opt$gamma &lt;- thresh
cwtrec &lt;- cwt_iw(cwtfit$Wx, opt$type, opt)

par(mfrow=c(1,1))
plot(tt, f, type="p", lty=2, xlab="time", ylab="f", col="red", cex=0.1)
lines(tt, f0, col="blue")
lines(tt, cwtrec)
</code></pre>

<hr>
<h2 id='est_riskshrink_thresh'>Estimate the RiskShrink Hard Thresholding Level</h2><span id='topic+est_riskshrink_thresh'></span>

<h3>Description</h3>

<p>This function estimates the RiskShrink hard thresholding level.
</p>
<p>This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_riskshrink_thresh(Wx, nv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_riskshrink_thresh_+3A_wx">Wx</code></td>
<td>
<p>wavelet transform of a signal, see <code>cwt_fw</code></p>
</td></tr>
<tr><td><code id="est_riskshrink_thresh_+3A_nv">nv</code></td>
<td>
<p>number of voices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Defn. 1 of Sec. 2.4 in [1], using the suggested
noise estimator from the discussion &quot;Estimating the noise level&quot;
in that same section.
</p>


<h3>Value</h3>

 
<p>the RiskShrink hard threshold estimate
</p>


<h3>References</h3>

<p>[1] Donoho, D. L. and Johnstone, I. M. (1994) Ideal spatial adaptation by 
wavelet shrinkage. <em>Biometrika</em>, <b>81</b>, 425&ndash;455.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cwt_fw">cwt_fw</a></code>, <code><a href="#topic+cwt_iw">cwt_iw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 10, , 1024)
nv &lt;- 32
f0 &lt;- (1+0.6*cos(2*tt))*cos(4*pi*tt+1.2*tt^2)
sigma &lt;- 0.5
f &lt;- f0 + sigma*rnorm(length(tt))

# Continuous wavelet transform
opt &lt;- list(type = "bump")
cwtfit &lt;- cwt_fw(f, opt$type, nv, tt[2]-tt[1], opt)

# Hard thresholing
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0
</code></pre>

<hr>
<h2 id='fftshift'>FFT Shift</h2><span id='topic+fftshift'></span>

<h3>Description</h3>

<p>This function exchanges the left halves of a vector with the right halves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftshift(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fftshift_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exchanges the left halves of a vector with the right halves. This function is adapted from Matlab.
</p>


<h3>Value</h3>

 
<p>shifted vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifftshift">ifftshift</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:4
fftshift(fftshift(x))
ifftshift(fftshift(x))

x &lt;- 1:5
fftshift(fftshift(x))
ifftshift(fftshift(x))
</code></pre>

<hr>
<h2 id='ifftshift'>Inverse FFT Shift</h2><span id='topic+ifftshift'></span>

<h3>Description</h3>

<p>This function exchanges the left halves of a vector with the right halves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifftshift(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifftshift_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exchanges the left halves of a vector with the right halves. This function is adapted from Matlab.
</p>


<h3>Value</h3>

 
<p>shifted vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fftshift">fftshift</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:4
fftshift(fftshift(x))
ifftshift(fftshift(x))

x &lt;- 1:5
fftshift(fftshift(x))
ifftshift(fftshift(x))
</code></pre>

<hr>
<h2 id='SynchWave-internal'>Internal SynchWave Functions</h2><span id='topic+SynchWave-internal'></span><span id='topic+padsignal'></span><span id='topic+p2up'></span><span id='topic+padarray'></span><span id='topic+cwt_freq_direct'></span><span id='topic+cwt_freq'></span><span id='topic+diff_so'></span><span id='topic+synsq_cwt_squeeze'></span><span id='topic+imdilate'></span><span id='topic+synsq_adm'></span><span id='topic+quadgk'></span><span id='topic+cwt_adm'></span>

<h3>Description</h3>

<p>The <code>padsignal</code>, <code>p2u</code>, <code>padarray</code>, <code>cwt_freq_direct</code>, 
<code>cwt_freq</code>, <code>diff_so</code>, <code>synsq_cwt_squeeze</code>, <code>imdilate</code>, <code>synsq_adm</code>,
<code>quadgk</code>, <code>cwt_adm</code> are internal SynchWave functions.
</p>
<p><code>padarray</code> and <code>imdilate</code> is adapted from Matlab.
<code>quadgk</code> is from pracma packake 1.4.5 authored by Hans W Borchers (hwborchers at googlemail.com).
Other codes are translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='synsq_cwt_fw'>Synchrosqueezing Transform</h2><span id='topic+synsq_cwt_fw'></span>

<h3>Description</h3>

<p>This function calculates the synchrosqueezing transform. 
</p>
<p>This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsq_cwt_fw(tt, x, nv=16, opt=NULL) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synsq_cwt_fw_+3A_tt">tt</code></td>
<td>
<p>vector of times samples are taken (e.g. <code>seq(0, 1,length=2)</code>)</p>
</td></tr>
<tr><td><code id="synsq_cwt_fw_+3A_x">x</code></td>
<td>
<p>vector of signal samples (e.g. <code>x = cos(20*pi*tt)</code>)</p>
</td></tr>
<tr><td><code id="synsq_cwt_fw_+3A_nv">nv</code></td>
<td>
<p>number of voices (default: 16, recommended: 32 or 64)</p>
</td></tr>
<tr><td><code id="synsq_cwt_fw_+3A_opt">opt</code></td>
<td>
<p>list of options. <code>opt.type</code>: type of wavelet (see <code>wfiltfn</code>), <code>opt$s</code>, <code>opt$mu</code>, etc (wavelet parameters: see <code>opt</code> from <code>wfiltfn</code>),
<code>opt.disp</code>: display debug information?,
<code>opt.gamma</code>: wavelet hard thresholding value (see <code>cwt_freq_direct</code>, default: sqrt(machine epsilon))
<code>opt.dtype</code>: direct or numerical differentiation (default: 1, uses direct).  if <code>dtype=0</code>, uses differentiation algorithm 
instead (see <code>cwt_freq</code>), which is faster and
uses less memory, but may be less accurate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function
calculates the synchrosqueezing transform of vector <code>x</code>, with
samples taken at times given in vector <code>tt</code>.  Uses <code>nv</code> voices.  <code>opt</code>
is a struct of options for the way synchrosqueezing is done, the
type of wavelet used, and the wavelet parameters.  This
implements the algorithm described in Sec. III of [1].
</p>
<p>Note that <code>Wx</code> itself is not thresholded by <code>opt$gamma</code>.
The instantaneoues frequency <code>w</code> is calculated using <code>Wx</code> by <code>cwt_freq_direct</code> and
<code>cwt_freq</code>. After the calculation, instantaneoues frequency <code>w</code> is treated as <code>NA</code> where <code>abs(Wx) &lt; opt$gamma</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>Tx</code></td>
<td>
<p>synchrosqueezed output of <code>x</code> (columns associated with time <code>tt</code>)</p>
</td></tr>
<tr><td><code>fs</code></td>
<td>
<p>frequencies associated with rows of <code>Tx</code></p>
</td></tr>
<tr><td><code>Wx</code></td>
<td>
<p>wavelet transform of <code>x</code> (see <code>cwt_fw</code>)</p>
</td></tr>
<tr><td><code>asc</code></td>
<td>
<p>scales associated with rows of <code>Wx</code></p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>instantaneous frequency estimates for each element of <code>Wx</code>
(see <code>cwt_freq_direct</code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] Thakur, G., Brevdo, E., Fuckar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: 
Robustness properties and new paleoclimate applications. 
<em>Signal Processing</em>, <b>93</b>, 1079&ndash;1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cwt_fw">cwt_fw</a></code>, <code><a href="#topic+est_riskshrink_thresh">est_riskshrink_thresh</a></code>, <code><a href="#topic+wfiltfn">wfiltfn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(0, 10, , 1024)
nv &lt;- 32
f0 &lt;- (1+0.6*cos(2*tt))*cos(4*pi*tt+1.2*tt^2)
sigma &lt;- 0.5
f &lt;- f0 + sigma*rnorm(length(tt))

# Continuous wavelet transform
opt &lt;- list(type = "bump")
cwtfit &lt;- cwt_fw(f, opt$type, nv, tt[2]-tt[1], opt)

# Hard thresholing
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0

# Reconstruction
opt$gamma &lt;- thresh
#[1] 0.0593984
#opt$gamma &lt;- 10^-5
cwtrec &lt;- cwt_iw(cwtfit$Wx, opt$type, opt)

par(mfrow=c(1,1))
plot(tt, f, type="p", lty=2, xlab="time", ylab="f", col="red", cex=0.1)
lines(tt, f0, col="blue")
lines(tt, cwtrec)

# Synchrosqueezed wavelet transform
sstfit &lt;- synsq_cwt_fw(tt, f, nv, opt)

#par(mfrow=c(2,2))
#plot(tt, f, type="p", lty=2, xlab="time", ylab="f", col="red", cex=0.1)
#lines(tt, f0, col="blue")

#image.plot(list(x=tt, y=sstfit$asc, z=t(abs(sstfit$Wx))), log="y", 
#    xlab="Time", ylab="Scale", main="Time-Scale Representation by CWT",  
#    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=rev(range(sstfit$asc)))
#image.plot(list(x=tt, y=sstfit$fs, z=t(abs(sstfit$Tx))), log="y", 
#    xlab="Time", ylab="Frequency", main="Time-Frequency Representation by SST", 
#    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=c(0.5, 25))
#image.plot(list(x=tt, y=sstfit$asc, z=t(sstfit$w)), log="y", 
#    xlab="Time", ylab="Scale", main="Instantaneous Frequency",  
#    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=rev(range(sstfit$asc)))
</code></pre>

<hr>
<h2 id='synsq_cwt_iw'>Invese Synchrosqueezing Transform</h2><span id='topic+synsq_cwt_iw'></span>

<h3>Description</h3>

<p>This function performs inverse synchrosqueezing transform. 
</p>
<p>This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsq_cwt_iw(Tx, fs, opt=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synsq_cwt_iw_+3A_tx">Tx</code></td>
<td>
<p>synchrosqueezed output of <code>x</code> (columns associated with time <code>t</code>)</p>
</td></tr>
<tr><td><code id="synsq_cwt_iw_+3A_fs">fs</code></td>
<td>
<p>frequencies associated with rows of <code>Tx</code></p>
</td></tr>
<tr><td><code id="synsq_cwt_iw_+3A_opt">opt</code></td>
<td>
<p>list of options. See <code>synsq_cwt_fw</code>. <code>opt.type</code>: type of wavelet used in <code>synsq_cwt_fw</code>, 
other wavelet options (<code>opt.mu</code>, <code>opt.s</code>) should also match
those used in <code>synsq_cwt_fw</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs 
inverse synchrosqueezing transform of <code>Tx</code> with associated
frequencies in <code>fs</code>. This implements Eq. 5 of [1].
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>reconstructed signal</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1] Thakur, G., Brevdo, E., Fuckar, N. S. and Wu, H-T. (2013) The Synchrosqueezing algorithm for time-varying spectral analysis: 
Robustness properties and new paleoclimate applications. 
<em>Signal Processing</em>, <b>93</b>, 1079&ndash;1094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synsq_cwt_fw">synsq_cwt_fw</a></code>, <code><a href="#topic+synsq_filter_pass">synsq_filter_pass</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
n &lt;- 2048
tu &lt;- seq(0,10,, n)
dt &lt;- tu[2]-tu[1]

feq1 &lt;- function(t) (1+0.2*cos(t))*cos(2*pi*(2*t+0.3*cos(t)))
feq2 &lt;- function(t) (1+0.3*cos(2*t))*exp(-t/15)*cos(2*pi*(2.4*t+0.5*t^(1.2)+0.3*sin(t)))
feq3 &lt;- function(t) cos(2*pi*(5.3*t-0.2*t^(1.3)))
feq &lt;- function(t) feq1(t) + feq2(t) + feq3(t)
s2 &lt;- 2.4
noise &lt;- sqrt(s2)*rnorm(length(tu))

fu0 &lt;- feq(tu);
fu &lt;- fu0 + noise;
fus &lt;- cbind(feq1(tu), feq2(tu), feq3(tu))

# Continuous wavelet transform
nv &lt;- 32
opt &lt;- list(type = "bump")

cwtfit &lt;- cwt_fw(fu, opt$type, nv, dt, opt)
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)

# Hard thresholding and Reconstruction
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0
fur &lt;- cwt_iw(cwtfit$Wx, opt$type, opt)

# Synchrosqueezed wavelet transform using denoised signal
sstfit &lt;- synsq_cwt_fw(tu, fur, nv, opt)

#par(mfrow=c(1,2))
#image.plot(list(x=tu, y=sstfit$fs, z=t(abs(sstfit$Tx))), log="y",
#    xlab="Time", ylab="Frequency", main="Time-Frequency Representation by SST", 
#    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=c(1, 8))

# Extracting the second component by filtering of synchrosqueezed wavelet transform
fm &lt;- fM &lt;- (2.4+0.5*1.2*tu^0.2+0.3*cos(tu))

#lines(tu, 0.88*fm, col="red", lty=3, lwd=2)
#lines(tu, 1.22*fM, col="red", lty=3, lwd=2)

tmp &lt;- synsq_filter_pass(sstfit$Tx, sstfit$fs, 0.88*fm, 1.12*fM);
fursst &lt;- synsq_cwt_iw(tmp$Txf, w, opt);

#plot(tu, fursst, type="l", main="SST", xlab="time", ylab="f", col="red", 
#    xlim=c(1.5,8.5), ylim=c(-1,1))
#lines(tu, feq2(tu), col="blue")

# Example:
# tmp &lt;- synsq_cwt_fw(t, x, 32)  # Synchrosqueezing
# Txf &lt;- synsq_filter_pass(tmp$Tx, tmp$fs, -Inf, 1) # Pass band filter
# xf &lt;- synsq_cwt_iw(Txf, fs)  # Filtered signal reconstruction 
</code></pre>

<hr>
<h2 id='synsq_filter_pass'>Filtering of the Synchrosqueezing Representation</h2><span id='topic+synsq_filter_pass'></span>

<h3>Description</h3>

<p>This function filters the Synchrosqueezing representation <code>Tx</code>, having associated
frequencies fs (see <code>synsq_cwt_fw</code>).
This band-pass filter keeps frequencies in the
range <code>[fm, fM]</code>. 
This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsq_filter_pass(Tx, fs, fm, fM)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synsq_filter_pass_+3A_tx">Tx</code></td>
<td>
<p>synchrosqueezed output of <code>x</code> (columns associated with time <code>t</code>). output of <code>synsq_cwt_fw</code></p>
</td></tr>
<tr><td><code id="synsq_filter_pass_+3A_fs">fs</code></td>
<td>
<p>frequencies associated with rows of <code>Tx</code></p>
</td></tr>
<tr><td><code id="synsq_filter_pass_+3A_fm">fm</code></td>
<td>
<p>Minimum band pass values. scalars, or vectors with each value associated
with a time index (<code>length(fm)=ncol(Tx)</code>)</p>
</td></tr>
<tr><td><code id="synsq_filter_pass_+3A_fm">fM</code></td>
<td>
<p>Maximum band pass values. scalars, or vectors with each value associated
with a time index (<code>length(fM)=ncol(Tx)</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function filters the Synchrosqueezing representation <code>Tx</code>, having associated
frequencies <code>fs</code> (see <code>synsq_cwt_fw</code>).
This band-pass filter keeps frequencies in the
range <code>[fm, fM]</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>Txf</code></td>
<td>
<p>Filtered version of <code>Tx</code> (same size), with zeros outside the pass band rows.</p>
</td></tr>
<tr><td><code>fmi</code></td>
<td>
<p>time-length vector of min-frequency row indices</p>
</td></tr>
<tr><td><code>fMi</code></td>
<td>
<p>time-length vector of max-frequency row indices</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+synsq_cwt_fw">synsq_cwt_fw</a></code>, <code><a href="#topic+synsq_cwt_fw">synsq_cwt_fw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
n &lt;- 2048
tu &lt;- seq(0,10,, n)
dt &lt;- tu[2]-tu[1]

feq1 &lt;- function(t) (1+0.2*cos(t))*cos(2*pi*(2*t+0.3*cos(t)))
feq2 &lt;- function(t) (1+0.3*cos(2*t))*exp(-t/15)*cos(2*pi*(2.4*t+0.5*t^(1.2)+0.3*sin(t)))
feq3 &lt;- function(t) cos(2*pi*(5.3*t-0.2*t^(1.3)))
feq &lt;- function(t) feq1(t) + feq2(t) + feq3(t)
s2 &lt;- 2.4
noise &lt;- sqrt(s2)*rnorm(length(tu))

fu0 &lt;- feq(tu);
fu &lt;- fu0 + noise;
fus &lt;- cbind(feq1(tu), feq2(tu), feq3(tu))

# Continuous wavelet transform
nv &lt;- 32
opt &lt;- list(type = "bump")

cwtfit &lt;- cwt_fw(fu, opt$type, nv, dt, opt)
thresh &lt;- est_riskshrink_thresh(cwtfit$Wx, nv)

# Hard thresholding and Reconstruction
cwtfit$Wx[which(abs(cwtfit$Wx) &lt; thresh)] &lt;- 0.0
fur &lt;- cwt_iw(cwtfit$Wx, opt$type, opt)

# Synchrosqueezed wavelet transform using denoised signal
sstfit &lt;- synsq_cwt_fw(tu, fur, nv, opt)

#par(mfrow=c(2,2))
#image.plot(list(x=tu, y=sstfit$asc, z=t(abs(sstfit$Wx))), log="y", 
#    xlab="Time", ylab="Scale", main="Time-Scale Representation by CWT",  
#    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=c(1, 0.0625)) 

# Extracting the second component by filtering of continuous wavelet transform
am &lt;- 0.2 * rep(1, length(tu))
aM &lt;- 0.3 * rep(1, length(tu))

#lines(tu, am, col="red", lty=3, lwd=2)
#lines(tu, aM, col="red", lty=3, lwd=2)

tmp &lt;- synsq_filter_pass(sstfit$Wx, sstfit$asc, am, aM);
furcwt &lt;- cwt_iw(tmp$Txf, opt$type, opt);

#image.plot(list(x=tu, y=sstfit$fs, z=t(abs(sstfit$Tx))), log="y",
#    xlab="Time", ylab="Frequency", main="Time-Frequency Representation by SST", 
#    col=designer.colors(64, c("azure", "cyan", "blue", "darkblue")), ylim=c(1, 8))

# Extracting the second component by filtering of synchrosqueezed wavelet transform
fm &lt;- fM &lt;- (2.4+0.5*1.2*tu^0.2+0.3*cos(tu))

#lines(tu, 0.88*fm, col="red", lty=3, lwd=2)
#lines(tu, 1.22*fM, col="red", lty=3, lwd=2)

tmp &lt;- synsq_filter_pass(sstfit$Tx, sstfit$fs, 0.88*fm, 1.12*fM);
fursst &lt;- synsq_cwt_iw(tmp$Txf, w, opt);

#plot(tu, fursst, type="l", main="SST", xlab="time", ylab="f", col="red",
#    xlim=c(1.5,8.5), ylim=c(-1,1))
#lines(tu, feq2(tu), col="blue")

#plot(tu, furcwt, type="l", main="CWT", xlab="time", ylab="f", col="red", 
#    xlim=c(1.5,8.5), ylim=c(-1,1))
#lines(tu, feq2(tu), col="blue")

# Remove all energy for normalized frequencies above 1.
# synsq_filter_pass(Tx, fs, -Inf, 1) 
</code></pre>

<hr>
<h2 id='wfiltfn'>Wavelet Transform Function of the Wavelet Filter</h2><span id='topic+wfiltfn'></span>

<h3>Description</h3>

<p>This function provides 
wavelet transform function of the wavelet filter in question,
fourier domain. 
This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wfiltfn(type, opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wfiltfn_+3A_type">type</code></td>
<td>
<p>wavelet type. &lsquo;gauss&rsquo;, &lsquo;mhat&rsquo;, &lsquo;cmhat&rsquo;, &lsquo;morlet&rsquo;, &lsquo;shannon&rsquo;, &lsquo;hshannon&rsquo;, &lsquo;hhat&rsquo;, &lsquo;hhhat&rsquo;, &lsquo;bump&rsquo;</p>
</td></tr>
<tr><td><code id="wfiltfn_+3A_opt">opt</code></td>
<td>
<p>list of options for wavelet type. 
For &lsquo;gauss&rsquo;, <code>s</code> and <code>mu</code> with default 1/6 and 2. For &lsquo;mhat&rsquo;, <code>s</code> with default 1. For &lsquo;cmhat&rsquo;, <code>s</code> and <code>mu</code> with default 1 and 1.
For &lsquo;morlet&rsquo;, <code>mu</code> with default <code>2*pi</code>. For &lsquo;hhhat&rsquo;, <code>mu</code> with default 5. For &lsquo;bump&rsquo;, <code>s</code> and <code>mu</code> with default 1 and 5.
The wavelet types &lsquo;mhat&rsquo;, &lsquo;shannon&rsquo; and &lsquo;hhat&rsquo; are not used for synchrosqueezed transform.
The wavelet types &lsquo;shannon&rsquo; and &lsquo;hshannon&rsquo; are NOT recommended for analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides 
wavelet transform function of the wavelet filter in question,
fourier domain.
</p>


<h3>Value</h3>

 
<p>wavelet transform function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wfilth">wfilth</a></code>, <code><a href="#topic+cwt_fw">cwt_fw</a></code>, <code><a href="#topic+cwt_iw">cwt_iw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>psihfn &lt;- wfiltfn("bump", list(mu=1, s=.5))
plot(psihfn(seq(-5, 5, by=0.01)), type="l", xlab="", ylab="")
</code></pre>

<hr>
<h2 id='wfilth'>FFT of Wavelet Transform Function</h2><span id='topic+wfilth'></span>

<h3>Description</h3>

<p>This function outputs the FFT of the wavelet. 
This code is translated from MATLAB Synchrosqueezing Toolbox, version 1.1 developed by Eugene Brevdo (http://www.math.princeton.edu/~ebrevdo/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wfilth(type, N, a, opt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wfilth_+3A_type">type</code></td>
<td>
<p>wavelet type. See <code>wfiltfn</code>. &lsquo;gauss&rsquo;, &lsquo;mhat&rsquo;, &lsquo;cmhat&rsquo;, &lsquo;morlet&rsquo;, &lsquo;shannon&rsquo;, &lsquo;hshannon&rsquo;, &lsquo;hhat&rsquo;, &lsquo;hhhat&rsquo;, &lsquo;bump&rsquo;</p>
</td></tr>
<tr><td><code id="wfilth_+3A_n">N</code></td>
<td>
<p>number of samples to calculate</p>
</td></tr>
<tr><td><code id="wfilth_+3A_a">a</code></td>
<td>
<p>wavelet scale parameter (default = 1)</p>
</td></tr>
<tr><td><code id="wfilth_+3A_opt">opt</code></td>
<td>
<p>list of options for wavelet type. See <code>wfiltfn</code>.
<code>opt.dt</code>: sampling period, default = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs the FFT of the wavelet of family 'type' with parameters
in 'opt', of length N at scale a: (psi(-t/a)).
</p>
<p>Note that the output is made so that the inverse fft of the
result is zero-centered in time.  This is important for
convolving with the derivative(dpsih).  To get the correct
output, perform an <code>ifftshift</code>. That is,
</p>
<p><code>psi = ifftshift(fft(psih, inverse=TRUE) / length(psih))</code>, 
</p>
<p><code>xfilt = ifftshift(fft(fft(x) * psih, inverse=TRUE) / length(fft(x) * psih))</code>
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>psih</code></td>
<td>
<p>wavelet sampling in frequency domain (for use in <code>fft</code>)</p>
</td></tr>
<tr><td><code>dpsih</code></td>
<td>
<p>derivative of same wavelet, sampled in frequency domain (for <code>fft</code>)</p>
</td></tr>
<tr><td><code>xi</code></td>
<td>
<p>associated fourier domain frequencies of the samples.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+wfiltfn">wfiltfn</a></code>, <code><a href="#topic+cwt_fw">cwt_fw</a></code>, <code><a href="#topic+cwt_iw">cwt_iw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- wfilth("morlet", 1024, 4)
plot(fftshift(tmp$xi/(2*pi)), fftshift(abs(tmp$psih)), type="l", col="blue", xlab="", ylab="")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
