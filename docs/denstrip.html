<!DOCTYPE html><html lang="en"><head><title>Help for package denstrip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {denstrip}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#denstrip-package'>
<p>Overview of the denstrip package</p></a></li>
<li><a href='#bpstrip'><p>Box-percentile strips</p></a></li>
<li><a href='#cistrip'><p>Line drawings of point and interval estimates</p></a></li>
<li><a href='#densregion'><p> Density regions</p></a></li>
<li><a href='#densregion.normal'><p> Density regions based on normal distributions</p></a></li>
<li><a href='#densregion.survfit'><p>Density regions for survival curves</p></a></li>
<li><a href='#denstrip'><p>Density strips</p></a></li>
<li><a href='#denstrip.legend'><p> Add a legend to a density strip or shaded region</p></a></li>
<li><a href='#denstrip.normal'><p>Density strip for a normal or log-normal distribution</p></a></li>
<li><a href='#sectioned.density'><p> Sectioned density plots</p></a></li>
<li><a href='#seqToIntervals'><p>Find contiguous sequences in a vector of integers</p></a></li>
<li><a href='#vwstrip'><p>Varying-width strips</p></a></li>
<li><a href='#vwstrip.normal'><p>Varying width strip for a normal or log-normal distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Strips and Other Methods for Compactly Illustrating
Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-03-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Jackson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graphical methods for compactly illustrating probability distributions, including density strips, density regions, sectioned density plots and varying width strips.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice</td>
</tr>
<tr>
<td>Enhances:</td>
<td>survival</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-18 14:31:22 UTC; chris</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-18 15:11:54 UTC</td>
</tr>
</table>
<hr>
<h2 id='denstrip-package'>
Overview of the denstrip package
</h2><span id='topic+denstrip-package'></span>

<h3>Description</h3>

<p>Graphical methods for compactly 
illustrating and comparing distributions, particularly distributions arising from parameter
estimation or prediction.
</p>


<h3>Details</h3>

<p><code><a href="#topic+denstrip">denstrip</a></code> implements the <em>density strip</em> for
illustrating a single univariate distribution.  The darkness of the
density strip at a point is proportional to the density at that point. 
A shortcut function <code><a href="#topic+denstrip.normal">denstrip.normal</a></code> draws the strip for the
given normal distribution. 
</p>
<p><code><a href="#topic+densregion">densregion</a></code> implements the <em>density region</em>, which
illustrates the uncertainty surrounding a continuously-varying quantity
as a two-dimensional shaded region with darkness proportional to the
density.  There are shortcut functions <code><a href="#topic+densregion.normal">densregion.normal</a></code>
and <code><a href="#topic+densregion.survfit">densregion.survfit</a></code> for computing and drawing the
region for normally-distributed predictions and survival curves,
respectively.
</p>
<p><code><a href="#topic+sectioned.density">sectioned.density</a></code> implements the <em>sectioned density plots</em>
of Cohen and Cohen (2006).  These illustrate distributions using
occlusion and varying shading.  They were developed for
summarising data, but can also be used for illustrating known
distributions.
</p>
<p><code><a href="#topic+vwstrip">vwstrip</a></code> can be used to draw <em>varying-width strips</em> to
illustrate distributions, in a similar manner to the <em>violin plot</em> for
summarising data. The width of the strip is proportional to the density.
A shortcut function <code><a href="#topic+vwstrip.normal">vwstrip.normal</a></code> draws the strip for the
given normal distribution. 
</p>
<p><code><a href="#topic+bpstrip">bpstrip</a></code> adapts the <em>box-percentile plot</em> to illustrate a
distribution instead of observed data.  This strip has width
proportional to the probability of a more extreme point.
</p>
<p><code><a href="#topic+cistrip">cistrip</a></code> implements the popular point and line figure for
illustrating point and interval estimates, for example from multiple
regression. 
</p>
<p>These methods are discussed in more detail by Jackson (2008).
</p>
<p>Each function is designed to add a graphic to an existing set of plot
axes. The plots can be added to either base graphics or <span class="pkg">lattice</span>
panels.
</p>


<h3>Author(s)</h3>

<p>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Jackson, C. H. (2008) Displaying uncertainty with shading. <em>The American Statistician</em>, 62(4):340-347.
</p>

<hr>
<h2 id='bpstrip'>Box-percentile strips</h2><span id='topic+bpstrip'></span><span id='topic+panel.bpstrip'></span>

<h3>Description</h3>

<p>Box-percentile strips give a compact illustration of a distribution. 
The width of the strip is proportional to the probability of a more
extreme point.  This function adds a box-percentile strip to an existing
plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bpstrip(x, prob, at, width, horiz=TRUE, scale=1, limits=c(-Inf, Inf), 
        col="gray", border=NULL, lwd, lty, ticks=NULL, tlen=1, twd, tty,
        lattice=FALSE)
panel.bpstrip(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bpstrip_+3A_x">x</code></td>
<td>
<p> Either the vector of points at which the probability is
evaluated (if <code>prob</code> supplied), or a sample from the distribution
(if <code>prob</code> not supplied). </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_prob">prob</code></td>
<td>
<p> Probability, or cumulative density, of the distribution
at <code>x</code>.  If <code>prob</code> is not supplied, this is estimated from
the sample <code>x</code> using <code><a href="stats.html#topic+ecdf">ecdf</a>(x)</code>.</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_at">at</code></td>
<td>
<p> Position of the centre of the strip on the y-axis (if
<code>horiz=TRUE</code>) or the x-axis (if <code>horiz=FALSE</code>).  </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_width">width</code></td>
<td>
<p> Thickness of the strip at its thickest point, which will
be at the median.  Defaults to 1/20 of the axis range. </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_horiz">horiz</code></td>
<td>
<p> Draw the strip horizontally (<code>TRUE</code>) or vertically (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_scale">scale</code></td>
<td>
<p> Alternative way of specifying the thickness of the
strip, as a proportion of <code>width</code>. </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_limits">limits</code></td>
<td>
<p>Vector of minimum and maximum values, respectively, at which to terminate the strip.</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_col">col</code></td>
<td>
<p>Colour to shade the strip, either as a built-in R
colour name (one of <code><a href="grDevices.html#topic+colors">colors</a>()</code>) or an RGB hex
value, e.g. black is <code>"#000000"</code>.</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_border">border</code></td>
<td>
<p>Colour of the border, see <code><a href="graphics.html#topic+polygon">polygon</a></code>. Use
<code>border=NA</code> to show no border.  The default, 'NULL', means to
use 'par(&quot;fg&quot;)' or its <span class="pkg">lattice</span> equivalent.</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_lwd">lwd</code></td>
<td>
<p>Line width of the border (defaults to
<code><a href="graphics.html#topic+par">par</a>("lwd")</code> or its <span class="pkg">lattice</span> equivalent).</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_lty">lty</code></td>
<td>
<p>Line type of the border (defaults to
<code><a href="graphics.html#topic+par">par</a>("lty")</code> or its <span class="pkg">lattice</span> equivalent).</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_ticks">ticks</code></td>
<td>
<p> Vector of <code>x</code>-positions on the strip to draw tick
marks, or <code>NULL</code> for no ticks. </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_tlen">tlen</code></td>
<td>
<p>Length of the ticks, relative to the thickness of the strip.</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_twd">twd</code></td>
<td>
<p> Line width of these marks (defaults to
<code><a href="graphics.html#topic+par">par</a>("lwd")</code> or its <span class="pkg">lattice</span> equivalent). </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_tty">tty</code></td>
<td>
<p> Line type of these marks (defaults to
<code><a href="graphics.html#topic+par">par</a>("lty")</code> or its <span class="pkg">lattice</span> equivalent). </p>
</td></tr>
<tr><td><code id="bpstrip_+3A_lattice">lattice</code></td>
<td>
<p>Set this to <code>TRUE</code> to make <code><a href="#topic+bpstrip">bpstrip</a></code>
a <span class="pkg">lattice</span> panel function instead of a base graphics function. <br />
<code>panel.bpstrip(x,...)</code> is equivalent to
<code>bpstrip(x, lattice=TRUE, ...)</code>.</p>
</td></tr>
<tr><td><code id="bpstrip_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>panel.bpstrip</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The box-percentile strip looks the same as the <em>box-percentile plot</em>
(Esty and Banfield, 2003) which is a generalisation of the boxplot for
summarising data.  However, <code><a href="#topic+bpstrip">bpstrip</a></code> is intended for illustrating
distributions arising from parameter
estimation or prediction.  Either the distribution is known
analytically, or an arbitrarily large sample from the distribution is
assumed to be available via a method such as MCMC or bootstrapping.
</p>
<p>The function <code>bpplot</code> in the <span class="pkg">Hmisc</span>
package can be used to draw vertical box-percentile plots of observed
data.  
</p>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>References</h3>

<p> Jackson, C. H.  (2008) Displaying uncertainty with
shading. <em>The American Statistician</em>, 62(4):340-347. 
</p>
<p>Esty, W. W. and Banfield, J. D. (2003) The box-percentile
plot. <em>Journal of Statistical Software</em> <b>8</b>(17).  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+vwstrip">vwstrip</a></code>, <code><a href="#topic+cistrip">cistrip</a></code>, <code><a href="#topic+denstrip">denstrip</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, length=1000)
prob &lt;- pnorm(x)
plot(x, xlim=c(-5, 5), ylim=c(-5, 5), xlab="x", ylab="x", type="n")
bpstrip(x, prob, at=1, ticks=qnorm(c(0.25, 0.5, 0.75)))

## Terminate the strip at specific outer quantiles
bpstrip(x, prob, at=2, limits=qnorm(c(0.025, 0.975)))
bpstrip(x, prob, at=3, limits=qnorm(c(0.005, 0.995)))

## Compare with density strip
denstrip(x, dnorm(x), at=0)

## Estimate the density from a large sample 
x &lt;- rnorm(10000)
bpstrip(x, at=4)

</code></pre>

<hr>
<h2 id='cistrip'>Line drawings of point and interval estimates</h2><span id='topic+cistrip'></span><span id='topic+panel.cistrip'></span>

<h3>Description</h3>

<p>Adds one or more points and lines to a plot, representing point and
interval estimates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cistrip(x, at, d, horiz=TRUE, pch = 16, cex = 1, lattice=FALSE, ...)
panel.cistrip(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cistrip_+3A_x">x</code></td>
<td>
<p> Either a vector of three elements corresponding to point estimate,
lower limit and upper limit of the interval estimate, respectively,
or a numeric matrix or data frame with three columns representing
point estimates, lower and upper limits. 
</p>
</td></tr>
<tr><td><code id="cistrip_+3A_at">at</code></td>
<td>
<p> Position of the line on the y-axis (if
<code>horiz=TRUE</code>) or the x-axis (if <code>horiz=FALSE</code>).  </p>
</td></tr>
<tr><td><code id="cistrip_+3A_d">d</code></td>
<td>
<p>Length of the serifs at each end of the line.  Defaults to
1/60 of the axis range.</p>
</td></tr>
<tr><td><code id="cistrip_+3A_horiz">horiz</code></td>
<td>
<p> Draw the line horizontally (<code>TRUE</code>) or vertically (<code>FALSE</code>).</p>
</td></tr>  
<tr><td><code id="cistrip_+3A_pch">pch</code></td>
<td>
<p>Character to draw at the point estimate, see
<code><a href="graphics.html#topic+points">points</a></code>.  By default this is a small solid circle, <code>pch=16</code>.</p>
</td></tr>
<tr><td><code id="cistrip_+3A_cex">cex</code></td>
<td>
<p>Expansion factor for the character at the point estimate,
for.  A vector can be supplied here, one for each estimate, as in <code>pch</code>.  Useful for
meta-analysis forest plots.</p>
</td></tr>
<tr><td><code id="cistrip_+3A_lattice">lattice</code></td>
<td>
<p>Set this to <code>TRUE</code> to make <code><a href="#topic+cistrip">cistrip</a></code>
a <span class="pkg">lattice</span> panel function instead of a base graphics function. <br />
<code>panel.cistrip(x,...)</code> is equivalent to
<code>cistrip(x, lattice=TRUE, ...)</code>.</p>
</td></tr>
<tr><td><code id="cistrip_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="graphics.html#topic+points">points</a></code> and
<code><a href="graphics.html#topic+segments">segments</a></code> functions or their <span class="pkg">lattice</span> equivalents.
For example <code>lty,lwd</code> to set the
style and thickness of the line.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>See Also</h3>

 <p><code><a href="#topic+denstrip">denstrip</a></code>, <code><a href="#topic+vwstrip">vwstrip</a></code>, <code><a href="#topic+bpstrip">bpstrip</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## One estimate 
x &lt;- c(0.1, -2, 2)
plot(0, type="n", xlim=c(-5, 5), ylim=c(-5, 5), xlab="", ylab="")
abline(h=0, lty=2, col="lightgray")
abline(v=0, lty=2, col="lightgray")
cistrip(x, at=-0.1)
cistrip(x, at=0.2, lwd=3, d=0.1)
cistrip(x, at=-4, horiz=FALSE, lwd=3, d=0.2)

## Double / triple the area of the central point, as in forest plots
cistrip(x, at=2, d=0.2, pch=22, bg="black")
cistrip(x, at=2.5, d=0.2, pch=22, bg="black", cex=sqrt(2))
cistrip(x, at=3, d=0.2, pch=22, bg="black", cex=sqrt(3))

## Several estimates
x &lt;- rbind(c(0.1, -2, 2), c(1, -1, 2.3),
           c(-0.2, -0.8, 0.4), c(-0.3, -1.2, 1.5))
plot(0, type="n", xlim=c(-5, 5), ylim=c(-5, 5), xlab="", ylab="")
cistrip(x, at=1:4)
abline(v=0, lty=2, col="lightgray")
cistrip(x, at=1:4, horiz=FALSE, lwd=3, d=0.2)
abline(h=0, lty=2, col="lightgray")
</code></pre>

<hr>
<h2 id='densregion'> Density regions </h2><span id='topic+densregion'></span><span id='topic+densregion.default'></span>

<h3>Description</h3>

<p>A density region uses shading to represent the uncertainty surrounding a
continuously-varying quantity, such as a survival curve or
a forecast from a time series.  The darkness of the shading is
proportional to the (posterior, predictive or fiducial) density.
This function adds a density region to an existing plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densregion(x, ...)
## Default S3 method:
densregion(x, y, z, pointwise=FALSE, nlevels=100, 
                   colmax=par("fg"), colmin="white", scale=1, gamma=1,
                   contour=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="densregion_+3A_x">x</code></td>
<td>
<p> Suppose the continuously-varying quantity varies over a
space S.  <code>x</code> is a vector of the points in S at which the full
posterior / predictive / fiducial distribution will be evaluated.  </p>
</td></tr>
<tr><td><code id="densregion_+3A_y">y</code></td>
<td>
<p> Vector of ordinates at which the density of the distribution
will be evaluated for every point in <code>x</code>. 
</p>
</td></tr>
<tr><td><code id="densregion_+3A_z">z</code></td>
<td>
<p> Matrix of densities on the grid defined by <code>x</code> and
<code>y</code>, with rows corresponding to elements of <code>x</code> and
columns corresponding to elements of <code>y</code>.  </p>
</td></tr>
<tr><td><code id="densregion_+3A_pointwise">pointwise</code></td>
<td>
<p> If <code>TRUE</code> then the maximum density at each
<code>x</code>
is shaded with <code>colmax</code> (default black), and the shading
intensity is proportional to the density within each <code>x</code>.
</p>
<p>If <code>FALSE</code> then the maximum density <em>over all</em> <code>x</code> is shaded
with <code>colmax</code>, and the shading is proportional to the density over
all <code>x</code>. </p>
</td></tr>
<tr><td><code id="densregion_+3A_nlevels">nlevels</code></td>
<td>
<p> Number of distinct shades to use to illustrate
the varying densities.  The default of 100 should result in a plot with
smoothly-varying shading.   </p>
</td></tr>
<tr><td><code id="densregion_+3A_colmax">colmax</code></td>
<td>
<p> Colour to shade the maximum density, either as a built-in R
colour name (one of <code><a href="grDevices.html#topic+colors">colors</a>()</code>) or an RGB hex
value. Defaults to <code>par("fg")</code> which is normally     
<code>"black"</code>, or <code>"#000000"</code>.  </p>
</td></tr>
<tr><td><code id="densregion_+3A_colmin">colmin</code></td>
<td>
<p> Colour to shade the minimum density, likewise. 
Defaults to &quot;white&quot;.  If this is set to <code>"transparent"</code>,
and the current graphics device supports transparency (see <code><a href="grDevices.html#topic+rgb">rgb</a></code>), then
multiple regions drawn on the same plot will merge smoothly. </p>
</td></tr>
<tr><td><code id="densregion_+3A_scale">scale</code></td>
<td>
<p> Proportion of <code>colmax</code> to shade the maximum density, for example <code>scale=0.5</code> with <code>colmax="black"</code> for a mid-grey colour. </p>
</td></tr>
<tr><td><code id="densregion_+3A_gamma">gamma</code></td>
<td>
<p>Gamma correction to apply to the colour palette, see <code><a href="#topic+denstrip">denstrip</a></code>.</p>
</td></tr>
<tr><td><code id="densregion_+3A_contour">contour</code></td>
<td>
<p>If <code>TRUE</code> then contours are added to
illustrate lines of constant density.</p>
</td></tr>
<tr><td><code id="densregion_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods, such
as the <code><a href="graphics.html#topic+contour">contour</a></code> function for drawing contours.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is shaded by interpolating the value of the density
between grid points, using the algorithm described by Cleveland (1993)
as implemented in the <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> function.
</p>
<p>With <span class="pkg">lattice</span> graphics, similar plots can be implemented using
the <code><a href="lattice.html#topic+contourplot">contourplot</a></code> or <code><a href="lattice.html#topic+levelplot">levelplot</a></code> functions.
</p>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>References</h3>

<p>Jackson, C. H.  (2008) Displaying uncertainty with
shading. <em>The American Statistician</em>, 62(4):340-347.
</p>
<p>Cleveland, W. S. (1993) <em>Visualizing Data</em>. Hobart Press, Summit,
New Jersey. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+densregion.survfit">densregion.survfit</a></code>, <code><a href="#topic+densregion.normal">densregion.normal</a></code>, <code><a href="#topic+denstrip">denstrip</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Predictive uncertainty around a hypothetical regression line

x &lt;- 1:10
nx &lt;- length(x)
est &lt;- seq(0, 1, length=nx)
lcl &lt;- seq(-1, 0, length=nx)
ucl &lt;- seq(1, 2, length=nx)
se &lt;- (est - lcl)/qnorm(0.975)

y &lt;- seq(-3, 3, length=100)
z &lt;- matrix(nrow=nx, ncol=length(y))
for(i in 1:nx)
  z[i,] &lt;- dnorm(y, est[i], se[i])
plot(x, type="n", ylim=c(-5.5, 2.5))
densregion(x, y, z, colmax="darkgreen")
lines(x, est)
lines(x, lcl, lty=2)
lines(x, ucl, lty=2)
box()

## On graphics devices that support transparency, specify
## colmin="transparent" to allow adjacent regions to overlap smoothly
densregion(x, y-1, z, colmax="magenta", colmin="transparent")


## or automatically choose the y points to evaluate the density 

plot(x, type="n", ylim=c(-1.5, 2.5))
densregion.normal(x, est, se, ny=50, colmax="darkgreen")
lines(x, est)
lines(x, lcl, lty=2)
lines(x, ucl, lty=2)
</code></pre>

<hr>
<h2 id='densregion.normal'> Density regions based on normal distributions </h2><span id='topic+densregion.normal'></span>

<h3>Description</h3>

<p>Adds a density region to an existing plot of a normally-distributed quantity with
continuously-varying mean and standard deviation, such as a
time series forecast.  Automatically computes a reasonable set of 
ordinates to evaluate the density at, which span the whole forecast
space. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'normal'
densregion(x, mean, sd, ny=20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="densregion.normal_+3A_x">x</code></td>
<td>
<p> Suppose the continuously-varying quantity varies over a
space S. <code>x</code> is a vector of the points in S at which the
posterior / predictive / fiducial distribution will be evaluated.  </p>
</td></tr>
<tr><td><code id="densregion.normal_+3A_mean">mean</code></td>
<td>
<p> Vector of normal means at each point in <code>x</code>. </p>
</td></tr>
<tr><td><code id="densregion.normal_+3A_sd">sd</code></td>
<td>
<p> Vector of standard deviations at each point in <code>x</code>. </p>
</td></tr>
<tr><td><code id="densregion.normal_+3A_ny">ny</code></td>
<td>
<p> Minimum number of points to calculate the density at for
each <code>x</code>.  The density is calculated for at least <code>ny</code> equally
spaced normal quantiles for each point.  The density is actually
calculated at the union over <code>x</code> of all such points, for each <code>x</code>. 
</p>
</td></tr>
<tr><td><code id="densregion.normal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+densregion">densregion</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is shaded by interpolating the value of the density
between grid points, using the algorithm described by Cleveland (1993)
as implemented in the <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> function.
</p>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>References</h3>

<p>Jackson, C. H.  (2008) Displaying uncertainty with
shading. <em>The American Statistician</em>, 62(4):340-347.
</p>
<p>Cleveland, W. S. (1993) <em>Visualizing Data</em>. Hobart Press, Summit,
New Jersey. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+densregion">densregion</a></code>, <code><a href="#topic+densregion.survfit">densregion.survfit</a></code>, <code><a href="#topic+denstrip">denstrip</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Time series forecasting

(fit &lt;- arima(USAccDeaths, order = c(0,1,1),
              seasonal = list(order=c(0,1,1))))
pred &lt;- predict(fit, n.ahead = 36)
plot(USAccDeaths, xlim=c(1973, 1982), ylim=c(5000, 15000))

## Compute normal forecast densities automatically (slow)

## Not run: 
densregion.normal(time(pred$pred), pred$pred, pred$se, 
                  pointwise=TRUE, colmax="darkgreen")
lines(pred$pred, lty=2)
lines(pred$pred + qnorm(0.975)*pred$se, lty=3)
lines(pred$pred - qnorm(0.975)*pred$se, lty=3)

## End(Not run)

## Compute forecast densities by hand (more efficient) 

nx &lt;- length(pred$pred)
y &lt;- seq(5000, 15000, by=100)
z &lt;- matrix(nrow=nx, ncol=length(y))
for(i in 1:nx)
    z[i,] &lt;- dnorm(y, pred$pred[i], pred$se[i])
plot(USAccDeaths, xlim=c(1973, 1982), ylim=c(5000, 15000))
densregion(time(pred$pred), y, z, colmax="darkgreen", pointwise=TRUE)
lines(pred$pred, lty=2)
lines(pred$pred + qnorm(0.975)*pred$se, lty=3)
lines(pred$pred - qnorm(0.975)*pred$se, lty=3)


densregion(time(pred$pred), y+2000, z, colmax="darkblue", pointwise=TRUE)
</code></pre>

<hr>
<h2 id='densregion.survfit'>Density regions for survival curves</h2><span id='topic+densregion.survfit'></span>

<h3>Description</h3>

<p>Adds a density region to a survival plot.  The shading of the region
has darkness proportional to the fiducial density of the point.  
This distribution is assumed to be normal with standard deviation
calculated using the lower confidence limit stored in the survival
curve object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit'
densregion(x, ny=20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="densregion.survfit_+3A_x">x</code></td>
<td>
<p> Survival curve object, returned by
<code><a href="survival.html#topic+survfit">survfit</a></code>.  Confidence intervals must have been
calculated, using <code>conf.type</code>.  </p>
</td></tr>
<tr><td><code id="densregion.survfit_+3A_ny">ny</code></td>
<td>
<p> Minimum number of points to calculate the density at for
each event time.  The default of 20 should be sufficient to obtain
smooth-looking plots. </p>
</td></tr>
<tr><td><code id="densregion.survfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+densregion.default">densregion.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density is calculated at a grid of points, and interpolated using
the method referred to in <code><a href="#topic+densregion">densregion</a></code>.
</p>


<h3>Note</h3>

<p>In general, this approach can only illustrate one survival curve per
plot.  Though if the graphics device supports transparency (e.g. PDF)
multiple curves can be made to overlap smoothly - see the example
below. 
</p>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>References</h3>

<p> Jackson, C. H.  (2008) Displaying uncertainty with
shading. <em>The American Statistician</em>, 62(4):340-347.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+densregion">densregion</a></code>, <code><a href="#topic+densregion.normal">densregion.normal</a></code>, <code><a href="#topic+denstrip">denstrip</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("survival", quietly=TRUE)){

library(survival)
fit &lt;- survfit(Surv(time, status) ~ 1, data=aml, conf.type="log-log")
plot(fit, col=0)
densregion(fit)
lines(fit, lwd=3, conf.int=FALSE, lty=1)
lines(fit, lwd=3, conf.int=TRUE, lty=2)

## Wider CIs based on log survival
fit &lt;- survfit(Surv(time, status) ~ 1, data=aml, conf.type="log")
plot(fit, col=0) 
densregion(fit) # Big variation in maximum density 
plot(fit, col=0) 
densregion(fit, pointwise=TRUE, colmax="maroon4")
par(new=TRUE)
plot(fit)

## Narrower CIs based on untransformed survival.
## Normal assumption probably unrealistic
fit &lt;- survfit(Surv(time, status) ~ 1, data=aml, conf.type="plain")
plot(fit, col=0) 
densregion(fit, pointwise=TRUE, colmax="darkmagenta")
par(new=TRUE)
plot(fit)

## Multiple survival curves on same axes
## Should overlap smoothly on devices that allow transparency
fit2 &lt;- survfit(Surv(time, status) ~ x, data=aml, conf.type="log-log")
fit2x1 &lt;- survfit(Surv(time, status) ~ 1, data=aml,
                  conf.type="log-log", subset=(x=="Maintained"))
fit2x0 &lt;- survfit(Surv(time, status) ~ 1, data=aml,
                  conf.type="log-log", subset=(x=="Nonmaintained"))
plot(fit2, lwd=3, xlab="Weeks", ylab="Survival", xlim=c(0, 60),
     lty=1:2, col=c("red", "blue"), conf.int=TRUE, mark.time=TRUE)
densregion(fit2x1, colmax="red", gamma=2)
densregion(fit2x0, colmax="blue", gamma=2)

}

</code></pre>

<hr>
<h2 id='denstrip'>Density strips</h2><span id='topic+denstrip'></span><span id='topic+panel.denstrip'></span>

<h3>Description</h3>

<p>The density strip illustrates a univariate distribution as a shaded
rectangular strip, whose darkness at a point is proportional to the
probability density.  The strip is darkest at the maximum density and
fades into the background at the minimum density.  It may be used to generalise
the common point-and-line drawing of a point and interval estimate,
by representing the entire posterior or predictive distribution of the
estimate.  This function adds a density strip to an existing plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denstrip(x, dens, at, width, horiz=TRUE, colmax, colmin="white",
         scale=1, gamma=1, ticks=NULL, tlen=1.5, twd, tcol, mticks=NULL,
         mlen=1.5, mwd, mcol, lattice=FALSE, ...)
panel.denstrip(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denstrip_+3A_x">x</code></td>
<td>
<p> Either the vector of points at which the density is
evaluated (if <code>dens</code> supplied), or a sample from the distribution
(if <code>dens</code> not supplied). </p>
</td></tr>
<tr><td><code id="denstrip_+3A_dens">dens</code></td>
<td>
<p> Density at <code>x</code>. If <code>dens</code> is not supplied,
the density of the sample <code>x</code> is estimated by kernel density
estimation, using <code><a href="stats.html#topic+density">density</a>(x,...)</code>.</p>
</td></tr>
<tr><td><code id="denstrip_+3A_at">at</code></td>
<td>
<p> Position of the centre of the strip on the y-axis (if
<code>horiz=TRUE</code>) or the x-axis (if <code>horiz=FALSE</code>).  </p>
</td></tr>
<tr><td><code id="denstrip_+3A_width">width</code></td>
<td>
<p> Thickness of the strip, that is, the length of its
shorter dimension.  Defaults to 1/30 of the axis range. </p>
</td></tr>
<tr><td><code id="denstrip_+3A_horiz">horiz</code></td>
<td>
<p> Draw the strip horizontally (<code>TRUE</code>) or vertically (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="denstrip_+3A_colmax">colmax</code></td>
<td>
<p> Colour at the maximum density, either as a built-in R
colour name (one of <code><a href="grDevices.html#topic+colors">colors</a>()</code>) or an RGB hex
value. Defaults to <code>par("fg")</code> which is normally 
<code>"black"</code>, or <code>"#000000"</code>. Or in <span class="pkg">lattice</span>, defaults   
to <code>trellis.par.get("add.line")$col</code>.</p>
</td></tr>
<tr><td><code id="denstrip_+3A_colmin">colmin</code></td>
<td>
<p> Colour to shade the minimum density, likewise. 
Defaults to &quot;white&quot;.  If this is set to <code>"transparent"</code>,
and the current graphics device supports transparency (see <code><a href="grDevices.html#topic+rgb">rgb</a></code>), then
overlapping strips will merge smoothly. </p>
</td></tr>
<tr><td><code id="denstrip_+3A_scale">scale</code></td>
<td>
<p> Proportion of <code>colmax</code> to shade the maximum
density, for example <code>scale=0.5</code> with <code>colmax="black"</code> for
a mid-grey colour.  </p>
</td></tr>
<tr><td><code id="denstrip_+3A_gamma">gamma</code></td>
<td>
<p> Gamma correction to apply to the colour palette.
The default of 1 should give an approximate perception of
darkness proportional to density, but this may need to be adjusted
for different displays. Values of <code>gamma</code> greater than 1
produce colours weighted towards the lighter end, and values of
between 0 and 1 produce darker colours.
</p>
</td></tr>
<tr><td><code id="denstrip_+3A_ticks">ticks</code></td>
<td>
<p> Vector of <code>x</code>-positions on the strip to draw tick marks, or <code>NULL</code> for no ticks. </p>
</td></tr>
<tr><td><code id="denstrip_+3A_tlen">tlen</code></td>
<td>
<p> Length of these tick marks relative to the strip width. </p>
</td></tr>
<tr><td><code id="denstrip_+3A_twd">twd</code></td>
<td>
<p> Line thickness of these marks (defaults to
<code><a href="graphics.html#topic+par">par</a>("lwd")</code>, or in <span class="pkg">lattice</span>, to
</p>
<p><code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a>("add.line")$lwd*2</code>.). </p>
</td></tr>
<tr><td><code id="denstrip_+3A_tcol">tcol</code></td>
<td>
<p>Colour of the tick marks. Defaults to <code>colmax</code>.</p>
</td></tr>
<tr><td><code id="denstrip_+3A_mticks">mticks</code></td>
<td>
 <p><code>x</code>-position to draw a thicker tick mark or tick
marks (for example, at the mean or median). </p>
</td></tr>
<tr><td><code id="denstrip_+3A_mlen">mlen</code></td>
<td>
<p> Length of this mark relative to the strip width. </p>
</td></tr>
<tr><td><code id="denstrip_+3A_mwd">mwd</code></td>
<td>
<p> Line thickness of this mark (defaults to
<code><a href="graphics.html#topic+par">par</a>("lwd")*2</code>, or in <span class="pkg">lattice</span>, to    
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a>("add.line")$lwd*2</code>.). </p>
</td></tr>
<tr><td><code id="denstrip_+3A_mcol">mcol</code></td>
<td>
<p>Colour of this mark. Defaults to <code>colmax</code>.</p>
</td></tr>
<tr><td><code id="denstrip_+3A_lattice">lattice</code></td>
<td>
<p>Set this to <code>TRUE</code> to make <code><a href="#topic+denstrip">denstrip</a></code>
a <span class="pkg">lattice</span> panel function instead of a base graphics function. <br />
<code>panel.denstrip(x,...)</code> is equivalent to
<code>denstrip(x, lattice=TRUE, ...)</code>.</p>
</td></tr>
<tr><td><code id="denstrip_+3A_...">...</code></td>
<td>
<p>Additional arguments supplied to <code><a href="stats.html#topic+density">density</a>(x,...)</code>, if
the density is being estimated.  For example, <code>bw</code> to change
the bandwidth of the kernel. </p>
</td></tr>
</table>


<h3>In other software</h3>

<p>In OpenBUGS (<a href="http://www.openbugs.net">http://www.openbugs.net</a>) density strips are
available via the Inference/Compare menu. 
</p>
<p>See this blog post:
<a href="http://blogs.sas.com/content/graphicallyspeaking/2012/11/03/density-strip-plot/">http://blogs.sas.com/content/graphicallyspeaking/2012/11/03/density-strip-plot/</a>,
for density strips in SAS. 
</p>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>References</h3>

<p> Jackson, C. H.  (2008) Displaying uncertainty with
shading. <em>The American Statistician</em>, 62(4):340-347. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+denstrip.legend">denstrip.legend</a></code>, <code><a href="#topic+densregion">densregion</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Illustrate a known standard normal distribution
## Various settings to change the look of the plot

x &lt;- seq(-4, 4, length=10000)
dens &lt;- dnorm(x)
plot(x, xlim=c(-5, 5), ylim=c(-5, 5), xlab="x", ylab="x", type="n")
denstrip(x, dens, at=0) # default width 
denstrip(x, dens, width=0.5, at=0) 
denstrip(x, dens, at=-4, ticks=c(-2, 0, 2)) 
denstrip(x, dens, at=-3, ticks=c(-2, 2), mticks=0) 
denstrip(x, dens, at=-2, ticks=c(-2, 2), mticks=0, mlen=3, 
         mwd=4, colmax="#55AABB") 
denstrip(x, dens, at=1, ticks=c(-2, 2), tlen=3, twd=3) 
denstrip(x, dens, at=-4, ticks=c(-2, 2), mticks=0, colmax="darkgreen", 
         horiz=FALSE)
x &lt;- rnorm(1000) # Estimate the density
denstrip(x, width=0.2, at=-3, ticks=c(-2, 2), mticks=0, colmax="darkgreen",
         horiz=FALSE)
denstrip(x, at=2, width=0.5, gamma=2.2) 
denstrip(x, at=3, width=0.5, gamma=1/2.2) 

### Specifying colour of minimum density 
par(bg="lightyellow")
plot(x, xlim=c(-5, 5), ylim=c(-5, 5), xlab="x", ylab="x", type="n")
x &lt;- seq(-4, 4, length=10000)
dens &lt;- dnorm(x)
## Equivalent ways of drawing same distribution 
denstrip(x, dens, at=-1, ticks=c(-2, 2), mticks=0, colmax="darkmagenta")
denstrip(x, dens, at=-2, ticks=c(-2, 2), mticks=0, colmax="darkmagenta",
         colmin="lightyellow")
## ...though the next only works if graphics device supports transparency 
denstrip(x, dens, at=-3, ticks=c(-2, 2), mticks=0, colmax="darkmagenta",
         colmin="transparent")
denstrip(x, dens, at=-4, ticks=c(-2, 2), mticks=0, colmax="#8B008B", colmin="white")

## Alternative to density regions (\link{densregion.survfit}) for
## survival curves - a series of vertical density strips with no
## interpolation

if (requireNamespace("survival", quietly=TRUE)){

library(survival)
fit &lt;- survfit(Surv(time, status) ~ 1, data=aml, conf.type="log-log")
plot(fit, col=0)
lse &lt;- (log(-log(fit$surv)) - log(-log(fit$upper)))/qnorm(0.975)
n &lt;- length(fit$time)
lstrip &lt;- fit$time - (fit$time-c(0,fit$time[1:(n-1)])) / 2
rstrip &lt;- fit$time + (c(fit$time[2:n], fit$time[n])-fit$time) / 2
for (i in 1:n) { 
    y &lt;- exp(-exp(qnorm(seq(0,1,length=1000)[-c(1,1000)], 
                        log(-log(fit$surv))[i], lse[i])))
    z &lt;- dnorm(log(-log(y)), log(-log(fit$surv))[i], lse[i])
    denstrip(y, z, at=(lstrip[i]+rstrip[i])/2,
                 width=rstrip[i]-lstrip[i],
                 horiz=FALSE, colmax="darkred")
}
par(new=TRUE)
plot(fit, lwd=2)

}

## Use for lattice graphics (first example from help(xyplot))

library(lattice)
Depth &lt;- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes,
       panel = function(x, y) { 
           panel.xyplot(x, y)
           panel.denstrip(x, horiz=TRUE, at=-10, ticks=mean(x))
           panel.denstrip(y, horiz=FALSE, at=165, ticks=mean(y))
       } 
       )

## Lattice example data: heights of singing voice types

bwplot(voice.part ~ height, data=singer, xlab="Height (inches)",
       panel=panel.violin, xlim=c(50,80))
bwplot(voice.part ~ height, data=singer, xlab="Height (inches)",
       panel = function(x, y) {
           xlist &lt;- split(x, factor(y))
           for (i in seq(along=xlist))
               panel.denstrip(x=xlist[[i]], at=i)
       },
       xlim=c(50,80)
       )
</code></pre>

<hr>
<h2 id='denstrip.legend'> Add a legend to a density strip or shaded region </h2><span id='topic+denstrip.legend'></span><span id='topic+panel.denstrip.legend'></span>

<h3>Description</h3>

<p>Add a legend to an existing plot with a density strip or shaded
region, indicating the mapping of colours to densities.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denstrip.legend(x, y, width, len, colmax, colmin="white", gamma=1,
                horiz=FALSE, max=1, nticks = 5, ticks, value.adj = 0,
                cex, main = "Density", lattice=FALSE)
panel.denstrip.legend(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denstrip.legend_+3A_x">x</code></td>
<td>
<p> Central x position of the legend. </p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_y">y</code></td>
<td>
<p> Central y position of the legend. </p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_width">width</code></td>
<td>
<p> Width of the legend strip, that is, the length of its
shorter dimension. Defaults to 1/30 of the axis range.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_len">len</code></td>
<td>
<p> Length of the legend strip, that is, the length of its
longer dimension. Defaults to 1/4 of the axis range.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_colmax">colmax</code></td>
<td>
<p> Colour at the maximum density, either as a built-in R
colour name (one of <code>colors()</code>) or an RGB hex value.  Defaults
to <code>par("fg")</code> or its <span class="pkg">lattice</span> equivalent, which is
<code>"black"</code> by default.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_colmin">colmin</code></td>
<td>
<p> Colour to shade the minimum density, likewise. 
Defaults to &quot;white&quot;.  If this is set to <code>"transparent"</code>,
and the current graphics device supports transparency (see <code><a href="grDevices.html#topic+rgb">rgb</a></code>), then
overlapping strips will merge smoothly. </p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_gamma">gamma</code></td>
<td>
<p>Gamma correction to apply to the colour palette, see <code><a href="#topic+denstrip">denstrip</a></code>.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_horiz">horiz</code></td>
<td>
<p> Legend strip drawn vertically (<code>FALSE</code>) or
horizontally (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_max">max</code></td>
<td>
<p> Maximum density on the legend, which is represented by
<code>colmax</code>.  With the default of 1, the legend indicates the
mapping of colours to proportions of the maximum density.
</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_nticks">nticks</code></td>
<td>
<p> Number of tick marks on the axis adjacent to the
legend, if <code>ticks</code> not supplied. </p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_ticks">ticks</code></td>
<td>
<p>Positions of numbered ticks on the axis adjacent to the
legend. Defaults to <code>nticks</code> equally spaced ticks between 0 and
the maximum density.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_value.adj">value.adj</code></td>
<td>
<p> Extra adjustment for the axis labels to the right
(if <code>horiz=FALSE</code>) or downwards (if <code>horiz=TRUE</code>). </p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_cex">cex</code></td>
<td>
<p>Text expansion.  Defaults to <code><a href="graphics.html#topic+par">par</a>("cex") * 0.75</code> or
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a>("axis.text")$cex * 0.75</code>.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_main">main</code></td>
<td>
<p> Text to place above the legend. </p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_lattice">lattice</code></td>
<td>
<p>Set this to <code>TRUE</code> to make <code><a href="#topic+denstrip.legend">denstrip.legend</a></code>
a <span class="pkg">lattice</span> panel function instead of a base graphics function. <br />
<code>panel.denstrip.legend(x,...)</code> is equivalent to
<code>denstrip.legend(x, lattice=TRUE, ...)</code>.</p>
</td></tr>
<tr><td><code id="denstrip.legend_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>panel.denstrip.legend</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>See Also</h3>

 <p><code><a href="#topic+denstrip">denstrip</a></code>, <code><a href="#topic+densregion">densregion</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("survival", quietly=TRUE)){

library(survival)
fit &lt;- survfit(Surv(time, status) ~ 1, data=aml, conf.type="log-log")
plot(fit, col=0)
densregion(fit)
denstrip.legend(100, 0.8)

    ### TODO if max not supplied - ticks are not meaningful.
    ### In help example, find actual max dens used for densregion

denstrip.legend(120, 0.8, width=3, len=0.4, value.adj=5)
denstrip.legend(40, 0.9, horiz=TRUE)
denstrip.legend(60, 0.7, horiz=TRUE, width=0.02, len=50, value.adj=0.04)


}



</code></pre>

<hr>
<h2 id='denstrip.normal'>Density strip for a normal or log-normal distribution</h2><span id='topic+denstrip.normal'></span><span id='topic+panel.denstrip.normal'></span>

<h3>Description</h3>

<p>Draws a density strip for a normal or log-normal distribution
with the given mean and standard deviation, based on computing the
density at a large set of equally-spaced quantiles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denstrip.normal(mean, sd, log=FALSE, nx=1000, ...)
panel.denstrip.normal(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denstrip.normal_+3A_mean">mean</code></td>
<td>
<p>Mean of the normal distribution.</p>
</td></tr>
<tr><td><code id="denstrip.normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the normal distribution.</p>
</td></tr>
<tr><td><code id="denstrip.normal_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> then the strip for a log-normal distribution,
with mean and SD on the log scale <code>mean</code> and <code>sd</code>,
respectively, is plotted.  This may be useful for illustrating hazard ratios
or odds ratios. 
</p>
</td></tr>
<tr><td><code id="denstrip.normal_+3A_nx">nx</code></td>
<td>
<p>Number of points to evaluate the density at.</p>
</td></tr>
<tr><td><code id="denstrip.normal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+denstrip">denstrip</a></code>,
for example, <code>at</code> to position the strip on the y-axis,
or <code>lattice=TRUE</code> to use as a lattice panel function. <br />
<code>panel.denstrip.normal(x,...)</code> is equivalent to
<code>denstrip.normal(x, lattice=TRUE,...)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+denstrip">denstrip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, length=10000)
dens &lt;- dnorm(x)
plot(x, xlim=c(-5, 5), ylim=c(-1, 2), xlab="x", ylab="", type="n", axes=FALSE)
axis(1)
denstrip(x, dens, at=0, width=0.3)
denstrip.normal(0, 1, at=1, width=0.3)

### log-normal distribution
sdlog &lt;- 0.5
x &lt;- rlnorm(10000, 0, sdlog)
plot(x, xlim=c(0, 5), ylim=c(-2, 4), xlab="x", , ylab="", type="n",
     axes=FALSE)
axis(1)
abline(v=1, lty=2, col="lightgray")
denstrip(x, at=0, ticks=exp(-sdlog^2), width=0.4) # tick at theoretical maximum density 
denstrip(x, at=1, bw=0.1, ticks=exp(-sdlog^2), width=0.4)
denstrip.normal(0, sdlog, log=TRUE, at=3, nx=1000,
                ticks=exp(-sdlog^2), width=0.4)
</code></pre>

<hr>
<h2 id='sectioned.density'> Sectioned density plots </h2><span id='topic+sectioned.density'></span><span id='topic+panel.sectioned.density'></span>

<h3>Description</h3>

<p>Sectioned density plots (Cohen and Cohen, 2006) use shading and
occlusion to give a compact illustration of a distribution, such as
the empirical distribution of data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sectioned.density(x, dens, at, width, offset, ny,
                  method=c("kernel","frequency"), nx, horiz=TRUE,
                  up.left = TRUE, colmax, colmin="white", gamma=1,
                  lattice=FALSE, ...)
panel.sectioned.density(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sectioned.density_+3A_x">x</code></td>
<td>
<p> Either the vector of points at which the density is
evaluated (if <code>dens</code> supplied), or a sample from the distribution
(if <code>dens</code> not supplied).</p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_dens">dens</code></td>
<td>
<p> Density at <code>points</code>. If <code>dens</code> is not supplied,
the density of the distribution underlying <code>x</code> is estimated using the method
specified in <code>method</code>. </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_at">at</code></td>
<td>
<p> Position of the bottom of the plot on the y-axis (if
<code>horiz=TRUE</code>) or position of the right of the plot on the
x-axis (if <code>horiz=FALSE</code>) (required).  </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_ny">ny</code></td>
<td>
<p> Number of fixed-width intervals for categorising the density. </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_width">width</code></td>
<td>
<p> Width of individual rectangles in the plot.  Defaults to
the range of the axis divided by 20. </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_offset">offset</code></td>
<td>
<p> Offset for adjacent rectangles. Defaults to
<code>width/3</code>. </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_method">method</code></td>
<td>
<p>Method of estimating the density of <code>x</code>, when
<code>dens</code> is not supplied.
</p>
<p>If <code>"kernel"</code> (the default)
then kernel density estimation is used, via <code><a href="stats.html#topic+density">density</a>(x,...)</code>. 
</p>
<p>If <code>"frequency"</code> then the density is estimated as the relative
frequency in a series of bins, as in Cohen and Cohen (2006).  This
method is controlled by the number of data bins <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_nx">nx</code></td>
<td>
<p> Number of data bins for the <code>"frequency"</code> density
estimation method. The default uses Sturges' formula (see <code><a href="grDevices.html#topic+nclass.Sturges">nclass.Sturges</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>).</p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_horiz">horiz</code></td>
<td>
<p> If <code>horiz=TRUE</code>, then the plot is horizontal and
points upwards.  If <code>horiz=FALSE</code> then the plot is vertical
and points leftwards, as the illustrations in Cohen and Cohen
(2006). </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_up.left">up.left</code></td>
<td>
<p> If changed to <code>FALSE</code>, then horizontal plots
point downwards and vertical plots point rightwards.</p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_colmax">colmax</code></td>
<td>
<p> Darkest colour, either as a built-in R colour name (one
of <code><a href="grDevices.html#topic+colors">colors</a>()</code>) or an RGB hex value.  Defaults to
<code><a href="graphics.html#topic+par">par</a>("fg")</code> or its <span class="pkg">lattice</span> equivalent, which is normally     
<code>"black"</code>, or <code>"#000000"</code>. </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_colmin">colmin</code></td>
<td>
<p> Lightest colour, either as a built-in R colour name (one
of <code><a href="grDevices.html#topic+colors">colors</a>()</code>) or an RGB hex value.  Defaults to white. </p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_gamma">gamma</code></td>
<td>
<p>Gamma correction to apply to the colour palette, see <code><a href="#topic+denstrip">denstrip</a></code>.</p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_lattice">lattice</code></td>
<td>
<p>Set this to <code>TRUE</code> to make <code><a href="#topic+sectioned.density">sectioned.density</a></code>
a <span class="pkg">lattice</span> panel function instead of a base graphics function. <br />
<code>panel.sectioned.density(x,...)</code> is equivalent to
<code>sectioned.density(x, lattice=TRUE, ...)</code>.</p>
</td></tr>
<tr><td><code id="sectioned.density_+3A_...">...</code></td>
<td>
<p>Additional arguments supplied to <code><a href="stats.html#topic+density">density</a>(x,...)</code>, if
<code>method="kernel"</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; (R implementation)</p>


<h3>References</h3>

<p> Cohen, D. J. and Cohen, J. The sectioned density
plot. <em>The American Statistician</em> (2006) <b>60</b>(2):167&ndash;174 </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fisher's iris data 
## Various settings to change the look of the plot
hist(iris$Sepal.Length, nclass=20, col="lightgray")
sectioned.density(iris$Sepal.Length, at=0.2)
sectioned.density(iris$Sepal.Length, at=5)
sectioned.density(iris$Sepal.Length, at=10, width=0.5)
hist(iris$Sepal.Length, nclass=20, col="lightgray")
sectioned.density(iris$Sepal.Length, at=7, width=0.5,
                  offset=0.1, colmax="darkmagenta")
sectioned.density(iris$Sepal.Length, at=9, width=0.5,
                  offset=0.1, ny=15, colmin="lemonchiffon")
## frequency method less smooth than kernel density 
sectioned.density(iris$Sepal.Length, at=12, width=0.5, offset=0.1,
                  method="frequency")
sectioned.density(iris$Sepal.Length, at=13.5, width=0.5, offset=0.1,
                  method="frequency", nx=20)

## Illustrate a known distribution
x &lt;- seq(-4, 4, length=1000)
dens &lt;- dnorm(x)
plot(x, xlim=c(-5, 5), ylim=c(-5, 5), xlab="x", ylab="x", type="n")
sectioned.density(x, dens, ny=8, at=0, width=0.3)
sectioned.density(x, dens, ny=16, at=2, width=0.1)
sectioned.density(x, dens, at=-3, horiz=FALSE)
sectioned.density(x, dens, at=4, width=0.3, horiz=FALSE)

</code></pre>

<hr>
<h2 id='seqToIntervals'>Find contiguous sequences in a vector of integers</h2><span id='topic+seqToIntervals'></span>

<h3>Description</h3>

<p>Get all sequences of contiguous values in a vector of integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqToIntervals(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqToIntervals_+3A_x">x</code></td>
<td>
<p>A vector of integers, for example, representing
indices. <code>x</code> is coerced to integer, sorted, and unique values
extracted, if necessary, before finding the contiguous sequences. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one row for each sequence, and two columns containing
the start and the end of the sequence, respectively.
</p>


<h3>Author(s)</h3>

<p>Chris Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;. Thanks to Tobias Verbeke for the suggestion.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sectioned.density">sectioned.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqToIntervals(1:10)  # [1 10]
seqToIntervals(c(1:10, 15:18, 20))  # [1 10; 15 18; 20 20]
# vectorised, so efficient for large vectors x
seqToIntervals(sample(1:1000000, size=999990)) 
</code></pre>

<hr>
<h2 id='vwstrip'>Varying-width strips</h2><span id='topic+vwstrip'></span><span id='topic+panel.vwstrip'></span>

<h3>Description</h3>

<p>Varying-width strips give a compact illustration of a distribution. 
The width of the strip is proportional to the density.  This function 
adds a varying-width strip to an exising plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vwstrip(x, dens, at, width, horiz=TRUE, scale=1, limits=c(-Inf, Inf), 
        col="gray", border=NULL, lwd, lty, ticks=NULL, tlen=1, twd, tty,
        lattice=FALSE,...)
panel.vwstrip(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vwstrip_+3A_x">x</code></td>
<td>
<p> Either the vector of points at which the density is
evaluated (if <code>dens</code> supplied), or a sample from the distribution
(if <code>dens</code> not supplied). </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_dens">dens</code></td>
<td>
<p> Density at <code>x</code>. If <code>dens</code> is not supplied,
the density of the sample <code>x</code> is estimated by kernel density
estimation, using <code><a href="stats.html#topic+density">density</a>(x,...)</code>.</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_at">at</code></td>
<td>
<p> Position of the centre of the strip on the y-axis (if
<code>horiz=TRUE</code>) or the x-axis (if <code>horiz=FALSE</code>).  </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_width">width</code></td>
<td>
<p> Thickness of the strip at the maximum density, that is, the length of its
shorter dimension.  Defaults to 1/20 of the axis range. </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_horiz">horiz</code></td>
<td>
<p> Draw the strip horizontally (<code>TRUE</code>) or vertically (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_scale">scale</code></td>
<td>
<p> Alternative way of specifying the thickness of the
strip, as a proportion of <code>width</code>. </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_limits">limits</code></td>
<td>
<p>Vector of minimum and maximum values, respectively, at which to terminate the strip.</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_col">col</code></td>
<td>
<p>Colour to shade the strip, either as a built-in R
colour name (one of <code><a href="grDevices.html#topic+colors">colors</a>()</code>) or an RGB hex
value, e.g. black is <code>"#000000"</code>.</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_border">border</code></td>
<td>
<p>Colour of the border, see <code><a href="graphics.html#topic+polygon">polygon</a></code>. Use
<code>border=NA</code> to show no border.  The default, 'NULL', means to
use 'par(&quot;fg&quot;)' or its <span class="pkg">lattice</span> equivalent</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_lwd">lwd</code></td>
<td>
<p>Line width of the border (defaults to
<code><a href="graphics.html#topic+par">par</a>("lwd")</code> or its <span class="pkg">lattice</span> equivalent).</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_lty">lty</code></td>
<td>
<p>Line type of the border (defaults to
<code><a href="graphics.html#topic+par">par</a>("lty")</code> or its <span class="pkg">lattice</span> equivalent).</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_ticks">ticks</code></td>
<td>
<p> Vector of <code>x</code>-positions on the strip to draw tick
marks, or <code>NULL</code> for no ticks. </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_tlen">tlen</code></td>
<td>
<p>Length of the ticks, relative to the thickness of the strip.</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_twd">twd</code></td>
<td>
<p> Line width of these marks (defaults to
<code><a href="graphics.html#topic+par">par</a>("lwd")</code> or its <span class="pkg">lattice</span> equivalent). </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_tty">tty</code></td>
<td>
<p> Line type of these marks (defaults to
<code><a href="graphics.html#topic+par">par</a>("lty")</code> or its <span class="pkg">lattice</span> equivalent). </p>
</td></tr>
<tr><td><code id="vwstrip_+3A_lattice">lattice</code></td>
<td>
<p>Set this to <code>TRUE</code> to make <code><a href="#topic+vwstrip">vwstrip</a></code>
a <span class="pkg">lattice</span> panel function instead of a base graphics function. <br />
<code>panel.vwstrip(x,...)</code> is equivalent to
<code>vwstrip(x, lattice=TRUE, ...)</code>.</p>
</td></tr>
<tr><td><code id="vwstrip_+3A_...">...</code></td>
<td>
<p>Additional arguments supplied to <code><a href="stats.html#topic+density">density</a>(x,...)</code>, if
the density is being estimated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Varying-width strips look like <em>violin plots</em>.  The difference is that
violin plots are intended to summarise data, while
<code><a href="#topic+vwstrip">vwstrip</a></code> is
intended to illustrate a distribution arising from parameter
estimation or prediction.  Either the distribution is known
analytically, or an arbitrarily large sample from the distribution is
assumed to be available via a method such as MCMC or bootstrapping.
</p>
<p>Illustrating outliers is important for summarising data, therefore
violin plots terminate at the sample minimum and maximum and superimpose
a box plot (which appears like the bridge of a violin, hence the name). 
Varying-width strips, however, are used to illustrate known
distributions which may have unbounded support.  Therefore it is
important to think about where the strips should terminate (the
<code>limits</code> argument).  For example, the end points may illustrate 
a particular pair of extreme quantiles of the distribution.
</p>
<p>The function <code>vioplot</code> in the <span class="pkg">vioplot</span>
package and <code><a href="lattice.html#topic+panel.violin">panel.violin</a></code> in the <span class="pkg">lattice</span>
package can be used to draw violin plots of observed data.
</p>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>References</h3>

<p> Jackson, C. H.  (2008) Displaying uncertainty with
shading. <em>The American Statistician</em>, 62(4):340-347. 
</p>
<p>Hintze, J.L. and Nelson, R.D. (1998) Violin plots: a box plot -
density trace synergism. <em>The American Statistician</em>
<b>52</b>(2),181&ndash;184. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+denstrip">denstrip</a></code>, <code><a href="#topic+bpstrip">bpstrip</a></code>, <code><a href="#topic+cistrip">cistrip</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, length=10000)
dens &lt;- dnorm(x)
plot(x, xlim=c(-5, 5), ylim=c(-5, 5), xlab="x", ylab="x", type="n")
vwstrip(x, dens, at=1, ticks=qnorm(c(0.025, 0.25,0.5, 0.75, 0.975)))

## Terminate the strip at specific outer quantiles
vwstrip(x, dens, at=2, limits=qnorm(c(0.025, 0.975)))
vwstrip(x, dens, at=3, limits=qnorm(c(0.005, 0.995)))

## Compare with density strip
denstrip(x, dens, at=0)

## Estimate the density from a large sample 
x &lt;- rnorm(10000)
vwstrip(x, at=4)

</code></pre>

<hr>
<h2 id='vwstrip.normal'>Varying width strip for a normal or log-normal distribution</h2><span id='topic+vwstrip.normal'></span><span id='topic+panel.vwstrip.normal'></span>

<h3>Description</h3>

<p>Draws a varying width strip for a normal or log-normal distribution
with the given mean and standard deviation, based on computing the
density at a large set of equally-spaced quantiles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vwstrip.normal(mean, sd, log=FALSE, nx=1000, ...)
panel.vwstrip.normal(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vwstrip.normal_+3A_mean">mean</code></td>
<td>
<p>Mean of the normal distribution.</p>
</td></tr>
<tr><td><code id="vwstrip.normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the normal distribution.</p>
</td></tr>
<tr><td><code id="vwstrip.normal_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> then the strip for a log-normal distribution,
with mean and SD on the log scale <code>mean</code> and <code>sd</code>,
respectively, is plotted.  This may be useful for illustrating hazard ratios
or odds ratios. 
</p>
</td></tr>
<tr><td><code id="vwstrip.normal_+3A_nx">nx</code></td>
<td>
<p>Number of points to evaluate the density at.</p>
</td></tr>
<tr><td><code id="vwstrip.normal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+vwstrip">vwstrip</a></code>,
for example, <code>at</code> to position the strip on the y-axis,
or <code>lattice=TRUE</code> to use as a lattice panel function. <br />
<code>panel.vwstrip.normal(x,...)</code> is equivalent to
<code>vwstrip.normal(x, lattice=TRUE,...)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt; </p>


<h3>See Also</h3>

<p><code><a href="#topic+vwstrip">vwstrip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, length=10000)
dens &lt;- dnorm(x)
plot(x, xlim=c(-5, 5), ylim=c(-1, 2), xlab="x", ylab="",
     type="n", axes=FALSE)
axis(1)
vwstrip(x, dens, at=0, width=0.4, limits=qnorm(c(0.005, 0.995)))
vwstrip.normal(0, 1, at=1, width=0.4, limits=qnorm(c(0.005, 0.995)))

### log-normal distribution
sdlog &lt;- 0.5
x &lt;- rlnorm(10000, 0, sdlog)
plot(x, xlim=c(0, 5), ylim=c(-1, 3), xlab="x", ylab="",
     type="n", axes=FALSE)
axis(1)
abline(v=1, lty=2, col="lightgray")
vwstrip(x, at=0, width=0.4, ticks=exp(-sdlog^2),
        limits=qlnorm(c(0.005,0.975),0,sdlog)) # tick at theoretical maximum density 
vwstrip(x, at=1, width=0.4, bw=0.1, ticks=exp(-sdlog^2),
        limits=qlnorm(c(0.005,0.975),0,sdlog))
vwstrip.normal(0, sdlog, log=TRUE, at=2.5, width=0.4, nx=1000,
               ticks=exp(-sdlog^2), limits=qlnorm(c(0.005,0.975),0,sdlog))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
