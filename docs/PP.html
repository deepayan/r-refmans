<!DOCTYPE html><html><head><title>Help for package PP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#findmodel'><p>Create a model-type vector template</p></a></li>
<li><a href='#fourpl_df'><p>Simulated data set</p></a></li>
<li><a href='#JKpp'><p>Run a jackknife</p></a></li>
<li><a href='#Pfit'><p>Person-Fit statistics</p></a></li>
<li><a href='#PP'><p>Estimation of Person Parameters and calculation of Person Fit for the 1,2,3,4-PL model and the GPCM.</p></a></li>
<li><a href='#PP_4pl'><p>Estimate Person Parameters for the 4-PL model</p></a></li>
<li><a href='#pp_amt'><p>Adaptive Matrices Test data</p></a></li>
<li><a href='#PP_gpcm'><p>Estimate Person Parameters for the GPCM</p></a></li>
<li><a href='#PPall'><p>Estimate Person Parameters</p></a></li>
<li><a href='#PPass'><p>Person Assessment function</p></a></li>
<li><a href='#PV'><p>Draw Plausible values</p></a></li>
<li><a href='#sim_4pl'><p>Simulate data for 1/2/3/4-pl model</p></a></li>
<li><a href='#sim_gpcm'><p>Simulate data for the gpcm model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Person Parameter Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.3-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Steinfeld <a href="https://orcid.org/0000-0001-9853-8260"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Manuel Reif [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Steinfeld &lt;jan.d.steinfeld@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The PP package includes estimation of (MLE, WLE, MAP, EAP, ROBUST)
    person parameters for the 1,2,3,4-PL model and the GPCM (generalized
    partial credit model). The parameters are estimated under the assumption
    that the item parameters are known and fixed. The package is useful e.g. in
    the case that items from an item pool / item bank with known item parameters
    are administered to a new population of test-takers and an ability
    estimation for every test-taker is needed.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jansteinfeld/PP">https://github.com/jansteinfeld/PP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jansteinfeld/PP/issues">https://github.com/jansteinfeld/PP/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, roxygen2, knitr, eRm, data.table, prettydoc,
rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-24 11:23:23 UTC; jansteinfeld</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-27 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='findmodel'>Create a model-type vector template</h2><span id='topic+findmodel'></span>

<h3>Description</h3>

<p>This is a small helper function which creates a vector template  quick and easily for the <code>PPall()</code> function. Modify this template as you like.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findmodel(thres)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findmodel_+3A_thres">thres</code></td>
<td>
<p>A numeric matrix which contains the threshold parameter for each item. NA is allowed - in fact expected!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to guess the model which was applied to each item by using the matrix of threshold parameters. It only discriminates between GPCM and 4-PL model, and returns a character vector of length equal to the number of items, that contains <code>"GPCM"</code> or <code>"4PL"</code> entries depending on the structure of the thres matrix.
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>See Also</h3>

<p><a href="#topic+PPall">PPall</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# GPCM  and 4PL mixed #########################################

# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)

THRESx &lt;- THRES
THRESx[2,1:3] &lt;- NA

# for the 4PL item the estimated parameters are submitted, 
# for the GPCM items the lower asymptote = 0 
# and the upper asymptote = 1.
la     &lt;- c(0.02,0.1,0,0,0,0)
ua     &lt;- c(0.97,0.91,1,1,1,1)

awmatrix &lt;- matrix(c(1,0,1,0,1,1,1,0,0,1
                     ,2,0,0,0,0,0,0,0,0,1
                     ,1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)

# create model2est
# this function tries to help finding the appropriate 
# model by inspecting the THRESx.
model2est &lt;- findmodel(THRESx)


# MLE
respmixed_mle &lt;- PPall(respm = awmatrix,thres = THRESx, 
                     slopes = sl,lowerA = la, upperA=ua,type = "mle",
                     model2est=model2est)
# WLE
respmixed_wle &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua,type = "wle",
                    model2est=model2est)
# MAP estimation
respmixed_map &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "map",
                    model2est=model2est)

# EAP estimation
respmixed_eap &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "eap",
                    model2est=model2est)

# Robust estimation
respmixed_rob &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "robust",
                    model2est=model2est)


# summary to summarize the results
summary(respmixed_mle)
summary(respmixed_wle)
summary(respmixed_map)
summary(respmixed_eap)
summary(respmixed_rob)

</code></pre>

<hr>
<h2 id='fourpl_df'>Simulated data set</h2><span id='topic+fourpl_df'></span>

<h3>Description</h3>

<p>This dataset contains data simulated with the <code>sim_4pl()</code> function.
</p>


<h3>Format</h3>

<p>A data.frame with 60 rows and 14 columns.
</p>


<h3>Source</h3>

<p>simulation
</p>


<h3>See Also</h3>

<p><a href="#topic+sim_4pl">sim_4pl</a>
</p>

<hr>
<h2 id='JKpp'>Run a jackknife</h2><span id='topic+JKpp'></span><span id='topic+JKpp.fourpl'></span><span id='topic+JKpp.gpcm'></span><span id='topic+JKpp.gpcm4pl'></span><span id='topic+print.jk'></span><span id='topic+summary.jk'></span>

<h3>Description</h3>

<p>This function uses a jackknife approach to compute person parameters. The jackknife ability measure is based on primarily estimated models (<code>PP_4pl()</code>, <code>PP_gpcm()</code> or <code>PPall()</code>) - so the function is applied on the estimation objects, and jackknifed ability measures are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JKpp(estobj, ...)

## S3 method for class 'fourpl'
JKpp(
  estobj,
  cmeth = "mean",
  maxsteps = 500,
  exac = 0.001,
  fullmat = FALSE,
  ctrl = list(),
  ...
)

## S3 method for class 'gpcm'
JKpp(
  estobj,
  cmeth = "mean",
  maxsteps = 500,
  exac = 0.001,
  fullmat = FALSE,
  ctrl = list(),
  ...
)

## S3 method for class 'gpcm4pl'
JKpp(
  estobj,
  cmeth = "mean",
  maxsteps = 500,
  exac = 0.001,
  fullmat = FALSE,
  ctrl = list(),
  ...
)

## S3 method for class 'jk'
print(x, ...)

## S3 method for class 'jk'
summary(object, nrowmax = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JKpp_+3A_estobj">estobj</code></td>
<td>
<p>An object which originates from using <code>PP_gpcm()</code>, <code>PP_4pl()</code> or <code>PPall()</code>.</p>
</td></tr>
<tr><td><code id="JKpp_+3A_...">...</code></td>
<td>
<p>More input.</p>
</td></tr>
<tr><td><code id="JKpp_+3A_cmeth">cmeth</code></td>
<td>
<p>Choose the centering method, to summarize the n jackknife results to one single ability estimate. There are three valid entries: &quot;mean&quot;, &quot;median&quot; and &quot;AMT&quot; (see Details for further description).</p>
</td></tr>
<tr><td><code id="JKpp_+3A_maxsteps">maxsteps</code></td>
<td>
<p>The maximum number of steps the NR Algorithm will take.</p>
</td></tr>
<tr><td><code id="JKpp_+3A_exac">exac</code></td>
<td>
<p>How accurate are the estimates supposed to be? Default is 0.001.</p>
</td></tr>
<tr><td><code id="JKpp_+3A_fullmat">fullmat</code></td>
<td>
<p>Default = FALSE. If TRUE, the function returns the whole jackknife matrix, which is the basis for the jackknife estimator.</p>
</td></tr>
<tr><td><code id="JKpp_+3A_ctrl">ctrl</code></td>
<td>
<p>More controls</p>
</td></tr>
<tr><td><code id="JKpp_+3A_x">x</code></td>
<td>
<p>an object of class <code>jk</code> which is the result of using the <code>JKpp()</code> function</p>
</td></tr>
<tr><td><code id="JKpp_+3A_object">object</code></td>
<td>
<p>An object of class <code>jk</code> which is the result of using the <code>JKpp()</code> function</p>
</td></tr>
<tr><td><code id="JKpp_+3A_nrowmax">nrowmax</code></td>
<td>
<p>When printing the matrix of estimates - how many rows should be shown? Default = 15.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please use the Jackknife <b>Standard-Error</b> output with <b>caution</b>! It is implemented as suggested in Wainer and Wright (1980), but the results seem a bit strange, because the JK-SE is supposed to overestimate the SE compared to the MLE-SE. Actually, in all examples an underestimation of the SE was observed compared to the MLE/WLE-SE! 
</p>
<p><b>AMT-robustified jackknife:</b> When choosing <code>cmeth = AMT</code>, the jackknife ability subsample estimates and the original supplied ability estimate are combined to a single jackknife-ability value by the Sine M-estimator. The AMT (or Sine M-estimator) is one of the winners in the Princeton Robustness Study of 1972. To get a better idea how the estimation process works, take a closer look to the paper which is mentioned below (Wainer &amp; Wright, 1980).
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>References</h3>

<p>Wainer, H., &amp; Wright, B. D. (1980). Robust estimation of ability in the Rasch model. Psychometrika, 45(3), 373-391.
</p>


<h3>See Also</h3>

<p><a href="#topic+PP_gpcm">PP_gpcm</a>, <a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+PPall">PPall</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# Jackknife ###################################################

### 4 PL model ######

### data creation ##########

set.seed(1623)
# intercepts
diffpar &lt;- seq(-3,3,length=12)
# slope parameters
sl     &lt;- round(runif(12,0.5,1.5),2)
la     &lt;- round(runif(12,0,0.25),2)
ua     &lt;- round(runif(12,0.8,1),2)

# response matrix
abpar &lt;- rnorm(10,0,1.7)
awm &lt;- sim_4pl(beta = diffpar,alpha = sl,lowerA = la,upperA=ua,theta = abpar)

## 1PL model ##### 

# MLE
res1plmle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "mle")
# WLE
res1plwle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "wle")
# MAP estimation
res1plmap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "map")
# EAP estimation
res1pleap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "eap")
# robust estimation
res1plrob &lt;- PP_4pl(respm = awm,thres = diffpar,type = "robust")

## centering method = mean
res_jk1 &lt;- JKpp(res1plmle)
res_jk2 &lt;- JKpp(res1plwle)
res_jk3 &lt;- JKpp(res1plmap)
res_jk4 &lt;- JKpp(res1plrob)
res_jk5 &lt;- JKpp(res1pleap)

summary(res_jk1)

## centering method = median
res_jk1a &lt;- JKpp(res1plmle,cmeth = "median")
res_jk2a &lt;- JKpp(res1plwle,cmeth = "median")
res_jk3a &lt;- JKpp(res1plmap,cmeth = "median")

summary(res_jk2a)

## centering method = AMT
res_jk1b &lt;- JKpp(res1plmle,cmeth = "AMT")
res_jk2b &lt;- JKpp(res1plwle,cmeth = "AMT")
res_jk3b &lt;- JKpp(res1plmap,cmeth = "AMT")

summary(res_jk3b)


## 2PL model ##### 

# MLE
res2plmle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "mle")
# WLE
res2plwle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "wle")
# MAP estimation
res2plmap &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "map")
# EAP estimation
res2pleap &lt;- PP_4pl(respm = awm,thres = diffpar,slopes = sl,type = "eap")
# robust estimation
res2plrob &lt;- PP_4pl(respm = awm,thres = diffpar,slopes = sl,type = "robust")

res_jk6 &lt;- JKpp(res2plmle)
res_jk7 &lt;- JKpp(res2plwle)
res_jk8 &lt;- JKpp(res2plmap)
res_jk9 &lt;- JKpp(res2pleap)
res_jk10 &lt;- JKpp(res2plrob)

### GPCM model ######

# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)
awmatrix &lt;- matrix(c(1,0,2,0,1,1,1,0,0,1,2,0,0,0,0,0,0,0,0,1,
                     1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)


### PCM model ######

# MLE
respcmlmle &lt;- PP_gpcm(respm = awmatrix,thres = THRES,
                      slopes = rep(1,ncol(THRES)),type = "mle")
# WLE
respcmwle &lt;- PP_gpcm(respm = awmatrix,thres = THRES,
                     slopes = rep(1,ncol(THRES)),type = "wle")
# MAP estimation
respcmmap &lt;- PP_gpcm(respm = awmatrix,thres = THRES,
                     slopes = rep(1,ncol(THRES)),type = "map")


res_jk11 &lt;- JKpp(respcmlmle)
res_jk12 &lt;- JKpp(respcmwle)
res_jk13 &lt;- JKpp(respcmmap)

### GPCM/4-PL mixed model ######

THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)

sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)

THRESx &lt;- THRES
THRESx[2,1:3] &lt;- NA

# for the 4PL item the estimated parameters are submitted, 
# for the GPCM items the lower asymptote = 0 
# and the upper asymptote = 1.
la     &lt;- c(0.02,0.1,0,0,0,0)
ua     &lt;- c(0.97,0.91,1,1,1,1)

awmatrix &lt;- matrix(c(1,0,1,0,1,1,1,0,0,1
                     ,2,0,0,0,1,0,0,0,0,1
                     ,0,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)

# create model2est
# this function tries to help finding the appropriate 
# model by inspecting the THRESx.
model2est &lt;- findmodel(THRESx)


# MLE estimation
respmixed_mle &lt;- PPall(respm = awmatrix,
                       thres = THRESx, 
                       slopes = sl,
                       lowerA = la,
                       upperA=ua,
                       type = "mle",
                       model2est=model2est)
# WLE estimation
respmixed_wle &lt;- PPall(respm = awmatrix,
                       thres = THRESx, 
                       slopes = sl,
                       lowerA = la,
                       upperA=ua,
                       type = "wle",
                       model2est=model2est)


res_jk114 &lt;- JKpp(respmixed_mle)
res_jk115 &lt;- JKpp(respmixed_wle)
</code></pre>

<hr>
<h2 id='Pfit'>Person-Fit statistics</h2><span id='topic+Pfit'></span><span id='topic+Pfit.gpcm'></span>

<h3>Description</h3>

<p>Compute several person fit statistic for the 1-PL, 2-PL, 3-PL, 4-PL and PCM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pfit(respm, pp, fitindices, SE = FALSE)

## S3 method for class 'gpcm'
Pfit(respm, pp, fitindices = c("infit", "outfit"), SE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pfit_+3A_respm">respm</code></td>
<td>
<p>numeric response matrix</p>
</td></tr>
<tr><td><code id="Pfit_+3A_pp">pp</code></td>
<td>
<p>object of the class fourpl with estimated person parameter</p>
</td></tr>
<tr><td><code id="Pfit_+3A_fitindices">fitindices</code></td>
<td>
<p>character vector of desired person fit statistics c(&quot;lz&quot;,&quot;lzstar&quot;,&quot;infit&quot;,&quot;outfit&quot;)</p>
</td></tr>
<tr><td><code id="Pfit_+3A_se">SE</code></td>
<td>
<p>logical: if true standard errors are computed using jackknife method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that currently only the likelihood based LZ-Index (Drasgow, Levine, and Williams, 1985) and LZ*-Index (Snijders, 2001) are implemented. Also the INFIT-OUTIFT (Wright and Masters, 1982, 1990) statistic as well as the polytomouse version of INFIT-OUTFIT are supported. Other person fit statistics will be added soon.
</p>
<p>The calculation of the person fit statistics requires the numeric response-matrix as well as an object of the fourpl-class. So first you should estimate the person parameter and afterwards calculate the person fit statistics. You could also use our PPass-function to estimate the person parameter and calculate the desired person fit simultaneously.
It is possible to calculate several person fit statistics at once, you only have to specify them in a vector.
</p>
<p>For the Partial Credit model we currently support the infit-outfit statistic. Please submit also the numeric response-matrix as well as the estimated person parameter with an gpcm-class.
</p>


<h3>Value</h3>

<p>list of person-fits for each person-fit statistic
</p>

<ul>
<li><p> the list of person-fits contains the calculated person-fit (like lz, lzstar) and also additional information like p-value or standard error if desired.
</p>
</li>
<li><p> the additional information is provided after the short form of the personfit
</p>
</li>
<li><p> lz (lz)
</p>
</li>
<li><p> lzstar (lzs)
</p>
</li>
<li><p> infit the mean-square statistic (in)
</p>
</li>
<li><p> outfit the mean-square statistic (ou)
</p>
</li>
<li><p> _unst: unstandardised
</p>
</li>
<li><p> _se: standard error
</p>
</li>
<li><p> _t: t-value
</p>
</li>
<li><p> _chisq: $chi^2$-value
</p>
</li>
<li><p> _df: defrees of freedom
</p>
</li>
<li><p> _pv: p-value
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jan Steinfeld
</p>


<h3>References</h3>

<p>Armstrong, R. D., Stoumbos, Z. G., Kung, M. T. &amp; Shi, M. (2007). On the performance of the lz person-fit statistic.  <em>Practical Assessment, Research &amp; Evaluation</em>, <b>12(16)</b>. Chicago	
</p>
<p>De La Torre, J., &amp; Deng, W. (2008). Improving Person-Fit Assessment by Correcting the Ability Estimate and Its Reference Distribution. Journal of Educational Measurement, <b>45(2)</b>, 159-177.
</p>
<p>Drasgow, F., Levine, M. V. &amp; Williams, E. A. (1985) Appropriateness measurement with polychotomous item response models and standardized indices. <em>British Journal of Mathematical and Statistical Psychology</em>, <b>38(1)</b>, 67&ndash;86.
</p>
<p>Efron, B., &amp; Stein, C. (1981). The jackknife estimate of variance. <em>The Annals of Statistics</em>, <b>9(3)</b>, 586-596.	
</p>
<p>Karabatsos, G. (2003) Comparing the Aberrant Response Detection Performance of Thirty-Six Person-Fit Statistics. <em>Applied Measurement In Education</em>, <b>16(4)</b>, 277&ndash;298.
</p>
<p>Magis, D., Raiche, G. &amp; Beland, S. (2012) A didactic presentation of Snijders's l[sub]z[/sub] index of person fit with emphasis on response model selection and ability estimation. <em>Journal of Educational and Behavioral Statistics</em>, <b>37(1)</b>, 57&ndash;81.
</p>
<p>Meijer, R. R. &amp; Sijtsma, K. (2001) Methodology review: Evaluating person fit. <em>Applied Psychological Measurement</em>, <b>25(2)</b>, 107&ndash;135.
</p>
<p>Molenaar, I. W. &amp; Hoijtink, H. (1990) The many null distributions of person fit indices. <em>Psychometrika</em>, <b>55(1)</b>, 75&ndash;106. 
</p>
<p>Mousavi, A. &amp; Cui, Y. Evaluate the performance of and of person fit: A simulation study.
</p>
<p>Reise, S. P. (1990). A comparison of item-and person-fit methods of assessing model-data fit in IRT.  <em>Applied Psychological Measurement</em>, <b>14(2)</b>, 127-137.
</p>
<p>Snijders, T. B. (2001) Asymptotic null distribution of person fit statistics with estimated person parameter. <em>Psychometrika</em>, <b>66(3)</b>, 331&ndash;342. 
</p>
<p>Wright, B. D. &amp; Masters, G. N. (1990). Computation of OUTFIT and INFIT Statistics.  <em>Rasch Measurement Transactions</em>, 3:4, 84-85.
</p>
<p>Wright, B. D., &amp; Masters, G. N. (1982). <em>Rating Scale Analysis. Rasch Measurement.</em> MESA Press, 5835 S. Kimbark Avenue, Chicago, IL 60637.
</p>


<h3>See Also</h3>

<p><a href="#topic+PPall">PPall</a>, <a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+PPass">PPass</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# Pfit ###################################################


### data creation ##########

set.seed(1337)


# intercepts
diffpar &lt;- seq(-3,3,length=15)
# slope parameters
sl     &lt;- round(runif(15,0.5,1.5),2)
la     &lt;- round(runif(15,0,0.25),2)
ua     &lt;- round(runif(15,0.8,1),2)

# response matrix
awm &lt;- matrix(sample(0:1,100*15,replace=TRUE),ncol=15)

# ------------------------------------------------------------------------
## 1PL model ##### 
# ------------------------------------------------------------------------
# MLE
res1plmle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "mle")
# WLE
res1plwle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "wle")
# MAP estimation
res1plmap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "map")
# ------------------------------------------------------------------------
## LZ*-Index ##### 
Pfit(respm=awm,pp=res1plwle,fitindices="lzstar")
Pfit(respm=awm,pp=res1plmle,fitindices="lzstar")
Pfit(respm=awm,pp=res1plmap,fitindices="lzstar")
## LZ*-Index combined with Infit-Outfit ##### 
Pfit(respm=awm,pp=res1plwle,fitindices=c("lzstar","infit","outfit"))
# ------------------------------------------------------------------------

##########################################################################

# ------------------------------------------------------------------------
## 2PL model ##### 
# ------------------------------------------------------------------------
# MLE
res2plmle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "mle")
# WLE
res2plwle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "wle")
# ------------------------------------------------------------------------
## LZ*-Index ##### 
Pfit(respm=awm,pp=res2plwle,fitindices="lzstar")
Pfit(respm=awm,pp=res2plmle,fitindices="lzstar")
## LZ*-Index combined with Infit-Outfit ##### 
Pfit(respm=awm,pp=res2plwle,fitindices=c("lzstar","infit","outfit"))
# ------------------------------------------------------------------------

##########################################################################

# ------------------------------------------------------------------------
## 3PL model ##### 
# ------------------------------------------------------------------------
# MLE
res3plmle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,type = "mle")
# WLE
res3plwle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,type = "wle")
# ------------------------------------------------------------------------
## LZ*-Index ##### 
Pfit(respm=awm,pp=res3plwle,fitindices="lzstar")
Pfit(respm=awm,pp=res3plmle,fitindices="lzstar")
## LZ*-Index combined with Infit-Outfit ##### 
Pfit(respm=awm,pp=res3plwle,fitindices=c("lzstar","infit","outfit"))
# ------------------------------------------------------------------------

##########################################################################

# ------------------------------------------------------------------------
## 4PL model ##### 
# ------------------------------------------------------------------------
# MLE
res4plmle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,upperA=ua,type = "mle")
# WLE
res4plwle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,upperA=ua,type = "wle")
# ------------------------------------------------------------------------
## LZ*-Index ##### 
Pfit(respm=awm,pp=res4plwle,fitindices="lzstar")
Pfit(respm=awm,pp=res4plmle,fitindices="lzstar")
## LZ*-Index combined with Infit-Outfit ##### 
Pfit(respm=awm,pp=res4plwle,fitindices=c("lzstar","infit","outfit"))
# ------------------------------------------------------------------------

##########################################################################
</code></pre>

<hr>
<h2 id='PP'>Estimation of Person Parameters and calculation of Person Fit for the 1,2,3,4-PL model and the GPCM.</h2><span id='topic+PP'></span>

<h3>Description</h3>

<p>PP-package has been developed to easily compute ML, WL (Warm 1989), MAP, EAP and robust estimates of person parameters for a given response matrix and given item parameters of the 1,2,3,4-PL model (Birnbaum 1968, Barton &amp; Lord 1981) and the GPCM (Muraki 1992). It provides c++ routines which makes estimation of parameters very fast. Additional some methods to calculate the person fit are provided like the infit-outfit-, lz- and lz*-idex. Read the vignettes for getting started with this package.
</p>


<h3>Author(s)</h3>

<p>Manuel Reif and Jan Steinfeld
</p>


<h3>References</h3>

<p>Barton, M. A., &amp; Lord, F. M. (1981). An Upper Asymptote for the Three-Parameter Logistic Item-Response Model.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability. In Lord, F.M. &amp; Novick, M.R. (Eds.), Statistical theories of mental test scores. Reading, MA: Addison-Wesley.
</p>
<p>Drasgow, F., Levine, M. V. &amp; Williams, E. A. (1985) Appropriateness measurement with polychotomous item response models and standardized indices. <em>British Journal of Mathematical and Statistical Psychology</em>, <b>38(1)</b>, 67&ndash;86.
</p>
<p>Muraki, Eiji (1992). A Generalized Partial Credit Model: Application of an EM Algorithm. Applied Psychological Measurement, 16, 159-176.
</p>
<p>Samejima, Fumiko (1993). An approximation of the bias function of the maximum likelihood estimate of a latent variable for the general case where the item responses are discrete. Psychometrika,  58, 119-138.
</p>
<p>Snijders, T. B. (2001) Asymptotic null distribution of person fit statistics with estimated person parameter. <em>Psychometrika</em>, <b>66(3)</b>, 331&ndash;342. 
</p>
<p>Warm, Thomas A. (1989). Weighted Likelihood Estimation Of Ability In Item Response Theory. Psychometrika, 54, 427-450.
</p>
<p>Wright, B. D. &amp; Masters, G. N. (1990). Computation of OUTFIT and INFIT Statistics.  <em>Rasch Measurement Transactions</em>, 3:4, 84-85.
</p>
<p>Yen, Y.-C., Ho, R.-G., Liao, W.-W., Chen, L.-J., &amp; Kuo, C.-C. (2012). An empirical evaluation of the slip correction in the four parameter logistic models with computerized adaptive testing. Applied Psychological Measurement, 36, 75-87.
</p>


<h3>See Also</h3>

<p><a href="#topic+PPass">PPass</a>, <a href="#topic+PP_gpcm">PP_gpcm</a>, <a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+PPall">PPall</a>, <a href="#topic+Pfit">Pfit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1522)
# intercepts
diffpar &lt;- seq(-3,3,length=12)
# slope parameters
sl     &lt;- round(runif(12,0.5,1.5),2)
la     &lt;- round(runif(12,0,0.25),2)
ua     &lt;- round(runif(12,0.8,1),2)

# response matrix
awm &lt;- matrix(sample(0:1,10*12,replace=TRUE),ncol=12)
# MLE estimation
res3plmle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,lowerA = la,type = "mle")
# WLE estimation
res3plwle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,lowerA = la,type = "wle")
# MAP estimation
res3plmap &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,lowerA = la,type = "map")

# calculate person fit
res3plmlepfit &lt;- Pfit(respm=awm,pp=res3plmle,fitindices=c("infit","outfit"))

# or estimate person parameter and calculate person fit in one step 
out &lt;- PPass(respdf = data.frame(awm),thres = diffpar, items="all",
             mod=c("1PL"), fitindices= c("lz","lzstar","infit","outfit"))
</code></pre>

<hr>
<h2 id='PP_4pl'>Estimate Person Parameters for the 4-PL model</h2><span id='topic+PP_4pl'></span>

<h3>Description</h3>

<p>Compute Person Parameters for the 1/2/3/4-PL model and choose between five common estimation techniques: ML, WL, MAP, EAP and a robust estimation. All item parameters are treated as fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PP_4pl(
  respm,
  thres,
  slopes = NULL,
  lowerA = NULL,
  upperA = NULL,
  theta_start = NULL,
  mu = NULL,
  sigma2 = NULL,
  type = "wle",
  maxsteps = 40,
  exac = 0.001,
  H = 1,
  ctrl = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PP_4pl_+3A_respm">respm</code></td>
<td>
<p>An integer matrix, which contains the examinees responses. A persons x items matrix is expected.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_thres">thres</code></td>
<td>
<p>A numeric vector or a numeric matrix which contains the threshold parameter (also known as difficulty parameter or beta parameter) for each item. If a matrix is submitted, the first row must contain only <b>zeroes</b>!</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_slopes">slopes</code></td>
<td>
<p>A numeric vector, which contains the slope parameters for each item - one parameter per item is expected.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_lowera">lowerA</code></td>
<td>
<p>A numeric vector, which contains the lower asymptote parameters (kind of guessing parameter) for each item.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_uppera">upperA</code></td>
<td>
<p>numeric vector, which contains the upper asymptote parameters for each item.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_theta_start">theta_start</code></td>
<td>
<p>A vector which contains a starting value for each person. If NULL is submitted, the starting values are set automatically. If a scalar is submitted, this start value is used for each person.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_mu">mu</code></td>
<td>
<p>A numeric vector of location parameters for each person in case of MAP or EAP estimation. If nothing is submitted this is set to 0 for each person for MAP estimation.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_sigma2">sigma2</code></td>
<td>
<p>A numeric vector of variance parameters for each person in case of MAP or EAP estimation. If nothing is submitted this is set to 1 for each person for MAP estimation.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_type">type</code></td>
<td>
<p>Which maximization should be applied? There are five valid entries possible: &quot;mle&quot;, &quot;wle&quot;, &quot;map&quot;, &quot;eap&quot; and &quot;robust&quot;. To choose between the methods, or just to get a deeper understanding the papers mentioned below are quite helpful. The default is <code>"wle"</code> which is a good choice in many cases.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_maxsteps">maxsteps</code></td>
<td>
<p>The maximum number of steps the NR Algorithm will take. Default = 100.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_exac">exac</code></td>
<td>
<p>How accurate are the estimates supposed to be? Default is 0.001.</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_h">H</code></td>
<td>
<p>In case <code>type = "robust"</code> a Huber ability estimate is performed, and <code>H</code> modulates how fast the downweighting takes place (for more Details read Schuster &amp; Yuan 2011).</p>
</td></tr>
<tr><td><code id="PP_4pl_+3A_ctrl">ctrl</code></td>
<td>
<p>more controls:
</p>

<ul>
<li> <p><code>killdupli</code>: Should duplicated response pattern be removed for estimation (estimation is faster)? This is especially resonable in case of a large number of examinees and a small number of items.  Use this option with caution (for map and eap), because persons with different <code>mu</code> and <code>sigma2</code> will have different ability estimates despite they responded identically. Default value is <code>FALSE</code>.
</p>
</li>
<li> <p><code>skipcheck</code>: Default = FALSE. If TRUE data matrix and arguments are not checked - this saves time e.g. when you use this function for simulations.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function you can estimate:
</p>

<ul>
<li> <p><b>1-PL model</b> (Rasch model) by submitting: the data matrix, item difficulties and <b>nothing else</b>, since the 1-PL model is merely a 4-PL model with: any slope = 1, any lower asymptote = 0 and any upper asymptote = 1!
</p>
</li>
<li> <p><b>2-PL model</b> by submitting: the data matrix, item difficulties and slope parameters. Lower and upper asymptotes are automatically set to 0 und 1 respectively.
</p>
</li>
<li> <p><b>3-PL model</b> by submitting anything except the upper asymptote parameters
</p>
</li>
<li> <p><b>4-PL model</b> &mdash;&gt; submit all parameters ...
</p>
</li></ul>

<p>The probability function of the 4-PL model is:
</p>
<p style="text-align: center;"><code class="reqn">P(x_{ij} = 1 | \hat \alpha_i, \hat\beta_i, \hat\gamma_i, \hat\delta_i, \theta_j ) = \hat\gamma_i + (\hat\delta_i-\hat\gamma_i) \frac{exp(\hat \alpha_i (\theta_{j} - \hat\beta_{i}))}{\,1 + exp(\hat\alpha_i (\theta_{j} - \hat\beta_{i}))}</code>
</p>

<p>In our case <code class="reqn">\theta</code> is to be estimated, and the four item parameters are assumed as fixed (usually these are estimates of a former scaling procedure).
</p>
<p>The 3-PL model is the same, except that <code class="reqn">\delta_i = 1, \forall i</code>.
</p>
<p>In the 2-PL model <code class="reqn">\delta_i = 1, \gamma_i = 0, \forall i</code>.
</p>
<p>In the 1-PL model <code class="reqn">\delta_i = 1, \gamma_i = 0, \alpha_i = 1, \forall i</code>.
</p>
<p>.
</p>
<p>The <b>robust</b> estimation method, applies a Huber-type estimator (Schuster &amp; Yuan, 2011), which downweights responses to items which provide little information for the ability estimation. First a residuum is estimated and on this basis, the weight for each observation is computed.
</p>
<p>residuum:
</p>
<p style="text-align: center;"><code class="reqn">r_i = \alpha_i(\theta - \beta_i)</code>
</p>

<p>weight:
</p>
<p style="text-align: center;"><code class="reqn">w(r_i) =  1 \rightarrow if\, |r_i| \leq H</code>
</p>

<p style="text-align: center;"><code class="reqn">w(r_i) = H/|r| \rightarrow if\, |r_i| &gt; H</code>
</p>



<h3>Value</h3>

<p>The function returns a list with the estimation results and pretty much everything which has been submitted to fit the model. The estimation results can be found in <code>OBJ$resPP</code>. The core result is a number_of_persons x 2 matrix, which contains the ability estimate and the SE for each submitted person.
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>References</h3>

<p>Baker, Frank B., and Kim, Seock-Ho (2004). Item Response Theory - Parameter Estimation Techniques. CRC-Press.
</p>
<p>Barton, M. A., &amp; Lord, F. M. (1981). An Upper Asymptote for the Three-Parameter Logistic Item-Response Model.
</p>
<p>Birnbaum, A. (1968). Some latent trait models and their use in inferring an examinee's ability. In Lord, F.M. &amp; Novick, M.R. (Eds.), Statistical theories of mental test scores. Reading, MA: Addison-Wesley.
</p>
<p>Magis, D. (2013). A note on the item information function of the four-parameter logistic model. Applied Psychological Measurement, 37(4), 304-315.
</p>
<p>Samejima, Fumiko (1993). The bias function of the maximum likelihood estimate of ability for the dichotomous response level. Psychometrika,  58, 195-209.
</p>
<p>Samejima, Fumiko (1993). An approximation of the bias function of the maximum likelihood estimate of a latent variable for the general case where the item responses are discrete. Psychometrika,  58, 119-138.
</p>
<p>Schuster, C., &amp; Yuan, K. H. (2011). Robust estimation of latent ability in item response models. Journal of Educational and Behavioral Statistics, 36(6), 720-735.
</p>
<p>Warm, Thomas A. (1989). Weighted Likelihood Estimation Of Ability In Item Response Theory. Psychometrika, 54, 427-450.
</p>
<p>Yen, Y.-C., Ho, R.-G., Liao, W.-W., Chen, L.-J., &amp; Kuo, C.-C. (2012). An empirical evaluation of the slip correction in the four parameter logistic models with computerized adaptive testing. Applied Psychological Measurement, 36, 75-87.
</p>


<h3>See Also</h3>

<p><a href="#topic+PPass">PPass</a>, <a href="#topic+PPall">PPall</a>, <a href="#topic+PP_gpcm">PP_gpcm</a>, <a href="#topic+JKpp">JKpp</a>, <a href="#topic+PV">PV</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# 4 PL #############################################################

### real data ##########

data(pp_amt)

d &lt;- as.matrix(pp_amt$daten_amt[,-(1:7)])

rd_res &lt;- PP_4pl(respm = d, thres = pp_amt$betas[,2], type = "wle")
summary(rd_res)

rd_res1 &lt;- PP_4pl(respm = d, thres = pp_amt$betas[,2], theta_start = 0,type = "wle")
summary(rd_res1)

### fake data ##########
# smaller ... faster

set.seed(1522)
# intercepts
diffpar &lt;- seq(-3,3,length=12)
# slope parameters
sl     &lt;- round(runif(12,0.5,1.5),2)
la     &lt;- round(runif(12,0,0.25),2)
ua     &lt;- round(runif(12,0.8,1),2)

# response matrix
awm &lt;- matrix(sample(0:1,10*12,replace=TRUE),ncol=12)


## 1PL model ##### 

# MLE
res1plmle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "mle")
# WLE
res1plwle &lt;- PP_4pl(respm = awm,thres = diffpar,type = "wle")
# MAP estimation
res1plmap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "map")
# EAP estimation
res1pleap &lt;- PP_4pl(respm = awm,thres = diffpar,type = "eap")
# robust estimation
res1plrob &lt;- PP_4pl(respm = awm,thres = diffpar,type = "robust")

# summarize results
summary(res1plmle)
summary(res1plwle)
summary(res1plmap)


## 2PL model ##### 

# MLE
res2plmle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "mle")
# WLE
res2plwle &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "wle")
# MAP estimation
res2plmap &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "map")
# EAP estimation
res2pleap &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "eap")
# robust estimation
res2plrob &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "robust")


## 3PL model ##### 

# MLE
res3plmle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,type = "mle")
# WLE
res3plwle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,type = "wle")
# MAP estimation
res3plmap &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,type = "map")
# EAP estimation
res3pleap &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la, type = "eap")


## 4PL model ##### 

# MLE
res4plmle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,upperA=ua,type = "mle")
# WLE
res4plwle &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,upperA=ua,type = "wle")
# MAP estimation
res4plmap &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,upperA=ua,type = "map")
# EAP estimation
res4pleap &lt;- PP_4pl(respm = awm,thres = diffpar,
                    slopes = sl,lowerA = la,upperA=ua,type = "eap")


## A special on robust estimation:
# it reproduces the example given in Schuster &amp; Ke-Hai 2011:

diffpar &lt;- c(-3,-2,-1,0,1,2,3)

AWM &lt;- matrix(0,7,7)
diag(AWM) &lt;- 1

res1plmle &lt;- PP_4pl(respm = AWM,thres = diffpar, type = "mle")

summary(res1plmle)

res1plrob &lt;- PP_4pl(respm = AWM,thres = diffpar, type = "robust")

summary(res1plrob)
</code></pre>

<hr>
<h2 id='pp_amt'>Adaptive Matrices Test data</h2><span id='topic+pp_amt'></span>

<h3>Description</h3>

<p>This dataset contains real data from the 'Adaptive Matrices Test' (AMT), which is a computer-administered test.
This power test assesses logical reasoning as an indicator of general intelligence. The ability to identify regularities and draw logical conclusions is a very good predictor of long-term success at work. The dataset is sparse, because the test tailores a specific set of items for each examinee's ability level. (More information about adaptive testing: <a href="https://en.wikipedia.org/wiki/Computerized_adaptive_testing">https://en.wikipedia.org/wiki/Computerized_adaptive_testing</a>)
</p>


<h3>Format</h3>

<p>A list with two data.frames. The first data.frame 'daten_amt' contains 298 columns and 710 rows. Each row contains responses from on examinee. The second data.frame 'betas' contains the difficulty parameter (1PL) (These parameters came with the raw-score extraction.).
</p>


<h3>Details</h3>

<p>The data are provided from the Unitersity of Vienna, Faculty of Psychology, Department of Psychological Assessment.
Thanks to Schuhfried <a href="https://marketplace.schuhfried.com/de/AMT">https://marketplace.schuhfried.com/de/AMT</a>.
</p>


<h3>Source</h3>

<p>Division of Psychological Assessment and Applied Psychometrics, Fakulty of Psychology, University of Vienna
</p>

<ul>
<li><p> ID: id of person
</p>
</li>
<li><p> AGE: age in years (with ages below 18 and above 34 are collapsed)
</p>
</li>
<li><p> TE_GA:
</p>

<ul>
<li><p> TE: self-assessment. To pass a psychological assessment course, the students have to complete several hours self assessment on a bunch of tests, to get familiar with them.
</p>
</li>
<li><p> GA: testing for an assessment report. The students also have to test other people (not psychologists nor psychology students) in order to write an assessment report.
</p>
</li></ul>

</li>
<li><p> FORM: There are several different versions of this test, which differ in test length, duration etc ...
</p>
</li>
<li><p> TIME1: start time
</p>
</li>
<li><p> TIME2: end time
</p>
</li>
<li><p> REL: reliability for each person
</p>
</li>
<li><p> i: items
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Hornke, L. F., Etzel, S., &amp; Rettig, K. (2003). Manual Adaptive Matrices Test (AMT). <em>Moedling: SCHUHFRIED GmbH</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+PPass">PPass</a>
</p>

<hr>
<h2 id='PP_gpcm'>Estimate Person Parameters for the GPCM</h2><span id='topic+PP_gpcm'></span>

<h3>Description</h3>

<p>Compute person parameters for the GPCM and choose between five common estimation techniques: ML, WL, MAP, EAP and a robust estimation. All item parameters are treated as fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PP_gpcm(
  respm,
  thres,
  slopes,
  theta_start = NULL,
  mu = NULL,
  sigma2 = NULL,
  type = "wle",
  maxsteps = 100,
  exac = 0.001,
  H = 1,
  ctrl = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PP_gpcm_+3A_respm">respm</code></td>
<td>
<p>An integer matrix, which contains the examinees responses. A persons x items matrix is expected.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_thres">thres</code></td>
<td>
<p>A numeric matrix which contains the threshold parameter for each item. If the first row of the matrix is not set to zero (only zeroes in the first row) - then a row-vector with zeroes is added by default.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_slopes">slopes</code></td>
<td>
<p>A numeric vector, which contains the slope parameters for each item - one parameter per item is expected.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_theta_start">theta_start</code></td>
<td>
<p>A vector which contains a starting value for each person. If NULL is submitted, the starting values are set automatically. If a scalar is submitted, this start value is used for each person.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_mu">mu</code></td>
<td>
<p>A numeric vector of location parameters for each person in case of MAP or EAP estimation. If nothing is submitted this is set to 0 for each person for MAP estimation.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_sigma2">sigma2</code></td>
<td>
<p>A numeric vector of variance parameters for each person in case of MAP  or EAP estimation. If nothing is submitted this is set to 1 for each person for MAP estimation.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_type">type</code></td>
<td>
<p>Which maximization should be applied? There are five valid entries possible: &quot;mle&quot;, &quot;wle&quot;, &quot;map&quot;, &quot;eap&quot; and &quot;robust&quot;. To choose between the methods, or just to get a deeper understanding the papers mentioned below are quite helpful. The default is <code>"wle"</code> which is a good choice in many cases.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_maxsteps">maxsteps</code></td>
<td>
<p>The maximum number of steps the NR Algorithm will take. Default = 100.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_exac">exac</code></td>
<td>
<p>How accurate are the estimates supposed to be? Default is 0.001.</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_h">H</code></td>
<td>
<p>In case <code>type = "robust"</code> a Huber ability estimate is performed, and <code>H</code> modulates how fast the downweighting takes place (for more Details read Schuster &amp; Yuan 2011).</p>
</td></tr>
<tr><td><code id="PP_gpcm_+3A_ctrl">ctrl</code></td>
<td>
<p>more controls
</p>

<ul>
<li> <p><code>killdupli</code>: Should duplicated response pattern be removed for estimation (estimation is faster)? This is especially resonable in case of a large number of examinees and a small number of items.  Use this option with caution (for map and eap), because persons with different <code>mu</code> and <code>sigma2</code> will have different ability estimates despite they responded identically. Default value is <code>FALSE</code>.
</p>
</li>
<li> <p><code>skipcheck</code>: Default = FALSE. If TRUE data matrix and arguments are not checked - this saves time e.g. when you use this function for simulations.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note, that <code>robust</code> estimation with (Huber ability estimate) polytomous items is still experimental!
</p>
<p>The probability choosing the k-th category is as follows:
</p>
<p style="text-align: center;"><code class="reqn">P(x_{ij} = k | \hat \alpha_i, \hat\beta_{iv}, \theta_j) = \frac{exp(\sum_{v=0}^{(k-1)}\hat \alpha_{i}(\theta_j - \hat \beta_{iv}))}{\,\sum_{c=0}^{m_i - 1}exp(\sum_{v=0}^{c}\hat \alpha_{i}(\theta_j - \hat \beta_{iv})))}</code>
</p>

<p>In our case <code class="reqn">\theta</code> is to be estimated. The item parameters are assumed as fixed (usually these are estimates of a former scaling procedure).
</p>
<p>The model simplifies to the Partial Credit Model by setting <code class="reqn">\alpha_{i} = 1, \forall i</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the estimation results and pretty much everything which has been submitted to fit the model. The estimation results can be found in <code>OBJ$resPP</code>. The core result is a number_of_persons x 2 matrix, which contains the ability estimate and the SE for each submitted person.
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>References</h3>

<p>Baker, Frank B., and Kim, Seock-Ho (2004). Item Response Theory - Parameter Estimation Techniques. CRC-Press.
</p>
<p>Masters, G. N. (1982). A Rasch model for partial credit scoring. Psychometrika, 47(2), 149-174.
</p>
<p>Muraki, Eiji (1992). A Generalized Partial Credit Model: Application of an EM Algorithm. Applied Psychological Measurement, 16, 159-176.
</p>
<p>Muraki, Eiji (1993). Information Functions of the Generalized Partial Credit Model. Applied Psychological Measurement, 17, 351-363.
</p>
<p>Samejima, Fumiko (1993). The bias function of the maximum likelihood estimate of ability for the dichotomous response level. Psychometrika,  58, 195-209.
</p>
<p>Samejima, Fumiko (1993). An approximation of the bias function of the maximum likelihood estimate of a latent variable for the general case where the item responses are discrete. Psychometrika,  58, 119-138.
</p>
<p>Schuster, C., &amp; Yuan, K. H. (2011). Robust estimation of latent ability in item response models. Journal of Educational and Behavioral Statistics, 36(6), 720-735.
</p>
<p>Wang, S. and Wang, T. (2001). Precision of Warm's Weighted Likelihood Estimates for a Polytomous Model in Computerized Adaptive Testing. Applied Psychological Measurement, 25, 317-331.
</p>
<p>Warm, Thomas A. (1989). Weighted Likelihood Estimation Of Ability In Item Response Theory. Psychometrika, 54, 427-450.
</p>


<h3>See Also</h3>

<p><a href="#topic+PPass">PPass</a>, <a href="#topic+PPall">PPall</a>, <a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+JKpp">JKpp</a>, <a href="#topic+PV">PV</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# GPCM ###########################################################################

# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)
awmatrix &lt;- matrix(c(1,0,2,0,1,1,1,0,0,1
                     ,2,0,0,0,0,0,0,0,0,1,1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)

## GPCM model ##### 

# MLE
resgpcmlmle &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = sl,type = "mle")
# WLE
resgpcmwle &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = sl,type = "wle")
# MAP estimation
resgpcmmap &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = sl,type = "map")
# EAP estimation
resgpcmeap &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = sl,type = "eap")
# robust estimation
resgpcmrob &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = sl,type = "robust")

## PCM model ##### 

# MLE
respcmlmle &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = rep(1,ncol(THRES)),type = "mle")
# WLE
respcmwle &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = rep(1,ncol(THRES)),type = "wle")
# MAP estimation
respcmmap &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = rep(1,ncol(THRES)),
                     type = "map")
# EAP estimation
respcmeap &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = rep(1,ncol(THRES)),
                     type = "eap")

#### with different number of categories ##

THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
THRES1 &lt;- rbind(THRES,c(NA,NA,NA,NA,1.7,1))

awmatrix1 &lt;- matrix(c(1,0,2,0,1,3,1,0,0,1,3,1,0,0
                      ,0,0,0,0,0,1,1,2,2,1,1,1,1,0,0,1), byrow=TRUE, nrow=5)

# MLE estimation
respcmlmle1 &lt;- PP_gpcm(respm = awmatrix1,thres = THRES1, slopes = sl,type = "mle")
# WLE estimation
respcmwle1 &lt;- PP_gpcm(respm = awmatrix1,thres = THRES1, slopes = sl,type = "wle")
# MAP estimation
respcmmap1 &lt;- PP_gpcm(respm = awmatrix1,thres = THRES1, slopes = sl,type = "map")
# EAP estimation
respcmeap1 &lt;- PP_gpcm(respm = awmatrix1, thres = THRES1, slopes = sl,type = "eap")
</code></pre>

<hr>
<h2 id='PPall'>Estimate Person Parameters</h2><span id='topic+PPall'></span><span id='topic+print.ppeo'></span><span id='topic+summary.ppeo'></span>

<h3>Description</h3>

<p>Compute person parameters for the 1,2,3,4-PL model and for the GPCM. Choose between ML, WL, MAP, EAP and robust estimation. Use this function if 4-PL items and GPCM items are mixed for each person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPall(
  respm,
  thres,
  slopes,
  lowerA,
  upperA,
  theta_start = NULL,
  mu = NULL,
  sigma2 = NULL,
  type = "wle",
  model2est,
  maxsteps = 100,
  exac = 0.001,
  H = 1,
  ctrl = list()
)

## S3 method for class 'ppeo'
print(x, ...)

## S3 method for class 'ppeo'
summary(object, nrowmax = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPall_+3A_respm">respm</code></td>
<td>
<p>An integer matrix, which contains the examinees responses. A persons x items matrix is expected.</p>
</td></tr>
<tr><td><code id="PPall_+3A_thres">thres</code></td>
<td>
<p>A numeric matrix which contains the threshold parameter for each item. If the first row of the matrix is not set to zero (only zeroes in the first row) - then a row-vector with zeroes is added by default.</p>
</td></tr>
<tr><td><code id="PPall_+3A_slopes">slopes</code></td>
<td>
<p>A numeric vector, which contains the slope parameters for each item - one parameter per item is expected.</p>
</td></tr>
<tr><td><code id="PPall_+3A_lowera">lowerA</code></td>
<td>
<p>A numeric vector, which contains the lower asymptote parameters (kind of guessing parameter) for each item. In the case of polytomous items, the value must be 0.</p>
</td></tr>
<tr><td><code id="PPall_+3A_uppera">upperA</code></td>
<td>
<p>numeric vector, which contains the upper asymptote parameters for each item. In the case of polytomous items, the value must be 1.</p>
</td></tr>
<tr><td><code id="PPall_+3A_theta_start">theta_start</code></td>
<td>
<p>A vector which contains a starting value for each person. If NULL is submitted, the starting values are set automatically. If a scalar is submitted, this start value is used for each person.</p>
</td></tr>
<tr><td><code id="PPall_+3A_mu">mu</code></td>
<td>
<p>A numeric vector of location parameters for each person in case of MAP estimation. If nothing is submitted this is set to 0 for each person for MAP estimation.</p>
</td></tr>
<tr><td><code id="PPall_+3A_sigma2">sigma2</code></td>
<td>
<p>A numeric vector of variance parameters for each person in case of MAP or EAP estimation. If nothing is submitted this is set to 1 for each person for MAP estimation.</p>
</td></tr>
<tr><td><code id="PPall_+3A_type">type</code></td>
<td>
<p>Which maximization should be applied? There are five valid entries possible: &quot;mle&quot;, &quot;wle&quot;, &quot;map&quot;, &quot;eap&quot; and &quot;robust&quot;. To choose between the methods, or just to get a deeper understanding the papers mentioned below are quite helpful. The default is <code>"wle"</code> which is a good choice in many cases.</p>
</td></tr>
<tr><td><code id="PPall_+3A_model2est">model2est</code></td>
<td>
<p>A character vector with length equal to the number of submitted items. It defines itemwise the response model under which the item parameter was estimated. There are 2 valid inputs up to now: <code>"GPCM"</code> and <code>"4PL"</code>.</p>
</td></tr>
<tr><td><code id="PPall_+3A_maxsteps">maxsteps</code></td>
<td>
<p>The maximum number of steps the NR algorithm will take. Default = 100.</p>
</td></tr>
<tr><td><code id="PPall_+3A_exac">exac</code></td>
<td>
<p>How accurate are the estimates supposed to be? Default is 0.001.</p>
</td></tr>
<tr><td><code id="PPall_+3A_h">H</code></td>
<td>
<p>In case <code>type = "robust"</code> a Huber ability estimate is performed, and <code>H</code> modulates how fast the downweighting takes place (for more Details read Schuster &amp; Yuan 2011).</p>
</td></tr>
<tr><td><code id="PPall_+3A_ctrl">ctrl</code></td>
<td>
<p>More controls:
</p>

<ul>
<li> <p><code>killdupli</code>: Should duplicated response pattern be removed for estimation (estimation is faster)? This is especially resonable in case of a large number of examinees and a small number of items.  Use this option with caution (for map and eap), because persons with different <code>mu</code> and <code>sigma2</code> will have different ability estimates despite they responded identically. Default value is <code>FALSE</code>.
</p>
</li>
<li> <p><code>skipcheck</code>: Default = FALSE. If TRUE data matrix and arguments are not checked - this saves time e.g. when you use this function for simulations.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PPall_+3A_x">x</code></td>
<td>
<p>an object of class <code>gpcm4pl</code> which is the result of using the <code>PPall()</code> function</p>
</td></tr>
<tr><td><code id="PPall_+3A_...">...</code></td>
<td>
<p>just some points.</p>
</td></tr>
<tr><td><code id="PPall_+3A_object">object</code></td>
<td>
<p>An object of class <code>gpcm4pl</code> which is the result of using the <code>PPall()</code> function</p>
</td></tr>
<tr><td><code id="PPall_+3A_nrowmax">nrowmax</code></td>
<td>
<p>When printing the matrix of estimates - how many rows should be shown? Default = 15.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a test with both: dichotomous and polytomous items which have been scaled under 1/2/3/4-PL model or the GPCM, use this function to estimate the person ability parameters. You have to define the appropriate model for each item. 
</p>
<p>Please note, that  <code>robust</code> estimation with (Huber ability estimate) polytomous items is still experimental!
</p>


<h3>Value</h3>

<p>The function returns a list with the estimation results and pretty much everything which has been submitted to fit the model. The estimation results can be found in <code>OBJ$resPP</code>. The core result is a number_of_persons x 2 matrix, which contains the ability estimate and the SE for each submitted person.
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>References</h3>

<p>Baker, Frank B., and Kim, Seock-Ho (2004). Item Response Theory - Parameter Estimation Techniques. CRC-Press.
</p>
<p>Barton, M. A., &amp; Lord, F. M. (1981). An Upper Asymptote for the Three-Parameter Logistic Item-Response Model.
</p>
<p>Magis, D. (2013). A note on the item information function of the four-parameter logistic model. Applied Psychological Measurement, 37(4), 304-315.
</p>
<p>Muraki, Eiji (1992). A Generalized Partial Credit Model: Application of an EM Algorithm. Applied Psychological Measurement, 16, 159-176.
</p>
<p>Muraki, Eiji (1993). Information Functions of the Generalized Partial Credit Model. Applied Psychological Measurement, 17, 351-363.
</p>
<p>Samejima, Fumiko (1993). The bias function of the maximum likelihood estimate of ability for the dichotomous response level. Psychometrika,  58, 195-209.
</p>
<p>Samejima, Fumiko (1993). An approximation of the bias function of the maximum likelihood estimate of a latent variable for the general case where the item responses are discrete. Psychometrika,  58, 119-138.
</p>
<p>Schuster, C., &amp; Yuan, K. H. (2011). Robust estimation of latent ability in item response models. Journal of Educational and Behavioral Statistics, 36(6), 720-735.
</p>
<p>Wang, S. and Wang, T. (2001). Precision of Warm's Weighted Likelihood Estimates for a Polytomous Model in Computerized Adaptive Testing. Applied Psychological Measurement, 25, 317-331.
</p>
<p>Warm, Thomas A. (1989). Weighted Likelihood Estimation Of Ability In Item Response Theory. Psychometrika, 54, 427-450.
</p>
<p>Yen, Y.-C., Ho, R.-G., Liao, W.-W., Chen, L.-J., &amp; Kuo, C.-C. (2012). An empirical evaluation of the slip correction in the four parameter logistic models with computerized adaptive testing. Applied Psychological Measurement, 36, 75-87.
</p>


<h3>See Also</h3>

<p><a href="#topic+PPass">PPass</a>, <a href="#topic+PP_gpcm">PP_gpcm</a>, <a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+JKpp">JKpp</a>, <a href="#topic+PV">PV</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# GPCM  and 4PL mixed #########################################

# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)

THRESx &lt;- THRES
THRESx[2,1:3] &lt;- NA

# for the 4PL item the estimated parameters are submitted, 
# for the GPCM items the lower asymptote = 0 
# and the upper asymptote = 1.
la     &lt;- c(0.02,0.1,0,0,0,0)
ua     &lt;- c(0.97,0.91,1,1,1,1)

awmatrix &lt;- matrix(c(1,0,1,0,1,1,1,0,0,1
                     ,2,0,0,0,0,0,0,0,0,1
                     ,1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)

# create model2est
# this function tries to help finding the appropriate 
# model by inspecting the THRESx.
model2est &lt;- findmodel(THRESx)


# MLE
respmixed_mle &lt;- PPall(respm = awmatrix,thres = THRESx, 
                     slopes = sl,lowerA = la, upperA=ua,type = "mle",
                     model2est=model2est)
# WLE
respmixed_wle &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua,type = "wle",
                    model2est=model2est)
# MAP estimation
respmixed_map &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "map",
                    model2est=model2est)

# EAP estimation
respmixed_eap &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "eap",
                    model2est=model2est)

# Robust estimation
respmixed_rob &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "robust",
                    model2est=model2est)


# summary to summarize the results
summary(respmixed_mle)
summary(respmixed_wle)
summary(respmixed_map)
summary(respmixed_eap)
summary(respmixed_rob)

</code></pre>

<hr>
<h2 id='PPass'>Person Assessment function</h2><span id='topic+PPass'></span><span id='topic+PPass.default'></span><span id='topic+PPass.Rm'></span>

<h3>Description</h3>

<p>Estimate Person Paramters and calculate Person Fit in one step to gain resonse pattern assessment. Submit a data.frame which contains item responses, or an fitted model (Rasch Model and Partial Credit Model are supported) of the <code>eRm</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPass(...)

## Default S3 method:
PPass(
  respdf,
  items = "all",
  mod = c("1PL", "2PL", "3PL", "4PL", "PCM", "GPCM", "MIXED"),
  fitindices = c("lz", "lzstar", "infit", "outfit"),
  ...
)

## S3 method for class 'Rm'
PPass(RMobj, fitindices = c("lz", "lzstar", "infit", "outfit"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPass_+3A_respdf">respdf</code></td>
<td>
<p>A data.frame which contains the items, and perhaps other informations. Each row is a person related resonse patter. Each column denotes a variable.</p>
</td></tr>
<tr><td><code id="PPass_+3A_items">items</code></td>
<td>
<p>A numeric (integer) vector which indicates the positions of the items in the data.frame (<code>respdf</code>). If <code>items</code> = 'all', <b>all columns</b> are treated as items.</p>
</td></tr>
<tr><td><code id="PPass_+3A_mod">mod</code></td>
<td>
<p>Choose your data generating model. This argument switches between the three person parameter estimating functions <code>PP_4pl</code>, <code>PP_gpcm</code> and <code>PPall</code>.</p>
</td></tr>
<tr><td><code id="PPass_+3A_fitindices">fitindices</code></td>
<td>
<p>A character vector which denotes the fit indices to compute.</p>
</td></tr>
<tr><td><code id="PPass_+3A_rmobj">RMobj</code></td>
<td>
<p>A fitted Rasch Model (<code>RM()</code>) object which stems from the <code>eRm</code> package.</p>
</td></tr>
<tr><td><code id="PPass_+3A_...">...</code></td>
<td>
<p>Submit arguments to the underlying functions: <code>PP_4pl</code>, <code>PP_gpcm</code> and <code>PPall</code> (see documentation files) for person parameter estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PPass fuses Person Parameter estimation and Person Fit computation into a single function.
</p>


<h3>Value</h3>

<p>The original data.frame and
</p>

<ul>
<li><p> The Person Parameter estimates incl. Standard Errors (2 columns)
</p>
</li>
<li><p> Person Fit Indices you chose (1 or more)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Manuel Reif, Jan Steinfeld
</p>


<h3>See Also</h3>

<p><a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+PP_gpcm">PP_gpcm</a>, <a href="#topic+PPall">PPall</a>, <a href="#topic+Pfit">Pfit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(eRm)
### real data ##########

data(pp_amt)

d &lt;- pp_amt$daten_amt

rd_res &lt;- PPass(respdf = d, 
                items = 8:ncol(d),
                mod="1PL",
                thres = pp_amt$betas[,2], 
                fitindices = "lz")

head(rd_res)


## ========== RM - eRm 
my_data &lt;- eRm::sim.rasch(200, 12)
my_rm &lt;- eRm::RM(my_data)

res_pp1 &lt;- PPass(my_rm)


## ========== PCM - eRm

set.seed(2751)

THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
THRES &lt;- rbind(THRES,c(-0.2,NA,NA,NA,NA,NA))

sl          &lt;- rep(1,6)
THRESx      &lt;- rbind(0,THRES)
THETA       &lt;- rnorm(200)
simdat_gpcm &lt;- sim_gpcm(thres = THRESx,alpha = sl,theta = THETA)

my_pcm &lt;- eRm::PCM(simdat_gpcm)

res_pp2 &lt;- PPass(my_pcm)

## ==========  1PL model

set.seed(1337)

# intercepts
diffpar &lt;- seq(-3,3,length=15)
# slope parameters
sl     &lt;- round(runif(15,0.5,1.5),2)
la     &lt;- round(runif(15,0,0.25),2)
ua     &lt;- round(runif(15,0.8,1),2)

# response matrix
awm &lt;- matrix(sample(0:1,100*15,replace=TRUE),ncol=15)
awm &lt;- as.data.frame(awm)
# estimate person parameter

# estimate person parameter and person fit
out &lt;- PPass(respdf = awm,thres = diffpar, items="all",
             mod=c("1PL"), fitindices= c("lz","lzstar","infit","outfit"))

# show first rows
head(out)
</code></pre>

<hr>
<h2 id='PV'>Draw Plausible values</h2><span id='topic+PV'></span><span id='topic+PV.fourpl'></span><span id='topic+PV.gpcm'></span><span id='topic+PV.gpcm4pl'></span><span id='topic+print.pv'></span><span id='topic+summary.pv'></span>

<h3>Description</h3>

<p>This function draws <code>npv</code> plausible values for each person from their posterior density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PV(estobj, ...)

## S3 method for class 'fourpl'
PV(estobj, npv = 10, approx = TRUE, thinning = 6, burnin = 10, mult = 2, ...)

## S3 method for class 'gpcm'
PV(estobj, npv = 10, approx = TRUE, thinning = 6, burnin = 10, mult = 2, ...)

## S3 method for class 'gpcm4pl'
PV(estobj, npv = 10, approx = TRUE, thinning = 6, burnin = 10, mult = 2, ...)

## S3 method for class 'pv'
print(x, ...)

## S3 method for class 'pv'
summary(object, nrowmax = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PV_+3A_estobj">estobj</code></td>
<td>
<p>An object which originates from using <code>PP_4pl()</code>, <code>PP_gpcm()</code> or <code>PPall()</code>. EAP estimation is strongly recommended (<code>type = "eap"</code>), when plausible values are drawn afterwards, because the EAP estimate is used as starting point for the MH algorithm.</p>
</td></tr>
<tr><td><code id="PV_+3A_...">...</code></td>
<td>
<p>More arguments</p>
</td></tr>
<tr><td><code id="PV_+3A_npv">npv</code></td>
<td>
<p>The number of (effectively returned) plausible values - default is 10.</p>
</td></tr>
<tr><td><code id="PV_+3A_approx">approx</code></td>
<td>
<p>Whether a normal approximation <code>N(mu,sigma2)</code> is used to draw the plausible values. Default = TRUE. If FALSE a Metropolitan-Hastings-Algorithm will draw the values.</p>
</td></tr>
<tr><td><code id="PV_+3A_thinning">thinning</code></td>
<td>
<p>A numeric vector of length = 1. If approx = FALSE, a Metropolitan-Hastings-Algorithm draws the plausible values. To avoid autocorrelation, thinning takes every <b>kth</b> value as effective plausible value. The default is 6 (every 6th value is taken), which works appropriately in almost all cases here (with default settings).</p>
</td></tr>
<tr><td><code id="PV_+3A_burnin">burnin</code></td>
<td>
<p>How many draws should be discarded at the chains beginning? Default is 10 - and this seems reasonable high (probably 5 will be enough as well), because starting point is the EAP.</p>
</td></tr>
<tr><td><code id="PV_+3A_mult">mult</code></td>
<td>
<p>Multiplication constant (default = 2). Use this parameter to vary the width of the proposal distribution - which is <code>N(theta_v,mult*SE_eap)</code> - when a MH-Algorithm is applied. So the constant quantifies the width in terms of multiples of the EAP standard error. 2 works fine with the default thinning. If the supplied value is large, thinning can take lower values without causing autocorrelation.</p>
</td></tr>
<tr><td><code id="PV_+3A_x">x</code></td>
<td>
<p>An object of class <code>pv</code> which is the result of using the <code>PV()</code> function</p>
</td></tr>
<tr><td><code id="PV_+3A_object">object</code></td>
<td>
<p>An object of class <code>pv</code> which is the result of using the <code>PV()</code> function</p>
</td></tr>
<tr><td><code id="PV_+3A_nrowmax">nrowmax</code></td>
<td>
<p>When printing the matrix of estimates - how many rows should be shown? Default = 15.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list which main element is <code>pvdraws</code>. This is a matrix of size number_of_persons x npv - so if 10 plausible values are requested for 100 persons, a 100x10 matrix is returned.
</p>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>References</h3>

<p>Mislevy, R. J. (1991). Randomization-based inference about latent variables from complex samples. Psychometrika, 56(2), 177-196.
</p>
<p>Von Davier, M., Gonzalez, E., &amp; Mislevy, R. (2009). What are plausible values and why are they useful. IERI monograph series, 2, 9-36.
</p>
<p>Kruschke, J. (2010). Doing Bayesian data analysis: A tutorial introduction with R. Academic Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+PP_gpcm">PP_gpcm</a>, <a href="#topic+PP_4pl">PP_4pl</a>, <a href="#topic+JKpp">JKpp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# Plausible values #############################################################


### 4 PL model ######


### data creation ##########

set.seed(1522)
# intercepts
diffpar &lt;- seq(-3,3,length=12)
# slope parameters
sl     &lt;- round(runif(12,0.5,1.5),2)
la     &lt;- round(runif(12,0,0.25),2)
ua     &lt;- round(runif(12,0.8,1),2)

# response matrix
awm &lt;- matrix(sample(0:1,10*12,replace=TRUE),ncol=12)


# EAP estimation - 2pl model
res2pleap &lt;- PP_4pl(respm = awm,thres = diffpar, slopes = sl,type = "eap")

# draw 10 plausible values
res_pv  &lt;- PV(res2pleap)
summary(res_pv)

# draw 10 plausible values - use a metropolitan hastings algorithm
res_pv2  &lt;- PV(res2pleap,approx = FALSE)
summary(res_pv2)

# ------ check the PVs


# -- autocorrelation?
autocor &lt;- function(acv)
  {
  cor(acv[-1],acv[-length(acv)]) 
  }


res_pvac  &lt;- PV(res2pleap,approx = FALSE,npv = 200)

# independent draws - so there cannot be any systematic autocorrelation when
# approx = TRUE. So this acts as a kind of benchmark for the MH-Alg.
res_pvac2  &lt;- PV(res2pleap,approx = TRUE,npv = 200)

apply(res_pvac$pvdraws,1,autocor)
apply(res_pvac2$pvdraws,1,autocor)

# -- autocorrelation distr?


apply(res_pvac$pvdraws,1,quantile)
apply(res_pvac2$pvdraws,1, quantile)




### GPCM model ######


# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)
awmatrix &lt;- matrix(c(1,0,2,0,1,1,1,0,0,1
                     ,2,0,0,0,0,0,0,0,0,1,1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)


# EAP estimation
resgpcmeap &lt;- PP_gpcm(respm = awmatrix,thres = THRES, slopes = sl,type = "eap")


res_gpcmpv  &lt;- PV(resgpcmeap,approx = FALSE,npv = 20)




### GPCM and 4PL model ######


# some threshold parameters
THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)

THRESx &lt;- THRES
THRESx[2,1:3] &lt;- NA

# for the 4PL item the estimated parameters are submitted, 
# for the GPCM items the lower asymptote = 0 
# and the upper asymptote = 1.
la     &lt;- c(0.02,0.1,0,0,0,0)
ua     &lt;- c(0.97,0.91,1,1,1,1)

awmatrix &lt;- matrix(c(1,0,1,0,1,1,1,0,0,1
                     ,2,0,0,0,0,0,0,0,0,1
                     ,1,2,2,1,1,1,1,0,0,1),byrow=TRUE,nrow=5)

model2est &lt;- findmodel(THRESx)


# EAP estimation
respcmeap1 &lt;- PPall(respm = awmatrix,thres = THRESx, 
                    slopes = sl,lowerA = la, upperA=ua, type = "eap",
                    model2est=model2est)


res_mixedpv_1  &lt;- PV(respcmeap1,approx = FALSE,npv = 200)

# rowMeans of plausible values should approximate the EAPs
rowMeans(res_mixedpv_1$pvdraws)
# EAPs
respcmeap1

# show the quantiles of the empirical distribution
apply(res_mixedpv_1$pvdraws,1,quantile)

</code></pre>

<hr>
<h2 id='sim_4pl'>Simulate data for 1/2/3/4-pl model</h2><span id='topic+sim_4pl'></span>

<h3>Description</h3>

<p>This function returns a dichotomous matrix of simulated responses under given item and person parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_4pl(beta, alpha, lowerA, upperA, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_4pl_+3A_beta">beta</code></td>
<td>
<p>A numeric vector which contains the difficulty parameters for each item.</p>
</td></tr>
<tr><td><code id="sim_4pl_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector, which contains the slope parameters for each item.</p>
</td></tr>
<tr><td><code id="sim_4pl_+3A_lowera">lowerA</code></td>
<td>
<p>A numeric vector, which contains the lower asymptote parameters (kind of guessing parameter) for each item.</p>
</td></tr>
<tr><td><code id="sim_4pl_+3A_uppera">upperA</code></td>
<td>
<p>numeric vector, which contains the upper asymptote parameters for each item.</p>
</td></tr>
<tr><td><code id="sim_4pl_+3A_theta">theta</code></td>
<td>
<p>A numeric vector which contains person parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel Reif
</p>


<h3>See Also</h3>

<p><a href="#topic+sim_gpcm">sim_gpcm</a>, <a href="#topic+PP_4pl">PP_4pl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# simulate 4PL ###############################################

set.seed(1700)
 
# simulate 1-PL model ----------

thetas &lt;- c(0.231,-1.313,1.772,1.601,1.733,-2.001,0.443,3.111,-4.156)
sl &lt;- c(1,1.1,0.9,0.89,1.5,1.1,1)
la &lt;- c(0,0,0.2,0.15,0.04,0,0.21)
ua &lt;- c(0.9,0.98,0.97,1,1,1,0.97)

simdat1pl &lt;- sim_4pl(beta=seq(-4,4,length.out=7), alpha=rep(1,7),
                  lowerA=rep(0,7), upperA=rep(1,7), theta=thetas)


head(simdat1pl)


# simulate 2-PL model ----------

simdat2pl &lt;- sim_4pl(beta=seq(-4,4,length.out=7), alpha=sl,
                  lowerA=rep(0,7), upperA=rep(1,7), theta=thetas)


head(simdat2pl)


# simulate 3-PL model ----------

simdat3pl &lt;- sim_4pl(beta=seq(-4,4,length.out=7), alpha=sl,
                     lowerA=la, upperA=rep(1,7), theta=thetas)


head(simdat3pl)


# simulate 4-PL model ----------

simdat4pl &lt;- sim_4pl(beta=seq(-4,4,length.out=7), alpha=sl,
                     lowerA=la, upperA=ua, theta=thetas)


head(simdat4pl)

</code></pre>

<hr>
<h2 id='sim_gpcm'>Simulate data for the gpcm model</h2><span id='topic+sim_gpcm'></span>

<h3>Description</h3>

<p>This function returns an integer matrix of simulated responses under given item and person parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_gpcm(thres, alpha, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_gpcm_+3A_thres">thres</code></td>
<td>
<p>An numeric matrix which contains threshold parameters for each item. The first row must contain zeroes only!</p>
</td></tr>
<tr><td><code id="sim_gpcm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector, which contains the slope parameters - one parameter per item is expected.</p>
</td></tr>
<tr><td><code id="sim_gpcm_+3A_theta">theta</code></td>
<td>
<p>A numeric vector which contains person parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+sim_4pl">sim_4pl</a>, <a href="#topic+PP_gpcm">PP_gpcm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################# simulate GPCM ###############################################

set.seed(1750)

THRES  &lt;- matrix(c(-2,-1.23,1.11,3.48,1
                   ,2,-1,-0.2,0.5,1.3,-0.8,1.5),nrow=2)
# slopes
sl     &lt;- c(0.5,1,1.5,1.1,1,0.98)

THRESx &lt;- rbind(0,THRES)

THETA  &lt;- rnorm(100)

simdat_gpcm &lt;- sim_gpcm(thres = THRESx,alpha = sl,theta = THETA)

head(simdat_gpcm)


### simulate with a different number of categories


THRES1 &lt;- rbind(THRESx,c(NA,NA,NA,NA,1.7,1))
THRES1 # last 2 items have +1 category

simdat_gpcm2 &lt;- sim_gpcm(thres = THRES1,alpha = sl,theta = THETA)

head(simdat_gpcm2)

# check the maximum category
apply(simdat_gpcm2,2,max)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
