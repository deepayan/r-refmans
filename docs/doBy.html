<!DOCTYPE html><html lang="en"><head><title>Help for package doBy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {doBy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.rhsf2list'><p>Convert right hand sided formula to a list</p></a></li>
<li><a href='#beets'><p>beets data</p></a></li>
<li><a href='#binomial_to_bernoulli_data'><p>Convert binomial data to bernoulli data</p></a></li>
<li><a href='#bquote_fun_list'><p>Backquote a list of functions</p></a></li>
<li><a href='#by_scale'><p>Scale a dataframe or matrix</p></a></li>
<li><a href='#by-lapply'><p>Formula based version of lapply and sapply</p></a></li>
<li><a href='#by-lmby'><p>List of lm objects with a common model</p></a></li>
<li><a href='#by-order'><p>Ordering (sorting) rows of a data frame</p></a></li>
<li><a href='#by-sample'><p>Sampling from a data frame</p></a></li>
<li><a href='#by-split'><p>Split a data frame</p></a></li>
<li><a href='#by-subset'><p>Finds subsets of a dataframe which is split by variables in</p>
a formula.</a></li>
<li><a href='#by-summary'><p>Function to calculate groupwise summary statistics</p></a></li>
<li><a href='#by-transform'><p>Function to make groupwise transformations</p></a></li>
<li><a href='#carcass'><p>Lean meat contents of 344 pig carcasses</p></a></li>
<li><a href='#codstom'><p>Diet of Atlantic cod in the Gulf of St. Lawrence (Canada)</p></a></li>
<li><a href='#crickets'><p>crickets data</p></a></li>
<li><a href='#crime_rate'><p>crimeRate</p></a></li>
<li><a href='#crimeRate'><p>crimeRate</p></a></li>
<li><a href='#cropyield'><p>Yield from Danish agricultural production of grain and root crop.</p></a></li>
<li><a href='#cv_glm_fitlist'><p>Cross-validation for list of glm objects</p></a></li>
<li><a href='#data_breastcancer'><p>Gene expression signatures for p53 mutation status in 250 breast cancer</p>
samples</a></li>
<li><a href='#data_budworm'><p>Budworm data</p></a></li>
<li><a href='#data_cad'><p>Coronary artery disease data</p></a></li>
<li><a href='#data_mathmark'><p>Mathematics marks for students</p></a></li>
<li><a href='#data_personality'><p>Personality traits</p></a></li>
<li><a href='#descStat'><p>Computing simple descriptive statistics of a numeric vector.</p></a></li>
<li><a href='#dietox'><p>Growth curves of pigs in a 3x3 factorial experiment</p></a></li>
<li><a href='#esticon'><p>Contrasts for lm, glm, lme, and geeglm objects</p></a></li>
<li><a href='#expr_to_fun'><p>Convert expression into function object.</p></a></li>
<li><a href='#fatacid'><p>Fish oil in pig food</p></a></li>
<li><a href='#fev'><p>Forced expiratory volume in children</p></a></li>
<li><a href='#firstlastobs'><p>Locate the index of the first/last unique value</p></a></li>
<li><a href='#formula_ops'><p>Formula operations and coercion.</p></a></li>
<li><a href='#generate_data_list'><p>Generate data list</p></a></li>
<li><a href='#get_formulas'><p>Get formulas from model_stability_glm_class object</p></a></li>
<li><a href='#haldCement'><p>Heat development in cement under hardening.</p></a></li>
<li><a href='#income'><p>income data</p></a></li>
<li><a href='#interaction-plot'><p>Two-way interaction plot</p></a></li>
<li><a href='#internal'><p>Internal functions for the doBy package</p></a></li>
<li><a href='#is_estimable'><p>Determines if contrasts are estimable.</p></a></li>
<li><a href='#linest'><p>Compute linear estimates</p></a></li>
<li><a href='#linest-get'><p>Auxillary functions for computing lsmeans, contrasts etc</p></a></li>
<li><a href='#linest-matrix'><p>Linear estimates matrix</p></a></li>
<li><a href='#ls-means'><p>Compute  LS-means (aka population means or</p>
marginal means)</a></li>
<li><a href='#mb_summary'><p>Fast summary of microbenchmark object</p></a></li>
<li><a href='#milkman'><p>Milk yield data for manually milked cows.</p></a></li>
<li><a href='#model_stability_glm'><p>Model stability for glm objects</p></a></li>
<li><a href='#nir_milk'><p>nir_milk</p></a></li>
<li><a href='#NIRmilk'><p>NIRmilk</p></a></li>
<li><a href='#parseGroupFormula'><p>Extract components from a formula with &quot;conditioning bar&quot;</p></a></li>
<li><a href='#plot_lm'><p>Plot linear model object</p></a></li>
<li><a href='#potatoes'><p>Weight and size of 20 potatoes</p></a></li>
<li><a href='#prostate'><p>Prostate Tumor Gene Expression Dataset</p></a></li>
<li><a href='#recodeVar'><p>Recode values of a vector</p></a></li>
<li><a href='#recover_pca_data'><p>Recover data from principal component analysis</p></a></li>
<li><a href='#renameCol'><p>Rename columns in a matrix or a dataframe.</p></a></li>
<li><a href='#response_plot'><p>Plot the response variable against the predictor variables.</p></a></li>
<li><a href='#scale_df'><p>Scaling numerical values</p></a></li>
<li><a href='#section_fun'><p>Section a function and set default values in function</p></a></li>
<li><a href='#set_list_set_matrix'><p>Matrix representatation of list of vectors and vice versa</p></a></li>
<li><a href='#split_byrow_bycol'><p>Split matrix or dataframe into list</p></a></li>
<li><a href='#sub_seq'><p>Find sub-sequences of identical elements in a vector.</p></a></li>
<li><a href='#taylor'><p>Taylor expansion (one dimension)</p></a></li>
<li><a href='#tidy-esticon'><p>Tidy an esticon object</p></a></li>
<li><a href='#tidy-linest'><p>Tidy a linest object</p></a></li>
<li><a href='#timeSinceEvent'><p>Calculate &quot;time since event&quot; in a vector.</p></a></li>
<li><a href='#truncate0'><p>Truncate values in a matrix / vector to zero if they are below a certain threshold.</p></a></li>
<li><a href='#which.maxn'><p>Where are the n largest or n smallest elements in a numeric vector ?</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>4.6.25</td>
</tr>
<tr>
<td>Title:</td>
<td>Groupwise Statistics, LSmeans, Linear Estimates, Utilities</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utility package containing:
    1) Facilities for working with grouped data: 'do' something to data
    stratified 'by' some variables.
    2) LSmeans (least-squares means), general linear estimates.
    3) Restrict functions to a smaller domain.
    4) Miscellaneous other utilities.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hojsgaard/doBy">https://github.com/hojsgaard/doBy</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, broom, cowplot, Deriv, dplyr, ggplot2, MASS, Matrix,
modelr, microbenchmark, rlang, tibble, tidyr,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geepack, knitr, lme4, markdown, multcomp, pbkrtest (&ge;
0.5.2), survival, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-30 07:41:25 UTC; sorenh</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrich Halekoh [aut, cph],
  Søren Højsgaard [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-30 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.rhsf2list'>Convert right hand sided formula to a list</h2><span id='topic+.rhsf2list'></span>

<h3>Description</h3>

<p>Convert right hand sided formula to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rhsf2list(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rhsf2list_+3A_f">f</code></td>
<td>
<p>A right hand sided formula</p>
</td></tr>
</table>

<hr>
<h2 id='beets'>beets data</h2><span id='topic+beets'></span>

<h3>Description</h3>

<p>Yield and sugar percentage in sugar beets from a split plot
experiment.  Data is obtained from a split plot experiment. There are 3
blocks and in each of these the harvest time defines the &quot;whole plot&quot; and
the sowing time defines the &quot;split plot&quot;. Each plot was 25 square meters and
the yield is recorded in kg. See 'details' for the experimental layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beets
</code></pre>


<h3>Format</h3>

<p>The format is: chr &quot;beets&quot;
</p>


<h3>Details</h3>

<pre>  
Experimental plan
Sowing times            1        4. april
                        2       12. april
                        3       21. april
                        4       29. april
                        5       18. may
Harvest times           1        2. october
                        2       21. october
Plot allocation:
               Block 1     Block 2     Block 3
            +-----------|-----------|-----------+
      Plot  | 1 1 1 1 1 | 2 2 2 2 2 | 1 1 1 1 1 | Harvest time
       1-15 | 3 4 5 2 1 | 3 2 4 5 1 | 5 2 3 4 1 | Sowing time
            |-----------|-----------|-----------|
      Plot  | 2 2 2 2 2 | 1 1 1 1 1 | 2 2 2 2 2 | Harvest time
      16-30 | 2 1 5 4 3 | 4 1 3 2 5 | 1 4 3 2 5 | Sowing time
            +-----------|-----------|-----------+  
</pre>


<h3>References</h3>

<p>Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
Models - The R Package pbkrtest., Journal of Statistical Software,
58(10), 1-30., <a href="https://www.jstatsoft.org/v59/i09/">https://www.jstatsoft.org/v59/i09/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beets)

beets$bh &lt;- with(beets, interaction(block, harvest))
summary(aov(yield ~ block + sow + harvest + Error(bh), beets))
summary(aov(sugpct ~ block + sow + harvest + Error(bh), beets))

</code></pre>

<hr>
<h2 id='binomial_to_bernoulli_data'>Convert binomial data to bernoulli data</h2><span id='topic+binomial_to_bernoulli_data'></span>

<h3>Description</h3>

<p>Convert binomial data to bernoulli data by expanding dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_to_bernoulli_data(
  data.,
  y,
  size,
  type = c("rest", "total"),
  response_name = "response",
  rest_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomial_to_bernoulli_data_+3A_data.">data.</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="binomial_to_bernoulli_data_+3A_y">y</code></td>
<td>
<p>Column with 'successes' in binomial distribution <code>y~bin(size, p)</code></p>
</td></tr>
<tr><td><code id="binomial_to_bernoulli_data_+3A_size">size</code></td>
<td>
<p>Column with 'failures', i.e. size-y or 'total', i.e. size.</p>
</td></tr>
<tr><td><code id="binomial_to_bernoulli_data_+3A_type">type</code></td>
<td>
<p>Whether <code>size</code> is rest (i.e. 'failures') or 'total'</p>
</td></tr>
<tr><td><code id="binomial_to_bernoulli_data_+3A_response_name">response_name</code></td>
<td>
<p>Name of response variable in output dataset.</p>
</td></tr>
<tr><td><code id="binomial_to_bernoulli_data_+3A_rest_name">rest_name</code></td>
<td>
<p>Name of 'failures' in column <code>response_name</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- budworm
dat &lt;- dat[dat$dose %in% c(1,2), ]
dat$ntotal &lt;- 5
dat
dat.a &lt;- dat |&gt;
  binomial_to_bernoulli_data(ndead, ntotal, type="total")
dat.b &lt;- dat |&gt;
  dplyr::mutate(nalive=ntotal-ndead) |&gt; dplyr::select(-ntotal) |&gt;
  binomial_to_bernoulli_data(ndead, nalive, type="rest")

m0 &lt;- glm(cbind(ndead, ntotal-ndead) ~ dose + sex, data=dat, family=binomial())
m1 &lt;- glm(ndead / ntotal ~ dose + sex, data=dat, weight=ntotal, family=binomial())
ma &lt;- glm(response ~ dose + sex, data=dat.a, family=binomial())
mb &lt;- glm(response ~ dose + sex, data=dat.b, family=binomial())

dat.a$response
dat.b$response ## Not same and therefore the following do not match

all.equal(coef(m0), coef(ma))
all.equal(coef(m0), coef(mb))
all.equal(coef(m1), coef(ma))
all.equal(coef(m1), coef(mb))
</code></pre>

<hr>
<h2 id='bquote_fun_list'>Backquote a list of functions</h2><span id='topic+bquote_fun_list'></span>

<h3>Description</h3>

<p>Backquote a list of functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bquote_fun_list(fun_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bquote_fun_list_+3A_fun_list">fun_list</code></td>
<td>
<p>List of functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+bquote">base::bquote()</a></code>, <code><a href="#topic+set_default">set_default()</a></code>, <code><a href="#topic+section_fun">section_fun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Evaluate a list of functions
f1 &lt;- function(x){x + 1}
f2 &lt;- function(x){x + 8}

f1_ &lt;- set_default(f1, list(x=10))
f2_ &lt;- set_default(f2, list(x=10))

f1_(); f2_()

fn_list  &lt;- list(f1_, f2_)
fn_list_ &lt;- bquote_fun_list(fn_list)

eval(fn_list[[1]])     ## No
sapply(fn_list, eval)  ## No

eval(fn_list_[[1]])    ## Yes
sapply(fn_list_, eval) ## Yes

</code></pre>

<hr>
<h2 id='by_scale'>Scale a dataframe or matrix</h2><span id='topic+by_scale'></span><span id='topic+scaleBy'></span><span id='topic+scale_by'></span>

<h3>Description</h3>

<p>Split a dataframe into a list according to the levels
of variables in the dataframe and scale the numeric variables
in each dataframe in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleBy(formula, data = parent.frame(), center = TRUE, scale = TRUE)

scale_by(data, formula, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by_scale_+3A_formula">formula</code></td>
<td>
<p>Variables to split data frame by, as <code>as.quoted</code>
variables, a formula or character vector.</p>
</td></tr>
<tr><td><code id="by_scale_+3A_data">data</code></td>
<td>
<p>A dataframe or matrix</p>
</td></tr>
<tr><td><code id="by_scale_+3A_center">center</code></td>
<td>
<p>Logical, should data be centered.</p>
</td></tr>
<tr><td><code id="by_scale_+3A_scale">scale</code></td>
<td>
<p>Logical, should data be scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of same class as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderBy">orderBy</a></code>, <code><a href="#topic+order_by">order_by</a></code>,
<code><a href="#topic+summaryBy">summaryBy</a></code>, <code><a href="#topic+summary_by">summary_by</a></code>,
<code><a href="#topic+transformBy">transformBy</a></code>, <code><a href="#topic+transform_by">transform_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scaleBy(~Species, data=iris, center=TRUE, scale=FALSE)
scaleBy(~1, data=iris, center=TRUE, scale=FALSE)

scale_by(iris, ~Species)
scale_by(iris, ~1)

## Not combine list of dataframes to one dataframe e.g. as:
a &lt;- scale_by(iris, ~Species)
d &lt;- do.call(rbind, a)
</code></pre>

<hr>
<h2 id='by-lapply'>Formula based version of lapply and sapply</h2><span id='topic+by-lapply'></span><span id='topic+lapply_by'></span><span id='topic+lapplyBy'></span><span id='topic+sapply_by'></span><span id='topic+sapplyBy'></span>

<h3>Description</h3>

<p>This function is a wrapper for calling lapply on the
list resulting from first calling splitBy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapply_by(data, formula, FUN, ...)

lapplyBy(formula, data = parent.frame(), FUN, ...)

sapply_by(data, formula, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)

sapplyBy(
  formula,
  data = parent.frame(),
  FUN,
  ...,
  simplify = TRUE,
  USE.NAMES = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-lapply_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="by-lapply_+3A_formula">formula</code></td>
<td>
<p>A formula describing how data should be split.</p>
</td></tr>
<tr><td><code id="by-lapply_+3A_fun">FUN</code></td>
<td>
<p>A function to be applied to each element in the split
list, see 'Examples' below.</p>
</td></tr>
<tr><td><code id="by-lapply_+3A_...">...</code></td>
<td>
<p>optional arguments to FUN.</p>
</td></tr>
<tr><td><code id="by-lapply_+3A_simplify">simplify</code></td>
<td>
<p>Same as for <code>sapply</code></p>
</td></tr>
<tr><td><code id="by-lapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>Same as for <code>sapply</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitBy">splitBy</a></code>, <code><a href="#topic+split_by">split_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- function(x) range(x$uptake)
lapplyBy(~Treatment + Type, data=CO2, FUN=fun)
sapplyBy(~Treatment + Type, data=CO2, FUN=fun)

# Same as
lapply(splitBy(~Treatment + Type, data=CO2), FUN=fun)
</code></pre>

<hr>
<h2 id='by-lmby'>List of lm objects with a common model</h2><span id='topic+by-lmby'></span><span id='topic+lm_by'></span><span id='topic+lmBy'></span><span id='topic+coef.lmBy'></span><span id='topic+coef.summary_lmBy'></span><span id='topic+summary.lmBy'></span><span id='topic+fitted.lmBy'></span><span id='topic+residuals.lmBy'></span><span id='topic+getBy'></span>

<h3>Description</h3>

<p>The data is split into strata according to the levels
of the grouping factors and individual lm fits are obtained for
each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_by(data, formula, id = NULL, ...)

lmBy(formula, data, id = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-lmby_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="by-lmby_+3A_formula">formula</code></td>
<td>
<p>A linear model formula object of the form
<code>y ~ x1 + ... + xn | g1 + ... + gm</code>.  In the formula object, <code>y</code> represents
the response, <code style="white-space: pre;">&#8288;x1, ..., xn&#8288;</code> the covariates, and the grouping
factors specifying the partitioning of the data according to
which different lm fits should be performed.</p>
</td></tr>
<tr><td><code id="by-lmby_+3A_id">id</code></td>
<td>
<p>A formula describing variables from data which are to be
available also in the output.</p>
</td></tr>
<tr><td><code id="by-lmby_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>lm()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lm fits.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bb &lt;- lmBy(1 / uptake ~ log(conc) | Treatment, data=CO2)
coef(bb)

fitted(bb)
residuals(bb)

summary(bb)
coef(summary(bb))
coef(summary(bb), simplify=TRUE)
</code></pre>

<hr>
<h2 id='by-order'>Ordering (sorting) rows of a data frame</h2><span id='topic+by-order'></span><span id='topic+order_by'></span><span id='topic+orderBy'></span>

<h3>Description</h3>

<p>Ordering (sorting) rows of a data frame by the certain
variables in the data frame. This function is essentially a
wrapper for the <code>order()</code> function - the important
difference being that variables to order by can be given by a
model formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_by(data, formula)

orderBy(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-order_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="by-order_+3A_formula">formula</code></td>
<td>
<p>The right hand side of a formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sign of the terms in the formula determines whether
sorting should be ascending or decreasing; see examples below
</p>


<h3>Value</h3>

<p>The ordered data frame
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a> and Kevin
Wright
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transformBy">transformBy</a></code>, <code><a href="#topic+transform_by">transform_by</a></code>, <code><a href="#topic+splitBy">splitBy</a></code>, <code><a href="#topic+split_by">split_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
orderBy(~ conc + Treatment, CO2)
## Sort decreasingly by conc
orderBy(~ - conc + Treatment, CO2)
</code></pre>

<hr>
<h2 id='by-sample'>Sampling from a data frame</h2><span id='topic+by-sample'></span><span id='topic+sample_by'></span><span id='topic+sampleBy'></span>

<h3>Description</h3>

<p>A data frame is split according to some variables in a
formula, and a sample of a certain fraction of each is drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_by(data, formula, frac = 0.1, replace = FALSE, systematic = FALSE)

sampleBy(
  formula,
  frac = 0.1,
  replace = FALSE,
  data = parent.frame(),
  systematic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-sample_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="by-sample_+3A_formula">formula</code></td>
<td>
<p>A formula defining the grouping of the data frame.</p>
</td></tr>
<tr><td><code id="by-sample_+3A_frac">frac</code></td>
<td>
<p>The part of data to be sampled.</p>
</td></tr>
<tr><td><code id="by-sample_+3A_replace">replace</code></td>
<td>
<p>Is the sampling with replacement.</p>
</td></tr>
<tr><td><code id="by-sample_+3A_systematic">systematic</code></td>
<td>
<p>Should sampling be systematic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If systematic=FALSE (default) then frac gives the fraction
of data sampled. If systematic=TRUE and frac=.2 then every 1/.2
i.e. every 5th observation is taken out.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderBy">orderBy</a></code>, <code><a href="#topic+order_by">order_by</a></code>,
<code><a href="#topic+splitBy">splitBy</a></code>, <code><a href="#topic+split_by">split_by</a></code>,
<code><a href="#topic+summaryBy">summaryBy</a></code>, <code><a href="#topic+summary_by">summary_by</a></code>,
<code><a href="#topic+transformBy">transformBy</a></code>, <code><a href="#topic+transform_by">transform_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dietox)
sampleBy(formula = ~ Evit + Cu, frac=.1, data = dietox)
</code></pre>

<hr>
<h2 id='by-split'>Split a data frame</h2><span id='topic+by-split'></span><span id='topic+split_by'></span><span id='topic+splitBy'></span><span id='topic+head.splitByData'></span><span id='topic+tail.splitByData'></span>

<h3>Description</h3>

<p>Split a dataframe according to the levels of variables
in the dataframe. The variables to split by can be given as a
formula or as a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by(data, formula, drop = TRUE)

splitBy(formula, data = parent.frame(), drop = TRUE)

## S3 method for class 'splitByData'
head(x, n = 6L, ...)

## S3 method for class 'splitByData'
tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-split_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="by-split_+3A_formula">formula</code></td>
<td>
<p>Variables to split data frame by, as <code>as.quoted</code>
variables, a formula or character vector.</p>
</td></tr>
<tr><td><code id="by-split_+3A_drop">drop</code></td>
<td>
<p>Logical indicating if levels that do not occur should
be dropped. Deprecated; levels that do not occur are ignored.</p>
</td></tr>
<tr><td><code id="by-split_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="by-split_+3A_n">n</code></td>
<td>
<p>A single integer.  If positive or zero, size for the
resulting object: number of elements for a vector (including
lists), rows for a matrix or data frame or lines for a
function.  If negative, all but the &quot;n&quot; last/first number of
elements of &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="by-split_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderBy">orderBy</a></code>, <code><a href="#topic+order_by">order_by</a></code>,
<code><a href="#topic+summaryBy">summaryBy</a></code>, <code><a href="#topic+summary_by">summary_by</a></code>,
<code><a href="#topic+transformBy">transformBy</a></code>, <code><a href="#topic+transform_by">transform_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox, package="doBy")
splitBy(formula = ~Evit + Cu, data = dietox)
splitBy(formula = c("Evit", "Cu"), data = dietox)

splitBy(~Treatment + Type, data=CO2)
splitBy(c("Treatment", "Type"), data=CO2)

x &lt;- splitBy(~Treatment, data=CO2)
head(x)
tail(x)
</code></pre>

<hr>
<h2 id='by-subset'>Finds subsets of a dataframe which is split by variables in
a formula.</h2><span id='topic+by-subset'></span><span id='topic+subset_by'></span><span id='topic+subsetBy'></span>

<h3>Description</h3>

<p>A data frame is split by a formula into groups. Then
subsets are found within each group, and the result is
collected into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_by(data, formula, subset, select, drop = FALSE, join = TRUE, ...)

subsetBy(
  formula,
  subset,
  data = parent.frame(),
  select,
  drop = FALSE,
  join = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-subset_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="by-subset_+3A_formula">formula</code></td>
<td>
<p>A right hand sided formula or a character vector of
variables to split by.</p>
</td></tr>
<tr><td><code id="by-subset_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to
keep: missing values are taken as false.</p>
</td></tr>
<tr><td><code id="by-subset_+3A_select">select</code></td>
<td>
<p>expression, indicating columns to select from a data
frame.</p>
</td></tr>
<tr><td><code id="by-subset_+3A_drop">drop</code></td>
<td>
<p>passed on to <code>[</code> indexing operator.</p>
</td></tr>
<tr><td><code id="by-subset_+3A_join">join</code></td>
<td>
<p>If FALSE the result is a list of data frames (as
defined by 'formula'); if TRUE one data frame is returned.</p>
</td></tr>
<tr><td><code id="by-subset_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitBy">splitBy</a></code>, <code><a href="#topic+split_by">split_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox)
subsetBy(~Evit, Weight &lt; mean(Weight), data=dietox)
</code></pre>

<hr>
<h2 id='by-summary'>Function to calculate groupwise summary statistics</h2><span id='topic+by-summary'></span><span id='topic+summary_by'></span><span id='topic+summaryBy'></span>

<h3>Description</h3>

<p>Function to calculate groupwise summary statistics,
much like the summary procedure of SAS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_by(
  data,
  formula,
  id = NULL,
  FUN = mean,
  keep.names = FALSE,
  p2d = FALSE,
  order = TRUE,
  full.dimension = FALSE,
  var.names = NULL,
  fun.names = NULL,
  ...
)

summaryBy(
  formula,
  data = parent.frame(),
  id = NULL,
  FUN = mean,
  keep.names = FALSE,
  p2d = FALSE,
  order = TRUE,
  full.dimension = FALSE,
  var.names = NULL,
  fun.names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-summary_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_formula">formula</code></td>
<td>
<p>A formula object, see examples below.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_id">id</code></td>
<td>
<p>A formula specifying variables which data are not grouped by but
which should appear in the output. See examples below.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_fun">FUN</code></td>
<td>
<p>A list of functions to be applied, see examples below.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_keep.names">keep.names</code></td>
<td>
<p>If TRUE and if there is only ONE function in FUN, then the
variables in the output will have the same name as the variables in the
input, see 'examples'.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_p2d">p2d</code></td>
<td>
<p>Should parentheses in output variable names be replaced by dots?</p>
</td></tr>
<tr><td><code id="by-summary_+3A_order">order</code></td>
<td>
<p>Should the resulting dataframe be ordered according to the
variables on the right hand side of the formula? (using <a href="#topic+orderBy">orderBy</a></p>
</td></tr>
<tr><td><code id="by-summary_+3A_full.dimension">full.dimension</code></td>
<td>
<p>If TRUE then rows of summary statistics are repeated
such that the result will have the same number of rows as the input
dataset.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_var.names">var.names</code></td>
<td>
<p>Option for user to specify the names of the variables on the
left hand side.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_fun.names">fun.names</code></td>
<td>
<p>Option for user to specify function names to apply to the
variables on the left hand side.</p>
</td></tr>
<tr><td><code id="by-summary_+3A_...">...</code></td>
<td>
<p>Additional arguments to FUN. This could for example be NA actions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extra arguments (...) are passed onto the functions in
FUN. Hence care must be taken that all functions in FUN accept
these arguments - OR one can explicitly write a functions which
get around this.  This can particularly be an issue in
connection with handling NAs. See examples below.  Some code
for this function has been suggested by Jim
Robison-Cox. Thanks.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ave">ave</a></code>, <code><a href="#topic+descStat">descStat</a></code>, <code><a href="#topic+orderBy">orderBy</a></code>, <code><a href="#topic+order_by">order_by</a></code>,
<code><a href="#topic+splitBy">splitBy</a></code>, <code><a href="#topic+split_by">split_by</a></code>, <code><a href="#topic+transformBy">transformBy</a></code>, <code><a href="#topic+transform_by">transform_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox)
dietox12    &lt;- subset(dietox,Time==12)

fun &lt;- function(x){
  c(m=mean(x), v=var(x), n=length(x))
}

summaryBy(cbind(Weight, Feed) ~ Evit + Cu, data=dietox12,
          FUN=fun)

summaryBy(list(c("Weight", "Feed"), c("Evit", "Cu")), data=dietox12,
          FUN=fun)

## Computations on several variables is done using cbind( )
summaryBy(cbind(Weight, Feed) ~ Evit + Cu, data=subset(dietox, Time &gt; 1),
   FUN=fun)

## Calculations on transformed data is possible using cbind( ), but
# the transformed variables must be named

summaryBy(cbind(lw=log(Weight), Feed) ~ Evit + Cu, data=dietox12, FUN=mean)
 
## There are missing values in the 'airquality' data, so we remove these
## before calculating mean and variance with 'na.rm=TRUE'. However the
## length function does not accept any such argument. Hence we get
## around this by defining our own summary function in which length is
## not supplied with this argument while mean and var are:

sumfun &lt;- function(x, ...){
  c(m=mean(x, na.rm=TRUE, ...), v=var(x, na.rm=TRUE, ...), l=length(x))
}
summaryBy(cbind(Ozone, Solar.R) ~ Month, data=airquality, FUN=sumfun)
## Compare with
aggregate(cbind(Ozone, Solar.R) ~ Month, data=airquality, FUN=sumfun)

## Using '.' on the right hand side of a formula means to stratify by
## all variables not used elsewhere:

data(warpbreaks)
summaryBy(breaks ~ wool + tension, warpbreaks, FUN=mean)
summaryBy(breaks ~ ., warpbreaks, FUN=mean)
summaryBy(. ~ wool + tension, warpbreaks, FUN=mean)

summaryBy(. ~ wool + tension, warpbreaks, FUN=mean)

</code></pre>

<hr>
<h2 id='by-transform'>Function to make groupwise transformations</h2><span id='topic+by-transform'></span><span id='topic+transform_by'></span><span id='topic+transformBy'></span>

<h3>Description</h3>

<p>Function to make groupwise transformations of data by applying
the transform function to subsets of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_by(data, formula, ...)

transformBy(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by-transform_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="by-transform_+3A_formula">formula</code></td>
<td>
<p>A formula with only a right hand side, see examples below</p>
</td></tr>
<tr><td><code id="by-transform_+3A_...">...</code></td>
<td>
<p>Further arguments of the form tag=value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ... arguments are tagged vector expressions, which are evaluated
in the data frame data. The tags are matched against names(data), and for
those that match, the value replace the corresponding variable in data,
and the others are appended to data.
</p>


<h3>Value</h3>

<p>The modified value of the dataframe data.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderBy">orderBy</a></code>, <code><a href="#topic+order_by">order_by</a></code>, <code><a href="#topic+summaryBy">summaryBy</a></code>, <code><a href="#topic+summary_by">summary_by</a></code>,
<code><a href="#topic+splitBy">splitBy</a></code>, <code><a href="#topic+split_by">split_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(dietox)
transformBy(~Pig, data=dietox, minW=min(Weight), maxW=max(Weight), 
    gain=diff(range(Weight)))

</code></pre>

<hr>
<h2 id='carcass'>Lean meat contents of 344 pig carcasses</h2><span id='topic+carcass'></span><span id='topic+carcassall'></span>

<h3>Description</h3>

<p>Measurement of lean meat percentage of 344 pig carcasses together with
auxiliary information collected at three Danish slaughter houses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carcass
</code></pre>


<h3>Format</h3>

<p>carcassall: A data frame with 344 observations on the following 17
variables.
</p>

<dl>
<dt><code>weight</code></dt><dd><p>Weight of carcass</p>
</dd>
<dt><code>lengthc</code></dt><dd><p>Length of carcass from back toe to head (when
the carcass hangs in the back legs)</p>
</dd>
<dt><code>lengthf</code></dt><dd><p>Length of carcass from back toe to front leg
(that is, to the shoulder)</p>
</dd>
<dt><code>lengthp</code></dt><dd><p>Length of carcass from back toe to the pelvic bone</p>
</dd>
<dt><code>Fat02, Fat03, Fat11, Fat12, Fat13, Fat14, Fat16</code></dt><dd><p>Thickness of fat
layer at different locations on the back of the carcass (FatXX
refers to thickness at (or rather next to) rib no. XX. Notice that
02 is closest to the head</p>
</dd>
<dt><code>Meat11, Meat12, Meat13</code></dt><dd><p>Thickness of meat layer at different
locations on the back of the carcass, see description above</p>
</dd>
<dt><code>LeanMeat</code></dt><dd><p>Lean meat percentage determined by dissection</p>
</dd>
<dt><code>slhouse</code></dt><dd><p>Slaughter house; a factor with levels <code>slh1</code> and  <code>slh2</code>.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex of the pig; a factor with levels <code>castrate</code> and <code>female</code>.</p>
</dd>
<dt><code>size</code></dt><dd><p>Size of the carcass; a factor with levels <code>normal</code> and <code>large</code>.
Here, <code>normal</code> refers to carcass weight under 80 kg; <code>large</code> refers to carcass weights between 80 and 110 kg.</p>
</dd>
</dl>



<h3>Details</h3>

<p>: Notice that there were slaughtered large pigs only at one slaughter house.
</p>


<h3>Note</h3>

<p>carcass: Contains only the variables Fat11, Fat12, Fat13,
Meat11, Meat12, Meat13, LeanMeat
</p>


<h3>Source</h3>

<p>Busk, H., Olsen, E. V., Brøndum, J. (1999) Determination of
lean meat in pig carcasses with the Autofom classification
system, Meat Science, 52, 307-314
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carcass)
head(carcass)

</code></pre>

<hr>
<h2 id='codstom'>Diet of Atlantic cod in the Gulf of St. Lawrence (Canada)</h2><span id='topic+codstom'></span>

<h3>Description</h3>

<p>Stomach content data for Atlantic cod (<em>Gadus morhua</em>) in the Gulf of
St.Lawrence, Eastern Canada.  Note: many prey items were of no interest for
this analysis and were regrouped into the &quot;Other&quot; category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codstom
</code></pre>


<h3>Format</h3>

<p>A data frame with 10000 observations on the following 10 variables.
</p>

<dl>
<dt><code>region</code></dt><dd><p>a factor with levels <code>SGSL</code> <code>NGSL</code>
representing the southern and northern Gulf of St. Lawrence, respectively</p>
</dd>
<dt><code>ship.type</code></dt><dd><p>a factor with levels <code>2</code> <code>3</code> <code>31</code>
<code>34</code> <code>90</code> <code>99</code></p>
</dd>
<dt><code>ship.id</code></dt><dd><p>a factor with levels <code>11558</code> <code>11712</code>
<code>136148</code> <code>136885</code>
<code>136902</code> <code>137325</code> <code>151225</code> <code>151935</code> <code>99433</code></p>
</dd>
<dt><code>trip</code></dt><dd><p>a factor with levels <code>10</code> <code>11</code>
<code>12</code> <code>179</code> <code>1999</code>
<code>2</code> <code>2001</code> <code>20020808</code> <code>3</code> <code>4</code> <code>5</code>
<code>6</code> <code>7</code> <code>8</code>
<code>88</code> <code>9</code> <code>95</code></p>
</dd>
<dt><code>set</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fish.id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fish.length</code></dt><dd><p>a numeric vector, length in mm</p>
</dd>
<dt><code>prey.mass</code></dt><dd><p>a numeric vector, mass of item in stomach, in g</p>
</dd>
<dt><code>prey.type</code></dt><dd><p>a factor with levels <code>Ammodytes_sp</code>
<code>Argis_dent</code>
<code>Chion_opil</code> <code>Detritus</code> <code>Empty</code> <code>Eualus_fab</code>
<code>Eualus_mac</code> <code>Gadus_mor</code> <code>Hyas_aran</code>
<code>Hyas_coar</code>
<code>Lebbeus_gro</code> <code>Lebbeus_pol</code> <code>Leptocl_mac</code>
<code>Mallot_vil</code>
<code>Megan_norv</code> <code>Ophiuroidea</code> <code>Other</code> <code>Paguridae</code>
<code>Pandal_bor</code> <code>Pandal_mon</code> <code>Pasiph_mult</code>
<code>Sabin_sept</code>
<code>Sebastes_sp</code> <code>Them_abys</code> <code>Them_comp</code> <code>Them_lib</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Cod are collected either by contracted commerical fishing vessels
(<code>ship.type</code> 90 or 99) or by research vessels.  Commercial vessels are
identified by a unique <code>ship.id</code>.
</p>
<p>Either one research vessel or several commercial vessels conduct a survey
(<code>trip</code>), during which a trawl, gillnets or hooked lines are set
several times. Most trips are random stratified surveys (depth-based
stratification).
</p>
<p>Each trip takes place within one of the <code>region</code>s.  The <code>trip</code>
label is only guaranteed to be unique within a region and the <code>set</code>
label is only guaranteed to be unique within a <code>trip</code>.
</p>
<p>For each fish caught, the <code>fish.length</code> is recorded and the fish is
allocated a <code>fish.id</code>, but the <code>fish.id</code> is only guaranteed to be
unique within a <code>set</code>. A subset of the fish caught are selected for
stomach analysis (stratified random selection according to fish length; unit
of stratification is the set for research surveys, the combination ship.id
and stratum for surveys conducted by commercial vessels, although strata are
not shown in codstom).
</p>
<p>The basic experimental unit in this data set is a cod stomach (one stomach
per fish).  Each stomach is uniquely identified by a combination of
<code>region</code>, <code>ship.type</code>, <code>ship.id</code>, <code>trip</code>, <code>set</code>,
and <code>fish.id</code>.
</p>
<p>For each prey item found in a stomach, the species and mass of the prey item
are recorded, so there can be multiple observations per stomach.  There may
also be several prey items with the same <code>prey.type</code> in the one stomach
(for example many <code>prey.types</code> have been recoded <code>Other</code>, which
produced many instances of <code>Other</code> in the same stomach).
</p>
<p>If a stomach is empty, a single observation is recorded with
<code>prey.type</code> <code>Empty</code> and a <code>prey.mass</code> of zero.
</p>


<h3>Source</h3>

<p>Small subset from a larger dataset (more stomachs, more variables,
more <code>prey.types</code>) collected by D. Chabot and M. Hanson, Fisheries &amp;
Oceans Canada <a href="mailto:chabotd@dfo-mpo.gc.ca">chabotd@dfo-mpo.gc.ca</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(codstom)
str(codstom)
# removes multiple occurences of same prey.type in stomachs
codstom1 &lt;- summaryBy(prey.mass ~ 
                      region + ship.type + ship.id + trip + set + fish.id + prey.type,
                      data = codstom, 
                      FUN = sum) 

# keeps a single line per stomach with the total mass of stomach content
codstom2 &lt;- summaryBy(prey.mass ~ region + ship.type + ship.id + trip + set + fish.id,
                      data = codstom, 
                      FUN = sum) 

# mean prey mass per stomach for each trip
codstom3 &lt;- summaryBy(prey.mass.sum ~ region + ship.type + ship.id + trip,
                      data = codstom2, FUN = mean) 

## Not run:           
# wide version, one line per stomach, one column per prey type
library(reshape)
codstom4 &lt;- melt(codstom, id = c(1:7, 9))
codstom5 &lt;- cast(codstom4, 
                 region + ship.type + ship.id + trip + set + fish.id + fish.length ~ 
                 prey.type, sum)
k &lt;- length(names(codstom5))
prey_col &lt;- 8:k
out &lt;- codstom5[,prey_col]
out[is.na(out)] &lt;- 0
codstom5[,prey_col] &lt;- out
codstom5$total.content &lt;- rowSums(codstom5[, prey_col])

## End(Not run)

</code></pre>

<hr>
<h2 id='crickets'>crickets data</h2><span id='topic+crickets'></span>

<h3>Description</h3>

<p>Mating songs of male tree crickets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crickets
</code></pre>


<h3>Format</h3>

<p>This data frame contains:
</p>

<dl>
<dt>species:</dt><dd><p>Species, see details</p>
</dd>
<dt>temp:</dt><dd><p>temperature</p>
</dd>
<dt>pps:</dt><dd><p>pulse per second</p>
</dd>
</dl>



<h3>Details</h3>

<p>Walker (1962) studied the mating songs of male
tree crickets. Each wingstroke by a cricket produces a pulse of
song, and females may use the number of pulses per second to
identify males of the correct species. Walker (1962) wanted to
know whether the chirps of the crickets Oecanthus
exclamationis and Oecanthus niveus had different pulse
rates. See <a href="https://www.biostathandbook.com/">https://www.biostathandbook.com/</a> for
details.  He measured the pulse rate of the crickets (variable
<code>pps</code>) at a variety of temperatures (<code>temp</code>):
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
data(crickets)
coplot(pps ~ temp | species, data=crickets) 
</code></pre>

<hr>
<h2 id='crime_rate'>crimeRate</h2><span id='topic+crime_rate'></span>

<h3>Description</h3>

<p>Crime rates per 100,000 inhabitants in states of the USA for different crime
types in 1977.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crime_rate
</code></pre>


<h3>Format</h3>

<p>This data frame contains:
</p>

<dl>
<dt>murder:</dt><dd><p>crime of murder</p>
</dd>
<dt>rape:</dt><dd></dd>
<dt>robbery:</dt><dd></dd>
<dt>assault:</dt><dd></dd>
<dt>burglary:</dt><dd><p>residential theft</p>
</dd>
<dt>larceny:</dt><dd><p>unlawful taking of personal property (pocket picking)</p>
</dd>
<dt>autotheft:</dt><dd></dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>	
data(crime_rate)

</code></pre>

<hr>
<h2 id='crimeRate'>crimeRate</h2><span id='topic+crimeRate'></span>

<h3>Description</h3>

<p>Crime rates per 100,000 inhabitants in states of the USA for different crime
types in 1977.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crimeRate
</code></pre>


<h3>Format</h3>

<p>This data frame contains:
</p>

<dl>
<dt>state:</dt><dd><p>State of the USA</p>
</dd>
<dt>murder:</dt><dd><p>crime of murder</p>
</dd>
<dt>rape:</dt><dd></dd>
<dt>robbery:</dt><dd></dd>
<dt>assault:</dt><dd></dd>
<dt>burglary:</dt><dd><p>residential theft</p>
</dd>
<dt>larceny:</dt><dd><p>unlawful taking of personal property (pocket picking)</p>
</dd>
<dt>autotheft:</dt><dd></dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>	
data(crimeRate)

</code></pre>

<hr>
<h2 id='cropyield'>Yield from Danish agricultural production of grain and root crop.</h2><span id='topic+cropyield'></span>

<h3>Description</h3>

<p>Yield from Danish agricultural production of grain and root crop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cropyield
</code></pre>


<h3>Format</h3>

<p>A dataframe with 97 rows and 7 columns.
</p>

<dl>
<dt><code>year</code></dt><dd><p>From 1901 to 1997.</p>
</dd>
<dt><code>precip</code></dt><dd><p>Milimeter precipitation.</p>
</dd>
<dt><code>yield</code></dt><dd><p>Million feed units (see details).</p>
</dd>
<dt><code>area</code></dt><dd><p>Area in 1000 ha for grains and root crop.</p>
</dd>
<dt><code>fertil</code></dt><dd><p>1000 tons fertilizer.</p>
</dd>
<dt><code>avgtmp1</code></dt><dd><p>Average temperature April-June (3 months).</p>
</dd>
<dt><code>avgtmp2</code></dt><dd><p>Average temperature July-Octobre (4 months). </p>
</dd>
</dl>



<h3>Details</h3>

<p>A feed unit is the amount of energy in a kg of barley.
</p>


<h3>References</h3>

<p>Danmarks statistik (Statistics Denmark).
</p>

<hr>
<h2 id='cv_glm_fitlist'>Cross-validation for list of glm objects</h2><span id='topic+cv_glm_fitlist'></span>

<h3>Description</h3>

<p>Cross-validation for list of glm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_glm_fitlist(data., fit_list, K = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_glm_fitlist_+3A_data.">data.</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cv_glm_fitlist_+3A_fit_list">fit_list</code></td>
<td>
<p>A list of glm objects</p>
</td></tr>
<tr><td><code id="cv_glm_fitlist_+3A_k">K</code></td>
<td>
<p>Number of folds</p>
</td></tr>
</table>

<hr>
<h2 id='data_breastcancer'>Gene expression signatures for p53 mutation status in 250 breast cancer
samples</h2><span id='topic+data_breastcancer'></span><span id='topic+breastcancer'></span>

<h3>Description</h3>

<p>Perturbations of the p53 pathway are associated with more aggressive and
therapeutically refractory tumours. We preprocessed the data using Robust
Multichip Analysis (RMA). Dataset has been truncated to the 1000 most
informative genes (as selected by Wilcoxon test statistics) to simplify
computation. The genes have been standardized to have zero mean and unit
variance (i.e. z-scored).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breastcancer
</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on 1001 variables. The
first 1000 columns are numerical variables; the last column
(named <code>code</code>) is a factor with levels <code>case</code> and
<code>control</code>.
</p>


<h3>Details</h3>

<p>The factor <code>code</code> defines whether there was a mutation in the p53
sequence (code=case) or not (code=control).
</p>


<h3>Source</h3>

<p>Chris Holmes, <a href="mailto:c.holmes@stats.ox.ac.uk">c.holmes@stats.ox.ac.uk</a>
</p>


<h3>References</h3>

<p>Miller et al (2005, PubMed
ID:16141321)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(breastcancer)
bc &lt;- breastcancer
pairs(bc[,1:5], col=bc$code)

train &lt;- sample(1:nrow(bc), 50)
table(bc$code[train])
## Not run: 
library(MASS)
z &lt;- lda(code ~ ., data=bc, prior = c(1, 1) / 2, subset = train)
pc &lt;- predict(z, bc[-train, ])$class
pc
bc[-train, "code"]
table(pc, bc[-train, "code"])

## End(Not run)

</code></pre>

<hr>
<h2 id='data_budworm'>Budworm data</h2><span id='topic+data_budworm'></span><span id='topic+budworm'></span>

<h3>Description</h3>

<p>Experiment on the toxicity to the tobacco budworm
Heliothis virescens of doses of the pyrethroid
trans-cypermethrin to which the moths were beginning to show
resistance. Batches of 20 moths of each sex were exposed for
three days to the pyrethroid and the number in each batch that
were dead or knocked down was recorded. Data is reported in
Collett (1991, p. 75).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>budworm
</code></pre>


<h3>Format</h3>

<p>This data frame contains 12 rows and 4 columns:
</p>

<dl>
<dt>sex:</dt><dd><p>sex of the budworm.</p>
</dd>
<dt>dose:</dt><dd><p>dose of the insecticide trans-cypermethrin (in micro grams)</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>ndead:</dt><dd><p>budworms killed in a trial.</p>
</dd>
<dt>ntotal:</dt><dd><p>total number of budworms exposed per trial.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Collett, D. (1991) Modelling Binary Data, Chapman &amp; Hall, London,
Example 3.7
</p>


<h3>References</h3>

<p>Venables, W.N; Ripley, B.D.(1999) Modern Applied Statistics with
S-Plus, Heidelberg, Springer, 3rd edition, chapter 7.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(budworm)

## function to caclulate the empirical logits
empirical.logit&lt;- function(nevent,ntotal) {
   y &lt;- log((nevent + 0.5) / (ntotal - nevent + 0.5))
   y
}


# plot the empirical logits against log-dose

log.dose &lt;- log(budworm$dose)
emp.logit &lt;- empirical.logit(budworm$ndead, budworm$ntotal)
plot(log.dose, emp.logit, type='n', xlab='log-dose',ylab='emprirical logit')
title('budworm: emprirical logits of probability to die ')
male &lt;- budworm$sex=='male'
female &lt;- budworm$sex=='female'
lines(log.dose[male], emp.logit[male], type='b', lty=1, col=1)
lines(log.dose[female], emp.logit[female], type='b', lty=2, col=2)
legend(0.5, 2, legend=c('male', 'female'), lty=c(1,2), col=c(1,2))

## Not run: 
* SAS example;
data budworm;
infile 'budworm.txt' firstobs=2;
input sex dose ndead ntotal;
run;

## End(Not run)


</code></pre>

<hr>
<h2 id='data_cad'>Coronary artery disease data</h2><span id='topic+data_cad'></span><span id='topic+cad1'></span><span id='topic+cad2'></span>

<h3>Description</h3>

<p>A cross classified table with observational data from a Danish
heart clinic.  The response variable is CAD (coronary artery
disease, some times called heart attack).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cad1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 236 observations on the following 14 variables.
</p>

<dl>
<dt><code>Sex</code></dt><dd><p>Sex; a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt><code>AngPec</code></dt><dd><p>Angina pectoris (chest pain attacks); a
factor with levels <code>Atypical</code> <code>None</code> <code>Typical</code></p>
</dd>
<dt><code>AMI</code></dt><dd><p>Acute myocardic infarct; a factor with
levels <code>Definite</code> <code>NotCertain</code></p>
</dd>
<dt><code>QWave</code></dt><dd><p>A reading from an electrocardiogram; a
factor with levels <code>No</code> <code>Yes</code>; Yes means pathological and is a sign of previous myocardial infarction. </p>
</dd>
<dt><code>QWavecode</code></dt><dd><p>a factor with levels <code>Nonusable</code>
<code>Usable</code>. An assesment of whether QWave is reliable.</p>
</dd>
<dt><code>STcode</code></dt><dd><p>a factor with levels
<code>Nonusable</code> <code>Usable</code>. An assesment of whether STchange is reliable.</p>
</dd>
<dt><code>STchange</code></dt><dd><p>A reading from an electrocardiogram; a factor
with levels <code>No</code> <code>Yes</code>. An STchange indicates a blockage of the coronary artery.</p>
</dd>
<dt><code>SuffHeartF</code></dt><dd><p>Sufficient heart frequency; a factor with levels <code>No</code>, <code>Yes</code></p>
</dd>
<dt><code>Hypertrophi</code></dt><dd><p>a factor with levels <code>No</code>, <code>Yes</code>. Hypertrophy refers to an
increased size of the heart muscle due to exercise. </p>
</dd>
<dt><code>Hyperchol</code></dt><dd><p>a factor with levels <code>No</code> <code>Yes</code>. Hypercholesterolemia, also called high cholesterol,
is the presence of high levels of cholesterol in the blood.</p>
</dd>
<dt><code>Smoker</code></dt><dd><p>Is the patient a smoker; a factor with levels <code>No</code>, <code>Yes</code>.</p>
</dd>
<dt><code>Inherit</code></dt><dd><p>Hereditary predispositions for CAD; a factor with levels  <code>No</code>, <code>Yes</code>.</p>
</dd>
<dt><code>Heartfail</code></dt><dd><p>Previous heart failures; a factor with  levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>CAD</code></dt><dd><p>Coronary Artery Disease; a factor with levels
<code>No</code> <code>Yes</code></p>
</dd></dl>
<p>.  CAD refers to a reduction of blood flow
to the heart muscle (commonly known as a heart attack). The
diagnosis made from biopsies.
</p>



<h3>Details</h3>

<p>Notice that data are collected at a heart clinic, so data do not
represent the population, but are conditional on patients having
ended up at the clinic.
</p>

<ul>
<li><p> cad1: Complete dataset, 236 cases.
</p>
</li>
<li><p> cad2: Incomplete dataset, 67 cases. Information on (some of) the
variables 'Hyperchol', 'Smoker' and 'Inherit' is missing.
</p>
</li></ul>



<h3>References</h3>

<p>Hansen, J. F. (1980). The clinical diagnosis of
ischaemic heart disease due to coronary artery disease. Danish
Medical Bulletin
</p>
<p>Højsgaard, Søren and Thiesson, Bo (1995). BIFROST - Block recursive
models Induced From Relevant knowledge, Observations and
Statistical Techniques. Computational Statistics and Data Analysis,
vol. 19, p. 155-175
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cad1)
## maybe str(cad1) ; plot(cad1) ...

</code></pre>

<hr>
<h2 id='data_mathmark'>Mathematics marks for students</h2><span id='topic+data_mathmark'></span><span id='topic+mathmark'></span><span id='topic+math'></span>

<h3>Description</h3>

<p>The <code>mathmark</code> data frame has 88 rows and 5 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mathmark)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: mechanics, vectors,
algebra, analysis, statistics.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>David Edwards, An Introduction to Graphical Modelling, Second
Edition, Springer Verlag, 2000
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mathmark)

</code></pre>

<hr>
<h2 id='data_personality'>Personality traits</h2><span id='topic+data_personality'></span><span id='topic+personality'></span>

<h3>Description</h3>

<p>The <code>peronality</code> dataframe has 240 rows and 32 columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(personality)
</code></pre>


<h3>Format</h3>

<p>This dataframe has recordings on the following 32
variables: distant, talkatv, carelss, hardwrk, anxious,
agreebl, tense, kind, opposng, relaxed, disorgn, outgoin,
approvn, shy, discipl, harsh, persevr, friendl, worryin,
respnsi, contrar, sociabl, lazy, coopera, quiet, organiz,
criticl, lax, laidbck, withdrw, givinup, easygon
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Origin unclear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(personality)
str(personality)
</code></pre>

<hr>
<h2 id='descStat'>Computing simple descriptive statistics of a numeric vector.</h2><span id='topic+descStat'></span>

<h3>Description</h3>

<p>Computing simple descriptive statistics of a numeric
vector - not unlike what proc means of SAS does
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descStat(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="descStat_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="descStat_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with named elements.
</p>


<h3>Author(s)</h3>

<p>Gregor Gorjanc; <a href="mailto:gregor.gorjanc@bf.uni-lj.si">gregor.gorjanc@bf.uni-lj.si</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summaryBy">summaryBy</a></code>, <code><a href="#topic+summary_by">summary_by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 2, 3, 4, NA, NaN)
descStat(x)

</code></pre>

<hr>
<h2 id='dietox'>Growth curves of pigs in a 3x3 factorial experiment</h2><span id='topic+dietox'></span>

<h3>Description</h3>

<p>The <code>dietox</code> data frame has 861 rows and 7 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dietox
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Weight</dt><dd><p>Weight in Kg</p>
</dd>
<dt>Feed</dt><dd><p>Cumulated feed intake in Kg</p>
</dd>
<dt>Time</dt><dd><p>Time (in weeks) in the experiment</p>
</dd>
<dt>Pig</dt><dd><p>Factor; id of each pig</p>
</dd>
<dt>Evit</dt><dd><p>Factor; vitamin E dose; see 'details'.</p>
</dd>
<dt>Cu</dt><dd><p>Factor, copper dose; see 'details'</p>
</dd>
<dt>Start</dt><dd><p>Start weight in experiment, i.e. weight at week 1.</p>
</dd>
<dt>Litter</dt><dd><p>Factor, id of litter of each pig</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data contains weight of slaughter pigs measured weekly for 12
weeks. Data also contains the start weight (i.e. the weight at week
1). The treatments are 3 different levels of Evit = vitamin E (dose: 0,
100, 200 mg dl-alpha-tocopheryl acetat /kg feed) in combination with 3
different levels of Cu=copper (dose: 0, 35, 175 mg/kg feed) in the feed.
The cumulated feed intake is also recorded. The pigs are litter mates.
</p>


<h3>Source</h3>

<p>Lauridsen, C., Højsgaard, S.,Sørensen, M.T. C. (1999) Influence of
Dietary Rapeseed Oli, Vitamin E, and Copper on Performance and
Antioxidant and Oxidative Status of Pigs. J. Anim. Sci.77:906-916
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox)
head(dietox)
coplot(Weight ~ Time | Evit * Cu, data=dietox)

</code></pre>

<hr>
<h2 id='esticon'>Contrasts for lm, glm, lme, and geeglm objects</h2><span id='topic+esticon'></span><span id='topic+coef.esticon_class'></span><span id='topic+summary.esticon_class'></span><span id='topic+confint.esticon_class'></span><span id='topic+vcov.esticon_class'></span>

<h3>Description</h3>

<p>Computes linear functions (i.e. weighted sums) of the
estimated regression parameters. Can also test the hypothesis,
that such a function is equal to a specific value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esticon(obj, L, beta0, conf.int = TRUE, level = 0.95, joint.test = FALSE, ...)

## S3 method for class 'esticon_class'
coef(object, ...)

## S3 method for class 'esticon_class'
summary(object, ...)

## S3 method for class 'esticon_class'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'esticon_class'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="esticon_+3A_obj">obj</code></td>
<td>
<p>Regression object (of type lm, glm, lme, geeglm).</p>
</td></tr>
<tr><td><code id="esticon_+3A_l">L</code></td>
<td>
<p>Matrix (or vector) specifying linear functions of the regression
parameters (one
linear function per row).  The number of columns must match the number of
fitted regression parameters in the model. See 'details' below.</p>
</td></tr>
<tr><td><code id="esticon_+3A_beta0">beta0</code></td>
<td>
<p>A vector of numbers</p>
</td></tr>
<tr><td><code id="esticon_+3A_conf.int">conf.int</code></td>
<td>
<p>TRUE</p>
</td></tr>
<tr><td><code id="esticon_+3A_level">level</code></td>
<td>
<p>The confidence level</p>
</td></tr>
<tr><td><code id="esticon_+3A_joint.test">joint.test</code></td>
<td>
<p>Logical value. If TRUE a 'joint' Wald test for the
hypothesis L beta = beta0 is made. Default is that the 'row-wise' tests are
made, i.e. (L beta)i=beta0i.  If joint.test is TRUE, then no confidence
interval etc. is calculated.</p>
</td></tr>
<tr><td><code id="esticon_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="esticon_+3A_object">object</code></td>
<td>
<p>An <code>esticon_class</code> object.</p>
</td></tr>
<tr><td><code id="esticon_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given
confidence intervals, either a vector of numbers or a vector
of names.  If missing, all parameters are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let the estimated parameters of the model be
</p>
<p style="text-align: center;"><code class="reqn">\beta_1, \beta_2, \dots, \beta_p</code>
</p>

<p>A linear function of the estimates is of the form </p>
<p style="text-align: center;"><code class="reqn">l=\lambda_1
    \beta_1+\lambda_2 \beta_2+ \dots+\lambda_p \beta_p</code>
</p>
<p> where
<code class="reqn">\lambda_1, \lambda_2, \dots,\lambda_p</code> is specified by the
user.
</p>
<p>The esticon function calculates l, its standard error and by default also a
95 pct confidence interval.  It is sometimes of interest to test the
hypothesis <code class="reqn">H_0: l=\beta_0</code> for some value <code class="reqn">\beta_0</code>
given by the user. A test is provided for the hypothesis <code class="reqn">H_0:
l=0</code> but other values of <code class="reqn">\beta_0</code> can be specified.
</p>
<p>In general, one can specify r such linear functions at one time by
specifying L to be an <code class="reqn">r\times p</code> matrix where each row consists
of p numbers <code class="reqn">\lambda_1,\lambda_2,\dots, \lambda_p</code>. Default is
then that <code class="reqn">\beta_0</code> is a p vector of 0s but other values can be
given.
</p>
<p>It is possible to test simultaneously that all specified linear functions
are equal to the corresponding values in <code class="reqn">\beta_0</code>.
</p>
<p>For computing contrasts among levels of a single factor, 'contrast.lm' may
be more convenient.
</p>


<h3>Value</h3>

<p>Returns a matrix with one row per linear function.  Columns contain
estimated coefficients, standard errors, t values, degrees of freedom,
two-sided p-values, and the lower and upper endpoints of the 1-alpha
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
lm1  &lt;- lm(Sepal.Length ~ Sepal.Width + Species + Sepal.Width : Species, data=iris)
## Note that the setosa parameters are set to zero
coef(lm1)

## Estimate the intercept for versicolor
lambda1 &lt;- c(1, 0, 1, 0, 0, 0)
esticon(lm1, L=lambda1)

## Estimate the difference between versicolor and virgica intercept
## and test if the difference is 1
lambda2 &lt;- c(0, 1, -1, 0, 0, 0)
esticon(lm1, L=lambda2, beta0=1)

## Do both estimates at one time
esticon(lm1, L=rbind(lambda1, lambda2), beta0=c(0, 1))

## Make a combined test for that the difference between versicolor and virgica intercept
## and difference between versicolor and virginica slope is zero:
lambda3 &lt;- c(0, 0, 0, 0, 1, -1)
esticon(lm1, L=rbind(lambda2, lambda3), joint.test=TRUE)

# Example using esticon on coxph objects (thanks to Alessandro A. Leidi).
# Using dataset 'veteran' in the survival package
# from the Veterans' Administration Lung Cancer study

if (require(survival)){
data(veteran)
sapply(veteran, class)
levels(veteran$celltype)
attach(veteran)
veteran.s &lt;- Surv(time, status)
coxmod &lt;- coxph(veteran.s ~ age + celltype + trt, method='breslow')
summary(coxmod)

# compare a subject 50 years old with celltype 1
# to a subject 70 years old with celltype 2
# both subjects on the same treatment
AvB &lt;- c(-20, -1, 0, 0, 0)

# compare a subject 40 years old with celltype 2 on treat=0
# to a subject 35 years old with celltype 3 on treat=1
CvB &lt;- c(5, 1, -1, 0, -1)

est &lt;- esticon(coxmod, L=rbind(AvB, CvB))
est
##exp(est[, c(2, 7, 8)])
}
</code></pre>

<hr>
<h2 id='expr_to_fun'>Convert expression into function object.</h2><span id='topic+expr_to_fun'></span>

<h3>Description</h3>

<p>Convert expression into function object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_to_fun(expr_, order = NULL, vec_arg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expr_to_fun_+3A_expr_">expr_</code></td>
<td>
<p>R expression.</p>
</td></tr>
<tr><td><code id="expr_to_fun_+3A_order">order</code></td>
<td>
<p>desired order of function argument.</p>
</td></tr>
<tr><td><code id="expr_to_fun_+3A_vec_arg">vec_arg</code></td>
<td>
<p>should the function take vector valued argument.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ee  &lt;- expression(b1 + (b0 - b1)*exp(-k*x) + b2*x)
ff1 &lt;- expr_to_fun(ee)
formals(ff1)

ff2 &lt;- expr_to_fun(ee, vec_arg=TRUE)
formals(ff2)
formals(ff2)$length_parm
formals(ff2)$names_parm |&gt; eval()

ee &lt;- expression(matrix(c(x1+x2, x1-x2, x1^2+x2^2, x1^3+x2^3), nrow=2))
ff1 &lt;- expr_to_fun(ee)
ff2 &lt;- expr_to_fun(ee, vec_arg=TRUE)

formals(ff2)
formals(ff2)$length_parm
formals(ff2)$names_parm |&gt; eval()

</code></pre>

<hr>
<h2 id='fatacid'>Fish oil in pig food</h2><span id='topic+fatacid'></span>

<h3>Description</h3>

<p>Fish oil in pig food
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatacid
</code></pre>


<h3>Format</h3>

<p>A dataframe.
</p>


<h3>Details</h3>

<p>A fish oil fatty acid <code>X14</code> has been added in
different concentrations to the food for pigs in a
study. Interest is in studying how much of the fatty acid can
be found in the tissue. The concentrations of <code>x14</code> in the
food are <code>verb+dose+={0.0, 4.4, 6.2, 9.3}</code>.
</p>
<p>The pigs are fed with this food until their weight is 60 kg.  From
thereof and until they are slaughtered at 100kg, their food does
not contain the fish oil.
At 60kg (sample=1) and 100kg (sample=2) muscle
biopsies are made and the concentration of x14 is
determined.
Measurements on the same pig are correlated, and pigs are additionally
related through litters.
</p>


<h3>References</h3>

<p>Data courtesy of Charlotte Lauridsen, Department of
Animal Science, Aarhus University, Denmark.
</p>

<hr>
<h2 id='fev'>Forced expiratory volume in children</h2><span id='topic+fev'></span>

<h3>Description</h3>

<p>Dataset to examine if respiratory function in children
was influenced by smoking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fev
</code></pre>


<h3>Format</h3>

<p>A data frame with 654 observations on the following 5 variables.
</p>

<dl>
<dt><code>Age</code></dt><dd><p>Age in years.</p>
</dd>
<dt><code>FEV</code></dt><dd><p>Forced expiratory volume in liters per second.</p>
</dd>
<dt><code>Ht</code></dt><dd><p>Height in centimeters.</p>
</dd>
<dt><code>Gender</code></dt><dd><p>Gender.</p>
</dd>
<dt><code>Smoke</code></dt><dd><p>Smoking status.</p>
</dd>
</dl>



<h3>References</h3>

<p>I. Tager and S. Weiss and B. Rosner and F. Speizer (1979). Effect
of Parental Cigarette Smoking on the Pulmonary Function of
Children.  American Journal of Epidemiology. 110:15-26
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fev)
summary(fev)

</code></pre>

<hr>
<h2 id='firstlastobs'>Locate the index of the first/last unique value</h2><span id='topic+firstlastobs'></span><span id='topic+lastobs'></span><span id='topic+firstobs'></span><span id='topic+firstobs.default'></span><span id='topic+lastobs.default'></span><span id='topic+firstobs.formula'></span><span id='topic+lastobs.formula'></span>

<h3>Description</h3>

<p>Locate the index of the first/last unique value in i) a vector
or of a variable in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastobs(x, ...)

firstobs(x, ...)

## Default S3 method:
lastobs(x, ...)

## Default S3 method:
firstobs(x, ...)

## S3 method for class 'formula'
lastobs(formula, data = parent.frame(), ...)

## S3 method for class 'formula'
firstobs(formula, data = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="firstlastobs_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="firstlastobs_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="firstlastobs_+3A_formula">formula</code></td>
<td>
<p>A formula (only the first term is used, see 'details').</p>
</td></tr>
<tr><td><code id="firstlastobs_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If writing ~a + b + c as formula, then only a is considered.
</p>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(1, 5), rep(2, 3), rep(3, 7), rep(1, 4))
firstobs(x)
lastobs(x)
data(dietox)
firstobs(~Pig, data=dietox)
lastobs(~Pig, data=dietox)

</code></pre>

<hr>
<h2 id='formula_ops'>Formula operations and coercion.</h2><span id='topic+formula_ops'></span><span id='topic+formula_add_str'></span><span id='topic+formula_add'></span><span id='topic+formula_poly'></span><span id='topic+formula_nth'></span><span id='topic+formula_to_interaction_matrix'></span><span id='topic+formula_chr_to_form'></span><span id='topic+to_str'></span><span id='topic+terms_labels'></span><span id='topic+simplify_rhs'></span><span id='topic+simplify_rhs.formula'></span><span id='topic+simplify_rhs.character'></span><span id='topic+as_rhs_frm'></span><span id='topic+as_lhs_frm'></span><span id='topic+as_rhs_chr'></span><span id='topic+as_lhs_chr'></span><span id='topic+unique_formula'></span>

<h3>Description</h3>

<p>Formula operations and coercion as a supplement to <code>update.formula()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_add_str(frm1, terms, op = "+")

formula_add(frm1, frm2)

formula_poly(chr1, n, noint = FALSE, y = NULL)

formula_nth(frm1, n)

formula_to_interaction_matrix(frm1)

formula_chr_to_form(rhs, lhs = character(0))

to_str(chr1, collapse = "+")

terms_labels(frm1)

simplify_rhs(object)

## S3 method for class 'formula'
simplify_rhs(object)

## S3 method for class 'character'
simplify_rhs(object)

as_rhs_frm(object)

as_lhs_frm(object)

as_rhs_chr(object, string = FALSE)

as_lhs_chr(object, string = FALSE)

unique_formula(list_of_formulas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula_ops_+3A_frm1">frm1</code>, <code id="formula_ops_+3A_frm2">frm2</code></td>
<td>
<p>Formulas to be coerced to character vectors.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_terms">terms</code></td>
<td>
<p>Character string.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_op">op</code></td>
<td>
<p>Either &quot;+&quot; (default) or &quot;-&quot;.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_chr1">chr1</code></td>
<td>
<p>Character vector to be coerced to formulas.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_n">n</code></td>
<td>
<p>Positive integer.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_noint">noint</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_y">y</code></td>
<td>
<p>Response</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_rhs">rhs</code>, <code id="formula_ops_+3A_lhs">lhs</code></td>
<td>
<p>right-hand-side and left-hand-side for formula (as characters)</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_collapse">collapse</code></td>
<td>
<p>Character to use as separator.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_object">object</code></td>
<td>
<p>Character vector or formula.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_string">string</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="formula_ops_+3A_list_of_formulas">list_of_formulas</code></td>
<td>
<p>list of formulas</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
formula_poly("z", 2)
formula_poly("z", 2, noint=TRUE)

as_rhs_chr(c("a", "b", "z"))
as_rhs_chr(c("a*b", "z"))

as_rhs_chr(y~a+b+z)
as_rhs_chr(y~a+b+z, string=TRUE)
as_rhs_chr(y~a+b+z)
as_rhs_chr(y~a*b+z)
as_rhs_chr(y~a*b+z, string=TRUE)

as_lhs_chr(y~a*b+z)
as_lhs_chr(log(y)~a*b+z)      ## Not what one might expect
as_lhs_chr(cbind(y, u)~a*b+z) ## Not what one might expect

formula_chr_to_form(c("a*b", "z"))
formula_chr_to_form(c("a*b", "z"), "y")
formula_chr_to_form(c("a*b", "z"), "log(y)")

formula_add(y~a*b+z, ~-1)
formula_add(y~a*b+z, ~a:b)

formula_add_str(y~x1 + x2, "x3")
formula_add_str(y~x1 + x2, "x1")
formula_add_str(y~x1 + x2, "x1", op="-")

</code></pre>

<hr>
<h2 id='generate_data_list'>Generate data list</h2><span id='topic+generate_data_list'></span>

<h3>Description</h3>

<p>Generate data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data_list(data., K, method = c("subgroups", "resample"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data_list_+3A_data.">data.</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="generate_data_list_+3A_k">K</code></td>
<td>
<p>Number of folds</p>
</td></tr>
<tr><td><code id="generate_data_list_+3A_method">method</code></td>
<td>
<p>Method for generating data</p>
</td></tr>
</table>

<hr>
<h2 id='get_formulas'>Get formulas from model_stability_glm_class object</h2><span id='topic+get_formulas'></span>

<h3>Description</h3>

<p>Get formulas from model_stability_glm_class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formulas(object, unique = TRUE, text = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_formulas_+3A_object">object</code></td>
<td>
<p>A model_stability_glm_class object</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_unique">unique</code></td>
<td>
<p>If TRUE, return unique models</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_text">text</code></td>
<td>
<p>If TRUE, return text (rather than formula).</p>
</td></tr>
</table>

<hr>
<h2 id='haldCement'>Heat development in cement under hardening.</h2><span id='topic+haldCement'></span>

<h3>Description</h3>

<p>Heat development in cement under hardening related to the chemical
composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haldCement
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 5 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>Percentage (weight) of <code style="white-space: pre;">&#8288;[3Ca0][Al2O3]&#8288;</code></p>
</dd>
<dt><code>x2</code></dt><dd><p>Percentage (weight) of <code style="white-space: pre;">&#8288;[3Cao][SiO2]&#8288;</code></p>
</dd>
<dt><code>x3</code></dt><dd><p>Percentage (weight) of <code style="white-space: pre;">&#8288;[4Ca0][Al2O3][Fe03]&#8288;</code></p>
</dd>
<dt><code>x4</code></dt><dd><p>Percentage (weight) of <code style="white-space: pre;">&#8288;[2Cao][SiO2]&#8288;</code></p>
</dd>
<dt><code>y</code></dt><dd><p>Heat development measured in calories per
gram cement after 180 days</p>
</dd>
</dl>



<h3>References</h3>

<p>Anders Hald (1949); Statistiske Metoder; Akademisk Forlag (in
Danish), page 509.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(haldCement)

if( interactive() ){
pairs( haldCement )
}
m &lt;- lm(y ~ x1 + x2 + x3 + x4, data=haldCement)
summary(m)

# Notice: The model explains practically all variation in data;
# yet none of the explanatory variables appear to be statistically
# significant.

</code></pre>

<hr>
<h2 id='income'>income data</h2><span id='topic+income'></span><span id='topic+shoes'></span>

<h3>Description</h3>

<p>Data on income, years of educations and ethnicity.
</p>
<p>Wear of soles of shoes of materials A and B for one foot each for of ten boys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>income

shoes
</code></pre>


<h3>Format</h3>

<p>This data frame contains:
</p>

<dl>
<dt>inc:</dt><dd><p>Income: Yearly income.</p>
</dd>
<dt>educ:</dt><dd><p>Education: Number of years of education.</p>
</dd>
<dt>race:</dt><dd><p>Racial-Ethnic group: &quot;b&quot; (black), &quot;h&quot; (hispanic) and &quot;w&quot; (white).</p>
</dd>
</dl>

<p>This data frame contains:
</p>

<dl>
<dt>A:</dt><dd><p>Wear, material A</p>
</dd>
<dt>B:</dt><dd><p>Wear, material B</p>
</dd>
<dt>boy:</dt><dd><p>Id of boy</p>
</dd>
<dt>footA:</dt><dd><p>The foot with material A</p>
</dd>
</dl>



<h3>Details</h3>

<p>Variable names are as in the reference.
</p>
<p>The shoes data are measurements of the amount wear of the
soles of shoes worn by 10 boys. The soles were made to two
different synthetic materials, a standard material A and a
cheaper material B.
</p>


<h3>References</h3>

<p>Agresti, A. (2024) Statistical Methods for the Social
Sciences, Global Edition (6th edition).  ISBN-13: 9781292449197. Table 13.1
</p>
<p>Box, Hunter, Hunter (2005) Statistics for Experimenters, 2nd edition Wiley, p. 81.
</p>

<hr>
<h2 id='interaction-plot'>Two-way interaction plot</h2><span id='topic+interaction-plot'></span><span id='topic+interaction_plot'></span>

<h3>Description</h3>

<p>Plots the mean of the response for
two-way combinations of factors, thereby illustrating possible
interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction_plot(.data, .formula, interval = "conf.int")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interaction-plot_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="interaction-plot_+3A_.formula">.formula</code></td>
<td>
<p>A formula of the form <code>y ~ x1 + x2</code></p>
</td></tr>
<tr><td><code id="interaction-plot_+3A_interval">interval</code></td>
<td>
<p>Either <code>conf.int</code>, <code>boxplot</code> or <code>none</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a recent addition to the package and is subject to change.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ToothGrowth |&gt; interaction_plot(len ~ dose + supp)
ToothGrowth |&gt; interaction_plot(len ~ dose + supp, interval="conf.int")
ToothGrowth |&gt; interaction_plot(len ~ dose + supp, interval="boxplot")
ToothGrowth |&gt; interaction_plot(len ~ dose + supp, interval="none")
</code></pre>

<hr>
<h2 id='internal'>Internal functions for the doBy package</h2><span id='topic+internal'></span><span id='topic+orderByOLD'></span><span id='topic+splitByOLD'></span><span id='topic+summaryByOLD'></span><span id='topic+linest_matrix_class-class'></span><span id='topic+print.linest_class'></span><span id='topic+print.esticon_class'></span><span id='topic+print.linest_matrix_class'></span><span id='topic+summary.linest_matrix_class'></span><span id='topic+asNumericMatrix2'></span><span id='topic+matrix2dataFrame2'></span><span id='topic+subsAttr2'></span><span id='topic+doby.xtabs'></span><span id='topic+print.lmBy'></span><span id='topic+print.summary_lmBy'></span><span id='topic+print.splitByData'></span><span id='topic+linest_class-class'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Internal functions for the doBy package</p>

<hr>
<h2 id='is_estimable'>Determines if contrasts are estimable.</h2><span id='topic+is_estimable'></span>

<h3>Description</h3>

<p>Determines if contrasts are estimable, that is, if the contrasts
can be written as a linear function of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_estimable(K, null.basis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_estimable_+3A_k">K</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="is_estimable_+3A_null.basis">null.basis</code></td>
<td>
<p>A basis for a null space (can be found with
<code>null_basis()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the setting <code class="reqn">E(Y)=Xb</code>. A linear function of <code class="reqn">b</code>,
say <code class="reqn">l'b</code> is estimable if and only if there exists an <code class="reqn">r</code> such
that <code class="reqn">r'X=l'</code> or equivalently <code class="reqn">l=X'r</code>. Hence <code class="reqn">l</code> must be in
the column space of <code class="reqn">X'</code>, i.e. in the orthogonal complement of the
null space of <code class="reqn">X</code>. Hence, with a basis <code class="reqn">B</code> for the null space,
<code>is_estimable()</code> checks if each row <code class="reqn">l</code> of the matrix <code class="reqn">K</code> is
perpendicular to each column basis vector in <code class="reqn">B</code>.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p><a href="http://web.mit.edu/18.06/www/Essays/newpaper_ver3.pdf">http://web.mit.edu/18.06/www/Essays/newpaper_ver3.pdf</a>
</p>

<hr>
<h2 id='linest'>Compute linear estimates</h2><span id='topic+linest'></span><span id='topic+linest.lm'></span><span id='topic+linest.glm'></span><span id='topic+linest.geeglm'></span><span id='topic+linest.lmerMod'></span><span id='topic+linest.merMod'></span><span id='topic+linest.default'></span><span id='topic+confint.linest_class'></span><span id='topic+coef.linest_class'></span><span id='topic+summary.linest_class'></span>

<h3>Description</h3>

<p>Compute linear estimates, i.e. <code>L %*% beta</code> for a range of models. One example of
linear estimates is population means (also known as LSMEANS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linest(object, L = NULL, level = 0.95, ...)

## S3 method for class 'linest_class'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'linest_class'
coef(object, ...)

## S3 method for class 'linest_class'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linest_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="linest_+3A_l">L</code></td>
<td>
<p>Either <code>NULL</code> or a matrix with p columns where p is
the number of parameters in the systematic effects in the
model. If <code>NULL</code> then <code>L</code> is taken to be the p times
p identity matrix</p>
</td></tr>
<tr><td><code id="linest_+3A_level">level</code></td>
<td>
<p>The level of the (asymptotic) confidence interval.</p>
</td></tr>
<tr><td><code id="linest_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="linest_+3A_parm">parm</code></td>
<td>
<p>Specification of the parameters estimates for which
confidence intervals are to be calculated.</p>
</td></tr>
<tr><td><code id="linest_+3A_confint">confint</code></td>
<td>
<p>Should confidence interval appear in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with results from computing the contrasts.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSmeans">LSmeans</a></code>, <code><a href="#topic+LE_matrix">LE_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Make balanced dataset
dat.bal &lt;- expand.grid(list(AA=factor(1:2), BB=factor(1:3), CC=factor(1:3)))
dat.bal$y &lt;- rnorm(nrow(dat.bal))

## Make unbalanced dataset
#   'BB' is nested within 'CC' so BB=1 is only found when CC=1
#   and BB=2,3 are found in each CC=2,3,4
dat.nst &lt;- dat.bal
dat.nst$CC &lt;-factor(c(1,1,2,2,2,2,1,1,3,3,3,3,1,1,4,4,4,4))

mod.bal  &lt;- lm(y ~ AA + BB * CC, data=dat.bal)
mod.nst  &lt;- lm(y ~ AA + BB : CC, data=dat.nst)

L &lt;- LE_matrix(mod.nst, effect=c("BB", "CC"))
linest( mod.nst, L )

</code></pre>

<hr>
<h2 id='linest-get'>Auxillary functions for computing lsmeans, contrasts etc</h2><span id='topic+linest-get'></span><span id='topic+get_xlevels'></span><span id='topic+get_xlevels.default'></span><span id='topic+get_xlevels.mer'></span><span id='topic+get_xlevels.merMod'></span><span id='topic+get_contrasts'></span><span id='topic+get_contrasts.default'></span><span id='topic+get_contrasts.merMod'></span><span id='topic+set_xlevels'></span><span id='topic+get_vartypes'></span><span id='topic+set_covariate_val'></span><span id='topic+get_X'></span><span id='topic+get_X.default'></span><span id='topic+get_X.merMod'></span>

<h3>Description</h3>

<p>Auxillary functions for computing lsmeans, contrasts etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_xlevels(obj)

## Default S3 method:
get_xlevels(obj)

## S3 method for class 'mer'
get_xlevels(obj)

## S3 method for class 'merMod'
get_xlevels(obj)

get_contrasts(obj)

## Default S3 method:
get_contrasts(obj)

## S3 method for class 'merMod'
get_contrasts(obj)

set_xlevels(xlev, at)

get_vartypes(obj)

set_covariate_val(xlev, covariateVal)

get_X(obj, newdata, at = NULL)

## Default S3 method:
get_X(obj, newdata, at = NULL)

## S3 method for class 'merMod'
get_X(obj, newdata, at = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linest-get_+3A_obj">obj</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="linest-get_+3A_xlev">xlev</code></td>
<td>
<p>FIXME: to be described</p>
</td></tr>
<tr><td><code id="linest-get_+3A_at">at</code></td>
<td>
<p>FIXME: to be described</p>
</td></tr>
<tr><td><code id="linest-get_+3A_covariateval">covariateVal</code></td>
<td>
<p>FIXME: to be described</p>
</td></tr>
<tr><td><code id="linest-get_+3A_newdata">newdata</code></td>
<td>
<p>FIXME: to be described</p>
</td></tr>
</table>

<hr>
<h2 id='linest-matrix'>Linear estimates matrix</h2><span id='topic+linest-matrix'></span><span id='topic+LE_matrix'></span><span id='topic+LE_matrix.default'></span><span id='topic+aggregate_linest_list'></span><span id='topic+get_linest_list'></span>

<h3>Description</h3>

<p>Generate matrix specifying linear estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LE_matrix(object, effect = NULL, at = NULL)

## Default S3 method:
LE_matrix(object, effect = NULL, at = NULL)

aggregate_linest_list(linest_list)

get_linest_list(object, effect = NULL, at = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linest-matrix_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="linest-matrix_+3A_effect">effect</code></td>
<td>
<p>A vector of variables. For each configuration of
these the estimate will be calculated.</p>
</td></tr>
<tr><td><code id="linest-matrix_+3A_at">at</code></td>
<td>
<p>Either NULL, a list or a dataframe. 1) If a list, then the list
must consist of covariates (including levels of some factors)
to be used in the calculations. 2) If a dataframe, the
dataframe is split rowwise and the function is invoked on each
row.</p>
</td></tr>
<tr><td><code id="linest-matrix_+3A_linest_list">linest_list</code></td>
<td>
<p>Linear estimate list (as generated by <code>get_linest_list</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check this
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSmeans">LSmeans</a></code>, <code><a href="#topic+linest">linest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two way anova:

data(warpbreaks)

## An additive model
m0 &lt;- lm(breaks ~ wool + tension, data=warpbreaks)

## Estimate mean for each wool type, for tension="M":
K &lt;- LE_matrix(m0, at=list(wool=c("A", "B"), tension="M"))
K

## Vanilla computation:
K %*% coef(m0)

## Alternative; also providing standard errors etc:
linest(m0, K)
esticon(m0, K)

## Estimate mean for each wool type when averaging over tension;
# two ways of doing this
K &lt;- LE_matrix(m0, at=list(wool=c("A", "B")))
K
K &lt;- LE_matrix(m0, effect="wool")
K
linest(m0, K)

## The linear estimate is sometimes called to "least squares mean"
# (LSmeans) or popupulation means.
# Same as
LSmeans(m0, effect="wool")

## Without mentioning 'effect' or 'at' an average across all
#predictors are calculated:
K &lt;- LE_matrix(m0)
K
linest(m0, K)

## Because the design is balanced (9 observations per combination
#of wool and tension) this is the same as computing the average. If
#the design is not balanced, the two quantities are in general not
#the same.
mean(warpbreaks$breaks)

## Same as 
LSmeans(m0)

## An interaction model 
m1 &lt;- lm(breaks ~ wool * tension, data=warpbreaks)

K &lt;- LE_matrix(m1, at=list(wool=c("A", "B"), tension="M"))
K
linest(m1, K)
K &lt;- LE_matrix(m1, at=list(wool=c("A", "B")))
K
linest(m1, K)
K &lt;- LE_matrix(m1, effect="wool")
K
linest(m1, K)
LSmeans(m1, effect="wool")

K &lt;- LE_matrix(m1)
K
linest(m1, K)
LSmeans(m1)
</code></pre>

<hr>
<h2 id='ls-means'>Compute  LS-means (aka population means or
marginal means)</h2><span id='topic+ls-means'></span><span id='topic+LSmeans'></span><span id='topic+LSmeans.default'></span><span id='topic+LSmeans.lmerMod'></span><span id='topic+popMeans'></span><span id='topic+popMeans.default'></span><span id='topic+popMeans.lmerMod'></span>

<h3>Description</h3>

<p>LS-means (least squares means, also known as
population means and as marginal means) for a range of model types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSmeans(object, effect = NULL, at = NULL, level = 0.95, ...)

## Default S3 method:
LSmeans(object, effect = NULL, at = NULL, level = 0.95, ...)

## S3 method for class 'lmerMod'
LSmeans(object, effect = NULL, at = NULL, level = 0.95, adjust.df = TRUE, ...)

popMeans(object, effect = NULL, at = NULL, level = 0.95, ...)

## Default S3 method:
popMeans(object, effect = NULL, at = NULL, level = 0.95, ...)

## S3 method for class 'lmerMod'
popMeans(object, effect = NULL, at = NULL, level = 0.95, adjust.df = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls-means_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="ls-means_+3A_effect">effect</code></td>
<td>
<p>A vector of variables. For each configuration of
these the estimate will be calculated.</p>
</td></tr>
<tr><td><code id="ls-means_+3A_at">at</code></td>
<td>
<p>A list of values of covariates (including levels of some
factors) to be used in the calculations</p>
</td></tr>
<tr><td><code id="ls-means_+3A_level">level</code></td>
<td>
<p>The level of the (asymptotic) confidence interval.</p>
</td></tr>
<tr><td><code id="ls-means_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="ls-means_+3A_adjust.df">adjust.df</code></td>
<td>
<p>Should denominator degrees of freedom be adjusted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are restrictions on the formulas allowed in the model object.
For example having <code>y ~ log(x)</code> will cause an error. Instead one
must define the variable <code>logx = log(x)</code> and do <code>y ~ logx</code>.
</p>


<h3>Value</h3>

<p>A dataframe with results from computing the contrasts.
</p>


<h3>Warning</h3>

<p>Notice that <code>LSmeans</code> and <code>LE_matrix</code>
fails if the model formula contains an offset (as one would
have in connection with e.g. Poisson regression.
</p>


<h3>Note</h3>

<p><code>LSmeans</code> and <code>popMeans</code> are synonymous.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LE_matrix">LE_matrix</a></code>, <code><a href="#topic+linest">linest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two way anova:

data(warpbreaks)

m0 &lt;- lm(breaks ~ wool + tension, data=warpbreaks)
m1 &lt;- lm(breaks ~ wool * tension, data=warpbreaks)
LSmeans(m0)
LSmeans(m1)

## same as:
K &lt;- LE_matrix(m0);K
linest(m0, K)
K &lt;- LE_matrix(m1);K
linest(m1, K)

LE_matrix(m0, effect="wool")
LSmeans(m0, effect="wool")

LE_matrix(m1, effect="wool")
LSmeans(m1, effect="wool")

LE_matrix(m0, effect=c("wool", "tension"))
LSmeans(m0, effect=c("wool", "tension"))

LE_matrix(m1, effect=c("wool", "tension"))
LSmeans(m1, effect=c("wool", "tension"))


## Regression; two parallel regression lines:

data(Puromycin)

m0 &lt;- lm(rate ~ state + log(conc), data=Puromycin)
## Can not use LSmeans / LE_matrix here because of
## the log-transformation. Instead we must do:
Puromycin$lconc &lt;- log( Puromycin$conc )
m1 &lt;- lm(rate ~ state + lconc, data=Puromycin)

LE_matrix(m1)
LSmeans(m1)

LE_matrix(m1, effect="state")
LSmeans(m1, effect="state")

LE_matrix(m1, effect="state", at=list(lconc=3))
LSmeans(m1, effect="state", at=list(lconc=3))

## Non estimable contrasts

## ## Make balanced dataset
dat.bal &lt;- expand.grid(list(AA=factor(1:2), BB=factor(1:3),
                            CC=factor(1:3)))
dat.bal$y &lt;- rnorm(nrow(dat.bal))

## ## Make unbalanced dataset
#      'BB' is nested within 'CC' so BB=1 is only found when CC=1
#       and BB=2,3 are found in each CC=2,3,4
dat.nst &lt;- dat.bal
dat.nst$CC &lt;-factor(c(1, 1, 2, 2, 2, 2, 1, 1, 3, 3,
                      3, 3, 1, 1, 4, 4, 4, 4))

mod.bal  &lt;- lm(y ~ AA + BB * CC,    data=dat.bal)
mod.nst  &lt;- lm(y ~ AA + BB : CC, data=dat.nst)

LSmeans(mod.bal, effect=c("BB", "CC"))
LSmeans(mod.nst, effect=c("BB", "CC"))
LSmeans(mod.nst, at=list(BB=1, CC=1))

LSmeans(mod.nst, at=list(BB=1, CC=2))
## Above: NA's are correct; not an estimable function

if( require( lme4 )){
 warp.mm &lt;- lmer(breaks ~ -1 + tension + (1|wool), data=warpbreaks)
 LSmeans(warp.mm, effect="tension")
 class(warp.mm)
 fixef(warp.mm)
 coef(summary(warp.mm))
 vcov(warp.mm)
 if (require(pbkrtest))
   vcovAdj(warp.mm)
}

LSmeans(warp.mm, effect="tension")

</code></pre>

<hr>
<h2 id='mb_summary'>Fast summary of microbenchmark object</h2><span id='topic+mb_summary'></span><span id='topic+summary_mb'></span>

<h3>Description</h3>

<p>Fast summary of microbenchmark object. The default
summary method from the microbenchmark package is fairly slow
in producing a summary (due to a call to a function from the
multcomp package.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_summary(object, unit, add.unit = TRUE, ...)

summary_mb(object, unit, add.unit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mb_summary_+3A_object">object</code></td>
<td>
<p>A microbenchmark object</p>
</td></tr>
<tr><td><code id="mb_summary_+3A_unit">unit</code></td>
<td>
<p>The time unit to be used</p>
</td></tr>
<tr><td><code id="mb_summary_+3A_add.unit">add.unit</code></td>
<td>
<p>Should time unit be added as column to resulting
dataframe.</p>
</td></tr>
<tr><td><code id="mb_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='milkman'>Milk yield data for manually milked cows.</h2><span id='topic+milkman'></span><span id='topic+milkman_rdm1'></span>

<h3>Description</h3>

<p>Milk yield data for cows milked manually twice a day (morning and evening).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>milkman
</code></pre>


<h3>Format</h3>

<p>A data frame with 161836 observations on the following 12 variables.
</p>

<dl>
<dt><code>cowno</code></dt><dd><p>a numeric vector; cow identification</p>
</dd>
<dt><code>lactno</code></dt><dd><p>a numeric vector; lactation number</p>
</dd>
<dt><code>ampm</code></dt><dd><p>a numeric vector; milking time: 1: morning; 2: evening</p>
</dd>
<dt><code>dfc</code></dt><dd><p>a numeric vector; days from calving</p>
</dd>
<dt><code>my</code></dt><dd><p>a numeric vector; milk yield (kg)</p>
</dd>
<dt><code>fatpct</code></dt><dd><p>a numeric vector; fat percentage</p>
</dd>
<dt><code>protpct</code></dt><dd><p>a numeric vector; protein percentage</p>
</dd>
<dt><code>lactpct</code></dt><dd><p>a numeric vector; lactose percentage</p>
</dd>
<dt><code>scc</code></dt><dd><p>a numeric vector; somatic cell counts</p>
</dd>
<dt><code>race</code></dt><dd><p>a factor with levels <code>RDM</code> <code>Holstein</code> <code>Jersey</code></p>
</dd>
<dt><code>ecmy</code></dt><dd><p>a numeric vector; energy corrected milk</p>
</dd>
<dt><code>cowlact</code></dt><dd><p>Combination of cowno and lactno; necessary
because the same cow may appear more than once in the dataset (in
different lactations)</p>
</dd>
</dl>



<h3>Details</h3>

<p>There are data for 222 cows. Some cows appear more than once in the dataset
(in different lactations) and there are 288 different lactations.
</p>


<h3>References</h3>

<p>Friggens, N. C.; Ridder, C. and Løvendahl, P. (2007).
On the Use of Milk Composition Measures to Predict the Energy Balance of Dairy Cows.
J. Dairy Sci. 90:5453–5467 doi:10.3168/jds.2006-821.
</p>
<p>This study was part of the Biosens project used data from the
“Malkekoens energibalance og mobilisering” project; both were
funded by the Danish Ministry of Food, Agriculture and Fisheries
and the Danish Cattle Association.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(milkman)

</code></pre>

<hr>
<h2 id='model_stability_glm'>Model stability for glm objects</h2><span id='topic+model_stability_glm'></span>

<h3>Description</h3>

<p>Model stability for glm objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_stability_glm(
  data.,
  model,
  n.searches = 10,
  method = c("subgroups", "resample"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_stability_glm_+3A_data.">data.</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="model_stability_glm_+3A_model">model</code></td>
<td>
<p>A glm object</p>
</td></tr>
<tr><td><code id="model_stability_glm_+3A_n.searches">n.searches</code></td>
<td>
<p>Number of searches</p>
</td></tr>
<tr><td><code id="model_stability_glm_+3A_method">method</code></td>
<td>
<p>Method for generating data</p>
</td></tr>
<tr><td><code id="model_stability_glm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+step">step</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='nir_milk'>nir_milk</h2><span id='topic+nir_milk'></span>

<h3>Description</h3>

<p>Near infra red light (NIR) measurements are made at
152 wavelengths on 17 milk samples.  While milk runs through a
glass tube, infra red light is sent through the tube and the
amount of light passing though the tube is measured at
different wavelengths.  Each milk sample was additionally
analysed for fat, lactose, protein and dry matter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nir_milk
</code></pre>


<h3>Format</h3>

<p>A list with two components
x Datafrane with infra red light amount at different wavelengths (column names are the wavelengths; just remove the leading X).
y Datafrane with response variables fat, protein,
lactose and dm (drymatter)
</p>


<h3>See Also</h3>

<p><a href="#topic+NIRmilk">NIRmilk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
data(nir_milk)

</code></pre>

<hr>
<h2 id='NIRmilk'>NIRmilk</h2><span id='topic+NIRmilk'></span>

<h3>Description</h3>

<p>Near infra red light (NIR) measurements are made at
152 wavelengths on 17 milk samples.  While milk runs through a
glass tube, infra red light is sent through the tube and the
amount of light passing though the tube is measured at
different wavelengths.  Each milk sample was additionally
analysed for fat, lactose, protein and dry matter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NIRmilk
</code></pre>


<h3>Format</h3>

<p>This data frame contains 17 rows and 158 columns.  The
first column is the sample number.  The columns <code>Xklm</code> contains
the transmittance (fraction of electromagnetic power)
transmittance through the sample at wavelength <code>klm</code>.  The
response variables are fat, protein, lactose and dm (dry
matter).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
data(NIRmilk)

</code></pre>

<hr>
<h2 id='parseGroupFormula'>Extract components from a formula with &quot;conditioning bar&quot;</h2><span id='topic+parseGroupFormula'></span>

<h3>Description</h3>

<p>Extract components from a formula with the form
<code>y ~ x1 + ... + xn | g1 + ... + gm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseGroupFormula(form)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parseGroupFormula_+3A_form">form</code></td>
<td>
<p>A formula of the form <code>y ~ x1 + ... + xn | g1 + ... + gm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the formula is <code>y ~ x1 + x2 | g1 + g2</code> the result is
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p><code>y ~ x1 + x2</code></p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p><code> g1 + g2</code></p>
</td></tr>
<tr><td><code>groupFormula</code></td>
<td>
<p><code>~ g1 + g2</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gf &lt;- parseGroupFormula(y ~ x1 + x2 | g1 + g2)
gf 

</code></pre>

<hr>
<h2 id='plot_lm'>Plot linear model object</h2><span id='topic+plot_lm'></span>

<h3>Description</h3>

<p>Plot linear model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lm(lm_fit, format = "2x2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_lm_+3A_lm_fit">lm_fit</code></td>
<td>
<p>An object of class 'lm'</p>
</td></tr>
<tr><td><code id="plot_lm_+3A_format">format</code></td>
<td>
<p>The format of the plot (or a list of plots if format is &quot;list&quot;)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
m1 &lt;- lm(speed ~ dist, data=cars)
plot_lm(m1)
plot_lm(m1, "2x2")
plot_lm(m1, "1x4")
plot_lm(m1, "4x1")
plot_lm(m1, "list")

</code></pre>

<hr>
<h2 id='potatoes'>Weight and size of 20 potatoes</h2><span id='topic+potatoes'></span>

<h3>Description</h3>

<p>Weight and size of 20 potatoes. Weight in grams; size in millimeter. There
are two sizes: <code>length</code> is the longest length and <code>width</code> is the
shortest length across a potato.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potatoes
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 3 variables.
</p>

<dl>
<dt><code>weight</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>length</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>width</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Source</h3>

<p>My own garden; autumn 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(potatoes)
plot(potatoes) 

</code></pre>

<hr>
<h2 id='prostate'>Prostate Tumor Gene Expression Dataset</h2><span id='topic+prostate'></span>

<h3>Description</h3>

<p>This is the Prostate Tumor Gene Expression dataset used in Chung and Keles (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(prostate) </code></pre>


<h3>Format</h3>

<p>A list with two components:
</p>

<dl>
<dt>x</dt><dd><p> Gene expression data. A matrix with 102 rows and 6033 columns.</p>
</dd>
<dt>y</dt><dd><p> Class index. A vector with 102 elements.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The prostate dataset consists of 52 prostate tumor and 50 normal samples.
Normal and tumor classes are coded in 0 and 1, respectively, in <code>y</code> vector.
Matrix <code>x</code> is gene expression data and
arrays were normalized, log transformed, and standardized 
to zero mean and unit variance across genes as described
in Dettling (2004) and Dettling and Beuhlmann (2002).
See Chung and Keles (2010) for more details. 
</p>


<h3>Source</h3>

<p>Singh D, Febbo P, Ross K, Jackson D, Manola J, Ladd C, Tamayo P, Renshaw A,
DAmico A, Richie J, Lander E, Loda M, Kantoff P, Golub T, and Sellers W (2002),
&quot;Gene expression correlates of clinical prostate cancer behavior&quot;, <em>Cancer Cell</em>, 
Vol. 1, pp. 203&ndash;209.
</p>


<h3>References</h3>

<p>Chung D and Keles S (2010), 
&quot;Sparse partial least squares classification for high dimensional data&quot;,
<em>Statistical Applications in Genetics and Molecular Biology</em>, Vol. 9, Article 17.
</p>
<p>Dettling M (2004), &quot;BagBoosting for tumor classification with gene expression data&quot;,
<em>Bioinformatics</em>, Vol. 20, pp. 3583&ndash;3593.
</p>
<p>Dettling M and Beuhlmann P (2002), &quot;Supervised clustering of genes&quot;, <em>Genome Biology</em>,
Vol. 3, pp. research0069.1&ndash;0069.15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(prostate)
prostate$x[1:5,1:5]
prostate$y
</code></pre>

<hr>
<h2 id='recodeVar'>Recode values of a vector</h2><span id='topic+recodeVar'></span><span id='topic+recode_var'></span>

<h3>Description</h3>

<p>Recodes a vector with values, say 1,2 to a variable with values, say 'a',
'b'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeVar(x, src, tgt, default = NULL, keep.na = TRUE)

recode_var(x, src, tgt, default = NULL, keep.na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recodeVar_+3A_x">x</code></td>
<td>
<p>A vector; the variable to be recoded.</p>
</td></tr>
<tr><td><code id="recodeVar_+3A_src">src</code></td>
<td>
<p>The source values: a subset of the present values of x</p>
</td></tr>
<tr><td><code id="recodeVar_+3A_tgt">tgt</code></td>
<td>
<p>The target values: the corresponding new values of x</p>
</td></tr>
<tr><td><code id="recodeVar_+3A_default">default</code></td>
<td>
<p>Default target value for those values of x not listed in
<code>src</code>. When default=NULL, values of x which are not given in <code>src</code> will
be kept in the output.</p>
</td></tr>
<tr><td><code id="recodeVar_+3A_keep.na">keep.na</code></td>
<td>
<p>If TRUE then NA's in x will be retained in the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>


<h3>Warning </h3>

<p>Care should be taken if x is a factor. A safe approach may
be to convert x to a character vector using as.character.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="base.html#topic+factor">factor</a></code>,
<code><a href="#topic+recodeVar">recodeVar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c("dec", "jan", "feb", "mar", "apr", "may")
src1 &lt;- list(c("dec", "jan", "feb"), c("mar", "apr", "may"))
tgt1 &lt;- list("winter", "spring")
recodeVar(x, src=src1, tgt=tgt1)
#[1] "winter" "winter" "winter" "spring" "spring" "spring"

x &lt;- c(rep(1:3, 3))
#[1] 1 2 3 1 2 3 1 2 3

## Simple usage:
recodeVar(x, src=c(1, 2), tgt=c("A", "B"))
#[1] "A" "B" NA  "A" "B" NA  "A" "B" NA 

## Here we need to use lists
recodeVar(x, src=list(c(1, 2)), tgt=list("A"))
#[1] "A" "A" NA  "A" "A" NA  "A" "A" NA 
recodeVar(x, src=list(c(1, 2)), tgt=list("A"), default="L")
#[1] "A" "A" "L" "A" "A" "L" "A" "A" "L"
recodeVar(x, src=list(c(1, 2), 3), tgt=list("A", "B"), default="L")
#[1] "A" "A" "B" "A" "A" "B" "A" "A" "B"

## Dealing with NA's in x
x&lt;-c(NA,rep(1:3, 3),NA)
#[1] NA  1  2  3  1  2  3  1  2  3 NA
recodeVar(x, src=list(c(1, 2)), tgt=list("A"))
#[1] NA  "A" "A" NA  "A" "A" NA  "A" "A" NA  NA 
recodeVar(x, src=list(c(1, 2)), tgt=list("A"), default="L")
#[1] NA  "A" "A" "L" "A" "A" "L" "A" "A" "L" NA 
recodeVar(x, src=list(c(1, 2)), tgt=list("A"), default="L", keep.na=FALSE)
#[1] "L" "A" "A" "L" "A" "A" "L" "A" "A" "L" "L"

x &lt;- c("no", "yes", "not registered", "no", "yes", "no answer")
recodeVar(x, src = c("no", "yes"), tgt = c("0", "1"), default = NA)


</code></pre>

<hr>
<h2 id='recover_pca_data'>Recover data from principal component analysis</h2><span id='topic+recover_pca_data'></span>

<h3>Description</h3>

<p>Recover data from principal component analysis based on the first (typically few) components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_pca_data(object, comp = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recover_pca_data_+3A_object">object</code></td>
<td>
<p>An object of class <code>prcomp</code>.</p>
</td></tr>
<tr><td><code id="recover_pca_data_+3A_comp">comp</code></td>
<td>
<p>The number of components to be used. Must be smaller
than the number of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
crime &lt;- doBy::crimeRate
rownames(crime) &lt;- crime$state
crime$state &lt;- NULL

o &lt;- order(apply(scale(crime), 1, sum))
dat &lt;- crime[o,]
head(dat)
tail(dat)
matplot(scale(dat), type="l")

pc1 &lt;- prcomp(dat, scale. = TRUE)
summary(pc1)
rec2 &lt;- recover_pca_data(pc1, 2)

pairs(rec2)

par(mfrow=c(1,2))
matplot(scale(dat), type="l")
matplot(scale(rec2), type="l")

j &lt;- merge(dat, rec2, by=0)
pairs(j[,-1])

</code></pre>

<hr>
<h2 id='renameCol'>Rename columns in a matrix or a dataframe.</h2><span id='topic+renameCol'></span>

<h3>Description</h3>

<p>Rename columns in a matrix or a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameCol(indata, src, tgt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renameCol_+3A_indata">indata</code></td>
<td>
<p>A dataframe or a matrix</p>
</td></tr>
<tr><td><code id="renameCol_+3A_src">src</code></td>
<td>
<p>Source: Vector of names of columns in <code>indata</code> to be
renamed. Can also be a vector of column numbers.</p>
</td></tr>
<tr><td><code id="renameCol_+3A_tgt">tgt</code></td>
<td>
<p>Target: Vector with corresponding new names in the
output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe if <code>indata</code> is a dataframe; a matrix in
<code>indata</code> is a matrix.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>renameCol(CO2, 1:2, c("kk", "ll"))
renameCol(CO2, c("Plant", "Type"), c("kk", "ll"))

# These fail - as they should:
# renameCol(CO2, c("Plant", "Type", "conc"), c("kk", "ll"))
# renameCol(CO2, c("Plant", "Type", "Plant"), c("kk", "ll"))

</code></pre>

<hr>
<h2 id='response_plot'>Plot the response variable against the predictor variables.</h2><span id='topic+response_plot'></span>

<h3>Description</h3>

<p>Plot the response variable against the predictor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_plot(
  data.,
  formula.,
  geoms = NULL,
  global_aes = NULL,
  plot = TRUE,
  nrow = NULL,
  ncol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="response_plot_+3A_data.">data.</code></td>
<td>
<p>A data frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="response_plot_+3A_formula.">formula.</code></td>
<td>
<p>A formula of the form y ~ x1 + x2 + ... + xn, where
y is the response variable and x1, x2, ..., xn are the
predictor variables. A dot as right hand side is allowed.</p>
</td></tr>
<tr><td><code id="response_plot_+3A_geoms">geoms</code></td>
<td>
<p>A list of ggplot2 geoms to be added to the plot.</p>
</td></tr>
<tr><td><code id="response_plot_+3A_global_aes">global_aes</code></td>
<td>
<p>A list of global aesthetics to be added to the plot.</p>
</td></tr>
<tr><td><code id="response_plot_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether the plot should be displayed.</p>
</td></tr>
<tr><td><code id="response_plot_+3A_nrow">nrow</code>, <code id="response_plot_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows / columns in plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ggplot2 plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
response_plot(iris, Sepal.Width ~ ., geoms=geom_point())
response_plot(iris, Sepal.Width ~ ., geoms=geom_point(), global_aes=list(color="Species"))
personality |&gt; response_plot(easygon~., geoms=geom_point(), global_aes=NULL)

</code></pre>

<hr>
<h2 id='scale_df'>Scaling numerical values</h2><span id='topic+scale_df'></span><span id='topic+scale2'></span>

<h3>Description</h3>

<p>Similar to 'base::scale' but applies to scales / centers only numeric values
in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_df(x, center = TRUE, scale = TRUE)

scale2(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_df_+3A_x">x</code></td>
<td>
<p>dataframe or matrix</p>
</td></tr>
<tr><td><code id="scale_df_+3A_center">center</code></td>
<td>
<p>Logical, should data be centered.</p>
</td></tr>
<tr><td><code id="scale_df_+3A_scale">scale</code></td>
<td>
<p>Logical, should data be scaled.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>x</code> is not a dataframe, then base::scale is invoked on
<code>x</code>.
</p>
</li>
<li><p> Suppose <code>x</code> is a dataframe. Then base::scale is invoked
on all columns that are numeric, integer or logical.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scale2(iris)
</code></pre>

<hr>
<h2 id='section_fun'>Section a function and set default values in function</h2><span id='topic+section_fun'></span><span id='topic+set_default'></span><span id='topic+section_fun_sub'></span><span id='topic+section_fun_env'></span><span id='topic+get_section'></span><span id='topic+get_fun'></span>

<h3>Description</h3>

<p>Section a functions domain by fixing certain
arguments of a function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_default(fun, nms, vls = NULL)

section_fun(fun, nms, vls = NULL, method = "args")

section_fun_sub(fun, nms, vls = NULL, envir = parent.frame())

section_fun_env(fun, nms, vls = NULL)

get_section(object)

get_fun(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="section_fun_+3A_fun">fun</code></td>
<td>
<p>Function to be sectioned</p>
</td></tr>
<tr><td><code id="section_fun_+3A_nms">nms</code></td>
<td>
<p>Either a named list of the form name=value where each
name is the name of an argument of the function (in which case
<code>vls</code> is ignored) or a character vector of names of arguments.</p>
</td></tr>
<tr><td><code id="section_fun_+3A_vls">vls</code></td>
<td>
<p>A vector or list of values of the arguments</p>
</td></tr>
<tr><td><code id="section_fun_+3A_method">method</code></td>
<td>
<p>One of the following: 1) &quot;args&quot; (default); based on
substituting fixed values into the function argument list as
default values). For backward compatibility can also be &quot;def&quot;.
2) &quot;body&quot; for substituting fixed values into the function
body. For backward compatibility can also be &quot;sub&quot;. 3) &quot;env&quot;:
(for environment); using an auxillary argument for storing
sectioned values.</p>
</td></tr>
<tr><td><code id="section_fun_+3A_envir">envir</code></td>
<td>
<p>Environment</p>
</td></tr>
<tr><td><code id="section_fun_+3A_object">object</code></td>
<td>
<p>An object from section_fun (a scaffold object).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let E be a subset of the cartesian product X x Y where X
and Y are some sets. Consider a function f(x,y) defined on
E. Then for any x in X, the section of E defined by x (denoted
Ex) is the set of $y$s in Y such that (x, y) is in
E. Correspondingly, the section of f(x,y) defined by x is the
function $f_x$ defined on Ex given by $f_x(y)=f(x,y)$.
</p>
<p><code>section_fun</code> is a wrapper for calling <code>set_default</code> (default
method), <code>section_fun_env</code> or <code>section_fun_sub</code>. Notice that
creating a sectioned function with <code>section_fun_sub</code> can be
time consuming.
</p>


<h3>Value</h3>

<p>A new function: The input function <code>fun</code> but with certain
arguments fixed at specific values.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a> based on code
adapted from the curry package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bquote_fun_list">bquote_fun_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f  &lt;- function(x, y){x + y}

f_ &lt;- section_fun(f, list(y = 10),    method="args") ## "def"" is default
f_ &lt;- section_fun(f, nms="y", vls=10, method="args") ## SAME AS ABOVE
f_
f_(x=1)

f_ &lt;- section_fun(f, list(y = 10),    method="body") ## 
f_ &lt;- section_fun(f, nms="y", vls=10, method="body") ## SAME AS ABOVE
f_
f_(x=1)

f_ &lt;- section_fun(f, list(y = 10),    method="env")
f_ &lt;- section_fun(f, nms="y", vls=10, method="env") ## SAME AS ABOVE
f_
f_(x=1)
get_section(f_)
get_fun(f_)

 
## With more complicated values:
g &lt;- function(A, B) {
  A + B
}
g_ &lt;- section_fun(g, list(A = matrix(1:4, nrow=2)))
g_ &lt;- section_fun(g, "A", list(matrix(1:4, nrow=2)))
g_(diag(1, 2))

g_ &lt;- section_fun(g, list(A = matrix(1:4, nrow=2)))

## Using built in function
set.seed(123)
rnorm5 &lt;- section_fun(rnorm, list(n=5)) 
rnorm5(0, 1)

set.seed(123)
rnorm(5)


</code></pre>

<hr>
<h2 id='set_list_set_matrix'>Matrix representatation of list of vectors and vice versa</h2><span id='topic+set_list_set_matrix'></span><span id='topic+set_list2matrix'></span><span id='topic+matrix2set_list'></span>

<h3>Description</h3>

<p>Matrix representatation of list of vectors and vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_list2matrix(set_list, aggregate = FALSE)

matrix2set_list(set_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_list_set_matrix_+3A_set_list">set_list</code></td>
<td>
<p>list of vectors</p>
</td></tr>
<tr><td><code id="set_list_set_matrix_+3A_aggregate">aggregate</code></td>
<td>
<p>should the vectors be aggregated</p>
</td></tr>
<tr><td><code id="set_list_set_matrix_+3A_set_matrix">set_matrix</code></td>
<td>
<p>matrix representatation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(c(1,2,3), c(3,2,4), c(3,2,4))
m1 &lt;- set_list2matrix(l)
m1
matrix2set_list(m1)

m2 &lt;- set_list2matrix(l, aggregate=TRUE)
m2
matrix2set_list(m2)


</code></pre>

<hr>
<h2 id='split_byrow_bycol'>Split matrix or dataframe into list</h2><span id='topic+split_byrow_bycol'></span><span id='topic+split_bycol'></span><span id='topic+split_byrow'></span>

<h3>Description</h3>

<p>Split matrix or dataframe into list by columns or by rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_bycol(x, idx = NULL, as.list = FALSE)

split_byrow(x, idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_byrow_bycol_+3A_x">x</code></td>
<td>
<p>Matrix or dataframe.</p>
</td></tr>
<tr><td><code id="split_byrow_bycol_+3A_idx">idx</code></td>
<td>
<p>Index to split by. If NULL, split by columns or rows.</p>
</td></tr>
<tr><td><code id="split_byrow_bycol_+3A_as.list">as.list</code></td>
<td>
<p>If TRUE, return list of dataframes. If FALSE, return list of matrices.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- mtcars[1:3, 1:6]
x  |&gt; split_bycol()
x  |&gt; split_bycol(as.list=TRUE)
x  |&gt; split_bycol(as.list=FALSE)
x  |&gt; split_bycol(idx=c(1,1,1,2,2,3,3,3))
## x  |&gt; split_bycol(idx=c(1,1,7,2,2,3,3,3)) ## Gives error

x &lt;- mtcars[1:6, 1:6]
x  |&gt; split_byrow()
x  |&gt; split_byrow(idx=c(1,1,2,2))

m &lt;- as.matrix(x)
u &lt;- x |&gt; split_byrow(idx=c(1,1,2,2))
y &lt;- m |&gt; split_byrow(idx=c(1,1,2,2))

</code></pre>

<hr>
<h2 id='sub_seq'>Find sub-sequences of identical elements in a vector.</h2><span id='topic+sub_seq'></span><span id='topic+subSeq'></span><span id='topic+is_grouped'></span><span id='topic+rle2'></span>

<h3>Description</h3>

<p>Find sub-sequences of identical elements in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subSeq(x, item = NULL)

sub_seq(x, item = NULL)

is_grouped(x)

rle2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sub_seq_+3A_x">x</code></td>
<td>
<p>An atomic vector or a factor.</p>
</td></tr>
<tr><td><code id="sub_seq_+3A_item">item</code></td>
<td>
<p>Optionally a specific value to look for in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>sub_seq</code> is synonymous with <code>subSeq</code>
</p>
</li>
<li> <p><code>rle2</code> is identical to <code>rle</code> (from base) but <code>rle2</code> works on
factors as input (a factor is coerced to character).
</p>
</li>
<li> <p><code>is_grouped</code> checks if the values in <code>x</code> are clustered into the
smallest number of clusters.
</p>
</li></ul>



<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rle">rle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 1, 1, 0, 0, 1, 1, 1, 2, 2, 2, 1, 2, 2, 2, 3)
(ans &lt;- subSeq(x))
ans$value

## Notice: Same results below
subSeq(x, item=1)
subSeq(x, item="1")

xc &lt;- as.character(x)
(ans&lt;-subSeq(xc))
ans$value

## Notice: Same results below
subSeq(xc, item="1")
subSeq(xc, item=1)

is_grouped(x)
is_grouped(sort(x))
is_grouped(xc)
is_grouped(sort(xc))
</code></pre>

<hr>
<h2 id='taylor'>Taylor expansion (one dimension)</h2><span id='topic+taylor'></span>

<h3>Description</h3>

<p>Returns Taylor polynomial approximating a function fn(x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taylor(fn, x0, ord = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taylor_+3A_fn">fn</code></td>
<td>
<p>A function of one variable and that variable must be named 'x'.</p>
</td></tr>
<tr><td><code id="taylor_+3A_x0">x0</code></td>
<td>
<p>The point in which to to the Taylor expansion.</p>
</td></tr>
<tr><td><code id="taylor_+3A_ord">ord</code></td>
<td>
<p>The order of the Taylor expansion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function(x) log(x)
ord &lt;- 2
x0 &lt;- 2

xv  &lt;- seq(.2, 5, .1)
plot(xv, fn(xv), type="l")
lines(xv, taylor(fn, x0=x0, ord=ord)(xv), lty=2)
abline(v=x0)

fn &lt;- function(x)sin(x)
ord &lt;- 4
x0 &lt;- 0
xv &lt;- seq(-2*pi, 2*pi, 0.1)
plot(xv, fn(xv), type="l")
lines(xv, taylor(fn, x0=x0, ord=ord)(xv), lty=2)
abline(v=x0)



</code></pre>

<hr>
<h2 id='tidy-esticon'>Tidy an esticon object</h2><span id='topic+tidy-esticon'></span><span id='topic+tidy.esticon_class'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esticon_class'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy-esticon_+3A_x">x</code></td>
<td>
<p>A 'esticon_class' object (produced by <code>esticon</code> methods).</p>
</td></tr>
<tr><td><code id="tidy-esticon_+3A_conf.int">conf.int</code></td>
<td>
<p>Should confidence intervals be added.</p>
</td></tr>
<tr><td><code id="tidy-esticon_+3A_conf.level">conf.level</code></td>
<td>
<p>Desired confidence level.</p>
</td></tr>
<tr><td><code id="tidy-esticon_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='tidy-linest'>Tidy a linest object</h2><span id='topic+tidy-linest'></span><span id='topic+tidy.linest_class'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linest_class'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy-linest_+3A_x">x</code></td>
<td>
<p>A 'linest_class' object (produced by <code>linest</code> methods).</p>
</td></tr>
<tr><td><code id="tidy-linest_+3A_conf.int">conf.int</code></td>
<td>
<p>Should confidence intervals be added.</p>
</td></tr>
<tr><td><code id="tidy-linest_+3A_conf.level">conf.level</code></td>
<td>
<p>Desired confidence level.</p>
</td></tr>
<tr><td><code id="tidy-linest_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='timeSinceEvent'>Calculate &quot;time since event&quot; in a vector.</h2><span id='topic+timeSinceEvent'></span>

<h3>Description</h3>

<p>Calculate &quot;time since event&quot; in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeSinceEvent(yvar, tvar = seq_along(yvar))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeSinceEvent_+3A_yvar">yvar</code></td>
<td>
<p>A numerical or logical vector specifying the events</p>
</td></tr>
<tr><td><code id="timeSinceEvent_+3A_tvar">tvar</code></td>
<td>
<p>An optional vector specifying time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Events are coded as 1 in numeric vector (and non-events are
coded with values different from 1). <code>timeSinceEvent</code> will give the
time since event (with and without sign). In a logical vector, events are
coded as TRUE and all non-events as FALSE.
</p>


<h3>Value</h3>

<p>A dataframe with columns 'yvar', 'tvar', 'abs.tse' (absolute time
since nearest event), 'sign.tse' (signed time since nearest event) and
'run' (indicator of the time window around each event).
</p>


<h3>Note</h3>

<p>NA's in yvar are converted to zeros.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subSeq">subSeq</a></code>, <code><a href="base.html#topic+rle">rle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Events:
yvar &lt;- c(0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,
          0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0)

## Plot results:
tse &lt;- timeSinceEvent(yvar)
plot(sign.tse ~ tvar, data=tse, type="b")
grid()
rug(tse$tvar[tse$yvar==1], col=4, lwd=4)
points(scale(tse$run), col=tse$run, lwd=2)
lines(abs.tse + .2 ~ tvar, data=tse, type="b", col=3)

## Find times for which time since an event is at most 1:
tse$tvar[tse$abs &lt;= 1]

yvar &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
)

tvar &lt;- c(207, 208, 208, 208, 209, 209, 209, 209, 210, 210, 211, 211, 
211, 212, 213, 213, 214, 214, 215, 216, 216, 216, 216, 217, 217, 
217, 218, 218, 219, 219, 219, 219, 220, 220, 221, 221, 221, 221, 
222, 222, 222)

timeSinceEvent(yvar, tvar)



</code></pre>

<hr>
<h2 id='truncate0'>Truncate values in a matrix / vector to zero if they are below a certain threshold.</h2><span id='topic+truncate0'></span>

<h3>Description</h3>

<p>Truncate values in a matrix / vector to zero if they are below a certain threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncate0(x, tol = 0.6, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncate0_+3A_x">x</code></td>
<td>
<p>matrix / vector</p>
</td></tr>
<tr><td><code id="truncate0_+3A_tol">tol</code></td>
<td>
<p>threshold</p>
</td></tr>
<tr><td><code id="truncate0_+3A_sparse">sparse</code></td>
<td>
<p>logical; if TRUE and <code>x</code> is a matrix, return a sparse matrix</p>
</td></tr>
</table>

<hr>
<h2 id='which.maxn'>Where are the n largest or n smallest elements in a numeric vector ?</h2><span id='topic+which.maxn'></span><span id='topic+which.minn'></span>

<h3>Description</h3>

<p>Determines the locations, i.e., indices of the n largest or n smallest
elements of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.maxn(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.maxn_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="which.maxn_+3A_n">n</code></td>
<td>
<p>integer &gt;= 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length at most n with the indices of the n largest /
smaller elements. NAs are discarded and that can cause the vector to be
smaller than n.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which.max">which.max</a></code>, <code><a href="base.html#topic+which.min">which.min</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1:4, 0:5, 11, NA, NA)
ii &lt;- which.minn(x, 5)

x &lt;- c(1, rep(NA,10), 2)
ii &lt;- which.minn(x, 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
