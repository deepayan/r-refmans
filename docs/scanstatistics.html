<!DOCTYPE html><html><head><title>Help for package scanstatistics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scanstatistics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#closest_subsets'><p>Set of increasing sets from left to right of input vector.</p></a></li>
<li><a href='#connected_neighbors'><p>Find the connected sets for a location and its <code class="reqn">k</code> nearest neighbors.</p></a></li>
<li><a href='#connected_to'><p>Return those elements in the second set which are connected to those in the</p>
first.</a></li>
<li><a href='#coords_to_knn'><p>Get the k nearest neighbors for each location, given its coordinates.</p></a></li>
<li><a href='#df_to_matrix'><p>Convert a long data frame to a wide matrix.</p></a></li>
<li><a href='#dist_to_knn'><p>Given a distance matrix, find the <code class="reqn">k</code> nearest neighbors.</p></a></li>
<li><a href='#estimate_baselines'><p>Estimate baselines based on observed counts.</p></a></li>
<li><a href='#estimate_variances'><p>Estimate variances based on observed counts.</p></a></li>
<li><a href='#estimate_zip_params'><p>Estimate the parameters of a ZIP distribution.</p></a></li>
<li><a href='#flexible_zones'><p>Computes the flexibly shaped zones as in Tango (2005).</p></a></li>
<li><a href='#flipud'><p>Flip a matrix upside down</p></a></li>
<li><a href='#get_zero_indices'><p>Get indices of zero elements in a vector.</p></a></li>
<li><a href='#get_zone'><p>Extract a zone from the set of all zones.</p></a></li>
<li><a href='#gumbel_pvalue'><p>Calculate the Gumbel <code class="reqn">p</code>-value for a scan statistic.</p></a></li>
<li><a href='#has_converged'><p>Is the relative error between two numbers is less than the given tolerance?</p></a></li>
<li><a href='#if_connected'><p>Return a set of the location and its neighbors if they are connected,</p>
else return the empty set.</a></li>
<li><a href='#is_connected'><p>Returns TRUE if the neighboring locations are connected to the given</p>
location, FALSE if not.</a></li>
<li><a href='#knn_zones'><p>Find the increasing subsets of <code class="reqn">k</code> nearest neighbors for all locations.</p></a></li>
<li><a href='#matrix_to_df'><p>Convert a matrix to a data frame.</p></a></li>
<li><a href='#mc_pvalue'><p>Calculate the Monte Carlo <code class="reqn">p</code>-value for a scan statistic.</p></a></li>
<li><a href='#NM_geo'><p>Longitude and latitude of New Mexico county seats.</p></a></li>
<li><a href='#NM_map'><p>Data to plot the counties of New Mexico.</p></a></li>
<li><a href='#NM_popcas'><p>Population and brain cancer cases in New Mexico counties during 1973&ndash;1991.</p></a></li>
<li><a href='#permute_matrix'><p>Permute the entries of the matrix, preserving row and column marginals.</p></a></li>
<li><a href='#powerset_zones'><p>Creates a set of all non-empty subsets of the integers from 1 to <code class="reqn">n</code>.</p></a></li>
<li><a href='#print.scanstatistic'><p>Print a scanstatistic object.</p></a></li>
<li><a href='#run_scan'><p>Run a scan statistic analysis.</p></a></li>
<li><a href='#scan_bayes_negbin'><p>Calculate the negative binomial bayesian scan statistic..</p></a></li>
<li><a href='#scan_bayes_negbin_cpp'><p>Calculate the &quot;Bayesian Spatial Scan Statistic&quot; by Neill et al. (2006).</p></a></li>
<li><a href='#scan_eb_negbin'><p>Calculate the expectation-based negative binomial scan statistic.</p></a></li>
<li><a href='#scan_eb_negbin_cpp'><p>Calculate the expectation-based negative binomial scan statistic.</p></a></li>
<li><a href='#scan_eb_poisson'><p>Calculate the expectation-based Poisson scan statistic.</p></a></li>
<li><a href='#scan_eb_poisson_cpp'><p>Calculate the expecation-based Poisson scan statistic.</p></a></li>
<li><a href='#scan_eb_zip'><p>Calculate the expectation-based ZIP scan statistic.</p></a></li>
<li><a href='#scan_eb_zip_cpp'><p>Calculate the highest-value EB ZIP loglihood ratio statistic.</p></a></li>
<li><a href='#scan_pb_perm_cpp'><p>Calculate the space-time permutation scan statistic.</p></a></li>
<li><a href='#scan_pb_poisson'><p>Calculate the population-based Poisson scan statistic.</p></a></li>
<li><a href='#scan_pb_poisson_cpp'><p>Calculate the population-based Poisson scan statistic.</p></a></li>
<li><a href='#scan_permutation'><p>Calculate the space-time permutation scan statistic.</p></a></li>
<li><a href='#scanstatistics'><p>scanstatistics: Space-time anomaly detection using scan statistics.</p></a></li>
<li><a href='#score_locations'><p>Score each location over zones and duration.</p></a></li>
<li><a href='#top_clusters'><p>Get the top (non-overlappig) clusters.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Space-Time Anomaly Detection using Scan Statistics</td>
</tr>
<tr>
<td>Description:</td>
<td>Detection of anomalous space-time clusters using the scan 
  statistics methodology. Focuses on prospective surveillance of data streams, 
  scanning for clusters with ongoing anomalies. Hypothesis testing is made 
  possible by Monte Carlo simulation. Allévius (2018) &lt;<a href="https://doi.org/10.21105%2Fjoss.00515">doi:10.21105/joss.00515</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-25</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/promerpr/scanstatistics">https://github.com/promerpr/scanstatistics</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/promerpr/scanstatistics/issues">https://github.com/promerpr/scanstatistics/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ismev, magrittr, plyr, Rcpp, stats, sets, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>purrr, doParallel, foreach, ggplot2, knitr, MASS, pscl,
reshape2, rmarkdown, sp, testthat, gamlss.dist</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-25 19:57:56 UTC; promerpr</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Allévius [aut],
  Paul Romer Present [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Romer Present &lt;paul.romerpresent@fastmail.fm&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-26 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='closest_subsets'>Set of increasing sets from left to right of input vector.</h2><span id='topic+closest_subsets'></span>

<h3>Description</h3>

<p>Returns a set (list) of the increasing sets (integer vectors) of the input 
vector <code>v</code>, in the sense that the first set contains the first element 
of <code>v</code>, the second set the first and second elements of <code>v</code>, and so 
on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_subsets(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_subsets_+3A_v">v</code></td>
<td>
<p>An integer vector. Meant to represent the <code class="reqn">k</code> nearest neighbors
of a location, the first element being the integer identifier of the 
location itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as the input. The first element of the list
is v[1], the second is sort(v[1:2]), the third sort(v[1:3]), and so on.
</p>

<hr>
<h2 id='connected_neighbors'>Find the connected sets for a location and its <code class="reqn">k</code> nearest neighbors.</h2><span id='topic+connected_neighbors'></span>

<h3>Description</h3>

<p>Returns a <code>set</code> of <code>set</code>s, each set of the latter type containing
the location itself and zero or more of its neighbors, if they are connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connected_neighbors(neighbors, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected_neighbors_+3A_neighbors">neighbors</code></td>
<td>
<p>A vector of neighbors to a location, the first element
of the vector being the specific location, and the other elements its 
other nearest neighbors. Locations should be encoded as integers.</p>
</td></tr>
<tr><td><code id="connected_neighbors_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>A boolean matrix, with element <code class="reqn">(i,j)</code> set 
to TRUE if location <code class="reqn">j</code> is adjacent to location <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>set</code> of <code>set</code>s, each set of the latter type 
containing the location itself and zero or more of its neighbors, if they 
are connected.
</p>

<hr>
<h2 id='connected_to'>Return those elements in the second set which are connected to those in the
first.</h2><span id='topic+connected_to'></span>

<h3>Description</h3>

<p>Return those elements in the second set <code class="reqn">Z_1</code> which are connected to 
those in the first set <code class="reqn">Z_0</code>, according to the adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connected_to(Z_0, Z_1, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected_to_+3A_z_0">Z_0</code></td>
<td>
<p>A set of locations, given as integers.</p>
</td></tr>
<tr><td><code id="connected_to_+3A_z_1">Z_1</code></td>
<td>
<p>A set of locations, given as integers.</p>
</td></tr>
<tr><td><code id="connected_to_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>A boolean matrix, with element <code class="reqn">(i,j)</code> set 
to TRUE if location <code class="reqn">j</code> is adjacent to location <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set, possibly empty, containing those locations in <code class="reqn">Z_1</code>
that are connected to any of the locations in <code class="reqn">Z_0</code>.
</p>

<hr>
<h2 id='coords_to_knn'>Get the k nearest neighbors for each location, given its coordinates.</h2><span id='topic+coords_to_knn'></span>

<h3>Description</h3>

<p>Get the k nearest neighbors for each location, including the location itself.
This function calls <code><a href="stats.html#topic+dist">dist</a></code>, so the options for the 
distance measure used is the same as for that one. Distances are calculated 
between rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords_to_knn(x, k = min(10, nrow(x)), method = "euclidean", p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_to_knn_+3A_x">x</code></td>
<td>
<p>a numeric matrix, data frame or <code>"dist"</code> object.</p>
</td></tr>
<tr><td><code id="coords_to_knn_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbors, counting the location itself.</p>
</td></tr>
<tr><td><code id="coords_to_knn_+3A_method">method</code></td>
<td>
<p>the distance measure to be used.  This must be one of
<code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, <code>"binary"</code> or <code>"minkowski"</code>.
Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="coords_to_knn_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix of the <code class="reqn">k</code> nearest neighbors for each location. 
Each row corresponds to a location, with the first element of each row 
being the location itself. Locations are encoded as integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(0, 0,
              1, 0,
              2, 1,
              0, 4,
              1, 3),
            ncol = 2, byrow = TRUE)
plot(x)
coords_to_knn(x)
</code></pre>

<hr>
<h2 id='df_to_matrix'>Convert a long data frame to a wide matrix.</h2><span id='topic+df_to_matrix'></span>

<h3>Description</h3>

<p>Convert a long data frame to a wide matrix, with time along the row dimension
and locations along the column dimension. Values in the matrix could be e.g.
the observed counts or the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_matrix(df, time_col = 1, location_col = 2, value_col = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_to_matrix_+3A_df">df</code></td>
<td>
<p>A data frame with at least 3 columns.</p>
</td></tr>
<tr><td><code id="df_to_matrix_+3A_time_col">time_col</code></td>
<td>
<p>Integer or string that specifies the time column.</p>
</td></tr>
<tr><td><code id="df_to_matrix_+3A_location_col">location_col</code></td>
<td>
<p>Integer or string that specifies the location column.</p>
</td></tr>
<tr><td><code id="df_to_matrix_+3A_value_col">value_col</code></td>
<td>
<p>Integer or string that specifies the value column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with time on rows and locations on columns.
</p>

<hr>
<h2 id='dist_to_knn'>Given a distance matrix, find the <code class="reqn">k</code> nearest neighbors.</h2><span id='topic+dist_to_knn'></span>

<h3>Description</h3>

<p>Given a distance matrix, calculate the <code class="reqn">k</code> nearest neighbors of each 
location, including the location itself. The matrix should contain only zeros 
on the diagonal, and all other elements should be positive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_to_knn(x, k = min(10, nrow(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_to_knn_+3A_x">x</code></td>
<td>
<p>A (square) distance matrix. Elements should be non-negative and the 
diagonal zeros, but this is not checked.</p>
</td></tr>
<tr><td><code id="dist_to_knn_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbors, counting the location itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of integers, row <code class="reqn">i</code> containing the <code class="reqn">k</code> nearest 
neighbors of location <code class="reqn">i</code>, including itself.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(0, 0,
              1, 0,
              2, 1,
              0, 4,
              1, 3),
            ncol = 2, byrow = TRUE)
d &lt;- dist(x, diag = TRUE, upper = TRUE)
dist_to_knn(d, k = 3)
</code></pre>

<hr>
<h2 id='estimate_baselines'>Estimate baselines based on observed counts.</h2><span id='topic+estimate_baselines'></span>

<h3>Description</h3>

<p>Estimate the baselines (expected values) for the supplied counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_baselines(counts, population = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_baselines_+3A_counts">counts</code></td>
<td>
<p>A matrix of observed counts. Rows indicate time (ordered from 
most recent) and columns indicate locations.</p>
</td></tr>
<tr><td><code id="estimate_baselines_+3A_population">population</code></td>
<td>
<p>A matrix or vector of populations for each location 
(optional). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of
columns in <code>counts</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of baselines of the same dimensions as <code>counts</code>.
</p>

<hr>
<h2 id='estimate_variances'>Estimate variances based on observed counts.</h2><span id='topic+estimate_variances'></span>

<h3>Description</h3>

<p>Estimate the variances for the supplied counts. It is assumed that variances
are constant over time for each location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_variances(
  counts,
  baselines = NULL,
  population = NULL,
  constant_dim = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_variances_+3A_counts">counts</code></td>
<td>
<p>A matrix of observed counts. Rows indicate time (ordered from 
most recent) and columns indicate locations.</p>
</td></tr>
<tr><td><code id="estimate_variances_+3A_baselines">baselines</code></td>
<td>
<p>A matrix of the same dimensions as <code>counts</code> (optional).</p>
</td></tr>
<tr><td><code id="estimate_variances_+3A_population">population</code></td>
<td>
<p>A matrix or vector of populations for each location 
(optional). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of
columns in <code>counts</code>.</p>
</td></tr>
<tr><td><code id="estimate_variances_+3A_constant_dim">constant_dim</code></td>
<td>
<p>An integer. If equal to 1, variances are assumed to be
constant over time but different between locations. If equal to 2, 
variances are assumed to vary over time but at each time point be equal 
for all locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of variances of the same dimensions as <code>counts</code>.
</p>

<hr>
<h2 id='estimate_zip_params'>Estimate the parameters of a ZIP distribution.</h2><span id='topic+estimate_zip_params'></span>

<h3>Description</h3>

<p>Heuristically estimate the ZIP distribution Poisson mean parameters and the 
structural zero probabilities for each location and time point. Assumes the 
structural zero probability is constant over time for each location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_zip_params(counts, population = NULL, min_p = 0.001, min_mu = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_zip_params_+3A_counts">counts</code></td>
<td>
<p>A matrix or vector of observed counts. Rows indicate time 
(ordered from most recent) and columns indicate locations. If a vector,
the elements are assumed to be the counts for each location.</p>
</td></tr>
<tr><td><code id="estimate_zip_params_+3A_population">population</code></td>
<td>
<p>A matrix or vector of populations for each location 
(optional). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of
columns in <code>counts</code>.</p>
</td></tr>
<tr><td><code id="estimate_zip_params_+3A_min_p">min_p</code></td>
<td>
<p>The minimum value you think possible for the structural zero
probability.</p>
</td></tr>
<tr><td><code id="estimate_zip_params_+3A_min_mu">min_mu</code></td>
<td>
<p>The mimum value you think possible for the Poisson mean 
parameter of the ZIP distribution (before adjusting for population size).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<dl>
<dt>baselines</dt><dd><p>A matrix of the same dimensions as <code>counts</code>.
If <code>counts</code> was a vector, a matrix with 1 row will
be returned.</p>
</dd>
<dt>probs</dt><dd><p>A matrix of the same dimensions as <code>counts</code>. If 
<code>counts</code> was a vector, a matrix with 1 row will be
returned.</p>
</dd>
</dl>


<hr>
<h2 id='flexible_zones'>Computes the flexibly shaped zones as in Tango (2005).</h2><span id='topic+flexible_zones'></span>

<h3>Description</h3>

<p>Given a matrix of <code class="reqn">k</code> nearest neighbors and an adjacency matrix
for the locations involved, produces the set of flexibly shaped zones
as a list of integer vectors. The locations in these zones are all connected, 
in the sense that any location in the zone can be reached from another by 
traveling through adjacent locations within the zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexible_zones(k_nearest, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexible_zones_+3A_k_nearest">k_nearest</code></td>
<td>
<p>An integer matrix of the <code class="reqn">k</code> nearest neighbors for each 
location. Each row corresponds to a location, with the first element of 
each row being the location itself. Locations should be encoded as 
integers.</p>
</td></tr>
<tr><td><code id="flexible_zones_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>A boolean matrix, with element <code class="reqn">(i,j)</code> set 
to TRUE if location <code class="reqn">j</code> is adjacent to location <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of integer vectors.
</p>


<h3>References</h3>

<p>Tango, T. &amp; Takahashi, K. (2005), <em>A flexibly shaped spatial scan 
statistic for detecting clusters</em>, International Journal of Health 
Geographics 4(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(0,1,0,0,0,0,
              1,0,1,0,0,0,
              0,1,0,0,0,0,
              0,0,0,0,1,0,
              0,0,0,1,0,0,
              0,0,0,0,0,0), 
              nrow = 6, byrow = TRUE) == 1
nn &lt;- matrix(as.integer(c(1,2,3,4,5,6,
                          2,1,3,4,5,6,
                          3,2,1,4,5,6,
                          4,5,1,6,3,2,
                          5,4,6,1,3,2,
                          6,5,4,1,3,2)),
                          nrow = 6, byrow = TRUE)
flexible_zones(nn, A)
</code></pre>

<hr>
<h2 id='flipud'>Flip a matrix upside down</h2><span id='topic+flipud'></span>

<h3>Description</h3>

<p>Flip a matrix upside down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipud_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, <code>x</code> with rows reversed.
</p>

<hr>
<h2 id='get_zero_indices'>Get indices of zero elements in a vector.</h2><span id='topic+get_zero_indices'></span>

<h3>Description</h3>

<p>Get indices of zero elements in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_zero_indices(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_zero_indices_+3A_v">v</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the indices of elements equal to zero in <code>v</code>.
Indices start at zero.
</p>

<hr>
<h2 id='get_zone'>Extract a zone from the set of all zones.</h2><span id='topic+get_zone'></span>

<h3>Description</h3>

<p>Extract zone number <code class="reqn">n</code> from the set of all zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_zone(n, zones)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_zone_+3A_n">n</code></td>
<td>
<p>An integer; the number of the zone you wish to retrieve.</p>
</td></tr>
<tr><td><code id="get_zone_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors, representing the set of all zones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zones &lt;- list(1L, 2L, 3L, 1:2, c(1L, 3L), c(2L, 3L))
get_zone(4, zones)
</code></pre>

<hr>
<h2 id='gumbel_pvalue'>Calculate the Gumbel <code class="reqn">p</code>-value for a scan statistic.</h2><span id='topic+gumbel_pvalue'></span>

<h3>Description</h3>

<p>Given an observed scan statistic <code class="reqn">\lambda^*</code> and a vector of replicate 
scan statistics <code class="reqn">\lambda_i</code>, <code class="reqn">i=1,\ldots,R</code>, fit a Gumbel 
distribution to the replicates and calculate a <code class="reqn">p</code>-value for the observed
statistic based on the fitted distribution.
</p>
<p style="text-align: center;"><code class="reqn">
 \frac{1 + \sum_{i=1}^R \mathrm{I}(\lambda_i &gt; \lambda^*)}{1 + R}
</code>
</p>

<p>The function is vectorized, so multiple <code class="reqn">p</code>-values can be calculated if
several scan statistics (e.g. statistics from secondary clusters) are 
supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gumbel_pvalue(observed, replicates, method = "ML", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gumbel_pvalue_+3A_observed">observed</code></td>
<td>
<p>A scalar containing the observed value of the scan statistic,
or a vector of observed values from secondary clusters.</p>
</td></tr>
<tr><td><code id="gumbel_pvalue_+3A_replicates">replicates</code></td>
<td>
<p>A vector of Monte Carlo replicates of the scan statistic.</p>
</td></tr>
<tr><td><code id="gumbel_pvalue_+3A_method">method</code></td>
<td>
<p>Either &quot;ML&quot;, for maximum likelihood, or &quot;MoM&quot;, for method of 
moments.</p>
</td></tr>
<tr><td><code id="gumbel_pvalue_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>ismev::gum.fit</code>, which 
may include arguments passed along further to <code>optim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">p</code>-value or <code class="reqn">p</code>-values corresponding to the observed 
scan statistic(s).
</p>

<hr>
<h2 id='has_converged'>Is the relative error between two numbers is less than the given tolerance?</h2><span id='topic+has_converged'></span>

<h3>Description</h3>

<p>Given two consecutive numbers in a sequence, return <code>TRUE</code> if the
relative change is positive but less than the given tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_converged(current, previous, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_converged_+3A_current">current</code></td>
<td>
<p>A scalar; the most recent value of the sequence.</p>
</td></tr>
<tr><td><code id="has_converged_+3A_previous">previous</code></td>
<td>
<p>A scalar; the second most recent value of the sequence, or a
reference value.</p>
</td></tr>
<tr><td><code id="has_converged_+3A_tol">tol</code></td>
<td>
<p>The tolerance, a positive scalar near zero.</p>
</td></tr>
</table>

<hr>
<h2 id='if_connected'>Return a set of the location and its neighbors if they are connected,
else return the empty set.</h2><span id='topic+if_connected'></span>

<h3>Description</h3>

<p>If the location and its neighbors, not including itself, are connected,
then return the set containing the location and its neighbors;
otherwise, return the empty set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_connected(distinct_neighbors, location, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_connected_+3A_distinct_neighbors">distinct_neighbors</code></td>
<td>
<p>A <code>set</code> containing the neighboring locations
to the given location, not including the location itself.</p>
</td></tr>
<tr><td><code id="if_connected_+3A_location">location</code></td>
<td>
<p>A location, preferably given as an integer.</p>
</td></tr>
<tr><td><code id="if_connected_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>A boolean matrix, with element <code class="reqn">(i,j)</code> set 
to TRUE if location <code class="reqn">j</code> is adjacent to location <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>set</code> of the given location and the neighbors if they are
connected, else returns the empty set.
</p>

<hr>
<h2 id='is_connected'>Returns TRUE if the neighboring locations are connected to the given 
location, FALSE if not.</h2><span id='topic+is_connected'></span>

<h3>Description</h3>

<p>Returns TRUE if the neighboring locations are connected to the given 
location, FALSE if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_connected(neighbor_locations, location, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_connected_+3A_neighbor_locations">neighbor_locations</code></td>
<td>
<p>A <code>set</code> of neighboring locations to the given
location; these neighbors do not include the given location itself.</p>
</td></tr>
<tr><td><code id="is_connected_+3A_location">location</code></td>
<td>
<p>A location, preferably given as an integer.</p>
</td></tr>
<tr><td><code id="is_connected_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>A boolean matrix, with element <code class="reqn">(i,j)</code> set 
to TRUE if location <code class="reqn">j</code> is adjacent to location <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean: is the neighbors connected to the given location?
</p>

<hr>
<h2 id='knn_zones'>Find the increasing subsets of <code class="reqn">k</code> nearest neighbors for all locations.</h2><span id='topic+knn_zones'></span>

<h3>Description</h3>

<p>Returns the set of increasing nearest neighbor sets for all locations, as
a list of integer vectors. That is, for each location the list returned 
contains one vector containing the location itself, another containing the 
location and its nearest neighbor, and so on, up to the vector containing the 
location and its <code class="reqn">k-1</code> nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_zones(k_nearest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_zones_+3A_k_nearest">k_nearest</code></td>
<td>
<p>An integer matrix of with <code class="reqn">k</code> columns and as many rows
as locations. The first element of each row is the integer encoding the
location (and equal to the row number); the following elements are the 
<code class="reqn">k-1</code> nearest neighbors in ascending order of distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of integer vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nn &lt;- matrix(c(1L, 2L, 4L, 3L, 5L,
               2L, 1L, 3L, 4L, 5L, 
               3L, 2L, 4L, 1L, 5L,
               4L, 1L, 2L, 3L, 5L,
               5L, 3L, 4L, 2L, 1L),
               ncol = 5, byrow = TRUE)
knn_zones(nn[, 1:3])
</code></pre>

<hr>
<h2 id='matrix_to_df'>Convert a matrix to a data frame.</h2><span id='topic+matrix_to_df'></span>

<h3>Description</h3>

<p>Convert a matrix to a data frame with columns time, location, and one more
containing the elements of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_df(mat, name, locations = NULL, times = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_df_+3A_mat">mat</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="matrix_to_df_+3A_name">name</code></td>
<td>
<p>The name of the third column in the output matrix.</p>
</td></tr>
<tr><td><code id="matrix_to_df_+3A_locations">locations</code></td>
<td>
<p>If not <code>NULL</code>, a vector with the names of the 
locations.</p>
</td></tr>
<tr><td><code id="matrix_to_df_+3A_times">times</code></td>
<td>
<p>If not <code>NULL</code>, a vector with the time points. If 
<code>NULL</code>, the matrix is assumed to be ordered with time point 1 in the 
first row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns <code>time, location, name</code>, where <code>name</code>
is specified in the input.
</p>

<hr>
<h2 id='mc_pvalue'>Calculate the Monte Carlo <code class="reqn">p</code>-value for a scan statistic.</h2><span id='topic+mc_pvalue'></span>

<h3>Description</h3>

<p>Given an observed scan statistic <code class="reqn">\lambda^*</code> and a vector of replicate 
scan statistics <code class="reqn">\lambda_i</code>, <code class="reqn">i=1,\ldots,R</code>, calculate the Monte 
Carlo <code class="reqn">p</code>-value as
</p>
<p style="text-align: center;"><code class="reqn">
 \frac{1 + \sum_{i=1}^R \mathrm{I}(\lambda_i &gt; \lambda^*)}{1 + R}
</code>
</p>

<p>The function is vectorized, so multiple <code class="reqn">p</code>-values can be calculated if
several scan statistics (e.g. statistics from secondary clusters) are 
supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_pvalue(observed, replicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_pvalue_+3A_observed">observed</code></td>
<td>
<p>A scalar containing the observed value of the scan statistic,
or a vector of observed values from secondary clusters.</p>
</td></tr>
<tr><td><code id="mc_pvalue_+3A_replicates">replicates</code></td>
<td>
<p>A vector of Monte Carlo replicates of the scan statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">p</code>-value or <code class="reqn">p</code>-values corresponding to the observed 
scan statistic(s).
</p>

<hr>
<h2 id='NM_geo'>Longitude and latitude of New Mexico county seats.</h2><span id='topic+NM_geo'></span>

<h3>Description</h3>

<p>A dataset containing the longitude and latitude of the county seats of New
Mexico, except for Cibola county.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NM_geo
</code></pre>


<h3>Format</h3>

<p>A data frame with 33 rows and 7 variables:
</p>

<dl>
<dt>county</dt><dd><p>Factor; the counties of New Mexico (no spaces).</p>
</dd>
<dt>seat</dt><dd><p>Character; the name of the county seat, i.e. the administrative 
center or seat of government.</p>
</dd>
<dt>area(km2)</dt><dd><p>Numeric; the area in square kilometers of each county.</p>
</dd>
<dt>seat_long</dt><dd><p>Numeric; the longitude of the county seat.</p>
</dd>
<dt>seat_lat</dt><dd><p>Numeric; the latitude of the county seat.</p>
</dd>
<dt>center_long</dt><dd><p>Numeric; the longitude of the geographical center of
the county.</p>
</dd>
<dt>center_lat</dt><dd><p>Numeric; the latitude of the geographical center of the 
county.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/List_of_counties_in_New_Mexico">https://en.wikipedia.org/wiki/List_of_counties_in_New_Mexico</a>
</p>

<hr>
<h2 id='NM_map'>Data to plot the counties of New Mexico.</h2><span id='topic+NM_map'></span>

<h3>Description</h3>

<p>Map data for New Mexico. Was created using <code>ggplot2::map_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NM_map
</code></pre>


<h3>Format</h3>

<p>A data frame with 867 rows and 7 variables:
</p>

<dl>
<dt>long</dt><dd><p>Numeric; longitude of county polygon corner.</p>
</dd>
<dt>lat</dt><dd><p>Numeric; latitude of county polygon corner.</p>
</dd>
<dt>group</dt><dd><p>Numeric; grouping by county.</p>
</dd>
<dt>order</dt><dd><p>Numeric; order of the polygon corners.</p>
</dd>
<dt>region</dt><dd><p>Character; region is &quot;new mexico&quot; for all rows.</p>
</dd>
<dt>subregion</dt><dd><p>Character; the county name (with spaces).</p>
</dd>
<dt>county</dt><dd><p>Factor; the county name (no spaces).</p>
</dd>
</dl>


<hr>
<h2 id='NM_popcas'>Population and brain cancer cases in New Mexico counties during 1973&ndash;1991.</h2><span id='topic+NM_popcas'></span>

<h3>Description</h3>

<p>A dataset containing the population count and number of brain cancer cases in 
the counties of New Mexico during the years 1973&ndash;1991. The population 
numbers are interpolations from the censuses conducted in 1973, 1982, and 
1991. Interpolations were done using a quadratic function of time. Thus the
year-to-year changes are overly smooth but match the census numbers in the 
three years mentioned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NM_popcas
</code></pre>


<h3>Format</h3>

<p>A data frame with 608 rows and 4 variables:
</p>

<dl>
<dt>year</dt><dd><p>Integer; the year the cases were recorded.</p>
</dd>
<dt>county</dt><dd><p>Character; the name of the county (no spaces).</p>
</dd>
<dt>population</dt><dd><p>Integer; the population in that county and year.</p>
</dd>
<dt>count</dt><dd><p>Integer; the number of brain cancer cases in that county and 
year.</p>
</dd>
</dl>


<hr>
<h2 id='permute_matrix'>Permute the entries of the matrix, preserving row and column marginals.</h2><span id='topic+permute_matrix'></span>

<h3>Description</h3>

<p>Permute the entries of the matrix, preserving row and column marginals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_matrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_matrix_+3A_a">A</code></td>
<td>
<p>An integer matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix.
</p>

<hr>
<h2 id='powerset_zones'>Creates a set of all non-empty subsets of the integers from 1 to <code class="reqn">n</code>.</h2><span id='topic+powerset_zones'></span>

<h3>Description</h3>

<p>Creates a list of all <code class="reqn">2^(n-1)</code> non-empty subsets of the integers from 1 
to <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerset_zones(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerset_zones_+3A_n">n</code></td>
<td>
<p>An integer larger than 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of integer vectors.
</p>

<hr>
<h2 id='print.scanstatistic'>Print a scanstatistic object.</h2><span id='topic+print.scanstatistic'></span>

<h3>Description</h3>

<p>Prints a scanstatistic object and returns it invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanstatistic'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scanstatistic_+3A_x">x</code></td>
<td>
<p>A an object of class <code>scanstatistic</code>.</p>
</td></tr>
<tr><td><code id="print.scanstatistic_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>

<hr>
<h2 id='run_scan'>Run a scan statistic analysis.</h2><span id='topic+run_scan'></span>

<h3>Description</h3>

<p>Run a scan statistic analysis with the given scan statistic and arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_scan(scanstat, args, gumbel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_scan_+3A_scanstat">scanstat</code></td>
<td>
<p>A scan statistic function.</p>
</td></tr>
<tr><td><code id="run_scan_+3A_args">args</code></td>
<td>
<p>A named list of arguments to be passed to <code>scanstat</code>.</p>
</td></tr>
<tr><td><code id="run_scan_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical: should a Gumbel P-value be calculated? Default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>observed</dt><dd><p>The table of observed statistics.</p>
</dd>
<dt>simulated</dt><dd><p>The table of simulated statistics.</p>
</dd>
<dt>MC_pvalue</dt><dd><p>The Monte Carlo P-value of the scan statistic.</p>
</dd>
<dt>Gumbel_pvalue</dt><dd><p>The Gumbel P-value of the scan statistic.</p>
</dd>
</dl>


<hr>
<h2 id='scan_bayes_negbin'>Calculate the negative binomial bayesian scan statistic..</h2><span id='topic+scan_bayes_negbin'></span>

<h3>Description</h3>

<p>Calculate the &quot;Bayesian Spatial Scan Statistic&quot; by Neill et al. (2006),
adapted to a spatio-temporal setting. The scan statistic assumes that,
given the relative risk, the data follows a Poisson distribution. The 
relative risk is in turn assigned a Gamma distribution prior, yielding a 
negative binomial marginal distribution for the counts under the null 
hypothesis. Under the alternative hypothesis, the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_bayes_negbin(
  counts,
  zones,
  baselines = NULL,
  population = NULL,
  outbreak_prob = 0.05,
  alpha_null = 1,
  beta_null = 1,
  alpha_alt = alpha_null,
  beta_alt = beta_null,
  inc_values = seq(1, 3, by = 0.1),
  inc_probs = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_bayes_negbin_+3A_counts">counts</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A matrix of observed counts. Rows indicate time and are ordered
from least recent (row 1) to most recent (row 
<code>nrow(counts)</code>). Columns indicate locations, numbered from 1 
and up. If <code>counts</code> is a matrix, the optional matrix argument
<code>baselines</code> should also be specified.
</p>
</li>
<li><p> A data frame with columns &quot;time&quot;, &quot;location&quot;, &quot;count&quot;, &quot;baseline&quot;.
Alternatively, the column &quot;baseline&quot; can be replaced by a column
&quot;population&quot;. The baselines are the expected values of the counts.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors. Each vector corresponds to a single
zone; its elements are the numbers of the locations in that zone.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_baselines">baselines</code></td>
<td>
<p>Optional. A matrix of the same dimensions as <code>counts</code>. 
Not needed if <code>counts</code> is a data frame. Holds the Poisson mean 
parameter for each observed count. Will be estimated if not supplied 
(requires the <code>population</code> argument). These parameters are typically 
estimated from past data using e.g. Poisson (GLM) regression.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_population">population</code></td>
<td>
<p>Optional. A matrix or vector of populations for each 
location. Not needed if <code>counts</code> is a data frame. If <code>counts</code> is
a matrix, <code>population</code> is only needed if <code>baselines</code> are to be 
estimated and you want to account for the different populations in each 
location (and time). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of 
columns in <code>counts</code>.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_outbreak_prob">outbreak_prob</code></td>
<td>
<p>A scalar; the probability of an outbreak (at any time,
any place). Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_alpha_null">alpha_null</code></td>
<td>
<p>A scalar; the shape parameter for the gamma distribution
under the null hypothesis of no anomaly. Defaults to 1.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_beta_null">beta_null</code></td>
<td>
<p>A scalar; the scale parameter for the gamma distribution
under the null hypothesis of no anomaly. Defaults to 1.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_alpha_alt">alpha_alt</code></td>
<td>
<p>A scalar; the shape parameter for the gamma distribution
under the alternative hypothesis of an anomaly. Defaults to the same value
as <code>alpha_null</code>.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_beta_alt">beta_alt</code></td>
<td>
<p>A scalar; the scale parameter for the gamma distribution
under the alternative hypothesis of an anomaly. Defaults to the same value
as <code>beta_null</code>.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_inc_values">inc_values</code></td>
<td>
<p>A vector of possible values for the increase in the mean
(and variance) of an anomalous count. Defaults to evenly spaced values 
between 1 and 3, with a difference of 0.1 between consecutive values.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_+3A_inc_probs">inc_probs</code></td>
<td>
<p>A vector of the prior probabilities of each value in 
<code>inc_values</code>. Defaults to 1, implying a discrete uniform 
distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which, in addition to the information about the type of scan
statistic, has the following components: <code>priors</code> (list), 
<code>posteriors</code> (list), <code>MLC</code> (list) and <code>marginal_data_prob</code> 
(scalar). The list <code>MLC</code> has elements
</p>

<dl>
<dt>zone</dt><dd><p>The number of the spatial zone of the most likely cluster 
(MLC).</p>
</dd>
<dt>duration</dt><dd><p>The most likely event duration.</p>
</dd>
<dt>log_posterior</dt><dd><p>The posterior log probability that an event is 
ongoing in the MLC.</p>
</dd>
<dt>log_bayes_factor</dt><dd><p>The logarithm of the Bayes factor for the MLC.</p>
</dd>
<dt>posterior</dt><dd><p>The posterior probability that an event is ongoing in 
the MLC.</p>
</dd>
<dt>locations</dt><dd><p>The locations involved in the MLC.</p>
</dd>
</dl>
    
<p>The list <code>priors</code> has elements
</p>

<dl>
<dt>null_prior</dt><dd><p>The prior probability of no anomaly.</p>
</dd>
<dt>alt_prior</dt><dd><p>The prior probability of an anomaly.</p>
</dd>
<dt>inc_prior</dt><dd><p>A vectorof prior probabilities of each value in the 
argument <code>inc_values</code>.</p>
</dd>
<dt>window_prior</dt><dd><p>The prior probability of an outbreak in any of the
space-time windows.</p>
</dd>
</dl>

<p>The list <code>posteriors</code> has elements
</p>

<dl>
<dt>null_posterior</dt><dd><p>The posterior probability of no anomaly.</p>
</dd>
<dt>alt_posterior</dt><dd><p>The posterior probability of an anomaly.</p>
</dd>
<dt>inc_posterior</dt><dd><p>A data frame with columns <code>inc_values</code> and
<code>inc_posterior</code>.</p>
</dd>
<dt>window_posteriors</dt><dd><p>A data frame with columns <code>zone</code>, 
<code>duration</code>, <code>log_posterior</code> and 
<code>log_bayes_factor</code>, each row corresponding
to a space-time window.</p>
</dd>
<dt>space_time_posteriors</dt><dd><p>A matrix with the posterior anomaly 
probability of each location-time 
combination.</p>
</dd>
<dt>location_posteriors</dt><dd><p>A vector with the posterior probability of an
anomaly at each location.</p>
</dd>
</dl>



<h3>References</h3>

<p>Neill, D. B., Moore, A. W., Cooper, G. F. (2006). 
<em>A Bayesian Spatial Scan Statistic</em>. Advances in Neural Information 
Processing Systems 18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Create location coordinates, calculate nearest neighbors, and create zones
n_locs &lt;- 50
max_duration &lt;- 5
n_total &lt;- n_locs * max_duration
geo &lt;- matrix(rnorm(n_locs * 2), n_locs, 2)
knn_mat &lt;- coords_to_knn(geo, 15)
zones &lt;- knn_zones(knn_mat)

# Simulate data
baselines &lt;- matrix(rexp(n_total, 1/5), max_duration, n_locs)
counts &lt;- matrix(rpois(n_total, as.vector(baselines)), max_duration, n_locs)

# Inject outbreak/event/anomaly
ob_dur &lt;- 3
ob_cols &lt;- zones[[10]]
ob_rows &lt;- max_duration + 1 - seq_len(ob_dur)
counts[ob_rows, ob_cols] &lt;- matrix(
  rpois(ob_dur * length(ob_cols), 2 * baselines[ob_rows, ob_cols]), 
  length(ob_rows), length(ob_cols))
res &lt;- scan_bayes_negbin(counts = counts,
                         zones = zones,
                         baselines = baselines)
</code></pre>

<hr>
<h2 id='scan_bayes_negbin_cpp'>Calculate the &quot;Bayesian Spatial Scan Statistic&quot; by Neill et al. (2006).</h2><span id='topic+scan_bayes_negbin_cpp'></span>

<h3>Description</h3>

<p>Calculate the &quot;Bayesian Spatial Scan Statistic&quot; by Neill et al. (2006),
adapted to a spatio-temporal setting. The scan statistic assumes that,
given the relative risk, the data follows a Poisson distribution. The 
relative risk is in turn assigned a Gamma distribution prior, yielding a 
negative binomial marginal distribution for the counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_bayes_negbin_cpp(
  counts,
  baselines,
  zones,
  zone_lengths,
  outbreak_prob,
  alpha_null,
  beta_null,
  alpha_alt,
  beta_alt,
  inc_values,
  inc_probs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_counts">counts</code></td>
<td>
<p>An integer matrix (most recent timepoint in first row).</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_baselines">baselines</code></td>
<td>
<p>A matrix with positive entries (most recent timepoint in 
first row).</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_zones">zones</code></td>
<td>
<p>An integer vector (all zones concatenated; locations indexed 
from 0 and up).</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_zone_lengths">zone_lengths</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_outbreak_prob">outbreak_prob</code></td>
<td>
<p>A scalar; the probability of an outbreak (at any time,
any place).</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_alpha_null">alpha_null</code></td>
<td>
<p>A scalar; the shape parameter for the gamma distribution
under the null hypothesis of no anomaly.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_beta_null">beta_null</code></td>
<td>
<p>A scalar; the scale parameter for the gamma distribution
under the null hypothesis of no anomaly.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_alpha_alt">alpha_alt</code></td>
<td>
<p>A scalar; the shape parameter for the gamma distribution
under the alternative hypothesis of an anomaly.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_beta_alt">beta_alt</code></td>
<td>
<p>A scalar; the scale parameter for the gamma distribution
under the alternative hypothesis of an anomaly.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_inc_values">inc_values</code></td>
<td>
<p>A vector of possible values for the increase in the mean
(and variance) of an anomalous count.</p>
</td></tr>
<tr><td><code id="scan_bayes_negbin_cpp_+3A_inc_probs">inc_probs</code></td>
<td>
<p>A vector of the prior probabilities of each value in 
<code>inc_values</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>priors</code> (list), <code>posteriors</code> (list), 
and <code>marginal_data_prob</code> (scalar). The list <code>priors</code> has 
elements
</p>

<dl>
<dt>null_prior</dt><dd><p>The prior probability of no anomaly.</p>
</dd>
<dt>alt_prior</dt><dd><p>The prior probability of an anomaly.</p>
</dd>
<dt>inc_prior</dt><dd><p>A vector (matrix with 1 row) of prior probabilities
of each value in the argument <code>m_values</code>.</p>
</dd>
<dt>window_prior</dt><dd><p>The prior probability of an outbreak in any of the
space-time windows.</p>
</dd>
</dl>

<p>The list <code>posteriors</code> has elements
</p>

<dl>
<dt>null_posterior</dt><dd><p>The posterior probability of no anomaly.</p>
</dd>
<dt>alt_posterior</dt><dd><p>The posterior probability of an anomaly.</p>
</dd>
<dt>inc_posterior</dt><dd><p>A data frame with columns <code>inc_values</code> and
<code>inc_posterior</code>.</p>
</dd>
<dt>window_posteriors</dt><dd><p>A data frame with columns <code>zone</code>, 
<code>duration</code>, <code>log_posterior</code> and 
<code>log_bayes_factor</code>, each row 
corresponding to a space-time window.</p>
</dd>
<dt>space_time_posteriors</dt><dd><p>A matrix with the posterior anomaly 
probability of each location-time 
combination.</p>
</dd>
<dt>location_posteriors</dt><dd><p>A vector (matrix with 1 row) with the 
posterior probability of an anomaly at each
location.</p>
</dd>
</dl>


<hr>
<h2 id='scan_eb_negbin'>Calculate the expectation-based negative binomial scan statistic.</h2><span id='topic+scan_eb_negbin'></span>

<h3>Description</h3>

<p>Calculate the expectation-based negative binomial scan statistic devised by
Tango et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_eb_negbin(
  counts,
  zones,
  baselines = NULL,
  thetas = 1,
  type = c("hotspot", "emerging"),
  n_mcsim = 0,
  gumbel = FALSE,
  max_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_eb_negbin_+3A_counts">counts</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A matrix of observed counts. Rows indicate time and are ordered
from least recent (row 1) to most recent (row 
<code>nrow(counts)</code>). Columns indicate locations, numbered from 1 
and up. If <code>counts</code> is a matrix, the optional matrix 
arguments <code>baselines</code> and <code>thetas</code> should also be 
specified.
</p>
</li>
<li><p> A data frame with columns &quot;time&quot;, &quot;location&quot;, &quot;count&quot;, &quot;baseline&quot;,
&quot;theta&quot;. See the description of the optional arguments 
<code>baselines</code> and <code>thetas</code> below to see their definition.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors. Each vector corresponds to a single
zone; its elements are the numbers of the locations in that zone.</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_baselines">baselines</code></td>
<td>
<p>Optional. A matrix of the same dimensions as <code>counts</code>. 
Holds the expected value parameter for each observed count. These 
parameters are typically estimated from past data using e.g. GLM.</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_thetas">thetas</code></td>
<td>
<p>Optional. A matrix of the same dimensions as <code>counts</code>, or 
a scalar. Holds the dispersion parameter of the distribution, which is 
such that if <code class="reqn">\mu</code> is the expected value, the variance is 
<code class="reqn">\mu+\mu^2/\theta</code>. These parameters are typically estimated from past 
data using e.g. GLM. If a scalar is supplied, the dispersion parameter is 
assumed to be the same for all locations and time points.</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_type">type</code></td>
<td>
<p>A string, either &quot;hotspot&quot; or &quot;emerging&quot;. If &quot;hotspot&quot;, the
relative risk is assumed to be fixed over time. If &quot;emerging&quot;, the
relative risk is assumed to increase with the duration of the outbreak.</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_n_mcsim">n_mcsim</code></td>
<td>
<p>A non-negative integer; the number of replicate scan
statistics to generate in order to calculate a <code class="reqn">P</code>-value.</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical: should a Gumbel P-value be calculated? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_+3A_max_only">max_only</code></td>
<td>
<p>Boolean. If <code>FALSE</code> (default) the statistic calculated
for each zone and duration is returned. If <code>TRUE</code>, only the largest 
such statistic (i.e. the scan statistic) is returned, along with the 
corresponding zone and duration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which, in addition to the information about the type of scan
statistic, has the following components:
</p>

<dl>
<dt>MLC</dt><dd><p>A list containing the number of the zone of the most likely
cluster (MLC), the locations in that zone, the duration of the 
MLC, and the calculated score. In order, the 
elements of this list are named  <code>zone_number, locations, 
           duration, score</code>.</p>
</dd>
<dt>observed</dt><dd><p>A data frame containing, for each combination of zone 
and duration investigated, the zone number, duration, and score. 
The table is sorted by score with the top-scoring location on top. 
If <code>max_only = TRUE</code>, only contains a single row 
corresponding to the MLC.</p>
</dd>
<dt>replicates</dt><dd><p>A data frame of the Monte Carlo replicates of the scan 
statistic (if any), and the corresponding zones and durations.</p>
</dd>
<dt>MC_pvalue</dt><dd><p>The Monte Carlo <code class="reqn">P</code>-value.</p>
</dd>
<dt>Gumbel_pvalue</dt><dd><p>A <code class="reqn">P</code>-value obtained by fitting a Gumbel 
distribution to the replicate scan statistics.</p>
</dd>
<dt>n_zones</dt><dd><p>The number of zones scanned.</p>
</dd>
<dt>n_locations</dt><dd><p>The number of locations.</p>
</dd>
<dt>max_duration</dt><dd><p>The maximum duration considered.</p>
</dd>
<dt>n_mcsim</dt><dd><p>The number of Monte Carlo replicates made.</p>
</dd>
</dl>



<h3>References</h3>

<p>Tango, T., Takahashi, K. &amp; Kohriyama, K. (2011), A space-time scan
statistic for detecting emerging outbreaks, Biometrics 67(1), 106–115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Create location coordinates, calculate nearest neighbors, and create zones
n_locs &lt;- 50
max_duration &lt;- 5
n_total &lt;- n_locs * max_duration
geo &lt;- matrix(rnorm(n_locs * 2), n_locs, 2)
knn_mat &lt;- coords_to_knn(geo, 15)
zones &lt;- knn_zones(knn_mat)

# Simulate data
 baselines &lt;- matrix(rexp(n_total, 1/5), max_duration, n_locs)
 thetas &lt;- matrix(runif(n_total, 0.05, 3), max_duration, n_locs)
 counts &lt;- matrix(rnbinom(n_total,  mu = baselines,  size = thetas), 
                  max_duration, n_locs)

# Inject outbreak/event/anomaly
ob_dur &lt;- 3
ob_cols &lt;- zones[[10]]
ob_rows &lt;- max_duration + 1 - seq_len(ob_dur)
counts[ob_rows, ob_cols] &lt;- matrix(
  rnbinom(ob_dur * length(ob_cols), 
          mu = 2 * baselines[ob_rows, ob_cols],
          size = thetas[ob_rows, ob_cols]),
  length(ob_rows), length(ob_cols))
res &lt;- scan_eb_negbin(counts = counts,
                      zones = zones,
                      baselines = baselines,
                      thetas = thetas,
                      type = "hotspot",
                      n_mcsim = 99,
                      max_only = FALSE)
</code></pre>

<hr>
<h2 id='scan_eb_negbin_cpp'>Calculate the expectation-based negative binomial scan statistic.</h2><span id='topic+scan_eb_negbin_cpp'></span>

<h3>Description</h3>

<p>Calculate the expectation-based negative binomial scan statistic and Monte
Carlo replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_eb_negbin_cpp(
  counts,
  baselines,
  overdisp,
  zones,
  zone_lengths,
  store_everything,
  num_mcsim,
  score_hotspot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_eb_negbin_cpp_+3A_counts">counts</code></td>
<td>
<p>Integer matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_baselines">baselines</code></td>
<td>
<p>Matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_overdisp">overdisp</code></td>
<td>
<p>Matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_zones">zones</code></td>
<td>
<p>Integer vector (all zones concatenated; locations indexed from
0 and up)</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_zone_lengths">zone_lengths</code></td>
<td>
<p>Integer vector</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_store_everything">store_everything</code></td>
<td>
<p>Boolean</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_num_mcsim">num_mcsim</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="scan_eb_negbin_cpp_+3A_score_hotspot">score_hotspot</code></td>
<td>
<p>Boolean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>observed</code> and <code>simulated</code>, each 
being a data frame with columns:
</p>

<dl>
<dt>zone</dt><dd><p>The top-scoring zone (spatial component of MLC).</p>
</dd>
<dt>duration</dt><dd><p>The corresponding duration (time-length of MLC).</p>
</dd>
<dt>score</dt><dd><p>The value of the loglihood ratio statistic (the scan
statistic).</p>
</dd>
<dt>relrisk</dt><dd><p>The estimated relative risk.</p>
</dd>
<dt>n_iter</dt><dd><p>The number of iterations performed by the EM algorithm.</p>
</dd>
</dl>


<hr>
<h2 id='scan_eb_poisson'>Calculate the expectation-based Poisson scan statistic.</h2><span id='topic+scan_eb_poisson'></span>

<h3>Description</h3>

<p>Calculate the expectation-based Poisson scan statistic devised by Neill et 
al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_eb_poisson(
  counts,
  zones,
  baselines = NULL,
  population = NULL,
  n_mcsim = 0,
  gumbel = FALSE,
  max_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_eb_poisson_+3A_counts">counts</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A matrix of observed counts. Rows indicate time and are ordered
from least recent (row 1) to most recent (row 
<code>nrow(counts)</code>). Columns indicate locations, numbered from 1 
and up. If <code>counts</code> is a matrix, the optional matrix argument 
<code>baselines</code> should also be specified.
</p>
</li>
<li><p> A data frame with columns &quot;time&quot;, &quot;location&quot;, &quot;count&quot;, &quot;baseline&quot;. 
Alternatively, the column &quot;baseline&quot; can be replaced by a column
&quot;population&quot;. The baselines are the expected values of the counts.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan_eb_poisson_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors. Each vector corresponds to a single
zone; its elements are the numbers of the locations in that zone.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_+3A_baselines">baselines</code></td>
<td>
<p>Optional. A matrix of the same dimensions as <code>counts</code>. 
Not needed if <code>counts</code> is a data frame. Holds the Poisson mean 
parameter for each observed count. Will be estimated if not supplied 
(requires the <code>population</code> argument). These parameters are typically 
estimated from past data using e.g. Poisson (GLM) regression.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_+3A_population">population</code></td>
<td>
<p>Optional. A matrix or vector of populations for each 
location. Not needed if <code>counts</code> is a data frame. If <code>counts</code> is
a matrix, <code>population</code> is only needed if <code>baselines</code> are to be 
estimated and you want to account for the different populations in each 
location (and time). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of 
columns in <code>counts</code>.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_+3A_n_mcsim">n_mcsim</code></td>
<td>
<p>A non-negative integer; the number of replicate scan
statistics to generate in order to calculate a <code class="reqn">P</code>-value.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical: should a Gumbel P-value be calculated? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_+3A_max_only">max_only</code></td>
<td>
<p>Boolean. If <code>FALSE</code> (default) the log-likelihood ratio
statistic for each zone and duration is returned. If <code>TRUE</code>, only the
largest such statistic (i.e. the scan statistic) is returned, along with
the corresponding zone and duration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which, in addition to the information about the type of scan
statistic, has the following components:
</p>

<dl>
<dt>MLC</dt><dd><p>A list containing the number of the zone of the most likely
cluster (MLC), the locations in that zone, the duration of the 
MLC, the calculated score, and the relative risk. In order, the 
elements of this list are named  <code>zone_number, locations, 
           duration, score, relative_risk</code>.</p>
</dd>
<dt>observed</dt><dd><p>A data frame containing, for each combination of zone 
and duration investigated, the zone number, duration, score, 
relative risk. The table is sorted by score with the top-scoring 
location on top. If <code>max_only = TRUE</code>, only contains a single 
row corresponding to the MLC.</p>
</dd>
<dt>replicates</dt><dd><p>A data frame of the Monte Carlo replicates of the scan 
statistic (if any), and the corresponding zones and durations.</p>
</dd>
<dt>MC_pvalue</dt><dd><p>The Monte Carlo <code class="reqn">P</code>-value.</p>
</dd>
<dt>Gumbel_pvalue</dt><dd><p>A <code class="reqn">P</code>-value obtained by fitting a Gumbel 
distribution to the replicate scan statistics.</p>
</dd>
<dt>n_zones</dt><dd><p>The number of zones scanned.</p>
</dd>
<dt>n_locations</dt><dd><p>The number of locations.</p>
</dd>
<dt>max_duration</dt><dd><p>The maximum duration considered.</p>
</dd>
<dt>n_mcsim</dt><dd><p>The number of Monte Carlo replicates made.</p>
</dd>
</dl>



<h3>References</h3>

<p>Neill, D. B., Moore, A. W., Sabhnani, M. and Daniel, K. (2005). 
<em>Detection of emerging space-time clusters</em>. Proceeding of the 
eleventh ACM SIGKDD international conference on Knowledge discovery in 
data mining - KDD ’05, 218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Create location coordinates, calculate nearest neighbors, and create zones
n_locs &lt;- 50
max_duration &lt;- 5
n_total &lt;- n_locs * max_duration
geo &lt;- matrix(rnorm(n_locs * 2), n_locs, 2)
knn_mat &lt;- coords_to_knn(geo, 15)
zones &lt;- knn_zones(knn_mat)

# Simulate data
baselines &lt;- matrix(rexp(n_total, 1/5), max_duration, n_locs)
counts &lt;- matrix(rpois(n_total, as.vector(baselines)), max_duration, n_locs)

# Inject outbreak/event/anomaly
ob_dur &lt;- 3
ob_cols &lt;- zones[[10]]
ob_rows &lt;- max_duration + 1 - seq_len(ob_dur)
counts[ob_rows, ob_cols] &lt;- matrix(
  rpois(ob_dur * length(ob_cols), 2 * baselines[ob_rows, ob_cols]), 
  length(ob_rows), length(ob_cols))
res &lt;- scan_eb_poisson(counts = counts,
                       zones = zones,
                       baselines = baselines,
                       n_mcsim = 99,
                       max_only = FALSE)
</code></pre>

<hr>
<h2 id='scan_eb_poisson_cpp'>Calculate the expecation-based Poisson scan statistic.</h2><span id='topic+scan_eb_poisson_cpp'></span>

<h3>Description</h3>

<p>Calculate the expectation-based Poisson scan statistic and Monte Carlo 
replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_eb_poisson_cpp(
  counts,
  baselines,
  zones,
  zone_lengths,
  store_everything,
  num_mcsim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_eb_poisson_cpp_+3A_counts">counts</code></td>
<td>
<p>An integer matrix (most recent timepoint in first row).</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_cpp_+3A_baselines">baselines</code></td>
<td>
<p>A matrix with positive entries (most recent timepoint in 
first row).</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_cpp_+3A_zones">zones</code></td>
<td>
<p>An integer vector (all zones concatenated; locations indexed 
from 0 and up).</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_cpp_+3A_zone_lengths">zone_lengths</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_cpp_+3A_store_everything">store_everything</code></td>
<td>
<p>A boolean.</p>
</td></tr>
<tr><td><code id="scan_eb_poisson_cpp_+3A_num_mcsim">num_mcsim</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>observed</code> and <code>simulated</code>, each 
being a data frame with columns:
</p>

<dl>
<dt>zone</dt><dd><p>The top-scoring zone (spatial component of MLC).</p>
</dd>
<dt>duration</dt><dd><p>The corresponding duration (time-length of MLC).</p>
</dd>
<dt>score</dt><dd><p>The value of the loglihood ratio statistic (the scan
statistic).</p>
</dd>
<dt>relrisk_in</dt><dd><p>The estimated relative risk inside.</p>
</dd>
<dt>relrisk_in</dt><dd><p>The estimated relative risk outside.</p>
</dd>
</dl>


<hr>
<h2 id='scan_eb_zip'>Calculate the expectation-based ZIP scan statistic.</h2><span id='topic+scan_eb_zip'></span>

<h3>Description</h3>

<p>Calculates the expectation-based scan statistic. See details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_eb_zip(
  counts,
  zones,
  baselines = NULL,
  probs = NULL,
  population = NULL,
  n_mcsim = 0,
  gumbel = FALSE,
  max_only = FALSE,
  rel_tol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_eb_zip_+3A_counts">counts</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A matrix of observed counts. Rows indicate time and are ordered
from least recent (row 1) to most recent (row 
<code>nrow(counts)</code>). Columns indicate locations, numbered from 1 
and up. If <code>counts</code> is a matrix, the optional matrix 
arguments <code>baselines</code> and <code>probs</code> should also be 
specified.
</p>
</li>
<li><p> A data frame with columns &quot;time&quot;, &quot;location&quot;, &quot;count&quot;, &quot;baseline&quot;,
&quot;prob&quot;. The baselines are the expected values of the counts, and 
&quot;prob&quot; are the structural zero probabilities of the counts. If
&quot;baseline&quot; and &quot;prob&quot; are not found as columns, their values are
estimated in a <em>very</em> heuristic fashion (not recommended).
If population numbers are available, they can be included in a 
column &quot;population&quot; to help with the estimation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors. Each vector corresponds to a single
zone; its elements are the numbers of the locations in that zone.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_baselines">baselines</code></td>
<td>
<p>Optional. A matrix of the same dimensions as <code>counts</code>. 
Holds the Poisson mean parameter of the ZIP distribution for each observed 
count. These parameters are typically estimated from past data using e.g. 
ZIP regression.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_probs">probs</code></td>
<td>
<p>Optional. A matrix of the same dimensions as <code>counts</code>. 
Holds the structural zero probability of the ZIP distribution for each 
observed count. These parameters are typically estimated from past data 
using e.g. ZIP regression.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_population">population</code></td>
<td>
<p>Optional. A matrix or vector of populations for each 
location. Only needed if <code>baselines</code> and <code>probs</code> are to be 
estimated and you want to account for the different populations in each 
location (and time). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of 
columns in <code>counts</code>.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_n_mcsim">n_mcsim</code></td>
<td>
<p>A non-negative integer; the number of replicate scan
statistics to generate in order to calculate a <code class="reqn">P</code>-value.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical: should a Gumbel P-value be calculated? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_max_only">max_only</code></td>
<td>
<p>Boolean. If <code>FALSE</code> (default) the log-likelihood ratio
statistic for each zone and duration is returned. If <code>TRUE</code>, only the
largest such statistic (i.e. the scan statistic) is returned, along with
the corresponding zone and duration.</p>
</td></tr>
<tr><td><code id="scan_eb_zip_+3A_rel_tol">rel_tol</code></td>
<td>
<p>A positive scalar. If the relative change in the incomplete
information likelihood is less than this value, then the EM algorithm is
deemed to have converged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the expectation-based zero-inflated Poisson scan statistic
(Allévius &amp; Höhle 2017), the null hypothesis of no anomaly holds that 
the count observed at each location <code class="reqn">i</code> and duration <code class="reqn">t</code> (the 
number of time periods before present) has a zero-inflated Poisson 
distribution with expected value parameter <code class="reqn">\mu_{it}</code> and structural 
zero probability <code class="reqn">p_{it}</code>:
</p>
<p style="text-align: center;"><code class="reqn">
     H_0 : Y_{it} \sim \textrm{ZIP}(\mu_{it}, p_{it}).
   </code>
</p>

<p>This holds for all locations <code class="reqn">i = 1, \ldots, m</code> and all durations
<code class="reqn">t = 1, \ldots,T</code>, with <code class="reqn">T</code> being the maximum duration considered.
Under the alternative hypothesis, there is a space-time window <code class="reqn">W</code>
consisting of a spatial zone <code class="reqn">Z \subset \{1, \ldots, m\}</code> and a time
window <code class="reqn">D \subseteq \{1, \ldots, T\}</code> such that the counts in that
window have their Poisson expected value parameters inflated by a factor
<code class="reqn">q_W &gt; 1</code> compared to the null hypothesis:
</p>
<p style="text-align: center;"><code class="reqn">
   H_1 : Y_{it} \sim \textrm{ZIP}(q_W \mu_{it}, p_{it}), ~~(i,t) \in W.
   </code>
</p>

<p>For locations and durations outside of this window, counts are assumed to
be distributed as under the null hypothesis. The sets <code class="reqn">Z</code> considered
are those specified in the argument <code>zones</code>, while the maximum
duration <code class="reqn">T</code> is taken as the maximum value in the column
<code>duration</code> of the input <code>table</code>.
</p>
<p>For each space-time window <code class="reqn">W</code> considered, (the log of) a likelihood
ratio is computed using the distributions under the alternative and null
hypotheses, and the expectation-based Poisson scan statistic is calculated
as the maximum of these quantities over all space-time windows. The
expectation-maximization (EM) algorithm is used to obtain maximum
likelihood estimates.
</p>


<h3>Value</h3>

<p>A list which, in addition to the information about the type of scan
statistic, has the following components:
</p>

<dl>
<dt>MLC</dt><dd><p>A list containing the number of the zone of the most likely
cluster (MLC), the locations in that zone, the duration of the 
MLC, the calculated score, the relative risk, and the number of 
iterations until convergence for the EM algorithm. In order, the 
elements of this list are named  <code>zone_number, locations, 
           duration, score, relative_risk, n_iter</code>.</p>
</dd>
<dt>observed</dt><dd><p>A data frame containing, for each combination of zone 
and duration investigated, the zone number, duration, score, 
relative risk, number of EM iterations. The table is sorted by 
score with the top-scoring location on top. If 
<code>max_only = TRUE</code>, only contains a single row corresponding 
to the MLC.</p>
</dd>
<dt>replicates</dt><dd><p>A data frame of the Monte Carlo replicates of the scan 
statistic (if any), and the corresponding zones and durations.</p>
</dd>
<dt>MC_pvalue</dt><dd><p>The Monte Carlo <code class="reqn">P</code>-value.</p>
</dd>
<dt>Gumbel_pvalue</dt><dd><p>A <code class="reqn">P</code>-value obtained by fitting a Gumbel 
distribution to the replicate scan statistics.</p>
</dd>
<dt>n_zones</dt><dd><p>The number of zones scanned.</p>
</dd>
<dt>n_locations</dt><dd><p>The number of locations.</p>
</dd>
<dt>max_duration</dt><dd><p>The maximum duration considered.</p>
</dd>
<dt>n_mcsim</dt><dd><p>The number of Monte Carlo replicates made.</p>
</dd>
</dl>



<h3>References</h3>

<p>Allévius, B. and Höhle, M, <em>An expectation-based space-time scan 
statistic for ZIP-distributed data</em>, (Technical report),
<a href="https://goo.gl/yYJ42A">Link to PDF</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("gamlss.dist")) {
  set.seed(1)
  # Create location coordinates, calculate nearest neighbors, and create zones
  n_locs &lt;- 50
  max_duration &lt;- 5
  n_total &lt;- n_locs * max_duration
  geo &lt;- matrix(rnorm(n_locs * 2), n_locs, 2)
  knn_mat &lt;- coords_to_knn(geo, 15)
  zones &lt;- knn_zones(knn_mat)
  
  # Simulate data
  baselines &lt;- matrix(rexp(n_total, 1/5), max_duration, n_locs)
  probs &lt;- matrix(runif(n_total) / 4, max_duration, n_locs)
  counts &lt;- matrix(gamlss.dist::rZIP(n_total, baselines, probs), 
                   max_duration, n_locs)
  
  # Inject outbreak/event/anomaly
  ob_dur &lt;- 3
  ob_cols &lt;- zones[[10]]
  ob_rows &lt;- max_duration + 1 - seq_len(ob_dur)
  counts[ob_rows, ob_cols] &lt;- gamlss.dist::rZIP(
    ob_dur * length(ob_cols), 2 * baselines[ob_rows, ob_cols],
    probs[ob_rows, ob_cols])
  res &lt;- scan_eb_zip(counts = counts,
                     zones = zones,
                     baselines = baselines,
                     probs = probs,
                     n_mcsim = 9,
                     max_only = FALSE,
                     rel_tol = 1e-3)
}
</code></pre>

<hr>
<h2 id='scan_eb_zip_cpp'>Calculate the highest-value EB ZIP loglihood ratio statistic.</h2><span id='topic+scan_eb_zip_cpp'></span>

<h3>Description</h3>

<p>Calculate the expectation-based ZIP loglihood ratio statistic for each zone
and duration, but only keep the zone and duration with the highest value
(the MLC). The estimate of the relative risk is also calculated, along with
the number of iterations the EM algorithm performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_eb_zip_cpp(
  counts,
  baselines,
  probs,
  zones,
  zone_lengths,
  rel_tol,
  store_everything,
  num_mcsim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_eb_zip_cpp_+3A_counts">counts</code></td>
<td>
<p>matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_baselines">baselines</code></td>
<td>
<p>matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_probs">probs</code></td>
<td>
<p>matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_zones">zones</code></td>
<td>
<p>integer vector (all zones concatenated; locations indexed from
0 and up)</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_zone_lengths">zone_lengths</code></td>
<td>
<p>integer vector</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_rel_tol">rel_tol</code></td>
<td>
<p>double</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_store_everything">store_everything</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="scan_eb_zip_cpp_+3A_num_mcsim">num_mcsim</code></td>
<td>
<p>int</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>observed</code> and <code>simulated</code>, each 
being a data frame with columns:
</p>

<dl>
<dt>zone</dt><dd><p>The top-scoring zone (spatial component of MLC).</p>
</dd>
<dt>duration</dt><dd><p>The corresponding duration (time-length of MLC).</p>
</dd>
<dt>score</dt><dd><p>The value of the loglihood ratio statistic (the scan
statistic).</p>
</dd>
<dt>relrisk</dt><dd><p>The estimated relative risk.</p>
</dd>
<dt>n_iter</dt><dd><p>The number of iterations performed by the EM algorithm.</p>
</dd>
</dl>


<hr>
<h2 id='scan_pb_perm_cpp'>Calculate the space-time permutation scan statistic.</h2><span id='topic+scan_pb_perm_cpp'></span>

<h3>Description</h3>

<p>Calculate the space-time permutation scan statistic (Kulldorff 2005) and 
Monte Carloo  replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_pb_perm_cpp(
  counts,
  baselines,
  zones,
  zone_lengths,
  store_everything,
  num_mcsim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_pb_perm_cpp_+3A_counts">counts</code></td>
<td>
<p>An integer matrix (most recent timepoint in first row).</p>
</td></tr>
<tr><td><code id="scan_pb_perm_cpp_+3A_baselines">baselines</code></td>
<td>
<p>A matrix with positive entries (most recent timepoint in 
first row).</p>
</td></tr>
<tr><td><code id="scan_pb_perm_cpp_+3A_zones">zones</code></td>
<td>
<p>An integer vector (all zones concatenated; locations indexed 
from 0 and up)</p>
</td></tr>
<tr><td><code id="scan_pb_perm_cpp_+3A_zone_lengths">zone_lengths</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="scan_pb_perm_cpp_+3A_store_everything">store_everything</code></td>
<td>
<p>A boolean.</p>
</td></tr>
<tr><td><code id="scan_pb_perm_cpp_+3A_num_mcsim">num_mcsim</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>observed</code> and <code>simulated</code>, each 
being a data frame with columns:
</p>

<dl>
<dt>zone</dt><dd><p>The top-scoring zone (spatial component of MLC).</p>
</dd>
<dt>duration</dt><dd><p>The corresponding duration (time-length of MLC).</p>
</dd>
<dt>score</dt><dd><p>The value of the loglihood ratio statistic (the scan
statistic).</p>
</dd>
<dt>relrisk_in</dt><dd><p>The estimated relative risk inside.</p>
</dd>
<dt>relrisk_in</dt><dd><p>The estimated relative risk outside.</p>
</dd>
</dl>


<hr>
<h2 id='scan_pb_poisson'>Calculate the population-based Poisson scan statistic.</h2><span id='topic+scan_pb_poisson'></span>

<h3>Description</h3>

<p>Calculate the population-based Poisson scan statistic devised by Kulldorff
(1997, 2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_pb_poisson(
  counts,
  zones,
  population = NULL,
  n_mcsim = 0,
  gumbel = FALSE,
  max_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_pb_poisson_+3A_counts">counts</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A matrix of observed counts. Rows indicate time and are ordered
from least recent (row 1) to most recent (row 
<code>nrow(counts)</code>). Columns indicate locations, numbered from 1 
and up. If <code>counts</code> is a matrix, the optional argument 
<code>population</code> should also be specified.
</p>
</li>
<li><p> A data frame with columns &quot;time&quot;, &quot;location&quot;, &quot;count&quot;, 
&quot;population&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan_pb_poisson_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors. Each vector corresponds to a single
zone; its elements are the numbers of the locations in that zone.</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_+3A_population">population</code></td>
<td>
<p>Optional. A matrix or vector of populations for each 
location and time point. Only needed if <code>baselines</code> are to be 
estimated and you want to account for the different populations in each 
location (and time). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of 
columns in <code>counts</code> (the number of locations).</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_+3A_n_mcsim">n_mcsim</code></td>
<td>
<p>A non-negative integer; the number of replicate scan
statistics to generate in order to calculate a P-value.</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical: should a Gumbel P-value be calculated? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_+3A_max_only">max_only</code></td>
<td>
<p>Boolean. If <code>FALSE</code> (default) the log-likelihood ratio
statistic for each zone and duration is returned. If <code>TRUE</code>, only the
largest such statistic (i.e. the scan statistic) is returned, along with
the corresponding zone and duration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which, in addition to the information about the type of scan
statistic, has the following components:
</p>

<dl>
<dt>MLC</dt><dd><p>A list containing the number of the zone of the most likely
cluster (MLC), the locations in that zone, the duration of the 
MLC, the calculated score, and the relative risk inside and 
outside the cluster. In order, the elements of this list are named  
<code>zone_number, locations, duration, score, relrisk_in,
           relrisk_out</code>.</p>
</dd>
<dt>observed</dt><dd><p>A data frame containing, for each combination of zone 
and duration investigated, the zone number, duration, score, 
relative risks. The table is sorted by score with the top-scoring 
location on top. If <code>max_only = TRUE</code>, only contains a single 
row corresponding to the MLC.</p>
</dd>
<dt>replicates</dt><dd><p>A data frame of the Monte Carlo replicates of the scan 
statistic (if any), and the corresponding zones and durations.</p>
</dd>
<dt>MC_pvalue</dt><dd><p>The Monte Carlo <code class="reqn">P</code>-value.</p>
</dd>
<dt>Gumbel_pvalue</dt><dd><p>A <code class="reqn">P</code>-value obtained by fitting a Gumbel 
distribution to the replicate scan statistics.</p>
</dd>
<dt>n_zones</dt><dd><p>The number of zones scanned.</p>
</dd>
<dt>n_locations</dt><dd><p>The number of locations.</p>
</dd>
<dt>max_duration</dt><dd><p>The maximum duration considered.</p>
</dd>
<dt>n_mcsim</dt><dd><p>The number of Monte Carlo replicates made.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kulldorff, M. (1997). <em>A spatial scan statistic</em>. Communications in 
Statistics - Theory and Methods, 26, 1481–1496.
</p>
<p>Kulldorff, M. (2001). <em>Prospective time periodic geographical disease 
surveillance using a scan statistic</em>. Journal of the Royal Statistical 
Society, Series A (Statistics in Society), 164, 61–72.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Create location coordinates, calculate nearest neighbors, and create zones
n_locs &lt;- 50
max_duration &lt;- 5
n_total &lt;- n_locs * max_duration
geo &lt;- matrix(rnorm(n_locs * 2), n_locs, 2)
knn_mat &lt;- coords_to_knn(geo, 15)
zones &lt;- knn_zones(knn_mat)

# Simulate data
population &lt;- matrix(rnorm(n_total, 100, 10), max_duration, n_locs)
counts &lt;- matrix(rpois(n_total, as.vector(population) / 20), 
                 max_duration, n_locs)

# Inject outbreak/event/anomaly
ob_dur &lt;- 3
ob_cols &lt;- zones[[10]]
ob_rows &lt;- max_duration + 1 - seq_len(ob_dur)
counts[ob_rows, ob_cols] &lt;- matrix(
  rpois(ob_dur * length(ob_cols), 2 * population[ob_rows, ob_cols] / 20), 
  length(ob_rows), length(ob_cols))
res &lt;- scan_pb_poisson(counts = counts,
                       zones = zones,
                       population = population,
                       n_mcsim = 99,
                       max_only = FALSE)
</code></pre>

<hr>
<h2 id='scan_pb_poisson_cpp'>Calculate the population-based Poisson scan statistic.</h2><span id='topic+scan_pb_poisson_cpp'></span>

<h3>Description</h3>

<p>Calculate the population-based Poisson scan statistic and Monte Carlo 
replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_pb_poisson_cpp(
  counts,
  baselines,
  zones,
  zone_lengths,
  store_everything,
  num_mcsim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_pb_poisson_cpp_+3A_counts">counts</code></td>
<td>
<p>integer matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_cpp_+3A_baselines">baselines</code></td>
<td>
<p>matrix (most recent timepoint in first row)</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_cpp_+3A_zones">zones</code></td>
<td>
<p>integer vector (all zones concatenated; locations indexed from
0 and up)</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_cpp_+3A_zone_lengths">zone_lengths</code></td>
<td>
<p>integer vector</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_cpp_+3A_store_everything">store_everything</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="scan_pb_poisson_cpp_+3A_num_mcsim">num_mcsim</code></td>
<td>
<p>int</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>observed</code> and <code>simulated</code>, each 
being a data frame with columns:
</p>

<dl>
<dt>zone</dt><dd><p>The top-scoring zone (spatial component of MLC).</p>
</dd>
<dt>duration</dt><dd><p>The corresponding duration (time-length of MLC).</p>
</dd>
<dt>score</dt><dd><p>The value of the loglihood ratio statistic (the scan
statistic).</p>
</dd>
<dt>relrisk_in</dt><dd><p>The estimated relative risk inside.</p>
</dd>
<dt>relrisk_in</dt><dd><p>The estimated relative risk outside.</p>
</dd>
</dl>


<hr>
<h2 id='scan_permutation'>Calculate the space-time permutation scan statistic.</h2><span id='topic+scan_permutation'></span>

<h3>Description</h3>

<p>Calculate the space-time permutation scan statistic devised by Kulldorff
(2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_permutation(
  counts,
  zones,
  population = NULL,
  n_mcsim = 0,
  gumbel = FALSE,
  max_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_permutation_+3A_counts">counts</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A matrix of observed counts. Rows indicate time and are ordered
from least recent (row 1) to most recent (row 
<code>nrow(counts)</code>). Columns indicate locations, numbered from 1 
and up. If <code>counts</code> is a matrix, the optional argument 
<code>population</code> should also be specified.
</p>
</li>
<li><p> A data frame with columns &quot;time&quot;, &quot;location&quot;, &quot;count&quot;, 
&quot;population&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan_permutation_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors. Each vector corresponds to a single
zone; its elements are the numbers of the locations in that zone.</p>
</td></tr>
<tr><td><code id="scan_permutation_+3A_population">population</code></td>
<td>
<p>Optional. A matrix or vector of populations for each 
location and time point. Only needed if <code>baselines</code> are to be 
estimated and you want to account for the different populations in each 
location (and time). If a matrix, should be of the same dimensions as 
<code>counts</code>. If a vector, should be of the same length as the number of 
columns in <code>counts</code> (the number of locations).</p>
</td></tr>
<tr><td><code id="scan_permutation_+3A_n_mcsim">n_mcsim</code></td>
<td>
<p>A non-negative integer; the number of replicate scan
statistics to generate in order to calculate a P-value.</p>
</td></tr>
<tr><td><code id="scan_permutation_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical: should a Gumbel P-value be calculated? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scan_permutation_+3A_max_only">max_only</code></td>
<td>
<p>Boolean. If <code>FALSE</code> (default) the log-likelihood ratio
statistic for each zone and duration is returned. If <code>TRUE</code>, only the
largest such statistic (i.e. the scan statistic) is returned, along with
the corresponding zone and duration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which, in addition to the information about the type of scan
statistic, has the following components:
</p>

<dl>
<dt>MLC</dt><dd><p>A list containing the number of the zone of the most likely
cluster (MLC), the locations in that zone, the duration of the 
MLC, the calculated score, and the relative risk inside and 
outside the cluster. In order, the elements of this list are named  
<code>zone_number, locations, duration, score, relrisk_in,
           relrisk_out</code>.</p>
</dd>
<dt>observed</dt><dd><p>A data frame containing, for each combination of zone 
and duration investigated, the zone number, duration, score, 
relative risks. The table is sorted by score with the top-scoring 
location on top. If <code>max_only = TRUE</code>, only contains a single 
row corresponding to the MLC.</p>
</dd>
<dt>replicates</dt><dd><p>A data frame of the Monte Carlo replicates of the scan 
statistic (if any), and the corresponding zones and durations.</p>
</dd>
<dt>MC_pvalue</dt><dd><p>The Monte Carlo <code class="reqn">P</code>-value.</p>
</dd>
<dt>Gumbel_pvalue</dt><dd><p>A <code class="reqn">P</code>-value obtained by fitting a Gumbel 
distribution to the replicate scan statistics.</p>
</dd>
<dt>n_zones</dt><dd><p>The number of zones scanned.</p>
</dd>
<dt>n_locations</dt><dd><p>The number of locations.</p>
</dd>
<dt>max_duration</dt><dd><p>The maximum duration considered.</p>
</dd>
<dt>n_mcsim</dt><dd><p>The number of Monte Carlo replicates made.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kulldorff, M., Heffernan, R., Hartman, J., Assunção, R. M., Mostashari, F.
(2005). <em>A space-time permutation scan statistic for disease outbreak 
detection</em>. PLoS Medicine, 2(3), 0216-0224.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Create location coordinates, calculate nearest neighbors, and create zones
n_locs &lt;- 50
max_duration &lt;- 5
n_total &lt;- n_locs * max_duration
geo &lt;- matrix(rnorm(n_locs * 2), n_locs, 2)
knn_mat &lt;- coords_to_knn(geo, 15)
zones &lt;- knn_zones(knn_mat)

# Simulate data
population &lt;- matrix(rnorm(n_total, 100, 10), max_duration, n_locs)
counts &lt;- matrix(rpois(n_total, as.vector(population) / 20), 
                 max_duration, n_locs)

# Inject outbreak/event/anomaly
ob_dur &lt;- 3
ob_cols &lt;- zones[[10]]
ob_rows &lt;- max_duration + 1 - seq_len(ob_dur)
counts[ob_rows, ob_cols] &lt;- matrix(
  rpois(ob_dur * length(ob_cols), 2 * population[ob_rows, ob_cols] / 20), 
  length(ob_rows), length(ob_cols))
res &lt;- scan_permutation(counts = counts,
                           zones = zones,
                           population = population,
                           n_mcsim = 99,
                           max_only = FALSE)
</code></pre>

<hr>
<h2 id='scanstatistics'>scanstatistics: Space-time anomaly detection using scan statistics.</h2><span id='topic+scanstatistics'></span>

<h3>Description</h3>

<p>The scanstatistics package provides two categories of important functions:
data preparation functions, and the scan statistics themselves.
</p>


<h3>Data preparation functions</h3>

<p>These functions prepare your data for use. In particular, it helps you 
define the <em>zones</em> which will be considered by the scan statistics.
</p>


<h3>Scan statistics</h3>

<p>These are the functions used for space-time anomaly detection. Scan statistic
functions for univariate space-time data have a name that begins with 
<code>scan_</code> and functions for multivariate space-time data have a name that
begins with <code>mscan_</code>.
</p>

<hr>
<h2 id='score_locations'>Score each location over zones and duration.</h2><span id='topic+score_locations'></span>

<h3>Description</h3>

<p>For each location, compute the average of the statistic calculated for each
space-time window that the location is included in, i.e. average the 
statistic over both zones and the maximum duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_locations(x, zones)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_locations_+3A_x">x</code></td>
<td>
<p>An object of class <code>scanstatistic</code>.</p>
</td></tr>
<tr><td><code id="score_locations_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with the following columns:
</p>

<dl>
<dt>location</dt><dd><p>The locations (as integers).</p>
</dd>
<dt>total_score</dt><dd><p>For each location, the sum of all window statistics 
that the location appears in.</p>
</dd>
<dt>n_zones</dt><dd><p>The number of spatial zones that the location appears 
in.</p>
</dd>
<dt>score</dt><dd><p>The total score divided by the number of zones and the 
maximum duration.</p>
</dd>
<dt>relative_score</dt><dd><p>The score divided by the maximum score.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Simple example
set.seed(1)
table &lt;- data.frame(zone = 1:5, duration = 1, score = 5:1)
zones &lt;- list(1:2, 1:3, 2:5, 4:5, c(1, 5))
x &lt;- list(observed = table, n_locations = 5, max_duration = 1, n_zones = 5)
score_locations(x, zones)
</code></pre>

<hr>
<h2 id='top_clusters'>Get the top (non-overlappig) clusters.</h2><span id='topic+top_clusters'></span>

<h3>Description</h3>

<p>Get the top <code class="reqn">k</code> space-time clusters according to the statistic calculated
for each cluster (the maximum being the scan statistic). The default is to 
return the spatially non-overlapping clusters, i.e. those that do not have 
any locations in common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_clusters(
  x,
  zones,
  k = 5,
  overlapping = FALSE,
  gumbel = FALSE,
  alpha = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_clusters_+3A_x">x</code></td>
<td>
<p>An object of class scanstatistics.</p>
</td></tr>
<tr><td><code id="top_clusters_+3A_zones">zones</code></td>
<td>
<p>A list of integer vectors.</p>
</td></tr>
<tr><td><code id="top_clusters_+3A_k">k</code></td>
<td>
<p>An integer, the number of clusters to return.</p>
</td></tr>
<tr><td><code id="top_clusters_+3A_overlapping">overlapping</code></td>
<td>
<p>Logical; should the top clusters be allowed to overlap in
the spatial dimension? The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="top_clusters_+3A_gumbel">gumbel</code></td>
<td>
<p>Logical; should a Gumbel P-value be calculated? The default is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="top_clusters_+3A_alpha">alpha</code></td>
<td>
<p>A significance level, which if not <code>NULL</code> will be used to
calculate a critical value for the statistics in the table.</p>
</td></tr>
<tr><td><code id="top_clusters_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with at most <code class="reqn">k</code> rows, with columns 
<code>zone, duration, score</code> and possibly <code>MC_pvalue, Gumbel_pvalue</code>
and <code>critical_value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
counts &lt;- matrix(rpois(15, 3), 3, 5)
zones &lt;- list(1:2, 1:3, 2:5, c(1, 3), 4:5, c(1, 5))
scanres &lt;- scan_permutation(counts, zones, n_mcsim = 5)
top_clusters(scanres, zones, k = 4, overlapping = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
