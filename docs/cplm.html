<!DOCTYPE html><html><head><title>Help for package cplm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cplm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcplm'>
<p>Bayesian Compound Poisson Linear Models</p></a></li>
<li><a href='#class-methods'><p>Classes and Methods for a Compound Poisson Linear Model Object</p></a></li>
<li><a href='#cpglm'><p>Compound Poisson Generalized Linear Models</p></a></li>
<li><a href='#cpglmm'>
<p>Compound Poisson Generalized Linear Mixed Models</p></a></li>
<li><a href='#cplm-package'>
<p>Tweedie compound Poisson linear models</p></a></li>
<li><a href='#datasets'><p>Data sets in the cplm pakcage</p></a></li>
<li><a href='#getF'><p>Get and plot the smoothing function values</p></a></li>
<li><a href='#gini'>
<p>The Gini index</p></a></li>
<li><a href='#sp2d'>
<p>2-dimentional Radial Spline</p></a></li>
<li><a href='#tp'><p>Generate basis functions for penalized spline smoothing.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compound Poisson Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Yanwei (Wayne) Zhang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yanwei (Wayne) Zhang &lt;actuary_zhang@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood-based and Bayesian methods for various compound Poisson linear models based on Zhang, Yanwei (2013) &lt;<a href="https://doi.org/10.1007%2Fs11222-012-9343-7">doi:10.1007/s11222-012-9343-7</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>biglm, ggplot2, minqa, nlme, reshape2, statmod, stats, stats4,
tweedie</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), coda, Matrix, splines, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Matrix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/actuaryzhang/cplm">https://github.com/actuaryzhang/cplm</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-14 00:24:03 UTC; waynezhang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-14 01:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcplm'>
Bayesian Compound Poisson Linear Models
</h2><span id='topic+bcplm'></span>

<h3>Description</h3>

<p>This function fits Tweedie compound Poisson linear models using Markov Chain Monte Carlo methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bcplm(formula, link = "log", data, inits = NULL,
  weights, offset, subset, na.action, contrasts = NULL, 
  n.chains = 3, n.iter = 2000, n.burnin = floor(n.iter / 2),
  n.thin = max(1, floor(n.chains * (n.iter - n.burnin) / n.sims)),
  n.sims = 1000, n.report = 2, prior.beta.mean = NULL, 
  prior.beta.var = NULL, bound.phi = 100, bound.p = c(1.01, 1.99), 
  tune.iter = 5000, n.tune = floor(tune.iter/100),  
  basisGenerators = c("tp", "bsp", "sp2d"), doFit = TRUE, ...)  
    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcplm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>. See <code><a href="stats.html#topic+glm">glm</a></code> and <code>cpglmm</code> for details.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_link">link</code></td>
<td>
<p>a specification for the model link function. This can be either a literal character string or a numeric number. If it is a character string, it must be one of &quot;log&quot;, &quot;identity&quot;, &quot;sqrt&quot; or &quot;inverse&quot;. If it is numeric, it is the same as the <code>link.power</code> argument in the <code><a href="statmod.html#topic+tweedie">tweedie</a></code> function. The default is <code>link = "log"</code>.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_inits">inits</code></td>
<td>
<p>a list of initial values to be used for each chain. It must be of length <code>n.chains</code>. Each element is a named list with the following components: 'beta' (fixed effects), 'phi' (dispersion), and 'p' (index parameter). If the formula indicates a mixed model, it must also contain two additional members 'u' (random effects) and 'Sigma' (variance components). 'Sigma' must be a list of the same format as the <code>ST</code> slot in <code>cpglmm</code>. If not supplied, the function will generate initial values automatically.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_data">data</code>, <code id="bcplm_+3A_subset">subset</code>, <code id="bcplm_+3A_weights">weights</code>, <code id="bcplm_+3A_na.action">na.action</code>, <code id="bcplm_+3A_offset">offset</code>, <code id="bcplm_+3A_contrasts">contrasts</code></td>
<td>
<p>further model specification arguments as in <code><a href="#topic+cpglm">cpglm</a></code>; see there for details.</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.chains">n.chains</code></td>
<td>
<p>an integer indicating the number of Markov chains (default: <code>3</code>).  
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.iter">n.iter</code></td>
<td>

<p>the number of total iterations per chain (including burn in; default: <code>2000</code>)
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.burnin">n.burnin</code></td>
<td>

<p>the length of burn in, i.e. number of iterations to discard at the beginning. Default
is <code>n.iter/2</code>, that is, discarding the first half of the simulations.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.thin">n.thin</code></td>
<td>

<p>thinning rate. Must be a positive integer. Set <code>n.thin &gt; 1</code> to save memory and
computation time if <code>n.iter</code> is large. Default is <code>max(1, floor(n.chains * (n.iter - n.burnin) / 1000))</code> which will only thin if there are at
least <code>2000</code> simulations.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.sims">n.sims</code></td>
<td>

<p>The approximate number of simulations to keep after thinning (all chains combined).
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.report">n.report</code></td>
<td>
<p>if greater than zero, fitting information will be printed out  <code>n.report</code> times for each chain. 
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_prior.beta.mean">prior.beta.mean</code></td>
<td>
<p>a vector of prior means for the fixed effects. Default is a vector of zeros. 
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_prior.beta.var">prior.beta.var</code></td>
<td>

<p>a vector of prior variances for the fixed effects. Default is a vector of <code>10000</code>'s.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_bound.phi">bound.phi</code></td>
<td>
<p>a numeric value indicating the upper bound of the uniform prior for the dispersion parameter. The default is <code>100</code>. The lower bound is set to be <code>0</code> in the function.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_bound.p">bound.p</code></td>
<td>
<p>a vector of lower and upper bounds for the index parameter <code class="reqn">p</code>. The default is <code>c(1.01, 1.99)</code>.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_tune.iter">tune.iter</code></td>
<td>
<p>the number of iterations used for tuning the proposal variances used in the Metropolis-Hastings updates. These iterations will not be included in the final output. Default is <code>5000</code>. Set it to be zero if the tuning process is not desired.  
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_n.tune">n.tune</code></td>
<td>
<p>a positive integer (default: <code>20</code>). The <code>tune.iter</code> iterations is divided into <code>n.tune</code> loops. Proposal variances are updated at the end of each loop if acceptance rates are outside the desired interval.
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_basisgenerators">basisGenerators</code></td>
<td>

<p>a character vector of names of functions that generate spline bases. See <code><a href="#topic+tp">tp</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_dofit">doFit</code></td>
<td>

<p>if <code>FALSE</code>, the constructed <code>"bcplm_input"</code> object is returned before the model is fitted. 
</p>
</td></tr>
<tr><td><code id="bcplm_+3A_...">...</code></td>
<td>
<p> not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides Markov chain Monte Carlo [MCMC] methods for fitting Tweedie compound Poisson linear models within the Bayesian framework. Both  generalized linear models and mixed models can be handled. In computing the posterior distribution, the series evaluation method (see, e.g., <code><a href="tweedie.html#topic+dtweedie">dtweedie</a></code>) is employed to evaluate the compound Poisson density.    
</p>
<p>In the Bayesian model, prior distributions have to be specified for all parameters in the model. Here, Normal distributions are used for the fixed effects (<code class="reqn">\beta</code>), a Uniform distribution for the  dispersion parameter (<code class="reqn">\phi</code>),  a Uniform distribution for the index parameter (<code class="reqn">p</code>). If a mixed model is specified,  prior distributions must be specified for the  variance component. If there is one random effect in a group, the inverse Gamma (scale = <code>0.001</code>, shape = <code>0.001</code>) is specified as the prior. If there is more than one random effects in a group, the inverse Wishart (identity matrix as the scale and the dimension of the covariance matrix as the shape)  is specified as the prior.
</p>
<p>Prior means and variances of the fixed effects can be supplied using the argument <code>prior.beta.mean</code> and <code>prior.beta.var</code>, respectively. The prior distribution of <code class="reqn">\phi</code> is uniform on (0, <code>bound.phi</code>). And the bounds of the Uniform for <code class="reqn">p</code> can be specified in the argument <code>bound.p</code>. See details in section 'Arguments'. 
</p>
<p>In implementing the MCMC, a Gibbs sampler is constructed in which parameters are updated one at a time given the current values of all the other parameters. Specifically, we use the random-walk Metropolis-Hastings algorithm in updating each parameter except for the variance components, which can be simulated directly due to conjugacy.
</p>
<p>Before the MCMC, there is a tuning process where the proposal variances of the (truncated) Normal proposal distributions are updated according to the sample variances computed from the simulations in each tuning loop. The goal is to make the acceptance rate roughly between 40% and 60% for univariate M-H updates. The argument <code>tune.iter</code> determines how many iterations are used for the tuning process, and <code>n.tune</code> determines how many loops these iterations should be divided into. These iterations will not be used in the final output. 
</p>
<p>The simulated values of all model parameters are stored in the  <code>sims.list</code> slot of the returned <code>bcplm</code> object. It is a list of <code>n.chains</code> matrices and each matrix has approximately <code>n.sims</code> rows. The <code>sims.list</code> slot is further coerced to be of class <code>"mcmc.list"</code> so that various methods from the  <code>coda</code> package can be directly applied  to get Markov chain diagnostics, posterior summary and plots. See <code>coda</code> for available methods.    
</p>


<h3>Value</h3>

<p><code>bcplm</code> returns an object of class <code>"bcplm"</code>. See <code><a href="#topic+bcplm-class">bcplm-class</a></code> for details of the return values as well as various methods available for this class.
</p>


<h3>Author(s)</h3>

<p>Yanwei (Wayne) Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a>
</p>


<h3>References</h3>

<p><cite> Zhang, Y (2013). Likelihood-based and Bayesian Methods for Tweedie Compound Poisson Linear Mixed Models, <em>Statistics and Computing</em>, 23, 743-757.
</cite>
</p>


<h3>See Also</h3>

<p>The users are recommended to see the documentation for <code><a href="#topic+bcplm-class">bcplm-class</a></code>, <code><a href="#topic+cpglm">cpglm</a></code>, <code><a href="#topic+cpglmm">cpglmm</a></code>, <code><a href="coda.html#topic+mcmc">mcmc</a></code>, and <code><a href="statmod.html#topic+tweedie">tweedie</a></code> for related information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# fit the FineRoot data with Bayesian models
# Bayesian cpglm
set.seed(10)
fit1 &lt;- bcplm(RLD ~ factor(Zone) * factor(Stock), 
            data = FineRoot, tune.iter = 2000, 
            n.iter = 6000, n.burnin = 1000, n.thin = 5)

gelman.diag(fit1$sims.list)
# diagnostic plots                             
acfplot(fit1$sims.list, lag.max = 20)
xyplot(fit1$sims.list)                              
densityplot(fit1$sims.list)               
summary(fit1)
plot(fit1)
                          

# now fit the Bayesian model to an insurance loss triangle 
# (see Peters et al. 2009)
fit2 &lt;- bcplm(increLoss ~ factor(year) + factor(lag), 
            data = ClaimTriangle, n.iter = 12000, 
            n.burnin = 2000, n.thin = 10, bound.p = c(1.1, 1.95))
gelman.diag(fit2$sims.list)                   
summary(fit2)

# mixed models 
set.seed(10)
fit3 &lt;- bcplm(RLD ~ Stock * Zone + (1|Plant), 
            data = FineRoot, n.iter = 15000, 
            n.burnin = 5000, n.thin = 10)
gelman.diag(fit3$sims.list)                   
summary(fit3)




## End(Not run)

</code></pre>

<hr>
<h2 id='class-methods'>Classes and Methods for a Compound Poisson Linear Model Object</h2><span id='topic+cplm-class'></span><span id='topic++24+2Ccplm-method'></span><span id='topic++5B+2Ccplm+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Ccplm+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+5B+2Ccplm+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+2Ccplm+2Cnumeric+2Cmissing-method'></span><span id='topic+model.matrix+2Ccplm-method'></span><span id='topic+names+2Ccplm-method'></span><span id='topic+show+2Ccplm-method'></span><span id='topic+terms+2Ccplm-method'></span><span id='topic+formula+2Ccplm-method'></span><span id='topic+vcov+2Ccplm-method'></span><span id='topic+cpglm-class'></span><span id='topic+coef+2Ccpglm-method'></span><span id='topic+fitted+2Ccpglm-method'></span><span id='topic+residuals+2Ccpglm-method'></span><span id='topic+resid+2Ccpglm-method'></span><span id='topic+AIC+2Ccpglm+2Cmissing-method'></span><span id='topic+deviance+2Ccpglm-method'></span><span id='topic+summary+2Ccpglm-method'></span><span id='topic+predict+2Ccpglm-method'></span><span id='topic+cpglmm-class'></span><span id='topic+coef+2Ccpglmm-method'></span><span id='topic+fixef+2Ccpglmm-method'></span><span id='topic+ranef+2Ccpglmm-method'></span><span id='topic+logLik+2Ccpglmm-method'></span><span id='topic+anova+2Ccpglmm-method'></span><span id='topic+fitted+2Ccpglmm-method'></span><span id='topic+residuals+2Ccpglmm-method'></span><span id='topic+resid+2Ccpglmm-method'></span><span id='topic+print+2Ccpglmm-method'></span><span id='topic+summary+2Ccpglmm-method'></span><span id='topic+show+2Ccpglmm-method'></span><span id='topic+VarCorr+2Ccpglmm-method'></span><span id='topic+vcov+2Ccpglmm-method'></span><span id='topic+predict+2Ccpglmm-method'></span><span id='topic+summary.cpglmm-class'></span><span id='topic+bcplm-class'></span><span id='topic+plot+2Cbcplm+2Cmissing-method'></span><span id='topic+summary+2Cbcplm-method'></span><span id='topic+show+2Cbcplm-method'></span><span id='topic+VarCorr+2Cbcplm-method'></span><span id='topic+fixef+2Cbcplm-method'></span><span id='topic+NullNum-class'></span><span id='topic+NullList-class'></span><span id='topic+NullFunc-class'></span><span id='topic+ListFrame-class'></span><span id='topic+gini-class'></span><span id='topic+plot+2Cgini+2Cmissing-method'></span><span id='topic+show+2Cgini-method'></span><span id='topic+VarCorr'></span><span id='topic+VarCorr-methods'></span>

<h3>Description</h3>

<p>Documented here are the <code>"cplm"</code> class and its derived classes <code>"cpglm"</code>, <code>"cpglmm"</code>, and <code>"bcplm"</code>. Several primitive methods and statistical methods are created to facilitate the extraction of specific slots and further statistical analysis. <code>"gini"</code> is a class that stores the Gini indices and associated standard errors that could be used to perform model comparison involving the compound Poisson distribution. <code>"NullNum"</code>,  <code>"NullList"</code>, <code>"NullFunc"</code> and <code>"ListFrame"</code> are virtual classes for <code>c("NULL", "numeric")</code>, <code>c("NULL","list")</code>, <code>c("NULL","function")</code> and <code>c("list","data.frame")</code>, respectively. 
</p>


<h3>Objects from the Class</h3>


<dl>
<dt><code>"cplm"</code></dt><dd><p>Objects can be created by calls of the form <code>new("cplm", ...)</code>.</p>
</dd> 
<dt><code>"cpglm"</code></dt><dd><p>Objects can be created by calls from <code>new("cpglm", ...)</code> or <code>cpglm</code>.</p>
</dd> 
<dt><code>"cpglmm"</code></dt><dd><p>Objects can be created by calls of the form <code>new("cpglmm", ...)</code>, or a call to <code>cpglmm</code>.</p>
</dd>
<dt><code>"summary.cpglmm"</code></dt><dd><p>Objects can be created by calls of the form <code>new("summary.cpglmm", ...)</code>, or a call to <code>summary</code> on a <code>cpglmm</code> object. </p>
</dd>
<dt><code>"bcplm"</code></dt><dd><p>Objects can be created by calls from <code>new("bcplm", ...)</code> or <code>bcplm</code>.</p>
</dd>
<dt><code>"gini"</code></dt><dd><p>Objects can be created by calls from <code>new("gini", ...)</code> or <code>gini</code>.</p>
</dd>  
<dt><code>"NullNum"</code>, <code>"NullList"</code>, <code>"NullFunc"</code></dt><dd><p>These are  virtual classes and  no objects may be created from them.</p>
</dd>
</dl>
 


<h3>Slots</h3>

<p>The <code>"cplm"</code> class defines the slots common in all the model classes in the <code>cplm</code> package, and thus the utility methods defined on the <code>"cplm"</code> class such as <code>[</code>, <code>names</code> and so on are applicable to all of the derived classes. 
</p>

<dl>
<dt><code>call</code>:</dt><dd><p>the matched call. </p>
</dd>
<dt><code>formula</code>:</dt><dd><p>the formula supplied, class <code>"formula"</code></p>
</dd>
<dt><code>contrasts</code>:</dt><dd><p>the contrasts used, class <code>"NullList"</code> </p>
</dd>
<dt><code>link.power</code>:</dt><dd><p>index of power link function, class <code>"numeric"</code>. See <code><a href="statmod.html#topic+tweedie">tweedie</a></code>.</p>
</dd>
<dt><code>model.frame</code>:</dt><dd><p>the data frame used. class <code>"ListFrame"</code>. </p>
</dd>
<dt><code>inits</code>:</dt><dd><p>initial values used, class <code>"NullList"</code>.</p>
</dd>
</dl>

<p>The <code>"cpglm"</code> class extends <code>"cplm"</code> directly. Most of the slots have the same definition as those in <code><a href="stats.html#topic+glm">glm</a></code>.  The following slots are in addition to those in <code>"cplm"</code>:
</p>

<dl>
<dt><code>coefficients</code>:</dt><dd><p>estimated mean parameters, class <code>"numeric"</code>. </p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>the working residuals, that is the residuals in the final iteration of the IWLS fit, class <code>"numeric"</code></p>
</dd>
<dt><code>fitted.values</code>:</dt><dd><p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function, class <code>"numeric"</code> </p>
</dd>
<dt><code>linear.predictors</code>:</dt><dd><p>the fitted linear predictors, class <code>"numeric"</code></p>
</dd>    
<dt><code>weights</code>:</dt><dd><p>working weights from the last iteration of the iterative least square, class <code>"numeric"</code></p>
</dd>
<dt><code>df.residual</code>:</dt><dd><p>residual degrees of freedom, class <code>"integer"</code></p>
</dd>
<dt><code>deviance</code>:</dt><dd><p>up to a constant, minus twice the maximized log-likelihood. Where sensible, the constant is chosen so that a saturated model has deviance zero. This is computed using <code><a href="tweedie.html#topic+tweedie.dev">tweedie.dev</a></code>.</p>
</dd>
<dt><code>aic</code>:</dt><dd><p>a version of Akaike's Information Criterion, minus twice the maximized log-likelihood plus twice the number of mean parameters. This is computed using the tweedie density approximation as in <code><a href="tweedie.html#topic+dtweedie">dtweedie</a></code>. </p>
</dd>
<dt><code>offset</code>:</dt><dd><p>the offset vector used, class <code>"NullNum"</code>,</p>
</dd> 
<dt><code>prior.weights</code>:</dt><dd><p>the weights initially supplied, a vector of <code>1</code>s if none were, class <code>"NullNum"</code></p>
</dd>        
<dt><code>y</code>:</dt><dd><p>the response vector used.</p>
</dd>
<dt><code>control</code>:</dt><dd><p>the value of the control argument used, class <code>"list"</code> </p>
</dd>
<dt><code>p</code>:</dt><dd><p>the maximum likelihood estimate of the index parameter.</p>
</dd>    
<dt><code>phi</code>:</dt><dd><p>the maximum likelihood estimate of the dispersion parameter.</p>
</dd>    
<dt><code>vcov</code>:</dt><dd><p>estimated variance-covariance matrix, class <code>"matrix"</code></p>
</dd>    
<dt><code>iter</code>:</dt><dd><p>the number of Fisher's scoring iterations in the final GLM.</p>
</dd>
<dt><code>converged</code>:</dt><dd><p>indicating whether the algorithm has converged, class <code>"logical"</code>.</p>
</dd>
<dt><code>na.action</code>:</dt><dd><p>method of handling <code>NA</code>'s, class <code>"NullFunc"</code>.</p>
</dd>
</dl>
    
<p>The  <code>"cpglmm"</code> class extends <code>"cplm"</code> and the old version of <code>"mer"</code> class from <code>lme4</code> directly, and has the following additional slots:
</p>

<dl>
<dt><code>p</code>:</dt><dd><p>estimated value of the index parameter, class <code>"numeric"</code>  </p>
</dd>
<dt><code>phi</code>:</dt><dd><p>estimated value of the dispersion parameter, class <code>"numeric"</code> </p>
</dd>
<dt><code>bound.p</code>:</dt><dd><p>the specified bounds of the index parameter, class <code>"numeric"</code>   </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>estimated variance-covariance matrix, class <code>"matrix"</code></p>
</dd>
<dt><code>smooths</code>:</dt><dd><p>a list of smooth terms</p>
</dd>
</dl>

<p>The slots it used from the old <code>"mer"</code> class has the following slots (copied from <code>lme4_0.999999-2</code>):
</p>

<dl>
<dt><code>env</code>:</dt><dd><p>An environment (class <code>"environment"</code>)
created for the evaluation of the nonlinear model function. </p>
</dd>
<dt><code>nlmodel</code>:</dt><dd><p>The nonlinear model function as an object of
class <code>"call"</code>. </p>
</dd>
<dt><code>frame</code>:</dt><dd><p>The model frame (class <code>"data.frame"</code>).</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The matched call to the function that
created the object. (class <code>"call"</code>).</p>
</dd>
<dt><code>flist</code>:</dt><dd><p>The list of grouping factors for the random
effects.</p>
</dd>
<dt><code>X</code>:</dt><dd><p>Model matrix for the fixed effects. </p>
</dd>
<dt><code>Zt</code>:</dt><dd><p>The transpose of model matrix for the random
effects, stored as a compressed column-oriented sparse matrix (class
<code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code>).</p>
</dd>
<dt><code>pWt</code>:</dt><dd><p>Numeric prior weights vector. This may be of length
zero (0), indicating unit prior weights.</p>
</dd>
<dt><code>offset</code>:</dt><dd><p>Numeric offset vector. This may be of length
zero (0), indicating no offset.</p>
</dd>
<dt><code>y</code>:</dt><dd><p>The response vector (class <code>"numeric"</code>).</p>
</dd>
<dt><code>Gp</code>:</dt><dd><p>Integer vector of group pointers within the random
effects vector.  The elements of <code>Gp</code> are 0-based indices of
the first element from each random-effects term.  Thus the first
element is always 0.  The last element is the total length of the
random effects vector.</p>
</dd>
<dt><code>dims</code>:</dt><dd><p>A named integer vector of dimensions.  Some of
the dimensions are <code class="reqn">n</code>, the number of observations, <code class="reqn">p</code>, the
number of fixed effects, <code class="reqn">q</code>, the total number of random
effects, <code class="reqn">s</code>, the number of parameters in the nonlinear model
function and <code class="reqn">nt</code>, the number of random-effects terms in the
model.</p>
</dd>
<dt><code>ST</code>:</dt><dd><p>A list of S and T factors in the TSST' Cholesky
factorization of the relative variance matrices of the random
effects associated with each random-effects term.  The unit lower
triangular matrix, <code class="reqn">T</code>, and the diagonal matrix, <code class="reqn">S</code>, for
each term are stored as a single matrix with diagonal elements
from <code class="reqn">S</code> and off-diagonal elements from <code class="reqn">T</code>.</p>
</dd>
<dt><code>V</code>:</dt><dd><p>Numeric gradient matrix (class <code>"matrix"</code>) of
the nonlinear model function.</p>
</dd>
<dt><code>A</code>:</dt><dd><p>Scaled sparse model matrix (class
<code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code>) for
the the unit, orthogonal random effects, <code class="reqn">U</code>.</p>
</dd>
<dt><code>Cm</code>:</dt><dd><p>Reduced, weighted sparse model matrix (class
<code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code>) for the
unit, orthogonal random effects, U.  .</p>
</dd>
<dt><code>Cx</code>:</dt><dd><p>The <code>"x"</code> slot in the weighted sparse model
matrix (class <code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code>)
for the unit, orthogonal random effects, <code class="reqn">U</code>, in generalized
linear mixed models.  For these models the matrices <code class="reqn">A</code> and
<code class="reqn">C</code> have the same sparsity pattern and only the <code>"x"</code>
slot of <code class="reqn">C</code> needs to be stored.</p>
</dd>
<dt><code>L</code>:</dt><dd><p>The sparse lower Cholesky factor of <code class="reqn">P(AA'+I)P'</code>
(class <code>"<a href="Matrix.html#topic+CHMfactor-class">dCHMfactor</a>"</code>) where <code class="reqn">P</code>
is the fill-reducing permutation calculated from the pattern of
nonzeros in <code class="reqn">A</code>.</p>
</dd>
<dt><code>deviance</code>:</dt><dd><p>Named numeric vector containing the deviance
corresponding to the maximum likelihood (the <code>"ML"</code> element)
and <code>"REML"</code> criteria and various components. The
<code>"ldL2"</code> element is twice the logarithm of the determinant of
the Cholesky factor in the <code>L</code> slot. The <code>"usqr"</code>
component is the value of the random-effects quadratic form.</p>
</dd>
<dt><code>fixef</code>:</dt><dd><p>Numeric vector of fixed effects.</p>
</dd>
<dt><code>ranef</code>:</dt><dd><p>Numeric vector of random effects on the
original scale.</p>
</dd>
<dt><code>u</code>:</dt><dd><p>Numeric vector of orthogonal, constant variance,
random effects.</p>
</dd>
<dt><code>eta</code>:</dt><dd><p>The linear predictor at the current values of the
parameters and the random effects.</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>The means of the responses at the current parameter
values.</p>
</dd>
<dt><code>muEta</code>:</dt><dd><p>The diagonal of the Jacobian of <code class="reqn">\mu</code>
by <code class="reqn">\eta</code>.  Has length zero (0) except for generalized
mixed models.</p>
</dd>
<dt><code>var</code>:</dt><dd><p>The diagonal of the conditional variance of
<code class="reqn">Y</code> given the random effects, up to prior weights.  In
generalized mixed models this is the value of the variance
function for the <code><a href="stats.html#topic+glm">glm</a></code> family.</p>
</dd>
<dt><code>resid</code>:</dt><dd><p>The residuals, <code class="reqn">y - \mu</code>, weighted by
the <code>sqrtrWt</code> slot (when its length is <code class="reqn">&gt;0</code>).</p>
</dd>
<dt><code>sqrtXWt</code>:</dt><dd><p>The square root of the weights applied to the
model matrices <code class="reqn">X</code> and <code class="reqn">Z</code>. This may be of length zero
(0), indicating unit weights.</p>
</dd>
<dt><code>sqrtrWt</code>:</dt><dd><p>The square root of the weights applied to the
residuals to obtain the weighted residual sum of squares. This may
be of length zero (0), indicating unit weights.</p>
</dd>
<dt><code>RZX</code>:</dt><dd><p>The dense solution (class <code>"matrix"</code>) to
<code class="reqn">L RZX = ST'Z'X = AX</code>.</p>
</dd>
<dt><code>RX</code>:</dt><dd><p>The upper Cholesky factor (class <code>"matrix"</code>)
of the downdated <code class="reqn">X'X</code>.</p>
</dd>
</dl>

<p>The <code>"summary.cpglmm"</code> class <em>contains</em> the <code>"cpglmm"</code>
class and has the following additional slots:
</p>

<dl>
<dt><code>methTitle</code>:</dt><dd><p>character string specifying a method title</p>
</dd>
<dt><code>logLik</code>:</dt><dd><p>the same as <code>logLik(object)</code>.</p>
</dd>
<dt><code>ngrps</code>:</dt><dd><p>the number of levels per grouping factor in the
<code>flist</code> slot.</p>
</dd>
<dt><code>sigma</code>:</dt><dd><p>the scale factor for the variance-covariance estimates</p>
</dd>
<dt><code>coefs</code>:</dt><dd><p>the matrix of estimates, standard errors,
etc. for the fixed-effects coefficients</p>
</dd>
<dt><code>REmat</code>:</dt><dd><p>the formatted Random-Effects matrix</p>
</dd>
<dt><code>AICtab</code>:</dt><dd><p>a named vector of values of AIC, BIC, log-likelihood
and deviance</p>
</dd>
</dl>
    
<p>The  <code>"bcplm"</code> class extends <code>"cplm"</code> directly, and has the following additional slots: 
</p>

<dl>
<dt><code>dims</code>:</dt><dd><p>a named integer vector of dimensions. </p>
</dd>
<dt><code>sims.list</code>:</dt><dd><p>an object of class <code>"mcmc.list"</code>. It is a list of <code>n.chains</code> <code>mcmc</code> objects, each <code>mcmc</code> object storing the simulation result from a Markov chain. See <code><a href="coda.html#topic+mcmc">mcmc</a></code> and <code><a href="coda.html#topic+mcmc.convert">mcmc.convert</a></code>. Since this is an <code>"mcmc.list"</code> object, most methods defined in the  <code>coda</code> package can be directly applied to it. </p>
</dd>
<dt><code>Zt</code>:</dt><dd><p>the transpose of model matrix for the random effects, stored as a compressed column-oriented sparse matrix (class <code>"dgCMatrix"</code>).</p>
</dd>
<dt><code>flist</code>:</dt><dd><p>the list of grouping factors for the random effects.</p>
</dd>  
<dt><code>prop.var</code>:</dt><dd><p>a named list of proposal variance-covariance matrix used in the Metropolis-Hasting update.</p>
</dd>
</dl>

<p>The <code>"gini"</code> class has the following slots:
</p>

<dl>
<dt><code>call</code>:</dt><dd><p>the matched call. </p>
</dd>
<dt><code>gini</code>:</dt><dd><p>a matrix of the Gini indices. The row names are corresponding to the base while the column names are corresponding to the scores.</p>
</dd>
<dt><code>sd</code>:</dt><dd><p>a matrix of standard errors for each computed Gini index. </p>
</dd>
<dt><code>lorenz</code>:</dt><dd><p>a list of matrices that determine the graph of the ordered Lorenz curve associated with each base and score combination. For each base, there is an associated matrix.   </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"cpglm"</code> extends class <code>"<a href="#topic+cplm-class">cplm</a>"</code>, directly.
</p>
<p>Class <code>"cpglmm"</code> extends class <code>"<a href="#topic+cplm-class">cplm</a>"</code>, directly;
</p>
<p>Class <code>"summary.cpglmm"</code>  extends class <code>"<a href="#topic+cpglmm-class">cpglmm</a>"</code>, directly; 
class <code>"<a href="#topic+cplm-class">cplm</a>"</code>, by class <code>"<a href="#topic+cpglmm-class">cpglmm</a>"</code>, distance 2.
</p>
<p>Class <code>"bcplm"</code> extends class <code>"<a href="#topic+cplm-class">cplm</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>The following methods are defined for the class <code>"cplm"</code>, which are also applicable to all of the derived classes:
</p>

<dl>
<dt>$</dt><dd><p><code>signature(x = "cplm")</code>:  extract a slot of <code>x</code> with a specified slot name, just as in list. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "cplm", i = "numeric", j = "missing")</code>:  extract the i-th slot of a <code>"cpglm"</code> object, just as in list. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "cplm", i = "character", j = "missing")</code>: extract the slots of a <code>"cpglm"</code> object with names in <code>i</code>, just as in list.</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "cplm", i = "numeric", j = "missing", drop="missing")</code>:  extract the i-th slot of a <code>"cpglm"</code> object, just as in list. <code>i</code> could be a vector. </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "cplm", i = "character", j = "missing", drop="missing")</code>:  extract the slots of a <code>"cpglm"</code> object with names in <code>i</code>, just as in list. <code>i</code> could be a vector. </p>
</dd>    
<dt>names</dt><dd><p><code>signature(x = "cplm")</code>:  return the slot names. </p>
</dd>
<dt>terms</dt><dd><p><code>signature(x = "cplm")</code>: extract the <code>terms</code> object from the model frame.  See <code><a href="stats.html#topic+terms">terms</a></code>.</p>
</dd>
<dt>formula</dt><dd><p><code>signature(x = "cplm")</code>: extract the <code>formula</code> slot.  See <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</dd>    
<dt>model.matrix</dt><dd><p><code>signature(object = "cplm")</code>: extract the design matrix.  </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "cplm")</code>: method for <code>show</code>. </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "cplm")</code>: extract the variance-covariance matrix of a <code>"cplm"</code> object.</p>
</dd>
</dl>

<p>The following methods are defined for the <code>"cpglm"</code> class:
</p>
    
<dl>
<dt>coef</dt><dd><p><code>signature(object = "cpglm")</code>:  extract the estimated coefficients.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "cpglm")</code>: return the fitted values. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "cpglm")</code>: extract residuals  from a <code>cpglm</code> object. You can also specify a <code>type</code> argument to indicate the type of residuals to be computed. See <code><a href="stats.html#topic+glm.summaries">glm.summaries</a></code>.</p>
</dd>
<dt>resid</dt><dd><p><code>signature(object = "cpglm")</code>: same as <code>residuals</code>.</p>
</dd>   
<dt>AIC</dt><dd><p><code>signature(object = "cpglm",k="missing")</code>: extract the AIC information from the <code>"cpglm"</code> object.  See <code><a href="stats.html#topic+AIC">AIC</a></code>.</p>
</dd>    
<dt>deviance</dt><dd><p><code>signature(object = "cpglm")</code>: extract the deviance from the <code>"cpglm"</code> object.  See <code><a href="stats.html#topic+deviance">deviance</a></code>.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "cpglm")</code>:  the same as <code><a href="stats.html#topic+glm.summaries">glm.summaries</a></code> except that both the dispersion and the index parameter are estimated using maximum likelihood estimation.  </p>
</dd>    
<dt>predict</dt><dd><p><code>signature(object = "cpglm")</code>: generate predictions for new data sets</p>
</dd>
</dl>

<p>The following are written for <code>"cpglmm"</code>: 
</p>

<dl>
<dt>print</dt><dd><p><code>signature(x = "cpglmm")</code>:  print the object </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "cpglmm")</code>: summary results</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "cpglmm")</code>: generate predictions for new data sets</p>
</dd>
<dt>VarCorr</dt><dd><p><code>signature(x = "cpglmm")</code>: estimation for the variance components </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "cpglmm")</code>: variance-covariance matrix for fixed effects </p>
</dd>
</dl>

<p>The following methods are available for the class <code>"bcplm"</code>: 
</p>

<dl>
<dt>plot</dt><dd><p><code>signature(x = "bcplm", y = "missing")</code>: summarize the <code>"bcplm"</code> object with a trace of the sampled output and a density estimate for each variable in the chain. See <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code>. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "bcplm")</code>:  produce two sets of summary statistics. See <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>. </p>
</dd>
<dt>VarCorr</dt><dd><p><code>signature(x = "bcplm")</code>: estimation for the variance components if the random effects are present </p>
</dd>
<dt>fixef</dt><dd><p><code>signature(object = "bcplm")</code>: extract fixed effects. Additional arguments include: <code>sd = FALSE</code>: extract standard errors; <code>quantiles = NULL</code>: compute empirical quantiles. These additional statistics are stored as attributes in the returned results.</p>
</dd>
</dl>

<p>The following methods are defined for the <code>"gini"</code> class:
</p>

<dl>
<dt>plot</dt><dd><p><code>signature(x = "gini", y = "missing")</code>: plot the ordered Lorenz curve from each model comparison. If <code>overlay = TRUE</code> (the default), different curves are plotted on the same graph for each base. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "gini")</code>: print the computed Gini indices and standard errors.</p>
</dd>
</dl>
 


<h3>Author(s)</h3>

<p> Wayne  Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+cpglm">cpglm</a></code>, <code><a href="#topic+cpglmm">cpglmm</a></code>, <code><a href="#topic+bcplm">bcplm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>.   
</p>

<hr>
<h2 id='cpglm'>Compound Poisson Generalized Linear Models
</h2><span id='topic+cpglm'></span>

<h3>Description</h3>

<p>This function fits compound Poisson generalized linear models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpglm(formula, link = "log", data, weights, offset, 
          subset, na.action = NULL, contrasts = NULL, 
          control = list(), chunksize = 0, 
          optimizer = "nlminb", ...)                      
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpglm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>. See also in <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_link">link</code></td>
<td>
<p>a specification for the model link function. This can be either a literal character string or a numeric number. If it is a character string, it must be one of &quot;log&quot;, &quot;identity&quot;, &quot;sqrt&quot; or &quot;inverse&quot;. If it is numeric, it is the same as the <code>link.power</code> argument in the <code><a href="statmod.html#topic+tweedie">tweedie</a></code> function. The default is <code>link = "log"</code>.
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. 
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights. Should be either <code>NULL</code> or a numeric vector. When it is numeric, it must be positive. Zero weights are not allowed in <code>cpglm</code>. 
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of options, and is <code>na.fail</code> if that is unset.  Another possible value is <code>NULL</code>, no action. Value <code>na.exclude</code> can be useful.
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be either <code>NULL</code> or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. 
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See <code>contrasts.arg</code>.
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controling the fitting process. See 'Details' below. 
</p>
</td></tr> 
<tr><td><code id="cpglm_+3A_chunksize">chunksize</code></td>
<td>
<p>an integer that indicates the size of chunks for processing the data frame as used in <code><a href="biglm.html#topic+bigglm">bigglm</a></code>. The value of this argument also determines how the model is estimated. When it is <code>0</code> (the default), regular Fisher's scoring algorithms are used, which may run into memory issues when handling large data sets. In contrast,  a value  greater than <code>0</code> indicates that the <code>bigglm</code> is employed to fit the GLMs. The function <code>bigglm</code> relies on the bounded memory regression technique, and thus is well suited to large data GLMs. 
</p>
</td></tr> 
<tr><td><code id="cpglm_+3A_optimizer">optimizer</code></td>
<td>
<p>a character string that determines which optimization routine is to be used in estimating the index and the dispersion parameters. Possible choices are <code>"nlminb"</code> (the default, see <code><a href="stats.html#topic+nlminb">nlminb</a></code>), <code>"bobyqa"</code> (<code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>) and <code>"L-BFGS-B"</code> (<code><a href="stats.html#topic+optim">optim</a></code>).   
</p>
</td></tr>
<tr><td><code id="cpglm_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>bigglm</code>. Not used when <code>chunksize = 0</code>. The <code>maxit</code> argument defaults to <code>50</code> in <code>cpglm</code> if not specified. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the profile likelihood approach in Tweedie compound Poisson generalized linear models. First, the index and the dispersion parameters are estimated  by maximizing (numerically) the profile likelihood (profile out the mean parameters as they are determined for a given value of the index parameter). Then the mean parameters are estimated using a GLM with the above-estimated index parameter. To compute the profile likelihood, one must resort to numerical methods provided in the  <code>tweedie</code> package for approximating the density of the compound Poisson distribution. Indeed, the function  <code><a href="tweedie.html#topic+tweedie.profile">tweedie.profile</a></code> in that package makes available the profile likelihood approach. The <code>cpglm</code> function  differs from <code><a href="tweedie.html#topic+tweedie.profile">tweedie.profile</a></code> in two aspects. First, the user does not need to specify the grid of possible values the index parameter can take. Rather, the optimization of the profile likelihood is automated.   Second, big data sets can be handled where the <code>bigglm</code> function from the <code>biglm</code> package is used in fitting GLMs. The <code>bigglm</code> is invoked when the argument <code>chunksize</code> is greater than 0. It is also to be noted that only MLE estimate for the dispersion parameter is included here, while <code><a href="tweedie.html#topic+tweedie.profile">tweedie.profile</a></code> provides several other possibilities.
</p>
<p>The package used to implement a second approach using the Monte Carlo EM algorithm, but it is now removed because it does not offer obvious advantages over the profile likelihood approach for this model.
</p>
<p>The <code>control</code> argument is a list that can supply various controlling elements used in the optimization process, and it has the following components:
</p>

<dl>
<dt><code>bound.p</code></dt><dd><p>a vector of lower and upper bounds for the index parameter <code class="reqn">p</code> used in the optimization. The default is <code>c(1.01, 1.99)</code>. </p>
</dd>
<dt><code>trace</code></dt><dd><p>if greater than 0, tracing information on the progress of the fitting is produced. For <code>optimizer = "nlminb"</code> or <code>optimizer = "L-BFGS-B"</code>, this is the same as the <code>trace</code> control parameter, and for <code>optimizer = "bobyqa"</code>, this is the same as the <code>iprint</code> control parameter. See the corresponding documentation for details. 
</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>maximum number of iterations allowed in the optimization. The default is <code>300</code>. </p>
</dd>
<dt><code>max.fun</code></dt><dd><p>maximum number of function evaluations allowed in the optimizer. The default is <code>2000</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>cpglm</code> returns an object of class <code>"cpglm"</code>. See <code><a href="#topic+cpglm-class">cpglm-class</a></code> for details of the return values as well as various methods available for this class. 
</p>


<h3>Author(s)</h3>

<p>Yanwei (Wayne) Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a>
</p>


<h3>References</h3>

<p><cite> Dunn, P.K. and Smyth, G.K. (2005). Series evaluation of Tweedie exponential dispersion models densities. <em>Statistics and Computing</em>, 15, 267-280.</cite>
</p>


<h3>See Also</h3>

<p>The users are recommended to see the documentation for <code><a href="#topic+cpglm-class">cpglm-class</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="statmod.html#topic+tweedie">tweedie</a></code>, and <code><a href="tweedie.html#topic+tweedie.profile">tweedie.profile</a></code> for related information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit1 &lt;- cpglm(RLD ~ factor(Zone) * factor(Stock),
  data = FineRoot)
     
# residual and qq plot
parold &lt;- par(mfrow = c(2, 2), mar = c(5, 5, 2, 1))
# 1. regular plot
r1 &lt;- resid(fit1) / sqrt(fit1$phi)
plot(r1 ~ fitted(fit1), cex = 0.5)
qqnorm(r1, cex = 0.5)
# 2. quantile residual plot to avoid overlapping
u &lt;- tweedie::ptweedie(fit1$y, fit1$p, fitted(fit1), fit1$phi)
u[fit1$y == 0] &lt;- runif(sum(fit1$y == 0), 0, u[fit1$y == 0])
r2 &lt;- qnorm(u)
plot(r2 ~ fitted(fit1), cex = 0.5)
qqnorm(r2, cex = 0.5)
par(parold)

# use bigglm 
fit2 &lt;- cpglm(RLD ~ factor(Zone), 
  data = FineRoot, chunksize = 250)

</code></pre>

<hr>
<h2 id='cpglmm'>
Compound Poisson Generalized Linear Mixed Models
</h2><span id='topic+cpglmm'></span>

<h3>Description</h3>

<p>Laplace approximation and adaptive Gauss-Hermite quadrature methods for compound Poisson  mixed and additive models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpglmm(formula, link = "log", data, weights, offset, subset, 
    na.action, inits = NULL,  contrasts = NULL, 
    control = list(), basisGenerators = c("tp", "bsp", "sp2d"),
    optimizer = "nlminb", doFit = TRUE, nAGQ = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpglmm_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing the  model structure, with the response on the left of a ~ operator and the terms, separated by + operators, on the right. The vertical bar character &quot;|&quot; separates an expression for a model matrix and a grouping factor. The right side can also include basis generators. See <code>lme4</code> and <code>basisGenerators</code> below.</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_link">link</code></td>
<td>
<p>a specification for the model link function. This can be either a literal character string or a numeric number. If it is a character string, it must be one of &quot;log&quot;, &quot;identity&quot;, &quot;sqrt&quot; or &quot;inverse&quot;. If it is numeric, it is the same as the <code>link.power</code> argument in the <code><a href="statmod.html#topic+tweedie">tweedie</a></code> function. The default is <code>link="log"</code>.
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model.
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_subset">subset</code>, <code id="cpglmm_+3A_weights">weights</code>, <code id="cpglmm_+3A_na.action">na.action</code>, <code id="cpglmm_+3A_offset">offset</code>, <code id="cpglmm_+3A_contrasts">contrasts</code></td>
<td>
<p>further model specification arguments as in <code><a href="#topic+cpglm">cpglm</a></code>; see there for details.</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_inits">inits</code></td>
<td>
<p>a named list with three components 'beta', 'phi', 'p', 'Sigma' that supply the initial values used in the optimization. If not supplied, the function will generate initial values automatically, which are based on a GLM with the supplied model structure.
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_control">control</code></td>
<td>

<p>a list of parameters for controlling the fitting process. See <code><a href="#topic+cpglm">cpglm</a></code>. The parameter <code>PQL.init</code> is not used.
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_basisgenerators">basisGenerators</code></td>
<td>

<p>a character vector of names of functions that generate spline bases. This is used when smoothing effects are to be included in the model. See <code><a href="#topic+tp">tp</a></code> for details. 
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_optimizer">optimizer</code></td>
<td>

<p>a character string that determines which optimization routine is to be used. Possible choices are <code>"nlminb"</code> (the default, see <code><a href="stats.html#topic+nlminb">nlminb</a></code>), <code>"bobyqa"</code> (<code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>) and <code>"L-BFGS-B"</code> (<code><a href="stats.html#topic+optim">optim</a></code>).   
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_dofit">doFit</code></td>
<td>

<p>if <code>FALSE</code>, the constructed <code>"cpglmm"</code> object is returned before the model is fitted. 
</p>
</td></tr>
<tr><td><code id="cpglmm_+3A_nagq">nAGQ</code></td>
<td>

<p>a positive integer - the number of points per axis for evaluating the adaptive Gauss-Hermite approximation to the log-likelihood. This defaults to 1, corresponding to the Laplacian approximation. Values greater than 1 produce greater accuracy in the evaluation of the log-likelihood at the expense of speed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of compound Poisson mixed models in  existing software has been limited to the Penalized Quasi-Likelihood [PQL] approach (e.g., see <code><a href="MASS.html#topic+glmmPQL">glmmPQL</a></code>). While straightforward and fast, this method is not equipped to estimate the unknown variance function, i.e., the index parameter. In contrast, the function <code>cpglmm</code> implements true likelihood-based inferential procedures, i.e., the Laplace approximation and the Adaptive Gauss-Hermite Quadrature (for single grouping factor), so that all parameters in the model can be estimated using maximum likelihood estimation. 
</p>
<p>This implementation is based on the older <code>lme4</code> package (the <code>0.9*</code> version), with changes made on updating of the mean, the variance function and the marginal loglikelihood. For the Laplace method, the contribution of the dispersion parameter to the approximated loglikelihood is explicitly accounted for, which should be more accurate and more consistent with the quadrature estimate. Indeed, both the dispersion parameter and  the index parameter are included as a part of the optimization process. In computing the marginal loglikelihood, the density of the compound Poisson distribution is approximated using numerical methods provided in the <code>tweedie</code> package. For details of the Laplace approximation and the Gauss-Hermite quadrature method for generalized linear mixed models, see the documentation associated with <code>lme4</code>. 
</p>
<p>In addition, similar to the package <code>amer</code> (already retired from CRAN), we provide convenient interfaces for fitting additive models using penalized splines.  See the 'example' section for one such application.  
</p>


<h3>Value</h3>

<p><code>cpglmm</code> returns an object of class <code>cpglmm</code>. See <code><a href="#topic+cpglmm-class">cpglmm-class</a></code> for details of the return values as well as various method available for this class.
</p>


<h3>Author(s)</h3>

<p>Yanwei (Wayne)) Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a>
</p>


<h3>References</h3>

<p><cite> Zhang Y (2013). Likelihood-based and Bayesian Methods for Tweedie Compound Poisson Linear Mixed Models, <em>Statistics and Computing</em>, 23, 743-757. 
</cite> 
<a href="https://github.com/actuaryzhang/cplm/files/144051/TweediePaper.pdf">https://github.com/actuaryzhang/cplm/files/144051/TweediePaper.pdf</a>
</p>
<p><cite>Bates D, Maechler M, Bolker B and Walker S (2015). <code>lme4</code>: Linear mixed-effects models using Eigen and S4..
</cite>
</p>


<h3>See Also</h3>

<p>The users are recommended to see <code><a href="#topic+cpglm">cpglm</a></code> for a general introduction to the compound Poisson distribution, <code>lme4</code> for syntax and usage of mixed-effect models and <code><a href="#topic+cpglmm-class">cpglmm-class</a></code> for detailed explanation of the return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# use Stock and Spacing as main effects and Plant as random effect
(f1 &lt;- cpglmm(RLD ~ Stock + Spacing +  (1|Plant), data = FineRoot))
            
coef(f1); fixef(f1); ranef(f1)  #coefficients
VarCorr(f1)  #variance components

# add another random effect
(f2 &lt;- update(f1, . ~ . + (1|Zone)))
# test the additional random effect
anova(f1,f2)

# try a different optimizer 
(f3 &lt;- cpglmm(RLD ~  Stock + Spacing +  (1|Plant), 
            data = FineRoot, optimizer = "bobyqa", 
            control = list(trace = 2)))

# adaptive G-H quadrature  
(f4 &lt;- cpglmm(RLD ~  Stock + Spacing +  (1|Plant), 
            data = FineRoot, nAGQ = 3))

# a model with smoothing effects
(f5 &lt;- cpglmm(increLoss ~ tp(lag, k = 4) + (1|year) , 
            data = ClaimTriangle))

## End(Not run)
</code></pre>

<hr>
<h2 id='cplm-package'>
Tweedie compound Poisson linear models 
</h2><span id='topic+cplm-package'></span><span id='topic+cplm'></span>

<h3>Description</h3>

<p>The Tweedie compound Poisson distribution is a mixture of a degenerate distribution at the origin and a continuous distribution on the positive real line. It has been applied in a wide range of fields in which continuous data with exact zeros regularly arise. Nevertheless, statistical inference based on full likelihood and Bayesian methods is not available in most statistical software, largely because the distribution has an intractable density function and numerical methods that allow fast and accurate evaluation of the density did not appear until fairly recently. The <code>cplm</code> package provides likelihood-based and Bayesian procedures for fitting common Tweedie compound Poisson linear models. In particular, models with hierarchical structures or extra zero inflation can be handled. Further, the package implements the Gini index based on an ordered version of the Lorenz curve as a robust model comparison tool involving zero-inflated and highly skewed distributions.  
</p>
<p>The following features of the package may be of special interest to the users:
</p>

<ol>
<li><p> All methods available in the package enable the index parameter (i.e., the unknown variance function) to be estimated from the data.
</p>
</li>
<li><p> The compound Poisson generalized linear model handles large data set using the bounded memory regression facility in <code>biglm</code>.
</p>
</li>
<li><p> For mixed models, we provide likelihood-based methods using Laplace approximation and adaptive Gauss-Hermit quadrature. 
</p>
</li>
<li><p> A convenient interface is offered to fit additive models (penalized splines) using the mixed model estimation procedure.
</p>
</li>
<li><p> Self-tuned Markov chain Monte Carlo procedures are available for both GLM-type and  mixed models.
</p>
</li>
<li><p> The package also implements a zero-inflated compound Poisson model, in which the observed frequency of zeros can generally be more adequately modeled. 
</p>
</li>
<li><p> We provide the Gini index based on an ordered Lorenz curve, which is better suited for model comparison involving the compound Poisson distribution.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Yanwei (Wayne) Zhang &lt;actuary_zhang@hotmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Dunn, P.K. and Smyth, G.K. (2005). Series evaluation of Tweedie exponential dispersion models densities. <em>Statistics and Computing</em>, 15, 267-280.</cite>
</p>
<p><cite>Frees, E. W., Meyers, G. and Cummings, D. A. (2011). Summarizing Insurance Scores Using
a Gini Index. <em>Journal of the American Statistical Association</em>, 495, 1085 - 1098.
</cite>
</p>
<p><cite> Zhang, Y (2013). Likelihood-based and Bayesian Methods for Tweedie Compound Poisson Linear Mixed Models, <em>Statistics and Computing</em>, 23, 743-757.
</cite>
</p>

<hr>
<h2 id='datasets'>Data sets in the cplm pakcage</h2><span id='topic+FineRoot'></span><span id='topic+ClaimTriangle'></span><span id='topic+AutoClaim'></span>

<h3>Description</h3>

<p>The data sets included in package is described here.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FineRoot)
data(ClaimTriangle)
data(AutoClaim)
</code></pre>


<h3>Format</h3>

<p><code>FineRoot</code>: a data set used for the study of the fine root length density of plants. It is a data frame with 511 records and 5 variables: 
</p>

<dl>
<dt><code>Plant</code>:</dt><dd><p>identifier of the apple tree, 1-8</p>
</dd>
<dt><code>Stock</code>:</dt><dd><p>root stokcing, one of three different root stocks: Mark, MM106 and M26</p>
</dd>
<dt><code>Spacing</code>:</dt><dd><p>between-row <code class="reqn">\times</code> within-row spacings, one of the following two: <code class="reqn">4 \times 2</code> meters and <code class="reqn">5 \times 3</code> meters</p>
</dd>
<dt><code>Zone</code>:</dt><dd><p>inner or outer</p>
</dd>
<dt><code>RLD</code>:</dt><dd><p>root length density</p>
</dd>
</dl>

<p><code>ClaimTriangle</code>: a data set from an insurance loss reserving triangle. It is a data frame with 55 records and 3 variables: 
</p>

<dl>
<dt><code>year</code>:</dt><dd><p>the year when the accident occurs</p>
</dd>
<dt><code>lag</code>:</dt><dd><p>development lag</p>
</dd>
<dt><code>increLoss</code>:</dt><dd><p>incremental insurance loss in 1000s</p>
</dd>
</dl>

<p><code>AutoClaim</code>: a motor insurance data set retrieved from
the SAS Enterprise Miner database. It is a data frame with 10296 records and 29 variables: 
</p>

<dl>
<dt><code>POLICYNO</code>:</dt><dd><p>&quot;character&quot;, the policy number</p>
</dd>
<dt><code>PLCYDATE</code>:</dt><dd><p>&quot;Date&quot;, policy effective date</p>
</dd>
<dt><code>CLM_FREQ5</code>:</dt><dd><p>&quot;integer&quot;, the number of claims in the past 5 years</p>
</dd>
<dt><code>CLM_AMT5</code>:</dt><dd><p>&quot;integer&quot;, the total claim amount in the past 5 years</p>
</dd>
<dt><code>CLM_AMT</code>:</dt><dd><p>&quot;integer&quot;, the claim amount in the current insured period</p>
</dd>
<dt><code>KIDSDRIV</code>:</dt><dd><p>&quot;integer&quot;, the number of driving children</p>
</dd>
<dt><code>TRAVTIME</code>:</dt><dd><p>&quot;integer&quot;, the distance to work</p>
</dd>
<dt><code>CAR_USE</code>:</dt><dd><p>&quot;factor&quot;, the primary use of the vehicle: &quot;Commercial&quot;, &quot;Private&quot;.</p>
</dd>
<dt><code>BLUEBOOK</code>:</dt><dd><p>&quot;integer&quot;, the value of the vehicle</p>
</dd>
<dt><code>RETAINED</code>:</dt><dd><p>&quot;integer&quot;, the number of years as a customer</p>
</dd>
<dt><code>NPOLICY</code>:</dt><dd><p>&quot;integer&quot;, the number of policies</p>
</dd>
<dt><code>CAR_TYPE</code>:</dt><dd><p>&quot;factor&quot;, the type of the car: &quot;Panel Truck&quot;, &quot;Pickup&quot;, &quot;Sedan&quot;, &quot;Sports Car&quot;, &quot;SUV&quot;, &quot;Van&quot;.</p>
</dd>
<dt><code>RED_CAR</code>:</dt><dd><p>&quot;factor&quot;, whether the color of the car is red: &quot;no&quot;, &quot;yes&quot;.</p>
</dd>
<dt><code>REVOLKED</code>:</dt><dd><p>&quot;factor&quot;, whether the dirver's license was invoked in the past 7 years: &quot;No&quot;, &quot;Yes&quot;,</p>
</dd>
<dt><code>MVR_PTS</code>:</dt><dd><p>&quot;integer&quot;, MVR violation records</p>
</dd>
<dt><code>CLM_FLAG</code>:</dt><dd><p>&quot;factor&quot;, whether a claim is reported: &quot;No&quot;, &quot;Yes&quot;.</p>
</dd>
<dt><code>AGE</code>:</dt><dd><p>&quot;integer&quot;, the age of the driver</p>
</dd>
<dt><code>HOMEKIDS</code>:</dt><dd><p>&quot;integer&quot;, the number of children</p>
</dd>
<dt><code>YOJ</code>:</dt><dd><p>&quot;integer&quot;, years at current job</p>
</dd>
<dt><code>INCOME</code>:</dt><dd><p>&quot;integer&quot;, annual income</p>
</dd>
<dt><code>GENDER</code>:</dt><dd><p>&quot;factor&quot;, the gender of the driver: &quot;F&quot;, &quot;M&quot;.</p>
</dd>
<dt><code>MARRIED</code>:</dt><dd><p>&quot;factor&quot;, married or not: &quot;No&quot;, &quot;Yes&quot;.</p>
</dd>
<dt><code>PARENT1</code>:</dt><dd><p>&quot;factor&quot;, single parent: &quot;No&quot;, &quot;Yes&quot;.</p>
</dd>
<dt><code>JOBCLASS</code>:</dt><dd><p>&quot;factor&quot;: &quot;Unknown&quot;, &quot;Blue Collar&quot;, &quot;Clerical&quot;, &quot;Doctor&quot;, &quot;Home Maker&quot;, &quot;Lawyer&quot;, &quot;Manager&quot;, &quot;Professional&quot;, &quot;Student&quot;.</p>
</dd>
<dt><code>MAX_EDUC</code>:</dt><dd><p>&quot;factor&quot;, max education level:&quot;&lt;High School&quot;, &quot;Bachelors&quot;, &quot;High School&quot;, &quot;Masters&quot;, &quot;PhD&quot;.</p>
</dd>
<dt><code>HOME_VAL</code>:</dt><dd><p>&quot;integer&quot;, the value of the insured's home</p>
</dd>
<dt><code>SAMEHOME</code>:</dt><dd><p>&quot;integer&quot;, years in the current address</p>
</dd>
<dt><code>DENSITY</code>:</dt><dd><p>&quot;factor&quot;, home/work area: &quot;Highly Rural&quot;, &quot;Highly Urban&quot;, &quot;Rural&quot;, &quot;Urban&quot;.</p>
</dd>
<dt><code>IN_YY</code>:</dt><dd><p>&quot;logical&quot;, whether the record is used in the Yip and Yau (2005) paper.</p>
</dd>
</dl>



<h3>Source</h3>

<p><cite>de Silva, H. N., Hall, A. J., Tustin, D. S. and Gandar, P. W. (1999). Analysis of distribution
of root length density of apple trees on different dwarfing rootstocks. <em>Annals of 
Botany</em>, 83: 335-345.</cite>
</p>
<p><cite> Dunn, P.K. and Smyth, G.K. (2005). Series evaluation of Tweedie exponential dispersionmodels densities. <em>Statistics and Computing</em>, 15, 267-280.</cite>
</p>
<p><cite>Peters G. W., Shevchenko P. V. and Wuthrich M. V. (2009). Model Uncertainty in Claims Reserving within Tweedie's Compound Poisson Models. <em>Astin Bulletin</em>, 39(1),  1-33.</cite>
</p>
<p><cite>Yip, K. C. H. and Yau, K. K. W. (2005). On Modeling Claim Frequency Data In General
Insurance With Extra Zeros. <em>Insurance: Mathematics and Economics</em>, 36(2), 153-163.</cite>
</p>

<hr>
<h2 id='getF'>Get and plot the smoothing function values</h2><span id='topic+getF'></span><span id='topic+plotF'></span>

<h3>Description</h3>

<p>Get and plot the estimated smoothing function values</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF(object, which, n=100, newdata, interval=c("NONE", "MCMC",
    "RW"), addConst=TRUE, varying=1, level=0.9, sims=1000)
    
plotF(object, which, n=100, interval="RW", addConst=TRUE,
    trans=I, level=0.9, sims=1000, auto.layout=TRUE, rug=TRUE,
    legendPos="topright", ...)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF_+3A_object">object</code></td>
<td>
<p>a fitted <code>cpglmm</code> object.</p>
</td></tr>
<tr><td><code id="getF_+3A_which">which</code></td>
<td>
<p>(optional) an integer vector or a character vector of names giving the smooths for which fitted values are desired. Defaults to all.</p>
</td></tr>
<tr><td><code id="getF_+3A_n">n</code></td>
<td>
<p>if no <code>newdata</code> is given, fitted values for a regular grid with n values in the range of the respective covariates are returned</p>
</td></tr>
<tr><td><code id="getF_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict</p>
</td></tr>
<tr><td><code id="getF_+3A_interval">interval</code></td>
<td>
<p>what mehod should be used to compute pointwise confidence/HPD intervals: RW= bias-adjusted empirical bayes</p>
</td></tr>
<tr><td><code id="getF_+3A_addconst">addConst</code></td>
<td>
<p>boolean should the global intercept and intercepts for the levels of the by-variable be included in the fitted values (and their CIs) can also be a vector of the same length as <code>which</code></p>
</td></tr>
<tr><td><code id="getF_+3A_varying">varying</code></td>
<td>
<p>value of the<code>varying</code>-covariate (see <code><a href="#topic+tp">tp</a></code>) to be used if no newdata is supplied. 
Defaults to 1.</p>
</td></tr>
<tr><td><code id="getF_+3A_level">level</code></td>
<td>
<p>level for the confidence/HPD intervals</p>
</td></tr>
<tr><td><code id="getF_+3A_sims">sims</code></td>
<td>
<p>how many iterates should  be generated for the MCMC-based HPD-intervals</p>
</td></tr>
<tr><td><code id="getF_+3A_trans">trans</code></td>
<td>
<p>a function that should be applied to the fitted values and ci's before plotting (e.g. the inverse link function to get plots on the scale of the reponse)</p>
</td></tr>
<tr><td><code id="getF_+3A_auto.layout">auto.layout</code></td>
<td>
<p>automagically set plot layout via <code>par()$mfrow</code></p>
</td></tr>
<tr><td><code id="getF_+3A_rug">rug</code></td>
<td>
<p>add <code><a href="graphics.html#topic+rug">rug</a></code>-plots of the observed covariate locations</p>
</td></tr>
<tr><td><code id="getF_+3A_legendpos">legendPos</code></td>
<td>
<p>a (vector of) keyword(s) where to put labels of by-variables (see <code><a href="graphics.html#topic+legend">legend</a></code>). &quot;none&quot; if you don't want a legend.</p>
</td></tr>
<tr><td><code id="getF_+3A_...">...</code></td>
<td>
<p>arguments passed on to the low-level plot functions (<code>plot</code>, <code>matlines</code>), <code>legend</code>, and <code>title</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with one <code>data.frame</code> for each function, giving <code>newdata</code> or the values of the generated grid plus the fitted values (and confidence/HPD intervals).</p>


<h3>Note</h3>

<p>These are from the <code>amer</code> package that has retired from CRAN. The formula used for the pointwise bias-adjusted CIs is taken from Ruppert and Wand's  'Semiparametric Regression' (2003), p. 140. 
These leave out the uncertainty associated with the variance component estimates. </p>


<h3>Author(s)</h3>

<p>Fabian Scheipl <a href="mailto:fabian.scheipl@googlemail.com">fabian.scheipl@googlemail.com</a>
</p>


<h3>See Also</h3>

<p>See the vignette for examples</p>

<hr>
<h2 id='gini'>
The Gini index 
</h2><span id='topic+gini'></span>

<h3>Description</h3>

<p>Compute Gini indices and their standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini(loss, score, base = NULL, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini_+3A_loss">loss</code></td>
<td>
<p>a character that contains the name of the response variable. 
</p>
</td></tr>
<tr><td><code id="gini_+3A_score">score</code></td>
<td>

<p>a character vector that contains the list of the scores, which are the predictions from the set of models to be compared.  
</p>
</td></tr>
<tr><td><code id="gini_+3A_base">base</code></td>
<td>
<p>a character that contains the name of a baseline statistic. If <code>NULL</code> (the default), each score will be successively used as the base. 
</p>
</td></tr>
<tr><td><code id="gini_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables listed in the above arguments. 
</p>
</td></tr>
<tr><td><code id="gini_+3A_...">...</code></td>
<td>

<p>not used. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For model comparison involving the compound Poisson distribution, the usual mean squared loss function is not quite informative for capturing the differences between predictions and observations, due to the high proportions of zeros and the skewed heavy-tailed distribution of the positive losses. For this reason, Frees et al. (2011) develop an ordered version of the Lorenz curve and the associated Gini index as a statistical measure of the association between distributions, through which different predictive models can be compared. The idea is that a score (model) with a greater Gini index produces a greater separation among the observations. In the insurance context, a higher Gini index indicates greater ability to distinguish good risks from bad risks. Therefore, the model with the highest Gini index is preferred. 
</p>
<p>This function computes the Gini indices and their asymptotic standard errors based on the ordered Lorenz curve. These metrics are mainly used for model comparison. Depending on the problem, there are generally two ways to do this. Take insurance predictive modeling as an example. First, when there is a baseline premium, we can compute the Gini index for each score (predictions from the model), and select the model with the highest Gini index.  Second, when there is no baseline premium (<code>base = NULL</code>), we successively specify the prediction from each model as the baseline premium and use the remaining models as the scores. This results in a matrix of Gini indices, and we select the model that is least vulnerable to alternative models using a &quot;mini-max&quot; argument - we select the score that provides the smallest of the maximal Gini indices, taken over competing scores.  
</p>


<h3>Value</h3>

<p><code>gini</code> returns an object of class <code>"gini"</code>. See <code><a href="#topic+gini-class">gini-class</a></code> for details of the return values as well as various methods available for this class.
</p>


<h3>Author(s)</h3>

<p>Yanwei (Wayne) Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a>
</p>


<h3>References</h3>

<p><cite>Frees, E. W., Meyers, G. and Cummings, D. A. (2011). Summarizing Insurance Scores Using
a Gini Index. <em>Journal of the American Statistical Association</em>, 495, 1085 - 1098.
</cite>
</p>


<h3>See Also</h3>

<p>The users are recommended to see the documentation for <code><a href="#topic+gini-class">gini-class</a></code>  for related information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Let's fit a series of models and compare them using the Gini index
da &lt;- subset(AutoClaim, IN_YY == 1)
da &lt;- transform(da, CLM_AMT = CLM_AMT / 1000)
                    
P1 &lt;- cpglm(CLM_AMT ~ 1, data = da, offset = log(NPOLICY))


P2 &lt;- cpglm(CLM_AMT ~ factor(CAR_USE) + factor(REVOLKED) + 
              factor(GENDER) + factor(AREA) + 
              factor(MARRIED) + factor(CAR_TYPE),
            data = da, offset = log(NPOLICY))

P3 &lt;- cpglm(CLM_AMT ~ factor(CAR_USE) + factor(REVOLKED) + 
              factor(GENDER) + factor(AREA) + 
              factor(MARRIED) + factor(CAR_TYPE) +
              TRAVTIME + MVR_PTS + INCOME,
            data = da, offset = log(NPOLICY))

da &lt;- transform(da, P1 = fitted(P1), P2 = fitted(P2), P3 = fitted(P3))
                
# compute the Gini indices
gg &lt;- gini(loss = "CLM_AMT", score  = paste("P", 1:3, sep = ""), 
           data = da)
gg
           
# plot the Lorenz curves 
theme_set(theme_bw())
plot(gg)
plot(gg, overlay = FALSE)


## End(Not run)
</code></pre>

<hr>
<h2 id='sp2d'>
2-dimentional Radial Spline
</h2><span id='topic+sp2d'></span>

<h3>Description</h3>

<p>2-dimentional radial spline generator used in <code>cpglmm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2d(x1, x2, k = max(20, min(length(x1)/4, 150)), by = NULL, 
allPen = FALSE, varying = NULL, diag = FALSE, 
knots1 = quantile(x1, probs = 1:k/(k + 1)), 
knots2 = quantile(x1, probs = 1:k/(k + 1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2d_+3A_x1">x1</code></td>
<td>

<p>the first covariate in the coordinate 
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_x2">x2</code></td>
<td>

<p>the second covariate in the coordinate
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_k">k</code></td>
<td>

<p>number of knots 
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_by">by</code></td>
<td>

<p>not used. This is just for compatibility with <code>amer</code>. 
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_allpen">allPen</code></td>
<td>

<p>not used. This is just for compatibility with <code>amer</code>.
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_varying">varying</code></td>
<td>

<p>not used. This is just for compatibility with <code>amer</code>.
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_diag">diag</code></td>
<td>

<p>not used. This is just for compatibility with <code>amer</code>.
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_knots1">knots1</code></td>
<td>

<p>vector of knot locations for the first covariate in the coordinate
</p>
</td></tr>
<tr><td><code id="sp2d_+3A_knots2">knots2</code></td>
<td>

<p>vector of knot locations for the second covariate in the coordinate
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabian Scheipl <a href="mailto:fabian.scheipl@googlemail.com">fabian.scheipl@googlemail.com</a>
</p>

<hr>
<h2 id='tp'>Generate basis functions for penalized spline smoothing.</h2><span id='topic+tp'></span><span id='topic+bsp'></span>

<h3>Description</h3>

<p><code>tp</code> generates a truncated power basis and <code>bsp</code> generates a reparameterized b-spline basis for penalized spline smoothing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp(x, degree=1, k=15, by=NULL, allPen=FALSE, varying=NULL, diag=FALSE,
    knots=quantile(x, probs = (1:(k - degree))/(k - degree  + 1)), 
    centerscale=NULL, scaledknots=FALSE)
    
bsp(x, k=15, spline.degree=3, diff.ord=2, knots, by,
    allPen=FALSE, varying, diag=FALSE)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tp_+3A_x">x</code></td>
<td>
<p>covariate for the smooth function</p>
</td></tr>
<tr><td><code id="tp_+3A_degree">degree</code></td>
<td>
<p>integer: degree of truncated polynomials (0: piecewise constant, 1: piecewise linear etc..)</p>
</td></tr>
<tr><td><code id="tp_+3A_k">k</code></td>
<td>
<p>integer: dimensionality of the basis (i.e.: number of knots + degree)</p>
</td></tr>
<tr><td><code id="tp_+3A_by">by</code></td>
<td>
<p>factor variable: estimate separate functions for each level - this assumes standard treatment contrasts for the supplied factor.</p>
</td></tr>
<tr><td><code id="tp_+3A_allpen">allPen</code></td>
<td>
<p>boolean: if TRUE, make design for group-specific curves with common smoothing parameter: all parameters (including the normally unpenalized basis functions in X) are penalized, every level of &quot;by&quot; has the same amount of smoothing 
if FALSE, make design for separate curves for each by-level: separate smoothing parameters for every level of &quot;by&quot;, unpenalized estimates for the coefficients associated with X</p>
</td></tr>
<tr><td><code id="tp_+3A_varying">varying</code></td>
<td>
<p>numeric: if not NULL, a varying coefficient model is fit: f(x,varying) = f(x)*varying</p>
</td></tr>
<tr><td><code id="tp_+3A_diag">diag</code></td>
<td>
<p>logical: force a diagonal covariance-matrix for the random effects for X if <code>allPen=TRUE</code>?</p>
</td></tr>
<tr><td><code id="tp_+3A_knots">knots</code></td>
<td>
<p>vector of knot locations (optional). Defaults to quantile-based knots at the <code class="reqn">i/(k+1-</code>degree)-quantiles 
for <code class="reqn">i=1,\dots,k-</code>degree.</p>
</td></tr>
<tr><td><code id="tp_+3A_centerscale">centerscale</code></td>
<td>
<p>numeric(2): center&amp;scale x by these values if not NULL</p>
</td></tr>
<tr><td><code id="tp_+3A_scaledknots">scaledknots</code></td>
<td>
<p>boolean:	are knot locations given for the rescaled x-values?</p>
</td></tr>
<tr><td><code id="tp_+3A_spline.degree">spline.degree</code></td>
<td>
<p>integer: degree of B-splines (defaults to cubic)</p>
</td></tr>
<tr><td><code id="tp_+3A_diff.ord">diff.ord</code></td>
<td>
<p>integer: order of the difference penalty on the un-reparamerized spline coefficients. Defaults to 2, that is, penalized deviations from linearity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tp</code> generates truncated power bases which have <code>degree</code> unpenalized basis functions, namely <code class="reqn">x^1,\dots, x^{degree}</code> and <code class="reqn">k-</code><code>degree</code> penalized basis functions that contain the positive part <code class="reqn">(x-\kappa_j)^{degree}</code> for knots <code class="reqn">\kappa_j, j=1,dots,k-</code><code>degree</code>.
This function can be used as a reference when implementing other <code>basisGenerators</code> that can be used for additive models through <code>cpglmm</code>. 
</p>
<p><code>bsp</code> generate a b-spline basis with equidistant knots in mixed model reparameterization.</p>


<h3>Value</h3>

<p>list with entries:
<code>"X"</code>: For <code>tp</code>, it is an <code>n x degree</code> design matrix for unpenalized part (without intercept) (or a list of those for every level of by if allPen=F); and for <code>bsp</code>, it is an <code>n x (diff.ord - 1)</code> design matrix for unpenalized part (without intercept).
</p>
<p><code>"Z"</code>: For <code>tp</code>, it is an <code>n x (k-degree)</code> design matrix for penalized part (or a list of those for every level of by if allPen=F); and for <code>bsp</code>, it is an <code>n x (k - diff.ord+1)</code> design matrix for penalized part.</p>


<h3>Note</h3>

<p>These are from the <code>amer</code> package that has retired from CRAN.</p>


<h3>Author(s)</h3>

<p>Fabian Scheipl <a href="mailto:fabian.scheipl@googlemail.com">fabian.scheipl@googlemail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
