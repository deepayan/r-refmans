<!DOCTYPE html><html><head><title>Help for package spam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spam-package'><p>SPArse Matrix Package</p></a></li>
<li><a href='#adjacency'><p>Administrative Districts of Germany</p></a></li>
<li><a href='#allequal'><p>Test if Two Sparse Matrices are (Nearly) Equal</p></a></li>
<li><a href='#apply'><p>Apply Functions Over Sparse Matrix Margins</p></a></li>
<li><a href='#bandwidth'><p>Bandwidth of a Sparse Matrix</p></a></li>
<li><a href='#bdiag'><p>Binds Arrays Corner-to-Corner</p></a></li>
<li><a href='#cbind'><p>Combine Sparse Matrices by Rows or Columns</p></a></li>
<li><a href='#chol'><p>Cholesky Factorization for Sparse Matrices</p></a></li>
<li><a href='#circulant'><p>Create Circulant Matrices</p></a></li>
<li><a href='#cleanup'><p>Cleaning up sparse matrices</p></a></li>
<li><a href='#coerce-methods'><p>Force a <code>spam</code> Object to Belong to a Class</p></a></li>
<li><a href='#Coercion'><p>Coercion to a Vector</p></a></li>
<li><a href='#complexity'><p>Complexity for Sparse Matrices</p></a></li>
<li><a href='#constructors'><p>Slot Modification</p></a></li>
<li><a href='#covmat'><p>Covariance Functions</p></a></li>
<li><a href='#crossprod'><p>Spam Matrix Crossproduct</p></a></li>
<li><a href='#det'><p>Determinant of a Symmetric Positive Definite Sparse Matrix</p></a></li>
<li><a href='#diag'><p>Sparse Matrix diagonals</p></a></li>
<li><a href='#diff'><p>Lagged Differences</p></a></li>
<li><a href='#dim'><p>Dimensions of an Object</p></a></li>
<li><a href='#display'><p>Graphially Represent the Nonzero Entries</p></a></li>
<li><a href='#eigen'><p>Eigenvalues for Sparse Matrices</p></a></li>
<li><a href='#fields-wrapper'><p>Wrapper for Distance Matrix Computation</p></a></li>
<li><a href='#foreign'><p>Transformation to Other Sparse Formats</p></a></li>
<li><a href='#germany.data'><p>Meta-data About Administrative Districts of Germany</p></a></li>
<li><a href='#germany.plot'><p>Plot Administrative Districts of Germany</p></a></li>
<li><a href='#gmult'><p>Generalized Multiplication</p></a></li>
<li><a href='#grid_trace2'><p>Two trace plots and a scatter plot.</p></a></li>
<li><a href='#grid_zoom'><p>grid_zoom</p></a></li>
<li><a href='#head'>
<p>Return the First or Last Part of an Object</p></a></li>
<li><a href='#image'><p>Display a Sparse Matrix as Color Image</p></a></li>
<li><a href='#import'><p>Read External Matrix Formats</p></a></li>
<li><a href='#isSymmetric'><p>Test if a Sparse Matrix is Symmetric</p></a></li>
<li><a href='#kronecker'><p>Kronecker Products on Sparse Matrices</p></a></li>
<li><a href='#large_matrix'><p>Large 64-bit matrices require the R package <span class="pkg">spam64</span></p></a></li>
<li><a href='#lower.tri'><p>Lower and Upper Triangular Part of a Sparse Matrix</p></a></li>
<li><a href='#makeprec'><p>Create Precision Matrices</p></a></li>
<li><a href='#map.landkreis'><p>Administrative districts of Germany</p></a></li>
<li><a href='#Math'><p>Mathematical Functions</p></a></li>
<li><a href='#Math2'><p>Rounding of Numbers</p></a></li>
<li><a href='#mle'><p>Maximum likelihood estimates</p></a></li>
<li><a href='#nearestdist'><p>Distance Matrix Computation</p></a></li>
<li><a href='#options'><p>Options Settings</p></a></li>
<li><a href='#Oral'><p>Oral Cavity Cancer</p></a></li>
<li><a href='#ordering'><p>Extract the permutation</p></a></li>
<li><a href='#pad'><p>Padding a Sparse Matrix</p></a></li>
<li><a href='#permutation'><p>Permute a Matrix</p></a></li>
<li><a href='#powerboost'><p>Specific Options Setting</p></a></li>
<li><a href='#precmat'><p>IGMRF Precision Matrices</p></a></li>
<li><a href='#print'><p>Printing and Summarizing Sparse Matrices</p></a></li>
<li><a href='#random'><p>Create Random Sparse Matrices</p></a></li>
<li><a href='#rgrf'><p>Draw From a Gaussian Random Field</p></a></li>
<li><a href='#rmvnorm'><p>Draw Multivariate Normals</p></a></li>
<li><a href='#rmvnorm.conditional'><p>Draw Conditional Multivariate Normals</p></a></li>
<li><a href='#rmvnorm.const'><p>Draw Constrainted Multivariate Normals</p></a></li>
<li><a href='#rmvt'><p>Draw From a Multivariate t-Distribution</p></a></li>
<li><a href='#rowSums'><p>Form Row and Column Sums and Means</p></a></li>
<li><a href='#s3only'><p>Wappers for Sparse Matrices</p></a></li>
<li><a href='#spam'><p>Sparse Matrix Class</p></a></li>
<li><a href='#spam internal'>
<p>Spam internal and auxiliary functions</p></a></li>
<li><a href='#spam methods'><p>Methods for Sparse Matrices</p></a></li>
<li><a href='#spam-class'><p>Class &quot;spam&quot;</p></a></li>
<li><a href='#spam-defunct'><p>Defunct Objects in Package <span class="pkg">spam</span></p></a></li>
<li><a href='#spam-operations'><p>Basic Linear Algebra for Sparse Matrices</p></a></li>
<li><a href='#spam-solve'><p>Linear Equation Solving for Sparse Matrices</p></a></li>
<li><a href='#spam.chol.NgPeyton-class'><p>Class &quot;spam.chol.NgPeyton&quot;</p></a></li>
<li><a href='#Summary'><p>Rounding of Numbers</p></a></li>
<li><a href='#toeplitz'><p>Create Toeplitz Matrices</p></a></li>
<li><a href='#triplet'><p>Transform a &quot;spam&quot; Format to Triplets</p></a></li>
<li><a href='#UScounties'><p>Adjacency Structure of the Counties in the Contiguous United States</p></a></li>
<li><a href='#USprecip'><p>Monthly Total Precipitation (mm) for April 1948 in the Contiguous United States</p></a></li>
<li><a href='#validate_spam'><p>Validate a Sparse Matrix</p></a></li>
<li><a href='#version'><p>Spam Version Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>SPArse Matrix</td>
</tr>
<tr>
<td>Version:</td>
<td>2.10-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-23</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dotCall64, grid, methods, Rcpp (&ge; 1.0.8.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spam64, fields, Matrix, testthat, R.rsp, truncdist, knitr,
rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions for sparse matrix algebra.
    Differences with other sparse matrix packages are:
    (1) we only support (essentially) one sparse matrix format,
    (2) based on transparent and simple structure(s),
    (3) tailored for MCMC calculations within G(M)RF.
    (4) and it is fast and scalable (with the extension package spam64).
    Documentation about 'spam' is provided by vignettes included in this package, see also Furrer and Sain (2010) &lt;<a href="https://doi.org/10.18637%2Fjss.v036.i10">doi:10.18637/jss.v036.i10</a>&gt;; see 'citation("spam")' for details.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.math.uzh.ch/pages/spam/">https://www.math.uzh.ch/pages/spam/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://git.math.uzh.ch/reinhard.furrer/spam/-/issues">https://git.math.uzh.ch/reinhard.furrer/spam/-/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-23 07:47:45 UTC; furrer</td>
</tr>
<tr>
<td>Author:</td>
<td>Reinhard Furrer <a href="https://orcid.org/0000-0002-6319-2332"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Florian Gerber <a href="https://orcid.org/0000-0001-8545-5263"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Roman Flury <a href="https://orcid.org/0000-0002-0349-8698"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Daniel Gerber [ctb],
  Kaspar Moesinger [ctb],
  Cincera Annina [ctb],
  Youcef Saad [ctb] (SPARSEKIT
    http://www-users.cs.umn.edu/~saad/software/SPARSKIT/),
  Esmond G. Ng [ctb] (Fortran Cholesky routines),
  Barry W. Peyton [ctb] (Fortran Cholesky routines),
  Joseph W.H. Liu [ctb] (Fortran Cholesky routines),
  Alan D. George [ctb] (Fortran Cholesky routines),
  Lehoucq B. Rich [ctb] (ARPACK),
  Maschhoff Kristi [ctb] (ARPACK),
  Sorensen C. Danny [ctb] (ARPACK),
  Yang Chao [ctb] (ARPACK)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Reinhard Furrer &lt;reinhard.furrer@math.uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-23 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spam-package'>SPArse Matrix Package</h2><span id='topic+spam-package'></span><span id='topic+SPAM'></span><span id='topic+Spam'></span><span id='topic+.+20SPAM+20.'></span>

<h3>Description</h3>

<p><code>spam</code> is a collection of functions for sparse matrix
algebra.
</p>


<h3>Gereral overview</h3>

<p>What is spam and what is it not:<br />
</p>
<p>While <code>Matrix</code> seems an overshoot of classes and <code>SparseM</code>
focuses mainly on regression type problem, we provide a minimal set of
sparse matrix functions fully functional for everyday spatial statistics
life. There is however some emphasize on Markov chain Monte Carlo type
calculations within the framework of (Gaussian) Markov random fields.
<br />
</p>
<p>Emphasis is given on a comprehensive, simple, tutorial structure of the
code. The code is S4 based but (in a tutorial spirit) the functions are
in a S3 structure visible to the user (exported via <code>NAMESPACE</code>).<br />
</p>
<p>There exist many methods for sparse matrices that work identically as in
the case of ordinary matrices. All the methods are discussed in the help
and can be accessed directly via a <code>*.spam</code> concatenation to the
function. For example, <code>help(chol.spam)</code> calls the help
directly. We deliberately avoided aliases according to analogue helps from the
base package.<br />
</p>
<p>Sparseness is used when handling large matrices. Hence, care has been
used to provide efficient and fast routines. Essentially, the functions
do not transform the sparse structure into full matrices to use standard
(available) functionality, followed by a back transform. We agree, more
operators, functions, etc. should eventually be implemented.
</p>
<p>The packages <code>fields</code> and <code>spam</code> are closely linked.  <br />
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, with the help of Florian Gerber, Kaspar
Moesinger and many others. <br />
Some Fortran routines were written by Youcef Saad, Esmond G. Ng, Barry W. Peyton, Joseph W.H. Liu, Alan D. George.
</p>


<h3>References</h3>

<p>Reinhard Furrer, Stephan R. Sain (2010).
&quot;spam: A Sparse Matrix R Package with Emphasis on MCMC
Methods for Gaussian Markov Random Fields.&quot;,
<em>Journal of Statistical Software</em>, 36(10), 1-25,
<a href="https://doi.org/10.18637/jss.v036.i10">doi:10.18637/jss.v036.i10</a>.<br />
Florian Gerber, Reinhard Furrer (2015).
&quot;Pitfalls in the Implementation of Bayesian Hierarchical Modeling of Areal Count Data: An Illustration Using BYM and Leroux Models.&quot;,
<em>Journal of Statistical Software</em>, Code Snippets, 63(1), 1-32,
<a href="https://doi.org/10.18637/jss.v063.c01">doi:10.18637/jss.v063.c01</a>.<br />
F. Gerber, K. Moesinger, R. Furrer (2017),
&quot;Extending R packages to support 64-bit compiled code: An illustration with spam64 and GIMMS NDVI3g data.&quot;,
<em>Computer &amp; Geoscience</em> 104, 109-119, <a href="https://doi.org/10.1016/j.cageo.2016.11.015">doi:10.1016/j.cageo.2016.11.015</a>.&quot;
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+spam.class">spam.class</a></code> for a detailed class description,
<code><a href="#topic+spam">spam</a></code> and  <code><a href="#topic+spam.ops">spam.ops</a></code> for creation,
coercion and algebraic operations. <code><a href="base.html#topic+options">options</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Citations:
citation('spam')
citation('spam', auto=TRUE)


## History of changes
## Not run: 
file.show(system.file("NEWS.md", package = "spam"))

## End(Not run)
</code></pre>

<hr>
<h2 id='adjacency'>Administrative Districts of Germany</h2><span id='topic+adjacency'></span><span id='topic+adjacency.spam'></span><span id='topic+adjacency.landkreis'></span><span id='topic+germany.graph'></span>

<h3>Description</h3>

<p>Constructing the adjacency graph
of the administrative districts of Germany</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency.landkreis(loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_+3A_loc">loc</code></td>
<td>
<p>location of the graph structure, can be an URL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is included as an example on how to
construct adjacency matrices form a (common) adjacency structure.
For the particular example, note that the nodes are not numbered
consecutively and that they start from zero.</p>


<h3>Value</h3>

<p>a sparse matrix in <code>spam</code> format.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>The adjacency data has been provided by Havard Rue and is
also available in <span class="pkg">INLA</span>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+germany.plot">germany.plot</a></code> super-seeding <code>map.landkreis</code>
for plotting.<br />
<code><a href="#topic+Oral">Oral</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loc &lt;- system.file("demodata/germany.adjacency", package="spam")
display( adjacency.landkreis( loc))

## End(Not run)
</code></pre>

<hr>
<h2 id='allequal'>Test if Two Sparse Matrices are (Nearly) Equal</h2><span id='topic+all.equal.spam'></span><span id='topic+all.equal+2Cmatrix+2Cspam-method'></span><span id='topic+all.equal+2Cspam+2Cmatrix-method'></span><span id='topic+all.equal+2Cspam+2Cspam-method'></span>

<h3>Description</h3>

<p>Utility to compare two <code>spam</code> objects
testing 'near equality'.  Depending on the type of difference, comparison is
still made to some extent, and a report of the differences is
returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'spam'
all.equal(target, current, tolerance = .Machine$double.eps^0.5,
    scale = NULL, check.attributes = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allequal_+3A_target">target</code></td>
<td>
<p>a <code>spam</code> object.</p>
</td></tr>
<tr><td><code id="allequal_+3A_current">current</code></td>
<td>
<p>another <code>spam</code> object to be compared with <code>target</code>.</p>
</td></tr>
<tr><td><code id="allequal_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0.  Differences smaller than
<code>tolerance</code> are not considered.</p>
</td></tr>
<tr><td><code id="allequal_+3A_scale">scale</code></td>
<td>
<p>numeric scalar &gt; 0 (or <code>NULL</code>). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="allequal_+3A_check.attributes">check.attributes</code></td>
<td>
<p>currently not yet implemented.</p>
</td></tr>
<tr><td><code id="allequal_+3A_...">...</code></td>
<td>
<p>Further arguments for different methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerical comparisons for <code>scale = NULL</code> (the default) are
typically on a <em>relative difference</em> scale unless the
<code>target</code> values are close to zero or infinite. Specifically,
the scale is computed as the average absolute value of <code>target</code>.
If this scale is finite and exceeds <code>tolerance</code>, differences
are expressed relative to it; otherwise, absolute differences are used.
</p>
<p>If <code>scale</code> is numeric (and positive), absolute comparisons are
made after scaling (dividing) by <code>scale</code>. Note that if all of
scale is sufficiently close to 1 (specifically, within <code>tolerance</code>),
the difference is still reported as being on an absolute scale.
</p>
<p>Do not use <code>all.equal.spam</code> directly in <code>if</code>
expressions: either use <code>isTRUE( all.equal.spam(...))</code> or
<code>identical</code> if appropriate.
</p>
<p>Cholesky decomposition routines use this function to test for
symmetry.
</p>
<p>A method for <code>matrix-spam</code> objects is defined as well.
</p>
<p>There is the additional catch of a zero matrix being represented by
one zero element, see &lsquo;Examples&rsquo; below.
</p>


<h3>Value</h3>

<p>Either <code>TRUE</code> or a vector of 'mode' <code>"character"</code> describing the
differences between <code>target</code> and <code>current</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+isSymmetric.spam">isSymmetric.spam</a></code> and <code><a href="#topic+cleanup">cleanup</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- diag.spam(2)
obj[1,2] &lt;- .Machine$double.eps

all.equal( diag.spam(2), obj)

all.equal( t(obj), obj)

all.equal( t(obj), obj*1.1)

# We can compare a spam to a matrix
all.equal(diag(2),diag.spam(2))

# the opposite does often not make sense,
# hence, it is not implemented.
all.equal(diag.spam(2),diag(2))


# A zero matrix contains one element:
str(spam(0))
# hence
all.equal.spam(spam(0,3,3), diag.spam(0,3) )
norm(spam(0,3,3) - diag.spam(0,3) )
</code></pre>

<hr>
<h2 id='apply'>Apply Functions Over Sparse Matrix Margins</h2><span id='topic+apply.spam'></span>

<h3>Description</h3>

<p>Returns a vector or array or list of values obtained by applying a
function to margins of a sparse matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.spam(X, MARGIN=NULL, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_+3A_x">X</code></td>
<td>
<p>the <code>spam</code> matrix to be used.</p>
</td></tr>
<tr><td><code id="apply_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be
applied over. <code>1</code> indicates rows, <code>2</code> indicates columns,
<code>NULL</code> or <code>c(1,2)</code> indicates rows and columns.</p>
</td></tr>
<tr><td><code id="apply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied.</p>
</td></tr>
<tr><td><code id="apply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a handy wrapper to apply a function to the (nonzero)
elements of a sparse matrix. 
For example, it is possible to apply a covariance matrix to a distance
matrix obtained by <code>nearest.dist</code>, see Examples.<br />
</p>
<p>A call to <code>apply</code> only coerces the sparse matrix to a regular one.<br />
</p>
<p>The basic principle is applying the function to <code>@entries</code>, or to
the extracted columns or rows (<code>[,i,drop=F]</code> or
<code>[i,,drop=F]</code>). It is important to note that an empty column
contains at least one zero value and may lead to non intuitive
results.<br />
</p>
<p>This function may evolve over the next few releases. 
</p>


<h3>Value</h3>

<p>Similar as a call to <code>apply</code> with a regular matrix. The most
important cases are as follows. The
result is a vector (<code>MARGIN</code> is length 1 and <code>FUN</code> is
scalar) or a matrix (<code>MARGIN</code> is length 1 and <code>FUN</code> returns
fixed length vectors, or <code>MARGIN</code> is length 2 and <code>FUN</code> is
scalar) or a list (if <code>FUN</code> returns vectors of different lengths).</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code>base:apply</code> for more details on Value.</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- as.spam(dist(1:5))
S &lt;- apply.spam(S/2, NULL, exp)
# instead of 
# S@entries &lt;- exp( S@entries/2) 

# Technical detail, a null matrix consists
# of one zero element.
apply.spam(S,c(1,2),pmax)
apply.spam(S,1,range)


# A similar example as for the base apply.
# However, no dimnames else we would get warnings. 
x &lt;- as.spam(cbind(x1 = 3, x2 = c(0,0,0, 5:2)))
apply.spam(x, 2, mean, trim = .2)
col.sums &lt;- apply.spam(x, 2, sum)
row.sums &lt;- apply.spam(x, 1, sum)
rbind(cbind(x, row.sums), c(col.sums, sum(col.sums)))

apply.spam(x, 2, is.vector)

# Sort the columns of a matrix
# Notice that the result is a list due to the different
# lengths induced by the nonzero elements
apply.spam(x, 2, sort)

# Function with extra args:
cave &lt;- function(x, c1, c2) c(mean(x[c1]), mean(x[c2]))
apply(x,1, cave,  c1=1, c2=c(1,2))

ma &lt;- spam(c(1:4, 0, 0,0, 6), nrow = 2)
ma
apply.spam(ma, 1, table)  #--&gt; a list of length 2
apply.spam(ma, 1, stats::quantile)# 5 x n matrix with rownames
</code></pre>

<hr>
<h2 id='bandwidth'>Bandwidth of a Sparse Matrix</h2><span id='topic+bandwidth'></span>

<h3>Description</h3>

<p>Returns the lower and upper bandwidth of a sparse matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth_+3A_a">A</code></td>
<td>
<p>spam object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix does not need to be diagonal. Values can be negative
indicating the the matrix contains a band cinfined in the
upper or lower triangular part.
</p>


<h3>Value</h3>

<p>Integer vector containing the lower and upper bandwidth</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+diag.spam">diag.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bandwidth(spam(c(0, 1), 3, 2))

bandwidth(spam(c(0, 0, 1, rep(0, 9)), 4, 3))

</code></pre>

<hr>
<h2 id='bdiag'>Binds Arrays Corner-to-Corner</h2><span id='topic+bdiag'></span><span id='topic+bdiag.spam'></span>

<h3>Description</h3>

<p>Creates a sparse block-diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiag.spam(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdiag_+3A_...">...</code></td>
<td>
<p>Arrays to be binded together</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a small helper function to create block diagonal sparse matrices. In the two matrix case,
<code>bdiag.spam(A,B)</code>, this is equivalent to a complicated <code>rbind(cbind(A, null), cbind(B, t(null)))</code>,
where <code>null</code> is a null matrix of appropriate dimension.<br />
</p>
<p>It is recursively defined.
</p>
<p>The arrays are coerced to sparse matrices first.<br />
</p>
<p>This function is similar to the function <code>bdiag</code> from the package
<code>Matrix</code>. It is also similar to the function <code>adiag</code> from the package
<code>magic</code>.  However, here no padding is done and all the dimnames are
stripped.
</p>


<h3>Value</h3>

<p>Returns a <code>spam</code> matrix as described above.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+diag.spam">diag.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag.spam(2, 4)           # 2*I4
B &lt;- matrix(1,3,3)
AB &lt;- bdiag.spam(A,B)

# equivalent to:
ABalt &lt;- rbind(cbind( A, matrix(0,nrow(A),ncol(B))),
               cbind( matrix(0,nrow(B),ncol(A)), B))
         
norm(AB-ABalt)


# Matrices do not need to be square:
bdiag.spam(1,2:5,6)
</code></pre>

<hr>
<h2 id='cbind'>Combine Sparse Matrices by Rows or Columns</h2><span id='topic+cbind.spam'></span><span id='topic+rbind.spam'></span><span id='topic+cbind'></span><span id='topic+rbind'></span><span id='topic+cbind+2Cspam-method'></span><span id='topic+rbind+2Cspam-method'></span>

<h3>Description</h3>

<p>Take a sequence of vector, matrix or <code>spam</code> object arguments and
combine by <em>c</em>olumns or <em>r</em>ows, respectively.</p>


<h3>Usage</h3>

<pre><code class='language-R'># cbind(\dots, force64 = getOption("spam.force64"), deparse.level = 0)
# rbind(\dots, deparse.level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_+3A_...">...</code></td>
<td>
<p>vectors, matrices or <code>spam</code> objects. See &lsquo;Details&rsquo; and &lsquo;Value&rsquo;</p>
</td></tr>
<tr><td><code id="cbind_+3A_force64">force64</code></td>
<td>
<p>logical vector of length 1. If <code>TRUE</code>, a 64-bit
spam matrix is returned in any case. If <code>FALSE</code>, a 32-bit
matrix is returned when possible. </p>
</td></tr>
<tr><td><code id="cbind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>for compatibility reason here. Only <code>0</code> is implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rbind</code> and <code>cbind</code> are not exactly symmetric in how
the objects are processed. The former is essentially an concatenation
of the slots due to the sparse storage format. Different types of
inputs are handled differently. The latter calls a
Fortran routine after the input has been coerced to <code>spam</code>
objects. <br />
</p>
<p>Only two objects at a time are processed. If more than two are
present, a loop concatenates them successively. <br />
</p>
<p>A method is defined for a  <code>spam</code> object as first argument. 
</p>


<h3>Value</h3>

<p>a <code>spam</code> object combining the <code>...</code> arguments
column-wise or row-wise.  (Exception: if there are no inputs or all
the inputs are <code>NULL</code>, the value is <code>NULL</code>.)</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind.spam(1:5,6)

y &lt;- cbind(x, 7)

rbind( x, x)
# for some large matrices   t( cbind( t(x), t(x)))
# might be slightly faster:


</code></pre>

<hr>
<h2 id='chol'>Cholesky Factorization for Sparse Matrices</h2><span id='topic+chol'></span><span id='topic+chol.spam'></span><span id='topic+chol+2CANY-method'></span><span id='topic+chol+2Cmatrix-method'></span><span id='topic+chol+2Cspam-method'></span><span id='topic+update.spam'></span><span id='topic+update+2Cspam.chol.NgPeyton-method'></span><span id='topic+update.spam.chol.NgPeyton'></span>

<h3>Description</h3>

<p><code>chol</code> performs a Cholesky
decomposition of a symmetric positive definite sparse matrix <code>x</code>
of class <code>spam</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'># chol(x, \dots)

## S4 method for signature 'spam'
chol(x, pivot = "MMD", method = "NgPeyton",
       memory = list(), eps = getOption("spam.eps"), Rstruct=NULL,
       ..., verbose=FALSE)

# update.spam.chol.NgPeyton(object, x,...)
## S4 method for signature 'spam.chol.NgPeyton'
update(object, x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol_+3A_x">x</code></td>
<td>
<p>symmetric positive definite matrix of class <code>spam</code>.</p>
</td></tr>
<tr><td><code id="chol_+3A_pivot">pivot</code></td>
<td>
<p>should the matrix be permuted, and if, with what
algorithm, see &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="chol_+3A_method">method</code></td>
<td>
<p>Currently, only <code>NgPeyton</code> is implemented.</p>
</td></tr>
<tr><td><code id="chol_+3A_memory">memory</code></td>
<td>
<p>Parameters specific to the method, see &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="chol_+3A_eps">eps</code></td>
<td>
<p>threshold to test symmetry. Defaults to <code>getOption("spam.eps")</code>.</p>
</td></tr>
<tr><td><code id="chol_+3A_rstruct">Rstruct</code></td>
<td>
<p>sparsity structure  of the factor, see &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="chol_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="chol_+3A_object">object</code></td>
<td>
<p>an object from a previous call to <code>chol</code>, i.e.,
sparsity structure of the factor.</p>
</td></tr>
<tr><td><code id="chol_+3A_verbose">verbose</code></td>
<td>
<p>provides more details about the decomposition. Useful
when working with  huge matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chol</code> performs a Cholesky decomposition of a symmetric
positive definite sparse matrix <code>x</code> of class
<code>spam</code>. Currently, there is only the block sparse Cholesky
algorithm of Ng and Peyton (1993) implemented (<code>method="NgPeyton"</code>).
</p>
<p>To pivot/permute the matrix, you can choose between the multiple minimum
degree (<code>pivot="MMD"</code>) or reverse Cuthill-Mckee (<code>pivot="RCM"</code>)
from George and Lui (1981). It is also possible to furnish a specific
permutation in which case <code>pivot</code> is a vector. For compatibility
reasons, <code>pivot</code> can also take a logical in which for <code>FALSE</code>
no permutation is done and for <code>TRUE</code> is equivalent to
<code>MMD</code>.<br />
</p>
<p>Often the sparsity structure is fixed and does not change, but the
entries do. In those cases, we can update the Cholesky factor with
<code>update.spam.chol.NgPeyton</code> by suppling a Cholesky factor and the
updated matrix. For <code>U &lt;- chol(A)</code>,  <code>update(U,
  Anew)</code> and <code>chol(Anew, Rstruct=U)</code> are equivalent.
</p>
<p>The option <code>cholupdatesingular</code> determines how singular matrices
are handled by <code>update</code>. The function hands back an error
(<code>"error"</code>), a warning (<code>"warning"</code>) or the value <code>NULL</code>
(<code>"null"</code>).<br />
</p>
<p>The Cholesky decompositions requires parameters, linked to memory
allocation.  If the default values are too small the Fortran routine
returns an error to <span class="rlang"><b>R</b></span>, which allocates more space and calls the Fortran
routine again. The user can also pass better estimates of the allocation
sizes to <code>chol</code> with the argument <code>memory=list(nnzR=...,
  nnzcolindices=...)</code>. The minimal sizes for a fixed sparsity
structure can be obtained from a <code>summary</code> call, see &lsquo;Examples&rsquo;.<br />
</p>
<p>The output of <code>chol</code> can be used with <code>forwardsolve</code> and
<code>backsolve</code> to solve a system of linear equations.<br />
</p>
<p>Notice that the Cholesky factorization of the package <code>SparseM</code> is also
based on the algorithm of Ng and Peyton (1993).  Whereas the Cholesky
routine of the package <code>Matrix</code> are based on
<code>CHOLMOD</code> by Timothy A. Davis (<code>C</code> code).
</p>


<h3>Value</h3>

<p>The function returns the Cholesky factor in an object of class
<code>spam.chol.</code><em>method</em>. Recall that the latter is the Cholesky
factor of a reordered matrix <code>x</code>, see also <code><a href="#topic+ordering">ordering</a></code>.
</p>


<h3>Note</h3>

<p>Although the symmetric structure of <code>x</code> is needed, only the upper
diagonal entries are used. By default, the code does check for
symmetry (contrarily to <code>base:::chol</code>). However,
depending on the matrix size, this is a time consuming test.
A test is ignored if
<code>options("spam.cholsymmetrycheck")</code> is set to <code>FALSE</code>.
</p>
<p>If a permutation is supplied with <code>pivot</code>,
<code>options("spam.cholpivotcheck")</code> determines if the permutation is
tested for validity (defaults to <code>TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, based on Ng and Peyton (1993) Fortran routines</p>


<h3>References</h3>

<p>Ng, E. G. and Peyton, B. W.  (1993) Block sparse Cholesky algorithms on
advanced uniprocessor computers, <em>SIAM J. Sci. Comput.</em>, <b>14</b>,
1034&ndash;1056.
</p>
<p>Gilbert, J. R., Ng, E. G. and Peyton, B. W. (1994) An efficient
algorithm to compute row and column counts for sparse Cholesky
factorization, <em>SIAM J. Matrix Anal. Appl.</em>, <b>15</b>,
1075&ndash;1091.
</p>
<p>George, A. and  Liu, J. (1981)
<em>Computer Solution of Large Sparse Positive Definite Systems</em>,
Prentice Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+det.spam">det.spam</a></code>, <code><a href="#topic+solve.spam">solve.spam</a></code>,
<code><a href="#topic+forwardsolve.spam">forwardsolve.spam</a></code>, <code><a href="#topic+backsolve.spam">backsolve.spam</a></code> and <code><a href="#topic+ordering">ordering</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate multivariate normals:
set.seed(13)
n &lt;- 25    # dimension
N &lt;- 1000  # sample size
Sigma &lt;- .25^abs(outer(1:n,1:n,"-"))
Sigma &lt;- as.spam( Sigma, eps=1e-4)

cholS &lt;- chol( Sigma)
# cholS is the upper triangular part of the permutated matrix Sigma
iord &lt;- ordering(cholS, inv=TRUE)

R &lt;- as.spam(cholS)
mvsample &lt;- ( array(rnorm(N*n),c(N,n)) %*% R)[,iord]
# It is often better to order the sample than the matrix
# R itself.

# 'mvsample' is of class 'spam'. We need to transform it to a
# regular matrix, as there is no method 'var' for 'spam' (should there?).
norm( var( as.matrix( mvsample)) - Sigma, type='m')
norm( t(R) %*% R - Sigma)


# To speed up factorizations, memory allocations can be optimized:
opt &lt;- summary(cholS)
# here, some elements of Sigma may be changed...
cholS &lt;- chol( Sigma, memory=list(nnzR=opt$nnzR,nnzcolindices=opt$nnzc))

</code></pre>

<hr>
<h2 id='circulant'>Create Circulant Matrices</h2><span id='topic+circulant.spam'></span>

<h3>Description</h3>

<p>Creates a circulant matrix in <code>spam</code> format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulant.spam(x, n = NULL, eps = getOption("spam.eps"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant_+3A_x">x</code></td>
<td>
<p>the first row to form the circulant matrix or a list
containing the indices and the nonzero values.</p>
</td></tr>
<tr><td><code id="circulant_+3A_n">n</code></td>
<td>
<p>if <code>x</code> is a list, the dimension of the matrix.</p>
</td></tr>
<tr><td><code id="circulant_+3A_eps">eps</code></td>
<td>
<p>A tolerance parameter:  elements of <code>x</code> such that <code>abs(x)
    &lt;= eps</code> set to zero. Defaults to <code>eps = getOption("spam.eps")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The circulant matrix in <code>spam</code> format.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code>circulant</code> from package <span class="pkg">magic</span>, <code><a href="#topic+toeplitz.spam">toeplitz.spam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>circulant.spam(c(1,.25,0,0,0))
</code></pre>

<hr>
<h2 id='cleanup'>Cleaning up sparse matrices</h2><span id='topic+cleanup'></span>

<h3>Description</h3>

<p>Eliminates an zeros in a sparse matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanup(x, eps = getOption("spam.eps"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanup_+3A_x">x</code></td>
<td>
<p>a sparse matrix of class <code>spam</code>.</p>
</td></tr>
<tr><td><code id="cleanup_+3A_eps">eps</code></td>
<td>
<p>numeric scalar &gt; 0.  Smaller entries are coerced to zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sparse matrix may still contain zeros. This function (aliased
to <code>as.spam</code>) filters these values.<br />
This often causes confusion when testing such matrices for symmetry
or comparing apparently equal matrices with <code>all.equal</code>
(see &lsquo;Examples&rsquo; below.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+isSymmetric.spam">isSymmetric.spam</a></code> and <code><a href="#topic+all.equal.spam">all.equal.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag.spam(2)
A[1,2] &lt;- 0

all.equal(A, t(A))
isSymmetric.spam(A)
all.equal(cleanup(A), diag.spam(2))
</code></pre>

<hr>
<h2 id='coerce-methods'>Force a <code>spam</code> Object to Belong to a Class</h2><span id='topic+coerce.spam'></span><span id='topic+coerce+2Cspam+2Clogical-method'></span><span id='topic+coerce+2Cspam+2Cmatrix-method'></span><span id='topic+coerce+2Cspam+2Cvector-method'></span><span id='topic+coerce+2Cspam+2Clist-method'></span><span id='topic+coerce+2Cspam+2Cinteger-method'></span>

<h3>Description</h3>

<p>These functions manage the relations that allow coercing a <code>spam</code> object
to a given class.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(from = "spam", to = "matrix")</code></dt><dd>
<p>this is essentially equivalent to <code>as.matrix(object)</code>.
</p>
</dd>
<dt><code>signature(from = "spam", to = "list")</code></dt><dd>
<p>this is essentially equivalent to <code>triplet(object)</code>.
</p>
</dd>
<dt><code>signature(from = "spam", to = "vector")</code></dt><dd>
<p>this is essentially equivalent to <code>object@entries</code>
(<code>structurebased=TRUE</code>) or <code>c(object)</code>.
</p>
</dd>
<dt><code>signature(from = "spam", to = "logical")</code></dt><dd>
<p>the entries are forced to logicals (nonzeros only in case of
<code>structurebased=TRUE</code>).
</p>
</dd>
<dt><code>signature(from = "spam", to = "integer")</code></dt><dd>
<p>the entries are forced to integers (nonzeros only in case of
<code>structurebased=TRUE</code>).
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>ifelse( diag.spam(2)*c(0,1), TRUE, FALSE)
</code></pre>

<hr>
<h2 id='Coercion'>Coercion to a Vector</h2><span id='topic+as.vector'></span><span id='topic+as.vector.spam'></span><span id='topic+as.vector+2Cspam-method'></span><span id='topic+as.vector+2Cspam.chol.NgPeyton-method'></span>

<h3>Description</h3>

<p>Coercion of <code>spam</code> matrices to proper vector objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spam'
as.vector(x, mode = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coercion_+3A_x">x</code></td>
<td>
<p>spam object.</p>
</td></tr>
<tr><td><code id="Coercion_+3A_mode">mode</code></td>
<td>
<p>character string naming an atomic mode or <code>"any"</code>/<code>"list"</code>/<code>"expression"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This coercion allows smooth transitions between different
matrix formats, see example below.<br />
The Cholesky factors are first transformed to a <code>spam</code> object.
</p>


<h3>Value</h3>

<p>If <code>structurebased=TRUE</code>, the vector <code>x@entries</code>.<br />
Conversely, if <code>structurebased=FALSE</code>, the result is identical to
one with <code>as.vector(as.matrix(x))</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+spam.options">spam.options</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- diag(2)
ifelse( x, x, 1-x)
ifelse( x, as.vector(x), 1-as.vector(x))

x &lt;- diag.spam(2)
options(spam.structurebased=FALSE)
ifelse( x, as.vector(x), 1-as.vector(x))
options(spam.structurebased=TRUE)
ifelse( x, as.vector(x), 1-as.vector(x))
</code></pre>

<hr>
<h2 id='complexity'>Complexity for Sparse Matrices</h2><span id='topic+complexity'></span><span id='topic+complexities'></span>

<h3>Description</h3>

<p>A few results of computational complexities for selected
sparse algoritms in <code>spam</code>
</p>


<h3>Details</h3>

<p>A Cholesky factorization of an n-matrix requires n^3/3 flops. In case of
banded matrices (bandwidth p, p&lt;&lt;n) a factorization requires about 2np^2
flops. Forward- and backsolves for banded matrices require essentially
2np flops.
</p>
<p>George and Liu (1981) proves that any reordering would require at
least O(n^3/2) flops for the factorization and produce at least O(n
log(n)) fill-ins for square lattices with a local neighbor hood.<br />
They also show that algorithms based on nested dissection are optimal
in the order of magnitude sense.
</p>
<p>More to follow.
</p>


<h3>References</h3>

 
<p>George, A. and  Liu, J. (1981)
<em>Computer Solution of Large Sparse Positive Definite Systems</em>,
Prentice Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+det">det</a></code>, <code><a href="#topic+solve">solve</a></code>, 
<code><a href="#topic+forwardsolve">forwardsolve</a></code>, <code><a href="#topic+backsolve">backsolve</a></code> and <code><a href="#topic+ordering">ordering</a></code>.
</p>

<hr>
<h2 id='constructors'>Slot Modification</h2><span id='topic+rowpointers'></span><span id='topic+rowpointers+3C-'></span><span id='topic+colindices'></span><span id='topic+colindices+3C-'></span><span id='topic+entries'></span><span id='topic+entries+3C-'></span><span id='topic+dimension+3C-'></span><span id='topic+constructors'></span>

<h3>Description</h3>

<p>Modify slots of <code>spam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowpointers( x) &lt;- value
colindices( x) &lt;- value
entries( x) &lt;- value</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constructors_+3A_x">x</code></td>
<td>
<p>a <code>spam</code> matrix</p>
</td></tr>
<tr><td><code id="constructors_+3A_value">value</code></td>
<td>
<p>vector of appropriate length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Various tests are performed. Thus much slower than direct
assignment.<br />
Slot <code>dimension</code> should be changed through <code>pad</code> or <code>dim</code>
</p>


<h3>Value</h3>

<p>Modified <code>spam</code> object.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- diag.spam( 2)  
rowpointers( x) &lt;- c(1,1,3)

# The last line is equivalent to 
x@rowpointers &lt;- as.integer( c(1,1,3))
</code></pre>

<hr>
<h2 id='covmat'>Covariance Functions</h2><span id='topic+covmat'></span><span id='topic+cov.exp'></span><span id='topic+cov.sph'></span><span id='topic+cor.sph'></span><span id='topic+cov.nug'></span><span id='topic+cov.wu1'></span><span id='topic+cov.wu2'></span><span id='topic+cov.wu3'></span><span id='topic+cov.wend1'></span><span id='topic+cov.wend2'></span><span id='topic+cov.mat'></span><span id='topic+cov.mat12'></span><span id='topic+cov.mat32'></span><span id='topic+cov.mat52'></span><span id='topic+cov.finnmat'></span>

<h3>Description</h3>

<p>Evaluate a covariance function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat(h, theta, ... , type="sph")

cov.exp(h, theta, ... , eps= getOption("spam.eps"))
cov.sph(h, theta, ... , eps= getOption("spam.eps"))
cov.nug(h, theta, ... , eps= getOption("spam.eps"))
cov.wend1(h, theta, ... , eps= getOption("spam.eps"))
cov.wend2(h, theta, ... , eps= getOption("spam.eps"))
cov.wu1(h, theta, ... , eps= getOption("spam.eps"))
cov.wu2(h, theta, ... , eps= getOption("spam.eps"))
cov.wu3(h, theta, ... , eps= getOption("spam.eps"))
cov.mat(h, theta, ... , eps= getOption("spam.eps"))
cov.finnmat(h, theta, ... , eps= getOption("spam.eps"))
cov.mat12(h, theta, ... , eps= getOption("spam.eps"))
cov.mat32(h, theta, ... , eps= getOption("spam.eps"))
cov.mat52(h, theta, ... , eps= getOption("spam.eps"))

cor.sph(h, range, ... , eps= getOption("spam.eps"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat_+3A_h">h</code></td>
<td>
<p>object containing the lags.</p>
</td></tr>
<tr><td><code id="covmat_+3A_theta">theta</code></td>
<td>
<p>parameter of the covariance function, see
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="covmat_+3A_range">range</code></td>
<td>
<p>parameter defining the compact support.</p>
</td></tr>
<tr><td><code id="covmat_+3A_type">type</code></td>
<td>
<p>covariance function specification.</p>
</td></tr>
<tr><td><code id="covmat_+3A_...">...</code></td>
<td>
<p>arguments passed from other methods.</p>
</td></tr>
<tr><td><code id="covmat_+3A_eps">eps</code></td>
<td>
<p>tolerance level, see
&lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>covmat</code> is a wrapper that calls the other functions
according to the argument <code>type</code>. The nomenclature is similar to
<code>precmat</code>.
<br />
The parametrization is (range, [partial-sill = 1], [smoothness = 1], [nugget = 0]), where
only the range needs to be specified.
In case of negative parameter values, a warning is issued and the
absolute value is retained.
Although more cryptic, having all arguments as a single vector
simplifies optimization with <code>optim</code>.
<br />
The parameters are and locations are up to precision <code>epsilon</code>.
That means that all distances smaller than <code>eps</code> are considered zero; a nugget smaller than <code>eps</code> is ignored; a range smaller than <code>eps</code> represents a nugget model; etc.
<br />
<code>cov.finnmat()</code> is similar to <code>cov.mat()</code> but with the
<code>sqrt(8*smoothness)/range</code> argument in the Bessel function
(instead of <code>1/range</code>).
<code>cov.mat12()</code> is a wrapper to <code>cov.exp()</code>
<code>cov.mat32()</code>, and <code>cov.mat52()</code> are fast version of
<code>cov.mat()</code> with smoothness 3/2 and 5/2, respectively (factor 10).
<br />
<code>cor.sph(,range)</code> is a fast version of <code>cov.sph(,c(range,1,0))</code>.
<br />
Currently, the functions distinguish between a sparse <code>spam</code>
object <code>h</code> and any other numeric type. In the future, this might
change and appropriate methods will be implemented.
</p>


<h3>Value</h3>

<p>Covariance function evaluated on <code>h</code>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>Any classical book about geostatistics.</p>


<h3>See Also</h3>

<p><code><a href="#topic+precmat">precmat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 200
locs &lt;- cbind(runif(n),runif(n))
h &lt;- nearest.dist(locs, delta=sqrt(2), upper = NULL)
Sigma &lt;- cov.sph(h, c(.3, 1, .1))

iidsample &lt;- rnorm(n)
cholS &lt;- chol.spam(as.spam(Sigma))
iorder &lt;- iord &lt;- ordering(cholS, inv = TRUE)
sample &lt;- (iidsample %*% as.spam(cholS))[iorder]
plot(locs, col = fields::tim.colors(n = 256)[cut(sample, n)], pch = 20)

## Not run: 
h &lt;- seq(0, to=1, length.out=100)
plot( h, cov.exp(h, c(1/3,1)), type='l', ylim=c(0,1))
type &lt;- c("sph","wendland1","wendland2","wu1","wu2","wu3")
for (i in 1:6)
  lines( h, covmat(h, 1, type=type[i]), col=i+1)
legend('topright',legend=type, col=2:7, lty=1)


## End(Not run)
</code></pre>

<hr>
<h2 id='crossprod'>Spam Matrix Crossproduct</h2><span id='topic+crossprod.default'></span><span id='topic+crossprod.spam'></span><span id='topic+tcrossprod.spam'></span><span id='topic+crossprod+2Cspam+2Cmissing-method'></span><span id='topic+tcrossprod+2Cspam+2Cmissing-method'></span><span id='topic+crossprod+2CANY+2Cspam-method'></span><span id='topic+tcrossprod+2CANY+2Cspam-method'></span><span id='topic+crossprod+2Cspam+2Cspam-method'></span><span id='topic+tcrossprod+2Cspam+2Cspam-method'></span><span id='topic+crossprod+2Cspam+2CANY-method'></span><span id='topic+tcrossprod+2Cspam+2CANY-method'></span>

<h3>Description</h3>

<p>Given matrices <code>x</code> and <code>y</code> as arguments, return a matrix
cross-product.  This is formally equivalent to (but usually
slightly faster than) the call <code>t(x) %*% y</code> (<code>crossprod.spam</code>) or <code>x
     %*% t(y)</code> (<code>tcrossprod.spam</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>
     crossprod.spam(x, y = NULL, ...)
     
     tcrossprod.spam(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossprod_+3A_x">x</code>, <code id="crossprod_+3A_y">y</code></td>
<td>
<p>matrices: <code>y = NULL</code> is taken to be the
same matrix as <code>x</code>.  Vectors are promoted to single-column or
single-row matrices, depending on the context.</p>
</td></tr>
<tr><td><code id="crossprod_+3A_...">...</code></td>
<td>
<p>potentially further arguments from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double matrix</p>


<h3>Note</h3>

<p>When <code>x</code> or <code>y</code> are not matrices, they are treated as column or
row matrices.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>Examples</h3>

<pre><code class='language-R'>crossprod.spam(diag.spam(2),1:2)

</code></pre>

<hr>
<h2 id='det'>Determinant of a Symmetric Positive Definite Sparse Matrix</h2><span id='topic+det+2Cspam-method'></span><span id='topic+det+2Cspam.chol.NgPeyton-method'></span><span id='topic+det.spam'></span><span id='topic+det'></span><span id='topic+determinant'></span><span id='topic+determinant+2Cspam-method'></span><span id='topic+determinant.spam'></span><span id='topic+determinant.spam.chol'></span><span id='topic+determinant.spam.chol.NgPeyton'></span>

<h3>Description</h3>

<p><code>det</code> and <code>determinant</code> calculate the determinant of a
symmetric, positive definite sparse matrix. <code>determinant</code> returns
separately the modulus of the determinant, optionally on the logarithm scale,
and the sign of the determinant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det(x, ...)
determinant(x, logarithm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det_+3A_x">x</code></td>
<td>
<p>sparse matrix of class <code>spam</code> or a Cholesky factor  of
class <code>spam.chol.NgPeyton</code>.</p>
</td></tr>
<tr><td><code id="det_+3A_logarithm">logarithm</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) return the logarithm of the
modulus of the determinant.</p>
</td></tr>
<tr><td><code id="det_+3A_...">...</code></td>
<td>
<p>Optional arguments. Examples include <code>method</code> argument
and additional parameters used by the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the matrix is not positive definite, the function issues a
warning and returns <code>NA</code>.
</p>
<p>The determinant is based on the product of the diagonal entries of a
Cholesky factor, i.e. internally, a Cholesky decomposition is
performed. By default, the NgPeyton algorithm with minimal degree
ordering us used. To change the methods or supply additonal parameters
to the Cholesky factorization function, it is possible to pass via
<code><a href="#topic+chol">chol</a></code>.
</p>
<p>The determinant of a Cholesky factor is also defined.
</p>


<h3>Value</h3>

<p>For <code>det</code>, the determinant of <code>x</code>.  For <code>determinant</code>, a
list with components
</p>
<table>
<tr><td><code>modulus</code></td>
<td>
<p>a numeric value.  The modulus (absolute value) of the
determinant if <code>logarithm</code> is <code>FALSE</code>; otherwise the
logarithm of the modulus.</p>
</td></tr>
<tr><td><code>sign</code></td>
<td>
<p>+1, as only symmetric positive definite matrices are considered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>Ng, E. G. and B. W. Peyton (1993) Block sparse Cholesky algorithms
on advanced uniprocessor computers, <em>SIAM J. Sci. Comput.</em>, <b>14</b>,
1034&ndash;1056.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chol.spam">chol.spam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spam( c(4,3,0,3,5,1,0,1,4), 3)
det( x)
determinant( x)

det( chol( x))
</code></pre>

<hr>
<h2 id='diag'>Sparse Matrix diagonals</h2><span id='topic+diag'></span><span id='topic+diag.of.spam'></span><span id='topic+diag.spam'></span><span id='topic+spam_diag'></span><span id='topic+diag+2Cspam-method'></span><span id='topic+diag+2CANY-method'></span><span id='topic+diag+3C-'></span><span id='topic+diag+3C-+2CANY-method'></span><span id='topic+diag+3C-+2Cspam-method'></span><span id='topic+diag+3C-.spam'></span><span id='topic+diag.spam+3C-'></span><span id='topic+diag.assign+2Cspam-method'></span>

<h3>Description</h3>

<p>Extract or replace the diagonal of a matrix, or construct a
diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## diag(x)
## diag(x=1, nrow, ncol, names = TRUE)
diag(x) &lt;- value

diag.spam(x=1, nrow, ncol)
spam_diag(x=1, nrow, ncol)
diag.spam(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_+3A_x">x</code></td>
<td>
<p>a <code>spam</code> matrix, a vector or a scalar.</p>
</td></tr>
<tr><td><code id="diag_+3A_nrow">nrow</code>, <code id="diag_+3A_ncol">ncol</code></td>
<td>
<p>Optional dimensions for the result.</p>
</td></tr>
<tr><td><code id="diag_+3A_value">value</code></td>
<td>
<p>either a single value or a vector of length equal to that of
the current diagonal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>diag(x)</code> can have unexpected effects if <code>x</code> is a vector
that could be of length one. Use <code>diag(x, nrow = length(x))</code> for
consistent behaviour.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a spam matrix then <code>diag(x)</code> returns the diagonal of <code>x</code>.
</p>
<p>The assignment form sets the diagonal of the sparse matrix <code>x</code> to the
given value(s).<br />
</p>
<p><code>diag.spam</code> works as <code>diag</code> for spam matrices:
If <code>x</code> is a vector (or 1D array) of length two or more, then
<code>diag.spam(x)</code> returns a diagonal matrix whose diagonal is
<code>x</code>.
<code>spam_diag</code> is an alias for  <code>diag.spam</code> and in the spirit
of the result of <code>diag</code> is a <code>spam</code> object.
</p>
<p>If <code>x</code> is a vector of length one then <code>diag.spam(x)</code> returns an
identity matrix of order the nearest integer to <code>x</code>.  The
dimension of the returned matrix can be specified by <code>nrow</code> and
<code>ncol</code> (the default is square).
</p>
<p>The assignment form sets the diagonal of the matrix <code>x</code> to the
given value(s).
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+upper.tri">upper.tri</a></code>, <code><a href="#topic+lower.tri">lower.tri</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diag.spam(2, 4)           # 2*I4
smat &lt;- diag.spam(1:5)
diag( smat)
diag( smat) &lt;- 5:1

# The last line is equivalent to 
diag.spam( smat) &lt;- 5:1

# Note that diag.spam( 1:5) &lt;- 5:1 not work of course.


</code></pre>

<hr>
<h2 id='diff'>Lagged Differences</h2><span id='topic+diff'></span><span id='topic+diff.spam'></span><span id='topic+diff+2Cspam-method'></span>

<h3>Description</h3>

<p>Returns suitably lagged and iterated differences.</p>


<h3>Usage</h3>

<pre><code class='language-R'># diff.spam(x, lag = 1, differences = 1, ...)
## S4 method for signature 'spam'
diff(x, lag = 1, differences = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_+3A_x">x</code></td>
<td>
<p>a <code>spam</code> matrix containing the values to be
differenced.</p>
</td></tr>
<tr><td><code id="diff_+3A_lag">lag</code></td>
<td>
<p>an integer indicating which lag to use.</p>
</td></tr>
<tr><td><code id="diff_+3A_differences">differences</code></td>
<td>
<p>an integer indicating the order of the difference.</p>
</td></tr>
<tr><td><code id="diff_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>spam</code> matrix with elements similar to
<code>as.spam(diff(as.matrix(x), ...))</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diff">diff</a></code> in <code>base</code>, <code><a href="#topic+precmat">precmat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># incidence matrix for a RW(3) model
D &lt;- diff.spam(diag.spam(10), lag=1, differences=3)
t(D)%*%D
</code></pre>

<hr>
<h2 id='dim'>Dimensions of an Object</h2><span id='topic+dim.spam'></span><span id='topic+dim+3C-.spam'></span><span id='topic+dim+3C-+2Cspam-method'></span>

<h3>Description</h3>

<p>Retrieve or set the dimension of an <code>spam</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># dim(x)
# dim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_+3A_x">x</code></td>
<td>
<p>a <code>spam</code> matrix</p>
</td></tr>
<tr><td><code id="dim_+3A_value">value</code></td>
<td>
<p>A numeric two-vector, which is coerced to integer (by truncation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In older version of <code>spam</code>, the behavior of the replacement
method was different and is now implemented in <code><a href="#topic+pad.spam">pad.spam</a></code>.
</p>


<h3>Value</h3>

<p><code>dim</code> retrieves
the <code>dimension</code> slot of the object.  It is a vector
of mode <code>integer</code>.
</p>
<p>The replacemnt method changes the dimension of the object by rearranging.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+pad.spam">pad.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- diag(4)
dim(x)&lt;-c(2,8)
x

s &lt;- diag.spam(4)
dim(s) &lt;- c(2,8)  # result is different than x

s &lt;- diag.spam(4)
pad(s) &lt;- c(7,3)  # any positive value can be used

</code></pre>

<hr>
<h2 id='display'>Graphially Represent the Nonzero Entries</h2><span id='topic+display'></span><span id='topic+display.spam'></span><span id='topic+display+2Cspam-method'></span>

<h3>Description</h3>

<p>The function represents the nonzero entries in a simple
bicolor plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_+3A_x">x</code></td>
<td>
<p>matrix of class <code>spam</code> or <code>spam.chol.NgPeyton</code>.</p>
</td></tr>
<tr><td><code id="display_+3A_...">...</code></td>
<td>
<p>any other arguments passed
to <code>image.default</code>/<code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spam.getOption("imagesize")</code> determines  if the sparse matrix is
coerced into a matrix and the plotted with <code>image.default</code> or if
the matrix is simply represented as a scatterplot with
<code>pch="."</code>.  The points are scaled according to
<code>cex*getOption("spam.cex")/(nrow + ncol)</code>.
For some devices or for non-square matrices,
<code>cex</code> needs probably some adjustment.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+image">image</a></code>, <code><a href="#topic+spam.options">spam.options</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)

smat &lt;- spam_random(8)
par(mfcol=c(1,2), pty='s')
options(spam.imagesize = 1000)
display(smat)
options(spam.imagesize = 10)
display(smat, cex=.25)


# very large but very sparse matrix
smat &lt;- spam_random(2^14, distribution=rnorm, density=1e-5, verbose=TRUE)
par(mfcol=c(1, 1), mai=c(.4,.4,.1,.1), pty='s')
display(smat)
</code></pre>

<hr>
<h2 id='eigen'>Eigenvalues for Sparse Matrices</h2><span id='topic+eigen.spam'></span><span id='topic+eigen_approx'></span>

<h3>Description</h3>

<p>Functions to calculate eigenvalues and eigenvectors of <code>sparse</code> matrices.
It uses the value of <code>spam.options("inefficiencywarning")</code> to dispatch between <code>base::eigen()</code> or the Implicitly Restarted Arnoldi Process, using 'ARPACK'.
</p>
<p><code>eigen.spam</code> is a wrapper function of <code>eigen_approx</code> and transforms its output to <code>base::eigen</code> like.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen.spam(x, nev = 10, symmetric, only.values = FALSE, control = list())
eigen_approx(x, nev, ncv, nitr, mode, only.values = FALSE, verbose = FALSE, f_routine)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_+3A_x">x</code></td>
<td>
<p>a matrix of class <code>spam</code> whose <code>nev</code> eigenvalues and eigenvectors are to be computed.</p>
</td></tr>
<tr><td><code id="eigen_+3A_nev">nev</code></td>
<td>
<p>number of eigenvalues to calculate.</p>
</td></tr>
<tr><td><code id="eigen_+3A_symmetric">symmetric</code></td>
<td>
<p>if TRUE, the matrix is assumed to be symmetric.</p>
</td></tr>
<tr><td><code id="eigen_+3A_only.values">only.values</code></td>
<td>
<p>if TRUE, only <code>nev</code> eigenvalues are computed and returned, otherwise <code>nev</code> eigenvalues and eigenvectors are returned.</p>
</td></tr>
<tr><td><code id="eigen_+3A_control">control</code></td>
<td>
<p>additional options, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="eigen_+3A_ncv">ncv</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr><td><code id="eigen_+3A_nitr">nitr</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr><td><code id="eigen_+3A_mode">mode</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr><td><code id="eigen_+3A_verbose">verbose</code></td>
<td>
<p>see &lsquo;Details&rsquo;, use the <code>control</code> option for <code>eigen.spam</code>.</p>
</td></tr>
<tr><td><code id="eigen_+3A_f_routine">f_routine</code></td>
<td>
<p>only for <code>eigen_approx</code>, to call the Fortran routine for symmetric matrices set this option to &quot;ds_eigen_f&quot; and for non symmetric to &quot;dn_eigen_f&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>mode = "  "</code>:</dt><dd>
<p>there are different modes available for this function, each mode returns a different range of eigenvalues.
Also the available modes are dependent, whether the input matrix is symmetric or not:
</p>

<dl>
<dt><code>"LM"</code>:</dt><dd><p>Eigenvalues with largest magnitude (sym, non sym), that is, largest eigenvalues in the Euclidean norm of complex numbers.</p>
</dd>
<dt><code>"SM"</code>:</dt><dd><p>Eigenvalues with smallest magnitude (sym, non sym), that is, smallest eigenvalues in the Euclidean norm of complex numbers.</p>
</dd>
<dt><code>"LR"</code>:</dt><dd><p>Eigenvalues with largest real part (non sym).</p>
</dd>
<dt><code>"SR"</code>:</dt><dd><p>Eigenvalues with smallest real part (non sym).</p>
</dd>
<dt><code>"LI"</code>:</dt><dd><p>Eigenvalues with largest imaginary part (non sym).</p>
</dd>
<dt><code>"SI"</code>:</dt><dd><p>Eigenvalues with smallest imaginary part (non sym).</p>
</dd>
<dt><code>"LA"</code>:</dt><dd><p>Eigenvalues with largest algebraic value (sym), that is, largest eigenvalues inclusive of any negative sign.</p>
</dd>
<dt><code>"SA"</code>:</dt><dd><p>Eigenvalues with smallest algebraic value (syn), that is, smallest eigenvalues inclusive of any negative sign.</p>
</dd>
</dl>

</dd>
<dt><code>ncv</code>:</dt><dd>
<p>the largest number of basis vectors that will be used in the Implicitly Restarted Arnoldi Process.
Work per major iteration is proportional to x@dimension[1]*ncv*ncv.
The default is set if <code>symmetric</code> to min(x@dimension[1] + 1, max(2 * nev + 1, 200)) or else to min(x@dimension[1] - 1, max(2 * nev + 1, 100)).
Note, this value should not be chosen arbitrary large, but slightly larger than <code>nev</code>.
Otherwise it could lead to memory allocation problems.</p>
</dd>
<dt><code>nitr</code>:</dt><dd>
<p>the maximum number of iterations.
The default is set to <code>ncv + 1000</code></p>
</dd>
<dt><code>spamflag = FALSE</code>:</dt><dd>
<p>if TRUE, the Implicitly Restarted Arnoldi Process is used,
independent of the dimension of the respective matrix (provided matrix
is larger than 10x10).</p>
</dd>
<dt><code>verbose = FALSE</code>:</dt><dd>
<p>print additional information.</p>
</dd>
<dt><code>cmplxeps</code>:</dt><dd>
<p>threshold to determine whether a double value is zero, while transforming the ARPACK output to R class complex.
The default is set to <code>.Machine$double.eps</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A vector of the length corresponding to the dimension of the input matrix.
Containing the required <code>nev</code> eigenvalues.
If requested also the corresponding eigenvectors.
In the non symmetric case, the eigenvalues are returned in a matrix with a column containing the real parts and a column containing the imaginary parts of the eigenvalues.
The eigenvectors are then returned in two matrices.</p>


<h3>Note</h3>

<p>The user is advised to choose the <code>control</code> options carefully, see &lsquo;Details&rsquo; for more information.
</p>


<h3>Author(s)</h3>

<p>Roman Flury, Reinhard Furrer</p>


<h3>References</h3>

<p>Lehoucq, R. B. and Sorensen, D. C. and Yang, C. (1997) <em>ARPACK Users Guide: Solution of Large Scale Eigenvalue Problems by Implicitly Restarted Arnoldi Methods</em>.</p>


<h3>See Also</h3>

<p>Option <code>"inefficiencywarning"</code> in <code><a href="#topic+spam.options">spam.options</a></code> and <code><a href="#topic+spam_random">spam_random</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(81)
rspam &lt;- spam_random(42^2, density = .0001, spd = TRUE)
SPD &lt;- eigen.spam(rspam, nev = 18, control = list(mode = "SM"),
                  only.values = TRUE)

any(SPD$values &lt;= 0, na.rm = TRUE)
isSymmetric(rspam)
# hence the matrix is symmetric positiv definit

rspam2 &lt;- spam_random(50^2, density = .0001, spd = FALSE, sym = TRUE,
                      distribution = rpois, lambda = 2)
SNPD &lt;- eigen.spam(rspam2, nev = 18, control = list(mode = "SM"),
                    only.values = TRUE)

any(SNPD$values &lt;= 0, na.rm = TRUE)
isSymmetric(rspam2)
# hence the matrix is symmetric but not positiv definit
</code></pre>

<hr>
<h2 id='fields-wrapper'>Wrapper for Distance Matrix Computation</h2><span id='topic+spam_rdist'></span><span id='topic+rdist.dist'></span><span id='topic+spam_rdist.earth'></span>

<h3>Description</h3>

<p>These functions are simple wrappers to <code>nearest.dist</code>
to be used in <code>fields</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spam_rdist( x1, x2, delta = 1)
spam_rdist.earth( x1, x2, delta = 1, miles=TRUE, R=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fields-wrapper_+3A_x1">x1</code></td>
<td>
<p>Matrix of first set of locations where each row gives the
coordinates of a particular point. </p>
</td></tr>
<tr><td><code id="fields-wrapper_+3A_x2">x2</code></td>
<td>
<p>Matrix of second set of locations where each row gives the
coordinates of a particular point.</p>
</td></tr>
<tr><td><code id="fields-wrapper_+3A_delta">delta</code></td>
<td>
<p>only distances smaller than <code>delta</code> are recorded,
see Details.</p>
</td></tr>
<tr><td><code id="fields-wrapper_+3A_miles">miles</code></td>
<td>
<p>For great circle distance: If true distances are in statute miles if false distances in
kilometers.</p>
</td></tr>
<tr><td><code id="fields-wrapper_+3A_r">R</code></td>
<td>
<p>Radius to use for sphere to find spherical distances. If <code>NULL</code>
the radius is either in miles or kilometers depending on the
values of the miles argument. If <code>R=1</code> then distances are of
course in radians.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers to <code>rdist</code> and
<code>rdist.earth</code> in <code>fields</code>. They are used
to simplify the use of sparse matrices in functions like <code>mKrig</code>.
<br />
</p>
<p>For great circle distance, the matrices <code>x1</code> and <code>x2</code>
contain the degrees longitudes in the first and the degrees latitudes
in the second column.  <code>delta</code> is in degrees. Hence to restrict
to distances smaller than <code>delta.km</code>, one has to specify
<code>delta=delta.km*360/(6378.388*2*pi)</code>.
</p>


<h3>Value</h3>

<p>A <code>spam</code> object containing the distances spanned between
zero and <code>delta</code>. The sparse matrix may contain many zeros
(e.g., collocated data). However, to calculate covariances, these zeros
are essential.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+nearest.dist">nearest.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(fields)
look &lt;- mKrig(x,Y, Covariance="Wendland", dimension=2, k=1,
    cov.args=list( Distance='spam_rdist'))

## End(Not run)

</code></pre>

<hr>
<h2 id='foreign'>Transformation to Other Sparse Formats</h2><span id='topic+foreign'></span><span id='topic+as.spam.matrix.csr'></span><span id='topic+as.dgRMatrix.spam'></span><span id='topic+as.dgCMatrix.spam'></span><span id='topic+as.spam.dgRMatrix'></span><span id='topic+as.spam.dgCMatrix'></span>

<h3>Description</h3>

<p>Transform between the <code>spam</code> sparse format to the
<code>matrix.csr</code> format of <code>SparseM</code> and  <code>dgRMatrix</code> format of <code>Matrix</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>as.spam.matrix.csr(x)
as.dgRMatrix.spam(x)
as.dgCMatrix.spam(x)
as.spam.dgRMatrix(x)
as.spam.dgCMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreign_+3A_x">x</code></td>
<td>
<p>sparse matrix of class <code>spam</code>, <code>matrix.csr</code>,
<code>dgRMatrix</code> or <code>dgCMatrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We do not provide any <code>S4</code> methods and because of the existing
mechanism a standard <code>S3</code> does not work.<br />
</p>
<p>The functions are based on <code>require</code>.<br />
</p>
<p>Notice that <code>as.matrix.csr.spam</code> should read as <code>as."matrix.csr".spam</code>.
</p>


<h3>Value</h3>

<p>According to the call, a sparse matrix of class  <code>spam</code>,
<code>matrix.csr</code>, <code>dgRMatrix</code> or <code>dgCMatrix</code>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+triplet">triplet</a></code>, <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> or <code>matrix.csr</code> from package <span class="pkg">SparseM</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
S &lt;- diag.spam(4)
R &lt;- as.dgRMatrix.spam( S)
C &lt;- as.dgCMatrix.spam( S)
as.spam.dgCMatrix(C)
slotNames(C)
slotNames(R)
# For column oriented sparse formats a transpose does not the job,
# as the slot names change.


# as.spam(R) does not work.

## End(Not run)

## Not run: 
# for transformations between SparseM and spam:

as.matrix.csr.spam &lt;- function(x,...) {
  if (new("matrix.csr")) {
    newx &lt;- new("matrix.csr")
    slot(newx,"ra",check=FALSE) &lt;- x@entries
    slot(newx,"ja",check=FALSE) &lt;- x@colindices
    slot(newx,"ia",check=FALSE) &lt;- x@rowpointers
    slot(newx,"dimension",check=FALSE) &lt;- x@dimension
    return(newx)
    }
  stop("function requires 'SparseM' package")
}
# then with `SparseM`:  as.matrix.csr.spam( spamobject )

## End(Not run)

## Not run: 
# a dataset contained in Matrix
data(KNex, package='Matrix')
summary( KN &lt;- as.spam.dgCMatrix(KNex$mm) )


## End(Not run)
</code></pre>

<hr>
<h2 id='germany.data'>Meta-data About Administrative Districts of Germany</h2><span id='topic+germany.data'></span><span id='topic+germany.info'></span><span id='topic+germany.poly'></span><span id='topic+germany.spam'></span><span id='topic+germany'></span>

<h3>Description</h3>

<p>Supplementary data used for the display of data
from the administrative districts of Germany</p>


<h3>Format</h3>

<p><code>germany.info</code> is a list with elements
</p>

<dl>
<dt>n</dt><dd><p>544 (number of districts around 1990).</p>
</dd>
<dt>xrep,yrep</dt><dd><p>representative coordinates of the districts (vectors
of length 544)</p>
</dd>
<dt>xlim,ylim</dt><dd><p>2-vectors defining the limits of the districts.</p>
</dd>
<dt>polyid</dt><dd><p>linking the polygons to the districts (599 vector).</p>
</dd>
<dt>id</dt><dd><p>linking the districts to Community Identification Number.</p>
</dd></dl>

<p><code>germany.poly</code> defines the polygons. It is a 17965 by two matrix,
each polygon separated by a row of <code>NA</code>s, each district by two rows.<br />
<code>germany</code> defines the polygons in form of a list (backwards compatibility). </p>


<h3>Details</h3>

<p>The representative coordinates are calculated based on the mean
value of the polygon coordinates. This creates sometimes strange
values, e.g., district Leer.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>The meta-data has been constructed based on (essentially)
files from the   package <span class="pkg">INLA</span>, see <code>demo(Bym)</code>.<br />
</p>
<p>See also <a href="https://de.wikipedia.org/wiki/Amtlicher_Gemeindeschl%C3%BCssel">https://de.wikipedia.org/wiki/Amtlicher_Gemeindeschl%C3%BCssel</a>
and <a href="https://en.wikipedia.org/wiki/Districts_of_Germany">https://en.wikipedia.org/wiki/Districts_of_Germany</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+germany.plot">germany.plot</a></code> <code><a href="#topic+Oral">Oral</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the Bundeslaender:
germany.plot(germany.info$id%/%1000,col=rep(2:8,3), legend=FALSE)
</code></pre>

<hr>
<h2 id='germany.plot'>Plot Administrative Districts of Germany</h2><span id='topic+germany.plot'></span>

<h3>Description</h3>

<p>Displaying data
over the administrative districts of Germany</p>


<h3>Usage</h3>

<pre><code class='language-R'>germany.plot(vect,  col=NULL, zlim=range(vect), legend=TRUE, 
             main=NULL, cex.axis=1, cex.main=1.5, add=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="germany.plot_+3A_vect">vect</code></td>
<td>
<p>vector of length 544</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_col">col</code></td>
<td>
<p>color scheme to be used. By default uses <code>colorRampPalette(brewer.pal(9,"Blues"))(100)</code>.</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_zlim">zlim</code></td>
<td>
<p>the minimum and maximum values for which colors should be
plotted, defaulting to the range of <code>data</code>.</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_legend">legend</code></td>
<td>
<p>Should the legend be added, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>label size of legend.</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_cex.main">cex.main</code></td>
<td>
<p>label size of overall plot title.</p>
</td></tr> 
<tr><td><code id="germany.plot_+3A_add">add</code></td>
<td>
<p>logical, if true adds to current plot.</p>
</td></tr>
<tr><td><code id="germany.plot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>polygon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The legend is only added, provided (a) function
<code>image.plot</code> is available.<br />
</p>
<p>The perfect position of the legend is an art per se and depends on
various <code>par</code> parameters. One possiblity for finer control is to
not plot it and to manually call the function
<code>image.plot</code> of <span class="pkg">fields</span>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>See also <a href="https://de.wikipedia.org/wiki/Amtlicher_Gemeindeschl%C3%BCssel">https://de.wikipedia.org/wiki/Amtlicher_Gemeindeschl%C3%BCssel</a>
and <a href="https://de.wikipedia.org/wiki/Liste_der_Landkreise_in_Deutschland">https://de.wikipedia.org/wiki/Liste_der_Landkreise_in_Deutschland</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Oral">Oral</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( Oral)
germany.plot( Oral$Y/Oral$E)


# Plot the Bundeslaender:
germany.plot(germany.info$id%/%1000,col=rep(2:8,3), legend=FALSE)
</code></pre>

<hr>
<h2 id='gmult'>Generalized Multiplication</h2><span id='topic+gmult'></span>

<h3>Description</h3>

<p>Multiplying specific submatrices of a spam matrix with different factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmult(x, splits, fact)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmult_+3A_x">x</code></td>
<td>
<p>a spam matrix.</p>
</td></tr>
<tr><td><code id="gmult_+3A_splits">splits</code></td>
<td>
<p>vector of how to split the matrix into submatrices.
It starts with <code>1</code> and ends with <code>max(dim(X))+1</code>.</p>
</td></tr>
<tr><td><code id="gmult_+3A_fact">fact</code></td>
<td>
<p>matrix of factors to multiply submatrices defined by splits.
Dimensions of <code>fact</code> must correspond to the <code>length(splits)-1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spam matrix, where each specified submatrix is multiplied with a factor.</p>


<h3>Author(s)</h3>

<p>Florian Gerber, Roman Flury</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spam(1, 15, 15)
print(x, minimal = FALSE)

splits &lt;- c(1,2,8,ncol(x)+1) # divide matrix into 9 submatrices
fact &lt;- array(1:9, c(3,3))   # multiply each submatrix with a different factor
oF &lt;- gmult(x, splits, fact)
print(oF, minimal = FALSE)
</code></pre>

<hr>
<h2 id='grid_trace2'>Two trace plots and a scatter plot.</h2><span id='topic+grid_trace2'></span>

<h3>Description</h3>

<p>For two (MCMC) chains of the same length trace plots
and a scatter plot are drawn. </p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_trace2(chain1, chain2 = NULL,
            xlim = NULL, ylim1 = NULL, ylim2=NULL,
            chain1_lab = "", chain2_lab = "", main = "",
            chain1_yaxis_at = NULL, chain2_yaxis_at = NULL,
            log = FALSE,
            cex_points = unit(0.2, "mm"),
            cex_main = unit(1.2, "mm"),
            lwd_lines = unit(0.1, "mm"),
            lwd_frame = unit(0.8, "mm"),
            draw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_trace2_+3A_chain1">chain1</code></td>
<td>
<p>Numeric vector or a matrix with two columns.</p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_chain2">chain2</code></td>
<td>
<p>Numeric vector of same length as <code>chain1</code>. (Only used if <code>chain1</code> is specified as vector).</p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits of both chains (numeric vector of length 2). </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_ylim1">ylim1</code></td>
<td>
<p>y axis limits of chain 1 (numeric vector of length 2).</p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_ylim2">ylim2</code></td>
<td>
<p>y axis limits of chain 2 (numeric vector of length 2).</p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_chain1_lab">chain1_lab</code></td>
<td>
<p>Label of chain 1 (character of length 1). </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_chain2_lab">chain2_lab</code></td>
<td>
<p>Label of chain 2 (character of length 1). </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_main">main</code></td>
<td>
<p>Title (character of length 1). </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_chain1_yaxis_at">chain1_yaxis_at</code></td>
<td>
<p>Points at which tick-marks are drawn for chain 1.</p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_chain2_yaxis_at">chain2_yaxis_at</code></td>
<td>
<p>Points at which tick-marks are drawn for chain 2. </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_log">log</code></td>
<td>
<p>Logical, should the date be log transformed?</p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_cex_points">cex_points</code></td>
<td>
<p>Size of points in scatter plot. </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_cex_main">cex_main</code></td>
<td>
<p>Size of the title font. </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_lwd_lines">lwd_lines</code></td>
<td>
<p>Line width of trace plots. </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_lwd_frame">lwd_frame</code></td>
<td>
<p>Line width of frames. </p>
</td></tr>
<tr><td><code id="grid_trace2_+3A_draw">draw</code></td>
<td>
<p>Logical, should the returned grob object be drawn?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The figure is optimized for a plot of the format
x11(width = 10, height = 3).</p>


<h3>Value</h3>

<p>A grob object.</p>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;</p>


<h3>See Also</h3>

<p>grid_zoom</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid_trace2(runif(500), runif(500),
            chain1_yaxis_at = seq(.2, 1, by = .2),
            chain1_lab = "chain1", chain2_lab = "chain2",
            main = "Uniform",
            lwd_lines = grid::unit(.5, "mm"))
</code></pre>

<hr>
<h2 id='grid_zoom'>grid_zoom</h2><span id='topic+grid_zoom'></span>

<h3>Description</h3>

<p>This function takes a grob object (e.g. created with
package grid) and adds a zoom window. </p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_zoom(inputGrob = pointsGrob(runif(200),runif(200)),
          inputViewport = viewport(name='main'),
          x = 'topleft', y, just,
          ratio = c(.3,.4), zoom_xlim, zoom_ylim,
          rect = TRUE, rect_lwd = 1, rect_fill = 'gray92',
          draw =TRUE, zoom_fill = 'white',
          zoom_frame_gp = gpar(lwd = 1),
          zoom_gp = NULL, zoom_xaxis = xaxisGrob(main = FALSE),
          zoom_yaxis = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_zoom_+3A_inputgrob">inputGrob</code></td>
<td>
<p>A grob object, e.g created with package grid.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_inputviewport">inputViewport</code></td>
<td>
<p>Viewport related to <code>inputGrob</code>.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_x">x</code></td>
<td>
<p>Specifies the <code>x</code> coordinate of the zoom
window. Alternatively it can be set to 'topleft', 'topright',
'bootmleft' or 'bootmright'</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_y">y</code></td>
<td>
<p>Specifies the <code>y</code> coordinate of the zoom
window. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_just">just</code></td>
<td>
<p>Specifies the justification of the zoom window. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_ratio">ratio</code></td>
<td>
<p>Specifies size of the zoom window relative to the main window. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_xlim">zoom_xlim</code></td>
<td>
<p>Specifies xlim value of the zoom window. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_ylim">zoom_ylim</code></td>
<td>
<p>Specifies ylim value of the zoom window. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_rect">rect</code></td>
<td>
<p>Logical, if TRUE a rectangle of the zoom region is draw in the main window. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_rect_lwd">rect_lwd</code></td>
<td>
<p>lwd of the rectangle. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_rect_fill">rect_fill</code></td>
<td>
<p>fill of the rectangle. </p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_draw">draw</code></td>
<td>
<p>logical, if TRUE the returned grob object is also drawn.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_fill">zoom_fill</code></td>
<td>
<p>fill color of the zoom window.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_frame_gp">zoom_frame_gp</code></td>
<td>
<p>gpar() of the frame of the zoom window.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_gp">zoom_gp</code></td>
<td>
<p>gpar() of the inputGrob in the zoom viewport.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_xaxis">zoom_xaxis</code></td>
<td>
<p>xaxisGrob() to draw for the zoom window.</p>
</td></tr>
<tr><td><code id="grid_zoom_+3A_zoom_yaxis">zoom_yaxis</code></td>
<td>
<p>yaxisGrob() to draw for the zoom window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A zoom plot does only make sense if all objects of the <code>inputGrob</code>
are specified in <code>native</code> units. Additional caution me be require
for certain grobs: e.g. a zoom of a circleGrob() is problematic if the x
and y axis are stretched by a different amount.
</p>


<h3>Value</h3>

<p>A grob object.</p>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;</p>


<h3>See Also</h3>

<p>grid_trace2</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(grid)
## -- Example 1 --
set.seed(133)
grid_zoom(inputGrob = pointsGrob(runif(200), runif(200)),
          inputViewport = viewport(name = 'main'),
          zoom_xlim = c(.2, .3), zoom_ylim = c(.2, .3))


## -- Example 2 --
## initial plot
grid.newpage()
vp &lt;- viewport(width=.8, height=.8, clip='on')
gt &lt;- gTree(children=gList(polylineGrob(x=c((0:4)/10, rep(.5, 5), (10:6)/10, rep(.5, 5)),
              y=c(rep(.5, 5), (10:6/10), rep(.5, 5), (0:4)/10),
              id=rep(1:5, 4), default.units='native',
              gp=gpar(col=1:5, lwd=3)),
              pointsGrob(runif(1000), runif(1000),pch='.', gp=gpar(cex=3)),
              rectGrob(gp=gpar(lwd=3))))
pushViewport(vp)
grid.draw(gt)

## plot with zoom window
grid.newpage()
grid_zoom(inputGrob = gt,
          inputViewport = vp,
          x='topright', zoom_xlim=c(.6,.73), zoom_ylim=c(.3,.43),ratio=.4,
          zoom_xaxis = NULL, zoom_gp = gpar(cex=3))
</code></pre>

<hr>
<h2 id='head'>
Return the First or Last Part of an Object
</h2><span id='topic+head.spam'></span><span id='topic+head+2Cspam-method'></span><span id='topic+head+2Cspam.chol.NgPeyton-method'></span><span id='topic+tail.spam'></span><span id='topic+tail+2Cspam-method'></span><span id='topic+tail+2Cspam.chol.NgPeyton-method'></span>

<h3>Description</h3>

<p>Returns the upper left or lower right part of a
<code><a href="#topic+spam-class">spam</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spam'
head(x, n = 6L, m = n, ...)
## S4 method for signature 'spam'
tail(x, n = 6L, m = n, addrownums = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+spam-class">spam</a></code> object</p>
</td></tr>
<tr><td><code id="head_+3A_n">n</code></td>
<td>
<p>a single integer. If positive, size for the resulting
object: number of elements for a vector (including lists), rows for
a matrix or data frame or lines for a function. If negative, all but
the <code>n</code> last/first number of elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="head_+3A_m">m</code></td>
<td>
<p>similar to <code>n</code> but for the number of columns.</p>
</td></tr>
<tr><td><code id="head_+3A_addrownums">addrownums</code></td>
<td>
<p>create row and column namves them from the selected
elements.</p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For matrices, 2-dim tables and data frames, <code>head()</code> (<code>tail()</code>) returns
the first (last) <code>n</code> rows and <code>m</code> columns when <code>n &gt; 0</code> or all but the
last (first) <code>n</code> rows when <code>n &lt; 0</code> (with similar behavior
for <code>m</code>).
</p>
<p><code>tail()</code> will add row and column names of
the form <code>"[n,]"</code> and <code>"[,n]"</code> to the result, so that it looks similar to the
last lines and columns of <code>x</code> when printed.  Setting <code>addrownums =
    FALSE</code> suppresses this behaviour.
</p>
<p>A method for <code><a href="#topic+spam.chol.NgPeyton-class">spam.chol.NgPeyton</a></code> objects is
exported as well.
</p>


<h3>Value</h3>

<p>An regular matrix.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head( precmat.RW2( 10))
tail( precmat.season(n=10, season=3), n=4, m=10)
</code></pre>

<hr>
<h2 id='image'>Display a Sparse Matrix as Color Image</h2><span id='topic+image'></span><span id='topic+image.spam'></span><span id='topic+image.spam.chol'></span><span id='topic+image+2Cspam-method'></span>

<h3>Description</h3>

<p>The function creates a grid of colored rectangles with
colors corresponding to the values of the <code>spam</code> matrix. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spam'
image(x, cex = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_+3A_x">x</code></td>
<td>
<p>matrix of class <code>spam</code> or <code>spam.chol.NgPeyton</code>.</p>
</td></tr>
<tr><td><code id="image_+3A_cex">cex</code></td>
<td>
<p>for very large matrices, the dot size may need to be scaled.</p>
</td></tr>
<tr><td><code id="image_+3A_...">...</code></td>
<td>
<p>any other arguments passed
to <code>image.default</code> and <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getOption("spam.imagesize")</code> determines  if the sparse matrix is
coerced into a matrix and the plotted similarly to <code>image.default</code> or if
the matrix is simply represented as a scatterplot with
<code>pch="."</code>. The points are scaled according to
<code>cex*getOption("spam.cex")/(nrow+ncol)</code>.
For some devices or for non-square matrices,
<code>cex</code> needs probably some adjustment.<br />
The a zero matrix in <code>spam</code> format has as (1,1) entry the value
zero and only missing entries are interpreted as <code>NA</code> in the
scatter plot.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code> and  <code><a href="#topic+spam.options">spam.options</a></code>.<br />
The code is based on  <code><a href="graphics.html#topic+image">image</a></code> of <code>graphics</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)

smat &lt;- spam_random(8)

par(mfcol=c(1,2),pty='s')
options(spam.imagesize=1000)
image(smat) # or use better color schemes
options(spam.imagesize=10)
image(smat, cex=.25)

smat &lt;- spam_random(2^14, distribution=rnorm, density=1e-5, verbose=TRUE)
par(mfcol=c(1,1), mai=c(.4,.4,.1,.1), pty='s')
image(smat)

</code></pre>

<hr>
<h2 id='import'>Read External Matrix Formats</h2><span id='topic+import'></span><span id='topic+read.MM'></span><span id='topic+read.HB'></span>

<h3>Description</h3>

<p>Read matrices stored in the Harwell-Boeing or MatrixMarket formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.HB(file)
read.MM(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_+3A_file">file</code></td>
<td>
<p>the name of the file to read, as a character scalar.  
</p>
<p>Alternatively, <code>read.HB</code> and <code>read.MM</code> accept connection
objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of files storing matrices in the
Harwell-Boeing format usually end in <code>".rua"</code> or <code>".rsa"</code>.
Those storing matrices in the MatrixMarket format usually end in
<code>".mtx"</code>.
</p>
<p>Currently, only  real assembled Harwell-Boeing can be read with
<code>read.HB</code>. Reading MatrixMarket formats is more flexible.
However, as entries of <code>spam</code> matrices are of mode <code>double</code>,
integers matrices are coerced to doubles, patterns lead to matrices
containing ones and complex are coerced to the real part thereof. In
these aforementioned cases, a warning is issued.<br />
</p>
<p>MatrixMarket also defines an array format, in which case a (possibly)
dense <code>spam</code> object is return (retaining only elements which are
larger than <code>options('spam.eps')</code>. A warning is issued. </p>


<h3>Value</h3>

<p>A sparse matrix of class  <code>spam</code>.</p>


<h3>Note</h3>

<p>The functions are based on <code>readHB</code> and <code>readMM</code> from
the library <code>Matrix</code> to build the connection and read the raw
data.
At present, <code>read.MM</code> is more flexible than  <code>readMM</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer based on <code>Matrix</code> functions by
Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a> and Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p><a href="https://math.nist.gov/MatrixMarket/">https://math.nist.gov/MatrixMarket/</a>
</p>
<p><a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
image(read.MM(gzcon(url(
  "ftp://math.nist.gov/pub/MatrixMarket2/Harwell-Boeing/bcspwr/bcspwr01.mtx.gz"))))

## End(Not run)

## Not run: 
## Datasets supplied within Matrix
str(read.MM(system.file("external/pores_1.mtx",package = "Matrix")))
str(read.HB(system.file("external/utm300.rua", package = "Matrix")))
str(read.MM(system.file("external/lund_a.mtx", package = "Matrix")))
str(read.HB(system.file("external/lund_a.rsa", package = "Matrix")))

## End(Not run)
</code></pre>

<hr>
<h2 id='isSymmetric'>Test if a Sparse Matrix is Symmetric</h2><span id='topic+isSymmetric.spam'></span><span id='topic+isSymmetric+2Cspam-method'></span>

<h3>Description</h3>

<p>Efficient function to test if 'object' is symmetric or not.</p>


<h3>Usage</h3>

<pre><code class='language-R'># isSymmetric.spam(object, ...)
## S3 method for class 'spam'
isSymmetric(object, tol = 100 * .Machine$double.eps, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSymmetric_+3A_object">object</code></td>
<td>
<p>a <code>spam</code> matrix.</p>
</td></tr>
<tr><td><code id="isSymmetric_+3A_tol">tol</code></td>
<td>
<p>numeric scalar &gt;= 0.  Smaller differences are not considered,
see <code>all.equal.spam</code>.</p>
</td></tr>
<tr><td><code id="isSymmetric_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>all.equal.spam</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>symmetry is assessed by comparing the sparsity structure of
<code>object</code> and <code>t(object)</code> via the function
<code>all.equal.spam</code>. If a difference is detected, the matrix is
cleaned with <code>cleanup</code> and compared again.</p>


<h3>Value</h3>

<p>logical indicating if <code>object</code> is symmetric or not.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+all.equal.spam">all.equal.spam</a></code>, <code><a href="#topic+cleanup">cleanup</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- diag.spam(2)
isSymmetric(obj)

obj[1,2] &lt;- .Machine$double.eps
isSymmetric(obj)
all.equal(obj, t(obj))
</code></pre>

<hr>
<h2 id='kronecker'>Kronecker Products on Sparse Matrices</h2><span id='topic+kronecker.default'></span><span id='topic+kronecker.spam'></span><span id='topic+kronecker+2Cspam+2CANY-method'></span><span id='topic+kronecker+2CANY+2Cspam-method'></span><span id='topic+kronecker+2Cspam+2Cspam-method'></span>

<h3>Description</h3>

<p>Computes the generalised kronecker product of two arrays, <code>X</code> and
<code>Y</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronecker.spam(X, Y, FUN = "*", make.dimnames = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronecker_+3A_x">X</code></td>
<td>
<p>sparse matrix of class <code>spam</code>, a vector or a matrix.</p>
</td></tr>
<tr><td><code id="kronecker_+3A_y">Y</code></td>
<td>
<p>sparse matrix of class <code>spam</code>, a vector or a matrix.</p>
</td></tr>
<tr><td><code id="kronecker_+3A_fun">FUN</code></td>
<td>
<p>a function; it may be a quoted string. See details</p>
</td></tr>
<tr><td><code id="kronecker_+3A_make.dimnames">make.dimnames</code></td>
<td>
<p>Provide dimnames that are the product of the dimnames of
<code>X</code> and <code>Y</code>. </p>
</td></tr>
<tr><td><code id="kronecker_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sparsity structure is determined by the ordinary
<code>%x%</code>. Hence, the result of <code>kronecker(X, Y, FUN = "+")</code> is
different depending on the input.
</p>


<h3>Value</h3>

<p>An array <code>A</code> with dimensions
<code>dim(X) * dim(Y)</code>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>Examples</h3>

<pre><code class='language-R'># Starting with non-spam objects, we get a spam matrix
kronecker.spam( diag(2), array(1:4, c(2, 2)))

kronecker( diag.spam(2), array(1:4, c(2, 2)))

# Notice the preservation of sparsity structure:
kronecker( diag.spam(2), array(1:4, c(2, 2)), FUN="+")


</code></pre>

<hr>
<h2 id='large_matrix'>Large 64-bit matrices require the R package <span class="pkg">spam64</span></h2><span id='topic+large_matrix'></span><span id='topic+large+20matrix'></span><span id='topic+large_matries'></span><span id='topic+large+20matries'></span><span id='topic+64bit'></span><span id='topic+64bits'></span><span id='topic+long+20vector'></span><span id='topic+long+20vectors'></span><span id='topic+spam64'></span>

<h3>Description</h3>

<p>The R package <span class="pkg">spam</span> can handle sparse matrices with up
to 2^31-1 non-zero elements. For matrices with more non-zero elements
it is necessary to load the <span class="pkg">spam64</span> package in addition.
</p>


<h3>Details</h3>

<p>With the help of the R package <span class="pkg">dotCall64</span> spam interfaces
either the compiled code with 32-bit integers provided in
<span class="pkg">spam</span> or the compiled code with 64-bit integers provided in
<span class="pkg">spam64</span>.
<br />
To mimick 64-bit behavior, set <code>options(spam.force64 = TRUE)</code>. The subsequent matrix indices are then stored in double format.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, Florian Gerber, Kaspar Moesinger, Daniel Gerber</p>


<h3>References</h3>

<p>F. Gerber, K. Moesinger, R. Furrer (2017),
Extending R packages to support 64-bit compiled code: An illustration with spam64 and GIMMS NDVI3g data,
Computer &amp; Geoscience 104, 109-119, https://doi.org/10.1016/j.cageo.2016.11.015.
</p>


<h3>See Also</h3>

<p><code><a href="spam64.html#topic+spam64-package">spam64-package</a></code>,  <code><a href="dotCall64.html#topic+dotCall64">dotCall64</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## the following matrices are very large, and hence,
## require much memory and cpu time.
library("spam64")
s1 &lt;- spam(1, ncol=2^30)        # 32-bit matrix
s1

s2 &lt;- cbind(s1, s1)             # 64-bit matrix
s2

s3 &lt;- spam(1, ncol=2^31)        # 64-bit matrix
s3

## End(Not run)
</code></pre>

<hr>
<h2 id='lower.tri'>Lower and Upper Triangular Part of a Sparse Matrix</h2><span id='topic+lower.tri'></span><span id='topic+upper.tri'></span><span id='topic+lower.tri.spam'></span><span id='topic+upper.tri.spam'></span>

<h3>Description</h3>

<p>Returns the lower or upper triangular structure or
entries of  a sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower.tri(x, diag = FALSE)
upper.tri(x, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower.tri_+3A_x">x</code></td>
<td>
<p>a sparse matrix of class <code>spam</code></p>
</td></tr>
<tr><td><code id="lower.tri_+3A_diag">diag</code></td>
<td>
<p>logical. Should the diagonal be included?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often not only the structure of the matrix is required but the
entries as well. For compatibility, the default is only a structure
consisting of ones (representing <code>TRUE</code>s). Setting the flag
<code>getOption( "spam.trivalues")</code> to <code>TRUE</code>,
the function returns the actual
values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spam.options">spam.options</a></code> and <code><a href="#topic+diag">diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>smat &lt;- spam( c( 1,2,0,3,0,0,0,4,5),3)
upper.tri( smat)
upper.tri( smat, diag=TRUE)

options(spam.trivalues=TRUE)
upper.tri( smat)

</code></pre>

<hr>
<h2 id='makeprec'>Create Precision Matrices</h2><span id='topic+precmat.GMRFreglat'></span>

<h3>Description</h3>

<p>Creates precision matrices for gridded GMRF.</p>


<h3>Usage</h3>

<pre><code class='language-R'>precmat.GMRFreglat(n,m, par, model = "m1p1",  eps = getOption("spam.eps"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeprec_+3A_n">n</code></td>
<td>
<p>first dimension of the grid.</p>
</td></tr>
<tr><td><code id="makeprec_+3A_m">m</code></td>
<td>
<p>second dimension of the grid.</p>
</td></tr>
<tr><td><code id="makeprec_+3A_par">par</code></td>
<td>
<p>parameters used to construct the matrix.</p>
</td></tr>
<tr><td><code id="makeprec_+3A_model">model</code></td>
<td>
<p>see details and examples.</p>
</td></tr>
<tr><td><code id="makeprec_+3A_eps">eps</code></td>
<td>
<p>A tolerance parameter:  elements of <code>x</code> such that <code>abs(x)
    &lt;= eps</code> set to zero. Defaults to <code>eps = getOption("spam.eps")</code></p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function should be illustrative on how to create precision
matrices for gridded GMRF. Hence, no testing (positive definiteness is
done).
</p>
<p>The model specification <code>"m"</code> determines the complexity and
<code>"p"</code> the number of parameters. 
</p>
<p>Please see the examples on the meaning of the different models. 
</p>


<h3>Value</h3>

<p>A <code>spam</code> matrix of dimension <code>prod(dims)</code>x<code>prod(dims)</code>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+precmat">precmat</a></code>, <code><a href="#topic+toeplitz.spam">toeplitz.spam</a></code>, <code><a href="#topic+kronecker.spam">kronecker.spam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>as.matrix(precmat.GMRFreglat(4, 3, c(.4),         'm1p1'))
as.matrix(precmat.GMRFreglat(4, 3, c(.4,.3),      'm1p2'))
as.matrix(precmat.GMRFreglat(4, 3, c(.4,.3,.2),   'm2p3'))
as.matrix(precmat.GMRFreglat(4, 3, c(.4,.3,.2,.1),'m2p4'))

# up to the diagonal, the following are equivalent:
cleanup( precmat.IGMRFreglat(3,4) -
             precmat.GMRFreglat(3,4,1, 'm1p1'))

</code></pre>

<hr>
<h2 id='map.landkreis'>Administrative districts of Germany</h2><span id='topic+map.landkreis'></span>

<h3>Description</h3>

<p>Displaying data
over the administrative districts of Germany</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.landkreis(data, col=NULL, zlim=range(data), add=FALSE,
              legendpos=c( 0.88,0.9,0.05,0.4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.landkreis_+3A_data">data</code></td>
<td>
<p>vector of length 544</p>
</td></tr>
<tr><td><code id="map.landkreis_+3A_col">col</code></td>
<td>
<p>color scheme to be used. By default uses <code>tim.colors</code> if
available or a generic gray scale.</p>
</td></tr>
<tr><td><code id="map.landkreis_+3A_zlim">zlim</code></td>
<td>
<p>the minimum and maximum values for which colors should be
plotted, defaulting to the range of <code>data</code>.</p>
</td></tr>
<tr><td><code id="map.landkreis_+3A_add">add</code></td>
<td>
<p>logical, if true adds to current plot.</p>
</td></tr>
<tr><td><code id="map.landkreis_+3A_legendpos">legendpos</code></td>
<td>
<p>if package <span class="pkg">fields</span> is loaded, puts a legend at that position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+germany.plot">germany.plot</a></code> super-seeds
<code>map.landkreis</code> (it is several factors faster). <br />
</p>
<p>The perfect position of the legend is an art per se and depends on
various <code>par</code> parameters. See also the source code of the function
<code>image.plot</code> of <span class="pkg">fields</span>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>The code of <code>map.landkreis</code> is very similar to
<code>germany.map</code> from the package <span class="pkg">INLA</span>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+germany.plot">germany.plot</a></code> super-seeding <code>map.landkreis</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data( Oral)
par( mfcol=c(1,2))
germany.plot( log( Oral$Y), legend=TRUE)
map.landkreis( log( Oral$Y))

## End(Not run)
</code></pre>

<hr>
<h2 id='Math'>Mathematical Functions</h2><span id='topic+Math'></span><span id='topic+Math.spam'></span><span id='topic+Math+2Cspam-method'></span><span id='topic+ceiling.spam'></span><span id='topic+ceiling+2Cspam-method'></span><span id='topic+floor.spam'></span><span id='topic+floor+2Cspam-method'></span><span id='topic+trunc.spam'></span><span id='topic+trunc+2Cspam-method'></span><span id='topic+exp.spam'></span><span id='topic+exp+2Cspam-method'></span><span id='topic+log.spam'></span><span id='topic+log+2Cspam-method'></span><span id='topic+log2.spam'></span><span id='topic+log2+2Cspam-method'></span><span id='topic+log10.spam'></span><span id='topic+log10+2Cspam-method'></span><span id='topic+sqrt.spam'></span><span id='topic+sqrt+2Cspam-method'></span><span id='topic+gamma.spam'></span><span id='topic+gamma+2Cspam-method'></span><span id='topic+digamma.spam'></span><span id='topic+digamma+2Cspam-method'></span><span id='topic+trigamma.spam'></span><span id='topic+trigamma+2Cspam-method'></span><span id='topic+lgamma.spam'></span><span id='topic+lgamma+2Cspam-method'></span><span id='topic+abs.spam'></span><span id='topic+abs+2Cspam-method'></span><span id='topic+cumprod.spam'></span><span id='topic+cumprod+2Cspam-method'></span><span id='topic+cumsum.spam'></span><span id='topic+cumsum+2Cspam-method'></span><span id='topic+cummax.spam'></span><span id='topic+cummax+2Cspam-method'></span><span id='topic+cummin.spam'></span><span id='topic+cummin+2Cspam-method'></span><span id='topic+cos.spam'></span><span id='topic+cos+2Cspam-method'></span><span id='topic+cosh.spam'></span><span id='topic+cosh+2Cspam-method'></span><span id='topic+acos.spam'></span><span id='topic+acos+2Cspam-method'></span><span id='topic+acosh.spam'></span><span id='topic+acosh+2Cspam-method'></span><span id='topic+sin.spam'></span><span id='topic+sin+2Cspam-method'></span><span id='topic+asin.spam'></span><span id='topic+asin+2Cspam-method'></span><span id='topic+asinh.spam'></span><span id='topic+asinh+2Cspam-method'></span><span id='topic+tan.spam'></span><span id='topic+tan+2Cspam-method'></span><span id='topic+atan.spam'></span><span id='topic+atan+2Cspam-method'></span><span id='topic+atanh.spam'></span><span id='topic+atanh+2Cspam-method'></span>

<h3>Description</h3>

<p>Applies the <code>Math</code> group functions to <code>spam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'># ceiling(x)
# floor(x)
# exp(x, base = exp(1))
# log(x, base = exp(1))
# sqrt(x)

# abs(x)
# cumprod(x)
# cumsum(x)

# cos(x)
# sin(x)
# tan(x)

# acosh(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math_+3A_x">x</code></td>
<td>
<p>spam object.</p>
</td></tr>
<tr><td><code id="Math_+3A_base">base</code></td>
<td>
<p>positive number. The base with respect to which logarithms
are computed. Defaults to <code>e=exp(1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to note that the zero entries do not enter the
evaluation when <code>structurebased=FALSE</code>. The operations are performed on the stored non-zero
elements. This may lead to differences if compared with the same
operation on a full matrix.
</p>


<h3>Value</h3>

<p>If the option <code>spam.structurebased=TRUE</code>, all functions operate on the vector <code>x@entries</code> and return the
result thereof.<br />
Conversely, if <code>structurebased=FALSE</code>, the result is identical to
one with <code>as.matrix(x)</code> input and an <code>as.spam</code> purger.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+Summary.spam">Summary.spam</a></code>, <code><a href="#topic+Ops.spam">Ops.spam</a></code> and <code><a href="#topic+Math2.spam">Math2.spam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getGroupMembers("Math")

mat &lt;- matrix(c( 1,2,0,3,0,0,0,4,5),3)
smat &lt;- as.spam( mat)
cos( mat)
cos( smat)

options(spam.structurebased=FALSE)
cos( smat)

sqrt( smat)
</code></pre>

<hr>
<h2 id='Math2'>Rounding of Numbers</h2><span id='topic+Math2'></span><span id='topic+Math2.spam'></span><span id='topic+Math2+2Cspam-method'></span><span id='topic+Math2+2Cspam+2Cnumeric-method'></span><span id='topic+round+2Cspam-method'></span><span id='topic+signif+2Cspam-method'></span><span id='topic+round.spam'></span><span id='topic+signif.spam'></span>

<h3>Description</h3>

<p>Applies the <code>Math2</code> group functions to '<code>spam</code>' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spam'
round(x, digits = 0)
## S4 method for signature 'spam'
signif(x, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math2_+3A_x">x</code></td>
<td>
<p>spam object.</p>
</td></tr>
<tr><td><code id="Math2_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions operate on the vector <code>x@entries</code> and return the
result thereof.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.spam">Ops.spam</a></code> and <code><a href="#topic+Math.spam">Math.spam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getGroupMembers("Math2")

smat &lt;- diag.spam( rnorm(15))
round(smat, 3)
</code></pre>

<hr>
<h2 id='mle'>Maximum likelihood estimates</h2><span id='topic+neg2loglikelihood.spam'></span><span id='topic+neg2loglikelihood.nomean'></span><span id='topic+mle.spam'></span><span id='topic+mle.nomean.spam'></span><span id='topic+neg2loglikelihood'></span><span id='topic+mle'></span><span id='topic+mle.nomean'></span>

<h3>Description</h3>

<p>Maximum likelihood estimates of a simple spatial model</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg2loglikelihood.spam(y, X, distmat, Covariance,
                 beta, theta, Rstruct = NULL, cov.args = NULL, ...)

neg2loglikelihood(y, X, distmat, Covariance,
                 beta, theta, cov.args = NULL, ...)

neg2loglikelihood.nomean(y, distmat, Covariance,
                 theta, cov.args = NULL, ...)

mle.spam(y, X, distmat, Covariance,
     beta0, theta0, thetalower, thetaupper, optim.control=NULL,
     Rstruct = NULL, hessian = FALSE, cov.args = NULL, ...)

mle(y, X, distmat, Covariance,
     beta0, theta0, thetalower, thetaupper, optim.control=NULL,
     hessian = FALSE, cov.args = NULL, ...)

mle.nomean.spam(y, distmat, Covariance,
     theta0, thetalower, thetaupper, optim.control=NULL,
     Rstruct = NULL, hessian = FALSE, cov.args = NULL, ...) 

mle.nomean(y, distmat, Covariance,
     theta0, thetalower, thetaupper, optim.control=NULL,
     hessian = FALSE, cov.args = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_+3A_y">y</code></td>
<td>
<p>data vector of length n.</p>
</td></tr>
<tr><td><code id="mle_+3A_x">X</code></td>
<td>
<p>the design matrix of dimension n x p.</p>
</td></tr>
<tr><td><code id="mle_+3A_distmat">distmat</code></td>
<td>
<p>a distance matrix. Usually the result of a call
to <code>nearest.dist</code>.</p>
</td></tr>
<tr><td><code id="mle_+3A_covariance">Covariance</code></td>
<td>
<p>function defining the covariance. See example.</p>
</td></tr>
<tr><td><code id="mle_+3A_beta">beta</code></td>
<td>
<p>parameters of the trend (fixed effects).</p>
</td></tr>
<tr><td><code id="mle_+3A_theta">theta</code></td>
<td>
<p>parameters of the covariance structure.</p>
</td></tr>
<tr><td><code id="mle_+3A_rstruct">Rstruct</code></td>
<td>
<p>the Cholesky structure of the covariance matrix.</p>
</td></tr>
<tr><td><code id="mle_+3A_beta0">beta0</code>, <code id="mle_+3A_theta0">theta0</code></td>
<td>
<p>inital values.</p>
</td></tr>
<tr><td><code id="mle_+3A_thetalower">thetalower</code>, <code id="mle_+3A_thetaupper">thetaupper</code></td>
<td>
<p>lower and upper bounds of the parameter
<code>theta</code>.</p>
</td></tr>
<tr><td><code id="mle_+3A_optim.control">optim.control</code></td>
<td>
<p>arguments passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="mle_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix
be returned?</p>
</td></tr>
<tr><td><code id="mle_+3A_cov.args">cov.args</code></td>
<td>
<p>additional arguments passed to <code>Covariance</code>.</p>
</td></tr>
<tr><td><code id="mle_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>chol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We provide functions to calculate the
negative-2-log-likelihood and maximum likelihood estimates  for the model
</p>
<p>y ~ N_n( X beta, Sigma(h;theta) )
</p>
<p>in the case of a sparse or ordinary covariance matrices.
</p>
<p>In the case of the <code>*.spam</code> versions, the covariance function has
to return a <code>spam</code> object. In the other case, the methods are
correctly overloaded and work either way, slightly slower than the
<code>*.spam</code> counterparts though.
</p>
<p>When working on the sphere, the distance matrix has to be transformed by
</p>
<p>h -&gt;   R / 2 sin(h/2)
</p>
<p>where R is the radius of the sphere.
</p>
<p>The covariance function requires that the first argument is the distance
matrix and the second the parameters. One can image cases in which the
covariance function does not take the entire distance matrix but only
some partial information thereof. (An example is the use of a kronecker
type covariance structure.)  In case of a sparse covariance construction
where the argument <code>Rstruct</code> is not given, the first parameter
element needs to be the range parameter. (This results from the fact,
that a sparse structure is constructed that is independent of the
parameter values to exploit the fast Choleski decomposition.)
</p>
<p>In the zero-mean case, the <code>neg2loglikelihood</code> is calculated by setting
the parameters <code>X</code> or <code>beta</code> to zero.
</p>


<h3>Value</h3>

<p>The negative-2-loglikelihood or the output from the function
<code>optim</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer </p>


<h3>See Also</h3>

<p><code><a href="#topic+covmat">covmat</a></code>, <code><a href="#topic+rmvnorm.spam">rmvnorm.spam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># True parameter values:
truebeta &lt;- c(1,2,.2)    # beta = (intercept, linear in x, linear in y)
truetheta &lt;- c(.5,2,.02) # theta = (range, sill, nugget)



# We now define a grid, distance matrix, and a sample:
x &lt;- seq(0,1,l=5)
locs &lt;- expand.grid( x, x)
X &lt;- as.matrix( cbind(1,locs))  # design matrix

distmat &lt;- nearest.dist( locs, upper=NULL) # distance matrix
Sigma &lt;- cov.sph( distmat, truetheta)    # true covariance matrix


set.seed(15)
y &lt;- c(rmvnorm.spam(1,X %*% truebeta,Sigma)) # construct sample

# Here is the negative 2 log likelihood:
neg2loglikelihood.spam( y, X, distmat, cov.sph,
                       truebeta, truetheta)

# We pass now to the mle:
res &lt;- mle.spam(y, X, distmat, cov.sph,
         truebeta, truetheta,thetalower=c(0,0,0),thetaupper=c(1,Inf,Inf))

# Similar parameter estimates here, of course:
mle.nomean.spam(y-X%*%res$par[1:3], distmat, cov.sph,
         truetheta, thetalower=c(0,0,0), thetaupper=c(1,Inf,Inf))
</code></pre>

<hr>
<h2 id='nearestdist'>Distance Matrix Computation</h2><span id='topic+dist.spam'></span><span id='topic+nearest.dist'></span><span id='topic+distance'></span>

<h3>Description</h3>

<p>This function computes and returns specific elements of distance
matrix computed by
using the specified distance measure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest.dist( x, y=NULL, method = "euclidean",
             delta = 1, upper = if (is.null(y)) FALSE else NULL,
             p = 2, miles = TRUE, R = NULL, fortran = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestdist_+3A_x">x</code></td>
<td>
<p>Matrix of first set of locations where each row gives the
coordinates of a particular point. See also &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_y">y</code></td>
<td>
<p>Matrix of second set of locations where each row gives the
coordinates of a particular point. If this is missing <code>x</code> is
used. See also &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_method">method</code></td>
<td>
<p>the distance measure to be used. This must be one of
<code>"euclidean"</code>, <code>"maximum"</code>, <code>"minkowski"</code> or
<code>"greatcircle"</code>. Any unambiguous substring can be
given.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_delta">delta</code></td>
<td>
<p>only distances smaller than <code>delta</code> are recorded,
see Details.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_upper">upper</code></td>
<td>
<p>Should the entire matrix (<code>NULL</code>) or only the upper-triagonal (<code>TRUE</code>)
or lower-triagonal (<code>FALSE</code>) values be calculated.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_miles">miles</code></td>
<td>
<p>For great circle distance: If true distances are in statute miles if false distances in
kilometers.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_r">R</code></td>
<td>
<p>For great circle distance: Radius to use for sphere to find spherical distances. If <code>NULL</code>
the radius is either in miles or kilometers depending on the
values of the miles argument. If <code>R=1</code> then distances are of
course in radians.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_fortran">fortran</code></td>
<td>
<p>Should the C++ (<code>FALSE</code>) or the Fortran code (<code>TRUE</code>) be used. If 64-bit matrices are needed, the argument is set to (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For great circle distance, the matrices <code>x</code> and <code>y</code>
contain the degrees longitudes in the first and the degrees latitudes
in the second column. <code>delta</code> is in
degrees. Hence to restrict to distances smaller than <code>delta.km</code>,
one has to specify <code>delta=delta.km*360/(6378.388*2*pi)</code>.
</p>
<p>The distances are calculated based on spherical law of cosines.
Care is needed for &lsquo;zero&rsquo; distances due to the final acosin:
<code>acos(1-1e-16)</code>, especially with an actual radius.
</p>
<p>Default value of Earth's radius is 3963.34miles (6378.388km).<br />
</p>
<p>There are many other packages providing distance functions. Especially
for great circle distances there are considerable differences between
the implementations. For high precision results, <code>sp::spDists</code> is
a good candidate and distances of large amount of locations can be
processed in parallel with the <code>parallelDist</code> package.<br />
</p>
<p>The formerly depreciated arguments <code>eps</code> and <code>diag</code> are now
eliminated.
</p>
<p><code>x</code> and <code>y</code> can be any object with an existing
<code>as.matrix</code> method.<br />
</p>
<p>The Fortran code is based on a idea of Doug Nychka.
</p>


<h3>Value</h3>

<p>A <code>spam</code> object containing the distances spanned between
zero and <code>delta</code>. The sparse matrix may contain many zeros
(e.g., collocated data). However, to calculate covariances, these zeros
are essential.</p>


<h3>Author(s)</h3>

<p>Annina Cincera (C++ code), Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+spam_rdist">spam_rdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that upper=T and using t(X)+X is quicker than upper=NULL;
#     upper=T marginally slower than upper=F.

# To compare nearest.dist with dist, use as.dist(...)
nx &lt;- 4
x &lt;- expand.grid(as.double(1:nx),as.double(1:nx))
sum( ( as.dist(nearest.dist( x, delta=nx*2))-
          dist(x)                            )^2)

# Create nearest neighbor structures:
par(mfcol=c(1,2))
x &lt;- expand.grid(1:nx,1:(2*nx))
display( nearest.dist( x, delta=1))
x &lt;- expand.grid(1:(2*nx),1:nx)
display( nearest.dist( x, delta=1))

</code></pre>

<hr>
<h2 id='options'>Options Settings</h2><span id='topic+spam.options'></span><span id='topic+options.spam'></span><span id='topic+getOption.spam'></span>

<h3>Description</h3>

<p>Allow the user to set and examine a variety of <em>options</em>
which affect the way in which <span class="rlang"><b>R</b></span> computes and displays sparse
matrix results.
</p>


<h3>Details</h3>

<p>Invoking <code>options()</code> with no arguments returns a list with the
current values of the options. To access the value of a single option, one should
use <code>getOption("spam.eps")</code>, e.g., rather than
<code>options("spam.eps")</code> which is a <em>list</em> of length one.<br />
</p>
<p>Of course, printing is still subordinate to
<code>getOption("max.print")</code> or similar options.
</p>


<h3>Value</h3>

<p>For <code>getOption</code>, the current value set for option <code>x</code>, or
<code>NULL</code> if the option is unset.
</p>
<p>For <code>options()</code>, a list of all set options sorted by category.  For
<code>options(name)</code>, a list of length one containing the set value,
or <code>NULL</code> if it is unset.  For uses setting one or more options,
a list with the previous values of the options changed (returned
invisibly).
</p>


<h3>Options used for the package <code>spam</code></h3>

<p>A short description with the default values follows.
</p>

<dl>
<dt><code>spam.eps=.Machine$double.eps</code>:</dt><dd><p>values smaller than this are
considered as zero. This is only used when creating spam objects.</p>
</dd>
<dt><code>spam.drop=FALSE</code>:</dt><dd><p>default parameter for <code>drop</code> when subsetting</p>
</dd>
<dt><code>spam.printsize=100</code>:</dt><dd><p>the max number of elements of a matrix which we
display as regular matrix.</p>
</dd>
<dt><code>spam.imagesize=10000</code>:</dt><dd><p>the max number of elements of a matrix we display
as regular matrix with <code>image</code> or <code>display</code>. Larger matrices are represented
as dots only.</p>
</dd>
<dt><code>spam.cex=1200</code>:</dt><dd><p>default dot size for  <code>image</code> or <code>display</code>.</p>
</dd>
<dt><code>spam.structurebased=FALSE</code>:</dt><dd><p>should operations be carried out on
the nonzero entries (the structure) or including the zeros.</p>
</dd>
<dt><code>spam.inefficiencywarning=1e6</code>:</dt><dd><p>issue a warning when inefficient
operations are performed and the matrix exceeds the specified size.
Valid value is a postive integer or a logical. <code>TRUE</code> corresponds
to 1 (always), <code>FALSE</code> to <code>Inf</code>.</p>
</dd>
<dt><code>spam.trivalues=FALSE</code>:</dt><dd><p>a flag whether to return the structure
(<code>FALSE</code>) or the values themselves (<code>TRUE</code>) when returning the
upper and lower triangular part of a matrix.</p>
</dd>
<dt><code>spam.listmethod="PE"</code>:</dt><dd><p>algorithm for <code>spam.list</code>. Default
is suggestion by Paul Eilers (thanks). Any other specification uses a
bubble sort algorithm which is only slightly faster for very sparse matrices. </p>
</dd>
<dt><code>spam.dopivoting=TRUE</code>:</dt><dd><p>default parameter for &quot;<code>solve</code>&quot; routines. <code>FALSE</code>
would solve the system without using the permutation.</p>
</dd>
<dt><code>spam.NAOK=FALSE</code>:</dt><dd><p>logical determines if <code>NA</code>, <code>NaN</code> and <code>Inf</code> are
allowed to Fortan. Setting to <code>TRUE</code> allows to work with these but
full functionality has not been tested.</p>
</dd>
<dt><code>spam.safemodevalidity=TRUE</code>:</dt><dd><p>logical determines if sanity check
is peformed when constructing sparse matrices.
Default is safer but somewhat slower.</p>
</dd>
<dt><code>spam.cholsymmetrycheck=TRUE</code>:</dt><dd><p>for the Cholesky factorization,
verify if the matrix is symmetric.</p>
</dd>
<dt><code>spam.cholpivotcheck=TRUE</code>:</dt><dd><p>for the Cholesky factorization,
when passing a permutation, should a minimum set of checks be performed?</p>
</dd>
<dt><code>spam.cholupdatesingular="warning"</code>:</dt><dd><p>for a Cholesky update, what
happens if the matrix is singular: <code>"warning"</code> only and
returning the not updated factor, <code>"error"</code>  or  return simply <code>"NULL"</code>.</p>
</dd>
<dt><code>spam.cholincreasefactor=c(1.25,1.25)</code>:</dt><dd><p>If not enought memory
could be allocated, these are the steps to increase it.</p>
</dd>
<dt><code>spam.nnznearestdistnnz=c(400^2,400)</code>:</dt><dd><p>Memory allocation
parameters for <code>nearest.dist</code>.</p>
</dd>
<dt><code>spam.nearestdistincreasefactor=1.25</code>:</dt><dd><p>If not enought memory
could be allocated, this is the step to increase it. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Functions influenced by these options include: <code><a href="#topic+print.spam">print.spam</a></code>,
<code><a href="#topic+display.spam">display.spam</a></code>,  <code><a href="#topic+image.spam">image.spam</a></code>, <code><a href="#topic+upper.tri.spam">upper.tri.spam</a></code>,
<code><a href="#topic+chol.spam">chol.spam</a></code>, <code><a href="#topic+nearest.dist">nearest.dist</a></code>, etc.<br />
<code><a href="#topic+powerboost">powerboost</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smat &lt;- diag.spam( 1:8)
smat
options(spam.printsize=49)
smat

# List all spam options:
options()[grep("spam",names(options()))]

# Reset to default values:
options(spam.eps=.Machine$double.eps,
        spam.drop=FALSE,
        spam.printsize=100,
        spam.imagesize=10000,
        spam.cex=1200,
        spam.structurebased=FALSE,
        spam.inefficiencywarning=1e6,
        spam.trivalues=FALSE,
        spam.listmethod="PE",
        spam.NAOK=FALSE,
        spam.safemodevalidity=TRUE,
        spam.dopivoting=TRUE,
        spam.cholsymmetrycheck=TRUE,
        spam.cholpivotcheck=TRUE,
        spam.cholupdatesingular="warning",
        spam.cholincreasefactor=c(1.25,1.25),
        spam.nearestdistincreasefactor=1.25,
        spam.nearestdistnnz=c(400^2,400))

</code></pre>

<hr>
<h2 id='Oral'>Oral Cavity Cancer</h2><span id='topic+Oral'></span><span id='topic+Oral.spam'></span><span id='topic+oral.spam'></span>

<h3>Description</h3>

<p>Oral cavity cancer counts in 544 districts in Germany over 1986-1990.</p>


<h3>Format</h3>

<p><code>Oral</code> is a dataframe with 3 columns.
</p>

<dl>
<dt>Y</dt><dd><p>observed counts</p>
</dd>
<dt>E</dt><dd><p>expected counts</p>
</dd>
<dt>SMR</dt><dd><p>standardized mortality ratios</p>
</dd></dl>

<p><code>germany</code> is a
list of 544 elements, each describing an individual polygon of the district.
</p>


<h3>Details</h3>

<p>The expected counts depend on the number of people in the
region and their age distribution.<br />
The regions are ordered according the supplied polygon description and
adjacency graph.<br />
</p>
<p>There is a similar dataset <code>data(Germany)</code>  with larynx cancer cases from the package
<span class="pkg">INLA</span> as well, with an additional smoking covariate.
</p>


<h3>Source</h3>

<p>The data is available from the package <span class="pkg">INLA</span>
distributed from <a href="https://www.r-inla.org">https://www.r-inla.org</a>.
</p>


<h3>References</h3>

<p>Knorr-Held, L. and Rasser, G. (2000) Bayesian Detection of Clusters and Discontinuities in Disease Maps,
<em>Biometrics</em>,
56,
13&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+germany.plot">germany.plot</a></code>.</p>

<hr>
<h2 id='ordering'>Extract the permutation</h2><span id='topic+ordering'></span><span id='topic+ordering.spam'></span><span id='topic+ordering-methods'></span><span id='topic+ordering.spam.chol'></span><span id='topic+ordering.spam.chol.NgPeyton'></span><span id='topic+ordering+2Cspam-method'></span><span id='topic+ordering+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Extract the (inverse) permutation used by the Cholesky
decomposition</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordering( x, inv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordering_+3A_x">x</code></td>
<td>
<p>object of class <code>spam.chol.</code><em>method</em> returned by the function
<code>chol</code>.</p>
</td></tr>
<tr><td><code id="ordering_+3A_inv">inv</code></td>
<td>
<p>Return the permutation (default) or inverse thereof.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recall that calculating a Cholesky factor from a sparse matrix
consists of finding a permutation first, then calculating the factors
of the permuted matrix. The ordering is important when working with
the factors themselves.<br />
</p>
<p>The ordering from a full/regular matrix is <code>1:n</code>.<br />
</p>
<p>Note that there exists many different algorithms to find
orderings.  
<br />
</p>
<p>See the examples, they speak more than 10 lines.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+chol.spam">chol.spam</a></code>, <code><a href="#topic+solve.spam">solve.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a pd matrix S to work with (size n)
n &lt;- 100    # dimension
S &lt;- .25^abs(outer(1:n,1:n,"-"))
S &lt;- as.spam( S, eps=1e-4)
I &lt;- diag(n)  # Identity matrix

cholS &lt;- chol( S)
ord &lt;- ordering(cholS)
iord &lt;- ordering(cholS, inv=TRUE)

R &lt;- as.spam( cholS ) # R'R = P S P', with P=I[ord,],
  # a permutation matrix (rows permuted).
RtR &lt;- t(R) %*% R

# the following are equivalent:
as.spam( RtR -            S[ord,ord],    eps=1e-15)
as.spam( RtR[iord,iord] - S,             eps=1e-15)
as.spam( t(R[,iord]) %*% R[,iord] - S, eps=1e-15)
# we use 'eps' to avoid issues close to machine precision

# trivially:
as.spam( t(I[iord,]) - I[ord,])  # (P^-1)' = P  
as.spam( t(I[ord,]) - I[,ord])  # 
as.spam( I[iord,] - I[,ord])
as.spam( I[ord,]%*%S%*%I[,ord] - S[ord,ord] )
   # pre and post multiplication with P and P' is ordering
</code></pre>

<hr>
<h2 id='pad'>Padding a Sparse Matrix</h2><span id='topic+pad'></span><span id='topic+pad.spam'></span><span id='topic+pad+3C-'></span><span id='topic+pad+3C-.spam'></span><span id='topic+pad+3C-+2Cspam-method'></span><span id='topic+pad+3C-+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Resets the dimension of a <code>spam</code> matrix by truncation or zero padding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_x">x</code></td>
<td>
<p>a <code>spam</code> matrix</p>
</td></tr>
<tr><td><code id="pad_+3A_value">value</code></td>
<td>
<p>A numeric two-vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to notice the different behavior of the replacement
method for ordinary arrays and <code>spam</code> objects (see
&lsquo;Examples&rsquo;). Here, the elements are not simply rearranged but
an entirely new matrix is constructed. If the new column dimension is
smaller than the original, the matrix is also cleaned (with
<code>option("spam.eps")</code> as filter).
</p>


<h3>Value</h3>

<p>A (<code>spam</code>) matrix of dimension <code>value</code> where trunction or
padding has
been used.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+dim.spam">dim.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- diag(4)
dim(x)&lt;-c(2,8)
x

s &lt;- diag.spam(4)
pad(s) &lt;- c(7,3)  # any positive value can be used

s &lt;- diag.spam(4)
pad(s) &lt;- c(2,8)  # result is different than x
</code></pre>

<hr>
<h2 id='permutation'>Permute a Matrix</h2><span id='topic+permutation'></span><span id='topic+permutation.spam'></span><span id='topic+permutation+2Cspam-method'></span><span id='topic+permutation+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Row and/or column permutes a (sparse) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation.spam(A, P=NULL, Q=NULL, ind=FALSE, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutation_+3A_a">A</code></td>
<td>
<p>sparse matrix</p>
</td></tr>
<tr><td><code id="permutation_+3A_p">P</code></td>
<td>
<p>vector giving the row permutation.</p>
</td></tr>
<tr><td><code id="permutation_+3A_q">Q</code></td>
<td>
<p>vector giving the column permutation.</p>
</td></tr>
<tr><td><code id="permutation_+3A_ind">ind</code></td>
<td>
<p>are the indices given. See examples.</p>
</td></tr>
<tr><td><code id="permutation_+3A_check">check</code></td>
<td>
<p>Should rudimentary checks be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If P and Q are permutation matrices, the result is
PAQ. However, it is also possible to specify the indices
and to perform in a very efficient way
<code>A[rowind, colind]</code>, see examples.
</p>
<p>A row permutation is much faster than a colum permutation.
For very large matrices, a double transpose might be faster.
</p>
<p>The spam option <code>spam.checkpivot</code> determines if the permutation
is verified.
</p>


<h3>Value</h3>

<p>A permuted matrix.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordering">ordering</a></code>, <code><a href="#topic+spam.options">spam.options</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- spam(1:12,3)
P &lt;- c(3,1,2)
Q &lt;- c(2,3,1,4)

permutation(A,P,Q)-A[order(P),order(Q)]

permutation(A,P,Q,ind=TRUE)-A[P,Q]

</code></pre>

<hr>
<h2 id='powerboost'>Specific Options Setting</h2><span id='topic+powerboost'></span>

<h3>Description</h3>

<p>Sets several options for speed-up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerboost(flag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerboost_+3A_flag">flag</code></td>
<td>
<p>on or off</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options turn checking off (<code>"safemode"</code>,
<code>"cholsymmetrycheck"</code>  and <code>"cholpivotcheck"</code>) and switch to
single precision for <code>"eps"</code>.</p>


<h3>Value</h3>

<p><code>NULL</code> in any case.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, after receiving too much C.mc.st adds.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spam.options">spam.options</a></code>.
</p>

<hr>
<h2 id='precmat'>IGMRF Precision Matrices</h2><span id='topic+precmat'></span><span id='topic+precmat.RW1'></span><span id='topic+precmat.RW2'></span><span id='topic+precmat.RWn'></span><span id='topic+precmat.season'></span><span id='topic+precmat.IGMRFreglat'></span><span id='topic+precmat.IGMRFirreglat'></span>

<h3>Description</h3>

<p>Fast ways to create sparse precision matrices for various IGMRF.</p>


<h3>Usage</h3>

<pre><code class='language-R'>precmat(n, season=12, m=n, A=NULL, order=1, ... , type="RW1")
precmat.RW1(n)
precmat.RW2(n)
precmat.RWn(n, order=3)
precmat.season(n, season=12)
precmat.IGMRFreglat(n, m, order=1, anisotropy=1)
precmat.IGMRFirreglat(A, eps=getOption("spam.eps"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precmat_+3A_n">n</code></td>
<td>
<p>dimension of the field.</p>
</td></tr>
<tr><td><code id="precmat_+3A_type">type</code></td>
<td>
<p>the type of the IGMRF.</p>
</td></tr>
<tr><td><code id="precmat_+3A_season">season</code></td>
<td>
<p>length of season.</p>
</td></tr>
<tr><td><code id="precmat_+3A_m">m</code></td>
<td>
<p>second dimension (in case of a regular lattice).</p>
</td></tr>
<tr><td><code id="precmat_+3A_a">A</code></td>
<td>
<p>adjacency matrix (see below).</p>
</td></tr>
<tr><td><code id="precmat_+3A_order">order</code></td>
<td>
<p>order for higher order RWs.</p>
</td></tr>
<tr><td><code id="precmat_+3A_anisotropy">anisotropy</code></td>
<td>
<p>anisotropy factor, between 0 and 2.</p>
</td></tr>
<tr><td><code id="precmat_+3A_eps">eps</code></td>
<td>
<p>tolerance level.</p>
</td></tr>
<tr><td><code id="precmat_+3A_...">...</code></td>
<td>
<p>arguments passed to individual functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>precmat</code> is a wrapper that calls the other functions
according to the argument <code>type</code>.
<br />
Implements many of the precision matrices discussed in Chapter
3 of Rue and Held (2005). For example, <code>precmat.RW1</code>,
<code>precmat.RW2</code> and <code>precmat.season</code> are given in
equations (3.22), (3.40) and (3.59); <code>precmat.IGMRFreglat</code> on
page 107. Note that for the latter we reverse the order of the dimension here!
<br />
If adjacency matrix is a regular matrix, it is coerced to a
<code>spam</code> object. Only the structure is used. Make sure, that the
diagonal is empty.
</p>


<h3>Value</h3>

<p>A sparse precision matrix.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>Rue and Held (2005). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precmat.GMRFreglat">precmat.GMRFreglat</a></code>, <code><a href="#topic+rmvnorm.prec">rmvnorm.prec</a></code>, <code><a href="#topic+adjacency.landkreis">adjacency.landkreis</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
Q &lt;- precmat.RW2( n)
# rmvnorm.prec(1, Q=Q) # does not work, because the matrix is singular.

Q%*%cbind(1,1:n)
</code></pre>

<hr>
<h2 id='print'>Printing and Summarizing Sparse Matrices</h2><span id='topic+print'></span><span id='topic+print.spam'></span><span id='topic+print+2Cspam-method'></span><span id='topic+print.spam.chol'></span><span id='topic+print.spam.chol.NgPeyton'></span><span id='topic+summary.spam'></span><span id='topic+summary+2Cspam-method'></span><span id='topic+summary.spam.chol'></span><span id='topic+summary.spam.chol.NgPeyton'></span><span id='topic+print_nnzpos'></span>

<h3>Description</h3>

<p>Printing (non-zero elements) of sparse matrices
and summarizing the sparsity structure thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'spam'
print(x, ...)
## S4 method for signature 'spam'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>matrix of class <code>spam</code> or <code>spam.chol.</code><em>method</em>.</p>
</td></tr>
<tr><td><code id="print_+3A_object">object</code></td>
<td>
<p>matrix of class <code>spam</code> or <code>spam.chol.</code><em>method</em>.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>any other arguments passed to <code>print.default</code>.
If the non-standard argument <code>minimal</code> is set to <code>FALSE</code>,
an extended spam print is available with logical argument <code>rowpointer</code>
to print rowpointers, and <code>zerosymbol</code> defining the character
to display the zero element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getOption('spam.printsize')</code> determines  if the sparse matrix is
coerced into a matrix and the printed as an array or if
only the non-zero elements of the matrix are given.
</p>


<h3>Value</h3>

<p><code>NULL</code> for <code>print</code>, because the information is printed with <code>cat</code> there
is no real need to pass any object back. <br />

A list containing the non-zero elements and the density for
<code>summary</code>
for class <code>spam</code>.<br />

A list containing the non-zero elements of the factor, the density and
the fill-in for  <code>summary</code> for class <code>spam.chol.NgPeyton</code>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+display">display</a></code> or <code><a href="#topic+image">image</a></code> for a graphical visualization;
<code><a href="#topic+spam.options">spam.options</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
smat &lt;- spam_random(8)
par(mfcol=c(1,2),pty='s')
options(spam.printsize=1000)
print(smat)
options(spam.printsize=10)
print(smat)
summary(smat)
summary(smat)$nnz

smat@entries[1:5] &lt;- 0
print(smat, minimal = FALSE)
print(smat, minimal = FALSE, rowpointer = TRUE)
smat@rowpointers
print_nnzpos(smat)

</code></pre>

<hr>
<h2 id='random'>Create Random Sparse Matrices</h2><span id='topic+spam_random'></span>

<h3>Description</h3>

<p>Creates random spam matrix given the dimension and other parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spam_random(nrow = 1L, ncol = nrow, density = 0.5, distribution = NULL, digits = NULL,
            sym = FALSE, spd = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_nrow">nrow</code></td>
<td>
<p>integer value for the number of rows for the <code>spam</code> matrix to create.</p>
</td></tr>
<tr><td><code id="random_+3A_ncol">ncol</code></td>
<td>
<p>integer value for the number of columns. The default value is the same as <code>nrow</code>.</p>
</td></tr>
<tr><td><code id="random_+3A_density">density</code></td>
<td>
<p>A numeric value between 0 and 1 specifying the approximate density of matrix.
If equal to zero the <code>spam</code> matrix contains only zeros and if equal to 1 the <code>spam</code> matrix is full.</p>
</td></tr>
<tr><td><code id="random_+3A_distribution">distribution</code></td>
<td>
<p>a random number generating distribution function to sample the entries of the <code>spam</code> matrix.
The function must have an argument with the name <code>n</code>, possible candidates are <code>rnorm</code>, <code>rexp</code>, <code>rpois</code>, <code>rweibull</code>, etc..</p>
</td></tr>
<tr><td><code id="random_+3A_...">...</code></td>
<td>
<p>possible additional arguments for the distribution function if specified with <code>distribution</code>.</p>
</td></tr>
<tr><td><code id="random_+3A_digits">digits</code></td>
<td>
<p>an integer value for the number of digits the entries should be rounded.</p>
</td></tr>
<tr><td><code id="random_+3A_sym">sym</code></td>
<td>
<p>logical value to specify symmetry of the <code>spam</code> matrix.</p>
</td></tr>
<tr><td><code id="random_+3A_spd">spd</code></td>
<td>
<p>logical value to specify positive definitness of the <code>spam</code> matrix, via diagonal dominace criteria.
Note, if <code>spd</code> TRUE, then <code>sym</code> is overwritten to <code>TRUE</code> in any case.</p>
</td></tr>
<tr><td><code id="random_+3A_verbose">verbose</code></td>
<td>
<p>logical value to specify verbose statments of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create a random spam64 matrix, set <code>options(spam.force64 = TRUE)</code>.</p>


<h3>Value</h3>

<p>A random matrix in <code>spam</code> format.</p>


<h3>Author(s)</h3>

<p>Florian Gerber, Roman Flury, Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+spam-class">spam-class</a></code> and <code><a href="#topic+display.spam">display.spam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
rspam &lt;- spam_random(500, digits = 2, distribution = rnorm, sd = 2, mean = 10, density = .01)
display.spam(rspam, cex = 2)
</code></pre>

<hr>
<h2 id='rgrf'>Draw From a Gaussian Random Field</h2><span id='topic+rgrf'></span><span id='topic+rgrf.spam'></span>

<h3>Description</h3>

<p>Fast and intuitive ways to draw from a Gaussian random field.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgrf( n,
   locs, nx, ny=nx, xlim=c(0,1), ylim=c(0,1), tau=0,
   Covariance, theta, beta=0, X, 
   method=c('chol'),  method.args=list(sparse=FALSE), 
   eps = getOption("spam.eps"), drop=TRUE, attributes=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgrf_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_locs">locs</code></td>
<td>
<p>locations, the result of <code>as.matrix(locs)</code> will be
used.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_nx">nx</code>, <code id="rgrf_+3A_ny">ny</code></td>
<td>
<p>if no locations are specified, at least one of these to
specify the grid dimension.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_xlim">xlim</code>, <code id="rgrf_+3A_ylim">ylim</code></td>
<td>
<p>Domain, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_tau">tau</code></td>
<td>
<p>perturbation degree, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_covariance">Covariance</code></td>
<td>
<p>covariance function name.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_theta">theta</code></td>
<td>
<p>covariance parameter.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_beta">beta</code></td>
<td>
<p>mean or vector for regression-type mean.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_x">X</code></td>
<td>
<p>design matrix for regression-type mean.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_method">method</code></td>
<td>
<p>based on Choleski factorization.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_method.args">method.args</code></td>
<td>
<p>list of arguments that can be passed to the corresponding approach.
For <code>"chol"</code> it can be, e.g., <code>RStruct</code>, <code>chol.args</code>, <code>cov.args</code>.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_eps">eps</code></td>
<td>
<p>small value, anything smaller is considered a collocation.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_drop">drop</code></td>
<td>
<p>logical, if a single realization should be returned as a vector.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_attributes">attributes</code></td>
<td>
<p>logical, if should attributes be passed back.</p>
</td></tr>
<tr><td><code id="rgrf_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no locations are given, the function constructs these
according a regular or a regular perturbed grid. The perturbation is
determined by <code>tau</code>, which has to be greater than zero (no
perturbation) and strictly smaller than 1/2 (max perturbation).
</p>
<p>The regular grid has spacing (here for x) <code>dx=diff(xlim)/nx</code> and runs
from <code>xlim[1]+dx/2</code> to <code>xlim[2]-dx/2</code>.
The locations are at least  <code>(1/nx-2*tau*dx)</code> separated.
<br />
</p>
<p>Currently, the only method implemented is a Cholesky factorization
routine,  (much as in <code><a href="#topic+rmvnorm">rmvnorm</a></code>).
</p>
<p>The <code>rdist()</code> from the <code>fields</code> package is awefully
fast. Unless one has very sparse covariance matrices, a sparse
approach is not bringing a lot of improvements. 
</p>
<p>The methods may use different covariance construction approaches and
thus the nesting of <code>cov.args</code> in <code>method.args</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgrf">rgrf</a></code>, <code><a href="#topic+chol">chol</a></code> and <code><a href="#topic+ordering">ordering</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(fields)
# Regular grid with constant mean:
nx &lt;- 10
field &lt;- rgrf(1, nx=nx,  Covariance="cov.wend2", theta=c(.5, 1), beta=5)
quilt.plot(cbind(attr(field,"locs"),z=field), nx=nx, ny=nx)
points(attr(field,"locs"))

# Irregluar grid:
field &lt;- rgrf(1, nx=10, tau=0.3, Covariance="cov.mat", theta=c(.2, 1, 1.5))
fields::quilt.plot(attr(field,"locs"), field)

</code></pre>

<hr>
<h2 id='rmvnorm'>Draw Multivariate Normals</h2><span id='topic+rmvnorm'></span><span id='topic+rmvnorm.spam'></span><span id='topic+rmvnorm.prec'></span><span id='topic+rmvnorm.canonical'></span>

<h3>Description</h3>

<p>Fast ways to draw multivariate normals when the variance or precision matrix
is sparse.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm(n, mu=rep.int(0, dim(Sigma)[1]), Sigma, ..., mean, sigma)
rmvnorm.spam(n, mu=rep.int(0, dim(Sigma)[1]), Sigma, Rstruct=NULL, ..., mean, sigma)
rmvnorm.prec(n, mu=rep.int(0, dim(Q)[1]), Q, Rstruct=NULL, ...)
rmvnorm.canonical(n, b, Q, Rstruct=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix (of class <code>spam</code>).</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_q">Q</code></td>
<td>
<p>precision matrix.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_b">b</code></td>
<td>
<p>vector determining the mean.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_rstruct">Rstruct</code></td>
<td>
<p>the Cholesky structure of <code>Sigma</code> or <code>Q</code>.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>chol</code>.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_mean">mean</code>, <code id="rmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>similar to <code>mu</code> and  <code>Sigma</code>. Here for portability with <code>mvtnorm::rmvnorm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions rely on a Cholesky factorization of the
covariance or precision matrix.
<br />
The functions <code>rmvnorm.prec</code> and <code>rmvnorm.canonical</code>
do not require sparse precision matrices
Depending on the the covariance matrix <code>Sigma</code>,  <code>rmvnorm</code>
or <code>rmvnorm.spam</code> is used. If wrongly specified, dispatching to
the other function is done.
<br />
Default mean is zero. Side note: mean is added via <code>sweep()</code> and
no gain is accieved by distinguishing this case.
<br />
Often (e.g., in a Gibbs sampler setting), the sparsity structure of
the covariance/precision does not change. In such setting, the
Cholesky factor can be passed via <code>Rstruct</code> in which only updates
are performed (i.e., <code>update.spam.chol.NgPeyton</code> instead of a
full <code>chol</code>).
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>See references in <code><a href="#topic+chol">chol</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgrf">rgrf</a></code>, <code><a href="#topic+chol">chol</a></code> and <code><a href="#topic+ordering">ordering</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate multivariate from a covariance inverse:
# (usefull for GRMF)
set.seed(13)
n &lt;- 25    # dimension
N &lt;- 1000  # sample size
Sigmainv &lt;- .25^abs(outer(1:n,1:n,"-"))
Sigmainv &lt;- as.spam( Sigmainv, eps=1e-4)


Sigma &lt;- solve( Sigmainv)  # for verification
iidsample &lt;- array(rnorm(N*n),c(n,N))

mvsample &lt;- backsolve( chol(Sigmainv), iidsample)
norm( var(t(mvsample)) - Sigma, type="m")

# compare with:
mvsample &lt;- backsolve( chol(as.matrix( Sigmainv)), iidsample, n)
   #### ,n as patch
norm( var(t(mvsample)) - Sigma, type="m")


# 'solve' step by step:
b &lt;- rnorm( n)
R &lt;- chol(Sigmainv)
norm( backsolve( R, forwardsolve( R, b))-
      solve( Sigmainv, b) )
norm( backsolve( R, forwardsolve( R, diag(n)))- Sigma )


</code></pre>

<hr>
<h2 id='rmvnorm.conditional'>Draw Conditional Multivariate Normals</h2><span id='topic+rmvnorm.cond'></span><span id='topic+rmvnorm.conditional'></span><span id='topic+rmvnorm.conditional.spam'></span>

<h3>Description</h3>

<p>Fast way to draw conditional multivariate normals when the covariance
matrix is sparse.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm.conditional(n, y, mu = rep.int(0, dim(SigmaXX)[1]+dim(SigmaYY)[1]),
                    SigmaXX, SigmaYY, SigmaXY, noise, RstructYY = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm.conditional_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_y">y</code></td>
<td>
<p>observed vector.</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_sigmaxx">SigmaXX</code></td>
<td>
<p>covariance of X, required (of class <code>spam</code>).</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_sigmaxy">SigmaXY</code></td>
<td>
<p>cross-covariance of X-Y, optional (of class <code>spam</code>).</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_sigmayy">SigmaYY</code></td>
<td>
<p>covariance of Y, required (of class <code>spam</code>).</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_noise">noise</code></td>
<td>
<p>observational noice of Y, optional. See &lsquo;Details&rsquo;. </p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_rstructyy">RstructYY</code></td>
<td>
<p>the Cholesky structure of <code>SigmaYY</code>.</p>
</td></tr>
<tr><td><code id="rmvnorm.conditional_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>chol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quite often, we want to draw condional observations <code class="reqn">X|y</code>
from the model <code class="reqn">Y=X+e</code>, where <code class="reqn">X</code> has covariance matrix
<code>SigmaXX</code> and <code class="reqn">e</code> has white noise.<br />
</p>
<p>Covariance of <code class="reqn">Y</code> can be specified by <code>SigmaYY</code> or
<code>SigmaXX+diag(noise,)</code>. If <code class="reqn">Y</code> and <code class="reqn">X</code> do not have the
same dimensions, <code>SigmaXY</code> needs to be specified. <br />
</p>
<p>The function also implmements a general multivariate model, where the
we only observe part of the vector.  The components are first
<code class="reqn">X</code> then <code class="reqn">Y</code>.
</p>
<p>The function <code>rmvnorm.cond()</code> is a wrapper to
<code>rmvnorm.conditional()</code> and included to increase similarities
with other packages.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmvnorm.spam">rmvnorm.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
N &lt;- 300
y &lt;- c(5, -5, -5, 5)
SigmaXX &lt;- as.spam(.95^abs(outer(1:N, 1:N, "-")), eps=1e-4)
sel &lt;- c(10, 100, 120, 300)        # where we observe y
SigmaXY &lt;- SigmaXX[, sel]
SigmaYY &lt;- SigmaXX[sel,sel] + diag.spam(.01, length(y)) # some noise
x &lt;- rmvnorm.conditional(3, y, SigmaXX=SigmaXX, SigmaXY=SigmaXY,
                         SigmaYY=SigmaYY)
# unconditional sample:
ux &lt;- rmvnorm(1, Sigma=SigmaXX)
matplot(t(rbind(x, ux)), type='l', lty=1)
points(sel, y, pch=19)
</code></pre>

<hr>
<h2 id='rmvnorm.const'>Draw Constrainted Multivariate Normals</h2><span id='topic+rmvnorm.const'></span><span id='topic+rmvnorm.prec.const'></span><span id='topic+rmvnorm.canonical.const'></span>

<h3>Description</h3>

<p>Fast ways to draw multivariate normals with linear constrains when the variance or precision matrix
is sparse.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm.const(n, mu = rep.int(0, dim(Sigma)[1]), Sigma, Rstruct = NULL,
              A = array(1, c(1,dim(Sigma)[1])), a=0, U=NULL,  ...)
rmvnorm.prec.const(n, mu = rep.int(0, dim(Q)[1]), Q, Rstruct = NULL,
              A = array(1, c(1,dim(Q)[1])), a=0, U=NULL,  ...)
rmvnorm.canonical.const(n, b, Q, Rstruct = NULL,
              A = array(1, c(1,dim(Q)[1])), a=0, U=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm.const_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of class <code>spam</code>.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_q">Q</code></td>
<td>
<p>precision matrix.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_b">b</code></td>
<td>
<p>vector determining the mean.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_rstruct">Rstruct</code></td>
<td>
<p>the Cholesky structure of <code>Sigma</code> or <code>Q</code>.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_a">A</code></td>
<td>
<p>Constrain matrix.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_a">a</code></td>
<td>
<p>Constrain vector.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_u">U</code></td>
<td>
<p>see below.</p>
</td></tr>
<tr><td><code id="rmvnorm.const_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>chol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>rmvnorm.prec</code> and <code>rmvnorm.canonical</code>
do not requrie sparse precision matrices.
For <code>rmvnorm.spam</code>, the differences between regular and sparse
covariance matrices are too significant to be implemented here.  <br />
Often (e.g., in a Gibbs sampler setting), the sparsity structure of
the covariance/precision does not change. In such setting, the
Cholesky factor can be passed via <code>Rstruct</code> in which only updates
are performed (i.e., <code>update.spam.chol.NgPeyton</code> instead of a
full <code>chol</code>).
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>See references in <code><a href="#topic+chol">chol</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmvnorm.spam">rmvnorm.spam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to be filled in

</code></pre>

<hr>
<h2 id='rmvt'>Draw From a Multivariate t-Distribution</h2><span id='topic+rmvt'></span><span id='topic+rmvt.spam'></span>

<h3>Description</h3>

<p>Fast ways to draw from a multivariate t-distribution the scale (covariance) matrix
is sparse.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvt(n, Sigma, df = 1, delta = rep(0, nrow(Sigma)),
    type = c("shifted", "Kshirsagar"), ..., sigma)
rmvt.spam(n, Sigma, df = 1, delta = rep(0, nrow(Sigma)),
    type = c("shifted", "Kshirsagar"), ..., sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvt_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rmvt_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix (of class <code>spam</code>).</p>
</td></tr>
<tr><td><code id="rmvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="rmvt_+3A_delta">delta</code></td>
<td>
<p>vector of noncentrality parameters.</p>
</td></tr>
<tr><td><code id="rmvt_+3A_type">type</code></td>
<td>
<p>type of the noncentral multivariate t distribution.</p>
</td></tr>
<tr><td><code id="rmvt_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>rmvnorm.spam</code>.</p>
</td></tr>
<tr><td><code id="rmvt_+3A_sigma">sigma</code></td>
<td>
<p>similar to <code>Sigma</code>. Here for portability with <code>mvtnorm::rmvt()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very much like <code>rmvt()</code> from the package
<span class="pkg">mvtnorm</span>. We refer to the help of the afore mentioned.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>See references in <code>mvtnorm::rmvt()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmvnorm">rmvnorm</a></code>.
</p>

<hr>
<h2 id='rowSums'>Form Row and Column Sums and Means</h2><span id='topic+rowSums.spam'></span><span id='topic+colSums.spam'></span><span id='topic+rowMeans.spam'></span><span id='topic+colMeans.spam'></span><span id='topic+rowSums'></span><span id='topic+colSums'></span><span id='topic+rowMeans'></span><span id='topic+colMeans'></span><span id='topic+rowSums+2Cspam-method'></span><span id='topic+colSums+2Cspam-method'></span><span id='topic+rowMeans+2Cspam-method'></span><span id='topic+colMeans+2Cspam-method'></span>

<h3>Description</h3>

<p>Form row and column sums and means for sparse <code><a href="#topic+spam-class">spam</a></code> matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowSums(x, na.rm = FALSE, dims = 1, ...)
colSums(x, na.rm = FALSE, dims = 1, ...)
rowMeans(x, na.rm = FALSE, dims = 1, ...)
colMeans(x, na.rm = FALSE, dims = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSums_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+spam-class">spam</a></code> object</p>
</td></tr>
<tr><td><code id="rowSums_+3A_na.rm">na.rm</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="rowSums_+3A_dims">dims</code></td>
<td>
<p>ignored as we have only two dimensions.</p>
</td></tr>
<tr><td><code id="rowSums_+3A_...">...</code></td>
<td>
<p>potentially further arguments from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the flag .
</p>


<h3>Value</h3>

<p>Vector of appropriate length.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply.spam">apply.spam</a></code>, <code><a href="#topic+spam.options">spam.options</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spam( rnorm(20), 5, 4)
rowSums( x)
c( x %*% rep(1,4))
</code></pre>

<hr>
<h2 id='s3only'>Wappers for Sparse Matrices</h2><span id='topic+var.spam'></span>

<h3>Description</h3>

<p>These functions are convenient wrappers for  <code>spam</code> objects
to classical matrix operations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.spam(x, ...)

## S3 method for class 'spam'
var(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s3only_+3A_x">x</code></td>
<td>
<p>matrix of class <code>spam</code>.</p>
</td></tr>
<tr><td><code id="s3only_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is probably no point in fully defining methods
here. Typically, these functions do not exploit sparsity
structures. Hence, for very large matrices, warnings may be posted.</p>


<h3>Value</h3>

<p>Depends on function...
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p>Option <code>"inefficiencywarning"</code> in <code><a href="#topic+spam.options">spam.options</a></code>.
</p>

<hr>
<h2 id='spam'>Sparse Matrix Class</h2><span id='topic+spam.creation'></span><span id='topic+initialize+2Cspam-method'></span><span id='topic+spam'></span><span id='topic+spam.list'></span><span id='topic+spam.numeric'></span><span id='topic+spam+2Clist-method'></span><span id='topic+spam+2Cnumeric-method'></span><span id='topic+as.spam+2Cmatrix-method'></span><span id='topic+as.spam+2Cnumeric-method'></span><span id='topic+as.spam+2Cspam-method'></span><span id='topic+as.spam+2Cdist-method'></span><span id='topic+as.spam+2Clist-method'></span><span id='topic+as.spam'></span><span id='topic+as.spam.spam'></span><span id='topic+as.spam.numeric'></span><span id='topic+as.spam.matrix'></span><span id='topic+as.spam.chol.NgPeyton'></span><span id='topic+as.spam.dist'></span><span id='topic+as.spam.list'></span><span id='topic+is.spam'></span>

<h3>Description</h3>

<p>This group of functions evaluates and coerces changes in class structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spam(x, nrow = 1, ncol = 1, eps = getOption("spam.eps"))

as.spam(x, eps = getOption("spam.eps"))

is.spam(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spam_+3A_x">x</code></td>
<td>
<p>is a matrix (of either dense or sparse form), a list, vector
object or a distance object</p>
</td></tr>
<tr><td><code id="spam_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of matrix </p>
</td></tr>
<tr><td><code id="spam_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of matrix </p>
</td></tr>
<tr><td><code id="spam_+3A_eps">eps</code></td>
<td>
<p>A tolerance parameter:  elements of <code>x</code> such that
<code>abs(x) &lt; eps</code> set to zero. Defaults to <code>eps =
    getOption("spam.eps")</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>spam</code> and <code>as.spam</code> act like <code>matrix</code>
and <code>as.matrix</code>
to coerce an object to a sparse matrix object of class <code>spam</code>.
</p>
<p>If <code>x</code> is a list, it should contain either two or three elements.
In case of the former, the list should contain a <code>n</code> by two
matrix of indicies (called <code>ind</code>) and the values.
In case of the latter, the list should contain three vectors
containing the row, column indices (called <code>i</code> and
<code>j</code>) and the values. In both cases partial matching is done.
In case there are several triplets with the same <code>i</code>, <code>j</code>,
the values are added.
</p>
<p><code>eps</code> should be at least as large as <code>.Machine$double.eps</code>.
</p>
<p>If <code>getOption("spam.force64")</code> is <code>TRUE</code>, a 64-bit
spam matrix is returned in any case. If <code>FALSE</code>, a 32-bit
matrix is returned when possible.
</p>


<h3>Value</h3>

<p>A valid <code>spam</code> object.<br />
<code>is.spam</code> returns <code>TRUE</code> if <code>x</code> is a <code>spam</code> object.</p>


<h3>Note</h3>

<p>The zero matrix has the element zero stored in (1,1).<br />
</p>
<p>The functions do not test the presence of <code>NA/NaN/Inf</code>. Virtually
all call a Fortran routine with the <code>NAOK=NAOK</code>
argument, which defaults to <code>FALSE</code> resulting in an error.
Hence, the <code>NaN</code> do not always properly propagate through (i.e.
<code>spam</code> is not IEEE-754 compliant).
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>Reinhard Furrer, Stephan R. Sain (2010).
&quot;spam: A Sparse Matrix R Package with Emphasis on MCMC
Methods for Gaussian Markov Random Fields.&quot;,
<em>Journal of Statistical Software</em>, 36(10), 1-25,
<a href="https://doi.org/10.18637/jss.v036.i10">doi:10.18637/jss.v036.i10</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SPAM">SPAM</a></code> for a general overview of the package;
<code><a href="#topic+spam_random">spam_random</a></code> to create matrices with a random sparsity pattern;
<code><a href="#topic+cleanup">cleanup</a></code> to purge a sparse matrix;
<code><a href="#topic+spam.options">spam.options</a></code> for details about the <code>safemode</code> flag;
<code><a href="#topic+read.MM">read.MM</a></code> and <code><a href="#topic+foreign">foreign</a></code> to create <code>spam</code>
matrices from MatrixMarket
files and from certain <span class="pkg">Matrix</span> or <span class="pkg">SparseM</span> formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># old message, do not loop, when you create a large sparse matrix
set.seed(13)
nz &lt;- 128
ln &lt;- nz^2
smat &lt;- spam(0,ln,ln)
is &lt;- sample(ln,nz)
js &lt;- sample(ln,nz)
## IGNORE_RDIFF_BEGIN
system.time(for (i in 1:nz) smat[is[i], js[i]] &lt;- i)
system.time(smat[cbind(is,js)] &lt;- 1:nz)
## IGNORE_RDIFF_END

getClass("spam")


options(spam.NAOK=TRUE)
as.spam(c(1, NA))
</code></pre>

<hr>
<h2 id='spam+20internal'>
Spam internal and auxiliary functions
</h2><span id='topic+printSize'></span>

<h3>Description</h3>

<p>The functions listed below are auxiliary functions and are not exported by the NAMESPACE. 
The user should not require to call these directly. 
</p>


<h3>Details</h3>

<p><code>printSize(x, size=8, digits=2L)</code> constructs a string for
pretty printing the object size <code>x</code>. <br />
</p>

<hr>
<h2 id='spam+20methods'>Methods for Sparse Matrices</h2><span id='topic+methods.spam'></span>

<h3>Description</h3>

<p>Methods without any additional parameters for sparse matrices.
</p>


<h3>Details</h3>

<p>If a method for <code>spam</code> objects takes the same arguments,
produces the intuitive output. We do not provide additional help
pages.
</p>
<p>However, such methods are usually linked to a <code>xzy.spam</code>
function, that could also be called directly.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p>Corresponding base help functions.
</p>

<hr>
<h2 id='spam-class'>Class &quot;spam&quot;</h2><span id='topic+spam.class'></span><span id='topic+spam-class'></span><span id='topic+as.matrix+2Cspam-method'></span><span id='topic+as.matrix.spam'></span><span id='topic++5B+3C-+2Cspam+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cmatrix+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cvector+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cvector+2Cspam-method'></span><span id='topic++5B+3C-+2Cspam+2Cspam+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cmissing+2Cspam-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cvector+2CANY-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cvector+2Cspam-method'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cvector+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cvector+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2Cmatrix+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2Cmatrix+2Cmatrix+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2Cspam+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspam+2CANY-method'></span><span id='topic++5B+2Cspam+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cspam+2Cmissing+2Cvector+2CANY-method'></span><span id='topic++5B+2Cspam+2Cvector+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Cspam+2Cvector+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cspam+2Cvector+2Cvector+2CANY-method'></span><span id='topic++5B+2Cspam+2Cmatrix+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cspam+2Cmatrix+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Cspam+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic++5B+2Cspam+2Cspam+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cspam+2CANY+2CANY+2CANY-method'></span><span id='topic+Arith+2Cspam+2Cspam-method'></span><span id='topic+Arith+2Cspam+2CANY-method'></span><span id='topic+Arith+2CANY+2Cspam-method'></span><span id='topic+Compare+2CANY+2Cspam-method'></span><span id='topic+Compare+2Cspam+2CANY-method'></span><span id='topic+Compare+2Cspam+2Cspam-method'></span><span id='topic++21+2Cspam-method'></span><span id='topic++2B+2Cspam+2Cmissing-method'></span><span id='topic+-+2Cspam+2Cmissing-method'></span><span id='topic+c+2Cspam-method'></span><span id='topic+t+2Cspam-method'></span><span id='topic+length+3C-+2Cspam-method'></span><span id='topic+length+2Cspam-method'></span><span id='topic+lower.tri+2Cspam-method'></span><span id='topic+plot+2Cspam+2Cmissing-method'></span><span id='topic+plot+2Cspam+2Cspam-method'></span><span id='topic+show+2Cspam-method'></span><span id='topic+upper.tri+2Cspam-method'></span>

<h3>Description</h3>

<p>The <code>spam</code> class is a representation of sparse matrices.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("spam", entries, colindices,
    rowpointes, dimension)</code>.
The standard &quot;old Yale sparse format&quot; is used to store sparse matrices.<br />
The matrix
<code>x</code> is stored in row form.  The first element of row <code>i</code> is
<code>x@rowpointers[i]</code>. The length of row <code>i</code> is determined by
<code>x@rowpointers[i+1]-x@rowpointers[i]</code>. The column indices of <code>x</code> are stored in
the <code>x@colindices</code> vector. The column index for element <code>x@entries[k]</code> is
<code>x@colindices[k]</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>entries</code>:</dt><dd><p>Object of class <code>"numeric"</code> contains the
nonzero values. </p>
</dd>
<dt><code>colindices</code>:</dt><dd><p>Object of class <code>"integer"</code> ordered indices
of the nonzero values. </p>
</dd>
<dt><code>rowpointers</code>:</dt><dd><p>Object of class <code>"integer"</code> pointer to the beginning
of each row in the arrays <code>entries</code> and <code>colindices</code>.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>"integer"</code> specifying
the dimension of the matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.matrix</dt><dd><p><code>signature(x = "spam")</code>:
transforming a sparse
matrix into a regular matrix.</p>
</dd>
<dt>as.vector</dt><dd><p><code>signature(x = "spam")</code>:
transforming a sparse
matrix into a vector (dependings on <code>structurebased</code>) see <code><a href="#topic+as.vector.spam">as.vector.spam</a></code> for details.</p>
</dd>
<dt>as.spam</dt><dd><p><code>signature(x = "spam")</code>:
cleaning of a sparse matrix.</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "spam", i,j, value)</code>:
assigning a
sparse matrix. The negative vectors are not implemented yet. </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "spam", i, j)</code>:
subsetting a
sparse matrix. The negative vectors are not implemented yet. </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x, y)</code>:
matrix multiplication, all combinations of sparse with full
matrices or vectors are implemented.</p>
</dd>
<dt>c</dt><dd><p><code>signature(x = "spam")</code>:
vectorizes the sparse matrix and takes account of the zeros. Hence
the lenght of the result is <code>prod(dim(x))</code>.</p>
</dd>
<dt>cbind</dt><dd><p><code>signature(x = "spam")</code>: binds sparse matrices, see <code><a href="#topic+cbind">cbind</a></code> for details.</p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "spam")</code>:
see <code><a href="#topic+chol">chol</a></code> for details.</p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "spam")</code>:
see <code><a href="#topic+diag">diag</a></code> for details.</p>
</dd>
<dt>dim&lt;-</dt><dd><p><code>signature(x = "spam")</code>: rearranges
the matrix to reflect a new dimension.</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "spam")</code>: gives the dimension of the
sparse matrix.</p>
</dd>
<dt>pad&lt;-</dt><dd><p><code>signature(x = "spam")</code>: truncates or augments
the matrix see <code><a href="base.html#topic+dim">dim</a></code> for details.</p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "spam")</code>:
see <code><a href="#topic+image">image</a></code> for details.</p>
</dd>
<dt>display</dt><dd><p><code>signature(x = "spam")</code>:
see <code><a href="#topic+display">display</a></code> for details.</p>
</dd>
<dt>length&lt;-</dt><dd><p><code>signature(x = "spam")</code>: Is not implemented and
causes an error.</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "spam")</code>: gives the number of
non-zero elements.</p>
</dd>
<dt>lower.tri</dt><dd><p><code>signature(x = "spam")</code>: see <code><a href="#topic+lower.tri">lower.tri</a></code> for details. </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "spam")</code>: see <code><a href="#topic+Math">Math</a></code> for details.</p>
</dd>
<dt>Math2</dt><dd><p><code>signature(x = "spam")</code>: see <code><a href="#topic+Math2">Math2</a></code> for details. </p>
</dd>
<dt>norm</dt><dd><p><code>signature(x = "spam")</code>: calculates the norm of a matrix.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "spam", y)</code>: same functionality as
the ordinary <code><a href="graphics.html#topic+plot">plot</a></code>. </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "spam")</code>: see <code><a href="#topic+print">print</a></code> for details.</p>
</dd>
<dt>rbind</dt><dd><p><code>signature(x = "spam")</code>: binds sparse
matrices, see <code><a href="#topic+cbind">cbind</a></code> for details.</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "spam")</code>: see <code><a href="#topic+solve">solve</a></code> for details.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "spam")</code>: small summary
statement of the sparse matrix.</p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "spam")</code>:
All functions of the <code>Summary</code> class (like <code>min</code>, <code>max</code>,
<code>range</code>...) operate on the vector <code>x@entries</code> and return the
result thereof. See Examples or <code><a href="#topic+Summary">Summary</a></code> for details.
</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "spam")</code>: transpose of a sparse matrix.</p>
</dd>
<dt>upper.tri</dt><dd><p><code>signature(x = "spam")</code>: see <code><a href="#topic+lower.tri">lower.tri</a></code> for details.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The compressed sparse row (CSR) format is often described with the
vectors <code>a</code>, <code>ia</code>, <code>ja</code>. To be a bit more
comprehensive, we have chosen longer slot names.
</p>


<h3>Note</h3>

<p>The slots <code>colindices</code> and <code>rowpointers</code> are
tested for proper integer assignments. This is not true for
<code>entries</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, some of the Fortran code is based on A. George,
J. Liu, E. S. Ng, B.W Peyton and Y. Saad (alphabetical)</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods("as.spam")


smat &lt;- diag.spam(runif(15))
range(smat)
cos(smat)
</code></pre>

<hr>
<h2 id='spam-defunct'>Defunct Objects in Package <span class="pkg">spam</span></h2><span id='topic+spam-defunct'></span><span id='topic+validspamobject'></span>

<h3>Description</h3>

<p>The functions or variables listed here are defunct, i.e. thorw an error when used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  validspamobject(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spam-defunct_+3A_...">...</code></td>
<td>
<p>some arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>,
<code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='spam-operations'>Basic Linear Algebra for Sparse Matrices</h2><span id='topic+Ops.spam'></span><span id='topic+spam.ops'></span><span id='topic++25+2A+25-methods'></span><span id='topic++25+2A+25+2CANY+2CANY-method'></span><span id='topic++25+2A+25+2Cspam+2Cspam-method'></span><span id='topic++25+2A+25+2Cspam+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cspam+2Cnumeric-method'></span><span id='topic++25+2A+25+2Cmatrix+2Cspam-method'></span><span id='topic++25+2A+25+2Cnumeric+2Cspam-method'></span><span id='topic++25d+2A+25'></span><span id='topic++25d+2A+25+2Cspam+2Cspam-method'></span><span id='topic++25d+2A+25+2Cspam+2CANY-method'></span><span id='topic++25d+2A+25+2Cmatrix+2Cspam-method'></span><span id='topic++25d+2A+25+2Cmatrix+2CANY-method'></span><span id='topic++25d+2A+25+2Cspam+2Cnumeric-method'></span><span id='topic++25d+2A+25+2Cnumeric+2Cspam-method'></span><span id='topic++25d+2A+25+2Cnumeric+2Cmatrix-method'></span><span id='topic++25d+2A+25+2Cnumeric+2Cnumeric-method'></span><span id='topic++25d+2B+25'></span><span id='topic++25d+2B+25+2Cspam+2Cspam-method'></span><span id='topic++25d+2B+25+2Cspam+2CANY-method'></span><span id='topic++25d+2B+25+2Cmatrix+2Cspam-method'></span><span id='topic++25d+2B+25+2Cmatrix+2CANY-method'></span><span id='topic++25d+2B+25+2Cspam+2Cnumeric-method'></span><span id='topic++25d+2B+25+2Cnumeric+2Cmatrix-method'></span><span id='topic++25d+2B+25+2Cnumeric+2Cspam-method'></span><span id='topic++25d+2B+25+2Cnumeric+2Cnumeric-method'></span><span id='topic++2B+2Cspam+2Cspam-method'></span><span id='topic++2B+2Cmatrix+2Cspam-method'></span><span id='topic++2B+2Cspam+2Cmatrix-method'></span><span id='topic++2B+2CANY+2Cspam-method'></span><span id='topic++2B+2Cspam+2CANY-method'></span><span id='topic+-+2Cspam+2Cspam-method'></span><span id='topic+-+2Cmatrix+2Cspam-method'></span><span id='topic+-+2Cspam+2Cmatrix-method'></span><span id='topic+-+2CANY+2Cspam-method'></span><span id='topic+-+2Cspam+2CANY-method'></span><span id='topic++2A+2Cspam+2Cspam-method'></span><span id='topic++2A+2CANY+2Cspam-method'></span><span id='topic++2A+2Cspam+2CANY-method'></span><span id='topic++2F+2Cspam+2Cspam-method'></span><span id='topic++2F+2CANY+2Cspam-method'></span><span id='topic++2F+2Cspam+2CANY-method'></span><span id='topic++2F+2Cmatrix+2Cspam-method'></span><span id='topic++5E+2Cspam+2Cspam-method'></span><span id='topic++5E+2CANY+2Cspam-method'></span><span id='topic++5E+2Cspam+2CANY-method'></span><span id='topic++26+2Cspam+2CANY-method'></span><span id='topic++26+2Cspam+2Cspam-method'></span><span id='topic++26+2CANY+2Cspam-method'></span><span id='topic++7C+2Cspam+2CANY-method'></span><span id='topic++7C+2CANY+2Cspam-method'></span><span id='topic++7C+2Cspam+2Cspam-method'></span><span id='topic++5E+2Cspam-method'></span><span id='topic++25+25+2Cspam-method'></span><span id='topic++25+2F+25+2Cspam-method'></span><span id='topic++3E+2Cspam-method'></span><span id='topic++3E+3D+2Cspam-method'></span><span id='topic++3C+2Cspam-method'></span><span id='topic++3C+3D+2Cspam-method'></span><span id='topic++3D+3D+2Cspam-method'></span><span id='topic++21+3D+2Cspam-method'></span><span id='topic+norm'></span><span id='topic+norm.spam'></span><span id='topic+norm+2CANY-method'></span><span id='topic+norm+2Cspam+2Ccharacter-method'></span><span id='topic+norm+2Cspam+2Cmissing-method'></span><span id='topic+norm+2Cnumeric+2Cmissing-method'></span><span id='topic+norm+2Cnumeric+2Ccharacter-method'></span><span id='topic+norm+2Cmatrix+2Cmissing-method'></span><span id='topic+norm+2Cmatrix+2Ccharacter-method'></span><span id='topic+t.spam'></span><span id='topic+ncol+2Cspam-method'></span><span id='topic+nrow+2Cspam-method'></span><span id='topic+dim+2CANY-method'></span><span id='topic+dim+2Cspam-method'></span><span id='topic++5B.spam'></span><span id='topic++5B+3C-.spam'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2Cspam+2Cmissing+2Cvector-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cmissing-method'></span><span id='topic++5B+3C-+2Cspam+2Cvector+2Cvector-method'></span><span id='topic++5B+3C-+2Cspam+2Cmatrix+2Cmissing-method'></span><span id='topic++5B+3C-+2Cspam+2Cmatrix+2Cmatrix-method'></span><span id='topic++5B+3C-+2Cspam+2Cspam+2Cmissing-method'></span><span id='topic++5B+3C-+2Cspam+2CANY+2CANY-method'></span><span id='topic+plot.spam'></span><span id='topic+subset.spam'></span><span id='topic+assign.spam'></span>

<h3>Description</h3>

<p>Basic linear algebra operations for sparse matrices
of class <code>spam</code>.
</p>


<h3>Details</h3>

<p>Linear algebra operations for matrices of class
<code>spam</code> are designed to behave exactly as for
regular matrices.  In particular, matrix multiplication, transpose, addition,
subtraction and various logical operations should work as with the conventional
dense form of matrix storage, as does indexing, rbind, cbind, and diagonal
assignment and extraction (see for example <code><a href="#topic+diag">diag</a></code>).
Further functions with identical behavior are <code>dim</code> and thus <code>nrow</code>, <code>ncol</code>.
</p>
<p>The function <code>norm</code> calculates the (matrix-)norm of the argument.
The argument <code>type</code> specifies the <code>l1</code> norm, <code>sup</code> or max
norm (default), or the Frobenius or Hilbert-Schmidt
(<code>frobenius/hs</code>) norm. Partial matching can be used. For example,
<code>norm</code> is used to check for symmetry in the function <code>chol</code> by
computing the norm of the difference between the matrix and its
transpose
</p>
<p>The operator <code>%d*%</code> efficiently multiplies a diagonal matrix (in
vector form) and a sparse matrix and is used for compatibility with the
package fields. More specifically, this method is used in the internal
functions of <code>Krig</code> to make the code more readable. It avoids
having a branch in the source code to handle the diagonal or nondiagonal
cases.  Note that this operator is not symmetric: a vector in
the left argument is interpreted as a diagonal matrix and a vector in
the right argument is kept as a column vector.
</p>
<p>The operator <code>%d+%</code> efficiently adds a diagonal matrix (in vector
form) and a sparse matrix, similarly to the operator <code>%d+%</code>.
</p>


<h3>References</h3>

<p>Some Fortran functions are based on
<a href="https://github.com/johannesgerer/jburkardt-f/blob/master/sparsekit/sparsekit.html">https://github.com/johannesgerer/jburkardt-f/blob/master/sparsekit/sparsekit.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spam">spam</a></code> for coercion and other class relations involving the
sparse matrix classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a weight matrix and scale it:
## Not run: 
wij &lt;- distmat
# with distmat from a nearest.dist(..., upper=TRUE) call

n &lt;- dim(wij)[1]

wij@entries &lt;- kernel( wij@entries, h) # for some function kernel
wij &lt;- wij + t(wij) + diag.spam(n)     # adjust from diag=FALSE, upper=TRUE

sumwij &lt;- wij %*% rep(1,n)
    # row scaling:
    #   wij@entries &lt;- wij@entries/sumwij[ wij@colindices]
    # col scaling:
wij@entries &lt;- wij@entries/sumwij[ rep(1:n, diff(wij@rowpointers))]

## End(Not run)
</code></pre>

<hr>
<h2 id='spam-solve'>Linear Equation Solving for Sparse Matrices</h2><span id='topic+solve'></span><span id='topic+backsolve'></span><span id='topic+forwardsolve'></span><span id='topic+backsolve-methods'></span><span id='topic+backsolve+2CANY-method'></span><span id='topic+backsolve+2Cspam-method'></span><span id='topic+backsolve+2Cmatrix-method'></span><span id='topic+backsolve.spam'></span><span id='topic+forwardsolve-methods'></span><span id='topic+forwardsolve+2CANY-method'></span><span id='topic+forwardsolve+2Cspam-method'></span><span id='topic+forwardsolve+2Cmatrix-method'></span><span id='topic+forwardsolve.spam'></span><span id='topic+chol2inv'></span><span id='topic+chol2inv.spam'></span><span id='topic+chol2inv+2Cspam-method'></span><span id='topic+chol2inv+2Cspam.chol.NgPeyton-method'></span><span id='topic+solve.spam'></span><span id='topic+solve+2CANY-method'></span><span id='topic+solve+2Cspam-method'></span>

<h3>Description</h3>

<p><code>backsolve</code> and <code>forwardsolve</code> solve a system
of linear equations where the coefficient matrix
is upper or lower triangular.
<br />
<code>solve</code> solves a linear system or computes the inverse
of a matrix if the right-hand-side is missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spam'
solve(a, b, Rstruct=NULL, ...)
## S4 method for signature 'spam'
backsolve(r, x, ...)
## S4 method for signature 'spam'
forwardsolve(l, x, ...)
## S4 method for signature 'spam'
chol2inv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spam-solve_+3A_a">a</code></td>
<td>
<p>symmetric positive definite matrix of class <code>spam</code> or a Cholesky factor
as the result of a <code>chol</code> call.</p>
</td></tr>
<tr><td><code id="spam-solve_+3A_l">l</code>, <code id="spam-solve_+3A_r">r</code></td>
<td>
<p>object of class <code>spam</code> or <code>spam.chol.</code><em>method</em> returned by the function
<code>chol</code>.</p>
</td></tr>
<tr><td><code id="spam-solve_+3A_x">x</code>, <code id="spam-solve_+3A_b">b</code></td>
<td>
<p>vector or regular matrix of right-hand-side(s) of a system of linear equations.</p>
</td></tr>
<tr><td><code id="spam-solve_+3A_rstruct">Rstruct</code></td>
<td>
<p>the Cholesky structure of <code>a</code>.</p>
</td></tr>
<tr><td><code id="spam-solve_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, see
&lsquo;Details&rsquo; below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We can solve <code>A %*% x = b</code> by first computing the Cholesky decomposition <code>A =
  t(R)%*%R)</code>, then solving <code>t(R)%*%y = b</code> for <code>y</code>, and
finally solving <code>R%*%x = y</code> for <code>x</code>.
<code>solve</code> combines <code>chol</code>, a Cholesky decomposition of a
symmetric positive definite sparse matrix, with <code>forwardsolve</code> and
then <code>backsolve</code>.<br />
</p>
<p>In case <code>a</code> is from a <code>chol</code> call, then <code>solve</code> is an
efficient way to calculate <code>backsolve(a, forwardsolve( t(a), b))</code>.
</p>
<p>However, for <code>a.spam</code> and <code>a.mat</code> from a <code>chol</code> call
with a sparse and ordinary matrix,  note that
<code>forwardsolve( a.mat, b, transpose=T, upper.tri=T)</code>
is equivalent to
<code>forwardsolve( t(a.mat), b)</code>
and <code>backsolve(a.spam, forwardsolve(a.spam, b, transpose=T, upper.tri=T))</code>
yields the desired result. But
<code>backsolve(a.spam,forwardsolve(t(a.spam), resid))</code> is
wrong because  <code>t(a.spam)</code> is a <code>spam</code> and not a
<code>spam.chol.NgPeyton</code> object.
</p>
<p><code>forwardsolve</code> and <code>backsolve</code> solve a system of linear
equations where the coefficient matrix is lower (<code>forwardsolve</code>) or
upper (<code>backsolve</code>) triangular.  Usually, the triangular matrix is
result from a <code>chol</code> call and it is not required to transpose it
for <code>forwardsolve</code>.  Note that arguments of the default
methods <code>k</code>, <code>upper.tri</code> and <code>transpose</code> do not have any
effects here.
</p>
<p>Notice that it is more efficient to solve successively the linear
equations (both triangular solves) than to implement these in the
Fortran code.
</p>
<p>If the right-hand-side in <code>solve</code> is missing it will compute
the inverse of a matrix. For details about the specific Cholsesky
decomposition, see <code><a href="#topic+chol">chol</a></code>.
</p>
<p>Recall that the Cholesky factors are from ordered matrices.
</p>
<p><code>chol2inv(x)</code> is a faster way to <code>solve(x)</code>.
</p>


<h3>Note</h3>

<p>There is intentionally no <abbr><span class="acronym">S3</span></abbr> distinction between the classes
<code>spam</code> and <code>spam.chol.</code><em>method</em>.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer, based on Ng and Peyton (1993) Fortran routines</p>


<h3>References</h3>

<p>See references in <code><a href="#topic+chol">chol</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chol.spam">chol.spam</a></code> and <code><a href="#topic+ordering">ordering</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate multivariate form a covariance inverse:
# (usefull for GRMF)
set.seed(13)
n &lt;- 25    # dimension
N &lt;- 1000  # sample size
Sigmainv &lt;- .25^abs(outer(1:n,1:n,"-"))
Sigmainv &lt;- as.spam( Sigmainv, eps=1e-4)


Sigma &lt;- solve( Sigmainv)  # for verification
iidsample &lt;- array(rnorm(N*n),c(n,N))

mvsample &lt;- backsolve( chol(Sigmainv), iidsample)
norm( var(t(mvsample)) - Sigma)

# compare with:
mvsample &lt;- backsolve( chol(as.matrix( Sigmainv)), iidsample, n)
   #### ,n as patch
norm( var(t(mvsample)) - Sigma)



# 'solve' step by step:
b &lt;- rnorm( n)
R &lt;- chol(Sigmainv)
norm( backsolve( R, forwardsolve( R, b))-
      solve( Sigmainv, b) )
norm( backsolve( R, forwardsolve( R, diag(n)))- Sigma )


# 'update':
R1 &lt;- update( R, Sigmainv + diag.spam( n))



</code></pre>

<hr>
<h2 id='spam.chol.NgPeyton-class'>Class &quot;spam.chol.NgPeyton&quot;</h2><span id='topic+spam.chol.NgPeyton-class'></span><span id='topic+as.matrix+2Cspam.chol.NgPeyton-method'></span><span id='topic+as.spam+2Cspam.chol.NgPeyton-method'></span><span id='topic+backsolve+2Cspam.chol.NgPeyton-method'></span><span id='topic+c+2Cspam.chol.NgPeyton-method'></span><span id='topic+determinant+2Cspam.chol.NgPeyton-method'></span><span id='topic+diag+2Cspam.chol.NgPeyton-method'></span><span id='topic+diag+3C-+2Cspam.chol.NgPeyton-method'></span><span id='topic+dim+3C-+2Cspam.chol.NgPeyton-method'></span><span id='topic+dim+2Cspam.chol.NgPeyton-method'></span><span id='topic+display+2Cspam.chol.NgPeyton-method'></span><span id='topic+forwardsolve+2Cspam.chol.NgPeyton-method'></span><span id='topic+image+2Cspam.chol.NgPeyton-method'></span><span id='topic+length+3C-+2Cspam.chol.NgPeyton-method'></span><span id='topic+length+2Cspam.chol.NgPeyton-method'></span><span id='topic+ordering+2Cspam.chol.NgPeyton-method'></span><span id='topic+print+2Cspam.chol.NgPeyton-method'></span><span id='topic+show+2Cspam.chol.NgPeyton-method'></span><span id='topic+summary+2Cspam.chol.NgPeyton-method'></span><span id='topic+t+2Cspam.chol.NgPeyton-method'></span><span id='topic+chol+2Cspam.chol.NgPeyton-method'></span>

<h3>Description</h3>

<p>Result of a Cholesky decomposition with the <code>NgPeyton</code>
method</p>


<h3>Details</h3>

<p>It is not possible to directly change the length, dimension and the
diagonal entries of a <code>"spam.chol.NgPeyton"</code> object. 
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls of the form <code>chol(x,method="NgPeyton", ...)</code>
and should not be created directly with a
<code>new("spam.chol.NgPeyton", ...)</code> call.<br />
At present, no proper print method is defined. However, the factor can
be transformed into a <code>spam</code> object.
</p>


<h3>Methods</h3>


<dl>
<dt>as.matrix</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Transform the factor
into a regular matrix. </p>
</dd>
<dt>as.spam</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>:  Transform the factor
into a <code>spam</code> object.</p>
</dd>
<dt>backsolve</dt><dd><p><code>signature(r = "spam.chol.NgPeyton")</code>: solving
a triangular system, see <code><a href="#topic+solve">solve</a></code>. </p>
</dd>
<dt>forwardsolve</dt><dd><p><code>signature(l = "spam.chol.NgPeyton")</code>: solving
a triangular system, see <code><a href="#topic+solve">solve</a></code>. </p>
</dd>
<dt>c</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Coerce the factor into a vector. </p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>:
Calculates the determinant from the factor, see also <code><a href="#topic+det">det</a></code>. </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Extracts the
diagonal entries.</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Retrieve the
dimension. Note that <code>"dim&lt;-"</code> is not implemented.</p>
</dd>
<dt>display</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Transformation
to a <code>spam</code> object and display, see also <code><a href="#topic+display">display</a></code>. </p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Transformation
to a <code>spam</code> object and display, see also <code><a href="#topic+image">image</a></code>. </p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Retrieve the
dimension. Note that <code>"length&lt;-"</code> is not implemented. </p>
</dd>
<dt>ordering</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>:
Retrieves the ordering, in <code><a href="#topic+ordering">ordering</a></code>. </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Short description. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "spam.chol.NgPeyton")</code>: Short description. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "spam.chol.NgPeyton")</code>:
Description of the factor, returns (as a list) <code>nnzR</code>, <code>nnzcolindices</code>,
the density of the factor <code>density</code>, and fill-in ratio
<code>fillin</code>. For the use of the first two, see &lsquo;Examples&rsquo;
in <code><a href="#topic+chol">chol</a></code>.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Transformation
to a <code>spam</code> object and transposition. </p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "spam.chol.NgPeyton")</code>: Returns
<code>x</code> unchanged. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>References</h3>

<p>Ng, E. G. and B. W. Peyton (1993), &quot;Block sparse Cholesky algorithms
on advanced uniprocessor computers&quot;, <em>SIAM J. Sci. Comput.</em>, <b>14</b>,
pp. 1034-1056.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.spam">print.spam</a></code>
<code><a href="#topic+ordering">ordering</a></code> and <code><a href="#topic+chol">chol</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- spam( c(4,3,0,3,5,1,0,1,4),3)
cf &lt;- chol( x)
cf
as.spam( cf)


# Modify at own risk...
slotNames(cf)

</code></pre>

<hr>
<h2 id='Summary'>Rounding of Numbers</h2><span id='topic+Summary'></span><span id='topic+Summary.spam'></span><span id='topic+Summary+2Cspam-method'></span><span id='topic+all.spam'></span><span id='topic+any.spam'></span><span id='topic+max.spam'></span><span id='topic+min.spam'></span><span id='topic+prod.spam'></span><span id='topic+range.spam'></span><span id='topic+sum.spam'></span><span id='topic+all+2Cspam-method'></span><span id='topic+any+2Cspam-method'></span><span id='topic+max+2Cspam-method'></span><span id='topic+min+2Cspam-method'></span><span id='topic+prod+2Cspam-method'></span><span id='topic+range+2Cspam-method'></span><span id='topic+sum+2Cspam-method'></span>

<h3>Description</h3>

<p>Applies the <code>Math2</code> group functions to <code>spam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'># max(x,..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary_+3A_x">x</code></td>
<td>
<p>spam object.</p>
</td></tr>
<tr><td><code id="Summary_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be
removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>na.rm</code> argument is only meaninful if <code>NAOK=TRUE</code>.
</p>


<h3>Value</h3>

<p>If <code>structurebased=TRUE</code>, all functions operate on the vector <code>x@entries</code> and return the
result thereof.<br />
Conversely, if <code>structurebased=FALSE</code>, the result is identical to
one with <code>as.matrix(x)</code> input.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="#topic+Math.spam">Math.spam</a></code> and <code><a href="#topic+Math2">Math2</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>getGroupMembers("Summary")

smat &lt;- diag.spam( runif(15))
range(smat)
options(spam.structurebased=FALSE)
range(smat)

## Not run: 
max( log(spam(c(1,-1))), na.rm=TRUE)

## End(Not run)
# allow 'NA's first:
# TODO
# options(spam.NAOK=TRUE)
# max( log(spam(c(1,-1))), na.rm=TRUE)
</code></pre>

<hr>
<h2 id='toeplitz'>Create Toeplitz Matrices</h2><span id='topic+toeplitz.spam'></span>

<h3>Description</h3>

<p>Creates symmetric and asymmetric Toeplitz matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>toeplitz.spam(x, y = NULL, eps = getOption("spam.eps"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toeplitz_+3A_x">x</code></td>
<td>
<p>the first row to form the Toeplitz matrix.</p>
</td></tr>
<tr><td><code id="toeplitz_+3A_y">y</code></td>
<td>
<p>for asymmetric Toeplitz matrices, this contains the first
column.</p>
</td></tr>
<tr><td><code id="toeplitz_+3A_eps">eps</code></td>
<td>
<p>A tolerance parameter:  elements of <code>x</code> such that <code>abs(x)
    &lt;= eps</code> set to zero. Defaults to <code>eps = getOption("spam.eps")</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The vector <code>y</code> has to be of the same length as <code>x</code>
and its first element is discarded. 
</p>


<h3>Value</h3>

<p>The Toeplitz matrix in <code>spam</code> format.</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+toeplitz">toeplitz</a></code>, <code><a href="#topic+circulant.spam">circulant.spam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>toeplitz.spam(c(1,.25,0,0,0))

</code></pre>

<hr>
<h2 id='triplet'>Transform a &quot;spam&quot; Format to Triplets</h2><span id='topic+triplet'></span>

<h3>Description</h3>

<p>Returns a list containing the indices and elements of a  <code>spam</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>triplet(x, tri=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triplet_+3A_x">x</code></td>
<td>
<p>sparse matrix of class <code>spam</code> or a matrix.</p>
</td></tr>
<tr><td><code id="triplet_+3A_tri">tri</code></td>
<td>
<p>Boolean indicating whether to create individual row and
column  indices vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The elements are row (column) first if <code>x</code> is a <code>spam</code> object (matrix).<br />
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>indices</code></td>
<td>
<p>a by two matrix containing the indices if
<code>tri=FALSE</code>.</p>
</td></tr>
<tr><td><code>i</code>, <code>j</code></td>
<td>
<p>vectors  containing the row and column indices if <code>tri=TRUE</code>.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>a vector containing the matrix elements.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

 <p><code><a href="#topic+spam.creation">spam.creation</a></code> for the inverse operation and
<code>foreign</code> for other transformations.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- diag.spam(1:4)
x[2,3] &lt;- 5
triplet(x)
all.equal( spam( triplet(x, tri=TRUE)), x)

</code></pre>

<hr>
<h2 id='UScounties'>Adjacency Structure of the Counties in the Contiguous United States</h2><span id='topic+UScounties'></span><span id='topic+UScounties.storder'></span><span id='topic+UScounties.ndorder'></span>

<h3>Description</h3>

<p>First and second order adjacency structure of the counties
in the contiguous United States. We consider that two counties
are neighbors if they share at
least one edge of their polygon description in <code>maps</code>.
</p>


<h3>Format</h3>

<p>Two matrices of class <code>spam</code>
</p>

<dl>
<dt>UScounties.storder</dt><dd>
<p>Contains a one in the <code>i</code> and <code>j</code> element if  county
<code>i</code> is a neighbor of county <code>j</code>.
</p>
</dd>
<dt>UScounties.ndorder</dt><dd>
<p>Contains a one in the <code>i</code> and <code>j</code> element if  counties
<code>i</code> and <code>j</code> are a neighbors of county <code>k</code> and counties
<code>i</code> and <code>j</code>  are not  neighbors.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>map</code>, from <span class="pkg">maps</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of counties:
n  &lt;- nrow( UScounties.storder)

## Not run: 
# make a precision matrix
Q &lt;- diag.spam( n) + .2 * UScounties.storder + .1 * UScounties.ndorder
display( as.spam( chol( Q)))

## End(Not run)
</code></pre>

<hr>
<h2 id='USprecip'>Monthly Total Precipitation (mm) for April 1948 in the Contiguous United States</h2><span id='topic+USprecip'></span>

<h3>Description</h3>

<p>This is a useful spatial data set of moderate to large size consisting of 11918
locations. See <a href="https://www.image.ucar.edu/GSP/Data/US.monthly.met/">https://www.image.ucar.edu/GSP/Data/US.monthly.met/</a> for the source of these data.
</p>


<h3>Format</h3>

<p>This data set is an array containing the following columns:
</p>

<dl>
<dt>lon,lat</dt><dd>
<p>Longitude-latitude position of monitoring stations.
</p>
</dd>
<dt>raw</dt><dd>
<p>Monthly total precipitation in millimeters for April 1948.
</p>
</dd>
<dt>anomaly</dt><dd>
<p>Preipitation anomaly for April 1948.
</p>
</dd>
<dt>infill</dt><dd>
<p>Indicator, which station values were observed (5906 out of the 11918)
compared to which were estimated.
</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.image.ucar.edu/GSP/Data/US.monthly.met/">https://www.image.ucar.edu/GSP/Data/US.monthly.met/</a></p>


<h3>References</h3>

<p>Johns, C., Nychka, D., Kittel, T., and Daly, C. (2003)
Infilling sparse records of spatial fields.
<em>Journal of the American Statistical Association</em>,
98, 796&ndash;806.
</p>


<h3>See Also</h3>

<p><code><a href="fields.html#topic+RMprecip">RMprecip</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># plot
## Not run: 
library(fields)

data(USprecip)
par(mfcol=c(2,1))
quilt.plot(USprecip[,1:2],USprecip[,3])
US( add=TRUE, col=2, lty=2)
quilt.plot(USprecip[,1:2],USprecip[,4])
US( add=TRUE, col=2, lty=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='validate_spam'>Validate a Sparse Matrix</h2><span id='topic+validate_spam'></span>

<h3>Description</h3>

<p>Checks if the sparse matrix has the correct structure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_spam(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_spam_+3A_object">object</code></td>
<td>
<p>a spam matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>object</code> is a valid spam objects. </p>


<h3>See Also</h3>

<p><code><a href="#topic+spam.creation">spam.creation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>validate_spam(spam(1, 20))
</code></pre>

<hr>
<h2 id='version'>Spam Version Information</h2><span id='topic+version'></span><span id='topic+spam.version'></span><span id='topic+spam.Version'></span>

<h3>Description</h3>

<p><code>spam.version</code> is a variable (<code>list</code>) holding
detailed information about the version of
<code>spam</code> loaded.
</p>
<p><code>spam.Version()</code> provides detailed information about the version of <code>spam</code>
running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spam.version
</code></pre>


<h3>Value</h3>

<p><code>spam.version</code> is a list with character-string components
</p>
<table>
<tr><td><code>status</code></td>
<td>
<p>the status of the version (e.g., <code>"beta"</code>)</p>
</td></tr>
<tr><td><code>major</code></td>
<td>
<p>the major version number</p>
</td></tr>
<tr><td><code>minor</code></td>
<td>
<p>the minor version number</p>
</td></tr>
<tr><td><code>year</code></td>
<td>
<p>the year the version was released</p>
</td></tr>
<tr><td><code>month</code></td>
<td>
<p>the month the version was released</p>
</td></tr>
<tr><td><code>day</code></td>
<td>
<p>the day the version was released</p>
</td></tr>
<tr><td><code>version.string</code></td>
<td>
<p>a <code>character</code> string concatenating
the info  above, useful for plotting, etc.</p>
</td></tr>
</table>
<p><code>spam.version</code> is a list of class <code>"simple.list"</code> which
has a <code>print</code> method.
</p>


<h3>Author(s)</h3>

<p>Reinhard Furrer</p>


<h3>See Also</h3>

<p>See the R counterparts  <code><a href="base.html#topic+R.version">R.version</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spam.version$version.string
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
