<!DOCTYPE html><html><head><title>Help for package netUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_adj_list1'><p>Adjacency list</p></a></li>
<li><a href='#as_adj_weighted'><p>weighted dense adjacency matrix</p></a></li>
<li><a href='#as_multi_adj'><p>Convert a list of graphs to an adjacency matrices</p></a></li>
<li><a href='#bipartite_from_data_frame'><p>two-mode network from a data.frame</p></a></li>
<li><a href='#clique_vertex_mat'><p>Clique Vertex Matrix</p></a></li>
<li><a href='#core_periphery'><p>Discrete core-periphery model</p></a></li>
<li><a href='#dyad_census_attr'><p>dyad census with node attributes</p></a></li>
<li><a href='#fast_cliques'><p>Find Cliques, maximal or not, fast</p></a></li>
<li><a href='#graph_cartesian'><p>Cartesian product of two graphs</p></a></li>
<li><a href='#graph_cor'><p>Graph correlation</p></a></li>
<li><a href='#graph_direct'><p>Direct product of two graphs</p></a></li>
<li><a href='#graph_from_multi_edgelist'><p>Multiple networks from a single edgelist with a typed attribute</p></a></li>
<li><a href='#graph_kpartite'><p>k partite graphs</p></a></li>
<li><a href='#graph_to_sage'><p>convert igraph object to sage format</p></a></li>
<li><a href='#helpers'><p>helper function</p></a></li>
<li><a href='#reciprocity_cor'><p>Reciprocity correlation coefficient</p></a></li>
<li><a href='#sample_coreseq'><p>Generate random graphs with a given coreness sequence</p></a></li>
<li><a href='#sample_lfr'><p>LFR benchmark graphs</p></a></li>
<li><a href='#sample_pa_homophilic'><p>Homophilic random graph using BA preferential attachment model</p></a></li>
<li><a href='#split_graph'><p>split graph</p></a></li>
<li><a href='#str.igraph'><p>Print graphs to terminal</p></a></li>
<li><a href='#structural_equivalence'><p>Maximal Structural Equivalence</p></a></li>
<li><a href='#triad_census_attr'><p>triad census with node attributes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Collection of Tools for Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of network analytic (convenience) functions which are missing in other standard packages. This includes triad census with attributes &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2019.04.003">doi:10.1016/j.socnet.2019.04.003</a>&gt;, core-periphery models &lt;<a href="https://doi.org/10.1016%2FS0378-8733%2899%2900019-2">doi:10.1016/S0378-8733(99)00019-2</a>&gt;, and several graph generators. Most functions are build upon 'igraph'.  </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schochastics/netUtils/">https://github.com/schochastics/netUtils/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schochastics/netUtils/issues">https://github.com/schochastics/netUtils/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, igraph, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, GA, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-28 20:55:06 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schoch &lt;david@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 16:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_adj_list1'>Adjacency list</h2><span id='topic+as_adj_list1'></span>

<h3>Description</h3>

<p>Create adjacency lists from a graph, either for adjacent edges or for neighboring vertices. This version is faster than the version of igraph but less general.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_list1(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adj_list1_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function does not have a mode parameter and only returns the adjacency list comparable to as_adj_list(g,mode=&quot;all)
</p>


<h3>Value</h3>

<p>A list of numeric vectors.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_ring(10)
as_adj_list1(g)
</code></pre>

<hr>
<h2 id='as_adj_weighted'>weighted dense adjacency matrix</h2><span id='topic+as_adj_weighted'></span>

<h3>Description</h3>

<p>returns the weighted adjacency matrix in dense format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_weighted(g, attr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adj_weighted_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="as_adj_weighted_+3A_attr">attr</code></td>
<td>
<p>Either NULL or a character string giving an edge attribute name. If NULL a traditional adjacency matrix is returned. If not NULL then the values of the given edge attribute are included in the adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is faster than as_adj from igraph if you need the weighted adjacency matrix in dense format
</p>


<h3>Value</h3>

<p>Numeric matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(10, 0.2)
E(g)$weight &lt;- runif(ecount(g))
as_adj_weighted(g, attr="weight")
</code></pre>

<hr>
<h2 id='as_multi_adj'>Convert a list of graphs to an adjacency matrices</h2><span id='topic+as_multi_adj'></span>

<h3>Description</h3>

<p>Convenience function that turns a list of igraph objects into adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_multi_adj(g_lst, attr = NULL, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_multi_adj_+3A_g_lst">g_lst</code></td>
<td>
<p>A list of igraph object</p>
</td></tr>
<tr><td><code id="as_multi_adj_+3A_attr">attr</code></td>
<td>
<p>Either NULL or a character string giving an edge attribute name. If NULL a binary adjacency matrix is returned.</p>
</td></tr>
<tr><td><code id="as_multi_adj_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to create a sparse matrix. The 'Matrix' package must be installed for creating sparse matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of numeric matrices
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='bipartite_from_data_frame'>two-mode network from a data.frame</h2><span id='topic+bipartite_from_data_frame'></span>

<h3>Description</h3>

<p>Create a two-mode network from a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite_from_data_frame(d, type1, type2, attr = NULL, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite_from_data_frame_+3A_d">d</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="bipartite_from_data_frame_+3A_type1">type1</code></td>
<td>
<p>column name of mode 1</p>
</td></tr>
<tr><td><code id="bipartite_from_data_frame_+3A_type2">type2</code></td>
<td>
<p>column name of mode 2</p>
</td></tr>
<tr><td><code id="bipartite_from_data_frame_+3A_attr">attr</code></td>
<td>
<p>named list of edge attributes</p>
</td></tr>
<tr><td><code id="bipartite_from_data_frame_+3A_weighted">weighted</code></td>
<td>
<p>should a weighted graph be created if multiple edges occur</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two mode network as igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
edges &lt;- data.frame(mode1=1:5,mode2=letters[1:5])
bipartite_from_data_frame(edges,"mode1","mode2")
</code></pre>

<hr>
<h2 id='clique_vertex_mat'>Clique Vertex Matrix</h2><span id='topic+clique_vertex_mat'></span>

<h3>Description</h3>

<p>Creates the clique vertex matrix with entries (i,j) equal to one if node j is in clique i
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clique_vertex_mat(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clique_vertex_mat_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(10,0.2)
clique_vertex_mat(g)
</code></pre>

<hr>
<h2 id='core_periphery'>Discrete core-periphery model</h2><span id='topic+core_periphery'></span>

<h3>Description</h3>

<p>Fits a discrete core-periphery model to a given network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>core_periphery(graph, method = "rk1_dc", iter = 500, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="core_periphery_+3A_graph">graph</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="core_periphery_+3A_method">method</code></td>
<td>
<p>algorithm to use (see details)</p>
</td></tr>
<tr><td><code id="core_periphery_+3A_iter">iter</code></td>
<td>
<p>number of iterations if <code>method=GA</code></p>
</td></tr>
<tr><td><code id="core_periphery_+3A_...">...</code></td>
<td>
<p>other parameters for GA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits the data to an optimal pattern matrix with a genetic algorithm (method=&quot;GA&quot;) or a rank 1 approximation, either with degree centrality (method=&quot;rk1_dc&quot;) or eigenvector centrality (method=&quot;rk1_ec&quot;) . The rank 1 approximation is computationally far cheaper but also more experimental. Best is to compare the results from both models.
</p>


<h3>Value</h3>

<p>list with numeric vector with entries (k1,k2,...ki...) where ki assigns vertex i to either the core (ki=1) or periphery (ki=0), and the maximal correlation with an optimal pattern matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Borgatti, Stephen P., and Martin G. Everett. &quot;Models of core/periphery structures.&quot; Social networks 21.4 (2000): 375-395.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(121)
#split graphs have a perfect core-periphery structure
sg &lt;- split_graph(n = 20, p = 0.3,core = 0.5)
core_periphery(sg)
</code></pre>

<hr>
<h2 id='dyad_census_attr'>dyad census with node attributes</h2><span id='topic+dyad_census_attr'></span>

<h3>Description</h3>

<p>dyad census with node attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyad_census_attr(g, vattr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyad_census_attr_+3A_g">g</code></td>
<td>
<p>igraph object. should be a directed graph.</p>
</td></tr>
<tr><td><code id="dyad_census_attr_+3A_vattr">vattr</code></td>
<td>
<p>name of vertex attribute to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The node attribute should be integers from 1 to max(attr)
</p>


<h3>Value</h3>

<p>dyad census as a data.frame.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(10,0.4,directed = TRUE)
V(g)$attr &lt;- c(rep(1,5),rep(2,5))
dyad_census_attr(g,"attr")
</code></pre>

<hr>
<h2 id='fast_cliques'>Find Cliques, maximal or not, fast</h2><span id='topic+fast_cliques'></span>

<h3>Description</h3>

<p>Enumerates all (maximal) cliques using MACE. Can be faster than igraph in some circumstances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_cliques(g, what = "M", min = NULL, max = NULL, outfile = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_cliques_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="fast_cliques_+3A_what">what</code></td>
<td>
<p>either &quot;M&quot; for maximal cliques or &quot;C&quot; for all cliques</p>
</td></tr>
<tr><td><code id="fast_cliques_+3A_min">min</code></td>
<td>
<p>Numeric constant, lower limit on the size of the cliques to find. NULL means no limit, ie. it is the same as 0</p>
</td></tr>
<tr><td><code id="fast_cliques_+3A_max">max</code></td>
<td>
<p>Numeric constant, upper limit on the size of the cliques to find. NULL means no limit</p>
</td></tr>
<tr><td><code id="fast_cliques_+3A_outfile">outfile</code></td>
<td>
<p>character. If not NA, cliques are written to file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>C Code downloaded from http://research.nii.ac.jp/~uno/codes.htm. Download the code and run make and then point an environment variable called MACE_PATH to the binary. See http://research.nii.ac.jp/~uno/code/mace.html for more details. MACE is faster than igraph for dense graphs.
</p>


<h3>Value</h3>

<p>a list containing numeric vectors of vertex ids. Each list element is a clique. If outfile!=NA, the output is written to the specified file
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Kazuhisa Makino, Takeaki Uno, &quot;New Algorithms for Enumerating All Maximal Cliques&quot;, Lecture Notes in Computer Science 3111 (Proceedings of SWAT 2004), Springer, pp.260-272, 2004
</p>

<hr>
<h2 id='graph_cartesian'>Cartesian product of two graphs</h2><span id='topic+graph_cartesian'></span>

<h3>Description</h3>

<p>Compute the Cartesian product of two graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_cartesian(g, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_cartesian_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="graph_cartesian_+3A_h">h</code></td>
<td>
<p>An igraph object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://en.wikipedia.org/wiki/Cartesian_product_of_graphs
</p>


<h3>Value</h3>

<p>Cartesian product as igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_ring(4)
h &lt;- make_full_graph(2)
graph_cartesian(g,h)
</code></pre>

<hr>
<h2 id='graph_cor'>Graph correlation</h2><span id='topic+graph_cor'></span><span id='topic+graph_cor.default'></span><span id='topic+graph_cor.igraph'></span><span id='topic+graph_cor.matrix'></span><span id='topic+graph_cor.array'></span>

<h3>Description</h3>

<p>This function computes the correlation between networks. Implemented methods expect
the graph to be an adjacency matrix, an igraph, or a network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_cor(object1, object2)

## Default S3 method:
graph_cor(object1, object2)

## S3 method for class 'igraph'
graph_cor(object1, object2, ...)

## S3 method for class 'matrix'
graph_cor(object1, object2)

## S3 method for class 'array'
graph_cor(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_cor_+3A_object1">object1</code></td>
<td>
<p>igraph object or adjacency matrix</p>
</td></tr>
<tr><td><code id="graph_cor_+3A_object2">object2</code></td>
<td>
<p>igraph object or adjacency matrix over the same vertex set as object1</p>
</td></tr>
<tr><td><code id="graph_cor_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation between graphs
</p>

<hr>
<h2 id='graph_direct'>Direct product of two graphs</h2><span id='topic+graph_direct'></span>

<h3>Description</h3>

<p>Compute the direct product of two graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_direct(g, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_direct_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="graph_direct_+3A_h">h</code></td>
<td>
<p>An igraph object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://en.wikipedia.org/wiki/Tensor_product_of_graphs
</p>


<h3>Value</h3>

<p>Direct product as igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_ring(4)
h &lt;- make_full_graph(2)
graph_direct(g,h)
</code></pre>

<hr>
<h2 id='graph_from_multi_edgelist'>Multiple networks from a single edgelist with a typed attribute</h2><span id='topic+graph_from_multi_edgelist'></span>

<h3>Description</h3>

<p>Create a list of igraph objects from an edgelist according to a type attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_multi_edgelist(
  d,
  from = NULL,
  to = NULL,
  type = NULL,
  weight = NULL,
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_multi_edgelist_+3A_d">d</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="graph_from_multi_edgelist_+3A_from">from</code></td>
<td>
<p>column name of sender. If NULL, defaults to first column.</p>
</td></tr>
<tr><td><code id="graph_from_multi_edgelist_+3A_to">to</code></td>
<td>
<p>column of receiver. If NULL, defaults to second column.</p>
</td></tr>
<tr><td><code id="graph_from_multi_edgelist_+3A_type">type</code></td>
<td>
<p>type attribute to split the edgelist. If NULL, defaults to third column.</p>
</td></tr>
<tr><td><code id="graph_from_multi_edgelist_+3A_weight">weight</code></td>
<td>
<p>optional column name of edge weights. Ignored if NULL.</p>
</td></tr>
<tr><td><code id="graph_from_multi_edgelist_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether or not to create a directed graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of igraph objects.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
d &lt;- data.frame(from=rep(c(1,2,3),3),to=rep(c(2,3,1),3),
                type=rep(c("a","b","c"),each=3),weight=1:9)
graph_from_multi_edgelist(d,"from","to","type","weight")
</code></pre>

<hr>
<h2 id='graph_kpartite'>k partite graphs</h2><span id='topic+graph_kpartite'></span>

<h3>Description</h3>

<p>Create a random k-partite graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_kpartite(n = 10, grp = c(5, 5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_kpartite_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="graph_kpartite_+3A_grp">grp</code></td>
<td>
<p>vector of partition sizes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3-partite graph with equal sized groups
graph_kpartite(n = 15, grp = c(5,5,5))
</code></pre>

<hr>
<h2 id='graph_to_sage'>convert igraph object to sage format</h2><span id='topic+graph_to_sage'></span>

<h3>Description</h3>

<p>convert igraph object to sage format to be read in SAGE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_to_sage(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_to_sage_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sage string
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='helpers'>helper function</h2><span id='topic+helpers'></span><span id='topic+biggest_component'></span><span id='topic+delete_isolates'></span>

<h3>Description</h3>

<p>small functions to deal with typical network problems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biggest_component(g)

delete_isolates(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='reciprocity_cor'>Reciprocity correlation coefficient</h2><span id='topic+reciprocity_cor'></span>

<h3>Description</h3>

<p>Reciprocity correlation coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity_cor(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_cor_+3A_g">g</code></td>
<td>
<p>igraph object. should be a directed graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual definition of reciprocity has some defects. It cannot tell the relative difference of reciprocity compared with purely random network with the same number of vertices and edges.
The useful information from reciprocity is not the value itself, but whether mutual links occur more or less often than expected by chance.
</p>
<p>To overcome this issue, reciprocity can be defined as the correlation coefficient between the entries of the adjacency matrix of a directed graph:
</p>
<p style="text-align: center;"><code class="reqn">
 \frac{\sum_{i\neq j} (a_{ij} - a')((a_{ji} - a')}{\sum_{i\neq j} (a_{ij} - a')^2}
</code>
</p>

<p>where a' is the density of g.
</p>
<p>This definition gives an absolute quantity which directly allows one to distinguish between reciprocal (&gt;0) and antireciprocal (&lt; 0) networks, with mutual links occurring more and less often than random respectively.
</p>


<h3>Value</h3>

<p>Reciprocity as a correlation
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Diego Garlaschelli; Loffredo, Maria I. (2004). &quot;Patterns of Link Reciprocity in Directed Networks&quot;. Physical Review Letters. American Physical Society. 93 (26): 268701
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(20,p = 0.3,directed = TRUE)
reciprocity(g)
reciprocity_cor(g)
</code></pre>

<hr>
<h2 id='sample_coreseq'>Generate random graphs with a given coreness sequence</h2><span id='topic+sample_coreseq'></span>

<h3>Description</h3>

<p>Similar to <a href="igraph.html#topic+sample_degseq">sample_degseq</a> just with <a href="igraph.html#topic+coreness">coreness</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_coreseq(cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_coreseq_+3A_cores">cores</code></td>
<td>
<p>coreness sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code is an adaption of the python code from https://github.com/ktvank/Random-Graphs-with-Prescribed-K-Core-Sequences/
</p>


<h3>Value</h3>

<p>igraph object of graph with the same coreness sequence as the input
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Van Koevering, Katherine, Austin R. Benson, and Jon Kleinberg. 2021. ‘Random Graphs with Prescribed K-Core Sequences: A New Null Model for Network Analysis’. ArXiv:2102.12604. https://doi.org/10.1145/3442381.3450001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g1 &lt;- make_graph("Zachary")
kcores1 &lt;- coreness(g1)
g2 &lt;- sample_coreseq(kcores1)
kcores2 &lt;- coreness(g2)

#the sorted arrays are the same
all(sort(kcores1)==sort(kcores2))

</code></pre>

<hr>
<h2 id='sample_lfr'>LFR benchmark graphs</h2><span id='topic+sample_lfr'></span>

<h3>Description</h3>

<p>Generates benchmark networks for clustering tasks with a priori known communities. The algorithm accounts for the heterogeneity in the distributions of node degrees and of community sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_lfr(
  n,
  tau1,
  tau2,
  mu,
  average_degree = NULL,
  max_degree = NULL,
  min_community = NULL,
  max_community = NULL,
  on = 0,
  om = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_lfr_+3A_n">n</code></td>
<td>
<p>Number of nodes in the created graph.</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_tau1">tau1</code></td>
<td>
<p>Power law exponent for the degree distribution of the created graph. This value must be strictly greater than one</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_tau2">tau2</code></td>
<td>
<p>Power law exponent for the community size distribution in the created graph. This value must be strictly greater than one</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_mu">mu</code></td>
<td>
<p>Fraction of inter-community edges incident to each node. This value must be in the interval 0 to 1.</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_average_degree">average_degree</code></td>
<td>
<p>Desired average degree of nodes in the created graph. This value must be in the interval 0 to n. Exactly one of this and <code>min_degree</code> must be specified, otherwise an error is raised</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_max_degree">max_degree</code></td>
<td>
<p>Maximum degree of nodes in the created graph. If not specified, this is set to n-1.</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_min_community">min_community</code></td>
<td>
<p>Minimum size of communities in the graph. If not specified, this is set to <code>min_degree</code></p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_max_community">max_community</code></td>
<td>
<p>Maximum size of communities in the graph. If not specified, this is set to n, the total number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_on">on</code></td>
<td>
<p>number of overlapping nodes</p>
</td></tr>
<tr><td><code id="sample_lfr_+3A_om">om</code></td>
<td>
<p>number of memberships of the overlapping nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>code adapted from <a href="https://github.com/synwalk/synwalk-analysis/tree/master/lfr_generator">https://github.com/synwalk/synwalk-analysis/tree/master/lfr_generator</a>
</p>


<h3>Value</h3>

<p>an igraph object
</p>


<h3>References</h3>

<p>A. Lancichinetti, S. Fortunato, and F. Radicchi.(2008) Benchmark graphs for testing community detection algorithms. Physical Review E, 78. arXiv:0805.4770
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple Girven-Newman benchmark graphs
g &lt;- sample_lfr(n = 128,average_degree = 16,
                max_degree = 16,mu = 0.1,
                min_community = 32,max_community = 32)
</code></pre>

<hr>
<h2 id='sample_pa_homophilic'>Homophilic random graph using BA preferential attachment model</h2><span id='topic+sample_pa_homophilic'></span>

<h3>Description</h3>

<p>A graph of n nodes is grown by attaching new nodes each with m
edges that are preferentially attached to existing nodes with high
degree, depending on the homophily parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_pa_homophilic(
  n,
  m,
  minority_fraction,
  h_ab,
  h_ba = NULL,
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_pa_homophilic_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="sample_pa_homophilic_+3A_m">m</code></td>
<td>
<p>number of edges a new node is connected to</p>
</td></tr>
<tr><td><code id="sample_pa_homophilic_+3A_minority_fraction">minority_fraction</code></td>
<td>
<p>fraction of nodes that belong to the minority group</p>
</td></tr>
<tr><td><code id="sample_pa_homophilic_+3A_h_ab">h_ab</code></td>
<td>
<p>probability to connect a node from group a with groub b</p>
</td></tr>
<tr><td><code id="sample_pa_homophilic_+3A_h_ba">h_ba</code></td>
<td>
<p>probability to connect a node from group b with groub a. If NULL, h_ab is used.</p>
</td></tr>
<tr><td><code id="sample_pa_homophilic_+3A_directed">directed</code></td>
<td>
<p>should a directed network be created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code is an adaption of the python code from https://github.com/gesiscss/HomophilicNtwMinorities/
</p>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
#maximally heterophilic network
sample_pa_homophilic(n = 50, m = 2,minority_fraction = 0.2,h_ab = 1)
#maximally homophilic network
sample_pa_homophilic(n = 50, m = 2,minority_fraction = 0.2,h_ab = 0)
</p>


<h3>References</h3>

<p>Karimi, F., Génois, M., Wagner, C., Singer, P., &amp; Strohmaier, M. (2018). Homophily influences ranking of minorities in social networks. Scientific reports, 8(1), 1-12. (https://www.nature.com/articles/s41598-018-29405-7)
</p>
<p>Espín-Noboa, L., Wagner, C., Strohmaier, M., &amp; Karimi, F. (2022). Inequality and inequity in network-based ranking and recommendation algorithms. Scientific reports, 12(1), 1-14. (https://www.nature.com/articles/s41598-022-05434-1)
</p>

<hr>
<h2 id='split_graph'>split graph</h2><span id='topic+split_graph'></span>

<h3>Description</h3>

<p>Create a random split graph with a perfect core-periphery structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_graph(n, p, core)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_graph_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="split_graph_+3A_p">p</code></td>
<td>
<p>probability of peripheral nodes to connect to the core nodes</p>
</td></tr>
<tr><td><code id="split_graph_+3A_core">core</code></td>
<td>
<p>fraction of nodes in the core</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#split graph with 20 nodes and a core size of 10
split_graph(n = 20, p = 0.4, 0.5)
</code></pre>

<hr>
<h2 id='str.igraph'>Print graphs to terminal</h2><span id='topic+str.igraph'></span>

<h3>Description</h3>

<p>Prints an igraph object to terminal (different than the standard igraph method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
str(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str.igraph_+3A_object">object</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="str.igraph_+3A_...">...</code></td>
<td>
<p>additional arguments to print (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>str does not return anything. The obvious side effect is output to the terminal.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='structural_equivalence'>Maximal Structural Equivalence</h2><span id='topic+structural_equivalence'></span>

<h3>Description</h3>

<p>Calculates structural equivalence for an undirected graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structural_equivalence(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structural_equivalence_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two nodes u and v are structurally equivalent if they have exactly the same neighbors. The equivalence classes produced with this function are either cliques or empty graphs.
</p>


<h3>Value</h3>

<p>vector of equivalence classes
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='triad_census_attr'>triad census with node attributes</h2><span id='topic+triad_census_attr'></span>

<h3>Description</h3>

<p>triad census with node attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad_census_attr(g, vattr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triad_census_attr_+3A_g">g</code></td>
<td>
<p>igraph object. should be a directed graph</p>
</td></tr>
<tr><td><code id="triad_census_attr_+3A_vattr">vattr</code></td>
<td>
<p>name of vertex attribute to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The node attribute should be integers from 1 to max(attr).
The output is a named vector where the names are of the form Txxx-abc, where xxx corresponds to the standard triad census notation and &quot;abc&quot; are the attributes of the involved nodes.
</p>
<p>The implemented algorithm is comparable to the algorithm in Lienert et al.
</p>


<h3>Value</h3>

<p>triad census with node attributes
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Lienert, J., Koehly, L., Reed-Tsochas, F., &amp; Marcum, C. S. (2019). An efficient counting method for the colored triad census. Social Networks, 58, 136-142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
set.seed(112)
g &lt;- sample_gnp(20,p = 0.3,directed = TRUE)
# add a vertex attribute
V(g)$type &lt;- rep(1:2,each = 10)
triad_census_attr(g,"type")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
