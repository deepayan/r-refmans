<!DOCTYPE html><html lang="en"><head><title>Help for package networkscaleup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {networkscaleup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#networkscaleup-package'><p>The 'networkscaleup' package.</p></a></li>
<li><a href='#correlatedStan'><p>Fit ARD using the uncorrelated or correlated model in Stan</p>
This function fits the ARD using either the uncorrelated or correlated model
in Laga et al. (2021) in Stan. The population size estimates and degrees are
scaled using a post-hoc procedure.</a></li>
<li><a href='#example_data'><p>Simulated ARD data set with z and x.</p></a></li>
<li><a href='#killworth'><p>Fit Killworth models to ARD. This function estimates the degrees and</p>
population sizes using the plug-in MLE and MLE estimator.</a></li>
<li><a href='#overdispersed'><p>Fit Overdispersed model to ARD (Gibbs-Metropolis)</p></a></li>
<li><a href='#overdispersedStan'><p>Fit ARD using the Overdispersed model in Stan</p></a></li>
<li><a href='#scaling'><p>Scale raw log degree and log prevalence estimates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Network Scale-Up Models for Aggregated Relational Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a variety of Network Scale-up Models for researchers to analyze Aggregated Relational Data, mostly through the use of Stan. In this version, the package implements models from Laga, I., Bao, L., and Niu, X (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2109.10204">doi:10.48550/arXiv.2109.10204</a>&gt;, Zheng, T., Salganik, M. J., and Gelman, A. (2006) &lt;<a href="https://doi.org/10.1198%2F016214505000001168">doi:10.1198/016214505000001168</a>&gt;, Killworth, P. D., Johnsen, E. C., McCarty, C., Shelley, G. A., and Bernard, H. R. (1998) &lt;<a href="https://doi.org/10.1016%2FS0378-8733%2896%2900305-X">doi:10.1016/S0378-8733(96)00305-X</a>&gt;, and Killworth, P. D., McCarty, C., Bernard, H. R., Shelley, G. A., and Johnsen, E. C. (1998) &lt;<a href="https://doi.org/10.1177%2F0193841X9802200205">doi:10.1177/0193841X9802200205</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.26.0), rstantools (&ge; 2.1.1), LaplacesDemon (&ge; 16.1.6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 21:57:54 UTC; samidhashetty</td>
</tr>
<tr>
<td>Author:</td>
<td>Ian Laga <a href="https://orcid.org/0000-0002-5164-4856"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Le Bao [aut],
  Xiaoyue Niu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ian Laga &lt;ilaga25@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-25 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='networkscaleup-package'>The 'networkscaleup' package.</h2><span id='topic+networkscaleup-package'></span><span id='topic+networkscaleup'></span>

<h3>Description</h3>

<p>Provides a variety of Network Scale-up Models for researchers to
analyze Aggregated Relational Data, mostly through the use of Stan.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ian Laga <a href="mailto:ilaga25@gmail.com">ilaga25@gmail.com</a> (<a href="https://orcid.org/0000-0002-5164-4856">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Le Bao <a href="mailto:lebao@psu.edu">lebao@psu.edu</a>
</p>
</li>
<li><p> Xiaoyue Niu <a href="mailto:Xiaoyue@psu.edu">Xiaoyue@psu.edu</a>
</p>
</li></ul>



<h3>References</h3>

<p>Stan Development Team (2021). RStan: the R interface to Stan. R
package version 2.21.3. https://mc-stan.org
</p>
<p>Laga, I., Bao, L., and Niu, X (2021). A Correlated Network Scaleup Model:
Finding the Connection Between Subpopulations
</p>
<p>Zheng, T., Salganik, M. J., and Gelman, A. (2006). How many people do you
know in prison, <em>Journal of the American Statistical Association</em>,
<b>101:474</b>, 409&ndash;423
</p>
<p>Killworth, P. D., Johnsen, E. C., McCarty, C., Shelley, G. A., and Bernard,
H. R. (1998). A Social Network Approach to Estimating Seroprevalence in the
United States, <em>Social Networks</em>, <b>20</b>, 23&ndash;50
</p>
<p>Killworth, P. D., McCarty, C., Bernard, H. R., Shelley, G. A., and Johnsen,
E. C. (1998). Estimation of Seroprevalence, Rape and Homelessness in the
United States Using a Social Network Approach, <em>Evaluation Review</em>,
<b>22</b>, 289&ndash;308
</p>

<hr>
<h2 id='correlatedStan'>Fit ARD using the uncorrelated or correlated model in Stan
This function fits the ARD using either the uncorrelated or correlated model
in Laga et al. (2021) in Stan. The population size estimates and degrees are
scaled using a post-hoc procedure.</h2><span id='topic+correlatedStan'></span>

<h3>Description</h3>

<p>Fit ARD using the uncorrelated or correlated model in Stan
This function fits the ARD using either the uncorrelated or correlated model
in Laga et al. (2021) in Stan. The population size estimates and degrees are
scaled using a post-hoc procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlatedStan(
  ard,
  known_sizes = NULL,
  known_ind = NULL,
  N = NULL,
  model = c("correlated", "uncorrelated"),
  scaling = c("all", "overdispersed", "weighted", "weighted_sq"),
  x = NULL,
  z_global = NULL,
  z_subpop = NULL,
  G1_ind = NULL,
  G2_ind = NULL,
  B2_ind = NULL,
  chains = 3,
  cores = 1,
  warmup = 1000,
  iter = 1500,
  thin = 1,
  return_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlatedStan_+3A_ard">ard</code></td>
<td>
<p>The 'n_i x n_k' matrix of non-negative ARD integer responses,
where the '(i,k)th' element corresponds to the number of people that
respondent 'i' knows in subpopulation 'k'.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_known_sizes">known_sizes</code></td>
<td>
<p>The known subpopulation sizes corresponding to a subset of
the columns of <code>ard</code>.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_known_ind">known_ind</code></td>
<td>
<p>The indices that correspond to the columns of <code>ard</code>
with known_sizes. By default, the function assumes the first <code>n_known</code>
columns, where <code>n_known</code> corresponds to the number of
<code>known_sizes</code>.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_n">N</code></td>
<td>
<p>The known total population size.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_model">model</code></td>
<td>
<p>A character vector denoting which of the two models should be
fit, either 'uncorrelated' or 'correlated'. More details of these models
are provided below. The function decides which covariate model is needed
based on the covariates provided below.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_scaling">scaling</code></td>
<td>
<p>An optional character vector providing the name of scaling
procedure should be performed in order to transform estimates to degrees
and subpopulation sizes. If 'NULL', the parameters will be returned
unscaled. Alternatively, scaling may be performed independently using the
<a href="#topic+scaling">scaling</a> function. Scaling options are 'NULL',
'overdispersed', 'all', 'weighted', or 'weighted_sq' ('weighted' and
'weighted_sq' are only available if 'model = &quot;correlated&quot;'. Further details
are provided in the Details section.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions 'n_i x n_unknown', where 'n_unknown' refers
to the number of unknown subpopulation sizes. In the language of Teo et al.
(2019), these represent the individual's perception of each hidden
population.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_z_global">z_global</code></td>
<td>
<p>A matrix with dimensions 'n_i x p_global', where 'p_global'
is the number of demographic covariates used. This matrix represents the
demographic information about the respondents in order to capture the
barrier effects.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_z_subpop">z_subpop</code></td>
<td>
<p>A matrix with dimensions 'n_i x p_subpop', where 'p_subpop'
is the number of demographic covariates used. This matrix represents the
demographic information about the respondents in order to capture the
barrier effects.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_g1_ind">G1_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the primary scaling groups, i.e. the collection of rare
girls' names in Zheng, Salganik, and Gelman (2006). By default, all
known_sizes are used. If G2_ind and B2_ind are not provided, 'C = C_1', so
only G1_ind are used. If G1_ind is not provided, no scaling is performed.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_g2_ind">G2_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the subpopulations that belong to the first secondary scaling
groups, i.e. the collection of somewhat popular girls' names.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_b2_ind">B2_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the subpopulations that belong to the second secondary
scaling groups, i.e. the collection of somewhat popular boys' names.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_cores">cores</code></td>
<td>
<p>A positive integer specifying the number of cores to use to run
the Markov chains in parallel.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the total number of samples for
each chain (including warmup). Matches the usage in <a href="rstan.html#topic+stan">stan</a>.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of warmup samples for
each chain. Matches the usage in <a href="rstan.html#topic+stan">stan</a>.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the interval for saving posterior
samples. Default value is 1 (i.e. no thinning).</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_return_fit">return_fit</code></td>
<td>
<p>A logical indicating whether the fitted 'stanfit' object
should be return. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="correlatedStan_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <a href="rstan.html#topic+stan">stan</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently fits a variety of models proposed in Laga et
al. (2022+). The user may provide any combination of 'x', 'z_global', and
'z_subpop'. Additionally, the user may choose to fit a uncorrelated version
of the model, where the correlation matrix is equal to the identity matrix.
</p>
<p>The 'scaling' options are described below: </p>
<dl>
<dt>NULL</dt><dd><p>No scaling
is performed</p>
</dd> <dt>overdispersed</dt><dd><p>The scaling procedure outlined in Zheng
et al. (2006) is performed. In this case, at least 'Pg1_ind' must be
provided. See <a href="#topic+overdispersedStan">overdispersedStan</a> for more details.</p>
</dd>
<dt>all</dt><dd><p>All subpopulations with known sizes are used to scale the
parameters, using a modified scaling procedure that standardizes the sizes
so each population is weighted equally. Additional details are provided in
Laga et al. (2022+).</p>
</dd> <dt>weighted</dt><dd><p>All subpopulations with known sizes
are weighted according their correlation with the unknown subpopulation
size. Additional details are provided in Laga et al. (2022+)</p>
</dd>
<dt>weighted_sq</dt><dd><p>Same as 'weighted', except the weights are squared,
providing more relative weight to subpopulations with higher correlation.</p>
</dd></dl>



<h3>Value</h3>

<p>Either the full fitted Stan model if <code>return_fit = TRUE</code>, else a
named list with the estimated parameters extracted using
<a href="rstan.html#topic+extract">extract</a> (the default). The estimated parameters are named as
follows (if estimated in the corresponding model), with additional
descriptions as needed:
</p>
<dl>
<dt>delta</dt><dd><p>Raw delta parameters</p>
</dd> <dt>sigma_delta</dt><dd><p>Standard
deviation of delta</p>
</dd> <dt>rho</dt><dd><p>Log prevalence, if scaled, else raw rho
parameters</p>
</dd> <dt>mu_rho</dt><dd><p>Mean of rho</p>
</dd> <dt>sigma_rho</dt><dd><p>Standard deviation
of rho</p>
</dd> <dt>alpha</dt><dd><p>Slope parameters corresponding to z</p>
</dd>
<dt>beta_global</dt><dd><p>Slope parameters corresponding to x_global</p>
</dd>
<dt>beta_subpop</dt><dd><p>Slope parameters corresponding to x_subpop</p>
</dd>
<dt>tau_N</dt><dd><p>Standard deviation of random effects b</p>
</dd>
<dt>Corr</dt><dd><p>Correlation matrix, if 'Correlation = TRUE'</p>
</dd></dl>

<p>If scaled, the following additional parameters are included:
</p>
<dl>
<dt>log_degrees</dt><dd><p>Scaled log degrees</p>
</dd> <dt>degree</dt><dd><p>Scaled
degrees</p>
</dd> <dt>log_prevalences</dt><dd><p>Scaled log prevalences</p>
</dd>
<dt>sizes</dt><dd><p>Subpopulation size estimates</p>
</dd></dl>



<h3>References</h3>

<p>Laga, I., Bao, L., and Niu, X (2021). A Correlated Network
Scaleup Model: Finding the Connection Between Subpopulations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(example_data)

x = example_data$x
z_global = example_data$z[,1:2]
z_subpop = example_data$z[,3:4]

basic_corr_est = correlatedStan(example_data$ard,
     known_sizes = example_data$subpop_sizes[c(1, 2, 4)],
     known_ind = c(1, 2, 4),
     N = example_data$N,
     model = "correlated",
     scaling = "weighted",
     chains = 1,
     cores = 1,
     warmup = 50,
     iter = 100)

cov_uncorr_est = correlatedStan(example_data$ard,
     known_sizes = example_data$subpop_sizes[c(1, 2, 4)],
     known_ind = c(1, 2, 4),
     N = example_data$N,
     model = "uncorrelated",
     scaling = "all",
     x = x,
     z_global = z_global,
     z_subpop = z_subpop,
     chains = 1,
     cores = 1,
     warmup = 50,
     iter = 100)

cov_corr_est = correlatedStan(example_data$ard,
     known_sizes = example_data$subpop_sizes[c(1, 2, 4)],
     known_ind = c(1, 2, 4),
     N = example_data$N,
     model = "correlated",
     scaling = "all",
     x = x,
     z_subpop = z_subpop,
     chains = 1,
     cores = 1,
     warmup = 50,
     iter = 100)

# Compare size estimates
round(data.frame(true = example_data$subpop_sizes,
     corr_basic = colMeans(basic_corr_est$sizes),
     uncorr_x_zsubpop_zglobal = colMeans(cov_uncorr_est$sizes),
     corr_x_zsubpop = colMeans(cov_corr_est$sizes)))

# Look at z slope parameters
colMeans(cov_uncorr_est$beta_global)
colMeans(cov_corr_est$beta_subpop)
colMeans(cov_uncorr_est$beta_subpop)

# Look at x slope parameters
colMeans(cov_uncorr_est$alpha)
colMeans(cov_corr_est$alpha)

## End(Not run)
</code></pre>

<hr>
<h2 id='example_data'>Simulated ARD data set with z and x.</h2><span id='topic+example_data'></span>

<h3>Description</h3>

<p>A simulated data set to demonstrate and test the NSUM methods. The data was
simulated from the basic Killworth Binomial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data
</code></pre>


<h3>Format</h3>

<p>A named list for an ARD survey from 100 respondents about 5
subpopulations. </p>
 <dl>
<dt>ard</dt><dd><p>A '100 x 5' matrix with integer
valued respondents</p>
</dd> <dt>x</dt><dd><p>A '100 x 5' matrix with simulated answers from
a 1-5 Likert scale</p>
</dd> <dt>z</dt><dd><p>A '100 x 4' matrix with answers for each
respondents about 4 demographic questions</p>
</dd> <dt>N</dt><dd><p>An integer specifying
the total population size</p>
</dd> <dt>subpop_size</dt><dd><p>A vector with the 5 true
subpopulation sizes</p>
</dd> <dt>degrees</dt><dd><p>A vector with the 100 true respondent
degrees</p>
</dd></dl>


<hr>
<h2 id='killworth'>Fit Killworth models to ARD. This function estimates the degrees and
population sizes using the plug-in MLE and MLE estimator.</h2><span id='topic+killworth'></span>

<h3>Description</h3>

<p>Fit Killworth models to ARD. This function estimates the degrees and
population sizes using the plug-in MLE and MLE estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>killworth(
  ard,
  known_sizes = NULL,
  known_ind = 1:length(known_sizes),
  N = NULL,
  model = c("MLE", "PIMLE")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="killworth_+3A_ard">ard</code></td>
<td>
<p>The 'n_i x n_k' matrix of non-negative ARD integer responses,
where the '(i,k)th' element corresponds to the number of people that
respondent 'i' knows in subpopulation 'k'.</p>
</td></tr>
<tr><td><code id="killworth_+3A_known_sizes">known_sizes</code></td>
<td>
<p>The known subpopulation sizes corresponding to a subset of
the columns of <code>ard</code>.</p>
</td></tr>
<tr><td><code id="killworth_+3A_known_ind">known_ind</code></td>
<td>
<p>The indices that correspond to the columns of <code>ard</code>
with known_sizes. By default, the function assumes the first <code>n_known</code>
columns, where <code>n_known</code> corresponds to the number of
<code>known_sizes</code>.</p>
</td></tr>
<tr><td><code id="killworth_+3A_n">N</code></td>
<td>
<p>The known total population size.</p>
</td></tr>
<tr><td><code id="killworth_+3A_model">model</code></td>
<td>
<p>A character string corresponding to either the plug-in MLE
(PIMLE) or the MLE (MLE). The function assumes MLE by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the estimated degrees and sizes.
</p>


<h3>References</h3>

<p>Killworth, P. D., Johnsen, E. C., McCarty, C., Shelley, G. A.,
and Bernard, H. R. (1998). A Social Network Approach to Estimating
Seroprevalence in the United States, <em>Social Networks</em>, <b>20</b>,
23&ndash;50
</p>
<p>Killworth, P. D., McCarty, C., Bernard, H. R., Shelley, G. A., and Johnsen,
E. C. (1998). Estimation of Seroprevalence, Rape and Homelessness in the
United States Using a Social Network Approach, <em>Evaluation Review</em>,
<b>22</b>, 289&ndash;308
</p>
<p>Laga, I., Bao, L., and Niu, X. (2021). Thirty Years of the Network Scale-up
Method, <em>Journal of the American Statistical Association</em>,
<b>116:535</b>, 1548&ndash;1559
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Analyze an example ard data set using the killworth function
data(example_data)

ard = example_data$ard
subpop_sizes = example_data$subpop_sizes
N = example_data$N

mle.est = killworth(ard,
known_sizes = subpop_sizes[c(1, 2, 4)],
known_ind = c(1, 2, 4),
N = N, model = "MLE")

pimle.est = killworth(ard,
known_sizes = subpop_sizes[c(1, 2, 4)],
known_ind = c(1, 2, 4),
N = N, model = "PIMLE")

## Compare estimates with the truth
plot(mle.est$degrees, example_data$degrees)

data.frame(true = subpop_sizes[c(3, 5)],
mle = mle.est$sizes,
pimle = pimle.est$sizes)
</code></pre>

<hr>
<h2 id='overdispersed'>Fit Overdispersed model to ARD (Gibbs-Metropolis)</h2><span id='topic+overdispersed'></span>

<h3>Description</h3>

<p>This function fits the ARD using the Overdispersed model using the original
Gibbs-Metropolis Algorithm provided in Zheng, Salganik, and Gelman (2006).
The population size estimates and degrees are scaled using a post-hoc
procedure. For the Stan implementation, see
<a href="#topic+overdispersedStan">overdispersedStan</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overdispersed(
  ard,
  known_sizes = NULL,
  known_ind = NULL,
  G1_ind = NULL,
  G2_ind = NULL,
  B2_ind = NULL,
  N = NULL,
  warmup = 1000,
  iter = 1500,
  refresh = NULL,
  thin = 1,
  verbose = FALSE,
  alpha_tune = 0.4,
  beta_tune = 0.2,
  omega_tune = 0.2,
  init = "MLE"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overdispersed_+3A_ard">ard</code></td>
<td>
<p>The 'n_i x n_k' matrix of non-negative ARD integer responses,
where the '(i,k)th' element corresponds to the number of people that
respondent 'i' knows in subpopulation 'k'.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_known_sizes">known_sizes</code></td>
<td>
<p>The known subpopulation sizes corresponding to a subset of
the columns of <code>ard</code>.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_known_ind">known_ind</code></td>
<td>
<p>The indices that correspond to the columns of <code>ard</code>
with known_sizes. By default, the function assumes the first <code>n_known</code>
columns, where <code>n_known</code> corresponds to the number of
<code>known_sizes</code>.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_g1_ind">G1_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the primary scaling groups, i.e. the collection of rare
girls' names in Zheng, Salganik, and Gelman (2006). By default, all
known_sizes are used. If G2_ind and B2_ind are not provided, 'C = C_1', so
only G1_ind are used. If G1_ind is not provided, no scaling is performed.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_g2_ind">G2_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the subpopulations that belong to the first secondary scaling
groups, i.e. the collection of somewhat popular girls' names.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_b2_ind">B2_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the subpopulations that belong to the second secondary
scaling groups, i.e. the collection of somewhat popular boys' names.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_n">N</code></td>
<td>
<p>The known total population size.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup samples.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the total number of samples
(including warmup).</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_refresh">refresh</code></td>
<td>
<p>An integer specifying how often the progress of the sampling
should be reported. By default, resorts to every 10
<code>verbose = FALSE</code>.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the interval for saving posterior
samples. Default value is 1 (i.e. no thinning).</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, specifying whether sampling progress should be
reported.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_alpha_tune">alpha_tune</code></td>
<td>
<p>A positive numeric indicating the standard deviation used
as the jumping scale in the Metropolis step for alpha. Defaults to 0.4,
which has worked well for other ARD datasets.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_beta_tune">beta_tune</code></td>
<td>
<p>A positive numeric indicating the standard deviation used as
the jumping scale in the Metropolis step for beta Defaults to 0.2, which
has worked well for other ARD datasets.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_omega_tune">omega_tune</code></td>
<td>
<p>A positive numeric indicating the standard deviation used
as the jumping scale in the Metropolis step for omega Defaults to 0.2,
which has worked well for other ARD datasets.</p>
</td></tr>
<tr><td><code id="overdispersed_+3A_init">init</code></td>
<td>
<p>A named list with names corresponding to the first-level model
parameters, name 'alpha', 'beta', and 'omega'. By default the 'alpha' and
'beta' parameters are initialized at the values corresponding to the
Killworth MLE estimates (for the missing 'beta'), with all 'omega' set to
20. Alternatively, <code>init = 'random'</code> simulates 'alpha' and 'beta' from
a normal random variable with mean 0 and standard deviation 1. By default,
<code>init = 'MLE'</code> initializes values at the Killworth et al. (1998b) MLE
estimates for the degrees and sizes and simulates the other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the overdispersed NSUM model using the
Metropolis-Gibbs sampler provided in Zheng et al. (2006).
</p>


<h3>Value</h3>

<p>A named list with the estimated posterior samples. The estimated
parameters are named as follows, with additional descriptions as needed:
</p>
<dl>
<dt>alphas</dt><dd><p>Log degree, if scaled, else raw alpha parameters</p>
</dd>
<dt>betas</dt><dd><p>Log prevalence, if scaled, else raw beta parameters</p>
</dd>
<dt>inv_omegas</dt><dd><p>Inverse of overdispersion parameters</p>
</dd>
<dt>sigma_alpha</dt><dd><p>Standard deviation of alphas</p>
</dd> <dt>mu_beta</dt><dd><p>Mean of
betas</p>
</dd> <dt>sigma_beta</dt><dd><p>Standard deviation of betas</p>
</dd>
<dt>omegas</dt><dd><p>Overdispersion parameters</p>
</dd></dl>

<p>If scaled, the following additional parameters are included:
</p>
<dl>
<dt>mu_alpha</dt><dd><p>Mean of log degrees</p>
</dd> <dt>degrees</dt><dd><p>Degree
estimates</p>
</dd> <dt>sizes</dt><dd><p>Subpopulation size estimates</p>
</dd></dl>



<h3>References</h3>

<p>Zheng, T., Salganik, M. J., and Gelman, A. (2006). How many
people do you know in prison, <em>Journal of the American Statistical
Association</em>, <b>101:474</b>, 409&ndash;423
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Analyze an example ard data set using Zheng et al. (2006) models
# Note that in practice, both warmup and iter should be much higher
data(example_data)

ard = example_data$ard
subpop_sizes = example_data$subpop_sizes
known_ind = c(1, 2, 4)
N = example_data$N

overdisp.est = overdispersed(ard,
known_sizes = subpop_sizes[known_ind],
known_ind = known_ind,
G1_ind = 1,
G2_ind = 2,
B2_ind = 4,
N = N,
warmup = 50,
iter = 100)

# Compare size estimates
data.frame(true = subpop_sizes,
basic = colMeans(overdisp.est$sizes))

# Compare degree estimates
plot(example_data$degrees, colMeans(overdisp.est$degrees))

# Look at overdispersion parameter
colMeans(overdisp.est$omegas)
</code></pre>

<hr>
<h2 id='overdispersedStan'>Fit ARD using the Overdispersed model in Stan</h2><span id='topic+overdispersedStan'></span>

<h3>Description</h3>

<p>This function fits the ARD using the Overdispersed model in Stan. The
population size estimates and degrees are scaled using a post-hoc procedure.
For the Gibbs-Metropolis algorithm implementation, see
<a href="#topic+overdispersed">overdispersed</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overdispersedStan(
  ard,
  known_sizes = NULL,
  known_ind = NULL,
  G1_ind = NULL,
  G2_ind = NULL,
  B2_ind = NULL,
  N = NULL,
  chains = 3,
  cores = 1,
  warmup = 1000,
  iter = 1500,
  thin = 1,
  return_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overdispersedStan_+3A_ard">ard</code></td>
<td>
<p>The 'n_i x n_k' matrix of non-negative ARD integer responses,
where the '(i,k)th' element corresponds to the number of people that
respondent 'i' knows in subpopulation 'k'.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_known_sizes">known_sizes</code></td>
<td>
<p>The known subpopulation sizes corresponding to a subset of
the columns of <code>ard</code>.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_known_ind">known_ind</code></td>
<td>
<p>The indices that correspond to the columns of <code>ard</code>
with known_sizes. By default, the function assumes the first <code>n_known</code>
columns, where <code>n_known</code> corresponds to the number of
<code>known_sizes</code>.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_g1_ind">G1_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the primary scaling groups, i.e. the collection of rare
girls' names in Zheng, Salganik, and Gelman (2006). By default, all
known_sizes are used. If G2_ind and B2_ind are not provided, 'C = C_1', so
only G1_ind are used. If G1_ind is not provided, no scaling is performed.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_g2_ind">G2_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the subpopulations that belong to the first secondary scaling
groups, i.e. the collection of somewhat popular girls' names.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_b2_ind">B2_ind</code></td>
<td>
<p>A vector of indices denoting the columns of 'ard' that
correspond to the subpopulations that belong to the second secondary
scaling groups, i.e. the collection of somewhat popular boys' names.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_n">N</code></td>
<td>
<p>The known total population size.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_cores">cores</code></td>
<td>
<p>A positive integer specifying the number of cores to use to run
the Markov chains in parallel.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the total number of samples for
each chain (including warmup). Matches the usage in <a href="rstan.html#topic+stan">stan</a>.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of warmup samples for
each chain. Matches the usage in <a href="rstan.html#topic+stan">stan</a>.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the interval for saving posterior
samples. Default value is 1 (i.e. no thinning).</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_return_fit">return_fit</code></td>
<td>
<p>A logical indicating whether the fitted Stan model should
be returned instead of the rstan::extracted and scaled parameters. This is
FALSE by default.</p>
</td></tr>
<tr><td><code id="overdispersedStan_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <a href="rstan.html#topic+stan">stan</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the overdispersed NSUM model using the
Gibbs-Metropolis algorithm provided in Zheng et al. (2006).
</p>


<h3>Value</h3>

<p>Either the full fitted Stan model if <code>return_fit = TRUE</code>, else a
named list with the estimated parameters extracted using
<a href="rstan.html#topic+extract">extract</a> (the default). The estimated parameters are named as
follows, with additional descriptions as needed:
</p>
<dl>
<dt>alphas</dt><dd><p>Log degree, if 'scaling = TRUE', else raw alpha parameters</p>
</dd>
<dt>betas</dt><dd><p>Log prevalence, if 'scaling = TRUE', else raw beta parameters</p>
</dd>
<dt>inv_omegas</dt><dd><p>Inverse of overdispersion parameters</p>
</dd>
<dt>sigma_alpha</dt><dd><p>Standard deviation of alphas</p>
</dd>
<dt>mu_beta</dt><dd><p>Mean of betas</p>
</dd>
<dt>sigma_beta</dt><dd><p>Standard deviation of betas</p>
</dd>
<dt>omegas</dt><dd><p>Overdispersion parameters</p>
</dd></dl>

<p>If 'scaling = TRUE', the following additional parameters are included:
</p>
<dl>
<dt>mu_alpha</dt><dd><p>Mean of log degrees</p>
</dd>
<dt>degrees</dt><dd><p>Degree estimates</p>
</dd>
<dt>sizes</dt><dd><p>Subpopulation size estimates</p>
</dd></dl>



<h3>References</h3>

<p>Zheng, T., Salganik, M. J., and Gelman, A. (2006). How many
people do you know in prison, <em>Journal of the American Statistical
Association</em>, <b>101:474</b>, 409&ndash;423
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Analyze an example ard data set using Zheng et al. (2006) models
# Note that in practice, both warmup and iter should be much higher
## Not run: 
data(example_data)

ard = example_data$ard
subpop_sizes = example_data$subpop_sizes
known_ind = c(1, 2, 4)
N = example_data$N

overdisp.est = overdispersedStan(ard,
known_sizes = subpop_sizes[known_ind],
known_ind = known_ind,
G1_ind = 1,
G2_ind = 2,
B2_ind = 4,
N = N,
chains = 1,
cores = 1,
warmup = 250,
iter = 500)

# Compare size estimates
round(data.frame(true = subpop_sizes,
basic = colMeans(overdisp.est$sizes)))

# Compare degree estimates
plot(example_data$degrees, colMeans(overdisp.est$degrees))

# Look at overdispersion parameter
colMeans(overdisp.est$omegas)

## End(Not run)
</code></pre>

<hr>
<h2 id='scaling'>Scale raw log degree and log prevalence estimates</h2><span id='topic+scaling'></span>

<h3>Description</h3>

<p>This function scales estimates from either the overdispersed model or from
the correlated models. Several scaling options are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaling(
  log_degrees,
  log_prevalences,
  scaling = c("all", "overdispersed", "weighted", "weighted_sq"),
  known_sizes = NULL,
  known_ind = NULL,
  Correlation = NULL,
  G1_ind = NULL,
  G2_ind = NULL,
  B2_ind = NULL,
  N = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaling_+3A_log_degrees">log_degrees</code></td>
<td>
<p>The matrix of estimated raw log degrees from either the
overdispersed or correlated models.</p>
</td></tr>
<tr><td><code id="scaling_+3A_log_prevalences">log_prevalences</code></td>
<td>
<p>The matrix of estimates raw log prevalences from
either the overdispersed or correlated models.</p>
</td></tr>
<tr><td><code id="scaling_+3A_scaling">scaling</code></td>
<td>
<p>An character vector providing the name of scaling procedure
should be performed in order to transform estimates to degrees and
subpopulation sizes. Scaling options are 'overdispersed', 'all' (the
default), 'weighted', or 'weighted_sq' ('weighted' and 'weighted_sq' are
only available if 'Correlation' is provided. Further details are provided
in the Details section.</p>
</td></tr>
<tr><td><code id="scaling_+3A_known_sizes">known_sizes</code></td>
<td>
<p>The known subpopulation sizes corresponding to a subset of
the columns of <code>ard</code>.</p>
</td></tr>
<tr><td><code id="scaling_+3A_known_ind">known_ind</code></td>
<td>
<p>The indices that correspond to the columns of <code>ard</code>
with known_sizes. By default, the function assumes the first <code>n_known</code>
columns, where <code>n_known</code> corresponds to the number of
<code>known_sizes</code>.</p>
</td></tr>
<tr><td><code id="scaling_+3A_correlation">Correlation</code></td>
<td>
<p>The estimated correlation matrix used to calculate scaling
weights. Required if 'scaling = weighted' or 'scaling = weighted_sq'.</p>
</td></tr>
<tr><td><code id="scaling_+3A_g1_ind">G1_ind</code></td>
<td>
<p>If 'scaling = overdispersed', a vector of indices corresponding
to the subpopulations that belong to the primary scaling groups, i.e. the
collection of rare girls' names in Zheng, Salganik, and Gelman (2006). By
default, all known_sizes are used. If G2_ind and B2_ind are not provided,
'C = C_1', so only G1_ind are used. If G1_ind is not provided, no scaling
is performed.</p>
</td></tr>
<tr><td><code id="scaling_+3A_g2_ind">G2_ind</code></td>
<td>
<p>If 'scaling = overdispersed', a vector of indices corresponding
to the subpopulations that belong to the first secondary scaling groups,
i.e. the collection of somewhat popular girls' names.</p>
</td></tr>
<tr><td><code id="scaling_+3A_b2_ind">B2_ind</code></td>
<td>
<p>If 'scaling = overdispersed', a vector of indices corresponding
to the subpopulations that belong to the second secondary scaling groups,
i.e. the collection of somewhat popular boys' names.</p>
</td></tr>
<tr><td><code id="scaling_+3A_n">N</code></td>
<td>
<p>The known total population size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'scaling' options are described below: </p>
<dl>
<dt>NULL</dt><dd><p>No
scaling is performed</p>
</dd> <dt>overdispersed</dt><dd><p>The scaling procedure outlined
in Zheng et al. (2006) is performed. In this case, at least 'Pg1_ind' must
be provided. See <a href="#topic+overdispersedStan">overdispersedStan</a> for more
details.</p>
</dd> <dt>all</dt><dd><p>All subpopulations with known sizes are used to scale
the parameters, using a modified scaling procedure that standardizes the
sizes so each population is weighted equally. Additional details are
provided in Laga et al. (2021).</p>
</dd> <dt>weighted</dt><dd><p>All subpopulations with
known sizes are weighted according their correlation with the unknown
subpopulation size. Additional details are provided in Laga et al. (2021)</p>
</dd>
<dt>weighted_sq</dt><dd><p>Same as 'weighted', except the weights are squared,
providing more relative weight to subpopulations with higher correlation.</p>
</dd></dl>



<h3>Value</h3>

<p>The named list containing the scaled log degree, degree, log
prevalence, and size estimates
</p>


<h3>References</h3>

<p>Zheng, T., Salganik, M. J., and Gelman, A. (2006). How many
people do you know in prison, <em>Journal of the American Statistical
Association</em>, <b>101:474</b>, 409&ndash;423
</p>
<p>Laga, I., Bao, L., and Niu, X (2021). A Correlated Network Scaleup Model:
Finding the Connection Between Subpopulations
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
