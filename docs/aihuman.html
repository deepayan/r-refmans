<!DOCTYPE html><html><head><title>Help for package aihuman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aihuman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AiEvalmcmc'><p>Gibbs sampler for the main analysis</p></a></li>
<li><a href='#aihuman-package'><p>Experimental Evaluation of Algorithm-Assisted Human Decision-Making</p></a></li>
<li><a href='#APCEsummary'><p>Summary of APCE</p></a></li>
<li><a href='#APCEsummaryipw'><p>Summary of APCE for frequentist analysis</p></a></li>
<li><a href='#BootstrapAPCEipw'><p>Bootstrap for estimating variance of APCE</p></a></li>
<li><a href='#BootstrapAPCEipwRE'><p>Bootstrap for estimating variance of APCE with random effects</p></a></li>
<li><a href='#BootstrapAPCEipwREparallel'><p>Bootstrap for estimating variance of APCE with random effects</p></a></li>
<li><a href='#CalAPCE'><p>Calculate APCE</p></a></li>
<li><a href='#CalAPCEipw'><p>Compute APCE using frequentist analysis</p></a></li>
<li><a href='#CalAPCEipwRE'><p>Compute APCE using frequentist analysis with random effects</p></a></li>
<li><a href='#CalAPCEparallel'><p>Calculate APCE using parallel computing</p></a></li>
<li><a href='#CalDelta'><p>Calculate the delta given the principal stratum</p></a></li>
<li><a href='#CalDIM'><p>Calculate diff-in-means estimates</p></a></li>
<li><a href='#CalDIMsubgroup'><p>Calculate diff-in-means estimates</p></a></li>
<li><a href='#CalFairness'><p>Calculate the principal fairness</p></a></li>
<li><a href='#CalOptimalDecision'><p>Calculate optimal decision &amp; utility</p></a></li>
<li><a href='#CalPS'><p>Calculate the proportion of principal strata (R)</p></a></li>
<li><a href='#FTAdata'><p>Interim Dane data with failure to appear (FTA) as an outcome</p></a></li>
<li><a href='#g_legend'><p>Pulling ggplot legend</p></a></li>
<li><a href='#HearingDate'><p>Interim court event hearing date</p></a></li>
<li><a href='#hearingdate_synth'><p>Synthetic court event hearing date</p></a></li>
<li><a href='#NCAdata'><p>Interim Dane data with new criminal activity (NCA) as an outcome</p></a></li>
<li><a href='#NVCAdata'><p>Interim Dane data with new violent criminal activity (NVCA) as an outcome</p></a></li>
<li><a href='#PlotAPCE'><p>Plot APCE</p></a></li>
<li><a href='#PlotDIMdecisions'><p>Plot diff-in-means estimates</p></a></li>
<li><a href='#PlotDIMoutcomes'><p>Plot diff-in-means estimates</p></a></li>
<li><a href='#PlotFairness'><p>Plot the principal fairness</p></a></li>
<li><a href='#PlotOptimalDecision'><p>Plot optimal decision</p></a></li>
<li><a href='#PlotPS'><p>Plot the proportion of principal strata (R)</p></a></li>
<li><a href='#PlotSpilloverCRT'><p>Plot conditional randomization test</p></a></li>
<li><a href='#PlotSpilloverCRTpower'><p>Plot power analysis of conditional randomization test</p></a></li>
<li><a href='#PlotStackedBar'><p>Stacked barplot for the distribution of the decision given psa</p></a></li>
<li><a href='#PlotStackedBarDMF'><p>Stacked barplot for the distribution of the decision given DMF recommendation</p></a></li>
<li><a href='#PlotUtilityDiff'><p>Plot utility difference</p></a></li>
<li><a href='#PlotUtilityDiffCI'><p>Plot utility difference with 95% confidence interval</p></a></li>
<li><a href='#psa_synth'><p>Synthetic PSA data</p></a></li>
<li><a href='#PSAdata'><p>Interim Dane PSA data</p></a></li>
<li><a href='#SpilloverCRT'><p>Conduct conditional randomization test</p></a></li>
<li><a href='#SpilloverCRTpower'><p>Conduct power analysis of conditional randomization test</p></a></li>
<li><a href='#synth'><p>Synthetic data</p></a></li>
<li><a href='#TestMonotonicity'><p>Test monotonicity</p></a></li>
<li><a href='#TestMonotonicityRE'><p>Test monotonicity with random effects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Experimental Evaluation of Algorithm-Assisted Human
Decision-Making</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-22</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical methods for analyzing experimental 
    evaluation of the causal impacts of algorithmic recommendations 
    on human decisions developed by Imai, Jiang, Greiner, Halen, and 
    Shin (2023) &lt;<a href="https://doi.org/10.1093%2Fjrsssa%2Fqnad010">doi:10.1093/jrsssa/qnad010</a>&gt;.
    The data used for this paper, and made available here, are interim, 
    based on only half of the observations in the study and (for those 
    observations) only half of the study follow-up period. We use them 
    only to illustrate methods, not to draw substantive conclusions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sooahnshin/aihuman">https://github.com/sooahnshin/aihuman</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sooahnshin/aihuman/issues">https://github.com/sooahnshin/aihuman/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, coda, stats, magrittr, purrr, abind, foreach, parallel,
doParallel, ggplot2, dplyr, tidyr, metR, MASS, lme4</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-02 00:09:09 UTC; sooahn</td>
</tr>
<tr>
<td>Author:</td>
<td>Sooahn Shin <a href="https://orcid.org/0000-0001-6213-2197"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Zhichao Jiang [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sooahn Shin &lt;sooahnshin@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-02 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AiEvalmcmc'>Gibbs sampler for the main analysis</h2><span id='topic+AiEvalmcmc'></span>

<h3>Description</h3>

<p>See Appendix S5 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AiEvalmcmc(
  data,
  rho = 0,
  Sigma0.beta.inv = NULL,
  Sigma0.alpha.inv = NULL,
  sigma0 = NULL,
  beta = NULL,
  alpha = NULL,
  theta = NULL,
  delta = NULL,
  n.mcmc = 5 * 10,
  verbose = FALSE,
  out.length = 10,
  beta.zx.off = FALSE,
  theta.z.off = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AiEvalmcmc_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_rho">rho</code></td>
<td>
<p>A sensitivity parameter. The default is  <code>0</code> which implies the unconfoundedness assumption (Assumption 4).</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_sigma0.beta.inv">Sigma0.beta.inv</code></td>
<td>
<p>Inverse of the prior covariance matrix of beta. The default is a diagonal matrix with  <code>0.01</code> diagonal entries.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_sigma0.alpha.inv">Sigma0.alpha.inv</code></td>
<td>
<p>Inverse of the prior covariance matrix of alpha. The default is a diagonal matrix with  <code>0.01</code> diagonal entries.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_sigma0">sigma0</code></td>
<td>
<p>Prior variance of the cutoff points (theta and delta)</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_beta">beta</code></td>
<td>
<p>Initial value for beta.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_alpha">alpha</code></td>
<td>
<p>Initial value for alpha.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_theta">theta</code></td>
<td>
<p>Initial value for theta.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_delta">delta</code></td>
<td>
<p>Initial value for delta.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_n.mcmc">n.mcmc</code></td>
<td>
<p>The total number of MCMC iterations. The default is <code>50</code>.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument specified to print the progress on the screen. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_out.length">out.length</code></td>
<td>
<p>An integer to specify the progress on the screen. If <code>verbose = TRUE</code>, every <code>out.length</code>-th iteration is printed on the screen. The default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_beta.zx.off">beta.zx.off</code></td>
<td>
<p>A logical argument specified to exclude the interaction terms (Z by X) from the model. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="AiEvalmcmc_+3A_theta.z.off">theta.z.off</code></td>
<td>
<p>A logical argument specified to set same cutoffs theta for treatment and control group. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mcmc</code> containing the posterior samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 2)

</code></pre>

<hr>
<h2 id='aihuman-package'>Experimental Evaluation of Algorithm-Assisted Human Decision-Making</h2><span id='topic+aihuman-package'></span><span id='topic+aihuman'></span>

<h3>Description</h3>

<p>Provides statistical methods for analyzing experimental 
    evaluation of the causal impacts of algorithmic recommendations 
    on human decisions developed by Imai, Jiang, Greiner, Halen, and 
    Shin (2023) &lt;doi:10.1093/jrsssa/qnad010&gt;.
    The data used for this paper, and made available here, are interim, 
    based on only half of the observations in the study and (for those 
    observations) only half of the study follow-up period. We use them 
    only to illustrate methods, not to draw substantive conclusions.</p>


<h3>Package Content</h3>


<p>Index of help topics:
</p>
<pre>
APCEsummary             Summary of APCE
APCEsummaryipw          Summary of APCE for frequentist analysis
AiEvalmcmc              Gibbs sampler for the main analysis
BootstrapAPCEipw        Bootstrap for estimating variance of APCE
BootstrapAPCEipwRE      Bootstrap for estimating variance of APCE with
                        random effects
BootstrapAPCEipwREparallel
                        Bootstrap for estimating variance of APCE with
                        random effects
CalAPCE                 Calculate APCE
CalAPCEipw              Compute APCE using frequentist analysis
CalAPCEipwRE            Compute APCE using frequentist analysis with
                        random effects
CalAPCEparallel         Calculate APCE using parallel computing
CalDIM                  Calculate diff-in-means estimates
CalDIMsubgroup          Calculate diff-in-means estimates
CalDelta                Calculate the delta given the principal stratum
CalFairness             Calculate the principal fairness
CalOptimalDecision      Calculate optimal decision &amp; utility
CalPS                   Calculate the proportion of principal strata
                        (R)
FTAdata                 Interim Dane data with failure to appear (FTA)
                        as an outcome
HearingDate             Interim court event hearing date
NCAdata                 Interim Dane data with new criminal activity
                        (NCA) as an outcome
NVCAdata                Interim Dane data with new violent criminal
                        activity (NVCA) as an outcome
PSAdata                 Interim Dane PSA data
PlotAPCE                Plot APCE
PlotDIMdecisions        Plot diff-in-means estimates
PlotDIMoutcomes         Plot diff-in-means estimates
PlotFairness            Plot the principal fairness
PlotOptimalDecision     Plot optimal decision
PlotPS                  Plot the proportion of principal strata (R)
PlotSpilloverCRT        Plot conditional randomization test
PlotSpilloverCRTpower   Plot power analysis of conditional
                        randomization test
PlotStackedBar          Stacked barplot for the distribution of the
                        decision given psa
PlotStackedBarDMF       Stacked barplot for the distribution of the
                        decision given DMF recommendation
PlotUtilityDiff         Plot utility difference
PlotUtilityDiffCI       Plot utility difference with 95
                        interval
SpilloverCRT            Conduct conditional randomization test
SpilloverCRTpower       Conduct power analysis of conditional
                        randomization test
TestMonotonicity        Test monotonicity
TestMonotonicityRE      Test monotonicity with random effects
aihuman-package         Experimental Evaluation of Algorithm-Assisted
                        Human Decision-Making
g_legend                Pulling ggplot legend
hearingdate_synth       Synthetic court event hearing date
psa_synth               Synthetic PSA data
synth                   Synthetic data
</pre>

<h3>Maintainer</h3>

<p>NA</p>


<h3>Author(s)</h3>

<p>NA</p>

<hr>
<h2 id='APCEsummary'>Summary of APCE</h2><span id='topic+APCEsummary'></span>

<h3>Description</h3>

<p>Summary of average principal causal effects (APCE) with ordinal decision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APCEsummary(apce.mcmc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APCEsummary_+3A_apce.mcmc">apce.mcmc</code></td>
<td>
<p>APCE.mcmc array generated from <code>CalAPCE</code> or <code>CalAPCEparallel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> that consists of mean and quantiles (2.5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, subgroup = subgroup_synth)
sample_apce_summary = APCEsummary(sample_apce[["APCE.mcmc"]])


</code></pre>

<hr>
<h2 id='APCEsummaryipw'>Summary of APCE for frequentist analysis</h2><span id='topic+APCEsummaryipw'></span>

<h3>Description</h3>

<p>Summary of average principal causal effects (APCE) with ordinal decision with frequentist results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APCEsummaryipw(
  G1_est,
  G2_est,
  G3_est,
  G4_est,
  G5_est,
  G1_boot,
  G2_boot,
  G3_boot,
  G4_boot,
  G5_boot,
  name.group = c("Overall", "Female", "Male", "Non-white\nMale", "White\nMale")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APCEsummaryipw_+3A_g1_est">G1_est</code></td>
<td>
<p>List generated from <code>CalAPCEipw</code> for the first subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g2_est">G2_est</code></td>
<td>
<p>List generated from <code>CalAPCEipw</code> for the second subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g3_est">G3_est</code></td>
<td>
<p>List generated from <code>CalAPCEipw</code> for the third subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g4_est">G4_est</code></td>
<td>
<p>List generated from <code>CalAPCEipw</code> for the fourth subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g5_est">G5_est</code></td>
<td>
<p>List generated from <code>CalAPCEipw</code> for the fifth subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g1_boot">G1_boot</code></td>
<td>
<p>List generated from <code>BootstrapAPCEipw</code> for the first subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g2_boot">G2_boot</code></td>
<td>
<p>List generated from <code>BootstrapAPCEipw</code> for the second subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g3_boot">G3_boot</code></td>
<td>
<p>List generated from <code>BootstrapAPCEipw</code> for the third subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g4_boot">G4_boot</code></td>
<td>
<p>List generated from <code>BootstrapAPCEipw</code> for the fourth subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_g5_boot">G5_boot</code></td>
<td>
<p>List generated from <code>BootstrapAPCEipw</code> for the fifth subgroup.</p>
</td></tr>
<tr><td><code id="APCEsummaryipw_+3A_name.group">name.group</code></td>
<td>
<p>A list of character vectors for the label of five subgroups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> that consists of mean and quantiles (2.5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
synth$SexWhite = synth$Sex * synth$White
freq_apce = CalAPCEipw(synth)
boot_apce = BootstrapAPCEipw(synth, rep = 10)
# subgroup analysis
data_s0 = subset(synth, synth$Sex==0,select=-c(Sex,SexWhite))
freq_s0 = CalAPCEipw(data_s0)
boot_s0 = BootstrapAPCEipw(data_s0, rep = 10)
data_s1 = subset(synth, synth$Sex==1,select=-c(Sex,SexWhite))
freq_s1 = CalAPCEipw(data_s1)
boot_s1 = BootstrapAPCEipw(data_s1, rep = 10)
data_s1w0 = subset(synth, synth$Sex==1&amp;synth$White==0,select=-c(Sex,White,SexWhite))
freq_s1w0 = CalAPCEipw(data_s1w0)
boot_s1w0 = BootstrapAPCEipw(data_s1w0, rep = 10)
data_s1w1 = subset(synth, synth$Sex==1&amp;synth$White==1,select=-c(Sex,White,SexWhite))
freq_s1w1 = CalAPCEipw(data_s1w1)
boot_s1w1 = BootstrapAPCEipw(data_s1w1, rep = 10)

freq_apce_summary &lt;- APCEsummaryipw(freq_apce, freq_s0, freq_s1, freq_s1w0, freq_s1w1,
                                    boot_apce, boot_s0, boot_s1, boot_s1w0, boot_s1w0)
PlotAPCE(freq_apce_summary, y.max = 0.25, decision.labels = c("signature","small cash",
         "middle cash","large cash"), shape.values = c(16, 17, 15, 18), 
         col.values = c("blue", "black", "red", "brown", "purple"), label = FALSE)

</code></pre>

<hr>
<h2 id='BootstrapAPCEipw'>Bootstrap for estimating variance of APCE</h2><span id='topic+BootstrapAPCEipw'></span>

<h3>Description</h3>

<p>Estimate variance of APCE for frequentist analysis using bootstrap. See S7 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapAPCEipw(data, rep = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootstrapAPCEipw_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipw_+3A_rep">rep</code></td>
<td>
<p>Size of bootstrap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is rep (size of bootstrap), dimension 2 is (k+1) values of D from 0 to k, dimension 3 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R.boot</code></td>
<td>
<p>An array with dimension rep by (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
<tr><td><code>alpha.boot</code></td>
<td>
<p>An array with estimated alpha for each bootstrap.</p>
</td></tr>
<tr><td><code>delta.boot</code></td>
<td>
<p>An array with estimated delta for each bootstrap.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
set.seed(123)
boot_apce = BootstrapAPCEipw(synth, rep = 100)


</code></pre>

<hr>
<h2 id='BootstrapAPCEipwRE'>Bootstrap for estimating variance of APCE with random effects</h2><span id='topic+BootstrapAPCEipwRE'></span>

<h3>Description</h3>

<p>Estimate variance of APCE for frequentist analysis with random effects using bootstrap. See S7 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapAPCEipwRE(data, rep = 1000, formula, CourtEvent_HearingDate, nAGQ = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootstrapAPCEipwRE_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwRE_+3A_rep">rep</code></td>
<td>
<p>Size of bootstrap</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwRE_+3A_formula">formula</code></td>
<td>
<p>A formula of the model to fit.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwRE_+3A_courtevent_hearingdate">CourtEvent_HearingDate</code></td>
<td>
<p>The court event hearing date.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwRE_+3A_nagq">nAGQ</code></td>
<td>
<p>Integer scalar - the number of points per axis for evaluating the adaptive Gauss-Hermite approximation to the log-likelihood. Defaults to 1, corresponding to the Laplace approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is rep (size of bootstrap), dimension 2 is (k+1) values of D from 0 to k, dimension 3 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R.boot</code></td>
<td>
<p>An array with dimension rep by (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
data(hearingdate_synth)
synth$CourtEvent_HearingDate = hearingdate_synth
set.seed(123)
boot_apce_re = BootstrapAPCEipwRE(synth, rep = 10, formula = "Y ~ Sex + White + Age + 
                                  CurrentViolentOffense + PendingChargeAtTimeOfOffense + 
                                  PriorMisdemeanorConviction + PriorFelonyConviction + 
                                  PriorViolentConviction + (1|CourtEvent_HearingDate) + D", 
                                  CourtEvent_HearingDate = hearingdate_synth)


</code></pre>

<hr>
<h2 id='BootstrapAPCEipwREparallel'>Bootstrap for estimating variance of APCE with random effects</h2><span id='topic+BootstrapAPCEipwREparallel'></span>

<h3>Description</h3>

<p>Estimate variance of APCE for frequentist analysis with random effects using bootstrap. See S7 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapAPCEipwREparallel(data, rep = 1000, formula, nAGQ = 1, size = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootstrapAPCEipwREparallel_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwREparallel_+3A_rep">rep</code></td>
<td>
<p>Size of bootstrap</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwREparallel_+3A_formula">formula</code></td>
<td>
<p>A formula of the model to fit.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwREparallel_+3A_nagq">nAGQ</code></td>
<td>
<p>Integer scalar - the number of points per axis for evaluating the adaptive Gauss-Hermite approximation to the log-likelihood. Defaults to 1, corresponding to the Laplace approximation.</p>
</td></tr>
<tr><td><code id="BootstrapAPCEipwREparallel_+3A_size">size</code></td>
<td>
<p>The number of parallel computing. The default is <code>5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is rep (size of bootstrap), dimension 2 is (k+1) values of D from 0 to k, dimension 3 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE.boot</code></td>
<td>
<p>An array with dimension rep by (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R.boot</code></td>
<td>
<p>An array with dimension rep by (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
data(hearingdate_synth)
synth$CourtEvent_HearingDate = hearingdate_synth
set.seed(123)
boot_apce_re = BootstrapAPCEipwREparallel(synth, rep = 10, 
                                          formula = "Y ~ Sex + White + Age + 
                                          CurrentViolentOffense + PendingChargeAtTimeOfOffense + 
                                          PriorMisdemeanorConviction + PriorFelonyConviction + 
                                          PriorViolentConviction + (1|CourtEvent_HearingDate) + 
                                          D", size = 1) # adjust the size


</code></pre>

<hr>
<h2 id='CalAPCE'>Calculate APCE</h2><span id='topic+CalAPCE'></span>

<h3>Description</h3>

<p>Calculate average principal causal effects (APCE) with ordinal decision. See Section 3.4 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalAPCE(
  data,
  mcmc.re,
  subgroup,
  name.group = c("overall", "Sex0", "Sex1", "Sex1 White0", "Sex1 White1"),
  rho = 0,
  burnin = 0,
  out.length = 500,
  c0 = 0,
  c1 = 0,
  ZX = NULL,
  save.individual.optimal.decision = FALSE,
  parallel = FALSE,
  optimal.decision.only = FALSE,
  dmf = NULL,
  fair.dmf.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalAPCE_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_mcmc.re">mcmc.re</code></td>
<td>
<p>A <code>mcmc</code> object generated by <code>AiEvalmcmc()</code> function.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_subgroup">subgroup</code></td>
<td>
<p>A list of numeric vectors for the index of each of the five subgroups.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_name.group">name.group</code></td>
<td>
<p>A list of character vectors for the label of five subgroups.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_rho">rho</code></td>
<td>
<p>A sensitivity parameter. The default is  <code>0</code> which implies the unconfoundedness assumption (Assumption 4).</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_burnin">burnin</code></td>
<td>
<p>A proportion of burnin for the Markov chain. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_out.length">out.length</code></td>
<td>
<p>An integer to specify the progress on the screen. Every <code>out.length</code>-th iteration is printed on the screen. The default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_c0">c0</code></td>
<td>
<p>The cost of an outcome. See Section 3.7 for more details. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_c1">c1</code></td>
<td>
<p>The cost of an unnecessarily harsh decision. See Section 3.7 for more details. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_zx">ZX</code></td>
<td>
<p>The data matrix for interaction terms. The default is the interaction between Z and all of the pre-treatment covariates (X).</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_save.individual.optimal.decision">save.individual.optimal.decision</code></td>
<td>
<p>A logical argument specified to save individual optimal decision rules. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_parallel">parallel</code></td>
<td>
<p>A logical argument specifying whether parallel computing is conducted. Do not change this argument manually.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_optimal.decision.only">optimal.decision.only</code></td>
<td>
<p>A logical argument specified to compute only the optimal decision rule. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_dmf">dmf</code></td>
<td>
<p>A numeric vector of binary DMF recommendations. If <code>null</code>, use judge's decisions (0 if the decision is 0 and 1 o.w; e.g., signature or cash bond).</p>
</td></tr>
<tr><td><code id="CalAPCE_+3A_fair.dmf.only">fair.dmf.only</code></td>
<td>
<p>A logical argument specified to compute only the fairness of given DMF recommendations. The default is <code>FALSE</code>. Not used in the analysis for the JRSSA paper.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is each posterior sample; dimension 2 is subgroup, dimension 3 is (k+1) values of D from 0 to k, dimension 4 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
<tr><td><code>Optimal.Z.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 for the proportion of the cases where treatment (PSA provided) is optimal.</p>
</td></tr>
<tr><td><code>Optimal.D.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) for the proportion of optimal decision rule (average over observations). If <code>save.individual.optimal.decision = TRUE</code>, the dimension would be n by (k+1) (average over mcmc samples).</p>
</td></tr>
<tr><td><code>P.DMF.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for the proportion of binary DMF recommendations. Not used in the analysis for the JRSSA paper.</p>
</td></tr>
<tr><td><code>Utility.g_d.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n for the individual utility of judge's decisions.</p>
</td></tr>
<tr><td><code>Utility.g_dmf.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n for the individual utility of DMF recommendation.</p>
</td></tr>
<tr><td><code>Utility.diff.control.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n.mcmc for estimated difference in utility between judge's decisions and DMF recommendation among control group.</p>
</td></tr>
<tr><td><code>Utility.diff.treated.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n.mcmc for estimated difference in utility between judge's decisions and DMF recommendation among treated group.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 2)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, subgroup = subgroup_synth)

</code></pre>

<hr>
<h2 id='CalAPCEipw'>Compute APCE using frequentist analysis</h2><span id='topic+CalAPCEipw'></span>

<h3>Description</h3>

<p>Estimate propensity score and use Hajek estimator to compute APCE. See S7 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalAPCEipw(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalAPCEipw_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1</code></td>
<td>
<p>An array with dimension (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is (k+1) values of D from 0 to k, dimension 2 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0</code></td>
<td>
<p>An array with dimension (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE</code></td>
<td>
<p>An array with dimension (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R</code></td>
<td>
<p>An array with dimension (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>An array with estimated alpha.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>An array with estimated delta.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
freq_apce = CalAPCEipw(synth)

</code></pre>

<hr>
<h2 id='CalAPCEipwRE'>Compute APCE using frequentist analysis with random effects</h2><span id='topic+CalAPCEipwRE'></span>

<h3>Description</h3>

<p>Estimate propensity score and use Hajek estimator to compute APCE. See S7 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalAPCEipwRE(data, formula, nAGQ = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalAPCEipwRE_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="CalAPCEipwRE_+3A_formula">formula</code></td>
<td>
<p>A formula of the model to fit.</p>
</td></tr>
<tr><td><code id="CalAPCEipwRE_+3A_nagq">nAGQ</code></td>
<td>
<p>Integer scalar - the number of points per axis for evaluating the adaptive Gauss-Hermite approximation to the log-likelihood. Defaults to 1, corresponding to the Laplace approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1</code></td>
<td>
<p>An array with dimension (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is (k+1) values of D from 0 to k, dimension 2 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0</code></td>
<td>
<p>An array with dimension (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE</code></td>
<td>
<p>An array with dimension (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R</code></td>
<td>
<p>An array with dimension (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>An array with estimated alpha.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>An array with estimated delta.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
data(hearingdate_synth)
synth$CourtEvent_HearingDate = hearingdate_synth
freq_apce_re = CalAPCEipwRE(synth, formula = "Y ~ Sex + White + Age + 
                            CurrentViolentOffense + PendingChargeAtTimeOfOffense + 
                            PriorMisdemeanorConviction + PriorFelonyConviction + 
                            PriorViolentConviction + (1|CourtEvent_HearingDate) + D")

</code></pre>

<hr>
<h2 id='CalAPCEparallel'>Calculate APCE using parallel computing</h2><span id='topic+CalAPCEparallel'></span>

<h3>Description</h3>

<p>Calculate average principal causal effects (APCE) with ordinal decision using parallel computing. See Section 3.4 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalAPCEparallel(
  data,
  mcmc.re,
  subgroup,
  name.group = c("overall", "Sex0", "Sex1", "Sex1 White0", "Sex1 White1"),
  rho = 0,
  burnin = 0,
  out.length = 500,
  c0 = 0,
  c1 = 0,
  ZX = NULL,
  save.individual.optimal.decision = FALSE,
  optimal.decision.only = FALSE,
  dmf = NULL,
  fair.dmf.only = FALSE,
  size = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalAPCEparallel_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_mcmc.re">mcmc.re</code></td>
<td>
<p>A <code>mcmc</code> object generated by <code>AiEvalmcmc()</code> function.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_subgroup">subgroup</code></td>
<td>
<p>A list of numeric vectors for the index of each of the five subgroups.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_name.group">name.group</code></td>
<td>
<p>A list of character vectors for the label of five subgroups.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_rho">rho</code></td>
<td>
<p>A sensitivity parameter. The default is  <code>0</code> which implies the unconfoundedness assumption (Assumption 4).</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_burnin">burnin</code></td>
<td>
<p>A proportion of burnin for the Markov chain. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_out.length">out.length</code></td>
<td>
<p>An integer to specify the progress on the screen. Every <code>out.length</code>-th iteration is printed on the screen. The default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_c0">c0</code></td>
<td>
<p>The cost of an outcome. See Section 3.7 for more details. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_c1">c1</code></td>
<td>
<p>The cost of an unnecessarily harsh decision. See Section 3.7 for more details. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_zx">ZX</code></td>
<td>
<p>The data matrix for interaction terms. The default is the interaction between Z and all of the pre-treatment covariates (X).</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_save.individual.optimal.decision">save.individual.optimal.decision</code></td>
<td>
<p>A logical argument specified to save individual optimal decision rules. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_optimal.decision.only">optimal.decision.only</code></td>
<td>
<p>A logical argument specified to compute only the optimal decision rule. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_dmf">dmf</code></td>
<td>
<p>A numeric vector of binary DMF recommendations. If <code>null</code>, use judge's decisions (0 if the decision is 0 and 1 o.w; e.g., signature or cash bond).</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_fair.dmf.only">fair.dmf.only</code></td>
<td>
<p>A logical argument specified to compute only the fairness of given DMF recommendations. The default is <code>FALSE</code>. Not used in the analysis for the JRSSA paper.</p>
</td></tr>
<tr><td><code id="CalAPCEparallel_+3A_size">size</code></td>
<td>
<p>The number of parallel computing. The default is <code>5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>P.D1.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for quantity P(D(1)=d| R=r), dimension 1 is each posterior sample; dimension 2 is subgroup, dimension 3 is (k+1) values of D from 0 to k, dimension 4 is (k+2) values of R from 0 to k+1.</p>
</td></tr>
<tr><td><code>P.D0.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for quantity P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>APCE.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for quantity P(D(1)=d| R=r)-P(D(0)=d| R=r).</p>
</td></tr>
<tr><td><code>P.R.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+2) for quantity P(R=r) for r from 0 to (k+1).</p>
</td></tr>
<tr><td><code>Optimal.Z.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 for the proportion of the cases where treatment (PSA provided) is optimal.</p>
</td></tr>
<tr><td><code>Optimal.D.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) for the proportion of optimal decision rule.</p>
</td></tr>
<tr><td><code>P.DMF.mcmc</code></td>
<td>
<p>An array with dimension n.mcmc by 5 by (k+1) by (k+2) for the proportion of binary DMF recommendations. Not used in the analysis for the JRSSA paper.</p>
</td></tr>
<tr><td><code>Utility.g_d.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n for the individual utility of judge's decisions.</p>
</td></tr>
<tr><td><code>Utility.g_dmf.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n for the individual utility of DMF recommendation.</p>
</td></tr>
<tr><td><code>Utility.diff.control.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n.mcmc for estimated difference in utility between judge's decisions and DMF recommendation among control group.</p>
</td></tr>
<tr><td><code>Utility.diff.treated.mcmc</code></td>
<td>
<p>Included if <code>save.individual.optimal.decision = TRUE</code>. An array with dimension n.mcmc for estimated difference in utility between judge's decisions and DMF recommendation among treated group.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
sample_apce = CalAPCEparallel(data = synth, mcmc.re = sample_mcmc, 
                              subgroup = subgroup_synth, 
                              size = 1) # adjust the size


</code></pre>

<hr>
<h2 id='CalDelta'>Calculate the delta given the principal stratum</h2><span id='topic+CalDelta'></span>

<h3>Description</h3>

<p>Calculate the maximal deviation of decisions probability among the distributions for different groups (delta) given the principal stratum (R).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalDelta(r, k, pd0, pd1, attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalDelta_+3A_r">r</code></td>
<td>
<p>The given principal stratum.</p>
</td></tr>
<tr><td><code id="CalDelta_+3A_k">k</code></td>
<td>
<p>The maximum decision (e.g., largest bail amount).</p>
</td></tr>
<tr><td><code id="CalDelta_+3A_pd0">pd0</code></td>
<td>
<p>P.D0.mcmc array generated from <code>CalAPCE</code> or <code>CalAPCEparallel</code>.</p>
</td></tr>
<tr><td><code id="CalDelta_+3A_pd1">pd1</code></td>
<td>
<p>P.D1.mcmc array generated from <code>CalAPCE</code> or <code>CalAPCEparallel</code>.</p>
</td></tr>
<tr><td><code id="CalDelta_+3A_attr">attr</code></td>
<td>
<p>The index of subgroups (within the output of CalAPCE/CalAPCEparallel) that corresponds to the protected attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of the delta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
subgroup_synth = list(1:nrow(synth), which(synth$Sex==0), which(synth$Sex==1), 
                      which(synth$Sex==1&amp;synth$White==0), which(synth$Sex==1&amp;synth$White==1))
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, subgroup = subgroup_synth, 
                      burnin = 0)
CalDelta(0, 3, sample_apce[["P.D0.mcmc"]], sample_apce[["P.D1.mcmc"]], c(2,3))


</code></pre>

<hr>
<h2 id='CalDIM'>Calculate diff-in-means estimates</h2><span id='topic+CalDIM'></span>

<h3>Description</h3>

<p>Calculate average causal effect based on diff-in-means estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalDIM(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalDIM_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of which columns includes a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of diff-in-means estimates effect for each value of D and Y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
CalDIM(synth)

</code></pre>

<hr>
<h2 id='CalDIMsubgroup'>Calculate diff-in-means estimates</h2><span id='topic+CalDIMsubgroup'></span>

<h3>Description</h3>

<p>Calculate average causal effect based on diff-in-means estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalDIMsubgroup(
  data,
  subgroup,
  name.group = c("Overall", "Female", "Male", "Non-white\nMale", "White\nMale")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalDIMsubgroup_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of which columns includes a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y).</p>
</td></tr>
<tr><td><code id="CalDIMsubgroup_+3A_subgroup">subgroup</code></td>
<td>
<p>A list of numeric vectors for the index of each of the five subgroups.</p>
</td></tr>
<tr><td><code id="CalDIMsubgroup_+3A_name.group">name.group</code></td>
<td>
<p>A character vector including the labels of five subgroups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of diff-in-means estimates for each value of D and Y for each subgroup.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
CalDIMsubgroup(synth, subgroup = subgroup_synth)

</code></pre>

<hr>
<h2 id='CalFairness'>Calculate the principal fairness</h2><span id='topic+CalFairness'></span>

<h3>Description</h3>

<p>See Section 3.6 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalFairness(apce, attr = c(2, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalFairness_+3A_apce">apce</code></td>
<td>
<p>The list generated from <code>CalAPCE</code> or <code>CalAPCEparallel</code>.</p>
</td></tr>
<tr><td><code id="CalFairness_+3A_attr">attr</code></td>
<td>
<p>The index of subgroups (within the output of CalAPCE/CalAPCEparallel) that corresponds to the protected attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of the delta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
subgroup_synth = list(1:nrow(synth), which(synth$Sex==0), which(synth$Sex==1), 
                      which(synth$Sex==1&amp;synth$White==0), which(synth$Sex==1&amp;synth$White==1))
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, subgroup = subgroup_synth, 
                      burnin = 0)
CalFairness(sample_apce)


</code></pre>

<hr>
<h2 id='CalOptimalDecision'>Calculate optimal decision &amp; utility</h2><span id='topic+CalOptimalDecision'></span>

<h3>Description</h3>

<p>(1) Calculate optimal decision for each observation given each of c0 (cost of an outcome) and c1 (cost of an unnecessarily harsh decision) from the lists. 
(2) Calculate difference in the expected utility between binary version of judge's decisions and DMF recommendations given each of c0 (cost of an outcome) and c1 (cost of an unnecessarily harsh decision) from the lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalOptimalDecision(
  data,
  mcmc.re,
  c0.ls,
  c1.ls,
  dmf = NULL,
  rho = 0,
  burnin = 0,
  out.length = 500,
  ZX = NULL,
  size = 5,
  include.utility.diff.mcmc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalOptimalDecision_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_mcmc.re">mcmc.re</code></td>
<td>
<p>A <code>mcmc</code> object generated by <code>AiEvalmcmc()</code> function.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_c0.ls">c0.ls</code></td>
<td>
<p>The list of cost of an outcome. See Section 3.7 for more details.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_c1.ls">c1.ls</code></td>
<td>
<p>The list of cost of an unnecessarily harsh decision. See Section 3.7 for more details.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_dmf">dmf</code></td>
<td>
<p>A numeric vector of binary DMF recommendations. If <code>null</code>, use judge's decisions (0 if the decision is 0 and 1 o.w; e.g., signature or cash bond).</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_rho">rho</code></td>
<td>
<p>A sensitivity parameter. The default is  <code>0</code> which implies the unconfoundedness assumption (Assumption 4).</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_burnin">burnin</code></td>
<td>
<p>A proportion of burnin for the Markov chain. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_out.length">out.length</code></td>
<td>
<p>An integer to specify the progress on the screen. Every <code>out.length</code>-th iteration is printed on the screen. The default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_zx">ZX</code></td>
<td>
<p>The data matrix for interaction terms. The default is the interaction between Z and all of the pre-treatment covariates (X).</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_size">size</code></td>
<td>
<p>The number of parallel computing. The default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="CalOptimalDecision_+3A_include.utility.diff.mcmc">include.utility.diff.mcmc</code></td>
<td>
<p>A logical argument specifying whether to save <code>Utility.diff.control.mcmc</code> and <code>Utility.diff.treated.mcmc</code> for Figure S17. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of (1) the probability that the optimal decision for each observation being d in 0,1,...,k, (2) expected utility of binary version of judge's decision (g_d), (3) expected utility of binary DMF recommendation, and (4) the difference between (2) and (3). If <code>include.utility.diff.mcmc = TRUE</code>, returns a list of such <code>data.frame</code> and a <code>data.frame</code> that includes the result for mean and quantile of <code>Utility.diff.control.mcmc</code> and <code>Utility.diff.treated.mcmc</code> across mcmc samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
sample_optd = CalOptimalDecision(data = synth, mcmc.re = sample_mcmc, 
                                 c0.ls = seq(0,5,1), c1.ls = seq(0,5,1), 
                                 size = 1) # adjust the size


</code></pre>

<hr>
<h2 id='CalPS'>Calculate the proportion of principal strata (R)</h2><span id='topic+CalPS'></span>

<h3>Description</h3>

<p>Calculate the proportion of each principal stratum (R).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalPS(
  p.r.mcmc,
  name.group = c("Overall", "Female", "Male", "Non-white\nMale", "White\nMale")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalPS_+3A_p.r.mcmc">p.r.mcmc</code></td>
<td>
<p>P.R.mcmc array generated from <code>CalAPCE</code> or <code>CalAPCEparallel</code>.</p>
</td></tr>
<tr><td><code id="CalPS_+3A_name.group">name.group</code></td>
<td>
<p>A character vector including the labels of five subgroups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of the proportion of each principal stratum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, 
                      subgroup = subgroup_synth)
CalPS(sample_apce[["P.R.mcmc"]])


</code></pre>

<hr>
<h2 id='FTAdata'>Interim Dane data with failure to appear (FTA) as an outcome</h2><span id='topic+FTAdata'></span>

<h3>Description</h3>

<p>An interim dataset containing pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), 
and an outcome variable (Y). The data used for the paper, and made available here, are interim, based on 
only half of the observations in the study and (for those observations) only half of the study follow-up period.  
We use them only to illustrate methods, not to draw substantive conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTAdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 1891 rows and 19 variables:
</p>

<dl>
<dt>Z</dt><dd><p>binary treatment</p>
</dd>
<dt>D</dt><dd><p>ordinal decision</p>
</dd>
<dt>Y</dt><dd><p>outcome</p>
</dd>
<dt>Sex</dt><dd><p>male or female</p>
</dd>
<dt>White</dt><dd><p>white or non-white</p>
</dd>
<dt>SexWhite</dt><dd><p>the interaction between gender and race</p>
</dd>
<dt>Age</dt><dd><p>age</p>
</dd>
<dt>PendingChargeAtTimeOfOffense</dt><dd><p>binary variable for pending charge (felony, misdemeanor, or both) at the time of offense</p>
</dd>
<dt>NCorNonViolentMisdemeanorCharge</dt><dd><p>binary variable for current non-violent felony charge</p>
</dd>
<dt>ViolentMisdemeanorCharge</dt><dd><p>binary variable for current violent misdemeanor charge</p>
</dd>
<dt>ViolentFelonyCharge</dt><dd><p>binary variable for current violent felony charge</p>
</dd>
<dt>NonViolentFelonyCharge</dt><dd><p>binary variable for current non-violent felony charge</p>
</dd>
<dt>PriorMisdemeanorConviction</dt><dd><p>binary variable for prior conviction of misdemeanor</p>
</dd>
<dt>PriorFelonyConviction</dt><dd><p>binary variable for prior conviction of felony</p>
</dd>
<dt>PriorViolentConviction</dt><dd><p>four-level ordinal variable for prior violent conviction</p>
</dd>
<dt>PriorSentenceToIncarceration</dt><dd><p>binary variable for prior sentence to incarceration</p>
</dd>
<dt>PriorFTAInPastTwoYears</dt><dd><p>three-level ordinal variable for FTAs from past two years</p>
</dd>
<dt>PriorFTAOlderThanTwoYears</dt><dd><p>binary variable for FTAs from over two years ago</p>
</dd>
<dt>Staff_ReleaseRecommendation</dt><dd><p>four-level ordinal variable for the DMF recommendation</p>
</dd>
</dl>


<hr>
<h2 id='g_legend'>Pulling ggplot legend</h2><span id='topic+g_legend'></span>

<h3>Description</h3>

<p>Pulling ggplot legend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_legend(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_legend_+3A_p">p</code></td>
<td>
<p>A <code>ggplot</code> of which legend should be pulled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot legend.
</p>

<hr>
<h2 id='HearingDate'>Interim court event hearing date</h2><span id='topic+HearingDate'></span>

<h3>Description</h3>

<p>An Interim Dane court event hearing date of Dane data in factor format. The data used for the paper, and made available here, are interim, based on 
only half of the observations in the study and (for those observations) only half of the study follow-up period.  
We use them only to illustrate methods, not to draw substantive conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HearingDate
</code></pre>


<h3>Format</h3>

<p>A date variable in factor format.
</p>

<hr>
<h2 id='hearingdate_synth'>Synthetic court event hearing date</h2><span id='topic+hearingdate_synth'></span>

<h3>Description</h3>

<p>A synthetic court event hearing date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hearingdate_synth
</code></pre>


<h3>Format</h3>

<p>A date variable.
</p>

<hr>
<h2 id='NCAdata'>Interim Dane data with new criminal activity (NCA) as an outcome</h2><span id='topic+NCAdata'></span>

<h3>Description</h3>

<p>An interim dataset containing pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), 
and an outcome variable (Y). The data used for the paper, and made available here, are interim, based on 
only half of the observations in the study and (for those observations) only half of the study follow-up period.  
We use them only to illustrate methods, not to draw substantive conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCAdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 1891 rows and 19 variables:
</p>

<dl>
<dt>Z</dt><dd><p>binary treatment</p>
</dd>
<dt>D</dt><dd><p>ordinal decision</p>
</dd>
<dt>Y</dt><dd><p>outcome</p>
</dd>
<dt>Sex</dt><dd><p>male or female</p>
</dd>
<dt>White</dt><dd><p>white or non-white</p>
</dd>
<dt>SexWhite</dt><dd><p>the interaction between gender and race</p>
</dd>
<dt>Age</dt><dd><p>age</p>
</dd>
<dt>PendingChargeAtTimeOfOffense</dt><dd><p>binary variable for pending charge (felony, misdemeanor, or both) at the time of offense</p>
</dd>
<dt>NCorNonViolentMisdemeanorCharge</dt><dd><p>binary variable for current non-violent felony charge</p>
</dd>
<dt>ViolentMisdemeanorCharge</dt><dd><p>binary variable for current violent misdemeanor charge</p>
</dd>
<dt>ViolentFelonyCharge</dt><dd><p>binary variable for current violent felony charge</p>
</dd>
<dt>NonViolentFelonyCharge</dt><dd><p>binary variable for current non-violent felony charge</p>
</dd>
<dt>PriorMisdemeanorConviction</dt><dd><p>binary variable for prior conviction of misdemeanor</p>
</dd>
<dt>PriorFelonyConviction</dt><dd><p>binary variable for prior conviction of felony</p>
</dd>
<dt>PriorViolentConviction</dt><dd><p>four-level ordinal variable for prior violent conviction</p>
</dd>
<dt>PriorSentenceToIncarceration</dt><dd><p>binary variable for prior sentence to incarceration</p>
</dd>
<dt>PriorFTAInPastTwoYears</dt><dd><p>three-level ordinal variable for FTAs from past two years</p>
</dd>
<dt>PriorFTAOlderThanTwoYears</dt><dd><p>binary variable for FTAs from over two years ago</p>
</dd>
<dt>Staff_ReleaseRecommendation</dt><dd><p>four-level ordinal variable for the DMF recommendation</p>
</dd>
</dl>


<hr>
<h2 id='NVCAdata'>Interim Dane data with new violent criminal activity (NVCA) as an outcome</h2><span id='topic+NVCAdata'></span>

<h3>Description</h3>

<p>An interim dataset containing pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), 
and an outcome variable (Y). The data used for the paper, and made available here, are interim, based on 
only half of the observations in the study and (for those observations) only half of the study follow-up period.  
We use them only to illustrate methods, not to draw substantive conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NVCAdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 1891 rows and 19 variables:
</p>

<dl>
<dt>Z</dt><dd><p>binary treatment</p>
</dd>
<dt>D</dt><dd><p>ordinal decision</p>
</dd>
<dt>Y</dt><dd><p>outcome</p>
</dd>
<dt>Sex</dt><dd><p>male or female</p>
</dd>
<dt>White</dt><dd><p>white or non-white</p>
</dd>
<dt>SexWhite</dt><dd><p>the interaction between gender and race</p>
</dd>
<dt>Age</dt><dd><p>age</p>
</dd>
<dt>PendingChargeAtTimeOfOffense</dt><dd><p>binary variable for pending charge (felony, misdemeanor, or both) at the time of offense</p>
</dd>
<dt>NCorNonViolentMisdemeanorCharge</dt><dd><p>binary variable for current non-violent felony charge</p>
</dd>
<dt>ViolentMisdemeanorCharge</dt><dd><p>binary variable for current violent misdemeanor charge</p>
</dd>
<dt>ViolentFelonyCharge</dt><dd><p>binary variable for current violent felony charge</p>
</dd>
<dt>NonViolentFelonyCharge</dt><dd><p>binary variable for current non-violent felony charge</p>
</dd>
<dt>PriorMisdemeanorConviction</dt><dd><p>binary variable for prior conviction of misdemeanor</p>
</dd>
<dt>PriorFelonyConviction</dt><dd><p>binary variable for prior conviction of felony</p>
</dd>
<dt>PriorViolentConviction</dt><dd><p>four-level ordinal variable for prior violent conviction</p>
</dd>
<dt>PriorSentenceToIncarceration</dt><dd><p>binary variable for prior sentence to incarceration</p>
</dd>
<dt>PriorFTAInPastTwoYears</dt><dd><p>three-level ordinal variable for FTAs from past two years</p>
</dd>
<dt>PriorFTAOlderThanTwoYears</dt><dd><p>binary variable for FTAs from over two years ago</p>
</dd>
<dt>Staff_ReleaseRecommendation</dt><dd><p>four-level ordinal variable for the DMF recommendation</p>
</dd>
</dl>


<hr>
<h2 id='PlotAPCE'>Plot APCE</h2><span id='topic+PlotAPCE'></span>

<h3>Description</h3>

<p>See Figure 4 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotAPCE(
  res,
  y.max = 0.1,
  decision.labels = c("signature bond", "small cash bond", "large cash bond"),
  shape.values = c(16, 17, 15),
  col.values = c("blue", "black", "red", "brown"),
  label = TRUE,
  r.labels = c("safe", "easily\npreventable", "prevent-\nable", "risky\n"),
  label.position = c("top", "top", "top", "top"),
  top.margin = 0.01,
  bottom.margin = 0.01,
  name.group = c("Overall", "Female", "Male", "Non-white\nMale", "White\nMale"),
  label.size = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotAPCE_+3A_res">res</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>APCEsummary()</code>.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_y.max">y.max</code></td>
<td>
<p>Maximum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_decision.labels">decision.labels</code></td>
<td>
<p>Labels of decisions (D).</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_shape.values">shape.values</code></td>
<td>
<p>Shape of point for each decisions.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_col.values">col.values</code></td>
<td>
<p>Color of point for each principal stratum.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_label">label</code></td>
<td>
<p>A logical argument whether to specify label of each principal stratum. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_r.labels">r.labels</code></td>
<td>
<p>Label of each principal stratum.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_label.position">label.position</code></td>
<td>
<p>The position of labels.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_top.margin">top.margin</code></td>
<td>
<p>Top margin of labels.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_bottom.margin">bottom.margin</code></td>
<td>
<p>Bottom margin of labels.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_name.group">name.group</code></td>
<td>
<p>A character vector including the labels of five subgroups.</p>
</td></tr>
<tr><td><code id="PlotAPCE_+3A_label.size">label.size</code></td>
<td>
<p>Size of label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, 
                      subgroup = subgroup_synth)
sample_apce_summary = APCEsummary(sample_apce[["APCE.mcmc"]])
PlotAPCE(sample_apce_summary, y.max = 0.25, decision.labels = c("signature","small cash",
         "middle cash","large cash"), shape.values = c(16, 17, 15, 18), 
         col.values = c("blue", "black", "red", "brown", "purple"), label = FALSE)


</code></pre>

<hr>
<h2 id='PlotDIMdecisions'>Plot diff-in-means estimates</h2><span id='topic+PlotDIMdecisions'></span>

<h3>Description</h3>

<p>See Figure 2 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDIMdecisions(
  res,
  y.max = 0.2,
  decision.labels = c("signature bond   ", "small cash bond   ", "large cash bond"),
  col.values = c("grey60", "grey30", "grey6"),
  shape.values = c(16, 17, 15)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDIMdecisions_+3A_res">res</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>CalDIMsubgroup</code>.</p>
</td></tr>
<tr><td><code id="PlotDIMdecisions_+3A_y.max">y.max</code></td>
<td>
<p>Maximum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotDIMdecisions_+3A_decision.labels">decision.labels</code></td>
<td>
<p>Labels of decisions (D).</p>
</td></tr>
<tr><td><code id="PlotDIMdecisions_+3A_col.values">col.values</code></td>
<td>
<p>Color of point for each decisions.</p>
</td></tr>
<tr><td><code id="PlotDIMdecisions_+3A_shape.values">shape.values</code></td>
<td>
<p>Shape of point for each decisions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
res_dec = CalDIMsubgroup(synth, subgroup = subgroup_synth)
PlotDIMdecisions(res_dec, decision.labels = c("signature","small cash","middle cash","large cash"),
                 col.values = c("grey60", "grey30", "grey6", "grey1"), 
                 shape.values = c(16, 17, 15, 18))

</code></pre>

<hr>
<h2 id='PlotDIMoutcomes'>Plot diff-in-means estimates</h2><span id='topic+PlotDIMoutcomes'></span>

<h3>Description</h3>

<p>See Figure 2 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDIMoutcomes(
  res.fta,
  res.nca,
  res.nvca,
  label.position = c("top", "top", "top"),
  top.margin = 0.01,
  bottom.margin = 0.01,
  y.max = 0.2,
  label.size = 7,
  name.group = c("Overall", "Female", "Male", "Non-white\nMale", "White\nMale")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDIMoutcomes_+3A_res.fta">res.fta</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>CalDIMsubgroup</code> with Y = FTA.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_res.nca">res.nca</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>CalDIMsubgroup</code> with Y = NCA.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_res.nvca">res.nvca</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>CalDIMsubgroup</code> with Y = NVCA.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_label.position">label.position</code></td>
<td>
<p>The position of labels.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_top.margin">top.margin</code></td>
<td>
<p>Top margin of labels.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_bottom.margin">bottom.margin</code></td>
<td>
<p>Bottom margin of labels.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_y.max">y.max</code></td>
<td>
<p>Maximum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_label.size">label.size</code></td>
<td>
<p>Size of label.</p>
</td></tr>
<tr><td><code id="PlotDIMoutcomes_+3A_name.group">name.group</code></td>
<td>
<p>A character vector including the labels of five subgroups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
synth_fta &lt;- synth_nca &lt;- synth_nvca &lt;- synth
set.seed(123)
synth_fta$Y &lt;- sample(0:1, 1000, replace = TRUE)
synth_nca$Y &lt;- sample(0:1, 1000, replace = TRUE)
synth_nvca$Y &lt;- sample(0:1, 1000, replace = TRUE)
res_fta = CalDIMsubgroup(synth_fta, subgroup = subgroup_synth)
res_nca = CalDIMsubgroup(synth_nca, subgroup = subgroup_synth)
res_nvca = CalDIMsubgroup(synth_nvca, subgroup = subgroup_synth)
PlotDIMoutcomes(res_fta, res_nca, res_nvca)

</code></pre>

<hr>
<h2 id='PlotFairness'>Plot the principal fairness</h2><span id='topic+PlotFairness'></span>

<h3>Description</h3>

<p>See Figure 5 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotFairness(
  res,
  top.margin = 0.01,
  y.max = 0.2,
  y.min = -0.1,
  r.labels = c("Safe", "Easily\nPreventable", "Preventable", "Risky"),
  label = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotFairness_+3A_res">res</code></td>
<td>
<p>The data frame generated from <code>CalFairness</code>.</p>
</td></tr>
<tr><td><code id="PlotFairness_+3A_top.margin">top.margin</code></td>
<td>
<p>The index of subgroups (within the output of CalAPCE/CalAPCEparallel) that corresponds to the protected attributes.</p>
</td></tr>
<tr><td><code id="PlotFairness_+3A_y.max">y.max</code></td>
<td>
<p>Maximum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotFairness_+3A_y.min">y.min</code></td>
<td>
<p>Minimum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotFairness_+3A_r.labels">r.labels</code></td>
<td>
<p>Label of each principal stratum.</p>
</td></tr>
<tr><td><code id="PlotFairness_+3A_label">label</code></td>
<td>
<p>A logical argument whether to specify label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of the delta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
subgroup_synth = list(1:nrow(synth), which(synth$Sex==0), which(synth$Sex==1), 
                      which(synth$Sex==1&amp;synth$White==0), which(synth$Sex==1&amp;synth$White==1))
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, subgroup = subgroup_synth, 
                      burnin = 0)
sample_fair = CalFairness(sample_apce)
PlotFairness(sample_fair, y.max = 0.4, y.min = -0.4, r.labels = c("Safe", "Preventable 1", 
             "Preventable 2", "Preventable 3", "Risky"))


</code></pre>

<hr>
<h2 id='PlotOptimalDecision'>Plot optimal decision</h2><span id='topic+PlotOptimalDecision'></span>

<h3>Description</h3>

<p>See Figure 6 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotOptimalDecision(res, colname.d, idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotOptimalDecision_+3A_res">res</code></td>
<td>
<p>The data frame generated from <code>CalOptimalDecision</code>.</p>
</td></tr>
<tr><td><code id="PlotOptimalDecision_+3A_colname.d">colname.d</code></td>
<td>
<p>The column name of decision to be plotted.</p>
</td></tr>
<tr><td><code id="PlotOptimalDecision_+3A_idx">idx</code></td>
<td>
<p>The row index of observations to be included. The default is all the observations from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
sample_optd = CalOptimalDecision(data = synth, mcmc.re = sample_mcmc, 
                                 c0.ls = seq(0,5,1), c1.ls = seq(0,5,1), 
                                 size = 1) # adjust the size
sample_optd$cash = sample_optd$d1 + sample_optd$d2 + sample_optd$d3
PlotOptimalDecision(sample_optd, "cash")


</code></pre>

<hr>
<h2 id='PlotPS'>Plot the proportion of principal strata (R)</h2><span id='topic+PlotPS'></span>

<h3>Description</h3>

<p>See Figure 3 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPS(
  res,
  y.min = 0,
  y.max = 0.75,
  col.values = c("blue", "black", "red", "brown"),
  label = TRUE,
  r.labels = c("safe", " easily             \n preventable    ",
    "\n          preventable\n", "  risky"),
  label.position = c("top", "top", "top", "bottom"),
  top.margin = 0.02,
  bottom.margin = 0.02,
  label.size = 6.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPS_+3A_res">res</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>CalPS</code>.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_y.min">y.min</code></td>
<td>
<p>Minimum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_y.max">y.max</code></td>
<td>
<p>Maximum value of y-axis.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_col.values">col.values</code></td>
<td>
<p>Color of point for each principal stratum.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_label">label</code></td>
<td>
<p>A logical argument whether to specify label of each principal stratum. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_r.labels">r.labels</code></td>
<td>
<p>Label of each principal stratum.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_label.position">label.position</code></td>
<td>
<p>The position of labels.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_top.margin">top.margin</code></td>
<td>
<p>Top margin of labels.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_bottom.margin">bottom.margin</code></td>
<td>
<p>Bottom margin of labels.</p>
</td></tr>
<tr><td><code id="PlotPS_+3A_label.size">label.size</code></td>
<td>
<p>Size of label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
subgroup_synth = list(1:nrow(synth),which(synth$Sex==0),which(synth$Sex==1),
                      which(synth$Sex==1&amp;synth$White==0),which(synth$Sex==1&amp;synth$White==1))
sample_apce = CalAPCE(data = synth, mcmc.re = sample_mcmc, 
                      subgroup = subgroup_synth)
sample_ps = CalPS(sample_apce[["P.R.mcmc"]])
PlotPS(sample_ps, col.values = c("blue", "black", "red", "brown", "purple"), label = FALSE)


</code></pre>

<hr>
<h2 id='PlotSpilloverCRT'>Plot conditional randomization test</h2><span id='topic+PlotSpilloverCRT'></span>

<h3>Description</h3>

<p>See Figure S8 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSpilloverCRT(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSpilloverCRT_+3A_res">res</code></td>
<td>
<p>A <code>list</code> generated with <code>SpilloverCRT</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
data(hearingdate_synth)
crt &lt;- SpilloverCRT(D = synth$D, Z = synth$Z, CourtEvent_HearingDate = hearingdate_synth)
PlotSpilloverCRT(crt)


</code></pre>

<hr>
<h2 id='PlotSpilloverCRTpower'>Plot power analysis of conditional randomization test</h2><span id='topic+PlotSpilloverCRTpower'></span>

<h3>Description</h3>

<p>See Figure S9 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSpilloverCRTpower(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSpilloverCRTpower_+3A_res">res</code></td>
<td>
<p>A <code>data.frame</code> generated with <code>SpilloverCRTpower</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
data(hearingdate_synth)
crt_power &lt;- SpilloverCRTpower(D = synth$D, Z = synth$Z, 
                               CourtEvent_HearingDate = hearingdate_synth,
                               size = 1) # adjust the size
PlotSpilloverCRTpower(crt_power)


</code></pre>

<hr>
<h2 id='PlotStackedBar'>Stacked barplot for the distribution of the decision given psa</h2><span id='topic+PlotStackedBar'></span>

<h3>Description</h3>

<p>See Figure 1 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotStackedBar(
  data,
  fta.label = "FTAScore",
  nca.label = "NCAScore",
  nvca.label = "NVCAFlag",
  d.colors = c("grey60", "grey30", "grey10"),
  d.labels = c("signature bond", "small cash bond", "large cash bond"),
  legend.position = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotStackedBar_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of which columns includes an ordinal decision (D), and psa variables (fta, nca, and nvca).</p>
</td></tr>
<tr><td><code id="PlotStackedBar_+3A_fta.label">fta.label</code></td>
<td>
<p>Column name of fta score in the data. The default is <code>"FTAScore"</code>.</p>
</td></tr>
<tr><td><code id="PlotStackedBar_+3A_nca.label">nca.label</code></td>
<td>
<p>Column name of nca score in the data. The default is <code>"NCAScore"</code>.</p>
</td></tr>
<tr><td><code id="PlotStackedBar_+3A_nvca.label">nvca.label</code></td>
<td>
<p>Column name of nvca score in the data. The default is <code>"NVCAFlag"</code>.</p>
</td></tr>
<tr><td><code id="PlotStackedBar_+3A_d.colors">d.colors</code></td>
<td>
<p>The color of each decision.</p>
</td></tr>
<tr><td><code id="PlotStackedBar_+3A_d.labels">d.labels</code></td>
<td>
<p>The label of each decision.</p>
</td></tr>
<tr><td><code id="PlotStackedBar_+3A_legend.position">legend.position</code></td>
<td>
<p>The position of legend. The default is <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three ggplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(psa_synth)
# Control group (PSA not provided)
PlotStackedBar(psa_synth[psa_synth$Z == 0, ], d.colors = c("grey80", "grey60", 
               "grey30", "grey10"), d.labels = c("signature","small",
               "middle","large"))
# Treated group (PSA provided)
PlotStackedBar(psa_synth[psa_synth$Z == 0, ], d.colors = c("grey80", "grey60", 
               "grey30", "grey10"), d.labels = c("signature","small",
               "middle","large"))

</code></pre>

<hr>
<h2 id='PlotStackedBarDMF'>Stacked barplot for the distribution of the decision given DMF recommendation</h2><span id='topic+PlotStackedBarDMF'></span>

<h3>Description</h3>

<p>See Figure 1 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotStackedBarDMF(
  data,
  dmf.label = "dmf",
  dmf.category = NULL,
  d.colors = c("grey60", "grey30", "grey10"),
  d.labels = c("signature bond", "small cash bond", "large cash bond"),
  legend.position = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotStackedBarDMF_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of which columns includes a binary treatment (Z; PSA provision), an ordinal decision (D), and DMF recommendation.</p>
</td></tr>
<tr><td><code id="PlotStackedBarDMF_+3A_dmf.label">dmf.label</code></td>
<td>
<p>Column name of DMF recommendation in the data. The default is <code>"dmf"</code>.</p>
</td></tr>
<tr><td><code id="PlotStackedBarDMF_+3A_dmf.category">dmf.category</code></td>
<td>
<p>The name of each category of DMF recommendation.</p>
</td></tr>
<tr><td><code id="PlotStackedBarDMF_+3A_d.colors">d.colors</code></td>
<td>
<p>The color of each decision.</p>
</td></tr>
<tr><td><code id="PlotStackedBarDMF_+3A_d.labels">d.labels</code></td>
<td>
<p>The label of each decision.</p>
</td></tr>
<tr><td><code id="PlotStackedBarDMF_+3A_legend.position">legend.position</code></td>
<td>
<p>The position of legend. The default is <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three ggplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(psa_synth)
PlotStackedBarDMF(psa_synth, dmf.label = "DMF", d.colors = c("grey80", 
                  "grey60", "grey30", "grey10"), d.labels = c("signature",
                  "small","middle","large"))

</code></pre>

<hr>
<h2 id='PlotUtilityDiff'>Plot utility difference</h2><span id='topic+PlotUtilityDiff'></span>

<h3>Description</h3>

<p>See Figure 7 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotUtilityDiff(res, idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotUtilityDiff_+3A_res">res</code></td>
<td>
<p>The data frame generated from <code>CalUtilityDiff</code>.</p>
</td></tr>
<tr><td><code id="PlotUtilityDiff_+3A_idx">idx</code></td>
<td>
<p>The row index of observations to be included. The default is all the observations from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
synth_dmf = sample(0:1, nrow(synth), replace = TRUE) # random dmf recommendation
sample_utility = CalOptimalDecision(data = synth, mcmc.re = sample_mcmc, 
                                    c0.ls = seq(0,5,1), c1.ls = seq(0,5,1), 
                                    dmf = synth_dmf, size = 1) # adjust the size
PlotUtilityDiff(sample_utility)


</code></pre>

<hr>
<h2 id='PlotUtilityDiffCI'>Plot utility difference with 95% confidence interval</h2><span id='topic+PlotUtilityDiffCI'></span>

<h3>Description</h3>

<p>See Figure S17 for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotUtilityDiffCI(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotUtilityDiffCI_+3A_res">res</code></td>
<td>
<p>The second data frame (res.mcmc) generated from <code>CalUtilityDiff(include.utility.diff.mcmc = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
sample_mcmc = AiEvalmcmc(data = synth, n.mcmc = 10)
synth_dmf = sample(0:1, nrow(synth), replace = TRUE) # random dmf recommendation
sample_utility = CalOptimalDecision(data = synth, mcmc.re = sample_mcmc, 
                                    c0.ls = seq(0,5,1), c1.ls = seq(0,5,1), 
                                    dmf = synth_dmf, size = 1, # adjust the size
                                    include.utility.diff.mcmc = TRUE)
PlotUtilityDiffCI(sample_utility$res.mcmc)


</code></pre>

<hr>
<h2 id='psa_synth'>Synthetic PSA data</h2><span id='topic+psa_synth'></span>

<h3>Description</h3>

<p>A synthetic dataset containing a binary treatment (Z), ordinal decision (D), three PSA variables (FTAScore, NCAScore, and NVCAFlag), and DMF recommendation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psa_synth
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 4 variables:
</p>

<dl>
<dt>Z</dt><dd><p>binary treatment</p>
</dd>
<dt>D</dt><dd><p>ordinal decision</p>
</dd>
<dt>FTAScore</dt><dd><p>FTA score</p>
</dd>
<dt>NCAScore</dt><dd><p>NCA score</p>
</dd>
<dt>NVCAFlag</dt><dd><p>NVCA flag</p>
</dd>
<dt>DMF</dt><dd><p>DMF recommendation</p>
</dd>
</dl>


<hr>
<h2 id='PSAdata'>Interim Dane PSA data</h2><span id='topic+PSAdata'></span>

<h3>Description</h3>

<p>An interim dataset containing a binary treatment (Z), ordinal decision (D), three PSA variables 
(FTAScore, NCAScore, and NVCAFlag), DMF recommendation, and two pre-treatment covariates (binary 
indicator for gender; binary indicator for race). The data used for the paper, and made available here, are interim, based on 
only half of the observations in the study and (for those observations) only half of the study follow-up period.  
We use them only to illustrate methods, not to draw substantive conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSAdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 1891 rows and 7 variables:
</p>

<dl>
<dt>Z</dt><dd><p>binary treatment</p>
</dd>
<dt>D</dt><dd><p>ordinal decision</p>
</dd>
<dt>FTAScore</dt><dd><p>FTA score</p>
</dd>
<dt>NCAScore</dt><dd><p>NCA score</p>
</dd>
<dt>NVCAFlag</dt><dd><p>NVCA flag</p>
</dd>
<dt>DMF</dt><dd><p>DMF recommendation</p>
</dd>
<dt>Sex</dt><dd><p>male or female</p>
</dd>
<dt>White</dt><dd><p>white or non-white</p>
</dd>
</dl>


<hr>
<h2 id='SpilloverCRT'>Conduct conditional randomization test</h2><span id='topic+SpilloverCRT'></span>

<h3>Description</h3>

<p>See S3.1 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpilloverCRT(D, Z, CourtEvent_HearingDate, n = 100, seed.number = 12345)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpilloverCRT_+3A_d">D</code></td>
<td>
<p>A numeric vector of judge's decision.</p>
</td></tr>
<tr><td><code id="SpilloverCRT_+3A_z">Z</code></td>
<td>
<p>A numeric vector of treatment variable.</p>
</td></tr>
<tr><td><code id="SpilloverCRT_+3A_courtevent_hearingdate">CourtEvent_HearingDate</code></td>
<td>
<p>The court event hearing date.</p>
</td></tr>
<tr><td><code id="SpilloverCRT_+3A_n">n</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="SpilloverCRT_+3A_seed.number">seed.number</code></td>
<td>
<p>An integer for random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of the observed and permuted test statistics and its p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
data(hearingdate_synth)
crt &lt;- SpilloverCRT(D = synth$D, Z = synth$Z, CourtEvent_HearingDate = hearingdate_synth)


</code></pre>

<hr>
<h2 id='SpilloverCRTpower'>Conduct power analysis of conditional randomization test</h2><span id='topic+SpilloverCRTpower'></span>

<h3>Description</h3>

<p>See S3.2 for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpilloverCRTpower(
  D,
  Z,
  CourtEvent_HearingDate,
  n = 4,
  m = 4,
  size = 2,
  cand_omegaZtilde = seq(-1.5, 1.5, by = 0.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpilloverCRTpower_+3A_d">D</code></td>
<td>
<p>A numeric vector of judge's decision.</p>
</td></tr>
<tr><td><code id="SpilloverCRTpower_+3A_z">Z</code></td>
<td>
<p>A numeric vector of treatment variable.</p>
</td></tr>
<tr><td><code id="SpilloverCRTpower_+3A_courtevent_hearingdate">CourtEvent_HearingDate</code></td>
<td>
<p>The court event hearing date.</p>
</td></tr>
<tr><td><code id="SpilloverCRTpower_+3A_n">n</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="SpilloverCRTpower_+3A_m">m</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="SpilloverCRTpower_+3A_size">size</code></td>
<td>
<p>The number of parallel computing. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="SpilloverCRTpower_+3A_cand_omegaztilde">cand_omegaZtilde</code></td>
<td>
<p>Candidate values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of the result of power analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(synth)
data(hearingdate_synth)
crt_power &lt;- SpilloverCRTpower(D = synth$D, Z = synth$Z, 
                               CourtEvent_HearingDate = hearingdate_synth,
                               size = 1) # adjust the size


</code></pre>

<hr>
<h2 id='synth'>Synthetic data</h2><span id='topic+synth'></span>

<h3>Description</h3>

<p>A synthetic dataset containing pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), 
and an outcome variable (Y).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 11 variables:
</p>

<dl>
<dt>Z</dt><dd><p>binary treatment</p>
</dd>
<dt>D</dt><dd><p>ordinal decision</p>
</dd>
<dt>Y</dt><dd><p>outcome</p>
</dd>
<dt>Sex</dt><dd><p>male or female</p>
</dd>
<dt>White</dt><dd><p>white or non-white</p>
</dd>
<dt>Age</dt><dd><p>age</p>
</dd>
<dt>CurrentViolentOffense</dt><dd><p>binary variable for current violent offense</p>
</dd>
<dt>PendingChargeAtTimeOfOffense</dt><dd><p>binary variable for pending charge (felony, misdemeanor, or both) at the time of offense</p>
</dd>
<dt>PriorMisdemeanorConviction</dt><dd><p>binary variable for prior conviction of misdemeanor</p>
</dd>
<dt>PriorFelonyConviction</dt><dd><p>binary variable for prior conviction of felony</p>
</dd>
<dt>PriorViolentConviction</dt><dd><p>four-level ordinal variable for prior violent conviction</p>
</dd>
</dl>


<hr>
<h2 id='TestMonotonicity'>Test monotonicity</h2><span id='topic+TestMonotonicity'></span>

<h3>Description</h3>

<p>Test monotonicity using frequentist analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestMonotonicity(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestMonotonicity_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Message indicating whether the monotonicity assumption holds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
TestMonotonicity(synth)

</code></pre>

<hr>
<h2 id='TestMonotonicityRE'>Test monotonicity with random effects</h2><span id='topic+TestMonotonicityRE'></span>

<h3>Description</h3>

<p>Test monotonicity using frequentist analysis with random effects for the hearing date of the case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestMonotonicityRE(data, formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestMonotonicityRE_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of which columns consists of pre-treatment covariates, a binary treatment (Z), an ordinal decision (D), and an outcome variable (Y). The column names of the latter three should be specified as &quot;Z&quot;, &quot;D&quot;, and &quot;Y&quot; respectively.</p>
</td></tr>
<tr><td><code id="TestMonotonicityRE_+3A_formula">formula</code></td>
<td>
<p>A formula of the model to fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Message indicating whether the monotonicity assumption holds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synth)
data(hearingdate_synth)
synth$CourtEvent_HearingDate = hearingdate_synth
TestMonotonicityRE(synth, formula = "Y ~ Sex + White + Age + 
                   CurrentViolentOffense + PendingChargeAtTimeOfOffense + 
                   PriorMisdemeanorConviction + PriorFelonyConviction + 
                   PriorViolentConviction + (1|CourtEvent_HearingDate) + D")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
