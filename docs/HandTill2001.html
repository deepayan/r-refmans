<!DOCTYPE html><html><head><title>Help for package HandTill2001</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HandTill2001}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc-methods'><p>Methods for Function <code>auc</code> in Package <span class="pkg">HandTill2001</span></p></a></li>
<li><a href='#bincap'><p>A Constructor for Objects of Class <code>bincap</code></p></a></li>
<li><a href='#bincap-class'><p>Binary Class and Prediction Objects</p></a></li>
<li><a href='#cap-class'><p>Class and Prediction Objects</p></a></li>
<li><a href='#HandTill2001-package'><p>Multiple Class Area under ROC Curve</p></a></li>
<li><a href='#ht01.multipleclass'><p>Example Data for Multiple Classes</p></a></li>
<li><a href='#ht01.twoclass'><p>Example Data for Binary Classes</p></a></li>
<li><a href='#multcap'><p>A Constructor for Objects of Class <code>multcap</code></p></a></li>
<li><a href='#multcap-class'><p>Multiple Class and Prediction Objects</p></a></li>
<li><a href='#throw'><p>Throw a Condition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Class Area under ROC Curve</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An S4 implementation of Eq. (3) and Eq. (7) by
    David J. Hand and Robert J. Till (2001) &lt;<a href="https://doi.org/10.1023%2FA%3A1010920819831">doi:10.1023/A:1010920819831</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/fvafrCU/HandTill2001">https://gitlab.com/fvafrCU/HandTill2001</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caTools, devtools, knitr, MASS, mda, nnet, pkgload,
rmarkdown, ROCR, rpart, rprojroot, RUnit, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-02 08:35:48 UTC; qwer</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Dominik Cullmann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Dominik Cullmann &lt;fvafrcu@mailbox.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-02 09:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc-methods'>Methods for Function <code>auc</code> in Package <span class="pkg">HandTill2001</span></h2><span id='topic+auc-methods'></span><span id='topic+auc'></span><span id='topic+auc+2Cbincap-method'></span><span id='topic+auc+2Cmultcap-method'></span>

<h3>Description</h3>

<p>Calculate area under curve of the receiver operating characteristic for
two or more prediction classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bincap'
auc(object)

## S4 method for signature 'multcap'
auc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc-methods_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> <em>bincap</em> or <em>multcap</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on whether <code>object</code> is of class <code>bincap</code> or of class
<code>multcap</code>, a binary class or multiple class AUC is calculated.
</p>


<h3>Value</h3>

<p>An object of class <code>"numeric"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>signature(object = &quot;bincap&quot;)</dt><dd><p> calculates the AUC statistic
for a binary class response following <cite>Hand and Till (2001)</cite>, Eq. (3). </p>
</dd>
<dt>signature(object = &quot;multcap&quot;)</dt><dd><p> calculates the AUC statistic
for a multiple class response following <cite>Hand and Till (2001)</cite>, Eq.
(7). </p>
</dd> </dl>



<h3>References</h3>

<p><cite>David J. Hand and Robert J. Till (2001). A Simple
Generalisation of the Area Under the ROC Curve for Multiple Class
Classification Problems. <em>Machine Learning</em> <b>45</b>(2), p. 171&ndash;186.
DOI:
<a href="http://dx.doi.org/10.1023/A:1010920819831">10.1023/A:1010920819831</a></cite>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bincap-class">class?bincap</a></code>,
<code><a href="#topic+multcap-class">class?multcap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ht01.twoclass, package = "HandTill2001")
message(" == AUC for a binary class response")
message(" == == HandTill2001 result:")
HandTill2001::auc(HandTill2001::bincap(
  response = as.factor(ht01.twoclass[["observed"]]),
  predicted = ht01.twoclass[["predicted"]],
  true = "1"
))
## Not run: 
message(" == == ROCR result:")
ROCR::performance(ROCR::prediction(
  labels = ht01.twoclass[["observed"]],
  predictions = ht01.twoclass[["predicted"]]
),
measure = "auc"
)@y.values

## End(Not run)
data(ht01.multipleclass, package = "HandTill2001")
message(" == AUC for a multiple class response")
predicted &lt;- as.matrix(ht01.multipleclass[, levels(ht01.multipleclass[["observed"]])])
HandTill2001::auc(HandTill2001::multcap(
  response = ht01.multipleclass[["observed"]],
  predicted = predicted
))
</code></pre>

<hr>
<h2 id='bincap'>A Constructor for Objects of Class <code>bincap</code></h2><span id='topic+bincap'></span>

<h3>Description</h3>

<p><code>bincap(...)</code> is an alias to <code>new("bincap", ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bincap(response, predicted, true = "1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bincap_+3A_response">response</code></td>
<td>
<p>Object of class <code>factor</code>.</p>
</td></tr>
<tr><td><code id="bincap_+3A_predicted">predicted</code></td>
<td>
<p>Object of class <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="bincap_+3A_true">true</code></td>
<td>
<p>Object of class <code>character</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no casting or conversion of data. <code>bincap(...)</code> is just an
alias to <code>new("bincap", ...)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bincap</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bincap-class">class?HandTill2001::bincap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(HandTill2001)
data(ht01.twoclass)
str(ht01.twoclass$observed)
message("note that ht01.twoclass$observed is not a factor; we have to convert it.")
bincap(
  response = as.factor(ht01.twoclass$observed),
  predicted = ht01.twoclass$predicted,
  true = c("1")
)
</code></pre>

<hr>
<h2 id='bincap-class'>Binary Class and Prediction Objects</h2><span id='topic+bincap-class'></span>

<h3>Description</h3>

<p>S4 class for a binary class response and corresponding (predicted)
probabilities.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("bincap", ...)</code>. They are used to store a binary class response
(one
of the two <code>levels</code> of which is supposed to be <code>true</code>), the
information which of the two <code>levels</code> of the binary class response is
thought of as 'true'/'positive'/'present' (the other one would then be
thought of as 'false'/'negative'/'absence') and the predicted probabilities
that <code>response</code> is <code>true</code>.
</p>


<h3>Note</h3>

<p>No defaults are set. Especially, you have to explicitly initialize
<code>true</code>, there is no trying to guess it from the <code>levels</code> of
<code>response</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cap-class">class?HandTill2001::cap</a></code> ,
<code><a href="#topic+multcap-class">class?HandTill2001::multcap</a></code> ,
<code><a href="#topic+bincap">?HandTill2001::bincap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("bincap")
</code></pre>

<hr>
<h2 id='cap-class'>Class and Prediction Objects</h2><span id='topic+cap-class'></span>

<h3>Description</h3>

<p>A virtual class for <code>bincap</code> and <code>multcap</code>.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created
from it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bincap-class">class?HandTill2001::bincap</a></code>,
<code><a href="#topic+multcap-class">class?HandTill2001::multcap</a></code>
</p>

<hr>
<h2 id='HandTill2001-package'>Multiple Class Area under ROC Curve</h2><span id='topic+HandTill2001-package'></span><span id='topic+HandTill2001'></span>

<h3>Description</h3>

<p>A very lean package implementing merely <code class="reqn">M</code> given by <cite>Hand and Till
(2001)</cite>, Eq. (7).
</p>


<h3>Details</h3>

<p><code class="reqn">M</code> given by <cite>Hand and Till (2001)</cite> defines a multiple class
version of the area under curve of the receiver operating characteristic.
</p>


<h3>References</h3>

<p><cite>David J. Hand and Robert J. Till (2001). A Simple
Generalisation of the Area Under the ROC Curve for Multiple Class
Classification Problems. <em>Machine Learning</em> <b>45</b>(2), p. 171&ndash;186.
DOI:
<a href="http://dx.doi.org/10.1023/A:1010920819831">10.1023/A:1010920819831</a></cite>.
</p>


<h3>See Also</h3>

<p><code>help(package="HandTill2001")</code>, especially
<code><a href="#topic+auc-methods">?HandTill2001::auc</a></code>; various packages that calculate
binary class AUC (<code><a href="ROCR.html#topic+performance">ROCR</a></code>) or multiple class AUC
(pROC, <code><a href="caTools.html#topic+caTools-package">caTools</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(HandTill2001)
data(ht01.multipleclass)
auc(
  multcap(
    response = ht01.multipleclass$observed,
    predicted = as.matrix(ht01.multipleclass[, levels(ht01.multipleclass$observed)])
  )
)
</code></pre>

<hr>
<h2 id='ht01.multipleclass'>Example Data for Multiple Classes</h2><span id='topic+ht01.multipleclass'></span>

<h3>Description</h3>

<p>Multiple class data and probability predictions thereof.
</p>


<h3>Format</h3>

<p>A data frame with 214 observations on the following 7 variables.
</p>

<dl>
<dt>observed</dt><dd><p>a factor with levels
<code>Con</code> <code>Head</code> <code>Tabl</code> <code>Veh</code>
<code>WinF</code> <code>WinNF</code></p>
</dd>
<dt>WinF</dt><dd><p>a numeric vector</p>
</dd>
<dt>WinNF</dt><dd><p>a numeric vector</p>
</dd>
<dt>Veh</dt><dd><p>a numeric vector</p>
</dd>
<dt>Con</dt><dd><p>a numeric vector</p>
</dd>
<dt>Tabl</dt><dd><p>a numeric vector</p>
</dd>
<dt>Head</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Multiple class data ('observed': <code>MASS::fgl$type</code>) and probability
predictions (<code>predict(fgl.rp4)</code>, cf. Venables and Ripley (2002), p. 264
and &lsquo;Source&rsquo;) from <code>rpart::rpart</code>.
</p>


<h3>Source</h3>

<pre> ## From: Forensic glass example Venables and Ripley
(2002) pp. 261--265 library(MASS);library(rpart);data(fgl);set.seed(123)
fgl.rp4 &lt;- rpart(type ~ ., data = fgl, cp = 0.03 , parms = list(split =
"information")) ht01.multipleclass &lt;- data.frame(observed = fgl$type,
predict(fgl.rp4)) write.table(ht01.multipleclass, file =
"ht01.multipleclass.txt") </pre>


<h3>References</h3>

<p>Venables, W. N and Ripley, B. D. (2002), <em>Modern Applied
Statistics with S</em> (4th edition). Springer, ISBN 0-387-95457-0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(HandTill2001)
data(ht01.multipleclass)
str(ht01.multipleclass)
</code></pre>

<hr>
<h2 id='ht01.twoclass'>Example Data for Binary Classes</h2><span id='topic+ht01.twoclass'></span>

<h3>Description</h3>

<p>Binary class data and probability predictions thereof.
</p>


<h3>Format</h3>

<p>A data frame with 189 observations on the following 2 variables.
</p>
 <dl>
<dt>observed</dt><dd><p>a numeric vector</p>
</dd>
<dt>predicted</dt><dd><p>a numeric vector</p>
</dd> </dl>



<h3>Details</h3>

<p>Binary class data ('observed': <code>MASS::birthwt$low</code>) and probability
predictions
(<code>predict(birthwt.step2, type = "response")</code>, cf. Venables and Ripley
(2002), pp. 195f and &lsquo;Source&rsquo;) from <code>stats::glm</code>.
</p>


<h3>Source</h3>

<pre> ## From: A binary class data example Venables and
Ripley pp. 194--199 library(MASS); data("birthwt"); attach(birthwt) race &lt;-
(factor(race, labels = c("white", "black", "other"))) ptd &lt;- factor(ptl &gt; 0)
ftv &lt;- factor(ftv) levels(ftv)[-(1:2)] &lt;- "2+" bwt &lt;- data.frame(low =
factor(low), age, lwt, race, smoke = (smoke &gt; 0) , ptd, ht = (ht &gt; 0), ui =
(ui &gt; 0), ftv) detach(birthwt) birthwt.glm &lt;- glm(low ~ .,
family=binomial(link=logit), data=bwt) birthwt.step2 &lt;- stepAIC(birthwt.glm,
~ .^2 + I(scale(age)^2) + I(scale(lwt)^2), trace = F ) ht01.twoclass &lt;-
data.frame(observed = bwt$low , predicted = predict(birthwt.step2 , type =
"response")) write.table(ht01.twoclass, file = "ht01.twoclass.txt") </pre>


<h3>References</h3>

<p>Venables, W. N and Ripley, B. D. (2002), <em>Modern Applied
Statistics with S</em> (4th edition). Springer, ISBN 0-387-95457-0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(HandTill2001)
data(ht01.twoclass)
str(ht01.twoclass)
</code></pre>

<hr>
<h2 id='multcap'>A Constructor for Objects of Class <code>multcap</code></h2><span id='topic+multcap'></span>

<h3>Description</h3>

<p><code>multcap(...)</code> is an alias to <code>new("multcap", ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multcap(response, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multcap_+3A_response">response</code></td>
<td>
<p>Object of class <code>factor</code>.</p>
</td></tr>
<tr><td><code id="multcap_+3A_predicted">predicted</code></td>
<td>
<p>Object of class <code>matrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no casting or conversion of data. <code>multcap(...)</code> is just
an alias to <code>new("multcap", ...)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>multcap</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multcap-class">class?HandTill2001::multcap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(HandTill2001)
data(ht01.multipleclass)
str(ht01.multipleclass$observed)
message("note that ht01.multipleclass$observed is a factor; we do not have to convert it.")
multcap(
  response = ht01.multipleclass$observed,
  predicted = as.matrix(ht01.multipleclass[, levels(ht01.multipleclass$observed)])
)
</code></pre>

<hr>
<h2 id='multcap-class'>Multiple Class and Prediction Objects</h2><span id='topic+multcap-class'></span>

<h3>Description</h3>

<p>S4 class for a multiple class response and corresponding (predicted)
probabilities.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("multcap", ...)</code>. They are used to store a multiple class response
and the predicted probabilities for each of the <code>levels(response)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cap-class">class?HandTill2001::cap</a></code> ,
<code><a href="#topic+bincap-class">class?HandTill2001::bincap</a></code> ,
<code><a href="#topic+multcap">?HandTill2001::multcap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("multcap")
</code></pre>

<hr>
<h2 id='throw'>Throw a Condition</h2><span id='topic+throw'></span>

<h3>Description</h3>

<p>Throws a condition of class c(&quot;error&quot;, &quot;HandTill2001&quot;, &quot;condition&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>throw(message_string, system_call = sys.call(-1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="throw_+3A_message_string">message_string</code></td>
<td>
<p>The message to be thrown.</p>
</td></tr>
<tr><td><code id="throw_+3A_system_call">system_call</code></td>
<td>
<p>The call to be thrown.</p>
</td></tr>
<tr><td><code id="throw_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to
<code><a href="base.html#topic+structure">base::structure</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use this condition as an error dedicated to <span class="pkg"> HandTill2001.</span>
</p>


<h3>Value</h3>

<p>The function does never return anything, it stops with a
condition of class c(&quot;error&quot;, &quot;HandTill2001&quot;, &quot;condition&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch(HandTill2001:::throw("Hello error!"), HandTill2001 = function(e) {
  return(e)
})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
