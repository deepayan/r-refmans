<!DOCTYPE html><html><head><title>Help for package zonohedra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zonohedra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#zonohedra-package'><p>zonhedra package</p></a></li>
<li><a href='#boundarypgramdata'>
<p>compute data about specific parallelograms in the boundary of a zonohedron</p></a></li>
<li><a href='#genlist'>
<p>zonohedra generators useful for testing and plotting</p></a></li>
<li><a href='#getmetrics.zonohedron'><p>Get Important Metrics about a Zonohedron, and Print and Summarize Them</p></a></li>
<li><a href='#grpDuplicated'>
<p>Grouping by duplicated elements</p></a></li>
<li><a href='#inside'>
<p>test points for being inside a zonotope</p></a></li>
<li><a href='#inside2trans'>
<p>test points against a 2-transition surface</p></a></li>
<li><a href='#invertboundary'>
<p>invert points on the boundary of a zonohedron</p></a></li>
<li><a href='#lintransform'>
<p>linear transformations of zonotopes, and vector matroids</p></a></li>
<li><a href='#matroid'>
<p>matroid construction</p></a></li>
<li><a href='#matroid-getters'>
<p>matroid get functions</p></a></li>
<li><a href='#matroid-props'>
<p>matroid properties</p></a></li>
<li><a href='#minkowskisum'>
<p>Minkowski sum of Two zonotopes</p></a></li>
<li><a href='#plot2trans'>
<p>plot the 2-transition surface associated with a zonohedron</p></a></li>
<li><a href='#plothighertrans'>
<p>plot abundant and deficient parallelograms</p></a></li>
<li><a href='#plotpolygon'>
<p>plot the <em>generator polygon</em> associated with a pointed zonohedron</p></a></li>
<li><a href='#print'><p>Print Basic Facts about a Matroid</p></a></li>
<li><a href='#print.genlist'><p>Print Basic Metrics for Each Zonohedron Generated by the Matrices in a <b>genlist</b> object</p></a></li>
<li><a href='#rank'>
<p>Rank and Independence</p></a></li>
<li><a href='#raytrace2trans'>
<p>compute the intersection of a ray and the 2-transition surface</p>
associated with a zonohedron</a></li>
<li><a href='#section2trans'>
<p>compute the intersection of a plane and the</p>
2-transition surface associated with a zonohedron</a></li>
<li><a href='#simplify'>
<p>simplify and unsimplify</p></a></li>
<li><a href='#spherize'>
<p>spherize a zonotope</p></a></li>
<li><a href='#support'>
<p>the support function for a zonotope</p></a></li>
<li><a href='#symmetrize'>
<p>symmetrize a zonotope</p></a></li>
<li><a href='#transitionsdf'>
<p>summarize the number of transitions and associated data,</p>
over all parallelograms in the boundary of a zonohedron</a></li>
<li><a href='#zonogon'>
<p>zonogon construction</p></a></li>
<li><a href='#zonogon-getmetrics'>
<p>get important metrics about a zonogon,</p>
and print basic facts about a zonogon.</a></li>
<li><a href='#zonogon-invert'>
<p>invert points in a zonogon</p></a></li>
<li><a href='#zonogon-plot'>
<p>plot a zonogon</p></a></li>
<li><a href='#zonogon-raytrace'>
<p>compute the intersection of a ray, based in the interior of</p>
a zonogon, and the boundary of that zonogon</a></li>
<li><a href='#zonogon-section'>
<p>compute the intersection of a line and the boundary of a zonogon</p></a></li>
<li><a href='#zonohedron'>
<p>zonohedron construction</p></a></li>
<li><a href='#zonohedron-plot'>
<p>plot a zonohedron</p></a></li>
<li><a href='#zonohedron-raytrace'>
<p>compute the intersection of a ray, based in the interior of</p>
a zonohedron, and the boundary of that zonohedron</a></li>
<li><a href='#zonohedron-section'>
<p>compute the intersection of a plane and the boundary of a zonohedron</p></a></li>
<li><a href='#zonoseg'>
<p>zonoseg construction, querying, and printing</p></a></li>
<li><a href='#zonoseg-invert'>
<p>invert points in a zonoseg</p></a></li>
<li><a href='#zonotope-getters'>
<p>zonotope get functions</p></a></li>
<li><a href='#zonotope-props'><p>zonotope properties</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute and Plot Zonohedra from Vector Generators</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>logger</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, orientlib, microbenchmark, arrangements, knitr,
rmarkdown, gifski</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes a zonohedron from real vector generators.  The package also computes zonogons (2D zonotopes) and zonosegs (1D zonotopes).  An elementary S3 class for matroids is included, which supports matroids with rank 3, 2, and 1.  Optimization methods are taken from Heckbert (1985) <a href="https://www.cs.cmu.edu/~ph/zono.ps.gz">https://www.cs.cmu.edu/~ph/zono.ps.gz</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Glenn Davis [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Glenn Davis &lt;gdavis@gluonics.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-06 23:48:07 UTC; Glenn</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='zonohedra-package'>zonhedra package</h2><span id='topic+zonohedra-package'></span>

<h3>Description</h3>

<p>This package deals with <em>zonohedra</em>, which are zonotopes of dimension 3.
It also handles <em>zonogons</em> (2D zonotopes)
and <em>zonosegs</em> (1D zonotopes).
</p>
<p>The term <em>zonoseg</em> (&quot;zonotope&quot; + &quot;segment&quot;) is my own personal term;
I could not find an alternative term.
It is a linear image of the unit cube <code class="reqn">[0,1]^n</code> in the real numbers,
and a compact segment of reals.
</p>


<h3>S3 classes</h3>


<table>
<tr>
 <td style="text-align: center;">
<code>Z</code>   </td><td style="text-align: center;"> <code>class(Z)</code>  </td>
</tr>
<tr>
 <td style="text-align: center;">
<b>zonohedron</b> </td><td style="text-align: center;"> <code>"zonohedron" "zonotope" "list"</code>  </td>
</tr>
<tr>
 <td style="text-align: center;">
<b>zonogon</b>    </td><td style="text-align: center;"> <code>"zonogon" "zonotope" "list"</code>  </td>
</tr>
<tr>
 <td style="text-align: center;">
<b>zonoseg</b>    </td><td style="text-align: center;"> <code>"zonoseg" "zonotope" "list"</code>  </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>For example, the <code>section()</code> returns very diffferent things
for a zonohedron and a zonogon, and so
<code>section.zonohedron()</code> and <code>section.zonogon()</code>
are coded and documented separately.
A section for a zonoseg does not make sense,
so <code>section.zonoseg()</code> is undefined.
</p>


<h3>Terminology</h3>

<p>For a convex polytope, a <em>supporting hyperplane</em> is a hyperplane
that intersect the polytope's boundary but <em>not</em> its interior.
<br />
A zonotope is a convex polytope.
A zonohedron has supporting planes,
and a zonogon has supporting lines.
<br /><br />
In the package <span class="pkg">zonohedra</span>,
a <em>zonotope</em> mean a zonotope of dimension 3, 2, or 1.
<br /><br />
A <em>face</em> of a zonotope is the intersection of the boundary
of the zonotope with some supporting hyperplane.
A <em>d-face</em> is a face of dimension <em>d</em>.
So a <em>0-face</em> is a <em>vertex</em>,
and a <em>1-face</em> is an <em>edge</em>.
<br /><br />
A <em>facet</em> of a zonotope is a face whose dimension is
1 less than the dimension of the zonotope.
A facet is a maximal proper face.
<br /><br />
A zonohedron has 0-faces (vertices), 1-faces (edges),
and 2-faces (facets).
<br /><br />
A zonogon has 0-faces (vertices) and 1-faces (edges).
Since the dimension of an edge is 1 less than the
dimension of the zonogon, an edge of a zonogon is also a facet
of a zonogon.
</p>

<hr>
<h2 id='boundarypgramdata'>
compute data about specific parallelograms in the boundary of a zonohedron
</h2><span id='topic+boundarypgramdata'></span>

<h3>Description</h3>

<p>The boundary of a zonohedron is the union of parallelograms,
where some of them may be facets, and some may be tiles
in the standard tiling of more complex facets.
The edges of each parallelogram are given by a pair of distinct simplified generators.
If a zonohedron has <code class="reqn">n</code> of these generators,
then there are <code class="reqn">n(n{-}1)/2</code> such pairs.
For each pair of generators,
there are 2 parallelograms which are antipodal to each other.
This function computes data about one parallelogram from this antipodal pair.
The total number of parallelograms is <code class="reqn">n(n{-}1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundarypgramdata( x, gndpair, cube=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundarypgramdata_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="boundarypgramdata_+3A_gndpair">gndpair</code></td>
<td>

<p>an Mx2 integer matrix.
Each row of <code>gndpair</code> must contain a pair of points
in the ground set of the simplified matroid of the zonohedron <code>x</code>.
The 1st point must be less that the 2nd point.
<br />
<code>gndpair</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
<tr><td><code id="boundarypgramdata_+3A_cube">cube</code></td>
<td>

<p>if <code>TRUE</code>, then a point of the cube that maps to the center
of the given parallelogram is returned, see <b>Value</b>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boundarypgramdata()</code> returns a <code>data.frame</code>
with M rows and these columns:
</p>
<table>
<tr><td><code>gndpair</code></td>
<td>
<p>the given <code>gndpair</code></p>
</td></tr>
<tr><td><code>hyperplaneidx</code></td>
<td>

<p>the index of the hyperplane in the simplified matroid
of <code>x</code> that contains <code>gndpair</code>
</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>the center of the parallelogram <em>relative to the center of
the zonohedron</em>.
For the antipodal parallelogram, multiply this by -1.
</p>
</td></tr>
<tr><td><code>transitions</code></td>
<td>

<p>the number of transitions in <code>pcube</code> - a point in the n-cube
that maps to <code>center</code>.
This is a non-negative even integer.
</p>
</td></tr>
</table>
<p>And if <code>cube</code> is <code>TRUE</code>, then this column is added:
</p>
<table>
<tr><td><code>pcube</code></td>
<td>

<p>a point in the n-cube that maps to <code>center</code>.
For the antipodal parallelogram, subtract this from 1;
the number of transitions is the same.
</p>
</td></tr>
</table>
<p>If a row of <code>gndpair</code> has an invalid pair,
the other columns are filled with <code>NA</code>s.
</p>
<p>In case of global error, the function returns <code>NULL</code>.
</p>


<h3>WARNING</h3>

<p>In this version of the package,
when the parallelogram is a tile in a more complex facet,
the function may return incorrect results.
This will be fixed in a future version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>
</p>

<hr>
<h2 id='genlist'>
zonohedra generators useful for testing and plotting
</h2><span id='topic+genlist'></span><span id='topic+classics.genlist'></span><span id='topic+colorimetry.genlist'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>classics.genlist</code> </td><td style="text-align: left;"> 13 classic zonohedra generators</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>colorimetry.genlist</code> </td><td style="text-align: left;"> 4 sets of Color Matching Functions (each set is a 3xN matrix)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Format</h3>

<p>Each is an S3 class <b>genlist</b> object organized as a list of 3xN matrices (N varies).
The list must have names, preferably short names or abbreviations.
Each matrix can have optional attributes 
<code>"shortname"</code> and <code>"fullname"</code>
which are useful when printing with <code><a href="#topic+print.genlist">print.genlist</a>()</code>.
</p>


<h3>Note</h3>

<p>Making these S3 class <b>genlist</b> makes it possible to easily
print a short summary using <code><a href="#topic+print.genlist">print.genlist</a>()</code>.
</p>
<p>For colorimetry.genlist[[2]] a few remarks are in order.
These generators come from the xyz CIE color matching functions of 1931,
from 360 to 830 nm with 1 nm step.
From 699 to 830 nm, the angles between the generators only differ by a few microradians,
and it apparent that the designers tapered all 3 functions identically in that nm range.
For an illustration of this in the chromaticity domain, see Burns, Figure 10.
When the zonohedron is constructed from these 132 generators, with the default options,
all these generators a 'collapsed' into a single one.
In the original matroid these 132 <em>points</em> form a <em>multiple group</em>,
and in the simplified matroid they are collapsed to a single <em>point</em>, labeled with 699.
</p>


<h3>Source</h3>

<p>David Eppstein.
<b>Zonohedra and Zonotopes</b>.
<br />
<a href="https://www.ics.uci.edu/~eppstein/junkyard/ukraine/ukraine.html">https://www.ics.uci.edu/~eppstein/junkyard/ukraine/ukraine.html</a>
</p>
<p>Colour &amp; Vision Research Laboratory.
University College London.
<a href="http://www.cvrl.org">http://www.cvrl.org</a>
</p>


<h3>References</h3>

<p>ASTM E 308 - 01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
Table 1 
</p>
<p>Scott A Burns.
<b>The location of optimal object colors with more than two transitions</b>.
Color Research &amp; Application.
Vol. 46.
No. 6.
pp 1180-1193.
2021.
</p>
<p>GÃ¼nther Wyszecki and W.S. Stiles.
<b>Color Science : Concepts and Methods, Quantitative Data and Formulae</b>.
Second Edition.
Wiley-Interscience. 1982.
Table I(3.3.1).
pp. 723-735.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.genlist">print.genlist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the names of 3 sets of color matching functions
names(colorimetry.genlist)
# [1] "xyz1931.5nm" "xyz1931.1nm" "lms2000.1nm"


# print zonohedra metrics associated with 3 sets of color matching functions
colorimetry.genlist
#                            fullname generators vertices  edges facets      area     volume pointed
# xyz1931.5nm  xyz at 5nm step                81     5100  10146   5048  1582.722   4070.345    TRUE
# xyz1931.1nm  xyz at 1nm step               471   112910 225720 112812 39586.707 509434.149    TRUE
# lms2000.1nm  lms at 1nm step               441   146642 292860 146220 22736.652 181369.085    TRUE
# ciexyzjv.5nm xyz at 5nm step (1978)         90     8012  16020   8010  1553.535   3951.899    TRUE
</code></pre>

<hr>
<h2 id='getmetrics.zonohedron'>Get Important Metrics about a Zonohedron, and Print and Summarize Them</h2><span id='topic+getmetrics'></span><span id='topic+getmetrics.zonohedron'></span><span id='topic+print.zonohedron'></span><span id='topic+summary.zonohedron'></span>

<h3>Description</h3>

<p>Get some important zonohedron metrics; for most some computation is needed.
<br /><br />
The <code>print()</code> function prints nicely formatted
facts about a zonohedron, including its matroid.
<br /><br />
The <code>summary()</code> function prints a single-line summary,
formatted as a row in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonohedron'
getmetrics( x )

## S3 method for class 'zonohedron'
print( x, trans2=FALSE, matroid=TRUE, ... )

## S3 method for class 'zonohedron'
summary( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmetrics.zonohedron_+3A_x">x</code></td>
<td>
<p>a <code>zonohedron</code> object as returned by the constructor <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="getmetrics.zonohedron_+3A_trans2">trans2</code></td>
<td>
<p>if <code>TRUE</code> then print extra metrics on the 2-transition surface associated with <code>x</code></p>
</td></tr>
<tr><td><code id="getmetrics.zonohedron_+3A_matroid">matroid</code></td>
<td>
<p>if <code>TRUE</code> then print extra information about the matroid associated with <code>x</code></p>
</td></tr>
<tr><td><code id="getmetrics.zonohedron_+3A_object">object</code></td>
<td>
<p>a <code>zonohedron</code> object as returned by the constructor <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="getmetrics.zonohedron_+3A_...">...</code></td>
<td>
<p>for <code>print()</code> further arguments are ignored;
for <code>summary()</code> the further arguments can be *more* zonohedron objects, which are summarized by adding more rows to the same data frame; see <b>Examples</b>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getmetrics.zonohedron()</code> returns a list with these items:
</p>
<table>
<tr><td><code>vertices</code></td>
<td>
<p>the number of vertices</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>the number of edges</p>
</td></tr>
<tr><td><code>facets</code></td>
<td>
<p>the number of facets (2D faces); all of them are zonogons</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>the sum of the areas of all the facets</p>
</td></tr>
<tr><td><code>volume</code></td>
<td>
<p>as a polytope</p>
</td></tr>
</table>
<p>All of these are always positive.
<br /><br />
<code>print.zonohedron()</code> returns <code>TRUE</code> or <code>FALSE</code>.
<br /><br />
<code>summary.zonohedron()</code> returns a data frame, see <b>Examples</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genlist">genlist</a></code>,
<code><a href="#topic+zonohedron">zonohedron</a>()</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zono = zonohedron( classics.genlist[['BD']] )
zono
# zonohedron:
# fullname:                          Bilinski dodecahedron 
# generators (original):             4 
# generators with multiples:         0 
# generators (simplified):           4 
# number of facets:                  12  [6 antipodal facet-pairs]
# facets that contain 0:             4    { 1 3 4 6 }
# number of edges:                   24 
# center:                            0.809017 2.118034 1.309017 
# pointed:                           TRUE 
# salient:                           TRUE 
# area:                              38.83282 
# volume:                            16.94427 
# 
# matroid:
# ground set:           4 points   {1 2 3 4}
# hyperplanes:          6     {1 2}  {1 3}  {1 4}  {2 3}  {2 4}  {3 4}
# rank:                 3
# loops:                0   {}
# multiple groups:      0   {}
# uniform:              TRUE
# paving:               TRUE
# simple:               TRUE
# This matroid is constructed from a 3x4 real matrix.
#             1        2        3         4
# [1,] 1.000000 1.618034 0.000000 -1.000000
# [2,] 1.618034 0.000000 1.000000  1.618034
# [3,] 0.000000 1.000000 1.618034  0.000000


summary( zono )
#                fullname generators vertices edges facets     area   volume
# 1 Bilinski dodecahedron          4       14    24     12 38.83282 16.94427

zono4 = zonohedron( classics.genlist[['RI']] )
zono7 = zonohedron( classics.genlist[['TO']] )
summary( zono, zono4, zono7 )
#                fullname generators vertices edges facets     area   volume
# 1 Bilinski dodecahedron          4       14    24     12 38.83282 16.94427
# 2   rhombic icosahedron          5       22    40     20 64.72136 42.36068
# 3  truncated octahedron          6       24    36     14 53.56922 32.00000
</code></pre>

<hr>
<h2 id='grpDuplicated'>
Grouping by duplicated elements
</h2><span id='topic+grpDuplicated'></span><span id='topic+grpDuplicated.default'></span><span id='topic+grpDuplicated.matrix'></span>

<h3>Description</h3>

<p><code>grpDuplicated()</code> is a generic function that takes an indexed set
of &quot;elements&quot;, and outputs an integer vector with the same length.
The &quot;elements&quot; can be components of a vector,
or the row vectors or column vectors of a matrix.
In the output vector, a component is 0 if and only if the corresponding
element is unique.
When the element is unique, it forms a <em>singleton group</em>.
Output components have equal positive integer values
if and only if the corresponding elements are identical to each other.
These elements form a <em>non-singleton group</em>,
and the positive integer is called the <em>group number</em>.
</p>
<p>The number of singleton groups is equal to #(zeros),
which is equal to the #(elements) - #(duplicated elements).<br />
The number of non-singleton groups is equal to max(output vector).<br /> 
The number of all groups is equal to #(zeros) + max(output vector).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
grpDuplicated( x, ... )
	
## S3 method for class 'matrix'
grpDuplicated( x, MARGIN=1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpDuplicated_+3A_x">x</code></td>
<td>
<p>a vector or matrix of atomic mode <code>"numeric"</code>, <code>"integer"</code>, <code>"logical"</code>, <code>"complex"</code>, <code>"character"</code> or <code>"raw"</code>.  
</p>
</td></tr>
<tr><td><code id="grpDuplicated_+3A_margin">MARGIN</code></td>
<td>
<p>an integer scalar, the matrix margin to be held fixed, as in <code><a href="base.html#topic+apply">apply</a></code>. <code>MARGIN=1</code> means that it looks for duplicated rows, and <code>MARGIN=2</code> means that it looks for duplicated columns.  Other values are invalid.</p>
</td></tr>  
<tr><td><code id="grpDuplicated_+3A_...">...</code></td>
<td>
<p>arguments for particular methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is based on <code>std::unordered_map</code> in C++11,
which uses a hash-table.
</p>


<h3>Value</h3>

<p>The return value is an integer vector with all elements ranging from 0 to <code>K</code>, where <code>K</code> is the number of non-singleton groups.<br />
For vector <code>x</code> the elements are the vector components,
and the output is the same length as the input.<br />
For a matrix <code>x</code> with <code>MARGIN=1</code>, the elements are the rows of
the matrix and the output has length <code>nrow(x)</code>.<br />
For a matrix <code>x</code> with <code>MARGIN=2</code>, the elements are the columns of
the matrix and the output has length <code>ncol(x)</code>.<br />
The <code>'ngroups'</code> attribute of the returned vector is set to an integer 3-vector.
The 1st component is the total number of groups,
the 2nd component is the number of singleton groups,
and the 3rd component is the number of non-singleton groups <code>K</code>.
</p>


<h3>Note</h3>

<p>The templated C++ function that does the real work is taken from the package <b>uniqueAtomMat</b>
by Long Qu,
but the returned vector is slightly modified by Glenn Davis.<br />
</p>


<h3>Author(s)</h3>

<p>Long Qu and Glenn Davis
</p>


<h3>Source</h3>

<p><a href="https://github.com/cran/uniqueAtomMat/">https://github.com/cran/uniqueAtomMat/</a><br />
The package <b>uniqueAtomMat</b> was removed from CRAN by its author Long Qu.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)

#   test a numeric vector
x = rnorm(7)
y = rnorm(5)
grpDuplicated( c(x,y,rev(x)) )
##  [1] 7 6 5 4 3 2 1 0 0 0 0 0 1 2 3 4 5 6 7
##  attr(,"ngroups")
##  [1] 12  5  7

# test a numeric matrix, both rows and columns
A = matrix( rnorm(3*7), 3, 7 )
B = matrix( rnorm(3*5), 3, 5 )

#   the columns of cbind(A,B,A) have the duplicates one would expect
grpDuplicated( cbind(A,B,A), MARGIN=2 )
##  [1] 1 2 3 4 5 6 7 0 0 0 0 0 1 2 3 4 5 6 7
##  attr(,"ngroups")
##  [1] 12  5  7

# but the rows of cbind(A,B,A) are unique
grpDuplicated( cbind(A,B,A), MARGIN=1 )
##  [1] 0 0 0
##  attr(,"ngroups")
##  [1] 3 3 0
</code></pre>

<hr>
<h2 id='inside'>
test points for being inside a zonotope
</h2><span id='topic+inside'></span><span id='topic+inside.zonotope'></span>

<h3>Description</h3>

<p>Test points for being inside a zonotope.
The boundary points are considered to be inside.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
inside( x, p )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside_+3A_x">x</code></td>
<td>

<p>a <b>zonotope</b> object - a <b>zonohedron</b>, <b>zonogon</b>,
or <b>zonoseg</b>
</p>
</td></tr>
<tr><td><code id="inside_+3A_p">p</code></td>
<td>

<p>an NxM numeric matrix, where M is the dimension of the zonotope.
The points to be tested are in the rows.
<code>p</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The given zonotope is viewed as the intersection of <em>slabs</em>;
there is a slab for each hyperplane in the simplified matroid.
For each slab a signed distance to boundary of the slab
is computed.
For points outside the slab the distance is positive,
for points on the boundary, the distance is 0,
and for points in the interior of the slab the distance is negative.
The distance to the zonotope is computed as the
maximum over all these slab distances,
and the <em>critical hyperplane</em> index is recorded.
A point is inside iff the zonotope distance <code class="reqn">\le</code> 0.
</p>


<h3>Value</h3>

<p><code>inside.zonotope()</code> returns a <code>data.frame</code> with N rows and these columns:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>the given point</p>
</td></tr>
<tr><td><code>inside</code></td>
<td>
<p>whether the point is inside the zonotope. For boundary points, <code>inside</code> is <code>TRUE</code>.</p>
</td></tr>  
<tr><td><code>distance</code></td>
<td>
<p>the distance from the point to the zonotope. For boundary points, <code>distance</code> is 0.  When <code>distance</code> &gt; 0, it may be larger
than the true mathematical distance, so <code>distance</code> is really
a pseudo-distance.</p>
</td></tr>
<tr><td><code>idxhyper</code></td>
<td>
<p>the index of the <em>critical hyperplane</em> in the
simplified matroid. This is the index of the slab where the maximum slab distance was taken.
For a <b>zonoseg</b> there is only 1 hyperplane (the empty set)
so this is always 1.
</p>
</td></tr>
</table>
<p>If the row names of <code>p</code> are unique,
they are copied to the row names of the output.
<br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inside2trans">inside2trans</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zono1 = zonoseg( c(1,-2,3,0,-3,-4) )

getsegment(zono1)
# [1] -9 4

p = c( 0, -3*pi, pi, 2*pi, getsegment(zono1) )

inside( zono1, p )
#           p inside   distance idxhyper
# 1  0.000000   TRUE -4.0000000        1
# 2 -9.424778  FALSE  0.4247780        1
# 3  3.141593   TRUE -0.8584073        1
# 4  6.283185  FALSE  2.2831853        1
# 5 -9.000000   TRUE  0.0000000        1
# 6  4.000000   TRUE  0.0000000        1
</code></pre>

<hr>
<h2 id='inside2trans'>
test points against a 2-transition surface
</h2><span id='topic+inside2trans'></span>

<h3>Description</h3>

<p>This function tests points for being inside the 2-transition surface
associated with a zonohedron.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside2trans( x, p )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside2trans_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object
</p>
</td></tr>
<tr><td><code id="inside2trans_+3A_p">p</code></td>
<td>

<p>an Nx3 numeric matrix. The points to be tested are in the rows.
<code>p</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the surface has no self-intersections,
the the definition of whether a point <code>p</code> is
&quot;inside&quot; is fairly straightforward:
it is where the linking number of
<code>p</code> and the surface is non-zero.
In fact, if it is non-zero then it must be +1 or -1.
The <em>linking number</em> is analogous the <em>winding number</em>
in 2D, for more discussion see <b>Note</b>.
</p>
<p>Unfortunately, there is currently no test for whether the
surface <em>has</em> self-intersections,
For a bad surface with self-intersections,
the linking number might be any integer.
Since there is no such test,
we simply use the same non-zero linking number rule always.
</p>
<p>The computed <code>linkingnumber</code> is returned so that the user
can apply the non-zero rule, or the even-odd rule,
as appropriate for their situation.
These 2 rules are analogous to the two winding number rules
used for polygons in computer graphics,
see <b>Point in polygon</b>.
</p>
<p>The case where a point is <em>on</em> the surface
(i.e. the <code>distance</code> to the surface is 0) is problematic.
The <code>linkingnumber</code> is then undefined,
and we currently set <code>inside</code> to be undefined as well.
Thus <code>inside</code> should be interpreted as <em>strictly inside</em>.
However, in some situations, the user may want to consider
<code>inside</code> to be <code>TRUE</code> in this problematic case.
Or the user may want to consider points that are within
a very small epsilon of the surface,
where roundoff might have occurred, to have <code>inside=FALSE</code>
or <code>inside=NA</code>.
So the both the computed <code>linkingnumber</code> and <code>distance</code> are
returned so the user can use them
to make their own definition of what &quot;inside&quot; means.
</p>


<h3>Value</h3>

<p><code>inside2trans()</code> returns a <code>data.frame</code>
with N rows and these columns:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>the given point</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>the distance from the point to the surface.
This is the true Euclidean distance,
and not a &quot;pseudo-distance&quot; as in the case of <code><a href="#topic+inside">inside</a>()</code>.
If the point is on the surface, the <code>distance</code> should be 0
up to numerical precision.
</p>
</td></tr>
<tr><td><code>linkingnumber</code></td>
<td>
<p>the linking number of the point and the surface.
If the point is <em>on</em> the surface (<code>distance==0</code>),
the (mathematical) linking number is undefined,
and the computed <code>linkingnumber</code> is <code>NA</code> (integer).
</p>
</td></tr>
<tr><td><code>inside</code></td>
<td>
<p>whether the point is inside the surface; a logical.
This is currently set to <code>linkingnumber != 0</code>.
If the <code>linkingnumber</code> is <code>NA</code> (integer),
then <code>inside</code> is <code>NA</code> (logical).
</p>
</td></tr>  
<tr><td><code>timecalc</code></td>
<td>
<p>the time to do the calculations, in seconds</p>
</td></tr>
</table>
<p>If the row names of <code>p</code> are unique,
they are copied to the row names of the output.
<br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The standard definition of the
<em>linking number</em> of a point and a surface uses intersections with rays,
see the vignette
<a href="../doc/transitions.html">The 2-Transition Subcomplex and the 2-Transition Surface</a>
for the precise definition.
This is fine in theory, but in practice does not handle well
the case when the ray intersects the boundary of a parallelogram.
So this function uses an integral formula for the degree of a <em>linking map</em>
that reduces to summing the signed area of a lot of spherical triangles, see
<b>Spivak</b> p. 75 and
<b>Guillemin and Pollack</b> p. 188.
</p>


<h3>References</h3>

<p><b>Guillemin, Victor and Alan Pollack</b>.
<em>Differential Topology</em>.
Prentice-Hall.
1974.
</p>
<p><b>Point in polygon &mdash; Wikipedia, The Free Encyclopedia</b>.
<a href="https://en.wikipedia.org/w/index.php?title=Point_in_polygon&amp;oldid=1139808558">https://en.wikipedia.org/w/index.php?title=Point_in_polygon&amp;oldid=1139808558</a>.
2023.
</p>
<p><b>Spivak, Michael</b>.
<em>A Comprehensive Introduction to Differential Geometry</em>.
Volume 1.
3rd edition.
Publish or Perish.
1999.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inside">inside</a>()</code>
</p>

<hr>
<h2 id='invertboundary'>
invert points on the boundary of a zonohedron
</h2><span id='topic+invertboundary'></span><span id='topic+invertboundary.zonohedron'></span>

<h3>Description</h3>

<p>A <em>zonohedron</em> <code class="reqn">Z</code> is the image of a linear map
<code class="reqn">[0,1]^n \to Z \subset \bold{R}^3</code>, from the n-cube to 3D space.
For a point on the boundary of the zonohedron, this function
computes a point in the unit cube that maps to it.
All coordinates of the point in the cube are 0 or 1, 
except for two of them.
The point is not necessarily unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonohedron'
invertboundary( x, point, tol=5.e-14 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertboundary_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="invertboundary_+3A_point">point</code></td>
<td>

<p>Mx3 matrix with points on the boundary of <code>x</code> in the rows.
Such a matrix typically is returned by
<code><a href="#topic+raytrace.zonohedron">raytrace.zonohedron</a>()</code>
or
<code><a href="#topic+section.zonohedron">section.zonohedron</a>()</code>.
<code>point</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
<tr><td><code id="invertboundary_+3A_tol">tol</code></td>
<td>

<p>points that are not within <code>tol</code> of the boundary are
skipped, see <b>Details</b>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the boundary point, the function determines the facet
that contains it.
The <code>pcube</code> coordinates of the <em>base vertex</em> of this facet are
all 0 or 1, and fairly easy to determine.
If the facet is a parallelogram, the other two coordinates are
fairly easy to determine too.
If the facet is a zonogon with <code>K</code> generators, with <code>K&gt;2</code>,
then the unknown <code>K</code> coordinates are calculated
using <code><a href="#topic+invert.zonogon">invert.zonogon</a>()</code>.
<br />
Because of floating point behaviour, coordinates can be slightly
negative or slightly more than 1.
After the calculation, they are clamped to [0,1].
</p>


<h3>Value</h3>

<p><code>invertboundary.zonohedron()</code> returns a <code>data.frame</code>
with M rows and these columns:
</p>
<table>
<tr><td><code>point</code></td>
<td>
<p>the given boundary point</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>

<p>signed distance to the boundary of <code>x</code>;
for successful inversion its absolute value is <code class="reqn">\le</code> <code>tol</code>
</p>
</td></tr>
<tr><td><code>facetidx</code></td>
<td>
<p>index of the facet pair that contains the point</p>
</td></tr>
<tr><td><code>sign</code></td>
<td>
<p>sign of the facet pair; either +1 or -1</p>
</td></tr>
<tr><td><code>pcube</code></td>
<td>

<p>a point in the unit n-cube that maps to the given boundary point;
all coordinates of <code>pcube</code> are 0 or 1,
except for 2 of them.
</p>
</td></tr>
<tr><td><code>transitions</code></td>
<td>

<p>the number of transitions in <code>pcube</code> - a non-negative even integer
</p>
</td></tr>
</table>
<p>If a point <code>point</code> cannot be inverted, e.g. because
<code>distance</code> is too large, the other columns are all <code>NA</code>.  
</p>
<p>If the row names of <code>point</code> are unique,
they are copied to the row names of the output.
The column names of <code>pcube</code> are copied from the ground set of the
associated matroid.
<br /><br />
In case of global error, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+section.zonohedron">section.zonohedron</a>()</code>,
<code><a href="#topic+raytrace.zonohedron">raytrace.zonohedron</a>()</code>,
<code><a href="#topic+invert.zonogon">invert.zonogon</a>()</code>
</p>

<hr>
<h2 id='lintransform'>
linear transformations of zonotopes, and vector matroids
</h2><span id='topic+lintransform'></span><span id='topic+lintransform.matroid'></span><span id='topic+lintransform.zonohedron'></span><span id='topic+lintransform.zonogon'></span>

<h3>Description</h3>

<p>These functions perform straightforward linear transformations
on the generators of a zonotope,
and the column vectors of a vector matroid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonohedron'
lintransform( x, W )
## S3 method for class 'zonogon'
lintransform( x, W )
## S3 method for class 'matroid'
lintransform( x, W )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lintransform_+3A_x">x</code></td>
<td>

<p><code>x</code> can be a vector matroid object, as returned from the constructor <code><a href="#topic+matroid">matroid</a>()</code> that takes a matrix as input.
</p>
</td></tr>
<tr><td><code id="lintransform_+3A_w">W</code></td>
<td>

<p>An invertible matrix that matches the rank of <code>x</code>.
This invertibility is verified.
<code>W</code> can also be a scalar; it is then replaced by that scalar
multiplied by the identity matrix of the appropriate rank.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a zonohedron (or zonogon),
<code>lintransform(x)</code> returns the zonohedron (or zonogon)
whose generators are the generators of <code>x</code> with the matrix
<code>W</code> applied on the left side.
This function is optimized - it is <em>not</em> necessary
to transform the generators and start all over again.
<br /><br />
If <code>x</code> is a vector matroid, <code>lintransform(x)</code> returns the matroid
whose generators are the generators of <code>x</code> with the matrix
<code>W</code> applied on the left side.
If <code>x</code> is a matroid, but *not* a vector matroid,
it returns the original matroid and prints a warning message.
<br /><br />
In case of error, e.g. invalid <code>W</code>,
the function prints an error message and returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Matroid - Wikipedia.
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank">rank</a>()</code>, 
<code><a href="#topic+matroid">matroid</a>()</code>
</p>

<hr>
<h2 id='matroid'>
matroid construction
</h2><span id='topic+matroid'></span><span id='topic+matroid.matrix'></span><span id='topic+matroid.list'></span>

<h3>Description</h3>

<p>Construct a matroid from a matrix, or from explicit list of hyperplanes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
matroid( x, e0=0, e1=1.e-6, e2=1.e-10, ground=NULL, ... )

## S3 method for class 'list'
matroid( x, ground=NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matroid_+3A_x">x</code></td>
<td>

<p><code>x</code> can be a numeric matrix with 3, 2, or 1 rows whose columns determine the matroid.
The matrix must be either square or &quot;wide&quot;, i.e. more columns than rows.
The matrix must be <em>full-rank</em>, i.e. the rank must be equal to the number of rows, which is then the rank of the constructed matroid.
Such a matroid is often called a <em>column matroid</em> or <em>vector matroid</em>.
<br /><br />
<code>x</code> can also be a list of vectors of positive integers,
which are thought of as sets, and are the hyperplanes of the matroid.
The hyperplanes are checked that they satisfy the matroid hyperplane axioms.
The rank of the constructed matroid is determined automatically,
and must be 3, 2, or 1.
</p>
</td></tr>
<tr><td><code id="matroid_+3A_ground">ground</code></td>
<td>

<p>The <em>ground set</em> of the matroid -
a vector of positive integers in strictly increasing order.
<br /><br />
When <code>x</code> is a matrix,
<code>length(ground)</code> must be equal to <code>ncol(x)</code>.
The point <code>ground[i]</code> corresponds to the <em>i'th</em> column of <code>x</code>.
If <code>ground</code> is <code>NULL</code>,
the column names of <code>x</code> are converted to such a vector if possible.
If this is not possible, <code>ground</code> is set to <code>1:ncol(x)</code>.
<br /><br />
When <code>x</code> is a list, every set in the list must be a subset of <code>ground</code>.
If <code>ground</code> is <code>NULL</code>, it is set to the union of all
the sets in <code>x</code>.
For technical reasons, when the rank is 1, <code>ground</code> is required
and cannot be <code>NULL</code>, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="matroid_+3A_e0">e0</code></td>
<td>

<p>threshold, in the <code class="reqn">L^{\infty}</code> norm, for a column vector of
<code>x</code> to be considered 0,
and thus that the corresponding point in the matroid is a loop.
Since the default is <code>e0=0</code>, 
by default a column vector must be exactly 0 to become a loop.
</p>
</td></tr>
<tr><td><code id="matroid_+3A_e1">e1</code></td>
<td>

<p>threshold, in a pseudo-angular sense, for column vectors to be multiples
of each other,
and thus members of a group of multiple (aka parallel) points in the matroid.
This tolerance is only used when the rank is 2 or 3.
</p>
</td></tr>
<tr><td><code id="matroid_+3A_e2">e2</code></td>
<td>

<p>threshold, in a pseudo-angular sense, for the planes
spanned by pairs of column vectors to be considered coincident,
and thus the columns to be in the same hyperplane of the matroid.
This tolerance is used when the rank is 3.
</p>
</td></tr>
<tr><td><code id="matroid_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It was mentioned above that the tolerances <code>e1</code> and <code>e2</code> are
<em>pseudo-angular</em>.
Specifically, vectors are normalized to the <code class="reqn">L^2</code> unit sphere and the
distance between them is computed in the <code class="reqn">L^{\infty}</code> norm.
<br /><br />
Matroids are well-known to have many cryptomorphic definitions,
e.g. independent sets, bases, circuits, rank function, closure operator,
flats, and hyperplanes.  See <b>Matroid - Wikipedia</b>.
In this package, matroids can only be constructed from hyperplanes,
but there are functions
<code><a href="#topic+rank">rank</a>()</code> and <code><a href="#topic+is_independent">is_independent</a>()</code>
that can be used <em>after</em> construction.
<br /><br />
Checking that the hyperplanes satisfy the matroid hyperplane axioms
is made easier by the fact that all simple matroids of rank 3 or less
are <em>paving matroids</em>, see <b>Paving Matroid - Wikipedia</b>
<br /><br />
Rank 1 matroids are extremely simple - the loops form the
single hyperplane (possibly empty), and the non-loops form
a multiple group.
If <code>ground=NULL</code> the non-loops are unknown, so this is why
<code>ground</code> is required when the rank is 1.
</p>


<h3>Value</h3>

<p><code>matroid()</code> returns an object with S3 class <b>'matroid'</b>.
<br />
In case of error, e.g. invalid <code>x</code> or computed hyperplanes,
the function prints an error message and returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The <em>ground set</em> of positive integers should not be too sparse;
otherwise performance may suffer.
<br /><br />
When <code>x</code> is a matrix with 3 rows,
it may happen that the computed hyperplanes do not satisfy the axioms for a matroid.
In that case, the user will be prompted to try reducing tolerance <code>e2</code>.
Getting the expected hyperplanes may require some <em>a priori</em> knowledge of the expected hyperplanes.
For best results, the matrix should be given with maximum precision.
</p>


<h3>References</h3>

<p><b>Matroid - Wikipedia</b>.<br />
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>
<p><b>Paving Matroid - Wikipedia</b>.<br />
<a href="https://en.wikipedia.org/w/index.php?title=Paving_matroid&amp;oldid=1021966244">https://en.wikipedia.org/w/index.php?title=Paving_matroid&amp;oldid=1021966244</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank">rank</a>()</code>, 
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+getsimplified">getsimplified</a>()</code>
</p>

<hr>
<h2 id='matroid-getters'>
matroid get functions
</h2><span id='topic+gethyperplane'></span><span id='topic+getground'></span><span id='topic+getmatrix'></span><span id='topic+getloop'></span><span id='topic+getmultiple'></span><span id='topic+gethyperplane.matroid'></span><span id='topic+getground.matroid'></span><span id='topic+getmatrix.matroid'></span><span id='topic+getloop.matroid'></span><span id='topic+getmultiple.matroid'></span>

<h3>Description</h3>

<p>get some important members of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matroid'
getground( x )

## S3 method for class 'matroid'
gethyperplane( x )

## S3 method for class 'matroid'
getmatrix( x )

## S3 method for class 'matroid'
getloop( x )

## S3 method for class 'matroid'
getmultiple( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matroid-getters_+3A_x">x</code></td>
<td>

<p>a matroid object, as returned from the constructor
<code><a href="#topic+matroid">matroid</a>()</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getground()</code> returns an vector of positive integers in strictly
increasing order = the ground set of the matroid <code>x</code>.
<br /><br />
<code>gethyperplane()</code> returns a list of vectors of positive integers 
= the hyperplanes of the matroid.
<br />
If <code>x</code> is the simplification of an &quot;original matroid&quot;,
the <code>"lmdata"</code> attribute of the returned list is set to the
<em>loop</em> and <em>multiple group</em> data of the &quot;original hyperplanes&quot;.
These hyperplanes can be recovered using <code><a href="#topic+unsimplify">unsimplify</a>()</code>.
<br />
If <code>x</code> was constructed from a matrix,
these hyperplanes are sorted in decreasing order by length.
The non-trivial hyperplanes come first, followed by the trivial hyperplanes.
A hyperplane is <em>trivial</em> iff it is independent in the matroid.
For a matroid of rank 3, a hyperplane is trivial iff it has 2 points.
<br /><br />
<code>getmatrix()</code> returns the matrix passed to the
<code><a href="#topic+matroid.matrix">matroid.matrix</a>()</code> constructor,
or <code>NULL</code> if the list constructor was used.
The column names are labeled with the ground set.
<br /><br />
<code>getloop()</code> returns an integer vector with the loops of <code>x</code>.
If <code>x</code> is simple, it is the empty vector.
<br /><br />
<code>getmultiple()</code> returns a list of integer vectors - the
multiple groups of <code>x</code>.
If <code>x</code> is simple, it is the empty list.
</p>


<h3>References</h3>

<p>Matroid - Wikipedia.
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank">rank</a>()</code>, 
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+unsimplify">unsimplify</a>()</code>,
<code><a href="#topic+getsimplified">getsimplified</a>()</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a classic matroid with 7 points, but assign an unusual ground set
mat = matroid( classics.genlist[['TRD']], ground=11:17 )

getmatrix( mat )

##       11 12 13 14       15       16       17
##  [1,]  1  1  1  1 1.732051 0.000000 0.000000
##  [2,]  1  1 -1 -1 0.000000 1.732051 0.000000
##  [3,]  1 -1  1 -1 0.000000 0.000000 1.732051
</code></pre>

<hr>
<h2 id='matroid-props'>
matroid properties
</h2><span id='topic+is_simple'></span><span id='topic+is_uniform'></span><span id='topic+is_paving'></span><span id='topic+is_simple.matroid'></span><span id='topic+is_uniform.matroid'></span><span id='topic+is_paving.matroid'></span>

<h3>Description</h3>

<p>get some important boolean properties of a matrix,
see <b>Matroid - Wikipedia</b> for the definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matroid'
is_simple( x )

## S3 method for class 'matroid'
is_uniform( x )

## S3 method for class 'matroid'
is_paving( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matroid-props_+3A_x">x</code></td>
<td>

<p>a matroid object, as returned from the constructor <code><a href="#topic+matroid">matroid</a>()</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_simple()</code> returns a logical.
A matroid is <em>simple</em> iff it has no loops and no multiple groups.
<br /><br />
<code>is_uniform()</code> returns a logical.
A matroid is <em>uniform</em> iff all the hyperplanes have the same size,
which is the rank-1.
<br /><br />
<code>is_paving()</code> returns a logical.
For the definition of <em>paving</em> see <b>Paving Matroid - Wikipedia</b>.
This property is important because the hyperplane axioms
are fairly easy to check.
</p>


<h3>References</h3>

<p>Matroid - Wikipedia.
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>
<p>Paving Matroid - Wikipedia.
<a href="https://en.wikipedia.org/w/index.php?title=Paving_matroid&amp;oldid=1021966244">https://en.wikipedia.org/w/index.php?title=Paving_matroid&amp;oldid=1021966244</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matroid">matroid</a>()</code>
</p>

<hr>
<h2 id='minkowskisum'>
Minkowski sum of Two zonotopes
</h2><span id='topic+minkowskisum'></span><span id='topic+minkowskisum.zonotope'></span><span id='topic++25+2B+25'></span><span id='topic++25+2B+25.zonotope'></span>

<h3>Description</h3>

<p>A zonotope can be viewed as a Minkowski sum of line segments,
with one endpoint at 0.
Therefore, the Minkowski sum of two zonotopes (in the same dimension)
is also a zonotope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
minkowskisum( zono1, zono2, e0=0, e1=1.e-6, e2=1.e-10, ground=NULL, ... )

## S3 method for class 'zonotope'
zono1 %+% zono2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minkowskisum_+3A_zono1">zono1</code></td>
<td>

<p>a zonotope object - a <b>zonohedron</b>, a <b>zonogon</b>, or a <b>zonoseg</b>
</p>
</td></tr>
<tr><td><code id="minkowskisum_+3A_zono2">zono2</code></td>
<td>

<p>a zonotope object with the same dimension as <code>zono1</code>
</p>
</td></tr>
<tr><td><code id="minkowskisum_+3A_e0">e0</code></td>
<td>
<p>see <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="minkowskisum_+3A_e1">e1</code></td>
<td>
<p>see <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="minkowskisum_+3A_e2">e2</code></td>
<td>
<p>see <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="minkowskisum_+3A_ground">ground</code></td>
<td>
<p>the ground set of the returned zonotope.
If <code>ground</code> is <code>NULL</code>, it is set to the ground set of <code>zono1</code>
followed by the ground set of <code>zono2</code> translated sufficiently
to not intersect that of <code>zono1</code>.
</p>
</td></tr>
<tr><td><code id="minkowskisum_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After verifying that <code>zono1</code> and <code>zono2</code> are the same dimension,
it takes the 2 matrices, <code>cbind</code>s them,
and passes the new matrix to the appropriate constructor,
along with the other arguments.
There are no special optimizations.
</p>


<h3>Value</h3>

<p><code>minkowskisum()</code> returns a zonotope of the same dimension
as <code>zono1</code> and <code>zono2</code>.<br />
<code>%+%</code> is a more convenient binary operator that calls
<code>minkowskisum()</code>, but without the flexibility of
the extra arguments.
<br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p><b>Zonohedron - Wikipedia</b>.<br />
<a href="https://en.wikipedia.org/wiki/Zonohedron">https://en.wikipedia.org/wiki/Zonohedron</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+zonoseg">zonoseg</a>()</code>
</p>

<hr>
<h2 id='plot2trans'>
plot the 2-transition surface associated with a zonohedron
</h2><span id='topic+plot2trans'></span>

<h3>Description</h3>

<p>The 2-transition surface has the topology of a sphere and is contained in the zonohedron.
All the facets are parallelograms.
The surface is centrally symmetric, with the same center as the zonohedron.
The surface may have self-intersections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2trans(  x, type='ef', ecol='black', econc=FALSE,
                 fcol='yellow', falpha=0.5, level=NULL,
                 normals=FALSE, both=TRUE, bgcol="gray40", add=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2trans_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_type">type</code></td>
<td>

<p>a character string with what parts to draw.
If <code>type</code> contains <code>'e'</code>, then draw the edges.
If <code>type</code> contains <code>'f'</code>, then draw filled facets.
If <code>type</code> contains <code>'p'</code>, then draw points
at the centers of the facets.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_ecol">ecol</code></td>
<td>

<p>The color to use when drawing the edges.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_econc">econc</code></td>
<td>

<p>If <code>TRUE</code> then draw the concave edges in red,
and with extra thickness
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_fcol">fcol</code></td>
<td>

<p>The color to use when drawing the facets.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_falpha">falpha</code></td>
<td>

<p>The opacity to use when drawing the facets.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_level">level</code></td>
<td>

<p>An integer vector which is a subvector of <code>0:(M-2)</code>,
where <code>M</code> is the number of simplified generators.
Only the facets and edges at the specified levels are drawn.
When <code>level=NULL</code> then <em>all</em> facets and edges are drawn.
This argument does not affect the drawing of points.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_normals">normals</code></td>
<td>

<p>If <code>TRUE</code> then draw the unit facet normals.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_both">both</code></td>
<td>

<p>if <code>FALSE</code> then draw only one half of the centrally symmetric surface.
Otherwise draw both halves (the default).
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_bgcol">bgcol</code></td>
<td>

<p>the background color
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_add">add</code></td>
<td>

<p>If <code>TRUE</code> then add to the current 3D plot.
If there is no current 3D plot, it is an error.
</p>
</td></tr>
<tr><td><code id="plot2trans_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Facets and regular edges are drawn with <code>rgl::quads3d()</code>.
Concave edges are drawn with <code>rgl::segments3d()</code>.
Points are drawn with <code>rgl::points3d()</code>.
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code>; or <code>FALSE</code> in case of error.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plots.
A large black point is drawn at 0, 
a large white point at the &quot;white point&quot;,
and a 50% gray point at the center.
A line from the black point to the white point is also drawn.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plothighertrans">plothighertrans</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>
</p>

<hr>
<h2 id='plothighertrans'>
plot abundant and deficient parallelograms
</h2><span id='topic+plothighertrans'></span>

<h3>Description</h3>

<p>The 2-transition surface associated with a zonohedron
is a topological sphere and is contained in the zonohedron.
The surface is centrally symmetric, with the same center as the zonohedron.
The surface may have self-intersections.
For this function, the surface is required to be strictly starshaped at
the center.
For the definition of <em>strictly starshaped</em> see the vignette
<a href="../doc/transitions.html">The 2-Transition Subcomplex and the 2-Transition Surface</a>.
</p>
<p>The 2-transition surface is a union of parallelograms.
Each parallelogram has a unit normal that defines a linear functional.
<br />
If a 2-transition parallelogram is in the <em>interior</em> of the zonohedron
then the functional is not maximized on the parallelogram,
and there is a corresponding similar parallelogram
on the boundary of the zonohedron where the functional *is* maximized.
The first parallelogram (in the surface) is called <em>deficient</em> because
the functional is not maximized,
and the second parallelogram (in the boundary)
is called <em>abundant</em> because the number of corresponding
transitions across this parallelogram is more than 2.
<br />
If the 2-transition parallelogram is on the boundary,
then it is called <em>coincident</em>.
The coincident parallelograms are ignored and
not drawn in this function.
</p>
<p>Because of this 1-1 correspondence between deficient parallelograms (in the 2-transition surface)
and the abundant parallelograms (in the boundary of the zonohedron),
the area of these two surfaces are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plothighertrans( x, abalpha=1, defcol='green', defalpha=0, ecol=NA,
                  connections=FALSE, bgcol="gray40", both=TRUE, ...  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plothighertrans_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_abalpha">abalpha</code></td>
<td>

<p>The opacity to use when drawing the abundant parallelograms.
If <code>abalpha=0</code> then they are not drawn.
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_defcol">defcol</code></td>
<td>

<p>The color to use when drawing the deficient parallelograms
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_defalpha">defalpha</code></td>
<td>

<p>The opacity to use when drawing the deficient parallelograms.
If <code>defalpha=0</code> (the default), then they are not drawn.
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_ecol">ecol</code></td>
<td>

<p>The color to use when drawing the edges.
If <code>ecol=NA</code> (the default), then they are not drawn.
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_connections">connections</code></td>
<td>

<p>If <code>TRUE</code> then draw segments between centers of the
deficient parallelograms in the 2-transition surface,
and centers of the the corresponding abundant parallelograms
in the zonohedron boundary
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_bgcol">bgcol</code></td>
<td>

<p>the background color
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_both">both</code></td>
<td>

<p>if <code>FALSE</code> then draw only one half of the centrally symmetric boundary.
Otherwise draw both halves.
This affects edges and parallelograms.
</p>
</td></tr>
<tr><td><code id="plothighertrans_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Connections are drawn with <code>rgl::segments3d()</code> and 
<code>rgl::points3d()</code> .
parallelograms and edges are drawn with <code>rgl::quads3d()</code>.
Both parallelograms and edges are drawn unlit (<code>lit=FALSE</code>).
The parallelograms are colored by the number of transitions
using the color codes in <b>Burns</b>, up to 10 transitions.
</p>
<p>A large black point is drawn at 0, 
a large white point at the &quot;white point&quot;,
and a 50% gray point at the center.
A line from the black point to the white point is also drawn.
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code> when successful; 
or <code>FALSE</code> in case of error.
</p>


<h3>WARNING</h3>

<p>This function currently only works when the 2-transition surface
is starshaped at the center.
This excludes many of the classic zonohedra.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plots.
</p>


<h3>References</h3>

<p>Scott A Burns.
<b>The location of optimal object colors with more than two transitions</b>.
Color Research &amp; Application.
Vol. 46.
No. 6.
pp 1180-1193.
2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>,
<code><a href="#topic+plot2trans">plot2trans</a>()</code>
</p>

<hr>
<h2 id='plotpolygon'>
plot the <em>generator polygon</em> associated with a pointed zonohedron
</h2><span id='topic+plotpolygon'></span>

<h3>Description</h3>

<p>A zonohedron is <em>pointed</em> iff there is a vector <b>n</b>
so the inner product of all the zonohedron generators with <b>n</b> is positive.
In other terminology, it is <em>pointed</em> iff there is an open halfspace
that contains all the generators.
<br />
When <b>n</b> exists, a neighborhood of 0 can be cut by a plane
orthogonal to <b>n</b> and the intersection is a polygon.
Since <b>n</b> is not unique, the polygon is only unique up
to a 2D projective transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpolygon( x, normal=NULL, points=TRUE, labels=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpolygon_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>.
It must be pointed.
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_normal">normal</code></td>
<td>

<p>the vector <b>n</b> to use - a non-zero numeric vector of length 3.
If it is given, the validity is checked and if invalid it is an error.
<br />
If it is <code>NULL</code>, a few canonical normals are first tested for validity.
If they are invalid, then a valid one is computed.
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_points">points</code></td>
<td>

<p>If <code>TRUE</code> then draw the vertices of the polygon
</p>
</td></tr>
<tr><td><code id="plotpolygon_+3A_labels">labels</code></td>
<td>

<p>If <code>TRUE</code> then draw labels,
taken from the ground set of the simplified matroid, near the vertices
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selected normal vector <b>n</b> is added to the title of the plot.
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code>; or <code>FALSE</code> in case of error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>
</p>

<hr>
<h2 id='print'>Print Basic Facts about a Matroid</h2><span id='topic+print'></span><span id='topic+print.matroid'></span>

<h3>Description</h3>

<p>The function prints a nicely formatted summary of a matroid,
including the ground set, the rank, loops, multiple groups,
and some boolean properties.
It prints the number of hyperplanes, broken down by their size.
If it is a vector matroid, and its matrix is not too large, it prints
that matrix.
If the matroid is not simple, it also prints the simplified matroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matroid'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a <code>matroid</code> object as returned by the constructor <code><a href="#topic+matroid">matroid</a>()</code></p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>further arguments ignored, but required by the generic <code>print()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matroid">matroid</a>()</code>
</p>

<hr>
<h2 id='print.genlist'>Print Basic Metrics for Each Zonohedron Generated by the Matrices in a <b>genlist</b> object </h2><span id='topic+print.genlist'></span>

<h3>Description</h3>

<p>An S3 class <b>genlist</b> object is organized as a named list
of 3xN matrices, when N varies.
The <code>print()</code> method constructs a zonohedron object from each matrix
and then prints some basic metrics about each zonohedron, as a data frame.
If the matrix has the <code>"fullname"</code> attribute, it is added as a column.
The names of the list are copied to the rownames of the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genlist'
print( x, full=TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.genlist_+3A_x">x</code></td>
<td>
<p>a <code>genlist</code> object</p>
</td></tr>
<tr><td><code id="print.genlist_+3A_full">full</code></td>
<td>
<p>if <code>TRUE</code>, include <code>area</code> and <code>volume</code> columns</p>
</td></tr>
<tr><td><code id="print.genlist_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.genlist()</code> uses <code>summary.zonohedron()</code>.
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genlist">genlist</a></code>,
<code><a href="#topic+summary.zonohedron">summary.zonohedron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># print zonohedra metrics associated with 3 sets of color matching functions
colorimetry.genlist
#                    fullname generators vertices  edges facets      area     volume
# xyz1931.5nm xyz at 5nm step         81     5100  10146   5048  1582.722   4070.345
# xyz1931.1nm xyz at 1nm step        471   112910 225720 112812 39586.707 509434.149
# lms2000.1nm lms at 1nm step        441   146642 292860 146220 22736.652 181369.085


names(classics.genlist)
#  [1] "C"   "RD"  "BD"  "RI"  "RHD" "RT"  "TO"  "TRD" "TC"  "RE"  "RH"  "TI"  "TSR"

print( classics.genlist, full=FALSE )
#                                   fullname generators vertices edges facets
# C                                     cube          3        8    12      6
# RD                    rhombic dodecahedron          4       14    24     12
# BD                   Bilinski dodecahedron          4       14    24     12
# RI                     rhombic icosahedron          5       22    40     20
# RHD          rhombo-hexagonal dodecahedron          5       18    28     12
# RT                 rhombic triacontahedron          6       32    60     30
# TO                    truncated octahedron          6       24    36     14
# TRD         truncated rhombic dodecahedron          7       32    48     18
# TC                 truncated cuboctahedron          9       48    72     26
# RE                rhombic enneacontahedron         10       92   180     90
# RH              rhombic hectotriadiohedron         12      134   264    132
# TI             truncated icosidodecahedron         15      120   180     62
# TSR truncated small rhombicosidodecahedron         21      240   360    122
</code></pre>

<hr>
<h2 id='rank'>
Rank and Independence
</h2><span id='topic+rank'></span><span id='topic+is_independent'></span>

<h3>Description</h3>

<p>calculate the rank of any subset of a matroid, or determine whether any subset is independent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank( x, subs )

is_independent( x, subs )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_+3A_x">x</code></td>
<td>

<p>a matroid object, as returned from the constructor <code><a href="#topic+matroid">matroid</a>()</code>
</p>
</td></tr>
<tr><td><code id="rank_+3A_subs">subs</code></td>
<td>

<p>a list of integer vectors, representing subsets of the ground set of <code>x</code>.
<code>subs</code> can also be an integer vector, which is put into a
list of length 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rank(x,subs)</code> returns an integer vector with the same length
as the list <code>subs</code>.
The i'th value is the rank of the i'th set in <code>subs</code>.
If a set is not a subset of the ground set of <code>x</code>, the value is <code>NA</code>, and a warning message is printed.
<br /><br />
<code>is_independent(x,subs)</code> returns a logical vector with the same length
as the list <code>subs</code>.
The i'th value is the independence of i'th set in <code>x</code>.
It is equal to <code>TRUE</code> iff the rank of the subset is equal to
the cardinality of the subset.
<br /><br />
For both functions the names are copied from input to output.
</p>


<h3>References</h3>

<p>Matroid - Wikipedia.
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matroid">matroid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a matroid with rank 3
mat = matroid( classics.genlist[['RT']] )


# the ground set itself should have rank 3
rank( mat, getground(mat) )
##  [1] 3


# single points should have rank 1  (there are no loops)
rank( mat, as.list(getground(mat)) )
##  [1] 1 1 1 1 1 1

# all hyperplanes should have rank 2
rank( mat, gethyperplane(mat) )
##  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2


# a point not in the ground set should have rank NA
# and the emtpy set should have rank 0
rank( mat, list(100L,integer(0)) )
##  1 of 1 subsets are not a subset of ground.
##  [1] NA 0
</code></pre>

<hr>
<h2 id='raytrace2trans'>
compute the intersection of a ray and the 2-transition surface
associated with a zonohedron
</h2><span id='topic+raytrace2trans'></span>

<h3>Description</h3>

<p>The <em>open ray</em> with basepoint <code class="reqn">\bold{b}</code>
and non-zero direction <code class="reqn">\bold{d}</code> is the set of the form
<code class="reqn">\bold{b} + t \bold{d}</code> where <code class="reqn">t &gt; 0</code>.
<br /><br />
This function computes the intersection of an open ray
and the 2-transition surface associated with a zonohedron.
The linking number of the surface and <code class="reqn">\bold{b}</code> must be <code class="reqn">\pm 1</code>.
This is verified at the beginning, and if not true, then it is an error.
The linking number condition implies that an intersection exists for every
ray based at <code class="reqn">\bold{b}</code>.
Note also that the condition implies that <code class="reqn">\bold{b}</code> is not on the surface.
For discussion of uniqueness, see <b>Details</b>.
For the definition of <em>linking number</em> see
<a href="../doc/transitions.html">The 2-Transition Subcomplex and the 2-Transition Surface</a>.
</p>
<p>The 2-transition surface is a union of parallelograms.
The surface is symmetric about the center of the zonhedron,
so each parallelogram has an antipodal parallelogram.
Each parallelogram is specified by an ordered pair of
distinct generators from the
<em>simplified</em> matroid associated with the zonohedron.
Thus, if there are <code class="reqn">N</code> generators, there are <code class="reqn">N(N-1)</code> parallelograms.
Swapping the generators of a parallelogram changes it
to the antipodal parallelogram.
</p>
<p>The 2-transition surface has two <em>poles</em> -
the point 0 and the sum of all the generators.
It is OK for the ray to pass through one of these poles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raytrace2trans( x, base, direction, invert=FALSE, plot=FALSE, tol=1.e-12, ...  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raytrace2trans_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="raytrace2trans_+3A_base">base</code></td>
<td>

<p>a numeric 3-vector - the basepoint of all the rays.
The surface must be strictly starshaped at <code>base</code>,
and this is verified.
</p>
</td></tr>
<tr><td><code id="raytrace2trans_+3A_direction">direction</code></td>
<td>

<p>a numeric Mx3 matrix with M non-zero directions in the rows.
The basepoint and these directions define M rays.
<br />
<code>direction</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
<tr><td><code id="raytrace2trans_+3A_invert">invert</code></td>
<td>

<p>if <code>TRUE</code>, then compute a point in the unit cube that maps to the point on the 2-transition surface associated with <code>x</code>,
and add it as a column in the returned <code>data.frame</code>
</p>
</td></tr>
<tr><td><code id="raytrace2trans_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>, the computed rays, up to the boundary,
are <em>added</em> to an existing
plot of the zonohedron <code>x</code>, see <code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>.
The segments are drawn in the color red.
If there is no open 3D plot, a warning is issued.
</p>
</td></tr>
<tr><td><code id="raytrace2trans_+3A_tol">tol</code></td>
<td>

<p>the tolerance for being strictly starshaped,
and for intersection with a <em>pole</em>.
</p>
</td></tr>
<tr><td><code id="raytrace2trans_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is designed for the situation when the intersection
of the ray and the surface exists and is unique.
This is guaranteed for all ray directions <code class="reqn">\bold{d}</code>
when the surface is strictly starshaped at <code class="reqn">\bold{b}</code>.
This condition is checked at the beginning of the function,
and if false then a warning is issued that the intersection point
may not be unique.
For the definition of <em>strictly starshaped</em> see
<a href="../doc/transitions.html">The 2-Transition Subcomplex and the 2-Transition Surface</a>.
</p>
<p>For finding a parallelogram of intersection,
a brute-force search is used; all parallelograms are searched until
the first one that intersects the ray is found.
To speed things up, the 3D problem is reduced to 2D,
and the search is programmed in plain C.
</p>
<p>If <code>plot</code> is <code>TRUE</code>, the rays are drawn in red
using <code>rgl::segments3d()</code> and <code>rgl::points3d()</code>.
</p>


<h3>Value</h3>

<p><code>raytrace2trans()</code> returns a <code>data.frame</code> with M rows and these columns:
</p>
<table>
<tr><td><code>base</code></td>
<td>

<p>the given basepoint - this is the same in every row
</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>

<p>the given direction
</p>
</td></tr>
<tr><td><code>gndpair</code></td>
<td>

<p>the 2 generators of the parallelogram that the ray intersects, 
taken from the ground set of the simplified matroid.
If the ray passes through a pole, both of these are <code>NA</code>.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>

<p>the 2 coordinates of the intersection point within the parallelogram
</p>
</td></tr>
<tr><td><code>tmax</code></td>
<td>

<p>ray parameter of the intersection with the parallelogram, always positive
</p>
</td></tr>
<tr><td><code>point</code></td>
<td>

<p>the point on the surface; the intersection of the ray and the parallelogram
</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>

<p>the number of parallelograms searched, until the desired one was found.
If the ray intersects a pole, this is 0.
</p>
</td></tr>
<tr><td><code>timetrace</code></td>
<td>

<p>the computation time for the given ray, in seconds.
This does not include the initial preprocessing time.
</p>
</td></tr>
</table>
<p>And if <code>invert</code> is <code>TRUE</code>, then this column is added:
</p>
<table>
<tr><td><code>pcube</code></td>
<td>
<p>a point in the unit cube that maps to <code>point</code>.  This point in the cube always has 2 transitions.</p>
</td></tr>
</table>
<p>If <code>base</code> and <code>direction</code> in a row cannot be
processed, the rest of the row is <code>NA</code>.
</p>
<p>If the row names of <code>direction</code> are unique,
they are copied to the row names of the output.
<br /><br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>,
<code><a href="#topic+section2trans">section2trans</a>()</code>,
<code><a href="#topic+raytrace.zonohedron">raytrace.zonohedron</a>()</code>
</p>

<hr>
<h2 id='section2trans'>
compute the intersection of a plane and the
2-transition surface associated with a zonohedron
</h2><span id='topic+section2trans'></span>

<h3>Description</h3>

<p>In general, the 2-transition surface may be highly non-convex,
possibly with self-intersections.
The intersection of a plane and the 2-transition surface is
a union of polygons,
possibly with self-intersections and intersecting each other.
This function computes one of those polygons.
If there are other polygons, it issues a warning
and does not try to compute them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>section2trans( x, normal, beta, invert=FALSE, plot=FALSE, tol=1.e-12, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="section2trans_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="section2trans_+3A_normal">normal</code></td>
<td>

<p>a non-zero numeric 3-vector - the normal of all the planes
</p>
</td></tr>
<tr><td><code id="section2trans_+3A_beta">beta</code></td>
<td>

<p>a numeric M-vector of plane constants.  
The equation of the k'th plane k is: <code>&lt;x,normal&gt; = beta[k]</code>.
</p>
</td></tr>
<tr><td><code id="section2trans_+3A_invert">invert</code></td>
<td>

<p>if <code>TRUE</code>, then compute a point in the unit cube that maps to the point on the 2-transition surface,
and add it as a column in the returned <code>data.frame</code>
</p>
</td></tr>
<tr><td><code id="section2trans_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>, the polygons formed by the the intersection 
of the planes and the 2-transition surface.
<em>added</em> to an existing 3D plot of the zonohedron <code>x</code>,
see <code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>.
The polygons are drawn in red.
</p>
</td></tr>
<tr><td><code id="section2trans_+3A_tol">tol</code></td>
<td>

<p>a small positive number, used as the tolerance for the plane
intersecting the interior of each parallelogram, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="section2trans_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is designed for the situation when the
intersection of a plane and the surface is a single polygon.
</p>
<p>Given a plane, the function finds all the parallelograms of the surface
whose interiors intersect the plane.
Each intersection is a line segment.
For each parallelogram it associates one of the endpoints of the segment.
The parallelograms are put in polygon order by picking an
arbitrary one as the starting point,
and then &quot;marching&quot; from one to the next using
the canonical parallelogram adjacency relation.
After returning to the starting point, if there are other parallelograms
remaining, it means that there are other polygons
in the section and a warning is issued.
</p>


<h3>Value</h3>

<p><code>section2trans()</code> returns a list of length M
(=<code>length(beta)</code>),
and the i'th item in the list is a data frame with these columns:
</p>
<table>
<tr><td><code>point</code></td>
<td>

<p>a Px3 matrix with the P points of the i'th polygon in the rows.
If the plane does not intersect the 2-transition surface, then P=0
and the matrix has 0 rows.
The row names of <code>point</code> are the indexes of the facets
that contain the vertices of the polygon; see <b>Details</b>.
</p>
</td></tr>
<tr><td><code>gndpair</code></td>
<td>

<p>the 2 indexes from the ground set that generates the parallelogram
containing <code>point</code>.
See <b>Details</b> for a description of the &quot;marching parallelogram&quot;
procedure.
</p>
</td></tr>
</table>
<p>And if <code>invert</code> is <code>TRUE</code>, then this column is added:
</p>
<table>
<tr><td><code>pcube</code></td>
<td>
<p>a point in the unit cube that maps to <code>point</code>.  This point in the cube always has 2 transitions.</p>
</td></tr>
</table>
<p>The names of the returned list are readable strings that contain
<code>normal</code> and <code>beta[i]</code>.
</p>
<p>In case of error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>,
<code><a href="#topic+section.zonohedron">section.zonohedron</a>()</code>,
<code><a href="#topic+raytrace2trans">raytrace2trans</a>()</code>
</p>

<hr>
<h2 id='simplify'>
simplify and unsimplify
</h2><span id='topic+simplify'></span><span id='topic+simplify.list'></span><span id='topic+unsimplify'></span><span id='topic+unsimplify.list'></span><span id='topic+getsimplified'></span><span id='topic+getsimplified.matroid'></span>

<h3>Description</h3>

<p>A <em>simple matroid</em> has no loops and no multiple groups.
Simplification is the process of removing all loops,
and every point except one from each multiple group.
The result is a simple matroid.
<br />
The functions below simplify a matroid, or an explicit list of hyperplanes.
<br />
The hyperplanes can be <em>unsimplified</em> if the original loops
and multiple groups are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matroid'
getsimplified( x, ... )

## S3 method for class 'list'
simplify( x, ground=NULL, ... )

## S3 method for class 'list'
unsimplify( x, loop=NULL, multiple=NULL, ground=NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_+3A_x">x</code></td>
<td>

<p><code>x</code> can be a matroid object, as returned from the constructor <code><a href="#topic+matroid">matroid</a>()</code>
<br />
<code>x</code> can also be a list of vectors of positive integers,
which are thought of as sets.
All must be subsets of <code>ground</code>. 
They do not have to satisfy the matroid hyperplane axioms.
For a definition of <em>loop</em> and <em>multiple group</em> in this case,
see <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="simplify_+3A_ground">ground</code></td>
<td>

<p>The <em>ground set</em> of the sets in <code>x</code>
(both <code>simplify()</code> and <code>unsimplify()</code>).
It must be a vector of positive integers in strictly increasing order
(not verified).
If <code>ground</code> is <code>NULL</code>, it is set to the union of
the sets in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="simplify_+3A_loop">loop</code></td>
<td>

<p>a vector of positive integers, the loops, to add to the list <code>x</code>;
<code>loop</code> must be disjoint from <code>ground</code> (verified).
If <code>loop</code> is <code>NULL</code>, the function looks for <code>loop</code>
in the attribute data <code>attr(x,'lmdata')</code>.
If there is no such attribute, <code>loop</code> is set to the empty set.
</p>
</td></tr>
<tr><td><code id="simplify_+3A_multiple">multiple</code></td>
<td>

<p>a list of vectors of positive integers, the multiple groups,
to add to the list <code>x</code>;
these groups must be pairwise disjoint and disjoint from <code>loop</code> (not verified).
Each group must intersect the ground set in exactly one point (verified).
If <code>multiple</code> is <code>NULL</code>, the function looks for <code>multiple</code>
in the attribute data <code>attr(x,'lmdata')</code>.
If there is no such attribute, <code>multiple</code> is set to the empty list.
</p>
</td></tr>
<tr><td><code id="simplify_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First consider the case when <code>x</code> is a list of vectors of positive integers.
Each vector represents a subset of the ground set.
They are not required to satisfy the hyperplane axioms,
but by abuse of language we will call them hyperplanes in this paragraph.
A <em>loop</em> is a point (an integer in the ground set)
that is in every hyperplane.
Imagine now that all loops have been removed.
Say that two points <code class="reqn">p</code> and <code class="reqn">q</code> are <em>multiples</em> iff
for every hyperplane <code class="reqn">H</code>, <code class="reqn">p \in H</code> iff <code class="reqn">q \in H</code>.
This is an equivalence relation, and the <em>multiple groups</em> are the
equivalence classes with more than one point.
For computation it is convenient to think of a boolean <em>incidence matrix</em>.
There is a column for each point in the ground set,
and a row for each hyperplane.
An entry is <code>TRUE</code> iff the point is in the hyperplane.
A <em>loop</em> is then a column of all <code>TRUE</code>s.
A <em>multiple group</em> is a maximal set of duplicate columns.
This is basically how <code>simplify()</code> is implemented,
except with optimizations that avoid computing the very large incidence matrix.
<br /><br />
Now consider the case when <code>x</code> is a matroid object.
When <code>x</code> was constructed, the simplification of <code>x</code> was
computed (with help from the *previous* <code>simplify()</code>) and stored
as a member of <code>x</code> (unless <code>x</code> was already simple).
So in this case <code>getsimplified(x)</code> does not do any real work
and only takes microseconds.
<br /><br />
These functions are accelerated with C/C++.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a matroid, <code>getsimplified(x)</code> returns <code>x</code>
when <code>x</code> is simple, and a member of <code>x</code> when <code>x</code> is not simple.
It does not do any real work.
<br /><br />
If <code>x</code> is a list, <code>simplify(x)</code> returns a list
of the same length, but with all loops removed,
and every point except one from each multiple group removed.
The integer that remains is the smallest one in the group.
The order of the sets is preserved.
It also sets the <code>'lmdata'</code> attribute of the returned list
to a list of 2 objects -
the loop and multiple group data found in <code>x</code>.
<br /><br />
If <code>x</code> is a list, <code>unsimplify(x)</code> returns a list
of the same length, but with the loops and multiples added back.
The order of the sets is preserved.
<br /><br />
In case of error, e.g. invalid <code>x</code> etc.,
the function prints an error message and returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Matroid - Wikipedia.
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank">rank</a>()</code>, 
<code><a href="#topic+matroid">matroid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an example using simplify.list() and unsimplify.list()
# get the matrix for CIE XYZ at 5 nm step size
mat3x81 = colorimetry.genlist[[1]]

# create the matroid
mat5 = matroid( mat3x81 )

#  test for simplicity
is_simple(mat5)
##  [1] FALSE

# get the list of hyperplanes, and simplify
hyper = gethyperplane( mat5 )
hypersimple = simplify( hyper )

# print the loop and multiple data found
attr(hypersimple,'lmdata')

# unsimplify and compare to the originals
# the list attr(hypersimple,'lmdata') is 'secretly' used in unsimplify()
identical( unsimplify(hypersimple), hyper )
##  [1] TRUE
</code></pre>

<hr>
<h2 id='spherize'>
spherize a zonotope
</h2><span id='topic+spherize'></span><span id='topic+spherize.zonotope'></span>

<h3>Description</h3>

<p>The input is a zonotope with a best-fit ellipsoid
(or ellipse for a <b>zonogon</b>)
with axes that may have very different lengths.
The function computes a <em>spherizing matrix</em> <code>W</code>, and then
transforms the zonotope so its boundary is close to a sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
spherize( x, method='ZCA', ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spherize_+3A_x">x</code></td>
<td>

<p>a zonotope object -  a <b>zonohedron</b>, a <b>zonogon</b>,
or a <b>zonoseg</b>.
</p>
</td></tr>
<tr><td><code id="spherize_+3A_method">method</code></td>
<td>

<p>for computing the matrix <code>W</code>, either <code>'ZCA'</code> or <code>'PCA-COR'</code>.
Matching is partial and case-insensitive.
</p>
</td></tr>
<tr><td><code id="spherize_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 2 methods are taken from <b>Kessy, et. al.</b>.
</p>


<h3>Value</h3>

<p>After computing the matrix <code>W</code>,
the function return <code>lintransform(x,W)</code>.
The <code>"sphering"</code> attribute is set to <code>W</code>.
<br />
If <code>x</code> is a 1D <b>zonoseg</b>, sphering is not really possible,
so the function prints a warning message and returns <code>x</code>.
In case of error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Agnan Kessy, Alex Lewin, Korbinian Strimmer.
<b>Optimal whitening and decorrelation</b>.<br />
<a href="https://arxiv.org/abs/1512.00809">https://arxiv.org/abs/1512.00809</a>
v4 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintransform">lintransform</a>()</code>
</p>

<hr>
<h2 id='support'>
the support function for a zonotope
</h2><span id='topic+support'></span><span id='topic+support.zonotope'></span>

<h3>Description</h3>

<p>Compute the classical support function for a zonotope.
It also computes a point on the boundary where the linear functional
is maximized, and the dimension of the face where the supporting
hyperplane intersects the zonotope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
support( x, direction, tol=5.e-15 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support_+3A_x">x</code></td>
<td>

<p>a zonotope object -  a <b>zonohedron</b>, a <b>zonogon</b>,
or a <b>zonoseg</b>
</p>
</td></tr>
<tr><td><code id="support_+3A_direction">direction</code></td>
<td>

<p>an NxM matrix with N directions in the rows.
If <code>x</code> is a <b>zonohedron</b>, M must be 3.
If <code>x</code> is a <b>zonogon</b>, M must be 2.
If <code>x</code> is a <b>zonoseg</b>, M must be 1.
<code>direction</code> can also be a vector that can be converted to
such a matrix, by row.
The direction is normal to the supporting hyperplane
</p>
</td></tr>
<tr><td><code id="support_+3A_tol">tol</code></td>
<td>

<p>the tolerance for determining whether the supporting hyperplane
intersects a face with positive dimension.
This does not affect the value of the support function.
For a <b>zonoseg</b>, <code>tol</code> is ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>data.frame</code> with N rows and these columns:
</p>
<table>
<tr><td><code>direction</code></td>
<td>
<p>the given direction</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the support function of <code>x</code>, in the given direction</p>
</td></tr>
<tr><td><code>argmax</code></td>
<td>
<p>a point on the boundary of <code>x</code> where the functional max is taken.  This point is the center of the face where the supporting hyperplane intersects the zonotope.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>of the face where the supporting hyperplane intersects the zonotope. 0 means a vertex, 1 means an edge, and 2 means a 2-face.</p>
</td></tr>
</table>
<p>If <code>direction</code> is 0, the other columns are <code>NA</code>.
If the rownames of <code>direction</code> are unique,
they are copied to the row names of the output.
<br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p><b>Wikipedia - Support function</b><br />
<a href="https://en.wikipedia.org/wiki/Support_function">https://en.wikipedia.org/wiki/Support_function</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonoseg">zonoseg</a>()</code>
</p>

<hr>
<h2 id='symmetrize'>
symmetrize a zonotope
</h2><span id='topic+symmetrize'></span><span id='topic+symmetrize.zonotope'></span>

<h3>Description</h3>

<p>The input is a zonotope whose matroid is simple.
The function adds new generators that creates a new zonotope
that is a translate of the original, and has center of symmetry at 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
symmetrize( x, e0=0, e1=1.e-6, e2=1.e-10, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetrize_+3A_x">x</code></td>
<td>

<p>a zonotope object -  a <b>zonohedron</b>, a <b>zonogon</b>,
or a <b>zonoseg</b>.
The matroid of this zonotope must be simple.
</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_e0">e0</code></td>
<td>
<p>see <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_e1">e1</code></td>
<td>
<p>see <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_e2">e2</code></td>
<td>
<p>see <code><a href="#topic+zonohedron">zonohedron</a>()</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each generator <code>g</code> (a column of the matrix)
is replace by 2 generators: <code>g/2</code> and <code>-g/2</code>.
The new set of generators correponds to a <em>star</em> at 0,
from Sec 2-8 of <b>Coxeter</b>.
<br />
The new ground points are obtained by translating the original
ground points by the their maximum.
</p>


<h3>Value</h3>

<p>The function returns a zonotope that is a translate of the original,
and has center of symmetry at 0.
<br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Coxeter, H.S.M.
<b>Regular Polytopes</b>.
Dover Publications.
1973.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+zonoseg">zonoseg</a>()</code>
</p>

<hr>
<h2 id='transitionsdf'>
summarize the number of transitions and associated data,
over all parallelograms in the boundary of a zonohedron
</h2><span id='topic+transitionsdf'></span>

<h3>Description</h3>

<p>The 2-transition surface is a union of parallelograms.
For this function, the surface is required to be strictly starshaped at
the center.
For the definition of <em>strictly starshaped</em> see
<a href="../doc/transitions.html">The 2-Transition Subcomplex and the 2-Transition Surface</a>.
</p>
<p>Each parallelogram has a unit normal that defines a linear functional.
<br />
If the 2-transition parallelogram is in the <em>interior</em> of the zonohedron
then the functional is not maximized on the parallelogram,
and there is a corresponding similar parallelogram
on the boundary of the zonohedron where the functional *is* maximized.
The first parallelogram (in the surface) is called <em>deficient</em> because
the functional is not maximized,
and the second parallelogram (in the boundary)
is called <em>abundant</em> because the number of corresponding
transitions across this parallelogram is more than 2.
The difference between the functional values is called the <em>deficit</em>.
<br />
If the 2-transition parallelogram is on the boundary,
then it is called <em>coincident</em>.
It is also called <em>non-deficient</em> and the deficit is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitionsdf( x, trans2=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionsdf_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>.
The 2-transition surface must be strictly starshaped.
</p>
</td></tr>
<tr><td><code id="transitionsdf_+3A_trans2">trans2</code></td>
<td>

<p>if <code>TRUE</code>, then include metrics on the non-deficient (coincident)
parallelograms, with 2 transitions.
This is always the first row of the returned data frame.
<br /> 
if <code>FALSE</code>, then data on the non-deficient parallelograms
is not included, and the returned data frame only has data
on the deficient parallelograms, with more than 2 transitions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>transitionsdf()</code> returns a <code>data.frame</code> with a row
for each number of transitions found,
plus a final row with totals on appropriate columns.
The columns are:
</p>
<table>
<tr><td><code>transitions</code></td>
<td>

<p>the number of transitions, a positive even integer, in increasing order.
</p>
</td></tr>
<tr><td><code>parallelograms</code></td>
<td>

<p>the number of parallelograms with the given number of transitions
</p>
</td></tr>
<tr><td><code>area</code></td>
<td>

<p>the min and max of the area of the
parallelograms with the given number of transitions
</p>
</td></tr>
<tr><td><code>area.sum</code></td>
<td>

<p>the total area of the parallelograms with the given number of transitions
</p>
</td></tr>
<tr><td><code>deficit</code></td>
<td>

<p>the min and max of the deficit of the
parallelograms with the given number of transitions.
When there are 2 transitions the deficit should be exactly 0,
but is usually slightly non-0 due to truncation.
When there are more than 2 transitions the deficit is positive.
</p>
</td></tr>
<tr><td><code>example</code></td>
<td>

<p>the 2 generators (from the ground set of the simplified matroid)
of the parallelogram with the maximum area
</p>
</td></tr>
</table>
<p>In case of error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>Because of the 1-1 correspondence between similar parallelograms,
the surface areas of the 2-transition surface
and the boundary of the zonohedron are equal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>
</p>

<hr>
<h2 id='zonogon'>
zonogon construction
</h2><span id='topic+zonogon'></span><span id='topic+polarzonogon'></span>

<h3>Description</h3>

<p>Construct a zonogon from a numeric matrix with 2 rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zonogon( mat, e0=0, e1=1.e-6, ground=NULL )

polarzonogon( n, m=n, ground=NULL )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonogon_+3A_mat">mat</code></td>
<td>

<p>a numeric 2xM matrix, where 2 <code class="reqn">\le</code> M.
The matrix must have rank 2 (verified).
The M columns are the generators of the zonogon.
</p>
</td></tr>
<tr><td><code id="zonogon_+3A_e0">e0</code></td>
<td>

<p>threshold for a column of <code>mat</code> to be considered 0,
in the <code class="reqn">L^\infty</code> norm.
Since the default is <code>e0=0</code>, 
by default a column must be exactly 0 to be considered 0.
</p>
</td></tr>
<tr><td><code id="zonogon_+3A_e1">e1</code></td>
<td>

<p>threshold, in a pseudo-angular sense,
for non-zero column vectors to be multiples of each other,
and thus members of a group of multiple (aka parallel) points in the associated matroid.
It OK for a column to be a negative multiple of another.
</p>
</td></tr>
<tr><td><code id="zonogon_+3A_ground">ground</code></td>
<td>

<p>The <em>ground set</em> of the associated matroid of rank 2 -
an integer vector in strictly increasing order, or <code>NULL</code>.
<br />
When <code>ground</code> is <code>NULL</code>, it is set to <code>1:ncol(mat)</code>.
If <code>ground</code> is not <code>NULL</code>, <code>length(ground)</code> must be equal to <code>ncol(mat)</code>.
The point <code>ground[i]</code> corresponds to the <em>i'th</em> column of <code>mat</code>.
</p>
</td></tr>
<tr><td><code id="zonogon_+3A_n">n</code></td>
<td>

<p>an integer <code class="reqn">\ge</code> 3.
The generators are computed as <code>n</code> equally spaced points on
the unit circle, starting at (1,0).
</p>
</td></tr>
<tr><td><code id="zonogon_+3A_m">m</code></td>
<td>
<p>an integer with 2 <code class="reqn">\le</code> <code>m</code> <code class="reqn">\le</code> <code>n</code>.
When  <code>m</code> &lt; <code>n</code>, only the first <code>m</code>
points are used as generators of the zonogon.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>polarzonogon()</code> is useful for testing.
The term <em>polar zonogon</em> is my own, and based on
the <em>polar zonohedron</em> in <em>Chilton &amp; Coxeter</em>.
It it loads the matrix <code>mat</code> and passes it to <code>zonogon()</code>.
When <code>m=n</code> the zonogon is a regular 2n-gon.
When <code>m&lt;n</code> the zonogon is a has 2<code>m</code> vertices,
but is not necessarily regular.
The generators correspond to the n'th-roots of unity.
</p>


<h3>Value</h3>

<p><code>zonogon()</code> and <code>polarzonogon()</code> return a list with S3 class <code>'zonogon'</code>.
In case of error, e.g. invalid <code>mat</code>,
the functions print an error message and returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The <em>ground set</em> of positive integers should not be too sparse;
otherwise performance may suffer.
</p>


<h3>References</h3>

<p>B. L. Chilton and H. S. M. Coxeter.
<b>Polar Zonohedra</b>.
The American Mathematical Monthly.
Vol 70. No. 9.
pp. 946-951.
1963.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+zonoseg">zonoseg</a>()</code>,
</p>

<hr>
<h2 id='zonogon-getmetrics'>
get important metrics about a zonogon, 
and print basic facts about a zonogon.
</h2><span id='topic+getmetrics.zonogon'></span><span id='topic+print.zonogon'></span>

<h3>Description</h3>

<p>Get some important zonogon metrics; some computation is used.
Also print the data, and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonogon'
getmetrics( x )

## S3 method for class 'zonogon'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonogon-getmetrics_+3A_x">x</code></td>
<td>

<p>a <b>zonogon</b> object
</p>
</td></tr>
<tr><td><code id="zonogon-getmetrics_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.zonogon()</code> prints some basic information about the zonogon,
and the associated matroid.
</p>


<h3>Value</h3>

<p><code>getmetrics()</code> returns a list with these items:
</p>
<table>
<tr><td><code>vertices</code></td>
<td>
<p>the number of vertices</p>
</td></tr>
<tr><td><code>perimeter</code></td>
<td>
<p>the sum of the lengths of the all edges</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>as a polygon</p>
</td></tr>
</table>
<p>All of these are always positive.
</p>
<p><code>print.zonogon()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+getmetrics.zonohedron">getmetrics.zonohedron</a>()</code>
</p>

<hr>
<h2 id='zonogon-invert'>
invert points in a zonogon
</h2><span id='topic+invert'></span><span id='topic+invert.zonogon'></span>

<h3>Description</h3>

<p>A <em>zonogon</em> <code class="reqn">Z</code> is the image of a linear map
<code class="reqn">[0,1]^n \to Z \subset \bold{R}^2</code>, from the n-cube to the plane.
For a point in a zonogon, this function
finds a point in the unit cube that maps to it.
There are infinitely many such points in general (unless <code class="reqn">n=2</code>),
but this function picks a specific point using the <em>standard tiling</em>,
see <b>Details</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonogon'
invert( x, z, tol=0, plot=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonogon-invert_+3A_x">x</code></td>
<td>

<p>a <b>zonogon</b> object as returned by the constructor <code>zonogon()</code>
</p>
</td></tr>
<tr><td><code id="zonogon-invert_+3A_z">z</code></td>
<td>

<p>a numeric Mx2 matrix, with M points in the rows.
<code>z</code> can also be a numeric vector that can be converted to such
a matrix, by row.
</p>
</td></tr>
<tr><td><code id="zonogon-invert_+3A_tol">tol</code></td>
<td>

<p>points that are within <code>tol</code> of the boundary are
still processed, see <b>Details</b>
</p>
</td></tr>
<tr><td><code id="zonogon-invert_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code> then the points in <code>z</code> are <em>added</em> to an existing
plot of the zonogon <code>x</code>, using a red X symbol,
see <code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code>.
If there is no plot open, a warning is issued.
</p>
</td></tr>
<tr><td><code id="zonogon-invert_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The given points are first tested for being inside the zonogon,
using <code><a href="#topic+inside">inside</a>()</code> and the given <code>tol</code>.
If any are outside, a warning is issued.
When the corresponding point <code>pcube</code> is computed,
it is clamped to the unit cube,
so the inversion error may be as large as <code>tol</code>.
<br /><br />
Inversion is not unique in general.
For this function, the <em>standard tiling</em> of the zonogon by parallelograms
is computed; it is an example of a <em>zonotopal tiling</em>.
It is a <em>regular zonotopal tiling</em> because it arises from the
projection of a zonohedron onto the plane, see <cite>Ziegler</cite>.
The function <code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code> has an option to plot this tiling.
Given the point <code>z</code>, the function determines a parallelogram
that contains the point.
The <code>pcube</code> coordinates of the <em>base</em> of this parallelogram are
all 0 or 1, and the coordinates of <code>z</code>
<em>within</em> the parallelogram are in [0,1].
Thus, all coordinates of <code>pcube</code> are 0 or 1,
except possibly for 2 of them.
</p>


<h3>Value</h3>

<p><code>invert.zonogon()</code> returns a <code>data.frame</code> with M rows and these columns:
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>the given point</p>
</td></tr>
<tr><td><code>pcube</code></td>
<td>

<p>a point in the unit cube that maps to <code>z</code>.
Every <code>pcube</code> has all coordinates 0 or 1,
except possibly for the 2 given by <code>hyper</code>, see <b>Details</b>.
</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>

<p>the 2 indexes of the generators of the parallelogram
that contains <code>z</code>, in the simplified matroid.
These 2 coordinates in <code>pcube</code> are not 0 or 1 in general.
</p>
</td></tr>
<tr><td><code>hyperidx</code></td>
<td>
<p>the index of the parallelogram that contains <code>z</code></p>
</td></tr>
</table>
<p>If a point <code>z</code> cannot be inverted, the other columns are
all <code>NA</code>, and a warning message is printed.  
</p>
<p>If the row names of <code>z</code> are unique,
they are copied to the row names of the output.
The column names of <code>pcube</code> are copied from the ground set of the
associated matroid.
<br /><br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Ziegler, G.M.
<b>Lectures on Polytopes</b>.
Graduate Texts in Mathematics.
Springer New York.
2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+inside">inside</a>()</code>,
<code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   make a zonogon with 5 generators
pz20 = polarzonogon( 20, 5 )

#   make 7 random points in the zonogon
set.seed(0)
pcube = matrix( runif(5*7), 5, 7 )
z = t( getmatrix(pz20) %*% pcube )

#  invert these 7 points back to the cube
invert( pz20, z )
#         z.1       z.2    pcube.1    pcube.2    pcube.3    pcube.4    pcube.5
# 1 2.0676319 1.6279807 0.00000000 0.70030526 1.00000000 1.00000000 0.01553241
# 2 2.4031738 1.9658035 0.00000000 0.96572153 1.00000000 1.00000000 0.28450140
# 3 0.9230336 1.0885446 0.00000000 0.00000000 0.39548689 1.00000000 0.04948838
# 4 2.5242122 1.7395069 0.16540765 1.00000000 1.00000000 1.00000000 0.03542132
# 5 2.2598725 1.0601592 0.38111324 1.00000000 1.00000000 0.20192029 0.00000000
# 6 1.1387813 1.2636700 0.00000000 0.00000000 0.65250505 1.00000000 0.07478012
# 7 1.6315341 1.0777737 0.00000000 0.64210923 1.00000000 0.36039509 0.00000000

#   hyper.1 hyper.2 hyperidx
# 1       2       5        7
# 2       2       5        7
# 3       3       5        9
# 4       1       5        4
# 5       1       4        3
# 6       3       5        9
# 7       2       4        6
</code></pre>

<hr>
<h2 id='zonogon-plot'>
plot a zonogon
</h2><span id='topic+plot.zonogon'></span>

<h3>Description</h3>

<p>Plot a <b>zonogon</b> object, with many options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonogon'
plot( x, orientation=TRUE, normals=FALSE, elabels=FALSE, 
                            tiling=FALSE,  tlabels=FALSE,
                            trans2=FALSE, trans2type='both', ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonogon-plot_+3A_x">x</code></td>
<td>

<p>a <b>zonogon</b> object as returned by the constructor <code>zonogon()</code>
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_orientation">orientation</code></td>
<td>

<p>if <code>TRUE</code> then draw the edges with orientation arrows.
Otherwise just draw unoriented line segments.
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_normals">normals</code></td>
<td>

<p>if <code>TRUE</code> then draw an outward-pointing unit normal on each edge
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_elabels">elabels</code></td>
<td>

<p>if <code>TRUE</code> then label each edge with its generator
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_tiling">tiling</code></td>
<td>

<p>if <code>TRUE</code> then draw the standard tiling of the zonogon by parallelograms
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_tlabels">tlabels</code></td>
<td>

<p>if <code>TRUE</code> then label each parallelogram in the tiling with
its generators.  
If <code>tiling</code> is <code>FALSE</code> then this is ignored.
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_trans2">trans2</code></td>
<td>

<p>if <code>TRUE</code> then draw the image of the 2-transition subcomplex
of the unit cube <code class="reqn">[0,1]^n</code>, in the color blue.
<br />
<code>trans2</code> can also be an integer 2-vector defining a range
of levels of the subcomplex, where the <em>level</em> of a vertex
of the <code class="reqn">n</code>-cube is the number of 1s.
Both integers should be between <code class="reqn">0</code> and <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_trans2type">trans2type</code></td>
<td>

<p>which part of the 2-transition subcomplex to draw.
It can be <code>'BP'</code> for <em>bandpass</em> (aka Type 1),
<code>'BS'</code> for <em>bandstop</em> (aka Type 2),
or <code>'both'</code> for both.
</p>
</td></tr>
<tr><td><code id="zonogon-plot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A white dot is plotted at the center of the zonogon.
A suitable is title is added above the plot.
If the zonogon was returned from <code><a href="#topic+spherize.zonotope">spherize.zonotope</a>()</code>
the string <code>"[spherized]"</code> is added to the title.
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code>; or <code>FALSE</code> in case of error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+spherize.zonotope">spherize.zonotope</a>()</code>
</p>

<hr>
<h2 id='zonogon-raytrace'>
compute the intersection of a ray, based in the interior of
a zonogon, and the boundary of that zonogon
</h2><span id='topic+raytrace.zonogon'></span>

<h3>Description</h3>

<p>The <em>open ray</em> with basepoint <code class="reqn">\bold{b}</code>
and non-zero direction <code class="reqn">\bold{d}</code> is the set of the form
<code class="reqn">\bold{b} + t \bold{d}</code> where <code class="reqn">t &gt; 0</code>.
<br /><br />
This function computes the intersection of an open ray
and the boundary of a zonogon <code class="reqn">Z</code>.
The basepoint is normally required to be in the interior
of <code class="reqn">Z</code>, but an exception is made if the basepoint is 0,
and on the boundary of <code class="reqn">Z</code>,
and the direction points into the interior of <code class="reqn">Z</code>.
In these two cases the intersection of the open ray
and the boundary of <code class="reqn">Z</code> is unique.
In the second case, the basepoint is also allowed to be
the sum of all the generators - the so-called <em>white point</em>
of <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonogon'
raytrace( x, base, direction, plot=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonogon-raytrace_+3A_x">x</code></td>
<td>

<p>a <b>zonogon</b> object as returned by the constructor <code>zonogon()</code>
</p>
</td></tr>
<tr><td><code id="zonogon-raytrace_+3A_base">base</code></td>
<td>

<p>a numeric 2-vector - the basepoint of all the rays.
<code>base</code> must either be in the interior of <code>x</code>,
or 0 or the <em>white point</em> and on the boundary of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="zonogon-raytrace_+3A_direction">direction</code></td>
<td>

<p>a numeric Mx2 matrix with M non-zero directions in the rows.
The basepoint and these directions define M rays.
<br />
<code>direction</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
<tr><td><code id="zonogon-raytrace_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>, the computed rays, up to the boundary,
are <em>added</em> to an existing
plot of the zonogon <code>x</code>, see <code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code>.
The segments are drawn in the color red.
If there is no open plot, a warning is issued.
</p>
</td></tr>
<tr><td><code id="zonogon-raytrace_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raytrace.zonogon()</code> returns a <code>data.frame</code> with M rows and these columns:
</p>
<table>
<tr><td><code>base</code></td>
<td>

<p>the given basepoint - this is the same in every row
</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>

<p>the given direction
</p>
</td></tr>
<tr><td><code>facetidx</code></td>
<td>

<p>the index of the facet (an edge) where ray exits the zonogon
</p>
</td></tr>
<tr><td><code>sign</code></td>
<td>

<p>of the facet, either +1 or -1
</p>
</td></tr>
<tr><td><code>tmax</code></td>
<td>

<p>ray parameter of the intersection with the exit facet, always positive
</p>
</td></tr>
<tr><td><code>point</code></td>
<td>

<p>the point on the boundary; the intersection of the ray and the facet
</p>
</td></tr>
<tr><td><code>timetrace</code></td>
<td>

<p>the computation time, in seconds
</p>
</td></tr>
</table>
<p>If <code>base</code> and <code>direction</code> in a row cannot be
processed, the rest of the row is <code>NA</code>.
</p>
<p>If the row names of <code>direction</code> are unique,
they are copied to the row names of the output.
<br /><br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code>,
<code><a href="#topic+section.zonohedron">section.zonohedron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   make a zonogon with 5 generators
pz20 = polarzonogon( 20, 5 )

#   make 4 random directions
set.seed(0)
dir = matrix(rnorm(4*2),4,2)

#  use basepoint in the interior of the zonogon
raytrace( pz20, c(0.5,0.5), dir )
#   base.1 base.2 direction.1 direction.2 facetidx sign      tmax boundary.1 boundary.2    timetrace
# 1    0.5    0.5   1.2629543   0.4146414        4   -1 2.0503073 3.08944438 1.35014236 7.680000e-05
# 2    0.5    0.5  -0.3262334  -1.5399500        1   -1 0.3246859 0.39407664 0.00000000 4.649995e-05
# 3    0.5    0.5   1.3297993  -0.9285670        2   -1 0.4868719 1.14744192 0.04790678 4.310103e-05
# 4    0.5    0.5   1.2724293  -0.2947204        2   -1 0.9354693 1.69031851 0.22429808 4.149997e-05


#  use basepoint at 0 - on the boundary of the zonogon
raytrace( pz20, c(0,0), dir )
#   base.1 base.2 direction.1 direction.2 facetidx sign     tmax boundary.1 boundary.2 timetrace
# 1      0      0   1.2629543   0.4146414        4   -1 2.192481  2.7690037  0.9090936 0.0001216
# 2      0      0  -0.3262334  -1.5399500       NA   NA       NA         NA         NA        NA
# 3      0      0   1.3297993  -0.9285670       NA   NA       NA         NA         NA        NA
# 4      0      0   1.2724293  -0.2947204       NA   NA       NA         NA         NA        NA
</code></pre>

<hr>
<h2 id='zonogon-section'>
compute the intersection of a line and the boundary of a zonogon
</h2><span id='topic+section.zonogon'></span>

<h3>Description</h3>

<p>Generically, a line intersects the boundary of a zonogon in 2 points.
Computing those 2 points is the chief goal of this function.
<br />
For a supporting line, the intersection is a face of the zonogon,
but in this function only one point of intersection is computed and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonogon'
section( x, normal, beta, tol=1.e-10, plot=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonogon-section_+3A_x">x</code></td>
<td>

<p>a <b>zonogon</b> object as returned by the constructor <code>zonogon()</code>
</p>
</td></tr>
<tr><td><code id="zonogon-section_+3A_normal">normal</code></td>
<td>

<p>a non-zero numeric 2-vector - the normal of all the lines
</p>
</td></tr>
<tr><td><code id="zonogon-section_+3A_beta">beta</code></td>
<td>

<p>a numeric M-vector of line-constants.  
The equation of the k'th line k is: <code>&lt;x,normal&gt; = beta[k]</code>.
</p>
</td></tr>
<tr><td><code id="zonogon-section_+3A_tol">tol</code></td>
<td>

<p>a small positive number, used as the tolerance for the line
being considered a supporting line
</p>
</td></tr>
<tr><td><code id="zonogon-section_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>,  the line segments formed by the the intersection 
of the lines and the zonogon are <em>added</em> to an existing
plot of the zonogon <code>x</code>, see <code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code>.
The segments are drawn in dashed linestyle and the color red.
<code>boundary1</code> and <code>boundary2</code> are plotted as points.
If there is no open plot, a warning is issued.
</p>
</td></tr>
<tr><td><code id="zonogon-section_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>section.zonogon()</code> returns a <code>data.frame</code> with M rows and these columns:
</p>
<table>
<tr><td><code>normal</code></td>
<td>
<p>the given normal vector - this is the same in every row</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>the given line constant
</p>
</td></tr>
<tr><td><code>boundary1</code></td>
<td>

<p>the 1st intersection point - a 2-vector
</p>
</td></tr>
<tr><td><code>boundary2</code></td>
<td>

<p>the 2nd intersection point - a 2-vector
</p>
</td></tr>
</table>
<p>Regarding orientation, if <code>normal</code> is considered &quot;north&quot; then 
<code>boundary1</code> is on the &quot;west&quot; and <code>boundary2</code> is on the &quot;east&quot;.
</p>
<p>If a line is a supporting line of the zonogon,
then <code>boundary1</code> is some point in the boundary face (vertex or edge),
and <code>boundary2</code> is <code>NA</code>.
If a line does not intersect the zonogon, 
both <code>boundary1</code> and <code>boundary2</code> are <code>NA</code>.
</p>
<p>If the names of <code>beta</code> are unique,
they are copied to the row names of the output.
<br /><br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+plot.zonogon">plot.zonogon</a>()</code>,
<code><a href="#topic+section.zonohedron">section.zonohedron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   make a zonogon with 5 generators
pz20 = polarzonogon( 20, 5 )

section( pz20, normal=c(1,1), beta=-1:5 )
#   normal.1 normal.2 beta   boundary1.1   boundary1.2 boundary2.1 boundary2.2
# 1        1        1   -1            NA            NA          NA          NA
# 2        1        1    0 -2.220446e-16  0.000000e+00          NA          NA
# 3        1        1    1  2.452373e-01  7.547627e-01   1.0000000   0.0000000
# 4        1        1    2  6.203838e-01  1.379616e+00   1.7547627   0.2452373
# 5        1        1    3  1.095537e+00  1.904463e+00   2.3796162   0.6203838
# 6        1        1    4  1.674729e+00  2.325271e+00   2.9044629   1.0955371
# 7        1        1    5  2.420068e+00  2.579932e+00   3.3252706   1.6747294
</code></pre>

<hr>
<h2 id='zonohedron'>
zonohedron construction
</h2><span id='topic+zonohedron'></span><span id='topic+polarzonohedron'></span><span id='topic+regularprism'></span>

<h3>Description</h3>

<p>Construct a zonohedron from a numeric matrix with 3 rows.
Also construct some special zonohedra useful for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zonohedron( mat, e0=0, e1=1.e-6, e2=1.e-10, ground=NULL )

polarzonohedron( n, m=n, height=pi, ground=NULL )

regularprism( n, m=n, axis=c(0,0,1), ground=NULL )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonohedron_+3A_mat">mat</code></td>
<td>

<p>a numeric 3xM matrix, where 3 <code class="reqn">\le</code> M.
The matrix must have rank 3 (verified).
The M columns are the generators of the zonohedron.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_e0">e0</code></td>
<td>

<p>threshold for a column of <code>mat</code> to be considered 0,
in the <code class="reqn">L^\infty</code> norm.
Since the default is <code>e0=0</code>, 
by default a column must be exactly 0 to be considered 0.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_e1">e1</code></td>
<td>

<p>threshold, in a pseudo-angular sense,
for non-zero column vectors to be multiples of each other,
and thus members of a group of multiple (aka parallel) points in the associated matroid.
It OK for a column to be a negative multiple of another.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_e2">e2</code></td>
<td>

<p>threshold, in a pseudo-angular sense, for the planes
spanned by pairs of column vectors to be considered coincident,
and thus the columns to be in the same hyperplane of the associated matroid.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_ground">ground</code></td>
<td>

<p>The <em>ground set</em> of the associated matroid of rank 3 -
an integer vector in strictly increasing order, or <code>NULL</code>.
<br />
When <code>ground</code> is <code>NULL</code>, it is set to <code>1:ncol(mat)</code>.
If <code>ground</code> is not <code>NULL</code>, <code>length(ground)</code> must be equal to <code>ncol(mat)</code>.
The point <code>ground[i]</code> corresponds to the <em>i'th</em> column of <code>mat</code>.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_n">n</code></td>
<td>

<p>an integer <code class="reqn">\ge</code> 3.
The generators are computed as <code>n</code> equally spaced points on
a circle.
See <b>Details</b> for more on this circle.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_m">m</code></td>
<td>
<p>an integer with 2 <code class="reqn">\le</code> <code>m</code> <code class="reqn">\le</code> <code>n</code>.
When  <code>m </code>&lt; <code>n</code>, only the first <code>m</code>
points are used as generators of the zonohedron.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_height">height</code></td>
<td>
<p>the z value at the apex of the zonohedron,
which is the sum of all the generators.
The z value of all the generators is set to make this happen.
When <code>height=pi</code>, as <code class="reqn">n \to \infty</code> the zonohedron
converges to the interior of the surface of revolution
of the curve <code class="reqn">x = sin(z)</code> for <code class="reqn">z \in [0,\pi]</code>,
see <b>Chilton &amp; Coxeter</b>.
</p>
</td></tr>
<tr><td><code id="zonohedron_+3A_axis">axis</code></td>
<td>

<p>the axis of the regular prism. It must be a 3-vector with z value non-zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>zonohedron()</code>, the contruction of the <em>zones</em> (or <em>belts</em>) is optimized by following
the procedure in <cite>Heckbert</cite>.
The key step is sorting face normals that all lie on a great circle
of the unit sphere.
<br /><br />
For <code>polarzonohedron()</code> the circle is centered at
(0,0,<code>height/n</code>) and parallel to the xy-plane.
The radius is <code>height/n</code>.
<br /><br />
For <code>regularprism()</code> the circle is the unit circle in the xy-plane.
The 3-vector <code>axis</code> is added as column <code>m+1</code> of the matrix.
The returned zonohedron is the Minkowski sum of a zonogon and
the line segment defined by <code>axis</code>.
If <code>m</code> &lt; <code>n</code>, the zonogon may not be regular.
<br /><br />
Both of these functions are useful for testing.
They load the matrix <code>mat</code> and pass it to <code>zonohedron()</code>.
</p>


<h3>Value</h3>

<p><code>zonohedron()</code> and <code>polarzonohedron()</code> return a list with S3 class <code>'zonohedron'</code>.
In case of error, e.g. invalid <code>mat</code>,
the functions print an error message and returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The <em>ground set</em> of positive integers should not be too sparse;
otherwise performance may suffer.
</p>


<h3>References</h3>

<p>B. L. Chilton and H. S. M. Coxeter.
<b>Polar Zonohedra</b>.
The American Mathematical Monthly.
Vol 70. No. 9.
pp. 946-951.
1963.
</p>
<p>Paul Heckbert.
<b>An Efficient Algorithm for Generating Zonohedra</b>.
3-D Technical Memo 11.
24 February 1985.
Computer Graphics Lab.
New York Institute of Technology
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+zonoseg">zonoseg</a>()</code>,
</p>

<hr>
<h2 id='zonohedron-plot'>
plot a zonohedron
</h2><span id='topic+plot.zonohedron'></span>

<h3>Description</h3>

<p>Plot a <b>zonohedron</b> object in 3D, with many options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonohedron'
plot( x, type='e', pcol=NULL, ecol=NULL, ewd=3, etcol=NA,
        fcol=NULL, falpha=1, normals=FALSE, bgcol="gray40", both=TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonohedron-plot_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_type">type</code></td>
<td>

<p>a string of letter with what parts to draw.
If <code>type</code> contains an <code>'p'</code>, then draw a point at the center
of each facet.
If <code>type</code> contains an <code>'e'</code>, then draw the edges.
If <code>type</code> contains an <code>'f'</code>, then draw filled facets.
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_pcol">pcol</code></td>
<td>

<p>The color to use when drawing points.
It can be a vector of 2 colors, and then when <code>both</code> is <code>TRUE</code>,
the first color is used for one half,
and the second color is used for the antipodal half.
When <code>pcol</code> is <code>NULL</code>,
it is set to <code>c('black','red')</code>.
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_ecol">ecol</code></td>
<td>

<p>A vector of colors to use when drawing the edges.
Let N be the number of <em>simplified</em> generators of the zonohedron.
Each edge is parallel to exactly one of the generators,
so this divides the edges into N <em>zones</em>, or <em>belts</em>.
<code>ecol</code> can be a vector of N colors, one for each zone.
If <code>ecol</code> is shorter than N, it is extended to length N using the last color.
If <code>ecol</code> is longer than N, the extra colors are ignored.
If <code>ecol</code> is <code>NULL</code>, it is set to <code>rainbow(N)</code>.
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_ewd">ewd</code></td>
<td>

<p>width of the edges, in pixels
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_etcol">etcol</code></td>
<td>

<p>color of the <em>tiling edges</em>, for the standard tiling
of the facets by parallelograms.
This only applies to facets that are <em>not</em> parallelograms.
The default <code>etol=NA</code> means do not draw these edges.
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_fcol">fcol</code></td>
<td>

<p>A vector of colors to use when drawing the facets.
The 1st color is used for parallelograms,
the next color for hexagons, etc.
For facets with more edges than colors available, the last color is used.
If <code>fcol</code> is <code>NULL</code>, it is set to
<code>c( 'blue', 'red', 'yellow', 'green', 'orange', 'purple' )</code>.
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_falpha">falpha</code></td>
<td>

<p>opacity of the facets
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_normals">normals</code></td>
<td>

<p>if <code>TRUE</code> then draw an outward-pointing unit normal from each facet
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_bgcol">bgcol</code></td>
<td>

<p>the background color
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_both">both</code></td>
<td>

<p>if <code>FALSE</code> then draw only one half of the centrally symmetric boundary.
Otherwise draw both halves.
This affects points, edges, and facets.
</p>
</td></tr>
<tr><td><code id="zonohedron-plot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Points are drawn with <code>rgl::points3d()</code>.
Edges are drawn with <code>rgl::segments3d()</code>.
Edges of the tiles are drawn with <code>rgl::quads3d()</code>.
Facets are drawn with <code>rgl::quads3d()</code>;
facets with more than 4 edges are split into trapezoids.
Facet normals are drawn with <code>rgl::arrow3d()</code>.
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code>; or <code>FALSE</code> in case of error.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plots.
A large black point is drawn at 0, 
a 50% gray point at the center,
and a large white point at the &quot;white point&quot; (which is 2*center).
</p>
<p>A line from the black point to the white point is also drawn.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+spherize.zonotope">spherize.zonotope</a>()</code>
</p>

<hr>
<h2 id='zonohedron-raytrace'>
compute the intersection of a ray, based in the interior of
a zonohedron, and the boundary of that zonohedron
</h2><span id='topic+raytrace'></span><span id='topic+raytrace.zonohedron'></span>

<h3>Description</h3>

<p>The <em>open ray</em> with basepoint <code class="reqn">\bold{b}</code>
and non-zero direction <code class="reqn">\bold{d}</code> is the set of the form
<code class="reqn">\bold{b} + t \bold{d}</code> where <code class="reqn">t &gt; 0</code>.
<br /><br />
This function computes the intersection of an open ray
and the boundary of a zonohedron <code class="reqn">Z</code>.
The basepoint is normally required to be in the interior
of <code class="reqn">Z</code>, but an exception is made if the basepoint is 0,
and on the boundary of <code class="reqn">Z</code>,
and the direction points into the interior of <code class="reqn">Z</code>.
In these two cases the intersection of the open ray
and the boundary of <code class="reqn">Z</code> is unique.
In the second case, the basepoint is also allowed to be
the sum of all the generators - the so-called <em>white point</em>
of <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonohedron'
raytrace( x, base, direction, invert=FALSE, plot=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonohedron-raytrace_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="zonohedron-raytrace_+3A_base">base</code></td>
<td>

<p>a numeric 3-vector - the basepoint of all the rays.
<code>base</code> must either be in the interior of <code>x</code>,
or 0 or the <em>white point</em> and on the boundary of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="zonohedron-raytrace_+3A_direction">direction</code></td>
<td>

<p>a numeric Mx3 matrix with M non-zero directions in the rows.
The basepoint and these directions define M rays.
<br />
<code>direction</code> can also be a numeric vector that can be converted
to such a matrix, by row.
</p>
</td></tr>
<tr><td><code id="zonohedron-raytrace_+3A_invert">invert</code></td>
<td>

<p>if <code>TRUE</code>, then compute a point in the unit cube that maps to the point on the boundary
of <code>x</code> and add it as a column in the returned <code>data.frame</code>
</p>
</td></tr>
<tr><td><code id="zonohedron-raytrace_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>, the computed rays, up to the boundary,
are <em>added</em> to an existing
plot of the zonohedron <code>x</code>, see <code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>.
The segments are drawn in the color red.
If there is no open plot, a warning is issued.
</p>
</td></tr>
<tr><td><code id="zonohedron-raytrace_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is <code>TRUE</code>, the rays are drawn
with <code>rgl::segments3d()</code>.
</p>


<h3>Value</h3>

<p><code>raytrace.zonohedron()</code> returns a <code>data.frame</code> with M rows and these columns:
</p>
<table>
<tr><td><code>base</code></td>
<td>

<p>the given basepoint - this is the same in every row
</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>

<p>the given direction
</p>
</td></tr>
<tr><td><code>facetidx</code></td>
<td>

<p>the index of the facet (a zonogon) where ray exits the zonohedron
</p>
</td></tr>
<tr><td><code>sign</code></td>
<td>

<p>of the facet, either +1 or -1
</p>
</td></tr>
<tr><td><code>tmax</code></td>
<td>

<p>ray parameter of the intersection with the exit facet, always positive
</p>
</td></tr>
<tr><td><code>point</code></td>
<td>

<p>the point on the boundary; the intersection of the ray and the facet
</p>
</td></tr>
<tr><td><code>timetrace</code></td>
<td>

<p>the computation time, in seconds
</p>
</td></tr>
</table>
<p>And if <code>invert</code> is <code>TRUE</code>, then these columns are added:
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>signed distance to the boundary of <code>x</code></p>
</td></tr>
<tr><td><code>pcube</code></td>
<td>
<p>a point in the unit cube that maps to <code>boundary</code></p>
</td></tr>
<tr><td><code>transitions</code></td>
<td>
<p>the number of transitions in <code>pcube</code> - a non-negative even integer</p>
</td></tr>
</table>
<p>If <code>base</code> and <code>direction</code> in a row cannot be
processed, the rest of the row is <code>NA</code>.
</p>
<p>If the row names of <code>direction</code> are unique,
they are copied to the row names of the output.
<br /><br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>,
<code><a href="#topic+section.zonohedron">section.zonohedron</a>()</code>,
<code><a href="#topic+invertboundary">invertboundary</a>()</code>,
<code><a href="#topic+raytrace.zonogon">raytrace.zonogon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   make a regular prism, a regular 20-gon extruded 1 unit along z-axis
rp10 = regularprism( 10 )

#   make 7 random directions
set.seed(0)
dir = matrix(rnorm(7*3),7,3)

#  use basepoint in the interior of the zonohedron
raytrace( rp10, c(0.5,0.5,0.5), dir )
#   base.1 base.2 base.3  direction.1  direction.2  direction.3 facetidx sign      tmax   ...
# 1    0.5    0.5    0.5  1.262954285 -0.294720447 -0.299215118        1    1 1.6710386   ...
# 2    0.5    0.5    0.5 -0.326233361 -0.005767173 -0.411510833        1    1 1.2150348   ...
# 3    0.5    0.5    0.5  1.329799263  2.404653389  0.252223448        6   -1 0.8724774   ...
# 4    0.5    0.5    0.5  1.272429321  0.763593461 -0.891921127        1    1 0.5605877   ...
# 5    0.5    0.5    0.5  0.414641434 -0.799009249  0.435683299        1   -1 1.1476226   ...
# 6    0.5    0.5    0.5 -1.539950042 -1.147657009 -1.237538422        1    1 0.4040279   ...
# 7    0.5    0.5    0.5 -0.928567035 -0.289461574 -0.224267885        1    1 2.2294766   ...

#  use basepoint 0 on the boundary of the zonohedron
#  note that only 2 directions point into the interior
raytrace( rp10, c(0,0,0), dir )
#   base.1 base.2 base.3  direction.1  direction.2  direction.3 facetidx sign     tmax   ...
# 1      0      0      0  1.262954285 -0.294720447 -0.299215118       NA   NA       NA   ...
# 2      0      0      0 -0.326233361 -0.005767173 -0.411510833       NA   NA       NA   ...
# 3      0      0      0  1.329799263  2.404653389  0.252223448        6   -1 1.128580   ...
# 4      0      0      0  1.272429321  0.763593461 -0.891921127       NA   NA       NA   ...
# 5      0      0      0  0.414641434 -0.799009249  0.435683299        1   -1 2.295245   ...
# 6      0      0      0 -1.539950042 -1.147657009 -1.237538422       NA   NA       NA   ...
# 7      0      0      0 -0.928567035 -0.289461574 -0.224267885       NA   NA       NA   ...
</code></pre>

<hr>
<h2 id='zonohedron-section'>
compute the intersection of a plane and the boundary of a zonohedron
</h2><span id='topic+section'></span><span id='topic+section.zonohedron'></span>

<h3>Description</h3>

<p>Generically, a plane intersects the boundary of a
zonohedron in a convex polygon.
Computing that polygon is the chief goal of this function.
<br />
For a supporting plane, the intersection is a face of the zonohedron,
but in this function only one point of intersection is computed and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonohedron'
section( x, normal, beta, tol=1.e-10, plot=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonohedron-section_+3A_x">x</code></td>
<td>

<p>a <b>zonohedron</b> object as returned by the constructor <code>zonohedron()</code>
</p>
</td></tr>
<tr><td><code id="zonohedron-section_+3A_normal">normal</code></td>
<td>

<p>a non-zero numeric 3-vector - the normal of all the planes
</p>
</td></tr>
<tr><td><code id="zonohedron-section_+3A_beta">beta</code></td>
<td>

<p>a numeric M-vector of line-constants.  
The equation of the k'th plane k is: <code>&lt;x,normal&gt; = beta[k]</code>.
</p>
</td></tr>
<tr><td><code id="zonohedron-section_+3A_tol">tol</code></td>
<td>

<p>a small positive number, used as the tolerance for the plane
being considered a supporting plane
</p>
</td></tr>
<tr><td><code id="zonohedron-section_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code>, the polygons formed by the the intersection 
of the planes and the boundary of the zonohedron are
<em>added</em> to an existing 3D plot of the zonohedron <code>x</code>,
see <code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>.
The polygons are drawn in red.
</p>
</td></tr>
<tr><td><code id="zonohedron-section_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a plane, the function finds all the facets of the zonohedron
that intersect the plane.
For each such facet it computes a single point of intersection
on the boundary of the facet.
For the parallelograms, the computation is done in a C function;
and for zonogon facets with 3 or more generators,
the computation is done in <code><a href="#topic+section.zonogon">section.zonogon</a>()</code>.
Orientation is handled carefully so that no point appears twice.
The facets are not processed in order around the boundary,
so these points are in no particular order.
They are put in polygon order by sorting them by angle
around a suitable &quot;diameter&quot; of the zonohedron.
</p>


<h3>Value</h3>

<p><code>section.zonohedron()</code> returns a list of length M
(=<code>length(beta)</code>),
and the i'th item in the list is a data frame with these columns:
</p>
<table>
<tr><td><code>point</code></td>
<td>

<p>a Px3 matrix with the P points of the i'th polygon in the rows.
If the plane does not intersect the zonohedron, then P=0
and the matrix has 0 rows.
If the plane is a supporting plane, the polygon is degenerate
and P=1 and the matrix has 1 row.
The row names of <code>section</code> are the indexes of the facets
that contain the vertices of the polygon; see <b>Details</b>.
</p>
</td></tr>
<tr><td><code>hyperidx</code></td>
<td>

<p>index of a hyperplane that contains the given point
</p>
</td></tr>
<tr><td><code>sign</code></td>
<td>

<p>The sign specifying which of the 2 facets (selected or antipodal)
contains the given point. The value is +1 or -1.
</p>
</td></tr>
</table>
<p>The names of the list are readable strings that contain
<code>normal</code> and <code>beta[i]</code>.
</p>
<p>In case of error, the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">rgl</span> is required for 3D plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+plot.zonohedron">plot.zonohedron</a>()</code>,
<code><a href="#topic+section.zonogon">section.zonogon</a>()</code>
</p>

<hr>
<h2 id='zonoseg'>
zonoseg construction, querying, and printing
</h2><span id='topic+getsegment'></span><span id='topic+getsegment2trans'></span><span id='topic+zonoseg'></span><span id='topic+getsegment.zonoseg'></span><span id='topic+getsegment2trans.zonoseg'></span><span id='topic+print.zonoseg'></span>

<h3>Description</h3>

<p>Construct a zonoseg from a numeric matrix with one row.
<br /><br />
A <em>zonoseg</em> (&quot;zonotope&quot; + &quot;segment&quot;) is my own personal term
for a 1-dimensional zonotope.
I could not find an alternative term.
It is a linear image of the unit cube <code class="reqn">[0,1]^n</code> in the real numbers,
and a compact segment of reals.
The order of the generators has no effect on the zonoseg.
<br /><br />
The image of the <em>2-transition subcomplex</em> of <code class="reqn">[0,1]^n</code>
is a compact subsegment of the zonoseg.
The order of the generators affects this subsegment in a major way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zonoseg( mat, e0=0, ground=NULL )

## S3 method for class 'zonoseg'
getsegment( x )

## S3 method for class 'zonoseg'
getsegment2trans( x )

## S3 method for class 'zonoseg'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonoseg_+3A_mat">mat</code></td>
<td>

<p>a numeric matrix with 1 row whose entries determine the zonoseg.
One or more entries must be non-zero.
It is OK to have both positive and negative entries.
<br />
<code>mat</code> can also be a numeric vector which is then
converted to a matrix with 1 row.
</p>
</td></tr>
<tr><td><code id="zonoseg_+3A_e0">e0</code></td>
<td>

<p>threshold for an entry of <code>mat</code> to be considered 0.
Since the default is <code>e0=0</code>, 
by default an entry must be exactly 0 to become a loop in the
associated matroid.
</p>
</td></tr>
<tr><td><code id="zonoseg_+3A_ground">ground</code></td>
<td>

<p>The <em>ground set</em> of the associated matroid of rank 1 -
an integer vector in strictly increasing order, or <code>NULL</code>.
<br />
When <code>ground</code> is <code>NULL</code>, it is set to <code>1:ncol(mat)</code>.
If <code>ground</code> is not <code>NULL</code>, <code>length(ground)</code> must be equal to <code>ncol(mat)</code>.
The point <code>ground[i]</code> corresponds to the <em>i'th</em> column of <code>mat</code>.
</p>
</td></tr>
<tr><td><code id="zonoseg_+3A_x">x</code></td>
<td>

<p>a <code>zonoseg</code> object as returned by <code>zonoseg()</code>
</p>
</td></tr>
<tr><td><code id="zonoseg_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <b>zonoseg</b> object is a list with only 3 items:
the associated matroid, the endpoints of the segment,
and endpoints of the <em>2-transition subsegment</em>.
<br /><br />
<code>print.zonoseg()</code> prints some information about the generators,
and the endpoints of the segment plus the 2 vertices of the unit cube
that map to these endpoints.
It prints similar data for the 2-transition subsegment.
Finally, it prints data on the associated matroid.
</p>


<h3>Value</h3>

<p><code>zonoseg()</code> returns a list with S3 class <code>'zonoseg'</code>.
In case of error, e.g. invalid <code>mat</code>,
the function prints an error message and returns <code>NULL</code>.
<br /><br />
<code>getsegment()</code> and <code>getsegment2trans()</code> 
return numeric 2-vectors - the min and max endpoints of the corresponding
segments.
<br /><br />
<code>print.zonoseg()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>The <em>ground set</em> of positive integers should not be too sparse;
otherwise performance may suffer.
</p>


<h3>References</h3>

<p><b>Matroid - Wikipedia</b>.<br />
<a href="https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057">https://en.wikipedia.org/w/index.php?title=Matroid&amp;oldid=1086234057</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank">rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zono1 = zonoseg( c(1,-2,3,0,-3,-4) )
zono1

# generators:        6 -- 3 negative, 2 positive, and 1 loops.
#
# segment:                   [-9,4]
#      value pcube.1 pcube.2 pcube.3 pcube.4 pcube.5 pcube.6
# zmin    -9       0       1       0       0       1       1
# zmax     4       1       0       1       0       0       0
#
# 2-transition subsegment:   [-8,3]
#             value source.1 source.2 source.3 source.4 source.5 source.6
# tmin-2trans    -8        1        1        0        0        1        1
# tmax-2trans     3        0        0        1        1        0        0
# 
# matroid:
# ground set:           6 points   {1 2 3 4 5 6}
# hyperplanes:          1     {4}
# rank:                 1
# loops:                1   {4}
# multiple groups:      1     {1 2 3 5 6}
# uniform:              FALSE
# paving:               TRUE
# simple:               FALSE
# This matroid is constructed from a 1x6 real matrix.
#      1  2 3 4  5  6
# [1,] 1 -2 3 0 -3 -4
# 
# The summary of the simplified matroid is:
#     ground set:           1 points   {1}
#                       Point 1 corresponds to the multiple group {1 2 3 5 6} in the original ...
#      hyperplanes:          1     {}
#      rank:                 1
#      loops:                0   {}
#      multiple groups:      0   {}
#      uniform:              TRUE
#      paving:               TRUE
#      simple:               TRUE
#      This matroid is constructed from a 1x1 real matrix.
#           1+...+6
#      [1,]     -13


## so the 2-transition subsegment is a proper subset of the zonoseg
</code></pre>

<hr>
<h2 id='zonoseg-invert'>
invert points in a zonoseg
</h2><span id='topic+invert.zonoseg'></span>

<h3>Description</h3>

<p>For points in a zonoseg, find points in the unit cube that map to those points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonoseg'
invert( x, z, tol=0, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonoseg-invert_+3A_x">x</code></td>
<td>

<p>a <code>zonoseg</code> object as returned by the constructor <code>zonoseg()</code>
</p>
</td></tr>
<tr><td><code id="zonoseg-invert_+3A_z">z</code></td>
<td>
<p>a numeric M-vector</p>
</td></tr>
<tr><td><code id="zonoseg-invert_+3A_tol">tol</code></td>
<td>
<p>points that are within <code>tol</code> of a boundary point are
taken to be that point</p>
</td></tr>
<tr><td><code id="zonoseg-invert_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a point in the interior of the zonoseg,
there are infinitely many points in the cube that map to it.
This function tries to find one with the fewest number of non-zero
components.
</p>


<h3>Value</h3>

<p><code>invert.zonoseg()</code> returns a <code>data.frame</code> with M rows and these columns:
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>the given point</p>
</td></tr>
<tr><td><code>pcube</code></td>
<td>
<p>a point in the unit cube that maps to <code>z</code>. For the 2 boundary points, <code>pcube</code> is a vertex. If <code>z</code> is outside the zonoseg, <code>pcube</code> is all <code>NA</code>, and a warning message is printed</p>
</td></tr>  
</table>
<p>If the names of <code>z</code> are unique,
they are copied to the row names of the output.
The column names are copied from the ground set of the associated matroid.
<br /><br />
In case of error, the function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonoseg">zonoseg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zono1 = zonoseg( c(1,-2,3,0,-3,-4) )
zono1
# generators:        6 -- 3 negative, 2 positive, and 1 loops.
# 
# segment:                   [-9,4]
#      value pcube.1 pcube.2 pcube.3 pcube.4 pcube.5 pcube.6
# zmin    -9       0       1       0       0       1       1
# zmax     4       1       0       1       0       0       0
# 
# 2-transition subsegment:   [-8,3]
#             value source.1 source.2 source.3 source.4 source.5 source.6
# tmin-2trans    -8        1        1        0        0        1        1
# tmax-2trans     3        0        0        1        1        0        0


z = c( 0, -3*pi, pi, 2*pi, getsegment(zono1) )

invert( zono1, z )
#           z   pcube.1   pcube.2   pcube.3   pcube.4   pcube.5   pcube.6
# 1  0.000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
# 2 -9.424778        NA        NA        NA        NA        NA        NA
# 3  3.141593 1.0000000 0.0000000 0.7138642 0.0000000 0.0000000 0.0000000
# 4  6.283185        NA        NA        NA        NA        NA        NA
# 5 -9.000000 0.0000000 1.0000000 0.0000000 0.0000000 1.0000000 1.0000000
# 6  4.000000 1.0000000 0.0000000 1.0000000 0.0000000 0.0000000 0.0000000
</code></pre>

<hr>
<h2 id='zonotope-getters'>
zonotope get functions
</h2><span id='topic+getmatroid'></span><span id='topic+getcenter'></span><span id='topic+getmatrix.zonotope'></span><span id='topic+getmatroid.zonotope'></span><span id='topic+getcenter.zonotope'></span>

<h3>Description</h3>

<p>get some important members of a zonotope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
getmatrix( x )

## S3 method for class 'zonotope'
getmatroid( x )

## S3 method for class 'zonotope'
getcenter( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonotope-getters_+3A_x">x</code></td>
<td>

<p>a zonotope object -  a <b>zonohedron</b>, a <b>zonogon</b>, or a <b>zonoseg</b>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getmatrix()</code> returns the matrix originally used to construct
the zonotope <code>x</code>.
<br /><br />
<code>getmatroid()</code> returns the matroid (possibly nonsimple)
constructed from the matrix
<br /><br />
<code>getcenter()</code> returns the center of the zonotope;
which is also the center of radial symmetry.
If <code>x</code> is an object-color solid, the center corresponds
to the 50% graypoint.  For the whitepoint multiply by 2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+zonoseg">zonoseg</a>()</code>
</p>

<hr>
<h2 id='zonotope-props'>zonotope properties</h2><span id='topic+is_salient'></span><span id='topic+is_pointed'></span><span id='topic+is_salient.zonotope'></span><span id='topic+is_pointed.zonotope'></span>

<h3>Description</h3>

<p>Get some important boolean properties of a zonotope.
<br /><br />
<em>pointed</em> means that 0 is a vertex of the zonotope.
<em>salient</em> means that 0 is in the boundary of the zonotope.
So pointed implies salient, but not the reverse.
<br /><br />
A zonotope has an associated <em>convex cone</em> - allow the
coefficients of the generators to be any non-negative numbers.
For convex cones, <em>pointed</em> means that the cone
is in an open linear halfspace (except for 0).
And <em>salient</em> means that the cone is in a
closed linear halfspace (the cone may contain a line).
<br /><br />
In terms of generators (of both zonotopes and convex cones),
<em>pointed</em> means that the generators
are in an open linear halfspace (except for 0 generators).
And <em>salient</em> means that the generators
are in a closed linear halfspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zonotope'
is_pointed( x )

## S3 method for class 'zonotope'
is_salient( x )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonotope-props_+3A_x">x</code></td>
<td>

<p>a zonotope object -  a <b>zonohedron</b>, a <b>zonogon</b>, or a <b>zonoseg</b>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <b>zonohedron</b>, if 0 is in the interior of an edge or a facet,
then the zonohdron is salient but not pointed.
<br />
For a <b>zonogon</b>, if 0 is in the interior of an edge,
then the zonogon is salient but not pointed.
<br />
For a <b>zonoseg</b>, both <em>pointed</em> and <em>salient</em> are equivalent
to 0 being a boundary point.
And this is equivalent to all the non-zero generators having
the same sign  (all negative or all positive).
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>References</h3>

<p><b>Zonohedron - Wikipedia</b>.<br />
<a href="https://en.wikipedia.org/wiki/Zonohedron">https://en.wikipedia.org/wiki/Zonohedron</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonohedron">zonohedron</a>()</code>,
<code><a href="#topic+zonogon">zonogon</a>()</code>,
<code><a href="#topic+zonoseg">zonoseg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zono1 = zonoseg( c(1,-2,3,0,-3,-4) )

is_pointed( zono1 )
# [1] FALSE

is_salient( zono1 )
# [1] FALSE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
