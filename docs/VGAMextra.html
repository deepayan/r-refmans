<!DOCTYPE html><html lang="en"><head><title>Help for package VGAMextra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VGAMextra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#VGAMextra-package'>
<p>Additions and extensions of the VGAM package.</p></a></li>
<li><a href='#ap.mx'><p>Air pollution Data, Mexico City.</p></a></li>
<li><a href='#ARIMAX.errors.ff'><p> VGLTSMs Family Functions:</p>
Generalized integrated regression
with order&ndash;<code class="reqn">(p, q)</code> ARMA errors</a></li>
<li><a href='#ARIMAXff'><p> VGLTSMs Family functions:</p>
The Order&ndash;<code class="reqn">(p, d, q)</code> Autoregressive Integrated Moving
Average Model (ARIMA(p, d, q)) with covariates</a></li>
<li><a href='#ARMA.studentt.ff'><p> VGLTSMs Family Functions:</p>
Generalized autoregressive moving average model
with Student-t errors</a></li>
<li><a href='#ARXff'><p> VGLTSMs family functions: Order&ndash;p Autoregressive Model</p>
with covariates</a></li>
<li><a href='#benini1Qlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter continuous</p>
distributions
</p></a></li>
<li><a href='#borel.tannerMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
discrete distributions: The Borel&ndash;Tanner distribution.
</p></a></li>
<li><a href='#break.VGAMextra'><p> Names/Value of linear predictors/parameters in time series</p>
family functions.</a></li>
<li><a href='#checkTS.VGAMextra'>
<p>Polynomial roots based on <em>transfer operators</em> in Vector</p>
Generalized Time Series Family Functions
</p></a></li>
<li><a href='#cm.ARMA'><p> Constraint matrices for vector generalized time series</p>
family functions.</a></li>
<li><a href='#dmultinorm'><p>Density for the multivariate Normal distribution</p></a></li>
<li><a href='#ECM.EngleGran'><p> VGLTSM family function for the</p>
Two&ndash;dimensional Error&ndash;Correction Model
(Engle and Granger, 1987) for <code class="reqn">I(1)</code>&ndash;variables</a></li>
<li><a href='#expMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
continuous distributions: The exponential distribution.
</p></a></li>
<li><a href='#expQlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter</p>
continuous distributions.
</p></a></li>
<li><a href='#gamma1Qlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter continuous</p>
distributions
</p></a></li>
<li><a href='#gammaRff'>
<p>2&ndash;parameter Gamma Distribution</p>
</p></a></li>
<li><a href='#gammaRMlink'>
<p>Link functions for the mean of 2&ndash;parameter</p>
continuous distributions: The gamma distribution.
</p></a></li>
<li><a href='#gen.betaIImr'><p> Generalized Beta Distribution of the Second Kind family function</p></a></li>
<li><a href='#genbetaIIDist'><p>The Generalized Beta Distribution of the Second King</p></a></li>
<li><a href='#geometricffMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
discrete distributions: The Geometric Distribution.
</p></a></li>
<li><a href='#HKdata'><p>Air pollution and hospital admissions due to respiratory and</p>
cardiovascular causes, Hong Kong.</a></li>
<li><a href='#inv.chisqDist'>
<p>The Inverse Chi&ndash;squared Distribution</p></a></li>
<li><a href='#inv.chisqff'>
<p>Inverse Chi&ndash;squared Distribution.</p>
</p></a></li>
<li><a href='#inv.chisqMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
continuous distributions: The inverse chi&ndash;squared distribution.
</p></a></li>
<li><a href='#invgamma2mr'><p> 2 - parameter Inverse Gamma Distribution</p></a></li>
<li><a href='#invgammaDist'><p>The Inverse Gamma Distribution</p></a></li>
<li><a href='#invweibull2mr'><p> 2- parameter Inverse Weibull Distribution</p></a></li>
<li><a href='#invweibullDist'><p>The Inverse Weibull Distribution</p></a></li>
<li><a href='#KPSS.test'><p>KPSS tests for stationarity</p></a></li>
<li><a href='#logffMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
discrete distributions: The Logarithmic Distribuion.
</p></a></li>
<li><a href='#MAXff'><p>VGLTSMs</p>
Family Functions: Order&ndash;q Moving Average Model with covariates</a></li>
<li><a href='#maxwellQlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter continuous</p>
distributions
</p></a></li>
<li><a href='#MVNcov'><p> Multivariate Normal Distribution Family Function</p></a></li>
<li><a href='#newtonRaphson.basic'>
<p>Newton&ndash;Raphson algorithm</p>
</p></a></li>
<li><a href='#normal1sdff'>
<p>Estimation and Inference for Conditional Quantiles of</p>
a 1&ndash;parameter Univariate Normal Distribution.
</p></a></li>
<li><a href='#normal1sdQlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter continuous</p>
distributions.
</p></a></li>
<li><a href='#notDocumentedYetVGAMextra'>
<p>Not-documented functions and classes in <span class="pkg">VGAMextra</span></p></a></li>
<li><a href='#posPoiMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
discrete distributions: The Positive Poisson Distribution.
</p></a></li>
<li><a href='#Q.reg'>

<p>Conditional quantile regression with <span class="pkg">VGAM</span></p>
</a></li>
<li><a href='#rayleighMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
continuous distributions: The Rayleigh and
the Maxwell distributions.
</p></a></li>
<li><a href='#rayleighQlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter continuous</p>
distributions
</p></a></li>
<li><a href='#summaryS4VGAMextra-methods'><p>Summary methods for Vector Generalized Time Series Models</p>
</p></a></li>
<li><a href='#toppleMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
continuous distribution: The Topp&ndash;Leone distribution.
</p></a></li>
<li><a href='#toppleQlink'>
<p>Link functions for the quantiles of several 1&ndash;parameter continuous</p>
distributions
</p></a></li>
<li><a href='#trinormalCovff'><p> Trivariate Normal Distribution Family Function</p></a></li>
<li><a href='#trunclognormal'>
<p>Truncated Log-normal Distribution Family Function</p></a></li>
<li><a href='#truncLognormal'><p>The Truncated Log-Normal Distribution</p></a></li>
<li><a href='#truncnormal'>
<p>Truncated normal Distribution Family Function</p></a></li>
<li><a href='#truncNormal'><p>The Truncated Normal Distribution</p></a></li>
<li><a href='#undocumented-methods'><p> Undocumented Methods Functions in <span class="pkg">VGAMextra</span></p></a></li>
<li><a href='#uninormalff'>
<p>Normal (distribution&ndash;specified) quantile regression</p>
</p></a></li>
<li><a href='#uninormalQlink'>
<p>Quantile regression:</p>
Link function for the quantiles of the normal distribution.
</p></a></li>
<li><a href='#UtilitiesVGAMextra'><p> Utility Functions for the <span class="pkg">VGAMextra</span> Package</p></a></li>
<li><a href='#VARff'><p> VGLTSM family function for the</p>
Order&ndash;<code class="reqn">p</code> Vector Auto(R)egressive Model</a></li>
<li><a href='#vgltsmff'><p>Class of Vector Generalized Linear Time Series Models</p></a></li>
<li><a href='#weibullMlink'>
<p>Link functions for the mean of 2&ndash;parameter</p>
continuous distributions: The Weibull distribution.
</p></a></li>
<li><a href='#weibullQlink'>
<p>Weibull Quantile regression:</p>
Link function for the quantiles of the Weibull distribution.
</p></a></li>
<li><a href='#weibullRff'>
<p>Distribution&ndash;specified quantile regression:</p>
2&ndash;parameter Weibull Distribution
</p></a></li>
<li><a href='#WN.InitARMA'><p>Estimated White Noise (WN) from the autoregressive moving-average model</p>
of order-(<code class="reqn">p</code>, <code class="reqn">q</code>) [ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>)].
</p></a></li>
<li><a href='#yulesimonMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
discrete distributions: The Yule&ndash;Simon Distribution.
</p></a></li>
<li><a href='#zetaffMlink'>
<p>Link functions for the mean of 1&ndash;parameter</p>
discrete distributions: The Zeta Distribution.
</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.0-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Additions and Extensions of the 'VGAM' Package</td>
</tr>
<tr>
<td>Author:</td>
<td>Victor Miranda [aut, cre, cph],
  Thomas Yee [ctb, ths, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Victor Miranda &lt;victor.miranda@aut.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods, stats, stats4, VGAM(&ge; 1.1-1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>VGAMdata</td>
</tr>
<tr>
<td>Description:</td>
<td>Extending the functionalities of the 'VGAM' package with
         additional functions and datasets. At present, 'VGAMextra'
         comprises new family functions (ffs) to estimate several time
         series models by maximum likelihood using Fisher scoring, 
         unlike popular packages in CRAN relying on optim(), including
         ARMA-GARCH-like models, the Order-(p, d, q) ARIMAX model (non-
         seasonal), the Order-(p) VAR model, error correction models
         for cointegrated time series, and ARMA-structures with Student-t 
         errors. For independent data, new ffs to estimate the inverse-
         Weibull, the inverse-gamma, the generalized beta of the second
         kind and the general multivariate normal distributions are
         available. In addition, 'VGAMextra' incorporates new VGLM-links
         for the mean-function, and the quantile-function (as an alternative
         to ordinary quantile modelling) of several 1-parameter distributions,
         that are compatible with the class of VGLM/VGAM family functions.
         Currently, only fixed-effects models are implemented. All functions
         are subject to change; see the NEWS for further details on the
         latest changes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 02:25:52 UTC; vico</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 11:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='VGAMextra-package'>
Additions and extensions of the VGAM package.
</h2><span id='topic+VGAMextra-package'></span><span id='topic+VGAMextra'></span>

<h3>Description</h3>

<p><span class="pkg">VGAMextra</span> supplies additional functions and methods
to the package <span class="pkg">VGAM</span>, under three main topics:
</p>
<p>** <em>Time series modelling</em>. A novel class 
of VGLMs to model univariate time series, called
<em>vector generalized linear time series models</em>
(VGLTSMs). It is
characterized by incorporating
<em>past information</em> in the VGLM/VGAM loglikelihood.
</p>
<p>** <em>1&ndash;parameter distribution mean modelling</em>.
We return full circle by developing new link functions for the
mean of 1&ndash;parameter distributions. VGAMs, VGLMs and GAMLSSs are
restricted to location, scale and shape, however, the
VGLM/VGAM framework has infrastructure to accommodate
new links as a function of the parameters.
</p>
<p>** <em>Quantile modelling of 1&ndash;parameter distributions</em>.
Similarly, we have implemented link functions to model
the quantiles of several 1&ndash;parameter distributions, for
<em>quantile regression</em>.

</p>


<h3>Details</h3>

<p>The inference infrastructure of <span class="pkg">VGAMextra</span> relies on the
VGLM/VGAM framework. Particularly, estimation is carried out via
IRLS using Fisher scoring, whilst additive models and reduced
rank regression are also
accommodated by all <span class="pkg">VGAMextra</span> family functions.
</p>
<p>At present, this package
allows the extent of VGLMs/VGAMs to operate
popular time series models as special cases, as well as
cointegrated time series (bivariate case), and 
modelling choices for volatility models incorporating
explanatories in the variance equation.
The central family functions in this respect are
<code><a href="#topic+ARXff">ARXff</a></code>,
<code><a href="#topic+MAXff">MAXff</a></code>,
<code><a href="#topic+ARMAX.GARCHff">ARMAX.GARCHff</a></code>, and
<code><a href="#topic+VGLM.INGARCHff">VGLM.INGARCHff</a></code>.
</p>
<p>Regarding modelling the mean/quantile-functions, <span class="pkg">VGAMextra</span>
affords links for several 1-parameter distributions,
e.g., <code><a href="#topic+expMlink">expMlink</a></code>,
<code><a href="#topic+benini1Qlink">benini1Qlink</a></code>, or
<code><a href="#topic+inv.chisqMlink">inv.chisqMlink</a></code>.
Collectively, the quantile-links represent an alternative
to quantile regression by directly modelling the quantile
function for distributions
beyond the exponential family (See Example 3 below).
</p>
<p>The VGLM/VGAM framework is very large and encompasses a wide range of
multivariate response types and models, e.g., it includes
univariate and multivariate distributions,
categorical data analysis, and extreme values.
See <code><a href="VGAM.html#topic+VGAM-package">VGAM-package</a></code> for a broad
description and further information on <span class="pkg">VGAM</span>.
</p>


<h3>Future work</h3>

<p>* Implement VGLM time series family functions to handle
error correction models (ECMs) for cointegrated time series.
Upgrade this framework beyond the bivariate case, e.g., the
the Vector ECM (VECMs).
</p>
<p>* Upgrade VGLMs time series family functions to handle
multivariate time series, e.g., the VAR model (Coming shortly).
</p>
<p>* Incorporate VGLM/VGAM-links to model the
mean and quantile functions of distributions with &gt; 1 parameters.
</p>
<p>* Develop the class of <em>multiple</em> reduced&ndash;rank 
VGLMs towards time series, to handle, e.g.,
vector error correction models (VECMs),
for multiple cointegrated time series.
</p>


<h3>Warning</h3>

<p><span class="pkg">VGAMextra</span> is revised, altered, and/or upgraded on a regular basis.
Hence, be aware that any feature, e.g., function names, arguments, or
methods, may be modified without prior notice.
Check the <code>NEWS</code> for the latest changes and additions across
the different versions.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda, <a href="mailto:victor.miranda@aut.ac.nz">victor.miranda@aut.ac.nz</a>.
</p>
<p>Maintainer: Victor Miranda, <a href="mailto:victor.miranda@aut.ac.nz">victor.miranda@aut.ac.nz</a>.
</p>
<p>Contributor: Thomas Yee, <a href="mailto:t.yee@auckland.ac.nz">t.yee@auckland.ac.nz</a>.
</p>


<h3>References</h3>

<p>Pfaff, B. (2011)
Analysis of Integrated and Cointegrated Time Series with R.
Seattle, Washington, USA: <em>Springer</em>.
</p>
<p>Chan, N., Li, D., Peng, L. and Zhang, R. (2013)
Tail index of an AR(1) model with ARCH(1) errors.
<em>Econometric Theory</em>, 29(5):920-940.
</p>
<p>Yee, T. W. (2015)
Vector Generalized Linear and Additive Models:
With an Implementation in R.
New York, USA: <em>Springer</em>.
</p>
<p>Miranda, V. and Yee, T. W.
<em>Vector generalized linear time series models.</em>
In preparation.
</p>
<p>Miranda, V. and Yee, T. W.
<em>On mean modelling of 1-parameter distributions using vector
generalized linear models</em>. In preparation
</p>
<p>Miranda, V. and Yee, T. W.
<em>Two&ndash;Parameter Link Functions with Applications to
Negative Binomail, Weibull, and Quantile 
Regression</em>. To be submitted to the 
Scandinavian Journal of Statistics.
</p>
<p>Miranda, V. and Yee, T.W.
<em>New Link Functions for Distribution-Specific Quantile
Regression Based on Vector Generalized Linear and Additive
Models</em>.  
Journal of Probability and Statistics,
Volume 2019, Article ID 3493628.
</p>
<p>Yee, T. W. (2008)
The <code>VGAM</code> Package.
<em>R News</em>, <b>8</b>, 28&ndash;39.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+vglm">vglm</a></code>,
<code><a href="VGAM.html#topic+vgam">vgam</a></code>,
<code><a href="VGAM.html#topic+rrvglm">rrvglm</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<a href="https://www.stat.auckland.ac.nz/~vmir178/">https://www.stat.auckland.ac.nz/~vmir178/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### EXAMPLE 1. An AR(1) model with ARCH(1) errors.
# Chan et.al. (2013) proposed a long and technical methodology to
# estimate the tail index of an AR(1) with ARCH(1) errors involving 
# its estimation by QMLE. I fit this model straightforwardly by MLE
# using the family function ARXff() for time series, and constraining
# the effect of Y^2_{t - 1} to the conditional variance using
# constraint matrices.


# Generate some data
set.seed(1)
nn       &lt;- ceiling(runif(1, 150, 160))
my.rho   &lt;- rhobitlink(-1.0, inverse = TRUE)  # -0.46212
my.mu    &lt;- 0.0
my.omega &lt;- 1
my.b     &lt;- 0.5
tsdata   &lt;- data.frame(x2 =  sort(runif(n = nn)))
tsdata   &lt;- transform(tsdata, index = 1:nn, TS1   = runif(nn))

for (ii in 2:nn)
  tsdata$TS1[ii] &lt;- my.mu + my.rho * tsdata$TS1[ii-1] +
  sqrt(my.omega + my.b * (tsdata$TS1[ii-1])^2) * rnorm(1)
  
# Remove the burn-in data:
nnr &lt;- ceiling(nn/5)
tsdata &lt;- tsdata[-(1:nnr), ]
tsdata["index"] &lt;- 1:(nn - nnr)


# The timeplot.
with(tsdata, plot(ts(TS1), lty = "solid", col = "blue", xlab ="Time", ylab = "Series"))
abline(h = mean(tsdata[, "TS1"]), lty = "dotted")

# The constraint matrices, to inhibit the effect of Y^2_{t - 1}
# over sigma^2 only.
const.mat &lt;- list('(Intercept)' = diag(3), 'TS1l1sq' = cbind(c(0, 1, 0)))

# Set up the data using function WN.lags() from VGAMextra to generate
# our 'explanatory'
tsdata &lt;- transform(tsdata, TS1l1sq = WN.lags(y = cbind(tsdata[, "TS1"])^2, lags = 1))

# Fitting the model
fit.Chan.etal &lt;- vglm(TS1 ~ TS1l1sq, ARXff(order = 1,   # AR order 
                                          zero = NULL, noChecks = FALSE,
                                          var.arg = TRUE, lvar = "identitylink"),
             crit = "loglikelihood", trace = TRUE,
             constraints = const.mat, data = tsdata)  ## Constraints...
summary(fit.Chan.etal, lrt0 = TRUE, score0 = TRUE, wald0 = TRUE)
constraints(fit.Chan.etal)


###### EXAMPLE 2. VGLMs handling cointegrated (bivariate) time series.
# In this example, vglm() accommodates an error correction model
# of order (2, 2) to fit two (non-stationary) cointegrated time series.

# Simulating some data.
set.seed(2017081901)
nn &lt;- 280
rho &lt;- 0.75
s2u &lt;- exp(log(1.5))  # Gaussian noise1
s2w &lt;- exp(0)         # Gaussian noise2
my.errors &lt;- rbinorm(nn, mean1 = 0, mean2 = 0, var1 = s2u, var2 = s2w, cov12 = rho)
ut &lt;- my.errors[, 1]
wt &lt;- my.errors[, 2]
yt &lt;- xt &lt;- numeric(0)

xt[1] &lt;- ut[1]     # Initial value: error.u[0]
yt[1] &lt;- wt[1]     # Initial value: error.w[0]
beta &lt;- c(0.0, 2.5, -0.32)  # Coefficients true values.

for (ii in 2:nn) {
  xt[ii] &lt;-  xt[ii - 1] + ut[ii]
  yt[ii] &lt;- beta[1] + beta[2] * xt[ii]  + beta[3] * yt[ii - 1] + wt[ii]
}

# Regression of yt on xt, save residuals. Compute Order--1 differences.
errors.coint &lt;- residuals(lm(yt ~ xt)) # Residuals from the static regression yt ~ xt
difx1 &lt;- diff(ts(xt), lag = 1, differences = 1)  # First difference for xt
dify1 &lt;- diff(ts(yt), lag = 1, differences = 1)  # First difference for yt

# Set up the dataset (coint.data), including Order-2 lagged differences.
coint.data &lt;- data.frame(embed(difx1, 3), embed(dify1, 3)) 
colnames(coint.data) &lt;- c("difx1", "difxLag1", "difxLag2",
                          "dify1", "difyLag1", "difyLag2")

# Remove unutilized lagged errors accordingly. Here, use from t = 3.
errors.cointLag1 &lt;- errors.coint[-c(1:2, nn)]
coint.data &lt;- transform(coint.data, errors.cointLag1 = errors.cointLag1)


# Plotting the data
plot(ts(yt[-c(1:3, NULL)]), lty = 4, type = "l", col = "red",
     main = "", xlab = "Time", las = 1, ylim = c(-32, 20),
     ylab = expression("Series"~x[t]~"and"~y[t]))
lines(ts(xt[-c(1:3, NULL)]), lty = 4, type = "l", col = "blue")
legend("bottomleft", c(expression("Series"~x[t]),
                       expression("Series"~y[t])),
       col = c("red", "blue"), lty = c(4, 4))


# Fitting an error correction model (2, 2), aka ECM(2, 2)
fit.coint &lt;- vglm(cbind(dify1, difx1) ~ errors.cointLag1 + difxLag1 + difyLag1 + 
                                           difxLag2 + difyLag2,
          binormal(zero = c("sd", "rho")),  # 'sigma', 'rho' are intercept--only.
          trace = FALSE, data = coint.data)
summary(fit.coint)
coef(fit.coint, matrix = TRUE)


##### EXAMPLE 3. Quantile Modelling (QM).
# Here, the quantile function of the Maxwell distribution is modelled
# for percentiles 25%, 50% and 75%. The resulting quantile-curves
# are plotted. The rate parameter is determined by an artificial covariate.

set.seed(123)
# An artificial covariate.
maxdata &lt;- data.frame(x2 = sort(runif(n &lt;- nn &lt;- 120)))
# The 'rate' function.
mymu &lt;- function(x) exp(2 -  6 * sin(2 * x - 0.2) / (x + 0.5)^2)
# Set up the data.
maxdata &lt;- transform(maxdata, y = rmaxwell(n, rate = mymu(x2)))

# 25%, 50% and 75% quantiles are to be modelled.
mytau &lt;- c(0.25, 0.50, 0.75)
mydof &lt;- 4

### Using B-splines with 'mydof'-degrees of freedom on the predictors
fit.QM &lt;- vglm(Q.reg(y, pvector = mytau) ~ bs(x2, df = mydof),
                 family = maxwell(link = "maxwellQlink(p = mytau)", 
                 zero = NULL),
                 data = maxdata, trace = TRUE)
            
summary(fit.QM, lscore0 = TRUE)
head(predictors(fit.QM))         # The 'fitted values'


## The 25%, 50%, and 75% quantile curves.
mylwd &lt;- 1.5
with(maxdata, plot(x2, y, col = "orange",
                 main = "Example 1; Quantile Modelling",
                 ylab = "y", pch = "o", cex = 0.75))
with(maxdata, matlines(x2, predict(fit.QM)[, 1], col = "blue",
                       lty = "dotted", lwd = mylwd))
with(maxdata, matlines(x2, predict(fit.QM)[, 2], col = "chocolate",
                       lty = "dotted", lwd = mylwd))
with(maxdata, matlines(x2, predict(fit.QM)[, 3], col = "brown",
                       lty = "dotted", lwd = mylwd))
legend("topleft", c("percentile25", "percentile50", "percentile75"),
       lty = rep("dotted", 3), lwd = rep(mylwd, 3))


### Double check: The data (in percentage) below the 25%, 50%, and 75% curves
round(length(predict(fit.QM)[, 1][(maxdata$y
                 &lt;= predict(fit.QM)[, 1] )]) /nn, 5) * 100  ## Should be 25% approx
round(length(predict(fit.QM)[, 2][(maxdata$y
                 &lt;= predict(fit.QM)[, 2] )]) /nn, 5) * 100  ## Should be 50% approx
round(length(predict(fit.QM)[, 3][(maxdata$y
                 &lt;= predict(fit.QM)[, 3] )]) /nn, 5) * 100  ## Should be 75% approx
</code></pre>

<hr>
<h2 id='ap.mx'>Air pollution Data, Mexico City.</h2><span id='topic+ap.mx'></span>

<h3>Description</h3>

<p>Daily air pollution levels in Mexico City, January 2004 &ndash; June 2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ap.mx)</code></pre>


<h3>Format</h3>

<p>This data frame stores time series vectors with the
following information:
</p>

<dl>
<dt>time</dt><dd>
<p>Time vector.
</p>
</dd>
<dt>PM10</dt><dd>
<p>24&ndash;hr average concentration of
<code class="reqn">PM_{10}</code>, in micrograms per milliliter.
</p>
</dd>
<dt>O3</dt><dd>
<p>Daily maximum 8&ndash;hour moving average
of ozone, in micrograms per milliliter.
</p>
</dd>
<dt>temp</dt><dd>
<p>Daily mean average of temperature, in celsius degrees.
</p>
</dd>
<dt>HR</dt><dd>
<p>Daily mean average (%) of relative humidity.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These are readings of <code class="reqn">PM_{10}</code>,
<code class="reqn">O_{3}</code>, temperature and humidity between
1 January 2004 and 30 June 2005 in 
Mexico City Metropolitan Area.
Each observation is the 24&ndash;hr mean average (between
00:00 and 23:59 hrs), except for
ozone, where the
maximum over all the sliding 8&ndash;hour&ndash;windows,
between 00:00 and 23:59 hrs is reported, viz.
the daily maximum 8&ndash;hour moving average.
</p>


<h3>Source</h3>

<p>National Institute of Ecology.
Gathers and disseminates the data generated 
by the central air quality monitoring network
in Mexico City. Website:
https://www.gob.mx/inecc/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ap.mx)
summary(ap.mx[, -1])
class(ap.mx[, "PM10"])

layout(matrix(c(1, 1, 2,3), 2, 2, byrow = TRUE))
plot.ts(ts(ap.mx$PM10), ylab = expression(PM[10]~"Series"), 
        col = "brown", xaxt = "n", las = 1)
xtick &lt;- c(1, 92, 183, 275, 367, 457, 518)
xtext &lt;- c("Jan/04", "April/04", "July/04", "Oct/04", "Jan/05",
           "April/05", "June/05")
axis(side = 1, at = xtick, labels = FALSE)
text(x = xtick, par("usr")[3], labels = xtext,
     pos = 1, xpd = TRUE, col = "black")
pacf(ap.mx$PM10, main = "", ylim= c(-0.5, 1), lag.max = 60, las = 1)
acf(ap.mx$PM10, main = "", ylim= c(-0.5, 1), lag.max = 60, las = 1)

</code></pre>

<hr>
<h2 id='ARIMAX.errors.ff'> VGLTSMs Family Functions:
Generalized integrated regression
with order&ndash;<code class="reqn">(p, q)</code> ARMA errors</h2><span id='topic+ARIMAX.errors.ff'></span>

<h3>Description</h3>

<p>A VLTSMff for dynamic regression.
Estimates regression models with order&ndash;<code class="reqn">(p, d, q)</code> ARIMA
errors by maximum likelihood.


</p>


<h3>Usage</h3>

<pre><code class='language-R'>      ARIMAX.errors.ff(order = c(1, 1, 1),
                       zero = "var",  # optionally, "mean".
                       order.trend = 0,
                       include.int = TRUE,
                       diffCovs  = TRUE,
                       xLag = 0,
                       include.currentX = TRUE,
                       lvar = "loglink",
                       lmean = "identitylink") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARIMAX.errors.ff_+3A_order">order</code></td>
<td>

<p>The usual <code class="reqn">(p, d, q)</code> integer vector as in, e.g., 
<code><a href="#topic+ARIMAXff">ARIMAXff</a></code>. 
By default, an order&ndash;<code class="reqn">(p, q)</code> ARMA model is 
fitted on the errors, whlist <code class="reqn">d</code> is the 
degree of differencing on the response.
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_zero">zero</code></td>
<td>

<p>What linear predictor is modelled as intercept&ndash;only?
See <code><a href="VGAM.html#topic+zero">zero</a></code> and
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>
for further details.
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_order.trend">order.trend</code></td>
<td>

<p>Non&ndash;negative integer. Allows to incorporate a polynomial
trend of order <code>order.trend</code> in the forecast mean
function. 
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_include.int">include.int</code></td>
<td>

<p>Logical. Should an intercept (int) be included in
the model for <code class="reqn">y_t</code>? Default is
<code>TRUE</code>. See below for details.
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_diffcovs">diffCovs</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default)
the order&ndash;<code>d</code> difference
of the covariates is internally computed and then
incorporated in the regression model. Else, 
only the current values are included.
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_xlag">xLag</code></td>
<td>

<p>Integer. If entered, the covariates, say 
<code class="reqn">\boldsymbol{x}_t</code> are laggeg 
(up to order <code>xLag</code>) and then embedded
in the regression model. 
See below for further details.
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_include.currentx">include.currentX</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the <em>actual</em> values, 
<code class="reqn">\boldsymbol{x}_t</code>, are included in the regression
model. Else, this is ignored and only the lagged
<code class="reqn">\boldsymbol{x}_{t - 1}, \ldots, \boldsymbol{x}_{t - xLag}</code> will be included.
</p>
</td></tr>
<tr><td><code id="ARIMAX.errors.ff_+3A_lvar">lvar</code>, <code id="ARIMAX.errors.ff_+3A_lmean">lmean</code></td>
<td>

<p>Link functions applied to conditional mean and the variance.
Same as <code><a href="VGAM.html#topic+uninormal">uninormal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized linear regression model with ARIMA errors
is another subclass of VGLTSMs (Miranda and Yee, 2018).
</p>
<p>For a univariate time series, say <code class="reqn">y_t</code>,
and a <code class="reqn">p</code>&ndash;dimensional vector of covariates
<code class="reqn">\boldsymbol{x}_t</code> covariates,
the model described by this VGLTSM family function is
</p>
<p style="text-align: center;"><code class="reqn">
 y_t = \boldsymbol{\beta}^T \boldsymbol{x}_t + u_t,
</code>
</p>

<p style="text-align: center;"><code class="reqn">
u_t = \theta_1 u_{t - 1} + \cdots + \theta_p u_{t - p} + z_t +
    \phi_1 z_{t - 1} + \cdots + \phi_1 z_{t - q}.
</code>
</p>

<p>The first entry in <code class="reqn">x_t</code> equals 1, allowing 
an intercept, for every $t$. Set 
<code>include.int = FALSE</code> to set this to zero,
dimissing the intercept.
</p>
<p>Also, if <code>diffCovs = TRUE</code>, then the differences up to order
<code>d</code> of the set
<code class="reqn">\boldsymbol{x}_t</code> are embedded in the model 
for <code class="reqn">y_t</code>.
If <code>xLag</code><code class="reqn">&gt; 0</code>, the lagged values up to order
<code>xLag</code> of the covariates are also included.
</p>
<p>The random disturbances <code class="reqn">z_t</code> are by default
handled as <code class="reqn">N(0, \sigma^2_z)</code>. Then,
denoting <code class="reqn">\Phi_{t}</code> as the history of the
process <code class="reqn">(x_{t + 1}, u_t)</code> up to time <code class="reqn">t</code>, yields
</p>
<p style="text-align: center;"><code class="reqn"> E(y_t | \Phi_{t - 1}) = \boldsymbol{\beta}^T \boldsymbol{x}_t +
\theta_1 u_{t - 1} + \cdots + \theta_p u_{t - p} +
    \phi_1 z_{t - 1} + \cdots + \phi_1 z_{t - q}. </code>
</p>

<p>Denoting <code class="reqn">\mu_t =  E(y_t | \Phi_{t - 1}),</code>
the default linear predictor for this VGLTSM family function is
</p>
<p style="text-align: center;"><code class="reqn"> \boldsymbol{\eta} = ( \mu_t, \log \sigma^2_{z})^T.</code>
</p>



<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>)
to be used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Note</h3>

<p>If <code>d = 0</code> in <code>order</code>, then <code>ARIMAX.errors.ff</code>
will perform as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARIMAXff">ARIMAXff</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Estimate a regression model with ARMA(1, 1) errors.
## Covariates are included up to lag 1.
set.seed(20171123)
nn &lt;- 250
x2 &lt;- rnorm(nn)                                    # One covariate
sigma2 &lt;- exp(1.15); theta1 &lt;- 0.5; phi1 &lt;- 0.27   # True coefficients
beta0  &lt;- 1.25; beta1 &lt;- 0.25; beta2 &lt;- 0.5

y &lt;- numeric(nn)
u &lt;- numeric(nn)
z &lt;- numeric(nn)

u[1] &lt;- rnorm(1)
z[1] &lt;- rnorm(1, 0, sqrt(sigma2))

for(ii in 2:nn) {
  z[ii] &lt;- rnorm(1, 0, sqrt(sigma2))
  u[ii] &lt;- theta1 * u[ii - 1] + phi1 * z[ii - 1] + z[ii]
  y[ii] &lt;- beta0 + beta1 * x2[ii] + beta2 * x2[ii - 1] + u[ii]
}

# Remove warm-up values.
x2 &lt;- x2[-c(1:100)]
y  &lt;- y[-c(1:100)]


plot(ts(y), lty = 2, col = "blue", type = "b")
abline(h = 0, lty = 2)


## Fit the model.
ARIMAX.reg.fit &lt;- vglm(y ~ x2, ARIMAX.errors.ff(order = c(1, 0, 1), xLag = 1),
             data = data.frame(y = y, x2 = x2), trace = TRUE)
coef(ARIMAX.reg.fit, matrix = TRUE)
summary(ARIMAX.reg.fit, HD = FALSE)


# Compare to arima()
# arima() can't handle lagged values of 'x2' by default, but these 
# may entered at argument 'xreg'.
arima(y, order = c(1, 0, 1), xreg = cbind(x2, c(0, x2[-150])))



</code></pre>

<hr>
<h2 id='ARIMAXff'> VGLTSMs Family functions: 
The Order&ndash;<code class="reqn">(p, d, q)</code> Autoregressive Integrated Moving
Average Model (ARIMA(p, d, q)) with covariates</h2><span id='topic+ARIMAXff'></span><span id='topic+ARMAXff'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the drift, 
standard deviation or variance of the random noise,
and coefficients of an autoregressive integrated
moving average process of order-<code class="reqn">(p, d, q)</code>
with covariates by MLE using Fisher scoring.
No seasonal terms handled yet. No seasonal components
handled yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      ARIMAXff(order   = c(1, 1, 0),
               zero     = c("ARcoeff", "MAcoeff"),
               diffCovs = TRUE,
               xLag     = 0,
               include.current = FALSE,
               type.EIM = c("exact", "approximate")[1], 
               var.arg  = TRUE,
               nodrift  = FALSE,
               noChecks = FALSE,
               ldrift   = "identitylink", 
               lsd      = "loglink",
               lvar     = "loglink",
               lARcoeff = "identitylink",
               lMAcoeff = "identitylink", 
               idrift   = NULL,
               isd      = NULL,
               ivar     = NULL,
               iARcoeff = NULL, 
               iMAcoeff = NULL) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARIMAXff_+3A_order">order</code></td>
<td>

<p>Integer vector with three components, 
(<code>p, d, q</code>): The AR order 
(<code>p</code>), the degree of differencing (<code>d</code>),
and the MA order (<code>q</code>).
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_zero">zero</code></td>
<td>

<p>Integer or character&ndash;strings vector. 
Name(s) or position(s) of the parameters/linear predictors
to be modeled as intercept-only. Details at 
<code><a href="VGAM.html#topic+zero">zero</a></code>.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_diffcovs">diffCovs</code></td>
<td>

<p>Logical. The default is <code>diffCovs = TRUE</code>, which means that
the order&ndash;<code>d</code> differences
of the covariates (if entered) are internally computed and then
incorporated in the conditional&ndash;mean model. Otherwise,
only the current <code>actual</code> values of the covariates are included.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_xlag">xLag</code></td>
<td>

<p>Integer, non&ndash;negative. If <code>xLag</code> &gt; 0, the covariates
at <em>current</em> time, <code class="reqn">\boldsymbol{x}_t</code>, plus
the lagged covariates up to order <code>'xLag'</code> are
embedded into the design matrix (as covariates too).
Leave <code>xLag = 0</code> and only the
<em>current</em> value, <code class="reqn">\boldsymbol{x}_t</code>,
will be considered. See more details below.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_include.current">include.current</code></td>
<td>

<p>Logical. Same as 
<code><a href="#topic+ARIMAX.errors.ff">ARIMAX.errors.ff</a></code>.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_type.eim">type.EIM</code></td>
<td>

<p>The type of expected information matrix (EIM) of the ARMA process
to be utilized in Fisher scoring.
<code>type.EIM = "exact"</code> (default)
enables the <em>exact</em> IM (Porat, et.al. 1986),
otherwise the <code>approximate</code> version is utilized.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_var.arg">var.arg</code></td>
<td>

<p>Logical. If <code>FALSE</code> (default), then the standard deviation
of the random noise is estimated. Else, the variance estimate is 
returned.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_nodrift">nodrift</code></td>
<td>

<p>Logical. <code>nodrift = TRUE</code> supresses estimation of the 
intercept (the <em>drift</em> in the ARMA case),
which is set to zero internally.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_nochecks">noChecks</code></td>
<td>

<p>Logical. If <code>FALSE</code> (default), this family function internally
checks <em>stationarity</em> (AR case) and
<em>invertibility</em> (MA case) of the the estimated model.
A <code>warning</code> is correspondingly displayed.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_ldrift">ldrift</code>, <code id="ARIMAXff_+3A_lsd">lsd</code>, <code id="ARIMAXff_+3A_lvar">lvar</code>, <code id="ARIMAXff_+3A_larcoeff">lARcoeff</code>, <code id="ARIMAXff_+3A_lmacoeff">lMAcoeff</code></td>
<td>

<p>Link functions applied to the intercept, 
the random noise standard deviation (or optionally,
the variance), and the coefficients in the 
ARMA&ndash;type conditional&ndash;mean model.
</p>
</td></tr>
<tr><td><code id="ARIMAXff_+3A_idrift">idrift</code>, <code id="ARIMAXff_+3A_isd">isd</code>, <code id="ARIMAXff_+3A_ivar">ivar</code>, <code id="ARIMAXff_+3A_iarcoeff">iARcoeff</code>, <code id="ARIMAXff_+3A_imacoeff">iMAcoeff</code></td>
<td>

<p>Optional initial values for the intercept (drift), noise SD
(or variance), and ARMA coeffcients (a vector of length <code class="reqn">p + q</code>). 
If failure to converge occurs then try different values and monitor 
convergence by using <code>trace = TRUE</code> in the <code>vglm()</code> call.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\boldsymbol{x}_t</code> be a (probably time&ndash;varying) vector of 
suitable covariates. The ARIMAX model handled by <code>ARIMAXff</code> is
</p>
<p style="text-align: center;"><code class="reqn"> \nabla^d Y_t = \mu^{\star} + \boldsymbol{\beta}^T 
              \nabla^d \boldsymbol{x}_t +
             \theta_1 \nabla^d Y_{t - 1} + \cdots +
             \theta_p \nabla^d Y_{t - p} +
             \phi_1 \varepsilon_{t - 1} + \cdots + 
             \phi_q \varepsilon_{t - q} + \varepsilon, </code>
</p>

<p>with <code class="reqn">\nabla^d (\cdot)</code> the operator differencing a
series <code>d</code> times. If <code>diffCovs = TRUE</code>, this function
differencing the covariates <code>d</code> times too. 
</p>
<p>Similarly, <code>ARMAXff</code> manages
</p>
<p style="text-align: center;"><code class="reqn"> \nabla^d Y_t = \mu^{\star} + \boldsymbol{\beta}^T \boldsymbol{x}_t +
             \theta_1 Y_{t - 1} + \cdots + \theta_p Y_{t - p} +
             \phi_1 \varepsilon_{t - 1} + \cdots + 
             \phi_q \varepsilon_{t - q} + \varepsilon, </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">    \varepsilon_{t | \Phi_{t - 1}}
         \sim N(0, \sigma_{\varepsilon_t | \Phi_{t - 1}}^2).</code>
</p>
 
<p>Note, <code class="reqn">\sigma_{\varepsilon | \Phi_{t - 1}}^2</code> is <em>conditional</em> on 
<code class="reqn">\Phi_{t - 1}</code>, 
the information
of the joint process
<code class="reqn">\left(Y_{t - 1}, \boldsymbol{x}_t \right)</code>,
at time <code class="reqn">t</code>, and hence may be 
modelled in terms of <code class="reqn">\boldsymbol{x}_t</code>,
if required.
</p>
<p><code>ARIMAXff()</code> and <code>ARMAXff()</code>
handle <em>multiple responses</em>, thus a
matrix can be used as the response. 
Note, no seasonal terms handled. This feature is to be
incorporated shortly.
</p>
<p>The default linear predictor is
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\eta} = \left( 
\mu, \log \sigma^{2}_{\varepsilon_{t | \Phi_{t - 1}}},
\theta_1, \ldots, \theta_p,
\phi_1, \ldots, \phi_q
\right)^T.</code>
</p>

<p>Other links are also handled. See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
<p>Further choices for the random noise, besides Gaussian, will
be implemented over time.
</p>
<p>As with <code><a href="#topic+ARXff">ARXff</a></code>
and <code><a href="#topic+MAXff">MAXff</a></code>, 
choices for the EIMs are <code>"exact"</code> and <code>"approximate"</code>.
Covariates may be incorporated in the fit for any linear
predictor above. Hence, <code>ARIMAXff</code> supports non&ndash;stationary 
processes (<code class="reqn">\sigma_{\varepsilon_t | \Phi_{t - 1}}^2</code>) may depend on 
<code class="reqn">\boldsymbol{X}_t</code>.
Also, constraint matrices 
on the linear predictors may be
entered through <code><a href="#topic+cm.ARMA">cm.ARMA</a></code> or
using the argument <code>constraints</code>, from
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>
<p>Checks on stationarity and
invertibility on the esitmated process are performed by default.
Set <code>noChecks = TRUE</code> to dismiss this step.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>)
to be used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Warning</h3>

<p><code>zero</code> can be a <b>numeric</b> or a <b>character&ndash;strings</b> 
vector specifying the position(s) or the name(s) of 
the parameter(s) modeled as intercept&ndash;only.
Numeric values can be set as 
usual (See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>).
If names are entered, the parameter names in this 
family function are:
</p>
<p><code>c("drift.mean", "noiseVar" || "noiseSD", "ARcoeff", "MAcoeff")</code>.
</p>
<p>Manually modify this if required.
For simplicity, the second choice is recommended.
</p>


<h3>Note</h3>

<p>No seasonal components handled yet.
</p>
<p>If no covariates, <code class="reqn">\boldsymbol{x}_t</code>,
are incorporated in the analysis,
then <code>ARIMAXff</code> fits an ordinary ARIMA model.
Ditto with <code>ARMAXff</code>.
</p>
<p>If <code>nodrift = TRUE</code>, then the 'drift' is removed from the
vector of parameters and is not estimated.
</p>
<p>By default, an ARMA model of order&ndash;<code class="reqn">c(1, 0)</code> with
order&ndash;1 differences is fitted. When initial
values are entered (<code>isd</code>, <code>iARcoeff</code>, etc.),
they are recycled
according to the number of responses.
</p>
<p>Also, the ARMA coefficients 
are intercept&ndash;only (note, <code>zero = c("ARcoeff", </code>
<code> "MAcoeff")</code>)
This may altered via <code>zero</code>, or by
constraint matrices (See <code><a href="VGAM.html#topic+constraints">constraints</a></code>)
using <code><a href="#topic+cm.ARMA">cm.ARMA</a></code>.
</p>
<p>Checks on stationarity and/or
invertibility can be manually via
<code><a href="#topic+checkTS.VGAMextra">checkTS.VGAMextra</a></code>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and T. W. Yee
</p>


<h3>References</h3>

<p>Miranda, V. and Yee, T.W. (2018)
Vector Generalized Linear Time Series Models.
<em>In preparation</em>.
</p>
<p>Porat, B., and Friedlander, B. (1986)
Computation of the Exact Information Matrix of Gaussian
Time Series with Stationary Random Components.
<em>IEEE Transactions on Acoustics, Speech and Signal
Processing</em>. <b>ASSp-34(1)</b>, 118&ndash;130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARXff">ARXff</a></code>,
<code><a href="#topic+MAXff">MAXff</a></code>,
<code><a href="#topic+checkTS.VGAMextra">checkTS.VGAMextra</a></code>,
<code><a href="#topic+cm.ARMA">cm.ARMA</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+constraints">constraints</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3)
nn      &lt;- 90
theta   &lt;- c(0.12, 0.17)  # AR coefficients
phi     &lt;- c(-0.15, 0.20)  # MA coefficients.
sdWNN &lt;- exp(1.0)          # SDs
mu    &lt;- c(1.25, 0.85)     # Mean (not drift) of the process.
covX  &lt;- runif(nn + 1)     # A single covariate.
mux3  &lt;- mu[1] + covX
##
## Simulate ARMA processes. Here, the drift for 'tsd3' depends on covX.
##
tsdata &lt;- data.frame(TS1 = mu[1] + arima.sim(model = list(ar = theta, ma = phi,
                             order = c(2, 1, 2)), n = nn, sd = sdWNN ),
                      TS2 = mu[2] + arima.sim(model = list(ar = theta, ma = phi,
                            order = c(2, 1, 2)), n = nn, sd = exp(2 + covX)),
                      TS3 =  mux3 + arima.sim(model = list(ar = theta, ma = phi,
                            order = c(2, 1, 2)), n = nn, sd = exp(2 + covX) ),
                      x2 = covX)

### EXAMPLE 1. Fitting a simple ARIMA(2, 1, 2) using vglm(). 
# Note that no covariates involved. 
fit.ARIMA1 &lt;-  vglm(TS1 ~ 1, ARIMAXff(order = c(2, 1, 2), var.arg = FALSE,
                       # OPTIONAL INITIAL VALUES
                       # idrift = c(1.5)*(1 - sum(theta)), 
                       # ivar = exp(4), isd = exp(2),
                       # iARcoeff = c(0.20, -0.3, 0.1),
                       # iMAcoeff = c(0.25, 0.35, 0.1),
                        type.EIM = "exact"), 
                 data = tsdata, trace = TRUE, crit = "log")
Coef(fit.ARIMA1)
summary(fit.ARIMA1)
vcov(fit.ARIMA1, untransform = TRUE)
#------------------------------------------------------------------------#
# Fitting same model using arima().
#------------------------------------------------------------------------#
# COMPARE to EXAMPLE1 
( fitArima  &lt;- arima(tsdata$TS1, order = c(2, 1, 2)) ) 


### EXAMPLE 2. Here only the ARMA coefficients and drift are intercept-only.
# The random noise variance is not constant.
fit.ARIMA2 &lt;-  vglm(TS2 ~ x2,  ARIMAXff(order = c(2, 1, 2), var.arg = TRUE,
                     lARcoeff = "rhobitlink", lMAcoeff = "identitylink",
                     type.EIM = c("exact", "approximate")[1], 
                     # NOTE THE ZERO ARGUMENT. 
                     zero = c("drift.mean", "ARcoeff", "MAcoeff")),
              data = tsdata, trace = TRUE)

coef(fit.ARIMA2, matrix = TRUE)
summary(fit.ARIMA2)
constraints(fit.ARIMA2)



### EXAMPLE 3. Here only ARMA coefficients are intercept-only.
# The random noise variance is not constant.
# Note that the "drift" and the "variance" are "generated" in 
# terms of 'x2' above for TS3.

fit.ARIMA3 &lt;- vglm(TS3 ~ x2,  ARIMAXff(order = c(1, 1, 2), var.arg = TRUE,
                     lARcoeff = "identitylink", lMAcoeff = "identitylink",
                     type.EIM = c("exact", "approximate")[1], nodrift = FALSE,
                     zero = c( "ARcoeff", "MAcoeff")), # NOTE THE ZERO ARGUMENT. 
              data = tsdata, trace = TRUE)
              
coef(fit.ARIMA3, matrix = TRUE)
summary(fit.ARIMA3)
constraints(fit.ARIMA3)

</code></pre>

<hr>
<h2 id='ARMA.studentt.ff'> VGLTSMs Family Functions:
Generalized autoregressive moving average model
with Student-t errors</h2><span id='topic+ARMA.studentt.ff'></span>

<h3>Description</h3>

<p>For an ARMA model, estimates a 3&ndash;parameter
Student-<code class="reqn">t</code> distribution characterizing the errors
plus the ARMA coefficients by MLE usign Fisher 
scoring. Central Student&ndash;t handled currently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>            ARMA.studentt.ff(order = c(1, 0),
                             zero = c("scale", "df"),
                             cov.Reg = FALSE,
                             llocation = "identitylink",
                             lscale    = "loglink",
                             ldf       = "logloglink",
                             ilocation = NULL,
                             iscale = NULL,
                             idf = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARMA.studentt.ff_+3A_order">order</code></td>
<td>

<p>Two&ndash;entries vector, non&ndash;negative. 
The order $u$ and $v$ of the ARMA model.
</p>
</td></tr>
<tr><td><code id="ARMA.studentt.ff_+3A_zero">zero</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+studentt3">studentt3</a></code>.
</p>
</td></tr>
<tr><td><code id="ARMA.studentt.ff_+3A_cov.reg">cov.Reg</code></td>
<td>

<p>Logical. If covariates are entered, Should these be
included in the ARMA model as a <code>Reg</code>ressand? Default is FALSE,
then only embedded in the linear predictors.
</p>
</td></tr>
<tr><td><code id="ARMA.studentt.ff_+3A_llocation">llocation</code>, <code id="ARMA.studentt.ff_+3A_lscale">lscale</code>, <code id="ARMA.studentt.ff_+3A_ldf">ldf</code>, <code id="ARMA.studentt.ff_+3A_ilocation">ilocation</code>, <code id="ARMA.studentt.ff_+3A_iscale">iscale</code>, <code id="ARMA.studentt.ff_+3A_idf">idf</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+studentt3">studentt3</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normality assumption for time series analysis is relaxed to handle
heavy&ndash;tailed data, giving place to the ARMA model with shift-scaled
Student-<code class="reqn">t</code> errors, another subclass of VGLTSMs. 
</p>
<p>For a univariate time series, say <code class="reqn">y_t</code>,
the model described by this VGLTSM family function is
</p>
<p style="text-align: center;"><code class="reqn">
 \theta(B)y_t = \phi(B) \varepsilon_t,
</code>
</p>

<p>where <code class="reqn">\varepsilon_t</code> are distributed as 
a shift-scaled Student&ndash;<code class="reqn">t</code>
with <code class="reqn">\nu</code> degrees of freedom, i.e.,
<code class="reqn">\varepsilon_t \sim t(\nu_t, \mu_t, \sigma_t)</code>.
This family functions estimates the location (<code class="reqn">\mu_t</code>),
scale (<code class="reqn">\sigma_t</code>) and degrees of freedom (<code class="reqn">\nu_t</code>)
parameters, plus the ARMA coefficients by MLE.
</p>
<p>Currently only centered Student&ndash;t distributions are handled.
Hence, the non&ndash;centrality parameter is set to zero.
</p>
<p>The linear/additive predictors are
<code class="reqn">\boldsymbol{\eta} = (\mu, \log \sigma, \log \log \nu)^T,</code>
where <code class="reqn">\log \sigma</code> and <code class="reqn">\nu</code> are intercept&ndash;only
by default.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>)
to be used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Note</h3>

<p>If <code>order = 0</code>, then <code>AR.studentt.ff</code>
fits a usual 3&ndash;parameter Student&ndash;<code class="reqn">t</code>, as with
<code><a href="VGAM.html#topic+studentt3">studentt3</a></code>.
</p>
<p>If covariates are incorporated in the analysis,
these are embedded in the location&ndash;parameter model.
Modify this through <code>zero</code>.
See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> 
for details on <code>zero</code>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARIMAXff">ARIMAXff</a></code>,
<code><a href="VGAM.html#topic+studentt">studentt</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Estimate the parameters of the errors distribution for an
## AR(1) model. Sample size = 50

set.seed(20180218)
nn &lt;- 250
y  &lt;- numeric(nn)
ncp   &lt;- 0           # Non--centrality parameter
nu    &lt;- 3.5         # Degrees of freedom.
theta &lt;- 0.45        # AR coefficient
res &lt;- numeric(250)  # Vector of residuals.

y[1] &lt;- rt(1, df = nu, ncp = ncp)
for (ii in 2:nn) {
  res[ii] &lt;- rt(1, df = nu, ncp = ncp)
  y[ii] &lt;- theta * y[ii - 1] + res[ii]
}
# Remove warm up values.
y &lt;- y[-c(1:200)]
res &lt;- res[-c(1:200)]

### Fitting an ARMA(1, 0) with Student-t errors.
AR.stut.er.fit &lt;- vglm(y ~ 1, ARMA.studentt.ff(order = c(1, 0)),
                       data = data.frame(y = y), trace = TRUE)

summary(AR.stut.er.fit)
Coef(AR.stut.er.fit)


plot(ts(y), col = "red", lty = 1, ylim = c(-6, 6), main = "Plot of series Y with Student-t errors")
lines(ts(fitted.values(AR.stut.er.fit)), col = "blue", lty = 2)
abline( h = 0, lty = 2)




</code></pre>

<hr>
<h2 id='ARXff'> VGLTSMs family functions: Order&ndash;p Autoregressive Model 
with covariates</h2><span id='topic+ARXff'></span><span id='topic+AR1'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the order&ndash;p autoregressive model
(AR(p)) with covariates.
Estimates the drift, standard deviation (or variance) of the 
random noise (not necessarily constant),
and coefficients of the conditional&ndash;mean model.


</p>


<h3>Usage</h3>

<pre><code class='language-R'>      ARXff(order    = 1,
            zero     = c(if (nodrift) NULL else "ARdrift", "ARcoeff"),
            xLag     = 0,
            type.EIM = c("exact", "approximate")[1],
            var.arg  = TRUE, 
            nodrift  = FALSE,
            noChecks = FALSE,
            ldrift   = "identitylink", 
            lsd      = "loglink",
            lvar     = "loglink",
            lARcoeff = "identitylink",
            idrift   = NULL,
            isd      = NULL,
            ivar     = NULL,
            iARcoeff = NULL)     
           
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARXff_+3A_order">order</code></td>
<td>

<p>The order (i.e., 'p') of the AR model, which is recycled if needed.
See below for further details.
By default, an autoregressive model of order-<code class="reqn">1</code> is fitted.


</p>
</td></tr>
<tr><td><code id="ARXff_+3A_zero">zero</code></td>
<td>

<p>Integer or character&ndash;strings vector. 
Name(s) or position(s) of the parameters/linear predictors
to be modeled as intercept-only. Details at 
<code><a href="VGAM.html#topic+zero">zero</a></code>.
</p>
</td></tr>
<tr><td><code id="ARXff_+3A_xlag">xLag</code></td>
<td>

<p>Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
</td></tr>  
<tr><td><code id="ARXff_+3A_type.eim">type.EIM</code>, <code id="ARXff_+3A_var.arg">var.arg</code>, <code id="ARXff_+3A_nodrift">nodrift</code>, <code id="ARXff_+3A_nochecks">noChecks</code></td>
<td>

<p>Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
</td></tr>
<tr><td><code id="ARXff_+3A_ldrift">ldrift</code>, <code id="ARXff_+3A_lsd">lsd</code>, <code id="ARXff_+3A_lvar">lvar</code>, <code id="ARXff_+3A_larcoeff">lARcoeff</code></td>
<td>

<p>Link functions applied to the <em>drift</em>,
the standar deviation (or variance) of the noise, and the
AR coefficients.
Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
<p>Further details on 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr><td><code id="ARXff_+3A_idrift">idrift</code>, <code id="ARXff_+3A_isd">isd</code>, <code id="ARXff_+3A_ivar">ivar</code>, <code id="ARXff_+3A_iarcoeff">iARcoeff</code></td>
<td>

<p>Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This family function describes an autoregressive model of order-<code class="reqn">p</code>
with covariates (ARX(p)). It is a special case of the subclass VGLM&ndash;ARIMA
(Miranda and Yee, 2018):
</p>
<p style="text-align: center;"><code class="reqn"> Y_t | \Phi_{t - 1} = \mu_t + \theta_{1} Y_{t - 1} + \ldots + 
\theta_p Y_{t - p} + \varepsilon_t,</code>
</p>

<p>where  <code class="reqn">\boldsymbol{x}_t</code>
a (possibly time&ndash;varying) covariate vector and
<code class="reqn">\mu_t = \mu^{\star} + \boldsymbol{\beta}^T \boldsymbol{x}_t</code> is a (time&ndash;dependent) scaled&ndash;mean, known as <em>drift</em>.
</p>
<p>At this stage, conditional Gaussian white noise, 
<code class="reqn">\varepsilon_t| \Phi_{t - 1}</code> 
is handled, in the form
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_t | \Phi_{t - 1} \sim 
  N(0, \sigma^2_{\varepsilon_t | \Phi_{t - 1}}).</code>
</p>

<p>The distributional assumptions on the observations are then
</p>
<p style="text-align: center;"><code class="reqn">Y_t | \Phi_{t - 1} \sim 
   N(\mu_{t | \Phi_{t - 1}}, 
   \sigma^2_{\varepsilon_t | \Phi_{t - 1}}), </code>
</p>

<p>involving the conditional mean 
equation for the ARX(p) model:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{t | \Phi_{t - 1}} = \mu_t + 
 \boldsymbol{\beta}^T * \boldsymbol{x}_t
   \theta_{1} Y_{t - 1} + \ldots + 
      \theta_p Y_{t - p}.</code>
</p>

<p><code class="reqn">\Phi_{t}</code> denotes the information
of the joint process
<code class="reqn">\left(Y_{t}, \boldsymbol{x}_{t + 1}^T \right)</code>,
at time <code class="reqn">t</code>.
</p>
<p>The loglikelihood is computed by <code><a href="#topic+dARp">dARp</a></code>,
at each Fisher scoring iteration.
</p>
<p>The linear predictor is
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\eta} = \left( 
\mu_t, \log \sigma^{2}_{\varepsilon_{t | \Phi_{t - 1}}},
\theta_1, \ldots, \theta_p
\right)^T.</code>
</p>
 
<p>Note, the covariates may also intervene in the conditional
variance model
<code class="reqn">\log \sigma^{2}_{\varepsilon_{t | \Phi_{t - 1}}}.</code> Hence, this family function
does not restrict the noise to be <em>strictly</em> white noise
(in the sense of <em>constant variance</em>). 
</p>
<p>The unconditional mean, 
<code class="reqn"> E(Y_{t}) = \mu</code>, satisfies
</p>
<p style="text-align: center;"><code class="reqn">\mu \rightarrow \frac{\mu^{\star}}{1 - (\theta_1 +
\ldots + \theta_p)} </code>
</p>

<p>when the process is stationary, and no covariates are involved.
</p>
<p>This family function currently handles
<em>multiple responses</em> so that a matrix can be used as the response.
Also, for further details on VGLM/VGAM&ndash;link functions refer to 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
<p>Further choices for the random noise, besides Gaussian, will be
implemented over time.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>). The
object is used by VGLM/VGAM modelling functions, such as
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Note</h3>

<p><code>zero</code> can be either an <em>integer</em> vector
or a vector of <b>character strings</b>
specifying either the position(s) or name(s) (partially or not) of the 
parameter(s) modeled as intercept-only. Numeric values can be set as usual 
(See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>).
Character strings can be entered as per
parameter names in this family function, given by:
</p>
<p><code>c("drift", "noiseVar" or "noiseSD", "ARcoeff")</code>.
</p>
<p>Users can modify the <code>zero</code> argument according to their needs.
</p>
<p>By default, <code class="reqn">\mu_t</code> and the coefficients
<code class="reqn">\theta_1, \ldots, \theta_p</code>
are intercept&ndash;only. That is, 
<code class="reqn">\log \sigma^{2}_{\varepsilon_{t | \Phi_{t - 1}}}</code> is modelled in terms of any explanatories
entered in the <code>formula</code>.
</p>
<p>Users, however, can modify this
according to their needs via
<code><a href="VGAM.html#topic+zero">zero</a></code>. For example, set the covariates in the
<code>drift</code> model, <code class="reqn">\mu_t</code>.
In addition, specific constraints 
for parameters are handled through the function 
<code><a href="#topic+cm.ARMA">cm.ARMA</a></code>.
</p>
<p>If <code>var.arg = TRUE</code>, this family function estimates
<code class="reqn">\sigma_{\varepsilon_t | \Phi_{t - 1}}^2</code>.
Else, the
<code class="reqn">\sigma_{\varepsilon_t | \Phi_{t - 1}}</code>
estimate is returned.
</p>
<p>For this family function the <code>order</code> is recycled. That is,
<code>order</code> will be replicated up to the number of responses
given in the <code>vglm</code> call is matched.
</p>


<h3>Warning</h3>

<p>Values of the estimates may not correspond
to stationary ARs, leading to low accuracy in the MLE estimates,
e.g., values very close to 1.0.
<em>Stationarity</em> is then examined, via
<code><a href="#topic+checkTS.VGAMextra">checkTS.VGAMextra</a></code>,
if
<code>noChecks = FALSE</code> (default) 
and <b>no</b> constraint matrices are set
(See <code><a href="VGAM.html#topic+constraints">constraints</a></code> for further
details on this).
If the estimated model very close to be non-stationary, then
a <code>warning</code> will be outlined. 
Set <code>noChecks = TRUE</code> to completely ignore this.
</p>
<p>NOTE: Full details on these 'checks' are shown within the 
<code>summary()</code> output.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and T. W. Yee
</p>


<h3>References</h3>

<p>Madsen, H. (2008)
Time Series Analysis. 
Florida, USA: <em>Chapman &amp; Hall</em>(Sections 5.3 and 5.5).
</p>
<p>Porat, B., and Friedlander, B. (1986)
Computation of the Exact Information Matrix of Gaussian
Time Series with Stationary Random Components.
<em>IEEE Transactions on Acoustics, Speech and Signal
Processing</em>. <b>ASSp-34(1)</b>, 118&ndash;130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARIMAXff">ARIMAXff</a></code>,
<code><a href="#topic+ARMAXff">ARMAXff</a></code>,
<code><a href="#topic+MAXff">MAXff</a></code>,
<code><a href="#topic+checkTS.VGAMextra">checkTS.VGAMextra</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>,

</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
nn     &lt;- 150
tsdata &lt;- data.frame(x2 =  runif(nn))             # A single covariate.
theta1 &lt;- 0.45; theta2 &lt;- 0.31; theta3 &lt;- 0.10     # Coefficients
drift  &lt;- c(1.3, -1.1)                             # Two responses.
sdAR   &lt;- c(sqrt(4.5), sqrt(6.0))                  # Two responses.

# Generate AR sequences of order 2 and 3, under Gaussian noise.
# Note, the drift for 'TS2' depends on x2 !
tsdata  &lt;-  data.frame(tsdata, TS1 = arima.sim(nn, 
              model = list(ar = c(theta1, theta1^2)),  rand.gen = rnorm, 
              mean = drift[1], sd = sdAR[1]),
                                TS2 = arima.sim(nn,  
              model = list(ar = c(theta1, theta2, theta3)), rand.gen = rnorm, 
              mean = drift[2] + tsdata$x2 , sd = sdAR[2]))

# EXAMPLE 1. A simple AR(2), maximizing the exact log-likelihood
# Note that parameter constraints are involved for TS1, but not 
# considered in this fit. "rhobitlink" is used as link for AR coeffs.

fit.Ex1 &lt;- vglm(TS1 ~ 1, ARXff(order = 2, type.EIM = "exact",
                      #iARcoeff = c(0.3, 0.3, 0.3), # OPTIONAL INITIAL VALUES
                      # idrift = 1, ivar = 1.5, isd = sqrt(1.5),
                      lARcoeff = "rhobitlink"), 
              data = tsdata,  trace = TRUE, crit = "loglikelihood")
Coef(fit.Ex1)
summary(fit.Ex1)
vcov(fit.Ex1, untransform = TRUE)       # Conformable with this fit.
AIC(fit.Ex1)
#------------------------------------------------------------------------#
# Fitting same model using arima(). 
#------------------------------------------------------------------------#
(fitArima &lt;- arima(tsdata$TS1, order = c(2, 0, 0)))
# Compare with 'fit.AR'. True are theta1 = 0.45; theta1^2 = 0.2025
Coef(fit.Ex1)[c(3, 4, 2)]    # Coefficients estimated in 'fit.AR'


# EXAMPLE 2. An AR(3) over TS2, with one covariate affecting the drift only.
# This analysis makes sense as the TS2's drift is a function ox 'x2', 
# i.e., 'x2' affects the 'drift' parameter only. The noise variance 
# (var.arg = TRUE) is estimated, as intercept-only. See the 'zero' argument.


#------------------------------------------------------------------------#
# This model CANNOT be fitted using arima()
#------------------------------------------------------------------------#
fit.Ex2 &lt;- vglm(TS2 ~ x2,  ARXff(order = 3, zero = c("noiseVar", "ARcoeff"), 
                             var.arg = TRUE), 
                  ## constraints = cm.ARMA(Model = ~ 1, lags.cm = 3, Resp = 1),
              data = tsdata,  trace = TRUE, crit = "log")

# True are theta1 &lt;- 0.45; theta2 &lt;- 0.31; theta3 &lt;- 0.10
coef(fit.Ex2, matrix = TRUE)
summary(fit.Ex2)    
vcov(fit.Ex2)
BIC(fit.Ex2)
constraints(fit.Ex2)


# EXAMPLE 3. Fitting an ARX(3) on two responses TS1, TS2; intercept-only model with
#  constraints over the drifts. Here, 
# a) No checks on invertibility performed given the use of cm.ARMA().
# b) Only the drifts are modeled in terms of 'x2'. Then,  'zero' is
# set correspondingly.
#------------------------------------------------------------------------#
# arima() does not handle this model.
#------------------------------------------------------------------------#
fit.Ex3 &lt;- vglm(cbind(TS1, TS2) ~ x2, ARXff(order = c(3, 3), 
                            zero = c("noiseVar", "ARcoeff"), var.arg = TRUE), 
             constraints = cm.ARMA(Model = ~ 1 + x2, lags.cm = c(3, 3), Resp = 2),
             trace = TRUE, data = tsdata, crit = "log")

coef(fit.Ex3, matrix = TRUE)
summary(fit.Ex3)
vcov(fit.Ex3)
constraints(fit.Ex3)



</code></pre>

<hr>
<h2 id='benini1Qlink'>
Link functions for the quantiles of several 1&ndash;parameter continuous
distributions
</h2><span id='topic+benini1Qlink'></span>

<h3>Description</h3>

<p>Computes the <code>benini1Qlink</code> transformation, its inverse and the
first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  benini1Qlink(theta, p = stop("Argument 'p' must be entered."),
               y0 = stop("Argument 'y0' must be specified."),
               bvalue = NULL, inverse = FALSE,
               deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benini1Qlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. See below for further details.
</p>
</td></tr>
<tr><td><code id="benini1Qlink_+3A_p">p</code></td>
<td>

<p>Numeric. A single value between 0.0 and 1.0.
It is the <code class="reqn">p</code>&ndash;quantile to be modeled by this link function. 
</p>
</td></tr>
<tr><td><code id="benini1Qlink_+3A_y0">y0</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+benini1">benini1</a></code>.
</p>
</td></tr>
<tr><td><code id="benini1Qlink_+3A_bvalue">bvalue</code>, <code id="benini1Qlink_+3A_inverse">inverse</code>, <code id="benini1Qlink_+3A_deriv">deriv</code>, <code id="benini1Qlink_+3A_short">short</code>, <code id="benini1Qlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a link function to model any <code class="reqn">p</code>&ndash;quantile of the 
1&ndash;parameter Benini distribution. It is called the
<code>benini1Qlink</code> transformation defined as

</p>
<p style="text-align: center;"><code class="reqn"> \log y_0 + \sqrt{\frac{ -\log (1 - p) }{s}}  </code>
</p>


<p>where <code class="reqn">y_0 &gt; 0</code> is a scale parameter and <code class="reqn">s</code> is 
a positive shape parameter, as in <code><a href="VGAM.html#topic+benini1">benini1</a></code>. 
</p>
<p>Numerical values of <code class="reqn">s</code> or <code class="reqn">p</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>
<p>In particular, arguments <code>inverse</code> and <code>deriv</code> are
disregarded if <code>theta</code> is character.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>benini1Qlink</code> transformation of
<code>theta</code>, when <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, then
the inverse transformation given by 
<code>-log(1 - p) / (theta - log y0)^2</code> is returned.
</p>
<p>For <code>deriv = 1</code>, this function returns the derivative 
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code>, 
if <code>inverse = FALSE</code>. Else, the reciprocal 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of <code>theta</code>.
</p>
<p>If <code>deriv = 2</code>, then the second order derivatives in terms of
<code>theta</code> are accordingly returned. 
</p>


<h3>Warning</h3>

<p>The horizontal straight line <code class="reqn">\log y0</code> is a lower asymptote
for this link function as <code class="reqn">\theta</code> increases to <code class="reqn">\infty</code>.
Thus, when <code>inverse = TRUE</code> and <code>deriv = 0</code> entries at 
<code>theta</code> becoming <code class="reqn">\eta</code> must be greater than 
<code class="reqn">\log y0</code>. Else, <code>NaN</code> will be returned. 
See examples 2 and 3 below.
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero or lower than <code class="reqn">\log y0</code>. 
Use argument <code>bvalue</code> to replace them before computing the link.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+benini1">benini1</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## E1. benini1Qlink() and its inverse ##
   p &lt;- 0.50; y0 = 1.25         ## Modeling the median
   my.s &lt;- seq(0, 5, by = 0.1)[-1]
    max(my.s - benini1Qlink(benini1Qlink(my.s, p = p, y0 = y0), 
                            p = p, y0 = y0, inverse  =TRUE))    ## Zero

  ## E2. Plot of the benini1Qlink() transformation and its inverse     ##
  ## Note, inverse = TRUE implies that argument 'theta' becomes 'eta'. ##
  ## which must be greater than log(y0). Else, value less than log(y0) ##
  ## are replaced by NaN.                                              ##
  
   #--- THE LINK
   my.b &lt;- seq(0, 5, by = 0.01)[-1]
   plot(benini1Qlink(theta = my.b, p = p, y0 = y0) ~ my.b,
        type = "l", col = "blue", lty = "dotted", lwd = 3,
        xlim = c(-0.1, 6), ylim = c(-0.1, 5), las = 1,
        main = c("Blue is benini1Qlink(), green is the inverse"),
        ylab = "eta = benini1Qlink", xlab = "theta")
   abline(h = 0, v = 0, lwd = 2)
    
   #--- THE INVERSE
   lines(my.b, benini1Qlink(theta = my.b, p = p, y0 = y0, inv = TRUE),
         col = "green", lwd = 2, lty = "dashed")
   #--- Tracing the identity function for double--check
   lines(my.b, my.b)     
   
    
   ## E3. WARNING! The first two values are less than log(y0)  ##
    benini1Qlink(theta = c(0.10, 0.15, 0.25, 0.35) , p = p, y0 = y0, inverse  = TRUE)
    
</code></pre>

<hr>
<h2 id='borel.tannerMlink'>
Link functions for the mean of 1&ndash;parameter 
discrete distributions: The Borel&ndash;Tanner distribution.
</h2><span id='topic+borel.tannerMlink'></span><span id='topic+borel.tannerMeanlink'></span>

<h3>Description</h3>

<p>Computes the <code>borel.tannerMlink</code> transformation, 
its inverse and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    borel.tannerMlink(theta, Qsize = 1, 
                      bvalue = NULL, inverse = FALSE, 
                      deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="borel.tannerMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. See below for further details.
</p>
</td></tr>
<tr><td><code id="borel.tannerMlink_+3A_qsize">Qsize</code></td>
<td>

<p>A positive integer. It is called <code class="reqn">Q</code>.
Same as <code><a href="VGAM.html#topic+borel.tanner">borel.tanner</a></code>.
Default it 1.
</p>
</td></tr>
<tr><td><code id="borel.tannerMlink_+3A_bvalue">bvalue</code>, <code id="borel.tannerMlink_+3A_inverse">inverse</code>, <code id="borel.tannerMlink_+3A_deriv">deriv</code>, <code id="borel.tannerMlink_+3A_short">short</code>, <code id="borel.tannerMlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with 
<code><a href="#topic+zetaffMlink">zetaffMlink</a></code> or
<code><a href="#topic+yulesimonMlink">yulesimonMlink</a></code>,
this link function is part of a set of link functions in
<span class="pkg">VGAM</span> developed under a common methodology: by taking the 
logarithm of the mean of the corresponding distribution. 
</p>
<p>In particular, this link function emerges by computing the 
logarithm of the mean of the Borel&ndash;Tanner distribution.
It is defined as

</p>
<p style="text-align: center;"><code class="reqn">  \tt{borel.tannerMlink}(a) = - \log (Q^{-1} - aQ^{-1}),</code>
</p>


<p>where <code class="reqn">a</code>, <code class="reqn">0 &lt; a &lt; 1</code>, is a scale parameter 
as in <code><a href="VGAM.html#topic+borel.tanner">borel.tanner</a></code>. 
</p>
<p>The domain set of <code>borel.tannerMlink</code> is the open interval
<code class="reqn">(0, 1)</code>, except when <code>inverse = TRUE</code> and <code>deriv = 0</code>.
See below for further details about this.
Moreover, unlike <code><a href="#topic+zetaffMlink">zetaffMlink</a></code>
or <code><a href="#topic+posPoiMlink">posPoiMlink</a></code>, the
inverse of <code>borel.tannerMlink</code> can be written in
closed&ndash;form.
</p>
<p>Values of <code class="reqn">a</code> (i.e. <code>theta</code>) out of range will result in 
<code>NaN</code> of <code>NA</code>.
</p>
<p>If <code>theta</code> is a character, arguments <code>inverse</code> and
<code>deriv</code> are discarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>borel.tannerMlink</code> transformation of
<code>theta</code>, if <code>inverse = FALSE</code>. When <code>inverse = TRUE</code>,
<code>theta</code> becomes <code class="reqn">\eta</code> and the inverse of 
<code>borel.tannerMlink</code>, given by

</p>
<p style="text-align: center;"><code class="reqn"> 1 - \frac{Q}{ e^{\eta} },</code>
</p>


<p>is returned. Here, the domain set changes to <code class="reqn">(0, \infty)</code>.
</p>
<p>For <code>deriv = 1</code>, <em>d</em> <code>eta</code> / <em>d</em> <code>theta</code> 
as a function of <code>theta</code> if <code>inverse = FALSE</code>, else 
the reciprocal <em>d</em> <code>theta</code> / <em>d</em> <code>eta</code>.
</p>
<p>Similarly, when <code>deriv = 2</code> the second order derivatives
in terms of <code>theta</code> are returned.





</p>


<h3>References</h3>

<p>Haight, F. and Brueuer, M. A. (1960) The Borel&ndash;Tanner distribution.
<em>Biometrika</em>, <b>47</b>, 143&ndash;150.
</p>


<h3>Note</h3>

<p>The vertical line <code class="reqn">a = 1</code> is an asymptote for this link 
function, which sharply grows for values of <code class="reqn">a</code> too close to 1.0
from the left. For such cases, <code>Inf</code> might result when computing 
<code>borel.tannerMlink</code>.
</p>
<p>This link function is useful to model any parameter
in <code class="reqn">(0, 1)</code>. Then, some problems may occur if there
are covariates causing out of range values.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+borel.tanner">borel.tanner</a></code>,
<code><a href="#topic+yulesimonMlink">yulesimonMlink</a></code>,
<code><a href="#topic+zetaffMlink">zetaffMlink</a></code>,
<code><a href="#topic+posPoiMlink">posPoiMlink</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1. Special values for theta (or eta, accordingly)  ##
a.par &lt;- c(0, 1:10/10, 20, 1e1, Inf, -Inf, NaN, NA) 

# The borel.tannerMlink transformation and the first two derivatives.
print(rbind(a.par, 
 deriv1 = borel.tannerMlink(theta = a.par, inverse = FALSE, deriv = 1),
 deriv2 = borel.tannerMlink(theta = a.par, inverse = FALSE, deriv = 2)),
 digits = 2)
  
# The inverse of 'borel.tannerMlink()' and the first two derivatives.
# 'theta' turns into 'eta'.
print(rbind(a.par, 
    Invderiv1 = borel.tannerMlink(theta = a.par, inverse = TRUE, deriv = 1),
    Invderiv2 = borel.tannerMlink(theta = a.par, inverse = TRUE, deriv = 2)),
    digits = 2)

  
## Example 2 ##
a.param &lt;- c(0, 1, 5, 10, 1e2, 1e3) 
rbind(a.values = a.param, 
      inv.BT = borel.tannerMlink(theta = a.param, inverse = TRUE))
    
data.inv &lt;- borel.tannerMlink(borel.tannerMlink(a.param, inv = TRUE)) - a.param
summary(data.inv)                      ## Should be zero



## Example 3. Some link functions in VGAM with domain set (0, 1) ##
a.param &lt;- ppoints(100)

par(lwd = 2)
plot(a.param, borel.tannerMlink(a.param), ylim = c(-5, 7), xlim = c(-0.01, 1.01),
     type = "l", col = "gray10", ylab = "transformation",
     las = 1, main = "Some probability link functions")
lines(a.param, logffMlink(a.param), col = "blue")
lines(a.param, logitlink(a.param), col = "limegreen")
lines(a.param, probitlink(a.param), col = "purple")
lines(a.param, clogloglink(a.param), col = "chocolate")
lines(a.param, cauchitlink(a.param), col = "tan")
abline(v = c(0.5, 1), lty = "dashed")
abline(v = 0, h = 0, lty = "dashed")
legend(0.05, 7, c("borel.tanneMlink", "logffMlink", "logitlink", "probitlink",
                  "clogloglink", "cauchitlink"),
       col = c("gray10", "blue", "limegreen", "purple", "chocolate", "tan"),
      lwd = 1)
par(lwd = 1) 

</code></pre>

<hr>
<h2 id='break.VGAMextra'> Names/Value of linear predictors/parameters in time series 
family functions. </h2><span id='topic+break.VGAMextra'></span>

<h3>Description</h3>

<p>Splitting out the names of linear predictors or Numeric values for 
parameters in time series family functions in <span class="pkg">VGAMextra</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      break.VGAMextra(eta      = NULL,
                      M1       = NULL,
                      noInter  = NULL,
                      bOrder   = NULL,
                      NOS      = NULL,
                      lInter   = "identitylink",
                      lvar     = "loglink",
                      lsd      = "loglink",
                      lcoeff1  = "rhobitlink",
                      lcoeff2  = "rhobitlink",
                      typeTS   = "AR",
                      namesLP  = FALSE,
                      Complete = FALSE,
                      varArg   = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="break.VGAMextra_+3A_eta">eta</code></td>
<td>

<p>A matrix of dimensions <code>c(n, M)</code> storing the linear predictors 
values coming from the <code>vglm</code> fit. Here, <code class="reqn">M</code> is the number
of parameters. See <code>warning</code> below for further information.


</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_m1">M1</code></td>
<td>

<p>Number of parameters involved in the <code>vglm</code> fit.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_nointer">noInter</code></td>
<td>

<p>Logical. To determine whether the intercept is 
estimated. If <code>'TRUE'</code>,
the intercept is not estimated and set to 0.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_border">bOrder</code></td>
<td>

<p>A vector. 
The order of the linear process fitted. Either a single number (if one 
response), or a vector (if multiple responses).
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_nos">NOS</code></td>
<td>

<p>Integer. Number of respones set in the <code>vglm</code> call.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_linter">lInter</code>, <code id="break.VGAMextra_+3A_lvar">lvar</code>, <code id="break.VGAMextra_+3A_lsd">lsd</code>, <code id="break.VGAMextra_+3A_lcoeff1">lcoeff1</code>, <code id="break.VGAMextra_+3A_lcoeff2">lcoeff2</code></td>
<td>

<p>Link functions applied to parameters. Same as in 
<code><a href="#topic+ARXff">ARXff</a></code>, or 
<code><a href="#topic+MAXff">MAXff</a></code>.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_typets">typeTS</code></td>
<td>

<p>Character. Currently, options <code>"AR"</code> for Autoregressive, and 
<code>"MA"</code> for Moving Average processes are handled.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_nameslp">namesLP</code></td>
<td>

<p>Logical. This function returns either the names of linear the
predictors/parameters ( if <code>namesLP = TRUE</code> ) or parameter
values (default) broken down from the <code>eta</code> matrix.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_complete">Complete</code></td>
<td>

<p>Logical. If <code>TRUE</code>, columns of zeros are incorporated into the
matrix <code>eta</code>. See below for further details.
</p>
</td></tr>
<tr><td><code id="break.VGAMextra_+3A_vararg">varArg</code></td>
<td>

<p>Sames as in <code><a href="#topic+ARXff">ARXff</a></code> or 
<code><a href="#topic+MAXff">MAXff</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time series family functions in <span class="pkg">VGAMextra</span> currently recycle 
the order set in the <code><a href="VGAM.html#topic+vglm">vglm</a></code>. 
Particularly, it occurs when the number of responses is fewer than 
the specified order. For instance, if the order set in <code>vglm</code>
is <code class="reqn">c(1, 3)</code>, and 5 responses are managed, then the new order
becomes <code class="reqn">c(1, 3, 1, 3, 1)</code>. 
</p>
<p>Due to such flexibility, time series family functions require 
specific functions to unload the amount of code within each one. 
</p>
<p>Moreover, when the order is recycled, the matrix <code>eta</code> is 
<em>completed</em>, as if the order was the same for each response.
This feature is enabled when <code>Complete = TRUE</code>.
This &lsquo;common&rsquo; order turns out to be the maximum order established in
the vector <code>order</code>. This trick makes the family function to work
properly. To return to the riginal &lsquo;order&rsquo;, <code>eta</code> is reduced 
in the same number of colums initially added.
</p>
<p><code>break.VGAMextra</code> works in this context. It may return either 
the names of the linear predictors/parameters, or the parameter values 
splitted out as a list. Thus, link functions entered in the <code>vglm</code> 
call must be passed down to this functions.
For further details on link functions refer to 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>


<h3>Value</h3>

<p>A list containing either the names of the linear predictors or the 
parameters values (not linear predictors) unwrapped from tje
<code>eta</code> matrix, as follows:
</p>
<p>a) If <code>namesLP = FALSE</code> (default), value of parameters are 
returned in this order: the intercept (1), standard deviation and
variance of the white noise (2, 3), and the coefficients (4).
</p>
<p>b) If <code>namesLP = TRUE</code>, <b>names of linear predictors</b> are
returned in the first entry, whereas <b>parameter names</b> are
allocated to the second entry.
</p>
<p>Yee and Wild (1996) provide more detailed information about 
the relationship between linear predictors and parameters within 
the VGLM statistical framework.
</p>


<h3>Warning</h3>

<p>Note that library <span class="pkg">VGAM</span> is definitely required.
</p>


<h3>Warning</h3>

<p>Be aware of the dimensions of matrix <code>eta</code>. It is <code>c(n, M)</code>,
where <code class="reqn">n</code> is the sample size, and <code class="reqn">M</code> is the number of 
parameters. If multiple responses, then <code class="reqn">M</code> equals the summation
of parameters individually.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and T. W. Yee
</p>


<h3>References</h3>

<p>Yee, T. W. and Wild, C. J. (1996)
Vector Generalized Additive Models.
<em>Journal of the Royal Statistical Society</em>, 
Series B, Methodological, <b>58(3)</b>, 481&ndash;493.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+ARXff">ARXff</a></code>,
<code><a href="#topic+MAXff">MAXff</a></code>,

<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.




</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(VGAM)

eta     &lt;- matrix(runif(100), nrow = 10, ncol = 10)
M1      &lt;- c(5, 5)
noInter &lt;- FALSE
bOrder  &lt;- c(3, 3)
NOS     &lt;- 2

### ONLY LINEAR PREDICTORS/PARAMETERS NAMES!
### RETURNED OBJECT IS A LIST !

break.VGAMextra(M1      = M1, 
                noInter = noInter, 
                bOrder  = bOrder, 
                NOS     = NOS, 
                typeTS  = "AR", 
                namesLP = TRUE, 
                varArg  = TRUE)

### PARAMETER VALUEs... "UNWRAPPED". Inverse link functions are applied.
###  Note that namesLP must be set to FALSE

break.VGAMextra(eta     = eta,
                M1      = M1, 
                noInter = noInter, 
                bOrder  = bOrder, 
                NOS     = NOS, 
                typeTS  = "AR", 
                namesLP = FALSE, 
                varArg  = TRUE)





</code></pre>

<hr>
<h2 id='checkTS.VGAMextra'>
Polynomial roots based on <em>transfer operators</em> in Vector 
Generalized Time Series Family Functions
</h2><span id='topic+checkTS.VGAMextra'></span><span id='topic+checkTS.ffs'></span>

<h3>Description</h3>

<p><code>checkTS.VGAMextra</code> computes the polynomial roots as per 
<em>transfer operator</em> in Vector 
Generalized Time Series Family Functions in <span class="pkg">VGAMextra</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>        checkTS.VGAMextra(thetaEst = NULL, 
                          tsclass  = c("AR", "MA"), 
                          chOrder  = 1,
                          NofS     = 1,
                          retmod   = TRUE,
                          pRoots   = TRUE)
                          
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkTS.VGAMextra_+3A_thetaest">thetaEst</code></td>
<td>

<p>A vector of coefficients. Its lenght must be <code>NofS * chOrder</code>.
If <code><a href="VGAM.html#topic+vglm">vglm</a></code> is called,
then <code>thetaEst</code> contains the estimated coefficients of the model
specified in <code>formula</code> .
</p>
</td></tr>
<tr><td><code id="checkTS.VGAMextra_+3A_tsclass">tsclass</code></td>
<td>

<p>Character indicating the model class to be checked. Presently, 
options <code>"AR"</code> and <code>"MA"</code> are handled.
</p>
</td></tr>
<tr><td><code id="checkTS.VGAMextra_+3A_chorder">chOrder</code></td>
<td>

<p>Positive integer. The order of polynomial associated to the
underlying procees involved:
either $p$ or $q$, which apply for 
<code>"AR"</code> or <code>"MA"</code> rspectively.



</p>
</td></tr>
<tr><td><code id="checkTS.VGAMextra_+3A_nofs">NofS</code></td>
<td>

<p>A positive integer denoting the number of Time Series to verify.
In the <code><a href="VGAM.html#topic+vglm">vglm</a></code> environment, <code>NofS</code> is 
the number of responses given in <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="checkTS.VGAMextra_+3A_retmod">retmod</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), the <em>Module</em> of all roots as per 
transfer operator in the process established in <code>tsclass</code> 
is returned. Else, essentially the roots are returned.
</p>
</td></tr>
<tr><td><code id="checkTS.VGAMextra_+3A_proots">pRoots</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), the roots computed from estimated 
models are displayed along with the time series family function 
execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stationarity and/or Invertibility of time series (TS) are usually verified 
via the roots of the polynomial derived from the <em>transfer
operators</em>. 
</p>
<p>In particular, <code>checkTS.VGAMextra</code> computes such roots via
the coefficients estimated by vector generalized TS family functions 
available in <span class="pkg">VGAMextra</span> ( <code><a href="#topic+ARXff">ARXff</a></code>, and 
<code><a href="#topic+MAXff">MAXff</a></code>).
</p>
<p>Specifically, <code>checkTS.VGAMextra</code> verifies whether the TS
analyzed via <code><a href="VGAM.html#topic+vglm">vglm</a></code> is <em>stationary</em> or 
<em>invertible</em>, accordingly.
</p>
<p>Note that an autoregressive process of order-<code class="reqn">p</code> 
[AR(<code class="reqn">p</code>)]  with coefficients
<code class="reqn">\theta_{1}, \ldots, \theta_{p}</code> 
can be written in the form
</p>
<p style="text-align: center;"><code class="reqn">  \theta(B) Y_{t} = \varepsilon_{t}, </code>
</p>
 
<p>where
</p>
<p style="text-align: center;"><code class="reqn"> \theta(B) = 1 - \sum_{k = 1}^{p} \theta_{k} B^{k} </code>
</p>

<p>Here, <code class="reqn"> \theta(B) </code> is referred to as 
the <em>transfer operator</em> of the process, and 
<code class="reqn">B^{k} Y_{t} = Y_{t - k},</code>,
for <code class="reqn">k = 0, 1, \ldots,p</code>, is the lagged single-function.
</p>
<p>In general, an autoregressive process of order-<code class="reqn">p</code> is
<em>stationary</em> if the roots of 
</p>
<p style="text-align: center;"><code class="reqn"> \theta(z) = 1 - \theta_{1} z - \ldots - \theta_{q} z^q  </code>
</p>

<p>lie <em>outside</em> the unit circle, i.e. <code class="reqn">|z| &gt; 1</code>.
</p>
<p>Similarly, a moving-average process of order-<code>q</code> can be formulated 
(without loss of generality <code class="reqn">\mu = 0</code>) 
</p>
<p style="text-align: center;"><code class="reqn"> Y_{t} = \psi(B) \varepsilon_{t}, </code>
</p>

<p>where <code class="reqn"> \psi(B) </code> is the <em>transfer operator</em>, given by
</p>
<p style="text-align: center;"><code class="reqn"> \psi(B) = 1 + \sum_{k = 1}^{q} \psi_{k} B^{k}, </code>
</p>

<p>Note that <code class="reqn"> \psi_{0} = 1 </code>, and 
<code class="reqn">B^{k} \varepsilon_{t} = \varepsilon{t - k} </code>.
</p>
<p>Hence, a moving-average process of order-<code class="reqn">q</code> [MA(<code class="reqn">q</code>)], 
generally given by (note <code class="reqn">\mu = 0</code>)
</p>
<p style="text-align: center;"><code class="reqn">Y_{t} = \phi_1 \varepsilon_{t - 1} + \ldots + 
              \phi_q \varepsilon_{t - q} + \varepsilon_{t},</code>
</p>

<p>is <em>invertible</em> if all the roots of
</p>
<p style="text-align: center;"><code class="reqn"> \phi(B) = 1 + \phi_{1} B + \ldots + \phi_{q} B^q  </code>
</p>

<p>lie <em>outside</em> the unit circle., i.e.m <code class="reqn">|z| &gt; 1</code>.
</p>
<p>Parallel arguments can be stated for autoregressive moving
aberage processes (ARMA). See Box and Jenkins (1970) for 
further details.
</p>


<h3>Value</h3>

<p>A vector whose elements are the roots of polynomials <em>inherited</em>
from <em>transfer operators</em> according to the process analyzed. 
</p>
<p>Alternatively, the modules of roots can by returned instead of merely roots
via the <code>retmod</code> argument. 
</p>


<h3>Warning</h3>

<p>The argument <code>thetaEst</code> manages the coefficients of the TS
model(s) in turn. Then, it must be <code>NofS * chOrder</code> length, 
where <code>NofS</code> is the number of responses established in the 
<code><a href="VGAM.html#topic+vglm">vglm</a></code> call.
Here the coefficients for each response must be sequentially groped.
</p>
<p>A moving average process is always stationary (See Madsen (2007) for
further details). Consequently, the <code><a href="#topic+MAXff">MAXff</a></code> 
in <span class="pkg">VGAMextra</span> verifies (by default) only for invertibility.
To enable this option set <code>nowarning = FALSE</code> in the 
<code><a href="#topic+MAXff">MAXff</a></code> 
call.
</p>
<p>Similarly, <code><a href="#topic+ARXff">ARXff</a></code> verifies whether the TS data 
fitted is stationary, whereas <code>ARMAXff()</code> verifies both properties.
</p>


<h3>Note</h3>

<p>For TS family functions in the VGLM/VGAM framework, 
<code>checkTS.VGAMextra</code> is called at the final iteration of Fisher scoring.
It means that the MLE estimates are actually evaluated to 
verify whether the process is <em>stationary</em> or <em>invertible</em>.
</p>
<p>If any root has module less than <code class="reqn">1 + 1e-5</code>, a <code>warning</code> is displayed 
for informative purposes.
</p>
<p>Argument <code>thetaEst</code> manages the parameters of the TS model 
in turn.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and T. W. Yee.
</p>


<h3>References</h3>

<p>Box, G.E.P. and Jenkins, G.M. (1970) 
<em>Time Series Analysis: Forecasting and Control</em>. 
Holden-Day, San Francisco, USA.
</p>
<p>Madsen, H (2007)
<em>Time Series Analysis</em>.
Chapman and Hall/CRC, Boca Raton, Florida, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A moving average process order-3 with coeffs --&gt; c(2.4, -5.6, 0.83)
#-------------------------#
# This is NOT invertible !
#-------------------------#

MAcoeffs &lt;- c(2.4, -5.6, 0.83)
checkTS.VGAMextra(thetaEst = MAcoeffs, 
                  tsclass = "MA", 
                  chOrder = 3,
                  retmod = FALSE)


# AR process order-3 with coeffs --&gt; c( 0.45, 0.45^2, 0.45^3 )
#-------------------------#
# This is stationary !
#-------------------------#

ARcoeffs &lt;- c( 0.45 , 0.45^2 , 0.45^3 )
checkTS.VGAMextra(thetaEst = ARcoeffs, 
                  tsclass = "AR", 
                  chOrder = 3,
                  retmod = TRUE,
                  pRoots = TRUE)  # DEFAULT for 'pRoots'
</code></pre>

<hr>
<h2 id='cm.ARMA'> Constraint matrices for vector generalized time series
family functions. </h2><span id='topic+cm.ARMA'></span>

<h3>Description</h3>

<p>Constraint matrices for coefficients of vector genelized time series 
family functions in <span class="pkg">VGAMextra</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>       cm.ARMA(Model      = ~ 1, 
               Resp       =  1,
               lags.cm    =  2,
               offset     = -2, 
               whichCoeff =  1,
               factorSeq  =  2) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cm.ARMA_+3A_model">Model</code></td>
<td>

<p>A symbolic description of the model being fitted. Must match that
formula specified in the <code>vglm()</code> call.
</p>
</td></tr>
<tr><td><code id="cm.ARMA_+3A_lags.cm">lags.cm</code></td>
<td>

<p>Vector of POSITIVE integers greater than 1 indicating the <em>order</em> 
for each response. It must match the <em>orders</em> entered in the 
<code><a href="VGAM.html#topic+vglm">vglm</a></code> call. Its default
value is <code>2</code>, assuming that a TS process of order greater
than 1 is being fitted. If <code>lags.cm &lt; 2</code>, then NO constraints
are required as only one coefficient (AR, MA or ARMA) is being 
estimated.
</p>
</td></tr>
<tr><td><code id="cm.ARMA_+3A_offset">offset</code></td>
<td>

<p>Vector of integers specifying the position of the ARMA coefficient 
at which constraints initiate FOR each response.
If negative, it is recycled and the absolute value is used. The default 
value is <code>-2</code>, which refers to the fourth position on the vector 
parameter, right after the drift or mean, the white noise sd, and
the first ARMA coefficient.
</p>
<p>Particularly, if only one coefficient is being estimated, i.e, an AR
or MA process of order-1 is being fitted, then NO restrictions over the
(unique) coefficient are needed. Consequently, <code>abs(offset &lt; 2)</code> 
leads to a message error.
</p>
</td></tr>
<tr><td><code id="cm.ARMA_+3A_whichcoeff">whichCoeff</code></td>
<td>

<p>Vector of POSITIVE integers strictly less than '<code>abs(offset)</code>',
each entry aplies to each response in the <code>vglm(...)</code> call.
This argument allows the user to specify the <em>unrestricted</em> 
coefficient to be considered for constraints. 
For instance, 
<code>whichCoeff = 2</code> means
that <code class="reqn">\theta_2</code> is the required coefficient to 
compute the constraint matrices. By default, <code>whichCoeff = -1</code> 
which implies that <code class="reqn">\theta_1</code> is used for this purpose.
</p>
<p>If <code>whichCoeff</code> is greater than or equal to
<code>abs(offset)</code>, an error message is displayed since 
constraints must be function of unrestricted
parameters. 
</p>
</td></tr>
<tr><td><code id="cm.ARMA_+3A_resp">Resp</code></td>
<td>

<p>The number of responses in the model fitted. Must match the number of 
responses given in <code>formula</code> in the <code>vglm</code> call.
</p>
</td></tr>
<tr><td><code id="cm.ARMA_+3A_factorseq">factorSeq</code></td>
<td>

<p>Vector of POSITIVE integers. Thus far, restrictions handled are 
<em>geometric sequences</em> and <em>arithmetic progressions</em>.
Hence, <code>factorSeq</code> specifies either the initial <em>power</em> or
<em>factor</em> at restrictions. 
</p>
<p>See below for further details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: Except for the <code>Model</code>, all arguments of length 1 are 
recycled when <code>Resp</code> <code class="reqn"> \geq 2</code>.
</p>
<p>Time Series family functions in <span class="pkg">VGAMextra</span> that are derived from 
AR(p) or MA(q) processes include the <em>drift</em> term (or mean) and the 
<em>white noise</em> standard deviation as the first two elements
in the vector parameter. For an MA(4), for example, it is given 
by
</p>
<p style="text-align: center;"><code class="reqn">(\mu, \sigma_\varepsilon, \phi_1, \phi_2, \phi_3, \phi_4).</code>
</p>

<p>Thus, constraint matrices on coefficients can be stated from the 
<em>second</em> coefficient, i.e., from
<code class="reqn">\phi_2</code>. This feature is specified with 
<code>offset = -2</code> by default. 
</p>
<p>In other words, <code>offset</code> indicates the exact position at 
which parameter restrictions commence. For example, <code>offset = -3</code> 
indicates that <code class="reqn">\phi_3</code> is the first coefficient over
which constraints are applied. Then, in order to successfully utilize 
this argument, it must be greater than or equal to 2 in absolute value.
Otherwise, an error message will be displayed as no single restriction
are amenable with <code class="reqn">\phi_1</code> only.
</p>
<p>Furthermore, if <code>lags.cm = 1</code>, i.e, a AR or MA process of order one 
is being fitted, then NO constraints are required either, as only one 
coefficient is directly considered.
</p>
<p>Hence, the miminum absolute value for argument <code>offset</code> is 
<code>2</code>
</p>
<p>As for the <code>factorSeq</code> argument, its defaul value is 2. 
Let <code>factorSeq = 4</code>, <code>lags.cm = 5</code>, <code>offset = -3</code>, and
<code>whichCoeff = 1</code>. The coefficient restrictions if a 
<em>geometric progression</em> is assumed are
</p>
<p style="text-align: center;"><code class="reqn"> \theta_3 = \theta_1^4, </code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_4 = \theta_1^5, </code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \theta_5 = \theta_1^6, </code>
</p>

<p>If coefficient restrictions are in <em>arithmetic sequence</em>, 
constraints are given by
</p>
<p style="text-align: center;"><code class="reqn"> \theta_3 = 4 * \theta_1, </code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_4 = 5 * \theta_1, </code>
</p>

<p style="text-align: center;"><code class="reqn"> \theta_5 = 6 * \theta_1, </code>
</p>

<p>The difference lies on thelink function used: 
<code><a href="VGAM.html#topic+loglink">loglink</a></code> for the first case, and 
<code><a href="VGAM.html#topic+identitylink">identitylink</a></code> for the latter.
</p>
<p>Note that conditions above are equivalent to test the following 
two Null Hypotheses:
</p>
<p style="text-align: center;"><code class="reqn">Ho: \theta_k = \theta_1^k</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">Ho: \theta_k = j * \theta_1</code>
</p>

<p>for <code class="reqn">k = 3, 4, 5</code>. 
</p>
<p>Simpler hypotheses can be tested by properly setting all arguments
in <code>cm.ARMA()</code>.
For instance, the default list of constraint matrices returned by 
<code>cm.ARMA()</code> allows to test
</p>
<p style="text-align: center;"><code class="reqn">Ho: \theta_k = \theta_1^j</code>
</p>

<p>for <code class="reqn">k = 2</code>, in a TS model of order-2 with one response.
</p>


<h3>Value</h3>

<p>A list of constraint matrices with specific restrictions over
the AR(<code class="reqn">p</code>), MA(<code class="reqn">q</code>) or ARMA (<code class="reqn">p, q</code>) coefficients. 
Each matrix returned is conformable with the VGAM/VGLM framework.
</p>
<p>Paragrpah above means that each constraint matrix returned by 
<code>cm.ARMA()</code> is full-rank with <em>M</em> rows (number of parameters), 
as required by  <span class="pkg">VGAM</span>. Note that constraint matrices within 
the VGAM/VGLM framework are <em>M</em> by <em>M</em> identity matrices 
by default. 
</p>
<p>Restrictions currently handled by <code>cm.ARMA()</code> are (increasing)
arithmetic and geometric progressions.
</p>


<h3>Warning</h3>

<p>Hypotheses above can be tested by properly applying
<em>parameter link functions</em>. If the test
</p>
<p style="text-align: center;"><code class="reqn">Ho: \theta_k = \theta_1^k,</code>
</p>

<p>arises, then constraint matrices returned by <code>cm.ARMA()</code> are
conformable to the use of <code><a href="VGAM.html#topic+loglink">loglink</a></code>.
</p>
<p>On the other hand, the following hypothesis
</p>
<p style="text-align: center;"><code class="reqn">Ho: \theta_k = k * \theta_1,</code>
</p>

<p>properly adapts to the link function 
<code><a href="VGAM.html#topic+identitylink">identitylink</a></code>. <code class="reqn">k = 2, 3,\ ldots</code>.
</p>
<p>For further details on parameter link functions within <span class="pkg">VGAM</span>, see
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>


<h3>Note</h3>

<p><code>cm.ARMA()</code> can be utilized to compute constraint matrices 
for many VGLTSM fmaily functions, e.g.,
<code><a href="#topic+ARXff">ARXff</a></code> and 
<code><a href="#topic+ARXff">MAXff</a></code> in <span class="pkg">VGAMextra</span>.
</p>
<p>More improvements such as restrictions on the
<em>drift parameter</em> and <em>white noise standard deviation</em>
will be set later.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and T. W. Yee
</p>


<h3>References</h3>

<p>Yee, T. W. and Hastie, T. J. (2003) 
Reduced-rank vector generalized linear models. 
<em>Statistical Modelling</em>, <b>3</b>, 15&ndash;41.
</p>
<p>Yee, T. W. (2008) 
The <code>VGAM</code> Package. 
<em>R News</em>, <b>8</b>, 28&ndash;39.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+loglink">loglink</a></code>,
<code><a href="VGAM.html#topic+rhobitlink">rhobitlink</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#############
# Example 1.
#############
# Constraint matrices for a TS family function (AR or MA) 
# with 6 lagged terms.
# Restriction commences at the third position (theta[3]) powered to
# or multiplied by 4. Intercept-only model.
position   &lt;- -3
numberLags &lt;-  6
myfactor   &lt;-  4
cm.ARMA(offset = position, lags.cm = numberLags, factorSeq = myfactor)

# With one covariate
cm.ARMA(Model =  ~ x2, offset = position, 
        lags.cm = numberLags, factorSeq = myfactor)


# Or 2 responses...
cm.ARMA(offset = position, lags.cm = numberLags, 
        factorSeq = myfactor, Resp = 2)


# The following call causes an ERROR.
# cm.ARMA(offset = -1, lags.cm = 6, factorSeq = 2)


##############
# Example 2.
##############

# In this example, the use of constraints via 'cm.ARMA()' is
# included in the 'vglm' call. Here, two AR(2) models are fitted
# in the same call (i.e. two responses), where different constraints
# are set, as follows:
# a) list(ar = c(theta1, theta1^2)) and
# b) list(ar = c(theta2, theta2^2 )).

# 2.0 Generate the data.
set.seed(1001)
nn     &lt;- 100
# A single covariate.
covdata &lt;- data.frame(x2 =  runif(nn)) 

theta1 &lt;- 0.40; theta2 &lt;- 0.55
drift  &lt;- c(0.5, 0.75)
sdAR   &lt;- c(sqrt(2.5), sqrt(2.0))

# Generate AR sequences, TS1 and TS2, considering Gaussian white noise

# Save both in a data.frame object: the data.
tsdata  &lt;- 
  data.frame(covdata, # Not used 
             TS1 = arima.sim(nn, 
                             model = list(ar = c(theta1, theta1^2)), 
                             rand.gen = rnorm, 
                             mean = drift[1], sd = sdAR[1]),
             TS2 = arima.sim(nn, 
                             model = list(ar = c(theta2, theta2^2)), 
                             rand.gen = rnorm, 
                             mean = drift[2], sd = sdAR[2]))

# 2.1 Fitting both time series with 'ARXff'... multiple responses case.
fit1 &lt;- vglm(cbind(TS1, TS2) ~ 1, 
             ARXff(order = c(2, 2), type.EIM = "exact"), 
             data = tsdata,  
             trace = TRUE)

Coef(fit1)                
coef(fit1, matrix = TRUE)
summary(fit1)

## Same length for both vectors, i.e. no constraints.
length(Coef(fit1))
length(coef(fit1, matrix = TRUE))




###2.2 Now, fit the same models with suitable constraints via 'cm.ARMA()'
# Most importantly, "loglink" is used as link function to adequately match 
# the relationship between coefficients and constraints. That is:
# theta2 = theta1^2, then log(theta2) = 2 * log(theta1).

fit2 &lt;- vglm(cbind(TS1, TS2) ~ 1, 
             ARXff(order = c(2, 2), type.EIM = "exact", lARcoeff = "loglink"), 
             constraints = cm.ARMA(Model = ~ 1, 
                                   Resp = 2,
                                   lags.cm = c(2, 2),
                                   offset  = -2),
             data = tsdata,  
             trace = TRUE)
Coef(fit2)
coef(fit2, matrix = TRUE)
summary(fit2)

# NOTE, for model 1, Coeff2 = Coeff1^2, then log(Coeff2) = 2 * log(Coeff1)
( mycoef &lt;- coef(fit2, matrix = TRUE)[c(3, 4)] )
2 * mycoef[1] - mycoef[2]    # SHOULD BE ZERO

# Ditto for model 2: 
( mycoef &lt;- coef(fit2, matrix = TRUE)[c(7, 8)] )
2 * mycoef[1] - mycoef[2]    # SHOULD BE ZERO

## Different lengths, due to constraints
length(Coef(fit2))
length(coef(fit2, matrix = TRUE))

 




</code></pre>

<hr>
<h2 id='dmultinorm'>Density for the multivariate Normal distribution</h2><span id='topic+dmultinorm'></span>

<h3>Description</h3>

<p>Density for the multivariate Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      dmultinorm(vec.x, vec.mean = c(0, 0),
                 mat.cov = c(1, 1, 0),
                 log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmultinorm_+3A_vec.x">vec.x</code></td>
<td>

<p>For the <code class="reqn">R</code>&ndash;multivariate Normal, an <code class="reqn">R</code>&ndash;vector of 
quantiles.
</p>
</td></tr>
<tr><td><code id="dmultinorm_+3A_vec.mean">vec.mean</code></td>
<td>

<p>The vector of means. 
</p>
</td></tr>
<tr><td><code id="dmultinorm_+3A_mat.cov">mat.cov</code></td>
<td>

<p>The vector of variances and covariances, arranged in that order.
See below for further details.
</p>
</td></tr>
<tr><td><code id="dmultinorm_+3A_log">log</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the logged values are returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of the multivariate (say
<code class="reqn">R</code>&ndash;dimensional) Normal density 
handles the variances and covariances, instead of 
correlation parameters. 
</p>
<p>For more than one observation, arrange all entries in
matrices accordingly.
</p>
<p>For each observation, <code>mat.cov</code> is a vector of
length <code class="reqn">R \times (R + 1) / 2</code>,
where the first <code class="reqn">R</code> entries are the variances
<code class="reqn">\sigma^2{i}</code>, <code class="reqn">i = 1, \ldots, R</code>, and 
then the covariances arranged as per rows, that is,
<code class="reqn">cov_{ij}</code> <code class="reqn">i = 1, \ldots, R,
  j = i + 1, \ldots, R</code>. 
</p>
<p>By default, it returns the density of two independent
standard Normal distributions. 
</p>


<h3>Value</h3>

<p>The density of the multivariate Normal distribution.
</p>


<h3>Warning</h3>

<p>For observations whose covariance matrix is not positive definite,
<code>NaN</code> will be returned.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+binormal">binormal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### Two - dimensional Normal density.
###
set.seed(180228)
nn  &lt;- 25
mean1 &lt;- 1; mean2 &lt;- 1.5; mean3 = 2
var1 &lt;- exp(1.5); var2 &lt;- exp(-1.5); var3 &lt;- exp(1); cov12 = 0.75
dmvndata &lt;- rbinorm(nn, mean1 = 1, mean2 = 1.5, var1 = var1, var2 = var2,
                    cov12 = cov12)

## Using dbinorm() from VGAM.
d2norm.data &lt;- dbinorm(x1 = dmvndata[, 1], x2 = dmvndata[, 2],
                        mean1 = mean1, mean2 = mean2, var1 = var1, var2 = var2,
                        cov12 = cov12)
## Using dmultinorm().
d2norm.data2 &lt;- dmultinorm(vec.x = dmvndata, vec.mean = c(mean1, mean2),
                        mat.cov = c(var1, var2, cov12))
summary(d2norm.data)
summary(d2norm.data2)
##
## 3--dimensional Normal.
##
dmvndata &lt;- cbind(dmvndata, rnorm(nn, mean3, sqrt(var3)))

d2norm.data3 &lt;- dmultinorm(dmvndata, vec.mean = c(mean1, mean2, mean3),
                       mat.cov = c(var1, var2, var3, cov12, 0, 0))

hist(d2norm.data3)
summary(d2norm.data3)

</code></pre>

<hr>
<h2 id='ECM.EngleGran'> VGLTSM family function for the
Two&ndash;dimensional Error&ndash;Correction Model 
(Engle and Granger, 1987) for <code class="reqn">I(1)</code>&ndash;variables</h2><span id='topic+ECM.EngleGran'></span>

<h3>Description</h3>

<p>Estimates a bidimensional error-correction model of
order&ndash;(<code class="reqn">K</code>, <code class="reqn">L</code>), as proposed by Engle&ndash;Granger
(Two step&ndash;approach; 1987), with bivariate normal errors
by maximum likelihood estimation using Fisher scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      ECM.EngleGran(ecm.order = c(1, 1),
                    zero = c("var", "cov"),
                    resids.pattern = c("intercept", "trend",
                                       "neither", "both")[1],
                    lag.res = 1, 
                    lmean = "identitylink",
                    lvar  = "loglink",
                    lcov  = "identitylink",
                    ordtsDyn = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ECM.EngleGran_+3A_ecm.order">ecm.order</code></td>
<td>

<p>Length&ndash;2 (positive) integer vector. The order of the ECM model.
</p>
</td></tr>
<tr><td><code id="ECM.EngleGran_+3A_zero">zero</code></td>
<td>

<p>Integer or character&ndash;string vector.

Details at <code><a href="VGAM.html#topic+zero">zero</a></code>.
</p>
</td></tr>
<tr><td><code id="ECM.EngleGran_+3A_resids.pattern">resids.pattern</code></td>
<td>

<p>Character. How the static linear regression
<code class="reqn">y_{2, t} \sim y_{1, t}</code> must be 
settle to estimate the residuals <code class="reqn">\widehat{z_t}</code>.
The default is a linear model with intercept, and no 
trend term.
See below for details. 
</p>
</td></tr>
<tr><td><code id="ECM.EngleGran_+3A_lag.res">lag.res</code></td>
<td>

<p>Numeric, single positive integer. The error
term for the long&ndash;run equilibrium path is
lagged up to order <code>lag.res</code>. See below
for further details.
</p>
</td></tr>
<tr><td><code id="ECM.EngleGran_+3A_lmean">lmean</code>, <code id="ECM.EngleGran_+3A_lvar">lvar</code>, <code id="ECM.EngleGran_+3A_lcov">lcov</code></td>
<td>

<p>Same as <code><a href="#topic+MVNcov">MVNcov</a></code>.
</p>
</td></tr>
<tr><td><code id="ECM.EngleGran_+3A_ordtsdyn">ordtsDyn</code></td>
<td>

<p>Positive integer. Allows to compare the estimated coefficients with
those provided by the package 'tsDyn'. See below for further details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the two&ndash;step approach as
proposed by Engle&ndash;Granger [1987] to estimate an
order&ndash;(<code class="reqn">K</code>, <code class="reqn">L</code>) bidimensional error correction
model (ECM) with bivariate normal errors. 
</p>
<p>This ECM class models the dynamic behaviour of two 
cointegrated <code class="reqn">I(1)</code>-variables,
say <code class="reqn">y_{1, t}</code> and <code class="reqn">y_{2, t}</code> with,
probably, <code class="reqn">y_{2, t}</code> a function of 
<code class="reqn">y_{1, t}</code>.
Note, the response must be a two&ndash;column matrix,
where the first entry is the regressor,
i.e, <code class="reqn">y_{1, t}</code> above, and the regressand in the
second colum. See Example 2 below.
</p>
<p>The general specification of the ECM class described by 
this family function is
</p>
<p style="text-align: center;"><code class="reqn"> \Delta y_{1, t} |\Phi_{t - 1} =
~\phi_{0, 1} + \gamma_1 \widehat{z}_{t - k} +
 \sum_{i = 1}^K \phi_{1, i} \Delta y_{2, t - i} +
 \sum_{j = 1}^L \phi_{2, j} \Delta y_{1, t - j} +
 \varepsilon_{1, t},</code>
</p>

<p style="text-align: center;"><code class="reqn"> \Delta y_{2, t} |\Phi_{t - 1}=
~\psi_{0, 1} + \gamma_2 \widehat{z}_{t - k} +
 \sum_{i = 1}^K \psi_{1, i} \Delta y_{1, t - i} +
 \sum_{j = 1}^L \psi_{2, j} \Delta y_{2, t - j} +
 \varepsilon_{2, t}.</code>
</p>

<p>Under the binormality assumption on the errors
<code class="reqn">(\varepsilon_{1, t}, \varepsilon_{2, t})^T</code> with covariance matrix <code class="reqn">\boldsymbol{\textrm{V}}</code>,
model above can be seen as a
VGLM fitting linear models over the conditional means,
<code class="reqn">\mu_{\Delta y_{1, t} } = E(\Delta y_{1, t} | \Phi_{t - 1})</code> and
<code class="reqn">\mu_{\Delta y_{2, t} } = E(\Delta y_{2, t} | \Phi_{t - 1} )</code>,
producing
</p>
<p style="text-align: center;"><code class="reqn"> (\Delta y_{1, t} |\Phi_{t - 1} , 
\Delta y_{2, t} |\Phi_{t - 1} )^T \sim N_{2}(\mu_{\Delta y_{1, t}}  , 
\mu_{\Delta y_{2, t}}, \boldsymbol{\textrm{V}})</code>
</p>

<p>The covariance matrix is assumed 
to have elements 
<code class="reqn">\sigma_1^2, \sigma_2^2,</code> and 
<code class="reqn">\textrm{Cov}_{12}.</code>
</p>
<p>Hence, the parameter vector is
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\theta} = 
    (\phi_{0, 1}, \gamma_1, \phi_{1, i}, \phi_{2, j},
                      \psi_{0, 1}, \gamma_2, \psi_{1, i}, \psi_{2, j},
                      \sigma_1^2, \sigma_2^2, \textrm{Cov}_{12})^T,</code>
</p>

<p>for <code class="reqn">i = 1, \ldots, K</code> and <code class="reqn">j = 1, \ldots, L</code>. 
</p>
<p>The linear predictor is
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\eta} = (\mu_{\Delta y_{1, t}  },
                          \mu_{\Delta y_{2, t} },
                          {\color{blue}\texttt{loglink}}~\sigma_1^2,
                          {\color{blue}\texttt{loglink}}~\sigma_2^2,
                          \textrm{Cov}_{12})^T.</code>
</p>

<p>The estimated cointegrated vector,
<code class="reqn">\boldsymbol{\widehat{\beta^{\star}}}</code> = <code class="reqn">(1, -\boldsymbol{\widehat{\beta})}^T</code> is obtained by linear regression
depending upon <code>resids.pattern</code>,
as follows:
</p>
<p>1) <code class="reqn">y_{2, t} = \beta_0 + \beta_1 y_{1, t} + z_t</code>, 
if <code>resids.pattern = "intercept"</code>,
</p>
<p>2) <code class="reqn">y_{2, t} = \beta_1 y_{1, t} + \beta_2 t + z_t</code>, 
if <code>resids.pattern = "trend"</code>,
</p>
<p>3) <code class="reqn">y_{2, t} = \beta_1 y_{1, t} + z_t</code>, 
if <code>resids.pattern = "neither"</code>, or else,
</p>
<p>4) <code class="reqn">y_{2, t} = \beta_0 + \beta_1 y_{1, t} + \beta_2 t + z_t</code>, 
if <code>resids.pattern = "both"</code>,
</p>
<p>where <code class="reqn">\boldsymbol{\widehat{\beta}} = 
(\widehat{\beta_0}, \widehat{\beta_1}, \widehat{\beta_2})^T,</code> and <code class="reqn">z_t</code> assigns the error term.
</p>
<p>Note, the <em>estimated residuals</em>, 
<code class="reqn">\widehat{z_t}</code> are (internally) computed
from any of the linear models 1) &ndash; 4) selected, and then lagged
up to order <code>alg.res</code>,
and embedded as explanatories in models 
<code class="reqn">\Delta y_{1, t} |\Phi_{t - 1}</code> and
<code class="reqn">\Delta y_{3, t} |\Phi_{t - 1}</code> above.
By default, <code class="reqn">\widehat{z}_{t - 1}</code>
are considered (as <code>lag.res</code> = 1), although it may be any lag
<code class="reqn">\widehat{z}_{t - k}</code>, for <code class="reqn">k &gt; 0</code>. 
Change this through argument <code>lag.res</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>) to be
used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Note</h3>

<p>Reduced&ndash;Rank VGLMs  (RR-VGLMs) can be utilized to aid the increasing
number of parameters as <code class="reqn">K</code> and <code class="reqn">L</code> grows.
See <code><a href="VGAM.html#topic+rrvglm">rrvglm</a></code>.
</p>
<p>By default, <code class="reqn">\sigma_1^2, \sigma_2^2</code> and  <code class="reqn">\textrm{Cov}_{12}</code>
are intercept&ndash;only. Set argument <code>zero</code> accordingly to change this.
</p>
<p>Package <span class="pkg">tsDyn</span> also has routines to fit ECMs.
However, the bivariate&ndash;ECM handled (similar to that one 
above) differs in their parametrization:
<span class="pkg">tsDyn</span> considers the <em>current</em> estimated residual,
<code class="reqn">\widehat{z}_t</code> instead of 
<code class="reqn">\widehat{z}_{t - 1}</code> in models
<code class="reqn">\Delta y_{1, t} |\Phi_{t - 1}</code> and
<code class="reqn">\Delta y_{2, t} |\Phi_{t - 1}</code>.
</p>
<p>See Example 3 below which compares ECMs
fitted with <span class="pkg">VGAMextra</span> and <span class="pkg">tsDyn</span>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda
</p>


<h3>References</h3>

<p>Engle, R.F. and Granger C.W.J. (1987)
Co-integration and error correction: Representation, estimation and
testing.
<em>Econometrica</em>, <span class="pkg">55</span>(2), 251&ndash;276.
</p>
<p>Pfaff, B. (2011)
<em>Analysis of Integrated and Cointegrated Time Series with <code>R</code>.</em>
Seattle, Washington, USA: <em>Springer</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MVNcov">MVNcov</a></code>,
<code><a href="VGAM.html#topic+rrvglm">rrvglm</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1. Comparing the Engle -- Granger procedure carried oud by two procedures.
##            ECM.EngleGran() makes easier the fitting process.
## Here, we will use:
## A) The R code 4.2, in Chapter 4, Pfaff (2011).
##    This code 1) generates artificial data and 2) fits an ECM, following
##    the Engle --Granger procedure. 
## B) The ECM.EngleGran() family function to fit the same model assuming
##    bivariate normal innovations. 
## The downside in the R code 4.2 is the assumption of no--correlation among
## the errors. These are generated indenpendently.
## A)
## STEP 1. Set up the data (R code as in Pfaff (2011)).
nn &lt;- 100
set.seed(123456)
e1 &lt;- rnorm(nn)   # Independent of e2
e2 &lt;- rnorm(nn)
y1 &lt;-  cumsum(e1)
y2 &lt;- 0.6 * y1 + e2
lr.reg &lt;- lm(y2 ~ y1)
error &lt;- residuals(lr.reg)
error.lagged &lt;- error[-c(nn - 1, nn)]
dy1 &lt;- diff(y1)
dy2 &lt;- diff(y2)
diff.dat &lt;- data.frame(embed(cbind(dy1, dy2), 2))
colnames(diff.dat) &lt;- c('dy1', 'dy2', 'dy1.1', 'dy2.1')

##  STEP 2. Fit the ECM model, using lm(), R code as in Pfaff (2011).
ecm.reg &lt;- lm(dy2 ~ error.lagged + dy1.1 + dy2.1, data = diff.dat)

summary(ecm.reg)


## B) Now, using ECM.EngleGran() and VGLMs, the steps at A) can be skipped. 
## Enter the I(1)--variables in the response vector only, putting down the
## the dependent variable from the I(1) set, i.e. y2, in the second column.

coint.data &lt;- data.frame(y1 = y1, y2 = y2)
fit.ECM &lt;- vglm(cbind(y1, y2) ~ 1, ECM.EngleGran, data = coint.data, trace = TRUE)

## Check coefficients ##
coef(fit.ECM, matrix = TRUE)  ## Compare 'Diff2' with summary(ecm.reg)
coef(summary(ecm.reg))

head(depvar(fit.ECM))   # The estimated differences (first order)
vcov(fit.ECM)
constraints(fit.ECM, matrix = TRUE)

## Not run: 
### Example 2.  Here, we compare ECM.EngleGran() from VGAMextra with VECM() from
##              package "tsDyn" when fitting an ECM(1, 1). We will make use of
##              the argument 'ordtsDyn' so that the outcomes can be compared.

library("tsDyn")  # Need to be installed first.
fit.tsDyn1 &lt;- with(coint.data, VECM(cbind(y2, y1), lag = 1, estim = "2OLS")) #  MODEL 1
summary(fit.tsDyn1)

### Fit same model using ECM.EngleGran(). NOTE: Set ordtsDyn = 1 !!          #  MODEL 2
fit.ECM.2 &lt;- vglm(cbind(y1, y2) ~ 1, ECM.EngleGran(ecm.order = c(1, 1),
                  resids.pattern = "neither", ordtsDyn = 1),
                  data = coint.data, trace = TRUE)

coef.ECM.2 &lt;- coef(fit.ECM.2, matrix = TRUE)
fit.tsDyn1$coefficients                      ## From pakage 'tsDyn'.
t(coef.ECM.2[, 1:2][c(2, 1, 4, 3), ][, 2:1]) ## FROM VGAMextra 


### Example 3. An ECM(2, 2), with residuals estimated by OLS, with NO intercept
###            and NO trend term. The data set is 'zeroyld', from package tsDyn.
###            ECM.EngleGran() and with VECM() willbe compared again.
data(zeroyld, package = "tsDyn")

# Fit a VECM with Engle-Granger 2OLS estimator:
vecm.eg &lt;- VECM(zeroyld, lag=2, estim = "2OLS") 
summary(vecm.eg)

# For the same data, fit a VECM with ECM.EngleGran(), from VGAMextra.
# Set ordtsDyn = 1 for compatibility! 
fit.ECM.3 &lt;- vglm(cbind(long.run, short.run) ~ 1, ECM.EngleGran(ecm.order = c(2, 2),
                                  resids.pattern = "neither", ordtsDyn = 1),
                  data = zeroyld, trace = TRUE)
coef.ECM.3 &lt;- coef(fit.ECM.3, matrix = TRUE)

#### Compare results
vecm.eg$coefficients                               # From tsDyn
t(coef.ECM.3[, 1:2][c(2, 1, 5, 3, 6, 4 ),][, 2:1]) # FROM VGAMextra

## End(Not run)
</code></pre>

<hr>
<h2 id='expMlink'>
Link functions for the mean of 1&ndash;parameter 
continuous distributions: The exponential distribution.
</h2><span id='topic+expMeanlink'></span><span id='topic+expMlink'></span>

<h3>Description</h3>


<p>Computes the <code>expMlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>         expMlink(theta, location = 0, bvalue = NULL, inverse = FALSE,
                  deriv = 0, short = TRUE, tag = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> although may 
be <code class="reqn">\eta</code> depending on the other parameters.
See below for further details.
</p>
</td></tr>
<tr><td><code id="expMlink_+3A_location">location</code></td>
<td>

<p>This is a known location parameter.
Same as <code>location</code> in <code><a href="VGAM.html#topic+exponential">exponential</a></code>.
</p>
</td></tr>
<tr><td><code id="expMlink_+3A_bvalue">bvalue</code>, <code id="expMlink_+3A_inverse">inverse</code>, <code id="expMlink_+3A_deriv">deriv</code>, <code id="expMlink_+3A_short">short</code>, <code id="expMlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a link function to model the mean of the exponential 
distribution, <code><a href="VGAM.html#topic+exponential">exponential</a></code>. 
It is defined as

</p>
<p style="text-align: center;"><code class="reqn">\eta = \log (A + \lambda^{-1}), </code>
</p>


<p>where <code class="reqn">\lambda &gt; 0</code> is a rate parameter and <code class="reqn">A</code> is a 
known location parameter, 
same as <code><a href="VGAM.html#topic+exponential">exponential</a></code>.
</p>
<p>Numerical values of <code class="reqn">\lambda</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>expMlink</code> transformation of
<code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then the inverse <code>exp(theta - A)^(-1)</code>.
</p>
<p>For <code>deriv = 1</code>,
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of 
<code>theta</code>.
</p>
<p>Similarly, when <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are returned.
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+exponential">exponential</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ##  E1. Modelling the mean of the exponential distribution  ##
    set.seed(17010402)
    nn &lt;- 100
    edata &lt;- data.frame(x2 = runif(nn) - 0.5, x3 = runif(nn) - 0.5)
    edata &lt;- transform(edata, eta = 0.2 - 0.7 * x2 + 1.9 * x3)
    
            #----- The mean is a function of 'x2' and 'x3' ------#
    edata &lt;- transform(edata, rate = expMlink(eta, inverse = TRUE))
    
    edata &lt;- transform(edata, y = rexp(nn, rate = rate))
    with(edata, stem(y))
    with(edata, hist(y))

    exp.fit &lt;- vglm(y ~ x2 + x3, exponential(link = "expMlink"), 
                    data = edata, zero = NULL, trace = TRUE, crit = "log")
   coef(exp.fit, matrix = TRUE)
   summary(exp.fit)
 
 ## E2. expMlink() and its inverse ##
    theta &lt;- 0.1 + 1:5
    location &lt;- 1.5
    my.diff &lt;- theta - expMlink(expMlink(theta = theta, 
                  location = location), location = location, inverse  =TRUE)
    summary(my.diff)     # Zero


  ## E3. Special values in a matrix ##
    theta &lt;- matrix(c(Inf, -Inf, NA, NaN, 1 , 2), ncol = 3, nrow = 2)
    expMlink(theta = theta, location = location)
</code></pre>

<hr>
<h2 id='expQlink'>
Link functions for the quantiles of several 1&ndash;parameter 
continuous distributions. 
</h2><span id='topic+expQlink'></span>

<h3>Description</h3>


<p>Computes the <code>expQlink</code> transformation, its inverse and
the first two derivatives.






</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expQlink(theta, p = stop("Argument 'p' must be entered."),
           bvalue = NULL, inverse = FALSE,
           deriv = 0, short = TRUE, tag = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> although may 
be <code class="reqn">\eta</code> depending on the other parameters.
See below for further details.
</p>
</td></tr>
<tr><td><code id="expQlink_+3A_p">p</code></td>
<td>

<p>Numeric. A prespecified number between 0 and 1.
The particular <code class="reqn">p</code>&ndash;quantile to be modelled.
For example, <code class="reqn">p = 0.5</code> means that the median is considered 
by this link function.
</p>
</td></tr>
<tr><td><code id="expQlink_+3A_bvalue">bvalue</code>, <code id="expQlink_+3A_inverse">inverse</code>, <code id="expQlink_+3A_deriv">deriv</code>, <code id="expQlink_+3A_short">short</code>, <code id="expQlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a link function to model any fixed quantile, say 
<code class="reqn">\xi_p</code>, of the exponential distribution.
It is called the <code>expQlink</code> transformation and is defined as

</p>
<p style="text-align: center;"><code class="reqn"> \log (1 - p)^{-1/\lambda},</code>
</p>


<p>where <code class="reqn">\lambda</code> is positive as in 
<code><a href="VGAM.html#topic+exponential">exponential</a></code>.
</p>
<p>Numerical values of <code class="reqn">\lambda</code> or <code class="reqn">p</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>With <code>deriv = 0</code>, the <code>expQlink</code> transformation of
<code>theta</code> for prespecified <code class="reqn">p</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then the inverse <code>-log(1 - p)/theta</code>.
</p>
<p>For <code>deriv = 1</code>, this link function returns
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of 
<code>theta</code>.
</p>
<p>Similarly, when <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are returned.
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+exponential">exponential</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## E1. expQlink() and its inverse ##
    p &lt;- 0.25            # Modelling the first quartile.
    my.theta &lt;- seq(0, 5, by = 0.1)[-1]
    my.diff &lt;- my.theta - expQlink(expQlink(my.theta, p = p), p = p, inverse  =TRUE)
    summary(my.diff)     # Zero


  ## E2. Special values ##
    expQlink(theta = c(Inf, -Inf, NA, NaN), p = p)
    

  ##  E3. Plot of expQlink() for different quantiles  ##
    plot(expQlink(my.theta, p = p) ~ my.theta, 
         type = "l", lty = "dotted", col = "blue", lwd = 2,
         main = "expQink(p) transformation", xlab = "theta", ylab = "expQLink",
         xlim = c(-0.5, 5), ylim = c(-0.5, 5))
    abline(h = 0, v = 0, lwd = 2)
    lines(my.theta, expQlink(my.theta, p = 0.50),  col = "green", lty = "dotted", lwd = 2)
    lines(my.theta, expQlink(my.theta, p = 0.75),  col = "red", lty = "dotted", lwd = 2)
    legend(2, 4,  c("p = 0.25", "p = 0.50", "p = 0.75"), col = c("blue", "green", "red"),
           lwd = c(2, 2, 2), lty = c("dotted", "dotted", "dotted"))
  
</code></pre>

<hr>
<h2 id='gamma1Qlink'>
Link functions for the quantiles of several 1&ndash;parameter continuous
distributions
</h2><span id='topic+gamma1Qlink'></span>

<h3>Description</h3>

<p>Computes the <code>gamma1Qlink</code> transformation, its inverse and the
first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gamma1Qlink(theta, p = stop("Argument 'p' must be specified."),
               bvalue = NULL, inverse = FALSE,
               deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma1Qlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. It is <code class="reqn">\theta</code> by default although
it could be <code class="reqn">\eta</code> depending upon other arguments. 
See <code><a href="VGAM.html#topic+Links">Links</a></code> for further details about this.
</p>
</td></tr>
<tr><td><code id="gamma1Qlink_+3A_p">p</code></td>
<td>

<p>A numeric vector of <code class="reqn">p</code>&ndash;quantiles (numbers between 0 and 1) 
to be modeled by this link function. 
</p>
</td></tr>
<tr><td><code id="gamma1Qlink_+3A_bvalue">bvalue</code>, <code id="gamma1Qlink_+3A_inverse">inverse</code>, <code id="gamma1Qlink_+3A_deriv">deriv</code>, <code id="gamma1Qlink_+3A_short">short</code>, <code id="gamma1Qlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This link function has been specifically designed to model any 
<code class="reqn">p</code>&ndash;quantile of the 1&ndash;parameter gamma distribution, 
<code><a href="VGAM.html#topic+gamma1">gamma1</a></code>, in the VGLM/VGAM context. 
It is defined as

</p>
<p style="text-align: center;"><code class="reqn">\eta = \log {\tt{qgamma}}({\tt{p}}, {\tt{shape =}} s),</code>
</p>


<p>where <code class="reqn">s</code> is a positive shape parameter as in 
<code><a href="VGAM.html#topic+gamma1">gamma1</a></code>, whilst
<code class="reqn">{\tt{qgamma()}}</code> is the quantile function 
<code><a href="stats.html#topic+qgamma">qgamma</a></code>.




</p>
<p>The inverse of the <code>gamma1Qlink</code> cannot be expressed in closed
form. Instead, the inverse image, <code class="reqn">s_{\eta}</code>,
of <code class="reqn">\eta</code> is numerically approximated by 
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code>.
</p>
<p>Numerical values of <code class="reqn">s</code> or <code class="reqn">p</code> out of range will 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>
correspondingly.
</p>
<p>Arguments <code>inverse</code> and <code>deriv</code> are dismissed
if <code>theta</code> is character.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>gamma1Qlink</code> transformation of
<code>theta</code>, when <code>inverse = FALSE</code>. 
If <code>inverse = TRUE</code>, then
<code>theta</code> becomes <code class="reqn">\eta</code>, and therefore,
the approximate inverse image of <code class="reqn">\eta</code> is returned.
</p>
<p>For <code>deriv = 1</code>, the partial derivative 
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code> is returned, 
if <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, 
then the reciprocal 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of <code>theta</code>.
</p>
<p>If <code>deriv = 2</code>, then the second order derivatives as a function
of <code>theta</code>. 
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too large, or
too close to 0.0. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+gamma1">gamma1</a></code>, 
<code><a href="stats.html#topic+qgamma">qgamma</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## E1. gamma1QLink() and values causing NaNs or out of range  ##
  
  p &lt;- 0.75                            # The third quartile is of interest.
  my.s &lt;- seq(0, 5, by = 0.1)[-1]
  
  max(my.s - gamma1Qlink(gamma1Qlink(my.s, p = p), p = p, inverse  =TRUE)) ## Zero
  
  ## E2. Special values of theta ##
  gamma1Qlink(theta = c(-0.15, -0.10, 0, 1:10) , p = p, inverse  = FALSE)  ## NaNs
  gamma1Qlink(theta = c(-5, -3, 0, 1:10) , p = p, inverse  = TRUE)         ## Out of range
   
   
  ## E3. Plot of gamma1QLink() and its inverse. ##
  
  
    # gamma1Qlink()
    plot(gamma1Qlink(theta = my.s, p = p) ~ my.s,
         type = "l", col = "blue", lty = "dotted", lwd = 3,
         xlim = c(-0.1, 5), ylim = c(-5, 15), las = 1,
         main = c("Blue is gamma1Qlink(), green is the inverse"),
         ylab = "gamma1Qlink transformation", xlab = "theta")
     abline(h = 0, v = 0, lwd = 2)

     # The inverse
     lines(my.s, gamma1Qlink(theta = my.s, p = p, inverse = TRUE),
           col = "green", lwd = 2, lty = "dashed")
           
      # The identity function, for double-checking.
     lines(my.s, my.s, lty = "dotted")
  
</code></pre>

<hr>
<h2 id='gammaRff'>
2&ndash;parameter Gamma Distribution
</h2><span id='topic+gammaRff'></span>

<h3>Description</h3>


<p>Estimates the 2&ndash;parameter gamma distribution by maximum likelihood.
One linear predictor models the mean.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>        gammaRff(zero = "shape", lmu = "gammaRMlink",
                 lrate = NULL, lshape = "loglink",
                  irate = NULL,   ishape = NULL, lss = TRUE)
                       
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaRff_+3A_zero">zero</code></td>
<td>

<p>Specifies the parameters to be modelled as intercept&ndash;only.
</p>
<p>See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr><td><code id="gammaRff_+3A_lmu">lmu</code></td>
<td>

<p>The link function applied to the gamma distribution mean, i.e.,
<code><a href="#topic+gammaRMlink">gammaRMlink</a></code>.
</p>
</td></tr>
<tr><td><code id="gammaRff_+3A_lrate">lrate</code>, <code id="gammaRff_+3A_lshape">lshape</code>, <code id="gammaRff_+3A_irate">irate</code>, <code id="gammaRff_+3A_ishape">ishape</code>, <code id="gammaRff_+3A_lss">lss</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+gammaR">gammaR</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This family function slightly enlarges the functionalities of 
<code><a href="VGAM.html#topic+gammaR">gammaR</a></code> by directly modelling the mean
of the gamma distribution. It performs very much like
<code><a href="VGAM.html#topic+gamma2">gamma2</a></code>, but involves the ordinary 
(not reparametrized) density, given by

</p>
<p style="text-align: center;"><code class="reqn">f(y; \alpha, \beta) = \frac{ \beta^\alpha }{ \Gamma(\alpha) } 
         e^{-\beta y} y^{\alpha - 1},</code>
</p>


<p>Here, <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are positive shape
and rate parameters as in <code><a href="VGAM.html#topic+gammaR">gammaR</a></code>.


The default linear predictors are 
<code class="reqn">\eta1 = {\tt{gammaRMlink}}(\alpha; \beta) = \log \mu =
  \log (\alpha / \beta)</code>, and
<code class="reqn">\eta2 = \log \alpha</code>,
unlike <code class="reqn">\eta1 = \log \beta</code> and
<code class="reqn">\eta2 = \log \alpha</code>
from <code><a href="VGAM.html#topic+gammaR">gammaR</a></code>.







</p>
<p><code>lmu</code> overrides <code>lrate</code> and no link other than
<code><a href="#topic+gammaRMlink">gammaRMlink</a></code> is a valid entry
(<code>lmu</code>). To
mimic <code><a href="VGAM.html#topic+gammaR">gammaR</a></code> simply
set <code>lmu = NULL</code> and <code>lrate = "loglink"</code>.
The mean (<code class="reqn">\mu</code>) is returned as the fitted values.
</p>




<p><code>gammaRff</code> differs from
<code><a href="VGAM.html#topic+gamma2">gamma2</a></code>. The latter estimates a
re-parametrization
of the gamma distribution in terms <code class="reqn">\mu</code> and
<code class="reqn">\alpha</code>. 
This <b>VGAM</b> family function does not handle censored data.








</p>


<h3>Value</h3>

<p>An object of class <code>"vglm"</code>.
See <code><a href="VGAM.html#topic+vglm-class">vglm-class</a></code> for full details.
</p>


<h3>Note</h3>



<p>The parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
match the arguments <code>shape</code> and <code class="reqn">rate</code> of
<code><a href="stats.html#topic+rgamma">rgamma</a></code>.
</p>
<p>Multiple responses are handled.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Yee, T. W. (2015)
<em>Vector Generalized Linear and Additive Models: 
With an Implementation in R</em>. 
Springer, New York, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammaRMlink">gammaRMlink</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+gammaR">gammaR</a></code>,
<code><a href="VGAM.html#topic+gamma2">gamma2</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  ### Modelling the mean in terms of x2, two responses.
  
    set.seed(2017022101)
    nn &lt;- 80
    x2 &lt;- runif(nn)
    mu &lt;- exp(2 + 0.5 * x2)
  
  # Shape and rate parameters in terms of 'mu'
    shape &lt;- rep(exp(1), nn)
    rate &lt;- gammaRMlink(theta = log(mu), shape = shape,
                            inverse = TRUE, deriv = 0)
  
  # Generating some random data
    y1 &lt;- rgamma(n = nn, shape = shape, rate =  rate)
    gdata &lt;- data.frame(x2 = x2, y1 = y1)
    rm(y1)

  # lmu = "gammaRMlink" replaces lshape, whilst lrate = "loglink"
    fit1 &lt;- vglm(cbind(y1, y1) ~ x2,
                 gammaRff(lmu = "gammaRMlink", lss = TRUE, zero = "shape"),
                 data = gdata, trace = TRUE, crit = "log")
     coef(fit1, matrix = TRUE)
     summary(fit1)
    
  # Comparing fitted values with true values.
    compare1 &lt;- cbind(fitted.values(fit1)[, 1, drop = FALSE], mu)
    colnames(compare1) &lt;- c("Fitted.vM1", "mu")
    head(compare1)
 
  
  ### Mimicking gammaR. Note that lmu = NULL.
    fit2 &lt;- vglm(y1 ~ x2, gammaRff(lmu = NULL, lrate = "loglink",
                            lshape = "loglink", lss = FALSE, zero = "shape"),
                 data = gdata, trace = TRUE, crit = "log")
 
  # Compare fitted values with true values.
    compare2 &lt;- with(gdata, cbind(fitted.values(fit2), y1, mu))
    colnames(compare2) &lt;- c("Fitted.vM2", "y", "mu")
    head(compare2)
 
    
  ### Fitted values -- Model1 vs Fitted values -- Model2
    fit1vsfit2 &lt;- cbind(fitted.values(fit1)[, 1, drop = FALSE], 
                        fitted.values(fit2))
    colnames(fit1vsfit2) &lt;- c("Fitted.vM1", "Fitted.vM2")
    head(fit1vsfit2)

  ### Use gamma2()
     fit3 &lt;- vglm(y1 ~ x2, gamma2,
                 data = gdata, trace = TRUE, crit = "log")
    fit1.fit3 &lt;- cbind(fitted.values(fit1)[, 1, drop = FALSE], 
                        fitted.values(fit2), fitted.values(fit3))
    colnames(fit1.fit3) &lt;- c("Fitted.vM1", "Fitted.vM2", "Fitted.vM3")
    head(fit1.fit3)
</code></pre>

<hr>
<h2 id='gammaRMlink'>
Link functions for the mean of 2&ndash;parameter 
continuous distributions: The gamma distribution.
</h2><span id='topic+gammaRMlink'></span><span id='topic+gammaRMeanlink'></span>

<h3>Description</h3>


<p>Computes the <code>gammaRMlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>        gammaRMlink(theta, shape = NULL, wrt.param = NULL,
                    bvalue = NULL, inverse = FALSE,
                    deriv = 0, short = TRUE, tag = FALSE)
                       
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaRMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code>
('rate' parameter) but iy may 
be <code class="reqn">\eta</code> depending on the other parameters.
See below for further details.
</p>
</td></tr>
<tr><td><code id="gammaRMlink_+3A_shape">shape</code></td>
<td>

<p>The shape parameter. Same as
<code><a href="#topic+gammaRff">gammaRff</a></code>.
</p>
</td></tr>
<tr><td><code id="gammaRMlink_+3A_wrt.param">wrt.param</code></td>
<td>

<p>Positive integer, either <code class="reqn">1</code> or <code class="reqn">2</code>. The partial derivatives
are computed with respect to one of the two linear predictors 
involved with this link. Further details listed below.
</p>
</td></tr>
<tr><td><code id="gammaRMlink_+3A_bvalue">bvalue</code>, <code id="gammaRMlink_+3A_inverse">inverse</code>, <code id="gammaRMlink_+3A_deriv">deriv</code>, <code id="gammaRMlink_+3A_short">short</code>, <code id="gammaRMlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The link to model the mean of the 2&ndash;parameter
gamma distribution.
</p>
<p>The <code>gammaRMlink</code> transformation, <em>for given</em>
<code class="reqn">\alpha</code> ('shape' parameter),
is defined as

</p>
<p style="text-align: center;"><code class="reqn"> \eta = \eta(\alpha; \beta) = \log \frac{\alpha}{\beta},</code>
</p>


<p>where <code class="reqn">\beta &gt; 0</code> is a <em>rate</em> parameter. 





This link is expressly a function of <code class="reqn">\beta</code>, i.e.
<code class="reqn">\theta</code>, therefore <code class="reqn">\alpha</code> (<em>shape</em>)
must be entered at every call.
</p>
<p>Numerical values of <code class="reqn">\alpha</code> or <code class="reqn">\beta</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>gammaRMlink</code> transformation of
<code>theta</code>, i.e. <code class="reqn">\beta</code>, when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then <code class="reqn">\theta</code> becomes <code class="reqn">\eta</code>,
and the inverse,
<code class="reqn">\alpha</code> * <code>exp(-theta)</code>, <em>for given</em> <code class="reqn">\alpha</code>, is
returned.
</p>
<p>For <code>deriv = 1</code>, <code>theta</code> becomes 
<code class="reqn">\theta = (\beta, \alpha)=</code><code class="reqn">(\theta1, \theta2)</code>, and
<code class="reqn">\eta = (\eta1, \eta2)</code>,
and then, the argument <code>wrt.param</code> must be
considered:
</p>
<p>A) If <code>inverse = FALSE</code>, then 
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code>theta1</code> when 
<code>wrt.param = 1</code>, and
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code>theta2</code> if
<code>wrt.param = 2</code>.
</p>
<p>B) For <code>inverse = TRUE</code>, this function returns
<code class="reqn">d</code> <code>theta1</code> / <code class="reqn">d</code> <code>eta1</code> and
<code class="reqn">d</code> <code>theta2</code> / <code class="reqn">d</code> <code>eta1</code> conformably arranged
in a matrix, if <code>wrt.param = 1</code>,
as a function of <code class="reqn">\theta_i</code>, <code class="reqn">i = 1, 2</code>.
Also, when <code>wrt.param = 2</code>, a matrix with columns
<code class="reqn">d</code><code>theta1</code> / <code class="reqn">d</code> <code>eta2</code> and 
<code class="reqn">d</code><code>theta2</code> / <code class="reqn">d</code> <code>eta2</code>
is returned.







</p>
<p>Similarly, when <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are returned.
</p>




<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammaRff">gammaRff</a></code>,
<code><a href="VGAM.html#topic+gammaR">gammaR</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
    eta &lt;- seq(-3, 3, by = 0.1) # this is eta = log(mu(b, a)).
    shape  &lt;- rep(exp(0.8), length(eta))    # 'shape' argument.
 
 ## E1. Get 'rate' values.
   theta &lt;- gammaRMlink(theta = eta, shape = shape, inverse = TRUE)  # rate
   
 ## Not run: 
 ## E2. Plot theta vs. eta, 'shape' fixed.
   plot(theta, eta, type = "l", las = 1, ylab = "", 
   main = "gammaRMlink(theta; shape)")
 
## End(Not run)
 
 ## E3. gammaRMlink() and its inverse ##
    etabis  &lt;- gammaRMlink(theta = theta, shape = shape, inverse = FALSE)
    my.diff &lt;- eta - etabis
    summary(my.diff)     # Zero
    
  ## E4. Special values arranged in a matrix ##
    bbeta &lt;- matrix(eta[1:9], ncol = 3, nrow = 3)  #Ensure equal dimensions. 
    alpha &lt;- matrix(c(Inf, -Inf, NA, NaN, -1 , 1, 0, -2, 2), ncol = 3, nrow = 3)
    # The gammaRMlink transformation (log(a/b))
    gammaRMlink(theta = bbeta, shape = alpha, inv = FALSE)   # NaNs produced.
    # Same as
    log(alpha/bbeta)
    
</code></pre>

<hr>
<h2 id='gen.betaIImr'> Generalized Beta Distribution of the Second Kind family function </h2><span id='topic+gen.betaIImr'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the 4-parameter 
generalized beta II distribution using Fisher scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> gen.betaIImr(lscale    = "loglink", 
              lshape1.a = "loglink", 
              lshape2.p = "loglink", 
              lshape3.q = "loglink", 
              iscale    = NULL, 
              ishape1.a = NULL,
              ishape2.p = NULL, 
              ishape3.q = NULL, 
              imethod   = 1,
              lss       = TRUE, 
              gscale    = exp(-5:5), 
              gshape1.a = exp(-5:5),
              gshape2.p = exp(-5:5), 
              gshape3.q = exp(-5:5), 
              probs.y   = c(0.25, 0.50, 0.75),
              zero      = "shape" )            
 </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.betaIImr_+3A_lscale">lscale</code>, <code id="gen.betaIImr_+3A_lshape1.a">lshape1.a</code>, <code id="gen.betaIImr_+3A_lshape2.p">lshape2.p</code>, <code id="gen.betaIImr_+3A_lshape3.q">lshape3.q</code></td>
<td>

<p>Parameter link functions applied to the 
shape parameter <code>a</code>,
scale parameter <code>scale</code>,
shape parameter <code>p</code>, and
shape parameter <code>q</code>.
All four parameters are positive.
See <code><a href="VGAM.html#topic+Links">Links</a></code> for more choices.
</p>
</td></tr>
<tr><td><code id="gen.betaIImr_+3A_iscale">iscale</code>, <code id="gen.betaIImr_+3A_ishape1.a">ishape1.a</code>, <code id="gen.betaIImr_+3A_ishape2.p">ishape2.p</code>, <code id="gen.betaIImr_+3A_ishape3.q">ishape3.q</code></td>
<td>

<p>Optional initial values for <code>b</code>, <code>a</code>, <code>p</code> and <code>q</code>.
Default is <code>NULL</code> for all of them, meaning initial values are 
computed internally.
</p>
</td></tr>
<tr><td><code id="gen.betaIImr_+3A_imethod">imethod</code></td>
<td>

<p>Initializing method to internally compute the initial values.
Currently, only <code>method = 1</code> is handled.
</p>
</td></tr>
<tr><td><code id="gen.betaIImr_+3A_gscale">gscale</code>, <code id="gen.betaIImr_+3A_gshape1.a">gshape1.a</code>, <code id="gen.betaIImr_+3A_gshape2.p">gshape2.p</code>, <code id="gen.betaIImr_+3A_gshape3.q">gshape3.q</code></td>
<td>

<p>Grid search initial values.
See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>
for further information.
</p>
</td></tr>
<tr><td><code id="gen.betaIImr_+3A_zero">zero</code></td>
<td>

<p>Numeric or Character vector. Position(s) or name(s) of the 
parameters/linear predictors to be modeled as intercept-only.
Details at 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.


</p>
</td></tr>
<tr><td><code id="gen.betaIImr_+3A_lss">lss</code>, <code id="gen.betaIImr_+3A_probs.y">probs.y</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> 
for fuller details.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This distribution is most useful for unifying a substantial
number of size distributions. For example, the Singh-Maddala,
Dagum, Fisk (log-logistic), Lomax (Pareto type II),
inverse Lomax, beta distribution of the second kind
distributions are all special cases.
Full details can be found in Kleiber and Kotz (2003), and
Brazauskas (2002). The argument names given here are used 
by other families that are special cases of this family.
Fisher scoring is used here and for the special cases too.
</p>
<p>The 4-parameter generalized beta II distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(y) = a y^{ap-1} / [b^{ap} B(p,q) \{1 + (y/b)^a\}^{p+q}]</code>
</p>

<p>for <code class="reqn">a &gt; 0</code>, <code class="reqn">b &gt; 0</code>, <code class="reqn">p &gt; 0</code>, <code class="reqn">q &gt; 0</code>, 
<code class="reqn">y \geq 0</code>.
Here <code class="reqn">B</code> is the beta function, and 
<code class="reqn">b</code> is the scale parameter <code>scale</code>,
while the others are shape parameters.
The mean is 
</p>
<p style="text-align: center;"><code class="reqn">E(Y) = b \, \Gamma(p + 1/a) \, \Gamma(q - 1/a) / 
                                (\Gamma(p) \, \Gamma(q))</code>
</p>

<p>provided <code class="reqn">-ap &lt; 1 &lt; aq</code>; these are returned as the fitted values.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>).
The object is used by modelling functions such as 
<code><a href="VGAM.html#topic+vglm">vglm</a></code>,
and <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Warning</h3>

<p><code>zero</code> can be a <b>numeric</b> or a <b>character</b> vector 
specifying the position(s) or the name(s) (partially or not) of the linear 
predictors modeled as intercept&ndash;only. Numeric values can be 
entered as usual. If names are used, note that the linear predictors in 
this family function are
</p>
<p><code>c("scale", "shape1.a", "shape2.p", "shape3.q")</code>.
</p>
<p>For simplicity, using names rather than numeric vectors is 
recommended.
</p>


<h3>Note</h3>

<p>Paramaters <code>"shape1.a", "shape2.p", "shape3.q"</code> are modeled 
as intercept only, by default.
</p>
<p>If the self-starting initial values fail, try experimenting
with the initial value arguments, <code>iscale</code>, <code>ishape1.a</code>,
<code>ishape2.p</code> and <code>ishape3.q</code> whose default is <code>NULL</code>.
Also, the constraint <code class="reqn">-ap &lt; 1 &lt; aq</code> may be violated as the 
iterations progress so it is worth monitoring convergence, e.g., 
set <code>trace = TRUE</code>.
</p>
<p>Successful convergence depends on choosing good initial values. This 
process might be difficult for this distribution, since 4 parameters are 
involved. Presently, only <code>method = 1</code> is internally handled to set 
initial values. It involves <em>grid search</em>, an internal implementation 
of the well-known grid search algorithm for exhaustive searching through 
a manually specified subset of the hyperparameter space.
</p>
<p>Default value of <code>lss</code> is <code>TRUE</code> standing for the 
following order: location (b), shape1.a (a), shape2.p (p), 
shape3.q (q). In order to match the arguments of existing R functions, 
the option <code>lss = FALSE</code> might be set leading to switch the 
position of location (b) and shape1.a (a), only.
</p>


<h3>Author(s)</h3>

<p> T. W. Yee and V. Miranda.</p>


<h3>References</h3>

<p>Brazauskas, V. (2002)
Fisher information matrix for the Feller-Pareto distribution.
<em>Statistics &amp; Probability Letters</em>, 
<b>59</b>, 159&ndash;167.
</p>
<p>Kleiber, C. and Kotz, S. (2003) 
<em>Statistical Size Distributions in Economics and Actuarial Sciences</em>.
Wiley Series in Probability and Statistics. 
Hoboken, New Jersey, USA.
</p>
<p>McDonald, J. B. and Xu, Y. J. (1995)
A generalization of the beta distribution with applications.
<em>Journal of Econometrics</em>. 
<b>66</b>, p.133&ndash;152.
</p>
<p>McDonald, J. B. (1984)
Some generalized functions for the size distribution of income.
<em>Econometrica</em>, 
<b>52</b>, 647&ndash;663.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+betaff">betaff</a></code>,
<code><a href="VGAM.html#topic+betaII">betaII</a></code>,
<code><a href="VGAM.html#topic+dagum">dagum</a></code>,
<code><a href="VGAM.html#topic+sinmad">sinmad</a></code>,
<code><a href="VGAM.html#topic+fisk">fisk</a></code>,
<code><a href="VGAM.html#topic+lomax">lomax</a></code>,
<code><a href="VGAM.html#topic+inv.lomax">inv.lomax</a></code>,
<code><a href="VGAM.html#topic+paralogistic">paralogistic</a></code>,
<code><a href="VGAM.html#topic+inv.paralogistic">inv.paralogistic</a></code>,

<code><a href="VGAM.html#topic+genbetaII">genbetaII</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------------------------------------- #
# An example.- In this data set parameters 'shape1.a' and 'shape3.q' are 
# generated in terms of x2.

set.seed(1003)
nn &lt;- 200
gdata1  &lt;- data.frame(x2 = runif(nn))
gdata   &lt;- transform(gdata1,
           y1 = rgen.betaII(nn, scale = exp(1.1), shape1.a = exp(1.2 + x2), 
                            shape2.p = exp(0.7) , shape3.q = exp(2.1 - x2)),
           y2 = rgen.betaII(nn, scale = exp(2.0), shape1.a = exp(1.8 + x2),
                            shape2.p = exp(2.3) , shape3.q = exp(1.9 - x2)), 
           y3 = rgen.betaII(nn, scale = exp(1.5), shape1.a = exp(1.8),
                            shape2.p = exp(2.3) , shape3.q = exp(1.3)))
                            
#------------------------------------------------------------------------#
# A single intercept-only model. No covariates.
# Note the use of (optional) initial values.
fit  &lt;- vglm(y2 ~ 1,   #y3 ~ 1
             gen.betaIImr(lss = TRUE,
                          # OPTIONAL INITIAL VALUES
                           #iscale    = exp(1.5), 
                           #ishape1.a = exp(1.8),
                           #ishape2.p = exp(2.3),
                           #ishape3.q = exp(1.3),
                          
                          imethod = 1),  
             data = gdata, trace = TRUE, crit = "loglik")
             
Coef(fit)
coef(fit, matrix = TRUE)
summary(fit)

#------------------------------------------------------------------------#
# An intercept-only model. Two responses.
fit1 &lt;- vglm(cbind(y2, y2) ~ 1,   # cbind(y1, y2)
             gen.betaIImr(lss = TRUE),  
             data = gdata, trace = TRUE, crit = "loglik")
             
Coef(fit1)
coef(fit1, matrix = TRUE)
summary(fit1)
vcov(fit1, untransform = TRUE)

#------------------------------------------------------------------------#
# An example incorporating one covariate. Constraints are set accordingly.
# x2 affects shape1.a and shape3.q.
# Note that the first option uses 'constraints', whilst in the second
# choice we use the argument 'zero' to 'set' the same constraints.

### Option 1.
c1 &lt;- rbind(0, 1, 0, 0)
c2 &lt;- rbind(0, 0, 0, 1)
mycons &lt;- matrix( c(c1, c2), nc = 2, byrow = FALSE)

fit2 &lt;- vglm(y1 ~ x2, gen.betaIImr(lss = TRUE, zero = NULL),
             data = gdata, trace = TRUE, crit = "loglik",
             constraints = list(x2 = mycons ))

coef(fit2, matrix = TRUE)
summary(fit2)
vcov(fit2)
constraints(fit2)


### Option 2.
fit3 &lt;- vglm(y1 ~ x2, 
             gen.betaIImr(lss = TRUE, 
                          zero = c("scale", "shape2.p")),
             data = gdata, trace = TRUE, crit = "loglik")

coef(fit3, matrix = TRUE)
summary(fit3)
vcov(fit3)
constraints(fit3)

  
</code></pre>

<hr>
<h2 id='genbetaIIDist'>The Generalized Beta Distribution of the Second King</h2><span id='topic+genbetaIIDist'></span><span id='topic+dgen.betaII'></span><span id='topic+pgen.betaII'></span><span id='topic+qgen.betaII'></span><span id='topic+rgen.betaII'></span>

<h3>Description</h3>

<p>Density, distribution function, inverse distribution (quantile function)
and random generation for the Generalized Beta of the Second Kind (GB2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dgen.betaII(x, scale = 1.0, shape1.a = 1.0, shape2.p = 1.0, shape3.q = 1.0, 
             log = FALSE)
  pgen.betaII(q, scale = 1.0, shape1.a = 1.0, shape2.p = 1.0, shape3.q = 1.0, 
             lower.tail = TRUE, log.p = FALSE)
  qgen.betaII(p, scale = 1.0, shape1.a = 1.0, shape2.p = 1.0, shape3.q = 1.0, 
             lower.tail = TRUE, log.p = FALSE)
  rgen.betaII(n, scale = 1.0, shape1.a = 1.0, shape2.p = 1.0, shape3.q = 1.0)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genbetaIIDist_+3A_x">x</code>, <code id="genbetaIIDist_+3A_q">q</code></td>
<td>

<p>Vector of quantiles.

</p>
</td></tr>
<tr><td><code id="genbetaIIDist_+3A_p">p</code></td>
<td>

<p>Vector of probabilities.
</p>
</td></tr>
<tr><td><code id="genbetaIIDist_+3A_n">n</code></td>
<td>

<p>Number of observations. If <code>length(n) &gt; 1</code>, its length is taken to be
the numbre required.
</p>
</td></tr>
<tr><td><code id="genbetaIIDist_+3A_scale">scale</code>, <code id="genbetaIIDist_+3A_shape1.a">shape1.a</code>, <code id="genbetaIIDist_+3A_shape2.p">shape2.p</code>, <code id="genbetaIIDist_+3A_shape3.q">shape3.q</code></td>
<td>
 
<p>Strictly positive scale and shape parameters.
</p>
</td></tr>
<tr><td><code id="genbetaIIDist_+3A_log">log</code>, <code id="genbetaIIDist_+3A_log.p">log.p</code>, <code id="genbetaIIDist_+3A_lower.tail">lower.tail</code></td>
<td>

<p>Same meaning as in <code><a href="stats.html#topic+Beta">Beta</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GB2 Distribution is defined by the probability density (pdf)
</p>
<p style="text-align: center;"><code class="reqn">f(y) = \frac{a x^{ap - 1}}{b^{ap} B(p, q) [1 + (y/b)^{a}]^{p + q},}</code>
</p>

<p>for <code class="reqn">y &gt; 0</code>, and <code class="reqn">b, a, p, q &gt; 0</code>.
Here, <code class="reqn">B(p, q)</code> is the beta function as in 
<code><a href="base.html#topic+Special">beta</a></code>.
</p>
<p>The GB2 Distribution and the Beta Distribution 
(see <code><a href="stats.html#topic+Beta">Beta</a></code>) are linked, as follows:
Let <code class="reqn">X</code> be a random variable with the Beta density and parameters 
<code class="reqn">p = shape_{1}</code> and <code class="reqn">q = shape_{2}</code>. 
Then, introducing additional <code class="reqn">b = scale</code> and
<code class="reqn">a = shape</code> parameters, the variable
</p>
<p style="text-align: center;"><code class="reqn">Y = \frac{(x/b)^{a}}{1 + (x/b)^{a}}</code>
</p>
 
<p>has the GB2 Distribution, with parameters <code class="reqn">b, a, p, q</code>.
</p>
<p>The GB2 <code class="reqn">k^{th}</code> moment exists for <code class="reqn">-ap &lt; k &lt; aq</code> 
and is given by
</p>
<p style="text-align: center;"><code class="reqn">E(Y^{k}) = \frac{b^{k} B(p + k/a, q - k/a)}{B(p, q)}</code>
</p>
 
<p>or, equivalently, 
</p>
<p style="text-align: center;"><code class="reqn">E(Y^{k}) = \frac{b^{k} \Gamma(p + k/a) \Gamma(q - k/a)}
                   {\Gamma(p) \Gamma(q)}).</code>
</p>
 
<p>Here, <code class="reqn">\Gamma(\cdot)</code> is the gamma function as in
<code><a href="base.html#topic+Special">gamma</a></code>.
</p>


<h3>Value</h3>

<p><code>dgen.betaII()</code> returns the density (p.d.f), <code>pgen.betaII()</code> gives 
the distribution function (p.d.f), <code>qgen.betaII()</code> gives the quantile
function (Inverse Distribution function), and <code>rgen.betaII()</code> generates 
random numbers from the GB2 distribution.
</p>


<h3>Note</h3>

<p>Values of the <code>shape2.p</code> parameter moderately close to zero may imply 
obtaning numerical values too close to zero or values represented as zero 
in computer arithmetic from the function <code>rgen.betaII()</code>.
</p>
<p>Additionally, for specific values of the arguments <code>x, q, p</code> such as 
<code>Inf, -Inf, NaN</code> and <code>NA</code>, the functions <code>qgen.betaII()</code>, 
<code>pgen.betaII()</code> and <code>qgen.betaII()</code> will return the limit when 
the argument tends to such value. 
</p>
<p>In particular, the quantile <code>qgen.betaII()</code> retunrs zero for negative
values and <code class="reqn">Inf</code> for missed probabilities greater than 1.0.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee</p>


<h3>References</h3>

<p>Abramowitz, M. and Stegun, I. A. (1972) 
<em>Handbook of Mathematical Functions with Formulas, Graphs, and 
Mathematical Tables</em>, 
<b>ch.6</b>, p.255. Dover, New York, USA.
</p>
<p>Kleiber, C. and Kotz, S. (2003) 
<em>Statistical Size Distributions in Economics and Actuarial Sciences</em>.
Wiley Series in Probability and Statistics. 
Hoboken, New Jersey, USA.
</p>
<p>McDonald, J. B. and Xu, Y. J. (1995)
A generalization of the beta distribution with applications.
<em>Journal of Econometrics</em>, <b>66</b>, p.133&ndash;152.
</p>
<p>McDonald, J. B. (1984)
Some generalized functions for the size distribution of income.
<em>Econometrica</em>, <b>52</b>, p.647&ndash;663.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>,
<code><a href="base.html#topic+Special">beta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Setting parameters to both examples below.
  b  &lt;- exp(0.4)      # Scale parameter.
  a  &lt;- exp(0.5)      # Shape1.a
  p  &lt;- exp(0.3)      # Shape2.p
  q  &lt;- exp(1.4)      # Shape3.q
  
  # (1) ______________  
  probs.y &lt;- seq(0.0, 1.0, by = 0.01)
  data.1  &lt;- qgen.betaII(p = probs.y, scale = b, shape1.a = a, 
                        shape2.p = p, shape3.q = q)
  max(abs(pgen.betaII(q = data.1, scale = b, shape1.a = a, 
                     shape2.p = p, shape3.q = q)) - probs.y) # Should be 0.
 
  # (2)_________________
  xx    &lt;- seq(0, 10.0, length = 200)
  yy    &lt;- dgen.betaII(xx, scale = b, shape1.a = a, shape2.p = p, shape3.q = q)
  qtl   &lt;- seq(0.1, 0.9, by = 0.1)
  d.qtl &lt;- qgen.betaII(qtl, scale = b, shape1.a = a, shape2.p = p, shape3.q = q)
  plot(xx, yy, type = "l", col = "red", 
       main = "Red is the GB2 density, blue is the GB2 Distribution Function",
       sub  = "Brown dashed lines represent the 10th, ..., 90th percentiles",
       las = 1, xlab = "x", ylab = "", xlim = c(0, 3), ylim = c(0,1))
  abline(h = 0, col = "navy", lty = 2)
  abline(h = 1, col = "navy", lty = 2)
  lines(xx, pgen.betaII(xx, scale = b, shape1.a = a, 
                       shape2.p = b, shape3.q = q), col= "blue")
  lines(d.qtl, dgen.betaII(d.qtl, scale = b, shape1.a = a, 
                        shape2.p = p, shape3.q = q), 
                        type ="h", col = "brown", lty = 3)
 
</code></pre>

<hr>
<h2 id='geometricffMlink'>
Link functions for the mean of 1&ndash;parameter 
discrete distributions: The Geometric Distribution.
</h2><span id='topic+geometricffMlink'></span><span id='topic+geometricffMeanlink'></span>

<h3>Description</h3>

<p>Computes the <code>geometricffMlink</code> transformation, including its inverse
and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    geometricffMlink(theta, bvalue = NULL, inverse = FALSE, 
                     deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geometricffMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character.
See below for further details.
</p>
</td></tr>
<tr><td><code id="geometricffMlink_+3A_bvalue">bvalue</code>, <code id="geometricffMlink_+3A_inverse">inverse</code>, <code id="geometricffMlink_+3A_deriv">deriv</code>, <code id="geometricffMlink_+3A_short">short</code>, <code id="geometricffMlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a natural link function to model the mean of the (discret)
geometric distribution, <code><a href="VGAM.html#topic+geometric">geometric</a></code>,
defined as the logarithmm of its mean, i.e.,
</p>
<p style="text-align: center;"><code class="reqn"> \eta = -\log \frac{p}{1 - p} = -{\tt{logit}}(p).</code>
</p>

<p>Here, <code class="reqn">p</code> is the probability of succes, as in 
<code><a href="VGAM.html#topic+geometric">geometric</a></code>. 
</p>
<p>While this link function can be used to model any parameter lying in 
<code class="reqn">(0, 1)</code>, it is particularly useful for event-rate geometric data 
where the mean can be written in terms of some rate of events, 
say <code class="reqn">\lambda = \lambda(\mathbf{x})</code>, as

</p>
<p style="text-align: center;"><code class="reqn">\mu = \lambda(\mathbf{x}) t,</code>
</p>


<p>and the time <code class="reqn">t</code> (as <code class="reqn">\log t</code>) can be easily 
incorporated in the analysis as an offset.
</p>
<p>Under this link function the domain set for <code class="reqn">p</code> 
is <code class="reqn">(0, 1)</code>. Hence, values of <code class="reqn">\rho</code> too
close to the extremes, or out of range will result 
in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>. 
Use argument <code>bvalue</code> to adequately replace them before 
computing the link function.
</p>
<p>If <code>theta</code> is a character, arguments <code>inverse</code> and 
<code>deriv</code> are disregarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>geometricffMlink</code> transformation of
<code>theta</code> when <code>inverse = FALSE</code>. When 
<code>inverse = TRUE</code> then <code>theta</code> becomes <code class="reqn">\eta</code>, and
<code>exp(-theta) / (exp(-theta) - 1)</code> is returned.
</p>
<p>For <code>deriv = 1</code>, <em>d</em> <code>eta</code> / <em>d</em> <code>theta</code>,
if <code>inverse = FALSE</code>, else 
the reciprocal <em>d</em> <code>theta</code> / <em>d</em> <code>eta</code>
as a function of <code>theta</code>.
</p>
<p>For <code>deriv = 2</code> the second order derivatives 
are correspondingly returned.
</p>


<h3>Warning</h3>

<p>Numerical instability may occur if covariates are used leading to 
values of <code class="reqn">p</code> out of range. Try to overcome this by using
argument <code>bvalue</code>.
</p>


<h3>Note</h3>

<p>This function may return <code>Inf</code> of <code>-Inf</code> for values of 
<code class="reqn">p</code> too close to <code class="reqn">0</code> and <code class="reqn">1</code> respectively.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+geometric">geometric</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>, 
<code><a href="VGAM.html#topic+logitlink">logitlink</a></code>,
<code><a href="#topic+logffMlink">logffMlink</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1  ###
my.probs &lt;- ppoints(100)
geol.inv &lt;-
    geometricffMlink(theta = geometricffMlink(theta = my.probs), # the inverse
                                inverse = TRUE) - my.probs
summary(geol.inv)     ## zero

###  Example 2. Special values of 'prob'  ###
my.probs &lt;- c(-Inf, -2, -1, 0, 0.25, 0.75, 1.0, 5, Inf, NaN, NA) 
rbind(probs = my.probs, 
      geoffMlink = geometricffMlink(theta = my.probs),
      inv.geoffl = geometricffMlink(theta = my.probs, inverse = TRUE))


###  Example 3 Some probability link functions  ###

my.probs &lt;- ppoints(100)

par(lwd = 2)
plot(my.probs, logitlink(my.probs), xlim = c(-0.1, 1.1), ylim = c(-5, 8),
     type = "l", col = "limegreen", 
     ylab = "transformation", las = 1, main = "Some probability link functions")
lines(my.probs, geometricffMlink(my.probs), col = "gray50")
lines(my.probs, logffMlink(my.probs), col = "blue")
lines(my.probs, probitlink(my.probs), col = "purple")
lines(my.probs, clogloglink(my.probs), col = "chocolate")
lines(my.probs, cauchitlink(my.probs), col = "tan")
abline(v = c(0.5, 1), lty = "dashed")
abline(v = 0, h = 0, lty = "dashed")
legend(0.1, 8, 
      c("geometricffMlink", "logffMlink","logitlink", "probitlink",
      "clogloglink", "cauchitlink"), 
      col = c("gray50", "blue", "limegreen", "purple", "chocolate", "tan"),
      lwd = 1, cex = 0.5)
par(lwd = 1) 
 
</code></pre>

<hr>
<h2 id='HKdata'>Air pollution and hospital admissions due to respiratory and 
cardiovascular causes, Hong Kong.</h2><span id='topic+HKdata'></span>

<h3>Description</h3>

<p>Daily air pollution levels and
hospital admissions due to respiratory and 
cardiovascular causes,
between 1 January 1994 and 31 December 1997,
Hong Kong. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HKdata)</code></pre>


<h3>Format</h3>

<p>This is a subset of the data
analyzed in Xia and Tong (2006) which 
stores the following time series:
</p>

<dl>
<dt>no</dt><dd>
<p>Time vector, 
</p>
</dd>
<dt>cardio, resp</dt><dd>
<p>Integer.
Daily hospital admissions due to respiratory and 
cardiovascular causes, 1 January 1994 and 31 December 1997. 
</p>
</dd>
<dt>no2, so2, rsp, o3</dt><dd>
<p>Numeric.
Daily mean average of <code class="reqn">\textrm{NO}_{2}</code>, 
<code class="reqn">\textrm{SO}_{2}</code>, respirable
suspended particles (rsp; that is
<code class="reqn">\textrm{PM}_{10}</code>), and
<code class="reqn">\textrm{O}_{3}</code>, in parts per billion (ppb). 
</p>
</dd>
<dt>temp, hum</dt><dd>
<p>Numeric.
Daily mean average of temperature (Celsius deg.) and humidity (%)
</p>
</dd>
<dt>mon, tue, wed, thur, fri, sat</dt><dd>
<p>Factors with two levels. Weekdays/weekends indicator variables.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data set retrieved from 
<a href="https://blog.nus.edu.sg/homepage/research/">https://blog.nus.edu.sg/homepage/research/</a>
</p>


<h3>References</h3>

<p>Xia, Y. and Tong, H. (2006)
Cumulative effects of air pollution on public health.
<em>Statistics in Medicine</em>.
<b>25(29)</b>, 3548-3559.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HKdata)
summary(HKdata[, -1])

</code></pre>

<hr>
<h2 id='inv.chisqDist'>
The Inverse Chi&ndash;squared Distribution
</h2><span id='topic+inv.chisqDist'></span><span id='topic+dinv.chisq'></span><span id='topic+pinv.chisq'></span><span id='topic+qinv.chisq'></span><span id='topic+rinv.chisq'></span>

<h3>Description</h3>

<p>Density, CDF, quantile function and random number generator for the
Inverse Chi&ndash;squared distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    dinv.chisq(x, df, log = FALSE)
    pinv.chisq(q, df, lower.tail = TRUE, log.p = FALSE)
    qinv.chisq(p, df, lower.tail = TRUE, log.p = FALSE)
    rinv.chisq(n, df) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv.chisqDist_+3A_x">x</code>, <code id="inv.chisqDist_+3A_q">q</code>, <code id="inv.chisqDist_+3A_p">p</code>, <code id="inv.chisqDist_+3A_n">n</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Chisquare">Chisquare</a></code>. 
</p>
</td></tr>
<tr><td><code id="inv.chisqDist_+3A_df">df</code>, <code id="inv.chisqDist_+3A_lower.tail">lower.tail</code>, <code id="inv.chisqDist_+3A_log">log</code>, <code id="inv.chisqDist_+3A_log.p">log.p</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Chisquare">Chisquare</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse chi&ndash;squared distribution with non&ndash;negative
<code>df</code> = <code class="reqn">\nu</code> degrees
of freedom implemented here has density

</p>
<p style="text-align: center;"><code class="reqn">f(x; \nu) = \frac{ 2^{-\nu / 2} x^{-\nu/2 - 1} 
               e^{-1 / (2x)} }{ \Gamma(\nu / 2) }, </code>
</p>


<p>where <code class="reqn">x &gt; 0</code>, and
<code class="reqn">\Gamma</code> is the <code><a href="base.html#topic+gamma">gamma</a></code> function.
</p>
<p>The mean is <code class="reqn">1 / (\nu - 2)</code>, for <code class="reqn">\nu &gt; 2</code>, and the variance is
given by <code class="reqn">2 / [(\nu - 2)^2 (\nu - 4)]</code>, for <code class="reqn">\nu &gt; 4</code>.
</p>
<p>Also, as with <code><a href="stats.html#topic+Chisquare">Chisquare</a></code>, the degrees
of freedom can be non&ndash;integer.
</p>


<h3>Value</h3>

<p><code>dinv.chisq</code> returns the density, <code>pinv.chisq</code> returns the 
distribution function, <code>qinv.chisq</code> gives the quantiles, and 
<code>rinv.chisq</code> generates random numbers from this distribution.
</p>


<h3>Source</h3>

<p>Specifically, it is the probability distribution of a random variable
whose reciprocal follows a chi&ndash;squared distribution, i.e.,
</p>
<p>If <code class="reqn">Y \sim</code> chi&ndash;squared<code class="reqn">(\nu)</code>, then <code class="reqn">1/Y \sim</code>
Inverse chi&ndash;squared<code class="reqn">(\nu)</code>.
</p>
<p>As a result, <code>dinv.chisq, pinv.chisq, qinv.chisq</code> and 
<code>rinv.chisq</code> use the functions 
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code> as a basis. Hence,
invalid arguments will lead these functions to return
<code>NA</code> or <code>NaN</code> accordingly.
</p>


<h3>Note</h3>

<p>Yet to do: A <em>non&ndash;central</em> parameter as an argument, 
if amenable. 
</p>
<p>Two similar versions of the Inverse chi&ndash;squared distribution with
<code class="reqn">\nu</code> degrees of freedom may be found in the literature, as 
follows:
</p>
<p>Let <code class="reqn">Y \sim</code> chi&ndash;squared<code class="reqn">(\nu)</code>, then
</p>
<p>I. <code class="reqn">1 / Y \sim</code> Inverse chi&ndash;squared<code class="reqn">(\nu)</code>, and
II. <code class="reqn"> \nu / Y \sim</code> Inverse chi&ndash;squared<code class="reqn">(\nu)</code>.
</p>
<p>Here, the former, which is the popular version, has been implemented.
</p>


<h3>Author(s)</h3>

<p>V. Miranda</p>


<h3>References</h3>

<p>Johnson, N.L., Kotz, S. and Balakrishnan, N. (1995) 
<em>Continuous Univariate Distributions</em>.
Chapters 18 (volume 1) and 29 (volume 2). Wiley, New York.  




</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Chisquare">Chisquare</a></code>,
<code><a href="base.html#topic+gamma">gamma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ##  Example 1  ## 
  nn &lt;- 50; df &lt;- 1.4
  data.1   &lt;- ppoints(nn)
  data.q   &lt;- qinv.chisq(-data.1, df = df, log.p = TRUE)  
  data.p   &lt;- -log(pinv.chisq(data.q, df = df)) 
  max(abs(data.p - data.1))     # Should be zero
  
  
  ##  Example 2  ##

  xx    &lt;- seq(0, 3.0, len = 301)
  yy    &lt;- dinv.chisq(xx, df = df)
  qtl   &lt;- seq(0.1, 0.9, by = 0.1)
  d.qtl &lt;- qinv.chisq(qtl, df = df)
  plot(xx, yy, type = "l", col = "orange", 
       main = "Orange is density, blue is cumulative distribution function",
       sub  = "Brown dashed lines represent the 10th, ... 90th percentiles",
       las = 1, xlab = "x", ylab = "", ylim = c(0, 1))
  abline(h = 0, col= "navy", lty = 2)
  lines(xx, pinv.chisq(xx, df = df), col = "blue")
  lines(d.qtl, dinv.chisq(d.qtl, df = df), type ="h", col = "brown", lty = 3)
  
</code></pre>

<hr>
<h2 id='inv.chisqff'>
Inverse Chi&ndash;squared Distribution.
</h2><span id='topic+inv.chisqff'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the degrees of freedom for an
inverse chi&ndash;squared distribution using Fisher scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>              inv.chisqff(link = "loglink", zero = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv.chisqff_+3A_link">link</code>, <code id="inv.chisqff_+3A_zero">zero</code></td>
<td>

<p><code>link</code> is the link function applied to the degrees of freedom,
leading to the unique linear predictor in this family function.
By default, the link is <code><a href="VGAM.html#topic+loglink">loglink</a></code>.
</p>
<p><code>zero</code>  allows to model the single linear predictor as
intercept&ndash;only.  
</p>
<p>For further details, see 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse chi&ndash;squared distribution 
with <code class="reqn">df = \nu \geq 0</code> degrees of 
freedom implemented here has density
</p>

<p style="text-align: center;"><code class="reqn">f(x; \nu) = \frac{ 2^{-\nu / 2} x^{-\nu/2 - 1} 
               e^{-1 / (2x)} }{ \Gamma(\nu / 2) }, </code>
</p>


<p>where <code class="reqn">x &gt; 0</code>, and
<code class="reqn">\Gamma</code> is the <code><a href="base.html#topic+gamma">gamma</a></code> function.
The mean of <code class="reqn">Y</code> is <code class="reqn">1 / (\nu - 2)</code> (returned as the fitted
values), provided <code class="reqn">\nu &gt; 2</code>.
</p>
<p>That is, while the expected information matrices used here are 
valid in all regions of the parameter space, the regularity conditions 
for maximum likelihood estimation are satisfied only if <code class="reqn">\nu &gt; 2</code>.
To enforce this condition, choose 
<code>link = logoff(offset = -2)</code>.
</p>
<p>As with, <code><a href="VGAM.html#topic+chisq">chisq</a></code>, the degrees of freedom are
treated as a parameter to be estimated using (by default) the
link <code><a href="VGAM.html#topic+loglink">loglink</a></code>. However, the mean can also
be modelled with this family function. 
See <code><a href="#topic+inv.chisqMlink">inv.chisqMlink</a></code> 
for specific details about this.
</p>
<p>This family <span class="pkg">VGAM</span> function handles multiple responses.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code>.
See <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code> for further details.
</p>


<h3>Warning</h3>

<p>By default, the single linear/additive predictor in this family 
function, say <code class="reqn">\eta = \log dof</code>, 
can be modeled in terms of covariates, 
i.e., <code>zero = NULL</code>. 
To model <code class="reqn">\eta</code> as intercept&ndash;only set <code>zero = "dof"</code>.
</p>
<p>See <code><a href="VGAM.html#topic+zero">zero</a></code> for more details about this.
</p>


<h3>Note</h3>

<p>As with <code><a href="VGAM.html#topic+chisq">chisq</a></code> or 
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code>, the degrees of freedom are
non&ndash;negative but allowed to be non&ndash;integer.
</p>


<h3>Author(s)</h3>

<p>V. Miranda.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+loglink">loglink</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="#topic+inv.chisqMlink">inv.chisqMlink</a></code>,
<code><a href="VGAM.html#topic+zero">zero</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(17010504)
   dof   &lt;- 2.5 
   yy    &lt;- rinv.chisq(100, df = dof)     
   ics.d &lt;- data.frame(y = yy)             # The data.
 
   
   fit.inv &lt;- vglm(cbind(y, y) ~ 1, inv.chisqff, 
                   data = ics.d, trace = TRUE, crit = "coef")
   Coef(fit.inv) 
   summary(fit.inv)
    
</code></pre>

<hr>
<h2 id='inv.chisqMlink'>
Link functions for the mean of 1&ndash;parameter 
continuous distributions: The inverse chi&ndash;squared distribution.
</h2><span id='topic+inv.chisqMlink'></span><span id='topic+inv.chisqMeanlink'></span>

<h3>Description</h3>


<p>Computes the <code>inv.chisqMlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>        inv.chisqMlink(theta, bvalue = NULL, inverse = FALSE,
                        deriv = 0, short = TRUE, tag = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv.chisqMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> by default but may 
be <code class="reqn">\eta</code> depending on the other parameters.
See below for further details.
</p>
</td></tr>
<tr><td><code id="inv.chisqMlink_+3A_bvalue">bvalue</code>, <code id="inv.chisqMlink_+3A_inverse">inverse</code>, <code id="inv.chisqMlink_+3A_deriv">deriv</code>, <code id="inv.chisqMlink_+3A_short">short</code>, <code id="inv.chisqMlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This link functions models the mean of the
inverse chi&ndash;squared distribution, 
<code><a href="#topic+inv.chisqff">inv.chisqff</a></code>.
</p>
<p>It is defined as 
</p>
<p style="text-align: center;"><code class="reqn"> \eta = -\log ( df - 2),</code>
</p>

<p>where <code class="reqn">df</code> denotes the (non&ndash;negative) degrees of freedom, as in 
<code><a href="#topic+inv.chisqff">inv.chisqff</a></code>.
</p>
<p>Notice, however, that <code class="reqn">df &gt; 2</code> is required for the mean of
this distribution to be real. Consequently, the domain set for
<code>df</code> for this link function is <code class="reqn">(2, \infty)</code>.
</p>
<p>Numerical values of <code class="reqn">df</code> out of range will 
result in <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>inv.chisqMlink</code> transformation of
<code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then the inverse <code>exp(-theta) + 2</code>.
</p>
<p>For <code>deriv = 1</code>,
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of 
<code>theta</code>.
</p>
<p>When <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are returned.
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too large or
possibly, too close to 2. Use argument <code>bvalue</code> to replace them
before computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inv.chisqff">inv.chisqff</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ##  E1. Modelling the mean of the exponential distribution  ##
    set.seed(17010502)
    dof &lt;- 2.5 
    isq.data &lt;- data.frame(x2 = runif(100, 0, 1))
    isq.data &lt;- transform(isq.data, y = rinv.chisq(n = 100, df = dof + x2))
    
    
    hist(isq.data$y)
    
    
    fit.inv &lt;- vglm(y ~ x2, family = inv.chisqff(link = "inv.chisqMlink"), 
                    data = isq.data, trace = TRUE )
    coef(fit.inv, matrix = TRUE)
    summary(fit.inv)

  ## E3. Special values in a matrix ##
    (theta &lt;- matrix(c(Inf, -Inf, NA, NaN, 1 , 2, 3, 4), ncol = 4, nrow = 2))
    inv.chisqMlink(theta = theta)   ## NaNs for df = theta &lt;= 2 
 
  ## E2. inv.chisqMlink() and its inverse ##
    theta &lt;- 0.1 + 1:5  # dof = df
    my.diff &lt;- theta - inv.chisqMlink(inv.chisqMlink(theta = theta), inverse  =TRUE)
    summary(my.diff)     # Zero

</code></pre>

<hr>
<h2 id='invgamma2mr'> 2 - parameter Inverse Gamma Distribution </h2><span id='topic+invgamma2mr'></span>

<h3>Description</h3>

<p>Estimates the 2-parameter Inverse Gamma distribution
by maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  invgamma2mr(lmu      = "loglink", 
              lshape   = logofflink(offset = -2), 
              parallel = FALSE, 
              ishape   = NULL, 
              imethod  = 1, 
              zero     = "shape") 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invgamma2mr_+3A_lmu">lmu</code>, <code id="invgamma2mr_+3A_lshape">lshape</code></td>
<td>

<p>Link functions applied to the (positives) <em>mu</em> and <em>shape</em>
parameters (called <code class="reqn">\mu</code> and <code class="reqn">a</code> respectively), 
according to <code><a href="VGAM.html#topic+gamma2">gamma2</a></code>.
See 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> 
for further information.
</p>
</td></tr>
<tr><td><code id="invgamma2mr_+3A_parallel">parallel</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+gamma2">gamma2</a></code>.
Details at 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.  


</p>
</td></tr>
<tr><td><code id="invgamma2mr_+3A_ishape">ishape</code></td>
<td>

<p>Optional initial value for <em>shape</em>, same as 
<code><a href="VGAM.html#topic+gamma2">gamma2</a></code>




</p>
</td></tr>
<tr><td><code id="invgamma2mr_+3A_imethod">imethod</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+gamma2">gamma2</a></code>.




</p>
</td></tr>
<tr><td><code id="invgamma2mr_+3A_zero">zero</code></td>
<td>

<p>Numeric or character vector. Position or name(s) of the 
parameters/linear predictors to be 
modeled as intercept&ndash;only. Default is <code>"shape"</code>. Details at 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.








</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gamma distribution and the Inverse Gamma distribution are related 
as follows:Let <em>X</em> be a random variable distributed as 
<code class="reqn">Gamma (a, \beta)</code>,  where <code class="reqn">a &gt; 0</code> 
denotes the <em>shape</em> parameter and <code class="reqn">\beta &gt; 0</code> is the 
<em>scale</em> paramater. Then <code class="reqn">Y = 1/X</code> is an Inverse Gamma 
random variable with parameters <em>scale</em> = <code class="reqn">a</code> and 
<em>shape</em> = <code class="reqn">1/\beta</code>. 
</p>
<p>The Inverse Gamma density function is given by
</p>
<p style="text-align: center;"><code class="reqn">f(y;\mu, a) = \frac{(a - 1)^{a} \mu^{a}}{\Gamma(a)}y^{-a- 1} \
                    e^{-\mu(a - 1)/y},</code>
</p>

<p>for <code class="reqn">\mu &gt; 0</code>, <code class="reqn">a &gt; 0</code> and <code class="reqn">y &gt; 0</code>.
Here, <code class="reqn">\Gamma(\cdot)</code> is the gamma function, as in 
<code><a href="base.html#topic+Special">gamma</a></code>. The mean of <em>Y</em> is 
<code class="reqn">\mu=\mu</code> (returned as the fitted values) with variance 
<code class="reqn">\sigma^2 = \mu^2 / (a - 2)</code> 
if <code class="reqn">a &gt; 2</code>, else is infinite. Thus, the 
<em>link function</em> for the <em>shape</em> parameter is 
<code><a href="VGAM.html#topic+logloglink">logloglink</a></code>. Then, by default, the two 
linear/additive predictors are <code class="reqn">\eta_1=\log(\mu)</code>, 
and <code class="reqn">\eta_2=\log(a)</code>, i.e in the VGLM context, 
<code class="reqn">\eta = (log(\mu), loglog(a)</code>
</p>
<p>This <span class="pkg">VGAM</span> family function handles <em>multiple</em> reponses by 
implementing Fisher scoring and unlike 
<code><a href="VGAM.html#topic+gamma2">gamma2</a></code>, the working-weight matrices
are <em>not</em> diagonal.


The Inverse Gamma distribution is right-skewed and either for small values
of <code class="reqn">a</code> (plus modest <code class="reqn">\mu</code>) or very large values of 
<code class="reqn">\mu</code> (plus moderate <code class="reqn">a &gt; 2</code>), the density has 
values too close to zero.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>).
The object is used by modelling functions
such as <code><a href="VGAM.html#topic+vglm">vglm</a></code>
and <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Warning</h3>

<p>Note that <code>zero</code> can be a <b>numeric</b> or a <b>character</b> 
vector specifying the position of the names 
(partially or not) of the linear predictor modeled as intercept only.
In this family function such names are
</p>
<p><code>c("mu", "shape")</code>.
</p>
<p>Numeric values can be entered as usual.
See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> 
for further details.
</p>


<h3>Note</h3>

<p>The response must be strictly positive.


</p>
<p>If <code>mu</code> and <code>shape</code> are vectors, then <code>rinvgamma(n = n,
  shape = shape, scale = mu/(shape - 1)</code> will generate random inverse gamma 
variates of this parameterization, etc.; 
see <code><a href="#topic+invgammaDist">invgammaDist</a></code>.



</p>
<p>Given the math relation between the Gamma and the Inverse Gamma
distributions, the parameterization of this <span class="pkg">VGAM</span> family function 
underlies on the parametrization of the 2-parameter gamma distribution 
described in the monograph
</p>


<h3>Author(s)</h3>

<p> Victor Miranda and T. W. Yee </p>


<h3>References</h3>

<p>McCullagh, P. and Nelder, J. A. (1989)
<em>Generalized Linear Models</em>, 
2nd ed. London, UK. Chapman &amp; Hall.



</p>


<h3>See Also</h3>

<p><code><a href="#topic+invgammaDist">invgammaDist</a></code>,
<code><a href="VGAM.html#topic+gamma2">gamma2</a></code> for the 2-parameter gamma distribution,
<code><a href="stats.html#topic+GammaDist">GammaDist</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,

</p>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------------------------------#
# Essentially fitting a 2-parameter inverse gamma distribution
# with 2 responses.

set.seed(101)
y1 = rinvgamma(n = 500, scale = exp(2.0), shape = exp(2.0))
y2 = rinvgamma(n = 500, scale = exp(2.5), shape = exp(2.5))
gdata &lt;- data.frame(y1, y2)

fit1 &lt;- vglm(cbind(y1, y2) ~ 1, 
            family = invgamma2mr(zero = NULL, 
            
                                 # OPTIONAL INITIAL VALUE
                                 # ishape = exp(2),
                                 
                                 imethod = 1),
            data = gdata, trace = TRUE)

Coef(fit1)
c(Coef(fit1), log(mean(gdata$y1)), log(mean(gdata$y2)))
summary(fit1)
vcov(fit1, untransform = TRUE)

#------------------------------------------------------------------------#
# An example including one covariate.
# Note that the x2 affects the shape parameter, which implies that both,
# 'mu' and 'shape' are affected.
# Consequently, zero must be set as NULL !

x2    &lt;- runif(1000)
gdata &lt;- data.frame(y3 = rinvgamma(n = 1000, 
                                   scale = exp(2.0), 
                                   shape = exp(2.0 + x2)))

fit2 &lt;- vglm(y3 ~ x2, 
            family = invgamma2mr(lshape = "loglink", zero = NULL), 
            data = gdata, trace = TRUE)

coef(fit2, matrix = TRUE)
summary(fit2)
vcov(fit2)

</code></pre>

<hr>
<h2 id='invgammaDist'>The Inverse Gamma Distribution</h2><span id='topic+invgammaDist'></span><span id='topic+dinvgamma'></span><span id='topic+pinvgamma'></span><span id='topic+qinvgamma'></span><span id='topic+rinvgamma'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random numbers 
generator for the Inverse Gamma Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, scale = 1/rate, shape, rate = 1, log = FALSE)
pinvgamma(q, scale = 1/rate, shape, rate = 1, lower.tail = TRUE, log.p = FALSE)
qinvgamma(p, scale = 1/rate, shape, rate = 1, lower.tail = TRUE, log.p = FALSE)
rinvgamma(n, scale = 1/rate, shape, rate = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invgammaDist_+3A_x">x</code>, <code id="invgammaDist_+3A_q">q</code>, <code id="invgammaDist_+3A_p">p</code>, <code id="invgammaDist_+3A_n">n</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>. 
</p>
</td></tr>
<tr><td><code id="invgammaDist_+3A_scale">scale</code>, <code id="invgammaDist_+3A_shape">shape</code></td>
<td>
 
<p>Scale and shape parameters, same as 
<code><a href="stats.html#topic+GammaDist">GammaDist</a></code>.
Both must be positive.
</p>
</td></tr>
<tr><td><code id="invgammaDist_+3A_rate">rate</code></td>
<td>
 
<p>Same as <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>.
</p>
</td></tr>
<tr><td><code id="invgammaDist_+3A_log">log</code>, <code id="invgammaDist_+3A_log.p">log.p</code>, <code id="invgammaDist_+3A_lower.tail">lower.tail</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Inverse Gamma density with parameters scale = <code class="reqn">b</code> and 
shape = <code class="reqn">s</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">f(y) = \frac{b^{s}}{\Gamma(s)} y^{-s-1} e^{-b/y},</code>
</p>

<p>for <code class="reqn">y &gt; 0</code>, <code class="reqn">b &gt; 0</code>, and <code class="reqn">s &gt; 0</code>. 
Here, <code class="reqn">\Gamma(\cdot)</code> is the gamma function as in 
<code><a href="base.html#topic+Special">gamma</a></code> 
</p>
<p>The relation between the Gamma Distribution and the Inverse Gamma 
Distribution is as follows:
</p>
<p>Let <code class="reqn">X</code> be a random variable distributed as Gamma 
(<code class="reqn">b, s</code>), then <code class="reqn">Y = 1 / X</code> is distributed as 
Inverse Gamma (<code class="reqn">1/b, s</code>). 
It is worth noting that the math relation between the <em>scale</em> paramaters
of both, the Inverse Gamma and Gamma distributions, is inverse.
</p>
<p>Thus, algorithms of <em>dinvgamma(), pinvgamma(), qinvgamma()</em> and 
<em>rinvgamma()</em> underlie on the algorithms 
<code><a href="stats.html#topic+GammaDist">GammaDist</a></code>.




</p>
<p>Let <code class="reqn">Y</code> distributed as Inverse Gamma (<code class="reqn">b, s</code>). Then the 
<code class="reqn">k^{th}</code> moment of <code class="reqn">Y</code> exists for <code class="reqn">-\infty &lt; k &lt; s</code> and is 
given by
</p>
<p style="text-align: center;"><code class="reqn">E[Y^k] = \frac{\Gamma(s - k)}{\Gamma(s)} b^k.</code>
</p>

<p>The mean (if <code class="reqn">s &gt; 1</code>) and variance (if <code class="reqn">s &gt; 2</code>) are
</p>
<p style="text-align: center;"><code class="reqn">E[Y] = \frac{b}{(s - 1)}; \ \ \ Var[Y] = \frac{b^2}{(s - 1)^2 
    \times (s - 2)}.</code>
</p>
    






<h3>Value</h3>

<p><code>dinvgamma()</code> returns the density, <code>pinvgamma()</code> gives the 
distribution function, <code>qinvgamma()</code> gives the quantiles, and 
<code>rinvgamma()</code> generates random deviates.
</p>


<h3>Warning</h3>

<p>The order of the arguments <em>scale</em> and <em>shape</em> does not match 
<code><a href="stats.html#topic+GammaDist">GammaDist</a></code>.
</p>


<h3>Note</h3>




<p>Unlike the <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, small values
of <code class="reqn">a</code> (plus modest <code class="reqn">\mu</code>) or very large values of 
<code class="reqn">\mu</code> (plus moderate <code class="reqn">a &gt; 2</code>), generate Inverse Gamma 
values so near to zero. Thus, <code>rinvgamma</code> in 
<code><a href="#topic+invgammaDist">invgammaDist</a></code> may return either values 
too close to zero or values represented as zero in computer arithmetic.
</p>
<p>In addition, function <code>dinvgamma</code> will return zero for 
<code class="reqn">x = 0</code>, which is the limit of the Inverse Gamma density when 
<code class="reqn">'x'</code> tends to zero.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee.</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003) 
<em>Statistical Size Distributions in Economics and Actuarial Sciences</em>.
Wiley Series in Probability and Statistics. Hoboken, New Jersey, USA.  




</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+GammaDist">GammaDist</a></code>,
<code><a href="base.html#topic+Special">gamma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Example 1.______________________
  n        &lt;- 20
  scale    &lt;- exp(2)
  shape    &lt;- exp(1)
  data.1   &lt;- runif(n, 0, 1)
  data.q   &lt;- qinvgamma(-data.1, scale = scale, shape = shape, log.p = TRUE)  
  data.p   &lt;- -log(pinvgamma(data.q, scale = scale, shape = shape)) 
  arg.max  &lt;- max(abs(data.p - data.1))     # Should be zero
  
  
  # Example 2.______________________
  scale &lt;- exp(1.0)
  shape &lt;- exp(1.2)
  xx    &lt;- seq(0, 3.0, len = 201)
  yy    &lt;- dinvgamma(xx, scale = scale, shape = shape)
  qtl   &lt;- seq(0.1, 0.9, by = 0.1)
  d.qtl &lt;- qinvgamma(qtl, scale = scale, shape = shape)
  plot(xx, yy, type = "l", col = "orange", 
       main = "Orange is density, blue is cumulative distribution function",
       sub  = "Brown dashed lines represent the 10th, ... 90th percentiles",
       las = 1, xlab = "x", ylab = "", ylim = c(0, 1))
  abline(h = 0, col= "navy", lty = 2)
  lines(xx, pinvgamma(xx, scale = scale, shape = shape), col = "blue")
  lines(d.qtl, dinvgamma(d.qtl, scale = scale, shape = shape), 
        type ="h", col = "brown", lty = 3)
        
</code></pre>

<hr>
<h2 id='invweibull2mr'> 2- parameter Inverse Weibull Distribution </h2><span id='topic+invweibull2mr'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the 2-parameter Inverse Weibull distribution.
No observations should be censored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  invweibull2mr(lscale  = loglink, 
                lshape  = logofflink(offset = -2),
                iscale  = NULL, 
                ishape  = NULL, 
                imethod = 2, 
                lss     = TRUE, 
                gscale  = exp(-4:4), 
                gshape  = exp(-4:4),
                probs.y = c(0.25, 0.50, 0.75),
                zero    = "shape")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invweibull2mr_+3A_lscale">lscale</code>, <code id="invweibull2mr_+3A_lshape">lshape</code></td>
<td>

<p>Parameter link functions applied to the 
(positive) <code>shape</code> parameter (called <code class="reqn">a</code> below) and
(positive) <code>scale</code> parameter (called <code class="reqn">b</code> below). 
Given that the <code>shape</code> parameter must be greater than <code class="reqn">2</code>,
<code>lshape = logofflink(offset = -2)</code> by default.
See <code><a href="VGAM.html#topic+Links">Links</a></code> for more choices.
</p>
</td></tr>
<tr><td><code id="invweibull2mr_+3A_iscale">iscale</code>, <code id="invweibull2mr_+3A_ishape">ishape</code></td>
<td>

<p>Optional initial values for the <code>shape</code> and <code>scale</code> parameters.
</p>
</td></tr>
<tr><td><code id="invweibull2mr_+3A_gscale">gscale</code>, <code id="invweibull2mr_+3A_gshape">gshape</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr><td><code id="invweibull2mr_+3A_lss">lss</code>, <code id="invweibull2mr_+3A_probs.y">probs.y</code></td>
<td>

<p>Details at 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr><td><code id="invweibull2mr_+3A_imethod">imethod</code></td>
<td>

<p>Initializing method internally implemented. 
Currently only the values 1 and 2 are allowed and NO observations 
should be censored.
</p>
</td></tr>
<tr><td><code id="invweibull2mr_+3A_zero">zero</code></td>
<td>

<p>Numeric or character vector. The position(s) of the name(s) of 
the parameters/linear predictors to be
modeled as intercept&ndash;only. Default is <code>"shape"</code>.



Details: 
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>



</table>


<h3>Details</h3>

<p>The Weibull distribution and the Inverse Weibull distributions are related
as follows:
</p>
<p>Let <code class="reqn">X</code> be a Weibull random variable with paramaters scale =<code class="reqn">b</code>
and shape =<code class="reqn">a</code>. Then, the random variable <code class="reqn">Y = 1/X</code> has 
the Inverse Weibull density with parameters scale = <code class="reqn">1/b</code> and 
shape = <code class="reqn">a</code>. 
</p>
<p>The  Inverse weibull density for a response <code class="reqn">Y</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">f(y;a,b) = a (b^a) y^{-a-1} \exp[-(y/b)^(-a)] </code>
</p>

<p>for <code class="reqn">a &gt; 0</code>, <code class="reqn">b &gt; 0</code>, <code class="reqn">y &gt; 0</code>.
The mean, that is returned as the fitted values, (if <code class="reqn">a &gt; 1</code>) and 
the variance (if <code class="reqn">a &gt; 2</code>) are
</p>
<p style="text-align: center;"><code class="reqn">E[Y] = b \ \Gamma(1 - 1/a); \ \ \ Var[Y] = b^{2} \ 
  [\Gamma(1 - 2/a) - (\Gamma(1 - 1/a))^2].</code>
</p>

<p>Fisher scoring is used to estimate both parameters.
Although the expected information matrices used are valid in all regions of 
the parameter space, the regularity conditions for maximum likelihood 
estimation (MLE) are satisfied only if <code class="reqn">a&gt;2</code> 
(according to Kleiber and Kotz (2003)). If this is violated then a warning 
message is issued. To enforce <code class="reqn">a &gt; 2</code>, it has been set by default 
that <code>lshape = logofflink(offset = 2)</code>.
</p>
<p>As a result of the math relation between the Weibull and the Inverse Weibull
distributions, regularity conditions for inference for the latter, are the
following:

if <code class="reqn">a \le 1</code> then the MLE's are not consisten, 
if <code class="reqn">1 &lt; a &lt; 2</code> then MLEs exist but are not assymptotically 
normal, if <code class="reqn">a = 2</code>, the MLE's exist and are normal and 
asymptotically efficient but the convergence rate is slower compared when 
<code class="reqn">a &gt; 2</code>. If <code class="reqn">a &gt; 2</code>, then the MLE's have classical
asymptotic properties.















</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>).
The object is used to model special models such as 
<code><a href="VGAM.html#topic+vglm">vglm</a></code> and <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Warning</h3>

<p>Note that <code>zero</code> can be a <b>numeric</b> or a <b>character</b> 
vector specifying the position of the names 
(partially or not) of the linear predictor modeled as intercept only.
In this family function these names are
</p>
<p><code>c("scale", "shape")</code>.
</p>
<p>Numeric values can be entered as usual.
See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> 
for further details.
For simplicity, the second choice is recommended.
</p>





<p>If the shape parameter is less than two (i.e. less than 
<code>exp(0.69315)</code>), then misleading inference may
result ! (see above the regularity condition for the 'variance'), 
e.g., in the <code>summary</code> and <code>vcov</code> of the object.
</p>
<p>However, the larger the shape parameter is (for instance, greater than 
<code>exp(2.5)</code>, plus reasonable scale), the more unstable the algorithm
may become. The reason is that inverse weibull densities under such 
conditions are highly peaked and left skewed. Thus, density values are 
too close to zero (or values represented as zero in computer arithmetic).
</p>


<h3>Note</h3>

<p>By default, the shape paramater is modeled as intercept only.
</p>
<p>Successful convergence depends on having reasonably good initial
values. If the initial values chosen by this function are not good,
make use the two initial value arguments, <code>iscale</code> and <code>ishape</code>.
</p>
<p>This <span class="pkg">VGAM</span> family function currently handles <em>multiple responses</em> 
however, it does not handle censored data. This feature will be considered in 
a later version of the package.
</p>
<p>The Inverse Weibull distribution, which is that of <code class="reqn">Y = 1/X</code> 
where <code class="reqn">X</code> has the Weibull density, is known as the 
log-Gompertz distribution.





</p>


<h3>Author(s)</h3>

 
<p>Victor Miranda and T. W. Yee.
</p>


<h3>References</h3>

<p>Harper, W. V., Eschenbach, T. G. and James, T. R. (2011)
Concerns about Maximum Likelihood Estimation for the Three-Parameter
Weibull Distribution: Case Study of Statistical Software.
<em>The American Statistician</em>, <b>65(1)</b>, 44-54.
</p>
<p>Kleiber, C. and Kotz, S. (2003)
<em>Statistical Size Distributions in Economics and Actuarial Sciences</em>,
Hoboken, NJ, USA: Wiley-Interscience.
</p>
<p>Johnson, N. L. and Kotz, S. and Balakrishnan, N. (1994)
<em>Continuous Univariate Distributions</em>,
2nd edition, Volume 1, New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invweibullDist">invweibullDist</a></code>,
<code><a href="VGAM.html#topic+weibullR">weibullR</a></code>.








</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-----------------------------------------------------------------------#
# Here, covariate 'x2' affects the scale parameter.
# See how data is generated.

set.seed(102)
wdata &lt;- data.frame(x2 = runif(nn &lt;- 1000))  # Complete data
wdata &lt;- transform(wdata,
            y1 = rinvweibull(nn, scale = exp(2.5 - (0.5) * x2), 
                             shape = exp(1.5) ),
                             
            y2 = rinvweibull(nn, scale = exp(1.5 + x2), 
                             shape = exp(1.25) ))
            
#------------------------------------------------------------------------#
# Fitting the Inverse Weibull distribution accordingly.
# Note that multiple responses are handled. 

fit1 &lt;- vglm(cbind(y1, y2) ~ x2, 
             invweibull2mr(zero = "shape",
                           # OPTIONAL INITIAL VALUE. Be carefull here when
                           # entered initial value. Sensitive distribution
                             ishape = exp(1.2),
                          lss = TRUE),                           
             data = wdata, trace = TRUE, crit = "log")

coef(fit1, matrix = TRUE)
vcov(fit1)
summary(fit1)

###   A second option (producing same results!!) might be to use the 
###   constraints argument in the 'vglm()' call. Note that 'x2' affects
###   the scale parameter only.

fit2 &lt;- vglm(y1 ~ x2, 
             invweibull2mr(zero = NULL), 
             data = wdata, trace = TRUE,
             constraints = list(x2 = rbind(1, 0)))
            
coef(fit2, matrix = TRUE)
vcov(fit2)
summary(fit2)
constraints(fit2)



</code></pre>

<hr>
<h2 id='invweibullDist'>The Inverse Weibull Distribution</h2><span id='topic+invweibullDist'></span><span id='topic+dinvweibull'></span><span id='topic+pinvweibull'></span><span id='topic+qinvweibull'></span><span id='topic+rinvweibull'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random numbers 
generator for the Inverse Weibull Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    dinvweibull(x, scale = 1, shape, log = FALSE)
    pinvweibull(q, scale = 1, shape, lower.tail = TRUE, log.p = FALSE)
    qinvweibull(p, scale = 1, shape, lower.tail = TRUE, log.p = FALSE)
    rinvweibull(n, scale = 1, shape)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invweibullDist_+3A_x">x</code>, <code id="invweibullDist_+3A_q">q</code>, <code id="invweibullDist_+3A_p">p</code>, <code id="invweibullDist_+3A_n">n</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Weibull">Weibull</a></code>. 
</p>
</td></tr>
<tr><td><code id="invweibullDist_+3A_scale">scale</code>, <code id="invweibullDist_+3A_shape">shape</code></td>
<td>
 
<p>Scale and shape parameters, same as <code><a href="stats.html#topic+Weibull">Weibull</a></code>.
Both must be positive. 
</p>
</td></tr>
<tr><td><code id="invweibullDist_+3A_log">log</code>, <code id="invweibullDist_+3A_log.p">log.p</code>, <code id="invweibullDist_+3A_lower.tail">lower.tail</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Weibull">Weibull</a></code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Inverse Weibull density with parameters scale = <em>b</em> and 
shape = <code class="reqn">s</code>, is
</p>
<p style="text-align: center;"><code class="reqn">f(y) = s b^s y^{-s-1} \exp{[-(y/b)^{-s}}],</code>
</p>

<p>for <code class="reqn">y &gt; 0</code>, <code class="reqn">b &gt; 0</code>, and <code class="reqn">s &gt; 0</code>. 
</p>
<p>The Weibull distribution and the Inverse Weibull distributions are related
as follows:
</p>
<p>Let <code class="reqn">X</code> be a Weibull random variable with paramaters scale =<code class="reqn">b</code>
and shape =<code class="reqn">s</code>. Then, the random variable <code class="reqn">Y = 1/X</code> has 
the Inverse Weibull density with parameters scale = <code class="reqn">1/b</code> and 
shape = <code class="reqn">s</code>. Thus, algorithms of <em>[dpqr]-Inverse Weibull</em> 
underlie on <code><a href="stats.html#topic+Weibull">Weibull</a></code>.
</p>
<p>Let <code class="reqn">Y</code> be a r.v. distributed as Inverse Weibull (<code class="reqn">b, s</code>).
The <code class="reqn">k^{th}</code> moment exists for 
<code class="reqn">-\infty &lt; k &lt; s</code> and is given by
</p>
<p style="text-align: center;"><code class="reqn">E[Y^k] = b^{k} \ \Gamma(1 - k/s).</code>
</p>

<p>The mean (if <code class="reqn">s &gt; 1</code>) and variance (if <code class="reqn">s &gt; 2</code>) are
</p>
<p style="text-align: center;"><code class="reqn">E[Y] = b \ \Gamma(1 - 1/s); \ \ \ Var[Y] = b^{2} \ 
  [\Gamma(1 - 2/s) - (\Gamma(1 - 1/s))^2].</code>
</p>





<p>Here, <code class="reqn">\Gamma(\cdot)</code> is the gamma function as in 
<code><a href="base.html#topic+Special">gamma</a></code>. 
</p>


<h3>Value</h3>

<p><code>dinvweibull()</code> returns the density, <code>pinvweibull()</code> computes the 
distribution function, <code>qinvweibull()</code> gives the quantiles, and 
<code>rinvweibull()</code> generates random numbers from the Inverse Weibull 
distribution.
</p>


<h3>Warning</h3>

<p>The order of the arguments of <em>[dpqr]-Inverse Weibull</em> does not match 
those in <code><a href="stats.html#topic+Weibull">Weibull</a></code>.
</p>


<h3>Note</h3>




<p>Small values of <em>scale</em> or <em>shape</em> will provide Inverse Weibull 
values too close to zero. Then, function <code>rinvweibull()</code> with such 
characteristics will return either values too close to zero or values
represented as zero in computer arithmetic.
</p>
<p>The Inverse Weibull distribution, which is that of <code class="reqn">X</code> where 
<code class="reqn">1/X</code> has the Weibull density, is known as the log-Gompertz
distribution. Thus, in order to emphazise the continuity concept of the 
Inverse Weibull density, if <code class="reqn">x = 0</code>, then <code>dinvweibull</code> 
returns zero, which is the limit of such a density when <code class="reqn">'x'</code> 
tends to zero.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee.</p>


<h3>References</h3>

<p>Kleiber, C. and Kotz, S. (2003) 
<em>Statistical Size Distributions in Economics and Actuarial Sciences</em>.
Wiley Series in Probability and Statistics. Hoboken, New Jersey, USA.
</p>
<p>Abramowitz, M. and Stegun, I. A. (1972) 
<em>Handbook of Mathematical Functions with Formulas, Graphs, and 
Mathematical Tables</em>.
ch.6, p.255. Dover, New York, USA.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">Weibull</a></code>,
<code><a href="base.html#topic+Special">gamma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #(1) ______________
  n        &lt;- 20
  scale    &lt;- exp(2)
  shape    &lt;- exp(1)
  data.1   &lt;- runif(n, 0, 1)
  data.q   &lt;- qinvweibull(-data.1, scale = scale, shape = shape, log.p = TRUE)  
  data.p   &lt;- -log(pinvweibull(data.q, scale = scale, shape = shape)) 
  arg.max  &lt;- max(abs(data.p - data.1))     # Should be zero
  

  #(2)_________________
   scale  &lt;- exp(1.0)
    shape &lt;- exp(1.2)
    xx    &lt;- seq(0, 10.0, len = 201)
    yy    &lt;- dinvweibull(xx, scale = scale, shape = shape)
    qtl   &lt;- seq(0.1, 0.9, by =0.1)
    d.qtl &lt;- qinvweibull(qtl, scale = scale, shape = shape)
    plot(xx, yy, type = "l", col = "red", 
         main = "Red is density, blue is cumulative distribution function",
         sub  = "Brown dashed lines represent the 10th, ... 90th percentiles",
         las = 1, xlab = "x", ylab = "", ylim = c(0,1))
    abline(h = 0, col= "navy", lty = 2)
    lines(xx, pinvweibull(xx, scale = scale, shape = shape), col= "blue")
    lines(d.qtl, dinvweibull(d.qtl, scale = scale, shape = shape), 
          type ="h", col = "brown", lty = 3)
        
</code></pre>

<hr>
<h2 id='KPSS.test'>KPSS tests for stationarity</h2><span id='topic+KPSS.test'></span>

<h3>Description</h3>

<p>The Kwiatkowski-Phillips-Schmidt-Shin (KPSS) 
test for the null hypothesis that the series <code class="reqn">x</code> is
<code>level</code> or <code>trend</code> stationary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>           KPSS.test(x, type.H0 = c("level", "trend")[1],
                        trunc.l = c("short", "large")[1],
                        show.output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KPSS.test_+3A_x">x</code></td>
<td>

<p>Numeric. A univariate series.
</p>
</td></tr>
<tr><td><code id="KPSS.test_+3A_type.h0">type.H0</code></td>
<td>

<p>The null hypothesis to be tested: either <code>level</code> or
<code>trend</code> stationarity.
</p>
</td></tr>
<tr><td><code id="KPSS.test_+3A_trunc.l">trunc.l</code></td>
<td>

<p>The lag truncation parameter. See below for more details.
</p>
</td></tr>
<tr><td><code id="KPSS.test_+3A_show.output">show.output</code></td>
<td>

<p>Logical. Should the results be displyed? Default is 
<code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test the null hypothesis that a univariate time series
is level&ndash;stationary or stationary around a deterministic
trend. The alternative states the existence of a unit root.
</p>
<p>Under this methodology, the series, say
<code class="reqn"> \{ y_t;~t = 1, \ldots, T\} </code>
is assumed to be decomposed as
</p>
<p style="text-align: center;"><code class="reqn">y_t = \rho t + \xi_t + \varepsilon_t,</code>
</p>

<p>that is, as the sum of a deterministic trend, 
a random walk (<code class="reqn">\xi_t</code>), and a stationary error
(<code class="reqn">\varepsilon_t \sim N(0, \sigma^2_z)</code>. 
Hence, this test reduces to simply test the
hypothesis that <code class="reqn">\{ \xi_t \} </code> 
is stationary,
that is, <code class="reqn">H_0: \sigma^2_z = 0.</code>
</p>
<p>The test statistic combines the one&ndash;sided Lagrange
multiplier (LM) statistic 
and the <em>locally best invariant</em> (LBI) test
statistic (Nabeya and Tanaka, (1988)). 
Its asymptotic distribution is discussed
in Kwiatkowski et al. (1992), and depends on 
the &lsquo;long&ndash;run&rsquo; variance <code class="reqn">\sigma^2</code>.
The test statistic is given by
</p>
<p style="text-align: center;"><code class="reqn">\eta = T^{-2} \sum_i S^2_i / \widehat{\sigma}^2= 
 T^{-2} \sum_i S^2_i / s^2(l).</code>
</p>

<p>where <code class="reqn">s^2(l)</code> is a consistent estimate of
<code class="reqn">\sigma^2</code>, given by
</p>
<p style="text-align: center;"><code class="reqn">s^2(l) = (1/T)\sum_{t = 1}^T\varepsilon^2_t + 
   (2 / T) \sum_{s = 1}^l w(s, l) \sum_{t = s + 1}^T \varepsilon_t
   \varepsilon_{t - s}.</code>
</p>

<p>Here, <code class="reqn">w(s, l) = 1 - s/(l + 1)</code>, where
<code>l</code> is taken from <code>trunc.l</code>, the 
lag&ndash;truncation parameter. The choice <code>"short"</code> 
gives the smallest integer not less than
<code class="reqn">3 \sqrt{T} / 11</code>, or else,
<code class="reqn">9 \sqrt{T} / 11</code>, if
<code>trunc.l = "large"</code>.
</p>
<p>Note, here the errors, <code class="reqn">\varepsilon_t</code>, are
estimated from the regression 
<code class="reqn">x ~ 1</code> (level) or <code class="reqn">x ~ 1 + t</code> (trend), depending upon 
the argument <code>type.H0</code>.
</p>
<p>Unlike other software using linear interpolates, here
the p&ndash;values for both, trend and level stationarity,
are interpolated by cubic spline interpolations 
from the tail critical values given 
in Table 1 in Kwiatkowski et al. (1992).
The interpolation takes place on <code class="reqn">\eta</code>. 
</p>


<h3>Value</h3>

<p>A list with the following:
</p>
<p>1) Test statistic and P-value,
</p>
<p>2) Critical values,
</p>
<p>3) Residuals, <code class="reqn">\varepsilon_t</code>.
</p>


<h3>Note</h3>

<p>There is no standard methodology to select an 
appropriate value for <code>trunc.l</code>, however,
satisfactory results have been found for 
<code>trunc.l</code> proportional to <code class="reqn">T^{1/2}</code>.
See Andrews, D.W.K. (1991) for a discussion on this.
Empirically, this parameter may be <em>suggested</em>
by the problem in turn, and should be large enough to 
approximate the true dynamic behaviour of the series.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda.
</p>


<h3>References</h3>

<p>Andrews, D.W.K. (1991)
Heteroskedasticiy and autocorrelation consistent
covariance matrix estimation.
<em>Econometrica</em>, <span class="pkg">59</span>, 817&ndash;858.
</p>
<p>Kwiatkowski, D., Phillips, P.C.B., 
Schmidt, P., and Shin, Y. (1992)
Testing the null hypothesis of stationarity against
the alternative of a unit root.
<em>Journal of Econometrics</em>, <span class="pkg">54</span>, 159&ndash;178.
</p>
<p>Nabeya, S. and Tanaka, K. (1988)
Asymptotic theory of a test for the constancy
regression coefficients against the random walk
alternative.
<em>Annals of Statistics</em>, <span class="pkg">16</span>, 218&ndash;235.
</p>
<p>Phillips, P.C.B. and Perron, P. (1988)
Testing for a unit root in time series regression.
<em>Biometrika</em>, <span class="pkg">75</span>, 335&ndash;346.
</p>
<p>Phillips, P.C.B. (1987)
Time series with unit roots.
<em>Econometrica</em>, <span class="pkg">55</span>, 277&ndash;301
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkTS.VGAMextra">checkTS.VGAMextra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2802)
test &lt;- KPSS.test(rnorm(20), type.H0 = "trend")
class(test)

test$crit.value
</code></pre>

<hr>
<h2 id='logffMlink'>
Link functions for the mean of 1&ndash;parameter 
discrete distributions: The Logarithmic Distribuion.
</h2><span id='topic+logffMlink'></span><span id='topic+logfflink.inv.deriv0'></span>

<h3>Description</h3>

<p>Computes the <code>logffMlink</code> transformation, including its inverse
and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    logffMlink(theta, bvalue = NULL, 
                alg.roots = c("Newton-Raphson", "bisection")[1],
                inverse = FALSE, deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logffMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> by default although could
be <code class="reqn">\eta</code> depending on other parameters. See below for details.
</p>
</td></tr>
<tr><td><code id="logffMlink_+3A_bvalue">bvalue</code></td>
<td>

<p>This is a boundary value. See below. 
Also refer to <code><a href="VGAM.html#topic+Links">Links</a></code> for additional
details.
</p>
</td></tr>
<tr><td><code id="logffMlink_+3A_alg.roots">alg.roots</code></td>
<td>

<p>Character. The iterative algorithm to find the inverse of this link
function. Default is the first (Newton&ndash;Raphson). Optionally, the 
bisection method is also available. See below for more details.
</p>
</td></tr>
<tr><td><code id="logffMlink_+3A_inverse">inverse</code>, <code id="logffMlink_+3A_deriv">deriv</code>, <code id="logffMlink_+3A_short">short</code>, <code id="logffMlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This link function arises as a natural link function for the mean,
<code class="reqn">\mu</code>, of the logarithmic (or log-series) distribution, 
<code><a href="VGAM.html#topic+logff">logff</a></code>. It is defined for any value 
of the shape parameter <code class="reqn">s</code> (i.e. <code>theta</code> in the 
VGLM/VGAM context), <code class="reqn">0 &lt; s &lt; 1</code>, as the
logarithm of <code class="reqn">\mu = \mu(s)</code>. It can be easily shown that 
<code>logffMlink</code> is the difference of two common link functions: 
<code><a href="VGAM.html#topic+logitlink">logitlink</a></code> and 
<code><a href="VGAM.html#topic+clogloglink">clogloglink</a></code>.
</p>
<p>It is particularly usefull for event&ndash;rate data where the expected 
number of events can be modelled as

</p>
<p style="text-align: center;"><code class="reqn">\mu = \mu(s) = \lambda t.</code>
</p>


<p>Here <code class="reqn">\lambda</code> is the standardized mean (or event-rate) 
per unit time, <code class="reqn">t</code> is the timeframe observed, 
whereas <code class="reqn">\mu</code> and <code class="reqn">s</code> are the mean and the 
shape parameter of the logarithmic distribution respectively.
The logarithm is then applied to both sides so 
that <code class="reqn">t</code> can be incorporated in the analysis as an offset. 
</p>
<p>While <code>logffMlink</code> is not the canonical link function of 
the logarithmic distribution, it is certainly part of the
canonical link, given by the composite

</p>
<p style="text-align: center;"><code class="reqn">\log \circ~(g^{-1}) \circ \log,</code>
</p>


<p>where <code class="reqn">g^{-1}</code> denotes the inverse of
<code>logffMlink</code>.
</p>
<p>The domain set of this link function is <code class="reqn">(0, 1)</code>. 
Therefore, values of <code>theta</code> (that is <code class="reqn">s</code>) too close to 
<code class="reqn">0</code> or to <code class="reqn">1</code> or out of range will result in <code>Inf</code>, 
<code>-Inf</code>, <code>NA</code> or <code>NaN</code>. Use argument <code>bvalue</code> 
to adequately replace them before computing the link function.
</p>
<p>Particularly, if <code>inverse = TRUE</code> and <code>deriv = 0</code>,
then <code class="reqn">s</code> becomes <code class="reqn">\eta</code>, and therefore the domain set 
turns to <code class="reqn">(0, \infty)</code>.
</p>
<p>If <code>theta</code> is a character, then arguments <code>inverse</code> and
<code>deriv</code> are disregarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>logffMlink</code> transformation of 
<code>theta</code>, i.e., <code>logitlink(theta) - clogloglink(theta)</code>, if 
<code>inverse = FALSE</code>. 
</p>
<p>When <code>inverse = TRUE</code> the vector entered at <code>theta</code> 
becomes <code class="reqn">\eta</code> and, then, this link function 
returns a unique vector <code class="reqn">\theta_{\eta}</code> such that 

</p>
<p style="text-align: center;"><code class="reqn"> {\tt{logffMlink}} (\theta_{\eta}) = \eta,</code>
</p>


<p>i.e., the inverse image of <code class="reqn">\eta</code>.
Specifically, the inverse of <code>logffMlink</code> cannot be written in 
closed&ndash;form, then the latter is equivalent to search for the roots 
of the function 

</p>
<p style="text-align: center;"><code class="reqn"> {\tt{logff.func}}(\theta) = {\tt{logffMlink}}(\theta) - \eta </code>
</p>
 

<p>as a function of <code class="reqn">\theta</code>. To do this, the auxiliary 
function <code>logff.func</code> is internally generated. 
Then, with the method established at <code>alg.roots</code>, 
either Newton&ndash;Raphson or bisection, this link function
approximates and returns the inverse image 
<code class="reqn">\theta_{\eta}</code> (of given <code class="reqn">\eta</code>), which 
plays the role of the inverse of <code>logffMlink</code>. In particular, 
for <code class="reqn">\eta = 0</code> and <code class="reqn">\eta =</code><code>Inf</code>, it returns <code class="reqn">0</code> 
and <code class="reqn">1</code> respectively.
</p>
<p>For <code>deriv = 1</code>, <em>d</em> <code>eta</code> / <em>d</em> <code>theta</code> 
as a function of <code>theta</code> if <code>inverse = FALSE</code>, else 
the reciprocal <em>d</em> <code>theta</code> / <em>d</em> <code>eta</code>.
</p>
<p>Similarly, when <code>deriv = 2</code> the second order derivatives 
are correspondingly returned.
</p>
<p>Both, first and second derivatives, can be written in closed&ndash;form.
</p>


<h3>Warning</h3>

<p><code><a href="#topic+logffMlink">logffMlink</a></code> is a monotonically
increasing, convex, and strictly positive function in <code class="reqn">(0, 1)</code> such
that the horizontal axis is an asymptote. Therefore, when the inverse 
image of <code class="reqn">\eta</code> is required, each entry of <code class="reqn">\eta</code> 
(via argument <code>theta</code>) must be non-negative so that 
<code class="reqn">{\tt{logff.func}(\theta; \eta) = \tt{logffMlink}}(\theta) - \eta</code> 
is <em>shifted down</em>. This fact allows this function to uniquely 
intersect the horizontal axis which guarantees to iteratively find 
the corresponding root <code class="reqn">\theta_{\eta}</code>, i.e., the
inverse image of <code class="reqn">\eta</code>. Else, <code>NaN</code> will be returned.
</p>
<p>See example 3. It is the plot of <code>logffMlink</code> in <code class="reqn">(0, 1)</code>
for <code class="reqn">\eta = 1.5</code>.
</p>
<p>Besides, the vertical straight line <code>theta</code><code class="reqn"> = 1</code> is also
an asymptote. Hence, this link function may grow sharply for
values of <code>theta</code> too close to <code class="reqn">1</code>.
See Example 4 for further details.
</p>


<h3>Note</h3>

<p>To find the inverse image <code class="reqn">\theta_{\eta}</code> of 
<code class="reqn">\eta</code>, either
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code> 
or <code><a href="VGAM.html#topic+bisection.basic">bisection.basic</a></code> is
called.
</p>
<p>This link function can be used for modelling any parameter lying 
between 0.0 and 1.0. Consequently, when there are covariates, 
some problems may occur. For example, the method entered 
at <code>alg.roots</code> to approximate the inverse image may converge
at a slow rate. Similarly if the sample size is small, less than 20 say.
Try another link function, as 
<code><a href="VGAM.html#topic+logitlink">logitlink</a></code>, in such cases.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+logff">logff</a></code>,
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code>,
<code><a href="VGAM.html#topic+bisection.basic">bisection.basic</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>, 
<code><a href="VGAM.html#topic+clogloglink">clogloglink</a></code>,
<code><a href="VGAM.html#topic+logitlink">logitlink</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1  ##
set.seed(0906)
Shapes &lt;- sort(runif(10)) 
logffMlink(theta = Shapes, deriv = 1)    ## d eta/d theta, as function of theta

logldata.inv &lt;-
       logffMlink(theta = logffMlink(theta = Shapes), inverse = TRUE) - Shapes
                      
summary(logldata.inv)                   ## Should be zero


## Example 2 Some probability link funtions ##
s.shapes &lt;- ppoints(100)

par(lwd = 2)
plot(s.shapes, logitlink(s.shapes), xlim = c(-0.1, 1.1), type = "l", col = "limegreen", 
     ylab = "transformation", las = 1, main = "Some probability link functions")
lines(s.shapes, logffMlink(s.shapes), col = "blue")
lines(s.shapes, probitlink(s.shapes), col = "purple")
lines(s.shapes, clogloglink(s.shapes), col = "chocolate")
lines(s.shapes, cauchitlink(s.shapes), col = "tan")
abline(v = c(0.5, 1), lty = "dashed")
abline(v = 0, h = 0, lty = "dashed")
legend(0.1, 4.5, c("logffMlink","logitlink", "probitlink", "clogloglink",
"cauchitlink"),
       col = c("blue", "limegreen", "purple", "chocolate", "tan"), lwd = 1)
par(lwd = 1) 


## Example 3. Plot of 'logffMlink()' with eta = 1.5.  ##
m.eta1.5 &lt;- logffMlink(theta = s.shapes, deriv = 0) - 1.5

 plot(m.eta1.5 ~ s.shapes, type = "l", col = "limegreen", 
      las = 1, lty = 2, lwd = 3, xlim = c(-0.1, 1.0), ylim = c(-2, 3),
      xlab = "shape parameter, s, in (0, 1).", 
      ylab = "logffMlink(s) - 1.5",
      main = "logff.func(s; 1.5) = logffMlink(s) - 1.5, in (0, 1)")
 abline(h = 0, v = 0)
 abline(v = 1.0, lty = 2)
 

## Example 4. Special values of theta, inverse = FALSE ##
s.shapes &lt;- c(-Inf, -2, -1, 0.0, 0.25, 0.5, 1, 10, 100, Inf, NaN, NA) 
rbind(s.shapes, logffMlink(theta = s.shapes))
</code></pre>

<hr>
<h2 id='MAXff'>VGLTSMs
Family Functions: Order&ndash;q Moving Average Model with covariates </h2><span id='topic+MAXff'></span>

<h3>Description</h3>

<p>Estimates the intercept, standard deviation (or variance) of the 
random noise (not necessarily constant), and
the conditional&ndash;mean model coefficients of an
order&ndash;q moving average (MA) process with covariates (MAX(q))
by maximum likelihood estimation using Fisher scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      MAXff(order    = 1,
            zero     = c(if (nomean) NULL else "Mean", "MAcoeff"),
            xLag     = 0,
            type.EIM = c("exact", "approximate")[1],
            var.arg  = TRUE, 
            nomean   = FALSE,
            noChecks = FALSE,
            lmean    = "identitylink", 
            lsd      = "loglink",
            lvar     = "loglink",
            lMAcoeff = "identitylink",
            imean    = NULL,
            isd      = NULL,
            ivar     = NULL,
            iMAcoeff = NULL)      
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAXff_+3A_order">order</code></td>
<td>

<p>The order 'q' of the MA model, recycled if needed.
By default <code>q = 1</code>.
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_zero">zero</code></td>
<td>

<p>Integer or character&ndash;string vector.
Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
Details at <code><a href="VGAM.html#topic+zero">zero</a></code>.
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_xlag">xLag</code></td>
<td>

<p>Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_type.eim">type.EIM</code>, <code id="MAXff_+3A_var.arg">var.arg</code></td>
<td>

<p>Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_nomean">nomean</code></td>
<td>

<p>Logical. <code>nomean = TRUE</code> supresses estimation of the 
<em>mean</em> (intercept of the conditional&ndash;mean model).
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_nochecks">noChecks</code></td>
<td>

<p>Logical. Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_lmean">lmean</code>, <code id="MAXff_+3A_lsd">lsd</code>, <code id="MAXff_+3A_lvar">lvar</code>, <code id="MAXff_+3A_lmacoeff">lMAcoeff</code></td>
<td>

<p>Link functions applied to the mean (intercept),
the standard deviation or variance of the random noise, and
the MA coefficients (conditional&ndash;mean model).
Note, <code>lmean</code> plays the role of <code>ldrift</code>.
</p>
</td></tr>
<tr><td><code id="MAXff_+3A_imean">imean</code>, <code id="MAXff_+3A_isd">isd</code>, <code id="MAXff_+3A_ivar">ivar</code>, <code id="MAXff_+3A_imacoeff">iMAcoeff</code></td>
<td>

<p>Same as <code><a href="#topic+ARIMAXff">ARIMAXff</a></code>.
Note, <code>imean</code> plays the role of <code>idrift</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to <code><a href="#topic+ARXff">ARXff</a></code>,
this family function fits an order&ndash;<code class="reqn">q</code> moving average model
with covariates (MAX(q)),
another special case of the class VGLM&ndash;ARIMA
(Miranda and Yee, 2018). Observations, <code class="reqn">Y_t</code>, are
modelled as
</p>
<p style="text-align: center;"><code class="reqn"> Y_t | \Phi_{t - 1} = \mu_t + \phi_{1} \varepsilon_{t - 1} +
\ldots + \phi_q \varepsilon_{t - q} + \varepsilon_t,</code>
</p>

<p>where <code class="reqn">\mu_t</code> is the (possibly time&ndash;dependent) intercept,
modelled as
<code class="reqn">\mu_t = \mu + \boldsymbol{\beta}^T \boldsymbol{x}_t</code>, and
the errors are mean&ndash;zero Gaussian:
<code class="reqn">\varepsilon_t | \Phi_{t - 1} \sim 
  N(0, \sigma^2_{\varepsilon_t | \Phi_{t - 1}})</code>.
The symbol
<code class="reqn">\Phi_{t}</code> denotes the history
of the joint process
<code class="reqn">\left(Y_{t}, \boldsymbol{X}_{t + 1}^T \right)</code>,
at time <code class="reqn">t</code> for a time&ndash;varying covariate 
vector <code class="reqn">\boldsymbol{x}_t</code>.
</p>
<p>At each step of Fisher scoring, the <em>exact</em> log-likelihood
based on model above 
is computed through <code><a href="#topic+dMAq">dMAq</a></code>.
</p>
<p>The linear predictor by default is 
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\eta} = \left( 
\mu_t, \log \sigma^{2}_{\varepsilon_{t | \Phi_{t - 1}}},
\phi_1, \ldots, \phi_q
\right)^T.</code>
</p>
 
<p>The unconditional mean of the process is simply
<code class="reqn"> E(Y_{t}) = \mu</code>, provided no covariates added.
</p>
<p>This family function
is not restricted to the noise to be strictly white noise
(in the sense of <em>constant variance</em>). 
That is, covariates may be incorporated in the linear predictor
<code class="reqn">\log \sigma^{2}_{\varepsilon_{t | \Phi_{t - 1}}}.</code> Also, it handles
<em>multiple responses</em> so that a matrix can be used as the response.
For further details on VGLM/VGAM&ndash;link functions,
such as <code><a href="VGAM.html#topic+logitlink">logitlink</a></code>, refer to 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>) to be
used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Warning</h3>

<p>By default, a moving-average model of order-<code class="reqn">1</code> is fitted.
</p>
<p>If different, the <code>order</code> is recycled up to the number of responses
entered in the <code>vglm \ vgam</code> call has been matched.
</p>
<p>Successful convergence depends on reasonably setting initial values. If 
initial values computed by the algorithm are not adequate, make use of 
the the optional initial values (<code>imean</code>, <code>isd</code>, etc.)
</p>
<p>For constraints on the paramaters see
<code><a href="#topic+cm.ARMA">cm.ARMA</a></code>.
</p>


<h3>Note</h3>

<p>Further choices for the random noise, besides Gaussian, will be
implemented over time.
</p>
<p><code>zero</code> can be either an <em>integer</em> vector
or a vector of <b>character strings</b>
specifying either the position(s) or name(s) (partially or not) of the 
parameter(s) modeled as intercept-only. For <code>MAXff</code>,
the parameters are placed and named as follows (by convention):
</p>
<p><code>c("Mean", "noiseVar" or "noiseSD", "MAcoeff")</code>.
</p>
<p>Users can modify the <code>zero</code> argument accordingly.
For simplicity, the second choice recommended.
See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> 
for further details on <code>zero</code>.
</p>
<p>If <b>no</b> constraints are entered in the fitting process,
(e.g., via <code><a href="#topic+cm.ARMA">cm.ARMA</a></code>)
this family function internally verifies by default
whether the estimated series
is invertible (since <code>noChecks = FALSE</code>).
To ignore this step, set <code>noChecks = TRUE</code>.
If the estimated MA process is non-invertible, MLE
coefficients will conform with the corresponding
invertible MA model.
</p>
<p>Further details about these checks are shown within 
the <code>summary()</code> output.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Miranda, V. and Yee, T.W. (2018)
Vector Generalized Linear Time Series Models.
<em>In preparation</em>.
</p>
<p>Madsen, H. (2008)
<em>Time Series Analysis</em>
Florida, USA: <em>Chapman &amp; Hall</em>.
(Sections 5.3 to 5.5).
</p>
<p>Tsay, R. (2013) 
An Introduction to Analysis of Financial data with <code>R</code>. 
New Jersey, USA: <em>Wiley</em> Sections 2.2 to 2.4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARIMAXff">ARIMAXff</a></code>,
<code><a href="#topic+ARXff">ARXff</a></code>,
<code><a href="#topic+checkTS.VGAMextra">checkTS.VGAMextra</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>,
<code><a href="VGAM.html#topic+vglm">vgam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
nn    &lt;- 130
### Coefficients
phi1  &lt;-  0.34; phi2 &lt;- -1.19; phi3 &lt;- 0.26
### Intercept
mu    &lt;- c(-1.4, 2.3)
### Noise standar deviations (Two responses)
sdMA  &lt;- c(sqrt(6.5), sqrt(4.0))
### A single covariate.
Xcov &lt;- runif(nn)

# Generating two MA processes, TS1 and TS2, Gaussian noise.
# Note, the SD noise for TS2 is function of Xcov.

y1   &lt;- mu[1] + arima.sim(nn, 
                          model = list( ma = c(phi1, phi1^2)), 
                          rand.gen = rnorm, sd = exp(sdMA[1]) ) 
y2   &lt;- mu[2] + arima.sim(nn, 
                          model = list( ma = c(phi1, phi2, phi3) ), 
                          rand.gen = rnorm, sd = exp(Xcov + sdMA[2]) )
# OUR DATA
tsdata &lt;- data.frame(x2 = Xcov , TS1 = y1, TS2 = y2)

#------------------------------------------------------------------------#
# 1. A simple MA(3) to compare with 'arima()'.

myfit0 &lt;- vglm(TS1 ~ 1,
               MAXff(order = 3, type.EIM = "exact",
                    var.arg = FALSE),
               #constraints = cm.ARMA(Model = ~ 1, 
               #                      lags.cm = 2, 
               #                      Resp = 1),
               data = tsdata, trace = TRUE) 

Coef(myfit0)[c(3, 4, 1)]
fitArima &lt;- arima(tsdata$TS1, order = c(0, 0, 2)) 
coef(fitArima)

AIC(myfit0); BIC(myfit0)

# ------------------------------------------------------------------------#
# 2. Estimate an MA(3), intercept-only, using initial values.

myfit &lt;- vglm(TS2 ~ 1,
              MAXff(order = 3, type.EIM = c("exact", "approx")[1],
                   # Optional initial values.
                    imean = 3,
                    iMAcoeff = c(0.3, -0.2, 0.25),
                   var.arg = TRUE),
              data = tsdata, trace = TRUE)

Coef(myfit)
summary(myfit)
constraints(myfit)


#----------------------------------------#
# Same model fitted using arima()
#----------------------------------------#

fitArima &lt;- arima(tsdata$TS2, order = c(0, 0, 3)) 
coef(fitArima)


#------------------------------------------------------------------------#
# 3. An MAX(3) with one covariate, testing its effect over the
#    standard deviation of the Gaussian noise. Note the 'zero' argument.

myfit1 &lt;- vglm(TS2 ~ x2,
               # Or Multiple responses! 
               # cbind(TS1, TS2) ~ 1,
               MAXff(order = 3, type.EIM = "exact", xLag = 1,
                    # Optional initial values:
                    # idev.mean = 1.4, 
                    # iMAcoeff = c(2.3, -1.2, 0.25), isd = 1.6,
                    
                    # NOTE THE ZERO ARGUMENT:
                    zero = c("Mean", "MAcoeff"),
                    
                    var.arg = TRUE),
               data = tsdata, trace = TRUE)

coef(myfit1, matrix = TRUE) 
summary(myfit1)
vcov(myfit1)

constraints(myfit1)

#------------------------------------------------------------------------#
# Model above CANNOT be fitted using arima()
#------------------------------------------------------------------------#

</code></pre>

<hr>
<h2 id='maxwellQlink'>
Link functions for the quantiles of several 1&ndash;parameter continuous
distributions
</h2><span id='topic+maxwellQlink'></span>

<h3>Description</h3>

<p>Computes the <code>maxwellQlink</code> transformation, its inverse and the
first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  maxwellQlink(theta, p = stop("Argument 'p' must be specified."),
               bvalue = NULL, inverse = FALSE,
               deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxwellQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. See below for further details.
</p>
</td></tr>
<tr><td><code id="maxwellQlink_+3A_p">p</code></td>
<td>

<p>Numeric. A single value between 0 and 1.
It is the <code class="reqn">p</code>&ndash;quantile to be modeled by this link function. 
</p>
</td></tr>
<tr><td><code id="maxwellQlink_+3A_bvalue">bvalue</code>, <code id="maxwellQlink_+3A_inverse">inverse</code>, <code id="maxwellQlink_+3A_deriv">deriv</code>, <code id="maxwellQlink_+3A_short">short</code>, <code id="maxwellQlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the VGLM/VGAM quantile regression context, this link function 
can be used to model any <code class="reqn">p</code>&ndash;quantile of the 
Maxwell distribition. It is the <code>maxwellQlink</code> transformation
given by 

</p>
<p style="text-align: center;"><code class="reqn">\sqrt{ 2~\textrm{\texttt{qgamma(p, 1.5) / a.}}}</code>
</p>
 

<p>Here, <code class="reqn">a</code> is positive parameter as in 
<code><a href="VGAM.html#topic+maxwell">maxwell</a></code> 
whereas  <code><a href="stats.html#topic+qgamma">qgamma</a></code> is the quantile 
function of the gamma distribution. 
</p>
<p>Numerical values of <code class="reqn">a</code> or <code class="reqn">p</code> out of range will 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>
correspondingly.
</p>
<p>In particular, arguments <code>inverse</code> and <code>deriv</code> are
disregarded if <code>theta</code> is character. 
Also, if  <code>inverse = TRUE</code> and <code>deriv = 0</code>, then argument
<code>theta</code> becomes <code class="reqn">\eta</code>. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details about this.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>maxwellQlink</code> transformation of
<code>theta</code>, when <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, 
then the inverse given by <code>2*qgamma(p, 1.5) / theta^2 </code> is returned.
</p>
<p>For <code>deriv = 1</code>, this function returns the derivative 
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code>, 
if <code>inverse = FALSE</code>. Else, the reciprocal 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of <code>theta</code>.
</p>
<p>If <code>deriv = 2</code>, then the second order derivatives in terms of
<code>theta</code> are accordingly returned. 
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+maxwell">maxwell</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## E1. maxwellQlink() and its inverse ##
   p &lt;- 0.25        ## Modeling the first quartile
   my.a &lt;- seq(0, 5, by = 0.1)[-1]
   max(my.a - maxwellQlink(maxwellQlink(my.a, p = p), p = p, inverse  =TRUE)) ## Zero
    
  ## E2. The first two values are negative, NaN is returned ##
    maxwellQlink(theta = c(-0.15, -0.10, 0.25, 0.35) , p = p, inverse  = FALSE)
    maxwellQlink(theta = c(-0.15, -0.10, 0.25, 0.35) , p = p, inverse  = TRUE)

  ## E3. Plot of the maxwellQlink() and its inverse                    ##
  ## Note, inverse = TRUE implies that argument 'theta' becomes 'eta'. ##
   
  
   #--- THE LINK
   
   plot(maxwellQlink(theta = my.a, p = p) ~ my.a,
        type = "l", col = "blue", lty = "dotted", lwd = 3,
        xlim = c(-0.1, 10), ylim = c(-0.1, 5), las = 1,
        main = c("Blue is maxwellQlink(), green is the inverse"),
        ylab = "eta = maxwellQlink", xlab = "theta")
   abline(h = 0, v = 0, lwd = 2)
    
   #--- THE INVERSE
   lines(my.a, maxwellQlink(theta = my.a, p = p,inv = TRUE), 
          col = "green", lwd = 2, lty = "dashed")
   lines(my.a, my.a)     # Tracing the identity function for double--check
   
    
</code></pre>

<hr>
<h2 id='MVNcov'> Multivariate Normal Distribution Family Function</h2><span id='topic+MVNcov'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the Multivariate Normal
distribution. The covariances (not correlation coefficients)
are included in the parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      MVNcov(zero = c("var", "cov"),
             lmean = "identitylink",
             lvar  = "loglink",
             lcov  = "identitylink")
 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MVNcov_+3A_zero">zero</code></td>
<td>

<p>Integer or character&ndash;string vector.
Which linear predictors are intercept&ndash;only.
Details at <code><a href="VGAM.html#topic+zero">zero</a></code> or
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>
<tr><td><code id="MVNcov_+3A_lmean">lmean</code>, <code id="MVNcov_+3A_lvar">lvar</code>, <code id="MVNcov_+3A_lcov">lcov</code></td>
<td>

<p>VGLM&ndash;link functions applied to the means, variances and covariances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code class="reqn">K</code>&ndash;dimensional normal distribution, 
this fits a linear model to the <code class="reqn">K</code> means 
<code class="reqn">\mu_j</code> <code class="reqn">j = 1, \ldots, K</code>, which are the 
first entries in the linear predictor. The variances
<code class="reqn">\sigma^2_j</code> <code class="reqn">j = 1, \ldots, K</code> 
and then the covariances
<code class="reqn">cov_{ij}</code> <code class="reqn">i = 1, \ldots, K,
  j = i + 1, \ldots, K</code>, are next aligned.
The fitted means are returned as the fitted values.
</p>
<p>The log&ndash;likelihood is computed via
<code><a href="#topic+dmultinorm">dmultinorm</a></code>,
an implementation of the multivariate Normal density.
</p>
<p>The score and 
expected information matrices are internally computed
at each Fisher scoring step, using its vectorized form.
</p>
<p>The response should be an <code class="reqn">K</code>&ndash;column matrix.
The covariances may be any real number so that
the <code><a href="VGAM.html#topic+identitylink">identitylink</a></code>
is a reasonable choice.
For further details on VGLM/VGAM&ndash;link functions, see
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>) to be
used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Note</h3>

<p>Unlike other implementations, e.g., 
<code><a href="VGAM.html#topic+binormal">binormal</a></code> from 
<span class="pkg">VGAM</span> in terms of <code class="reqn">\rho</code> and standard deviations,
<code>MVNcov</code> estimates
the variances and covariances, modeled as intercept&ndash;only.
See argument <code>zero</code>, whose default is <code>c("var", "cov")</code>,
to change this.
</p>
<p>Thus far, there is no guarantee that the estimated var&ndash;cov matrix will be 
positive&ndash;definite. Proper procedures to validate this will
be incorporated shortly, such as the <code>@validparams</code> slot.
</p>
<p>Although the function has been tested on <code class="reqn">K \leq 5</code>
data sets, it is recommended that <code class="reqn">K \leq 3</code>,
unless the data are <em>nice</em> and <code class="reqn">n</code> is sufficiently large.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmultinorm">dmultinorm</a></code>,
<code><a href="VGAM.html#topic+binormal">binormal</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># K = 3.
set.seed(180227)
nn  &lt;- 85
mvndata &lt;- data.frame(x2 = runif(nn), x3 = runif(nn))
mvndata &lt;- transform(mvndata, 
                     y = rbinorm(nn, mean1 = 2 - 2 * x2 + 1 * x3,
                          mean2 = 2 - 1.5 * x3,
                          var1 = exp(1.0), var2 = exp(-0.75),
                          cov12 = 0.5 * exp(1.0) * exp(-0.75)))
mvndata &lt;- transform(mvndata, y3 = rnorm(nn, mean = 2 + x2, sd = exp(1.5)))
colnames(mvndata) &lt;- c("x2", "x3", "y1", "y2", "y3")

mvnfit &lt;- vglm(cbind(y1, y2, y3) ~ x2 + x3, MVNcov, data = mvndata, trace = TRUE)
(mvncoef  &lt;- coef(mvnfit, mat = TRUE))

## Check variances and covariances: var1, var2 and var3.
exp(mvncoef[c(10, 13, 16)])  # True are var1 = exp(1.0) = 2.718, 
                             # var2 = exp(-0.75) = 0.472
                             # and var3 = exp(1.5)^2 = 20.08554
vcov(mvnfit)
constraints(mvnfit)
summary(mvnfit)


</code></pre>

<hr>
<h2 id='newtonRaphson.basic'>
Newton&ndash;Raphson algorithm
</h2><span id='topic+newtonRaphson.basic'></span>

<h3>Description</h3>

<p>Newton&ndash;Raphson algorithm to approximate the roots of
univariate real&ndash;valued functions.
</p>
<p>This function is vectorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newtonRaphson.basic(f, fprime, a, b, 
                    tol = 1e-8, n.Seq = 20,
                    nmax = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newtonRaphson.basic_+3A_f">f</code></td>
<td>

<p>A univariate function whose root(s) are approximated.
This is the target function. Must return a vector.
</p>
</td></tr>
<tr><td><code id="newtonRaphson.basic_+3A_fprime">fprime</code></td>
<td>

<p>A function. The first derivative of <code>f</code>. Must return a vector.
</p>
</td></tr>
<tr><td><code id="newtonRaphson.basic_+3A_a">a</code>, <code id="newtonRaphson.basic_+3A_b">b</code></td>
<td>

<p>Numeric vectors.
Upper and lower real limits of the open interval <code class="reqn">(a, b)</code> 
where the root(s) of  <code>f</code> will be searched. Notice, entries 
<code>Inf</code>, <code>-Inf</code>, <code>NA</code> and <code>NaN</code> are not handled.
</p>
<p>These vectors are subject to be recycled if <code>a</code> and <code>b</code>
lenghts differ.
</p>
</td></tr>
<tr><td><code id="newtonRaphson.basic_+3A_tol">tol</code></td>
<td>

<p>Numeric. A number close to zero to test whether the 
approximate roots from iterations <code class="reqn">k</code> and <code class="reqn">(k + 1)</code>
are close enough to stop the algorithm.
</p>
</td></tr>
<tr><td><code id="newtonRaphson.basic_+3A_n.seq">n.Seq</code></td>
<td>

<p>Numeric. The number of equally spaced initial points within
the interval (<code>a</code>, <code>b</code>) to internally set up initial 
values for the algorithm.
</p>
</td></tr>
<tr><td><code id="newtonRaphson.basic_+3A_nmax">nmax</code></td>
<td>

<p>Maximum number of iterations. Default is <code class="reqn">15</code>.
</p>
</td></tr>
<tr><td><code id="newtonRaphson.basic_+3A_...">...</code></td>
<td>

<p>Any other argument passed down to functions <code>f</code> and
<code>fprime</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the well&ndash;known Newton&ndash;Raphson 
algorithm to find a real root, <code class="reqn">r</code>, <code class="reqn">a &lt; r &lt; b</code>,
of the function <code class="reqn">f</code>.
</p>
<p>Initial values, <code class="reqn">r_0</code> say, for the algorithm are 
internally computed by drawing '<code>n.Seq</code>' equally spaced points 
in <code class="reqn">(a, b)</code>. Then, the function <code>f</code> is evaluated at this 
sequence. Finally, <code class="reqn">r_0</code> results from the closest image to 
the horizontal axis.
</p>
<p>At iteration <code class="reqn">k</code>, the <code class="reqn">(k + 1)^{th}</code> approximation 
given by

</p>
<p style="text-align: center;"><code class="reqn">r^{(k + 1)} = r^{(k)} - 
           {\tt{f}}(r^{(k), ...)} / {\tt{fprime}}(r^{(k)}, ...)</code>
</p>


<p>is computed, unless the approximate root from step <code class="reqn">k</code> is the 
desired one.
</p>
<p><code>newtonRaphson.basic</code> approximates this root up to
a relative error less than <code>tol</code>. That is, at each iteration, 
the relative error between the estimated roots from iterations 
<code class="reqn">k</code> and <code class="reqn">k + 1</code> is calculated and then compared to <code>tol</code>.
The algorithm stops when this condition is met.
</p>
<p>Instead of being single real values, arguments <code>a</code> and <code>b</code> 
can be entered as vectors of length <code class="reqn">n</code>, say
<code class="reqn">{\tt{a}} = c(a_1, a_2, \ldots, a_n)</code> and
<code class="reqn">{\tt{b}} = c(b_1, b_2,\ldots, b_n)</code>. 
In such cases, this function approaches the (supposed) root(s)
at each interval <code class="reqn">(a_j, b_j)</code>, 
<code class="reqn">j = 1, \ldots, n</code>. Here, initial values are searched 
for each interval <code class="reqn">(a_j, b_j)</code>.
</p>


<h3>Value</h3>

<p>The approximate roots in the intervals  
<code class="reqn">(a_j, b_j)</code>.
When <code class="reqn">j = 1</code>, then a single estimated root is returned, if any.
</p>


<h3>Note</h3>

<p>The explicit forms of the target function <code>f</code> and its 
first derivative <code>fprime</code> must be available for the algorithm. 
</p>
<p><code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code> 
does not handle yet numerically approximated derivatives.
</p>
<p>A warning is displayed if no roots are found, or if more than one 
root might be lying in
<code class="reqn">(a_j, b_j)</code>, for any <code class="reqn">j = 1, \ldots, n</code>.
</p>
<p>If <code>a</code> and <code>b</code> lengths differ, then the recyling rule 
is applied. Specifically, the vector with minimum length
will be extended up to match the maximum length by repeating
its values. 
</p>


<h3>Author(s)</h3>

<p>V. Miranda.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+bisection.basic">bisection.basic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the roots in c(-0.5, 0.8), c(0.6, 1.2) and c(1.3, 4.1) for the
# f(x) = x * (x - 1) * (x - 2). Roots: r1 = 0, and r2 = 1, r3 = 2.

f &lt;- function(x) x * (x - 1) * (x - 2)
fprime &lt;- function(x) 3 * x^2 - 6 * x + 2

# Three roots.
newtonRaphson.basic(f = f, fprime  = fprime, 
                    a = c(-0.5, 0.6, 1.3), 
                    b = c(0.8, 1.2, 4.1))              ## 0.0, 1.0 and 2.0
                    
# Recycling rule. Intervals analysed are (-0.5, 1.2) and (0.6, 1.2)
newtonRaphson.basic(f = f, fprime  = fprime, 
                    a = c(-0.5, 0.6), b = c(1.2)) 

## Warning: There is more than one root in (-0.5, 1.2)!
</code></pre>

<hr>
<h2 id='normal1sdff'>
Estimation and Inference for Conditional Quantiles of
a 1&ndash;parameter Univariate Normal Distribution.
</h2><span id='topic+normal1sdff'></span><span id='topic+uninormalsd'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the standard deviation, including 
inference for conditional quantiles, of a univariate normal 
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>            normal1sdff(zero = NULL, link = "loglink",
                        fixed.mean = 0, p.quant = NULL,
                        var.arg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal1sdff_+3A_zero">zero</code></td>
<td>

<p>Allows to model the single linear predictor in this family function
as intercept&ndash;only. See below for important details about this.
</p>
</td></tr>
<tr><td><code id="normal1sdff_+3A_link">link</code></td>
<td>

<p>This is the link function applied to the standard deviation.
If <code>var.arg</code> is <code>TRUE</code>, then <code>link</code> is applied
to the variance.
The default is <code><a href="VGAM.html#topic+loglink">loglink</a></code>. For 
inference on conditional quantiles entered at <code>p.quant</code>,
however, it must be manually changed to
<code><a href="#topic+normal1sdQlink">normal1sdQlink</a></code>.
See below for further details.
</p>
</td></tr>
<tr><td><code id="normal1sdff_+3A_fixed.mean">fixed.mean</code></td>
<td>

<p>Numeric, a vector or a matrix. It allocates the (fixed) mean of the 
response in the fitting process. See below for further details.
</p>
</td></tr>
<tr><td><code id="normal1sdff_+3A_p.quant">p.quant</code></td>
<td>

<p>Numeric. A prototype vector of probabilities indicating the quantiles 
of interest, when quantile regression is to be performed.
</p>
</td></tr>
<tr><td><code id="normal1sdff_+3A_var.arg">var.arg</code></td>
<td>

<p>If <code>TRUE</code>, then the variance is estimated, else the
standard deviation is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This family function is a variant of 
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code> 
to estimate the standard deviation of a Normal distribution 
with <em>known</em> mean. The estimated values are returned as
the fitted values, unlike some other family functions where the mean
is returned as <em>fitted values</em>. However, here the mean is 
assumed to be known.
</p>
<p>By default, the response is supposedly <em>centered</em> on its mean, 
that is, <code>fixed.mean</code><code class="reqn"> = 0</code>. Change this accordingly:
For a single response or multiple responses, <code>fixed.mean</code> must
be a numeric vector where each entry is the mean of each response, 
only <em>if</em> the mean is <em>fixed</em>. When the mean is not constant, 
<code>fixed.mean</code> must be matrix with the number of columns matching 
the number of responses.
</p>
<p><em>Quantile regression:</em>
The (single) linear/additive predictor by default is the <code>log</code> 
of the standard deviation. However, if quantile regression is of 
primary interest, then the response must be entered using the function
<code><a href="#topic+Q.reg">Q.reg</a></code>, and the corresponding 
<code class="reqn">p</code>&ndash;quantiles through <code>p.quant</code> in the
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code> call.
Additionally, set <code><a href="#topic+normal1sdQlink">normalsdQlink</a></code> 
as the link function via the argument <code>link</code>. 
</p>
<p>This family <span class="pkg">VGAM</span> function handles multiple responses.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code>.
See <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code> for further details.
</p>


<h3>Warning</h3>

<p>Be aware of the argument <code><a href="VGAM.html#topic+zero">zero</a></code>:
by default, the single linear/additive predictor in this family 
function, say <code class="reqn">\eta</code>, can be modeled in terms of covariates, 
i.e., <code>zero = NULL</code>. 
To model <code class="reqn">\eta</code>  as intercept&ndash;only, set <code>zero = "sd"</code>.
</p>
<p>See <code><a href="VGAM.html#topic+zero">zero</a></code> for more details about this.
</p>


<h3>Author(s)</h3>

<p>V. Miranda.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normal1sdQlink">normal1sdQlink</a></code>,
<code><a href="VGAM.html#topic+loglink">loglink</a></code>,
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="VGAM.html#topic+zero">zero</a></code>,
<code><a href="VGAM.html#topic+vgam">vgam</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(121216)
   my.mean &lt;- -1      #  Mean (CONSTANT)
   my.sd   &lt;- 2.5
   y &lt;- rnorm(100, mean = my.mean, sd = 2.0)      # Generate some data.
   normdat &lt;- data.frame(y = y)                   # Setting up our data.
 
    
   # Plotting the data
     plot(y, main = c("Y ~ Normal ( mean(known), sd = 2.5 ). "),
          ylab = "The data", pch = 20, 
          xlim = c(0, 100), ylim = c(-7, 7), col = "blue")
     abline(h = 0, v = 0, lwd = 2, col = "black")
   

   ### EXAMPLE 1. Estimate the SD with two responses. The mean is fixed. ###
   
   fit1 &lt;- vglm(cbind(y, y) ~ 1, family = normal1sdff(fixed.mean = my.mean), 
               data = normdat, trace = TRUE, crit = "coef")
   Coef(fit1) 
   summary(fit1)
    
    
   ### EXAMPLE 2. Quantile regression. The link normal1sdQlink() is used. ###
  
   my.p &lt;- c(25, 50, 75) / 100  # Quantiles 25%, 50% and 75% are of interest.
   
   fit2 &lt;- vglm(Q.reg(y, length.arg = 3) ~ 1, 
                family = normal1sdff(fixed.mean = my.mean, p.quant = my.p,
                                   link = normal1sdQlink), 
                data = normdat, trace = TRUE, crit = "coef")
    summary(fit2)
    head(predict(fit2))
    constraints(fit2)


   ### EXAMPLE 3. Complete the plot. Quantiles matching. ###
   
   
   ( my.c3Q &lt;- coef(fit2, matrix = TRUE) )
   with(normdat, lines(rep(my.c3Q[1], 100), col = "tan"   , lty = "dotted", lwd = 2))
   with(normdat, lines(rep(my.c3Q[2], 100), col = "orange", lty = "dotted", lwd = 2))
   with(normdat, lines(rep(my.c3Q[3], 100), col = "brown1", lty = "dotted", lwd = 2))
   legend(20, 7.0, c("Percentil 75", "Percentil 50", "Percentil 25"),
          col = c("brown1", "orange", "tan"),
          lty = rep("dotted", 3), lwd = rep(2, 3), cex = 0.75)
   
</code></pre>

<hr>
<h2 id='normal1sdQlink'>
Link functions for the quantiles of several 1&ndash;parameter continuous
distributions.
</h2><span id='topic+normal1sdQlink'></span>

<h3>Description</h3>

<p>Computes the <code>normal1sdQlink</code> transformation for the Univariate
Normal Distribution, its inverse and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   normal1sdQlink(theta,  mean = stop("Please, enter the fixed 'mean'."),
                  p = stop(" Please, enter argument 'p'."),
                  bvalue = NULL, inverse = FALSE, deriv = 0,
                  short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal1sdQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. 
This is <code class="reqn">\theta</code> by default although it could be <code class="reqn">\eta</code>
depending upon other arguments. See below for further details.
</p>
</td></tr>
<tr><td><code id="normal1sdQlink_+3A_mean">mean</code></td>
<td>

<p>A numeric vector or a matrix. It is the (known) fixed mean of the 
Normal distribution of interest. See below for further details.
</p>
</td></tr>
<tr><td><code id="normal1sdQlink_+3A_p">p</code></td>
<td>

<p>Numeric vector of <code class="reqn">p</code>&ndash;quantiles to be modelled by this link
function.
</p>
</td></tr>
<tr><td><code id="normal1sdQlink_+3A_bvalue">bvalue</code>, <code id="normal1sdQlink_+3A_inverse">inverse</code>, <code id="normal1sdQlink_+3A_deriv">deriv</code>, <code id="normal1sdQlink_+3A_short">short</code>, <code id="normal1sdQlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This link function is necessarily required by 
<code><a href="#topic+normal1sd">normal1sd</a></code> if quantile regression 
is to be performed. It computes the <code>normal1sdQlink</code> 
transformation, defined as

</p>
<p style="text-align: center;"><code class="reqn"> {\tt{mean}} + \sqrt{2}\sigma \cdot 
            {\tt{erf^{-1}}}(2 {\tt{p}} - 1).</code>
</p>


<p>Here, <code class="reqn">{\tt{erf^{-1}}}</code> denotes the inverse 
of the error function <code><a href="VGAM.html#topic+erf">erf</a></code>, and 
<code class="reqn">\sigma</code> is the standard deviation (<code>theta</code>) as in
<code><a href="#topic+normal1sd">normal1sd</a></code>.
Technically, <code>normal1sdQlink</code> can be used for quantile regression
over any vector of <code class="reqn">p</code>&ndash;quantiles of Normally distributed data
with <em>known</em> mean.
</p>
<p>See <code><a href="#topic+normal1sd">normal1sd</a></code> for further details 
about the latter.



</p>
<p>Values of <code class="reqn">p</code> out of the open interval <code class="reqn">(0, 1)</code> or non&ndash;positive
values of <code>theta</code> will result in <code>Inf</code>, <code>-Inf</code>,
<code>NA</code> or <code>NaN</code>. 
</p>


<h3>Value</h3>

<p>When <code>deriv = 0</code>, the <code>normal1sdQlink</code> transformation
of <code>theta</code>, if <code>inverse = FALSE</code>. Conversely, if
<code>inverse = TRUE</code>, <code>theta</code> becomes <code class="reqn">\eta</code> and
the inverse transformation given by 
<code>(theta -  mean)/</code><code class="reqn">\sqrt{2}</code>
<code>erf</code><code class="reqn">^{-1}</code><code class="reqn">(2</code><code>p</code><code class="reqn"> - 1)</code>
is returned.
</p>
<p>For <code>deriv = 1</code>, <code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code>
if <code>inverse = FALSE</code>. Else, this function returns  
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of <code>theta</code>.
</p>
<p>For <code>deriv = 2</code>, the second order derivatives are accordingly
returned.
</p>


<h3>Warning</h3>

<p>If <code>p</code> is a vector, then the recycling rule applies <em>only</em> 
if <code>theta</code> is entered as a matrix. Else, only the first entry in 
<code>p</code> is considered.
</p>


<h3>Note</h3>

<p>When <code>inverse = TRUE</code>, the reciprocal of the error function,
<code><a href="VGAM.html#topic+erf">erf</a></code>, evaluated at <code class="reqn">2</code><code>p</code><code class="reqn">- 1</code> 
is required. However, the result is <code>Inf</code> for <code>p</code><code class="reqn">= 0.5</code>. 
Here, in consequence, the limit of <code><a href="VGAM.html#topic+erf">erf</a></code> when
<code>p</code> tends to <code class="reqn">0.5</code> is returned to avoid numerical issues.
</p>


<h3>Author(s)</h3>

<p>V. Miranda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normal1sd">normal1sd</a></code>,
<code><a href="VGAM.html#topic+erf">erf</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ###   Example 1  ###
    theta &lt;- seq(0, 3, by = 0.1)[-1]  # This is sigma, then must be positive.
    mean  &lt;- -2.5                     # Intentionally, a negative value for mu.
    p     &lt;- 0.25                     # Modelling the first quartile.
    
    eta &lt;- normal1sdQlink(theta = theta, p = p, mean = mean) 
    inv.eta &lt;- normal1sdQlink(theta = eta, p = p, mean = mean, inverse = TRUE)
    summary(inv.eta - theta)          ## Should be 0

    
    ###  Example 2. Special values of theta, using argument 'bvalue'.  ###
    
    theta &lt;- c(-Inf, -5, -2.5, 0, 2.5, 5, Inf, NA, NaN)
    my.matrix &lt;- rbind(theta, normal1sdQlink(theta = theta, p = p, mean = mean),
                     normal1sdQlink(theta = theta, p = p, mean = mean, bvalue = 1e-5))
    rownames(my.matrix) &lt;- c("theta", "No 'bvalue'", "With 'bvalue'")
    colnames(my.matrix) &lt;- rep("", 9)
    
    my.matrix   # Second row has NAs, whilst third row has NO NAs except for theta = NA
</code></pre>

<hr>
<h2 id='notDocumentedYetVGAMextra'>
Not-documented functions and classes in <span class="pkg">VGAMextra</span>
</h2><span id='topic+notDocumentedYetVGAMextra'></span><span id='topic+ARpEIM.G2'></span><span id='topic+MAqEIM.G2'></span><span id='topic+ARMA.EIM.G2'></span><span id='topic+rINGARCH'></span><span id='topic+combVGAMextra'></span><span id='topic+arwzTS'></span><span id='topic+PIT'></span><span id='topic+typeTS'></span><span id='topic+responseVGAMex'></span><span id='topic+execute.PIT'></span><span id='topic+.onAttach'></span><span id='topic+vgamextraNEWS'></span><span id='topic+con.est.s2l'></span><span id='topic+pVal.KPSS.test'></span><span id='topic+B11'></span><span id='topic+B21'></span><span id='topic+B22'></span><span id='topic+poissonTSff'></span><span id='topic+ARMAX.GARCHff'></span><span id='topic+NegBinomTSff'></span><span id='topic+VGLM.INGARCHff'></span><span id='topic+yulesimonTSff'></span><span id='topic+logarithmicTSff'></span><span id='topic+dARp'></span><span id='topic+dMAq'></span><span id='topic+dARMA'></span><span id='topic+rAR.GARCH'></span><span id='topic+VARff.control'></span><span id='topic+ARXff.control'></span><span id='topic+MAXff.control'></span><span id='topic+MVNcov.control'></span><span id='topic+ARMAXff.control'></span><span id='topic+ARIMAXff.control'></span><span id='topic+poissonTSff.control'></span><span id='topic+NegBinomTSff.control'></span><span id='topic+yulesimonTSff.control'></span><span id='topic+ARMAX.GARCHff.control'></span><span id='topic+ECM.EngleGran.control'></span><span id='topic+VGLM.INGARCHff.control'></span><span id='topic+trinormalCovff.control'></span><span id='topic+trunclognormal.control'></span><span id='topic+logarithmicTSff.control'></span><span id='topic+ARIMAX.errors.ff.control'></span><span id='topic+ARMA.studentt.ff.control'></span><span id='topic+quick.check.coeffs'></span><span id='topic+interleaveArray.VGAMextra'></span>

<h3>Description</h3>

<p>Those functions not documented yet in 
<span class="pkg">VGAMextra</span> are aliased to this file.
</p>


<h3>Details</h3>

<p>These functions are still under review or being tested, and will
be documented over time.
</p>


<h3>Value</h3>

<p>Overall, these functions returns objects required by 
time series family functions in <span class="pkg">VGAMextra</span>.
</p>
<p>Further details will be given shortly.
</p>


<h3>Author(s)</h3>

<p>V. Miranda
</p>

<hr>
<h2 id='posPoiMlink'>
Link functions for the mean of 1&ndash;parameter 
discrete distributions: The Positive Poisson Distribution.
</h2><span id='topic+posPoiMlink'></span><span id='topic+posPoiMeanlink'></span><span id='topic+pospoilink.inv.deriv0'></span>

<h3>Description</h3>

<p>Computes the <code>posPoiMlink</code> transformation, 
its inverse and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     posPoiMlink(theta, bvalue = NULL, 
                 alg.roots = c("Newton-Raphson", "bisection")[1],
                 inverse = FALSE, deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posPoiMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> by default, although
it becomes <code class="reqn">\eta</code> sometimes, depending on the other parameters. 
See below for further details.
</p>
</td></tr>
<tr><td><code id="posPoiMlink_+3A_bvalue">bvalue</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
<tr><td><code id="posPoiMlink_+3A_alg.roots">alg.roots</code></td>
<td>

<p>Character. The iterative method to find the inverse of this link
function. Same as <code><a href="#topic+zetaffMlink">zetaffMlink</a></code>.
</p>
</td></tr>
<tr><td><code id="posPoiMlink_+3A_inverse">inverse</code>, <code id="posPoiMlink_+3A_deriv">deriv</code>, <code id="posPoiMlink_+3A_short">short</code>, <code id="posPoiMlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a link function for the mean of the 
positive Poisson distribution. It is defined as 

</p>
<p style="text-align: center;"><code class="reqn"> \eta = \tt{posPoiMlink}(\lambda) = 
           -\log (\lambda^{-1} - \lambda^{-1} e^{-\lambda}),</code>
</p>


<p>where <code class="reqn">\lambda &gt; 0</code> stands for the single parameter of
<code><a href="VGAM.html#topic+pospoisson">pospoisson</a></code>, i.e. 
<code>theta</code> in the VGLM/VGAM context.
</p>
<p>Notice, the mean of the positive Poisson is given by

</p>
<p style="text-align: center;"><code class="reqn"> \frac{\lambda}{1 - e^{-\lambda}}. </code>
</p>


<p>This link function comes up by taking the logarithm on both
sides of this equation.
</p>
<p>The domain set for <code class="reqn">\lambda</code> is <code class="reqn">(0, \infty)</code>. 
Hence, non&ndash;positive values of <code class="reqn">\lambda</code> will result in <code>NaN</code> 
or <code>NA</code>. Use argument <code>bvalue</code> to properly replace 
them before computing the link function.
</p>
<p><code>posPoiMlink</code> tends to infinity as <code class="reqn">\lambda</code> 
increases. Specially, its inverse grows at a higher rate. Therefore, 
large values of <code class="reqn">\lambda</code> will result in <code>Inf</code> accordingly. 
See example 2 below.
</p>
<p>If <code>theta</code> is a character, arguments <code>inverse</code> and
<code>deriv</code> are disregarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>posPoiMlink</code> transformation of 
<code>theta</code>, if <code>inverse = FALSE</code>. When <code>inverse = TRUE</code>,
<code>theta</code> becomes <code class="reqn">\eta</code> and the inverse of 
<code>posPoiMlink</code> is needed but cannot be written in 
closed&ndash;form. Instead this link function returns the approximated 
inverse image of <code class="reqn">\eta</code>, say <code class="reqn">\theta_\eta</code>, 
such that 

</p>
<p style="text-align: center;"><code class="reqn">  \tt{posPoiMlink}(\theta_\eta) = \eta.</code>
</p>


<p>Here, <code class="reqn">\theta_\eta</code> is iteratively computed
as the unique root of the auxiliary function

</p>
<p style="text-align: center;"><code class="reqn"> f(\theta; \eta) = \tt{posPoiMlink}(\theta) - \eta,</code>
</p>


<p>as a function of <code class="reqn">\theta</code>.
This work is performed via Newton&ndash;Raphson or bisection,
as per argument <code>alg.roots</code>. 
</p>
<p>For <code>deriv = 1</code>, <em>d</em> <code>eta</code> / <em>d</em> <code>theta</code> 
as a function of <code>theta</code> if <code>inverse = FALSE</code>, else 
the reciprocal <em>d</em> <code>theta</code> / <em>d</em> <code>eta</code>.
</p>
<p>Similarly, when <code>deriv = 2</code> the second order derivatives 
are returned in terms of <code>theta</code>.
</p>


<h3>Warning</h3>

<p>This link function is monotonic increasing in <code class="reqn">(0, \infty)</code> so that
the horizontal axis is an asymptote. Then, in order to assure the root 
of the auxiliary

</p>
<p style="text-align: center;"><code class="reqn"> f(\theta; \eta) = \tt{posPoiMlink}(\theta) - \eta</code>
</p>


<p>to be real, <code class="reqn">\eta</code> must be positive. As a result, 
<code>posPoiMlink</code> is <em>shited&ndash;down</em> and hence intersecting 
the horizontal axis uniquely.
</p>


<h3>Note</h3>

<p>This link function is useful to model any parameter
in <code class="reqn">(0, \infty)</code>. Some numerical issues may arise if there are 
covariates causing negative values the parameter. 
Try <code><a href="VGAM.html#topic+identitylink">identitylink</a></code> alternatively.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+pospoisson">pospoisson</a></code>,
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code>,
<code><a href="VGAM.html#topic+bisection.basic">bisection.basic</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="VGAM.html#topic+identitylink">identitylink</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1. Special values for theta (or eta, accordingly)  ##
m.lambda &lt;- c(0, 0.5, 1, 10, 20, 25, 1e2, 1e3, Inf, -Inf, NaN, NA) 

# The 'posPoiMlink' transformation and the first two derivatives.
print(rbind(m.lambda, 
  deriv1 = posPoiMlink(theta = m.lambda, inverse = FALSE, deriv = 1),
  deriv2 = posPoiMlink(theta = m.lambda, inverse = FALSE, deriv = 2)),
  digits = 2)
  
# The inverse of 'posPoiMlink' and the first two derivatives.
print(rbind(m.lambda, 
  Invderiv1 = posPoiMlink(theta = m.lambda, inverse = TRUE, deriv = 1),
  Invderiv2 = posPoiMlink(theta = m.lambda, inverse = TRUE, deriv = 2)),
  digits = 2)
  

## Example 2. The inverse of 'posPoiMlink' ##
m.lambda &lt;- c(0, 1, 5, 10, 1e2, 1e3) 
posPoiMlink(theta = posPoiMlink(m.lambda, inverse = TRUE))
pospoi.inv &lt;- posPoiMlink(posPoiMlink(m.lambda, inverse = TRUE)) - m.lambda
                           
summary(pospoi.inv)                      ## Should be zero.


## Example 3. Plot of 'posPoiMlink' and its first two derivatives ##
## inverse = FALSE, deriv = 0, 1, 2. ##

m.lambda &lt;- seq(0, 35, by = 0.01)[-1]
y.lambda &lt;- posPoiMlink(theta = m.lambda, deriv = 0)
der.1 &lt;- posPoiMlink(theta = m.lambda, deriv = 1)
der.2 &lt;- posPoiMlink(theta = m.lambda, deriv = 2)

plot(y.lambda ~ m.lambda, col = "black", 
     main = "log(mu), mu = E[Y], Y ~ pospoisson(lambda).",
     ylim = c(-1, 10), xlim = c(-1, 26),
     lty = 1, type = "l", lwd = 3)
abline(v = 0, h = 0, col = "gray50", lty = "dashed")

lines(m.lambda, der.1, col = "blue", lty = 5, lwd = 3)
lines(m.lambda, der.2, col = "chocolate", lty = 4, lwd = 3)
legend(5, 9, legend = c("posPoiMlink", "deriv = 1", "deriv = 2"),
       col = c("black", "blue", "chocolate"), lty = c(1, 5, 4), lwd = c(3, 3, 3))
 
</code></pre>

<hr>
<h2 id='Q.reg'>

Conditional quantile regression with <span class="pkg">VGAM</span>

</h2><span id='topic+Q.reg'></span>

<h3>Description</h3>

<p>Use this function to adequately confer the <code>formula</code> 
in <span class="pkg">VGAM</span> when fitting quantile regression models.


</p>


<h3>Usage</h3>

<pre><code class='language-R'>    Q.reg(y, pvector = NULL, length.arg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q.reg_+3A_y">y</code></td>
<td>

<p>Numeric, a vector or a matrix. It is the response or dependent 
variable in the <code>formula</code> of the model to be fit, as in 
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
See below for further details.
</p>
</td></tr>
<tr><td><code id="Q.reg_+3A_pvector">pvector</code></td>
<td>

<p>A prototype vector. Entries are the conditional <code class="reqn">p</code>&ndash;quantiles
in the fitting process.
</p>
</td></tr>
<tr><td><code id="Q.reg_+3A_length.arg">length.arg</code></td>
<td>

<p>A length&ndash;1 positive integer. It is the number of <code class="reqn">p</code>&ndash;quantiles
to be modelled.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional quantile regression can be carried out using family
functions in <span class="pkg">VGAM</span> and <span class="pkg">VGAMextra</span>.
The <code>formula</code> must be set up using this function, <code>Q.reg</code>.
Here, the <code class="reqn">p</code>&ndash;quantiles of interest may be entered via
<code>pvector</code>. Alternatively, use argument <code>length.arg</code> by
establishing the length of <code>pvector</code>.
</p>
<p>Besides, the corresponding link must be entered.
For example, <code><a href="#topic+gamma1Qlink">gamma1Qlink</a></code>
is the proper link to fit models of conditional quantiles for 
data distributed as Gamma via the family function
<code><a href="VGAM.html#topic+gamma1">gamma1</a></code>.
</p>
<p>See examples for further details.
</p>


<h3>Value</h3>

<p>A matrix, each column adequately arranged for regression on conditional
quantiles, conforming with <span class="pkg">VGAM</span>. 
</p>
<p>Indeed, this is equivalent to <code>cbind(y, y, ...)</code>, where the 
total number of columns is, either the length of <code>pvector</code>, or
<code>length.arg</code>.
</p>


<h3>Note</h3>

<p>Link functions for quantile regression in <span class="pkg">VGAM</span> require the
vector of <code class="reqn">p</code>&ndash;quantiles of interest via the argument <code>p</code>.
See <code><a href="#topic+normal1sdQlink">normal1sdQlink</a></code> or
<code><a href="#topic+maxwellQlink">maxwellQlink</a></code> for instance.
</p>
<p>Therefore, the integer entered at <code>length.arg</code> in this function, 
if utilized, must match the length of the vector <code>p</code>. Else,
it will be recycled.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normal1sdQlink">normal1sdQlink</a></code>,
<code><a href="#topic+maxwellQlink">maxwellQlink</a></code>,
<code><a href="#topic+gamma1Qlink">gamma1Qlink</a></code>,
<code><a href="VGAM.html#topic+gamma1">gamma1</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>,
<code><a href="VGAM.html#topic+vgam">vgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  ###  Quantile regression with data distributed as Maxwell(s)  ###
   set.seed(12073)
   x2 &lt;- seq(0, 100,length.out = 100)       # independent variable
   b0 &lt;- 0.5                                # true intercept
   b1 &lt;- 0.25                               # true slope
   b2 &lt;- 0.02                               # true second order coef.
   alpha &lt;- b0 + b1 * x2 + b2 * x2^2        # Quadratically modelling the parameters
   nn &lt;- 100                                # Sample size
  
   # The data as a data frame. #
   mdata &lt;- data.frame(y = rmaxwell(n = nn, rate = alpha), x2 = x2, x3 = x2^2)
   
   # Quantile regression using our link function maxwellQlink(). #
   # Quantiles 25%, 50%, 75% are of interest #
   my.p &lt;- c(0.25, 0.50, 0.75)
   

   fit &lt;- vglm(Q.reg(y, pvector = my.p) ~ x2 + x3, 
   
  # OPTIONALLY Q.reg(y, length = length(my.p)) ~ x2 + x3
   
              maxwell(link = "maxwellQlink(p = my.p)"), 
              data = mdata,  trace = TRUE, crit = "coef")

   coef(fit, matrix = TRUE) 
   summary(fit)
   head(predict(fit))
   constraints(fit)
   
</code></pre>

<hr>
<h2 id='rayleighMlink'>
Link functions for the mean of 1&ndash;parameter 
continuous distributions: The Rayleigh and 
the Maxwell distributions.
</h2><span id='topic+rayleighMlink'></span><span id='topic+maxwellMlink'></span>

<h3>Description</h3>


<p>The <code>rayleighMlink</code> and the <code>maxwellMlink</code> 
transformations, their inverse and the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rayleighMlink(theta, bvalue = NULL, inverse = FALSE,
                 deriv = 0, short = TRUE, tag = FALSE) 
                    
   maxwellMlink(theta, bvalue = NULL, inverse = FALSE,
                deriv = 0, short = TRUE, tag = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rayleighMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. It is <code class="reqn">\theta</code> by default, 
but it may be <code class="reqn">\eta</code> depending upon other 
parameters.
See <code><a href="VGAM.html#topic+Links">Links</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="rayleighMlink_+3A_bvalue">bvalue</code>, <code id="rayleighMlink_+3A_inverse">inverse</code>, <code id="rayleighMlink_+3A_deriv">deriv</code>, <code id="rayleighMlink_+3A_short">short</code>, <code id="rayleighMlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rayleighMlink</code> and <code>maxwellMlink</code> are link functions
to model  the mean of the Rayleigh distirbution,
(<code><a href="VGAM.html#topic+rayleigh">rayleigh</a></code>),
and the mean of the Maxwell distribution,
(<code><a href="VGAM.html#topic+maxwell">maxwell</a></code>), 
respectively.
</p>
<p>Both links are somehow defined as the 
<code class="reqn"> \log {\tt{theta}} </code> 
plus an <em>offset</em>. Specifcally,
</p>
<p style="text-align: center;"><code class="reqn"> {\tt{rayleighMlink}}(b) = \log ( b * \gamma(0.5) / sqrt{2} ),</code>
</p>

<p>where <code class="reqn">b &gt; 0</code> is a scale parameter as in
<code><a href="VGAM.html#topic+rayleigh">rayleigh</a></code>; and
</p>
<p style="text-align: center;"><code class="reqn"> {\tt{maxwellhMlink}}(b) = \log ( a^{-1/2} * sqrt{8 / \pi}  ).</code>
</p>

<p>Here, <code class="reqn">a</code> is positive as in <code><a href="VGAM.html#topic+maxwell">maxwell</a></code>.
</p>
<p>Non&ndash;positive values of <code class="reqn">a</code> and/or <code class="reqn">b</code> will result in 
<code>NaN</code>, whereas values too close to zero will return
<code>Inf</code> or <code>-Inf</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the corresponding transformation of
<code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then <code>theta</code> becomes <code class="reqn">\eta</code>, and
the inverse transformations 
</p>
<p>I)  <code>exp(theta) * sqrt</code>(2) / <code>gamma(0.5)</code> 
for <code>rayleighMlink</code>, and
</p>
<p>II)  <code class="reqn">8</code><code> * exp(-2 * theta) </code> / <code>gamma(0.5)</code><code class="reqn">^2</code> for 
<code>maxwellMlink</code>,
</p>
<p>are returned.
</p>
<p>For <code>deriv = 1</code>,
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of 
<code>theta</code>.
</p>
<p>When <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are returned.
</p>


<h3>Note</h3>

<p>Values of <code class="reqn">a</code> or <code class="reqn">b</code> out of range, e.g. when covariates
involved, may cause numerical instability. 
Use argument <code>bvalue</code> to replace them before computing any link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+maxwell">maxwell</a></code>, 
<code><a href="VGAM.html#topic+rayleigh">rayleigh</a></code>
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ##  The link and its inverse ##
    theta &lt;- 0.1 + 1:10
    eta   &lt;- maxwellMlink(maxwellMlink(theta = theta), inverse  =TRUE)
    summary(eta - theta)     # Zero
    
    eta   &lt;- rayleighMlink(rayleighMlink(theta = theta), inverse  =TRUE)
    summary(eta - theta)     # Zero


 ## Modelling the mean of the Maxwell distribution  ##
    set.seed(17010401)
    
    rate &lt;- maxwellMlink(theta = 2, inverse = TRUE)   # ~ 0.046
    mdata &lt;- data.frame(y = rmaxwell(1000, rate = rate ))
    
    fit &lt;- vglm(y ~ 1, maxwell(link = "maxwellMlink"), 
                data = mdata, trace = TRUE, crit = "coef")
    
    coef(fit, matrix = TRUE)
    Coef(fit)
 

</code></pre>

<hr>
<h2 id='rayleighQlink'>
Link functions for the quantiles of several 1&ndash;parameter continuous
distributions
</h2><span id='topic+rayleighQlink'></span>

<h3>Description</h3>

<p>Computes the <code>rayleighQlink</code> transformation, its inverse and the
first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rayleighQlink(theta, p = stop("Argument 'p' must be specified."),
                bvalue = NULL, inverse = FALSE,
                deriv = 0, short = TRUE, tag = FALSE)
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rayleighQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. It is <code class="reqn">\theta</code> by default, although 
it may be <code class="reqn">\eta</code>. See <code><a href="VGAM.html#topic+Links">Links</a></code> for
additional details about this.
</p>
</td></tr>
<tr><td><code id="rayleighQlink_+3A_p">p</code></td>
<td>

<p>Numeric. A single value between 0.0 and 1.0.
It is the <code class="reqn">p</code>&ndash;quantile to be modeled by this link function. 
</p>
</td></tr>
<tr><td><code id="rayleighQlink_+3A_bvalue">bvalue</code>, <code id="rayleighQlink_+3A_inverse">inverse</code>, <code id="rayleighQlink_+3A_deriv">deriv</code>, <code id="rayleighQlink_+3A_short">short</code>, <code id="rayleighQlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This link function directly models any <code class="reqn">p</code>&ndash;quantile of the 
Rayleigh distribution specified by the argument <code>p</code>.
It is called the <code>rayleighQlink</code> transformation defined as

</p>
<p style="text-align: center;"><code class="reqn">b \sqrt{-2 \log(1 - p)},</code>
</p>


<p>where <code class="reqn">b &gt; 0</code> is a scale parameter as in 
<code><a href="VGAM.html#topic+rayleigh">rayleigh</a></code>. 
</p>
<p>Numerical values of <code class="reqn">b</code> or <code class="reqn">p</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are discarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>rayleighQlink</code> transformation of
<code>theta</code>, when <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, then
this function returns <code>theta / sqrt(-2 log(1 - p))</code>.
</p>
<p>For <code>deriv = 1</code>, then the function returns
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code>, 
if <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, then
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of <code>theta</code>.
</p>
<p>If <code>deriv = 2</code>, then the second order derivatives in terms of
<code>theta</code>. 
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+rayleigh">rayleigh</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## E1. rayleighQlink() and its inverse ##
  p &lt;- 0.50                           ## Modeling the median
  my.b &lt;- seq(0, 5, by = 0.1)[-1]
  max(my.b - rayleighQlink(rayleighQlink(my.b, p = p), p = p, inverse  =TRUE)) ## Zero


 ## E2. Special values ##
  rayleighQlink(theta = c(Inf, -Inf, NA, NaN), p = p)
    
    
 ## E3. Use of argument 'bvalue' ##
  rayleighQlink(theta = seq(-0.2, 1.0, by = 0.1), p = p)  # WARNING: NaNs if theta &lt;= 0
  rayleighQlink(theta = seq(-0.2, 1.0, by = 0.1), p = p, bvalue = .Machine$double.xmin)
    
</code></pre>

<hr>
<h2 id='summaryS4VGAMextra-methods'>Summary methods for Vector Generalized Time Series Models
</h2><span id='topic+summaryS4VGAMextra'></span><span id='topic+summaryS4VGAMextra+2C+20vgltsmff-method'></span>

<h3>Description</h3>

<p> S4 summary methods for models fitted with
time series family functions from 
<span class="pkg">VGAMextra</span>. 
</p>
<p>These function are all 
<code><a href="utils.html#topic+methods">methods</a></code> for objects of class
<code><a href="VGAM.html#topic+vglm">vglm</a></code> with signature 
<code><a href="#topic+vgltsmff-class">vgltsmff-class</a></code>.
</p>


<h3>Details</h3>

<p>Implementation of vector generalized time series (TS) family functions 
(<em>vgltsmff</em>) in <span class="pkg">VGAMextra</span> is entirely based on the structure
of family functions of class 
<code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code> 
from <span class="pkg">VGAM</span>. More precisely, <em>vgltsmff</em> family functions
can be created by calls of the form <code>new("vgltsmff",...)</code>,
following the structure <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>.
See <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code> for 
additional details.
</p>
<p>In this line, specific S4 dispatching methods are currently 
implemented at <span class="pkg">VGAM</span> to show (or plot) essential 
statistical information about the model fitted.
</p>
<p>For the generic <code>summary</code>, specifically, S4 methods for 
objects with signature <code>vgtsff</code> are incorporated
in <span class="pkg">VGAMextra</span> to display supplementary analyses commonly
required by TS practicioners. That is, additional information
to the default output shown by 
<code><a href="VGAM.html#topic+summaryvglm">summaryvglm</a></code> for family functions
at <span class="pkg">VGAM</span>, as follows: 
</p>
<p>a) The standard errors, which are computed from the 
asymptotic distribution of the MLE estimates, unlike the asymptotic 
approach (z-value) from <span class="pkg">VGAM</span>.
</p>
<p>b) Checks on stationarity and/or invertibility for autoregressive 
(AR), moving average (MA), and autoregressive moving-average (ARMA)
models via the polynomial roots.
</p>
<p>c) The AIC, AICC and BIC criteria for model identification.
</p>
<p>Notice that, for intercept-only models in the 'vglm' context, 
the asypmtotic distribution of the estimates, either conditional
or unconditional, will coincide with the theoretical distributions
as long as <code class="reqn">n</code> increases. In particular, for the AR(<code class="reqn">p</code>)
process, the MLEs and the Yule-Walker estimates will concur 
asymptotically.
</p>
<p>Where covariates or parameter constraints are involved, 
the standard errors for the estimates from time series 
family functions at <span class="pkg">VGAMextra</span> are calculated from the 
predicted values allocated in the slot <code>@predictors</code>,
when <code>summary(...)</code> is called.
In this case, the <em>conditional</em> mean, 
<code class="reqn">\textrm{E}[\eta_j | \textbf{x}]</code> <b>x</b> <code class="reqn">]</code>, is considered as the estimate, where:
</p>
<p style="text-align: center;"><code class="reqn">\eta_j  = \sum_{k = 1}^{p} \beta_{(j)k} \times x_{k},</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, M</code>.
</p>


<h3>Value</h3>

<p>An object of class 
<code>summary.vglm</code> printed by specific methods defined
at <span class="pkg">VGAMextra</span> for objects with signature
vgltsff-class.
</p>


<h3>Note</h3>

<p>As for the intercept, notice that this is called <em>drift-term</em>
at <code><a href="#topic+ARXff">ARXff</a></code> and
<code><a href="#topic+ARMAXff">ARMAXff</a></code>, 
whilst it is refered as <em>intercept</em> 
in <code><a href="#topic+MAXff">MAXff</a></code>. 
This parameter is also estimated by TS family 
functions in <span class="pkg">VGAMextra</span>. In the MA model, particularly, 
it is the mean of the process.
</p>
<p>The drift-term, 
denoted as <code class="reqn">\mu^*</code>,
is linearly linked to the mean,
<code class="reqn">\mu</code>,
of the AR and ARMA processes in turn, as follows:
</p>
<p style="text-align: center;"><code class="reqn"> \mu \to \frac{\mu^{*} }{1 - \sum \theta_i}.  </code>
</p>

<p>Here, <code class="reqn">\theta_i</code> are the AR coefficients.
Hence, the standard error for the <em>drift-term</em> is 
accordingly computed based on the asymptotic distribution
of the mean. More precisely, the relation
</p>
<p style="text-align: center;"><code class="reqn">V(\mu^{*}) = (1 - \sum \theta_i)^{-2} \times 
                  \frac{\sigma_{\varepsilon}^2 }{n},</code>
</p>
 
<p>is considered, 
where <code class="reqn">\sigma_{\varepsilon}^2</code> is the variance
of the random errors.
</p>
<p>Finally, the AIC, AICC and BIC criteria are computed of the well-known
expressions
</p>
<p style="text-align: center;"><code class="reqn">AIC = (-2) \times Log-likelihood + 2 \times k</code>
</p>

<p style="text-align: center;"><code class="reqn">AICC = AIC + \frac{2~k~(k + 1)}{n - k - 1}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">BIC = (-2) \times Log-likelihood + k~\times~ln(n)</code>
</p>

<p>with <code class="reqn">k</code> denoting the number of parameters.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T.W. Yee.
</p>


<h3>References</h3>

<p>Woodward, H., Gray, H. and Elliot A. (2012)
<em>Applied Time Series Analysis</em>.
Taylor &amp; Francis/CRC, Florida, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vgtsff-class">vgtsff-class</a></code>,
<code><a href="VGAM.html#topic+summaryvglm">summaryvlgm</a></code>,
<code><a href="#topic+ARXff">ARXff</a></code>,
<code><a href="#topic+MAXff">MAXff</a></code>,
<code><a href="#topic+ARMAXff">ARMAXff</a></code>, 
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#------------------------------------------------------------------------#
# Fitting a simple Moving Average model to compare with arima().
#------------------------------------------------------------------------#
set.seed(0628)
nn    &lt;- 300
theta &lt;- c(0.2, -0.37)  # Autoregressive coefficients
phi   &lt;- c(0.25)        # MA coefficients.
mu    &lt;- c(1.5, 0.85)   # Mean (not drift) of the MA process.
x2 &lt;- runif(nn)

tsd1 &lt;- mu[1]/(1 - sum(theta)) + 
                  arima.sim(n = nn, 
                            model = list(order = c(2, 0, 0), 
                                          ar = theta),
                            sd = exp(1.5))
tsd2 &lt;- mu[2]/(1 - sum(theta)) + 
                  arima.sim(n = nn, 
                            model = list(order = c(2, 0, 1),
                                         ar = theta, ma = phi), 
                            sd = exp(1 + 2 * x2))

tsdata &lt;- data.frame(TS1 = tsd1, TS2 = tsd2, x2 = x2)
head(tsdata)

    ###    An ARIMA(2, 0, 0) model, that is an AR(2) model    ###
    
#fit1 &lt;- vglm(TS1 ~ 1, 
#             ARIMAXff(order = c(2, 0, 0), var.arg = FALSE, type.EIM = "exact"), 
#             data = tsdata,  crit = "log", trace = TRUE)

fit1 &lt;- vglm(TS1 ~ 1, 
             ARXff(order = 2, var.arg = FALSE, type.EIM = "exact"), 
             data = tsdata,  crit = "log", trace = TRUE)
m.coe &lt;- Coef(fit1)

## Using arima to compare to summary(vgtsff)
summary(fit1)
arima(tsdata$TS1, order = c(2, 0, 0)) ## Similar SE's than VGAMextra.


m.coe[1] / (1 - sum(m.coe[-(1:2)]))  # THIS IS SIMILAR TO THE INTERCEPT 
                                     # ESTIMATED BY arima(): 1.1898

    ###    An ARIMA(2, 0, 1) models, that is an ARMA(2, 1)     ###
    ###   The errors standard deviation is a function of 'x2'  ###

### NOTICE: ARIMA and ARMA use the "identitylink" for coefficients ###
#fit2 &lt;- vglm(TS2 ~ x2, 
#             ARMAXff(order = c(2, 1), var.arg = FALSE, type.EIM = "exact",
#                     zero = NULL), 
#            # constraints = list('x2' = rbind(0, 1, 0, 0, 0)),
#             data = tsdata,  crit = "loglikelihood", trace = TRUE)

#m.coe &lt;- coef(fit2)
#coef(fit2, matrix = TRUE)

## Compare summary(vglm) to arima().
#summary(fit2)
#arima(tsdata$TS2, order = c(2, 0, 1))



</code></pre>

<hr>
<h2 id='toppleMlink'>
Link functions for the mean of 1&ndash;parameter 
continuous distribution: The Topp&ndash;Leone distribution.
</h2><span id='topic+toppleMlink'></span><span id='topic+toppleMeanlink'></span>

<h3>Description</h3>


<p>Computes the <code>toppleMlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>      toppleMlink(theta, bvalue = NULL, inverse = FALSE,
                  deriv = 0, short = TRUE, tag = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toppleMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character.
See <code><a href="VGAM.html#topic+Links">Links</a></code> and below for further details.
</p>
</td></tr>
<tr><td><code id="toppleMlink_+3A_bvalue">bvalue</code>, <code id="toppleMlink_+3A_inverse">inverse</code>, <code id="toppleMlink_+3A_deriv">deriv</code>, <code id="toppleMlink_+3A_short">short</code>, <code id="toppleMlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>toppleMlink</code> transformation arises as a link function to
model the mean of the Topp&ndash;Leone distribution,
<code><a href="VGAM.html#topic+topple">topple</a></code>. It is defined as
</p>
<p style="text-align: center;"><code class="reqn"> \eta = {\tt{logit}} \left( \left( 1 - \frac{4^{s} \Gamma(1 + s)^2}{ 
                \Gamma(2 + 2s)} \right) / sup.tp \right).</code>
</p>

<p>Here, <code class="reqn">0 &lt; s &lt; 1</code> is a shape parameter as in
<code><a href="VGAM.html#topic+topple">topple</a></code>, whereas 
<code class="reqn">sup.tp</code> is the <em>supremum</em> of 
</p>
<p style="text-align: center;"><code class="reqn">  1 - \frac{4^{s} \Gamma(1 + s)^2}{ \Gamma(2 + 2s)}, </code>
</p>

<p>in <code class="reqn">(0, 1)</code>, as a function of <code class="reqn">s</code>.
</p>
<p>For numerical values of <code class="reqn">s</code> out of <code class="reqn">(0, 1)</code>, this link may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>toppleMlink</code> transformation of
<code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then <code>theta</code> becomes <code class="reqn">\eta</code>, and
the inverse transformation is required. However, it 
can't be expressed in close form. Therefore, the approximate 
<em>inverse image</em> of entered <code>theta</code> computed by 
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code> 
is returned.
</p>
<p>For <code>deriv = 1</code>,
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code> when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of 
<code>theta</code>.
</p>




<h3>Note</h3>

<p>Values of <code class="reqn">s</code> too close to zero or 1.0 may cause numerical 
instability. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+topple">topple</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## E1. The toppleMlink() and its inverse ##
    theta &lt;- ppoints(10)
    eta   &lt;- toppleMlink(toppleMlink(theta = theta), inverse  =TRUE)
    summary(eta - theta)     # Zero


  ## E2. Some probability link functions ##
  
my.probs &lt;- ppoints(100)

par(lwd = 2)
plot(my.probs, logitlink(my.probs), xlim = c(-0.1, 1.1), ylim = c(-5, 8),
     type = "l", col = "limegreen", 
     ylab = "transformation", las = 1, main = "Some probability link functions")
lines(my.probs, geometricffMlink(my.probs), col = "gray50")
lines(my.probs, logffMlink(my.probs), col = "blue")
lines(my.probs, probitlink(my.probs), col = "purple")
lines(my.probs, clogloglink(my.probs), col = "chocolate")
lines(my.probs, cauchitlink(my.probs), col = "tan")
lines(my.probs, toppleMlink(my.probs), col = "black")
abline(v = c(0.5, 1), lty = "dashed")
abline(v = 0, h = 0, lty = "dashed")
legend(0.1, 8, 
      c( "toppleMlink", "geometricffMlink", "logffMlink",
      "logitlink", "probitlink", 
      "clogloglink", "cauchitlink"), 
      col = c("black", "gray50", "blue", "limegreen", "purple", "chocolate", "tan"),
      lwd = 1, cex = 0.5)
par(lwd = 1) 
 

</code></pre>

<hr>
<h2 id='toppleQlink'>
Link functions for the quantiles of several 1&ndash;parameter continuous
distributions
</h2><span id='topic+toppleQlink'></span>

<h3>Description</h3>

<p>Computes the <code>toppleQlink</code> transformation, its inverse and the
first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  toppleQlink(theta, p = stop("Argument 'p' must be specified."),
              bvalue = NULL, inverse = FALSE,
              deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toppleQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. It is <code class="reqn">\theta</code> by default although
it could be <code class="reqn">\eta</code> depending upon other arguments. 
See <code><a href="VGAM.html#topic+Links">Links</a></code> for further details about this.
</p>
</td></tr>
<tr><td><code id="toppleQlink_+3A_p">p</code></td>
<td>

<p>Numeric. A single value between 0 and 1.
It is the <code class="reqn">p</code>&ndash;quantile to be modeled by this link function. 
</p>
</td></tr>
<tr><td><code id="toppleQlink_+3A_bvalue">bvalue</code>, <code id="toppleQlink_+3A_inverse">inverse</code>, <code id="toppleQlink_+3A_deriv">deriv</code>, <code id="toppleQlink_+3A_short">short</code>, <code id="toppleQlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This link function comforms with requirements of <span class="pkg">VGAM</span> in order
to be compatible within the VGLM/VGAM framework. That is, monotonic,
onto, among other features.
In this line, the <code>toppleQlink</code> transformation arises as the
proper link to model any quantile of the Topp&ndash;Leone distribution
<code><a href="VGAM.html#topic+topple">topple</a></code>. It is defined as

</p>
<p style="text-align: center;"><code class="reqn">\frac{1 - \sqrt{1 - p^{1/s}}}{m.max}.</code>
</p>


<p>Here, <code class="reqn">s</code> is a shape parameter lying in <code class="reqn">(0, 1)</code> 
as in <code><a href="VGAM.html#topic+topple">topple</a></code>,
whereas <code class="reqn">m.max</code> stands for the maximum in <code class="reqn">(0, 1)</code> of
</p>
<p style="text-align: center;"><code class="reqn">1 - \sqrt{1 - p^{1/s}}</code>
</p>

<p>as a function of <code class="reqn">s</code>. Note, <code class="reqn">p</code> is prespecified (fixed) between 
<code class="reqn">0</code> and <code class="reqn">1</code>. 
</p>
<p>Numerical values of <code class="reqn">s</code> or <code class="reqn">p</code> out of range will 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>
correspondingly.
</p>
<p>Arguments <code>inverse</code> and <code>deriv</code> will be ignored
if <code>theta</code> is character.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>toppleQlink</code> transformation of
<code>theta</code>, when <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, then
the inverse transformation 
<code> log(p)/log(1 - (1 - theta * </code><code class="reqn">m.max</code><code>)^2)</code> 
is returned.
</p>
<p>For <code>deriv = 1</code>, this function returns 
<code class="reqn">d</code> <code>eta</code> / <code class="reqn">d</code> <code>theta</code>, 
if <code>inverse = FALSE</code>. If <code>inverse = TRUE</code>, then the reciprocal 
<code class="reqn">d</code> <code>theta</code> / <code class="reqn">d</code> <code>eta</code> as a function of <code>theta</code>.
</p>
<p>If <code>deriv = 2</code>, then the second order derivatives as a function of
<code>theta</code>. 
</p>


<h3>Warning</h3>

<p>The expression <code class="reqn">p^{1/s}</code> tends rapidly to zero specially
for values of <code class="reqn">s</code> less than <code class="reqn">0.005</code>. Therefore, in such cases
numerical values represented as zero may be returned when computing
this link function, regardless the value of argument <code>inverse</code>.
</p>


<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to 0.0 or 1.0. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+topple">topple</a></code>, 
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## E1. toppleQLink() and its inverse. ##
  my.s &lt;- ppoints(50); p &lt;- 0.75
  max(my.s - toppleQlink(toppleQlink(my.s, p = p), p = p, inverse  =TRUE))   ## Zero
  toppleQlink(theta = c(-0.15, -0.10, 0.25, 0.35) , p = p, inverse  = FALSE) ## NaNs
  toppleQlink(theta = c(-0.15, -0.10, 0.25, 0.35) , p = p, inverse  = TRUE)  ## NaNs
   
   
  ## E2. toppleQLink() for different avlues of 'p'. ##
  
  plot(toppleQlink(theta = my.s, p = 0.05) ~ my.s,
       type = "l", col = "blue", lty = "dotted", lwd = 3,
       xlim = c(-0.1, 1.65), ylim = c(-0.1, 1.1), las = 1,
       main = c("The toppleQlink() transformation"),
       ylab = "eta = toppleQlink", xlab = "theta")
  abline(h = 0, v = 0, lwd = 2)
  abline(h = 1, v = 1, lty = "dotted", col = "green")
  lines(toppleQlink(theta = my.s, p = 0.25) ~ my.s, lwd = 2, lty = "dashed", col = "gray")
  lines(toppleQlink(theta = my.s, p = 0.50) ~ my.s, lwd = 2, lty = "dashed", col = "brown")
  lines(toppleQlink(theta = my.s, p = 0.75) ~ my.s, lwd = 2, lty = "dashed", col = "orange")
  lines(toppleQlink(theta = my.s, p = 0.95) ~ my.s, lwd = 2, lty = "dashed", col = "gray50")
  legend(1.1, 1.0, c("p = 0.05", "p = 0.25", "p = 0.50", "p = 0.75", "p = 0.95"),
         lwd = rep(2, 5), lty = rep("dashed", 5), 
         col = c("blue", "gray", "brown", "orange", "gray50"))
  
</code></pre>

<hr>
<h2 id='trinormalCovff'> Trivariate Normal Distribution Family Function</h2><span id='topic+trinormalCovff'></span>

<h3>Description</h3>

<p>Estimates the means and the upper-half of the (symmetric) covariance matrix of 
a trivariate normal distribution by maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>      trinormalCovff(zero = c("var", "cov"),
                     lmean = "identitylink",
                     lvar  = "loglink",
                     lcov  = "identitylink")
                    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trinormalCovff_+3A_zero">zero</code></td>
<td>

<p>The linear predictors modelled as intercept&ndash;only.
See <code><a href="VGAM.html#topic+zero">zero</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="trinormalCovff_+3A_lmean">lmean</code>, <code id="trinormalCovff_+3A_lvar">lvar</code>, <code id="trinormalCovff_+3A_lcov">lcov</code></td>
<td>

<p>Link functions applied to the means, variances (diagonal elements of the 
covariance matrix), and covariances (off-diagonal elements).

See <code><a href="VGAM.html#topic+Links">Links</a></code> for more choices.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This family function is similar to
<code><a href="VGAM.html#topic+trinormal">trinormal</a></code>. The only difference is
that the variances and covariances, instead of the 
standard deviations and correlation coefficients,
are directly modelled and estimated.
Similarly, <code><a href="#topic+trinormalCovff">trinormalCovff</a></code>
also fits linear models to the means of a trivariate normal distribution.
</p>
<p>The fitted means are returned as the fitted values in the form of a
three&ndash;column matrix. By default, the variances and covariances 
are modelled as intercept&ndash;only, where a
<code><a href="VGAM.html#topic+loglink">loglink</a></code> link is applied to the variances
and an <code><a href="VGAM.html#topic+identitylink">identitylink</a></code> over
the covariances.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>) to be
used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and Thomas Yee.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+trinormal">trinormal</a></code>,
<code><a href="VGAM.html#topic+zero">zero</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123); nn &lt;- 350
var1 &lt;- exp(1.5); var2 &lt;- exp(0.75); var3 &lt;- exp(1.0)

### Artificial data, with two covariates.
tdata &lt;- data.frame(x2 = runif(nn), x3 = runif(nn))
tdata &lt;- transform(tdata,
                   y1 = rnorm(nn, 1 + 2 * x2, sd = sqrt(var1)),
                   y2 = rnorm(nn, 3 + 1 * x2, sd = sqrt(var2)),
                   y3 = rnorm(nn, 3 - 1 * x3, sd = sqrt(var2 * var3)))

### Fit the model using VGAMextra::trinormalCovff().
fit.trinormCovff &lt;- vglm(cbind(y1, y2, y3) ~ x2 + x3,
                         trinormalCovff,
                         data = tdata, trace = TRUE)

summary(fit.trinormCovff)
vcov(fit.trinormCovff)
                         
### Fitting the model using VGAM::trinormal()
fit.trinormVGAM &lt;- vglm(cbind(y1, y2, y3) ~ x2 + x3,
                        trinormal,
                        data = tdata, trace = TRUE)
                         
summary(fit.trinormVGAM)
vcov(fit.trinormVGAM)

                         
#### Compare the estimated coefficients. Note that 
#### trinormal() estimates the sd's and correlation coeffs.
coef(fit.trinormCovff, matrix = TRUE)
coef(fit.trinormVGAM, matrix = TRUE)


</code></pre>

<hr>
<h2 id='trunclognormal'>
Truncated Log-normal Distribution Family Function
</h2><span id='topic+trunclognormal'></span>

<h3>Description</h3>

<p>Maximum likelihood estimate of the two&ndash;parameter lognormal
distribution with lower/upper truncation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> trunclognormal(lmeanlog = "identitylink", lsdlog = "loglink",
                min.support = 1e-6, max.support = Inf, zero = "sdlog") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trunclognormal_+3A_lmeanlog">lmeanlog</code>, <code id="trunclognormal_+3A_lsdlog">lsdlog</code>, <code id="trunclognormal_+3A_zero">zero</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+lognormal">lognormal</a></code>.
</p>
</td></tr>
<tr><td><code id="trunclognormal_+3A_min.support">min.support</code>, <code id="trunclognormal_+3A_max.support">max.support</code></td>
<td>

<p>Positive lower and upper truncation limits (recycled).
<code>min.support</code> enables LHS truncation;

<code>max.support</code> enables RHS truncation (default is 
none).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MLE of the two&ndash;parameter (univariate) lognormal distribution subject 
to lower/upper truncation. All response values are greater
than <code>min.support</code> and lower than <code>max.support</code>.
</p>
<p>Default values of <code>min.support</code>, <code>max.suppport</code> should 
effectively reproduce <code><a href="VGAM.html#topic+lognormal">lognormal</a></code>.
</p>
<p>The truncated&ndash;lognormal density for a response <code class="reqn">Y</code> is
</p>
<p style="text-align: center;"><code class="reqn">f(y; \mu, \sigma) =    f_N(y; \mu, \sigma) /
  [\Phi(\texttt{max.support}, \mu, \sigma) -
  \Phi(\texttt{min.support},\mu, \sigma) ], </code>
</p>

<p>where <code class="reqn">f_N</code> is the ordinary lognormal density (see
<code><a href="VGAM.html#topic+lognormal">lognormal</a></code>) and 
<code class="reqn">\Phi</code> is the standard normal CDF.
</p>
<p>The mean of Y, given by
</p>
<p style="text-align: center;"><code class="reqn">
\exp{(\mu + \sigma^2/2)} \cdot
[\Phi(((\log(\texttt{max.support}) - \mu)/\sigma) - \sigma) -
 \Phi(((\log(\texttt{min.support}) - \mu)/\sigma) - \sigma)  ]  /  
\Delta \Phi(\mu,\sigma),</code>
</p>
 
<p>with <code class="reqn">\Delta \Phi(\mu, \sigma) = 
 \Phi( (\log(\texttt{max.support}) - \mu)/\sigma )  -
 \Phi( (\log(\texttt{min.support}) - \mu)/\sigma ),</code>
are returned as the fitted values.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>).
The object is used by modelling functions such as 
<code><a href="VGAM.html#topic+vglm">vglm</a></code>,
and <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda, Siqi (Vicky) Liu and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Nadarajah, S. and Kotz, S. (2003).
<code>R</code> Programs for Computing Truncated Distributions.
<em>Journal of Statistical Software, Code
Snippets</em>,
<b>16</b>(2), 1&ndash;8. 
</p>
<p>Cohen, A.C. (1991)
<em>Truncated and Censored Samples:
Theory and Applications</em>,
New York, USA. Marcel Dekker.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+lognormal">lognormal</a></code>,
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>,
<code><a href="stats.html#topic+Lognormal">Lognormal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########
set.seed(10470923)
nn &lt;- 3000

## Parameters
mysdlog   &lt;- exp(-1.5)   # sdlog
LL   &lt;- 3.5              # Lower bound
UL   &lt;- 8.0              # Upper bound

## Truncated data
ldata2 &lt;- data.frame(x2 = runif(nn))
ldata2 &lt;- transform(ldata2, y1 = rtrunclnorm(nn, 1 + 1.5 * x2, mysdlog, 
                                             min.support = LL, max.support = UL))
# head(ldata2)
# hist(ldata2$y1, breaks = 22, col = "blue", xlim = c(0, 10))

##############################################################
# Fitting a truncated lognormal distribution - sd is intercept only
fit1 &lt;- vglm(y1 ~ x2, trunclognormal(zero = "sdlog", min.support = LL, max.support = UL),
             data = ldata2, trace = TRUE)
coef(fit1, matrix = TRUE)
vcov(fit1)
             
##############################################################
# Fitting a truncated lognormal distribution - zero = NULL
fit2 &lt;- vglm(y1 ~ x2, trunclognormal(zero = NULL, min.support = LL, max.support = UL),
             data = ldata2, trace = TRUE)
coef(fit2, matrix = TRUE)
vcov(fit2)

##############################################################
# Mimicking lognormal()
fit3 &lt;- vglm(y1 ~ x2, trunclognormal(zero = "sdlog"),
             data = ldata2, trace = TRUE)
coef(fit3, mat = TRUE)

# Same as
fit3bis &lt;- vglm(y1 ~ x2, lognormal(zero = "sdlog"),
                 data = ldata2, trace = TRUE)
coef(fit3bis, mat = TRUE)
</code></pre>

<hr>
<h2 id='truncLognormal'>The Truncated Log-Normal Distribution</h2><span id='topic+trunclognormalDist'></span><span id='topic+dtrunclnorm'></span><span id='topic+ptrunclnorm'></span><span id='topic+qtrunclnorm'></span><span id='topic+rtrunclnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random 
generation for the truncated log-normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtrunclnorm(x, meanlog = 0, sdlog = 1, min.support = 0, max.support = Inf, log = FALSE)
ptrunclnorm(q, meanlog = 0, sdlog = 1, min.support = 0, max.support = Inf) 
qtrunclnorm(p, meanlog = 0, sdlog = 1, min.support = 0, max.support = Inf, log.p = FALSE)
rtrunclnorm(n, meanlog = 0, sdlog = 1, min.support = 0, max.support = Inf)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncLognormal_+3A_x">x</code>, <code id="truncLognormal_+3A_q">q</code>, <code id="truncLognormal_+3A_p">p</code>, <code id="truncLognormal_+3A_n">n</code>, <code id="truncLognormal_+3A_meanlog">meanlog</code>, <code id="truncLognormal_+3A_sdlog">sdlog</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>. 
</p>
</td></tr>
<tr><td><code id="truncLognormal_+3A_min.support">min.support</code>, <code id="truncLognormal_+3A_max.support">max.support</code></td>
<td>
 
<p>Lower and upper truncation limits.
</p>
</td></tr>
<tr><td><code id="truncLognormal_+3A_log">log</code>, <code id="truncLognormal_+3A_log.p">log.p</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider <code class="reqn">Y \sim</code> 
<code>Lognormal</code><code class="reqn">(\mu_Y, \sigma_Y  )</code> restricted
to <code class="reqn">(A, B )</code>, 
that is, <code class="reqn">0 &lt; A  = \code{min.support} &lt; X &lt; B 
   = \code{max.support}</code>.
The (conditional)
random variable
<code class="reqn">Y = X \cdot I_{(A , B)} </code>
has a log&ndash;truncated normal distribution. Its p.d.f. is given by
</p>
<p style="text-align: center;"><code class="reqn">
  f(y; \mu, \sigma, A, B) = (y^{-1} / \sigma) \cdot
  \phi(y^*) / [  \Phi(B^*) - \Phi(A^*) ],
  </code>
</p>

<p>where <code class="reqn">y^* = [\log(y) - \mu_Y]/ \sigma_Y</code>, 
<code class="reqn">A^* = [\log(A) - \mu_Y] / \sigma_Y</code>, 
and
<code class="reqn">B^* = [\log(B) - \mu_Y] / \sigma_Y</code>.
</p>
<p>Its mean is:
</p>
<p style="text-align: center;"><code class="reqn">\exp(\mu + \sigma^2/2) \cdot \{\Phi[(\log(B) - \mu) / \sigma
  - \sigma] - \Phi[(\log(A) - \mu) / \sigma
  - \sigma] \} / \{ 
  \Phi[(\log(B) - \mu) / \sigma] - \Phi[(\log(A) - \mu) / \sigma] \}.
    </code>
</p>

<p>Here, <code class="reqn">\Phi</code> is the standard normal c.d.f and 
<code class="reqn">\phi</code> is the standard normal p.d.f.
</p>


<h3>Value</h3>

<p><code>dtrunclnorm()</code> returns the density, 
<code>ptrunclnorm()</code> gives the 
distribution function, 
<code>qtrunclnorm()</code> gives the quantiles, and 
<code>rtrunclnorm()</code> generates random deviates.
</p>





<h3>Author(s)</h3>

<p>Victor Miranda and Thomas W. Yee.</p>


<h3>References</h3>

<p>Johnson, N. L., Kotz, S. and Balakrishnan, N. (1995) 
<em>Continuous Univariate Distributions</em>, Second Edition,
(Chapter 13) Wiley, New York.







</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Lognormal">Lognormal</a></code>,
<code><a href="#topic+truncnormal">truncnormal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############
## Example 1 ##

mymeanlog &lt;- exp(0.5)    # meanlog
mysdlog   &lt;- exp(-1.5)   # sdlog
LL   &lt;- 3.5              # Lower bound
UL   &lt;- 8.0              # Upper bound

## Quantiles:
pp &lt;- 1:10 / 10
(quants &lt;- qtrunclnorm(p = pp , min.support = LL, max.support = UL, 
                        mymeanlog, mysdlog))
sum(pp - ptrunclnorm(quants, min.support = LL, max.support = UL,
                      mymeanlog, mysdlog))     # Should be zero

###############
## Example 2 ##

set.seed(230723)
nn &lt;- 3000

## Truncated log-normal data
trunc_data &lt;- rtrunclnorm(nn, mymeanlog, mysdlog, LL, UL)

## non-truncated data - reference
nontrunc_data &lt;- rtrunclnorm(nn, mymeanlog, mysdlog, 0, Inf)

## Not run: 
## Densities
plot.new()
par(mfrow = c(1, 2))
plot(density(nontrunc_data), main = "Non-truncated Log--normal", 
     col = "green", xlim = c(0, 15), ylim = c(0, 0.40))
abline(v = c(LL, UL), col = "black", lwd = 2, lty = 2)
plot(density(trunc_data), main = "Truncated Log--normal", 
     col = "red", xlim = c(0, 15), ylim = c(0, 0.40))


## Histograms
plot.new()
par(mfrow = c(1, 2))
hist(nontrunc_data, main = "Non-truncated Log--normal", col = "green", 
       xlim = c(0, 15), ylim = c(0, 0.40), freq = FALSE, breaks = 22,
       xlab = "mu = exp(0.5), sd = exp(-1.5), LL = 3.5, UL = 8")
abline(v = c(LL, UL), col = "black", lwd = 4, lty = 2)

hist(trunc_data, main = "Truncated Log--normal", col = "red",
     xlim = c(0, 15), ylim = c(0, 0.40), freq = FALSE, 
     xlab = "mu = exp(0.5), sd = exp(-1.5), LL = 3.5, UL = 8")

## End(Not run)


## Area under the estimated densities
# (a) truncated data
integrate(approxfun(density(trunc_data)), 
          lower = min(trunc_data) - 0.1, 
          upper = max(trunc_data) + 0.1)

# (b) non-truncated data
integrate(approxfun(density(nontrunc_data)), 
          lower = min(nontrunc_data), 
          upper = max(nontrunc_data))

  
</code></pre>

<hr>
<h2 id='truncnormal'>
Truncated normal Distribution Family Function
</h2><span id='topic+truncnormal'></span>

<h3>Description</h3>

<p>Maximum likelihood estimate of the two&ndash;parameter normal
distribution with lower/upper truncation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> truncnormal(lmean = "identitylink", lsd = "loglink",
             min.support = -Inf, max.support = Inf, zero = "sd") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncnormal_+3A_lmean">lmean</code>, <code id="truncnormal_+3A_lsd">lsd</code></td>
<td>

<p>Link functions applied to mean and standard deviation/variance. 
</p>
</td></tr>
<tr><td><code id="truncnormal_+3A_min.support">min.support</code>, <code id="truncnormal_+3A_max.support">max.support</code></td>
<td>

<p>Vector of lower and upper truncation limits (recycled).
<code>min.support</code> enables LHS truncation and
<code>max.support</code> enables RHS truncation. 
The default imply no truncation (mimicks 
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>).
</p>
</td></tr>
<tr><td><code id="truncnormal_+3A_zero">zero</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code> for more information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MLE of the two&ndash;parameter (univariate) normal distribution subject to 
lower/upper truncation. All response values are greater
then <code>min.support</code> and/or lower than <code>max.support</code>.
</p>
<p>The truncated&ndash;normal density for a response <code class="reqn">Y</code> is
</p>
<p style="text-align: center;"><code class="reqn">f(y; \mu, \sigma) =    f(y; \mu, \sigma) /
  [\Phi(\texttt{max.support}, \mu, \sigma) -
  \Phi(\texttt{min.support},\mu, \sigma) ], </code>
</p>

<p>where <code class="reqn">f</code> is the probability density function of standard normal
distribution and <code class="reqn">\Phi</code> is the standard normal CDF.
</p>
<p>The mean of Y, given by
</p>
<p style="text-align: center;"><code class="reqn">
\mu + [\varphi(\texttt{min.support}) + \varphi(\texttt{max.support})/\Delta \Phi(\mu,\sigma)]\cdot \sigma,
</code>
</p>

<p>with <code class="reqn">\Delta \Phi(\mu, \sigma) = 
 \Phi((\texttt{max.support} - \mu)/\sigma )  -
 \Phi( (\texttt{min.support} - \mu)/\sigma ),</code>
are returned as the fitted values.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>).
The object is used by modelling functions such as 
<code><a href="VGAM.html#topic+vglm">vglm</a></code>,
and <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Author(s)</h3>

<p>Siqi (Vicky) Liu, Victor Miranda, and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Nadarajah, S. and Kotz, S. (2003).
<code>R</code> Programs for Computing Truncated Distributions.
<em>Journal of Statistical Software, Code
Snippets</em>,
<b>16</b>(2), 1&ndash;8. 
</p>
<p>Cohen, A.C. (1991)
<em>Truncated and Censored Samples:
Theory and Applications</em>,
New York, USA. Marcel Dekker.
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+uninormal">uninormal</a></code>,
<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nn &lt;- 2000
set.seed(14290909)

## Parameters
mysd &lt;- exp(1.0)   # sd
LL   &lt;- -0.5       # Lower bound
UL   &lt;-  8.0       # Upper bound

## Truncated data
ldata2 &lt;- data.frame(x2 = runif(nn))
ldata2 &lt;- transform(ldata2, y1 = rtruncnorm(nn, 1 + 1.5 * x2, mysd, 
                                min.support = LL, max.support = UL))
# head(ldata2)
# hist(ldata2$y1, breaks = 22, col = "blue", xlim = c(-5, 10))

##############################################################
# Fitting a truncated normal distribution - sd is intercept only
fit1 &lt;- vglm(y1 ~ x2, truncnormal(zero = "sd", min.support = LL, max.support = UL),
             data = ldata2, trace = TRUE)
coef(fit1, matrix = TRUE)
vcov(fit1)
             
##############################################################
# Fitting a truncated lognormal distribution - zero = NULL
fit2 &lt;- vglm(y1 ~ x2, truncnormal(zero = NULL, min.support = LL, max.support = UL),
             data = ldata2, trace = TRUE)
coef(fit2, matrix = TRUE)
vcov(fit2)

##############################################################
# Mimicking uninormal()
fit3 &lt;- vglm(y1 ~ x2, truncnormal(zero = "sd"),
             data = ldata2, trace = TRUE)
coef(fit3, mat = TRUE)

# Same as
fit3bis &lt;- vglm(y1 ~ x2, uninormal(zero = "sd"),
                 data = ldata2, trace = TRUE)
coef(fit3bis, mat = TRUE)



</code></pre>

<hr>
<h2 id='truncNormal'>The Truncated Normal Distribution</h2><span id='topic+truncnormalDist'></span><span id='topic+dtruncnorm'></span><span id='topic+ptruncnorm'></span><span id='topic+qtruncnorm'></span><span id='topic+rtruncnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random numbers 
generator for the truncated normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtruncnorm(x, mean = 0, sd = 1, min.support = -Inf, max.support = Inf, log = FALSE)
ptruncnorm(q, mean = 0, sd = 1, min.support = -Inf, max.support = Inf) 
qtruncnorm(p, mean = 0, sd = 1, min.support = -Inf, max.support = Inf, log.p = FALSE)
rtruncnorm(n, mean = 0, sd = 1, min.support = -Inf, max.support = Inf)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncNormal_+3A_x">x</code>, <code id="truncNormal_+3A_q">q</code>, <code id="truncNormal_+3A_p">p</code>, <code id="truncNormal_+3A_n">n</code>, <code id="truncNormal_+3A_mean">mean</code>, <code id="truncNormal_+3A_sd">sd</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Normal">Normal</a></code>. 
</p>
</td></tr>
<tr><td><code id="truncNormal_+3A_min.support">min.support</code>, <code id="truncNormal_+3A_max.support">max.support</code></td>
<td>
 
<p>Lower and upper truncation limits.
</p>
</td></tr>
<tr><td><code id="truncNormal_+3A_log">log</code>, <code id="truncNormal_+3A_log.p">log.p</code></td>
<td>

<p>Same as <code><a href="stats.html#topic+Normal">Normal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider <code class="reqn">X \sim</code> N(<code class="reqn">\mu</code>,
<code class="reqn">\sigma^2</code>), with <code class="reqn">A &lt; X &lt; B</code>,
i.e., <code class="reqn">X</code> restricted to <code class="reqn">(A , B)</code>.
We denote <code class="reqn">A</code> = <code>min.support</code> and
<code class="reqn">B</code> = <code>max.support</code>.
</p>
<p>Then the conditional
random variable
<code class="reqn">Y = X \cdot I_{(A , B)} </code>
has a truncated normal distribution. Its p.d.f. is given by
</p>
<p style="text-align: center;"><code class="reqn">
  f(y; \mu, \sigma, A, B) = (1 / \sigma) \cdot
  \phi(y^*) / [  \Phi(B^*) - \Phi(A^*) ],
  </code>
</p>

<p>where <code class="reqn">y^* = (y - \mu)/ \sigma</code>, 
<code class="reqn">A^* = (A - \mu) / \sigma</code>, 
and
<code class="reqn">B^* = (B - \mu) / \sigma</code>.
</p>
<p>Its mean is 
</p>
<p style="text-align: center;"><code class="reqn">\mu + \sigma \cdot [ \phi(A) - \phi(B) ] / 
  [\Phi(B) - \Phi(A)]. </code>
</p>

<p>Here, <code class="reqn">\Phi</code> is the standard normal c.d.f and 
<code class="reqn">\phi</code> is the standard normal p.d.f.
</p>


<h3>Value</h3>

<p><code>dtruncnorm()</code> returns the density, 
<code>ptruncnorm()</code> gives the 
distribution function, 
<code>qtruncnorm()</code> gives the quantiles, and 
<code>rtruncnorm()</code> generates random deviates.
</p>
<p><code>dtruncnorm</code> is computed from the definition, as 
in 'Details'. <code>[pqr]</code>truncnormal are computed based
on their relationship to the normal distribution.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and Thomas W. Yee.</p>


<h3>References</h3>

<p>Johnson, N. L., Kotz, S. and Balakrishnan, N. (1995) 
<em>Continuous Univariate Distributions</em>,
Second Edition (Chapter 13). Wiley, New York.







</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>,
<code><a href="VGAM.html#topic+truncweibull">truncweibull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############
## Example 1 ##

mymu &lt;- 2.1   # mu
mysd &lt;- 1.0   # sigma
LL   &lt;- -1.0  # Lower bound
UL   &lt;- 3.0   # Upper bound

## Quantiles:
pp &lt;- 1:10 / 10
(quants &lt;- qtruncnorm(p = pp , min.support = LL, max.support = UL, 
                        mean = mymu,  sd = mysd))
sum(pp - ptruncnorm(quants, min.support = LL, max.support = UL,
                      mean = mymu, sd = mysd))     # Should be zero

###############
## Example 2 ##

## Parameters
set.seed(230723)
nn &lt;- 3000
mymu &lt;- 12.7    # mu
mysigma &lt;- 3.5  # sigma
LL &lt;- 6     # Lower bound
UL &lt;- 17    # Upper bound

## Truncated-normal data
trunc_data &lt;- rtruncnorm(nn, mymu, mysigma, LL, UL)

## non-truncated data - reference
nontrunc_data &lt;- rnorm(nn, mymu, mysigma)


## Not run: 
## Densities
par(mfrow = c(1, 2))
plot(density(nontrunc_data), main = "Non-truncated ND", 
     col = "green", xlim = c(0, 25), ylim = c(0, 0.15))
abline(v = c(LL, UL), col = "black", lwd = 2, lty = 2)
plot(density(trunc_data), main = "Truncated ND", 
     col = "red", xlim = c(0, 25), ylim = c(0, 0.15))


## Histograms
plot.new()
par(mfrow = c(1, 2))
hist(nontrunc_data, main = "Non-truncated ND", col = "green", 
     xlim = c(0, 25), ylim = c(0, 0.15), freq = FALSE, breaks = 22,
     xlab = "mu = 12.7, sd = 3.5, LL = 6, UL = 17")
abline(v = c(LL, UL), col = "black", lwd = 4, lty = 2)
hist(trunc_data, main = "Truncated ND", col = "red",
     xlim = c(0, 25), ylim = c(0, 0.15), freq = FALSE,
     xlab = "mu = 12.7, sd = 3.5, LL = 6, UL = 17")


## End(Not run)


## Area under the estimated densities
# (a) truncated data
integrate(approxfun(density(trunc_data)), 
          lower = min(trunc_data) - 1, 
          upper = max(trunc_data) + 1)

# (b) non-truncated data
integrate(approxfun(density(nontrunc_data)), 
          lower = min(nontrunc_data), 
          upper = max(nontrunc_data))

  
</code></pre>

<hr>
<h2 id='undocumented-methods'> Undocumented Methods Functions in <span class="pkg">VGAMextra</span> </h2><span id='topic+typeTS+2Cvglm-method'></span>

<h3>Description</h3>

<p>Undocumented methods functions are aliased here.
In the <span class="pkg">VGAMextra</span> package there are currently some
objects/methods/classes which are currently internal and/or
undocumented. The help file suppresses the warnings when the package is
'CHECK'ed.
</p>


<h3>Methods</h3>

<p>Methods/classes will be documented over time.
</p>

<dl>
<dt>object</dt><dd>
<p>This argument is often used, and it is the primary object from which the
function operates on.
</p>
</dd>
</dl>


<hr>
<h2 id='uninormalff'>
Normal (distribution&ndash;specified) quantile regression
</h2><span id='topic+uninormalff'></span>

<h3>Description</h3>


<p>Distribution&ndash;specified quantile regression.
An extension of <code>uninormal</code> from <span class="pkg">VGAM</span>.
It handles effectively <code>uninormalQlink</code> via the first
linear predictor.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>    
     uninormalff(link1 = "identitylink", lsd = "loglink",
                 percentile = 50,
                 imethod = 1, isd = NULL, parallel = FALSE,
                 smallno = 1.0e-5, zero = "sd")
             
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uninormalff_+3A_link1">link1</code></td>
<td>

<p>Link function for the first linear predictor.
By default
<code>link1 = "identitylink"</code>,
same as <code>lmean</code> from
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>.
Set <code>link1 = "uninormalQlink"</code> for normal
quantile regression.
See details below.
</p>
</td></tr>
<tr><td><code id="uninormalff_+3A_percentile">percentile</code></td>
<td>

<p>Numeric. A vector with the percentiles of interest, between
0 and 100.
Used only when <code>link1 = "uninormalQlink"</code>.
</p>
</td></tr>
<tr><td><code id="uninormalff_+3A_lsd">lsd</code>, <code id="uninormalff_+3A_imethod">imethod</code>, <code id="uninormalff_+3A_isd">isd</code>, <code id="uninormalff_+3A_parallel">parallel</code>, <code id="uninormalff_+3A_smallno">smallno</code>, <code id="uninormalff_+3A_zero">zero</code></td>
<td>

<p>Same as in
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>, except
that <code>"sd"</code> is the only accepted value for <code>zero</code>. 
</p>
</td></tr>












</table>


<h3>Details</h3>

<p>An extension of 
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code> adapted to handle
<code><a href="#topic+uninormalQlink">uninormalQlink</a></code>, 
for normal quantile regression (QR) via the first
linear predictor. 
</p>
<p>The standard deviation only can be estimated.
The second linear predictor is fixed to
<code class="reqn">\eta_2 = \log \sigma</code>, and
<code>var.arg</code> is set internally to <code>FALSE</code>.
</p>
<p>Unlike usual QR where the distribution of <code class="reqn">Y|X</code> is unspecified,
<code>uninormalff()</code> estimates normal distributions at different
quantiles (as entered in <code>percentile</code>)
of the <code class="reqn">Y|X</code>. For this, set
<code>link1 = uninormaQlink</code>. To mimic
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code> set
<code>link1 = "identitylink"</code> (default).
</p>
<p>Initial developments of this work are in 
<em>Miranda &amp; Yee (2019)</em>.
See, e.g., 
<code><a href="#topic+weibullRff">weibullRff</a></code>,
for another example on distribution specified
quantile regression with the two&ndash;parameter Weibull
distribution.
</p>

















<h3>Value</h3>

<p>An object of class <code>"vglm"</code>.
See <code><a href="VGAM.html#topic+vglm-class">vglm-class</a></code> for full details.
</p>


<h3>Note</h3>

<p><code><a href="#topic+Q.reg">Q.reg</a></code> must be used in
the <code>vglm()</code> or <code>vgam()</code> to enter the response.
See example below.
</p>



<p>This <b>VGAM</b> family function does not handle censored data.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Miranda &amp; Yee (2019) 
<em>New Link Functions for Distribution&ndash;Specific
Quantile Regression Based on Vector Generalized
Linear and Additive Models</em>.
Journal of Probability and Statistics, 
Article ID 3493628.
</p>
<p>Miranda &amp; Yee (2021) 
<em>Two&ndash;Parameter Link Functions,
With Application to Negative Binomial, Weibull and
Quantile Regression</em>. In preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uninormalQlink">uninormalQlink</a></code>,
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>,
<code><a href="#topic+Q.reg">Q.reg</a></code>,
<code><a href="#topic+weibullQlink">weibullQlink</a></code>,
<code><a href="#topic+weibullRff">weibullRff</a></code>,


<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.



</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

x2 &lt;- seq(0,10,length.out = 100)             # independent variable
sig &lt;- exp(0.5 + 0.15*x2)                    # non-constant variance
b_0 &lt;- 10                                    # true intercept
b_1 &lt;- 0.15                                  # true slope
set.seed(17221)                              # make the next line reproducible
e &lt;- rnorm(100,mean = 0, sd = sig)           # normal random error with non-constant variance
y &lt;- b_0 + b_1*x2 + e                        # dependent variable

## Data
ndata &lt;- data.frame(y = y, x2 = x2)

## Some percentiles of interest
percentile &lt;- c(10, 25, 50, 90)

## Normal quantile regression, zero = NULL
fit1 &lt;- vglm(Q.reg(y, length.arg = 4) ~ x2, 
             uninormalff(link1 = "uninormalQlink", percentile = percentile, zero = NULL), 
             data = ndata, trace = TRUE)
#summary(fit1)
( my.coef3Q &lt;- coef(fit1, mat = TRUE) )

## Plots - percentile curves.
plot(y ~ x2, pch = 19, ylim = c(-1, 25), 
main =" Normal quantile regression")
abline(h = -3:25, v = 0, col = "gray", lty = "dashed")
with(ndata, lines(x2, my.coef3Q[1, 1] + my.coef3Q[2, 1] * x2, 
                  col = "red", lty = "dotted", lwd = 4))
with(ndata, lines(x2, my.coef3Q[1, 3] + my.coef3Q[2, 3] * x2, 
                  col = "orange", lty = "dotted", lwd = 4))
with(ndata, lines(x2, my.coef3Q[1, 5] + my.coef3Q[2, 5] * x2, 
                  col = "blue", lty = "dotted", lwd = 4))
with(ndata, lines(x2, my.coef3Q[1, 7] + my.coef3Q[2, 7] * x2, 
                  col = "brown", lty = "dotted", lwd = 4))
legend("topleft", c("90th", "50th", "25th", "10th"),
col = c("brown", "blue", "orange", "red"), lty = rep("dotted", 4), lwd = rep(4, 4))


## Mimicking 'VGAM:uninormal'
fit2 &lt;- vglm(y ~ x2,  uninormalff(link1 = "identitylink", percentile = NULL, zero = NULL), 
             data = ndata, trace = TRUE)

     
## End(Not run)
</code></pre>

<hr>
<h2 id='uninormalQlink'>
Quantile regression:
Link function for the quantiles of the normal distribution.
</h2><span id='topic+uninormalQlink'></span>

<h3>Description</h3>


<p>Computes the <code>uninormalQlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>     uninormalQlink(theta, percentile = stop("Enter percentiles."),
                    sd = NULL, wrt.param = NULL,
                    bvalue = NULL, inverse = FALSE,
                    deriv = 0, short = TRUE, tag = FALSE)
                       
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uninormalQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code>
('mean' parameter) but iy may 
be <code class="reqn">\eta</code> depending on the other parameters.
See below for further details.
</p>
</td></tr>
<tr><td><code id="uninormalQlink_+3A_percentile">percentile</code></td>
<td>

<p>Numeric. A vector of percentiles of interest, denoted as <code>perc</code>.
</p>
</td></tr>
<tr><td><code id="uninormalQlink_+3A_sd">sd</code></td>
<td>

<p>Numeric, positive. The 'standard deviation' parameter (required),
denoted as <code class="reqn">\sigma</code>. 
</p>
</td></tr>
<tr><td><code id="uninormalQlink_+3A_wrt.param">wrt.param</code></td>
<td>

<p>Positive integer, either <code class="reqn">1</code> or <code class="reqn">2</code>. The partial derivatives
are computed with respect to one of the two linear predictors 
involved with this link. Further details listed below.
</p>
</td></tr>
<tr><td><code id="uninormalQlink_+3A_bvalue">bvalue</code>, <code id="uninormalQlink_+3A_inverse">inverse</code>, <code id="uninormalQlink_+3A_deriv">deriv</code>, <code id="uninormalQlink_+3A_short">short</code>, <code id="uninormalQlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 2-parameter link for the quantiles of the normal 
distribution. It can only be used within 
<code><a href="#topic+uninormalff">uninormalff</a></code> as the first linear
predictor. It is defined as





</p>
<p style="text-align: center;"><code class="reqn"> \tt{uninormalQlink}(\mu; \sigma) = \eta_1(\mu; \sigma) = 
                \mu + \sigma \cdot \Phi^{-1}(perc), </code>
</p>


<p>where <code class="reqn">\Phi</code> is the error function
(see, e.g., <code><a href="VGAM.html#topic+erf">erf</a></code>), 
<code class="reqn">\mu in (-\infty, \infty)</code>, and <code class="reqn">\sigma &gt; 0</code>.
This link is expressly a function of <code class="reqn">\theta = \mu</code>, therefore
<code class="reqn">sigma</code> must be entered at every call.

Numerical values of <code class="reqn">\sigma</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>uninormalQlink</code> transformation of
<code>theta</code>, i.e. <code class="reqn">\mu</code>, when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then <code class="reqn">\theta</code> becomes <code class="reqn">\eta</code>,
and the inverse, <code class="reqn">\eta - \sigma \Phi^{-1}(perc)</code>,
<em>for given</em> <code class="reqn">\sigma</code>, is returned.
</p>
<p>When <code>deriv = 1</code> <code>theta</code> becomes 
<code class="reqn">\theta = (\mu, \sigma)= (\theta_1, \theta_2)</code>, and
<code class="reqn">\eta = (\eta_1, \eta_2)</code> with 
<code class="reqn">\eta_2 = \log~\sigma</code>,
and the argument <code>wrt.param</code> must be
considered:
</p>
<p>A) If <code>inverse = FALSE</code>, then 
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code class="reqn">\mu</code> is returned when 
<code>wrt.param = 1</code>, and
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code class="reqn">\sigma</code> if
<code>wrt.param = 2</code>.
</p>
<p>B) For <code>inverse = TRUE</code>, this link returns
<code class="reqn">d</code> <code class="reqn">\mu</code> / <code class="reqn">d</code> <code>eta1</code> and
<code class="reqn">d</code> <code class="reqn">\sigma</code> / <code class="reqn">d</code> <code>eta1</code> conformably arranged
in a matrix, if <code>wrt.param = 1</code>,
as a function of <code class="reqn">\theta_i</code>, <code class="reqn">i = 1, 2</code>.
When <code>wrt.param = 2</code>, then
<code class="reqn">d\mu</code> / <code class="reqn">d</code> <code>eta2</code> and 
<code class="reqn">d\sigma</code> / <code class="reqn">d</code> <code>eta2</code>
is returned.  











</p>
<p>For <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are similarly returned.
</p>






<h3>Note</h3>

<p>Numerical instability may occur for values of
<code>sigma</code> too close
to zero. Use argument <code>bvalue</code> to replace the former only before
computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uninormalff">uninormalff</a></code>,
<code><a href="VGAM.html#topic+uninormal">uninormal</a></code>,

<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    eta &lt;- seq(-3, 3, by = 0.1) # this is eta = log(Normal - Quantiles).
    sigma  &lt;- exp(1)    # 'sigma' argument.
    percentile &lt;- c(25, 50, 75, 95)  # some percentiles of interest.
 
 ## E1. Get 'mean' values.
   theta &lt;- uninormalQlink(theta = eta, percentile = percentile,
                          sd = sigma, inverse = TRUE)  # Mu
   
 ## Not run: 
 ## E2. Plot theta vs. eta, 'shape' fixed, for different percentiles.
plot(theta[, 1], eta, type = "l", las = 1, lty = 2, lwd = 3,
     ylim = c(-10, 10), xlim = c(-10, 10),
     main = "uninormalQlink(theta; shape), fixed 'shape'.",
     xlab = "Theta (scale)", ylab = "uninormalQlink")
abline(v = 0, h = 0, col = "red")
lines(theta[, 2], eta, lty = 2, lwd = 3, col = "blue")
lines(theta[, 3], eta, lty = 2, lwd = 3, col = "orange")
lines(theta[, 4], eta, lty = 2, lwd = 3, col = "red")
legend("bottomright", c("25th Perc", "50th Perc", "75th Perc", "95th Perc"),
      col = c("black", "blue", "orange", "red"), lty = c(2, 2, 2, 2),
      lwd = rep(3, 4))

 
## End(Not run)
 
 ## E3. uninormalQlink() and its inverse ##
    etabis  &lt;- uninormalQlink(theta = theta, percentile = percentile,
                              sd = sigma, inverse = FALSE)
    my.diff &lt;- eta - etabis
    summary(my.diff)     # Zero
</code></pre>

<hr>
<h2 id='UtilitiesVGAMextra'> Utility Functions for the <span class="pkg">VGAMextra</span> Package </h2><span id='topic+UtilitiesVGAMextra'></span><span id='topic+Is.Numeric'></span><span id='topic+is.FormulaAR'></span><span id='topic+cross.gammas'></span><span id='topic+extract.Residuals'></span><span id='topic+fittedVGAMextra'></span><span id='topic+weightsVGAMextra'></span><span id='topic+WN.lags'></span><span id='topic+isNA'></span><span id='topic+inspectVGAMextra'></span><span id='topic+ffff.help'></span><span id='topic+XLMmat'></span>

<h3>Description</h3>

<p>A set of common utility functions required by time series family 
functions at 'VGAMextra'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  Is.Numeric(x, isInteger  = FALSE, length.arg = NULL, Nnegative  = NULL)
  is.FormulaAR(Model = ~ 1, Resp  = 1) 
  cross.gammas(x, y = NULL, lags = 1)
  WN.lags(y, lags, to.complete = NULL)
  extract.Residuals(object, TSprocess,...)
  fittedVGAMextra(object,...)
  weightsVGAMextra(object, type.w = "prior",...)
  XLMmat(object,...)
  
  
  

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UtilitiesVGAMextra_+3A_x">x</code></td>
<td>

<p>A vector of quantiles. Particularly, for <code>Is.Numeric</code> it is a
single number (or vector) to be tested: Whether is numeric or not.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_y">y</code></td>
<td>

<p>Vector of quantiles to be lagged. Then, the <em>cross - covariances</em>
are computed from <code class="reqn">x</code> and <code class="reqn">y_t</code>, <code class="reqn">x</code> and 
<code class="reqn">y_{t -1}</code>, etcetera.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_isinteger">isInteger</code></td>
<td>

<p>Logical. If <code>TRUE</code>, it verifies that quantiles <code>x</code> are integers.
Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_lags">lags</code></td>
<td>

<p>Integer indicating the number of lags or <em>delays</em> to be applied to 
vector <code>y</code>. Then, calculate the cross-covariance between the pair
of signals <code>x</code> and delayed samples computed from <code>y</code>.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_length.arg">length.arg</code></td>
<td>

<p>Integer. If <code>length.arg &gt; 0</code>, it verifies that the length of
<code>x</code> matches <code>length.arg</code>.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_model">Model</code></td>
<td>

<p>Formula. A symbolic form of the models fitted by the <code>vglm</code> call.
See <code><a href="stats.html#topic+formula">formula</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_nnegative">Nnegative</code></td>
<td>

<p>Logical. If <code>TRUE</code>, it verifies that <code>x</code> (all entries) are
positive.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_resp">Resp</code></td>
<td>

<p>Integer. The number of <em>responses</em> in the <code>Model</code>. It must 
macth the number of respones entered in the <code>vglm</code> call.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_object">object</code></td>
<td>

<p>An object of class <code>'vglm'</code>.
See <code><a href="VGAM.html#topic+vglm-class">vglm-class</a></code> for details.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_tsprocess">TSprocess</code></td>
<td>

<p>Logical, what time series model is being fitted.
Choices are 
<code>'AR', 'MA', 'ARMA'</code> and  <code>'ARIMA'</code>.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_type.w">type.w</code></td>
<td>

<p>Character. What type of <code>weights</code> are to be used. 
Default is <code>"prior"</code>.
These are extracted from the slot <code>@prior.weights</code> of
<code>object</code>.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_to.complete">to.complete</code></td>
<td>

<p>Use this argument to fill in the first 'p' observations when
computing the lagged vectors in time series.
</p>
</td></tr>
<tr><td><code id="UtilitiesVGAMextra_+3A_...">...</code></td>
<td>

<p>Additional parameters required by function
<code><a href="#topic+extract.Residuals">extract.Residuals</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of utility functions in <span class="pkg">VGAMextra</span> for different
purposes.
</p>
<p>Specially for time series family functions in <span class="pkg">VGAMextra</span> which 
involve specific checks on the majority of arguments entered by 
the user.
</p>


<h3>Value</h3>

<p><code>Is.Numeric()</code> returns a logical vector (or value)
(<code>TRUE</code> or <code>FALSE</code>), after verifying whether quantiles
<code>x</code> satisfies all conditions entered.
</p>
<p>For <code>is.FormulaAR()</code>, this function returns a logical value,
after verifying whether the expression entered for the <code>Model</code>
argument in <code><a href="#topic+cm.ARMA">cm.ARMA</a></code> is an 
object of class '<code>formula</code>'. 
</p>
<p>Particularly, <code>cross.gammas()</code> computes either the single lagged 
covariance(s) from quantiles given in <code>x</code> or the 
lagged cross-covariance(s) from values given in <code>x</code> and <code>y</code>. 
</p>
<p><code>extract.Residuals()</code> extracts the residuals of the process from
slot <code>@residuals</code>, whilst
</p>
<p><code>fittedVGAMextra</code> and <code>weightsVGAMextra</code> return the
fitted values and the weights from the <code>vglm</code> object,
correspondingly.
</p>
<p><code>isNA</code> and <code>inspectVGAMextra</code> are essentially required when
implementing link functions in <span class="pkg">VGAMextra</span>.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cm.ARMA">cm.ARMA</a></code>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1.
myModel1 &lt;- ~ x1 + x2
is.FormulaAR(myModel1)       # TRUE

test &lt;- list( cbind(y1, y2) ~ x1, ~ x2 - 1)
is.FormulaAR(test)          # FALSE
is.FormulaAR(test[[1]], 2)  # TRUE

# Example 2.

x1 &lt;- c(1:3, 4.5, -Inf)
Is.Numeric(x1)                                        # TRUE
Is.Numeric(x1, length.arg = 5)                        # TRUE
Is.Numeric(x1, length.arg = 5, isInteger = TRUE)      # FALSE
Is.Numeric(x1, length.arg = 5, Nnegative = TRUE)      # FALSE

# Example 3. 
# Here, 'cross.gammas' computes Cov(x, y_{t - 1}), Cov(x, y_{t - 2}) and
# Cov(x, y_{t - 3}). 

x &lt;- runif(50)
y &lt;- runif(50)
cross.gammas(x, y, lags = 3)


</code></pre>

<hr>
<h2 id='VARff'> VGLTSM family function for the
Order&ndash;<code class="reqn">p</code> Vector Auto(R)egressive Model</h2><span id='topic+VARff'></span>

<h3>Description</h3>

<p>Estimates an Order(<code class="reqn">p</code>) Vector Autoregressive Models (VAR(p)) with
white noise random errors
by maximum likelihood estimation using Fisher scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>            VARff(VAR.order = 1,
                  zero = c("var", "cov"),
                  lmean = "identitylink",
                  lvar  = "loglink",
                  lcov  = "identitylink")
                    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VARff_+3A_var.order">VAR.order</code></td>
<td>

<p>Length&ndash;1 (positive) integer vector. The order of the VAR to be 
fitted.
</p>
</td></tr>
<tr><td><code id="VARff_+3A_zero">zero</code></td>
<td>

<p>Integer or character - string vector.
Same as <code><a href="#topic+MVNcov">MVNcov</a></code>.
Details at <code><a href="VGAM.html#topic+zero">zero</a></code>.
</p>
</td></tr>
<tr><td><code id="VARff_+3A_lmean">lmean</code>, <code id="VARff_+3A_lvar">lvar</code>, <code id="VARff_+3A_lcov">lcov</code></td>
<td>

<p>Same as <code><a href="#topic+MVNcov">MVNcov</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\boldsymbol{x}_t = (x_{1, t}, \ldots, x_{K, t})^T</code> be a time dependent
vector of responses, with index <code class="reqn">t = 1, \ldots, T</code>,
and <code class="reqn">\boldsymbol{\varepsilon}_t = (\varepsilon_{1, t},
\ldots, \varepsilon_{K, t})</code>
white noise with covariance matrix 
<code class="reqn">\boldsymbol{\textrm{V}}</code>.
</p>
<p><code>VARff</code> fits a linear model to the means of a 
<code class="reqn">K</code>&ndash;variate normal distribution, where
each variable, <code class="reqn">x_{i, t}</code>, <code class="reqn">i = 1, \ldots, K</code>,
is a linear function of <code class="reqn">p</code>&ndash;past
lags of itself and past <code class="reqn">p</code>&ndash;lags of the other variables.
The model has the form
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{x}_t = \boldsymbol{\Phi_1} \boldsymbol{x}_{t - 1} +
\cdots + \boldsymbol{\Phi_p} \boldsymbol{x}_{t - p} +
\boldsymbol{\varepsilon}_t,</code>
</p>

<p>where <code class="reqn">\boldsymbol{\Phi_j}</code> are 
<code class="reqn">K \times K</code> matrices of coefficients, <code class="reqn">j = 1, \ldots, K</code>,
to be estimated.
</p>
<p>The elements of the covariance matrix are intercept&ndash;only
by default.
</p>


<h3>Value</h3>

<p>An object of class <code>"vglmff"</code> 
(see <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>) to be
used by VGLM/VGAM modelling functions, e.g.,
<code><a href="VGAM.html#topic+vglm">vglm</a></code> or <code><a href="VGAM.html#topic+vgam">vgam</a></code>.
</p>


<h3>Author(s)</h3>

<p>Victor Miranda.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MVNcov">MVNcov</a></code>,
<code><a href="VGAM.html#topic+zero">zero</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>,
<code><a href="#topic+ECM.EngleGran">ECM.EngleGran</a></code>,
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20170227)
nn &lt;- 60
var.data &lt;- data.frame(x2 = runif(nn, -2.5, 2.5))
var.data &lt;- transform(var.data, y1 = rnorm(nn, 1.5 - 2 * x2, sqrt(exp(1.5))),
                                y2 = rnorm(nn, 1.0 - 1 * x2, sqrt(exp(0.75))),
                                y3 = rnorm(nn, 0.5 + 1 * x2, sqrt(exp(1.0))))

fit.var &lt;- vglm(cbind(y1, y2, y3) ~ x2, VARff(VAR.order = 2),
                trace = TRUE, data = var.data)
coef(fit.var, matrix = TRUE)

summary(fit.var)
vcov(fit.var)
</code></pre>

<hr>
<h2 id='vgltsmff'>Class of Vector Generalized Linear Time Series Models</h2><span id='topic+vgltsff-class'></span><span id='topic+vgtsff-class'></span><span id='topic+vgltsmff-class'></span><span id='topic+ARMAvgltsmff'></span>

<h3>Description</h3>

<p> Time series family functions for the <span class="pkg">VGAMextra</span> package</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calling 
<code>new("vgltsmff"...)</code>
</p>


<h3>slots</h3>

<p>Implementation of vector generalized linear time series (TS) family 
functions (<em>vgltsff</em>) at <span class="pkg">VGAMextra</span> is entirely based on 
the structure of family functions of the class 
<code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>.
</p>
<p>Hence, refer to <code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code> for a 
thourugh description of slots and features involved when objects 
of class <code>"vgtsff"</code> are being created.
</p>


<h3>Methods</h3>

<p>Thus far, the following methods for objects of class
<code>"vgltsff-class"</code> are implemented:
</p>

<dl>
<dt><code>summary</code></dt><dd>
<p>Additional information to that displayed by the <code>summary</code>
methods from <span class="pkg">VGAM</span>. That is: 
</p>
<p>a) Standard errors  based on the MLEs asymptotic distributions, and
</p>
<p>b) Checks on stationarity and/or invertibility via the polynomial roots.
</p>
<p>Currently, summary methods at <span class="pkg">VGAMextra</span> have been 
implemented for:
</p>

<dl>
<dt><code>signature(VGAMff = "ARff")</code>:</dt><dd>
<p>For ARX&ndash;types family functions.</p>
</dd>
<dt><code>signature(VGAMff = "MAff")</code>:</dt><dd>  
<p>For MAX&ndash;types  family functions.</p>
</dd>
<dt><code>signature(VGAMff = "ARMAff")</code>:</dt><dd>  
<p>For ARMAX&ndash;like family functions.</p>
</dd>
</dl>

</dd>
</dl>
<p>See 
<code><a href="#topic+summaryS4VGAMextra">summaryS4VGAMextra</a></code>
for further details.

</p>


<h3>Note</h3>

<p>Programmers to write VGAM/VGLM time series family functions are also
allowed to write methods functions either for specific purposes, or to 
extend those current methods to print some extra output required.
</p>
<p>In such cases, notice that the class <code>vgltsff-class</code> is 
<em>labeled</em> by an object of class <code>"character"</code> 
(a character vector) specified at the slot
<code>@vfamily</code> within the family function. This is, in fact, 
one of the required slots by the class 
<code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>.
</p>
<p>Additionally, practitioners are encouraged to mantain all previous 
conventions for naming the arguments in Ts family functions
as specified at
<code><a href="VGAM.html#topic+vglmff-class">vglmff-class</a></code>, e.g., 
<code>link</code> is the argument for parameter link functions, etc.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T.W. Yee.
</p>

<hr>
<h2 id='weibullMlink'>
Link functions for the mean of 2&ndash;parameter 
continuous distributions: The Weibull distribution.
</h2><span id='topic+weibullMlink'></span>

<h3>Description</h3>


<p>Computes the <code>weibullMlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>       weibullMlink(theta, shape = NULL, wrt.param = NULL,
                    bvalue = NULL, inverse = FALSE,
                    deriv = 0, short = TRUE, tag = FALSE)
                       
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weibullMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code>
('scale' parameter) but it may 
be <code class="reqn">\eta</code> depending on the other parameters.
See below for further details.
</p>
</td></tr>
<tr><td><code id="weibullMlink_+3A_shape">shape</code></td>
<td>

<p>The shape parameter. Required for this link to work.
See
<code><a href="#topic+weibullRff">weibullRff</a></code>.
</p>
</td></tr>
<tr><td><code id="weibullMlink_+3A_wrt.param">wrt.param</code></td>
<td>

<p>Positive integer, either <code class="reqn">1</code> or <code class="reqn">2</code>. The partial derivatives
are computed with respect to one of the two linear predictors 
involved with this link. Further details listed below.
</p>
</td></tr>
<tr><td><code id="weibullMlink_+3A_bvalue">bvalue</code>, <code id="weibullMlink_+3A_inverse">inverse</code>, <code id="weibullMlink_+3A_deriv">deriv</code>, <code id="weibullMlink_+3A_short">short</code>, <code id="weibullMlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the link for the mean of 
the 2&ndash;parameter Weibull distribution, also known as the
<code>weibullMlink</code> transformation.
It can only be used within
<code><a href="#topic+weibullRff">weibullRff</a></code>
and is defined as





</p>
<p style="text-align: center;"><code class="reqn"> \tt{weibullMlink}(\beta; \alpha) = \eta(\beta; \alpha) = 
                \log [\beta \cdot \Gamma (1 + 1/\alpha)],</code>
</p>


<p>for <em>given</em> <code class="reqn">\alpha</code> ('shape' parameter) where
<code class="reqn">\beta &gt; 0</code> is the <em>scale</em> parameter.


<code>weibullMlink</code> is expressly a function of <code class="reqn">\beta</code>, i.e.
<code class="reqn">\theta</code>, therefore <code class="reqn">\alpha</code> (<em>shape</em>)
must be entered at every call.
</p>
<p>Numerical values of <code class="reqn">\alpha</code> or <code class="reqn">\beta</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>weibmeanlnik</code> transformation of
<code>theta</code>, i.e., <code class="reqn">\beta</code>, when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then <code class="reqn">\theta</code> becomes <code class="reqn">\eta</code>,
and the inverse, 
<code class="reqn">\exp\left( theta - \log \Gamma(1 + 1/ \alpha)\right),</code>
<em>for given</em> <code class="reqn">\alpha</code>, is
returned.
</p>
<p>When <code>deriv = 1</code> <code>theta</code> becomes 
<code class="reqn">\theta = (\beta, \alpha)= (\theta_1, \theta_2)</code>, and
<code class="reqn">\eta = (\eta_1, \eta_2)</code> with 
<code class="reqn">\eta_2 = \log~\alpha</code>,
and the argument <code>wrt.param</code> must be
considered:
</p>
<p>A) If <code>inverse = FALSE</code>, then 
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code class="reqn">\beta</code> is returned when 
<code>wrt.param = 1</code>, and
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code class="reqn">\alpha</code> if
<code>wrt.param = 2</code>.
</p>
<p>B) For <code>inverse = TRUE</code>, this function returns
<code class="reqn">d</code> <code class="reqn">\beta</code> / <code class="reqn">d</code> <code>eta1</code> and
<code class="reqn">d</code> <code class="reqn">\alpha</code> / <code class="reqn">d</code> <code>eta1</code> conformably arranged
in a matrix, if <code>wrt.param = 1</code>,
as a function of <code class="reqn">\theta_i</code>, <code class="reqn">i = 1, 2</code>.
When <code>wrt.param = 2</code>, a matrix with columns
<code class="reqn">d\beta</code> / <code class="reqn">d</code> <code>eta2</code> and 
<code class="reqn">d\alpha</code> / <code class="reqn">d</code> <code>eta2</code>
is returned.  











</p>
<p>For <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are likewise returned.
</p>






<h3>Note</h3>

<p>Numerical instability may occur for values <code>theta</code> too close
to zero. Use argument <code>bvalue</code> to replace them before
computing the link.
</p>
<p>If <code>theta</code> is character, then arguments <code>inverse</code> and
<code>deriv</code> are ignored. See <code><a href="VGAM.html#topic+Links">Links</a></code>
for further details.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weibullQlink">weibullQlink</a></code>,
<code><a href="#topic+weibullRff">weibullRff</a></code>,
<code><a href="VGAM.html#topic+weibullR">weibullR</a></code>,
<code><a href="base.html#topic+lgamma">lgamma</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>    eta &lt;- seq(-3, 3, by = 0.1) # this is eta = log(mu(b, a)).
    shape  &lt;- exp(1)    # 'shape' argument.
 
 ## E1. Get 'scale' values with A WARNING (not the same length)!
   theta &lt;- weibullMlink(theta = eta, shape = shape, inverse = TRUE)  # Scale
   
 ## Not run: 
 ## E2. Plot theta vs. eta, 'shape' fixed.
 plot(theta, eta, type = "l", ylab = "", col = "blue",
      main = paste0("weibullMlink(theta; shape = ",
                    round(shape, 3), ")"))
  abline(h = -3:3, v = 0, col = "gray", lty = "dashed")
 
## End(Not run)
 
 ## E3. weibullMlink() and its inverse ##
    etabis  &lt;- weibullMlink(theta = theta, shape = shape, inverse = FALSE)
    summary(eta - etabis)     # Should be 0
</code></pre>

<hr>
<h2 id='weibullQlink'>
Weibull Quantile regression:
Link function for the quantiles of the Weibull distribution.
</h2><span id='topic+weibullQlink'></span>

<h3>Description</h3>


<p>Computes the <code>weibullQlink</code> transformation, its inverse and
the first two derivatives.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>       weibullQlink(theta, percentile = stop("Enter percentiles."),
                    shape = NULL, wrt.param = NULL,
                    bvalue = NULL, inverse = FALSE,
                    deriv = 0, short = TRUE, tag = FALSE)
                       
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weibullQlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. Same as
<code><a href="#topic+uninormalQlink">uninormalQlink</a></code>
</p>
</td></tr>
<tr><td><code id="weibullQlink_+3A_percentile">percentile</code></td>
<td>

<p>Same as <code><a href="#topic+uninormalQlink">uninormalQlink</a></code>.
Denoted below as <code>perc</code>.
</p>
</td></tr>
<tr><td><code id="weibullQlink_+3A_shape">shape</code></td>
<td>

<p>Numeric, positive. The shape parameter, required. 
</p>
</td></tr>
<tr><td><code id="weibullQlink_+3A_wrt.param">wrt.param</code></td>
<td>

<p>Same as in <code><a href="#topic+uninormalQlink">uninormalQlink</a></code> 



</p>
</td></tr>
<tr><td><code id="weibullQlink_+3A_bvalue">bvalue</code>, <code id="weibullQlink_+3A_inverse">inverse</code>, <code id="weibullQlink_+3A_deriv">deriv</code>, <code id="weibullQlink_+3A_short">short</code>, <code id="weibullQlink_+3A_tag">tag</code></td>
<td>

<p>See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ordinary 
scale&ndash;shape Weibull quantiles are directly modelled by this link,
aka <code>weibullQlink</code> transformation.
It can only be used within
<code><a href="#topic+weibullRff">weibullRff</a></code>
as the first linear predictor, <code class="reqn">\eta_1</code>,
and is defined as





</p>
<p style="text-align: center;"><code class="reqn"> \tt{weibullQlink}(\beta; \alpha) = \eta_1(\beta; \alpha) = 
                \log \{\beta \cdot [(-\log(1 - perc))^{(1/\alpha)}]\},</code>
</p>


<p>for <em>given</em> <code class="reqn">\alpha</code> ('shape' parameter) where
<code class="reqn">\beta &gt; 0</code> is the <em>scale</em> parameter.


<code>weibullQlink</code> is expressly a function of <code class="reqn">\beta</code>, i.e.
<code class="reqn">\theta</code>, therefore <code class="reqn">\alpha</code> (<em>shape</em>)
must be entered at every call.
</p>
<p>Numerical values of <code class="reqn">\alpha</code> or <code class="reqn">\beta</code> out of range may 
result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>weibullQlink</code> transformation of
<code>theta</code>, i.e. <code class="reqn">\beta</code>, when <code>inverse = FALSE</code>.
If <code>inverse = TRUE</code>, then <code class="reqn">\theta</code> becomes <code class="reqn">\eta</code>,
and the inverse, <code>exp[theta</code> - 
<code class="reqn">(1 / \alpha) log(-log(1 - perc))</code><code>]</code>,
<em>for given</em> <code class="reqn">\alpha</code>, is
returned.
</p>
<p>When <code>deriv = 1</code> <code>theta</code> becomes 
<code class="reqn">\theta = (\beta, \alpha)= (\theta_1, \theta_2)</code>, and
<code class="reqn">\eta = (\eta_1, \eta_2)</code> with 
<code class="reqn">\eta_2 = \log~\alpha</code>,
and the argument <code>wrt.param</code> must be
considered:
</p>
<p>A) If <code>inverse = FALSE</code>, then 
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code class="reqn">\beta</code> is returned when 
<code>wrt.param = 1</code>, and
<code class="reqn">d</code> <code>eta1</code> / <code class="reqn">d</code> <code class="reqn">\alpha</code> if
<code>wrt.param = 2</code>.
</p>
<p>B) For <code>inverse = TRUE</code>, this link returns
<code class="reqn">d</code> <code class="reqn">\beta</code> / <code class="reqn">d</code> <code>eta1</code> and
<code class="reqn">d</code> <code class="reqn">\alpha</code> / <code class="reqn">d</code> <code>eta1</code> conformably arranged
in a matrix, if <code>wrt.param = 1</code>,
as a function of <code class="reqn">\theta_i</code>, <code class="reqn">i = 1, 2</code>.
When <code>wrt.param = 2</code>, a matrix with columns
<code class="reqn">d\beta</code> / <code class="reqn">d</code> <code>eta2</code> and 
<code class="reqn">d\alpha</code> / <code class="reqn">d</code> <code>eta2</code>
is returned.  











</p>
<p>For <code>deriv = 2</code>, the second derivatives in
terms of <code>theta</code> are similarly returned.
</p>






<h3>Note</h3>

<p>See <code><a href="#topic+weibullMlink">weibullMlink</a></code>.




</p>





<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Miranda &amp; Yee (2021) 
<em>Two&ndash;Parameter Link Functions,
With Application to Negative Binomial, Weibull and
Quantile Regression</em>. In preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weibullRff">weibullRff</a></code>,
<code><a href="#topic+Q.reg">Q.reg</a></code>,
<code><a href="VGAM.html#topic+weibullR">weibullR</a></code>,
<code><a href="VGAM.html#topic+weibullR">weibmeanlink</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    eta &lt;- seq(-3, 3, by = 0.1) # this is eta = log(Weibull-quantiles).
    shape  &lt;- exp(1)    # 'shape' argument.
    percentile &lt;- c(25, 50, 75, 95)  # some percentiles of interest.
 
 ## E1. Get 'scale' values. Gives a warning (not of the same length) !
   theta &lt;- weibullQlink(theta = eta, percentile = percentile,
                         shape = shape, inverse = TRUE)  # Scale
   
 ## Not run: 
 ## E2. Plot theta vs. eta, 'shape' fixed, for different percentiles.
plot(theta[, 1], eta, type = "l", lwd = 3,
     ylim = c(-4, 4), 
     main = paste0("weibullQlink(theta; shape = ", round(shape, 3), ")"), 
     xlab = "Theta (scale)", ylab = "weibullQlink")
abline(h = -3:3, v = 0, col = "gray", lty = "dashed")
lines(theta[, 2], eta, lwd = 3, col = "blue")
lines(theta[, 3], eta, lwd = 3, col = "orange")
lines(theta[, 4], eta, lwd = 3, col = "red")
legend("bottomright", c("25th Perc", "50th Perc", "75th Perc", "95th Perc"),
      col = c("black", "blue", "orange", "red"),
      lwd = rep(3, 4))
 
## End(Not run)
 
 ## E3. weibullQlink() and its inverse ##
    etabis  &lt;- weibullQlink(theta = theta, percentile = percentile,
                            shape = shape, inverse = FALSE)
    summary(eta - etabis)     # Should be 0 for each colum (percentile)
</code></pre>

<hr>
<h2 id='weibullRff'>
Distribution&ndash;specified quantile regression: 
2&ndash;parameter Weibull Distribution
</h2><span id='topic+weibullRff'></span>

<h3>Description</h3>


<p>Estimates the 2&ndash;parameter Weibull distribution by maximum likelihood.
An extension of <code>weibullR</code> from <span class="pkg">VGAM</span>.
Weibull quantile regression and Weibull&ndash;mean
modelling are also handled via the first
linear predictor.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
     weibullRff(link1 = c("loglink", "weibullMlink", "weibullQlink")[1],
                lshape = "loglink", percentile = 50,
                imu = NULL, iscale = NULL, ishape = NULL,
                lss = TRUE, nrfs = 1, probs.y = c(0.2, 0.5, 0.8),
                imethod = 1, zero = "shape")
             
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weibullRff_+3A_link1">link1</code></td>
<td>

<p>Link function for the first linear predictor. 
Default
is <code>link1 = "loglink"</code>, mimicking 
<code><a href="VGAM.html#topic+weibullR">weibullR</a></code>. The other options
are the 2&ndash;parameter
<code><a href="#topic+weibullQlink">weibullQlink</a></code>, applied
to the Weibull quantile function, and the 2&ndash;parameter
<code><a href="#topic+weibullMlink">weibullMlink</a></code>, applied to 
the Weibull mean function. See below for more details.
</p>
</td></tr>
<tr><td><code id="weibullRff_+3A_percentile">percentile</code></td>
<td>

<p>Numeric. A vector with the percentiles of interest, between 0
and 100.
Used only in Weibull quantile regression, that is,
when <code>link1 = "weibullQlink"</code>.
</p>
</td></tr>
<tr><td><code id="weibullRff_+3A_lshape">lshape</code>, <code id="weibullRff_+3A_imu">imu</code>, <code id="weibullRff_+3A_iscale">iscale</code>, <code id="weibullRff_+3A_ishape">ishape</code>, <code id="weibullRff_+3A_lss">lss</code>, <code id="weibullRff_+3A_nrfs">nrfs</code>, <code id="weibullRff_+3A_probs.y">probs.y</code>, <code id="weibullRff_+3A_imethod">imethod</code></td>
<td>

<p>Same as <code><a href="VGAM.html#topic+weibullR">weibullR</a></code>.
</p>
</td></tr>
<tr><td><code id="weibullRff_+3A_zero">zero</code></td>
<td>

<p>Specifies the parameters to be modelled as intercept&ndash;only.
Further details below.
</p>
<p>See <code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.
</p>
</td></tr>












</table>


<h3>Details</h3>

<p><code>weibullRff</code> is a modified version of
<code><a href="VGAM.html#topic+weibullR">weibullR</a></code> adapted to handle
<code><a href="#topic+weibullQlink">weibullQlink</a></code>
and <code><a href="#topic+weibullMlink">weibullMlink</a></code>,
two 2-parameter linear predictors that model
the Weibull mean and quantiles respectively.


The underlying density is the ordinary 
<code>scale</code>(<code class="reqn">\beta</code>) &amp; <code>shape</code>(<code class="reqn">\alpha</code>)
Weibull density (see <code><a href="VGAM.html#topic+weibullR">weibullR</a></code>).
</p>
<p>The second linear predictor is always 
<code class="reqn">\eta_2 = \log~\alpha</code>.
The argument <code>link1</code> handles the first linear predictor.
</p>
<p><span class="pkg">** Mimicking <code>weibullR</code> **</span>
</p>
<p>The default is <code>link1 = "loglink"</code>, i.e., 
<code class="reqn">\eta_1 = \log~\beta = \log~scale</code>, and 
<code class="reqn">\eta_2 = \log~\alpha = \log~shape</code>,
as with <code><a href="VGAM.html#topic+weibullR">weibullR</a></code>.
The mean (<code class="reqn">\mu</code>) is returned as the fitted value.
</p>
<p><span class="pkg">** Weibull quantile regression **</span>
</p>
<p>For Weibull quantile regression set <code>link1 = "weibullQlink"</code>
and enter a numeric vector of percentiles of interest
via <code>percentile</code>.  
See examples.
</p>
<p>NOTE: Enter the response using 
<code><a href="#topic+Q.reg">Q.reg</a></code>. See example below.
The Weibull quantiles are returned as the fitted values.
</p>
<p><span class="pkg">** Weibull-mean modelling **</span>
</p>
<p>For Weibull-mean modelling (viz. mean time to failure)
set <code>link1 = "weibullMlink"</code>. 
The mean (<code class="reqn">\mu</code>) is returned as the fitted value.
</p>


















<h3>Value</h3>

<p>An object of class <code>"vglm"</code>.
See <code><a href="VGAM.html#topic+vglm-class">vglm-class</a></code> for full details.
</p>


<h3>Note</h3>



<p>The parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
match the arguments <code class="reqn">shape</code> and <code class="reqn">scale</code> from
<code><a href="stats.html#topic+rweibull">rweibull</a></code>.
</p>
<p>Multiple responses are handled.
</p>
<p>This <b>VGAM</b> family function does not handle censored data.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and Thomas W. Yee.
</p>


<h3>References</h3>

<p>Miranda &amp; Yee (2021) 
<em>Two&ndash;Parameter Link Functions,
With Application to Negative Binomial, Weibull and
Quantile Regression</em>. In preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Q.reg">Q.reg</a></code>,
<code><a href="#topic+weibullQlink">weibullQlink</a></code>,
<code><a href="#topic+weibullMlink">weibullMlink</a></code>,
<code><a href="VGAM.html#topic+weibullR">weibullR</a></code>,
<code><a href="base.html#topic+gamma">gamma</a></code>,

<code><a href="VGAM.html#topic+CommonVGAMffArguments">CommonVGAMffArguments</a></code>.



</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(18121)
nn &lt;- 300
x2 &lt;- sort(runif(nn, 0, 3))  # Predictor/covariate.
bb &lt;- exp(1.1 + 0.2 * x2)    # Scale parameter as function of x2.
aa &lt;- exp(1.0 - 0.35 * x2)     # Shape parameter as function of x2.
mymu &lt;- bb * gamma(1 + 1/aa)  # The Weibull mean.

## Use weibullMlink to generate appropriate scale parameter.
newbb &lt;- weibullMlink(theta = log(mymu), shape = aa, inverse = TRUE, deriv = 0)

## A single random response
wdata &lt;- data.frame(y1 = rweibull(nn, shape = aa, scale = newbb), x2 = x2)

# Plotting the data / Histogram
plot(y1  ~ x2, xlim = c(0, 3.1), ylim = c(-1, 35),
     pch = 20, data = wdata, col = "black", 
     main = "Weibull Quantile regression~ x2")
abline(h = 0, v = 0, col = "grey", lty = "dashed")
with(wdata, hist(y1, col = "red", breaks = 15))

## Weibull regression - percentile = c(25, 50, 75)
## Note the use of Q.reg.
fit1 &lt;- vglm(Q.reg(y1, length.arg = 3) ~ x2, 
             weibullRff(link1 = "weibullQlink", zero = NULL,
                                 percentile = c(25, 50, 75)), 
             trace = TRUE, data = wdata)
head(fitted(fit1))
summary(fit1)
my.coef3Q &lt;- coef(fit1, mat = TRUE)

### Proportion of data below the estimated 25% Quantile line.
100 * (1 - (sum(wdat$y1 &gt;= fitted(fit2)[, 1]) / nn))  # Around 25%
### Proportion of data below the estimated 50% Quantile line.
100 * (1 - (sum(wdat$y1 &gt;= fitted(fit2)[, 2]) / nn))   # Around 50%
### Proportion of data below the estimated 75% Quantile line.
100 * (1 - ( sum(wdat$y1 &gt;= fitted(fit2)[, 3]) / nn ))   # Around 75%

## The quantile plots ##
my.coef3Q &lt;- coef(fit2, matrix = TRUE)
with(wdat, lines(x2, exp(my.coef3Q[1, 1] + my.coef3Q[2, 1] * x2), 
                    col = "red", lty = "dotted", lwd = 4))
with(wdat, lines(x2, exp(my.coef3Q[1, 3] + my.coef3Q[2, 3] * x2), 
                 col = "orange", lty = "dotted", lwd = 4))
with(wdat, lines(x2, exp(my.coef3Q[1, 5] + my.coef3Q[2, 5] * x2), 
                 col = "blue", lty = "dotted", lwd = 4))

## Adding the 'mean' or expected Weibull regression line.
fit2 &lt;- vglm(y1 ~ x2, 
             weibullRff(link1 = "weibullMlink", zero = NULL), 
             trace = TRUE, data= wdat)
my.coef3Q &lt;- coef(fit2, mat = TRUE)
with(wdat, lines(x2, exp(my.coef3Q[1, 1] + my.coef3Q[2, 1] * x2), 
                 col = "yellow", lty = "dashed", lwd = 3))


legend("topleft", c("25h Perc", "50th Perc", "Mean", "75th Perc"),
       col = c("red", "orange", "cyan", "blue"),
       lty = c("dashed", "dashed", "dashed", "dashed"), lwd = rep(4, 4))
     
## End(Not run)
</code></pre>

<hr>
<h2 id='WN.InitARMA'>Estimated White Noise (WN) from the autoregressive moving-average model
of order-(<code class="reqn">p</code>, <code class="reqn">q</code>) [ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>)].
</h2><span id='topic+WN.InitARMA'></span>

<h3>Description</h3>

<p>Estimates the unobserved white noise of the ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) 
model via the corresponding inverted process.
</p>
<p>Also, provides the initial values of <code><a href="#topic+ARXff">ARXff</a></code>,
<code><a href="#topic+MAXff">MAXff</a></code>, and
<code>ARMAXff</code> family functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     WN.InitARMA(tsData    = NULL, 
                 order     = c(1, 0, 1),
                 whiteN    = FALSE, 
                 moreOrder = 0,
                 updateWN  = FALSE)
              
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WN.InitARMA_+3A_tsdata">tsData</code></td>
<td>

<p>A univariate data frame containing the time series to be fitted according 
to an ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) process. Data must be of class &quot;<code>ts</code>&quot;.
</p>
</td></tr>
<tr><td><code id="WN.InitARMA_+3A_order">order</code></td>
<td>

<p>A vector with three integer components. It is order of the ARMA model to be 
inverted. These entries, <code class="reqn">c(p, d, q)</code>, are the AR order, the 
degree of differencing, and the MA order, respectively.



</p>
</td></tr>
<tr><td><code id="WN.InitARMA_+3A_whiten">whiteN</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then the estimated white noise computed from
the inverted ARMA model is returned. This option is enabled only for 
<code><a href="#topic+MAXff">MAXff</a></code>, <code> ARMAXff </code> family functions.
</p>
</td></tr>
<tr><td><code id="WN.InitARMA_+3A_moreorder">moreOrder</code></td>
<td>

<p>A non-negative integer (might be zero) used to increment the order of 
the AR model initially fitted to estimate the residuals, i.e.,
an AR(<code class="reqn">p</code> + <code>moreOrder</code>) model.
Empirically, values of <code>moreOrder</code> <code class="reqn"> &gt; 2</code> do NOT improve
accuracy of estimates. This assert, however, may vary for different 
time series family functions.




</p>
</td></tr>
<tr><td><code id="WN.InitARMA_+3A_updatewn">updateWN</code></td>
<td>

<p>Logical. if <code>TRUE</code>, the white noise is <em>updated</em> through a 
second regression of <code class="reqn">Y_{t}</code> on 
<code class="reqn">Y_{t -1}, \ldots, Y_{t -p}, \widehat{\varepsilon_{t - 1}}, \ldots,
  \widehat{\varepsilon_{t - q} }</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overall, the autoregressive moving average process of order <code class="reqn">c(p, q)</code>, 
shortly denoted as ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>), with <em>intercept</em> 
<code class="reqn">\mu</code> can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = \mu + \theta_{1} y_{t - 1} + \ldots + \theta_{p} y_{t - p} +
              \phi_1 \varepsilon_{t - 1} + \ldots + 
              \phi_q \varepsilon_{t - q} + \varepsilon_{t}.</code>
</p>

<p>It is well known that it can be expressed in terms of an autoregressive 
process of infinite order, AR(<code class="reqn">\infty</code>), by
recursive substitutions. For instance, given a mean-zero ARMA(1, 1),
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = \theta_1 y_{t - 1} +  \phi_1 \varepsilon_{t - 1} + 
               \varepsilon_{t},
               \quad \quad (1) </code>
</p>

<p>one may express
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{t - 1} = Y_{t - 1} - ( \theta_{1} y_{t - 2} + 
                          \phi_{1} \varepsilon_{t - 2} </code>
</p>

<p>Substituting this equation in (1) yields the initial inverted process, 
as follows:
</p>
<p style="text-align: center;"><code class="reqn"> y_{t} = \psi_{1} y_{t - 1} + \psi_{2} y_{t - 2} +
                f(\varepsilon_{t - 2}, \varepsilon_{t} ). </code>
</p>

<p>where <code class="reqn">f</code> is a function of <code class="reqn">\varepsilon_{t - 2}</code> and
<code class="reqn">\varepsilon_{t}</code>.
</p>
<p>Repeated substitutions as above produces the so-called <em>inverted
process</em>,
</p>
<p style="text-align: center;"><code class="reqn"> y_{t} = \sum_{k = 1}^{\infty} \psi_{k} y_{t - k} + 
               \varepsilon_{t}. \quad \quad (2) </code>
</p>

<p><code class="reqn"> k = 1, \ldots, \infty</code>.
Hence, setting an acceptable order (via the <code>moreOrder</code> 
argument, <code class="reqn">1</code> or <code class="reqn">2</code> for instance), an 
AR(<code class="reqn">p</code> + <code>moreOrd</code>) 
<em>inverted</em> model is internally fitted 
within <code>WN.InitARMA</code>. Consequently, the unobserved white noise,
<code class="reqn"> \{ \varepsilon_{t} \} </code>, is estimated by computing 
the <em>residuals</em> in (2), after regression. 
<code>whiteN = TRUE</code> enables this option.
</p>
<p>Finally, initial values of the <code><a href="#topic+MAXff">MAXff</a></code>, and 
<code>ARMAXff</code> family functions can be computed by least squares from 
the estimated white noise above, <code class="reqn"> \{ \varepsilon_{t} \} </code> 
and the given data, <code class="reqn"> \{ t_{t} \} </code>. 
</p>
<p>Initial values of <code><a href="#topic+ARXff">ARXff</a></code> 
are also internally computed using <code class="reqn"> \{ t_{t} \} </code> only.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>Coeff</code></td>
<td>
<p>The initial values of the VGLM/VGAM family function in turn:
<code><a href="#topic+ARXff">ARXff</a></code>, <code><a href="#topic+MAXff">MAXff</a></code>,
or <code>ARMAXff</code>.</p>
</td></tr>
<tr><td><code>whiteN</code></td>
<td>
<p>(Optional) Estimated white noise enabled only for 
<code><a href="#topic+MAXff">MAXff</a></code>, <code> ARMAXff </code>.
That sequence is returned if <code>whiteN = TRUE</code>.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>For some time series family functions, 
<code><a href="#topic+MAXff">MAXff</a></code> for instance, values of 
<code>moreOrder</code> <code class="reqn"> &gt; 3</code> do NOT improve
the accuracy of estimates, and may lead the algorithm to failure to
converge. 
</p>


<h3>Author(s)</h3>

<p>Victor Miranda and T. W. Yee.
</p>


<h3>References</h3>

<p>Brockwell, P. and Davis, R. (2002) 
<em>Introduction to Time Series and Forecasting</em>. 
Springer, New York, USA.
</p>
<p>Durbin, J. (1959) 
Efficient Estimation of Parameters in Moving-Average Models. 
<em>Biometrika</em>, <b>46</b>, pp 306&ndash;316.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAXff">MAXff</a></code>, 
<code><a href="#topic+ARMAXff">ARMAXff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating some data -&gt; an MA(3) 
set.seed(1004)
mydata &lt;- arima.sim( n = 200, list(ma = c(0.3, 0.56 , 0.11)) )

# Computing initial values to be passed to MAXff()
WN.InitARMA(tsData = data.frame(y = mydata), 
            order = c(0, 0, 3), 
            moreOrder = 1)

# Returning initial values and white noise.
initMA &lt;- WN.InitARMA(tsData = data.frame(y = mydata), 
                      order = c(0, 0, 3), 
                      moreOrder = 1, 
                      whiteN = TRUE) 
                      
# Initial values passed to MAXff()
initMA$Coeff

# Estimated white noise
head(initMA$WhiteNoise)
                      
</code></pre>

<hr>
<h2 id='yulesimonMlink'>
Link functions for the mean of 1&ndash;parameter 
discrete distributions: The Yule&ndash;Simon Distribution.
</h2><span id='topic+yulesimonMlink'></span><span id='topic+yulesimonMeanlink'></span>

<h3>Description</h3>

<p>Computes the <code>yulesimonMlink</code> transformation, its inverse
and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> yulesimonMlink(theta, bvalue = NULL, inverse = FALSE, 
                deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yulesimonMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> by default,
or <code class="reqn">\eta</code> depending upon other arguments. 
See <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
<tr><td><code id="yulesimonMlink_+3A_bvalue">bvalue</code>, <code id="yulesimonMlink_+3A_inverse">inverse</code>, <code id="yulesimonMlink_+3A_deriv">deriv</code>, <code id="yulesimonMlink_+3A_short">short</code>, <code id="yulesimonMlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume <code class="reqn">Y \sim {\rm{Yule-Simon}}(\rho) </code>, 
where <code class="reqn">\rho</code> is a shape parameter as in
<code><a href="VGAM.html#topic+yulesimon">yulesimon</a></code>.
Then, the mean of <code class="reqn">Y</code> 
is given by

</p>
<p style="text-align: center;"><code class="reqn">\mu = \frac{\rho}{\rho - 1} = (1 - \rho^{-1})^{-1},
  </code>
</p>


<p>provided <code class="reqn"> \rho &gt; 1 </code>.
</p>
<p>This link function may be conceived as a natural link function 
for the mean of the Yule&ndash;Simon distribution which comes up by 
taking the logarithm on both sides of this equation. More precisely, 
the <code>yulesimonMlink</code> tranformation for <code class="reqn">\rho &gt; 1</code>
is given by

</p>
<p style="text-align: center;"><code class="reqn"> {\tt{yulesimonMlink}}(\rho) = - \log (1 - \rho^{-1}).</code>
</p>


<p>While this link function can be used to model any parameter lying in 
<code class="reqn">(1, \infty)</code>, it is particularly useful for event-rate data where
the mean, <code class="reqn">\mu</code>, can be written in terms of some rate of events,
say <code class="reqn">\lambda</code>, and the timeframe observed <code class="reqn">t</code>. 
Specifically,

</p>
<p style="text-align: center;"><code class="reqn">\mu = \lambda t.</code>
</p>


<p>Assuming that additional covariates might be available to linearly 
model <code class="reqn">\lambda</code> (or <code class="reqn">\log \lambda</code>), 
this model can be treated as a VGLM with one parameter where
the time <code class="reqn">t</code> (as <code class="reqn">\log t</code>) can be easily incorporated 
in the analysis as an offset.
</p>
<p>Under this link function the domain set for <code class="reqn">\rho</code> 
is <code class="reqn">(1, \infty)</code>. Hence, values of <code class="reqn">\rho</code> too 
close to <code class="reqn">1</code> from the right, or out of range will result 
in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or <code>NaN</code>. 
Use argument <code>bvalue</code> to adequately replace them before 
computing the link function.



</p>
<p>Unlike <code><a href="#topic+logffMlink">logffMlink</a></code> or
<code><a href="#topic+zetaffMlink">zetaffMlink</a></code>, the inverse of
this link function can be written in close form.
</p>
<p>If <code>theta</code> is a character, arguments <code>inverse</code> and 
<code>deriv</code> are disregarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>yulesimonMlink</code> transformation of
<code>theta</code> when <code>inverse = FALSE</code>, and if 
<code>inverse = TRUE</code> then 
<code>exp(theta) / (exp(theta) - 1)</code>.
</p>
<p>For <code>deriv = 1</code>, <em>d</em> <code>eta</code> / <em>d</em> <code>theta</code> 
as a function of <code>theta</code> if <code>inverse = FALSE</code>, else 
the reciprocal <em>d</em> <code>theta</code> / <em>d</em> <code>eta</code>.
</p>
<p>For <code>deriv = 2</code> the second order derivatives 
are correspondingly returned.
</p>


<h3>Warning</h3>

<p>Conforming with <code><a href="VGAM.html#topic+yulesimon">yulesimon</a></code>, the domain 
set for <code class="reqn">rho</code> is <code class="reqn">(0, \infty)</code>. However, in order for 
<code>yulesimonMlink</code> to be a real number, <code class="reqn">rho</code> must be greater 
then 1.0. Then, when a VGLM is fitted via 
<code><a href="VGAM.html#topic+yulesimon">yulesimon</a></code> using this link function, 
numerical instability will occur if the estimated or the true value of
<code class="reqn">rho</code> lies between 0 and 1, or if the initial values for <code class="reqn">rho</code> 
generated by
<code><a href="VGAM.html#topic+yulesimon">yulesimon</a></code> fail to meet
<code class="reqn">rho &gt; 1</code>. Alternatively, try 
<code><a href="#topic+posPoiMlink">posPoiMlink</a></code> or
<code><a href="VGAM.html#topic+loglink">loglink</a></code> if this happens.
</p>


<h3>Note</h3>

<p>If the underlying assumption <code class="reqn">\rho &gt; 1</code> is not met,
then this function returns <code>NaN</code>. 
This is equivalent to claim that the mean is infinite or negative 
and, consequently, its logarithm will not be real.
</p>
<p>The vertical line <code>theta = 1</code> is an asymptote for this link 
function. As a result, it may return <code>Inf</code> for values of 
<code class="reqn">\rho</code> too close to <code class="reqn">1</code> from the right.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+yulesimon">yulesimon</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>, 
<code><a href="#topic+posPoiMlink">posPoiMlink</a></code>,
<code><a href="VGAM.html#topic+loglink">loglink</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1  ##
Shapes &lt;- 1:10 
yulesimonMlink(theta = Shapes, deriv = 1)  ## d eta/d theta, as function of theta

yulesl.inv &lt;- 
    # The inverse  minus actual values
    yulesimonMlink(theta = yulesimonMlink(theta = Shapes),  inverse = TRUE) - Shapes
                      
summary(yulesl.inv)     ## zero


## Example 2. Special values of theta (rho) ##
rhos &lt;- c(-Inf, -2, -1, 0.0, 0.5, 1, 5, 10, 100, Inf, NaN, NA) 
rbind(rho = rhos, 
      yuleslink  = yulesimonMlink(theta = rhos),
      inv.yulesl =yulesimonMlink(theta = rhos, inverse = TRUE))


## Example 3 The yulesimonMlink transformation and the first two derivatives ##

rhos &lt;- seq(1, 20, by = 0.01)[-1]
y.rhos &lt;- yulesimonMlink(theta = rhos, deriv = 0)
der.1  &lt;- yulesimonMlink(theta = rhos, deriv = 1)
der.2  &lt;- yulesimonMlink(theta = rhos, deriv = 2)

plot(y.rhos ~ rhos, col = "black", 
     main = "log(mu), mu = E[Y], Y ~ Yule-Simon(rho).",
     ylim = c(-5, 10), xlim = c(-1, 5), lty = 1, type = "l", lwd = 3)
abline(v = 1.0, col = "orange", lty = 2, lwd = 3)
abline(v = 0, h = 0, col = "gray50", lty = "dashed")

lines(rhos, der.1, col = "blue", lty = 5)
lines(rhos, der.2, col = "chocolate", lty = 4)
legend(2, 7, legend = c("yulesimonMlink", "deriv = 1", "deriv = 2"),
       col = c("black", "blue", "chocolate"), lty = c(1, 5, 4))
 
</code></pre>

<hr>
<h2 id='zetaffMlink'>
Link functions for the mean of 1&ndash;parameter 
discrete distributions: The Zeta Distribution.
</h2><span id='topic+zetaffMlink'></span><span id='topic+zetaffMeanlink'></span><span id='topic+zetafflink.inv.deriv0'></span>

<h3>Description</h3>

<p>Computes the <code>zetaffMlink</code> transformation, including its inverse
and the first two derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  zetaffMlink(theta, bvalue = NULL, 
              alg.roots = c("Newton-Raphson", "bisection")[1],
              inverse = FALSE, deriv = 0, short = TRUE, tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zetaffMlink_+3A_theta">theta</code></td>
<td>

<p>Numeric or character. This is <code class="reqn">\theta</code> by default, although
it can be <code class="reqn">\eta</code> sometimes, depending on the other parameters. 
See below for further details.
</p>
</td></tr>
<tr><td><code id="zetaffMlink_+3A_bvalue">bvalue</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>
</td></tr>
<tr><td><code id="zetaffMlink_+3A_alg.roots">alg.roots</code></td>
<td>

<p>Character. The iterative method to find the inverse of this link
function. Default is Newton&ndash;Raphson. Optionally, the bisection 
method is also available.
</p>
</td></tr>
<tr><td><code id="zetaffMlink_+3A_inverse">inverse</code>, <code id="zetaffMlink_+3A_deriv">deriv</code>, <code id="zetaffMlink_+3A_short">short</code>, <code id="zetaffMlink_+3A_tag">tag</code></td>
<td>

<p>Details at <code><a href="VGAM.html#topic+Links">Links</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a link function for the zeta distribution,
<code><a href="VGAM.html#topic+zetaff">zetaff</a></code>, which emerges by applying 
the logarithm transformation to its mean. Specifically, 
assume <code class="reqn">Y</code> follows a zeta distribution with shape parameter 
<code class="reqn">s</code> (this is <code>theta</code> in the VGLM/VGAM framework). 
Then, the mean of <code class="reqn">Y</code> is 

</p>
<p style="text-align: center;"><code class="reqn"> \mu = \frac{\zeta (s)}{\zeta (s + 1)}, </code>
</p>


<p>provided <code class="reqn">s &gt; 1</code>, where <code class="reqn">\zeta</code> is the Riemann's zeta
function computed by <code><a href="VGAM.html#topic+zeta">zeta</a></code>. The notation 
adopted here conforms with <code><a href="VGAM.html#topic+zetaff">zetaff</a></code>
in terms of the density of the zeta distribution.
</p>
<p>The <code>zetaffMlink</code> transformation is given by

</p>
<p style="text-align: center;"><code class="reqn">\eta = \tt{zetaffMlink}(s) = \log \frac{\zeta (s)}{\zeta (s + 1)}.</code>
</p>


<p>It is particularly useful when modelling event&ndash;rate data where 
the expected number of events, <code class="reqn">\mu</code>, can be modelled as

</p>
<p style="text-align: center;"><code class="reqn">\mu = \lambda t.</code>
</p>


<p>Specifically, <code class="reqn">\lambda</code> is a standardized mean per unit&ndash;time, and 
<code class="reqn">t</code> is the observed timeframe.
</p>
<p>The domain set for <code class="reqn">s</code>, i.e. <code class="reqn">\theta</code>, is 
<code class="reqn">(1, \infty)</code>. Hence, either large values of 
<code class="reqn">s</code>, or those too close to <code class="reqn">1</code> from the right, or out of 
range will result in <code>Inf</code>, <code>-Inf</code>, <code>NA</code> or 
<code>NaN</code>. Use argument <code>bvalue</code> to adequately replace 
them before computing the link function.

</p>
<p>WARNING: While in <code><a href="VGAM.html#topic+zetaff">zetaff</a></code> the parameter 
<code class="reqn">s</code> lies in <code class="reqn">(1, \infty)</code>, 
<code>zetaffMlink</code> will be real when <code class="reqn">s &gt; 1</code>. Consequently, 
for any VGLM fitted via <code><a href="VGAM.html#topic+zetaff">zetaff</a></code> using this 
link function, numerical problems will take place if any 
<code class="reqn">s</code> value lies between 0.0 and 1.0 at any iteration. Use 
optional link functions like <code><a href="VGAM.html#topic+loglink">loglink</a></code>.
</p>
<p>When <code>inverse = TRUE</code> and <code>deriv = 0</code>,
<code class="reqn">s</code> changes into <code class="reqn">\eta</code>, and therefore the domain set 
(only in this case) turns into <code class="reqn">(0, \infty)</code>.
See below for further details.
</p>
<p>If <code>theta</code> is a character, arguments <code>inverse</code> and
<code>deriv</code> are disregarded.
</p>


<h3>Value</h3>

<p>For <code>deriv = 0</code>, the <code>zetaffMlink</code> transformation of 
<code>theta</code>, if <code>inverse = FALSE</code>. When <code>inverse = TRUE</code>,
<code>theta</code> becomes <code class="reqn">\eta</code>, and then the inverse of <code>zetaffMlink</code>
is required. However, it cannot be written in closed&ndash;form. Instead,
the inverse image of <code class="reqn">\eta</code>, say <code class="reqn">\theta_\eta</code>, 
is returned. That is, a unique vector <code class="reqn">\theta_\eta</code> 
such that 

</p>
<p style="text-align: center;"><code class="reqn"> {\tt{zetaffMlink}} (\theta_\eta) = \eta.</code>
</p>


<p>This process is equivalent to find the root, 
<code class="reqn">\theta_\eta</code>, of the function 
<code class="reqn"> {\tt{zetaffMlink}} (\theta) - \eta, </code>
which is internally carried out via the method entered
at <code>alg.roots</code>. Options available are 
&ldquo;<code>Newton-Raphson</code>&rdquo; and &ldquo;<code>bisection</code>&rdquo;.
</p>
<p>For <code>deriv = 1</code>, <em>d</em> <code>eta</code> / <em>d</em> <code>theta</code> 
as a function of <code>theta</code> if <code>inverse = FALSE</code>, else 
the reciprocal <em>d</em> <code>theta</code> / <em>d</em> <code>eta</code>.
</p>
<p>Similarly, when <code>deriv = 2</code> the second order derivatives 
are returned accordingly.
</p>
<p>The first two derivatives of the Riemman's zeta function 
are computed by <code><a href="VGAM.html#topic+zeta">zeta</a></code>.
</p>
<p>Besides, the <code>zetaffMlink</code> function as well as its derivatives
are graphically delimited for specific asymptotes.
Consequently, the mathematical limit of this link function is 
returned for special values of <code>theta</code>, e.g. 
for <code>theta</code> = <code class="reqn">\infty</code>. See example 2 below.
</p>


<h3>Warning</h3>

<p>Where the inverse image of <code class="reqn">\eta</code>, <code class="reqn">\theta_\eta</code>,
is required, values entered at <code>theta</code> (becoming <code class="reqn">\eta</code>) must
be non-negative. The reason is that the <code>zetaffMlink</code>
transformation is decreasing but strictly positive in <code class="reqn">(1, \infty)</code> 
asymptotically approaching to the horizontal axis. In this way, the 
<em>shifted&ndash;down</em> <code>zetaffMlink</code> function

</p>
<p style="text-align: center;"><code class="reqn">{\tt{zetaff.func}}(\theta | \eta) = 
           {\tt{zetaffMlink}}(\theta) - \eta</code>
</p>


<p>uniquely intersects the horizontal axis and hence the inverse image 
computed by &ldquo;<code>Newton-Raphson</code>&rdquo; or &ldquo;<code>bisection</code>&rdquo; 
will be a real
number.
</p>


<h3>Note</h3>

<p>Overall, this link function is useful to model any parameter
lying in <code class="reqn">(1, \infty)</code>, specially if the theoretical mean
can be written as <code class="reqn">\mu = \lambda t</code>, as stated above.
As a result, some problems may arise if there are covariates.
Try another link function if any issue, such 
as <code><a href="VGAM.html#topic+logloglink">logloglink</a></code>.
</p>


<h3>Author(s)</h3>

<p>V. Miranda and T. W. Yee
</p>


<h3>See Also</h3>

<p><code><a href="VGAM.html#topic+zetaff">zetaff</a></code>,
<code><a href="#topic+newtonRaphson.basic">newtonRaphson.basic</a></code>,
<code><a href="VGAM.html#topic+bisection.basic">bisection.basic</a></code>,
<code><a href="VGAM.html#topic+zeta">zeta</a></code>,
<code><a href="VGAM.html#topic+loglink">loglink</a></code>,
<code><a href="VGAM.html#topic+Links">Links</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1  ##
Shapes &lt;- 1:10 + 0.1 
zetaffMlink(theta = Shapes, deriv = 1)  ## d eta/d theta, as function of theta

zetafflk.inv &lt;- zetaffMlink(theta = zetaffMlink(theta = Shapes), inverse = TRUE) - Shapes
 
summary(zetafflk.inv)                      ## Should be zero


## Example 2. Special values of theta, inverse = FALSE ##
Shapes &lt;- c(-Inf, -1, 0.5, 1, 1.5, 10, 100, Inf, NaN, NA) 
print(rbind(Shapes, zetaffMlink  = zetaffMlink(theta = Shapes),
            inv.zfflink = zetaffMlink(theta = Shapes, inverse = TRUE)), digits = 3)


## Example 3. Plot of 'zetaffMlink()' and its first two derivatives ##
## inverse = FALSE, deriv = 0, 1, 2 ##

Shapes &lt;- seq(1, 20, by = 0.01)[-1]
y.shapes &lt;- zetaffMlink(theta = Shapes, deriv = 0)
der.1 &lt;- zetaffMlink(theta = Shapes, deriv = 1)
der.2 &lt;- zetaffMlink(theta = Shapes, deriv = 2)

plot(y.shapes ~ Shapes, 
     col = "black", main = "log(mu), mu = E[Y], Y ~ Zeta(s).",
     ylim = c(-5, 10), xlim = c(-0.1, 5), lty = 1, type = "l", lwd = 3)
abline(v = 1.0, col = "orange", lty = 2, lwd = 3)
abline(v = 0, h = 0, col = "gray50", lty = "dashed")

lines(Shapes, der.1, col = "blue", lty = 5)
lines(Shapes, der.2, col = "chocolate", lty = 4)
legend(2, 7, legend = c("zetaffMlink", "deriv = 1", "deriv = 2"),
       col = c("black", "blue", "chocolate"), lty = c(1, 5, 4), lwd = c(3, 1, 1))
 

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
