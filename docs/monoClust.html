<!DOCTYPE html><html lang="en"><head><title>Help for package monoClust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {monoClust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#monoClust-package'><p>monoClust: Perform Monothetic Clustering with Extensions to Circular</p>
Data</a></li>
<li><a href='#as_MonoClust'><p>Coerce Similar Object to MonoClust</p></a></li>
<li><a href='#centroid'><p>Find Centroid of the Cluster</p></a></li>
<li><a href='#checkem'><p>First Gate Function</p></a></li>
<li><a href='#circ_arith'><p>Add/Subtract Circular Values in Degrees/Radian</p></a></li>
<li><a href='#circ_dist'><p>Distance Matrix of Circular Variables</p></a></li>
<li><a href='#cluster_stats'><p>Cluster Statistics Calculation</p></a></li>
<li><a href='#create_labels'><p>Create Labels for Split Variables</p></a></li>
<li><a href='#cv.test'><p>Cross-Validation Test on MonoClust</p></a></li>
<li><a href='#error_bar'><p>Make Error Bars</p></a></li>
<li><a href='#find_closest'><p>Find the Closest Cut</p></a></li>
<li><a href='#find_split'><p>Find the Best Split</p></a></li>
<li><a href='#ggcv'><p>GGPlot the Mean Square Error with Error Bar for +/- 1 Standard Error</p></a></li>
<li><a href='#ggpcp'><p>Parallel Coordinates Plot with Circular Variables</p></a></li>
<li><a href='#inertia_calc'><p>Cluster Inertia Calculation</p></a></li>
<li><a href='#is_MonoClust'><p>Test If The Object is A MonoClust</p></a></li>
<li><a href='#make_jump_table'><p>Create Jump Table</p></a></li>
<li><a href='#medoid'><p>Find Medoid of the Cluster</p></a></li>
<li><a href='#MonoClust'><p>Monothetic Clustering</p></a></li>
<li><a href='#MonoClust.object'><p>Monothetic Clustering Tree Object</p></a></li>
<li><a href='#new_node'><p>Create A New Node for Split Data Frame</p></a></li>
<li><a href='#perm.test'><p>Permutation Test on Monothetic Tree</p></a></li>
<li><a href='#plot_prep_branch'><p>Calculate Branch Coordinates</p></a></li>
<li><a href='#plot_prep_node'><p>Calculate Nodes Coordinates</p></a></li>
<li><a href='#plot_tree'><p>Plot the monoClust Tree.</p></a></li>
<li><a href='#plot.cv.MonoClust'><p>Plot the Mean Square Error with Error Bar for +/- 1 Standard Error</p></a></li>
<li><a href='#plot.MonoClust'><p>Plot MonoClust Splitting Rule Tree</p></a></li>
<li><a href='#predict.MonoClust'><p>Predictions from a MonoClust Object</p></a></li>
<li><a href='#print.cv.MonoClust'><p>Print MonoClust Cross-Validation Result</p></a></li>
<li><a href='#print.MonoClust'><p>Print Monothetic Clustering Results</p></a></li>
<li><a href='#splitter'><p>Split Function</p></a></li>
<li><a href='#test_split'><p>Hypothesis Test at Split</p></a></li>
<li><a href='#text_tree'><p>Implementation of Print Labels on MonoClust Tree</p></a></li>
<li><a href='#to_deg_rad'><p>Transform Between Degree and Radian</p></a></li>
<li><a href='#tree_depth'><p>Find Tree Depth Based on Node Indexes</p></a></li>
<li><a href='#tree_walk'><p>Traverse a Tree to Find the Leaves (Terminal Nodes)</p></a></li>
<li><a href='#wind_sensit_2007'><p>Existence of Microorganisms Carried in Wind</p></a></li>
<li><a href='#wind_sensit_2008'><p>Existence of Microorganisms Carried in Wind</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Perform Monothetic Clustering with Extensions to Circular Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Monothetic Clustering
    algorithm (Chavent, 1998 &lt;<a href="https://doi.org/10.1016%2FS0167-8655%2898%2900087-7">doi:10.1016/S0167-8655(98)00087-7</a>&gt;) on
    continuous data sets. A lot of extensions are included in the package,
    including applying Monothetic clustering on data sets with circular
    variables, visualizations with the results, and permutation and
    cross-validation based tests to support the decision on the number of
    clusters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://vinhtantran.github.io/monoClust/">https://vinhtantran.github.io/monoClust/</a>,
<a href="https://github.com/vinhtantran/monoClust">https://github.com/vinhtantran/monoClust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vinhtantran/monoClust/issues">https://github.com/vinhtantran/monoClust/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster (&ge; 2.0.5), doParallel, dplyr (&ge; 1.0.0), foreach,
ggplot2, graphics, grDevices, parallel, permute, purrr (&ge;
0.3.0), rlang (&ge; 0.3.0), stats, stringr (&ge; 0.5), tibble (&ge;
3.0.0), tidyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mice, rmarkdown, covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-15 00:10:00 UTC; vinht</td>
</tr>
<tr>
<td>Author:</td>
<td>Tan Tran <a href="https://orcid.org/0000-0001-9881-6339"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Brian McGuire [aut],
  Mark Greenwood <a href="https://orcid.org/0000-0001-6933-1201"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tan Tran &lt;vinhtantran@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-15 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='monoClust-package'>monoClust: Perform Monothetic Clustering with Extensions to Circular
Data</h2><span id='topic+monoClust'></span><span id='topic+monoClust-package'></span>

<h3>Description</h3>

<p>Implementation of the Monothetic Clustering
algorithm (Chavent, 1998 &lt;doi:10.1016/S0167-8655(98)00087-7&gt;) on
continuous data sets. A lot of extensions are included in the package,
including applying Monothetic clustering on data sets with circular
variables, visualizations with the results, and permutation and
cross-validation based tests to support the decision on the number of
clusters.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tan Tran <a href="mailto:vinhtantran@gmail.com">vinhtantran@gmail.com</a> (<a href="https://orcid.org/0000-0001-9881-6339">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Brian McGuire <a href="mailto:mcguirebc@gmail.com">mcguirebc@gmail.com</a>
</p>
</li>
<li><p> Mark Greenwood <a href="mailto:greenwood@montana.edu">greenwood@montana.edu</a> (<a href="https://orcid.org/0000-0001-6933-1201">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://vinhtantran.github.io/monoClust/">https://vinhtantran.github.io/monoClust/</a>
</p>
</li>
<li> <p><a href="https://github.com/vinhtantran/monoClust">https://github.com/vinhtantran/monoClust</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/vinhtantran/monoClust/issues">https://github.com/vinhtantran/monoClust/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_MonoClust'>Coerce Similar Object to MonoClust</h2><span id='topic+as_MonoClust'></span><span id='topic+as_MonoClust.default'></span>

<h3>Description</h3>

<p>The function turns a MonoClust-similar object into MonoClust object so it
can use supported functions for MonoClust such as <code><a href="#topic+print.MonoClust">print.MonoClust()</a></code> and
<code><a href="#topic+plot.MonoClust">plot.MonoClust()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_MonoClust(x, ...)

## Default S3 method:
as_MonoClust(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_MonoClust_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to MonoClust object.</p>
</td></tr>
<tr><td><code id="as_MonoClust_+3A_...">...</code></td>
<td>
<p>For extensibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_MonoClust()</code> is an S3 generic. The function itself doesn't run unless
it is implemented for another similar object. Currently, this function is not
implemented within <code>monoClust</code> package.
</p>

<hr>
<h2 id='centroid'>Find Centroid of the Cluster</h2><span id='topic+centroid'></span>

<h3>Description</h3>

<p>Centroid is point whose coordinates are the means of their cluster values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(data, frame, cloc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centroid_+3A_data">data</code></td>
<td>
<p>Original data set.</p>
</td></tr>
<tr><td><code id="centroid_+3A_frame">frame</code></td>
<td>
<p>The split tree transferred as data frame.</p>
</td></tr>
<tr><td><code id="centroid_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with coordinates of centroids
</p>

<hr>
<h2 id='checkem'>First Gate Function</h2><span id='topic+checkem'></span>

<h3>Description</h3>

<p>This function checks what are available nodes to split and then call
<code>find_split()</code> on each node, then decide which node creates best split, and
call <code>splitter()</code> to perform the split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkem(
  data,
  cuts,
  frame,
  cloc,
  dist,
  variables,
  minsplit,
  minbucket,
  split_order,
  ncores
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkem_+3A_data">data</code></td>
<td>
<p>Original data set.</p>
</td></tr>
<tr><td><code id="checkem_+3A_cuts">cuts</code></td>
<td>
<p>Cuts data set, which has the next higher value of each variable
in the original data set.</p>
</td></tr>
<tr><td><code id="checkem_+3A_frame">frame</code></td>
<td>
<p>The split tree transferred as data frame.</p>
</td></tr>
<tr><td><code id="checkem_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
<tr><td><code id="checkem_+3A_dist">dist</code></td>
<td>
<p>Distance matrix of all observations in the data.
exported function yet. Vector of 1 for all observations.</p>
</td></tr>
<tr><td><code id="checkem_+3A_variables">variables</code></td>
<td>
<p>List of variables selected for clustering procedure. It
could be a vector of variable indexes, or a vector of variable names.</p>
</td></tr>
<tr><td><code id="checkem_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations that must exist in a node
in order for a split to be attempted.</p>
</td></tr>
<tr><td><code id="checkem_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of observations in any terminal leaf
node. Default is <code>minsplit/3</code>.</p>
</td></tr>
<tr><td><code id="checkem_+3A_split_order">split_order</code></td>
<td>
<p>The control argument to see how many split has been done.</p>
</td></tr>
<tr><td><code id="checkem_+3A_ncores">ncores</code></td>
<td>
<p>Number of CPU cores on the current host.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It is not supposed to return anything because global environment was
used. However, if there is nothing left to split, it returns 0 to tell the
caller to stop running the loop.
</p>

<hr>
<h2 id='circ_arith'>Add/Subtract Circular Values in Degrees/Radian</h2><span id='topic+circ_arith'></span><span id='topic++cd++'></span><span id='topic++cd-+'></span><span id='topic++25cr+2B+25'></span><span id='topic++25cr-+25'></span>

<h3>Description</h3>

<p>Add/subtract two circular variables in degrees (<code style="white-space: pre;">&#8288;%cd+%&#8288;</code> and <code style="white-space: pre;">&#8288;%cd-%&#8288;</code>) and
radian (<code style="white-space: pre;">&#8288;%cr+%&#8288;</code> and <code style="white-space: pre;">&#8288;%cr-%&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %cd+% y

x %cd-% y

x %cr+% y

x %cr-% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circ_arith_+3A_x">x</code>, <code id="circ_arith_+3A_y">y</code></td>
<td>
<p>Circular values in degrees/radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between [0, 360) in degrees or [0, 2*pi) in radian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>90 %cd+% 90

250 %cd+% 200

25 %cd-% 80

pi %cr+% (pi/2)

</code></pre>

<hr>
<h2 id='circ_dist'>Distance Matrix of Circular Variables</h2><span id='topic+circ_dist'></span>

<h3>Description</h3>

<p>Calculates the distance matrix of observations with circular variables using
an adapted version of Gower's distance. This distance should be compatible
with the Gower's distance for other variable types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_dist(frame)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circ_dist_+3A_frame">frame</code></td>
<td>
<p>A data frame with all columns are circular measured in degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance between two observations i and j of a circular variable q
is suggested to be
</p>
<p style="text-align: center;"><code class="reqn">(y_{iq}, y_{jq}) = \frac{180 - |180 - |y_{iq} - y_{jq}||}{180}.</code>
</p>



<h3>Value</h3>

<p>Object of class &quot;dist&quot;.
</p>


<h3>References</h3>


<ul>
<li><p> Tran, T. V. (2019). Chapter 3. Monothetic Cluster Analysis with Extensions
to Circular and Functional Data. Montana State University - Bozeman.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">stats::dist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a sample data set of 20 observations with 2 circular variables
data &lt;- data.frame(var1 = sample.int(359, 20),
                   var2 = sample.int(359, 20))
circ_dist(data)
</code></pre>

<hr>
<h2 id='cluster_stats'>Cluster Statistics Calculation</h2><span id='topic+cluster_stats'></span>

<h3>Description</h3>

<p>Calinski-Harabasz's pseudo-F (Calinski and Harabasz, 1974) and Average
silhoutte width (Rousseeuw, 1987) calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_stats(d, clustering)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_stats_+3A_d">d</code></td>
<td>
<p>Distance object (as generated by <code><a href="stats.html#topic+dist">dist()</a></code>) or a distance matrix
between cases.</p>
</td></tr>
<tr><td><code id="cluster_stats_+3A_clustering">clustering</code></td>
<td>
<p>Integer vector of length of the number of cases, which
indicates a clustering. The clusters have to be numbered from 1 to the
number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>f_stat</dt><dd><p>Calinski-Harabasz's pseudo-F.</p>
</dd>
<dt>asw</dt><dd><p>Average silhouette width.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Caliński, T. and Harabasz, J (1974). &quot;A dendrite method for cluster
analysis&quot;. en. In: <em>Communications in Statistics</em> 3.1, pp. 1–27.
doi: <a href="https://doi.org/10.1080/03610927408827101">10.1080/03610927408827101</a>.
</p>
</li>
<li><p> Rousseeuw, P. J. (1987). &quot;Silhouettes: A graphical aid to the
interpretation and validation of cluster analysis&quot;. In: <em>Journal of
Computational and Applied Mathematics</em> 20, pp. 53–65. ISSN: 03770427.
doi: <a href="https://doi.org/10.1016/0377-0427(87)90125-7">10.1016/0377-0427(87)90125-7</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="cluster.html#topic+silhouette">cluster::silhouette()</a></code>
</p>

<hr>
<h2 id='create_labels'>Create Labels for Split Variables</h2><span id='topic+create_labels'></span>

<h3>Description</h3>

<p>This function prints variable's labels for a <code>MonoClust</code> tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels(x, abbrev, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_+3A_x">x</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="create_labels_+3A_abbrev">abbrev</code></td>
<td>
<p>Whether to print the abbreviated versions of variable names.
Can be either &quot;no&quot; (default), &quot;short&quot;, or &quot;abbreviate&quot;. Short forms of them
can also be used.
</p>
<p>If &quot;no&quot;, the labels recorded in <code>x$labels</code> are used.
</p>
<p>If &quot;short&quot;, variable names will be turned into &quot;V1&quot;, &quot;V2&quot;, ...
</p>
<p>If &quot;abbreviate&quot;, <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> function will be used. Use the optional
arguments for this function.</p>
</td></tr>
<tr><td><code id="create_labels_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="create_labels_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>

<ul>
<li> <p><code>varnames</code>: A named vector of labels corresponding to variable's names
(at vector names).
</p>
</li>
<li> <p><code>labels</code>: Vector of labels of splitting rules to be displayed.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+abbreviate">abbreviate()</a></code>
</p>

<hr>
<h2 id='cv.test'>Cross-Validation Test on MonoClust</h2><span id='topic+cv.test'></span>

<h3>Description</h3>

<p>Perform cross-validation test for different different number of clusters of
Monothetic Clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.test(data, fold = 10L, minnodes = 2L, maxnodes = 10L, ncores = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.test_+3A_data">data</code></td>
<td>
<p>Data set to be partitioned.</p>
</td></tr>
<tr><td><code id="cv.test_+3A_fold">fold</code></td>
<td>
<p>Number of folds (k). <code>fold = 1</code> is the special case, when the
function performs a Leave-One-Out Cross-Validation (LOOCV).</p>
</td></tr>
<tr><td><code id="cv.test_+3A_minnodes">minnodes</code></td>
<td>
<p>Minimum number of clusters to be checked.</p>
</td></tr>
<tr><td><code id="cv.test_+3A_maxnodes">maxnodes</code></td>
<td>
<p>Maximum number of clusters to be checked.</p>
</td></tr>
<tr><td><code id="cv.test_+3A_ncores">ncores</code></td>
<td>
<p>Number of CPU cores on the current host. When set to NULL,
all available cores are used.</p>
</td></tr>
<tr><td><code id="cv.test_+3A_...">...</code></td>
<td>
<p>Other parameters transferred to <code><a href="#topic+MonoClust">MonoClust()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>-fold cross-validation randomly partitions data into <code class="reqn">k</code>
subsets with equal (or close to equal) sizes. <code class="reqn">k - 1</code> subsets are used as
the training data set to create a tree with a desired number of leaves and
the other subset is used as validation data set to evaluate the predictive
performance of the trained tree. The process repeats for each subset as the
validating set (<code class="reqn">m = 1, \ldots, k</code>) and the mean squared difference,
</p>
<p style="text-align: center;"><code class="reqn">MSE_m=\frac{1}{n_m} \sum_{q=1}^Q\sum_{i \in m} d^2_{euc}(y_{iq},
\hat{y}_{(-i)q}),</code>
</p>

<p>is calculated, where <code class="reqn">\hat{y}_{(-i)q}</code> is the cluster mean on the
variable
<code class="reqn">q</code> of the cluster created by the training data where the observed value,
<code class="reqn">y_{iq}</code>, of the validation data set will fall into, and
<code class="reqn">d^2_{euc}(y_{iq}, \hat{y}_{(-i)q})</code> is the squared Euclidean distance
(dissimilarity) between two observations at variable $q$. This process is
repeated for the $k$ subsets of the data set and the average of these test
errors is the cross-validation-based estimate of the mean squared error of
predicting a new observation,
</p>
<p style="text-align: center;"><code class="reqn">CV_K = \overline{MSE} = \frac{1}{M} \sum_{m=1}^M MSE_m.</code>
</p>



<h3>Value</h3>

<p>A <code>MonoClust.cv</code> class containing a data frame of mean sum of square
error and its standard deviation.
</p>


<h3>Note</h3>

<p>This function supports parallel processing with <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>.
It distributes MonoClust calls to processes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cv.MonoClust">plot.cv.MonoClust()</a></code>, <code><a href="#topic+MonoClust">MonoClust()</a></code>, <code><a href="#topic+predict.MonoClust">predict.MonoClust()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(cluster)
data(ruspini)

# Leave-one-out cross-validation
cv.test(ruspini, fold = 1, minnodes = 2, maxnodes = 4)

# 5-fold cross-validation
cv.test(ruspini, fold = 5, minnodes = 2, maxnodes = 4)

</code></pre>

<hr>
<h2 id='error_bar'>Make Error Bars</h2><span id='topic+error_bar'></span>

<h3>Description</h3>

<p>Make Error Bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_bar(x, y, upper, lower = upper, length = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="error_bar_+3A_x">x</code></td>
<td>
<p>x coordinates.</p>
</td></tr>
<tr><td><code id="error_bar_+3A_y">y</code></td>
<td>
<p>y coordinates.</p>
</td></tr>
<tr><td><code id="error_bar_+3A_upper">upper</code></td>
<td>
<p>Distance from y to the upper bar.</p>
</td></tr>
<tr><td><code id="error_bar_+3A_lower">lower</code></td>
<td>
<p>Distance from y to the lower bar.</p>
</td></tr>
<tr><td><code id="error_bar_+3A_length">length</code></td>
<td>
<p>Length of the horizontal bar.</p>
</td></tr>
<tr><td><code id="error_bar_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="graphics.html#topic+arrows">graphics::arrows()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot
</p>

<hr>
<h2 id='find_closest'>Find the Closest Cut</h2><span id='topic+find_closest'></span>

<h3>Description</h3>

<p>Find the cuts for a quantitative variable. These cuts are what we are
going to consider when thinking about bi-partitioning the data. For a
quantitative column, find the next larger value of each value, if it is the
largest, that value + 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_closest(col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_closest_+3A_col">col</code></td>
<td>
<p>a quantitative vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a quantitative vector which contains the closest higher cut.
</p>

<hr>
<h2 id='find_split'>Find the Best Split</h2><span id='topic+find_split'></span>

<h3>Description</h3>

<p>Find the best split in terms of reduction in inertia for the transferred
node, indicate by row. Find the terminal node with the greatest change in
inertia and bi-partition it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_split(
  data,
  cuts,
  frame_row,
  cloc,
  dist,
  variables,
  minsplit,
  minbucket,
  ncores
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_split_+3A_data">data</code></td>
<td>
<p>Original data set.</p>
</td></tr>
<tr><td><code id="find_split_+3A_cuts">cuts</code></td>
<td>
<p>Cuts data set, which has the next higher value of each variable
in the original data set.</p>
</td></tr>
<tr><td><code id="find_split_+3A_frame_row">frame_row</code></td>
<td>
<p>One row of the split tree as data frame.</p>
</td></tr>
<tr><td><code id="find_split_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
<tr><td><code id="find_split_+3A_dist">dist</code></td>
<td>
<p>Distance matrix of all observations in the data.
exported function yet. Vector of 1 for all observations.</p>
</td></tr>
<tr><td><code id="find_split_+3A_variables">variables</code></td>
<td>
<p>List of variables selected for clustering procedure. It
could be a vector of variable indexes, or a vector of variable names.</p>
</td></tr>
<tr><td><code id="find_split_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations that must exist in a node
in order for a split to be attempted.</p>
</td></tr>
<tr><td><code id="find_split_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of observations in any terminal leaf
node. Default is <code>minsplit/3</code>.</p>
</td></tr>
<tr><td><code id="find_split_+3A_ncores">ncores</code></td>
<td>
<p>Number of CPU cores on the current host.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>frame_row</code> with the next split updated.
</p>

<hr>
<h2 id='ggcv'>GGPlot the Mean Square Error with Error Bar for +/- 1 Standard Error</h2><span id='topic+ggcv'></span>

<h3>Description</h3>

<p>GGPlot the Mean Square Error with Error Bar for +/- 1 Standard Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcv(
  cv.obj,
  title = "MSE for CV of monothetic clustering",
  xlab = "Number of clusters",
  ylab = "MSE +/- 1 SE",
  type = c("b", "p", "l"),
  linetype = 2,
  err.col = "red",
  err.width = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggcv_+3A_cv.obj">cv.obj</code></td>
<td>
<p>A <code>cv.MonoClust</code> object (output of <code><a href="#topic+cv.test">cv.test()</a></code>).</p>
</td></tr>
<tr><td><code id="ggcv_+3A_title">title</code></td>
<td>
<p>Overall title for the plot.</p>
</td></tr>
<tr><td><code id="ggcv_+3A_xlab">xlab</code></td>
<td>
<p>Title for x axis.</p>
</td></tr>
<tr><td><code id="ggcv_+3A_ylab">ylab</code></td>
<td>
<p>Title for y axis.</p>
</td></tr>
<tr><td><code id="ggcv_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn. Choosing between <code>"l"</code> (line
only), <code>"p"</code> (point only), and <code>"b"</code> (both line and point).</p>
</td></tr>
<tr><td><code id="ggcv_+3A_linetype">linetype</code></td>
<td>
<p>The line type. See <code>vignette("ggplot2-specs")</code>.</p>
</td></tr>
<tr><td><code id="ggcv_+3A_err.col">err.col</code></td>
<td>
<p>Color of the error bars.</p>
</td></tr>
<tr><td><code id="ggcv_+3A_err.width">err.width</code></td>
<td>
<p>Width of the bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p>Plot using base R <code><a href="#topic+plot.cv.MonoClust">plot.cv.MonoClust()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(cluster)
data(ruspini)

# 10-fold cross-validation
cptable &lt;- cv.test(ruspini, minnodes = 2, maxnodes = 4)
ggcv(cptable)

</code></pre>

<hr>
<h2 id='ggpcp'>Parallel Coordinates Plot with Circular Variables</h2><span id='topic+ggpcp'></span>

<h3>Description</h3>

<p>Making a parallel coordinates plot with the circular variables are plotted
as ellipses. The function currently works well with data with one circular
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggpcp(
  data,
  circ.var = NULL,
  is.degree = TRUE,
  rotate = 0,
  north = 0,
  cw = FALSE,
  order.appear = NULL,
  linetype = 1,
  size = 0.5,
  alpha = 0.5,
  clustering,
  medoids = NULL,
  cluster.col = NULL,
  show.medoids = FALSE,
  labelsize = 4,
  xlab = "Variables",
  ylab = NULL,
  legend.cluster = "groups"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggpcp_+3A_data">data</code></td>
<td>
<p>Data set.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_circ.var">circ.var</code></td>
<td>
<p>Circular variable(s) in the data set, indicated by names
or index in the data set.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_is.degree">is.degree</code></td>
<td>
<p>Whether the unit of the circular variables is degree or not
(radian). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_rotate">rotate</code></td>
<td>
<p>The rotate (offset, shift) of the circular variable, in
radians. Default is 0 (no rotation).</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_north">north</code></td>
<td>
<p>What value of the circular variable is labeled North. Default is
0 radian.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_cw">cw</code></td>
<td>
<p>Which direction of the circular variable is considered increasing
in value, clockwise (<code>TRUE</code>) or counter-clockwise (<code>FALSE</code>). Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_order.appear">order.appear</code></td>
<td>
<p>The order of appearance of the variables, listed by a
vector of names or index. If set, length has to be equal to the number of
variables in the data set.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_linetype">linetype</code></td>
<td>
<p>Line type. Default is solid line. See details in
<code>vignette("ggplot2-specs")</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_size">size</code></td>
<td>
<p>Size of a line is its width in mm. Default is 0.5. See details in
<code>vignette("ggplot2-specs")</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_alpha">alpha</code></td>
<td>
<p>The transparency of the lines. Default is 0.1.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_clustering">clustering</code></td>
<td>
<p>Cluster membership.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_medoids">medoids</code></td>
<td>
<p>Vector of medoid observations of cluster. Only required when
<code>show.medoids = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_cluster.col">cluster.col</code></td>
<td>
<p>Color of clusters, indicating by a vector. If set, the
length of this vector must be equal to the number of clusters in
<code>clustering</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_show.medoids">show.medoids</code></td>
<td>
<p>Whether to highlight the median lines or not. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_labelsize">labelsize</code></td>
<td>
<p>The size of labels on the plot. Default is 4.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_xlab">xlab</code></td>
<td>
<p>Labels for x-axis.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_ylab">ylab</code></td>
<td>
<p>Labels for y-axis.</p>
</td></tr>
<tr><td><code id="ggpcp_+3A_legend.cluster">legend.cluster</code></td>
<td>
<p>Labels for group membership. Implemented by setting
label for ggplot <code>color</code> aesthetics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set color constant
COLOR4 &lt;- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3")
# Reduce the size of the data for for sake of example speed
set.seed(12345)
wind_reduced &lt;- wind_sensit_2007[sample.int(nrow(wind_sensit_2007), 50), ]

sol42007 &lt;- MonoClust(wind_reduced, cir.var = 3, nclusters = 4)

library(ggplot2)
ggpcp(data = wind_reduced,
      circ.var = "WDIR",
      # To improve aesthetics
      rotate = pi*3/4-0.3,
      order.appear = c("WDIR", "has.sensit", "WS"),
      alpha = 0.5,
      clustering = sol42007$membership,
      medoids = sol42007$medoids,
      cluster.col = COLOR4,
      show.medoids = TRUE) +
  theme(panel.background = element_rect(color = "white"),
        panel.border = element_rect(color = "white", fill = NA),
        panel.grid.major = element_line(color = "#f0f0f0"),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        legend.key = element_rect(color = NA),
        legend.position = "bottom",
        legend.direction = "horizontal",
        legend.title = element_text(face = "italic"),
        legend.justification = "center")

</code></pre>

<hr>
<h2 id='inertia_calc'>Cluster Inertia Calculation</h2><span id='topic+inertia_calc'></span>

<h3>Description</h3>

<p>Calculate inertia for a given subset of the distance matrix from the original
data set provided to <code>x</code>. Assumes that distance matrices are stored as
matrices and not distance objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inertia_calc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inertia_calc_+3A_x">x</code></td>
<td>
<p>Distance matrix, not an object of some distance measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inertia value of the matrix, formula in Chavent (1998). If <code>x</code> is a
single number, return 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

# Euclidean distance on first 20 rows of the 4 continuous variables
dist_mat &lt;- as.matrix(dist(iris[1:20, 1:4]))
inertia_calc(dist_mat)
</code></pre>

<hr>
<h2 id='is_MonoClust'>Test If The Object is A MonoClust</h2><span id='topic+is_MonoClust'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for MonoClust, and FALSE for all other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_MonoClust(mono_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_MonoClust_+3A_mono_obj">mono_obj</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object inherits from the <code>MonoClust</code> class.
</p>

<hr>
<h2 id='make_jump_table'>Create Jump Table</h2><span id='topic+make_jump_table'></span>

<h3>Description</h3>

<p>Create jump table from the MonoClust's frame object. <code>number</code> and <code>var</code> will
be used to create the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_jump_table(frame)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_jump_table_+3A_frame">frame</code></td>
<td>
<p>MonoClust's frame object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jump table with <code>number</code>, <code>var</code>, and two new columns <code>left</code> and
<code>right</code> indicate the left and right number at split.
</p>

<hr>
<h2 id='medoid'>Find Medoid of the Cluster</h2><span id='topic+medoid'></span>

<h3>Description</h3>

<p>Medoid is the point that has minimum distance to all other points in the
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medoid(members, dist_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medoid_+3A_members">members</code></td>
<td>
<p>index vector indicating which observation belongs to the
cluster.</p>
</td></tr>
<tr><td><code id="medoid_+3A_dist_mat">dist_mat</code></td>
<td>
<p>distance matrix of the whole data set. A class of <code>dist</code>
object must be coerced to a matrix before using.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index of the medoid point in the members vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(cluster)
data(ruspini)
ruspini4sol &lt;- MonoClust(ruspini, nclusters = 4)
ruspini4sol

medoid(which(ruspini4sol$membership == 4), ruspini4sol$dist)

# Check with the output with "4" label
ruspini4sol$medoids

</code></pre>

<hr>
<h2 id='MonoClust'>Monothetic Clustering</h2><span id='topic+MonoClust'></span>

<h3>Description</h3>

<p>Creates a MonoClust object after partitioning the data set using Monothetic
Clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MonoClust(
  toclust,
  cir.var = NULL,
  variables = NULL,
  distmethod = NULL,
  digits = getOption("digits"),
  nclusters = 2L,
  minsplit = 5L,
  minbucket = round(minsplit/3),
  ncores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MonoClust_+3A_toclust">toclust</code></td>
<td>
<p>Data set as a data frame.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_cir.var">cir.var</code></td>
<td>
<p>Index or name of the circular variable in the data set.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_variables">variables</code></td>
<td>
<p>List of variables selected for clustering procedure. It
could be a vector of variable indexes, or a vector of variable names.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_distmethod">distmethod</code></td>
<td>
<p>Distance method to use with the data set. Can be chosen
from &quot;euclidean&quot; (for Euclidean distance), &quot;mahattan&quot; (for Manhattan
distance), or &quot;gower&quot; (for Gower distance). If not set, Euclidean distance
is used unless <code>cir.var</code> is set, then it is Gower distance is used by
default. Abbreviations can be used.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_digits">digits</code></td>
<td>
<p>Significant decimal number printed in the output.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters created. Default is 2.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimum number of observations that must exist in a node
in order for a split to be attempted. Default is 5.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_minbucket">minbucket</code></td>
<td>
<p>The minimum number of observations in any terminal leaf
node. Default is <code>minsplit/3</code>.</p>
</td></tr>
<tr><td><code id="MonoClust_+3A_ncores">ncores</code></td>
<td>
<p>Number of CPU cores on the current host. If greater than 1,
parallel processing with <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> is used to distribute cut
search on variables to processes. When set to NULL, all available cores are
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MonoClust</code> object. See <code><a href="#topic+MonoClust.object">MonoClust.object</a></code>.
</p>


<h3>References</h3>


<ol>
<li><p> Chavent, M. (1998). A monothetic clustering method. Pattern Recognition
Letters, 19(11), 989-996. doi: <a href="https://doi.org/10.1016/S0167-8655(98)00087-7">10.1016/S0167-8655(98)00087-7</a>.
</p>
</li>
<li><p> Tran, T. V. (2019). Monothetic Cluster Analysis with Extensions to
Circular and Functional Data. Montana State University - Bozeman.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Very simple data set
library(cluster)
data(ruspini)
ruspini4sol &lt;- MonoClust(ruspini, nclusters = 4)
ruspini4sol

# data with circular variable
library(monoClust)
data(wind_sensit_2007)

# Use a small data set
set.seed(12345)
wind_reduced &lt;- wind_sensit_2007[sample.int(nrow(wind_sensit_2007), 10), ]
circular_wind &lt;- MonoClust(wind_reduced, cir.var = 3, nclusters = 2)
circular_wind
</code></pre>

<hr>
<h2 id='MonoClust.object'>Monothetic Clustering Tree Object</h2><span id='topic+MonoClust.object'></span>

<h3>Description</h3>

<p>The structure and objects contained in MonoClust, an object returned from
the <code><a href="#topic+MonoClust">MonoClust()</a></code> function and used as the input in other functions in the
package.
</p>


<h3>Value</h3>


<dl>
<dt>frame</dt><dd><p>Data frame in the form of a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> representing
a tree structure with one row for each node. The columns include:
</p>

<dl>
<dt>number</dt><dd><p>Index of the node. Depth of a node can be derived by
<code>number %/% 2</code>.</p>
</dd>
<dt>var</dt><dd><p>Name of the variable used in the split at a node or
<code>"&lt;leaf&gt;"</code> if it is a leaf node.</p>
</dd>
<dt>cut</dt><dd><p>Splitting value, so values of <code>var</code> that are smaller than
that go to left branch while values greater than that go to the right
branch.</p>
</dd>
<dt>n</dt><dd><p>Cluster size, the number of observations in that cluster.</p>
</dd>
<dt>inertia</dt><dd><p>Inertia value of the cluster at that node.</p>
</dd>
<dt>bipartsplitrow</dt><dd><p>Position of the next split row in the data set
(that position will belong to left node (smaller)).</p>
</dd>
<dt>bipartsplitcol</dt><dd><p>Position of the next split variable in the data
set.</p>
</dd>
<dt>inertiadel</dt><dd><p>Proportion of inertia value of the cluster at that
node to the inertia of the root.</p>
</dd>
<dt>medoid</dt><dd><p>Position of the data point regarded as the medoid of
its cluster.</p>
</dd>
<dt>loc</dt><dd><p>y-coordinate of the splitting node to facilitate showing
on the tree. See <code><a href="#topic+plot.MonoClust">plot.MonoClust()</a></code> for details.</p>
</dd>
<dt>split.order</dt><dd><p>Order of the splits with root is 0.</p>
</dd>
<dt>inertia_explained</dt><dd><p>Percent inertia explained as described in
Chavent (2007). It is <code style="white-space: pre;">&#8288;1 - (sum(current inertia)/inertial[1])&#8288;</code>.</p>
</dd>
<dt>alt</dt><dd><p>A nested tibble of alternate splits at a node. It contains
<code>bipartsplitrow</code> and <code>bipartsplitcol</code> with the same meaning above.
Note that this is only for information purpose. Currently <code>monoClust</code>
does not support choosing an alternate splitting route. Running
<code><a href="#topic+MonoClust">MonoClust()</a></code> with <code>nclusters = 2</code> step-by-step can be run if
needed.</p>
</dd>
</dl>
</dd>
<dt>membership</dt><dd><p>Vector of the same length as the number of rows in the
data, containing the value of <code>frame$number</code> corresponding to the leaf
node that an observation falls into.</p>
</dd>
<dt>dist</dt><dd><p>Distance matrix calculated using the method indicated in
<code>distmethod</code> argument of <code><a href="#topic+MonoClust">MonoClust()</a></code>.</p>
</dd>
<dt>terms</dt><dd><p>Vector of variable names in the data that were used to split.</p>
</dd>
<dt>centroids</dt><dd><p>Data frame with one row for centroid value of each
cluster.</p>
</dd>
<dt>medoids</dt><dd><p>Named vector of positions of the data points regarded as
medoids of clusters.</p>
</dd>
<dt>alt</dt><dd><p>Indicator of having an alternate splitting route occurred when
splitting.</p>
</dd>
<dt>circularroot</dt><dd><p>List of values designed for circular variable in the
data set. <code>var</code> is the name of circular variable and <code>cut</code> is its first
best split value. If circular variable is not available, both objects are
NULL.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Chavent, M., Lechevallier, Y., &amp; Briant, O. (2007). DIVCLUS-T: A monothetic
divisive hierarchical clustering method. Computational Statistics &amp; Data
Analysis, 52(2), 687-701. doi: <a href="https://doi.org/10.1016/j.csda.2007.03.013">10.1016/j.csda.2007.03.013</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MonoClust">MonoClust()</a></code>.
</p>

<hr>
<h2 id='new_node'>Create A New Node for Split Data Frame</h2><span id='topic+new_node'></span>

<h3>Description</h3>

<p>This function is just a helper to make sure that the default values of the
split data frame is correct when unspecified. It helps reduce type error,
especially when moving to use dplyr which is stricter in data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_node(
  number,
  var,
  cut = -99L,
  n,
  inertia,
  bipartsplitrow = -99L,
  bipartsplitcol = -99L,
  inertiadel = 0,
  inertia_explained = -99,
  medoid,
  loc,
  split.order = -99L,
  alt = list(tibble::tibble(bipartsplitrow = numeric(), bipartsplitcol = numeric()))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_node_+3A_number">number</code></td>
<td>
<p>Row index of the data frame.</p>
</td></tr>
<tr><td><code id="new_node_+3A_var">var</code></td>
<td>
<p>Whether it is a leaf, or the name of the next split variable.</p>
</td></tr>
<tr><td><code id="new_node_+3A_cut">cut</code></td>
<td>
<p>The splitting value, so values (of <code>var</code>) smaller than that
go to left branch while values greater than that go to right branch.</p>
</td></tr>
<tr><td><code id="new_node_+3A_n">n</code></td>
<td>
<p>Cluster size. Number of observations in that cluster.</p>
</td></tr>
<tr><td><code id="new_node_+3A_inertia">inertia</code></td>
<td>
<p>Inertia value of the cluster at that node.</p>
</td></tr>
<tr><td><code id="new_node_+3A_bipartsplitrow">bipartsplitrow</code></td>
<td>
<p>Position of the next split row in the data set (that
position will belong to left node (smaller)).</p>
</td></tr>
<tr><td><code id="new_node_+3A_bipartsplitcol">bipartsplitcol</code></td>
<td>
<p>Position of the next split variable in the data set.</p>
</td></tr>
<tr><td><code id="new_node_+3A_inertiadel">inertiadel</code></td>
<td>
<p>The proportion of inertia value of the cluster at that node
to the inertia of the root.</p>
</td></tr>
<tr><td><code id="new_node_+3A_inertia_explained">inertia_explained</code></td>
<td>
<p>Percent inertia explained as described in Chavent
(2007)</p>
</td></tr>
<tr><td><code id="new_node_+3A_medoid">medoid</code></td>
<td>
<p>Position of the data point regarded as the medoid of its
cluster.</p>
</td></tr>
<tr><td><code id="new_node_+3A_loc">loc</code></td>
<td>
<p>y-coordinate of the splitting node to facilitate showing on the
tree. See <code><a href="#topic+plot.MonoClust">plot.MonoClust()</a></code> for details.</p>
</td></tr>
<tr><td><code id="new_node_+3A_split.order">split.order</code></td>
<td>
<p>Order of the splits. Root is 0, and increasing.</p>
</td></tr>
<tr><td><code id="new_node_+3A_alt">alt</code></td>
<td>
<p>Indicator of an alternative cut yielding the same reduction in
inertia at that split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with only one row and correct default data type for even an
unspecified variables.
</p>


<h3>References</h3>


<ul>
<li><p> Chavent, M., Lechevallier, Y., &amp; Briant, O. (2007). DIVCLUS-T: A monothetic
divisive hierarchical clustering method. Computational Statistics &amp; Data
Analysis, 52(2), 687–701. https://doi.org/10.1016/j.csda.2007.03.013
</p>
</li></ul>


<hr>
<h2 id='perm.test'>Permutation Test on Monothetic Tree</h2><span id='topic+perm.test'></span>

<h3>Description</h3>

<p>Testing the significance of each monothetic clustering split by permutation
methods. The &quot;simple-withhold&quot; method (<code>"sw"</code>) shuffles the observations
between two groups without the splitting variable. The other two methods
shuffle the values in the splitting variable to create a new data set, then
it either splits again on that variable (&quot;resplit-limit&quot;, <code>"rl"</code>) or use all
variables as the splitting candidates (&quot;resplit-nolimit&quot;, <code>"rn"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm.test(
  object,
  data,
  auto.pick = FALSE,
  sig.val = 0.05,
  method = c("sw", "rl", "rn"),
  rep = 1000L,
  stat = c("f", "aw"),
  bon.adj = TRUE,
  ncores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perm.test_+3A_object">object</code></td>
<td>
<p>The <code>MonoClust</code> object as the result of the clustering.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_data">data</code></td>
<td>
<p>The data set which is being clustered.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_auto.pick">auto.pick</code></td>
<td>
<p>Whether the algorithm stops when p-value becomes larger than
<code>sig.val</code> or keeps testing and let the researcher pick the final splitting
tree. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_sig.val">sig.val</code></td>
<td>
<p>Significance value to decide when to stop splitting. This
option is ignored if <code>auto.pick = FALSE</code>, and is 0.05 by default when
<code>auto.pick = TRUE</code>.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_method">method</code></td>
<td>
<p>Can be chosen between <code>sw</code> (simple-withhold, default), <code>rl</code>
(resplit-limit), or <code>rn</code> (resplit-nolimit). See Details.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_rep">rep</code></td>
<td>
<p>Number of permutations required to calculate test statistic.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_stat">stat</code></td>
<td>
<p>Statistic to use. Choosing between <code>"f"</code> (Calinski-Harabasz's
pseudo-F (Calinski and Harabasz, 1974)) or <code>"aw"</code> (Average silhoutte width
by Rousseeuw (1987)).</p>
</td></tr>
<tr><td><code id="perm.test_+3A_bon.adj">bon.adj</code></td>
<td>
<p>Whether to adjust for multiple testing problem using
Bonferroni correction.</p>
</td></tr>
<tr><td><code id="perm.test_+3A_ncores">ncores</code></td>
<td>
<p>Number of CPU cores on the current host. When set to NULL,
all available cores are used.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Permutation Methods</h4>



<h5>Simple-Withhold: Shuffle the observations between two proposed clusters</h5>

<p>The <code>stat</code> calculated from the shuffles create the reference distribution
to find the p-value. Because the splitting variable that was chosen is
already the best in terms of reduction of inertia, that variable is withheld
from the distance matrix used in the permutation test.
</p>



<h5>Resplit-Limit: Shuffle splitting variable, split again on that variable</h5>

<p>This method shuffles the values of the splitting variables while keeping
other variables fixed to create a new data set, then the chosen <code>stat</code> is
calculated for each rep to compare with the observed <code>stat</code>.
</p>



<h5>Resplit-Nolimit: Shuffle splitting variable, split on all variables</h5>

<p>Similar to Method 2 but all variables are splitting candidates.
</p>




<h4>Bonferroni Correction</h4>

<p>A hypothesis test occurred lower in the monothetic clustering tree could have
its p-value corrected for multiple tests happened before it in order to reach
that node. The formula is
</p>
<p style="text-align: center;"><code class="reqn">adj.p = unadj.p \times depth,</code>
</p>

<p>with <code class="reqn">depth</code> is 1 at the root node.
</p>



<h3>Value</h3>

<p>The same <code>MonoClust</code> object with an extra column (p-value), as well
as the <code>numofclusters</code> object if <code>auto.pick = TRUE</code>.
</p>


<h3>Note</h3>

<p>This function uses <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> to facilitate parallel
processing. It distributes reps to processes.
</p>


<h3>References</h3>

<p>Calinski, T. and Harabasz, J (1974). &quot;A dendrite method for cluster
analysis&quot;. en. In: <em>Communications in Statistics</em> 3.1, pp. 1-27.
doi: <a href="https://doi.org/10.1080/03610927408827101">10.1080/03610927408827101</a>.
</p>
<p>Rousseeuw, P. J. (1987). &quot;Silhouettes: A graphical aid to the interpretation
and validation of cluster analysis&quot;. In: <em>Journal of Computational and
Applied Mathematics</em> 20, pp. 53-65. ISSN: 03770427.
doi: <a href="https://doi.org/10.1016/0377-0427(87)90125-7">10.1016/0377-0427(87)90125-7</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cluster)
data(ruspini)

ruspini6sol &lt;- MonoClust(ruspini, nclusters = 6)
ruspini6.p_value &lt;- perm.test(ruspini6sol, data = ruspini, method = "sw",
                              rep = 1000)
ruspini6.p_value

</code></pre>

<hr>
<h2 id='plot_prep_branch'>Calculate Branch Coordinates</h2><span id='topic+plot_prep_branch'></span>

<h3>Description</h3>

<p>Calculate Branch Coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prep_branch(x, y, node, branch = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_prep_branch_+3A_x">x</code></td>
<td>
<p>Nodes x-coordinates.</p>
</td></tr>
<tr><td><code id="plot_prep_branch_+3A_y">y</code></td>
<td>
<p>Nodes y-coordinates.</p>
</td></tr>
<tr><td><code id="plot_prep_branch_+3A_node">node</code></td>
<td>
<p>Nodes row number.</p>
</td></tr>
<tr><td><code id="plot_prep_branch_+3A_branch">branch</code></td>
<td>
<p>Controls the shape of the branches from parent to child node.
Any number from 0 to 1 is allowed. A value of 1 gives square shouldered
branches, a value of 0 give V shaped branches, with other values being
intermediate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Branch coordinates in a list of x and y axis.
</p>

<hr>
<h2 id='plot_prep_node'>Calculate Nodes Coordinates</h2><span id='topic+plot_prep_node'></span>

<h3>Description</h3>

<p>Calculate Nodes Coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prep_node(tree, uniform = FALSE, minbranch = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_prep_node_+3A_tree">tree</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="plot_prep_node_+3A_uniform">uniform</code></td>
<td>
<p>If TRUE, uniform vertical spacing of the nodes is used; this
may be less cluttered when fitting a large plot onto a page. The default is
to use a non-uniform spacing proportional to the inertia in the fit.</p>
</td></tr>
<tr><td><code id="plot_prep_node_+3A_minbranch">minbranch</code></td>
<td>
<p>Set the minimum length for a branch to <code>minbranch</code> times the
average branch length. This parameter is ignored if <code>uniform = TRUE</code>.
Sometimes a split will give very little improvement, or even no improvement
at all. A tree with branch lengths strictly proportional to improvement
leaves no room to squeeze in node labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nodes coordinates in a list of x and y axis.
</p>

<hr>
<h2 id='plot_tree'>Plot the monoClust Tree.</h2><span id='topic+plot_tree'></span>

<h3>Description</h3>

<p>This function plots the MonoClust tree. It is partially inspired by rpart
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree(
  x,
  uniform = FALSE,
  branch = 1,
  margin = 0,
  minbranch = 0.3,
  rel.loc.x = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_tree_+3A_x">x</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_uniform">uniform</code></td>
<td>
<p>If TRUE, uniform vertical spacing of the nodes is used; this
may be less cluttered when fitting a large plot onto a page. The default is
to use a non-uniform spacing proportional to the inertia in the fit.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_branch">branch</code></td>
<td>
<p>Controls the shape of the branches from parent to child node.
Any number from 0 to 1 is allowed. A value of 1 gives square shouldered
branches, a value of 0 give V shaped branches, with other values being
intermediate.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_margin">margin</code></td>
<td>
<p>An extra fraction of white space to leave around the borders of
the tree. (Long labels sometimes get cut off by the default computation).</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_minbranch">minbranch</code></td>
<td>
<p>Set the minimum length for a branch to <code>minbranch</code> times the
average branch length. This parameter is ignored if <code>uniform = TRUE</code>.
Sometimes a split will give very little improvement, or even no improvement
at all. A tree with branch lengths strictly proportional to improvement
leaves no room to squeeze in node labels.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_rel.loc.x">rel.loc.x</code></td>
<td>
<p>Whether to use the relative distance between clusters as x
coordinate of the leaves. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_tree_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code> and
<code><a href="graphics.html#topic+lines">graphics::lines()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of tree
</p>

<hr>
<h2 id='plot.cv.MonoClust'>Plot the Mean Square Error with Error Bar for +/- 1 Standard Error</h2><span id='topic+plot.cv.MonoClust'></span>

<h3>Description</h3>

<p>Plot the Mean Square Error with Error Bar for +/- 1 Standard Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.MonoClust'
plot(
  x,
  main = "MSE for CV of monothetic clustering",
  xlab = "Number of clusters",
  ylab = "MSE +/- 1 SE",
  type = "b",
  lty = 2,
  err.col = "red",
  err.width = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv.MonoClust_+3A_x">x</code></td>
<td>
<p>A <code>cv.MonoClust</code> object (output of <code><a href="#topic+cv.test">cv.test()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_main">main</code></td>
<td>
<p>Overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_xlab">xlab</code></td>
<td>
<p>Title for x axis.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_ylab">ylab</code></td>
<td>
<p>Title for y axis.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn. See <code><a href="graphics.html#topic+par">graphics::par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_lty">lty</code></td>
<td>
<p>The line type.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_err.col">err.col</code></td>
<td>
<p>Color of the error bars.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_err.width">err.width</code></td>
<td>
<p>Width of the bars.</p>
</td></tr>
<tr><td><code id="plot.cv.MonoClust_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line plot with error bars.
</p>


<h3>See Also</h3>

<p>Plot using ggplot2 <code><a href="#topic+ggcv">ggcv()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(cluster)
data(ruspini)

# 10-fold cross-validation
cptable &lt;- cv.test(ruspini, minnodes = 2, maxnodes = 4)
plot(cptable)

</code></pre>

<hr>
<h2 id='plot.MonoClust'>Plot MonoClust Splitting Rule Tree</h2><span id='topic+plot.MonoClust'></span>

<h3>Description</h3>

<p>Print the MonoClust tree in the form of dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonoClust'
plot(
  x,
  uniform = FALSE,
  branch = 1,
  margin = c(0.12, 0.02, 0, 0.05),
  minbranch = 0.3,
  text = TRUE,
  which = 4,
  stats = TRUE,
  abbrev = c("no", "short", "abbreviate"),
  digits = getOption("digits") - 2,
  cols = NULL,
  col.type = c("l", "p", "b"),
  rel.loc.x = TRUE,
  show.pval = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MonoClust_+3A_x">x</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_uniform">uniform</code></td>
<td>
<p>If TRUE, uniform vertical spacing of the nodes is used; this
may be less cluttered when fitting a large plot onto a page. The default is
to use a non-uniform spacing proportional to the inertia in the fit.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_branch">branch</code></td>
<td>
<p>Controls the shape of the branches from parent to child node.
Any number from 0 to 1 is allowed. A value of 1 gives square shouldered
branches, a value of 0 give V shaped branches, with other values being
intermediate.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_margin">margin</code></td>
<td>
<p>An extra fraction of white space to leave around the borders of
the tree. (Long labels sometimes get cut off by the default computation).</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_minbranch">minbranch</code></td>
<td>
<p>Set the minimum length for a branch to <code>minbranch</code> times the
average branch length. This parameter is ignored if <code>uniform = TRUE</code>.
Sometimes a split will give very little improvement, or even no improvement
at all. A tree with branch lengths strictly proportional to improvement
leaves no room to squeeze in node labels.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_text">text</code></td>
<td>
<p>Whether to print the labels on the tree.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_which">which</code></td>
<td>
<p>Labeling modes, which are:
</p>

<ul>
<li><p> 1: only splitting variable names are shown, no splitting rules.
</p>
</li>
<li><p> 2: only splitting rules to the left branches are shown.
</p>
</li>
<li><p> 3: only splitting rules to the right branches are shown.
</p>
</li>
<li><p> 4 (default): splitting rules are shown on both sides of branches.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_stats">stats</code></td>
<td>
<p>Whether to show statistics (cluster sizes and medoid points) on
the tree.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_abbrev">abbrev</code></td>
<td>
<p>Whether to print the abbreviated versions of variable names.
Can be either &quot;no&quot; (default), &quot;short&quot;, or &quot;abbreviate&quot;. Short forms of them
can also be used.
</p>
<p>If &quot;no&quot;, the labels recorded in <code>x$labels</code> are used.
</p>
<p>If &quot;short&quot;, variable names will be turned into &quot;V1&quot;, &quot;V2&quot;, ...
</p>
<p>If &quot;abbreviate&quot;, <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> function will be used. Use the optional
arguments for this function.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_cols">cols</code></td>
<td>
<p>Whether to shown color bars at leaves or not. It helps matching
this tree plot with other plots whose cluster membership were colored. It
only works when <code>text</code> is <code>TRUE</code>. Either <code>NULL</code>, a vector of one color, or
a vector of colors matching the number of leaves.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_col.type">col.type</code></td>
<td>
<p>When <code>cols</code> is set, choose whether the color indicators are
shown in a form of solid lines below the leaves (<code>"l"</code>), or big points
(<code>"p"</code>), or both (<code>"b"</code>).</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_rel.loc.x">rel.loc.x</code></td>
<td>
<p>Whether to use the relative distance between clusters as x
coordinate of the leaves. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_show.pval">show.pval</code></td>
<td>
<p>If MonoClust object has been run through <code><a href="#topic+perm.test">perm.test()</a></code>,
whether to show p-value on the tree.</p>
</td></tr>
<tr><td><code id="plot.MonoClust_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code> and
<code><a href="graphics.html#topic+lines">graphics::lines()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of splitting rule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cluster)
data(ruspini)

# MonoClust tree
ruspini4sol &lt;- MonoClust(ruspini, nclusters = 4)
plot(ruspini4sol)

# MonoClust tree after permutation test is run
ruspini6sol &lt;- MonoClust(ruspini, nclusters = 6)
ruspini6_test &lt;- perm.test(ruspini6sol,
                           data = ruspini,
                           method = "sw",
                           rep = 1000)
plot(ruspini6_test, branch = 1, uniform = TRUE)

</code></pre>

<hr>
<h2 id='predict.MonoClust'>Predictions from a MonoClust Object</h2><span id='topic+predict.MonoClust'></span>

<h3>Description</h3>

<p>Predict the cluster memberships of a new data set from a <code>MonoClust</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonoClust'
predict(object, newdata, type = c("centroid", "medoid"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MonoClust_+3A_object">object</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="predict.MonoClust_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing the values to be predicted. If missing,
the memberships of the MonoClust object are returned.</p>
</td></tr>
<tr><td><code id="predict.MonoClust_+3A_type">type</code></td>
<td>
<p>Type of returned cluster representatives. Either <code>"centroid"</code> to
return the centroid values of the terminal clusters, or <code>"medoid"</code> to
return the index of the medoid observations in the clustered data set.</p>
</td></tr>
<tr><td><code id="predict.MonoClust_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of cluster index in <code>cname</code> and either centroid values or
medoid observations index based on the value of <code>type</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cluster)
data(ruspini)

set.seed(1234)
test_index &lt;- sample(1:nrow(ruspini), nrow(ruspini)/5)
train_index &lt;- setdiff(1:nrow(ruspini), test_index)
ruspini_train &lt;- ruspini[train_index, ]
ruspini_test &lt;- ruspini[test_index, ]

ruspini_train_4sol &lt;- MonoClust(ruspini_train, nclusters = 4)
predict(ruspini_train_4sol, newdata = ruspini_test)
</code></pre>

<hr>
<h2 id='print.cv.MonoClust'>Print MonoClust Cross-Validation Result</h2><span id='topic+print.cv.MonoClust'></span>

<h3>Description</h3>

<p>Print MonoClust Cross-Validation Result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.MonoClust'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cv.MonoClust_+3A_x">x</code></td>
<td>
<p>A <code>cv.MonoClust</code> object (output of <code><a href="#topic+cv.test">cv.test()</a></code>).</p>
</td></tr>
<tr><td><code id="print.cv.MonoClust_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(cluster)
data(ruspini)

# 10-fold cross-validation
cp_table &lt;- cv.test(ruspini, minnodes = 2, maxnodes = 4)
print(cp_table)

</code></pre>

<hr>
<h2 id='print.MonoClust'>Print Monothetic Clustering Results</h2><span id='topic+print.MonoClust'></span>

<h3>Description</h3>

<p>Render the <code>MonoClust</code> split tree in an easy to read format with important
information such as terminal nodes, p-value (if possible), etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonoClust'
print(
  x,
  abbrev = c("no", "short", "abbreviate"),
  spaces = 2L,
  digits = getOption("digits"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MonoClust_+3A_x">x</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="print.MonoClust_+3A_abbrev">abbrev</code></td>
<td>
<p>Whether to print the abbreviated versions of variable names.
Can be either &quot;no&quot; (default), &quot;short&quot;, or &quot;abbreviate&quot;. Short forms of them
can also be used.
</p>
<p>If &quot;no&quot;, the labels recorded in <code>x$labels</code> are used.
</p>
<p>If &quot;short&quot;, variable names will be turned into &quot;V1&quot;, &quot;V2&quot;, ...
</p>
<p>If &quot;abbreviate&quot;, <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> function will be used. Use the optional
arguments for this function.</p>
</td></tr>
<tr><td><code id="print.MonoClust_+3A_spaces">spaces</code></td>
<td>
<p>Spaces indent between 2 tree levels.</p>
</td></tr>
<tr><td><code id="print.MonoClust_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="print.MonoClust_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nicely displayed MonoClust split tree.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+abbreviate">abbreviate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cluster)
data(ruspini)
ruspini4sol &lt;- MonoClust(ruspini, nclusters = 4)
print(ruspini4sol, digits = 2)
</code></pre>

<hr>
<h2 id='splitter'>Split Function</h2><span id='topic+splitter'></span>

<h3>Description</h3>

<p>Given the Cluster's frame's row position to split at <code>split_row</code>, this
function performs the split, calculate all necessary information for the
splitting tree and cluster memberships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitter(data, cuts, split_row, frame, cloc, dist, split_order = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitter_+3A_data">data</code></td>
<td>
<p>Original data set.</p>
</td></tr>
<tr><td><code id="splitter_+3A_cuts">cuts</code></td>
<td>
<p>Cuts data set, which has the next higher value of each variable
in the original data set.</p>
</td></tr>
<tr><td><code id="splitter_+3A_split_row">split_row</code></td>
<td>
<p>The row index in frame that would be split on.</p>
</td></tr>
<tr><td><code id="splitter_+3A_frame">frame</code></td>
<td>
<p>The split tree transferred as data frame.</p>
</td></tr>
<tr><td><code id="splitter_+3A_cloc">cloc</code></td>
<td>
<p>Vector of current cluster membership.</p>
</td></tr>
<tr><td><code id="splitter_+3A_dist">dist</code></td>
<td>
<p>Distance matrix of all observations in the data.
exported function yet. Vector of 1 for all observations.</p>
</td></tr>
<tr><td><code id="splitter_+3A_split_order">split_order</code></td>
<td>
<p>The control argument to see how many split has been done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>frame</code> and <code>cloc</code> saved in a list.
</p>

<hr>
<h2 id='test_split'>Hypothesis Test at Split</h2><span id='topic+test_split'></span>

<h3>Description</h3>

<p>Hypothesis Test at Split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_split(members_l, members_r, method, data, split_var, rep, stat, ncores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_split_+3A_members_l">members_l</code>, <code id="test_split_+3A_members_r">members_r</code></td>
<td>
<p>Vector of the index of observations that
are members of the left child node and the right child node, respectively.</p>
</td></tr>
<tr><td><code id="test_split_+3A_method">method</code></td>
<td>
<p>Can be chosen between <code>sw</code> (simple-withhold, default), <code>rl</code>
(resplit-limit), or <code>rn</code> (resplit-nolimit). See Details.</p>
</td></tr>
<tr><td><code id="test_split_+3A_data">data</code></td>
<td>
<p>The data set which is being clustered.</p>
</td></tr>
<tr><td><code id="test_split_+3A_split_var">split_var</code></td>
<td>
<p>Splitting variable at current split.</p>
</td></tr>
<tr><td><code id="test_split_+3A_rep">rep</code></td>
<td>
<p>Number of permutations required to calculate test statistic.</p>
</td></tr>
<tr><td><code id="test_split_+3A_stat">stat</code></td>
<td>
<p>Statistic to use. Choosing between <code>"f"</code> (Calinski-Harabasz's
pseudo-F (Calinski and Harabasz, 1974)) or <code>"aw"</code> (Average silhoutte width
by Rousseeuw (1987)).</p>
</td></tr>
<tr><td><code id="test_split_+3A_ncores">ncores</code></td>
<td>
<p>Number of CPU cores on the current host. When set to NULL,
all available cores are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of the test
</p>

<hr>
<h2 id='text_tree'>Implementation of Print Labels on MonoClust Tree</h2><span id='topic+text_tree'></span>

<h3>Description</h3>

<p>This function plots the labels onto the MonoClust tree. It is partially
inspired by rpart package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_tree(
  x,
  which = 4,
  digits = getOption("digits") - 2,
  stats = TRUE,
  abbrev,
  cols = NULL,
  cols.type = c("l", "p", "b"),
  rel.loc.x = TRUE,
  show.pval = TRUE,
  uniform = FALSE,
  minbranch = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="text_tree_+3A_x">x</code></td>
<td>
<p>MonoClust result object.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_which">which</code></td>
<td>
<p>Labeling modes, which are:
</p>

<ul>
<li><p> 1: only splitting variable names are shown, no splitting rules.
</p>
</li>
<li><p> 2: only splitting rules to the left branches are shown.
</p>
</li>
<li><p> 3: only splitting rules to the right branches are shown.
</p>
</li>
<li><p> 4 (default): splitting rules are shown on both sides of branches.
</p>
</li></ul>
</td></tr>
<tr><td><code id="text_tree_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_stats">stats</code></td>
<td>
<p>Whether to show statistics (cluster sizes and medoid points) on
the tree.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_abbrev">abbrev</code></td>
<td>
<p>Whether to print the abbreviated versions of variable names.
Can be either &quot;no&quot; (default), &quot;short&quot;, or &quot;abbreviate&quot;. Short forms of them
can also be used.
</p>
<p>If &quot;no&quot;, the labels recorded in <code>x$labels</code> are used.
</p>
<p>If &quot;short&quot;, variable names will be turned into &quot;V1&quot;, &quot;V2&quot;, ...
</p>
<p>If &quot;abbreviate&quot;, <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> function will be used. Use the optional
arguments for this function.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_cols">cols</code></td>
<td>
<p>Whether to shown color bars at leaves or not. It helps matching
this tree plot with other plots whose cluster membership were colored. It
only works when <code>text</code> is <code>TRUE</code>. Either <code>NULL</code>, a vector of one color, or
a vector of colors matching the number of leaves.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_rel.loc.x">rel.loc.x</code></td>
<td>
<p>Whether to use the relative distance between clusters as x
coordinate of the leaves. Default is TRUE.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_show.pval">show.pval</code></td>
<td>
<p>If MonoClust object has been run through <code><a href="#topic+perm.test">perm.test()</a></code>,
whether to show p-value on the tree.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_uniform">uniform</code></td>
<td>
<p>If TRUE, uniform vertical spacing of the nodes is used; this
may be less cluttered when fitting a large plot onto a page. The default is
to use a non-uniform spacing proportional to the inertia in the fit.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_minbranch">minbranch</code></td>
<td>
<p>Set the minimum length for a branch to <code>minbranch</code> times the
average branch length. This parameter is ignored if <code>uniform = TRUE</code>.
Sometimes a split will give very little improvement, or even no improvement
at all. A tree with branch lengths strictly proportional to improvement
leaves no room to squeeze in node labels.</p>
</td></tr>
<tr><td><code id="text_tree_+3A_...">...</code></td>
<td>
<p>Extra arguments that would be transferred to <code><a href="graphics.html#topic+text">graphics::text()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Labels on tree.
</p>

<hr>
<h2 id='to_deg_rad'>Transform Between Degree and Radian</h2><span id='topic+to_deg_rad'></span><span id='topic+torad'></span><span id='topic+todeg'></span>

<h3>Description</h3>

<p>This function transforms a circular angle from degree to radian or from
radian to degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torad(x)

todeg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_deg_rad_+3A_x">x</code></td>
<td>
<p>A degree value if <code>torad</code> or radian value if <code>todeg</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A radian value if <code>torad</code> or degree value if <code>todeg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>torad(90)

torad(-45)

todeg(pi/2)
</code></pre>

<hr>
<h2 id='tree_depth'>Find Tree Depth Based on Node Indexes</h2><span id='topic+tree_depth'></span>

<h3>Description</h3>

<p>Find Tree Depth Based on Node Indexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_depth(nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree_depth_+3A_nodes">nodes</code></td>
<td>
<p>Vector of node indexes in the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When building MonoClust tree, the node index was created with the rule that
new node indexes are the split node times 2 plus 0 (left) and 1 (right).
Therefore, this function is just a back-transform, taking a log base 2.
</p>


<h3>Value</h3>

<p>Depth of the node, with 0 is the root relative to the input.
</p>

<hr>
<h2 id='tree_walk'>Traverse a Tree to Find the Leaves (Terminal Nodes)</h2><span id='topic+tree_walk'></span>

<h3>Description</h3>

<p>Traverse a Tree to Find the Leaves (Terminal Nodes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_walk(new_point, jump_table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree_walk_+3A_new_point">new_point</code></td>
<td>
<p>New data point</p>
</td></tr>
<tr><td><code id="tree_walk_+3A_jump_table">jump_table</code></td>
<td>
<p>Jump table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of the terminal node after traversing the new data point on
the tree.
</p>

<hr>
<h2 id='wind_sensit_2007'>Existence of Microorganisms Carried in Wind</h2><span id='topic+wind_sensit_2007'></span>

<h3>Description</h3>

<p>Data set is a part of a study on microorganisms carried in strong f\&quot;ohn
winds at the Bonney Riegel location of Taylor Valley, an ice free area in the
Antarctic continent. Wind direction and wind speed data were obtained from
the meteorological station. Wind direction was recorded every 30 seconds and
wind speeds every 4 seconds at 1.15 meters above the ground surface. The
recorded wind directions and speeds were averaged at 15 minute intervals. For
wind direction, as discussed previously, winds from the north are defined as
0/360 degrees and from the east as 90 degrees. 2007 data were collected from
August 4&ndash;11, 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind_sensit_2007
</code></pre>


<h3>Format</h3>

<p>A data frame with 671 rows and 3 variables:
</p>

<dl>
<dt>has.sensit</dt><dd><p>A binary variable of the existence of particles in the
wind (1) or not (0).</p>
</dd>
<dt>WS</dt><dd><p>Wind speed measured in m/s.</p>
</dd>
<dt>WDIR</dt><dd><p>Wind direction in degree with 0 indicates &quot;from the north&quot; and
90 degrees indicate &quot;from the east&quot;.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sabacka, M., Priscu, J. C., Basagic, H. J., Fountain, A. G., Wall, D.
H., Virginia, R. A., and Greenwood, M. C. (2012). &quot;Aeolian flux of biotic and
abiotic material in Taylor Valley, Antarctica&quot;. In: Geomorphology 155-156,
pp. 102-111. issn: 0169555X. doi: <a href="https://doi.org/10.1016/j.geomorph.2011.12.009">10.1016/j.geomorph.2011.12.009</a>.
</p>

<hr>
<h2 id='wind_sensit_2008'>Existence of Microorganisms Carried in Wind</h2><span id='topic+wind_sensit_2008'></span>

<h3>Description</h3>

<p>Data set is a part of a study on microorganisms carried in strong f\&quot;ohn
winds at the Bonney Riegel location of Taylor Valley, an ice free area in the
Antarctic continent. Wind direction and wind speed data were obtained from
the meteorological station. Wind direction was recorded every 30 seconds and
wind speeds every 4 seconds at 1.15 meters above the ground surface. The
recorded wind directions and speeds were averaged at 15 minute intervals. For
wind direction, as discussed previously, winds from the north are defined as
0/360 degrees and from the east as 90 degrees. 2008 data were collected from
July 7&ndash;14, 2008.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind_sensit_2008
</code></pre>


<h3>Format</h3>

<p>A data frame with 673 rows and 3 variables:
</p>

<dl>
<dt>has.sensit</dt><dd><p>A binary variable of the existence of particles in the
wind (1) or not (0).</p>
</dd>
<dt>WS</dt><dd><p>Wind speed measured in m/s.</p>
</dd>
<dt>WDIR</dt><dd><p>Wind direction in degree with 0 indicates &quot;from the north&quot; and
90 degrees indicate &quot;from the east&quot;.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sabacka, M., Priscu, J. C., Basagic, H. J., Fountain, A. G., Wall, D.
H., Virginia, R. A., and Greenwood, M. C. (2012). &quot;Aeolian flux of biotic and
abiotic material in Taylor Valley, Antarctica&quot;. In: Geomorphology 155-156,
pp. 102-111. issn: 0169555X. doi: <a href="https://doi.org/10.1016/j.geomorph.2011.12.009">10.1016/j.geomorph.2011.12.009</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
