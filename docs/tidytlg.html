<!DOCTYPE html><html><head><title>Help for package tidytlg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidytlg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidytlg'><p>tidytlg: A package for producing tables, listings, and graphs (TLGs) using</p>
tidyverse packages.</a></li>
<li><a href='#add_format'><p>Add the formatting variables of <code>indentme</code>, <code>newrows</code>, <code>newpage</code>, and <code>roworder</code> to</p>
the results dataframe</a></li>
<li><a href='#add_indent'><p>Add indentation variable to the results dataframe</p></a></li>
<li><a href='#add_newrows'><p>Add the newrows variable to the results dataframe.</p></a></li>
<li><a href='#bind_table'><p>Bind a set of tidytlg tables together with formatting variables</p></a></li>
<li><a href='#cdisc adae'><p>ADAE data created from subsetting the CDISC ADAE dataset</p></a></li>
<li><a href='#cdisc adlb'><p>ADLB data created from subsetting the CDISC ADLB dataset</p></a></li>
<li><a href='#cdisc adsl'><p>ADSL data created from subsetting the CDISC ADSL with 15 subjects (5 subjects in each arm)</p></a></li>
<li><a href='#cdisc advs'><p>ADVS data created from subsetting the CDISC ADVS dataset</p></a></li>
<li><a href='#char2factor'><p>Convert character variable to a factor based off it's numeric variable</p>
counterpart.</a></li>
<li><a href='#column_metadata'><p>Metadata describing table column layouts</p></a></li>
<li><a href='#freq'><p>Frequency counts and percentages</p></a></li>
<li><a href='#generate_results'><p>Generate Results using Table and Column Metadata</p></a></li>
<li><a href='#gentlg'><p>Output a tidytlg table</p></a></li>
<li><a href='#nested_freq'><p>Generate nested count/percent for two or three levels</p></a></li>
<li><a href='#replace_na_with_blank'><p>Replace NA with &quot;&quot;</p></a></li>
<li><a href='#rmdpstitle'><p>Get Titles and Footnotes for all TLGs or one specific TLG</p></a></li>
<li><a href='#roundSAS'><p>SAS rounding in R</p></a></li>
<li><a href='#spanning_headers'><p>Spanning headers for outputs</p></a></li>
<li><a href='#statlist'><p>Create a statlist interface for a table</p></a></li>
<li><a href='#table_metadata'><p>Metadata describing the data, functions and arguments needed to produce your</p>
results.</a></li>
<li><a href='#tidytlg_titles'><p>Helper functions for returning files used in gentlg</p></a></li>
<li><a href='#tlgsetup'><p>Setup data to support the specified column type</p></a></li>
<li><a href='#univar'><p>Descriptive statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create TLGs using the 'tidyverse'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate tables, listings, and graphs (TLG) using 'tidyverse.'
  Tables can be created functionally, using a standard TLG process, or by
  specifying table and column metadata to create generic analysis summaries.
  The 'envsetup' package can also be leveraged to create environments for table
  creation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pharmaverse/tidytlg">https://github.com/pharmaverse/tidytlg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pharmaverse/tidytlg/issues">https://github.com/pharmaverse/tidytlg/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr (&ge; 1.23), rmarkdown (&ge; 2.10),
renv (&ge; 0.13.2), shiny (&ge; 1.3.2), kableExtra (&ge; 1.3.4),
haven (&ge; 2.4.1), withr (&ge; 2.3.0), devtools, writexl</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.4), tibble (&ge; 2.1.3), magrittr (&ge; 1.5), rlang
(&ge; 0.4.10), tidyr (&ge; 1.0.0), stats (&ge; 3.6.0), stringr (&ge;
1.4.0), forcats (&ge; 0.5.1), purrr (&ge; 0.3.4), huxtable (&ge;
5.1.0), assertthat (&ge; 0.2.1), glue (&ge; 1.4.2), usethis (&ge;
1.6.3), crayon (&ge; 1.4.1), tidyselect (&ge; 1.1.0), methods,
readxl (&ge; 1.3.1), cellranger (&ge; 1.1.0), png (&ge; 0.1-7),
ggplot2 (&ge; 3.3.2), rstudioapi (&ge; 0.13)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-18 14:13:01 UTC; eli.miller</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Masel [aut],
  Steven Haesendonckx [aut],
  Pelagia Alexandra Papadopoulou [aut],
  Sheng-Wei Wang [aut],
  Eli Miller <a href="https://orcid.org/0000-0002-2127-9456"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Nathan Kosiba <a href="https://orcid.org/0000-0001-5359-4234"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Aidan Ceney <a href="https://orcid.org/0000-0001-8313-487X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Janssen R&amp;D [cph, fnd],
  David Hugh-Jones [cph] (Author of included huxtable library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eli Miller &lt;eli.miller@atorusresearch.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-18 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidytlg'>tidytlg: A package for producing tables, listings, and graphs (TLGs) using
tidyverse packages.</h2><span id='topic+tidytlg'></span><span id='topic+tidytlg-package'></span>

<h3>Description</h3>

<p>The tidytlg package provide a set of function allowing you to produce TLGs
using table metadata.
</p>


<h3>tidytlg Options</h3>

 <ul>
<li><p>tidytlg.row_type.levels - The values of row_type and their
respective levels. Default: c(&quot;TABLE_BY_HEADER&quot;, &quot;BY_HEADER1&quot;, &quot;BY_HEADER2&quot;,
&quot;BY_HEADER3&quot;, &quot;BY_HEADER4&quot;, &quot;BY_HEADER5&quot;, &quot;HEADER&quot;, &quot;N&quot;, &quot;VALUE&quot;, &quot;NESTED&quot;)
</p>
</li>
<li><p>tidytlg.fontsize.title - Font size for titles in points. Default: 10
</p>
</li>
<li><p>tidytlg.fontsize.table.footnote - Font size for footnotes in points.
For tables. Default: 9 </p>
</li>
<li><p>tidytlg.fontsize.listing.footnote - Font size
for footnotes in points. For listings. Default: 8
</p>
</li>
<li><p>tidytlg.fontsize.graph.footnote - Font size for footnotes in points.
For graphs. Default: 8 </p>
</li>
<li><p>tidytlg.fontsize.table - Font size for tables
in points. Default: 9 </p>
</li>
<li><p>tidytlg.fontsize.graph - Font size for graphs in
points. Default: 10 </p>
</li>
<li><p>tidytlg.fontsize.listing - Font size for listings
in poins. Default: 8 </p>
</li>
<li><p>tidytlg.right.padding - Amount of right padding
for cells in points. Default: 1 </p>
</li>
<li><p>tidytlg.left.padding - Amount of left
padding for cells in points. Default: 1 </p>
</li>
<li><p>tidytlg.stat_labels - Labels
to be used for each summary statistic in the output table.  Will need to have
all available statistics if this option is changed!
</p>
</li>
<li><p>tidytlg.precision.extra - Value to be added on for each summary
statistic when calculating precision.  This will be used to make different
statistics have different precision as needed
</p>
</li>
<li><p>tidytlg.nested_freq.statlist.default - Default statlist object for
nested_freq tables. Default: statlist(&quot;n (x.x)&quot;)
</p>
</li>
<li><p>tidytlg.univar.statlist.default - Default statlist object for univar
tables. Default: statlist(c(&quot;N&quot;, &quot;MEANSD&quot;, &quot;MEDIAN&quot;, &quot;RANGE&quot;, &quot;IQRANGE&quot;))
</p>
</li>
<li><p>tidytlg.freq.statlist.default - Default statlist object for freq
tables. Default: statlist(&quot;n (x.x)&quot;) </p>
</li>
<li><p>tidytlg.stat_labels - A
data.frame controlling how the stats are labeled in a univar table. See
'Default Stat Labels' section for defaults. </p>
</li>
<li><p>tidytlg.denoms.message - A
boolean, should a message print detailing what the denominators are?
</p>
</li></ul>



<h3>Default Stat Labels</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>stat</strong> </td><td style="text-align: left;"> <strong>label</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   N </td><td style="text-align: left;"> N </td>
</tr>
<tr>
 <td style="text-align: left;">
   SUM </td><td style="text-align: left;"> Sum </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEAN </td><td style="text-align: left;"> Mean </td>
</tr>
<tr>
 <td style="text-align: left;">
   GeoMEAN </td><td style="text-align: left;"> Geometric Mean </td>
</tr>
<tr>
 <td style="text-align: left;">
   SD </td><td style="text-align: left;"> Std. Dev. </td>
</tr>
<tr>
 <td style="text-align: left;">
   SE </td><td style="text-align: left;"> Std. Error </td>
</tr>
<tr>
 <td style="text-align: left;">
   GSD </td><td style="text-align: left;"> Geometric Std. Dev. </td>
</tr>
<tr>
 <td style="text-align: left;">
   GSE </td><td style="text-align: left;"> Geometric Std. Error </td>
</tr>
<tr>
 <td style="text-align: left;">
   CV </td><td style="text-align: left;"> CV </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEANSD </td><td style="text-align: left;"> Mean (SD) </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEANSE </td><td style="text-align: left;"> Mean (SE) </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEDIAN </td><td style="text-align: left;"> Median </td>
</tr>
<tr>
 <td style="text-align: left;">
   MIN </td><td style="text-align: left;"> Minimum </td>
</tr>
<tr>
 <td style="text-align: left;">
   MAX </td><td style="text-align: left;"> Maximum </td>
</tr>
<tr>
 <td style="text-align: left;">
   RANGE </td><td style="text-align: left;"> Range </td>
</tr>
<tr>
 <td style="text-align: left;">
   Q1 </td><td style="text-align: left;"> First quartile </td>
</tr>
<tr>
 <td style="text-align: left;">
   Q3 </td><td style="text-align: left;"> Third quartile </td>
</tr>
<tr>
 <td style="text-align: left;">
   IQRANGE </td><td style="text-align: left;"> IQ range </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEDRANGE </td><td style="text-align: left;"> Median (Range) </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEDIQRANGE </td><td style="text-align: left;"> Median (Q1; Q3) </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEAN_CI </td><td style="text-align: left;"> Mean (95% C.I.) </td>
</tr>
<tr>
 <td style="text-align: left;">
   GeoMEAN_CI </td><td style="text-align: left;"> Geometric Mean (95% C.I.) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Default Precision Extra</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>stat</strong> </td><td style="text-align: left;"> <strong>extra</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   N </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SUM </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEAN </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   GeoMEAN </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SD </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SE </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   GSD </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   GSE </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   CV </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MEDIAN </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MIN </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MAX </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Q1 </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Q3 </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   LCL_MEAN </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   UCL_MEAN </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   LCL_GeoMEAN </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   UCL_GeoMEAN </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Updating Options</h3>


<ul>
<li><p>For a single session, an option can be changed by
<code style="white-space: pre;">&#8288;option(&lt;optionToChange&gt; = &lt;NewValue&gt;)&#8288;</code>
</p>
</li>
<li><p>To change an option for a single projects across sessions in that
projects, place the options update in the <code>.Rprofile</code> in that project
directory.
</p>
</li>
<li><p>To change an option for a user across all sessions, place the options
update in the <code>.Rprofile</code> file in the users home directory.
</p>
</li>
<li><p>To change an option for all users in an R environment, place the
options update in the <code>.Rprofile.site</code> file in the R home directory.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eli Miller <a href="mailto:eli.miller@atorusresearch.com">eli.miller@atorusresearch.com</a> (<a href="https://orcid.org/0000-0002-2127-9456">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Nicholas Masel <a href="mailto:nmasel@its.jnj.com">nmasel@its.jnj.com</a>
</p>
</li>
<li><p> Steven Haesendonckx <a href="mailto:shaesen2@its.jnj.com">shaesen2@its.jnj.com</a>
</p>
</li>
<li><p> Pelagia Alexandra Papadopoulou <a href="mailto:ppapadop@its.jnj.com">ppapadop@its.jnj.com</a>
</p>
</li>
<li><p> Sheng-Wei Wang <a href="mailto:swang69@its.jnj.com">swang69@its.jnj.com</a>
</p>
</li>
<li><p> Nathan Kosiba <a href="mailto:nkosiba@its.jnj.com">nkosiba@its.jnj.com</a> (<a href="https://orcid.org/0000-0001-5359-4234">ORCID</a>)
</p>
</li>
<li><p> Aidan Ceney <a href="mailto:aceney@its.jnj.com">aceney@its.jnj.com</a> (<a href="https://orcid.org/0000-0001-8313-487X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Janssen R&amp;D [copyright holder, funder]
</p>
</li>
<li><p> David Hugh-Jones (Author of included huxtable library) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/pharmaverse/tidytlg">https://github.com/pharmaverse/tidytlg</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pharmaverse/tidytlg/issues">https://github.com/pharmaverse/tidytlg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_format'>Add the formatting variables of <code>indentme</code>, <code>newrows</code>, <code>newpage</code>, and <code>roworder</code> to
the results dataframe</h2><span id='topic+add_format'></span>

<h3>Description</h3>

<p>Add the formatting variables of <code>indentme</code>, <code>newrows</code>, <code>newpage</code>, and <code>roworder</code> to
the results dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_format(df, tableby = NULL, groupby = NULL, .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_format_+3A_df">df</code></td>
<td>
<p>(required) dataframe of results and must contain the <code>anbr</code> variable</p>
</td></tr>
<tr><td><code id="add_format_+3A_tableby">tableby</code></td>
<td>
<p>(optional) character vector containing table by variables</p>
</td></tr>
<tr><td><code id="add_format_+3A_groupby">groupby</code></td>
<td>
<p>(optional) character vector containing group by variables</p>
</td></tr>
<tr><td><code id="add_format_+3A_.keep">.keep</code></td>
<td>
<p>(optional) should <code>tableby</code> and <code>groupby</code> variables be kept in the
final dataframe.  (default = FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with the formatting variables indentme, newrows, newpage, and roworder added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(row_type =
      c("TABLE_BY_HEADER", "HEADER", "BY_HEADER1", "N", "VALUE",
                                   "COUNTS", "UNIVAR", "NESTED", "NESTED"),
        nested_level =  c(NA, NA, NA, NA, NA, NA, NA, 1, 2),
        group_level =  c(0, 0, 0, 0, 0, 0, 0, 0, 0),
        label        =  c(NA, NA, NA, NA, NA, "N",NA, NA, NA),
        by           =  c(NA, NA, NA, NA, NA, NA, NA, NA, NA),
        tableby      =  c(NA, NA, NA, NA, NA, NA, NA, NA, NA),
        anbr      =  c(1:9))
add_format(df)
</code></pre>

<hr>
<h2 id='add_indent'>Add indentation variable to the results dataframe</h2><span id='topic+add_indent'></span>

<h3>Description</h3>

<p>Add the <code>indentme</code> variable to your results data. This drives the number of
indents for the row label text (e.g. 0, 1, 2, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_indent(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_indent_+3A_df">df</code></td>
<td>
<p>dataframe of results that contains <code>row_type</code> and <code>label</code>
and the optional <code>nested_level</code> and <code>group_level</code> variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>group_level</code> variable, which is added to the results dataframe by <code>freq()</code>
and <code>univar()</code> calls, is needed to define indentation when by variables are
used for summary.
</p>
<p>The <code>nested_level</code> variable, which is added to the results dataframe by
<code>nested_freq()</code>, is needed to define indentation for each level of nesting.
</p>
<p>Both of these are added to the default indentation which is driven by
<code>row_type</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   row_type </td><td style="text-align: center;"> default indentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   TABLE_BY_HEADER </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   BY_HEADER[1-9] </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   HEADER </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   N </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   VALUE </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   NESTED </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>dataframe with the <code>indentme</code> variable added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(row_type     =  c("TABLE_BY_HEADER", "HEADER",
       "BY_HEADER1", "N", "VALUE", "COUNTS", "UNIVAR", "NESTED", "NESTED"),
                     nested_level =  c(NA, NA, NA, NA, NA, NA, NA, 1, 2),
                     group_level =  c(0, 0, 0, 0, 0, 0, 0, 0, 0),
                     label        =  c(NA, NA, NA, NA, NA, "N",NA, NA, NA),
                     by           =  c(NA, NA, NA, NA, NA, NA, NA, NA, NA),
                     tableby      =  c(NA, NA, NA, NA, NA, NA, NA, NA, NA))
add_indent(df)
</code></pre>

<hr>
<h2 id='add_newrows'>Add the newrows variable to the results dataframe.</h2><span id='topic+add_newrows'></span>

<h3>Description</h3>

<p>The newrows variable is used by <code>gentlg()</code> to define when to add a blank row
to the output. Data will be grouped by anbr and the variables passed into
the tableby and groupby parameters.<code>newrows</code> will be set to 1 for the first
record in each group, except for the first row in the data.
The first row will always be set to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_newrows(df, tableby = NULL, groupby = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_newrows_+3A_df">df</code></td>
<td>
<p>dataframe of results.  must contain the anbr variable that is
added by add_format()</p>
</td></tr>
<tr><td><code id="add_newrows_+3A_tableby">tableby</code></td>
<td>
<p>character vector containing table by variables used to
generate the results</p>
</td></tr>
<tr><td><code id="add_newrows_+3A_groupby">groupby</code></td>
<td>
<p>character vector containing group by variables used to
generate the results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with the variable newrows and roworder added.
newrows is used by gentlg to insert line breaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example showing how newrows is set to one for each new anbr except
# the first
tbl &lt;-
  structure(
    list(rowvar = c("RANDFL", "AGE", "AGE", "AGE", "AGE", "AGE"),
     anbr   = c(1L, 2L, 2L, 2L, 2L, 2L),
     label  = c("Analysis set: Subjects Randomized", "Age (Years)", "N",
     "Mean (SD)", "Range", "IQ Range"),
     row_type = c("COUNT", "UNIVAR", "UNIVAR", "UNIVAR", "UNIVAR", "UNIVAR")
      ),
    row.names = c(NA,-6L),
    class = c("tbl_df", "tbl", "data.frame")
  )

add_newrows(tbl)

# Example of use when you have results summarized by one or more variables
tbl2 &lt;- tibble::tribble(
  ~anbr, ~SEX,    ~label,         ~row_type,
  "01",  "F", "Sex : F", "TABLE_BY_HEADER",
  "01",  "F",     "&lt;65",           "VALUE",
  "01",  "F",   "65-80",           "VALUE",
  "01",  "F",     "&gt;80",           "VALUE",
  "01",  "M", "Sex : M", "TABLE_BY_HEADER",
  "01",  "M",     "&lt;65",           "VALUE",
  "01",  "M",   "65-80",           "VALUE",
  "01",  "M",     "&gt;80",           "VALUE"
)

add_newrows(tbl2, tableby = "SEX")

tbl3 &lt;- tibble::tribble(
~anbr, ~SEX,           ~ETHNIC,                  ~label,         ~row_type,
 "01",  "F",                NA,                "Sex : F", "TABLE_BY_HEADER",
 "01",  "F", "HISPANIC OR LATINO", "HISPANIC OR LATINO",      "BY_HEADER1",
 "01",  "F", "HISPANIC OR LATINO",               "&lt;65",           "VALUE",
 "01",  "F", "HISPANIC OR LATINO",               "&gt;80",           "VALUE",
 "01",  "F", "HISPANIC OR LATINO",             "65-80",           "VALUE",
 "01", "F", "NOT HISPANIC OR LATINO", "NOT HISPANIC OR LATINO", "BY_HEADER1",
 "01", "F", "NOT HISPANIC OR LATINO",                    "&lt;65",      "VALUE",
 "01", "F", "NOT HISPANIC OR LATINO",                  "65-80",      "VALUE",
 "01", "F", "NOT HISPANIC OR LATINO",                    "&gt;80",      "VALUE",
 "01", "M",                       NA,           "Sex : M", "TABLE_BY_HEADER",
 "01", "M",    "HISPANIC OR LATINO",   "HISPANIC OR LATINO",    "BY_HEADER1",
 "01", "M",    "HISPANIC OR LATINO",                  "&lt;65",         "VALUE",
 "01", "M",    "HISPANIC OR LATINO",                "65-80",         "VALUE",
 "01", "M",     "HISPANIC OR LATINO",               "&gt;80",           "VALUE",
 "01", "M", "NOT HISPANIC OR LATINO", "NOT HISPANIC OR LATINO", "BY_HEADER1",
 "01", "M", "NOT HISPANIC OR LATINO",              "&lt;65",           "VALUE",
 "01",  "M", "NOT HISPANIC OR LATINO",            "65-80",           "VALUE",
 "01",  "M", "NOT HISPANIC OR LATINO",              "&gt;80",           "VALUE"
)

add_newrows(tbl3, tableby = "SEX", groupby = "ETHNIC")
</code></pre>

<hr>
<h2 id='bind_table'>Bind a set of tidytlg tables together with formatting variables</h2><span id='topic+bind_table'></span>

<h3>Description</h3>

<p>bind_table combines analysis results with formatting variables (indentme, newrows, newpage)
based on by variables (tablebyvar, rowbyvar), such that appropriate formatting (indentation,
line break, page break) can be applied in creating the output. It can also attach the column
metadata attribute, which will be automatically used in <code>gentlg</code> for creating output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_table(
  ...,
  colvar = NULL,
  tablebyvar = NULL,
  rowbyvar = NULL,
  prefix = NULL,
  add_count = FALSE,
  add_format = TRUE,
  column_metadata_file = NULL,
  column_metadata = NULL,
  tbltype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_table_+3A_...">...</code></td>
<td>
<p>(required) a set of tidytlg tables to bind together</p>
</td></tr>
<tr><td><code id="bind_table_+3A_colvar">colvar</code></td>
<td>
<p>(required) treatment variable within df to use to summarize.
Required if <code>add_count</code> is TRUE.</p>
</td></tr>
<tr><td><code id="bind_table_+3A_tablebyvar">tablebyvar</code></td>
<td>
<p>(optional) repeat entire table by variable within df</p>
</td></tr>
<tr><td><code id="bind_table_+3A_rowbyvar">rowbyvar</code></td>
<td>
<p>(optional) any rowbyvar values used to create the table</p>
</td></tr>
<tr><td><code id="bind_table_+3A_prefix">prefix</code></td>
<td>
<p>(optional) text to prefix the values of tablebyvar with</p>
</td></tr>
<tr><td><code id="bind_table_+3A_add_count">add_count</code></td>
<td>
<p>(optional) Should a count be included in the tablebyvar?
(default = TRUE)</p>
</td></tr>
<tr><td><code id="bind_table_+3A_add_format">add_format</code></td>
<td>
<p>(optional) Should format be added to the output table?
This is done using the add_format function. (default = TRUE)</p>
</td></tr>
<tr><td><code id="bind_table_+3A_column_metadata_file">column_metadata_file</code></td>
<td>
<p>(optional) An excel file for column_metadata.
Does not change the behavior of the function binds the column metadata
for <code>gentlg</code>. If a column_metadata dataframe is passed in too,
this is ignored.</p>
</td></tr>
<tr><td><code id="bind_table_+3A_column_metadata">column_metadata</code></td>
<td>
<p>(optional) A dataframe containing the column metadata.
This will be used in place of column_metadata_file.</p>
</td></tr>
<tr><td><code id="bind_table_+3A_tbltype">tbltype</code></td>
<td>
<p>(optional) A value used to subset the column_metadata_file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tidytlg tables bound together reflecting the tablebyvars used
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# bind tables together
t1 &lt;- cdisc_adsl %&gt;%
  freq(colvar = "TRT01PN",
       rowvar = "ITTFL",
       statlist = statlist("n"),
       subset = ITTFL == "Y",
       rowtext = "Analysis set: ITT")

t2 &lt;- cdisc_adsl %&gt;%
  univar(colvar = "TRT01PN",
         rowvar = "AGE",
         decimal = 0,
         row_header = "Age, years")

bind_table(t1, t2)

# bind tables together w/by groups
t1 &lt;- cdisc_adsl %&gt;%
  freq(colvar = "TRT01PN",
       rowvar = "ITTFL",
       rowbyvar = "SEX",
       statlist = statlist("n"),
       subset = ITTFL == "Y",
       rowtext = "Analysis set: ITT")

t2 &lt;- cdisc_adsl %&gt;%
  univar(colvar = "TRT01PN",
         rowvar = "AGE",
         rowbyvar = "SEX",
         decimal = 0,
         row_header = "Age, years")

bind_table(t1, t2, rowbyvar = "SEX")

# bind tables together w/table by groups
t1 &lt;- cdisc_adsl %&gt;%
  freq(colvar = "TRT01PN",
       rowvar = "ITTFL",
       tablebyvar = "SEX",
       statlist = statlist("n"),
       subset = ITTFL == "Y",
       rowtext = "Analysis set: ITT")

t2 &lt;- cdisc_adsl %&gt;%
  univar(colvar = "TRT01PN",
         rowvar = "AGE",
         tablebyvar = "SEX",
         decimal = 0,
         row_header = "Age, years")

bind_table(t1, t2, tablebyvar = "SEX")

# w/prefix
bind_table(t1, t2, tablebyvar = "SEX", prefix = "Gender: ")

# w/counts
bind_table(t1, t2, tablebyvar = "SEX", add_count = TRUE, colvar = "TRT01PN")
</code></pre>

<hr>
<h2 id='cdisc+20adae'>ADAE data created from subsetting the CDISC ADAE dataset</h2><span id='topic+cdisc+20adae'></span><span id='topic+cdisc_adae'></span>

<h3>Description</h3>

<p>ADAE data created from subsetting the CDISC ADAE dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdisc_adae
</code></pre>


<h3>Format</h3>

<p>A data frame with 84 rows and 55 variables:
</p>

<dl>
<dt>STUDYID</dt><dd><p>Study Identifier</p>
</dd>
<dt>SITEID</dt><dd><p>Study Site Identifier</p>
</dd>
<dt>USUBJID</dt><dd><p>Unique Subject Identifier</p>
</dd>
<dt>SUBJID</dt><dd><p>Subject Identifier for the Study</p>
</dd>
<dt>TRTA</dt><dd><p>Actual Treatment</p>
</dd>
<dt>TRTAN</dt><dd><p>Actual Treatment (N)</p>
</dd>
<dt>AGE</dt><dd><p>Age</p>
</dd>
<dt>AGEGR1</dt><dd><p>Pooled Age Group 1</p>
</dd>
<dt>AGEGR1N</dt><dd><p>Pooled Age Group 1 (N)</p>
</dd>
<dt>RACE</dt><dd><p>Race</p>
</dd>
<dt>RACEN</dt><dd><p>Race (N)</p>
</dd>
<dt>SEX</dt><dd><p>Sex</p>
</dd>
<dt>SAFFL</dt><dd><p>Safety Population Flag</p>
</dd>
<dt>TRTSDT</dt><dd><p>Date of First Exposure to Treatment</p>
</dd>
<dt>TRTEDT</dt><dd><p>Date of Last Exposure to Treatment</p>
</dd>
<dt>ASTDT</dt><dd><p>Analysis Start Date</p>
</dd>
<dt>ASTDTF</dt><dd><p>Analysis Start Date Imputation Flag</p>
</dd>
<dt>ASTDY</dt><dd><p>Analysis Start Relative Day</p>
</dd>
<dt>AENDT</dt><dd><p>Analysis End Date</p>
</dd>
<dt>AENDY</dt><dd><p>Analysis End Relative Day</p>
</dd>
<dt>ADURN</dt><dd><p>AE Duration (N)</p>
</dd>
<dt>ADURU</dt><dd><p>AE Duration Units</p>
</dd>
<dt>AETERM</dt><dd><p>Reported Term for the Adverse Event</p>
</dd>
<dt>AELLT</dt><dd><p>Lowest Level Term</p>
</dd>
<dt>AELLTCD</dt><dd><p>Lowest Level Term Code</p>
</dd>
<dt>AEDECOD</dt><dd><p>Dictionary-Derived Term</p>
</dd>
<dt>AEPTCD</dt><dd><p>Preferred Term Code</p>
</dd>
<dt>AEHLT</dt><dd><p>High Level Term</p>
</dd>
<dt>AEHLTCD</dt><dd><p>High Level Term Code</p>
</dd>
<dt>AEHLGT</dt><dd><p>High Level Group Term</p>
</dd>
<dt>AEHLGTCD</dt><dd><p>High Level Group Term Code</p>
</dd>
<dt>AEBODSYS</dt><dd><p>Body System or Organ Class</p>
</dd>
<dt>AESOC</dt><dd><p>Primary System Organ Class</p>
</dd>
<dt>AESOCCD</dt><dd><p>Primary System Organ Class Code</p>
</dd>
<dt>AESEV</dt><dd><p>Severity/Intensity</p>
</dd>
<dt>AESER</dt><dd><p>Serious Event</p>
</dd>
<dt>AESCAN</dt><dd><p>Involves Cancer</p>
</dd>
<dt>AESCONG</dt><dd><p>Congenital Anomaly or Birth Defect</p>
</dd>
<dt>AESDISAB</dt><dd><p>Persist or Signif Disability/Incapacity</p>
</dd>
<dt>AESDTH</dt><dd><p>Results in Death</p>
</dd>
<dt>AESHOSP</dt><dd><p>Requires or Prolongs Hospitalization</p>
</dd>
<dt>AESLIFE</dt><dd><p>Is Life Threatening</p>
</dd>
<dt>AESOD</dt><dd><p>Occurred with Overdose</p>
</dd>
<dt>AEREL</dt><dd><p>Causality</p>
</dd>
<dt>AEACN</dt><dd><p>Action Taken with Study Treatment</p>
</dd>
<dt>AEOUT</dt><dd><p>Outcome of Adverse Event</p>
</dd>
<dt>AESEQ</dt><dd><p>Sequence Number</p>
</dd>
<dt>TRTEMFL</dt><dd><p>Treatment Emergent Analysis Flag</p>
</dd>
<dt>AOCCFL</dt><dd><p>1st Occurrence of Any AE Flag</p>
</dd>
<dt>AOCCSFL</dt><dd><p>1st Occurrence of SOC Flag</p>
</dd>
<dt>AOCCPFL</dt><dd><p>1st Occurrence of Preferred Term Flag</p>
</dd>
<dt>AOCC02FL</dt><dd><p>1st Occurrence 02 Flag for Serious</p>
</dd>
<dt>AOCC03FL</dt><dd><p>1st Occurrence 03 Flag for Serious SOC</p>
</dd>
<dt>AOCC04FL</dt><dd><p>1st Occurrence 04 Flag for Serious PT</p>
</dd>
<dt>CQ01NAM</dt><dd><p>Customized Query 01 Name</p>
</dd>
<dt>AOCC01FL</dt><dd><p>1st Occurrence 01 Flag for CQ01</p>
</dd>
</dl>



<h3>Source</h3>

<p>CDISC SDTM/ADAM Pilot Project.
</p>

<hr>
<h2 id='cdisc+20adlb'>ADLB data created from subsetting the CDISC ADLB dataset</h2><span id='topic+cdisc+20adlb'></span><span id='topic+cdisc_adlb'></span>

<h3>Description</h3>

<p>ADLB data created from subsetting the CDISC ADLB dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdisc_adlb
</code></pre>


<h3>Format</h3>

<p>A data frame with 2154 rows and 46 variables:
</p>

<dl>
<dt>STUDYID</dt><dd><p>Study Identifier</p>
</dd>
<dt>SUBJID</dt><dd><p>Subject Identifier for the Study</p>
</dd>
<dt>USUBJID</dt><dd><p>Unique Subject Identifier</p>
</dd>
<dt>TRTA</dt><dd><p>Actual Treatment</p>
</dd>
<dt>TRTAN</dt><dd><p>Actual Treatment (N)</p>
</dd>
<dt>TRTSDT</dt><dd><p>Date of First Exposure to Treatment</p>
</dd>
<dt>TRTEDT</dt><dd><p>Date of Last Exposure to Treatment</p>
</dd>
<dt>AGE</dt><dd><p>Age</p>
</dd>
<dt>AGEGR1</dt><dd><p>Pooled Age Group 1</p>
</dd>
<dt>AGEGR1N</dt><dd><p>Pooled Age Group 1 (N)</p>
</dd>
<dt>RACE</dt><dd><p>Race</p>
</dd>
<dt>RACEN</dt><dd><p>Race (N)</p>
</dd>
<dt>SEX</dt><dd><p>Sex</p>
</dd>
<dt>COMP24FL</dt><dd><p>Completers of Week 24 Population Flag</p>
</dd>
<dt>DSRAEFL</dt><dd><p>Discontinued due to AE?</p>
</dd>
<dt>SAFFL</dt><dd><p>Safety Population Flag</p>
</dd>
<dt>AVISIT</dt><dd><p>Analysis Visit</p>
</dd>
<dt>AVISITN</dt><dd><p>Analysis Visit (N)</p>
</dd>
<dt>ADY</dt><dd><p>Analysis Relative Day</p>
</dd>
<dt>ADT</dt><dd><p>Analysis Date</p>
</dd>
<dt>VISIT</dt><dd><p>Visit Name</p>
</dd>
<dt>VISITNUM</dt><dd><p>Visit Number</p>
</dd>
<dt>PARAM</dt><dd><p>Parameter</p>
</dd>
<dt>PARAMCD</dt><dd><p>Parameter Code</p>
</dd>
<dt>PARAMN</dt><dd><p>Parameter (N)</p>
</dd>
<dt>PARCAT1</dt><dd><p>Parameter Category 1</p>
</dd>
<dt>AVAL</dt><dd><p>Analysis Value</p>
</dd>
<dt>BASE</dt><dd><p>Baseline Value</p>
</dd>
<dt>CHG</dt><dd><p>Change from Baseline</p>
</dd>
<dt>A1LO</dt><dd><p>Analysis Range 1 Lower Limit</p>
</dd>
<dt>A1HI</dt><dd><p>Analysis Range 1 Upper Limit</p>
</dd>
<dt>R2A1LO</dt><dd><p>Ratio to Analysis Range 1 Lower Limit</p>
</dd>
<dt>R2A1HI</dt><dd><p>Ratio to Analysis Range 1 Upper Limit</p>
</dd>
<dt>BR2A1LO</dt><dd><p>Base Ratio to Analysis Range 1 Lower Lim</p>
</dd>
<dt>BR2A1HI</dt><dd><p>Base Ratio to Analysis Range 1 Upper Lim</p>
</dd>
<dt>ANL01FL</dt><dd><p>Analysis 01 - Special Interest Flag</p>
</dd>
<dt>ALBTRVAL</dt><dd><p>Amount Threshold Range</p>
</dd>
<dt>ANRIND</dt><dd><p>Analysis Reference Range Indicator</p>
</dd>
<dt>BNRIND</dt><dd><p>Baseline Reference Range Indicator</p>
</dd>
<dt>ABLFL</dt><dd><p>Baseline Record Flag</p>
</dd>
<dt>AENTMTFL</dt><dd><p>Last value in treatment visit</p>
</dd>
<dt>LBSEQ</dt><dd><p>Sequence Number</p>
</dd>
<dt>LBNRIND</dt><dd><p>Reference Range Indicator</p>
</dd>
<dt>LBSTRESN</dt><dd><p>Numeric Result/Finding in Standard Units</p>
</dd>
</dl>



<h3>Source</h3>

<p>CDISC SDTM/ADAM Pilot Project.
</p>

<hr>
<h2 id='cdisc+20adsl'>ADSL data created from subsetting the CDISC ADSL with 15 subjects (5 subjects in each arm)</h2><span id='topic+cdisc+20adsl'></span><span id='topic+cdisc_adsl'></span>

<h3>Description</h3>

<p>ADSL data created from subsetting the CDISC ADSL with 15 subjects (5 subjects in each arm)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdisc_adsl
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 rows and 49 variables:
</p>

<dl>
<dt>STUDYID</dt><dd><p>Study Identifier</p>
</dd>
<dt>USUBJID</dt><dd><p>Unique Subject Identifier</p>
</dd>
<dt>SUBJID</dt><dd><p>Subject Identifier for the Study</p>
</dd>
<dt>SITEID</dt><dd><p>Study Site Identifier</p>
</dd>
<dt>SITEGR1</dt><dd><p>Pooled Site Group 1</p>
</dd>
<dt>ARM</dt><dd><p>Description of Planned Arm</p>
</dd>
<dt>TRT01P</dt><dd><p>Planned Treatment for Period 01</p>
</dd>
<dt>TRT01PN</dt><dd><p>Planned Treatment for Period 01 (N)</p>
</dd>
<dt>TRT01A</dt><dd><p>Actual Treatment for Period 01</p>
</dd>
<dt>TRT01AN</dt><dd><p>Actual Treatment for Period 01 (N)</p>
</dd>
<dt>TRTSDT</dt><dd><p>Date of First Exposure to Treatment</p>
</dd>
<dt>TRTEDT</dt><dd><p>Date of Last Exposure to Treatment</p>
</dd>
<dt>TRTDUR</dt><dd><p>Duration of Treatment (days)</p>
</dd>
<dt>AVGDD</dt><dd><p>Avg Daily Dose (as planned)</p>
</dd>
<dt>CUMDOSE</dt><dd><p>Cumulative Dose (as planned)</p>
</dd>
<dt>AGE</dt><dd><p>Age</p>
</dd>
<dt>AGEGR1</dt><dd><p>Pooled Age Group 1</p>
</dd>
<dt>AGEGR1N</dt><dd><p>Pooled Age Group 1 (N)</p>
</dd>
<dt>AGEU</dt><dd><p>Age Units</p>
</dd>
<dt>RACE</dt><dd><p>Race</p>
</dd>
<dt>RACEN</dt><dd><p>Race (N)</p>
</dd>
<dt>SEX</dt><dd><p>Sex</p>
</dd>
<dt>ETHNIC</dt><dd><p>Ethnicity</p>
</dd>
<dt>SAFFL</dt><dd><p>Safety Population Flag</p>
</dd>
<dt>ITTFL</dt><dd><p>Intent-To-Treat Population Flag</p>
</dd>
<dt>EFFFL</dt><dd><p>Efficacy Population Flag</p>
</dd>
<dt>COMP8FL</dt><dd><p>Completers of Week 8 Population Flag</p>
</dd>
<dt>COMP16FL</dt><dd><p>Completers of Week 16 Population Flag</p>
</dd>
<dt>COMP24FL</dt><dd><p>Completers of Week 24 Population Flag</p>
</dd>
<dt>DISCONFL</dt><dd><p>Did the Subject Discontinue the Study?</p>
</dd>
<dt>DSRAEFL</dt><dd><p>Discontinued due to AE?</p>
</dd>
<dt>DTHFL</dt><dd><p>Subject Died?</p>
</dd>
<dt>BMIBL</dt><dd><p>Baseline BMI (kg/m^2)</p>
</dd>
<dt>BMIBLGR1</dt><dd><p>Pooled Baseline BMI Group 1</p>
</dd>
<dt>HEIGHTBL</dt><dd><p>Baseline Height (cm)</p>
</dd>
<dt>WEIGHTBL</dt><dd><p>Baseline Weight (kg)</p>
</dd>
<dt>EDUCLVL</dt><dd><p>Years of Education</p>
</dd>
<dt>DISONSDT</dt><dd><p>Date of Onset of Disease</p>
</dd>
<dt>DURDIS</dt><dd><p>Duration of Disease (Months)</p>
</dd>
<dt>DURDSGR1</dt><dd><p>Pooled Disease Duration Group 1</p>
</dd>
<dt>VISIT1DT</dt><dd><p>Date of Visit 1</p>
</dd>
<dt>RFSTDTC</dt><dd><p>Subject Reference Start Date/Time</p>
</dd>
<dt>RFENDTC</dt><dd><p>Subject Reference End Date/Time</p>
</dd>
<dt>VISNUMEN</dt><dd><p>End of Trt Visit (Vis 12 or Early Term.)</p>
</dd>
<dt>RFENDT</dt><dd><p>Date of Discontinuation/Completion</p>
</dd>
<dt>DCDECOD</dt><dd><p>Standardized Disposition Term</p>
</dd>
<dt>EOSSTT</dt><dd><p>End of Study Status</p>
</dd>
<dt>DCREASCD</dt><dd><p>Reason for Discontinuation</p>
</dd>
<dt>MMSETOT</dt><dd><p>MMSE Total</p>
</dd>
</dl>



<h3>Source</h3>

<p>CDISC SDTM/ADAM Pilot Project.
</p>

<hr>
<h2 id='cdisc+20advs'>ADVS data created from subsetting the CDISC ADVS dataset</h2><span id='topic+cdisc+20advs'></span><span id='topic+cdisc_advs'></span>

<h3>Description</h3>

<p>ADVS data created from subsetting the CDISC ADVS dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdisc_advs
</code></pre>


<h3>Format</h3>

<p>A data frame with 1938 rows and 35 variables:
</p>

<dl>
<dt>STUDYID</dt><dd><p>Study Identifier</p>
</dd>
<dt>SITEID</dt><dd><p>Study Site Identifier</p>
</dd>
<dt>USUBJID</dt><dd><p>Unique Subject Identifier</p>
</dd>
<dt>AGE</dt><dd><p>Age</p>
</dd>
<dt>AGEGR1</dt><dd><p>Pooled Age Group 1</p>
</dd>
<dt>AGEGR1N</dt><dd><p>Pooled Age Group 1 (N)</p>
</dd>
<dt>RACE</dt><dd><p>Race</p>
</dd>
<dt>RACEN</dt><dd><p>Race (N)</p>
</dd>
<dt>SEX</dt><dd><p>Sex</p>
</dd>
<dt>SAFFL</dt><dd><p>Safety Population Flag</p>
</dd>
<dt>TRTSDT</dt><dd><p>Date of First Exposure to Treatment</p>
</dd>
<dt>TRTEDT</dt><dd><p>Date of Last Exposure to Treatment</p>
</dd>
<dt>TRTP</dt><dd><p>Planned  Treatment</p>
</dd>
<dt>TRTPN</dt><dd><p>Planned  Treatment (N)</p>
</dd>
<dt>TRTA</dt><dd><p>Actual Treatment</p>
</dd>
<dt>TRTAN</dt><dd><p>Actual Treatment (N)</p>
</dd>
<dt>PARAMCD</dt><dd><p>Parameter Code</p>
</dd>
<dt>PARAM</dt><dd><p>Parameter</p>
</dd>
<dt>PARAMN</dt><dd><p>Parameter (N)</p>
</dd>
<dt>ADT</dt><dd><p>Analysis Date</p>
</dd>
<dt>ADY</dt><dd><p>Analysis Relative Day</p>
</dd>
<dt>ATPTN</dt><dd><p>Analysis Timepoint (N)</p>
</dd>
<dt>ATPT</dt><dd><p>Analysis Timepoint</p>
</dd>
<dt>AVISIT</dt><dd><p>Analysis Visit</p>
</dd>
<dt>AVISITN</dt><dd><p>Analysis Visit (N)</p>
</dd>
<dt>AVAL</dt><dd><p>Analysis Value</p>
</dd>
<dt>BASE</dt><dd><p>Baseline Value</p>
</dd>
<dt>BASETYPE</dt><dd><p>Baseline Value</p>
</dd>
<dt>CHG</dt><dd><p>Change from Baseline</p>
</dd>
<dt>PCHG</dt><dd><p>Percent Change from Baseline</p>
</dd>
<dt>VISITNUM</dt><dd><p>Visit Number</p>
</dd>
<dt>VISIT</dt><dd><p>Visit Name</p>
</dd>
<dt>VSSEQ</dt><dd><p>Sequence Number</p>
</dd>
<dt>ANL01FL</dt><dd><p>Analysis 01 - Special Interest Flag</p>
</dd>
<dt>ABLFL</dt><dd><p>Baseline Record Flag</p>
</dd>
</dl>



<h3>Source</h3>

<p>CDISC SDTM/ADAM Pilot Project.
</p>

<hr>
<h2 id='char2factor'>Convert character variable to a factor based off it's numeric variable
counterpart.</h2><span id='topic+char2factor'></span>

<h3>Description</h3>

<p>Convert character variable to a factor based off it's numeric variable
counterpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2factor(df, c_var, n_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2factor_+3A_df">df</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="char2factor_+3A_c_var">c_var</code></td>
<td>
<p>character variable within the data frame.</p>
</td></tr>
<tr><td><code id="char2factor_+3A_n_var">n_var</code></td>
<td>
<p>numeric variable counter part within the data frame to control
the levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tribble(
  ~TRT01P, ~TRT01PN,
  "Placebo",   1,
  "Low Dose",  2,
  "High Dose", 3
  )

# alphabetical order
dplyr::arrange(df, TRT01P)

# change to factor with char2factor
df$TRT01P &lt;- char2factor(df, "TRT01P", "TRT01PN")

# factor order
dplyr::arrange(df, TRT01P)
</code></pre>

<hr>
<h2 id='column_metadata'>Metadata describing table column layouts</h2><span id='topic+column_metadata'></span>

<h3>Description</h3>

<p>This is used by tlgsetup to prepare you input data to support
the desired column layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column_metadata
</code></pre>


<h3>Format</h3>

<p>A data frame with one row per column for each table type
and 6 variables:
</p>

<dl>
<dt>tbltype</dt><dd><p>identifier used to group a table column layout</p>
</dd>
<dt>coldef</dt><dd><p>distinct variable values used, typically numeric
and typically a treatment/main effect variable, think TRT01PN</p>
</dd>
<dt>decode</dt><dd><p>decode of coldef that will display as a column header
in the table</p>
</dd>
<dt>span1</dt><dd><p>spanning header to display across multiple columns</p>
</dd>
<dt>span2</dt><dd><p>spanning header to display across multiple columns,
second level</p>
</dd>
<dt>span3</dt><dd><p>spanning header to display across multiple columns,
third level</p>
</dd>
</dl>


<hr>
<h2 id='freq'>Frequency counts and percentages</h2><span id='topic+freq'></span>

<h3>Description</h3>

<p>Frequency counts and percentages for a variable by treatment and/or group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq(
  df,
  denom_df = df,
  colvar = NULL,
  tablebyvar = NULL,
  rowvar = NULL,
  rowbyvar = NULL,
  statlist = getOption("tidytlg.freq.statlist.default"),
  decimal = 1,
  nested = FALSE,
  cutoff = NULL,
  cutoff_stat = "pct",
  subset = TRUE,
  descending_by = NULL,
  display_missing = FALSE,
  rowtext = NULL,
  row_header = NULL,
  .keep = TRUE,
  .ord = FALSE,
  pad = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_+3A_df">df</code></td>
<td>
<p>(required) dataframe containing records to summarize by treatment</p>
</td></tr>
<tr><td><code id="freq_+3A_denom_df">denom_df</code></td>
<td>
<p>(optional) dataframe used for population based denominators
(default = df)</p>
</td></tr>
<tr><td><code id="freq_+3A_colvar">colvar</code></td>
<td>
<p>(required) treatment variable within df to use to summarize</p>
</td></tr>
<tr><td><code id="freq_+3A_tablebyvar">tablebyvar</code></td>
<td>
<p>(optional) repeat entire table by variable within df</p>
</td></tr>
<tr><td><code id="freq_+3A_rowvar">rowvar</code></td>
<td>
<p>(required) character vector of variables to summarize within the
dataframe</p>
</td></tr>
<tr><td><code id="freq_+3A_rowbyvar">rowbyvar</code></td>
<td>
<p>(optional) repeat <code>rowvar</code> by variable within df</p>
</td></tr>
<tr><td><code id="freq_+3A_statlist">statlist</code></td>
<td>
<p>(optional) statlist object of stats to keep of length 1 or 2 specifying list
of statistics and format desired (e.g statlist(c(&quot;N&quot;, &quot;n (x.x\
(x.x)&quot;)))</p>
</td></tr>
<tr><td><code id="freq_+3A_decimal">decimal</code></td>
<td>
<p>(optional) decimal precision root level default (default = 1)</p>
</td></tr>
<tr><td><code id="freq_+3A_nested">nested</code></td>
<td>
<p>(optional) INTERNAL USE ONLY. The default should not be changed.
Switch on when this function is called by <code>nested_freq()</code> so we will not include
the by variables as part of the group denominators (default = FALSE)</p>
</td></tr>
<tr><td><code id="freq_+3A_cutoff">cutoff</code></td>
<td>
<p>(optional) percentage cutoff threshold. This can be passed as a
numeric cutoff, in that case any rows with greater than or equal to that
cutoff will be preserved, others will be dropped. To specify a single column
to define the cutoff logic, pass a character value of the form &quot;colName &gt;=
value&quot; and only that column will be used.</p>
</td></tr>
<tr><td><code id="freq_+3A_cutoff_stat">cutoff_stat</code></td>
<td>
<p>(optional) The value to cutoff by, n or pct. (default =
'pct'). Can be done with multiple columns by adding &amp; or | ex. <code>col1</code> &gt;=
<code>val1</code> &amp; <code>col2</code> &gt;= <code>val2</code></p>
</td></tr>
<tr><td><code id="freq_+3A_subset">subset</code></td>
<td>
<p>(optional) An R expression that will be passed to a
<code>dplyr::filter()</code> function to subset the data.frame. This is performed on
the numerator before any other derivations. Denominators must be
preprocessed and passed through using <code>denom_df</code>.</p>
</td></tr>
<tr><td><code id="freq_+3A_descending_by">descending_by</code></td>
<td>
<p>(optional) The column or columns to sort descending
counts. Can also provide a named list to do ascending order ex.
c(&quot;VarName1&quot; = &quot;asc&quot;, &quot;VarName2&quot; = &quot;desc&quot;) would sort by VarName1 in
ascending order and VarName2 in descending order. In case of a tie in count
or <code>descending_by</code> not provided, the columns will be sorted alphabetically.</p>
</td></tr>
<tr><td><code id="freq_+3A_display_missing">display_missing</code></td>
<td>
<p>(optional) Should the &quot;missing&quot; values be displayed? If
missing values are displayed, denominators will include missing values.
(default = FALSE)</p>
</td></tr>
<tr><td><code id="freq_+3A_rowtext">rowtext</code></td>
<td>
<p>(optional) A character vector used to rename the <code>label</code>
column. If named, names will give the new level and values will be the
replaced value. If unnamed, and the table has only one row, the rowtext will
rename the label of the row. If the rowtext is unnamed, the table has no
rows, and there is a subset, the table will be populated with zeros and the
label will be the only row.</p>
</td></tr>
<tr><td><code id="freq_+3A_row_header">row_header</code></td>
<td>
<p>(optional) A character vector to be added to the table.</p>
</td></tr>
<tr><td><code id="freq_+3A_.keep">.keep</code></td>
<td>
<p>(optional) Should the <code>rowbyvar</code> and <code>tablebyvar</code> be output in the
table.  If FALSE, <code>rowbyvar</code> will still be output in the <code>label</code> column.
(default = TRUE)</p>
</td></tr>
<tr><td><code id="freq_+3A_.ord">.ord</code></td>
<td>
<p>Should the ordering columns be output with the table? This is
useful if a table needs to be merged or reordered in any way after build.</p>
</td></tr>
<tr><td><code id="freq_+3A_pad">pad</code></td>
<td>
<p>(optional) A boolean that controls if levels with zero records
should be included in the final table. (default = TRUE)</p>
</td></tr>
<tr><td><code id="freq_+3A_...">...</code></td>
<td>
<p>(optional) Named arguments to be included as columns on the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of results
</p>


<h3>Sorting a 'freq' table</h3>

<p>By default, a frequency table is sorted based on the factor level of the
<code>rowvar</code> variable. If the <code>rowvar</code> variable isn't a factor, it will be
sorted alphabetically. This behavior can be modified in two ways, the first
is the <code>char2factor()</code> function that offers a interface for releveling a
variable based on a numeric variable, like VISITN. The second is based on
the <code>descending_by</code> argument which will sort based on counts on a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adsl &lt;- data.frame(
      USUBJID = c("DEMO-101", "DEMO-102", "DEMO-103"),
      RACE = c("WHITE", "BLACK", "ASIAN"),
      SEX = c("F", "M", "F"),
      colnbr = factor(c("Placebo", "Low", "High"))
  )

# Unique subject count of a single variable
freq(adsl
     ,colvar = "colnbr"
     ,rowvar = "RACE"
     ,statlist = statlist("n"))

# Unique subject count and percent of a single variable
freq(adsl
     ,colvar = "colnbr"
     ,rowvar = "RACE"
     ,statlist = statlist(c("N", "n (x.x%)")))

# Unique subject count of a variable by another variable
freq(adsl
     ,colvar = "colnbr"
     ,rowvar = "RACE"
     ,rowbyvar = "SEX"
     ,statlist = statlist("n"))

# Unique subject count of a variable by another variable using colvar and
# group to define the denominator
freq(adsl
     ,colvar = "colnbr"
     ,rowvar = "RACE"
     ,rowbyvar = "SEX"
     ,statlist = statlist("n (x.x%)", denoms_by = c("colnbr", "SEX")))

# Cut records where count meets threshold for any column
freq(cdisc_adsl
     ,rowvar = "ETHNIC"
     ,colvar = "TRT01P"
     ,statlist = statlist("n (x.x%)")
     ,cutoff = "5"
     ,cutoff_stat = "n")

# Cut records where count meets threshold for a specific column
freq(cdisc_adsl
     ,rowvar = "ETHNIC"
     ,colvar = "TRT01P"
     ,statlist = statlist("n (x.x%)")
     ,cutoff = "Placebo &gt;= 3"
     ,cutoff_stat = "n")

# Below illustrates how to make the same calls to freq() as above, using
# table and column metadata.

# Unique subject count of a single variable
table_metadata &lt;- tibble::tribble(
  ~anbr,  ~func,          ~df,   ~rowvar,      ~statlist,  ~colvar,
  1,     "freq", "cdisc_adsl",  "ETHNIC",  statlist("n"), "TRT01PN"
)

generate_results(table_metadata,
                 column_metadata = column_metadata,
                 tbltype = "type1")

# Unique subject count and percent of a single variable
table_metadata &lt;- tibble::tribble(
  ~anbr,  ~func,    ~df,     ~rowvar,     ~statlist,            ~colvar,
  "1", "freq", "cdisc_adsl", "ETHNIC", statlist(c("N", "n (x.x%)")),"TRT01PN"
)

generate_results(table_metadata,
                 column_metadata = column_metadata,
                 tbltype = "type1")

# Cut records where count meets threshold for any column
table_metadata &lt;- tibble::tibble(
  anbr= "1", func = "freq", df = "cdisc_adsl", rowvar = "ETHNIC",
  statlist = statlist("n (x.x%)"), colvar = "TRT01PN", cutoff = 5,
  cutoff_stat = "n")

generate_results(table_metadata,
                 column_metadata = column_metadata,
                 tbltype = "type1")

# Cut records where count meets threshold for a specific column
table_metadata &lt;- tibble::tibble(
  anbr= 1, func = "freq", df = "cdisc_adsl", rowvar = "ETHNIC",
  statlist = statlist("n (x.x%)"), colvar = "TRT01PN",
  cutoff = 'col1 &gt;= 3', cutoff_stat = "n")

generate_results(table_metadata,
                 column_metadata = column_metadata,
                 tbltype = "type1")
</code></pre>

<hr>
<h2 id='generate_results'>Generate Results using Table and Column Metadata</h2><span id='topic+generate_results'></span>

<h3>Description</h3>

<p>Generate Results using Table and Column Metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_results(
  table_metadata,
  column_metadata_file = NULL,
  column_metadata = NULL,
  env = parent.frame(),
  tbltype = NULL,
  add_count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_results_+3A_table_metadata">table_metadata</code></td>
<td>
<p>dataframe containing table metadata (see
?table_metadata for details)</p>
</td></tr>
<tr><td><code id="generate_results_+3A_column_metadata_file">column_metadata_file</code></td>
<td>
<p>An excel file with the data for column_metadata.
The file is read in with <code>readxl::read_excel()</code>. Should not be used with
<code>column_metadata</code> argument. Results in a dataframe containing the column
metadata that is passed to tlgsetup (see <code>tlgsetup()</code> for details). If a
column_metadata dataframe is passed in too, this is ignored.</p>
</td></tr>
<tr><td><code id="generate_results_+3A_column_metadata">column_metadata</code></td>
<td>
<p>A dataframe containing the column metadata. This will
be used in place of <code>column_metadata_file</code>.</p>
</td></tr>
<tr><td><code id="generate_results_+3A_env">env</code></td>
<td>
<p>environment to find dataframe specified in the table metadata
(defaults to parent environment)</p>
</td></tr>
<tr><td><code id="generate_results_+3A_tbltype">tbltype</code></td>
<td>
<p>If used, this will be used to subset the <code>column_metadata</code> based
on the <code>tbltype</code> column.</p>
</td></tr>
<tr><td><code id="generate_results_+3A_add_count">add_count</code></td>
<td>
<p>Passed to <code>bind_table()</code> should counts be added for
<code>tablebyvars</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe of results
</p>

<hr>
<h2 id='gentlg'>Output a tidytlg table</h2><span id='topic+gentlg'></span>

<h3>Description</h3>

<p>Generate and output a huxtable with desired properties
During this function call, the huxtable can be written to an RTF or
displayed in HTML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gentlg(
  huxme = NULL,
  tlf = "Table",
  format = "rtf",
  colspan = NULL,
  idvars = NULL,
  plotnames = NULL,
  plotwidth = NULL,
  plotheight = NULL,
  wcol = 0.45,
  orientation = "portrait",
  opath = ".",
  title_file = NULL,
  file = NULL,
  title = NULL,
  footers = NULL,
  print.hux = TRUE,
  watermark = NULL,
  colheader = NULL,
  pagenum = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gentlg_+3A_huxme">huxme</code></td>
<td>
<p>(optional) For tables and listings, An input dataframe
containing all columns of interest. For graphs, either NULL or a ggplot
object.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_tlf">tlf</code></td>
<td>
<p>(optional) String, representing the output choice. Choices are
&quot;Table&quot; &quot;Listing&quot; &quot;Figure&quot;. Abbreviations are allowed eg &quot;T&quot; for Table.
Strings can be either upper- or lowercase. (Default = &quot;Table&quot;)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_format">format</code></td>
<td>
<p>(optional) String, representing the output format. Choices are
&quot;rtf&quot; and &quot;html&quot;. Strings can be either upper- or lowercase.(Default = &quot;rtf&quot;)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_colspan">colspan</code></td>
<td>
<p>(optional) A list of character vectors representing the
spanning headers to be used for the table or listing. The first vector
represents the top spanning header, etc. Each vector should have a length
equal to the number of columns in the output data frame. A spanning header
is identified through the use of the same column name in adjacent elements.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_idvars">idvars</code></td>
<td>
<p>(optional) Character vector defining the columns of a listing
where repeated values should be removed recursively. If NULL then
all column names are used in the algorithm. If NA, then the listing remains
as is.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_plotnames">plotnames</code></td>
<td>
<p>(optional) Character vector containing the names of the png
files, with their extension to be incorporated for figure outputs.
The png files need to be located in the path defined by the parameter <code>opath</code>.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_plotwidth">plotwidth</code></td>
<td>
<p>(optional) Numerical value that indicates the plot width in
cm for figure outputs. (Default = 6)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_plotheight">plotheight</code></td>
<td>
<p>(optional) Numerical value that indicates the plot height
in cm for figure outputs. (Default = 5)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_wcol">wcol</code></td>
<td>
<p>(optional) Can be a single numerical value that represents the
width of the first column or a vector, specifying the lengths of all columns
in the final table or listing.<br />
When a single numerical value is used, this will be taken as the column width
for the first column. The other columns will be equally spaced across the
remainder of the available space. Alternatively, a vector can be used to
represent the widths of all columns in the final output. The order of the
arguments needs to correspond to the order of the columns in the <code>huxme</code>
dataset, that are not part of the formatting algorithms
(eg anbr, roworder, newpage, newrow, indentme, boldme, by_value, by_order).
The sum of the widths in the vector needs to be less or equal to one. When
'format=&quot;HTML&quot;' wcol can take only one value, the width of the first column.
(Default = 0.45)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_orientation">orientation</code></td>
<td>
<p>(optional) String: &quot;portrait&quot; or &quot;landscape&quot;.
(Default = &quot;portrait&quot;)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_opath">opath</code></td>
<td>
<p>(optional) File path pointing to the output files
(including .png files for graphs). (Default = &quot;.&quot;)</p>
</td></tr>
<tr><td><code id="gentlg_+3A_title_file">title_file</code></td>
<td>
<p>An Excel file that will be read in
with <code>readxl::read_excel()</code> to be used as the <code>title</code> and <code>footers</code> arugment.
The use of <code>title</code> or <code>footers</code> will override the values passed by this
argument. The file should be either an xls or xlsx file with the columns
'TABLE ID', 'IDENTIFIER', and TEXT'. The file will be read in, subset to
where the tblid matches the tlf argument, and identifiers with 'title' or
'footnote' will be used to populate the table.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_file">file</code></td>
<td>
<p>(required) String. Output identifier.
File name will be adjusted to be lowercase and have - and _ removed,
this will not affect table title.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_title">title</code></td>
<td>
<p>(required) String. Title of the output.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_footers">footers</code></td>
<td>
<p>(optional) Character vector, containing strings of footnotes
to be included.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_print.hux">print.hux</code></td>
<td>
<p>(optional) Logical, indicating whether the output should be
printed to RTF ('format' = &quot;rtf&quot;) / displayed as HTML ('format' = &quot;HTML&quot;).
(Default = TRUE) Note that RTF is written using <code>quick_rtf_jnj()</code>
function and that the HTML is displayed via the huxtable::print_html
function.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_watermark">watermark</code></td>
<td>
<p>(optional) String containing the desired watermark for
RTF outputs.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_colheader">colheader</code></td>
<td>
<p>(optional) Character vector that contains the column labels
for a table or listing. Default uses the column labels of huxme.</p>
</td></tr>
<tr><td><code id="gentlg_+3A_pagenum">pagenum</code></td>
<td>
<p>(optional) Logical. When true page numbers are added on the
right side of the footer section in the format page x/y. (Default = FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted huxtable with desired properties for output to an RTF/HTML
</p>


<h3>Huxme Details</h3>

<p>For tables and listings, formatting of the output can be dictated through the
formatting columns
(<code>newrows</code>, <code>indentme</code>, <code>boldme</code>, <code>newpage</code>), present in the input dataframe.
The final huxtable will display all columns of the input dataframe, except
any recognized formatting/sorting columns.
For tables, the algorithm uses
the column <code>label</code> as first column. The remaining columns are treated as
summary columns.
For graphs, you can pass a ggplot object directly into huxme and gentlg will
save a png with with <code>ggplot2::ggsave()</code> and output an rtf.
</p>


<h3>Author(s)</h3>

<p>Steven Haesendonckx <a href="mailto:shaesen2@its.jnj.com">shaesen2@its.jnj.com</a>
</p>
<p>Pelagia Alexandra Papadopoulou <a href="mailto:ppapadop@its.jnj.com">ppapadop@its.jnj.com</a>
</p>


<h3>References</h3>

<p><a href="https://github.com/hughjonesd/huxtable">https://github.com/hughjonesd/huxtable</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
final &lt;- data.frame(
  label = c(
    "Overall", "Safety Analysis Set",
    "Any Adverse event{\\super a}", "- Serious Adverse Event"
  ),
  Drug_A = c("", "40", "10 (25%)", "0"),
  Drug_B = c("", "40", "10 (25%)", "0"),
  anbr = c(1, 2, 3, 4),
  roworder = c(1, 1, 1, 1),
  boldme = c(1, 0, 0, 0),
  newrows = c(0, 0, 1, 0),
  indentme = c(0, 0, 0, 1),
  newpage = c(0, 0, 0, 0)
)

# Produce output in rtf format
gentlg(
  huxme = final,
  wcol = c(0.70, 0.15, 0.15),
  file = "TSFAEX",
  title = "This is Amazing Demonstration 1",
  footers = c(
    "Note: For demonstrative purposes only",
    "{\\super a} Subjects are counted once for any given event."
  )
)

# Pass in column headers instead of using variable name
gentlg(
  huxme = final,
  wcol = c(0.70, 0.15, 0.15),
  file = "TSFAEX",
  colheader = c("", "Drug A", "Drug B"),
  title = "This is Amazing Demonstration 1",
  footers = c(
    "Note: For demonstrative purposes only",
    "{\\super a} Subjects are counted once for any given event."
  )
)
# Use a watermark
gentlg(
  huxme = final,
  wcol = c(0.70, 0.15, 0.15),
  file = "TSFAEX",
  colheader = c("", "Drug A", "Drug B"),
  title = "This is Amazing Demonstration 1",
  footers = c(
    "Note: For demonstrative purposes only",
    "{\\super a} Subjects are counted once for any given event."
  ),
  watermark = "Confidential"
)

# Produce output in HTML format
hux &lt;- gentlg(
  huxme = final,
  file = "TSFAEX",
  colheader = c("", "Drug A", "Drug B"),
  title = "This is Amazing Demonstration 1",
  footers = c(
    "Note: For demonstrative purposes only",
    "{\\super a} Subjects are counted once for any given event."
  ),
  watermark = "Confidential",
  format = "HTML",
  print.hux = FALSE
)

# Export to HTML page
huxtable::quick_html(hux, file = "TSFAEX.html", open = FALSE)

# clean up.
file.remove("TSFAEX.html", "tsfaex.rtf")
</code></pre>

<hr>
<h2 id='nested_freq'>Generate nested count/percent for two or three levels</h2><span id='topic+nested_freq'></span>

<h3>Description</h3>

<p>This will call <code>freq()</code> multiple times and combine the levels together. This
is useful for adverse event and concomitant mediations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_freq(
  df,
  denom_df = df,
  colvar = NULL,
  tablebyvar = NULL,
  rowvar = NULL,
  rowbyvar = NULL,
  statlist = getOption("tidytlg.nested_freq.statlist.default"),
  decimal = 1,
  cutoff = NULL,
  cutoff_stat = "pct",
  subset = TRUE,
  descending_by = NULL,
  display_missing = FALSE,
  rowtext = NULL,
  row_header = NULL,
  .keep = TRUE,
  .ord = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_freq_+3A_df">df</code></td>
<td>
<p>(required) dataframe containing the two levels to summarize</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_denom_df">denom_df</code></td>
<td>
<p>(optional) dataframe containing records to use as the
denominator (default = df)</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_colvar">colvar</code></td>
<td>
<p>(required) treatment variable within df to use to summarize</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_tablebyvar">tablebyvar</code></td>
<td>
<p>(optional) repeat entire table by variable within df.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_rowvar">rowvar</code></td>
<td>
<p>(required) nested levels separated by a star, for example
AEBODSYS*AEDECOD,  this can handle up to three levels.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_rowbyvar">rowbyvar</code></td>
<td>
<p>(optional) repeat <code>rowvar</code> by variable within df</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_statlist">statlist</code></td>
<td>
<p>(optional) count/percent type to return (default = &quot;n (x.x)&quot;)</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_decimal">decimal</code></td>
<td>
<p>(optional) decimal precision root level (default = 1)</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_cutoff">cutoff</code></td>
<td>
<p>(optional) numeric value used to cut the data to a percentage
threshold, if any column meets the threshold the entire record is kept.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_cutoff_stat">cutoff_stat</code></td>
<td>
<p>(optional) The value to cutoff by, n or pct. (default =
'pct')</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_subset">subset</code></td>
<td>
<p>(optional) An R expression that will be passed to a
<code>dplyr::filter()</code> function to subset the data.frame</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_descending_by">descending_by</code></td>
<td>
<p>(optional) The column or columns to sort descending
values by. Can also provide a named list to do ascending order. ex.
c(&quot;VarName1&quot; = &quot;asc&quot;, &quot;VarName2&quot; = &quot;desc&quot;) would sort by VarName1 in
ascending order and VarName2 in descending order. If not provided, the
columns will be sorted alphabetically.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_display_missing">display_missing</code></td>
<td>
<p>(optional) Should the &quot;missing&quot; values be displayed?
(default = FALSE)</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_rowtext">rowtext</code></td>
<td>
<p>(optional) A character vector used to rename the <code>label</code>
column. If named, names will give the new level and values will be the
replaced value. If unnamed, and the table has only one row, the <code>rowtext</code>
will rename the <code>label</code> of the row.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_row_header">row_header</code></td>
<td>
<p>(optional) A character vector to be added to the table.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_.keep">.keep</code></td>
<td>
<p>(optional) Should the <code>rowbyvar</code> and <code>tablebyvar</code> be output in the
table.  If FALSE, <code>rowbyvar</code> will still be output in the <code>label</code> column.
(default = TRUE)</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_.ord">.ord</code></td>
<td>
<p>Should the ordering columns be output with the table? This is
useful if a table needs to be merged or reordered in any way after build.</p>
</td></tr>
<tr><td><code id="nested_freq_+3A_...">...</code></td>
<td>
<p>(optional) Named arguments to be included as columns on the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of nested results by <code>colvar</code> and optional <code>tablebyvar</code>.
There are a few additional variable sets added to support multiple
requirements. <br />  <br /> The level variables (<code>level1_</code>, <code>level2_</code>,
<code>level3_</code>) will carry down the counts for each level to every record.  This
allows for easy sorting of nested groups. <br />  <br /> The header variables
(<code>header1</code>, <code>header2</code>, <code>header3</code>) will flag the header for each level to
ensure each level header is sorted to the top of the level. <br />  <br /> The n
variables (&quot;n_<em>&quot;) provide a numeric variable containing frequency for each
<code>colvar</code>.  This can be used to sort and filter records. <br />  <br /> The pct
variables (&quot;pct_</em>&quot;) provide a numeric variable containing percentages for
each <code>colvar</code>.  This can be used to sort and filter records.<br />  <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adae &lt;- data.frame(
      SITEID = c("100", "100", "100","200", "200", "200"),
      USUBJID = c("Demo1-101", "Demo1-102", "Demo1-103",
                  "Demo1-104", "Demo1-105", "Demo1-106"),
      AEBODSYS = c("Cardiac disorders", "Cardiac disorders",
                   "Respiratory, thoracic and mediastinal disorders",
                   "Infections and infestations",
                   "Skin and subcutaneous tissue disorders",
                   "Infections and infestations"),
      AEDECOD = c("Arrhythmia supraventricular", "Cardiac failure",
                  "Chronic obstructive pulmonary disease", "Pneumonia",
                  "Pustular psoriasis", "Upper respiratory tract infection"),
      colnbr = structure(
        c(1L, 2L, 3L, 1L,  2L, 3L),
        .Label = c("Active", "Placebo", "Comparator"),
        class = "factor"
      )
    )

# Frequency and percent for two levels of nesting
nested_freq(adae
           ,colvar = "colnbr"
           ,rowvar = "AEBODSYS*AEDECOD"
           ,statlist = statlist("n (x.x%)"))

# Frequency and percent for three levels of nesting (for illustrative
# purpose)
nested_freq(adae
           ,colvar = "colnbr"
          ,rowvar = "SITEID*AEBODSYS*AEDECOD"
           ,statlist = statlist("n (x.x%)"))

# Cut records where pct meets threshold for a any column
nested_freq(cdisc_adae
            ,colvar = "TRTA"
            ,rowvar = "AEBODSYS*AEDECOD"
            ,statlist = statlist("n (x.x%)", distinct = TRUE)
            ,cutoff = 2
            ,cutoff_stat = "n")

# Cut records where pct meets threshold for a specific column
nested_freq(cdisc_adae
            ,rowvar = "AEBODSYS*AEDECOD"
            ,colvar = "TRTAN"
            ,statlist = statlist("n (x.x%)", distinct = TRUE)
            ,cutoff = "54 &gt;= 2"
            ,cutoff_stat = "n")

# Frequency and percent for two levels of nesting and sort by descending
# active
nested_freq(adae
            ,colvar = "colnbr"
            ,rowvar = "AEBODSYS*AEDECOD"
            ,statlist = statlist("n (x.x%)")
            ,descending = "Active")

# Below illustrates how make the same calls to nested_freq() as above, using
# table and # column metadata along with generate_results().

column_metadata &lt;- tibble::tribble(
 ~tbltype, ~coldef,   ~decode,
 "type1",     "1", "Placebo",
 "type1",     "2",     "Low",
 "type1",     "3",    "High"
)

# Frequency and percent for two levels of nesting
table_metadata &lt;- tibble::tribble(
 ~anbr,         ~func,    ~df,       ~rowvar, ~tbltype,  ~colvar, ~statlist,
 "1", "nested_freq", "cdisc_adae", "AEBODSYS*AEDECOD",  "type1",  "TRTP",
 statlist("n (x.x%)")
)
#generate_results(table_metadata,
#column_metadata_file = tidytlg_metadata(path)


# Frequency and percent for three levels of nesting (for illustrative purpose)
table_metadata &lt;- tibble::tribble(
 ~anbr,         ~func,    ~df,                 ~rowvar, ~tbltype,  ~colvar,
 ~statlist,
 "1", "nested_freq", "cdisc_adae", "SITEID*AEBODSYS*AEDECOD","type1",
 "TRTP", statlist("n (x.x%)")
)
# Commented out because it takes too long
# generate_results(table_metadata, column_metadata)

#Cut records where pct meets threshold for a any column
column_metadata &lt;- tibble::tribble(
 ~tbltype, ~coldef,   ~decode,
 "type2",     "1", "Placebo",
 "type2",     "2",  "Active"
)
table_metadata &lt;- tibble::tibble(
 anbr = "1", func = "nested_freq", df= "cdisc_adae",
 rowvar = "AEBODSYS*AEDECOD",
 tbltype = "type2", colvar = "TRTP", statlist = statlist("n (x.x%)"),
 dotdotdot = "cutoff = 5"
)
#generate_results(table_metadata,
# column_metadata_file = tidytlg_metadata(path)

# Cut records where pct meets threshold for a specific column
table_metadata &lt;- tibble::tibble(
 anbr = "1", func = "nested_freq", df= "cdisc_adae",
 rowvar = "AEBODSYS*AEDECOD",
 tbltype = "type2", colvar = "TRTP", statlist = statlist("n (x.x%)"),
 dotdotdot = "cutoff = 'col1 &gt;= 5'"
)
#generate_results(table_metadata,
#column_metadata_file = tidytlg_metadata(path)

# Frequency and percent for two levels of nesting and sort by descending col1
table_metadata &lt;- tibble::tibble(
 anbr = "1", func = "nested_freq", df= "cdisc_adae",
 rowvar = "AEBODSYS*AEDECOD",
 tbltype = "type2", colvar = "TRTP", statlist = statlist("n (x.x%)"),
 dotdotdot = "descending = 'col1'"
)
#generate_results(table_metadata,
#column_metadata_file = tidytlg_metadata(path)
</code></pre>

<hr>
<h2 id='replace_na_with_blank'>Replace NA with &quot;&quot;</h2><span id='topic+replace_na_with_blank'></span>

<h3>Description</h3>

<p>Used to swap in &quot;&quot; for by variables so the headers sort correctly to the top
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na_with_blank(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_with_blank_+3A_x">x</code></td>
<td>
<p>variable to check for NA and replace with &quot;&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with NA's replaced with &quot;&quot;.  Factors will add &quot;&quot;
as the first level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replace_na_with_blank(c("a", "b", NA))

replace_na_with_blank(factor(c("a", "b", NA), levels = c("a", "b")))
</code></pre>

<hr>
<h2 id='rmdpstitle'>Get Titles and Footnotes for all TLGs or one specific TLG</h2><span id='topic+rmdpstitle'></span>

<h3>Description</h3>

<p>Get Titles and Footnotes for all TLGs or one specific TLG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmdpstitle(
  df,
  tblid,
  idvar = "tblid",
  identifier = "identifier",
  text = "text"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmdpstitle_+3A_df">df</code></td>
<td>
<p>dataframe with three variables; table name, row identifier (TITLE
or FOOTNOTEn), and title/footnote text to display</p>
</td></tr>
<tr><td><code id="rmdpstitle_+3A_tblid">tblid</code></td>
<td>
<p>character vector containing the table id, optional, used to
subset df to a specific table (defaults to tblid)</p>
</td></tr>
<tr><td><code id="rmdpstitle_+3A_idvar">idvar</code></td>
<td>
<p>character vector containing the variable in df that contains
your table id</p>
</td></tr>
<tr><td><code id="rmdpstitle_+3A_identifier">identifier</code></td>
<td>
<p>character vector containing the variable name in df that
contains your record identifier (defaults to &quot;identifier&quot;)</p>
</td></tr>
<tr><td><code id="rmdpstitle_+3A_text">text</code></td>
<td>
<p>character vector containing the variable name in df that
contains your title and footnote text (defaults to &quot;text&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of length two, the first element contains the titles as a tibble
and the second contains the footnotes as a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tblid &lt;- "TSIDEM01"

titles &lt;-tibble::tribble(
  ~tblid, ~identifier,                  ~text,
  "TSIDEM01",     "TITLE", "Demographics Example",
  "TSIDEM01", "FOOTNOTE1",    "Example footnote."
)

title_foot &lt;- rmdpstitle(titles, tblid)

title_foot[[1]]
title_foot[[2]]
</code></pre>

<hr>
<h2 id='roundSAS'>SAS rounding in R</h2><span id='topic+roundSAS'></span>

<h3>Description</h3>

<p>roundSAS is an alternative rounding function, ensuring that decimals equal or
bigger than 5 are rounded upwards to the nearest number and returned as
character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundSAS(x, digits = 0, as_char = FALSE, na_char = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundSAS_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="roundSAS_+3A_digits">digits</code></td>
<td>
<p>An integer specifying the number of decimal places to be
displayed after rounding. Default is 0.</p>
</td></tr>
<tr><td><code id="roundSAS_+3A_as_char">as_char</code></td>
<td>
<p>logical value indicating conversion of rounded numerical
vector to character vector; default is FALSE</p>
</td></tr>
<tr><td><code id="roundSAS_+3A_na_char">na_char</code></td>
<td>
<p>A character string indicating missing value; if not specified,
&quot;NA&quot; is created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At the midpoint of a decimal place (e.g. 0.5, 1.5), the round function in R
rounds to the nearest even number (i.e. 0.5 is rounded to 0; 1.5 is rounded
to 2), whereas SAS rounds to the nearest number (i.e. 0.5 is rounded to 1;
1.5 is rounded to 2). The roundSAS function is an alternative rounding
function for R that ensures rounding to the nearest number, as done in SAS.
roundSAS comes from this Stack Overflow post https://stackoverflow.com/questions/12688717/round-up-from-5
</p>


<h3>Value</h3>

<p>character vector of rounded values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### input data vector with midpoint decimals
x &lt;- c(-2.5, -1.5, -0.5, 0.5, 1.5, 2.5)

### rounds to integer
roundSAS(x, digits = 0)

### input data vector with a missing value
y &lt;- c(8.65, 8.75, NA, 9.85, 9.95)

### rounds to tenths and label the missing value with "NE"
roundSAS(y, digits = 1, as_char = TRUE, na_char = "NE")

</code></pre>

<hr>
<h2 id='spanning_headers'>Spanning headers for outputs</h2><span id='topic+spanning_headers'></span>

<h3>Description</h3>

<p>This will create the list object to be passed to <code>gentlg()</code> You can create as
many spanning headers as you like, just add variables prefixed with span to
the column metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spanning_headers(column_metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spanning_headers_+3A_column_metadata">column_metadata</code></td>
<td>
<p>dataframe containing the column metadata that is
passed to <code>tlgsetup()</code> (see <code>tlgsetup()</code> for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of character vectors containing column headers for an output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>column_metadata &lt;-
  tibble::tribble(
    ~tbltype, ~coldef, ~decode,                ~span1,
    "type1",  "0",     "Placebo",              "",
    "type1",  "54",    "Low Dose",             "Xanomeline",
    "type1",  "81",    "High Dose",            "Xanomeline",
    "type1",  "54+81", "Total Xanomeline",     ""
  )

spanning_headers(column_metadata)
</code></pre>

<hr>
<h2 id='statlist'>Create a statlist interface for a table</h2><span id='topic+statlist'></span>

<h3>Description</h3>

<p>The statlist is the interface for the presentation of data in a tidytlg
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statlist(stats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statlist_+3A_stats">stats</code></td>
<td>
<p>(required) A character vector of statistics to display in the
table.</p>
</td></tr>
<tr><td><code id="statlist_+3A_...">...</code></td>
<td>
<p>(optional) Additional configuration for stats. See sections below
for allowable arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A statlist object that can be passed in the 'statlist' argument of
<code>freq</code>, <code>nested_freq</code>, or <code>univar</code>.
</p>


<h3>Statlists for <code>freq()</code> and <code>nested_freq()</code></h3>

<p><code>freq()</code> statlists can be composed of n(count), N(denominator), and
x.x(percentage, formatted with or without a percent sign). Denominators will
include missing values if the 'display_missing' argument is TRUE, otherwise
they will be excluded. They can be arranged
in the following ways:
</p>

<ul>
<li><p>n
</p>
</li>
<li><p>n/N
</p>
</li>
<li><p>n (x.x)
</p>
</li>
<li><p>n (x.x%)
</p>
</li>
<li><p>n/N (x.x)
</p>
</li>
<li><p>n/N (x.x%)
</p>
</li></ul>

<p>The following other configurations are supported:
</p>

<ul>
<li><p>denoms_by - Controls what groupings of variables should define the
denominator. Variables should be passed as a quoted vector
</p>
</li>
<li><p>distinct - A boolean value. Should the numerator reflect distinct
USUBJIDs or event counts. Defaults to TRUE which captures distinct
subjects.
</p>
</li>
<li><p>distinct_by - A character value used to select the variable that
should be used to &quot;distinct&quot; the freq tables. Defaults to USUBJID.
</p>
</li>
<li><p>zero_denom - The string to display when there are no records found
in an entire denominator group. Defaults to &quot;-&quot;
</p>
</li>
<li><p>zero_n - The string to display when there are no records found for
a numerator. Defaults to &quot;0&quot;.
</p>
</li></ul>



<h3>Statlists for univar statlists</h3>


<ul>
<li><p>N
</p>
</li>
<li><p>SUM
</p>
</li>
<li><p>MEAN
</p>
</li>
<li><p>GeoMEAN
</p>
</li>
<li><p>SD
</p>
</li>
<li><p>SE
</p>
</li>
<li><p>CV
</p>
</li>
<li><p>GSD
</p>
</li>
<li><p>GSE
</p>
</li>
<li><p>MEANSD
</p>
</li>
<li><p>MEANSE
</p>
</li>
<li><p>MEDIAN
</p>
</li>
<li><p>MIN
</p>
</li>
<li><p>MAX
</p>
</li>
<li><p>RANGE
</p>
</li>
<li><p>Q1
</p>
</li>
<li><p>Q3
</p>
</li>
<li><p>IQRANGE
</p>
</li>
<li><p>MEDRANGE
</p>
</li>
<li><p>MEDIQRANGE
</p>
</li>
<li><p>MEAN_CI
</p>
</li>
<li><p>GeoMEAN_CI
</p>
</li></ul>

<p>where GeoMEAN: Geometric Mean, CV: Coefficient of Variation, GSD: Geometric
Std. Dev., GSE: Geometric Std. Error, MEAN_CI: Mean (95% C.I.), GeoMEAN_CI:
Geometric Mean (95% C.I.). In calculating geometric statistics, if there
are zero values in the inputs, zero values will be excluded before
calculating geometric statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
freq(
  mtcars,
  colvar = "gear",
  rowvar = "cyl",
  rowbyvar = "am",
  statlist = statlist("n/N (x.x)",
                      distinct = FALSE,
                      denoms_by = c("gear", "am"),
                      zero_denom = "_0_")
  )
</code></pre>

<hr>
<h2 id='table_metadata'>Metadata describing the data, functions and arguments needed to produce your
results.</h2><span id='topic+table_metadata'></span>

<h3>Description</h3>

<p>Metadata describing the data, functions and arguments needed to produce your
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_metadata
</code></pre>


<h3>Format</h3>

<p>A data frame with one row per function call and 16 variables:
</p>

<dl>
<dt>func</dt><dd><p>name of the function you wish to call</p>
</dd>
<dt>df</dt><dd><p>data frame to pass to the function call</p>
</dd>
<dt>subset</dt><dd><p>filter df records, this is passed directly to filter,
ex. &quot;AESER == 'Y'&quot;</p>
</dd>
<dt>rowvar</dt><dd><p>variable being summarized that will pass to the function
call</p>
</dd>
<dt>rowtext</dt><dd><p>row label text to display in the table</p>
</dd>
<dt>row_header</dt><dd><p>header text to display above row summary</p>
</dd>
<dt>statlist</dt><dd><p>list of statistics in the analysis, see individual
functions for what is available per function (eg. &quot;N, n (x.x)&quot;)</p>
</dd>
<dt>colvar</dt><dd><p>variable used to determine the columns of the table</p>
</dd>
<dt>decimal</dt><dd><p>decimal precision</p>
</dd>
<dt>rowbyvar</dt><dd><p>repeat rowvar summary by this variable/s, comma separated
for multiple (eg. &quot;ETHNIC, AGEGR1&quot;)</p>
</dd>
<dt>tablebyvar</dt><dd><p>repeat the entire table summary by this variable/s,
comma separated for multiple (eg. &quot;ETHNIC, AGEGR1&quot;)</p>
</dd>
<dt>denom_df</dt><dd><p>used to set denominators if df does not contain
all required records</p>
</dd>
</dl>


<hr>
<h2 id='tidytlg_titles'>Helper functions for returning files used in gentlg</h2><span id='topic+tidytlg_titles'></span><span id='topic+tidytlg_metadata'></span>

<h3>Description</h3>

<p>Helper functions for returning files used in gentlg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidytlg_titles(path)

tidytlg_metadata(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidytlg_titles_+3A_path">path</code></td>
<td>
<p>Working directory of the project</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector to the requested file.
</p>

<hr>
<h2 id='tlgsetup'>Setup data to support the specified column type</h2><span id='topic+tlgsetup'></span>

<h3>Description</h3>

<p>tlgsetup is useful for pre-processing total columns and columns composed of
other columns. tlgsetup is called internally by <code>generate_results()</code> and can
be run manually for custom tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tlgsetup(
  df,
  var,
  column_metadata_file = NULL,
  column_metadata = NULL,
  tbltype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tlgsetup_+3A_df">df</code></td>
<td>
<p>dataframe of records for analysis</p>
</td></tr>
<tr><td><code id="tlgsetup_+3A_var">var</code></td>
<td>
<p>character vector that identifies the numeric column/treatment
variable</p>
</td></tr>
<tr><td><code id="tlgsetup_+3A_column_metadata_file">column_metadata_file</code></td>
<td>
<p>A file containing the column metadata. Read in
with <code>readxl::read_excel()</code>. If a <code>column_metadata</code> dataframe is passed in
too, this is ignored.</p>
</td></tr>
<tr><td><code id="tlgsetup_+3A_column_metadata">column_metadata</code></td>
<td>
<p>A dataframe containing the column metadata. This will
be used in place of <code>column_metadata_file</code>.</p>
</td></tr>
<tr><td><code id="tlgsetup_+3A_tbltype">tbltype</code></td>
<td>
<p>A value used to subset the <code>column_metadata</code>, both this and the
file requirements are needed to bind the data to the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with observations added to support the column type as well
as the factor variable <code>colnbr</code> which is used as our new column summary
variable. Regardless of if a <code>coldef</code> exists in data, the column will exist in
the table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;-
  tibble::tribble(
  ~TRT01AN, ~USUBJID,
  0,        "A",
 54,       "B",
 81,       "C"
)

tlgsetup(df, "TRT01AN", column_metadata = column_metadata)

# Using a dataframe of column metadata
column_metadata &lt;-
  tibble::tribble(
    ~tbltype, ~coldef, ~decode,                ~span1,
    "type1",  "0",     "Placebo",              "",
    "type1",  "54",    "Low Dose",             "Xanomeline",
    "type1",  "81",    "High Dose",            "Xanomeline",
    "type1",  "54+81", "Total Xanomeline",     ""
  )

tlgsetup(df, "TRT01AN", column_metadata = column_metadata)
</code></pre>

<hr>
<h2 id='univar'>Descriptive statistics</h2><span id='topic+univar'></span>

<h3>Description</h3>

<p>Univariate statitstics for a variables by treatment and/or group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univar(
  df,
  colvar = NULL,
  tablebyvar = NULL,
  rowvar = NULL,
  rowbyvar = NULL,
  statlist = getOption("tidytlg.univar.statlist.default"),
  decimal = 1,
  precisionby = NULL,
  precisionon = NULL,
  wide = FALSE,
  alpha = 0.05,
  rowtext = NULL,
  row_header = NULL,
  .keep = TRUE,
  .ord = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univar_+3A_df">df</code></td>
<td>
<p>(required) dataframe containing records to summarize by treatment</p>
</td></tr>
<tr><td><code id="univar_+3A_colvar">colvar</code></td>
<td>
<p>(required) character vector of the treatment variable within
the dataframe</p>
</td></tr>
<tr><td><code id="univar_+3A_tablebyvar">tablebyvar</code></td>
<td>
<p>(optional) repeat entire table by variable within df</p>
</td></tr>
<tr><td><code id="univar_+3A_rowvar">rowvar</code></td>
<td>
<p>(required) character vector of variable to summarize within the
dataframe</p>
</td></tr>
<tr><td><code id="univar_+3A_rowbyvar">rowbyvar</code></td>
<td>
<p>(optional) repeat <code>rowvar</code> by variable within df</p>
</td></tr>
<tr><td><code id="univar_+3A_statlist">statlist</code></td>
<td>
<p>(optional) statlist object of stats to keep (default =
statlist(c(&quot;N&quot;, &quot;MEANSD&quot;, &quot;MEDIAN&quot;, &quot;RANGE&quot;, &quot;IQRANGE&quot;)))</p>
</td></tr>
<tr><td><code id="univar_+3A_decimal">decimal</code></td>
<td>
<p>(optional) decimal precision root level, when using
<code>presisionby</code> this will be used as the base decimal cap (default = 1)</p>
</td></tr>
<tr><td><code id="univar_+3A_precisionby">precisionby</code></td>
<td>
<p>(optional) vector of by variable(s) to use when
calculating parameter based precision</p>
</td></tr>
<tr><td><code id="univar_+3A_precisionon">precisionon</code></td>
<td>
<p>(optional) variable to use when calculating parameter
based precision. If <code>precisionby</code> is specified but not <code>precisionon</code> this will
default to <code>rowvar</code></p>
</td></tr>
<tr><td><code id="univar_+3A_wide">wide</code></td>
<td>
<p>(optional) logical indicating to convert labels to column and
columns to labels (default = FALSE)</p>
</td></tr>
<tr><td><code id="univar_+3A_alpha">alpha</code></td>
<td>
<p>(optional) alpha level for 2-sided confidence interval (default
= 0.05)</p>
</td></tr>
<tr><td><code id="univar_+3A_rowtext">rowtext</code></td>
<td>
<p>(optional) A text string to replace the <code>label</code> value on the
table. Useful for tables with a single row.</p>
</td></tr>
<tr><td><code id="univar_+3A_row_header">row_header</code></td>
<td>
<p>(optional) A row to add as a header for the table.</p>
</td></tr>
<tr><td><code id="univar_+3A_.keep">.keep</code></td>
<td>
<p>(optional) Should the <code>rowbyvar</code> and <code>tablebyvar</code> be output in the
table.  If FALSE, <code>rowbyvar</code> will still be output in the <code>label</code> column.
(default = TRUE)</p>
</td></tr>
<tr><td><code id="univar_+3A_.ord">.ord</code></td>
<td>
<p>Should the ordering columns be output with the table? This is
useful if a table needs to be merged or reordered in any way after build.</p>
</td></tr>
<tr><td><code id="univar_+3A_...">...</code></td>
<td>
<p>(optional) Named arguments to be included as columns on the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe of results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adsl &lt;-
  structure(
    list(
      USUBJID = c("DEMO-101", "DEMO-102", "DEMO-103", "DEMO-104",
                  "DEMO-105", "DEMO-106"),
      AGE = c(59, 51, 57, 65, 21, 80),
      SEX = c("F", "M", "F", "M", "F", "M"),
      WEIGHTBL = c(83.6, 75, 84, 90, 65, 70),
      colnbr = structure(
        c(1L, 3L, 2L, 2L, 3L, 1L),
        .Label = c("Placebo", "Low", "High"),
        class = "factor"
      )
    ),
    row.names = c(NA, 6L),
    class = "data.frame"
  )

# N, Mean(SD), Median, Range, IQ Range for a rowvar by colvar
univar(adsl
       ,colvar = "colnbr"
       ,rowvar = "AGE")

# N and Mean for a rowvar by colvar
univar(adsl
       ,colvar   = "colnbr"
       ,rowvar   = "AGE"
       ,statlist = statlist(c("N", "MEAN")))

# N and Mean for a rowvar by colvar and a by variable
univar(adsl
       ,colvar   = "colnbr"
       ,rowvar   = "AGE"
       ,rowbyvar = "SEX"
       ,statlist = statlist(c("N", "MEAN")))

# Below illustrates how make the same calls to univar() as above, using table
# and column metadata # along with generate_results().

column_metadata &lt;- tibble::tribble(
  ~tbltype, ~coldef,   ~decode,
  "type1",     "0",  "Placebo",
  "type1",     "54",     "Low",
  "type1",     "81",    "High"
)

# N, Mean(SD), Median, Range, IQ Range for a rowvar by colvar
table_metadata &lt;- tibble::tribble(
  ~anbr,  ~func,    ~df, ~rowvar, ~tbltype, ~colvar,
  "1", "univar", "cdisc_adae",   "AGE",  "type1", "TRTA"
)

generate_results(table_metadata, column_metadata = column_metadata,
                 tbltype = "type1")


# N and Mean for a rowvar by colvar
table_metadata &lt;- tibble::tribble(
  ~anbr,  ~func,    ~df, ~rowvar, ~tbltype,  ~colvar, ~statlist,
  "1", "univar", "cdisc_adae",   "AGE",  "type1", "TRTA",
  statlist(c("N","MEAN"))
)

generate_results(table_metadata, column_metadata = column_metadata,
                 tbltype = "type1")


# N and Mean for a rowvar by colvar and a by variable
table_metadata &lt;- tibble::tribble(
  ~anbr,  ~func,    ~df, ~rowvar, ~tbltype,  ~colvar, ~statlist,  ~by,
  "1", "univar", "cdisc_adae",   "AGE",  "type1", "TRTA",
  statlist(c("N","MEAN")), "SEX"
)

generate_results(table_metadata, column_metadata = column_metadata,
                 tbltype = "type1")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
