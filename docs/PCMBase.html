<!DOCTYPE html><html lang="en"><head><title>Help for package PCMBase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PCMBase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Args_MixedGaussian_MGPMDefaultModelTypes'><p>Arguments to be passed to the constructor MixedGaussian when constructing</p>
a MGPM model with some of the default MGPM model types.</a></li>
<li><a href='#Args_MixedGaussian_MGPMScalarOUType'><p>Arguments for the MixedGaussian constructor for scalar OU MGPM models.</p></a></li>
<li><a href='#Args_MixedGaussian_MGPMSurfaceOUType'><p>Arguments for the MixedGaussian constructor for SURFACE OU MGPM models.</p></a></li>
<li><a href='#as.MixedGaussian'><p>Convert a <code>GaussianPCM</code> model object to a <code>MixedGaussian</code> model object</p></a></li>
<li><a href='#dataFig3'><p>Data for Fig3 in the TPB manuscript</p></a></li>
<li><a href='#FormatCellAsLatex'><p>Latex representation of a model parameter or other found in a data.table object</p></a></li>
<li><a href='#FormatTableAsLatex'><p>Latex representation of a data.table with matrix and vectors in its cells</p></a></li>
<li><a href='#is.GaussianPCM'><p>Check if an object is a 'GaussianPCM'</p></a></li>
<li><a href='#is.MixedGaussian'><p>Check if an object is a 'MixedGaussian' PCM</p></a></li>
<li><a href='#is.PCM'><p>Check if an object is a PCM.</p></a></li>
<li><a href='#is.PCMTree'><p>Check that a tree is a PCMTree</p></a></li>
<li><a href='#MatchListMembers'><p>Find the members in a list matching a member expression</p></a></li>
<li><a href='#MGPMScalarOUType'><p>Class name for the scalar OU MGPM model type</p></a></li>
<li><a href='#MGPMSurfaceOUType'><p>Class name for the SURFACE OU MGPM model type</p></a></li>
<li><a href='#MixedGaussian'><p>Create a multi-regime Gaussian model (MixedGaussian)</p></a></li>
<li><a href='#MixedGaussianTemplate'><p>Create a template MixedGaussian object containing a regime for each model type</p></a></li>
<li><a href='#PCM'><p>Create a phylogenetic comparative model object</p></a></li>
<li><a href='#PCMAbCdEf'><p>Quadratic polynomial parameters A, b, C, d, E, f for each node</p></a></li>
<li><a href='#PCMAddToListAttribute'><p>Add a value to a list-valued attribute of a member or members matching a pattern</p></a></li>
<li><a href='#PCMApplyTransformation'><p>Map a parametrization to its original form.</p></a></li>
<li><a href='#PCMBaseIsADevRelease'><p>Check if the PCMBase version corresponds to a dev release</p></a></li>
<li><a href='#PCMBaseTestObjects'><p>Test objects for the PCMBase package</p></a></li>
<li><a href='#PCMColorPalette'><p>A fixed palette of n colors</p></a></li>
<li><a href='#PCMCombineListAttribute'><p>Combine all member attributes of a given name into a list</p></a></li>
<li><a href='#PCMCond'><p>Conditional distribution of a daughter node given its parent node</p></a></li>
<li><a href='#PCMCond.GaussianPCM'><p>Conditional distribution of a daughter node given its parent node</p></a></li>
<li><a href='#PCMCondVOU'><p>Variance-covariance matrix of an OU process with optional measurement error and jump at the start</p></a></li>
<li><a href='#PCMCreateLikelihood'><p>Create a likelihood function of a numerical vector parameter</p></a></li>
<li><a href='#PCMDefaultModelTypes'><p>Class names for the the default PCM and MGPM model types</p></a></li>
<li><a href='#PCMDefaultObject'><p>Generate a default object of a given PCM model type or parameter type</p></a></li>
<li><a href='#PCMDescribe'><p>Human friendly description of a PCM</p></a></li>
<li><a href='#PCMDescribeParameters'><p>Describe the parameters of a PCM</p></a></li>
<li><a href='#PCMExtractDimensions'><p>Given a PCM or a parameter object, extract an analogical object for a subset</p>
of the dimensions (traits) in the original object.</a></li>
<li><a href='#PCMExtractRegimes'><p>Given a PCM or a parameter object, extract an analogical object for a subset</p>
of the regimes in the original object.</a></li>
<li><a href='#PCMFindMethod'><p>Find the S3 method for a given PCM object or class-name and an S3 generic</p></a></li>
<li><a href='#PCMFixParameter'><p>Fix a parameter in a PCM model</p></a></li>
<li><a href='#PCMGenerateModelTypes'><p>Generate default model types for given PCM base-classes</p></a></li>
<li><a href='#PCMGenerateParameterizations'><p>Generate possible parameterizations for a given type of model</p></a></li>
<li><a href='#PCMGetAttribute'><p>Value of an attribute of an object or values for an attribute found in its members</p></a></li>
<li><a href='#PCMGetVecParamsRegimesAndModels'><p>Get a vector of all parameters (real and discrete) describing a model on a</p>
tree including the numerical parameters of each model regime, the integer ids
of the splitting nodes defining the regimes on the tree and the integer ids of
the model types associated with each regime.</a></li>
<li><a href='#PCMInfo'><p>Meta-information about a tree and trait data associated with a PCM</p></a></li>
<li><a href='#PCMLik'><p>Likelihood of a multivariate Gaussian phylogenetic comparative model with non-interacting lineages</p></a></li>
<li><a href='#PCMLikDmvNorm'><p>Calculate the likelihood of a model using the standard formula for multivariate pdf</p></a></li>
<li><a href='#PCMLikTrace'><p>Tracing the log-likelihood calculation of a model over each node of the tree</p></a></li>
<li><a href='#PCMListMembers'><p>A vector of access-code strings to all members of a named list</p></a></li>
<li><a href='#PCMListParameterizations'><p>Specify the parameterizations for each parameter of a model</p></a></li>
<li><a href='#PCMLmr'><p>Quadratic polynomial parameters L, m, r</p></a></li>
<li><a href='#PCMMapModelTypesToRegimes'><p>Integer vector giving the model type index for each regime</p></a></li>
<li><a href='#PCMMean'><p>Expected mean vector at each tip conditioned on a trait-value vector at the root</p></a></li>
<li><a href='#PCMMeanAtTime'><p>Calculate the mean at time t, given X0, under a PCM model</p></a></li>
<li><a href='#PCMModels'><p>Get a list of PCM models currently implemented</p></a></li>
<li><a href='#PCMModelTypes'><p>Get the model type(s) of a model</p></a></li>
<li><a href='#PCMNumRegimes'><p>Number of regimes in a obj</p></a></li>
<li><a href='#PCMNumTraits'><p>Number of traits modeled by a PCM</p></a></li>
<li><a href='#PCMOptions'><p>Global options for the PCMBase package</p></a></li>
<li><a href='#PCMPairSums'><p>Sums of pairs of elements in a vector</p></a></li>
<li><a href='#PCMParam'><p>Module PCMParam</p></a></li>
<li><a href='#PCMParamBindRegimeParams'><p>Bind named vectors or matrices into an array so that the names form the names of the last dimension.</p></a></li>
<li><a href='#PCMParamCount'><p>Count the number of free parameters associated with a PCM or a PCM-parameter</p></a></li>
<li><a href='#PCMParamGetShortVector'><p>Get a vector of the variable numeric parameters in a model</p></a></li>
<li><a href='#PCMParamLoadOrStore'><p>Load (or store) a PCM parameter from (or to) a vector of the variable parameters in a model.</p></a></li>
<li><a href='#PCMParamLocateInShortVector'><p>Locate a named parameter in the short vector representation of a model</p></a></li>
<li><a href='#PCMParamLowerLimit'><p>The lower limit for a given model or parameter type</p></a></li>
<li><a href='#PCMParamRandomVecParams'><p>Generate a random parameter vector for a model using uniform distribution</p>
between its lower and upper bounds.</a></li>
<li><a href='#PCMParamSetByName'><p>Set model parameters from a named list</p></a></li>
<li><a href='#PCMParamType'><p>Parameter types</p></a></li>
<li><a href='#PCMParamUpperLimit'><p>The upper limit for a given model or parameter type</p></a></li>
<li><a href='#PCMParentClasses'><p>Parent S3 classes for a model class</p></a></li>
<li><a href='#PCMParseErrorMessage'><p>Extract error information from a formatted error message.</p></a></li>
<li><a href='#PCMPExpxMeanExp'><p>Create a function of time that calculates <code class="reqn">(1-exp(-lambda_ij*time))/lambda_ij</code></p>
for every element <code class="reqn">lambda_ij</code> of the input matrix <code class="reqn">Lambda_ij</code>.</a></li>
<li><a href='#PCMPLambdaP_1'><p>Eigen-decomposition of a matrix H</p></a></li>
<li><a href='#PCMPlotGaussianDensityGrid2D'><p>A 2D Gaussian distribution density grid in the form of a ggplot object</p></a></li>
<li><a href='#PCMPlotGaussianSample2D'><p>A 2D sample from Gaussian distribution</p></a></li>
<li><a href='#PCMPlotMath'><p>Beautiful model description based on plotmath</p></a></li>
<li><a href='#PCMPlotTraitData2D'><p>Scatter plot of 2-dimensional data</p></a></li>
<li><a href='#PCMPresentCoordinates'><p>Determine which traits are present (active) on each node of the tree</p></a></li>
<li><a href='#PCMRegimes'><p>Get the regimes (aka colors) of a PCM or of a PCMTree object</p></a></li>
<li><a href='#PCMSetAttribute'><p>Set an attribute of a named member in a PCM or other named list object</p></a></li>
<li><a href='#PCMSim'><p>Simulation of a phylogenetic comparative model on a tree</p></a></li>
<li><a href='#PCMSpecify'><p>Parameter specification of PCM model</p></a></li>
<li><a href='#PCMTable'><p>A data.table representation of a PCM object</p></a></li>
<li><a href='#PCMTableParameterizations'><p>Cartesian product of possible parameterizations for the different parameters of a model</p></a></li>
<li><a href='#PCMTrajectory'><p>Generate a trajectory for the mean in one regime of a PCM</p></a></li>
<li><a href='#PCMTree'><p>Create a PCMTree object from a phylo object</p></a></li>
<li><a href='#PCMTreeBackbonePartition'><p>Prune the tree leaving one tip for each or some of its parts</p></a></li>
<li><a href='#PCMTreeDropClade'><p>Drop a clade from a phylogenetic tree</p></a></li>
<li><a href='#PCMTreeDtNodes'><p>A data.table with time, part and regime information for the nodes in a tree</p></a></li>
<li><a href='#PCMTreeEdgeTimes'><p>A matrix with the begin and end time from the root for each edge in tree</p></a></li>
<li><a href='#PCMTreeEvalNestedEDxOnTree'><p>Perfrorm nested extractions or drops of clades from a tree</p></a></li>
<li><a href='#PCMTreeExtractClade'><p>Extract a clade from phylogenetic tree</p></a></li>
<li><a href='#PCMTreeGetBranchLength'><p>The length of the branch leading to a node</p></a></li>
<li><a href='#PCMTreeGetDaughters'><p>A vector of the daughter nodes for a given parent node id in a tree</p></a></li>
<li><a href='#PCMTreeGetLabels'><p>Node labels of a tree</p></a></li>
<li><a href='#PCMTreeGetParent'><p>The parent node id of a daughter node in a tree</p></a></li>
<li><a href='#PCMTreeGetPartition'><p>Get the starting branch' nodes for each part on a tree</p></a></li>
<li><a href='#PCMTreeGetPartNames'><p>Unique parts on a tree in the order of occurrence from the root to the tips (preorder)</p></a></li>
<li><a href='#PCMTreeGetPartRegimes'><p>Regime mapping for the parts in a tree</p></a></li>
<li><a href='#PCMTreeGetPartsForNodes'><p>Get the parts of the branches leading to a set of nodes or tips</p></a></li>
<li><a href='#PCMTreeGetRegimesForEdges'><p>Model regimes (i.e. colors) associated with the branches in a tree</p></a></li>
<li><a href='#PCMTreeGetRegimesForNodes'><p>Get the regimes of the branches leading to a set of nodes or tips</p></a></li>
<li><a href='#PCMTreeGetTipsInPart'><p>Get the tips belonging to a part in a tree</p></a></li>
<li><a href='#PCMTreeGetTipsInRegime'><p>Get the tips belonging to a regime in a tree</p></a></li>
<li><a href='#PCMTreeInsertSingletons'><p>Insert tips or singleton nodes on chosen edges</p></a></li>
<li><a href='#PCMTreeJumps'><p>Jumps in modeled traits associated with branches in a tree</p></a></li>
<li><a href='#PCMTreeListAllPartitions'><p>A list of all possible (including recursive) partitions of a tree</p></a></li>
<li><a href='#PCMTreeListCladePartitions'><p>A list of all possible clade partitions of a tree with a number of splitting nodes</p></a></li>
<li><a href='#PCMTreeListDescendants'><p>A list of the descendants for each node in a tree</p></a></li>
<li><a href='#PCMTreeListRootPaths'><p>A list of the path to the root from each node in a tree</p></a></li>
<li><a href='#PCMTreeLocateEpochOnBranches'><p>Find the crossing points of an epoch-time with each lineage of a tree</p></a></li>
<li><a href='#PCMTreeLocateMidpointsOnBranches'><p>Find the middle point of each branch longer than a threshold</p></a></li>
<li><a href='#PCMTreeMatchLabels'><p>Get the node numbers associated with tip- or node-labels in a tree</p></a></li>
<li><a href='#PCMTreeMatrixNodesInSamePart'><p>Which couples from a given set of nodes in a tree belong to the same part?</p></a></li>
<li><a href='#PCMTreeNearestNodesToEpoch'><p>Find the nearest node to a given time from the root (epoch) on each lineage crossing this epoch</p></a></li>
<li><a href='#PCMTreeNodeTimes'><p>Calculate the time from the root to each node of the tree</p></a></li>
<li><a href='#PCMTreeNumNodes'><p>Number of all nodes in a tree</p></a></li>
<li><a href='#PCMTreeNumParts'><p>Number of unique parts on a tree</p></a></li>
<li><a href='#PCMTreeNumTips'><p>Wrapper for length(tree$tip.label)</p></a></li>
<li><a href='#PCMTreePlot'><p>Plot a tree with parts and regimes assigned to these parts</p></a></li>
<li><a href='#PCMTreePostorder'><p>Post-order tree traversal</p></a></li>
<li><a href='#PCMTreePreorder'><p>Pre-order tree traversal</p></a></li>
<li><a href='#PCMTreeSetLabels'><p>Set tip and internal node labels in a tree</p></a></li>
<li><a href='#PCMTreeSetPartition'><p>Set a partition of a tree by specifying the partition nodes</p></a></li>
<li><a href='#PCMTreeSetPartRegimes'><p>Set regimes for the parts in a tree</p></a></li>
<li><a href='#PCMTreeSetRegimesForEdges'><p>Set the regime for each individual edge in a tree explicitly</p></a></li>
<li><a href='#PCMTreeSplitAtNode'><p>Slit a tree at a given internal node into a clade rooted at this node and the remaining tree after dropping this clade</p></a></li>
<li><a href='#PCMTreeTableAncestors'><p>A matrix (table) of ancestors/descendants for each node in a tree</p></a></li>
<li><a href='#PCMTreeToString'><p>A character representation of a phylo object.</p></a></li>
<li><a href='#PCMTreeVCV'><p>Phylogenetic Variance-covariance matrix</p></a></li>
<li><a href='#PCMUnfixParameter'><p>Unfix a parameter in a PCM model</p></a></li>
<li><a href='#PCMVar'><p>Expected variance-covariance matrix for each couple of tips (i,j)</p></a></li>
<li><a href='#PCMVarAtTime'><p>Calculate the variance covariance k x k matrix at time t, under a PCM model</p></a></li>
<li><a href='#RequireSuggestedPackages'><p>Check if all packages listed in Suggests are available</p></a></li>
<li><a href='#TruePositiveRate'><p>True positive rate of a set of binary predictions against their trues</p></a></li>
<li><a href='#UpperTriFactor'><p>Upper triangular factor of a symmetric positive definite matrix</p></a></li>
<li><a href='#White'><p>White Gaussian PCM ignoring phylogenetic history</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Likelihood Calculation of Phylogenetic
Comparative Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Venelin Mitov &lt;vmitov@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Phylogenetic comparative methods represent models of continuous trait 
  data associated with the tips of a phylogenetic tree. Examples of such models 
  are Gaussian continuous time branching stochastic processes such as Brownian 
  motion (BM) and Ornstein-Uhlenbeck (OU) processes, which regard the data at the 
  tips of the tree as an observed (final) state of a Markov process starting from 
  an initial state at the root and evolving along the branches of the tree. The 
  PCMBase R package provides a general framework for manipulating such models. 
  This framework consists of an application programming interface for specifying 
  data and model parameters, and efficient algorithms for simulating trait evolution 
  under a model and calculating the likelihood of model parameters for an assumed
  model and trait data. The package implements a growing collection of models, 
  which currently includes BM, OU, BM/OU with jumps, two-speed OU as well as mixed 
  Gaussian models, in which different types of the above models can be associated 
  with different branches of the tree. The PCMBase package is limited to 
  trait-simulation and likelihood calculation of (mixed) Gaussian phylogenetic 
  models. The PCMFit package provides functionality for inference of 
  these models to tree and trait data. The package web-site 
  <a href="https://venelin.github.io/PCMBase/">https://venelin.github.io/PCMBase/</a>
  provides access to the documentation and other resources. </td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, abind, expm, mvtnorm, data.table, ggplot2, xtable</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, ggtree, cowplot, covr, mvSLOUCH,
BiocManager</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://venelin.github.io/PCMBase/">https://venelin.github.io/PCMBase/</a>, <a href="https://venelin.github.io">https://venelin.github.io</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/venelin/PCMBase/issues">https://github.com/venelin/PCMBase/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 15:52:33 UTC; venelin</td>
</tr>
<tr>
<td>Author:</td>
<td>Venelin Mitov [aut, cre, cph] (&lt;a
    href="https://venelin.github.io"&gt;venelin.github.io&lt;/a&gt;),
  Krzysztof Bartoszek [ctb],
  Georgios Asimomitis [ctb],
  Tanja Stadler [ths]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Args_MixedGaussian_MGPMDefaultModelTypes'>Arguments to be passed to the constructor MixedGaussian when constructing
a MGPM model with some of the default MGPM model types.</h2><span id='topic+Args_MixedGaussian_MGPMDefaultModelTypes'></span>

<h3>Description</h3>

<p>Arguments to be passed to the constructor MixedGaussian when constructing
a MGPM model with some of the default MGPM model types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Args_MixedGaussian_MGPMDefaultModelTypes(omitGlobalSigmae_x = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Args_MixedGaussian_MGPMDefaultModelTypes_+3A_omitglobalsigmae_x">omitGlobalSigmae_x</code></td>
<td>
<p>logical, indicating if the returned list should specify
the global Sigmae_x parameter as '_Omitted'. Default: TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named arguments. Currently only a named element Sigmae_x
with specification depending on <code>omitGlobalSigmae_x</code>.
</p>


<h3>See Also</h3>

<p>MGPMDefaultModelTypes
</p>

<hr>
<h2 id='Args_MixedGaussian_MGPMScalarOUType'>Arguments for the MixedGaussian constructor for scalar OU MGPM models.</h2><span id='topic+Args_MixedGaussian_MGPMScalarOUType'></span>

<h3>Description</h3>

<p>Arguments for the MixedGaussian constructor for scalar OU MGPM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Args_MixedGaussian_MGPMScalarOUType()
</code></pre>


<h3>Value</h3>

<p>a list.
</p>

<hr>
<h2 id='Args_MixedGaussian_MGPMSurfaceOUType'>Arguments for the MixedGaussian constructor for SURFACE OU MGPM models.</h2><span id='topic+Args_MixedGaussian_MGPMSurfaceOUType'></span>

<h3>Description</h3>

<p>Arguments for the MixedGaussian constructor for SURFACE OU MGPM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Args_MixedGaussian_MGPMSurfaceOUType()
</code></pre>


<h3>Value</h3>

<p>a list.
</p>

<hr>
<h2 id='as.MixedGaussian'>Convert a <code>GaussianPCM</code> model object to a <code>MixedGaussian</code> model object</h2><span id='topic+as.MixedGaussian'></span>

<h3>Description</h3>

<p>Convert a <code>GaussianPCM</code> model object to a <code>MixedGaussian</code> model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.MixedGaussian(o, modelTypes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.MixedGaussian_+3A_o">o</code></td>
<td>
<p>an R object: either a <code>GaussianPCM</code> or a <code>MixedGaussian</code>.</p>
</td></tr>
<tr><td><code id="as.MixedGaussian_+3A_modeltypes">modelTypes</code></td>
<td>
<p>NULL (the default) or a (possibly named) character string
vector. Each such string denotes a mixed Gaussian regime model class, e.g.
the result of calling <code>MGPMDefaultModelTypes()</code>. If specified, an
attempt is made to match the deduced Gaussian regime model type from <code>o</code>
with the elements of <code>modelTypes</code> and an error is raised if the match
fails. If the match succeeds the converted MixedGaussian object will have the
specified <code>modelTypes</code> parameter as an attribute <code>"modelTypes"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MixedGaussian</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mg &lt;- as.MixedGaussian(PCMBaseTestObjects$model.ab.123.bSigmae_x)
stopifnot(
  PCMLik(
    X = PCMBaseTestObjects$traits.ab.123,
    PCMBaseTestObjects$tree.ab,
    PCMBaseTestObjects$model.ab.123.bSigmae_x) ==
  PCMLik(
    X = PCMBaseTestObjects$traits.ab.123,
    PCMBaseTestObjects$tree.ab,
    mg))

</code></pre>

<hr>
<h2 id='dataFig3'>Data for Fig3 in the TPB manuscript</h2><span id='topic+dataFig3'></span>

<h3>Description</h3>

<p>A list containing simulated tree, models and data used in Fig. 3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataFig3
</code></pre>


<h3>Format</h3>

<p>This is a list containing the following named elements representing
simulation parameters, a simulated tree and PCM objects, used in Fig. 3. For
details on all these objects, read the file data-raw/Fig3.Rmd.
</p>

<hr>
<h2 id='FormatCellAsLatex'>Latex representation of a model parameter or other found in a data.table object</h2><span id='topic+FormatCellAsLatex'></span>

<h3>Description</h3>

<p>Latex representation of a model parameter or other found in a data.table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormatCellAsLatex(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FormatCellAsLatex_+3A_x">x</code></td>
<td>
<p>an R object. Currently, character vectors of length 1,
numeric vectors and matrices are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string
</p>

<hr>
<h2 id='FormatTableAsLatex'>Latex representation of a data.table with matrix and vectors in its cells</h2><span id='topic+FormatTableAsLatex'></span>

<h3>Description</h3>

<p>Latex representation of a data.table with matrix and vectors in its cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FormatTableAsLatex(x, argsXtable = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FormatTableAsLatex_+3A_x">x</code></td>
<td>
<p>a data.table</p>
</td></tr>
<tr><td><code id="FormatTableAsLatex_+3A_argsxtable">argsXtable</code></td>
<td>
<p>a list (empty list by default) passed to xtable...</p>
</td></tr>
<tr><td><code id="FormatTableAsLatex_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print.xtable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string representing a parseable latex text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- data.table::data.table(
   A = list(
         matrix(c(2, 0, 1.2, 3), 2, 2),
         matrix(c(2.1, 0, 1.2, 3.2, 1.3, 3.4), 3, 2)),
   b = c(2.2, 3.1))
print(FormatTableAsLatex(dt))

</code></pre>

<hr>
<h2 id='is.GaussianPCM'>Check if an object is a 'GaussianPCM'</h2><span id='topic+is.GaussianPCM'></span>

<h3>Description</h3>

<p>Check if an object is a 'GaussianPCM'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.GaussianPCM(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.GaussianPCM_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x inherits from the S3 class 'GaussianPCM', FALSE otherwise.
</p>

<hr>
<h2 id='is.MixedGaussian'>Check if an object is a 'MixedGaussian' PCM</h2><span id='topic+is.MixedGaussian'></span>

<h3>Description</h3>

<p>Check if an object is a 'MixedGaussian' PCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.MixedGaussian(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.MixedGaussian_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x inherits from the S3 class 'MixedGaussian', FALSE otherwise.
</p>

<hr>
<h2 id='is.PCM'>Check if an object is a PCM.</h2><span id='topic+is.PCM'></span>

<h3>Description</h3>

<p>Check if an object is a PCM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.PCM(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.PCM_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if 'x' inherits from the S3 class &quot;PCM&quot;.
</p>

<hr>
<h2 id='is.PCMTree'>Check that a tree is a PCMTree</h2><span id='topic+is.PCMTree'></span>

<h3>Description</h3>

<p>Check that a tree is a PCMTree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.PCMTree(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.PCMTree_+3A_tree">tree</code></td>
<td>
<p>a tree object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical TRUE if 'inherits(tree, &quot;PCMTree&quot;)' is TRUE.
</p>

<hr>
<h2 id='MatchListMembers'>Find the members in a list matching a member expression</h2><span id='topic+MatchListMembers'></span>

<h3>Description</h3>

<p>Find the members in a list matching a member expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchListMembers(object, member, enclos = "?", q = "'", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatchListMembers_+3A_object">object</code></td>
<td>
<p>a list containing named elements.</p>
</td></tr>
<tr><td><code id="MatchListMembers_+3A_member">member</code></td>
<td>
<p>a member expression. Member expressions are character strings
denoting named elements in a list object (see examples).</p>
</td></tr>
<tr><td><code id="MatchListMembers_+3A_enclos">enclos</code></td>
<td>
<p>a character string containing the special symbol '?'. This
symbol is to be replaced by matching expressions. The result of this
substitution can be anything but, usually would be a valid R expression.
Default: &quot;?&quot;.</p>
</td></tr>
<tr><td><code id="MatchListMembers_+3A_q">q</code></td>
<td>
<p>a quote symbol, Default: <code>"'"</code>.</p>
</td></tr>
<tr><td><code id="MatchListMembers_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+grep">grep</a></code>. For example,
these could be <code>ignore.case=TRUE</code> or <code>perl=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named character vector, with names corresponding to the matched
member quoted expressions (using the argument <code>q</code> as a quote symbol),
and values corresponding to the '<code>enclos</code>-ed' expressions after
substituting the '?'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMListMembers">PCMListMembers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- PCMBaseTestObjects$model_MixedGaussian_ab
MatchListMembers(model, "Sigma_x", "diag(model?[,,1L])")
MatchListMembers(model, "S.*_x", "diag(model?[,,1L])")
MatchListMembers(model, "Sigma_x", "model?[,,1L][upper.tri(model?[,,1L])]")
MatchListMembers(model, "a$Sigma_x", "model?[,,1L][upper.tri(model?[,,1L])]")

</code></pre>

<hr>
<h2 id='MGPMScalarOUType'>Class name for the scalar OU MGPM model type</h2><span id='topic+MGPMScalarOUType'></span>

<h3>Description</h3>

<p>Class name for the scalar OU MGPM model type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGPMScalarOUType()
</code></pre>


<h3>Value</h3>

<p>a character vector of one named element (ScalarOU)
</p>

<hr>
<h2 id='MGPMSurfaceOUType'>Class name for the SURFACE OU MGPM model type</h2><span id='topic+MGPMSurfaceOUType'></span>

<h3>Description</h3>

<p>Class name for the SURFACE OU MGPM model type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGPMSurfaceOUType()
</code></pre>


<h3>Value</h3>

<p>a character vector of one named element (SURFACE)
</p>

<hr>
<h2 id='MixedGaussian'>Create a multi-regime Gaussian model (MixedGaussian)</h2><span id='topic+MixedGaussian'></span>

<h3>Description</h3>

<p>Create a multi-regime Gaussian model (MixedGaussian)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixedGaussian(
  k,
  modelTypes,
  mapping,
  className = paste0("MixedGaussian_", do.call(paste0, as.list(mapping))),
  X0 = structure(0, class = c("VectorParameter", "_Global"), description =
    "trait values at the root"),
  ...,
  Sigmae_x = structure(0, class = c("MatrixParameter", "_UpperTriangularWithDiagonal",
    "_WithNonNegativeDiagonal", "_Global"), description =
    "Upper triangular factor of the non-phylogenetic variance-covariance")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MixedGaussian_+3A_k">k</code></td>
<td>
<p>integer specifying the number of traits.</p>
</td></tr>
<tr><td><code id="MixedGaussian_+3A_modeltypes">modelTypes</code>, <code id="MixedGaussian_+3A_mapping">mapping</code></td>
<td>
<p>These two arguments define the mapping between the
regimes in the model and actual types of models. For convenience, different
combinations are possible as explained below:
</p>

<ul>
<li> <p><code>modelTypes</code> is a (possibly named) character string vector. Each
such string denotes a mixed Gaussian regime model class, e.g. the result of calling
<code>MGPMDefaultModelTypes()</code>. In that case <code>mapping</code> can be either
an integer vector with values corresponding to indices in <code>modelTypes</code>
or a character string vector. If <code>mapping</code> is a character string vector,
first it is matched against <code>names(modelTypes)</code> and if the match fails
either because of <code>names(modelTypes)</code> being <code>NULL</code> or because some
of the entries in <code>mapping</code> are not present in <code>names(modelTypes)</code>,
then an attempt is made to match <code>mapping</code> against <code>modelTypes</code>,
i.e. it is assumed that <code>mapping</code> contains actual class names.
</p>
</li>
<li> <p><code>modelTypes</code> is a (possibly named) list of PCM models of
<code>k</code> traits. In this case <code>mapping</code> can again be an integer vector
denoting indices in <code>modelTypes</code> or a character string vector denoting
names in <code>modelTypes</code>.
</p>
</li></ul>

<p>As a final note, <code>mapping</code> can also be named. In this case the names are
assumed to be the names of the different regimes in the model. If
<code>mapping</code> is not named, the regimes are named automatically as
<code>as.character(seq_len(mapping))</code>.  For example, if
<code>modelTypes = c("BM", "OU")</code> and
<code>mapping = c(a = 1, b = 1, c = 2, d = 1)</code> defines an MixedGaussian with
four different regimes named 'a', 'b', 'c', 'd', and  model-types
BM, BM, OU and BM, corresponding to each regime.</p>
</td></tr>
<tr><td><code id="MixedGaussian_+3A_classname">className</code></td>
<td>
<p>a character string defining a valid S3 class name for the
resulting MixedGaussian object. If not specified, a className is generated
using the expression
<code> paste0("MixedGaussian_", do.call(paste0, as.list(mapping)))</code>.</p>
</td></tr>
<tr><td><code id="MixedGaussian_+3A_x0">X0</code></td>
<td>
<p>specification for the global vector X0 to be used by all
models in the MixedGaussian.</p>
</td></tr>
<tr><td><code id="MixedGaussian_+3A_...">...</code></td>
<td>
<p>specifications for other _Global parameters coming after X0.</p>
</td></tr>
<tr><td><code id="MixedGaussian_+3A_sigmae_x">Sigmae_x</code></td>
<td>
<p>sepcification of a _Global Sigmae_x parameter. This is used
by Submodels only if they have Sigmae_x _Omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If X0 is not NULL it has no sense to use model-types including X0 as
a parameter (e.g. use BM1 or BM3 instead of BM or BM2). Similarly if Sigmae_x
is not NULL there is no meaning in using model-types including Sigmae_x as a
parameter, (e.g. use OU2 or OU3 instead of OU or OU1).
</p>


<h3>Value</h3>

<p>an object of S3 class className inheriting from MixedGaussian,
GaussianPCM and PCM.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMTreeGetPartNames">PCMTreeGetPartNames</a></code>
</p>
<p><code><a href="#topic+PCMModels">PCMModels</a>()</code>
</p>

<hr>
<h2 id='MixedGaussianTemplate'>Create a template MixedGaussian object containing a regime for each model type</h2><span id='topic+MixedGaussianTemplate'></span>

<h3>Description</h3>

<p>Create a template MixedGaussian object containing a regime for each model type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixedGaussianTemplate(mg, modelTypes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MixedGaussianTemplate_+3A_mg">mg</code></td>
<td>
<p>a MixedGaussian object or an object that can be converted to such
via <code><a href="#topic+as.MixedGaussian">as.MixedGaussian</a></code>.</p>
</td></tr>
<tr><td><code id="MixedGaussianTemplate_+3A_modeltypes">modelTypes</code></td>
<td>
<p>a (possibly named) character string
vector. Each such string denotes a mixed Gaussian regime model class, e.g.
the result of calling <code>MGPMDefaultModelTypes()</code>. If specified, an
attempt is made to match <code>PCMModelTypes(as.MixedGaussian(mg))</code>
with the elements of <code>modelTypes</code> and an error is raised if the match
fails. If not named, the model
types and regimes in the resulting MixedGaussian object are named by the
capital latin letters A,B,C,.... Default: <code>NULL</code>, which is interpreted
as <code>PCMModelTypes(as.MixedGaussian(mg, NULL))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a MixedGaussian with the same global parameter settings as for mg,
the same modelTypes as <code>modelTypes</code>, and with a regime for each model type.
The function will stop with an error if <code>mg</code> is not convertible to
a MixedGaussian object or if there is a mismatch between the model types in
<code>mg</code> and <code>modelTypes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mg &lt;- MixedGaussianTemplate(PCMBaseTestObjects$model.ab.123.bSigmae_x)
mgTemplBMOU &lt;- MixedGaussianTemplate(PCMBaseTestObjects$model.OU.BM)
</code></pre>

<hr>
<h2 id='PCM'>Create a phylogenetic comparative model object</h2><span id='topic+PCM'></span>

<h3>Description</h3>

<p>This is the entry-point function for creating model objects
within the PCMBase framework representing a single model-type with one or
several model-regimes of this type associated with the branches of a tree.
For mixed Gaussian phylogenetic models, which enable multiple model-types,
use the <code><a href="#topic+MixedGaussian">MixedGaussian</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCM(
  model,
  modelTypes = class(model)[1],
  k = 1L,
  regimes = 1L,
  params = NULL,
  vecParams = NULL,
  offset = 0L,
  spec = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCM_+3A_model">model</code></td>
<td>
<p>This argument can take one of the following forms:
</p>

<ul>
<li><p> a character vector of the S3-classes of the model object to be
created (one model object can have one or more S3-classes, with the class
PCM at the origin of the hierarchy);
</p>
</li>
<li><p> an S3 object which's class inherits from the PCM S3 class.
</p>
</li></ul>

<p>The Details section explains how these two types of input are processed.</p>
</td></tr>
<tr><td><code id="PCM_+3A_modeltypes">modelTypes</code></td>
<td>
<p>a character string vector specifying a set (family) of
model-classes, to which the constructed model object belongs. These are used
for model-selection.</p>
</td></tr>
<tr><td><code id="PCM_+3A_k">k</code></td>
<td>
<p>integer denoting the number of traits (defaults to 1).</p>
</td></tr>
<tr><td><code id="PCM_+3A_regimes">regimes</code></td>
<td>
<p>a character or integer vector denoting the regimes.</p>
</td></tr>
<tr><td><code id="PCM_+3A_params">params</code></td>
<td>
<p>NULL (default) or a list of parameter values (scalars, vectors,
matrices, or arrays) or sub-models (S3 objects inheriting from the PCM class).
See details.</p>
</td></tr>
<tr><td><code id="PCM_+3A_vecparams">vecParams</code></td>
<td>
<p>NULL (default) or a numeric vector the vector
representation of the variable parameters in the model. See details.</p>
</td></tr>
<tr><td><code id="PCM_+3A_offset">offset</code></td>
<td>
<p>integer offset in vecParams; see Details.</p>
</td></tr>
<tr><td><code id="PCM_+3A_spec">spec</code></td>
<td>
<p>NULL or a list specifying the model parameters (see
<code><a href="#topic+PCMSpecify">PCMSpecify</a></code>). If NULL (default), the generic PCMSpecify
is called on the created object of class <code>model</code>.</p>
</td></tr>
<tr><td><code id="PCM_+3A_...">...</code></td>
<td>
<p>additional parameters intended for use by sub-classes of the PCM
class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic. The PCMBase package defines three methods for
it:
</p>

<dl>
<dt>PCM.PCM: </dt><dd><p>A default constructor for any object with a class inheriting
from &quot;PCM&quot;.</p>
</dd>
<dt>PCM.character: </dt><dd><p>A default PCM constructor from a character string
specifying the type of model.</p>
</dd>
<dt>PCM.default: </dt><dd><p>A default constructor called when no other constructor
is found. When called this constructor raises an error message.</p>
</dd>
</dl>



<h3>Value</h3>

<p>an object of S3 class as defined by the argument <code>model</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MixedGaussian">MixedGaussian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a Brownian motion model with one regime
modelBM &lt;- PCM(model = "BM", k = 2)
# print the model
modelBM

# a BM model with two regimes
modelBM.ab &lt;- PCM("BM", k = 2, regimes = c("a", "b"))
modelBM.ab

# print a single parameter of the model (in this case, the root value)
modelBM.ab$X0

# assign a value to this parameter (note that the brackets [] are necessary
# to preserve  the parameter attributes):
modelBM.ab$X0[] &lt;- c(5, 2)

PCMNumTraits(modelBM)
PCMNumRegimes(modelBM)
PCMNumRegimes(modelBM.ab)

# number of numerical parameters in the model
PCMParamCount(modelBM)

# Get a vector representation of all parameters in the model
PCMParamGetShortVector(modelBM)

# Limits for the model parameters:
lowerLimit &lt;- PCMParamLowerLimit(modelBM)
upperLimit &lt;- PCMParamUpperLimit(modelBM)

# assign the model parameters at random: this will use uniform distribution
# with boundaries specified by PCMParamLowerLimit and PCMParamUpperLimit
# We do this in two steps:
# 1. First we generate a random vector. Note the length of the vector equals PCMParamCount(modelBM)
randomParams &lt;- PCMParamRandomVecParams(modelBM, PCMNumTraits(modelBM), PCMNumRegimes(modelBM))
randomParams
# 2. Then we load this random vector into the model.
PCMParamLoadOrStore(modelBM, randomParams, 0, PCMNumTraits(modelBM), PCMNumRegimes(modelBM), TRUE)

print(modelBM)

PCMParamGetShortVector(modelBM)

# generate a random phylogenetic tree of 10 tips
tree &lt;- ape::rtree(10)

#simulate the model on the tree
traitValues &lt;- PCMSim(tree, modelBM, X0 = modelBM$X0)

# calculate the likelihood for the model parameters, given the tree and the trait values
PCMLik(traitValues, tree, modelBM)

# create a likelihood function for faster processing for this specific model.
# This function is convenient for calling in optim because it recieves and parameter
# vector instead of a model object.
likFun &lt;- PCMCreateLikelihood(traitValues, tree, modelBM)
likFun(randomParams)
</code></pre>

<hr>
<h2 id='PCMAbCdEf'>Quadratic polynomial parameters A, b, C, d, E, f for each node</h2><span id='topic+PCMAbCdEf'></span>

<h3>Description</h3>

<p>An S3 generic function that has to be implemented for every
model class. This function is called by <code><a href="#topic+PCMLik">PCMLik</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMAbCdEf(
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(NULL, tree, model, verbose = verbose),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMAbCdEf_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMAbCdEf_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMAbCdEf_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMAbCdEf_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMAbCdEf_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>

<hr>
<h2 id='PCMAddToListAttribute'>Add a value to a list-valued attribute of a member or members matching a pattern</h2><span id='topic+PCMAddToListAttribute'></span>

<h3>Description</h3>

<p>Add a value to a list-valued attribute of a member or members matching a pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMAddToListAttribute(
  name,
  value,
  object,
  member = "",
  enclos = "?",
  spec = TRUE,
  inplace = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMAddToListAttribute_+3A_name">name</code></td>
<td>
<p>a character string denoting the attribute name.</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_value">value</code></td>
<td>
<p>the value for the attribute.</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_object">object</code></td>
<td>
<p>a PCM or a list object.</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_member">member</code></td>
<td>
<p>a member expression. Member expressions are character strings
denoting named elements in a list object (see examples). Default: &quot;&quot;.</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_enclos">enclos</code></td>
<td>
<p>a character string containing the special symbol '?'. This
symbol is to be replaced by matching expressions. The result of this
substitution can be anything but, usually would be a valid R expression.
Default: &quot;?&quot;.</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_spec">spec</code></td>
<td>
<p>a logical (TRUE by default) indicating if the attribute should
also be set in the corresponding member of the spec attribute (this is for
PCM objects only).</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_inplace">inplace</code></td>
<td>
<p>logical (TRUE by default) indicating if the attribute should
be set to the object in the current environment, or a modified object should
be returned.</p>
</td></tr>
<tr><td><code id="PCMAddToListAttribute_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+MatchListMembers">MatchListMembers</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>inplace</code> is <code>TRUE</code> no value is returned. Otherwise, a
modified version of <code>object</code> is returned.
</p>

<hr>
<h2 id='PCMApplyTransformation'>Map a parametrization to its original form.</h2><span id='topic+PCMApplyTransformation'></span>

<h3>Description</h3>

<p>This is an S3 generic that transforms the passed argument by
applying the transformation rules for its S3 class.
</p>
<p>This is an S3 generic. See 'PCMApplyTransformation._CholeskyFactor'
for an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMApplyTransformation(o, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMApplyTransformation_+3A_o">o</code></td>
<td>
<p>a PCM object or a parameter</p>
</td></tr>
<tr><td><code id="PCMApplyTransformation_+3A_...">...</code></td>
<td>
<p>additional arguments that can be used by implementing methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the same object if it is not transformable.
</p>


<h3>Value</h3>

<p>a transformed version of o.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.Transformable">is.Transformable</a></code>
</p>

<hr>
<h2 id='PCMBaseIsADevRelease'>Check if the PCMBase version corresponds to a dev release</h2><span id='topic+PCMBaseIsADevRelease'></span>

<h3>Description</h3>

<p>Check if the PCMBase version corresponds to a dev release
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMBaseIsADevRelease()
</code></pre>


<h3>Value</h3>

<p>a logical
</p>

<hr>
<h2 id='PCMBaseTestObjects'>Test objects for the PCMBase package</h2><span id='topic+PCMBaseTestObjects'></span>

<h3>Description</h3>

<p>A list containing simulated trees, trait-values and model objects for tests
and examples of the PCMBase package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMBaseTestObjects
</code></pre>


<h3>Format</h3>

<p>This is a list containing the following named elements representing
parameters of BM, OU and MixedGaussian models with up to three traits and
up to two regimes, model objects, simulated trees with partition of their
nodes in up to two parts (corresponding to the two regimes), and trait data
simulated on these trees.
</p>

<dl>
<dt>a.H, b.H </dt><dd><p> H matrices for OU models for regimes 'a' and 'b'. </p>
</dd>
<dt>a.Theta, b.Theta </dt><dd><p> Theta vectors for OU models for regimes 'a' and 'b'. </p>
</dd>
<dt>a.Sigma_x, b.Sigma_x </dt><dd><p> Sigma_x matrices for BM and OU models for regimes 'a' and 'b'. </p>
</dd>
<dt>a.Sigmae_x, b.Sigmae_x </dt><dd><p> Sigmae_x matrices regimes 'a' and 'b'. </p>
</dd>
<dt>a.X0, b.X0 </dt><dd><p> X0 vectors for regimes 'a' and 'b'. </p>
</dd>
<dt>H </dt><dd><p> an array resulting from abind(a.H, b.H). </p>
</dd>
<dt>Theta </dt><dd><p> a matrix resulting from cbind(Theta.a, Theta.b). </p>
</dd>
<dt>Sigma_x </dt><dd><p> an array resulting from abind(a.Sigma_x, b.Sigma_x). </p>
</dd>
<dt>Sigmae_x </dt><dd><p> an array resulting from abind(a.Sigmae_x, b.Sigmae_x). </p>
</dd>
<dt>model.a.1, model.a.2, model.a.3 </dt><dd><p> univariate models with a single regime for each of 3 traits. </p>
</dd>
<dt>model.a.1.Omitted_X0 </dt><dd><p> same as model.a.1 but omitting X0; suitable for nesting in an MGPM model. </p>
</dd>
<dt>model.a.123, model.b.123 </dt><dd><p> single-regime 3-variate models. </p>
</dd>
<dt>model.a.123.Omitted_X0 </dt><dd><p> single-regime 3-variate model with omitted X0 (suitable for nesting in an MGPM. </p>
</dd>
<dt>model.a.123.Omitted_X0__bSigmae_x </dt><dd><p> same as model.a.123.Omitted_X0 but with the value of Sigmae_x copied from model.b.123. </p>
</dd>
<dt>model.a.123.Omitted_X0__Omitted_Sigmae_x </dt><dd><p> same as model.a.123 but omitting X0 and Sigmae_x. </p>
</dd>
<dt>model.b.123.Omitted_X0, model.b.123.Omitted_X0__Omitted_Sigmae_x </dt><dd><p> analogical to corresponding model.a.123... </p>
</dd>
<dt>model.ab.123 </dt><dd><p> a two-regime 3-variate model. </p>
</dd>
<dt>model.ab.123.bSigmae_x </dt><dd><p> a two-regime 3-variate model having Sigmae_x from b.Sigmae_x. </p>
</dd>
<dt>model_MixedGaussian_ab </dt><dd><p> a two-regime MGPM model with a local Sigmae_x for each regime. </p>
</dd>
<dt>model_MixedGaussian_ab_globalSigmae_x </dt><dd><p>  a two-regime MGPM model with a global Sigmae_x. </p>
</dd>
<dt>N </dt><dd><p> number of tips in simulated trees </p>
</dd>
<dt>tree_15_tips </dt><dd><p> a tree of 15 tips used for testing clade extraction. </p>
</dd>
<dt>tree.a </dt><dd><p> a tree with one part only (one regime) </p>
</dd>
<dt>tree.ab </dt><dd><p> a tree partitioned in two parts (two regimes) </p>
</dd>
<dt>traits.a.1 </dt><dd><p> trait values simulated with model.a.1. </p>
</dd>
<dt>traits.a.123 </dt><dd><p> trait values simulated with model.a.123. </p>
</dd>
<dt>traits.a.2 </dt><dd><p> trait values simulated with model.a.2. </p>
</dd>
<dt>traits.a.3 </dt><dd><p> trait values simulated with model.a.3. </p>
</dd>
<dt>traits.ab.123 </dt><dd><p> trait values simulated with model.ab.123 on tree.ab. </p>
</dd>
<dt>tree </dt><dd><p>a tree of 5 tips used for examples.</p>
</dd>
<dt>X </dt><dd><p>3-trait data for 5 tips used together with tree for examples. </p>
</dd>
<dt>model.OU.BM </dt><dd><p>a mixed Gaussian phylogenetic model for 3 traits and an OU and BM regime used in examples. </p>
</dd>
</dl>


<hr>
<h2 id='PCMColorPalette'>A fixed palette of n colors</h2><span id='topic+PCMColorPalette'></span>

<h3>Description</h3>

<p>A fixed palette of n colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMColorPalette(
  n,
  names,
  colors = structure(hcl(h = seq(15, 375, length = n + 1), l = 65, c =
    100)[seq_len(n)], names = names)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMColorPalette_+3A_n">n</code></td>
<td>
<p>an integer defining the number of colors in the resulting palette.</p>
</td></tr>
<tr><td><code id="PCMColorPalette_+3A_names">names</code></td>
<td>
<p>a character vector of length 'n'.</p>
</td></tr>
<tr><td><code id="PCMColorPalette_+3A_colors">colors</code></td>
<td>
<p>a vector of n values convertible to colors. Default:
<code>structure(hcl(
h = seq(15, 375, length = n + 1), l = 65, c = 100)[seq_len(n)],
names = names)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings which can be used as color
specifications by R graphics functions.
</p>

<hr>
<h2 id='PCMCombineListAttribute'>Combine all member attributes of a given name into a list</h2><span id='topic+PCMCombineListAttribute'></span>

<h3>Description</h3>

<p>Combine all member attributes of a given name into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMCombineListAttribute(object, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMCombineListAttribute_+3A_object">object</code></td>
<td>
<p>a named list object.</p>
</td></tr>
<tr><td><code id="PCMCombineListAttribute_+3A_name">name</code></td>
<td>
<p>a character string denoting the name of the attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of attribute values
</p>

<hr>
<h2 id='PCMCond'>Conditional distribution of a daughter node given its parent node</h2><span id='topic+PCMCond'></span>

<h3>Description</h3>

<p>An S3 generic function that has to be implemented for every
model class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMCond(
  tree,
  model,
  r = 1,
  metaI = PCMInfo(NULL, tree, model, verbose = verbose),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMCond_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMCond_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMCond_+3A_r">r</code></td>
<td>
<p>an integer specifying a model regime</p>
</td></tr>
<tr><td><code id="PCMCond_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMCond_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type specific to the type of model
</p>

<hr>
<h2 id='PCMCond.GaussianPCM'>Conditional distribution of a daughter node given its parent node</h2><span id='topic+PCMCond.GaussianPCM'></span>

<h3>Description</h3>

<p>An S3 generic function that has to be implemented for every
model class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GaussianPCM'
PCMCond(
  tree,
  model,
  r = 1,
  metaI = PCMInfo(NULL, tree, model, verbose = verbose),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMCond.GaussianPCM_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMCond.GaussianPCM_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMCond.GaussianPCM_+3A_r">r</code></td>
<td>
<p>an integer specifying a model regime</p>
</td></tr>
<tr><td><code id="PCMCond.GaussianPCM_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMCond.GaussianPCM_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For GaussianPCM models, a named list with the following members:
</p>
<table role = "presentation">
<tr><td><code>omega</code></td>
<td>
<p>d</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
</td></tr>
<tr><td><code>V</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='PCMCondVOU'>Variance-covariance matrix of an OU process with optional measurement error and jump at the start</h2><span id='topic+PCMCondVOU'></span>

<h3>Description</h3>

<p>Variance-covariance matrix of an OU process with optional measurement error and jump at the start
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMCondVOU(
  H,
  Sigma,
  Sigmae = NULL,
  Sigmaj = NULL,
  xi = NULL,
  e_Ht = NULL,
  threshold.Lambda_ij = getOption("PCMBase.Threshold.Lambda_ij", 1e-08)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMCondVOU_+3A_h">H</code></td>
<td>
<p>a numerical k x k matrix - selection strength parameter.</p>
</td></tr>
<tr><td><code id="PCMCondVOU_+3A_sigma">Sigma</code></td>
<td>
<p>a numerical k x k matrix - neutral drift unit-time variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="PCMCondVOU_+3A_sigmae">Sigmae</code></td>
<td>
<p>a numerical k x k matrix - environmental variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="PCMCondVOU_+3A_sigmaj">Sigmaj</code></td>
<td>
<p>is the variance matrix of the normal jump distribution (default is NULL).</p>
</td></tr>
<tr><td><code id="PCMCondVOU_+3A_xi">xi</code></td>
<td>
<p>a vector of 0's and 1's corresponding to each branch in the tree. A value of 1
indicates that a jump takes place at the beginning of the branch. This arugment is only
used if Sigmaj is not NULL. Default is NULL.</p>
</td></tr>
<tr><td><code id="PCMCondVOU_+3A_e_ht">e_Ht</code></td>
<td>
<p>a numerical k x k matrix - the result of the matrix exponential expm(-t*H).</p>
</td></tr>
<tr><td><code id="PCMCondVOU_+3A_threshold.lambda_ij">threshold.Lambda_ij</code></td>
<td>
<p>a 0-threshold for abs(Lambda_i + Lambda_j), where Lambda_i
and Lambda_j are eigenvalues of the parameter matrix H. This threshold-values is used as
a condition to take the limit time of the expression '(1-exp(-Lambda_ij*time))/Lambda_ij'
as '(Lambda_i+Lambda_j) &ndash;&gt; 0'. You can control this value by the global option
&quot;PCMBase.Threshold.Lambda_ij&quot;. The default value (1e-8) is suitable for branch lengths
bigger than 1e-6. For smaller branch lengths, you may want to increase the threshold
value using, e.g.  'options(PCMBase.Threshold.Lambda_ij=1e-6)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function of one numerical argument (time) and an integer indicating the branch-index
that is used to check the corresponding element in xi.
</p>

<hr>
<h2 id='PCMCreateLikelihood'>Create a likelihood function of a numerical vector parameter</h2><span id='topic+PCMCreateLikelihood'></span>

<h3>Description</h3>

<p>Create a likelihood function of a numerical vector parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMCreateLikelihood(
  X,
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X, tree, model, SE),
  positiveValueGuard = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMCreateLikelihood_+3A_x">X</code></td>
<td>
<p>a <code>k x N</code> numerical matrix with possible <code>NA</code> and
<code>NaN</code> entries. For <code>i=1,..., N</code>, the column <code>i</code> of X contains
the measured trait values for species <code>i</code> (the tip with integer
identifier equal to <code>i</code> in <code>tree</code>). Missing values can be either
not-available (<code>NA</code>) or not existing (<code>NaN</code>). These two values are
treated differently when calculating likelihoods (see
<code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>).</p>
</td></tr>
<tr><td><code id="PCMCreateLikelihood_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMCreateLikelihood_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMCreateLikelihood_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMCreateLikelihood_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMCreateLikelihood_+3A_positivevalueguard">positiveValueGuard</code></td>
<td>
<p>positive numerical value (default Inf), which
serves as a guard for numerical error. Values exceeding
this positiveGuard are most likely due to numerical error and
PCMOptions()$PCMBase.Value.NA is returned instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to specify a function for the argument metaI. This
function should have three parameters (X, tree, model) and should return a
metaInfo object. (see <code><a href="#topic+PCMInfo">PCMInfo</a></code>).
</p>


<h3>Value</h3>

<p>a function of a numerical vector parameter called p returning the
likelihood of X given the tree and the model with parameter values specified
by p.
</p>

<hr>
<h2 id='PCMDefaultModelTypes'>Class names for the the default PCM and MGPM model types</h2><span id='topic+PCMDefaultModelTypes'></span><span id='topic+MGPMDefaultModelTypes'></span>

<h3>Description</h3>

<p>Utility functions returning named character vector of the
model class-names for the default model types used for PCM and MixedGaussian
model construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMDefaultModelTypes()

MGPMDefaultModelTypes()
</code></pre>


<h3>Value</h3>

<p>Both, <code>PCMFDefaultModelTypes</code> and
<code>MGPMDefaultModelTypes</code> return a character string vector with
named elements (A,B,C,D,E,F) defined as follows
(Mitov et al. 2019a):
</p>

<dl>
<dt>A. </dt><dd><p>BM (H = 0, diagonal <code class="reqn">\Sigma</code>): BM, uncorrelated traits.</p>
</dd>
<dt>B. </dt><dd><p>BM (H = 0, symmetric <code class="reqn">\Sigma</code>): BM, correlated traits.</p>
</dd>
<dt>C. </dt><dd><p>OU (diagonal H, diagonal <code class="reqn">\Sigma</code>): OU, uncorrelated traits.</p>
</dd>
<dt>D. </dt><dd><p>OU (diagonal H, symmetric <code class="reqn">\Sigma</code>): OU, correlated traits, but simple
(diagonal) selection strength matrix.</p>
</dd>
<dt>E. </dt><dd><p>OU (symmetric H, symmetric <code class="reqn">\Sigma</code>): An OU with nondiagonal symmetric H
and nondiagonal symmetric <code class="reqn">\Sigma</code>.</p>
</dd>
<dt>F. </dt><dd><p>OU (asymmetric H, symmetric <code class="reqn">\Sigma</code>): An OU with nondiagonal asymmetric
H and nondiagonal symmetric <code class="reqn">\Sigma</code>.</p>
</dd>
</dl>

<p>The only difference between the two functions is that the model
types returned by <code>PCMFDefaultModelTypes</code> have a global
parameter X0, while the model types returned by
<code>MGPMFDefaultModelTypes</code> have an omitted parameter X0.
</p>


<h3>References</h3>

<p>[Mitov et al. 2019a] Mitov, V., Bartoszek, K., &amp; Stadler, T. (2019). Automatic generation of
evolutionary hypotheses using mixed Gaussian phylogenetic models.
Proceedings of the National Academy of Sciences of the United States of
America, 35, 201813823. http://doi.org/10.1073/pnas.1813823116
</p>


<h3>See Also</h3>

<p>Args_MixedGaussian_MGPMDefaultModelTypes
</p>

<hr>
<h2 id='PCMDefaultObject'>Generate a default object of a given PCM model type or parameter type</h2><span id='topic+PCMDefaultObject'></span>

<h3>Description</h3>

<p>This is an S3 generic. See, e.g. 'PCMDefaultObject.MatrixParameter'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMDefaultObject(spec, model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMDefaultObject_+3A_spec">spec</code></td>
<td>
<p>any object having a class attribute. The value of this object is not
used, but its class is used for method-dispatch.</p>
</td></tr>
<tr><td><code id="PCMDefaultObject_+3A_model">model</code></td>
<td>
<p>a PCM object used to extract attributes needed for creating a
default object of class specified in <code>class(spec)</code>, such as the number of
traits (k) or the regimes and the number of regimes;</p>
</td></tr>
<tr><td><code id="PCMDefaultObject_+3A_...">...</code></td>
<td>
<p>additional arguments that can be used by methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parameter or a PCM object.
</p>

<hr>
<h2 id='PCMDescribe'>Human friendly description of a PCM</h2><span id='topic+PCMDescribe'></span>

<h3>Description</h3>

<p>Human friendly description of a PCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMDescribe(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMDescribe_+3A_model">model</code></td>
<td>
<p>a PCM model object</p>
</td></tr>
<tr><td><code id="PCMDescribe_+3A_...">...</code></td>
<td>
<p>additional arguments used by implementing methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This S3 generic function is intended to be specified for user models
</p>


<h3>Value</h3>

<p>a character string
</p>

<hr>
<h2 id='PCMDescribeParameters'>Describe the parameters of a PCM</h2><span id='topic+PCMDescribeParameters'></span>

<h3>Description</h3>

<p>This is an S3 generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMDescribeParameters(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMDescribeParameters_+3A_model">model</code></td>
<td>
<p>a PCM object.</p>
</td></tr>
<tr><td><code id="PCMDescribeParameters_+3A_...">...</code></td>
<td>
<p>additional arguments that can be used by implementing methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with character elements corresponding to each parameter.
</p>

<hr>
<h2 id='PCMExtractDimensions'>Given a PCM or a parameter object, extract an analogical object for a subset
of the dimensions (traits) in the original object.</h2><span id='topic+PCMExtractDimensions'></span>

<h3>Description</h3>

<p>Given a PCM or a parameter object, extract an analogical object for a subset
of the dimensions (traits) in the original object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMExtractDimensions(obj, dims = seq_len(PCMNumTraits(obj)), nRepBlocks = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMExtractDimensions_+3A_obj">obj</code></td>
<td>
<p>a PCM or a parameter object.</p>
</td></tr>
<tr><td><code id="PCMExtractDimensions_+3A_dims">dims</code></td>
<td>
<p>an integer vector; should be a subset or equal to
<code>seq_len(PCMNumTraits(obj))</code> (the default).</p>
</td></tr>
<tr><td><code id="PCMExtractDimensions_+3A_nrepblocks">nRepBlocks</code></td>
<td>
<p>a positive integer specifying if the specified dimensions
should be replicated to obtain a higher dimensional model, where the parameter
matrices are block-diagonal with blocks corresponding to dims. Default: 1L.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic
</p>


<h3>Value</h3>

<p>an object of the same class as obj with a subset of obj's dimensions
multiplied <code>nRepBlocks</code> times.
</p>

<hr>
<h2 id='PCMExtractRegimes'>Given a PCM or a parameter object, extract an analogical object for a subset
of the regimes in the original object.</h2><span id='topic+PCMExtractRegimes'></span>

<h3>Description</h3>

<p>Given a PCM or a parameter object, extract an analogical object for a subset
of the regimes in the original object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMExtractRegimes(obj, regimes = seq_len(PCMNumRegimes(obj)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMExtractRegimes_+3A_obj">obj</code></td>
<td>
<p>a PCM or a parameter object.</p>
</td></tr>
<tr><td><code id="PCMExtractRegimes_+3A_regimes">regimes</code></td>
<td>
<p>an integer vector; should be a subset or equal to
<code>seq_len(PCMNumRegimes(obj))</code> (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic
</p>


<h3>Value</h3>

<p>an object of the same class as obj with a subset of obj's regimes
</p>

<hr>
<h2 id='PCMFindMethod'>Find the S3 method for a given PCM object or class-name and an S3 generic</h2><span id='topic+PCMFindMethod'></span>

<h3>Description</h3>

<p>Find the S3 method for a given PCM object or class-name and an S3 generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMFindMethod(x, method = "PCMCond")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMFindMethod_+3A_x">x</code></td>
<td>
<p>a character string denoting a PCM S3 class name (e.g. &quot;OU&quot;), or a
PCM object.</p>
</td></tr>
<tr><td><code id="PCMFindMethod_+3A_method">method</code></td>
<td>
<p>a character string denoting the name of an S3 generic function.
Default: &quot;PCMCond&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function object corresponding to the S3 method found or an error is
raised if no such function is found for the specified object and method.
</p>

<hr>
<h2 id='PCMFixParameter'>Fix a parameter in a PCM model</h2><span id='topic+PCMFixParameter'></span>

<h3>Description</h3>

<p>Fix a parameter in a PCM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMFixParameter(model, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMFixParameter_+3A_model">model</code></td>
<td>
<p>a PCM object</p>
</td></tr>
<tr><td><code id="PCMFixParameter_+3A_name">name</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of the model with added class '_Fixed' to the class of the
parameter <code>name</code>
</p>

<hr>
<h2 id='PCMGenerateModelTypes'>Generate default model types for given PCM base-classes</h2><span id='topic+PCMGenerateModelTypes'></span>

<h3>Description</h3>

<p>This function calls 'PCMListParameterizations' or
'PCMListDefaultParameterizations' and generates the corresponding
'PCMParentClasses' and 'PCMSpecify' methods in the global environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMGenerateModelTypes(
  baseTypes = list(BM = "default", OU = "default", White = "all"),
  sourceFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMGenerateModelTypes_+3A_basetypes">baseTypes</code></td>
<td>
<p>a named list with character string elements among
<code>c("default", "all")</code> and names specifying base S3-class names for which
the parametrizations (sub-classes) will be generated. Defaults to
<code>list(BM="default", OU = "default", White = "all")</code>. The element value
specifies which one of 'PCMListParameterizations' or
'PCMListDefaultParameterizations' should be used:
</p>

<dl>
<dt>&quot;all&quot;</dt><dd><p>for calling 'PCMListParameterizations'</p>
</dd>
<dt>&quot;default&quot;</dt><dd><p>for calling 'PCMListDefaultParameterizations'</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="PCMGenerateModelTypes_+3A_sourcefile">sourceFile</code></td>
<td>
<p>NULL or a character string indicating a .R filename, to
which the automatically generated code will be saved. If NULL (the default),
the generated source code is evaluated and the S3 methods are defined in the
global environment. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has side effects only and does not return a value.
</p>


<h3>See Also</h3>

<p>PCMListDefaultParameterizations
</p>

<hr>
<h2 id='PCMGenerateParameterizations'>Generate possible parameterizations for a given type of model</h2><span id='topic+PCMGenerateParameterizations'></span>

<h3>Description</h3>

<p>A parameterization of a PCM of given type, e.g. OU, is a PCM-class
inheriting from this type, which imposes some restrictions or transformations of
the parameters in the base-type. This function generates the S3 methods responsible
for creating such parameterizations, in particular it generates the definition
of the methods for the two S3 generics 'PCMParentClasses' and 'PCMSpecify' for
al parameterizations specified in the 'tableParameterizations' argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMGenerateParameterizations(
  model,
  listParameterizations = PCMListParameterizations(model),
  tableParameterizations = PCMTableParameterizations(model, listParameterizations),
  env = .GlobalEnv,
  useModelClassNameForFirstRow = FALSE,
  sourceFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMGenerateParameterizations_+3A_model">model</code></td>
<td>
<p>a PCM object.</p>
</td></tr>
<tr><td><code id="PCMGenerateParameterizations_+3A_listparameterizations">listParameterizations</code></td>
<td>
<p>a list or a sublist returned by 'PCMListParameterizations'.
Default: 'PCMListParameterizations(model)'.</p>
</td></tr>
<tr><td><code id="PCMGenerateParameterizations_+3A_tableparameterizations">tableParameterizations</code></td>
<td>
<p>a data.table containing the parameterizations to
generate. By default this is generated from 'listParameterizations' using a
call 'PCMTableParameterizations(model, listParameterizations)'. If specified
by the user, this parameter takes precedence over 'listParameterizations' and
'listParameterizations' is not used.</p>
</td></tr>
<tr><td><code id="PCMGenerateParameterizations_+3A_env">env</code></td>
<td>
<p>an environment where the method definitions will be stored.
Default: 'env = .GlobalEnv'.</p>
</td></tr>
<tr><td><code id="PCMGenerateParameterizations_+3A_usemodelclassnameforfirstrow">useModelClassNameForFirstRow</code></td>
<td>
<p>A logical specifying if the S3 class name of
'model' should be used as a S3 class for the model defined in the first row of
'tableParameterizations'. Default: FALSE.</p>
</td></tr>
<tr><td><code id="PCMGenerateParameterizations_+3A_sourcefile">sourceFile</code></td>
<td>
<p>NULL or a character string indicating a .R filename, to
which the automatically generated code will be saved. If NULL (the default),
the generated source code is evaluated and the S3 methods are defined in the
global environment. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return a value. It only has a side effect by
defining S3 methods in 'env'.
</p>

<hr>
<h2 id='PCMGetAttribute'>Value of an attribute of an object or values for an attribute found in its members</h2><span id='topic+PCMGetAttribute'></span>

<h3>Description</h3>

<p>Value of an attribute of an object or values for an attribute found in its members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMGetAttribute(name, object, member = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMGetAttribute_+3A_name">name</code></td>
<td>
<p>attribute name.</p>
</td></tr>
<tr><td><code id="PCMGetAttribute_+3A_object">object</code></td>
<td>
<p>a PCM model object or a PCMTree object.</p>
</td></tr>
<tr><td><code id="PCMGetAttribute_+3A_member">member</code></td>
<td>
<p>a member expression. Member expressions are character strings
denoting named elements in a list object (see examples). Default: &quot;&quot;.</p>
</td></tr>
<tr><td><code id="PCMGetAttribute_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+MatchListMembers">MatchListMembers</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if member is an empty string, <code>attr(object, name)</code>. Otherwise, a named list
containing the value for the attribute for each member in <code>object</code>
matched by <code>member</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PCMGetAttribute("class", PCMBaseTestObjects$model_MixedGaussian_ab)
PCMGetAttribute(
  "dim", PCMBaseTestObjects$model_MixedGaussian_ab,
  member = "$Sigmae_x")
</code></pre>

<hr>
<h2 id='PCMGetVecParamsRegimesAndModels'>Get a vector of all parameters (real and discrete) describing a model on a
tree including the numerical parameters of each model regime, the integer ids
of the splitting nodes defining the regimes on the tree and the integer ids of
the model types associated with each regime.</h2><span id='topic+PCMGetVecParamsRegimesAndModels'></span>

<h3>Description</h3>

<p>Get a vector of all parameters (real and discrete) describing a model on a
tree including the numerical parameters of each model regime, the integer ids
of the splitting nodes defining the regimes on the tree and the integer ids of
the model types associated with each regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMGetVecParamsRegimesAndModels(model, tree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMGetVecParamsRegimesAndModels_+3A_model">model</code></td>
<td>
<p>a PCM model</p>
</td></tr>
<tr><td><code id="PCMGetVecParamsRegimesAndModels_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.part member.</p>
</td></tr>
<tr><td><code id="PCMGetVecParamsRegimesAndModels_+3A_...">...</code></td>
<td>
<p>additional parameters passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic.
In the default implementation, the last entry in the returned vector is the
number of numerical parameters. This is used to identify the starting positions
in the vector of the first splitting node.
</p>


<h3>Value</h3>

<p>a numeric vector concatenating the result
</p>

<hr>
<h2 id='PCMInfo'>Meta-information about a tree and trait data associated with a PCM</h2><span id='topic+PCMInfo'></span>

<h3>Description</h3>

<p>This function pre-processes the given tree and data in order to
create meta-information used during likelihood calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMInfo(
  X,
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  verbose = FALSE,
  preorder = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMInfo_+3A_x">X</code></td>
<td>
<p>a <code>k x N</code> numerical matrix with possible <code>NA</code> and
<code>NaN</code> entries. For <code>i=1,..., N</code>, the column <code>i</code> of X contains
the measured trait values for species <code>i</code> (the tip with integer
identifier equal to <code>i</code> in <code>tree</code>). Missing values can be either
not-available (<code>NA</code>) or not existing (<code>NaN</code>). These two values are
treated differently when calculating likelihoods (see
<code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>).</p>
</td></tr>
<tr><td><code id="PCMInfo_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMInfo_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMInfo_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMInfo_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
<tr><td><code id="PCMInfo_+3A_preorder">preorder</code></td>
<td>
<p>an integer vector of row-indices in tree$edge matrix as returned
by PCMTreePreorder. This can be given for performance speed-up when several
operations needing preorder are executed on the tree. Default : <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="PCMInfo_+3A_...">...</code></td>
<td>
<p>additional arguments used by implementing methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>k x N matrix denoting the trait data;</p>
</td></tr>
<tr><td><code>VE</code></td>
<td>
<p>k x k x N array denoting the measurement error variance covariance
matrix for each for each tip i = 1,...,N. See the parameter <code>SE</code> in
<code><a href="#topic+PCMLik">PCMLik</a>.</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>total number of nodes in the tree;</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of tips;</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>number of traits;</p>
</td></tr>
<tr><td><code>RTree</code></td>
<td>
<p>number of parts on the tree (distinct elements of tree$edge.part);</p>
</td></tr>
<tr><td><code>RModel</code></td>
<td>
<p>number of regimes in the model (elements of attr(model, regimes));</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>number of free parameters describing the model;</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>an integer vector corresponding to tree$edge with the regime for each
branch in tree;</p>
</td></tr>
<tr><td><code>xi</code></td>
<td>
<p>an integer vector of 0's and 1's corresponding to the rows in tree$edge
indicating the presence of a jump at the corresponding branch;</p>
</td></tr>
<tr><td><code>pc</code></td>
<td>
<p>a logical matrix of dimension k x M denoting the present coordinates
for each node; in special cases this matrix can be edited by hand after calling
PCMInfo and before passing the returned list to PCMLik. Otherwise, this matrix
can be calculated in a custom way by specifying the option PCMBase.PCMPresentCoordinatesFun.
See also <code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code> and <code><a href="#topic+PCMOptions">PCMOptions</a></code>. </p>
</td></tr>
</table>
<p>This list is passed to <code><a href="#topic+PCMLik">PCMLik</a></code>.
</p>

<hr>
<h2 id='PCMLik'>Likelihood of a multivariate Gaussian phylogenetic comparative model with non-interacting lineages</h2><span id='topic+PCMLik'></span>

<h3>Description</h3>

<p>The likelihood of a PCM represents the probability density function
of observed trait values (data) at the tips of a tree given the tree and
the model parameters. Seen as a function of the model parameters, the
likelihood is used to fit the model to the observed trait data and the
phylogenetic tree (which is typically inferred from another sort of data, such
as an alignment of genetic sequences for the species at the tips of the tree).
The <code><a href="#topic+PCMLik">PCMLik</a></code> function
provides a common interface for calculating the (log-)likelihood of different
PCMs.
Below we denote by N the number of tips, by M the total number of nodes in the
tree including tips, internal and root node, and by k - the number of traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMLik(
  X,
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X = X, tree = tree, model = model, SE = SE, verbose = verbose),
  log = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMLik_+3A_x">X</code></td>
<td>
<p>a <code>k x N</code> numerical matrix with possible <code>NA</code> and
<code>NaN</code> entries. For <code>i=1,..., N</code>, the column <code>i</code> of X contains
the measured trait values for species <code>i</code> (the tip with integer
identifier equal to <code>i</code> in <code>tree</code>). Missing values can be either
not-available (<code>NA</code>) or not existing (<code>NaN</code>). These two values are
treated differently when calculating likelihoods (see
<code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>).</p>
</td></tr>
<tr><td><code id="PCMLik_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMLik_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMLik_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMLik_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMLik_+3A_log">log</code></td>
<td>
<p>logical indicating whether a log-likelehood should be calculated. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="PCMLik_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For efficiency, the argument <code>metaI</code>
can be provided explicitly, because this is not supposed to change during a
model inference procedure such as likelihood maximization.
</p>


<h3>Value</h3>

<p>a numerical value with named attributes as follows:
</p>

<dl>
<dt>X0</dt><dd><p>A numerical vector of length k specifying the value at the root for which
the likelihood value was calculated. If the model contains a member called X0, this
vector is used; otherwise the value of X0 maximizing the likelihood for the given
model parameters is calculated by maximizing the quadratic polynomial
'X0 * L_root * X0 + m_root * X0 + r_root';</p>
</dd>
<dt>error</dt><dd><p>A character string with information if a numerical or other
logical error occurred during likelihood calculation.</p>
</dd>
</dl>

<p>If an error occured during likelihood calculation, the default behavior is to
return NA with a non-NULL error attribute. This behavior can be changed in
using global options:
</p>

<dl>
<dt>&quot;PCMBase.Value.NA&quot;</dt><dd><p>Allows to specify a different NA value such as <code>-Inf</code> or <code>-1e20</code> which can be used in combination with <code>log = TRUE</code> when
using <code>optim</code> to maximize the log-likelihood;</p>
</dd>
<dt>&quot;PCMBase.Errors.As.Warnings&quot;</dt><dd><p>Setting this option to FALSE will cause any
error to result in calling the <code><a href="base.html#topic+stop">stop</a></code> R-base function. If not caught
in a <code><a href="base.html#topic+tryCatch">tryCatch</a></code>, this will cause the inference procedure to abort at the occurence of a numerical error. By default, this option is set to TRUE, which
means that <code>getOption("PCMBase.Value.NA", as.double(NA))</code> is returned with
an error attribute and a warning is issued.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+PCMInfo">PCMInfo</a></code> <code><a href="#topic+PCMAbCdEf">PCMAbCdEf</a></code> <code><a href="#topic+PCMLmr">PCMLmr</a></code> <code><a href="#topic+PCMSim">PCMSim</a></code> <code><a href="#topic+PCMCond">PCMCond</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 10
tr &lt;- PCMTree(ape::rtree(N))

model &lt;- PCMBaseTestObjects$model_MixedGaussian_ab

PCMTreeSetPartRegimes(tr, c(`11` = 'a'), setPartition = TRUE)

set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
X &lt;- PCMSim(tr, model, X0 = rep(0, 3))

PCMLik(X, tr, model)
</code></pre>

<hr>
<h2 id='PCMLikDmvNorm'>Calculate the likelihood of a model using the standard formula for multivariate pdf</h2><span id='topic+PCMLikDmvNorm'></span>

<h3>Description</h3>

<p>Calculate the likelihood of a model using the standard formula for multivariate pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMLikDmvNorm(
  X,
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X, tree, model, SE, verbose = verbose),
  log = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMLikDmvNorm_+3A_x">X</code></td>
<td>
<p>a <code>k x N</code> numerical matrix with possible <code>NA</code> and
<code>NaN</code> entries. For <code>i=1,..., N</code>, the column <code>i</code> of X contains
the measured trait values for species <code>i</code> (the tip with integer
identifier equal to <code>i</code> in <code>tree</code>). Missing values can be either
not-available (<code>NA</code>) or not existing (<code>NaN</code>). These two values are
treated differently when calculating likelihoods (see
<code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>).</p>
</td></tr>
<tr><td><code id="PCMLikDmvNorm_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMLikDmvNorm_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMLikDmvNorm_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMLikDmvNorm_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMLikDmvNorm_+3A_log">log</code></td>
<td>
<p>logical indicating whether a log-likelehood should be calculated. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="PCMLikDmvNorm_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical value with named attributes as follows:
</p>

<hr>
<h2 id='PCMLikTrace'>Tracing the log-likelihood calculation of a model over each node of the tree</h2><span id='topic+PCMLikTrace'></span>

<h3>Description</h3>

<p>This is an S3 generic function providing tracing information
for the likelihood calculation for a given tree, data and model parameters.
Useful for illustration or for debugging purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMLikTrace(
  X,
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X = X, tree = tree, model = model, SE = SE, verbose = verbose),
  log = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMLikTrace_+3A_x">X</code></td>
<td>
<p>a <code>k x N</code> numerical matrix with possible <code>NA</code> and
<code>NaN</code> entries. For <code>i=1,..., N</code>, the column <code>i</code> of X contains
the measured trait values for species <code>i</code> (the tip with integer
identifier equal to <code>i</code> in <code>tree</code>). Missing values can be either
not-available (<code>NA</code>) or not existing (<code>NaN</code>). These two values are
treated differently when calculating likelihoods (see
<code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>).</p>
</td></tr>
<tr><td><code id="PCMLikTrace_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMLikTrace_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMLikTrace_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMLikTrace_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMLikTrace_+3A_log">log</code></td>
<td>
<p>logical indicating whether a log-likelehood should be calculated. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="PCMLikTrace_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object will, in general, depend on the type of model and
the algorithm used for likelihood calculation. For a G_LInv model and
pruning-wise likelihood calculation, the returned object will be a data.table
with columns corresponding to the node-state variables, e.g. the quadratic
polynomial coefficients associated with each node in the tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMInfo">PCMInfo</a></code> <code><a href="#topic+PCMAbCdEf">PCMAbCdEf</a></code> <code><a href="#topic+PCMLmr">PCMLmr</a></code> <code><a href="#topic+PCMSim">PCMSim</a></code> <code><a href="#topic+PCMCond">PCMCond</a></code> <code><a href="#topic+PCMParseErrorMessage">PCMParseErrorMessage</a></code>
</p>

<hr>
<h2 id='PCMListMembers'>A vector of access-code strings to all members of a named list</h2><span id='topic+PCMListMembers'></span>

<h3>Description</h3>

<p>A vector of access-code strings to all members of a named list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMListMembers(
  l,
  recursive = TRUE,
  format = c("$", "$'", "$\"", "$`", "[['", "[[\"", "[[`")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMListMembers_+3A_l">l</code></td>
<td>
<p>a named list object.</p>
</td></tr>
<tr><td><code id="PCMListMembers_+3A_recursive">recursive</code></td>
<td>
<p>logical indicating if list members should be gone through
recursively. TRUE by default.</p>
</td></tr>
<tr><td><code id="PCMListMembers_+3A_format">format</code></td>
<td>
<p>a character string indicating the format for accessing a member.
Acceptable values are <code>c("$", "$'", '$"', '$`', "[['", '[["', '[[`')</code> of which
the first one is taken as default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings denoting each named member of the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PCMListMembers(PCMBaseTestObjects$model_MixedGaussian_ab)
PCMListMembers(PCMBaseTestObjects$model_MixedGaussian_ab, format = '$`')
PCMListMembers(PCMBaseTestObjects$tree.ab, format = '$`')
</code></pre>

<hr>
<h2 id='PCMListParameterizations'>Specify the parameterizations for each parameter of a model</h2><span id='topic+PCMListParameterizations'></span><span id='topic+PCMListDefaultParameterizations'></span>

<h3>Description</h3>

<p>These are S3 generics. 'PCMListParameterizations' should return
all possible parametrizations for the class of 'model'.
'PCMListDefaultParameterizations' is a handy way to specify a subset of all
parametrizations. 'PCMListDefaultParameterizations' should be used to avoid
generating too many model parametrizations which occupy space in the R-global
environment while they are not used (see <a href="#topic+PCMGenerateParameterizations">PCMGenerateParameterizations</a>).
It is mandatory to implement a specification for 'PCMListParameterizations'
for each newly defined class of models.
'PCMListDefaultParameterizations' has a default implementation that calls
'PCMListParameterizations' and returns the first parametrization for each
parameter. Hence, implementing a method for 'PCMListDefaultParameterizations'
for a newly defined model type is optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMListParameterizations(model, ...)

PCMListDefaultParameterizations(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMListParameterizations_+3A_model">model</code></td>
<td>
<p>a PCM.</p>
</td></tr>
<tr><td><code id="PCMListParameterizations_+3A_...">...</code></td>
<td>
<p>additional arguments used by implementing methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with list elements corresponding to each parameter in
model. Each list element is a list of character vectors, specifying the possible
S3 class attributes for the parameter in question. For an example, type
'PCMListParameterizations.BM' to see the possible parameterizations for the
BM model.
</p>


<h3>See Also</h3>

<p>PCMGenerateParameterizations
</p>

<hr>
<h2 id='PCMLmr'>Quadratic polynomial parameters L, m, r</h2><span id='topic+PCMLmr'></span>

<h3>Description</h3>

<p>Quadratic polynomial parameters L, m, r
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMLmr(
  X,
  tree,
  model,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X = X, tree = tree, model = model, SE = SE, verbose = verbose),
  root.only = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMLmr_+3A_x">X</code></td>
<td>
<p>a <code>k x N</code> numerical matrix with possible <code>NA</code> and
<code>NaN</code> entries. For <code>i=1,..., N</code>, the column <code>i</code> of X contains
the measured trait values for species <code>i</code> (the tip with integer
identifier equal to <code>i</code> in <code>tree</code>). Missing values can be either
not-available (<code>NA</code>) or not existing (<code>NaN</code>). These two values are
treated differently when calculating likelihoods (see
<code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>).</p>
</td></tr>
<tr><td><code id="PCMLmr_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMLmr_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMLmr_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMLmr_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMLmr_+3A_root.only">root.only</code></td>
<td>
<p>logical indicating whether to return the calculated values of L,m,r
only for the root or for all nodes in the tree.</p>
</td></tr>
<tr><td><code id="PCMLmr_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the members A,b,C,d,E,f,L,m,r for all nodes in the tree or
only for the root if root.only=TRUE.
</p>

<hr>
<h2 id='PCMMapModelTypesToRegimes'>Integer vector giving the model type index for each regime</h2><span id='topic+PCMMapModelTypesToRegimes'></span>

<h3>Description</h3>

<p>Integer vector giving the model type index for each regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMMapModelTypesToRegimes(model, tree, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMMapModelTypesToRegimes_+3A_model">model</code></td>
<td>
<p>a PCM model</p>
</td></tr>
<tr><td><code id="PCMMapModelTypesToRegimes_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.part member</p>
</td></tr>
<tr><td><code id="PCMMapModelTypesToRegimes_+3A_...">...</code></td>
<td>
<p>additional parameters passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic S3 method. The default implementation for the basic
class PCM returns a vector of 1's, because it assumes that a single model type
is associated with each regime. The implementation for mixed Gaussian models
returns the mapping attribute of the MixedGaussian object reordered to
correspond to <code>PCMTreeGetPartNames(tree)</code>.
</p>


<h3>Value</h3>

<p>an integer vector with elements corresponding to the elements in
<code>PCMTreeGetPartNames(tree)</code>
</p>

<hr>
<h2 id='PCMMean'>Expected mean vector at each tip conditioned on a trait-value vector at the root</h2><span id='topic+PCMMean'></span>

<h3>Description</h3>

<p>Expected mean vector at each tip conditioned on a trait-value vector at the root
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMMean(
  tree,
  model,
  X0 = model$X0,
  metaI = PCMInfo(NULL, tree, model, verbose = verbose),
  internal = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMMean_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMMean_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMMean_+3A_x0">X0</code></td>
<td>
<p>a k-vector denoting the root trait</p>
</td></tr>
<tr><td><code id="PCMMean_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMMean_+3A_internal">internal</code></td>
<td>
<p>a logical indicating ig the per-node mean vectors should be returned (see Value). Default FALSE.</p>
</td></tr>
<tr><td><code id="PCMMean_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If internal is FALSE (default), then a k x N matrix Mu, such that <code>Mu[, i]</code> equals the expected mean k-vector
at tip i, conditioned on <code>X0</code> and the tree. Otherwise, a k x M matrix Mu containing the mean vector for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a Brownian motion model with one regime
modelBM &lt;- PCM(model = "BM", k = 2)
# print the model
modelBM
# assign the model parameters at random: this will use uniform distribution
# with boundaries specified by PCMParamLowerLimit and PCMParamUpperLimit
# We do this in two steps:
# 1. First we generate a random vector. Note the length of the vector equals PCMParamCount(modelBM)
randomParams &lt;- PCMParamRandomVecParams(modelBM, PCMNumTraits(modelBM), PCMNumRegimes(modelBM))
randomParams
# 2. Then we load this random vector into the model.
PCMParamLoadOrStore(modelBM, randomParams, 0, PCMNumTraits(modelBM), PCMNumRegimes(modelBM), TRUE)

# create a random tree of 10 tips
tree &lt;- ape::rtree(10)
PCMMean(tree, modelBM)
</code></pre>

<hr>
<h2 id='PCMMeanAtTime'>Calculate the mean at time t, given X0, under a PCM model</h2><span id='topic+PCMMeanAtTime'></span>

<h3>Description</h3>

<p>Calculate the mean at time t, given X0, under a PCM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMMeanAtTime(
  t,
  model,
  X0 = model$X0,
  regime = PCMRegimes(model)[1L],
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMMeanAtTime_+3A_t">t</code></td>
<td>
<p>positive numeric denoting time</p>
</td></tr>
<tr><td><code id="PCMMeanAtTime_+3A_model">model</code></td>
<td>
<p>a PCM model object</p>
</td></tr>
<tr><td><code id="PCMMeanAtTime_+3A_x0">X0</code></td>
<td>
<p>a numeric vector of length k, where k is the number of traits in the model (Defaults to model$X0).</p>
</td></tr>
<tr><td><code id="PCMMeanAtTime_+3A_regime">regime</code></td>
<td>
<p>an integer or a character denoting the regime in model for
which to do the calculation; Defaults to PCMRegimes(model)[1L], meaning the
first regime in the model.</p>
</td></tr>
<tr><td><code id="PCMMeanAtTime_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if (debug) messages should be written on the console (Defaults to FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length k
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a Brownian motion model with one regime
modelBM &lt;- PCM(model = "BM", k = 2)
# print the model
modelBM
# assign the model parameters at random: this will use uniform distribution
# with boundaries specified by PCMParamLowerLimit and PCMParamUpperLimit
# We do this in two steps:
# 1. First we generate a random vector. Note the length of the vector equals PCMParamCount(modelBM)
randomParams &lt;- PCMParamRandomVecParams(modelBM, PCMNumTraits(modelBM), PCMNumRegimes(modelBM))
randomParams
# 2. Then we load this random vector into the model.
PCMParamLoadOrStore(modelBM, randomParams, 0, PCMNumTraits(modelBM), PCMNumRegimes(modelBM), TRUE)

# PCMMeanAtTime(1, modelBM)

# note that the variance at time 0 is not the 0 matrix because the model has a non-zero
# environmental deviation
PCMMeanAtTime(0, modelBM)
</code></pre>

<hr>
<h2 id='PCMModels'>Get a list of PCM models currently implemented</h2><span id='topic+PCMModels'></span>

<h3>Description</h3>

<p>Get a list of PCM models currently implemented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMModels(pattern = NULL, parentClass = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMModels_+3A_pattern">pattern</code></td>
<td>
<p>a character string specifying an optional for the model-names to search for.</p>
</td></tr>
<tr><td><code id="PCMModels_+3A_parentclass">parentClass</code></td>
<td>
<p>a character string specifying an optional parent class of the models to look for.</p>
</td></tr>
<tr><td><code id="PCMModels_+3A_...">...</code></td>
<td>
<p>additional arguments used by implementing methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is using the S3 api function <code><a href="utils.html#topic+methods">methods</a></code> looking
for all registered implementations of the function <code><a href="#topic+PCMSpecify">PCMSpecify</a></code>.
</p>


<h3>Value</h3>

<p>a character vector of the model classes found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PCMModels()
PCMModels("^OU")
</code></pre>

<hr>
<h2 id='PCMModelTypes'>Get the model type(s) of a model</h2><span id='topic+PCMModelTypes'></span>

<h3>Description</h3>

<p>For a regular PCM object, the model type is its S3 class. For a
MixedGaussian each regime is mapped to one of several possible model types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMModelTypes(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMModelTypes_+3A_obj">obj</code></td>
<td>
<p>a PCM object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>

<hr>
<h2 id='PCMNumRegimes'>Number of regimes in a obj</h2><span id='topic+PCMNumRegimes'></span>

<h3>Description</h3>

<p>Number of regimes in a obj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMNumRegimes(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMNumRegimes_+3A_obj">obj</code></td>
<td>
<p>a PCM object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>

<hr>
<h2 id='PCMNumTraits'>Number of traits modeled by a PCM</h2><span id='topic+PCMNumTraits'></span>

<h3>Description</h3>

<p>Number of traits modeled by a PCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMNumTraits(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMNumTraits_+3A_model">model</code></td>
<td>
<p>a PCM object or an a parameter object (the name of this argument
could be misleading, because both, model and parameter objects are supported).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>

<hr>
<h2 id='PCMOptions'>Global options for the PCMBase package</h2><span id='topic+PCMOptions'></span>

<h3>Description</h3>

<p>Global options for the PCMBase package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMOptions()
</code></pre>


<h3>Value</h3>

<p>a named list with the currently set values of the following global
options:
</p>

<dl>
<dt><code>PCMBase.Value.NA </code></dt><dd><p>NA value for the likelihood; used in GaussianPCM to
return this value in case of an error occurring
during likelihood calculation. By default, this is set to <code>as.double(NA)</code>.</p>
</dd>
<dt><code>PCMBase.Errors.As.Warnings </code></dt><dd><p>a logical flag indicating if errors
(occuring, e.g. during likelihood calculation) should be treated as warnings
and added as an attribute &quot;error&quot; to attach to the likelihood values. Default TRUE.</p>
</dd>
<dt><code>PCMBase.Raise.Lik.Errors</code> </dt><dd><p>Should numerical and other sort of
errors occurring during likelihood calculation be raised either as errors or
as warnings, depending on the option <code>PCMBase.Errors.As.Warnings</code>.
Default TRUE. This option can be useful if too frequent warnings get raised
during a model fit procedure.</p>
</dd>
<dt><code>PCMBase.Threshold.Lambda_ij </code></dt><dd><p>a 0-threshold for abs(Lambda_i + Lambda_j),
where Lambda_i and Lambda_j are eigenvalues of the parameter matrix H of an OU or
other model. Default 1e-8. See <code><a href="#topic+PCMPExpxMeanExp">PCMPExpxMeanExp</a></code>.</p>
</dd>
<dt><code>PCMBase.Threshold.EV </code></dt><dd><p>A 0-threshold for the eigenvalues of the
matrix V for a given branch. The V matrix is considered singular if it has
eigenvalues smaller than <code>PCMBase.Threshold.EV </code> or when the ratio
min(svdV)/max(svdV) is below <code>PCMBase.Threshold.SV </code>. Default is 1e-5.
Treatment of branches with singular V matrix is defined by the option
<code>PCMBase.Skip.Singular</code>.</p>
</dd>
<dt><code>PCMBase.Threshold.SV </code></dt><dd><p>A 0-threshold for min(svdV)/max(svdV), where
svdV is the vector of singular values of the matrix V for a given branch.
The V matrix is considered singular if it has eigenvalues smaller than
<code>PCMBase.Threshold.EV </code> or when the ratio min(svdV)/max(svdV) is below
PCMBase.Threshold.SV. Default is 1e-6. Treatment
of branches with singular V matrix is defined by the option <code>PCMBase.Skip.Singular</code>.</p>
</dd>
<dt><code>PCMBase.Threshold.Skip.Singular </code></dt><dd><p>A double indicating if an internal branch of shorter
length with singular matrix V should be skipped during likelihood calculation. Setting this
option to a higher value, together with a TRUE value for the option PCMBase.Skip.Singular
will result in tolerating some parameter values resulting in singular variance covariance
matrix of the transition distribution. Default 1e-4.</p>
</dd>
<dt><code>PCMBase.Skip.Singular </code></dt><dd><p>A logical value indicating whether internal branches with
singular matrix V and shorter than <code>getOption("PCMBase.Threshold.Skip.Singular")</code>
should be skipped during likelihood calculation, adding their children
L,m,r values to their parent node. Default TRUE. Note, that setting this option to FALSE
may cause some models to stop working, e.g. the White model. Setting this option to FALSE
will also cause errors or NA likelihood values in the case of trees with very short or
0-length branches.</p>
</dd>
<dt><code>PCMBase.Tolerance.Symmetric </code></dt><dd><p>A double specifying the tolerance in tests
for symmetric matrices. Default 1e-8; see also <code><a href="base.html#topic+isSymmetric">isSymmetric</a></code>.</p>
</dd>
<dt><code>PCMBase.Lmr.mode</code> </dt><dd><p>An integer code specifying the parallel likelihood calculation mode.</p>
</dd>
<dt><code>PCMBase.ParamValue.LowerLimit</code> </dt><dd><p>Default lower limit value for parameters, default setting is -10.0.</p>
</dd>
<dt><code>PCMBase.ParamValue.LowerLimit.NonNegative</code> </dt><dd><p>Numeric (default: 0.0) indication the lower limit for
parameters inheriting from class <code>'_NonNegative'</code></p>
</dd></dl>
<p>s
</p>
<dl>
<dt><code>PCMBase.ParamValue.LowerLimit.NonNegativeDiagonal</code> </dt><dd><p>Default lower limit value for parameters corresponding to non-negative diagonal elements of matrices, default setting is 0.0.</p>
</dd>
<dt><code>PCMBase.ParamValue.UpperLimit</code> </dt><dd><p>Default upper limit value for parameters, default setting is 10.0.</p>
</dd>
<dt><code>PCMBase.Transpose.Sigma_x</code> </dt><dd><p>Should upper diagonal factors for variance-covariance rate matrices be transposed, e.g. should Sigma = t(Sigma_x) Sigma_x or, rather Sigma = Sigma_x t(Sigma_x)? Note that the two variants are not equal. The default is FALSE, meaning Sigma = Sigma_x t(Sigma_x). In this case, Sigma_x is not the actual upper Cholesky factor of Sigma, i.e. chol(Sigma) != Sigma_x. See also <code><a href="base.html#topic+chol">chol</a></code> and <code><a href="#topic+UpperTriFactor">UpperTriFactor</a></code>. This option applies to parameters Sigma_x, Sigmae_x, Sigmaj_x and the measurement errors <code>SE[,,i]</code> for each measurement i when the argument <code>SE</code> is specified as a cube.</p>
</dd>
<dt><code>PCMBase.MaxLengthListCladePartitions</code> </dt><dd><p>Maximum number of tree partitions returned by <code><a href="#topic+PCMTreeListCladePartitions">PCMTreeListCladePartitions</a></code>. This option has the goal to interrupt the recursive search for new partitions in the case of calling PCMTreeListCladePartitions on a big tree with a small value of the maxCladeSize argument. By default this is set to Inf.</p>
</dd>
<dt><code>PCMBase.PCMPresentCoordinatesFun</code> </dt><dd><p>A function with the same synopsis as <code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code> that can be specified in case of custom setting for the present coordinates for specific nodes of the tree. See <code><a href="#topic+PCMPresentCoordinates">PCMPresentCoordinates</a></code>, and <code><a href="#topic+PCMInfo">PCMInfo</a></code>.</p>
</dd>
<dt><code>PCMBase.Use1DClasses</code> </dt><dd><p>Logical indicating if 1D arithmetic operations
should be used instead of multi-dimensional ones. This can speed-up computations
in the case of a single trait. Currently, this feature is implemented only in
the PCMBaseCpp R-package and only for some model types, such as OU and BM.
Default: FALSE</p>
</dd>
<dt><code>PCMBase.PrintSubscript_u</code> </dt><dd><p>Logical indicating if a subscript 'u'
should be printed instead of a subscript 'x'. Used in <code>PCMTable</code>. Default: FALSE.</p>
</dd>
<dt><code>PCMBase.MaxNForGuessSigma_x</code> </dt><dd><p>A real fraction number in the
interval (0, 1) or an integer bigger than 1 controlling the
number of tips to use for analytical calculation of the evolutionary rate
matrix under a BM assumption. This option is used in the suggested PCMFit
R-package. Default: 0.25. </p>
</dd>
<dt><code>PCMBase.UsePCMVarForVCV</code> </dt><dd><p>Logical (default: FALSE) indicating
if the function <code><a href="#topic+PCMTreeVCV">PCMTreeVCV</a></code> should use <code><a href="#topic+PCMVar">PCMVar</a></code>
instead of ape's function <code><a href="ape.html#topic+vcv">vcv</a></code> to calculate the phylogenetic
variance covariance matrix under BM assumption. Note that setting this option
to TRUE would slow down the function PCMTreeVCV considerably but may be more
stable, particularly in the case of very big and deep trees, where previous
ape's versions of the <code><a href="ape.html#topic+vcv">vcv</a></code> function have thrown stack-overflow
errors.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>PCMOptions()
</code></pre>

<hr>
<h2 id='PCMPairSums'>Sums of pairs of elements in a vector</h2><span id='topic+PCMPairSums'></span>

<h3>Description</h3>

<p>Sums of pairs of elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPairSums(lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPairSums_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a squared symmetric matrix with elem_ij=lambda_i+lambda_j.
</p>

<hr>
<h2 id='PCMParam'>Module PCMParam</h2><span id='topic+PCMParam'></span>

<h3>Description</h3>

<p>Global and S3 generic functions for manipulating model parameters.
The parameters in a PCM are named objects with a class attribute specifying
the main type and optional properties (tags).
</p>
<p>S3 generic functions:
</p>

<dl>
<dt>PCMParamCount()</dt><dd><p>Counting the number of actual numeric parameters (used,
e.g. for calculating information scores, e.g. AIC);</p>
</dd>
<dt>PCMParamLoadOrStore(), PCMParamLoadOrStore()</dt><dd><p>Storing/loading a parameter
to/from a numerical vector;</p>
</dd>
<dt>PCMParamLowerLimit(),PCMParamUpperLimit()</dt><dd><p>Specifying parameter upper and lower limits;</p>
</dd>
<dt>PCMParamRandomVecParams()</dt><dd><p>Generating a random parameter vector;</p>
</dd>
</dl>

<p>For all the above properties, check-functions are defined, e.g. 'is.Local(o)',
'is.Global(o)', 'is.ScalarParameter(o)', 'is.VectorParameter', etc.
</p>

<hr>
<h2 id='PCMParamBindRegimeParams'>Bind named vectors or matrices into an array so that the names form the names of the last dimension.</h2><span id='topic+PCMParamBindRegimeParams'></span>

<h3>Description</h3>

<p>Bind named vectors or matrices into an array so that the names form the names of the last dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamBindRegimeParams(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamBindRegimeParams_+3A_...">...</code></td>
<td>
<p>Any number of named vectors, or matrices. The dimensions of all the
arrays must match. The names will be used for the names of the regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with dim attribute one longer than the number of dimensions of
each argument, i.e. if there are 5 vector arguments of length 2, the returned
value will be an array with dim c(2,5); if there are 5 matrix arguments of
dim 2 x 2, the returned value will be an array with dim c(2,2,5).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regimes

# in regime 'a' the three traits evolve according to three independent OU processes
a.X0 &lt;- c(5, 2, 1)
a.H &lt;- rbind(
  c(0, 0, 0),
  c(0, 2, 0),
  c(0, 0, 3))
a.Theta &lt;- c(10, 6, 2)
a.Sigma_x &lt;- rbind(
  c(1.6, 0.0, 0.0),
  c(0.0, 2.4, 0.0),
  c(0.0, 0.0, 2.0))
a.Sigmae_x &lt;- rbind(
  c(0.0, 0.0, 0.0),
  c(0.0, 0.0, 0.0),
  c(0.0, 0.0, 0.0))
a.h_drift&lt;-c(0, 0, 0)

# in regime 'b' there is correlation between the traits
b.X0 &lt;- c(12, 4, 3)
b.H &lt;- rbind(
  c(2.0, 0.1, 0.2),
  c(0.1, 0.6, 0.2),
  c(0.2, 0.2, 0.3))
b.Theta &lt;- c(10, 6, 2)
b.Sigma_x &lt;- rbind(
  c(1.6, 0.3, 0.3),
  c(0.0, 0.3, 0.4),
  c(0.0, 0.0, 2.0))
b.Sigmae_x &lt;- rbind(
  c(0.2, 0.0, 0.0),
  c(0.0, 0.3, 0.0),
  c(0.0, 0.0, 0.4))
b.h_drift&lt;-c(1, 2, 3)

H &lt;- PCMParamBindRegimeParams(a = a.H, b = b.H)
Theta &lt;- PCMParamBindRegimeParams(a = a.Theta, b = b.Theta)
Sigma_x &lt;- PCMParamBindRegimeParams(a = a.Sigma_x, b = b.Sigma_x)
Sigmae_x &lt;- PCMParamBindRegimeParams(a = a.Sigmae_x, b = b.Sigmae_x)
h_drift &lt;- PCMParamBindRegimeParams(a = a.h_drift, b = b.h_drift)

model.a.BM_drift.123 &lt;- PCM("BM_drift", k = 3, regimes = "a",
params = list(
  X0 = a.X0,
  h_drift = h_drift[,'a',drop=FALSE],
  Sigma_x = Sigma_x[,,'a',drop=FALSE],
  Sigmae_x = Sigmae_x[,,'a',drop=FALSE]))

# regimes 'a' and 'b', traits 1, 2 and 3
model.ab.123 &lt;- PCM("OU", k = 3, regimes = c("a", "b"),
                    params = list(
                      X0 = a.X0,
                      H = H[,,,drop=FALSE],
                      Theta = Theta[,,drop=FALSE],
                      Sigma_x = Sigma_x[,,,drop=FALSE],
                      Sigmae_x = Sigmae_x[,,,drop=FALSE]))

</code></pre>

<hr>
<h2 id='PCMParamCount'>Count the number of free parameters associated with a PCM or a PCM-parameter</h2><span id='topic+PCMParamCount'></span>

<h3>Description</h3>

<p>Count the number of free parameters associated with a PCM or a PCM-parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamCount(
  o,
  countRegimeChanges = FALSE,
  countModelTypes = FALSE,
  offset = 0L,
  k = 1L,
  R = 1L,
  parentModel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamCount_+3A_o">o</code></td>
<td>
<p>a PCM model object or a parameter of a PCM object</p>
</td></tr>
<tr><td><code id="PCMParamCount_+3A_countregimechanges">countRegimeChanges</code></td>
<td>
<p>logical indicating if regime changes should be
counted. If TRUE, the default implementation would add
<code>PCMNumRegimes(model) - 1</code>. Default FALSE.</p>
</td></tr>
<tr><td><code id="PCMParamCount_+3A_countmodeltypes">countModelTypes</code></td>
<td>
<p>logical indicating whether the model type should be
counted. If TRUE the default implementation will add +1 only if there are
more than one modelTypes
(<code>length(attr(model, "modelTypes", exact = TRUE)) &gt; 1</code>),
assuming that all regimes are regimes of the same model type (e.g. OU). The
implementation for MRG models will add +1 for every regime if there are more
than one modelTypes. Default FALSE.</p>
</td></tr>
<tr><td><code id="PCMParamCount_+3A_offset">offset</code></td>
<td>
<p>an integer denoting an offset count from which to start counting
(internally used). Default: 0.</p>
</td></tr>
<tr><td><code id="PCMParamCount_+3A_k">k</code></td>
<td>
<p>an integer denoting the number of modeled traits. Default: 1.</p>
</td></tr>
<tr><td><code id="PCMParamCount_+3A_r">R</code></td>
<td>
<p>an integer denoting the number of regimes in the model. Default: 1.</p>
</td></tr>
<tr><td><code id="PCMParamCount_+3A_parentmodel">parentModel</code></td>
<td>
<p>NULL or a PCM object. Default: NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>

<hr>
<h2 id='PCMParamGetShortVector'>Get a vector of the variable numeric parameters in a model</h2><span id='topic+PCMParamGetShortVector'></span>

<h3>Description</h3>

<p>The short vector of the model parameters does not include the
nodes in the tree where a regime change occurs, nor the the model types
associated with each regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamGetShortVector(o, k = 1L, R = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamGetShortVector_+3A_o">o</code></td>
<td>
<p>a PCM model object or a parameter of a PCM object</p>
</td></tr>
<tr><td><code id="PCMParamGetShortVector_+3A_k">k</code></td>
<td>
<p>an integer denoting the number of modeled traits. Default: 1.</p>
</td></tr>
<tr><td><code id="PCMParamGetShortVector_+3A_r">R</code></td>
<td>
<p>an integer denoting the number of regimes in the model. Default: 1.</p>
</td></tr>
<tr><td><code id="PCMParamGetShortVector_+3A_...">...</code></td>
<td>
<p>other arguments that could be used by implementing methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length equal to
'PCMParamCount(o, FALSE, FALSE, 0L, k, R)'.
</p>

<hr>
<h2 id='PCMParamLoadOrStore'>Load (or store) a PCM parameter from (or to) a vector of the variable parameters in a model.</h2><span id='topic+PCMParamLoadOrStore'></span>

<h3>Description</h3>

<p>Load (or store) a PCM parameter from (or to) a vector of the variable parameters in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamLoadOrStore(o, vecParams, offset, k, R, load, parentModel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamLoadOrStore_+3A_o">o</code></td>
<td>
<p>a PCM model object or a parameter of a PCM object</p>
</td></tr>
<tr><td><code id="PCMParamLoadOrStore_+3A_vecparams">vecParams</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="PCMParamLoadOrStore_+3A_offset">offset</code></td>
<td>
<p>an integer denoting an offset count from which to start counting
(internally used). Default: 0.</p>
</td></tr>
<tr><td><code id="PCMParamLoadOrStore_+3A_k">k</code></td>
<td>
<p>an integer denoting the number of modeled traits. Default: 1.</p>
</td></tr>
<tr><td><code id="PCMParamLoadOrStore_+3A_r">R</code></td>
<td>
<p>an integer denoting the number of regimes in the model. Default: 1.</p>
</td></tr>
<tr><td><code id="PCMParamLoadOrStore_+3A_load">load</code></td>
<td>
<p>logical indicating if parameters should be loaded from vecParams into o (TRUE)
or stored to vecParams from o (FALSE).</p>
</td></tr>
<tr><td><code id="PCMParamLoadOrStore_+3A_parentmodel">parentModel</code></td>
<td>
<p>NULL or a PCM object. Default: NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This S3 generic function has both, a returned value and side effects.
</p>


<h3>Value</h3>

<p>an integer equaling the number of elements read from vecParams.
In the case of type==&quot;custom&quot;, the number of indices bigger than offset returned by the function indices(offset, k).
</p>

<hr>
<h2 id='PCMParamLocateInShortVector'>Locate a named parameter in the short vector representation of a model</h2><span id='topic+PCMParamLocateInShortVector'></span>

<h3>Description</h3>

<p>Locate a named parameter in the short vector representation of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamLocateInShortVector(o, accessExpr, enclos = "?")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamLocateInShortVector_+3A_o">o</code></td>
<td>
<p>a PCM model object.</p>
</td></tr>
<tr><td><code id="PCMParamLocateInShortVector_+3A_accessexpr">accessExpr</code></td>
<td>
<p>a character string used to access the parameter, e.g.
<code>"$Theta[,,1]"</code> or <code>"[['Theta']][,,1]"</code>.</p>
</td></tr>
<tr><td><code id="PCMParamLocateInShortVector_+3A_enclos">enclos</code></td>
<td>
<p>a character string containing the symbol '?', e.g.
<code>'diag(?)'</code>. The meaning of this symbol is to be replaced by the matching
accessExpr (see examples). Default value : <code>'?'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of length <code>PCMParamCount(o)</code> with NAs
everywhere except at the coordinates corresponding to the parameter in
question.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- PCM(PCMDefaultModelTypes()["D"], k = 3, regimes = c("a", "b"))
# The parameter H is a diagonal 3x3 matrix. If this matrix is considered as
# a vector the indices of its diagonal elements are 1, 5 and 9. These indices
# are indicated as the non-NA entries in the returned vector.

PCMParamLocateInShortVector(model, "$H[,,1]")
PCMParamLocateInShortVector(model, "$H[,,'a']")
PCMParamLocateInShortVector(model, "$H[,,'b']")
PCMParamLocateInShortVector(model, "$Sigma_x[,,'b']", enclos = 'diag(?)')
PCMParamLocateInShortVector(model, "$Sigma_x[,,'b']", enclos = '?[upper.tri(?)]')
</code></pre>

<hr>
<h2 id='PCMParamLowerLimit'>The lower limit for a given model or parameter type</h2><span id='topic+PCMParamLowerLimit'></span>

<h3>Description</h3>

<p>This is an S3 generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamLowerLimit(o, k, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamLowerLimit_+3A_o">o</code></td>
<td>
<p>an object such as a VectorParameter a MatrixParameter or a PCM.</p>
</td></tr>
<tr><td><code id="PCMParamLowerLimit_+3A_k">k</code></td>
<td>
<p>integer denoting the number of traits</p>
</td></tr>
<tr><td><code id="PCMParamLowerLimit_+3A_r">R</code></td>
<td>
<p>integer denoting the number of regimes in the model in which o
belongs to.</p>
</td></tr>
<tr><td><code id="PCMParamLowerLimit_+3A_...">...</code></td>
<td>
<p>additional arguments (optional or future use).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same S3 class as o representing a lower limit
for the class.
</p>

<hr>
<h2 id='PCMParamRandomVecParams'>Generate a random parameter vector for a model using uniform distribution
between its lower and upper bounds.</h2><span id='topic+PCMParamRandomVecParams'></span>

<h3>Description</h3>

<p>Generate a random parameter vector for a model using uniform distribution
between its lower and upper bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamRandomVecParams(
  o,
  k,
  R,
  n = 1L,
  argsPCMParamLowerLimit = NULL,
  argsPCMParamUpperLimit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamRandomVecParams_+3A_o">o</code></td>
<td>
<p>a PCM model object or a parameter</p>
</td></tr>
<tr><td><code id="PCMParamRandomVecParams_+3A_k">k</code></td>
<td>
<p>integer denoting the number of traits.</p>
</td></tr>
<tr><td><code id="PCMParamRandomVecParams_+3A_r">R</code></td>
<td>
<p>integer denoting the number of regimes.</p>
</td></tr>
<tr><td><code id="PCMParamRandomVecParams_+3A_n">n</code></td>
<td>
<p>an integer specifying the number of random vectors to generate</p>
</td></tr>
<tr><td><code id="PCMParamRandomVecParams_+3A_argspcmparamlowerlimit">argsPCMParamLowerLimit</code>, <code id="PCMParamRandomVecParams_+3A_argspcmparamupperlimit">argsPCMParamUpperLimit</code></td>
<td>
<p>named lists of
arguments passed to
<code>PCMParamLowerLimit</code> and <code>PCMParamUpperLimit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of dimension <code>n</code> x <code>PCMParamCount(o)</code>.
</p>


<h3>See Also</h3>

<p>PCMParamLimits PCMParamGetShortVector
</p>

<hr>
<h2 id='PCMParamSetByName'>Set model parameters from a named list</h2><span id='topic+PCMParamSetByName'></span>

<h3>Description</h3>

<p>Set model parameters from a named list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamSetByName(
  model,
  params,
  inplace = TRUE,
  replaceWholeParameters = FALSE,
  deepCopySubPCMs = FALSE,
  failIfNamesInParamsDontExist = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamSetByName_+3A_model">model</code></td>
<td>
<p>a PCM model object</p>
</td></tr>
<tr><td><code id="PCMParamSetByName_+3A_params">params</code></td>
<td>
<p>a named list with elements among the names found in model</p>
</td></tr>
<tr><td><code id="PCMParamSetByName_+3A_inplace">inplace</code></td>
<td>
<p>logical indicating if the parameters should be set &quot;inplace&quot;
for the model object in the calling environment or a new model object with
the parameters set as specified should be returned. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="PCMParamSetByName_+3A_replacewholeparameters">replaceWholeParameters</code></td>
<td>
<p>logical, by default set to FALSE. If TRUE, the
parameters will be completely replaced, meaning that their attributes (e.g.
S3 class) will be replaced as well (dangerous).</p>
</td></tr>
<tr><td><code id="PCMParamSetByName_+3A_deepcopysubpcms">deepCopySubPCMs</code></td>
<td>
<p>a logical indicating whether nested PCMs should be
'deep'-copied, meaning element by element, eventually preserving the
attributes as in <code>model</code>. By default this is set to FALSE, meaning
that sub-PCMs found in <code>params</code> will completely overwrite the
sub-PCMs with the same name in <code>model</code>.</p>
</td></tr>
<tr><td><code id="PCMParamSetByName_+3A_failifnamesinparamsdontexist">failIfNamesInParamsDontExist</code></td>
<td>
<p>logical indicating if an error should be
raised if <code>params</code> contains elements not existing in model. Default: TRUE.</p>
</td></tr>
<tr><td><code id="PCMParamSetByName_+3A_...">...</code></td>
<td>
<p>other arguments that can be used by implementing methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If inplace is TRUE, the function only has a side effect of setting
the parameters of the model object in the calling environment; otherwise the
function returns a modified copy of the model object.
</p>

<hr>
<h2 id='PCMParamType'>Parameter types</h2><span id='topic+PCMParamType'></span><span id='topic+is.Local'></span><span id='topic+is.Global'></span><span id='topic+is.ScalarParameter'></span><span id='topic+is.VectorParameter'></span><span id='topic+is.MatrixParameter'></span><span id='topic+is.WithCustomVecParams'></span><span id='topic+is.Fixed'></span><span id='topic+is.Zeros'></span><span id='topic+is.Ones'></span><span id='topic+is.Identity'></span><span id='topic+is.AllEqual'></span><span id='topic+is.NonNegative'></span><span id='topic+is.Diagonal'></span><span id='topic+is.ScalarDiagonal'></span><span id='topic+is.Symmetric'></span><span id='topic+is.UpperTriangular'></span><span id='topic+is.UpperTriangularWithDiagonal'></span><span id='topic+is.WithNonNegativeDiagonal'></span><span id='topic+is.LowerTriangular'></span><span id='topic+is.LowerTriangularWithDiagonal'></span><span id='topic+is.Omitted'></span><span id='topic+is.CholeskyFactor'></span><span id='topic+is.Schur'></span><span id='topic+is.Transformable'></span><span id='topic+is.Transformed'></span><span id='topic+is.SemiPositiveDefinite'></span>

<h3>Description</h3>

<p>The parameter types are divided in the following categories:
</p>

<dl>
<dt>Main type</dt><dd><p>These are the &quot;ScalarParameter&quot;, &quot;VectorParameter&quot; and &quot;MatrixParameter&quot;
classes. Each model parameter must have a main type.</p>
</dd>
<dt>Scope/Omission</dt><dd><p>These are the &quot;_Global&quot; and &quot;_Omitted&quot; classes. Every
parameter can be global for all regimes or local for a single regime. If not
specified, local scope is assumed. In some special cases a parameter (e.g.
Sigmae can be omitted from a model. This is done by adding &quot;_Omitted&quot; to its
class attribute.</p>
</dd>
<dt>Constancy (optional)</dt><dd><p>These are the &quot;_Fixed&quot;, &quot;_Ones&quot;, &quot;_Identity&quot; and
&quot;_Zeros&quot; classes.</p>
</dd>
<dt>Transformation (optional)</dt><dd><p>These are the &quot;_Transformable&quot;, &quot;_CholeskyFactor&quot;
and &quot;_Schur&quot; classes. </p>
</dd>
<dt>Other properties (optional)</dt><dd><p>These are the &quot;_NonNegative&quot;,
&quot;_WithNonNegativeDiagonal&quot;, &quot;_LowerTriangular&quot;, &quot;_AllEqual&quot;, &quot;_ScalarDiagonal&quot;,
&quot;_Symmetric&quot;, &quot;_UpperTriangular&quot;, &quot;_LowerTriangularWithDiagonal&quot; and
&quot;_UpperTriangularWithDiagonal&quot; classes.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>is.Local(o)

is.Global(o)

is.ScalarParameter(o)

is.VectorParameter(o)

is.MatrixParameter(o)

is.WithCustomVecParams(o)

is.Fixed(o)

is.Zeros(o)

is.Ones(o)

is.Identity(o)

is.AllEqual(o)

is.NonNegative(o)

is.Diagonal(o)

is.ScalarDiagonal(o)

is.Symmetric(o)

is.UpperTriangular(o)

is.UpperTriangularWithDiagonal(o)

is.WithNonNegativeDiagonal(o)

is.LowerTriangular(o)

is.LowerTriangularWithDiagonal(o)

is.Omitted(o)

is.CholeskyFactor(o)

is.Schur(o)

is.Transformable(o)

is.Transformed(o)

is.SemiPositiveDefinite(o)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamType_+3A_o">o</code></td>
<td>
<p>an object, i.e. a PCM or a parameter object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if the object passed is from the type appearing in
the function-name.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is.Local</code>: 
</p>
</li>
<li> <p><code>is.Global</code>: 
</p>
</li>
<li> <p><code>is.ScalarParameter</code>: 
</p>
</li>
<li> <p><code>is.VectorParameter</code>: 
</p>
</li>
<li> <p><code>is.MatrixParameter</code>: 
</p>
</li>
<li> <p><code>is.WithCustomVecParams</code>: 
</p>
</li>
<li> <p><code>is.Fixed</code>: 
</p>
</li>
<li> <p><code>is.Zeros</code>: 
</p>
</li>
<li> <p><code>is.Ones</code>: 
</p>
</li>
<li> <p><code>is.Identity</code>: 
</p>
</li>
<li> <p><code>is.AllEqual</code>: 
</p>
</li>
<li> <p><code>is.NonNegative</code>: 
</p>
</li>
<li> <p><code>is.Diagonal</code>: 
</p>
</li>
<li> <p><code>is.ScalarDiagonal</code>: 
</p>
</li>
<li> <p><code>is.Symmetric</code>: 
</p>
</li>
<li> <p><code>is.UpperTriangular</code>: 
</p>
</li>
<li> <p><code>is.UpperTriangularWithDiagonal</code>: 
</p>
</li>
<li> <p><code>is.WithNonNegativeDiagonal</code>: 
</p>
</li>
<li> <p><code>is.LowerTriangular</code>: 
</p>
</li>
<li> <p><code>is.LowerTriangularWithDiagonal</code>: 
</p>
</li>
<li> <p><code>is.Omitted</code>: 
</p>
</li>
<li> <p><code>is.CholeskyFactor</code>: 
</p>
</li>
<li> <p><code>is.Schur</code>: 
</p>
</li>
<li> <p><code>is.Transformable</code>: 
</p>
</li>
<li> <p><code>is.Transformed</code>: 
</p>
</li>
<li> <p><code>is.SemiPositiveDefinite</code>: 
</p>
</li></ul>

<hr>
<h2 id='PCMParamUpperLimit'>The upper limit for a given model or parameter type</h2><span id='topic+PCMParamUpperLimit'></span>

<h3>Description</h3>

<p>This is an S3 generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParamUpperLimit(o, k, R, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParamUpperLimit_+3A_o">o</code></td>
<td>
<p>an object such as a VectorParameter a MatrixParameter or a PCM.</p>
</td></tr>
<tr><td><code id="PCMParamUpperLimit_+3A_k">k</code></td>
<td>
<p>integer denoting the number of traits</p>
</td></tr>
<tr><td><code id="PCMParamUpperLimit_+3A_r">R</code></td>
<td>
<p>integer denoting the number of regimes in the model in which o
belongs to.</p>
</td></tr>
<tr><td><code id="PCMParamUpperLimit_+3A_...">...</code></td>
<td>
<p>additional arguments (optional or future use).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same S3 class as o representing an upper limit
for the class.
</p>

<hr>
<h2 id='PCMParentClasses'>Parent S3 classes for a model class</h2><span id='topic+PCMParentClasses'></span>

<h3>Description</h3>

<p>Parent S3 classes for a model class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParentClasses(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParentClasses_+3A_model">model</code></td>
<td>
<p>an S3 object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This S3 generic function is intended to be specified for user models.
This function is called by the 'PCM.character' method to determine the parent
classes for a given model class.
</p>


<h3>Value</h3>

<p>a vector of character string denoting the names of the parent classes
</p>

<hr>
<h2 id='PCMParseErrorMessage'>Extract error information from a formatted error message.</h2><span id='topic+PCMParseErrorMessage'></span>

<h3>Description</h3>

<p>Extract error information from a formatted error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMParseErrorMessage(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMParseErrorMessage_+3A_x">x</code></td>
<td>
<p>character string representing the error message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Currently the function returns <code>x</code> unchanged.
</p>

<hr>
<h2 id='PCMPExpxMeanExp'>Create a function of time that calculates <code class="reqn">(1-exp(-lambda_ij*time))/lambda_ij</code>
for every element <code class="reqn">lambda_ij</code> of the input matrix <code class="reqn">Lambda_ij</code>.</h2><span id='topic+PCMPExpxMeanExp'></span>

<h3>Description</h3>

<p>Create a function of time that calculates <code class="reqn">(1-exp(-lambda_ij*time))/lambda_ij</code>
for every element <code class="reqn">lambda_ij</code> of the input matrix <code class="reqn">Lambda_ij</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPExpxMeanExp(
  Lambda_ij,
  threshold.Lambda_ij = getOption("PCMBase.Threshold.Lambda_ij", 1e-08)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPExpxMeanExp_+3A_lambda_ij">Lambda_ij</code></td>
<td>
<p>a squared numerical matrix of dimension k x k</p>
</td></tr>
<tr><td><code id="PCMPExpxMeanExp_+3A_threshold.lambda_ij">threshold.Lambda_ij</code></td>
<td>
<p>a 0-threshold for abs(Lambda_i + Lambda_j), where Lambda_i
and Lambda_j are eigenvalues of the parameter matrix H. This
threshold-value is used as a condition to
take the limit time of the expression '(1-exp(-Lambda_ij*time))/Lambda_ij' as
'(Lambda_i+Lambda_j) &ndash;&gt; 0'. You can control this value by the global option
&quot;PCMBase.Threshold.Lambda_ij&quot;. The default value (1e-8) is suitable for branch
lengths bigger than 1e-6. For smaller branch lengths, you may want to
increase the threshold value using, e.g.
'options(PCMBase.Threshold.Lambda_ij=1e-6)'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function <code class="reqn">(1-exp(-lambda_ij*time))/lambda_ij</code> corresponds to the product
of the CDF of an exponential distribution with rate <code class="reqn">Lambda_ij</code> multiplied by its mean value (mean waiting time).
</p>


<h3>Value</h3>

<p>a function of time returning a matrix with entries formed from the
above function or the limit, time, if <code class="reqn">|Lambda_{ij}|&lt;=trehshold0</code>.
</p>

<hr>
<h2 id='PCMPLambdaP_1'>Eigen-decomposition of a matrix H</h2><span id='topic+PCMPLambdaP_1'></span>

<h3>Description</h3>

<p>Eigen-decomposition of a matrix H
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPLambdaP_1(H)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPLambdaP_1_+3A_h">H</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fails with an error message if H is defective, that is, if its matrix of
eigenvectors is computationally singular. The test for singularity is based on the <code><a href="base.html#topic+rcond">rcond</a></code> function.
</p>


<h3>Value</h3>

<p>a list with elements as follows:
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>a vector of the eigenvalues of H</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>a squared matrix with column vectors, the eigenvectors of H corresponding to the
eigenvalues in <code>lambda</code></p>
</td></tr>
<tr><td><code>P_1</code></td>
<td>
<p>the inverse matrix of <code>P</code></p>
</td></tr></table>
<p>.
</p>

<hr>
<h2 id='PCMPlotGaussianDensityGrid2D'>A 2D Gaussian distribution density grid in the form of a ggplot object</h2><span id='topic+PCMPlotGaussianDensityGrid2D'></span>

<h3>Description</h3>

<p>A 2D Gaussian distribution density grid in the form of a ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPlotGaussianDensityGrid2D(
  mu,
  Sigma,
  xlim,
  ylim,
  xNumPoints = 100,
  yNumPoints = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPlotGaussianDensityGrid2D_+3A_mu">mu</code></td>
<td>
<p>numerical mean vector of length 2</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianDensityGrid2D_+3A_sigma">Sigma</code></td>
<td>
<p>numerical 2 x 2 covariance matrix</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianDensityGrid2D_+3A_xlim">xlim</code>, <code id="PCMPlotGaussianDensityGrid2D_+3A_ylim">ylim</code></td>
<td>
<p>numerical vectors of length 2</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianDensityGrid2D_+3A_xnumpoints">xNumPoints</code>, <code id="PCMPlotGaussianDensityGrid2D_+3A_ynumpoints">yNumPoints</code></td>
<td>
<p>integers denoting how many points should the grid contain for each axis.</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianDensityGrid2D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to ggplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='PCMPlotGaussianSample2D'>A 2D sample from Gaussian distribution</h2><span id='topic+PCMPlotGaussianSample2D'></span>

<h3>Description</h3>

<p>A 2D sample from Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPlotGaussianSample2D(mu, Sigma, numPoints = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPlotGaussianSample2D_+3A_mu">mu</code></td>
<td>
<p>numerical mean vector of length 2</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianSample2D_+3A_sigma">Sigma</code></td>
<td>
<p>numerical 2 x 2 covariance matrix</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianSample2D_+3A_numpoints">numPoints</code></td>
<td>
<p>an integer denoting how many points should be randomly sampled (see details).</p>
</td></tr>
<tr><td><code id="PCMPlotGaussianSample2D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to ggplot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a random sample of numPoints 2d points using
the function rmvnorm from the mvtnorm R-package. Then
it produces a ggplot on the generated points.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='PCMPlotMath'>Beautiful model description based on plotmath</h2><span id='topic+PCMPlotMath'></span>

<h3>Description</h3>

<p>This is an S3 generic that produces a plotmath expression for
its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPlotMath(o, roundDigits = 2, transformSigma_x = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPlotMath_+3A_o">o</code></td>
<td>
<p>a PCM or a parameter object.</p>
</td></tr>
<tr><td><code id="PCMPlotMath_+3A_rounddigits">roundDigits</code></td>
<td>
<p>an integer, default: 2.</p>
</td></tr>
<tr><td><code id="PCMPlotMath_+3A_transformsigma_x">transformSigma_x</code></td>
<td>
<p>a logical indicating if Cholesky transformation should be
applied to Cholesky-factor parameters prior to generating the plotmath expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string.
</p>

<hr>
<h2 id='PCMPlotTraitData2D'>Scatter plot of 2-dimensional data</h2><span id='topic+PCMPlotTraitData2D'></span>

<h3>Description</h3>

<p>Scatter plot of 2-dimensional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPlotTraitData2D(
  X,
  tree,
  sizePoints = 2,
  alphaPoints = 1,
  labeledTips = NULL,
  sizeLabels = 8,
  nudgeLabels = c(0, 0),
  palette = PCMColorPalette(PCMNumRegimes(tree), PCMRegimes(tree)),
  scaleSizeWithTime = !is.ultrametric(tree),
  numTimeFacets = if (is.ultrametric(tree) || scaleSizeWithTime) 1L else 3L,
  nrowTimeFacets = 1L,
  ncolTimeFacets = numTimeFacets
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPlotTraitData2D_+3A_x">X</code></td>
<td>
<p>a k x N matrix</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_sizepoints">sizePoints</code>, <code id="PCMPlotTraitData2D_+3A_alphapoints">alphaPoints</code></td>
<td>
<p>numeric parameters passed as arguments size and alpha to <code>geom_point</code>.
Default: sizePoints = 2, alphaPoints = 1.</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_labeledtips">labeledTips</code></td>
<td>
<p>a vector of tip-numbers to label (NULL by default)</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_sizelabels">sizeLabels</code></td>
<td>
<p>passed to <code>geom_text</code> to specify the size of tip-labels for the trait-points.</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_nudgelabels">nudgeLabels</code></td>
<td>
<p>a numeric vector of two elements (default: c(0,0)), passed as
arguments nudge_x and nudge_y of <code>geom_text</code>.</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_palette">palette</code></td>
<td>
<p>a named vector of colors</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_scalesizewithtime">scaleSizeWithTime</code></td>
<td>
<p>logical indicating if the size and the transparency of the points
should reflect the distance from the present (points that are farther away in time with
respect to the present moment, i.e. closer to the root of the tree, are displayed smaller
and more transparent.). By default this is set to <code>!is.ultrametric(tree)</code>.</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_numtimefacets">numTimeFacets</code></td>
<td>
<p>a number or a numeric vector controlling the creation of different facets
corresponding to different time intervals when the tree is non-ultrametric. If a single number,
it will be interpreted as an integer specifying the number of facets, each facets corresponding to
an equal interval of time. If a numeric vector, it will be used to specify the cut-points for
each interval. Default: <code>if(is.ultrametric(tree) || scaleSizeWithTime) 1L else 3</code>.</p>
</td></tr>
<tr><td><code id="PCMPlotTraitData2D_+3A_nrowtimefacets">nrowTimeFacets</code>, <code id="PCMPlotTraitData2D_+3A_ncoltimefacets">ncolTimeFacets</code></td>
<td>
<p>integers specifying how the time facets should
be layed out. Default: <code>nrowTimeFacets = 1L, ncolTimeFacets = numTimeFacets</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='PCMPresentCoordinates'>Determine which traits are present (active) on each node of the tree</h2><span id='topic+PCMPresentCoordinates'></span>

<h3>Description</h3>

<p>For every node (root, internal or tip) in tree, build a logical
vector of length k with TRUE values for every present coordinate. Non-present
coordinates arize from NA-values in the trait data. These can occur in two cases:
</p>

<dl>
<dt>Missing measurements for some traits at some tips:</dt><dd><p>the present coordinates
are FALSE for the corresponding tip and trait, but are full for all traits
at all internal and root nodes.</p>
</dd>
<dt>non-existent traits for some species:</dt><dd><p>the FALSE present coordinates
propagate towards the parent
nodes - an internal or root node will have a present coordinate set to FALSE
for a given trait, if all of its descendants have this coordinate set to FALSE.</p>
</dd>
</dl>

<p>These two cases have different effect on the likelihood calculation: missing
measurements (NA) are integrated out at the parent nodes; while non-existent
traits (NaN) are treated as reduced dimensionality of the vector at the
parent node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMPresentCoordinates(X, tree, metaI)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMPresentCoordinates_+3A_x">X</code></td>
<td>
<p>numeric k x N matrix of observed values, with possible NA entries. The
columns in X are in the order of tree$tip.label</p>
</td></tr>
<tr><td><code id="PCMPresentCoordinates_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMPresentCoordinates_+3A_metai">metaI</code></td>
<td>
<p>The result of calling PCMInfo.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a k x M logical matrix. The function fails in case when all traits are NAs for some of the tips.
In that case an error message is issued
&quot;PCMPresentCoordinates:: Some tips have 0 present coordinates. Consider
removing these tips.&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMLik">PCMLik</a></code>
</p>

<hr>
<h2 id='PCMRegimes'>Get the regimes (aka colors) of a PCM or of a PCMTree object</h2><span id='topic+PCMRegimes'></span>

<h3>Description</h3>

<p>Get the regimes (aka colors) of a PCM or of a PCMTree object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMRegimes(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMRegimes_+3A_obj">obj</code></td>
<td>
<p>a PCM or a PCMTree object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character or an integer vector giving the regime names in the obj
</p>

<hr>
<h2 id='PCMSetAttribute'>Set an attribute of a named member in a PCM or other named list object</h2><span id='topic+PCMSetAttribute'></span>

<h3>Description</h3>

<p>Set an attribute of a named member in a PCM or other named list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMSetAttribute(
  name,
  value,
  object,
  member = "",
  spec = TRUE,
  inplace = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMSetAttribute_+3A_name">name</code></td>
<td>
<p>a character string denoting the attribute name.</p>
</td></tr>
<tr><td><code id="PCMSetAttribute_+3A_value">value</code></td>
<td>
<p>the value for the attribute.</p>
</td></tr>
<tr><td><code id="PCMSetAttribute_+3A_object">object</code></td>
<td>
<p>a PCM or a list object.</p>
</td></tr>
<tr><td><code id="PCMSetAttribute_+3A_member">member</code></td>
<td>
<p>a member expression. Member expressions are character strings
denoting named elements in a list object (see examples). Default: &quot;&quot;.</p>
</td></tr>
<tr><td><code id="PCMSetAttribute_+3A_spec">spec</code></td>
<td>
<p>a logical (TRUE by default) indicating if the attribute should
also be set in the corresponding member of the spec attribute (this is for
PCM objects only).</p>
</td></tr>
<tr><td><code id="PCMSetAttribute_+3A_inplace">inplace</code></td>
<td>
<p>logical (TRUE by default) indicating if the attribute should
be set to the object in the current environment, or a modified object should
be returned.</p>
</td></tr>
<tr><td><code id="PCMSetAttribute_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+MatchListMembers">MatchListMembers</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling this function can affect the attributes of multiple members
matched by the <code>member</code> argument.
</p>


<h3>Value</h3>

<p>if inplace is TRUE (default) nothing is returned. Otherwise, a
modified version of object is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- PCMBaseTestObjects$model_MixedGaussian_ab
PCMSetAttribute("class", c("MatrixParameter", "_Fixed"), model, "H")
</code></pre>

<hr>
<h2 id='PCMSim'>Simulation of a phylogenetic comparative model on a tree</h2><span id='topic+PCMSim'></span>

<h3>Description</h3>

<p>Generate trait data on a tree according to a multivariate stochastic
model with one or several regimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMSim(
  tree,
  model,
  X0,
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X = NULL, tree = tree, model = model, SE = SE, verbose = verbose),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMSim_+3A_tree">tree</code></td>
<td>
<p>a phylo object specifying a rooted tree.</p>
</td></tr>
<tr><td><code id="PCMSim_+3A_model">model</code></td>
<td>
<p>an S3 object specifying the model (see Details).</p>
</td></tr>
<tr><td><code id="PCMSim_+3A_x0">X0</code></td>
<td>
<p>a numeric vector of length k (the number of traits) specifying the
trait values at the root of the tree.</p>
</td></tr>
<tr><td><code id="PCMSim_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each node i=1, ..., N.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMSim_+3A_metai">metaI</code></td>
<td>
<p>a named list containing meta-information about the data and the
model.</p>
</td></tr>
<tr><td><code id="PCMSim_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if informative messages should be written
during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, this function uses the <code><a href="#topic+PCMCond">PCMCond</a></code> implementation
for the given model class.
</p>


<h3>Value</h3>

<p>numeric M x k matrix of values at all nodes of the tree, i.e. root,
internal and tip, where M is the number of nodes: <code>M=dim(tree$edge)[1]+1</code>,
with indices from 1 to N=length(tree$tip.label) corresponding to tips, N+1
corresponding to the root and bigger than N+1 corresponding to internal nodes.
The function will fail in case that the length of the argument vector X0 differs
from the number of traits specified in <code>metaI$k</code>. Error message:
&quot;PCMSim:: X0 must be of length ...&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMLik">PCMLik</a></code> <code><a href="#topic+PCMInfo">PCMInfo</a></code> <code><a href="#topic+PCMCond">PCMCond</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 10
L &lt;- 100.0
tr &lt;- ape::stree(N)
tr$edge.length &lt;- rep(L, N)
for(epoch in seq(1, L, by = 1.0)) {
  tr &lt;- PCMTreeInsertSingletonsAtEpoch(tr, epoch)
}

model &lt;- PCMBaseTestObjects$model_MixedGaussian_ab

PCMTreeSetPartRegimes(tr, c(`11` = 'a'), setPartition = TRUE)

set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
X &lt;- PCMSim(tr, model, X0 = rep(0, 3))


</code></pre>

<hr>
<h2 id='PCMSpecify'>Parameter specification of PCM model</h2><span id='topic+PCMSpecify'></span>

<h3>Description</h3>

<p>The parameter specification of a PCM model represents a named
list with an entry for each parameter of the model. Each entry in the list is
a structure defining the S3 class of the parameter and its verbal description.
This is an S3 generic. See 'PCMSpecify.OU' for an example method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMSpecify(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMSpecify_+3A_model">model</code></td>
<td>
<p>a PCM model object.</p>
</td></tr>
<tr><td><code id="PCMSpecify_+3A_...">...</code></td>
<td>
<p>additional arguments used by implementing methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list specifying the parameters of a PCM.
</p>

<hr>
<h2 id='PCMTable'>A data.table representation of a PCM object</h2><span id='topic+PCMTable'></span>

<h3>Description</h3>

<p>A data.table representation of a PCM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTable(
  model,
  skipGlobalRegime = FALSE,
  addTransformed = TRUE,
  removeUntransformed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTable_+3A_model">model</code></td>
<td>
<p>a PCM object.</p>
</td></tr>
<tr><td><code id="PCMTable_+3A_skipglobalregime">skipGlobalRegime</code></td>
<td>
<p>logical indicating whether a raw in the returned
table for the global-scope parameters should be omitted (this is mostly for
internal use). Default (FALSE).</p>
</td></tr>
<tr><td><code id="PCMTable_+3A_addtransformed">addTransformed</code></td>
<td>
<p>logical. If TRUE (the default), columns for the
transformed version of the transformable parameters will be added.</p>
</td></tr>
<tr><td><code id="PCMTable_+3A_removeuntransformed">removeUntransformed</code></td>
<td>
<p>logical If TRUE (default), columns for the
untransformed version of the transformable parameters will be omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic.
</p>


<h3>Value</h3>

<p>an object of S3 class PCMTable
</p>

<hr>
<h2 id='PCMTableParameterizations'>Cartesian product of possible parameterizations for the different parameters of a model</h2><span id='topic+PCMTableParameterizations'></span>

<h3>Description</h3>

<p>This function generates a data.table in which each column corresponds to
one parameter of model and each row corresponds to one combination of parameterizations
for the model parameters, such that the whole table corresponds to the Cartesian product
of the lists found in 'listParameterizations'. Usually, subsets of this table
should be passed to 'PCMGenerateParameterizations'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTableParameterizations(
  model,
  listParameterizations = PCMListParameterizations(model, ...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTableParameterizations_+3A_model">model</code></td>
<td>
<p>a PCM object.</p>
</td></tr>
<tr><td><code id="PCMTableParameterizations_+3A_listparameterizations">listParameterizations</code></td>
<td>
<p>a list returned by a method for 'PCMListParameterizations'.
Default: 'PCMListParameterizations(model, ...)'.</p>
</td></tr>
<tr><td><code id="PCMTableParameterizations_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 'PCMListParameterizations(model, ...)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table object.
</p>

<hr>
<h2 id='PCMTrajectory'>Generate a trajectory for the mean in one regime of a PCM</h2><span id='topic+PCMTrajectory'></span>

<h3>Description</h3>

<p>Generate a trajectory for the mean in one regime of a PCM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTrajectory(
  model,
  regime = PCMRegimes(model)[1],
  X0 = rep(0, PCMNumTraits(model)),
  W0 = matrix(0, nrow = PCMNumTraits(model), ncol = PCMNumTraits(model)),
  tX = seq(0, 100, by = 1),
  tVar = tX[seq(0, length(tX), length.out = 4)],
  dims = seq_len(PCMNumTraits(model)),
  sizeSamp = 100,
  doPlot2D = FALSE,
  plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTrajectory_+3A_model">model</code></td>
<td>
<p>a PCM object.</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_regime">regime</code></td>
<td>
<p>a regime in 'model'. Default is PCMRegimes(model)[1].</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_x0">X0</code></td>
<td>
<p>a numeric vector specifying an initial point in the trait space.
Default is rep(0, PCMNumTraits(model))</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_w0">W0</code></td>
<td>
<p>a numeric k x k symmetric positive definite matrix or 0 matrix,
specifying the initial variance covariance matrix at t0. By default, this is
a k x k 0 matrix.</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_tx">tX</code>, <code id="PCMTrajectory_+3A_tvar">tVar</code></td>
<td>
<p>numeric vectors of positive points in time sorted in
increasing order. tX specifies the points in time at which to calculate the
mean (conditional on X0). tVar specifies a subset of the points in tX at
which to generate random samples from the k-variate Gaussian distribution
with mean equal to the mean value at the corresponding time conditional on X0
and variance equal to the variance at this time, conditional on W0. Default
settings are 'tX = seq(0, 100, by = 1)' and
'tVar = tX[seq(0, length(tX), length.out = 4)]'.</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_dims">dims</code></td>
<td>
<p>an integer vector specifying the traits for which samples at tVar
should be generated (see tX,tVar above).
Default: seq_len(PCMNumTraits(model)).</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_sizesamp">sizeSamp</code></td>
<td>
<p>an integer specifying the number points in the random
samples (see tX and tVar above). Default 100.</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_doplot2d">doPlot2D</code></td>
<td>
<p>Should a ggplot object be produced and returned. This is
possible only for two of the traits specified in dims.  Default: FALSE.</p>
</td></tr>
<tr><td><code id="PCMTrajectory_+3A_plot">plot</code></td>
<td>
<p>a ggplot object. This can be specified when doPlot2D is TRUE and
allows to add the plot of this trajectory as a layer in an existing ggplot.
Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if doPlot2D is TRUE, returns a ggplot. Otherwise a named list of two
elements:
</p>

<dl>
<dt>dt </dt><dd><p>a data.table with columns 'regime', 't', 'X', 'V' and 'samp'. For
each row corresponding to time in tVar, the column samp represents a list of
sizeSamp k-vectors.</p>
</dd>
<dt>dtPlot </dt><dd><p>a data.table with the same data as in dt, but with converted
columns X and samp into 2 x k columns denoted xi, i=1,...,k and xsi (i=1...k)
This is suitable for plotting with ggplot.</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")

# a Brownian motion model with one regime
modelOU &lt;- PCM(model = PCMDefaultModelTypes()['F'], k = 2)

# assign the model parameters at random: this will use uniform distribution
# with boundaries specified by PCMParamLowerLimit and PCMParamUpperLimit
# We do this in two steps:
# 1. First we generate a random vector. Note the length of the vector equals
# PCMParamCount(modelBM).

randomParams &lt;- PCMParamRandomVecParams(
  modelOU, PCMNumTraits(modelOU), PCMNumRegimes(modelOU))
# 2. Then we load this random vector into the model.
PCMParamLoadOrStore(
  modelOU,
  randomParams,
  0, PCMNumTraits(modelBM), PCMNumRegimes(modelBM), load = TRUE)

# let's plot the trajectory of the model starting from X0 = c(0,0)
PCMTrajectory(
  model = modelOU,
  X0 = c(0, 0),
  doPlot2D = TRUE)


# A faceted grid of plots for the two regimes in a mixed model:
pla &lt;- PCMTrajectory(
  model = PCMBaseTestObjects$model_MixedGaussian_ab, regime = "a",
  X0 = c(0, 0, 0),
  doPlot2D = TRUE) +
  ggplot2::scale_y_continuous(limits = c(0, 10)) +
  ggplot2::facet_grid(.~regime)

plb &lt;- PCMTrajectory(
  model = PCMBaseTestObjects$model_MixedGaussian_ab, regime = "b",
  X0 = c(0, 0, 0),
  doPlot2D = TRUE) +
  ggplot2::scale_y_continuous(limits = c(0, 10)) +
  ggplot2::facet_grid(.~regime) +
  ggplot2::theme(
    axis.title.y = ggplot2::element_blank(),
    axis.text.y = ggplot2::element_blank(),
    axis.ticks.y = ggplot2::element_blank())

plot(pla)
plot(plb)
</code></pre>

<hr>
<h2 id='PCMTree'>Create a PCMTree object from a phylo object</h2><span id='topic+PCMTree'></span>

<h3>Description</h3>

<p>PCMTree is class that inherits from the class 'phylo' in the
R-package 'ape'. Thus, all the functions working on a phylo object would work
in the same way if they receive as argument an object of class 'PCMTree'. A
PCMTree object has the following members in addition to the regular members
('tip.label', 'node.label', 'edge', 'edge.length') found in a regular phylo
object:
</p>

<dl>
<dt>edge.part </dt><dd><p>a character vector having as many elements as there are
branches in the tree (corresponding to the rows in 'tree$edge'). Each element
denotes the name of the part to which the corresponding branch belongs. A
part in the tree represents a connected subset of its nodes and the branches
leading to these nodes. A partition of the tree represents the splitting of
the tree into a number of parts. Visually, a partition can be represented as
a coloring of the tree, in which no color is assigned to more than one part.
In other words, if two branches in the tree are connected by the same color,
they either share a node, or all the branches on the path in the tree
connecting these two branches have the same color. Formally, we define a
partition of the tree as any set of nodes in the tree that includes the root.
Each node in this set defines a part as the set of its descendant nodes that
can be reached without traversing another partition node. We name
each part by the label of its most ancestral node, that is, the node in it,
which is closest to the root fo the tree. The value of edge.part for an edge
in the tree is the name of the part that contains the node to which the edge
is pointing.</p>
</dd>
<dt>part.regime </dt><dd><p>a named vector of size the number of parts in the tree.
The names correspond to part-names whereas the values denote the ids or
character names of regimes in a PCM object.</p>
</dd>
</dl>

<p>The constructor PCMTree() returns an object of call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTree(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTree_+3A_tree">tree</code></td>
<td>
<p>a phylo object. If this is already a PCMTree object, a copy of
this object will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class PCMTree. This is a copy of the passed phylo object
which is guaranteed to have node.label, edge.part and a part.regime
entries set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::rtree(8)

# the following four are NULLs
tree$node.label
tree$edge.part
tree$part.regime
tree$edge.regime

# In previous version regimes were assigned directly to the edges via
# tree$edge.regime. This is supported but not recommended anymore:

tree$edge.regime &lt;- sample(
  letters[1:3], size = PCMTreeNumNodes(tree) - 1, replace = TRUE)

tree.a &lt;- PCMTree(tree)
PCMTreeGetLabels(tree.a)
tree.a$node.label
tree.a$edge.part
tree.a$part.regime

# this is set to NULL - starting from PCMBase 1.2.9 all of the information
# for the regimes is stored in tree$edge.part and tree$part.regime.
tree.a$edge.regime

PCMTreeGetPartition(tree.a)
PCMTreeGetPartNames(tree.a)
PCMTreeGetPartRegimes(tree.a)

# let's see how the tree looks like
if(requireNamespace("ggtree"))
PCMTreePlot(tree.a) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

# This is the recommended way to set a partition on the tree
PCMTreeSetPartition(tree.a, c(10, 12))

PCMTreeGetPartition(tree.a)
PCMTreeGetPartNames(tree.a)
PCMTreeGetPartRegimes(tree.a)



if(requireNamespace("ggtree"))
PCMTreePlot(tree.a) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

PCMTreeGetPartsForNodes(tree.a, c(11, 15, 12))
PCMTreeGetPartsForNodes(tree.a, c("11", "15", "12"))

PCMTreeSetPartRegimes(tree.a, c(`9` = 'a', `10` = 'b', `12` = 'c'))

PCMTreeGetPartition(tree.a)
PCMTreeGetPartNames(tree.a)
PCMTreeGetPartRegimes(tree.a)

if(requireNamespace("ggtree"))
PCMTreePlot(tree.a) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

</code></pre>

<hr>
<h2 id='PCMTreeBackbonePartition'>Prune the tree leaving one tip for each or some of its parts</h2><span id='topic+PCMTreeBackbonePartition'></span>

<h3>Description</h3>

<p>Prune the tree leaving one tip for each or some of its parts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeBackbonePartition(tree, partsToKeep = PCMTreeGetPartNames(tree))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeBackbonePartition_+3A_tree">tree</code></td>
<td>
<p>a PCMTree or a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeBackbonePartition_+3A_partstokeep">partsToKeep</code></td>
<td>
<p>a character vector denoting part names in the tree to be
kept. Defaults to 'PCMTreeGetPartNames(tree)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a PCMTree object representing a pruned version of tree.
</p>


<h3>See Also</h3>

<p>PCMTreeSetPartition
</p>
<p>PCMTree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(25))

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

backb &lt;-  PCMTreeBackbonePartition(tree)

if(requireNamespace("ggtree"))
PCMTreePlot(backb) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

tree2 &lt;- PCMTreeSetPartRegimes(
  tree, c(`26` = "a", `28` = "b"), setPartition = TRUE,
  inplace = FALSE)

if(requireNamespace("ggtree"))
PCMTreePlot(tree2) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

backb &lt;-  PCMTreeBackbonePartition(tree2)

if(requireNamespace("ggtree"))
PCMTreePlot(backb) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

tree3 &lt;- PCMTreeSetPartRegimes(
  tree, c(`26` = "a", `28` = "b", `41` = "c"), setPartition = TRUE,
  inplace = FALSE)

if(requireNamespace("ggtree"))
PCMTreePlot(tree3) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

backb &lt;-  PCMTreeBackbonePartition(tree3)

if(requireNamespace("ggtree"))
PCMTreePlot(backb) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

backb41 &lt;-  PCMTreeBackbonePartition(tree3, partsToKeep = "41")

if(requireNamespace("ggtree"))
PCMTreePlot(backb41) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

backbMoreNodes &lt;- PCMTreeInsertSingletonsAtEpoch(
   backb, epoch = 3.7, minLength = 0.001)
PCMTreeGetPartRegimes(backbMoreNodes)

if(requireNamespace("ggtree"))
PCMTreePlot(backbMoreNodes) + ggtree::geom_nodelab(angle=45) +
  ggtree::geom_tiplab(angle=45)

backbMoreNodes &lt;- PCMTreeInsertSingletonsAtEpoch(
   backbMoreNodes, epoch = 0.2, minLength = 0.001)
PCMTreeGetPartRegimes(backbMoreNodes)

if(requireNamespace("ggtree"))
PCMTreePlot(backbMoreNodes) + ggtree::geom_nodelab(angle=45) +
  ggtree::geom_tiplab(angle=45)

backbMoreNodes &lt;- PCMTreeInsertSingletonsAtEpoch(
   backbMoreNodes, epoch = 1.2, minLength = 0.001)
PCMTreeGetPartRegimes(backbMoreNodes)

if(requireNamespace("ggtree"))
PCMTreePlot(backbMoreNodes) + ggtree::geom_nodelab(angle=45) +
  ggtree::geom_tiplab(angle=45)

</code></pre>

<hr>
<h2 id='PCMTreeDropClade'>Drop a clade from a phylogenetic tree</h2><span id='topic+PCMTreeDropClade'></span>

<h3>Description</h3>

<p>Drop a clade from a phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeDropClade(
  tree,
  cladeRootNode,
  tableAncestors = NULL,
  X = NULL,
  returnList = !is.null(X),
  errorOnMissing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeDropClade_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeDropClade_+3A_claderootnode">cladeRootNode</code></td>
<td>
<p>a character string denoting the label or an integer denoting a node in the tree</p>
</td></tr>
<tr><td><code id="PCMTreeDropClade_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>an integer matrix returned by a previous call to PCMTreeTableAncestors(tree) or NULL.</p>
</td></tr>
<tr><td><code id="PCMTreeDropClade_+3A_x">X</code></td>
<td>
<p>an optional k x N matrix with trait value vectors for each tip in tree.</p>
</td></tr>
<tr><td><code id="PCMTreeDropClade_+3A_returnlist">returnList</code></td>
<td>
<p>logical indicating if a list of the phylo object
associated with the tree after dropping the clade and the corresponding
entries in X should be returned. Defaults to <code>!is.null(X)</code></p>
</td></tr>
<tr><td><code id="PCMTreeDropClade_+3A_erroronmissing">errorOnMissing</code></td>
<td>
<p>logical indicating if an error should be raised if
cladeRootNode is not among the nodes in tree. Default FALSE, meaning that if
cladeRootNode is not a node in tree the tree (and X if
returnList is TRUE) is/are returned unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If returnList is FALSE, a phylo object associated with the remaining
tree after dropping the clade, otherise, a list with two named members :
</p>

<dl>
<dt>tree</dt><dd><p>the phylo object associated with the remaining tree after dropping the clade</p>
</dd>
<dt>X</dt><dd><p>the submatrix of X with columns corresponding to the tips in the remaining tree</p>
</dd>
</dl>



<h3>See Also</h3>

<p>PCMTreeSpliAtNode PCMTreeExtractClade
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(25))
PCMTreeSetPartRegimes(
  tree, c(`26`="a", `28`="b", `45`="c"), setPartition = TRUE)

if(requireNamespace("ggtree"))
PCMTreePlot(tree, palette=c(a = "red", b = "green", c = "blue")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

redGreenTree &lt;- PCMTreeDropClade(tree, 45)
PCMTreeGetPartRegimes(redGreenTree)

if(requireNamespace("ggtree"))
PCMTreePlot(redGreenTree, palette=c(a = "red", b = "green", c = "blue")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

# we need to use the label here, because the node 29 in tree is not the same
# id in redGreenTree:
redGreenTree2 &lt;- PCMTreeDropClade(redGreenTree, "29")

if(requireNamespace("ggtree"))
PCMTreePlot(redGreenTree2, palette=c(a = "red", b = "green", c = "blue")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

</code></pre>

<hr>
<h2 id='PCMTreeDtNodes'>A data.table with time, part and regime information for the nodes in a tree</h2><span id='topic+PCMTreeDtNodes'></span>

<h3>Description</h3>

<p>A data.table with time, part and regime information for the nodes in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeDtNodes(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeDtNodes_+3A_tree">tree</code></td>
<td>
<p>a phylo object with node-labels and parts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with a row for each node in tree and columns as follows:
</p>

<dl>
<dt>startNode </dt><dd><p>the starting node of each edge or NA_integer_ for the root</p>
</dd>
<dt>endNode </dt><dd><p>the end node of each edge or the root id for the root</p>
</dd>
<dt>startNodeLab </dt><dd><p>the character label for the startNode</p>
</dd>
<dt>endNodeLab </dt><dd><p>the character label for endNode</p>
</dd>
<dt>startTime </dt><dd><p>the time (distance from the root node) for the startNode or
NA_real_ for the root node</p>
</dd>
<dt>endTime </dt><dd><p>the time (distance from the root node) for the endNode or
NA_real_ for the root node</p>
</dd>
<dt>part </dt><dd><p>the part to which the edge belongs, i.e. the part of the
endNode</p>
</dd>
<dt>regime </dt><dd><p>the regime to which the edge belongs, i.e. the regime of the
part of the endNode</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>PCMTreeDtNodes(PCMBaseTestObjects$tree.ab)
</code></pre>

<hr>
<h2 id='PCMTreeEdgeTimes'>A matrix with the begin and end time from the root for each edge in tree</h2><span id='topic+PCMTreeEdgeTimes'></span>

<h3>Description</h3>

<p>A matrix with the begin and end time from the root for each edge in tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeEdgeTimes(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeEdgeTimes_+3A_tree">tree</code></td>
<td>
<p>a phylo</p>
</td></tr>
</table>

<hr>
<h2 id='PCMTreeEvalNestedEDxOnTree'>Perfrorm nested extractions or drops of clades from a tree</h2><span id='topic+PCMTreeEvalNestedEDxOnTree'></span>

<h3>Description</h3>

<p>Perfrorm nested extractions or drops of clades from a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeEvalNestedEDxOnTree(expr, tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeEvalNestedEDxOnTree_+3A_expr">expr</code></td>
<td>
<p>a character string representing an R expression of nested calls
of functions
<code>E(x,node)</code> denoting extracting the clade rooted at node from the tree
x, or <code>D(x,node)</code>, denoting dropping the clade rooted at node from the
tree x. These calls can be nested, i.e. x can be either the symbol x
(corresponding to the original tree passed as argument) or a nested call to
d or e.</p>
</td></tr>
<tr><td><code id="PCMTreeEvalNestedEDxOnTree_+3A_tree">tree</code></td>
<td>
<p>a phylo object with named tips and internal nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting phylo object from evaluating expr on tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(25))
PCMTreeSetPartRegimes(
  tree, c(`26`="a", `28`="b", `45`="c", `47`="d"), setPartition = TRUE)

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

bluePart &lt;- PCMTreeEvalNestedEDxOnTree("D(E(tree,45),47)", tree)
PCMTreeGetPartRegimes(bluePart)

if(requireNamespace("ggtree"))
PCMTreePlot(
  bluePart, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

# Swapping the D and E calls has the same result:
bluePart2 &lt;- PCMTreeEvalNestedEDxOnTree("E(D(tree,47),45)", tree)
PCMTreeGetPartRegimes(bluePart2)

if(requireNamespace("ggtree"))
PCMTreePlot(
  bluePart2, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

greenPart &lt;- PCMTreeEvalNestedEDxOnTree("E(tree,28)", tree)

bgParts &lt;- bluePart+greenPart


if(requireNamespace("ggtree")) {
PCMTreePlot(
  greenPart, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
PCMTreePlot(
  bluePart + greenPart, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
PCMTreePlot(
  greenPart + bluePart, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
PCMTreePlot(
  bgParts, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
}

</code></pre>

<hr>
<h2 id='PCMTreeExtractClade'>Extract a clade from phylogenetic tree</h2><span id='topic+PCMTreeExtractClade'></span>

<h3>Description</h3>

<p>Extract a clade from phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeExtractClade(
  tree,
  cladeRootNode,
  tableAncestors = NULL,
  X = NULL,
  returnList = !is.null(X)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeExtractClade_+3A_tree">tree</code></td>
<td>
<p>a PCMTree object.</p>
</td></tr>
<tr><td><code id="PCMTreeExtractClade_+3A_claderootnode">cladeRootNode</code></td>
<td>
<p>a character string denoting the label or an integer denoting a node in the tree.</p>
</td></tr>
<tr><td><code id="PCMTreeExtractClade_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>an integer matrix returned by a previous call to PCMTreeTableAncestors(tree) or NULL.</p>
</td></tr>
<tr><td><code id="PCMTreeExtractClade_+3A_x">X</code></td>
<td>
<p>an optional k x N matrix with trait value vectors for each tip in tree.</p>
</td></tr>
<tr><td><code id="PCMTreeExtractClade_+3A_returnlist">returnList</code></td>
<td>
<p>logical indicating if only the phylo object associated
with the clade should be returned. Defaults to <code>!is.null(X)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If returnList is FALSE, a phylo object associated with the clade,
otherwise, a list with two named members :
</p>

<dl>
<dt>tree</dt><dd><p>the phylo object associated with the clade</p>
</dd>
<dt>X</dt><dd><p>the submatrix of X with columns corresponding to the tips in the clade</p>
</dd>
</dl>



<h3>See Also</h3>

<p>PCMTreeSpliAtNode PCMTreeDropClade
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(25))
PCMTreeSetPartRegimes(
  tree, c(`26`="a", `28`="b", `45`="c"), setPartition = TRUE)

if(requireNamespace("ggtree"))
PCMTreePlot(tree, palette=c(a = "red", b = "green", c = "blue")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

blueTree &lt;- PCMTreeExtractClade(tree, 45)
PCMTreeGetPartRegimes(blueTree)

if(requireNamespace("ggtree"))
PCMTreePlot(blueTree, palette=c(a = "red", b = "green", c = "blue")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

# we need to use the label here, because the node 29 in tree is not the same
# id in redGreenTree:
blueTree2 &lt;- PCMTreeDropClade(blueTree, "48")

if(requireNamespace("ggtree"))
PCMTreePlot(blueTree2, palette=c(a = "red", b = "green", c = "blue")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

</code></pre>

<hr>
<h2 id='PCMTreeGetBranchLength'>The length of the branch leading to a node</h2><span id='topic+PCMTreeGetBranchLength'></span>

<h3>Description</h3>

<p>The length of the branch leading to a node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetBranchLength(tree, daughterId)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetBranchLength_+3A_tree">tree</code></td>
<td>
<p>a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeGetBranchLength_+3A_daughterid">daughterId</code></td>
<td>
<p>an integer denoting the id of a daughter node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double denoting the length of the branch leading to daughterId
</p>

<hr>
<h2 id='PCMTreeGetDaughters'>A vector of the daughter nodes for a given parent node id in a tree</h2><span id='topic+PCMTreeGetDaughters'></span>

<h3>Description</h3>

<p>A vector of the daughter nodes for a given parent node id in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetDaughters(tree, parentId)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetDaughters_+3A_tree">tree</code></td>
<td>
<p>a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeGetDaughters_+3A_parentid">parentId</code></td>
<td>
<p>an integer denoting the id of the parent node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of the direct descendants of parentId
</p>

<hr>
<h2 id='PCMTreeGetLabels'>Node labels of a tree</h2><span id='topic+PCMTreeGetLabels'></span><span id='topic+PCMTreeGetRootLabel'></span><span id='topic+PCMTreeGetNodeLabels'></span><span id='topic+PCMTreeGetTipLabels'></span>

<h3>Description</h3>

<p>Get the character labels of the tips, root and internal nodes in the tree
(see Functions below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetLabels(tree)

PCMTreeGetRootLabel(tree)

PCMTreeGetNodeLabels(tree)

PCMTreeGetTipLabels(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetLabels_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>PCMTreeGetLabels</code>: Get all labels in the order (tips,root,internal).
</p>
</li>
<li> <p><code>PCMTreeGetRootLabel</code>: Get the root label
</p>
</li>
<li> <p><code>PCMTreeGetNodeLabels</code>: Get the internal node labels
</p>
</li>
<li> <p><code>PCMTreeGetTipLabels</code>: Get the tip labels
</p>
</li></ul>

<hr>
<h2 id='PCMTreeGetParent'>The parent node id of a daughter node in a tree</h2><span id='topic+PCMTreeGetParent'></span>

<h3>Description</h3>

<p>The parent node id of a daughter node in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetParent(tree, daughterId)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetParent_+3A_tree">tree</code></td>
<td>
<p>a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeGetParent_+3A_daughterid">daughterId</code></td>
<td>
<p>an integer denoting the id of the daughter node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer denoting the parent of daughterId
</p>

<hr>
<h2 id='PCMTreeGetPartition'>Get the starting branch' nodes for each part on a tree</h2><span id='topic+PCMTreeGetPartition'></span>

<h3>Description</h3>

<p>Get the starting branch' nodes for each part on a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetPartition(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetPartition_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.part member denoting parts. The
function assumes that each part covers a linked set of branches on the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We call a starting branch the first branch from the root to the tips
of a given part. A starting node is the node at which a starting branch
ends.
</p>


<h3>Value</h3>

<p>a named integer vector with elements equal to the starting nodes for
each part in tree and names equal to the labels of these nodes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMTreeSetPartition">PCMTreeSetPartition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
PCMTreeGetPartition(PCMTree(ape::rtree(20)))
</code></pre>

<hr>
<h2 id='PCMTreeGetPartNames'>Unique parts on a tree in the order of occurrence from the root to the tips (preorder)</h2><span id='topic+PCMTreeGetPartNames'></span>

<h3>Description</h3>

<p>Unique parts on a tree in the order of occurrence from the root to the tips (preorder)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetPartNames(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetPartNames_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an additional member edge.part which should
be a character or an integer vector of length equal to the number of branches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector.
</p>

<hr>
<h2 id='PCMTreeGetPartRegimes'>Regime mapping for the parts in a tree</h2><span id='topic+PCMTreeGetPartRegimes'></span>

<h3>Description</h3>

<p>Regime mapping for the parts in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetPartRegimes(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetPartRegimes_+3A_tree">tree</code></td>
<td>
<p>a PCMTree or a phylo object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with names corresponding to the part names in tree
and values corresponding to regime names or ids.
</p>

<hr>
<h2 id='PCMTreeGetPartsForNodes'>Get the parts of the branches leading to a set of nodes or tips</h2><span id='topic+PCMTreeGetPartsForNodes'></span>

<h3>Description</h3>

<p>Get the parts of the branches leading to a set of nodes or tips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetPartsForNodes(tree, nodes = seq_len(PCMTreeNumNodes(tree)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetPartsForNodes_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.part member denoting parts.</p>
</td></tr>
<tr><td><code id="PCMTreeGetPartsForNodes_+3A_nodes">nodes</code></td>
<td>
<p>an integer vector denoting the nodes.
Default is seq_len(PCMTreeNumNodes(tree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector denoting the parts of the branches
leading to the nodes, according to tree$edge.part.
</p>

<hr>
<h2 id='PCMTreeGetRegimesForEdges'>Model regimes (i.e. colors) associated with the branches in a tree</h2><span id='topic+PCMTreeGetRegimesForEdges'></span>

<h3>Description</h3>

<p>Model regimes (i.e. colors) associated with the branches in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetRegimesForEdges(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetRegimesForEdges_+3A_tree">tree</code></td>
<td>
<p>a PCMTree or a phylo object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with entries corresponding to the rows in tree$edge
denoting the regime associated with each branch in the tree. The type
of the vector element is defined by the type of tree$part.regime.
</p>

<hr>
<h2 id='PCMTreeGetRegimesForNodes'>Get the regimes of the branches leading to a set of nodes or tips</h2><span id='topic+PCMTreeGetRegimesForNodes'></span>

<h3>Description</h3>

<p>Get the regimes of the branches leading to a set of nodes or tips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetRegimesForNodes(tree, nodes = seq_len(PCMTreeNumNodes(tree)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetRegimesForNodes_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.part member denoting parts.</p>
</td></tr>
<tr><td><code id="PCMTreeGetRegimesForNodes_+3A_nodes">nodes</code></td>
<td>
<p>an integer vector denoting the nodes.
Default is seq_len(PCMTreeNumNodes(tree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector denoting the parts of the branches
leading to the nodes, according to tree$edge.part.
</p>

<hr>
<h2 id='PCMTreeGetTipsInPart'>Get the tips belonging to a part in a tree</h2><span id='topic+PCMTreeGetTipsInPart'></span>

<h3>Description</h3>

<p>Get the tips belonging to a part in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetTipsInPart(tree, part)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetTipsInPart_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.regime member or a PCMTree object</p>
</td></tr>
<tr><td><code id="PCMTreeGetTipsInPart_+3A_part">part</code></td>
<td>
<p>a character or integer denoting a part name in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with the ids of the tips belonging to part
</p>


<h3>See Also</h3>

<p><a href="#topic+PCMTreeGetTipsInRegime">PCMTreeGetTipsInRegime</a>, <a href="#topic+PCMTreeGetPartNames">PCMTreeGetPartNames</a>, <a href="#topic+PCMRegimes">PCMRegimes</a>, <a href="#topic+PCMTreeGetPartRegimes">PCMTreeGetPartRegimes</a>, <a href="#topic+PCMTreeSetPartRegimes">PCMTreeSetPartRegimes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- ape::rtree(10)
regimes &lt;- sample(letters[1:3], nrow(tree$edge), replace = TRUE)
PCMTreeSetRegimesForEdges(tree, regimes)

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

part &lt;- PCMTreeGetPartNames(tree)[1]
PCMTreeGetTipsInPart(tree, part)
print(part)

</code></pre>

<hr>
<h2 id='PCMTreeGetTipsInRegime'>Get the tips belonging to a regime in a tree</h2><span id='topic+PCMTreeGetTipsInRegime'></span>

<h3>Description</h3>

<p>Get the tips belonging to a regime in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeGetTipsInRegime(tree, regime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeGetTipsInRegime_+3A_tree">tree</code></td>
<td>
<p>a phylo object with an edge.regime member or a PCMTree object</p>
</td></tr>
<tr><td><code id="PCMTreeGetTipsInRegime_+3A_regime">regime</code></td>
<td>
<p>a character or integer denoting a regime in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector with the ids of the tips belonging to regime.
</p>


<h3>See Also</h3>

<p><a href="#topic+PCMTreeGetTipsInPart">PCMTreeGetTipsInPart</a>, <a href="#topic+PCMTreeGetPartNames">PCMTreeGetPartNames</a>, <a href="#topic+PCMRegimes">PCMRegimes</a>, <a href="#topic+PCMTreeGetPartRegimes">PCMTreeGetPartRegimes</a>, <a href="#topic+PCMTreeSetPartRegimes">PCMTreeSetPartRegimes</a>, <a href="#topic+PCMTreeGetPartition">PCMTreeGetPartition</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- ape::rtree(10)
regimes &lt;- sample(letters[1:3], nrow(tree$edge), replace = TRUE)
PCMTreeSetRegimesForEdges(tree, regimes)

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

regime &lt;- PCMRegimes(tree)[1]
PCMTreeGetTipsInRegime(tree, regime)
print(regime)

</code></pre>

<hr>
<h2 id='PCMTreeInsertSingletons'>Insert tips or singleton nodes on chosen edges</h2><span id='topic+PCMTreeInsertSingletons'></span><span id='topic+PCMTreeInsertSingletonsAtEpoch'></span><span id='topic+PCMTreeInsertTipsOrSingletons'></span>

<h3>Description</h3>

<p>Insert tips or singleton nodes on chosen edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeInsertSingletons(tree, nodes, positions)

PCMTreeInsertSingletonsAtEpoch(tree, epoch, minLength = 0.1)

PCMTreeInsertTipsOrSingletons(
  tree,
  nodes,
  positions = rep(0, length(nodes)),
  singleton = FALSE,
  tipBranchLengths = 0.01,
  nodeLabels = NULL,
  tipLabels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeInsertSingletons_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_nodes">nodes</code></td>
<td>
<p>an integer vector denoting the terminating nodes of the edges
on which a singleton node is to be inserted. This vector should not have
duplicated nodes - if there is a need to insert two or more singleton nodes
at distinct positions of the same edge, this should be done by calling the
function several times with the longest position first and so on .</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_positions">positions</code></td>
<td>
<p>a positive numeric vector of the same length as nodes
denoting the root-ward distances from nodes at which the singleton nodes
should be inserted. For PCMTreeInsertTipsOrSingletons this can contains 0's and
is set by default to rep(0, length(nodes)).</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_epoch">epoch</code></td>
<td>
<p>a numeric indicating a distance from the root at which a
singleton node should be inserted in all lineages that are alive at that
time.</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_minlength">minLength</code></td>
<td>
<p>a numeric indicating the minimum allowed branch-length
after dividing a branch by insertion of a singleton nodes. No singleton node
is inserted if this would result in a branch shorter than 'minLength'. Note
that this condition is checked only in 'PCMTreeInsertSingletonsAtEpoch'.</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_singleton">singleton</code></td>
<td>
<p>(PCMTreeInsertTipsOrSingletons only) a logical indicating if a
singleton node should be inserted and no tip node should be inserted.</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_tipbranchlengths">tipBranchLengths</code></td>
<td>
<p>(PCMTreeInsertTipsOrSingletons only) positive numeric vector of the
length of <code>nodes</code>, denoting the lengths of the new edges leading to tips.</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_nodelabels">nodeLabels</code></td>
<td>
<p>(PCMTreeInsertSingletons and PCMTreeInsertTipsOrSingletons) a
character vector of the same length as <code>nodes</code>, indicating the names of
the newly inserted nodes. These names are ignored where <code>positions</code> is 0. This
argument is optional and default node labels will be assigned if this is not specified or set
to NULL. If specified, then it should not contain node-labels already present in the tree.</p>
</td></tr>
<tr><td><code id="PCMTreeInsertSingletons_+3A_tiplabels">tipLabels</code></td>
<td>
<p>(PCMTreeInsertTipsOrSingletons only) a character vector of the same length as
<code>nodes</code> of the new tip-labels. This
argument is optional and default tip labels will be assigned if this is not specified or set
to NULL. If specified, then it should not contain tip-labels already present in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified copy of tree.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>PCMTreeInsertSingletonsAtEpoch</code>: 
</p>
</li>
<li> <p><code>PCMTreeInsertTipsOrSingletons</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+PCMTreeEdgeTimes">PCMTreeEdgeTimes</a></code> <code><a href="#topic+PCMTreeLocateEpochOnBranches">PCMTreeLocateEpochOnBranches</a></code> <code><a href="#topic+PCMTreeLocateMidpointsOnBranches">PCMTreeLocateMidpointsOnBranches</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(25))
PCMTreeSetPartRegimes(
  tree, c(`26`="a", `28`="b", `45`="c", `47`="d"), setPartition = TRUE)

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree,
  palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

cbind(tree$edge, PCMTreeEdgeTimes(tree))

id47 &lt;- PCMTreeMatchLabels(tree, "47")
length47 &lt;- PCMTreeGetBranchLength(tree, id47)

# insert a singleton at 0.55 (root-ward) from node 47
tree &lt;- PCMTreeInsertSingletons(tree, nodes = "47", positions = (length47/2))

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree,
  palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

# this fails, because the branch leading to node "47" is shorter now (0.55).
ggplot2::should_stop(
  tree &lt;- PCMTreeInsertSingletons(
    tree, nodes = "47", positions= 2* length47 / 3))

# the tree is the same

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

# we can insert at a position within the edge:
tree &lt;- PCMTreeInsertSingletons(tree, nodes = "47", positions = length47/3)

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)


# Insert singletons at all branches crossing a given epoch. This will skip
# inserting singleton nodes where the resulting branches would be shorter
# than 0.1.
tree &lt;- PCMTreeInsertSingletonsAtEpoch(tree, 2.3)

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree, palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

# Insert singletons at all branches crossing a given epoch
tree &lt;- PCMTreeInsertSingletonsAtEpoch(tree, 2.3, minLength = 0.001)

if(requireNamespace("ggtree"))
PCMTreePlot(
  tree,
  palette=c(a = "red", b = "green", c = "blue", d = "magenta")) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)

</code></pre>

<hr>
<h2 id='PCMTreeJumps'>Jumps in modeled traits associated with branches in a tree</h2><span id='topic+PCMTreeJumps'></span>

<h3>Description</h3>

<p>Jumps in modeled traits associated with branches in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeJumps(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeJumps_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of 0's and 1's with entries corresponding to the
denoting if a jump took place at the beginning of a branch.
</p>

<hr>
<h2 id='PCMTreeListAllPartitions'>A list of all possible (including recursive) partitions of a tree</h2><span id='topic+PCMTreeListAllPartitions'></span>

<h3>Description</h3>

<p>A list of all possible (including recursive) partitions of a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeListAllPartitions(
  tree,
  minCladeSize,
  skipNodes = character(),
  tableAncestors = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeListAllPartitions_+3A_tree">tree</code></td>
<td>
<p>a phylo object with set labels for the internal nodes</p>
</td></tr>
<tr><td><code id="PCMTreeListAllPartitions_+3A_mincladesize">minCladeSize</code></td>
<td>
<p>integer indicating the minimum number of tips allowed in
one part.</p>
</td></tr>
<tr><td><code id="PCMTreeListAllPartitions_+3A_skipnodes">skipNodes</code></td>
<td>
<p>an integer or character vector indicating the ids or labels
of nodes that should not be used as partition nodes. By default, this is an
empty character vector.</p>
</td></tr>
<tr><td><code id="PCMTreeListAllPartitions_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>NULL (default) or an integer matrix returned by a
previous call to <code>PCMTreeTableAncestors(tree)</code>.</p>
</td></tr>
<tr><td><code id="PCMTreeListAllPartitions_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if informative messages should be printed to
the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of integer vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(10))

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

# list of all partitions into parts of at least 4 tips
PCMTreeListAllPartitions(tree, 4)

# list of all partitions into parts of at least 3 tips
PCMTreeListAllPartitions(tree, 3)

# list all partitions into parts of at least 3 tips, excluding the partitions
# where node 16 is one of the partition nodes:
PCMTreeListAllPartitions(tree, minCladeSize = 3, skipNodes = "16")

</code></pre>

<hr>
<h2 id='PCMTreeListCladePartitions'>A list of all possible clade partitions of a tree with a number of splitting nodes</h2><span id='topic+PCMTreeListCladePartitions'></span>

<h3>Description</h3>

<p>Each subset of <code>nNodes</code> distinct internal or tip nodes
defines a partition of the branches of the tree into <code>nNodes+1</code> blocks
called parts. This function generates partitions where each part has
<code>nNodes</code> splitting nodes and contains at least <code>minCladeSize</code> tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeListCladePartitions(
  tree,
  nNodes,
  minCladeSize = 0,
  skipNodes = character(0),
  tableAncestors = NULL,
  countOnly = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeListCladePartitions_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeListCladePartitions_+3A_nnodes">nNodes</code></td>
<td>
<p>an integer giving the number of partitioning nodes. There would be
<code>nNodes+1</code> blocks in each partition (see details).</p>
</td></tr>
<tr><td><code id="PCMTreeListCladePartitions_+3A_mincladesize">minCladeSize</code></td>
<td>
<p>integer indicating the minimum number of tips allowed in a clade.</p>
</td></tr>
<tr><td><code id="PCMTreeListCladePartitions_+3A_skipnodes">skipNodes</code></td>
<td>
<p>an integer or character vector indicating the ids or labels
of nodes that should not be used as partition nodes. By default, this is an
empty character vector.</p>
</td></tr>
<tr><td><code id="PCMTreeListCladePartitions_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>NULL (default) or an integer matrix returned by a previous call
to <code>PCMTreeTableAncestors(tree)</code>.</p>
</td></tr>
<tr><td><code id="PCMTreeListCladePartitions_+3A_countonly">countOnly</code></td>
<td>
<p>logical indicating if the only the number of partitions should
be returned.</p>
</td></tr>
<tr><td><code id="PCMTreeListCladePartitions_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if informative messages should be printed to
the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of integer <code>nNodes</code>-vectors. By default a full traversal
of all partitions is done. It is possible to truncate the search to a limited
number of partitions by setting the option PCMBase.MaxLengthListCladePartitions
to a finite positive integer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMOptions">PCMOptions</a></code>
</p>

<hr>
<h2 id='PCMTreeListDescendants'>A list of the descendants for each node in a tree</h2><span id='topic+PCMTreeListDescendants'></span>

<h3>Description</h3>

<p>A list of the descendants for each node in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeListDescendants(tree, tableAncestors = PCMTreeTableAncestors(tree))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeListDescendants_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeListDescendants_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>an integer matrix resulting from a call to
PCMTreeTableAncestors(tree).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has time and memory complexity O(M^2), where M is the
number of nodes in the tree. It can take several minutes and gigabytes of
memory on trees of more than 10000 tips.
</p>


<h3>Value</h3>

<p>a list with unnamed elements in the order of nodes in the tree. Each
element is an integer vector containing the descendant nodes (in increasing
order) of the node identified by its index-number in the list.
</p>

<hr>
<h2 id='PCMTreeListRootPaths'>A list of the path to the root from each node in a tree</h2><span id='topic+PCMTreeListRootPaths'></span>

<h3>Description</h3>

<p>A list of the path to the root from each node in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeListRootPaths(tree, tableAncestors = PCMTreeTableAncestors(tree))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeListRootPaths_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeListRootPaths_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>an integer matrix resulting from a call to
PCMTreeTableAncestors(tree).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has time and memory complexity O(M^2), where M is the
number of nodes in the tree. It can take several minutes and gigabytes of
memory on trees of more than 10000 tips.
</p>


<h3>Value</h3>

<p>a list with unnamed elements in the order of nodes in the tree. Each
element is an integer vector containing the ancestors nodes on the path from
the node (i) to the root of the tree in that order (the first element in the
vector is the parent node of i and so on).
</p>

<hr>
<h2 id='PCMTreeLocateEpochOnBranches'>Find the crossing points of an epoch-time with each lineage of a tree</h2><span id='topic+PCMTreeLocateEpochOnBranches'></span>

<h3>Description</h3>

<p>Find the crossing points of an epoch-time with each lineage of a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeLocateEpochOnBranches(tree, epoch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeLocateEpochOnBranches_+3A_tree">tree</code></td>
<td>
<p>a phylo</p>
</td></tr>
<tr><td><code id="PCMTreeLocateEpochOnBranches_+3A_epoch">epoch</code></td>
<td>
<p>a positive numeric indicating tip-ward distance from the root</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with an integer vector element &quot;nodes&quot; denoting the ending nodes for each
branch crossing epoch and numeric vector element &quot;positions&quot; denoting the root-ward offset
from each node in nodes.
</p>

<hr>
<h2 id='PCMTreeLocateMidpointsOnBranches'>Find the middle point of each branch longer than a threshold</h2><span id='topic+PCMTreeLocateMidpointsOnBranches'></span>

<h3>Description</h3>

<p>Find the middle point of each branch longer than a threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeLocateMidpointsOnBranches(tree, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeLocateMidpointsOnBranches_+3A_tree">tree</code></td>
<td>
<p>a phylo</p>
</td></tr>
<tr><td><code id="PCMTreeLocateMidpointsOnBranches_+3A_threshold">threshold</code></td>
<td>
<p>a positive numeric; only branches longer than threshold
will be returned; Default 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with an integer vector element &quot;nodes&quot; denoting the
ending nodes for each branch crossing epoch and numeric vector element
&quot;positions&quot; denoting the root-ward offset from each node in nodes.
</p>

<hr>
<h2 id='PCMTreeMatchLabels'>Get the node numbers associated with tip- or node-labels in a tree</h2><span id='topic+PCMTreeMatchLabels'></span>

<h3>Description</h3>

<p>Get the node numbers associated with tip- or node-labels in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeMatchLabels(tree, labels, stopIfNotFound = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeMatchLabels_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeMatchLabels_+3A_labels">labels</code></td>
<td>
<p>a character vector with valid tip or node labels from tree</p>
</td></tr>
<tr><td><code id="PCMTreeMatchLabels_+3A_stopifnotfound">stopIfNotFound</code></td>
<td>
<p>logical indicating if an error should be raised in case
a label has not been found in the tree labels. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector giving the tip- or node- integer indices
corresponding to labels. If stopIfNotFound is set to FALSE, this vector may
contain NAs for the labels that were not found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
PCMTreeMatchLabels(PCMTree(ape::rtree(20)), c("t1", "t15", "21", "39"))
PCMTreeMatchLabels(PCMTree(ape::rtree(20)), c("t1", "45"), stopIfNotFound = FALSE)
</code></pre>

<hr>
<h2 id='PCMTreeMatrixNodesInSamePart'>Which couples from a given set of nodes in a tree belong to the same part?</h2><span id='topic+PCMTreeMatrixNodesInSamePart'></span><span id='topic+PCMTreeMatrixNodesInSameRegime'></span>

<h3>Description</h3>

<p>Which couples from a given set of nodes in a tree belong to the same part?
</p>
<p>Which couples from a given set of nodes in a tree belong to the same regime?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeMatrixNodesInSamePart(
  tree,
  nodes = seq_len(PCMTreeNumNodes(tree)),
  upperTriangle = TRUE,
  returnVector = TRUE
)

PCMTreeMatrixNodesInSameRegime(
  tree,
  nodes = seq_len(PCMTreeNumNodes(tree)),
  upperTriangle = TRUE,
  returnVector = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeMatrixNodesInSamePart_+3A_tree">tree</code></td>
<td>
<p>a PCMTree object or a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeMatrixNodesInSamePart_+3A_nodes">nodes</code></td>
<td>
<p>an integer vector of length L &gt;= 2 denoting a set of nodes in
the tree.</p>
</td></tr>
<tr><td><code id="PCMTreeMatrixNodesInSamePart_+3A_uppertriangle">upperTriangle</code></td>
<td>
<p>logical indicating if all duplicated entries and
diagonal entries should be set to NA (by default TRUE).</p>
</td></tr>
<tr><td><code id="PCMTreeMatrixNodesInSamePart_+3A_returnvector">returnVector</code></td>
<td>
<p>logical indicating if a vector instead of a matrix
should be returned (corresponding to calling as.vector on the resulting
matrix and removing
NAs). Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a L x L logical matrix with TRUE on the diagonal and for each couple
of tips that belong to the same part or regime. If returnVector is TRUE
(default) only a vector of the non-NA entries will be returned.
</p>
<p>a L x L logical matrix with TRUE on the diagonal and for each couple
of tips that belong to the same part or regime. If returnVector is TRUE (default)
only a vector of the non-NA entries will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(8))
PCMTreeMatrixNodesInSamePart(tree, returnVector = FALSE)

PCMTreeSetPartition(tree, c(10, 12))
PCMTreeMatrixNodesInSamePart(tree, returnVector = FALSE)

PCMTreeMatrixNodesInSamePart(tree)
PCMTreeMatrixNodesInSamePart(tree, seq_len(PCMTreeNumTips(tree)))
PCMTreeMatrixNodesInSamePart(
  tree, seq_len(PCMTreeNumTips(tree)), returnVector = FALSE)

set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(8))
PCMTreeMatrixNodesInSamePart(tree, returnVector = FALSE)

PCMTreeSetPartition(tree, c(10, 12))
PCMTreeMatrixNodesInSamePart(tree, returnVector = FALSE)

PCMTreeMatrixNodesInSamePart(tree)
PCMTreeMatrixNodesInSamePart(tree, seq_len(PCMTreeNumTips(tree)))
PCMTreeMatrixNodesInSamePart(
  tree, seq_len(PCMTreeNumTips(tree)), returnVector = FALSE)

</code></pre>

<hr>
<h2 id='PCMTreeNearestNodesToEpoch'>Find the nearest node to a given time from the root (epoch) on each lineage crossing this epoch</h2><span id='topic+PCMTreeNearestNodesToEpoch'></span>

<h3>Description</h3>

<p>Find the nearest node to a given time from the root (epoch) on each lineage crossing this epoch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeNearestNodesToEpoch(tree, epoch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeNearestNodesToEpoch_+3A_tree">tree</code></td>
<td>
<p>a phylo</p>
</td></tr>
<tr><td><code id="PCMTreeNearestNodesToEpoch_+3A_epoch">epoch</code></td>
<td>
<p>a non-negative numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>

<hr>
<h2 id='PCMTreeNodeTimes'>Calculate the time from the root to each node of the tree</h2><span id='topic+PCMTreeNodeTimes'></span>

<h3>Description</h3>

<p>Calculate the time from the root to each node of the tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeNodeTimes(tree, tipsOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeNodeTimes_+3A_tree">tree</code></td>
<td>
<p>an object of class phylo</p>
</td></tr>
<tr><td><code id="PCMTreeNodeTimes_+3A_tipsonly">tipsOnly</code></td>
<td>
<p>Logical indicating whether the returned results should be truncated only to the tips of the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size the number of nodes in the tree (tips, root,
internal) containing the time from the root to the corresponding node in
the tree.
</p>

<hr>
<h2 id='PCMTreeNumNodes'>Number of all nodes in a tree</h2><span id='topic+PCMTreeNumNodes'></span>

<h3>Description</h3>

<p>Number of all nodes in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeNumNodes(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeNumNodes_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for nrow(tree$edge) + 1
</p>


<h3>Value</h3>

<p>the number of nodes in tree including root, internal and tips.
</p>

<hr>
<h2 id='PCMTreeNumParts'>Number of unique parts on a tree</h2><span id='topic+PCMTreeNumParts'></span>

<h3>Description</h3>

<p>Number of unique parts on a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeNumParts(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeNumParts_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of different parts encountered on the tree branches
</p>

<hr>
<h2 id='PCMTreeNumTips'>Wrapper for length(tree$tip.label)</h2><span id='topic+PCMTreeNumTips'></span>

<h3>Description</h3>

<p>Wrapper for length(tree$tip.label)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeNumTips(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeNumTips_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of tips in tree
</p>

<hr>
<h2 id='PCMTreePlot'>Plot a tree with parts and regimes assigned to these parts</h2><span id='topic+PCMTreePlot'></span>

<h3>Description</h3>

<p>Plot a tree with parts and regimes assigned to these parts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreePlot(
  tree,
  palette = PCMColorPalette(PCMNumRegimes(tree), PCMRegimes(tree)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreePlot_+3A_tree">tree</code></td>
<td>
<p>a PCMTree or a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreePlot_+3A_palette">palette</code></td>
<td>
<p>a named vector of colors corresponding to the regimes in tree</p>
</td></tr>
<tr><td><code id="PCMTreePlot_+3A_...">...</code></td>
<td>
<p>Arguments passed to ggtree, e.g. layout = 'fan', open.angle = 8,
size=.25.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires that the ggtree package is installed.
At the time of releasing this version the ggtree package is not available on
CRAN. Check the
<a href="https://guangchuangyu.github.io/software/ggtree/">ggtree homepage</a> for
instruction on how to install this package:
.
</p>

<hr>
<h2 id='PCMTreePostorder'>Post-order tree traversal</h2><span id='topic+PCMTreePostorder'></span>

<h3>Description</h3>

<p>Post-order tree traversal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreePostorder(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreePostorder_+3A_tree">tree</code></td>
<td>
<p>a phylo object with possible singleton nodes (i.e. internal nodes
with one daughter node)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices of edges in tree$edge in post-order.
</p>

<hr>
<h2 id='PCMTreePreorder'>Pre-order tree traversal</h2><span id='topic+PCMTreePreorder'></span>

<h3>Description</h3>

<p>Pre-order tree traversal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreePreorder(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreePreorder_+3A_tree">tree</code></td>
<td>
<p>a phylo object with possible singleton nodes (i.e. internal
nodes with one daughter node)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices of edges in tree$edge in pre-order.
</p>

<hr>
<h2 id='PCMTreeSetLabels'>Set tip and internal node labels in a tree</h2><span id='topic+PCMTreeSetLabels'></span>

<h3>Description</h3>

<p>Set tip and internal node labels in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeSetLabels(
  tree,
  labels = as.character(1:PCMTreeNumNodes(tree)),
  inplace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeSetLabels_+3A_tree">tree</code></td>
<td>
<p>a phylo object or a PCMTree object. If this is a PCMTree object,
the internal edge.part and part.regime members will be updated accordingly.</p>
</td></tr>
<tr><td><code id="PCMTreeSetLabels_+3A_labels">labels</code></td>
<td>
<p>a character vector in the order 1:PCMTreeNumNodes(tree) as
denoted in the tree$edge matrix.</p>
</td></tr>
<tr><td><code id="PCMTreeSetLabels_+3A_inplace">inplace</code></td>
<td>
<p>a logical indicating if the change should be done in place on
the object in the calling environment (in this case tree must not be a
temporary object, e.g. returned by another function call). Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if inplace is FALSE, a copy of tree with set or modified
tree$tip.label and tree$node.label. If the original tree has a member
edge.part, the returned tree has tree$edge.part and tree$part.regime updated.
If inplace is TRUE (the default), nothing is returned and the above changes
are made directly on the input tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMTree">PCMTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- ape::rtree(5)
tree$tip.label
# the following three are NULLs
tree$node.label
tree$edge.part
tree$part.regime


tree &lt;- PCMTree(tree)
PCMTreeSetPartition(tree, c(6, 8))
tree$tip.label
tree$node.label
tree$edge.part
tree$part.regime

PCMTreeSetLabels(
  tree, labels = paste0(c(rep("t", 5), rep("n", 4)), PCMTreeGetLabels(tree)))
PCMTreeGetLabels(tree)
tree$tip.label
tree$node.label
tree$edge.part
tree$part.regime

</code></pre>

<hr>
<h2 id='PCMTreeSetPartition'>Set a partition of a tree by specifying the partition nodes</h2><span id='topic+PCMTreeSetPartition'></span>

<h3>Description</h3>

<p>Set a partition of a tree by specifying the partition nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeSetPartition(tree, nodes = c(PCMTreeNumTips(tree) + 1L), inplace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeSetPartition_+3A_tree">tree</code></td>
<td>
<p>a PCMTree object.</p>
</td></tr>
<tr><td><code id="PCMTreeSetPartition_+3A_nodes">nodes</code></td>
<td>
<p>a character vector containing tip or node labels or an integer
vector denoting tip or internal nodes in tree - the parts change at the
start of the branches leading to these nodes. Default:
c(PCMTreeNumTips(tree) + 1L).</p>
</td></tr>
<tr><td><code id="PCMTreeSetPartition_+3A_inplace">inplace</code></td>
<td>
<p>a logical indicating if the change should be done to the tree
in the calling environment (TRUE) or a copy of the tree with set edge.part
member should be returned (FALSE). Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If inplace is TRUE nothing, otherwise a copy of the tree with set
edge.part member.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMTreeGetPartition">PCMTreeGetPartition</a></code>
</p>
<p><code><a href="#topic+PCMTree">PCMTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(8))
PCMTreeSetLabels(tree, paste0("x", PCMTreeGetLabels(tree)))
PCMTreeGetPartition(tree)
PCMTreeGetPartNames(tree)
PCMTreeGetPartRegimes(tree)

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

tree &lt;- PCMTreeSetPartition(tree, c(12, 14), inplace = FALSE)
PCMTreeGetPartition(tree)
PCMTreeGetPartNames(tree)
PCMTreeGetPartRegimes(tree)

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

# reset the partition to a default one, where there is only one part:
PCMTreeSetPartition(tree)

PCMTreeGetPartition(tree)
PCMTreeGetPartNames(tree)
PCMTreeGetPartRegimes(tree)
if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab() + ggtree::geom_tiplab()


# reset the labels to the default labels which are character representations
# of the node ids
PCMTreeSetLabels(tree)
PCMTreeGetPartition(tree)
PCMTreeGetPartNames(tree)
PCMTreeGetPartRegimes(tree)

</code></pre>

<hr>
<h2 id='PCMTreeSetPartRegimes'>Set regimes for the parts in a tree</h2><span id='topic+PCMTreeSetPartRegimes'></span>

<h3>Description</h3>

<p>Set regimes for the parts in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeSetPartRegimes(tree, part.regime, setPartition = FALSE, inplace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeSetPartRegimes_+3A_tree">tree</code></td>
<td>
<p>a PCMTree object.</p>
</td></tr>
<tr><td><code id="PCMTreeSetPartRegimes_+3A_part.regime">part.regime</code></td>
<td>
<p>a named vector containing regimes to be assigned to
some of or to each of the parts in the tree.</p>
</td></tr>
<tr><td><code id="PCMTreeSetPartRegimes_+3A_setpartition">setPartition</code></td>
<td>
<p>a logical indicating if the partition of the tree should
be set as well. If this argument is set to TRUE, the names of part.regime
are passed as the nodes argument in a call to <code>PCMTreeSetPartition</code>.
Default: FALSE.</p>
</td></tr>
<tr><td><code id="PCMTreeSetPartRegimes_+3A_inplace">inplace</code></td>
<td>
<p>a logical indicating if the change should be done to the tree
in the calling environment (TRUE) or a copy of the tree with set edge.part
member should be returned (FALSE). Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If inplace is TRUE nothing, otherwise a copy of the tree with set
edge.part and part.regime members.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCMTree">PCMTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- PCMTree(ape::rtree(25))
PCMTreeGetPartition(tree)
PCMTreeGetPartRegimes(tree)
PCMTreeGetPartNames(tree)

PCMTreeSetPartRegimes(tree, c(`26` = 2))
PCMTreeGetPartition(tree)
PCMTreeGetPartRegimes(tree)
PCMTreeGetPartNames(tree)

PCMTreeSetPartRegimes(tree, c(`26` = "global-regime"))
PCMTreeGetPartition(tree)
PCMTreeGetPartRegimes(tree)
PCMTreeGetPartNames(tree)

# This should fail because no partition with nodes 26, 28 and 41 has been
# done.
ggplot2::should_stop(
  PCMTreeSetPartRegimes(tree, c(`26` = "a", `28` = "b", `41` = "c")))
# This should succeed and change the partition as well as regime assignment
PCMTreeSetPartRegimes(
  tree, c(`26` = "a", `28` = "b", `41` = "c"), setPartition = TRUE)
PCMTreeGetPartition(tree)
PCMTreeGetPartRegimes(tree)
PCMTreeGetPartNames(tree)



set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
# number of tips
N &lt;- 40

# tree with one regime
tree.a &lt;- ape::rtree(N)

tree.a &lt;- PCMTree(tree.a)

PCMTreeSetPartRegimes(
  tree.a,
  part.regime = structure("a", names = as.character(N+1L)),
  setPartition = TRUE,
  inplace = TRUE)



if(requireNamespace("ggtree"))
PCMTreePlot(tree.a) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

tree.ab &lt;- tree.a
PCMTreeSetPartRegimes(
  tree.ab,
  part.regime = structure(c("a", "b"), names = as.character(c(N+1L, N+31L))),
  setPartition = TRUE,
  inplace = TRUE)

if(requireNamespace("ggtree"))
PCMTreePlot(tree.ab) + ggtree::geom_nodelab() + ggtree::geom_tiplab()

</code></pre>

<hr>
<h2 id='PCMTreeSetRegimesForEdges'>Set the regime for each individual edge in a tree explicitly</h2><span id='topic+PCMTreeSetRegimesForEdges'></span>

<h3>Description</h3>

<p>Set the regime for each individual edge in a tree explicitly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeSetRegimesForEdges(tree, regimes, inplace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeSetRegimesForEdges_+3A_tree">tree</code></td>
<td>
<p>a PCMTree or a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeSetRegimesForEdges_+3A_regimes">regimes</code></td>
<td>
<p>a vector of the length equal to 'nrow(tree$edge)'.</p>
</td></tr>
<tr><td><code id="PCMTreeSetRegimesForEdges_+3A_inplace">inplace</code></td>
<td>
<p>a logical indicating if the change should be done within the
tree in the calling environment or a copy of the tree with modified regime
assignment should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if inplace is TRUE, nothing, otherwise a modified copy of tree.
</p>


<h3>Note</h3>

<p>Calling this function overwrites the current partitioning of the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- ape::rtree(10)
regimes &lt;- sample(letters[1:3], nrow(tree$edge), replace = TRUE)
PCMTreeSetRegimesForEdges(tree, regimes)

if(requireNamespace("ggtree"))
PCMTreePlot(tree)

</code></pre>

<hr>
<h2 id='PCMTreeSplitAtNode'>Slit a tree at a given internal node into a clade rooted at this node and the remaining tree after dropping this clade</h2><span id='topic+PCMTreeSplitAtNode'></span>

<h3>Description</h3>

<p>Slit a tree at a given internal node into a clade rooted at this node and the remaining tree after dropping this clade
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeSplitAtNode(
  tree,
  node,
  tableAncestors = PCMTreeTableAncestors(tree),
  X = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeSplitAtNode_+3A_tree">tree</code></td>
<td>
<p>a PCMTree object.</p>
</td></tr>
<tr><td><code id="PCMTreeSplitAtNode_+3A_node">node</code></td>
<td>
<p>an integer or character indicating a root, internal or tip node</p>
</td></tr>
<tr><td><code id="PCMTreeSplitAtNode_+3A_tableancestors">tableAncestors</code></td>
<td>
<p>an integer matrix returned by a previous call to
PCMTreeTableAncestors(tree) or NULL.</p>
</td></tr>
<tr><td><code id="PCMTreeSplitAtNode_+3A_x">X</code></td>
<td>
<p>an optional k x N matrix with trait value vectors for each tip in
tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the current implementation, the edge.jump and edge.part members
of the tree will be discarded and not present in the clade.
</p>


<h3>Value</h3>

<p>A list containing two named phylo objects:
</p>

<dl>
<dt>clade </dt><dd><p>The subtree (clade) starting at <code>node</code>.</p>
</dd>
<dt>Xclade </dt><dd><p>The portion of X attributable to the tips in clade; NULL if X is NULL.</p>
</dd>
<dt>rest </dt><dd><p>The tree resulting after dropping all tips in the clade.</p>
</dd>
<dt>Xrest </dt><dd><p>The portion of X attributable to the tips in rest; NULL if X is NULL.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister", normal.kind = "Inversion")
tree &lt;- PCMTree(ape::rtree(25))

if(requireNamespace("ggtree"))
PCMTreePlot(tree) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

spl &lt;- PCMTreeSplitAtNode(tree, 28)

if(requireNamespace("ggtree"))
PCMTreePlot(PCMTree(spl$clade)) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

if(requireNamespace("ggtree"))
PCMTreePlot(PCMTree(spl$rest)) + ggtree::geom_nodelab(angle = 45) +
  ggtree::geom_tiplab(angle = 45)

</code></pre>

<hr>
<h2 id='PCMTreeTableAncestors'>A matrix (table) of ancestors/descendants for each node in a tree</h2><span id='topic+PCMTreeTableAncestors'></span>

<h3>Description</h3>

<p>A matrix (table) of ancestors/descendants for each node in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeTableAncestors(tree, preorder = PCMTreePreorder(tree))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeTableAncestors_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="PCMTreeTableAncestors_+3A_preorder">preorder</code></td>
<td>
<p>an integer vector returned by a previous call to
<code>PCMTreePreorder(tree)</code>. Default <code>PCMTreePreorder(tree)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has time and memory complexity O(M^2), where M is the
number of nodes in the tree. It can take several minutes and gigabytes of
memory on trees of more than 10000 tips.
</p>


<h3>Value</h3>

<p>an integer square matrix of size M x M where M is the number of nodes
in the tree. Element j on row i is 0 if j is not an ancestor of i or a positive
integer equal to the position of j on the path from the root to i if j is an
ancestor of i.
</p>

<hr>
<h2 id='PCMTreeToString'>A character representation of a phylo object.</h2><span id='topic+PCMTreeToString'></span>

<h3>Description</h3>

<p>A character representation of a phylo object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeToString(tree, includeLengths = FALSE, includePartition = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeToString_+3A_tree">tree</code></td>
<td>
<p>a phylo object.</p>
</td></tr>
<tr><td><code id="PCMTreeToString_+3A_includelengths">includeLengths</code></td>
<td>
<p>logical. Default: FALSE.</p>
</td></tr>
<tr><td><code id="PCMTreeToString_+3A_includepartition">includePartition</code></td>
<td>
<p>logical. Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string.
</p>

<hr>
<h2 id='PCMTreeVCV'>Phylogenetic Variance-covariance matrix</h2><span id='topic+PCMTreeVCV'></span>

<h3>Description</h3>

<p>This is a simplified wrapper for ape's <code><a href="ape.html#topic+vcv">vcv</a></code> function. Setting
the runtime option PCMBase.UsePCMVarForVCV to TRUE will switch to a
computation of the matrix using the function <code><a href="#topic+PCMVar">PCMVar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMTreeVCV(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMTreeVCV_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a N x N matrix. Assuming a BM model of evolution, this is a matrix
in which element (i,j) is equal to the shared root-distance of the nodes i
and j.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+vcv">vcv</a></code> <code><a href="#topic+PCMVar">PCMVar</a></code> <code><a href="#topic+PCMOptions">PCMOptions</a></code>
</p>

<hr>
<h2 id='PCMUnfixParameter'>Unfix a parameter in a PCM model</h2><span id='topic+PCMUnfixParameter'></span>

<h3>Description</h3>

<p>Unfix a parameter in a PCM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMUnfixParameter(model, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMUnfixParameter_+3A_model">model</code></td>
<td>
<p>a PCM object</p>
</td></tr>
<tr><td><code id="PCMUnfixParameter_+3A_name">name</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of the model with removed class '_Fixed' from the class of the
parameter <code>name</code>
</p>

<hr>
<h2 id='PCMVar'>Expected variance-covariance matrix for each couple of tips (i,j)</h2><span id='topic+PCMVar'></span>

<h3>Description</h3>

<p>Expected variance-covariance matrix for each couple of tips (i,j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMVar(
  tree,
  model,
  W0 = matrix(0, PCMNumTraits(model), PCMNumTraits(model)),
  SE = matrix(0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(NULL, tree, model, verbose = verbose),
  internal = FALSE,
  diagOnly = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMVar_+3A_tree">tree</code></td>
<td>
<p>a phylo object with N tips.</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_model">model</code></td>
<td>
<p>an S3 object specifying both, the model type (class, e.g. &quot;OU&quot;) as
well as the concrete model parameter values at which the likelihood is to be
calculated (see also Details).</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_w0">W0</code></td>
<td>
<p>a numeric matrix denoting the initial k x k variance covariance matrix at the
root (default is the k x k zero matrix).</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_se">SE</code></td>
<td>
<p>a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip <code>i=1, ..., N</code>. When <code>SE</code> is a matrix, the k x k
measurement error variance matrix for a tip <code>i</code> is calculated as
<code>VE[, , i] &lt;- diag(SE[, i] * SE[, i], nrow = k)</code>. When <code>SE</code> is a
cube, the way how the measurement variance matrix for a tip <code>i</code> is
calculated depends on the runtime option <code>PCMBase.Transpose.Sigma_x</code>
as follows:
</p>

<dl>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE</code> (default): </dt><dd><p>VE[, , i] &lt;- SE[, , i] %*% t(SE[, , i])</p>
</dd>
<dt>if <code>getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE</code>: </dt><dd><p>VE[, , i] &lt;- t(SE[, , i]) %*% SE[, , i]</p>
</dd>
</dl>

<p>Note that the above behavior is consistent with the treatment of the model
parameters <code>Sigma_x</code>, <code>Sigmae_x</code> and <code>Sigmaj_x</code>, which are
also specified as upper triangular factors.
Default: <code>matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))</code>.</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_metai">metaI</code></td>
<td>
<p>a list returned from a call to <code>PCMInfo(X, tree, model, SE)</code>,
containing meta-data such as N, M and k. Alternatively, this can be a
character string naming a function or a function object that returns such
a list, e.g. the function<code>PCMInfo</code> or the function <code>PCMInfoCpp</code>
from the <code>PCMBaseCpp</code> package.</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_internal">internal</code></td>
<td>
<p>a logical indicating if the per-node variance-covariances matrices for
the internal nodes should be returned (see Value). Default FALSE.</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_diagonly">diagOnly</code></td>
<td>
<p>a logical indicating if only the variance
blocks for the nodes should be calculated. By default this is set to FALSE,
meaning that the co-variances are calculated for all couples of nodes.</p>
</td></tr>
<tr><td><code id="PCMVar_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some debug-messages should printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If internal is FALSE, a (k x N) x (k x N) matrix W, such that k x k block
<code>W[((i-1)*k)+(1:k), ((j-1)*k)+(1:k)]</code> equals the expected
covariance matrix between tips i and j. Otherwise, a list with an element 'W' as described above and
a k x M matrix element 'Wii' containing the per-node variance covariance matrix for each node:
The k x k block <code>Wii[, (i-1)*k + (1:k)]</code> represents the variance covariance matrix for node i.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a Brownian motion model with one regime
modelBM &lt;- PCM(model = "BM", k = 2)
# print the model
modelBM
# assign the model parameters at random: this will use uniform distribution
# with boundaries specified by PCMParamLowerLimit and PCMParamUpperLimit
# We do this in two steps:
# 1. First we generate a random vector. Note the length of the vector equals PCMParamCount(modelBM)
randomParams &lt;- PCMParamRandomVecParams(modelBM, PCMNumTraits(modelBM), PCMNumRegimes(modelBM))
randomParams
# 2. Then we load this random vector into the model.
PCMParamLoadOrStore(modelBM, randomParams, 0, PCMNumTraits(modelBM), PCMNumRegimes(modelBM), TRUE)

# create a random tree of 10 tips
tree &lt;- ape::rtree(10)
covMat &lt;- PCMVar(tree, modelBM)
</code></pre>

<hr>
<h2 id='PCMVarAtTime'>Calculate the variance covariance k x k matrix at time t, under a PCM model</h2><span id='topic+PCMVarAtTime'></span>

<h3>Description</h3>

<p>Calculate the variance covariance k x k matrix at time t, under a PCM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCMVarAtTime(
  t,
  model,
  W0 = matrix(0, PCMNumTraits(model), PCMNumTraits(model)),
  SE = matrix(0, PCMNumTraits(model), PCMNumTraits(model)),
  regime = PCMRegimes(model)[1L],
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCMVarAtTime_+3A_t">t</code></td>
<td>
<p>positive numeric denoting time</p>
</td></tr>
<tr><td><code id="PCMVarAtTime_+3A_model">model</code></td>
<td>
<p>a PCM model object</p>
</td></tr>
<tr><td><code id="PCMVarAtTime_+3A_w0">W0</code></td>
<td>
<p>a numeric matrix denoting the initial k x k variance covariance matrix at the
root (default is the k x k zero matrix).</p>
</td></tr>
<tr><td><code id="PCMVarAtTime_+3A_se">SE</code></td>
<td>
<p>a k x k matrix specifying the upper triangular factor of
the measurement error variance-covariance matrix. The product
SE 
Default: SE = matrix(0.0, PCMNumTraits(model), PCMNumTraits(model)).</p>
</td></tr>
<tr><td><code id="PCMVarAtTime_+3A_regime">regime</code></td>
<td>
<p>an integer or a character denoting the regime in model for
which to do the calculation; Defaults to PCMRegimes(model)[1L], meaning the
first regime in the model.</p>
</td></tr>
<tr><td><code id="PCMVarAtTime_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if (debug) messages should be written on the console (Defaults to FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric k x k matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a Brownian motion model with one regime
modelBM &lt;- PCM(model = "BM", k = 2)
# print the model
modelBM
# assign the model parameters at random: this will use uniform distribution
# with boundaries specified by PCMParamLowerLimit and PCMParamUpperLimit
# We do this in two steps:
# 1. First we generate a random vector. Note the length of the vector equals PCMParamCount(modelBM)
randomParams &lt;- PCMParamRandomVecParams(modelBM, PCMNumTraits(modelBM), PCMNumRegimes(modelBM))
randomParams
# 2. Then we load this random vector into the model.
PCMParamLoadOrStore(modelBM, randomParams, 0, PCMNumTraits(modelBM), PCMNumRegimes(modelBM), TRUE)

# PCMVarAtTime(1, modelBM)

# note that the variance at time 0 is not the 0 matrix because the model has a non-zero
# environmental deviation
PCMVarAtTime(0, modelBM)
</code></pre>

<hr>
<h2 id='RequireSuggestedPackages'>Check if all packages listed in Suggests are available</h2><span id='topic+RequireSuggestedPackages'></span>

<h3>Description</h3>

<p>Check if all packages listed in Suggests are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RequireSuggestedPackages()
</code></pre>


<h3>Value</h3>

<p>logical TRUE if suggested packages are installed and can be loaded; FALSE
otherwise
</p>

<hr>
<h2 id='TruePositiveRate'>True positive rate of a set of binary predictions against their trues</h2><span id='topic+TruePositiveRate'></span><span id='topic+FalsePositiveRate'></span>

<h3>Description</h3>

<p>Let the set of predictions be described by a logical vector
'pred', and let the corresponding trues by described in a logical vector
'true' of the same length. Then, the true positive rate is given by the
expression:
<code>sum(pred &amp; true)/sum(true)</code>. The false positive rate is given by the
expression:
<code>sum(pred &amp; !true)/sum(!true)</code>. If these expressions do not give a
finite number, <code>NA_real_</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruePositiveRate(pred, true)

FalsePositiveRate(pred, true)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TruePositiveRate_+3A_pred">pred</code>, <code id="TruePositiveRate_+3A_true">true</code></td>
<td>
<p>vectors of the same positive length that can be converted to
logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double between 0 and 1 or <code>NA_real_</code> if the result is not a
finite number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TruePositiveRate(c(1,0,1,1), c(1,1,0,1))
TruePositiveRate(c(0,0,0,0), c(1,1,0,1))
TruePositiveRate(c(1,1,1,1), c(1,1,0,1))
FalsePositiveRate(c(1,0,1,1), c(1,1,0,1))
FalsePositiveRate(c(0,0,0,0), c(1,1,0,1))
FalsePositiveRate(c(1,1,1,1), c(1,1,0,1))
TruePositiveRate(c(1,0,1,1), c(0,0,0,0))
FalsePositiveRate(c(1,0,1,1), c(1,1,1,1))
</code></pre>

<hr>
<h2 id='UpperTriFactor'>Upper triangular factor of a symmetric positive definite matrix</h2><span id='topic+UpperTriFactor'></span>

<h3>Description</h3>

<p>This function is an analog to the Cholesky decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpperTriFactor(Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UpperTriFactor_+3A_sigma">Sigma</code></td>
<td>
<p>A symmetric positive definite k x k matrix that can be
passed as argument to <code><a href="base.html#topic+chol">chol</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an upper triangular matrix Sigma_x, such that
Sigma = Sigma_x %*% t(Sigma_x)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code>;
</p>
<p>the option <code>PCMBase.Transpose.Sigma_x</code> in <code><a href="#topic+PCMOptions">PCMOptions</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># S is a symmetric positive definite matrix
M&lt;-matrix(rexp(9),3,3); S &lt;- M %*% t(M)

# This should return a zero matrix:
UpperTriFactor(S) %*% t(UpperTriFactor(S)) - S

# This should return a zero matrix too:
t(chol(S)) %*% chol(S) - S

# Unless S is diagonal, in the general case, this will return a
# non-zero matrix:
chol(S) %*% t(chol(S)) - S
</code></pre>

<hr>
<h2 id='White'>White Gaussian PCM ignoring phylogenetic history</h2><span id='topic+White'></span>

<h3>Description</h3>

<p>White model ignoring phylogenetic history, treating trait values
as independent samples from a k-variate Gaussian.
</p>


<h3>Details</h3>

<p>Calculating likelihoods for this model does not work if the global
option PCMBase.Singular.Skip is set to FALSE.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
