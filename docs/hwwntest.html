<!DOCTYPE html><html><head><title>Help for package hwwntest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hwwntest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hwwntest-package'>
<p>Tests of White Noise using Wavelets</p></a></li>
<li><a href='#bartlettB.test'><p>Bartlett's B test for white noise</p></a></li>
<li><a href='#compute.rejection'><p>Function to compute empirical size or power for various</p>
tests of white noise.</a></li>
<li><a href='#cumperiod'><p>Compute cumulative normalized periodogram.</p></a></li>
<li><a href='#d00.test'><p>Test for white noise based on the coarsest scale Haar</p>
wavelet coefficient of the spectrum.</a></li>
<li><a href='#genwwn.powerplot'><p>Plot (approximation) to the theoretical power of the</p>
<code>genwwn.test</code> test for
ARMA processes (including, of course, white noise itself) for
a range of sample sizes.</a></li>
<li><a href='#genwwn.test'><p>White noise test using general wavelets.</p></a></li>
<li><a href='#genwwn.thpower'><p>Compute (approximation) to the theoretical power of the</p>
<code>genwwn.test</code> test for
ARMA processes (including, of course, white noise itself).</a></li>
<li><a href='#hwwn.dw'><p>Compute discrete wavelets</p></a></li>
<li><a href='#hwwn.test'><p>Perform a test for white noise on a time series.</p></a></li>
<li><a href='#hywavwn.test'><p>Hybrid wavelet test of white noise.</p></a></li>
<li><a href='#hywn.test'><p>Hybrid of Box-Ljung test, Bartlett B test, Haar wavelet and</p>
General wavelet tests.</a></li>
<li><a href='#Macdonald'><p>Compute the Macdonald density function for a specified parameter</p>
value <code>m</code> at a vector of <code>x</code> values.</a></li>
<li><a href='#sqcoefvec'><p>Compute coefficients required for approximaing the wavelet</p>
transform using the square of wavelets.</a></li>
<li><a href='#sqndwd'><p>Compute the non-decimated squared wavelet transform.</p></a></li>
<li><a href='#sqndwdecomp'><p>Brute-force calculation of the non-decimated squared wavelet transform.</p></a></li>
<li><a href='#sqwd'><p>Compute expansion with respect to squared wavelets.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tests of White Noise using Wavelets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods to test whether time series is consistent
	with white noise. Two new tests based on Haar wavelets and general
	wavelets described by Nason and Savchev (2014)
	&lt;<a href="https://doi.org/10.1002%2Fsta4.69">doi:10.1002/sta4.69</a>&gt; are provided and, for comparison purposes
	this package also implements the
	B test of Bartlett (1967) &lt;<a href="https://doi.org/10.2307%2F2333850">doi:10.2307/2333850</a>&gt;. Functionality
	is provided to compute an approximation to the theoretical
	power of the general wavelet test in the case of general
	ARMA alternatives.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, polynom, wavethresh</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-12 15:55:43 UTC; gnason</td>
</tr>
<tr>
<td>Author:</td>
<td>Delyan Savchev [aut],
  Guy Nason [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-13 07:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='hwwntest-package'>
Tests of White Noise using Wavelets
</h2><span id='topic+hwwntest-package'></span><span id='topic+hwwntest'></span>

<h3>Description</h3>

<p>Provides methods to test whether time series is consistent
	with white noise. Two new tests based on Haar wavelets and general
	wavelets described by Nason and Savchev (2014)
	&lt;doi:10.1002/sta4.69&gt; are provided and, for comparison purposes
	this package also implements the
	B test of Bartlett (1967) &lt;doi:10.2307/2333850&gt;. Functionality
	is provided to compute an approximation to the theoretical
	power of the general wavelet test in the case of general
	ARMA alternatives.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hwwntest</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Tests of White Noise using Wavelets</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-06</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Delyan", "Savchev",
        role=c("aut"),email="madbss@bristol.ac.uk"),
				person("Guy", "Nason", role=c("aut","cre"),
				email="g.nason@imperial.ac.uk"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Provides methods to test whether time series is consistent
	with white noise. Two new tests based on Haar wavelets and general
	wavelets described by Nason and Savchev (2014)
	&lt;doi:10.1002/sta4.69&gt; are provided and, for comparison purposes
	this package also implements the
	B test of Bartlett (1967) &lt;doi:10.2307/2333850&gt;. Functionality
	is provided to compute an approximation to the theoretical
	power of the general wavelet test in the case of general
	ARMA alternatives.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.3)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> parallel, polynom, wavethresh</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Delyan Savchev [aut],
  Guy Nason [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Macdonald               Compute the Macdonald density function for a
                        specified parameter value 'm' at a vector of
                        'x' values.
bartlettB.test          Bartlett's B test for white noise
compute.rejection       Function to compute empirical size or power for
                        various tests of white noise.
cumperiod               Compute cumulative normalized periodogram.
d00.test                Test for white noise based on the coarsest
                        scale Haar wavelet coefficient of the spectrum.
genwwn.powerplot        Plot (approximation) to the theoretical power
                        of the 'genwwn.test' test for ARMA processes
                        (including, of course, white noise itself) for
                        a range of sample sizes.
genwwn.test             White noise test using general wavelets.
genwwn.thpower          Compute (approximation) to the theoretical
                        power of the 'genwwn.test' test for ARMA
                        processes (including, of course, white noise
                        itself).
hwwn.dw                 Compute discrete wavelets
hwwn.test               Perform a test for white noise on a time
                        series.
hwwntest-package        Tests of White Noise using Wavelets
hywavwn.test            Hybrid wavelet test of white noise.
hywn.test               Hybrid of Box-Ljung test, Bartlett B test, Haar
                        wavelet and General wavelet tests.
sqcoefvec               Compute coefficients required for approximaing
                        the wavelet transform using the square of
                        wavelets.
sqndwd                  Compute the non-decimated squared wavelet
                        transform.
sqndwdecomp             Brute-force calculation of the non-decimated
                        squared wavelet transform.
sqwd                    Compute expansion with respect to squared
                        wavelets.
</pre>
<p>Contains a variety of hypothesis tests for white noise data.
The package contains an implementation of Bartlett's B test,
<code><a href="#topic+bartlettB.test">bartlettB.test</a></code>,
(Kolmogorov-Smirnov test on the cumulative periodogram),
a selection of wavelet-based tests
<code><a href="#topic+hwwn.test">hwwn.test</a></code> a test using Haar wavelets,
<code><a href="#topic+d00.test">d00.test</a></code> a single Haar wavelet coefficient test,
<code><a href="#topic+genwwn.test">genwwn.test</a></code> a test using smoother Daubechies
wavelets, a hybrid test <code><a href="#topic+hywavwn.test">hywavwn.test</a></code>
that uses Haar wavelets at fine scales and general wavelets
at coarse scales and a omnibus test
<code><a href="#topic+hywn.test">hywn.test</a></code> that combines the results of  four tests
(<code>hwwn.test</code>, <code>genwwn.test</code>, <code>bartlettB.test</code>
and the <code>Box.test</code>)
The wavelet tests work by examining
the wavelet transform of the regular periodogram
and assess whether it has non-zero coefficients.
If series is H_0: white noise,
then the underlying spectrum is constant (flat) and all true wavelet
coefficients will be zero. Then all periodogram wavelet coefficients
will have true zero mean which can be tested using knowledge of,
or approximation to, the
coefficient distribution.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hwwn.test">hwwn.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> # Invent test data set which IS white noise
     #
     x &lt;- rnorm(128)
     #
     # Do the test
     #
     x.wntest &lt;- hwwn.test(x)
     #
     # Print the results
     #
     #x.wntest
     #
     #       Wavelet Test of White Noise
     #
     #data:
     #p-value = 0.9606
     #
     # So p-value indicates that there is no evidence for rejection of
     # H_0: white noise.
     #
     # Let's do an example using data that is not white noise. E.g. AR(1)
     #
     x.ar &lt;- arima.sim(n=128, model=list(ar=0.8))
     #
     # Do the test
     #
     x.ar.wntest &lt;- hwwn.test(x.ar)
     #
     # Print the results
     #
     print(x.ar.wntest)
     #
     #       Wavelet Test of White Noise
     #
     #data:
     #p-value &lt; 2.2e-16
     #
     # p-value is very small. Extremely strong evidence
     # to reject H_0: white noise
     #
     #
     # Let's use one of the other tests: e.g. the general wavelet one
     #
     x.ar.genwwntest &lt;- genwwn.test(x.ar)
     #
     # Print the results
     #
     print(x.ar.genwwntest)
     #
     #
     #  Wavelet Test of White Noise
     #
     # data:
     # p-value = 1.181e-10
     #
     # Again, p-value is very small
</code></pre>

<hr>
<h2 id='bartlettB.test'>Bartlett's B test for white noise 
</h2><span id='topic+bartlettB.test'></span>

<h3>Description</h3>

<p>Bartlett's test uses the Kolmogorov-Smirnov test applied
to the cumulative normalized periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartlettB.test(x, plot.it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bartlettB.test_+3A_x">x</code></td>
<td>
<p>The time series you wish to test, of any length.
</p>
</td></tr>
<tr><td><code id="bartlettB.test_+3A_plot.it">plot.it</code></td>
<td>
<p>If TRUE then the normalized cumulative periodogram
is plotted along with a straight line that indicates the theoretical
line of this object under the null hypothesis. A further plot
of the density of the true statistic under the null hypothesis is
produced. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test: (i) computes the periodogram, (ii) derives the
normalized cumulative periodogram using the
<code><a href="#topic+cumperiod">cumperiod</a></code> function. Under the null hypothesis
of white noise the periodogram is a set of iid exponential
random variables, asymptotically. So, the cumulative periodogram
should look like a straight line at a 45 degree angle.
The test statistic is the maximum deviation of the normalized
cumulative periodogram and this straight line. The p-value of
the test is computed within the function by the <code>b.power</code>
function. This is an example of a Kolmogorov-Smirnov statistical
test.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code>. A list containing the following
components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The value of the Bartlett test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A text string saying what the method was</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Code was based on Professor Newton's explanation
</p>


<h3>Author(s)</h3>

<p>G. P. Nason
</p>


<h3>References</h3>

<p>Bartlett, M.S. (1967) Some Remarks on the Analysis of Time-Series.
<em>J. R. Statist. Soc. B</em>, <b>54</b>, 25-38.
</p>
<p><a href="https://web.stat.tamu.edu/~jnewton/stat626/topics/topics/topic13.pdf">https://web.stat.tamu.edu/~jnewton/stat626/topics/topics/topic13.pdf</a> Link to Professor H. Joseph Newton's web page on Bartlett's test
</p>
<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.rejection">compute.rejection</a></code>, <code><a href="#topic+cumperiod">cumperiod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do white noise test on smallish data set
#
x &lt;- rnorm(30)
bartlettB.test(x)
#
# For my realization the answer was:
#
#
#	Bartlett B Test for white noise
#
#data:  
#= 0.3747, p-value = 0.999
#
# So, we accept H_0
</code></pre>

<hr>
<h2 id='compute.rejection'>Function to compute empirical size or power for various
tests of white noise. 
</h2><span id='topic+compute.rejection'></span>

<h3>Description</h3>

<p>Can generate white noise sequences, or ARMA time series
and subject multiple realizations of these to various tests for
white noise. The function then counts how many have
been rejected to give some idea of empirical size (if no <code>ar</code>
or <code>ma</code> term is specified) or power (if such terms are specified). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.rejection(ar = NULL, ma = NULL, npow = 100, nom.size = 0.05,
	ndata = 1024, lapplyfn = lapply, Box.lag = 1, rand.gen = rnorm,
	hwwn = TRUE, box = TRUE, bartlett = TRUE, 
	d00test = TRUE, genwwn = TRUE, hywn = TRUE, hywavwn = TRUE,
	filter.number = 10, family = "DaubExPhase",
	away.from = "standard", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.rejection_+3A_ar">ar</code></td>
<td>
<p>Any autoregressive terms to go directly to the
<code>arima.sim</code> function. Leave as it is if you wish to
simulate white noise.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_ma">ma</code></td>
<td>
<p>As <code>ar</code> but for moving average terms.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_npow">npow</code></td>
<td>
<p>The number of realizations to carry out. The best
assessments are carried out with high values of <code>npow</code>,
e.g. 1000 or even 10000. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_nom.size">nom.size</code></td>
<td>
<p>The nominal statistical size of the test. Note: this
does not change the nomimal size for ALL tests. You need to check
each help pages for each function to check what can be changed.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_ndata">ndata</code></td>
<td>
<p>The length of the white noise or ARMA realizations.
Power for both these tests depends on sample size.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>If you have the library <code>parallel</code> and a suitable
multicore machine then this function can run the realizations
in parallel. If so, then you can change this argument to
<code>lapplyfn=mclapply</code> to take advantage of this.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_box.lag">Box.lag</code></td>
<td>
<p>The Box test tests for white noise by examining
autocorrelation coefficients. This argument specifies the max number
of autocorrelation coefficients, ie. coefficients from lag 1 up
to <code>Box.lag</code>.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_rand.gen">rand.gen</code></td>
<td>
<p>Alternative innovation generator. By default Gaussian
innovations are used, but you can specify alternatives to get
heavy-tailed innovations, for example. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_hwwn">hwwn</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+hwwn.test">hwwn.test</a></code> will be evaluated,
if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_box">box</code></td>
<td>
<p>If TRUE then the <code><a href="stats.html#topic+Box.test">Box.test</a></code> will be evaluated,
if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_bartlett">bartlett</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+bartlettB.test">bartlettB.test</a></code>
will be evaluated,
if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_d00test">d00test</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+d00.test">d00.test</a></code>
will be evaluated, if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_genwwn">genwwn</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+genwwn.test">genwwn.test</a></code>
will be evaluated, if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_hywn">hywn</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+hywn.test">hywn.test</a></code>
will be evaluated, if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_hywavwn">hywavwn</code></td>
<td>
<p>If TRUE then the <code><a href="#topic+hywavwn.test">hywavwn.test</a></code>
will be evaluated, if FALSE then it won't be. 
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments of wavelets
used in the general wavelet tests (genwwn, hywn and hywavwn).
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_family">family</code></td>
<td>
<p>Wavelet family, as for <code>filter.number</code> argument.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_away.from">away.from</code></td>
<td>
<p>The number of finer scales not to use for the
general wavelet tests. These tests work by relying on the
asymptotic normality of wavelet coefficients, but this only
becomes useful away from the finer scales. This argument
can be an integer in which case it defines the number of fine
scales to ignore. Alternatively, you can supply the argument
<code>"standard"</code> which chooses an automatically selected number
of scales to stay away from which works well up to time series
in length of 1000. Better performance can be obtained for
series longer than 1000 by adapting the <code>away.from</code> argument.
</p>
</td></tr>
<tr><td><code id="compute.rejection_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+hwwn.test">hwwn.test</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function repeatedly runs the hypothesis tests on 
realizations from a stochastic process which can be white
noise (if <code>ar</code> and <code>ma</code> are <code>NULL</code>) or an ARMA
process specified by <code>ar</code> and <code>ma</code>. It then counts how
many times the null was rejected and returns this as proportion
of the total number of realizations. In this way, this function
can compute the empirical size and power of the tests.
</p>


<h3>Value</h3>

<p>A list with eight components. Each component is a number, between
zero and one, which corresponds to the empirical size or power
of each test. Note, if any component is <code>NULL</code> this means
that it was not evaluated and was &lsquo;turned off&rsquo; in the command
line by setting its name equal to <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bartlettB.test">bartlettB.test</a></code>,
<code><a href="#topic+d00.test">d00.test</a></code>,
<code><a href="#topic+genwwn.test">genwwn.test</a></code>,
<code><a href="#topic+hwwn.test">hwwn.test</a></code>, 
<code><a href="#topic+hywn.test">hywn.test</a></code>,
<code><a href="#topic+hywavwn.test">hywavwn.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Compute empirical size of both tests using 1000 realizations
# with data of length 32
#
answer &lt;- compute.rejection(npow=100, ndata=32)
#
# Print the answer
#
print(answer)
#$hwwntest.rejprop
#[1] 0.03
#
#$box.rejprop
#[1] 0.02
#
#$bartlett.rejprop
#[1] 0.01
#
#$d00.pow
#[1] 0.03
#
#$genwwn.pow
#[1] 0.02
#
#$hywn.pow
#[1] 0.01
#
#$hywavwn.pow
#[1] 0.03
#
#
# So, all empirical sizes should be close to their nominal value of 0.05
#
# Now let's try and ascertain the empirical power on an AR(1)
#
answer &lt;- compute.rejection(ar=0.8, npow=100, ndata=32)
#
# Print the answer
#
print(answer)
#$hwwntest.rejprop
#[1] 0.79
#
#$box.rejprop
#[1] 0.98
#
#$bartlett.rejprop
#[1] 0.97
#
#$d00.pow
#[1] 0.97
#
#$genwwn.pow
#[1] 0.94
#
#$hywn.pow
#[1] 0.95
#
#$hywavwn.pow
#[1] 0.85
#
# Most powers are pretty good. 
</code></pre>

<hr>
<h2 id='cumperiod'>Compute cumulative normalized periodogram.
</h2><span id='topic+cumperiod'></span>

<h3>Description</h3>

<p>Computes cumulative normalized periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumperiod(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumperiod_+3A_x">x</code></td>
<td>
<p>The time series you wish to compute the cumulative
normalized periodogram.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does as the title suggests
</p>


<h3>Value</h3>

<p>A list containing the following two components:
</p>
<table>
<tr><td><code>wp</code></td>
<td>
<p>The Fourier frequencies where the cumulative normalized periodogram
is evaluated at</p>
</td></tr>
<tr><td><code>cumperiod</code></td>
<td>
<p>The cumulative normalized periodogram.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Code was based on Professor Newton's explanation
</p>


<h3>Author(s)</h3>

<p>G. P. Nason
</p>


<h3>References</h3>

<p>Bartlett, M.S. (1967) Some Remarks on the Analysis of Time-Series.
<em>J. R. Statist. Soc. B</em>, <b>54</b>, 25-38.
</p>
<p><a href="https://web.stat.tamu.edu/~jnewton/stat626/topics/topics/topic13.pdf">Link to Professor H. Joseph Newton's web page on Bartlett's test</a>
</p>
<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bartlettB.test">bartlettB.test</a></code>, <code><a href="#topic+compute.rejection">compute.rejection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Use example time series
#
x &lt;- rnorm(100)

x.cp &lt;- cumperiod(x)
#
# Can plot it, if you like
#
plot(x.cp$wp, x.cp$cumperiod, type="l", xlab="Frequency",
	ylab="Cumulative Normalized Periodogram")
#
# You can try replacing the x by, say, an AR(1) using arima.sim and
# you'll get a very different shaped line, depending on the AR(1)
# parameter.
</code></pre>

<hr>
<h2 id='d00.test'>Test for white noise based on the coarsest scale Haar
wavelet coefficient of the spectrum.
</h2><span id='topic+d00.test'></span>

<h3>Description</h3>

<p>Computes the coarsest scale Haar wavelet coefficient
of the periodogram but directly using a formula based on
a particular linear combination of autocorrelation coefficients. 
Then performs a hypothesis test by comparing the test statistic
to a standard normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d00.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d00.test_+3A_x">x</code></td>
<td>
<p>The time series you want to test, of arbitrary length.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htest</code> containing the following components.
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A test string indicating the method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.rejection">compute.rejection</a></code>,<code><a href="#topic+hwwn.test">hwwn.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Test data set
#
x &lt;- rnorm(30)
#
#
answer &lt;- d00.test(x)
#
# My answer was:
#
#	d00 test on acfs
#
#data:  
#= -1.696, p-value = 0.08989
</code></pre>

<hr>
<h2 id='genwwn.powerplot'>Plot (approximation) to the theoretical power of the
<code><a href="#topic+genwwn.test">genwwn.test</a></code> test for
ARMA processes (including, of course, white noise itself) for
a range of sample sizes.
</h2><span id='topic+genwwn.powerplot'></span>

<h3>Description</h3>

<p>Computes and plots (approximation) to the theoretical power of the
<code><a href="#topic+genwwn.test">genwwn.test</a></code> test using the
<code><a href="#topic+genwwn.thpower">genwwn.thpower</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genwwn.powerplot(N =c(32, 64, 128, 256, 512, 1024), ar = NULL,
	ma = NULL, plot.it = TRUE, sigsq = 1, alpha = 0.05,
	away.from = "standard", filter.number = 10,
	family = "DaubExPhase", verbose = FALSE, ylim=c(0,1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genwwn.powerplot_+3A_n">N</code></td>
<td>
<p>Vector of lengths of the series you want to plot
theoretical power for.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_ar">ar</code></td>
<td>
<p>Autoregressive parameters. A vector with p entries for AR(p)
with the first entry being the value for lag-one term (alpha_1),
the second
entry being the value for the lag-two term (alpha_2) etc.
If this argument is NULL then there are no AR terms.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_ma">ma</code></td>
<td>
<p>Similar to the <code>ar</code> argument except for MA terms. 
A vector of length q for MA(q) parameters, with first entry
being beta_1, the second being beta_2, etc. If this argument
is NULL then there are no MA terms.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> then a plot of theoretical power against
sample size is produced. The computed theoretical powers for the
fixed sample sizes specified by <code>N</code> are plotted as crosses.
The crosses are then joined by a dashed line to indicate a likely
trajectory of the theoretical power for sample sizes not computed.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_sigsq">sigsq</code></td>
<td>
<p>The theoretical innovation variance (also the variance
of white noise if <code>ar=ma=NULL</code>.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_alpha">alpha</code></td>
<td>
<p>The nominal size of the test for this theoretical power
calculation.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_away.from">away.from</code></td>
<td>
<p>Describes how many fine scales to exclude, the
same as in <code><a href="#topic+genwwn.test">genwwn.test</a></code>. This can be an integer
up to the number of scales. However, mostly you can leave this
at &quot;standard&quot; where the scales calculation is automatically determined.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments in the Daubechies
series of wavelets.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_family">family</code></td>
<td>
<p>The wavelet family.
</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then informative messages are printed during
the progress of the function.</p>
</td></tr>
<tr><td><code id="genwwn.powerplot_+3A_ylim">ylim</code></td>
<td>
<p>The theoretical power is a probability and lies in the range
of zero to one and this argument specifies those limits for the
vertical axis. These can be changed to whatever you like. E.g.
if all the powers were similar (e.g. if the null series was white
noise and <code>alpha</code>=0.05 then the theoretical powers would all
be approximately 0.05.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function calculates the value of the power function at
the specified sample sizes using the
<code><a href="#topic+genwwn.thpower">genwwn.thpower</a></code> function. Then these values
are plotted and returned.
</p>


<h3>Value</h3>

<p>A list containing the following components.
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>The vector of sample sizes.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>The computed theoretical powers for each sample size</p>
</td></tr>
<tr><td><code>ar</code></td>
<td>
<p>The autoregressive parameters, NULL if there are none.</p>
</td></tr>
<tr><td><code>ma</code></td>
<td>
<p>The moving average parameters, NULL if there are none.</p>
</td></tr>
<tr><td><code>sigsq</code></td>
<td>
<p>The innovation variance used</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The significance level used</p>
</td></tr>
<tr><td><code>away.from</code></td>
<td>
<p>The value of the <code>away.from</code> argument supplied</p>
</td></tr>
<tr><td><code>filter.number</code></td>
<td>
<p>The wavelet filter number used</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The wavelet family used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+genwwn.test">genwwn.test</a></code>, <code><a href="#topic+genwwn.thpower">genwwn.thpower</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Plot theoretical power for white noise
#
genwwn.powerplot()
#
# Plot theoretical power for AR(1) process
#
genwwn.powerplot(ar=0.8)
</code></pre>

<hr>
<h2 id='genwwn.test'>White noise test using general wavelets.
</h2><span id='topic+genwwn.test'></span>

<h3>Description</h3>

<p>Performs test for white noise using a general wavelet
decomposition of a normalized periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genwwn.test(x, away.from = "standard", lowlev = 0, plot.it = FALSE,
	stopeveryscale = FALSE, filter.number = 10,
	family = "DaubExPhase", mc.method = p.adjust.methods,
	mac.spread = 10, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genwwn.test_+3A_x">x</code></td>
<td>
<p>The time series you wish to test (of dyadic length).
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_away.from">away.from</code></td>
<td>
<p>Number of fine scales to stay away from, see details below.
If &quot;standard&quot; then this is automatically computed for sample sizes
up to length of 1024. If you have a longer series then the test
will still work but might not be quite as powerful (but probably
not too bad either).
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_lowlev">lowlev</code></td>
<td>
<p>The coarsest coefficient to evaluate. This should
always be left at 0. 
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_plot.it">plot.it</code></td>
<td>
<p>If TRUE then a series of plots similar to the ones produced
in the <code><a href="#topic+hwwn.test">hwwn.test</a></code> function is produced. See that help
page for further details on what the plots show.
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_stopeveryscale">stopeveryscale</code></td>
<td>
<p>If TRUE then if <code>plot.it=TRUE</code> then a
&lsquo;scan&rsquo; is issued after every plot. Just hit RETURN to continue.
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments of the wavelet
used to compute coefficients that are then evaluated to see whether
they are zero. In principle, best compression for a sparse evaluation
of the normalized spectrum should mean we use the smoothest wavelets
with the highest number of vanishing moments which is ten. The
other components of the function are optimized for ten vanishing
moments. The function will still work for other numbers of vanishing
moments but maybe with slightly reduced power.
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_family">family</code></td>
<td>
<p>Wavelet family to go with <code>filter.number</code>.
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_mc.method">mc.method</code></td>
<td>
<p>The type of multiple hypothesis correction, see
<code>p.adjust</code> for details.
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_mac.spread">mac.spread</code></td>
<td>
<p>Horizontal range for plotting of wavelet coefficients,
only used if <code>plot.it=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="genwwn.test_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> some information messages are printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the normalized periodogram, and then
subjects it to a wavelet transform with respect to any wavelet
(in wavethresh). Under the null hypothesis of white noise
the coefficients should all close to zero and this function
works out, for each coefficient, how close statistically it is
to zero by assuming a Gaussian null distribution with mean zero
and variance one. Then the multiple p-values from each of these
tests are adjusted for multiple hypothesis test by using the
<code>p.adjust</code> function before returning an overall p-value
for the test. The test has been optimized for using the
<code>filter.number=10</code> wavelet and <code>away.from="standard"</code>,
but should work pretty well for other wavelets and even away.from
values of more than 2-3 for moderate numbers of scales, and potentially
higher for longer data sets. 
</p>
<p>An approximation to the theoretical power of this test
can be obtained using the <code><a href="#topic+genwwn.thpower">genwwn.thpower</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code> with the following components.
</p>
<table>
<tr><td><code>p.val.collector</code></td>
<td>
<p>All the of unadjusted p-values</p>
</td></tr>
<tr><td><code>p.val.adjust</code></td>
<td>
<p>All of the adjusted p-values</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The overall p-value of the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A text string describing the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.rejection">compute.rejection</a></code>,
<code><a href="#topic+genwwn.thpower">genwwn.thpower</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate test set, of dyadic length
#
x &lt;- rnorm(64)
#
# Do the test:
#
answer &lt;- genwwn.test(x)
#
# What do we get?
#
#answer
#
#	Wavelet Test of White Noise
#
#data:  
#p-value = 0.4629
</code></pre>

<hr>
<h2 id='genwwn.thpower'>Compute (approximation) to the theoretical power of the
<code><a href="#topic+genwwn.test">genwwn.test</a></code> test for
ARMA processes (including, of course, white noise itself).
</h2><span id='topic+genwwn.thpower'></span>

<h3>Description</h3>

<p>Compute (approximation) to the theoretical power of the
<code><a href="#topic+genwwn.test">genwwn.test</a></code> test. Note: this
function does no simulation, it merely computes an approximation
to the likely statistical power (or size) of the
<code><a href="#topic+genwwn.test">genwwn.test</a></code> function. It can be useful to establish
the reverse question: what sample size do I require to 
achieve a certain power for a given ARMA process?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genwwn.thpower(N = 128, ar = NULL, ma = NULL, plot.it = FALSE,
	sigsq = 1, alpha = 0.05, away.from = "standard",
	filter.number = 10, family = "DaubExPhase", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genwwn.thpower_+3A_n">N</code></td>
<td>
<p>The length of the series you want to get a theoretical power
result for.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_ar">ar</code></td>
<td>
<p>Autoregressive parameters. A vector with p entries for AR(p)
with the first entry being the value for lag-one term (alpha_1),
the second
entry being the value for the lag-two term (alpha_2) etc.
If this argument is NULL then there are no AR terms.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_ma">ma</code></td>
<td>
<p>Similar to the <code>ar</code> argument except for MA terms. 
A vector of length q for MA(q) parameters, with first entry
being beta_1, the second being beta_2, etc. If this argument
is NULL then there are no MA terms.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> then two plots are produced. The first is
of the time series spectrum you are considering (controlled by
the <code>N</code>, <code>ar</code> and <code>ma</code> arguments.) The second
is a plot of the wavelet coefficients of the normalized
spectrum.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_sigsq">sigsq</code></td>
<td>
<p>The theoretical innovation variance (also the variance
of white noise if <code>ar=ma=NULL</code>.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_alpha">alpha</code></td>
<td>
<p>The nominal size of the test for this theoretical power
calculation.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_away.from">away.from</code></td>
<td>
<p>Describes how many fine scales to exclude, the
same as in <code><a href="#topic+genwwn.test">genwwn.test</a></code>. This can be an integer
up to the number of scales. However, mostly you can leave this
at &quot;standard&quot; where the scales calculation is automatically determined.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments in the Daubechies
series of wavelets.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_family">family</code></td>
<td>
<p>The wavelet family.
</p>
</td></tr>
<tr><td><code id="genwwn.thpower_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then informative messages are printed during
the progress of the function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function calculates the value of the power function at
the specified arguments. It does this by: (i) specifying the
functional spectrum of the ARMA process
(which can be flat, ie white noise);
(ii) calculating the variance of the ARMA process by numerical
integration of the spectrum; (iii) calculating the spectrum
values at the Fourier frequencies; (iv) calculating the wavelet
coefficients at the exact spectrum values; (v) computing the
exact variance of the wavelet coefficients of the squared normalized
spectrum; (vi) computing the approximate power of the whole lot.
</p>


<h3>Value</h3>

<p>A list containing the following components.
</p>
<table>
<tr><td><code>C.alpha.c</code></td>
<td>
<p>The critical value for the test, which is the nominal
size critical value after correction for multiple hypothesis
tests (correction using Bonferroni).
</p>
</td></tr>
<tr><td><code>th.power</code></td>
<td>
<p>The computed theoretical power</p>
</td></tr>
<tr><td><code>norspecwd</code></td>
<td>
<p>The wavelet coefficients of the true spectrum</p>
</td></tr>
<tr><td><code>norspecvarwd</code></td>
<td>
<p>The squared wavelet transform of the squared normalized
spectrum</p>
</td></tr>
<tr><td><code>all.hwc</code></td>
<td>
<p>All of the wavelet coefficients from the normalized true
specturm as a single vector</p>
</td></tr>
<tr><td><code>all.sdwc</code></td>
<td>
<p>The &lsquo;true&rsquo; standard deviations of the wavelet coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+genwwn.test">genwwn.test</a></code>, <code><a href="#topic+sqwd">sqwd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Calculate what the theoretical actual size is likely to be for the
# genwwn.test for a white noise sequence of T=64, nominal size=0.05
#
genwwn.thpower(N=64)$th.power
#[1] 0.04894124
#
# This is pretty close to the nominal size of 5%. Good.
#
# What is the power of detection for the AR(1) process with alpha=0.3?
# Let's say with sample size of T=32
#
genwwn.thpower(N=32, ar=0.3)$th.power 
#[1] 0.2294128
#
# That's pretty poor, we'll only detect about 23% of cases. Can we achieve
# a power of 90%? Actually, it turns out that by repeating these above
# functions with N=128 gives a power of 61%, and for N=256 we get a power of
# 90%. 
</code></pre>

<hr>
<h2 id='hwwn.dw'>Compute discrete wavelets
</h2><span id='topic+hwwn.dw'></span>

<h3>Description</h3>

<p>Compute discrete wavelets up to some scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwwn.dw(J, filter.number, filter.family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwwn.dw_+3A_j">J</code></td>
<td>
<p>The number of scales of discrete wavelets to produce.
</p>
</td></tr>
<tr><td><code id="hwwn.dw_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter number.
</p>
</td></tr>
<tr><td><code id="hwwn.dw_+3A_filter.family">filter.family</code></td>
<td>
<p>The wavelet family to produce.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the delta value method and uses wr to reconstruct the
wavelets. See Nason, von Sachs and Kroisandt 2000 for details.
</p>
<p>Note: this function is the same as the <code>discrete.wavelets</code>
function in the AutoSpec package, but copied here.
</p>


<h3>Value</h3>

<p>A list of length J, each component of the list corresponds to
a different scale of wavelets. Component 1 is the finest scale,
component 2 is the next finest and so on.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz
</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (2000) Wavelet processes
and adaptive estimation of the evolutionary wavelet spectrum.
<em>J. R. Statist. Soc. B</em>, <b>62</b>, 271-292.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqndwdecomp">sqndwdecomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate three scales of Haar wavelets
#
hwwn.dw(3, 1, "DaubExPhase")
#[[1]]
#[1] 0.7071068 -0.7071068
#
#[[2]]
#[1] 0.5 0.5 -0.5 -0.5
#
#[[3]]
#[1] 0.3535534 0.3535534 0.3535534 0.3535534 -0.3535534 -0.3535534 -0.3535534
#[8] -0.3535534
</code></pre>

<hr>
<h2 id='hwwn.test'>Perform a test for white noise on a time series.
</h2><span id='topic+hwwn.test'></span>

<h3>Description</h3>

<p>Often one wishes to know whether a time series is consistent
with a white noise model. This function tests whether the underlying
spectrum of the time series is flat, which is identical to saying
that all the autocorrelations of the series are zero (apart from
the lag zero autocorrelation which is always one). This test
is exact for Gaussian data but will also work well with heavy-tailed
distributions whose periodogram tends to the exponential distribution
asymptotically (see accompanying paper for details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwwn.test(x, lowlev = 0, plot.it = FALSE, stopeveryscale = FALSE,
	n.cdf.grid = 1000, mc.method = p.adjust.methods, mac.spread=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwwn.test_+3A_x">x</code></td>
<td>
<p>The data set you wish to test. For now, the length of this
series has to be a power of two. In theory, it could be any length.
</p>
</td></tr>
<tr><td><code id="hwwn.test_+3A_lowlev">lowlev</code></td>
<td>
<p>Specifies the coarsest resolution level of wavelet coefficients
computed on the spectrum. Typically, this should be left at one,
which is the coarsest that can be achieved an still approximate
the CDF
</p>
</td></tr>
<tr><td><code id="hwwn.test_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> then plots of the wavelet coefficients
and their modelled underlying distribution are plotted,
and their cumulative distributions and the resultant p-values
as a histogram for each scale. Theoretical values are in red
and data estimated values in black.
</p>
</td></tr>
<tr><td><code id="hwwn.test_+3A_stopeveryscale">stopeveryscale</code></td>
<td>
<p>If <code>TRUE</code> the code stops after every plot
if <code>plot.it==TRUE</code>. This is a way of ensuring that the
human can see every plot to stop it whizzing off the screen.
Simply press ENTER to continue.
</p>
</td></tr>
<tr><td><code id="hwwn.test_+3A_n.cdf.grid">n.cdf.grid</code></td>
<td>
<p>The CDF of the Macdonald distribution is evaluated
numerically. This argument controls the resolution of that
grid: it controls the number of grid points there are between
<code>-mac.spread</code> and <code>mac.spread</code>.
</p>
</td></tr>
<tr><td><code id="hwwn.test_+3A_mc.method">mc.method</code></td>
<td>
<p>The method of multiple hypothesis comparison.
See <code>p.adjust</code> for details.
</p>
</td></tr>
<tr><td><code id="hwwn.test_+3A_mac.spread">mac.spread</code></td>
<td>
<p>The range (from <code>-mac.spread</code> to <code>mac.spread</code>)
that the CDF of the Macdonald distribution is computed on.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis of the test contained in this function
is H_0: series is white noise (or constant spectrum) versus
H_A: it is not white noise.
This test works by assessing whether the spectrum of the
underlying series is constant or not. It does this by
first computing the periodogram of the sample series. This
is a well-studied estimate of the spectrum. Then it evaluates
the constancy of the spectrum by examining the Haar wavelet
coefficients of the periodogram. Under normality much is known
about the asymptotic distribution of the periodogram and this
can be transferred, through some moderately complex distribution
theory to the distribution of the Haar wavelet coefficients
of the periodogram. Hence, in this situation, we have a good handle
on whether a particular wavelet coefficients is too large or
to small as we have near theoretical knowledge of their
CDF. Since we are testing many wavelet coefficients simultaneously
we have to use multiple hypothesis p-value adjustment techniques,
such as Bonferroni to obtain a final p-value.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code> containing the results of
the hypothesis test. Actually a list containing the following
components:
</p>
<table>
<tr><td><code>p.val.collector</code></td>
<td>
<p>All the p-values for all Haar wavelet coefficients
of the periodogram. These are the values before p-value adjustment
for multiple tests.</p>
</td></tr>
<tr><td><code>p.val.adjust</code></td>
<td>
<p>The p-values after adjustment for multiple tests via
<code>p.adjust</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character string describing the test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.rejection">compute.rejection</a></code>, <code><a href="#topic+Macdonald">Macdonald</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Invent test data set which IS white noise
#
x &lt;- rnorm(128)
#
# Do the test
#
x.wntest &lt;- hwwn.test(x)
#
# Print the results
#
#x.wntest
#
#	Wavelet Test of White Noise
#
#data:  
#p-value = 0.9606
#
# So p-value indicates that there is no evidence for rejection of
# H_0: white noise.
#
# Let's do an example using data that is not white noise. E.g. AR(1)
#
x.ar &lt;- arima.sim(n=128, model=list(ar=0.8))
#
# Do the test
#
x.ar.wntest &lt;- hwwn.test(x.ar)
#
# Print the results
#
print(x.ar.wntest)
#
#	Wavelet Test of White Noise
#
#data:  
#p-value &lt; 2.2e-16
#
# p-value is very small. Extremely strong evidence to reject H_0: white noise
</code></pre>

<hr>
<h2 id='hywavwn.test'>Hybrid wavelet test of white noise.
</h2><span id='topic+hywavwn.test'></span>

<h3>Description</h3>

<p>Combines the general wavelet test <code><a href="#topic+genwwn.test">genwwn.test</a></code>
at the medium-coarse scales and the Haar wavelet test at
fine scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hywavwn.test(x, away.from = "standard", lowlev = 0, plot.it = FALSE,
	stopeveryscale = FALSE, filter.number = 10,
	family = "DaubExPhase", mc.method = p.adjust.methods,
	verbose = FALSE, n.cdf.grid = 1000, mac.spread = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hywavwn.test_+3A_x">x</code></td>
<td>
<p>The time series you wish to test (of dyadic length).
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_away.from">away.from</code></td>
<td>
<p>Number of fine scales to stay away from, see details below.
If &quot;standard&quot; then this is automatically computed for sample sizes
up to length of 1024. If you have a longer series then the test
will still work but might not be quite as powerful (but probably
not too bad either).
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_lowlev">lowlev</code></td>
<td>
<p>The coarsest coefficient to evaluate. This should
always be left at 0. 
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_plot.it">plot.it</code></td>
<td>
<p>If TRUE then a series of plots similar to the ones produced
in the <code><a href="#topic+hwwn.test">hwwn.test</a></code> function is produced. See that help
page for further details on what the plots show.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_stopeveryscale">stopeveryscale</code></td>
<td>
<p>If TRUE then if <code>plot.it=TRUE</code> then a
&lsquo;scan&rsquo; is issued after every plot. Just hit RETURN to continue.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments of the wavelet
used to compute coefficients that are then evaluated to see whether
they are zero. In principle, best compression for a sparse evaluation
of the normalized spectrum should mean we use the smoothest wavelets
with the highest number of vanishing moments which is ten. The
other components of the function are optimized for ten vanishing
moments. The function will still work for other numbers of vanishing
moments but maybe with slightly reduced power.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_family">family</code></td>
<td>
<p>Wavelet family to go with <code>filter.number</code>.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_mc.method">mc.method</code></td>
<td>
<p>The type of multiple hypothesis correction, see
<code>p.adjust</code> for details.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> some information messages are printed.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_n.cdf.grid">n.cdf.grid</code></td>
<td>
<p>The CDF of the Macdonald distribution is evaluated
numerically. This argument controls the resolution of that
grid: it controls the number of grid points there are between
<code>-mac.spread</code> and <code>mac.spread</code>.
</p>
</td></tr>
<tr><td><code id="hywavwn.test_+3A_mac.spread">mac.spread</code></td>
<td>
<p>Horizontal range for plotting of wavelet coefficients,
only used if <code>plot.it=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+genwwn.test">genwwn.test</a></code> performs pretty well, but does
not pick up departures from the null at the finest scale of
wavelet coefficients because it does not look at those scales
(because of the &lsquo;away.from&rsquo; argument and the asymptotic normality
that <code><a href="#topic+genwwn.test">genwwn.test</a></code> does not kick in at those finer
scales). So, this test augments the <code><a href="#topic+genwwn.test">genwwn.test</a></code>
with the finest scales results from <code><a href="#topic+hwwn.test">hwwn.test</a></code>.
Those scales finer than <code>away.from</code> use the Haar wavelet
and those coarser than <code>away.from</code> use the general wavelet.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code> with the following components.
</p>
<table>
<tr><td><code>p.val.collector</code></td>
<td>
<p>All the of unadjusted p-values</p>
</td></tr>
<tr><td><code>p.val.adjust</code></td>
<td>
<p>All of the adjusted p-values</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The overall p-value of the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A text string describing the test</p>
</td></tr>
<tr><td><code>p.val.collector.hw</code></td>
<td>
<p>The of unadjusted p-values from the Haar wavelet levels</p>
</td></tr>
<tr><td><code>p.val.collector.gw</code></td>
<td>
<p>The of unadjusted p-values from the general wavelet levels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+genwwn.test">genwwn.test</a></code>, <code><a href="#topic+hwwn.test">hwwn.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Test data
#
x &lt;- rnorm(64)
#
# Do the test
#
answer &lt;- hywavwn.test(x)
#
# The result in my case was:
#
#answer
#
#	Hybrid Wavelet Test of White Noise
#
#data:  
#p-value = 0.02305
</code></pre>

<hr>
<h2 id='hywn.test'>Hybrid of Box-Ljung test, Bartlett B test, Haar wavelet and
General wavelet tests.
</h2><span id='topic+hywn.test'></span>

<h3>Description</h3>

<p>Omnibus test that attempts to mitigate poor performance of
single test on a particular class where it does poorly by running
four different tests that work well in different directions and
pooling their results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hywn.test(x, filter.number = 10, family = "DaubExPhase")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hywn.test_+3A_x">x</code></td>
<td>
<p>The data you wish to test (dyadic length)
</p>
</td></tr>
<tr><td><code id="hywn.test_+3A_filter.number">filter.number</code></td>
<td>
<p>The number of vanishing moments of the wavelet used.
</p>
</td></tr>
<tr><td><code id="hywn.test_+3A_family">family</code></td>
<td>
<p>The family of the wavelets
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>The overall p-value of the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Text string containing the name of the method used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bartlettB.test">bartlettB.test</a></code>,
<code><a href="#topic+genwwn.test">genwwn.test</a></code>,
<code><a href="#topic+hwwn.test">hwwn.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate test data
#
x &lt;- rnorm(64)
#
# Run the hybrid test
#
hywn.test(x)
#
#	Hybrid Test
#
#data:  
#p-value = 0.09221
</code></pre>

<hr>
<h2 id='Macdonald'>Compute the Macdonald density function for a specified parameter
value <code>m</code> at a vector of <code>x</code> values.
</h2><span id='topic+Macdonald'></span>

<h3>Description</h3>

<p>Compute the Macdonald density function for a specified parameter
value <code>m</code> at a vector of <code>x</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Macdonald(x, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Macdonald_+3A_x">x</code></td>
<td>
<p>The <code>x</code> ordinates that you want to evaluate the density
at. A vector of real numbers. 
</p>
</td></tr>
<tr><td><code id="Macdonald_+3A_m">m</code></td>
<td>
<p>The parameter of the Macdonald's density
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Macdonald probability density
function for parameter <code>m</code> and values at which to
evaluate the density supplied in <code>x</code>. The mean and
variance of this density is zero and one respectively.
</p>


<h3>Value</h3>

<p>The density
</p>


<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute.rejection">compute.rejection</a></code>, <code><a href="#topic+hwwn.test">hwwn.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Work out density at x=0, 0.5 and 1 for the m=1 Macdonald density
#
Macdonald(x=c(0,0.5,1), m=2)
#[1] 0.3535534 0.2975933 0.2075131
#
# Check that the density integrates to one, e.g. for m=3
#
integrate(Macdonald, lower=-20, upper=20, m=3)
#1 with absolute error &lt; 4.7e-07
</code></pre>

<hr>
<h2 id='sqcoefvec'>Compute coefficients required for approximaing the wavelet
transform using the square of wavelets.
</h2><span id='topic+sqcoefvec'></span>

<h3>Description</h3>

<p>Essentially, part of a method for computing a wavelet-like
transform using the squares of wavelets rather than the
wavelets themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqcoefvec(m0, filter.number = 10, family = "DaubLeAsymm",
	resolution = 4096, stop.on.error = FALSE, plot.it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqcoefvec_+3A_m0">m0</code></td>
<td>
<p>The number of scales finer than the square wavelet being
approximated. Usually, 2 or 3 is enough. 
</p>
</td></tr>
<tr><td><code id="sqcoefvec_+3A_filter.number">filter.number</code></td>
<td>
<p>Number of vanishing moments of underlying wavelet.
</p>
</td></tr>
<tr><td><code id="sqcoefvec_+3A_family">family</code></td>
<td>
<p>Family of underlying wavelet
</p>
</td></tr>
<tr><td><code id="sqcoefvec_+3A_resolution">resolution</code></td>
<td>
<p>Function values of the wavelet itself are generated by
a high-resolution approximation. This argument specifies
exactly how many values.
</p>
</td></tr>
<tr><td><code id="sqcoefvec_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>This argument is supplied to the <code>integrate</code>
function which performs numerical integration within this code.
</p>
</td></tr>
<tr><td><code id="sqcoefvec_+3A_plot.it">plot.it</code></td>
<td>
<p>Plots showing the approximation are plotted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea is that the square of a wavelet (the square wavelet)
is approximated by wavelets at a finer scale. The argument <code>m0</code>
controls how many levels below the original scale are used.
Essentially, this function computes a representation of the
original square wavelet in terms of finer scale wavelets.  Hence,
when a decomposition of another function with respect to the square
wavelets is required, one can compute the representation with
respect to a regular wavelet decomposition and then apply the
wavelet to  square wavelet transform to turn it into a square wavelet
representation.
</p>
<p>This idea originally used for performing &lsquo;powers of wavelets&rsquo;
transforms in Herrick (2000) and Barber, Nason and Silverman
(2002) and for the mod-wavelets is described in Fryzlewicz, Nason
and von Sachs (2008).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>ll</code></td>
<td>
<p>Vector containing integers between the lower and upper limit
of the wavelets required at the finer scale.</p>
</td></tr>
<tr><td><code>ecoef</code></td>
<td>
<p>The appropriate coefficients that approximate the mod wavelet
at the finer scale.</p>
</td></tr>
<tr><td><code>m0</code></td>
<td>
<p>The number of scales finer below the scale that the function
is at</p>
</td></tr>
<tr><td><code>filter.number</code></td>
<td>
<p>The wavelet filter number used</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The wavelet family used</p>
</td></tr>
<tr><td><code>ecode</code></td>
<td>
<p>An error code, if zero then ok, otherwise returns 1</p>
</td></tr>
<tr><td><code>ians</code></td>
<td>
<p>The actual return values from the internal call to the
<code>integrate</code> function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Barber, S., Nason, G.P. and Silverman, B.W. (2002) Posterior
probability intervals for wavelet thresholding.
<em>J. R. Statist.  Soc. B</em>, <b>64</b>, 189-206.
</p>
<p>Fryzlewicz, P., Nason, G.P. and von Sachs, R. (2008) A
wavelet-Fisz approach to spectrum estimation.
<em>J. Time Ser.  Anal.</em>,
<b>29</b>, 868-880.
</p>
<p>Herrick, D.R.M. (2000) <em>Wavelet Methods for Curve Estimation</em>, PhD
thesis, University of Bristol, U.K.
</p>
<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqwd">sqwd</a></code>, <code><a href="#topic+sqndwd">sqndwd</a></code>,
<code><a href="#topic+sqndwdecomp">sqndwdecomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function is not really designed to be used by the casual user
#
tmp &lt;- sqcoefvec(m0=2, filter.number=4)
</code></pre>

<hr>
<h2 id='sqndwd'>Compute the non-decimated squared wavelet transform.
</h2><span id='topic+sqndwd'></span>

<h3>Description</h3>

<p>A transform of the data with respect to an expansion
comprised of squared wavelets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqndwd(x, ec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqndwd_+3A_x">x</code></td>
<td>
<p>The sequence that you want transformed, of dyadic length.
</p>
</td></tr>
<tr><td><code id="sqndwd_+3A_ec">ec</code></td>
<td>
<p>A structure containing the necessary information to
transform the wavelet transform of the sequence to the
squared wavelet transform. This is provided by the
function <code><a href="#topic+sqcoefvec">sqcoefvec</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first computes the wavelet transform of the <code>x</code>
data. Then, level by level it is retransformed into the
coefficients of the squared-wavelet transform using the <code>ec</code>
structure. Fine levels, that cannot be computed using the
approximate method are computed directly by the brute-force method
in <code>sqndwdecomp</code>.  Method used is described in Fryzlewicz, Nason and
von Sachs (2008), and is analogous to the &lsquo;powers of wavelets&rsquo;
transform described in Herrick (2000) and Barber, Nason and
Silverman (2002).
</p>


<h3>Value</h3>

<p>An object of class <code>wd</code> containing the non-decimated
squared wavelet transform.
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Barber, S., Nason, G.P. and Silverman, B.W. (2002) Posterior
probability intervals for wavelet thresholding.
<em>J. R. Statist.  Soc. B</em>, <b>64</b>, 189-206.
</p>
<p>Fryzlewicz, P., Nason, G.P. and von Sachs, R. (2008) A
wavelet-Fisz approach to spectrum estimation.
<em>J. Time Ser.  Anal.</em>,
<b>29</b>, 868-880.
</p>
<p>Herrick, D.R.M. (2000) <em>Wavelet Methods for Curve Estimation</em>, PhD
thesis, University of Bristol, U.K.
</p>
<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqwd">sqwd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Random data
#
x &lt;- rnorm(16)
#
# Compute the projection of x onto the squared wavelets... 
#
ans &lt;- sqndwd(x, ec=sqcoefvec(m0=2, filter.number=4))
</code></pre>

<hr>
<h2 id='sqndwdecomp'>Brute-force calculation of the non-decimated squared wavelet transform.
</h2><span id='topic+sqndwdecomp'></span>

<h3>Description</h3>

<p>Accurate, but brute-force, direct (slow) calculation of the
non-decimated squared wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqndwdecomp(x, J, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqndwdecomp_+3A_x">x</code></td>
<td>
<p>The sequence you want to transform
</p>
</td></tr>
<tr><td><code id="sqndwdecomp_+3A_j">J</code></td>
<td>
<p>The number of resolutions you want
</p>
</td></tr>
<tr><td><code id="sqndwdecomp_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter you  wish to use.
</p>
</td></tr>
<tr><td><code id="sqndwdecomp_+3A_family">family</code></td>
<td>
<p>The wavelet family you wish to use
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Works by computing the discrete wavelets and the necessary
scales using <code><a href="#topic+hwwn.dw">hwwn.dw</a></code> function. Then forms the
direct inner product with the data with the squares of the
discrete wavelets.
</p>


<h3>Value</h3>

<p>Returns a matrix of J rows and length(x) columns. Row j in the
matrix returned corresponds to the level (nlev-j) resolution level
coefficients (where nlev is nlevelsWT(x)) in the WaveThresh
ordering.
</p>


<h3>Author(s)</h3>

<p>Piotr Fryzlewicz (modified by Guy Nason)
</p>


<h3>References</h3>

<p>Fryzlewicz, P., Nason, G.P. and von Sachs, R. (2008) A
wavelet-Fisz approach to spectrum estimation.  <em>J. Time Ser.  Anal.</em>,
<b>29</b>, 868-880.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqndwd">sqndwd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate random series and then take transform
x &lt;- rnorm(128)
y &lt;- sqndwdecomp(x=x, J=2, filter.number=3, family="DaubExPhase")
</code></pre>

<hr>
<h2 id='sqwd'>Compute expansion with respect to squared wavelets. 
</h2><span id='topic+sqwd'></span>

<h3>Description</h3>

<p>Compute expansion with respect to squared wavelets. See help for
<code><a href="#topic+sqndwd">sqndwd</a></code>. The coefficients are the projection of the
input sequence onto the set of functions being the squares of
the usual wavelets. This operation is most useful for computing
variances of wavelet coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqwd(x, filter.number = 10, family = "DaubExPhase", type = "station", m0 = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqwd_+3A_x">x</code></td>
<td>
<p>Sequence that you wish to compute expansion for.
</p>
</td></tr>
<tr><td><code id="sqwd_+3A_filter.number">filter.number</code></td>
<td>
<p>Base wavelet family (no. of vanishing moments) you
wish to use.
</p>
</td></tr>
<tr><td><code id="sqwd_+3A_family">family</code></td>
<td>
<p>The base wavelet family you wish to use.
</p>
</td></tr>
<tr><td><code id="sqwd_+3A_type">type</code></td>
<td>
<p>Either <code>station</code> for the non-decimated transform or
<code>wavelet</code> for the regular wavelet transform.
</p>
</td></tr>
<tr><td><code id="sqwd_+3A_m0">m0</code></td>
<td>
<p>The number of scales down (finer) from the scale of the
squared wavelet being approximated. Usually, 2 or 3 is enough. Many
more scales results in a better approximation but at a higher
cost as the number of coefficients at consecutive scales doubles.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an implementation of the &lsquo;powers of wavelets&rsquo;
idea from Herrick (2000), Barber, Nason and Silverman (2002) and,
for the associated mod-wavelets by Fryzlewicz, Nason and von Sachs
(2008).
</p>


<h3>Value</h3>

<p>An object of class <code>wd</code> but containing coefficients with
respect to the squared wavelets.
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Barber, S., Nason, G.P. and Silverman, B.W. (2002) Posterior
probability intervals for wavelet thresholding. 
<em>J. R. Statist.  Soc. B</em>, <b>64</b>, 189-206.
</p>
<p>Fryzlewicz, P., Nason, G.P. and von Sachs, R. (2008) A
wavelet-Fisz approach to spectrum estimation.  
<em>J. Time Ser.  Anal.</em>,
<b>29</b>, 868-880.
</p>
<p>Herrick, D.R.M. (2000) <em>Wavelet Methods for Curve Estimation</em>, PhD
thesis, University of Bristol, U.K.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genwwn.thpower">genwwn.thpower</a></code>,
<code><a href="#topic+sqcoefvec">sqcoefvec</a></code>,
<code><a href="#topic+sqndwd">sqndwd</a></code>,
<code><a href="#topic+sqndwdecomp">sqndwdecomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# A made-up sequence
#
x &lt;- 1:32
#
# Work out its expansion wrt squared wavelets
#
x.sqwd &lt;- sqwd(1:32)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
