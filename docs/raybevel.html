<!DOCTYPE html><html><head><title>Help for package raybevel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {raybevel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrange_base'><p>Arrange or Reorder Rows of a Data Frame by Columns</p></a></li>
<li><a href='#change_polygon_bevel'><p>Change an existing polygon bevel's bevel profile.</p></a></li>
<li><a href='#convert_ss_to_polygons'><p>Get Face IDs</p></a></li>
<li><a href='#determinant2x2'><p>Title</p></a></li>
<li><a href='#discretize_and_merge_nodes'><p>Discretize and Merge Nodes</p></a></li>
<li><a href='#dot'><p>Dot Product</p></a></li>
<li><a href='#extrude_sides'><p>Extrude Sides of Polygon</p></a></li>
<li><a href='#find_dangling_nodes'><p>Discretize and Merge Nodes</p></a></li>
<li><a href='#generate_bevel'><p>Generate 2D Bevel Profile for 3D Polygons</p></a></li>
<li><a href='#generate_beveled_polygon'><p>Generate a beveled 3D polygon</p></a></li>
<li><a href='#generate_complex_bevel'><p>Generate Complex 2D Bevel Profile for 3D Polygons</p></a></li>
<li><a href='#generate_offset_links_nodes'><p>Generate Offset Polygon</p></a></li>
<li><a href='#generate_offset_polygon'><p>Generate an offset polygon</p></a></li>
<li><a href='#generate_roof'><p>Generate a 3D roof model</p></a></li>
<li><a href='#get_time'><p>Get time</p></a></li>
<li><a href='#identify_maxima_nodes'><p>Identify Local and Global Maxima Nodes</p></a></li>
<li><a href='#init_time'><p>Print time</p></a></li>
<li><a href='#insert_polygon_links_nodes'><p>Insert Polygon Links/Nodes</p></a></li>
<li><a href='#interpolate_location'><p>Interpolate Location</p></a></li>
<li><a href='#make_incremental_nodes'><p>Make incremental nodes</p></a></li>
<li><a href='#modify_bevel_with_skeleton'><p>Modify bevel data using straight skeleton</p></a></li>
<li><a href='#plot_offset_polygon'><p>Plot Offset Polygons</p></a></li>
<li><a href='#plot_skeleton'><p>Plot the Straight Skeleton of a Polygon</p></a></li>
<li><a href='#print_time'><p>Print time</p></a></li>
<li><a href='#process_sliced_links'><p>Process sliced links</p></a></li>
<li><a href='#recalculate_ordered_ids'><p>Recalculate Ordered IDs</p></a></li>
<li><a href='#remove_node_duplicates'><p>Remove Node Duplicates</p></a></li>
<li><a href='#remove_reversed_links'><p>Remove Reversed Links</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#skeletonize'><p>Skeletonize a polygon</p></a></li>
<li><a href='#swap_yz'><p>Extrude Sides of Polygon</p></a></li>
<li><a href='#unit_vector'><p>Dot Product</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generates Polygon Straight Skeletons and 3D Bevels</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates polygon straight skeletons and 3D models.  
    Provides functions to create and visualize interior polygon offsets, 
    3D beveled polygons, and 3D roof models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>progress, digest, decido, rayvertex (&ge; 0.10.4), sf, grid</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH, RcppCGAL (&ge; 5.6.3), progress, RcppThread (&ge;
2.1.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spData, rayrender, testthat (&ge; 3.0.0), ggplot2, png</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.raybevel.com">https://www.raybevel.com</a>,
<a href="https://github.com/tylermorganwall/raybevel/">https://github.com/tylermorganwall/raybevel/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylermorganwall/raybevel/issues">https://github.com/tylermorganwall/raybevel/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-11 22:41:31 UTC; tyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-14 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arrange_base'>Arrange or Reorder Rows of a Data Frame by Columns</h2><span id='topic+arrange_base'></span>

<h3>Description</h3>

<p>This function sorts a data frame based on the provided columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_base(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_base_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="arrange_base_+3A_...">...</code></td>
<td>
<p>Column names to determine the sort order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted data frame.
</p>

<hr>
<h2 id='change_polygon_bevel'>Change an existing polygon bevel's bevel profile.</h2><span id='topic+change_polygon_bevel'></span>

<h3>Description</h3>

<p>This function generates a beveled 3D polygon model from the modified straight skeleton with
pre-existing polygons generated from the 'generate_beveled_polygon' function when
'return_skeleton_polygons = TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_polygon_bevel(
  skeleton_polygons,
  bevel_offsets = NULL,
  bevel_heights = NULL,
  set_max_height = FALSE,
  max_height = 1,
  vertical_offset = 0,
  base = TRUE,
  base_height = NA,
  raw_offsets = FALSE,
  raw_heights = FALSE,
  swap_yz = TRUE,
  progress = TRUE,
  sides = FALSE,
  double_sided = FALSE,
  scale_all_max = FALSE,
  material = material_list(),
  bevel_material = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_polygon_bevel_+3A_skeleton_polygons">skeleton_polygons</code></td>
<td>
<p>Default 'NULL'. A straight skeleton generated from the 'generate_beveled_polygon' function when
'return_skeleton_polygons = TRUE'.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_bevel_offsets">bevel_offsets</code></td>
<td>
<p>Default 'NULL'. The offset(s) of the bevel.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_bevel_heights">bevel_heights</code></td>
<td>
<p>Default is set to 'bevel_offsets'. Numeric vector specifying the heights of the bevels. Must be of the same length as 'bevel_offsets'.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_set_max_height">set_max_height</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether to set the max height of the polygon based on the 'max_height' argument.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_max_height">max_height</code></td>
<td>
<p>Default '1'. The maximum height of the polygon.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_vertical_offset">vertical_offset</code></td>
<td>
<p>Default '0'. The vertical offset of the polygon.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_base">base</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether to generate the bottom of the polygon.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_base_height">base_height</code></td>
<td>
<p>Default 'NA'. Height of the base, defaulting to the 'min(bevel_heights) + vertical_offset' .</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_raw_offsets">raw_offsets</code></td>
<td>
<p>Default 'FALSE'. A logical flag indicating whether the 'bevel_offsets' are already in raw format and do not need to be multiplied by the maximum time of the skeleton.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_raw_heights">raw_heights</code></td>
<td>
<p>Default 'FALSE'. A logical flag indicating whether the 'bevel_heights' are already in raw format and do not need to be multiplied by the maximum time of the skeleton.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether to swap the y and z coordinates in the resulting mesh.
If 'TRUE', the y and z coordinates will be swapped.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to display a progress bar.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_sides">sides</code></td>
<td>
<p>Default 'FALSE'. A logical flag on whether to draw the sides. This will automatically be set to 'TRUE'
if 'base = TRUE' and the 'base_height' is less than 'vertical_offset'.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_double_sided">double_sided</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether the polygon should be double-sided.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_scale_all_max">scale_all_max</code></td>
<td>
<p>Default 'FALSE'. If passing in a list of multiple skeletons with polygons, whether to scale each polygon to the overall
max height, or whether to scale each max height to the maximum internal distance in the polygon.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_material">material</code></td>
<td>
<p>Default 'material_list()'. Interface to set the color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_bevel_material">bevel_material</code></td>
<td>
<p>Default 'NA', uses the material specified in 'material'. Interface to set the color/appearance/material options for the resulting 'ray_mesh' bevel mesh.</p>
</td></tr>
<tr><td><code id="change_polygon_bevel_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. A logical flag to control whether additional timing information should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D mesh of the beveled polygon model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Skeletonize a complex {sf} object and set return_skeleton_polygons = TRUE in
# generate_beveled_polygon(). This returns skeleton object with polygons included, which
# allows for quickly generating 3D models with different bevels.
if(run_documentation()) {
  library(rayrender)
  library(rayvertex)
  us_states = spData::us_states
  cali = us_states[us_states$NAME == "California",]
  cali_skeleton = skeletonize(cali)
  plot_skeleton(cali_skeleton)
  # We add manual offsets to ensure that the polygon can be morphed all along its interior
  bevel = generate_bevel(manual_offsets = seq(0,1,by=0.01), max_height=0.5)
  bevel_model_cali = generate_beveled_polygon(cali_skeleton,
                                              bevel_offsets = bevel,
                                              return_skeleton_polygons = TRUE)

  bevel_new = change_polygon_bevel(bevel_model_cali,
                                   bevel_offsets = generate_bevel(max_height=0.5,
                                   bevel_end=0.5)) |&gt;
    center_mesh()

  scene_base = xz_rect(xwidth=100,zwidth=100,
                       material=diffuse(color="grey20", checkercolor="white")) |&gt;
    add_object(sphere(y=8,z=10,x=-3,material=light(intensity=100))) |&gt;
    add_object(sphere(y=800,z=10,x=-3,radius=100,material=light(intensity=5)))

  raymesh_model(bevel_new, y=0.5, override_material = TRUE,
                material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(0,30,-10), sample_method = "sobol_blue",clamp_value = 10,
                 width=800,height=800,fov=0,ortho_dimensions=c(12,12))
}
# Change to a smooth bevel
if(run_documentation()) {
  new_bevel = generate_bevel("circular", bevel_start = 0, bevel_end=1)
  bevel_new = change_polygon_bevel(bevel_model_cali,
                                   bevel_offsets = new_bevel, solid ) |&gt;
    center_mesh()
  raymesh_model(bevel_new, override_material = TRUE, y=1,material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(0,30,-10), sample_method = "sobol_blue",clamp_value = 10,
                 width=800,height=800,fov=0,ortho_dimensions=c(12,12))
}

# Make a complex bevel
if(run_documentation()) {
  complex_coords = generate_complex_bevel(
    bevel_type  = c("angled","flat", "angled", "flat"),
    bevel_start = head(seq(0,1,by=0.05),-1),
    bevel_end   = tail(seq(0,1,by=0.05),-1),
    overall_height = 1,
    angle = c(45,45,15,15),
    reverse = c(FALSE, FALSE,TRUE,TRUE),
    plot_bevel = TRUE
  )
  bevel_new = change_polygon_bevel(bevel_model_cali,
                                   bevel_offsets = complex_coords) |&gt;
    center_mesh()
  raymesh_model(bevel_new, override_material = TRUE, y=1,material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(0,30,-20), sample_method = "sobol_blue",clamp_value = 10,
                 width=800,height=800,fov=0,ortho_dimensions=c(12,12))
}

# Quickly generate new bevels to inflate California like a balloon using the arctan function.
if(run_documentation()) {
  inflate_california = function(magnitudes) {
  for(val in magnitudes) {
    bevel_new = change_polygon_bevel(bevel_model_cali,
                                     bevel_heights = 1/2*atan(seq(0,val,length.out=100)),
                                     bevel_offsets = seq(0,1, length.out=100),
                                     base = TRUE) |&gt;
      translate_mesh(c(-120.49,0,-38.72))
    raymesh_model(bevel_new, y = 0, override_material = TRUE,
                  material = glossy(color="darkred")) |&gt;
      add_object(scene_base) |&gt;
      add_object(sphere(x=-30,z=30,y=18,radius=30,material=light(color="white", intensity=5))) |&gt;
      render_scene(lookfrom=c(-1, 28, -20.32), lookat=c(-1, 1.46, -2),
                   sample_method = "sobol_blue", clamp_value = 10,
                   width=800,height=800,fov=20,samples=256)
    }
  }
  inflate_california(c(1,4,16,64))
}
</code></pre>

<hr>
<h2 id='convert_ss_to_polygons'>Get Face IDs</h2><span id='topic+convert_ss_to_polygons'></span>

<h3>Description</h3>

<p>Get Face IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_ss_to_polygons(ss, progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_ss_to_polygons_+3A_ss">ss</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='determinant2x2'>Title</h2><span id='topic+determinant2x2'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determinant2x2(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determinant2x2_+3A_v1">v1</code></td>
<td>
<p>Vector 1</p>
</td></tr>
<tr><td><code id="determinant2x2_+3A_v2">v2</code></td>
<td>
<p>Vector 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None
</code></pre>

<hr>
<h2 id='discretize_and_merge_nodes'>Discretize and Merge Nodes</h2><span id='topic+discretize_and_merge_nodes'></span>

<h3>Description</h3>

<p>Discretize and Merge Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize_and_merge_nodes(skeleton, tolerance = 1e-05)
</code></pre>

<hr>
<h2 id='dot'>Dot Product</h2><span id='topic+dot'></span>

<h3>Description</h3>

<p>Dot Product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot_+3A_v1">v1</code></td>
<td>
<p>Vector 1</p>
</td></tr>
<tr><td><code id="dot_+3A_v2">v2</code></td>
<td>
<p>Vector 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None
</code></pre>

<hr>
<h2 id='extrude_sides'>Extrude Sides of Polygon</h2><span id='topic+extrude_sides'></span>

<h3>Description</h3>

<p>Extrude Sides of Polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrude_sides(vertices, holes = list(), bottom = 0, top = 1)
</code></pre>

<hr>
<h2 id='find_dangling_nodes'>Discretize and Merge Nodes</h2><span id='topic+find_dangling_nodes'></span>

<h3>Description</h3>

<p>Discretize and Merge Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dangling_nodes(skeleton)
</code></pre>

<hr>
<h2 id='generate_bevel'>Generate 2D Bevel Profile for 3D Polygons</h2><span id='topic+generate_bevel'></span>

<h3>Description</h3>

<p>Generate 2D Bevel Profile for 3D Polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_bevel(
  bevel_type = "angled",
  bevel_start = 0,
  bevel_end = 0.2,
  max_height = 1,
  angle = NULL,
  curve_points = 50,
  reverse = FALSE,
  flip = FALSE,
  initial_height = 0,
  add_end_points = TRUE,
  manual_offsets = NULL,
  step_epsilon = 1e-08,
  plot_bevel = FALSE,
  set_minimum_zero = TRUE,
  zero_offset_epsilon = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_bevel_+3A_bevel_type">bevel_type</code></td>
<td>
<p>Character 'angled'. Type of the bevel, one of the following options:
- &quot;circular&quot;: Creates a rounded bevel resembling a quarter-circle.
- &quot;exp&quot;: Creates an exponential curve, starting slow and accelerating.
- &quot;bump&quot;: Creates a bump-like profile, rising and falling within the coverage.
- &quot;step&quot;: Generates a step-like bevel with a flat top.
- &quot;block&quot;: Generates a block-like bevel, jumping straight to the max_height and back to the base.
- &quot;angled&quot;: Generates a straight angled bevel. You can optionally set the 'angle' parameter for this bevel.
- &quot;flat&quot;: Generates a flat area.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_bevel_start">bevel_start</code></td>
<td>
<p>Default '0'. The starting point of the bevel along the curve, ranges between 0 and 1.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_bevel_end">bevel_end</code></td>
<td>
<p>Default '0.2'. The ending point of the bevel along the curve, ranges between 0 and 1.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_max_height">max_height</code></td>
<td>
<p>Default '1'. The maximum height of the bevel, as measured from the initial height.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_angle">angle</code></td>
<td>
<p>Default 'NULL'. Optional angle parameter in degrees for angular bevels.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_curve_points">curve_points</code></td>
<td>
<p>Default '50'. Number of points to plot for curve-based bevels.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_reverse">reverse</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the curve is reversed vertically.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_flip">flip</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the curve is flipped horizontally.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_initial_height">initial_height</code></td>
<td>
<p>Default '0'. The initial height from which the bevel starts. The bevel is rescaled to fit within the range from initial_height to max_height.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_add_end_points">add_end_points</code></td>
<td>
<p>Default 'TRUE'. Whether to ensure there is a point at zero and a point at one.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_manual_offsets">manual_offsets</code></td>
<td>
<p>Default 'NULL', none. This will force the bevel to add a point (interpolating between the two nearest points)
at the specified offsets. This is useful when you want to add points at specific distances along the curve.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_step_epsilon">step_epsilon</code></td>
<td>
<p>Default '1e-5'. The size for the small percentage step when using a step bevel.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_plot_bevel">plot_bevel</code></td>
<td>
<p>Default 'FALSE'. Whether to plot the bevel.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_set_minimum_zero">set_minimum_zero</code></td>
<td>
<p>Default &lsquo;TRUE'. Whether to offset the lowest point of the bevel so it&rsquo;s at zero.</p>
</td></tr>
<tr><td><code id="generate_bevel_+3A_zero_offset_epsilon">zero_offset_epsilon</code></td>
<td>
<p>Default '1e-5'. Amount to offset the bevel to ensure no self-intersection with the base.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing 'x' and 'y', which are the coordinates of the 2D bevel profile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a single bevel profile and plot it
coords = generate_bevel("circular", 0.2, 0.8, 0.2, plot_bevel = TRUE)

# Plot all bevel profiles in a grid
plot_all_bevels = function() {
  oldpar = par(mfrow = c(4, 3), mai = c(0.2, 0.2, 0.5, 0.2))
  on.exit(par(oldpar))
  max_height = c(1,1,1,1)
  types = rep(c("circular", "exp", "bump", "step", "block", "angled"),2)
  reverses = c(rep(FALSE,6),rep(TRUE,6))
  for(i in seq_len(length(types))) {
    coords = generate_bevel(types[i], 0.2, 0.8, 1, flip = TRUE,
                            angle = 45, reverse = reverses[i], plot_bevel = TRUE)
  }
}
plot_all_bevels()
</code></pre>

<hr>
<h2 id='generate_beveled_polygon'>Generate a beveled 3D polygon</h2><span id='topic+generate_beveled_polygon'></span>

<h3>Description</h3>

<p>This function generates a beveled 3D polygon from a straight skeleton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_beveled_polygon(
  skeleton,
  bevel_offsets = generate_bevel(),
  bevel_heights = NULL,
  set_max_height = FALSE,
  max_height = NA,
  vertical_offset = 0,
  base = TRUE,
  base_height = 0,
  raw_offsets = FALSE,
  raw_heights = FALSE,
  swap_yz = TRUE,
  progress = TRUE,
  double_sided = FALSE,
  sides = FALSE,
  return_skeleton_polygons = FALSE,
  scale_all_max = FALSE,
  material = material_list(),
  bevel_material = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_beveled_polygon_+3A_skeleton">skeleton</code></td>
<td>
<p>Default 'NULL'. A straight skeleton generated from the 'skeletonize' function.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_bevel_offsets">bevel_offsets</code></td>
<td>
<p>Default 'NULL'. The offset(s) of the bevel.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_bevel_heights">bevel_heights</code></td>
<td>
<p>Default is set to 'bevel_offsets'. Numeric vector specifying the heights of the bevels. Must be of the same length as 'bevel_offsets'.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_set_max_height">set_max_height</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether to set the max height of the roof based on the 'max_height' argument.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_max_height">max_height</code></td>
<td>
<p>Default '1'. The maximum height of the polygon.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_vertical_offset">vertical_offset</code></td>
<td>
<p>Default '0'. The vertical offset of the polygon.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_base">base</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether to generate the bottom of the polygon.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_base_height">base_height</code></td>
<td>
<p>Default 'NA'. Height of the base, defaulting to 'min(bevel_heights) + vertical_offset' .</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_raw_offsets">raw_offsets</code></td>
<td>
<p>Default 'FALSE'. A logical flag indicating whether the 'bevel_offsets' are already in raw format and do not need to be multiplied by the maximum time of the skeleton.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_raw_heights">raw_heights</code></td>
<td>
<p>Default 'FALSE'. A logical flag indicating whether the 'bevel_heights' are already in raw format and do not need to be multiplied by the maximum time of the skeleton.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether to swap the y and z coordinates in the resulting mesh. If 'TRUE', the y and z coordinates will be swapped.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. A logical flag to control whether a progress bar is displayed during roof generation.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_double_sided">double_sided</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether the polygon should be double-sided.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_sides">sides</code></td>
<td>
<p>Default 'FALSE'. A logical flag on whether to draw the sides. This will automatically be set to 'TRUE'
if 'base = TRUE' and the 'base_height' is less than 'vertical_offset'.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_return_skeleton_polygons">return_skeleton_polygons</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether to return the skeleton polygons along with the 3D mesh.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_scale_all_max">scale_all_max</code></td>
<td>
<p>Default 'FALSE'. If passing in a list of multiple skeletons with polygons, whether to scale each polygon to the overall
max height, or whether to scale each max height to the maximum internal distance in the polygon.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_material">material</code></td>
<td>
<p>Default 'material_list()'. Interface to set the color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_bevel_material">bevel_material</code></td>
<td>
<p>Default 'NA', uses the material specified in 'material'. Interface to set the color/appearance/material options for the resulting 'ray_mesh' bevel mesh.</p>
</td></tr>
<tr><td><code id="generate_beveled_polygon_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. A logical flag to control whether additional timing information should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D mesh of the beveled polygon model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate vertices and holes
vertices = matrix(c(0,0, 7,0, 7,7, 0,7, 0,0), ncol = 2, byrow = TRUE)-3.5
hole_1 = matrix(c(1,1, 2,1, 2,2, 1,2, 1,1), ncol = 2, byrow = TRUE)[5:1,]-3.5
hole_2 = matrix(c(5,5, 6,5, 6,6, 5,6, 5,5), ncol = 2, byrow = TRUE)[5:1,]-3.5
skeleton = skeletonize(vertices, holes = list(hole_1, hole_2))
plot_skeleton(skeleton)

#Generate a roof model and specify the material
if(run_documentation()) {
  library(rayrender)
  library(rayvertex)
  scene_base = xz_rect(xwidth=100,zwidth=100,
                       material=diffuse(color="grey20", checkercolor="white")) |&gt;
    add_object(sphere(y=8,z=10,x=-3,material=light(intensity=100))) |&gt;
    add_object(sphere(y=800,z=10,x=-3,radius=100,material=light(intensity=5))) |&gt;
    add_object(sphere(x=-10,z=-10,y=5,material=light(color="red", intensity=40))) |&gt;
    add_object(sphere(x=10,z=-10,y=5,material=light(color="orange", intensity=40)))

  bevel = generate_bevel("angled", bevel_start = 0, bevel_end = 0.2, max_height=0.25)
  roof_model = generate_beveled_polygon(skeleton,
                                        bevel_offsets = bevel,
                                        material = material_list(diffuse="purple"))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,30,20), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Change the bevel to be circular
if(run_documentation()) {
  bevel = generate_bevel("circular", bevel_start = 0, bevel_end = 0.2, max_height=0.25)
  roof_model = generate_beveled_polygon(skeleton,
                                        bevel_offsets = bevel,
                                        material = material_list(diffuse="purple"))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,30,20), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Change the bevel to type "bump", change the max height, and raise it off the surface
if(run_documentation()) {
  bevel = generate_bevel("bump", bevel_start = 0, bevel_end = 0.4, max_height=0.25)
  roof_model = generate_beveled_polygon(skeleton, base_height=1,
                                        bevel_offsets = bevel,
                                        material = material_list(diffuse="purple"))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,30,20), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Generate a complex bevel and use the exact specified heights
if(run_documentation()) {
  bevel = generate_complex_bevel(c("bump", "exp", "circular","step"),
                                 bevel_start = c(0,0.3,0.7,0.95),
                                 bevel_end = c(0.1,0.6,0.95,1),
                                 reverse = c(F,F,T,F),
                                 segment_height = c(0.25,0.5,0.5,4),
                                 plot_bevel = TRUE)

  roof_model = generate_beveled_polygon(skeleton, vertical_offset=0.1,
                                        bevel_offsets = bevel,
                                        raw_heights = TRUE,
                                        material = material_list(diffuse="purple"))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,30,20), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Turn the polygon into a ziggurat, using the step bevel type
if(run_documentation()) {
  offs = seq(0, 1, by = 0.05)
  bevel = generate_complex_bevel("step",
                                 bevel_start = offs[-length(offs)],
                                 bevel_end = offs[-1],
                                 segment_height = 0.2)

  roof_model = generate_beveled_polygon(skeleton, vertical_offset=0.2,
                                        bevel_offsets = bevel,
                                        raw_heights = TRUE,
                                        material = material_list(diffuse = "purple"))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom = c(10,30,20), sample_method = "sobol_blue",
                 width = 800, height = 800, fov = 0, ortho_dimensions = c(10,10))
}

# Turn the polygon into a smooth wavy slide, taking advantage of vector recycling to flip/reverse
if(run_documentation()) {
  offs = seq(0, 1, by = 0.1)
  bevel = generate_complex_bevel("exp",
                                 bevel_start = offs[-length(offs)],
                                 bevel_end = offs[-1],
                                 reverse = c(TRUE, FALSE),
                                 flip = c(TRUE, FALSE),
                                 segment_height = 0.25)

  roof_model = generate_beveled_polygon(skeleton, vertical_offset=0.2,
                                        bevel_offsets = bevel,
                                        raw_heights = TRUE,
                                        material = material_list(diffuse = "purple"))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom = c(10,30,20), sample_method = "sobol_blue",
                 width = 800, height = 800, fov = 0, ortho_dimensions = c(10,10))
}

# Skeletonize and turn an {sf} object into a beveled polygon
if(run_documentation()) {
  us_states = spData::us_states
  texas = us_states[us_states$NAME == "Texas",]
  texas_skeleton = skeletonize(texas)
  plot_skeleton(texas_skeleton)

  bevel = generate_bevel("angled" , bevel_end=0.3, max_height = 0.3)
  roof_model_texas = generate_beveled_polygon(texas_skeleton,
                                        bevel_offsets = bevel,
                                        material = material_list(diffuse = "purple")) |&gt;
    center_mesh() |&gt;
    translate_mesh(c(0,0.3,0))

  raymesh_model(roof_model_texas, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    add_object(sphere(x=-10,z=-10,y=5,material=light(color="red", intensity=40))) |&gt;
    add_object(sphere(x=10,z=-10,y=5,material=light(color="orange", intensity=40))) |&gt;
    render_scene(lookfrom=c(0,10,0),camera_up=c(0,0,1), sample_method = "sobol_blue",
                 width=800,height=800,fov=0, ortho_dimensions=c(15,15))
}

# Generate a smooth bevel
if(run_documentation()) {
  bevel = generate_bevel("exp", bevel_start = 0, bevel_end=0.5, max_height=2)
  roof_model_texas = generate_beveled_polygon(texas_skeleton,
                                        bevel_offsets = bevel,
                                        material = material_list(diffuse = "purple")) |&gt;
    center_mesh() |&gt;
    translate_mesh(c(0,0.5,0))

  raymesh_model(roof_model_texas, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    add_object(sphere(x=-10,z=-10,y=5,material=light(color="red", intensity=40))) |&gt;
    add_object(sphere(x=10,z=-10,y=5,material=light(color="orange", intensity=40))) |&gt;
    render_scene(lookfrom=c(0,10,0),camera_up=c(0,0,1), sample_method = "sobol_blue",
                 width=800,height=800,fov=0, ortho_dimensions=c(15,15))
}
</code></pre>

<hr>
<h2 id='generate_complex_bevel'>Generate Complex 2D Bevel Profile for 3D Polygons</h2><span id='topic+generate_complex_bevel'></span>

<h3>Description</h3>

<p>All arguments are recycled to the length of the longest argument, allowing for the generation of
complex and repetitive bevel patterns without manual replication of argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_complex_bevel(
  bevel_type,
  bevel_start = 0,
  bevel_end = 1,
  segment_height = 1,
  angle = 45,
  curve_points = 30,
  reverse = FALSE,
  flip = FALSE,
  manual_offsets = NULL,
  add_end_points = TRUE,
  plot_bevel = FALSE,
  overall_height = NA,
  set_minimum_zero = TRUE,
  zero_offset_epsilon = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_complex_bevel_+3A_bevel_type">bevel_type</code></td>
<td>
<p>Vector of bevel types. Options are: '&quot;circular&quot;', '&quot;exp&quot;', '&quot;bump&quot;', '&quot;step&quot;', '&quot;block&quot;', '&quot;angled&quot;'.
Note that for the '&quot;step&quot;' type, the transition occurs at 'bevel_start'.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_bevel_start">bevel_start</code></td>
<td>
<p>Numeric vector of values between '0' and '1'.
Percentage distance in the interior the polygon at which to begin the corresponding 'bevel_type'. Note that for the '&quot;step&quot;' type, this is ignored.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_bevel_end">bevel_end</code></td>
<td>
<p>Numeric vector of values between '0' and '1'.
Percentage distance in the interior the polygon at which to end the corresponding 'bevel_type'.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_segment_height">segment_height</code></td>
<td>
<p>Numeric vector. The maximum heights of each bevel, as measured from the initial height at the end of the previous bevel.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_angle">angle</code></td>
<td>
<p>Default 'NULL'. Numeric vector. Optional angle parameter in degrees for angular bevels (overrides values in 'max_height').</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_curve_points">curve_points</code></td>
<td>
<p>Default '50'. Integer vector of number of points for each curve.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_reverse">reverse</code></td>
<td>
<p>Default 'FALSE'. Whether to reverse each bevel.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_flip">flip</code></td>
<td>
<p>Default 'FALSE'. Whether to reverse each bevel horizontally.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_manual_offsets">manual_offsets</code></td>
<td>
<p>Default 'NULL', none. This will force the bevel to add a point (interpolating between the two nearest points)
at the specified offsets. This is useful when you want to add points at specific distances along the curve.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_add_end_points">add_end_points</code></td>
<td>
<p>Default 'TRUE'. Whether to ensure there is a point at zero and a point at one.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_plot_bevel">plot_bevel</code></td>
<td>
<p>Default 'FALSE'. Whether to plot the resulting bevel.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_overall_height">overall_height</code></td>
<td>
<p>Default 'NA'. Numeric value specifying the overall height of the curve.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_set_minimum_zero">set_minimum_zero</code></td>
<td>
<p>Default &lsquo;TRUE'. Whether to offset the lowest point of the bevel so it&rsquo;s at zero.</p>
</td></tr>
<tr><td><code id="generate_complex_bevel_+3A_zero_offset_epsilon">zero_offset_epsilon</code></td>
<td>
<p>Default '1e-5'. Amount to offset the bevel to ensure no self-intersection with the base.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing 'x' and 'y', which are the coordinates of the complex 2D bevel profile
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a complex bevel profile and plot it
complex_coords = generate_complex_bevel(
  bevel_type  = c("circular", "bump", "step", "block", "angled"),
  bevel_start = c(0,   0.2, 0.6, 0.7, 0.9),
  bevel_end   = c(0.2, 0.5, 0.7, 0.8, 1.0),
  segment_height  = c(0.1, 0.2, 0.2, 0.2, 0.4),
  angle = 45,
  curve_points = c(50, 50, 50, 1, 1),
  reverse = c(FALSE, TRUE, FALSE, FALSE, FALSE),
  plot_bevel = TRUE
)
# Create a step function with reverses to generate a square wave pattern
complex_coords = generate_complex_bevel(
  bevel_type  = "step",
  bevel_start = head(seq(0,1,by=0.05),-1),
  bevel_end   = 1,
  segment_height  = 0.1,
  angle = 45,
  reverse = c(FALSE, TRUE),
  plot_bevel = TRUE
)
#Generate an increasing sawtooth pattern with angles
complex_coords = generate_complex_bevel(
  bevel_type  = "angled",
  bevel_start = head(seq(0,1,by=0.05),-1),
  bevel_end   = tail(seq(0,1,by=0.05),-1),
  segment_height  = 0.1,
  angle = c(45,30),
  reverse = c(FALSE, TRUE),
  plot_bevel = TRUE
)
# Create a step function to turn polygons into a ziggurat (note bevel_end is ignored)
complex_coords = generate_complex_bevel(
  bevel_type  = "step",
  bevel_start = head(seq(0,1,by=0.05),-1),
  bevel_end   = 1,
  segment_height  = 0.1,
  reverse = FALSE,
  plot_bevel = TRUE
)
</code></pre>

<hr>
<h2 id='generate_offset_links_nodes'>Generate Offset Polygon</h2><span id='topic+generate_offset_links_nodes'></span>

<h3>Description</h3>

<p>Generate Offset Polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_offset_links_nodes(
  ss,
  offsets,
  return_polys = FALSE,
  progress = FALSE,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='generate_offset_polygon'>Generate an offset polygon</h2><span id='topic+generate_offset_polygon'></span>

<h3>Description</h3>

<p>This function generates an interior offset polygon from a straight skeleton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_offset_polygon(skeleton, offset, progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_offset_polygon_+3A_skeleton">skeleton</code></td>
<td>
<p>Default 'NULL'. A straight skeleton generated from the 'skeletonize' function.</p>
</td></tr>
<tr><td><code id="generate_offset_polygon_+3A_offset">offset</code></td>
<td>
<p>Default 'NULL'. The offset(s) of the polygon.</p>
</td></tr>
<tr><td><code id="generate_offset_polygon_+3A_progress">progress</code></td>
<td>
<p>Default 'FALSE'. Whether to display a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, each representing a polygon offset by the specified amount.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple polygon example
simple_poly = matrix(c(0,0, 3,0, 3,3, 0,3, 0,0), ncol=2, byrow=TRUE)
skeleton = skeletonize(simple_poly)
offset_polys = generate_offset_polygon(skeleton, c(0.25, 0.5))
print(offset_polys)

# Polygon with hole example
# Outer polygon
vertices = matrix(c(0,0, 7,0, 7,7, 0,7, 0,0), ncol = 2, byrow = TRUE)
# Holes inside the polygon
hole_1 = matrix(c(1,1, 2,1, 2,2, 1,2, 1,1), ncol = 2, byrow = TRUE)[5:1,]
hole_2 = matrix(c(5,5, 6,5, 6,6, 5,6, 5,5), ncol = 2, byrow = TRUE)[5:1,]
skeleton = skeletonize(vertices, holes = list(hole_1, hole_2))
plot_skeleton(skeleton)

#Generate three offsets
plot_offset_polygon(generate_offset_polygon(skeleton, c(0.25,0.75,1.5,2)))

#Generate many offsets
plot_offset_polygon(generate_offset_polygon(skeleton, seq(0,2.5,by=0.1)+0.05))

# Skeletonize and plot an {sf} object
if(length(find.package("spData",quiet = TRUE)) &gt; 0) {
  us_states = spData::us_states
  texas = us_states[us_states$NAME == "Texas",]
  texas_skeleton = skeletonize(texas)
  plot_offset_polygon(generate_offset_polygon(texas_skeleton, seq(0, 2.5, by = 0.1)),
                      border = heat.colors,
                      linewidth = 1)
}
</code></pre>

<hr>
<h2 id='generate_roof'>Generate a 3D roof model</h2><span id='topic+generate_roof'></span>

<h3>Description</h3>

<p>This function generates a 3D roof model from a straight skeleton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_roof(
  skeleton,
  max_height = NA,
  vertical_offset = 0,
  base = FALSE,
  base_height = 0,
  angle = 45,
  sides = FALSE,
  double_sided = FALSE,
  scale_all_max = FALSE,
  swap_yz = TRUE,
  progress = TRUE,
  material = material_list(),
  roof_material = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_roof_+3A_skeleton">skeleton</code></td>
<td>
<p>Default 'NULL'. A straight skeleton generated from the 'skeletonize' function.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_max_height">max_height</code></td>
<td>
<p>Default 'NA'. The maximum height of the roof.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_vertical_offset">vertical_offset</code></td>
<td>
<p>Default '0'. The vertical offset of the roof.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_base">base</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether to generate the bottom of the roof.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_base_height">base_height</code></td>
<td>
<p>Default 'vertical_offset'. Height of the base.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_angle">angle</code></td>
<td>
<p>Default '45'. Angle of the roof.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_sides">sides</code></td>
<td>
<p>Default 'FALSE'. A logical flag on whether to draw the sides. This will automatically be set to 'TRUE'
if 'base = TRUE' and the 'base_height' is less than 'vertical_offset'.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_double_sided">double_sided</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether the polygon should be double-sided.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_scale_all_max">scale_all_max</code></td>
<td>
<p>Default 'FALSE'. If passing in a list of multiple skeletons with polygons, whether to scale each polygon to the overall
max height, or whether to scale each max height to the maximum internal distance in the polygon.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether to swap the y and z coordinates in the resulting mesh.
If 'TRUE', the y and z coordinates will be swapped.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. A logical flag to control whether a progress bar is displayed during roof generation.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_material">material</code></td>
<td>
<p>Default 'material_list()'. Interface to set the color/appearance/material options for the resulting 'ray_mesh' mesh.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_roof_material">roof_material</code></td>
<td>
<p>Default 'NA', uses the material specified in 'material'. Interface to set the color/appearance/material options for the resulting 'ray_mesh' rooftop mesh.</p>
</td></tr>
<tr><td><code id="generate_roof_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. A logical flag to control whether additional timing information should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D mesh of the roof model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate vertices and holes
vertices = matrix(c(0,0, 7,0, 7,7, 0,7, 0,0), ncol = 2, byrow = TRUE)-3.5
hole_1 = matrix(c(1,1, 2,1, 2,2, 1,2, 1,1), ncol = 2, byrow = TRUE)[5:1,]-3.5
hole_2 = matrix(c(5,5, 6,5, 6,6, 5,6, 5,5), ncol = 2, byrow = TRUE)[5:1,]-3.5
skeleton = skeletonize(vertices, holes = list(hole_1, hole_2))
if(run_documentation()) {
plot_skeleton(skeleton)
}

#Generate a roof model and specify the material
if(run_documentation()) {
  library(rayrender)
  library(rayvertex)
  roof_model = generate_roof(skeleton, material = material_list(diffuse="purple"))
  scene_base = xz_rect(xwidth=100,zwidth=100,
                       material=diffuse(color="grey20", checkercolor="white")) |&gt;
    add_object(sphere(y=8,z=10,x=-3,material=light(intensity=100))) |&gt;
    add_object(sphere(y=800,z=10,x=-3,radius=100,material=light(intensity=5)))

  raymesh_model(roof_model, override_material = FALSE) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,30,20), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Change the maximum height of the roof
if(run_documentation()) {
  roof_model = generate_roof(skeleton, max_height=5)
  raymesh_model(roof_model, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,30,20), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

#Add a vertical_offset to the roof, without a base
if(run_documentation()) {
  roof_model = generate_roof(skeleton, vertical_offset = 2, base = FALSE)
  raymesh_model(roof_model, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,10,20), lookat=c(0,2,0), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Add a base
if(run_documentation()) {
  roof_model = generate_roof(skeleton, vertical_offset = 2, base = TRUE)
  raymesh_model(roof_model, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,10,20), lookat=c(0,2,0), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}

# Change the base height (note that the vertical_offset is measured from the base, not from zero)
if(run_documentation()) {
  roof_model = generate_roof(skeleton, vertical_offset = 2, base = TRUE, base_height=1)
  raymesh_model(roof_model, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    render_scene(lookfrom=c(10,10,20), lookat=c(0,2,0), sample_method = "sobol_blue",
                 width=800,height=800,fov=0,ortho_dimensions=c(10,10))
}


# Skeletonize and turn an {sf} object into a roof
if(run_documentation()) {
  us_states = spData::us_states
  cali = us_states[us_states$NAME == "California",]
  cali_skeleton = skeletonize(cali)
  plot_skeleton(cali_skeleton)
  roof_model_cali = generate_roof(cali_skeleton, max_height = 2) |&gt;
    center_mesh() |&gt;
    translate_mesh(c(0,1,0))

  raymesh_model(roof_model_cali, material = diffuse(color="purple")) |&gt;
    add_object(scene_base) |&gt;
    add_object(sphere(x=-10,z=-10,y=4,material=light(color="red", intensity=40))) |&gt;
    add_object(sphere(x=10,z=-10,y=4,material=light(color="orange", intensity=40))) |&gt;
    render_scene(lookfrom=c(0,10,-1), sample_method = "sobol_blue",
                 width=800,height=800,fov=0, ortho_dimensions=c(12,12))
}
</code></pre>

<hr>
<h2 id='get_time'>Get time</h2><span id='topic+get_time'></span>

<h3>Description</h3>

<p>Get time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_time(init = TRUE)
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='identify_maxima_nodes'>Identify Local and Global Maxima Nodes</h2><span id='topic+identify_maxima_nodes'></span>

<h3>Description</h3>

<p>Identify Local and Global Maxima Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_maxima_nodes(straight_skeleton)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_maxima_nodes_+3A_straight_skeleton">straight_skeleton</code></td>
<td>
<p>The straight skeleton object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containting maxima ids
</p>

<hr>
<h2 id='init_time'>Print time</h2><span id='topic+init_time'></span>

<h3>Description</h3>

<p>Print time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_time()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='insert_polygon_links_nodes'>Insert Polygon Links/Nodes</h2><span id='topic+insert_polygon_links_nodes'></span>

<h3>Description</h3>

<p>Insert Polygon Links/Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_polygon_links_nodes(ss, new_links_all)
</code></pre>

<hr>
<h2 id='interpolate_location'>Interpolate Location</h2><span id='topic+interpolate_location'></span>

<h3>Description</h3>

<p>Interpolate Location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_location(node_start, node_end, height_start, height_end, height)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_location_+3A_node_start">node_start</code></td>
<td>
<p>Length-2 Numeric x/y position</p>
</td></tr>
<tr><td><code id="interpolate_location_+3A_node_end">node_end</code></td>
<td>
<p>Length-2 Numeric x/y position</p>
</td></tr>
<tr><td><code id="interpolate_location_+3A_height_start">height_start</code></td>
<td>
<p>Length-1 Numeric height at start node</p>
</td></tr>
<tr><td><code id="interpolate_location_+3A_height_end">height_end</code></td>
<td>
<p>Length-1 Numeric height at end node</p>
</td></tr>
<tr><td><code id="interpolate_location_+3A_height">height</code></td>
<td>
<p>Length-1 Numeric height at which to interpolate</p>
</td></tr>
</table>

<hr>
<h2 id='make_incremental_nodes'>Make incremental nodes</h2><span id='topic+make_incremental_nodes'></span>

<h3>Description</h3>

<p>Make incremental nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_incremental_nodes(ss)
</code></pre>

<hr>
<h2 id='modify_bevel_with_skeleton'>Modify bevel data using straight skeleton</h2><span id='topic+modify_bevel_with_skeleton'></span>

<h3>Description</h3>

<p>Modify bevel data using straight skeleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_bevel_with_skeleton(bevel_offsets, bevel_heights, straight_skeleton)
</code></pre>


<h3>Value</h3>

<p>list. Modified bevel_height and bevel_offset vectors.
</p>

<hr>
<h2 id='plot_offset_polygon'>Plot Offset Polygons</h2><span id='topic+plot_offset_polygon'></span>

<h3>Description</h3>

<p>Plot the offset polygons generated by the 'generate_offset_polygon' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_offset_polygon(
  offset_polygons,
  plot_original_polygon = TRUE,
  fill = NA,
  color = "dodgerblue",
  xlim = NULL,
  ylim = NULL,
  linewidth = 1,
  background = "white",
  plot_skeleton = FALSE,
  return_layers = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_offset_polygon_+3A_offset_polygons">offset_polygons</code></td>
<td>
<p>Default 'NULL'. A 'rayskeleton_polygon' or 'rayskeleton_polygon_list' object, generated from
'generate_offset_polygon()'.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_plot_original_polygon">plot_original_polygon</code></td>
<td>
<p>Default 'TRUE'. Whether to plot the original polygon.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_fill">fill</code></td>
<td>
<p>Default &lsquo;NULL'. A color or palette function to generate the fill palette for the polygons&rsquo; interiors.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_color">color</code></td>
<td>
<p>Default &lsquo;grDevices::heat.colors'.  A color or palette function to generate the color palette for the offset polygons&rsquo; borders.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_xlim">xlim</code></td>
<td>
<p>Default 'NULL'. The x-axis limits as a vector of two values (min, max). If 'NULL', it calculates the limits from the data.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_ylim">ylim</code></td>
<td>
<p>Default 'NULL'. The y-axis limits as a vector of two values (min, max). If 'NULL', it calculates the limits from the data.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_linewidth">linewidth</code></td>
<td>
<p>Default '1'. The linewidth of the polygon.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_background">background</code></td>
<td>
<p>Default '&quot;white&quot;'. Background color.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_plot_skeleton">plot_skeleton</code></td>
<td>
<p>Default 'FALSE'. Whether to plot the straight skeleton.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_return_layers">return_layers</code></td>
<td>
<p>Default 'FALSE', plots the figure. If 'TRUE', this will instead
return a list of the ggplot layers.</p>
</td></tr>
<tr><td><code id="plot_offset_polygon_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to 'plot_skeleton()' if 'plot_skeleton = TRUE'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot showing the offset polygons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Outer polygon
vertices = matrix(c(0,0, 7,0, 7,7, 0,7, 0,0), ncol = 2, byrow = TRUE)
# Holes inside the polygon
hole_1 = matrix(c(1,1, 2,1, 2,2, 1,2, 1,1), ncol = 2, byrow = TRUE)[5:1,]
hole_2 = matrix(c(5,5, 6,5, 6,6, 5,6, 5,5), ncol = 2, byrow = TRUE)[5:1,]
skeleton = skeletonize(vertices, holes = list(hole_1, hole_2))
plot_skeleton(skeleton)

#Generate three offsets with the skeleton
plot_offset_polygon(generate_offset_polygon(skeleton, c(0.25,0.75,1.5,2)), plot_skeleton = TRUE)

#Generate many offsets
plot_offset_polygon(generate_offset_polygon(skeleton, seq(0.05,2.55,by=0.1)))

#Pass a palette
plot_offset_polygon(generate_offset_polygon(skeleton, seq(0.05,2.55,by=0.1)),
                    color = heat.colors)

#Pass colors manually (colors in excess of the number of offsets are ignored)
plot_offset_polygon(generate_offset_polygon(skeleton, seq(0.05,2.55,by=0.1)),
                    color = rep(c("red","red","blue","blue"),100))

# Skeletonize and plot an {sf} object
if(length(find.package("spData",quiet = TRUE)) &gt; 0) {
  us_states = spData::us_states
  texas = us_states[us_states$NAME == "Texas",]
  texas_skeleton = skeletonize(texas)
  plot_offset_polygon(generate_offset_polygon(texas_skeleton, seq(0, 2.5, by = 0.1)),
                      color = heat.colors,
                      linewidth = 1)
}
</code></pre>

<hr>
<h2 id='plot_skeleton'>Plot the Straight Skeleton of a Polygon</h2><span id='topic+plot_skeleton'></span>

<h3>Description</h3>

<p>This function visualizes the straight skeleton derived from a given polygon.
The original polygon (with holes if present) is plotted in black, while the
straight skeleton is plotted in red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_skeleton(
  skeleton,
  use_arrow = TRUE,
  use_points = TRUE,
  xlim = c(0, 1),
  ylim = c(0, 1),
  arrow_color = "red",
  polygon_color = "black",
  size = 1,
  arrow_size = 0.05,
  highlight_links = NULL,
  highlight_color = "green",
  return_layers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_skeleton_+3A_skeleton">skeleton</code></td>
<td>
<p>A list object of class 'rayskeleton' containing the straight
skeleton details. It should have 'nodes' and 'links' as its primary components.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_use_arrow">use_arrow</code></td>
<td>
<p>Default 'TRUE'. A logical value indicating whether or not to use arrows
to represent the links of the straight skeleton. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_use_points">use_points</code></td>
<td>
<p>Default 'TRUE'. Whether to plot the vertex points as well.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_xlim">xlim</code></td>
<td>
<p>Default'c(0,1)'. A numeric vector of length 2 specifying the x-limits of the
plot in the form 'c(min, max)'. These are proportional limits relative
to the bounding box around the skeleton.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_ylim">ylim</code></td>
<td>
<p>Default 'c(0,1)'. A numeric vector of length 2 specifying the y-limits of the
plot in the form c(min, max). These are proportional limits relative
to the bounding box around the skeleton.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_arrow_color">arrow_color</code></td>
<td>
<p>Default '&quot;red&quot;'. Color of the arrows.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_polygon_color">polygon_color</code></td>
<td>
<p>Default '&quot;black&quot;'. Color of the polygon.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_size">size</code></td>
<td>
<p>Default '1'. Size of the vertex points.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_arrow_size">arrow_size</code></td>
<td>
<p>Default '1'. Scales the arrow size.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_highlight_links">highlight_links</code></td>
<td>
<p>Default 'NULL'. A numeric vector indicating which links
(by their index) to highlight. If specified, the corresponding links will
be colored with the 'highlight_color'.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_highlight_color">highlight_color</code></td>
<td>
<p>Default '&quot;purple&quot;'. Color of the highlighted links.</p>
</td></tr>
<tr><td><code id="plot_skeleton_+3A_return_layers">return_layers</code></td>
<td>
<p>Default 'FALSE', plots the figure. If 'TRUE', this will instead
return a list of the ggplot layers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'ggplot2' package for plotting. The straight skeleton
is visualized based on the details provided in the 'skeleton' object.
The original polygon and holes are plotted based on attributes stored
in the 'skeleton' object.
</p>


<h3>Value</h3>

<p>A ggplot object visualizing the straight skeleton and the original polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assuming skeleton1 is already defined as in the previous example
# Outer polygon
vertices = matrix(c(0,0, 7,0, 7,7, 0,7, 0,0), ncol = 2, byrow = TRUE)
# Holes inside the polygon
hole1 = matrix(c(1,1, 1,2, 2,2, 2,1, 1,1), ncol = 2, byrow = TRUE)
hole2 = matrix(c(5,5, 5,6, 6,6, 6,5, 5,5), ncol = 2, byrow = TRUE)
skeleton = skeletonize(vertices, holes = list(hole1, hole2))
if(length(find.package("ggplot2",quiet = TRUE)) &gt; 0) {
  plot_skeleton(skeleton)
}
# Skeletonize and plot an {sf} object
if(length(find.package("spData",quiet = TRUE)) &gt; 0) {
  us_states = spData::us_states
  texas = us_states[us_states$NAME == "Texas",]
  plot_skeleton(skeletonize(texas))
}
# Highlighting certain links in the skeleton
max_links =which(skeleton$links$destination_time == max(skeleton$links$destination_time))
if(length(find.package("ggplot2",quiet = TRUE)) &gt; 0) {
  plot_skeleton(skeleton, highlight_links = max_links, highlight_color = "green")
}
</code></pre>

<hr>
<h2 id='print_time'>Print time</h2><span id='topic+print_time'></span>

<h3>Description</h3>

<p>Print time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_time(verbose = FALSE, message_text = "")
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='process_sliced_links'>Process sliced links</h2><span id='topic+process_sliced_links'></span>

<h3>Description</h3>

<p>Process sliced links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_sliced_links(link_group)
</code></pre>

<hr>
<h2 id='recalculate_ordered_ids'>Recalculate Ordered IDs</h2><span id='topic+recalculate_ordered_ids'></span>

<h3>Description</h3>

<p>Recalculate Ordered IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalculate_ordered_ids(skeleton)
</code></pre>

<hr>
<h2 id='remove_node_duplicates'>Remove Node Duplicates</h2><span id='topic+remove_node_duplicates'></span>

<h3>Description</h3>

<p>Replace dup
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_node_duplicates(ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_node_duplicates_+3A_ss">ss</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='remove_reversed_links'>Remove Reversed Links</h2><span id='topic+remove_reversed_links'></span>

<h3>Description</h3>

<p>Remove Reversed Links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_reversed_links(skeleton)
</code></pre>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>This function determines if the examples are being run in pkgdown. It is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>Boolean value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See if the documentation should be run.
run_documentation()
</code></pre>

<hr>
<h2 id='skeletonize'>Skeletonize a polygon</h2><span id='topic+skeletonize'></span>

<h3>Description</h3>

<p>This function generates a straight skeleton of a polygon, based on a set of vertices and holes.
It uses the CGAL library to create the straight skeleton using exact arithmetic,
and then parses that file into a more manageable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeletonize(
  vertices,
  holes = list(),
  debug = FALSE,
  merge_nodes_tolerance = 1e-05,
  return_raw_ss = FALSE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeletonize_+3A_vertices">vertices</code></td>
<td>
<p>Default 'NULL'. A matrix of x and y coordinates representing the vertices of the polygon in counter-clockwise (CCW) order.</p>
</td></tr>
<tr><td><code id="skeletonize_+3A_holes">holes</code></td>
<td>
<p>Default 'list()'. A list of matrices, each representing a hole in the polygon with x and y coordinates in clockwise (CW) order.</p>
</td></tr>
<tr><td><code id="skeletonize_+3A_debug">debug</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether debugging information should be printed.</p>
</td></tr>
<tr><td><code id="skeletonize_+3A_merge_nodes_tolerance">merge_nodes_tolerance</code></td>
<td>
<p>Default '1e-5'. A numeric value specifying the tolerance level for merging nodes. It should be a value between 0 and 1.
This value species the size of the grid that the nodes are snapped to determining identical nodes.</p>
</td></tr>
<tr><td><code id="skeletonize_+3A_return_raw_ss">return_raw_ss</code></td>
<td>
<p>Default 'FALSE'. A logical flag that controls whether the raw straight skeleton should be returned.</p>
</td></tr>
<tr><td><code id="skeletonize_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. A logical flag that controls whether a progress bar should be displayed while skeletonizing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If &lsquo;return_raw_ss' is FALSE, a list with two data frames, &rsquo;nodes' and 'links', which represent the nodes and edges of the straight skeleton, respectively.
If 'return_raw_ss' is TRUE, a data frame representing the raw straight skeleton is returned.
If the polygon is not simple, a warning is issued and NULL is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Simple rectangle polygon with no holes
vertices1 = matrix(c(0,0, 4,0, 4,3, 0,3, 0,0), ncol = 2, byrow = TRUE)
skeleton1 = skeletonize(vertices1)
plot_skeleton(skeleton1)

# Example 2: Triangle polygon with no holes
vertices2 = matrix(c(0,0, 2,0, 1,2, 0,0), ncol = 2, byrow = TRUE)
skeleton2 = skeletonize(vertices2)
plot_skeleton(skeleton2)

# Example 3: Polygon with a hole
# Outer polygon
vertices3 = matrix(c(0,0, 5,0, 5,5, 0,5, 0,0), ncol = 2, byrow = TRUE)
# Hole inside the polygon
hole3 = matrix(c(1,1, 4,1, 4,4, 1,4, 1,1), ncol = 2, byrow = TRUE)[5:1,]
skeleton3 = skeletonize(vertices3, holes = list(hole3))
plot_skeleton(skeleton3)

# Example 4: Polygon with multiple holes
# Outer polygon
vertices4 = matrix(c(0,0, 7,0, 7,7, 0,7, 0,0), ncol = 2, byrow = TRUE)
# Holes inside the polygon
hole4_1 = matrix(c(1,1, 2,1, 2,2, 1,2, 1,1), ncol = 2, byrow = TRUE)[5:1,]
hole4_2 = matrix(c(5,5, 6,5, 6,6, 5,6, 5,5), ncol = 2, byrow = TRUE)[5:1,]
skeleton4 = skeletonize(vertices4, holes = list(hole4_1, hole4_2))
plot_skeleton(skeleton4)

# Example 5: Using debug and returning raw straight skeleton
vertices5 = matrix(c(0,0, 3,0, 3,3, 0,3, 0,0), ncol = 2, byrow = TRUE)
raw_skeleton5 = skeletonize(vertices5, debug = TRUE, return_raw_ss = TRUE)

# Skeletonize and plot an {sf} object
if(length(find.package("spData",quiet = TRUE)) &gt; 0) {
  us_states = spData::us_states
  texas = us_states[us_states$NAME == "Texas",]
  plot_skeleton(skeletonize(texas))
}
</code></pre>

<hr>
<h2 id='swap_yz'>Extrude Sides of Polygon</h2><span id='topic+swap_yz'></span>

<h3>Description</h3>

<p>Extrude Sides of Polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_yz(mesh)
</code></pre>

<hr>
<h2 id='unit_vector'>Dot Product</h2><span id='topic+unit_vector'></span>

<h3>Description</h3>

<p>Dot Product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_vector(v)
</code></pre>


<h3>Value</h3>

<p>Value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#None
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
