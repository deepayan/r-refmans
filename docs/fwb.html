<!DOCTYPE html><html><head><title>Help for package fwb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fwb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fwb-package'><p>fwb: Fractional Weighted Bootstrap</p></a></li>
<li><a href='#bearingcage'><p>Bearing Cage field failure data</p></a></li>
<li><a href='#fwb'><p>Fractional Weighted Bootstrap</p></a></li>
<li><a href='#fwb.ci'><p>Fractional Weighted Bootstrap Confidence Intervals</p></a></li>
<li><a href='#get_ci'><p>Extract Confidence Intervals from a <code>bootci</code> Object</p></a></li>
<li><a href='#plot.fwb'><p>Plots of the Output of a Fractional Weighted Bootstrap</p></a></li>
<li><a href='#set_fwb_wtype'><p>Set weights type</p></a></li>
<li><a href='#summary.fwb'><p>Summarize <code>fwb</code> Output</p></a></li>
<li><a href='#vcovFWB'><p>Fractional Weighted Bootstrap Covariance Matrix Estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fractional Weighted Bootstrap</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the fractional weighted bootstrap to be used as a drop-in for functions in
   the 'boot' package. The fractional weighted bootstrap (also known as the Bayesian bootstrap) involves drawing
   weights randomly that are applied to the data rather than resampling units from the data. See Xu et al. (2020)
   &lt;<a href="https://doi.org/10.1080%2F00031305.2020.1731599">doi:10.1080/00031305.2020.1731599</a>&gt; for details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, chk, pbapply, stats, utils, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, boot, sandwich (&ge; 2.4-0), lmtest, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ngreifer/fwb">https://github.com/ngreifer/fwb</a>, <a href="https://ngreifer.github.io/fwb/">https://ngreifer.github.io/fwb/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ngreifer/fwb/issues">https://github.com/ngreifer/fwb/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 22:27:39 UTC; NoahGreifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noah Greifer &lt;noah.greifer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 02:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fwb-package'>fwb: Fractional Weighted Bootstrap</h2><span id='topic+fwb-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>An implementation of the fractional weighted bootstrap to be used as a drop-in for functions in the 'boot' package. The fractional weighted bootstrap (also known as the Bayesian bootstrap) involves drawing weights randomly that are applied to the data rather than resampling units from the data. See Xu et al. (2020) <a href="https://doi.org/10.1080/00031305.2020.1731599">doi:10.1080/00031305.2020.1731599</a> for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noah Greifer <a href="mailto:noah.greifer@gmail.com">noah.greifer@gmail.com</a> (<a href="https://orcid.org/0000-0003-3067-7154">ORCID</a>)
</p>


<h3>References</h3>

<p>Xu, L., Gotwalt, C., Hong, Y., King, C. B., &amp; Meeker, W. Q. (2020). Applications of the Fractional-Random-Weight Bootstrap. <em>The American Statistician</em>, 74(4), 345–358. <a href="https://doi.org/10.1080/00031305.2020.1731599">doi:10.1080/00031305.2020.1731599</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ngreifer/fwb">https://github.com/ngreifer/fwb</a>
</p>
</li>
<li> <p><a href="https://ngreifer.github.io/fwb/">https://ngreifer.github.io/fwb/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ngreifer/fwb/issues">https://github.com/ngreifer/fwb/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bearingcage'>Bearing Cage field failure data</h2><span id='topic+bearingcage'></span>

<h3>Description</h3>

<p>The data consist of 1703 aircraft engines put into service over time. There were 6 failures and 1697 right-censored observations. These data were originally given in Abernethy et al. (1983) and were reanalyzed in Meeker and Escobar (1998, chap.8). The dataset used here specifically comes from Xu et al. (2020) and are used in a Weibull analysis of failure times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bearingcage")
</code></pre>


<h3>Format</h3>

<p>A data frame with 1703 rows and 2 variables:
</p>

<dl>
<dt><code>hours</code></dt><dd><p>integer; the number of hours until failure or censoring</p>
</dd>
<dt><code>failure</code></dt><dd><p>logical; whether a failure occurred</p>
</dd>
</dl>



<h3>References</h3>

<p>Abernethy, R. B., Breneman, J. E., Medlin, C. H., and Reinman, G. L. (1983), &quot;Weibull Analysis Handbook,&quot; Technical Report, Air Force Wright Aeronautical Laboratories, available at <a href="https://apps.dtic.mil/sti/citations/ADA143100">https://apps.dtic.mil/sti/citations/ADA143100</a>.
</p>
<p>Meeker, W. Q., and Escobar, L. A. (1998), <em>Statistical Methods for Reliability Data</em>, New York: Wiley.
</p>
<p>Xu, L., Gotwalt, C., Hong, Y., King, C. B., &amp; Meeker, W. Q. (2020). Applications of the Fractional-Random-Weight Bootstrap. <em>The American Statistician</em>, 74(4), 345–358. <a href="https://doi.org/10.1080/00031305.2020.1731599">doi:10.1080/00031305.2020.1731599</a>
</p>

<hr>
<h2 id='fwb'>Fractional Weighted Bootstrap</h2><span id='topic+fwb'></span><span id='topic+print.fwb'></span>

<h3>Description</h3>

<p><code>fwb()</code> implements the fractional (random) weighted bootstrap, also known as the Bayesian bootstrap. Rather than resampling units to include in bootstrap samples, weights are drawn to be applied to a weighted estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwb(
  data,
  statistic,
  R = 999,
  cluster = NULL,
  simple = FALSE,
  wtype = getOption("fwb_wtype", "exp"),
  verbose = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'fwb'
print(x, digits = getOption("digits"), index = 1L:ncol(x$t), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwb_+3A_data">data</code></td>
<td>
<p>the dataset used to compute the statistic</p>
</td></tr>
<tr><td><code id="fwb_+3A_statistic">statistic</code></td>
<td>
<p>a function, which, when applied to <code>data</code>, returns a vector containing the statistic(s) of interest. The function should take at least two arguments; the first argument should correspond to the dataset and the second argument should correspond to a vector of weights. Any further arguments can be passed to <code>statistic</code> through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="fwb_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replicates. Default is 999 but more is always better. For the percentile bootstrap confidence interval to be exact, it can be beneficial to use one less than a multiple of 100.</p>
</td></tr>
<tr><td><code id="fwb_+3A_cluster">cluster</code></td>
<td>
<p>optional; a vector containing cluster membership. If supplied, will run the cluster bootstrap. See Details. Evaluated first in <code>data</code> and then in the global environment.</p>
</td></tr>
<tr><td><code id="fwb_+3A_simple">simple</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, weights will be computed on-the-fly in each bootstrap replication rather than all at once. This can save memory at the cost of some speed.</p>
</td></tr>
<tr><td><code id="fwb_+3A_wtype">wtype</code></td>
<td>
<p>string; the type of weights to use. Allowable options include <code>"exp"</code> (the default), <code>"pois"</code>, <code>"multinom"</code>, and <code>"mammen"</code>. See Details. See <code><a href="#topic+set_fwb_wtype">set_fwb_wtype()</a></code> to set a global default.</p>
</td></tr>
<tr><td><code id="fwb_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to display a progress bar.</p>
</td></tr>
<tr><td><code id="fwb_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, or an integer to indicate the number of child-processes (integer values are ignored on Windows) for parallel evaluations. See <code><a href="pbapply.html#topic+pblapply">pbapply::pblapply()</a></code> for details. If <code>NULL</code>, no parallelization will take place.</p>
</td></tr>
<tr><td><code id="fwb_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>statistic</code>.</p>
</td></tr>
<tr><td><code id="fwb_+3A_x">x</code></td>
<td>
<p>an <code>fwb</code> object; the output of a call to <code>fwb()</code>.</p>
</td></tr>
<tr><td><code id="fwb_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to print</p>
</td></tr>
<tr><td><code id="fwb_+3A_index">index</code></td>
<td>
<p>the index or indices of the position of the quantity of interest in <code>x$t0</code> if more than one was specified in <code>fwb()</code>. Default is to print all quantities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fwb()</code> implements the fractional weighted bootstrap and is meant to function as a drop-in for <code>boot::boot(., stype = "f")</code> (i.e., the usual bootstrap but with frequency weights representing the number of times each unit is drawn). In each bootstrap replication, when <code>wtype = "exp"</code> (the default), the weights are sampled from independent exponential distributions with rate parameter 1 and then normalized to have a mean of 1, equivalent to drawing the weights from a Dirichlet distribution. Other weights are allowed as determined by the <code>wtype</code> argument (see <code><a href="#topic+set_fwb_wtype">set_fwb_wtype()</a></code> for details). The function supplied to <code>statistic</code> must incorporate the weights to compute a weighted statistic. For example, if the output is a regression coefficient, the weights supplied to the <code>w</code> argument of <code>statistic</code> should be supplied to the <code>weights</code> argument of <code>lm()</code>. These weights should be used any time frequency weights would be, since they are meant to function like frequency weights (which, in the case of the traditional bootstrap, would be integers). Unfortunately, there is no way for <code>fwb()</code> to know whether you are using the weights correctly, so care should be taken to ensure weights are correctly incorporated into the estimator.
</p>
<p>When fitting binomial regression models (e.g., logistic) using <code><a href="stats.html#topic+glm">glm()</a></code>, it may be useful to change the <code>family</code> to a &quot;quasi&quot; variety (e.g., <code><a href="stats.html#topic+quasibinomial">quasibinomial()</a></code>) to avoid a spurious warning about &quot;non-integer #successes&quot;.
</p>
<p>The cluster bootstrap can be requested by supplying a vector of cluster membership to <code>cluster</code>. Rather than generating a weight for each unit, a weight is generated for each cluster and then applied to all units in that cluster.
</p>
<p>Ideally, <code>statistic</code> should not involve a random element, or else it will not be straightforward to replicate the bootstrap results using the <code>seed</code> included in the output object. Setting a seed using <code><a href="base.html#topic+set.seed">set.seed()</a></code> is always advised.
</p>
<p>The <code>print()</code> method displays the value of the statistics, the bias (the difference between the statistic and the mean of its bootstrap distribution), and the standard error (the standard deviation of the bootstrap distribution).
</p>


<h4>Weight types</h4>

<p>Different types of weights can be supplied to the <code>wtype</code> argument. A global default can be set using <code><a href="#topic+set_fwb_wtype">set_fwb_wtype()</a></code>. The allowable weight types are described below.
</p>

<ul>
<li> <p><code>"exp"</code>
</p>
</li></ul>

<p>Draws weights from an exponential distribution with rate parameter 1 using <code><a href="stats.html#topic+rexp">rexp()</a></code>. These weights are the usual &quot;Bayesian bootstrap&quot; weights described in Xu et al. (2020). They are equivalent to drawing weights from a uniform Dirichlet distribution, which is what gives these weights the interpretation of a Bayesian prior.
</p>

<ul>
<li> <p><code>"multinom"</code>
</p>
</li></ul>

<p>Draws integer weights using <code><a href="base.html#topic+sample">sample()</a></code>, which samples unit indices with replacement and uses the tabulation of the indices as frequency weights. This is equivalent to drawing weights from a multinomial distribution. Using <code>wtype = "multinom"</code> is the same as using <code>boot::boot(., stype = "f")</code> instead of <code>fwb()</code> (i.e., the resulting estimates will be identical).
</p>

<ul>
<li> <p><code>"poisson"</code>
</p>
</li></ul>

<p>Draws integer weights from a Poisson distribution with 1 degree of freedom using <code><a href="stats.html#topic+rpois">rpois()</a></code>. This is an alternative to the multinomial weights that yields similar estimates (especially as the sample size grows) but can be faster.
</p>

<ul>
<li> <p><code>"mammen"</code>
</p>
</li></ul>

<p>Draws weights from a modification of the distribution described by Mammen (1983) for use in the wild bootstrap. These positive weights have a mean, variance, and skewness of 1, making them second-order accurate (in contrast to the usual exponential weights, which are only first-order accurate). The weights <code class="reqn">w</code> are drawn such that <code class="reqn">P(w=(3+\sqrt{5})/2)=(\sqrt{5}-1)/2\sqrt{5}</code> and <code class="reqn">P(w=(3-\sqrt{5})/2)=(\sqrt{5}+1)/2\sqrt{5}</code>.
</p>
<p>In general, <code>"mammen"</code> should be used for all cases. <code>"exp"</code> is the default due to it being the formulation described in Xu et al. (2020) and in the most formulations of the Bayesian bootstrap; it should be used if one wants to remain in line with these guidelines or to maintain a Bayesian flavor to the analysis, whereas <code>"mammen"</code>should be preferred for its frequentist operating characteristics. <code>"multinom"</code> and <code>"poisson"</code> should only be used for comparison purposes.
</p>



<h3>Value</h3>

<p>A <code>fwb</code> object, which also inherits from <code>boot</code>, with the following components:
</p>
<table>
<tr><td><code>t0</code></td>
<td>
<p>The observed value of <code>statistic</code> applied to <code>data</code> with uniform weights.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>A matrix with <code>R</code> rows, each of which is a bootstrap replicate of the result of calling <code>statistic</code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The value of <code>R</code> as passed to <code>fwb()</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The <code>data</code> as passed to <code>fwb()</code>.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>The value of <code>.Random.seed</code> just prior to generating the weights (after the first call to <code>statistic</code> with uniform weights).</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The function <code>statistic</code> as passed to <code>fwb()</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>fwb()</code>.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>The vector passed to <code>cluster</code>, if any.</p>
</td></tr>
<tr><td><code>wtype</code></td>
<td>
<p>The type of weights used as determined by the <code>wtype</code> argument.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(fwb)</code>: Print an <code>fwb</code> object
</p>
</li></ul>


<h3>References</h3>

<p>Mammen, E. (1993). Bootstrap and Wild Bootstrap for High Dimensional Linear Models. <em>The Annals of Statistics</em>, 21(1). <a href="https://doi.org/10.1214/aos/1176349025">doi:10.1214/aos/1176349025</a>
</p>
<p>Rubin, D. B. (1981). The Bayesian Bootstrap. <em>The Annals of Statistics</em>, 9(1), 130–134. <a href="https://doi.org/10.1214/aos/1176345338">doi:10.1214/aos/1176345338</a>
</p>
<p>Xu, L., Gotwalt, C., Hong, Y., King, C. B., &amp; Meeker, W. Q. (2020). Applications of the Fractional-Random-Weight Bootstrap. <em>The American Statistician</em>, 74(4), 345–358. <a href="https://doi.org/10.1080/00031305.2020.1731599">doi:10.1080/00031305.2020.1731599</a>
</p>
<p>The use of the <code>"mammen"</code> formulation of the bootstrap weights was suggested by Lihua Lei <a href="https://twitter.com/lihua_lei_stat/status/1641538993090351106">here</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwb.ci">fwb.ci()</a></code> for calculating confidence intervals; <code><a href="#topic+summary.fwb">summary.fwb()</a></code> for displaying output in a clean way; <code><a href="#topic+plot.fwb">plot.fwb()</a></code> for plotting the bootstrap distributions; <code><a href="#topic+vcovFWB">vcovFWB()</a></code> for estimating the covariance matrix of estimates using the FWB; <code><a href="#topic+set_fwb_wtype">set_fwb_wtype()</a></code> for an example of using weights other than the default exponential weights; <code><a href="boot.html#topic+boot">boot::boot()</a></code> for the traditional bootstrap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Performing a Weibull analysis of the Bearing Cage
# failure data as done in Xu et al. (2020)
set.seed(123)
data("bearingcage")

weibull_est &lt;- function(data, w) {
  fit &lt;- survival::survreg(survival::Surv(hours, failure) ~ 1,
                           data = data, weights = w,
                           dist = "weibull")

  c(eta = unname(exp(coef(fit))), beta = 1/fit$scale)
}

boot_est &lt;- fwb(bearingcage, statistic = weibull_est,
                R = 199, verbose = FALSE)
boot_est

#Get standard errors and CIs; uses bias-corrected
#percentile CI by default
summary(boot_est, ci.type = "bc")

#Plot statistic distributions
plot(boot_est, index = "beta", type = "hist")


</code></pre>

<hr>
<h2 id='fwb.ci'>Fractional Weighted Bootstrap Confidence Intervals</h2><span id='topic+fwb.ci'></span><span id='topic+print.fwbci'></span>

<h3>Description</h3>

<p><code>fwb.ci()</code> generates several types of equi-tailed two-sided nonparametric confidence intervals. These include the normal approximation, the basic bootstrap interval, the percentile bootstrap interval, the bias-corrected percentile bootstrap interval, and the bias-correct and accelerated (BCa) bootstrap interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwb.ci(
  fwb.out,
  conf = 0.95,
  type = "bc",
  index = 1L,
  h = base::identity,
  hinv = base::identity,
  ...
)

## S3 method for class 'fwbci'
print(x, hinv = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwb.ci_+3A_fwb.out">fwb.out</code></td>
<td>
<p>an <code>fwb</code> object; the output of a call to <code><a href="#topic+fwb">fwb()</a></code>.</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_conf">conf</code></td>
<td>
<p>the desired confidence level. Default is .95 for 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_type">type</code></td>
<td>
<p>the type of confidence interval desired. Allowable options include <code>"norm"</code> (normal approximation), <code>"basic"</code> (basic interval), <code>"perc"</code> (percentile interval), <code>"bc"</code> (bias-correct percentile interval), and <code>"bca"</code> (BCa interval). More than one is allowed. Can also be <code>"all"</code> to request all of them. BCa intervals require that the number of bootstrap replications is larger than the sample size.</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_index">index</code></td>
<td>
<p>the index of the position of the quantity of interest in <code>fwb.out$t0</code> if more than one was specified in <code>fwb()</code>. Only one value is allowed at a time. By default the first statistic is used.</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_h">h</code></td>
<td>
<p>a function defining a transformation. The intervals are calculated on the scale of <code>h(t)</code> and the inverse function <code>hinv</code> applied to the resulting intervals. It must be a function of one variable only and for a vector argument, it must return a vector of the same length. Default is the identity function.</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_hinv">hinv</code></td>
<td>
<p>a function, like <code>h</code>, which returns the inverse of <code>h</code>. It is used to transform the intervals calculated on the scale of <code>h(t)</code> back to the original scale. The default is the identity function. If <code>h</code> is supplied but <code>hinv</code> is not, then the intervals returned will be on the transformed scale.</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="fwb.ci_+3A_x">x</code></td>
<td>
<p>an <code>fwbci</code> object; the output of a call to <code>fwb.ci()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fwb.ci()</code> functions similarly to <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code> in that it takes in a bootstrapped object and computes confidence intervals. This interface is a bit old-fashioned, but was designed to mimic that of <code>boot.ci()</code>. For a more modern interface, see <code><a href="#topic+summary.fwb">summary.fwb()</a></code>.
</p>
<p>The bootstrap intervals are defined as follows, with <code class="reqn">\alpha =</code> 1 - <code>conf</code>, <code class="reqn">t_0</code> the estimate in the original sample, <code class="reqn">\hat{t}</code> the average of the bootstrap estimates, <code class="reqn">s_t</code> the standard deviation of the bootstrap estimates, <code class="reqn">t^{(i)}</code> the set of ordered estimates with <code class="reqn">i</code> corresponding to their quantile, and <code class="reqn">z_\frac{\alpha}{2}</code> and <code class="reqn">z_{1-\frac{\alpha}{2}}</code> the upper and lower critical <code class="reqn">z</code> scores.
</p>

<ul>
<li> <p><code>"norm"</code> (normal approximation): <code class="reqn">[2t_0 - \hat{t} + s_t z_\frac{\alpha}{2}, 2t_0 - \hat{t} + s_t z_{1-\frac{\alpha}{2}}]</code>
</p>
</li></ul>

<p>This involves subtracting the &quot;bias&quot; (<code class="reqn">\hat{t} - t_0</code>) from the estimate <code class="reqn">t_0</code> and using a standard Wald-type confidence interval. This method is valid when the statistic is normally distributed.
</p>

<ul>
<li> <p><code>"basic"</code>: <code class="reqn">[2t_0 - t^{(1-\frac{\alpha}{2})}, 2t_0 - t^{(\frac{\alpha}{2})}]</code>
</p>
</li>
<li> <p><code>"perc"</code> (percentile confidence interval): <code class="reqn">[t^{(\frac{\alpha}{2})}, t^{(1-\frac{\alpha}{2})}]</code>
</p>
</li>
<li> <p><code>"bc"</code> (bias-corrected percentile confidence interval): <code class="reqn">[t^{(l)}, t^{(u)}]</code>
</p>
</li></ul>

<p><code class="reqn">l = \Phi\left(2z_0 + z_\frac{\alpha}{2}\right)</code>, <code class="reqn">u = \Phi\left(2z_0 + z_{1-\frac{\alpha}{2}}\right)</code>, where <code class="reqn">\Phi(.)</code> is the normal cumulative density function (i.e., <code><a href="stats.html#topic+pnorm">pnorm()</a></code>) and <code class="reqn">z_0 = \Phi^{-1}(q)</code> where <code class="reqn">q</code> is the proportion of bootstrap estimates less than the original estimate <code class="reqn">t_0</code>. This is similar to the percentile confidence interval but changes the specific quantiles of the bootstrap estimates to use, correcting for bias in the original estimate. It is described in Xu et al. (2020). When <code class="reqn">t^0</code> is the median of the bootstrap distribution, the <code>"perc"</code> and <code>"bc"</code> intervals coincide.
</p>

<ul>
<li> <p><code>"bca"</code> (bias-corrected and accelerated confidence interval): <code class="reqn">[t^{(l)}, t^{(u)}]</code>
</p>
</li></ul>

<p><code class="reqn">l = \Phi\left(z_0 + \frac{z_0 + z_\frac{\alpha}{2}}{1-a(z_0+z_\frac{\alpha}{2})}\right)</code>, <code class="reqn">u = \Phi\left(z_0 + \frac{z_0 + z_{1-\frac{\alpha}{2}}}{1-a(z_0+z_{1-\frac{\alpha}{2}})}\right)</code>, using the same definitions as above, but with the additional acceleration parameter <code class="reqn">a</code>, where <code class="reqn">a = \frac{1}{6}\frac{\sum{L^3}}{(\sum{L^2})^{3/2}}</code>. <code class="reqn">L</code> is the empirical influence value of each unit, which is computed using the regression method described in <code><a href="boot.html#topic+empinf">boot::empinf()</a></code>. The acceleration parameter corrects for bias and skewness in the statistic. It can only be used when clusters are absent and the number of bootstrap replications is larger than the sample size. When <code class="reqn">a=0</code>, the <code>"bca"</code> and <code>"bc"</code> intervals coincide.
</p>
<p>Interpolation on the normal quantile scale is used when a non-integer order statistic is required, as in <code>boot::boot.ci()</code>. Note that unlike with <code>boot::boot.ci()</code>, studentized confidence intervals (<code>type = "stud"</code>) are not allowed.
</p>


<h3>Value</h3>

<p>An <code>fwbci</code> object, which inherits from <code>bootci</code> and has the following components:
</p>
<table>
<tr><td><code>R</code></td>
<td>
<p>the number of bootstrap replications in the original call to <code>fwb()</code>.</p>
</td></tr>
<tr><td><code>t0</code></td>
<td>
<p>the observed value of the statistic on the same scale as the intervals (i.e., after applying <code>h</code> and then <code>hinv</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to <code>fwb.ci()</code>.</p>
</td></tr>
</table>
<p>There will be additional components named after each confidence interval type requested. For <code>"norm"</code>, this is a matrix with one row containing the confidence level and the two confidence interval limits. For the others, this is a matrix with one row containing the confidence level, the indices of the two order statistics used in the calculations, and the confidence interval limits.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(fwbci)</code>: Print a bootstrap confidence interval
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fwb">fwb()</a></code> for performing the fractional weighted bootstrap; <code><a href="#topic+get_ci">get_ci()</a></code> for extracting confidence intervals from an <code>fwbci</code> object; <code><a href="#topic+summary.fwb">summary.fwb()</a></code> for producing clean output from <code>fwb()</code> that includes confidence intervals calculated by <code>fwb.ci()</code>; <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code> for computing confidence intervals from the traditional bootstrap; <code><a href="#topic+vcovFWB">vcovFWB()</a></code> for computing parameter estimate covariance matrices using the fractional weighted bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
data("infert")

fit_fun &lt;- function(data, w) {
  fit &lt;- glm(case ~ spontaneous + induced, data = data,
             family = "quasibinomial", weights = w)
  coef(fit)
}

fwb_out &lt;- fwb(infert, fit_fun, R = 199, verbose = FALSE)

# Bias corrected percentile interval
bcci &lt;- fwb.ci(fwb_out, index = "spontaneous", type = "bc")
bcci

# Using `get_ci()` to extract confidence limits

get_ci(bcci)

# Interval calculated on original (log odds) scale,
# then transformed by exponentiation to be on OR
fwb.ci(fwb_out, index = "induced", type = "norm",
       hinv = exp)

</code></pre>

<hr>
<h2 id='get_ci'>Extract Confidence Intervals from a <code>bootci</code> Object</h2><span id='topic+get_ci'></span>

<h3>Description</h3>

<p><code>get_ci()</code> extracts the confidence intervals from the output of a call to <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code> or <code><a href="#topic+fwb.ci">fwb.ci()</a></code> in a clean way. Normally the confidence intervals can be a bit challenging to extract because of the unusual structure of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ci(x, type = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ci_+3A_x">x</code></td>
<td>
<p>a <code>bootci</code> object; the output of a call to <code>boot::boot.ci()</code> or <code>fwb.ci()</code>.</p>
</td></tr>
<tr><td><code id="get_ci_+3A_type">type</code></td>
<td>
<p>the type of confidence intervals to extract. Only those available in <code>x</code> are allowed. Should be a given as a subset of the types passed to <code>type</code> in <code>boot.ci()</code> or <code>fwb.ci()</code>. The default, <code>"all"</code>, extracts all confidence intervals in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an entry for each confidence interval type; each entry is a numeric vector of length 2 with names <code>"L"</code> and <code>"U"</code> for the lower and upper interval bounds, respectively. The <code>"conf"</code> attribute contains the confidence level.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwb.ci">fwb.ci()</a></code>, <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See example at help("fwb.ci")

</code></pre>

<hr>
<h2 id='plot.fwb'>Plots of the Output of a Fractional Weighted Bootstrap</h2><span id='topic+plot.fwb'></span>

<h3>Description</h3>

<p><code>plot.fwb()</code> takes an <code>fwb</code> object and produces plots for the bootstrap replicates of the statistic of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fwb'
plot(
  x,
  index = 1,
  qdist = "norm",
  nclass = NULL,
  df,
  type = c("hist", "qq"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fwb_+3A_x">x</code></td>
<td>
<p>an <code>fwb</code> object; the output of a call to <code><a href="#topic+fwb">fwb()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fwb_+3A_index">index</code></td>
<td>
<p>the index of the position of the quantity of interest in <code>x$t0</code> if more than one was specified in <code>fwb()</code>. Only one value is allowed at a time. By default the first statistic is used.</p>
</td></tr>
<tr><td><code id="plot.fwb_+3A_qdist">qdist</code></td>
<td>
<p><code>character</code>; when a Q-Q plot is requested (as it is by default; see <code>type</code> argument below), the distribution against which the Q-Q plot should be drawn. Allowable options include <code>"norm"</code> (normal distribution - the default) and <code>"chisq"</code> (chi-squared distribution).</p>
</td></tr>
<tr><td><code id="plot.fwb_+3A_nclass">nclass</code></td>
<td>
<p>when a histogram is requested (as it is by default; see <code>type</code> argument below), the number of classes to be used. The default is the integer between 10 and 100 closest to <code>ceiling(length(R)/25)</code> where <code>R</code> is the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="plot.fwb_+3A_df">df</code></td>
<td>
<p>if <code>qdist</code> is <code>"chisq"</code>, the degrees of freedom for the chi-squared distribution to be used. If not supplied, the degrees of freedom will be estimated using maximum likelihood.</p>
</td></tr>
<tr><td><code id="plot.fwb_+3A_type">type</code></td>
<td>
<p>the type of plot to display. Allowable options include <code>"hist"</code> for a histogram of the bootstrap estimates and <code>"qq"</code> for a Q-Q plot of the estimates against the distribution supplied to <code>qdist</code>.</p>
</td></tr>
<tr><td><code id="plot.fwb_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can produces two side-by-side plots: a histogram of the bootstrap replicates and a Q-Q plot of the bootstrap replicates against theoretical quantiles of a supplied distribution (normal or chi-squared). For the histogram, a vertical dotted line indicates the position of the estimate computed in the original sample. For the Q-Q plot, the expected line is plotted.
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwb">fwb()</a></code>, <code><a href="#topic+summary.fwb">summary.fwb()</a></code>, <code><a href="boot.html#topic+plot.boot">boot::plot.boot()</a></code>, <code><a href="graphics.html#topic+hist">hist()</a></code>, <code><a href="stats.html#topic+qqplot">qqplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples at help("fwb")
</code></pre>

<hr>
<h2 id='set_fwb_wtype'>Set weights type</h2><span id='topic+set_fwb_wtype'></span><span id='topic+get_fwb_wtype'></span>

<h3>Description</h3>

<p>Set the default for the type of weights used in the weighted bootstrap computed by <code><a href="#topic+fwb">fwb()</a></code> and <code><a href="#topic+vcovFWB">vcovFWB()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_fwb_wtype(wtype = getOption("fwb_wtype", "exp"))

get_fwb_wtype(fwb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_fwb_wtype_+3A_wtype">wtype</code></td>
<td>
<p>string; the type of weights to use. Allowable options include <code>"exp"</code> (the default), <code>"pois"</code>, <code>"multinom"</code>, and <code>"mammen"</code>. Abbreviations allowed. See Details for what these mean.</p>
</td></tr>
<tr><td><code id="set_fwb_wtype_+3A_fwb">fwb</code></td>
<td>
<p>optional; an <code>fwb</code> objct, the output of a call to <code><a href="#topic+fwb">fwb()</a></code>. If left empty, will extract the weights type from <code>options()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set_fwb_wtype(x)</code> is equivalent to calling <code>options(fwb_wtype = x)</code>. <code>get_fwb_wtype()</code> is equivalent to calling <code>getOption("fwb_wtype")</code> when no argument is supplied and to extracting the <code>wtype</code> component of an <code>fwb</code> object when supplied.
</p>


<h3>Value</h3>

<p><code>set_fwb_wtype()</code> returns a call to <code><a href="base.html#topic+options">options()</a></code> with the options set to those prior to <code>set_fwb_wtype()</code> being called. This makes it so that calling <code>options(op)</code>, where <code>op</code> is the output of <code>set_fwb_wtype()</code>, resets the <code>fwb_wtype</code> to its original value. <code>get_fwb_wtype()</code> returns a string containing the <code>fwb_wtype</code> value set globally (if no argument is supplied) or used in the supplied <code>fwb</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+fwb">fwb</a> for a definition of each types of weights; <code><a href="#topic+vcovFWB">vcovFWB()</a></code>; <code><a href="base.html#topic+options">options()</a></code>; <code><a href="boot.html#topic+boot">boot::boot()</a></code> for the traditional bootstrap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Performing a Weibull analysis of the Bearing Cage
# failure data as done in Xu et al. (2020)
set.seed(123)
data("bearingcage")

#Set fwb type to "mammen"
op &lt;- set_fwb_wtype("mammen")

weibull_est &lt;- function(data, w) {
  fit &lt;- survival::survreg(survival::Surv(hours, failure) ~ 1,
                           data = data, weights = w,
                           dist = "weibull")

  c(eta = unname(exp(coef(fit))), beta = 1/fit$scale)
}

boot_est &lt;- fwb(bearingcage, statistic = weibull_est,
                R = 199, verbose = FALSE)
boot_est

#Get the fwb type used in the bootstrap
get_fwb_wtype(boot_est)
get_fwb_wtype()

#Restore original options
options(op)

get_fwb_wtype()

</code></pre>

<hr>
<h2 id='summary.fwb'>Summarize <code>fwb</code> Output</h2><span id='topic+summary.fwb'></span>

<h3>Description</h3>

<p><code>summary()</code> creates a regression summary-like table that displays the bootstrap estimates, their empirical standard errors, and their confidence intervals, which are computed using <code><a href="#topic+fwb.ci">fwb.ci()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fwb'
summary(
  object,
  conf = 0.95,
  ci.type = "bc",
  p.value = FALSE,
  index = 1L:ncol(object$t),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fwb_+3A_object">object</code></td>
<td>
<p>an <code>fwb</code> object; the output of a call to <code><a href="#topic+fwb">fwb()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fwb_+3A_conf">conf</code></td>
<td>
<p>the desired confidence level. Default is .95 for 95% confidence intervals.</p>
</td></tr>
<tr><td><code id="summary.fwb_+3A_ci.type">ci.type</code></td>
<td>
<p>the type of confidence interval desired. Allowable options include <code>"norm"</code> (normal approximation), <code>"basic"</code> (basic interval), <code>"perc"</code> (percentile interval), <code>"bc"</code> (bias-correct percentile interval), and <code>"bca"</code> (bias-corrected and accelerated [BCa] interval). Only one is allowed. BCa intervals require that the number of bootstrap replications is larger than the sample size. See <code><a href="#topic+fwb.ci">fwb.ci()</a></code> for details. The default is <code>"bc"</code>.</p>
</td></tr>
<tr><td><code id="summary.fwb_+3A_p.value">p.value</code></td>
<td>
<p><code>logical</code>; whether to display p-values for the test that each parameter is equal to 0. The p-value is computed using a Z-test with the test statistic computed as the ratio of the estimate to its bootstrap standard error. This test is only valid when the bootstrap distribution is normally distributed around 0 and is not guaranteed to agree with any of the confidence intervals. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.fwb_+3A_index">index</code></td>
<td>
<p>the index or indices of the position of the quantity of interest in <code>x$t0</code> if more than one was specified in <code>fwb()</code>. Default is to display all quantities.</p>
</td></tr>
<tr><td><code id="summary.fwb_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>summary.fwb</code> object, which is a matrix with the following columns:
</p>

<ul>
<li> <p><code>Estimate</code>: the statistic estimated in the original sample
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Std. Error&#8288;</code>: the standard deviation of the bootstrap estimates
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;CI {L}%&#8288;</code> and <code style="white-space: pre;">&#8288;CI {U}%&#8288;</code>, the upper and lower confidence interval bounds computed using the argument to <code>ci.type</code>.
</p>
</li></ul>

<p>When <code>p.value = TRUE</code>, two additional columns, <code style="white-space: pre;">&#8288;z value&#8288;</code> and <code style="white-space: pre;">&#8288;Pr(&gt;|z|)&#8288;</code> are included containing the z-statistic and p-value for each computed statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwb">fwb()</a></code> for performing the fractional weighted bootstrap; <code><a href="#topic+fwb.ci">fwb.ci()</a></code> for computing multiple confidence intervals for a single bootstrapped quantity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
data("infert")

fit_fun &lt;- function(data, w) {
  fit &lt;- glm(case ~ spontaneous + induced, data = data,
             family = "quasibinomial", weights = w)
  coef(fit)
}

fwb_out &lt;- fwb(infert, fit_fun, R = 199, verbose = FALSE)

# Basic confidence interval for both estimates
summary(fwb_out, ci.type = "basic")

# Just for "induced" coefficient; p-values requested
summary(fwb_out, index = "induced", p.value = TRUE)

</code></pre>

<hr>
<h2 id='vcovFWB'>Fractional Weighted Bootstrap Covariance Matrix Estimation</h2><span id='topic+vcovFWB'></span>

<h3>Description</h3>

<p><code>vcovFWB()</code> estimates the covariance matrix of model coefficient estimates using the fractional weighted bootstrap. It serves as a drop-in for <code>stats::vcov()</code> or <code>sandwich::vcovBS()</code>. Clustered covariances are can be requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovFWB(
  x,
  cluster = NULL,
  R = 1000,
  start = FALSE,
  wtype = getOption("fwb_wtype", "exp"),
  ...,
  fix = FALSE,
  use = "pairwise.complete.obs",
  verbose = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovFWB_+3A_x">x</code></td>
<td>
<p>a fitted model object, such as the output of a call to <code>lm()</code> or <code>glm()</code>. The model object must result from a function that can be updated using <code><a href="stats.html#topic+update">update()</a></code> and has a <code>weights</code> argument to input non-integer case weights.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_cluster">cluster</code></td>
<td>
<p>a variable indicating the clustering of observations,
a <code>list</code> (or <code>data.frame</code>) thereof, or a formula specifying
which variables from the fitted model should be used (see examples).
By default (<code>cluster = NULL</code>), either <code>attr(x, "cluster")</code> is used
(if any) or otherwise every observation is assumed to be its own cluster.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_start">start</code></td>
<td>
<p><code>logical</code>; should <code>coef(x)</code> be passed as <code>start</code> to the <code>update(x, weights = ...)</code> call? In case the model <code>x</code> is computed by some numeric iteration, this may speed up the bootstrapping.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_wtype">wtype</code></td>
<td>
<p>string; the type of weights to use. Allowable options include <code>"exp"</code> (the default), <code>"pois"</code>, <code>"multinom"</code>, and <code>"mammen"</code>. See <code><a href="#topic+fwb">fwb()</a></code> for details. See <code><a href="#topic+set_fwb_wtype">set_fwb_wtype()</a></code> to set a global default.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_fix">fix</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, the covariance matrix is fixed to be positive semi-definite in case it is not.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_use">use</code></td>
<td>
<p><code>character</code>; specification passed to <code><a href="stats.html#topic+cor">stats::cov()</a></code> for handling missing coefficients/parameters.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to display a progress bar.</p>
</td></tr>
<tr><td><code id="vcovFWB_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, or an integer to indicate the number of child-processes (integer values are ignored on Windows) for parallel evaluations. See <code><a href="pbapply.html#topic+pblapply">pbapply::pblapply()</a></code> for details. If <code>NULL</code>, no parallelization will take place.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vcovFWB()</code> functions like other <code>vcov()</code>-like functions, such as those in the <code>sandwich</code> package, in particular, <code><a href="sandwich.html#topic+vcovBS">sandwich::vcovBS()</a></code>, which implements the traditional bootstrap (and a few other bootstrap varieties for linear models). Sets of weights are generated as described in the documentation for <code><a href="#topic+fwb">fwb()</a></code>, and the supplied model is re-fit using those weights. When the fitted model already has weights, these are multiplied by the bootstrap weights.
</p>
<p>For <code>lm</code> objects, the model is re-fit using <code><a href="stats.html#topic+.lm.fit">.lm.fit()</a></code> for speed, and, similarly, <code>glm</code> objects are re-fit using <code><a href="stats.html#topic+glm.fit">glm.fit()</a></code> (or whichever fitting method was originally used). For other objects, <code><a href="stats.html#topic+update">update()</a></code> is used to populate the weights and re-fit the model (this assumes the fitting function accepts non-integer case weights through a <code>weights</code> argument). If a model accepts weights in some other way, <code><a href="#topic+fwb">fwb()</a></code> should be used instead; <code>vcovFWB()</code> is inherently limited in its ability to handle all possible models. It is important that the original model was not fit using frequency weights (i.e., weights that allow one row of data to represent multiple full, identical, individual units).
</p>
<p>See <code><a href="sandwich.html#topic+vcovBS">sandwich::vcovBS()</a></code> and <code><a href="sandwich.html#topic+vcovCL">sandwich::vcovCL()</a></code> for more information on clustering covariance matrices, and see <code><a href="#topic+fwb">fwb()</a></code> for more information on how clusters work with the fractional weighted bootstrap. When clusters are specified, each cluster is given a bootstrap weight, and all members of the cluster are given that weight; estimation then proceeds as normal. By default, when <code>cluster</code> is unspecified, each unit is considered its own cluster.
</p>


<h3>Value</h3>

<p>A matrix containing the covariance matrix estimate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwb">fwb()</a></code> for performing the fractional weighted bootstrap on an arbitrary quantity; <code><a href="#topic+fwb.ci">fwb.ci()</a></code> for computing nonparametric confidence intervals for <code>fwb</code> objects; <code><a href="#topic+summary.fwb">summary.fwb()</a></code> for producing standard errors and confidence intervals for <code>fwb</code> objects; <code><a href="sandwich.html#topic+vcovBS">sandwich::vcovBS()</a></code> for computing covariance matrices using the traditional bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
data("infert")
fit &lt;- glm(case ~ spontaneous + induced, data = infert,
             family = "binomial")
lmtest::coeftest(fit, vcov. = vcovFWB, R = 200)


# Example from help("vcovBS", package = "sandwich")
data("PetersenCL", package = "sandwich")
m &lt;- lm(y ~ x, data = PetersenCL)

# Note: this is not to compare performance, just to
# demonstrate the syntax
cbind(
  "BS" = sqrt(diag(sandwich::vcovBS(m))),
  "FWB" = sqrt(diag(vcovFWB(m))),
  "BS-cluster" = sqrt(diag(sandwich::vcovBS(m, cluster = ~firm))),
  "FWB-cluster" = sqrt(diag(vcovFWB(m, cluster = ~firm)))
)

# Using `wtype = "multinom"` exactly reproduces
# `sandwich::vcovBS()`
set.seed(11)
s &lt;- sandwich::vcovBS(m, R = 200)
set.seed(11)
f &lt;- vcovFWB(m, R = 200, wtype = "multinom")

all.equal(s, f)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
