<!DOCTYPE html><html><head><title>Help for package cycleRtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cycleRtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convert_time'><p>Reformat time.</p></a></li>
<li><a href='#cycleRdata'><p>cycleRdata class</p></a></li>
<li><a href='#diff_section'><p>Section data according to breaks.</p></a></li>
<li><a href='#download_elev_data'><p>Download geographical elevation data.</p></a></li>
<li><a href='#elevation_correct'><p>Generate reliable elevation data.</p></a></li>
<li><a href='#GC'><p>GoldenCheetah (&gt;v3.3) interface.</p></a></li>
<li><a href='#interval_detect'><p>Detect Intervals in a Ride.</p></a></li>
<li><a href='#LT'><p>Lactate Thresholds</p></a></li>
<li><a href='#mmv'><p>Maximal mean values.</p></a></li>
<li><a href='#mmv2'><p>Efficient maximal mean values.</p></a></li>
<li><a href='#plot.cycleRdata'><p>Plot cycling data.</p></a></li>
<li><a href='#predict.Ptmodels'><p>Predict Power or Time</p></a></li>
<li><a href='#Pt_model'><p>Power-time modelling.</p></a></li>
<li><a href='#Pt_prof'><p>Power-time profile.</p></a></li>
<li><a href='#read_ride'><p>Read cycling device data.</p></a></li>
<li><a href='#reset'><p>Reset a dataset or vector.</p></a></li>
<li><a href='#ride_examples'><p>Example cycling data.</p></a></li>
<li><a href='#rollmean_'><p>Rolling average smoothing.</p></a></li>
<li><a href='#rollmean_nunif'><p>Rolling mean for nonuniform data.</p></a></li>
<li><a href='#smth_plot'><p>Smoothed data plot.</p></a></li>
<li><a href='#summary_metrics'><p>Summary metrics.</p></a></li>
<li><a href='#summary.cycleRdata'><p>Summary method for cycleRdata class.</p></a></li>
<li><a href='#Wbal_'><p>W' balance.</p></a></li>
<li><a href='#zdist_plot'><p>Zone-time distribution plot.</p></a></li>
<li><a href='#zone_index'><p>Index zones.</p></a></li>
<li><a href='#zone_time'><p>Calculate time in zones.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Cycling Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of functions for analysing cycling data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 1.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, xml2, stats, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>changepoint, minpack.lm, RCurl, raster, pspline, leaflet,
knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmackie4/cycleRtools">https://github.com/jmackie4/cycleRtools</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-01-18 08:01:46 UTC; jordan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jordan Mackie [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jordan Mackie &lt;jmackie@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-01-18 17:29:02</td>
</tr>
</table>
<hr>
<h2 id='convert_time'>Reformat time.</h2><span id='topic+convert_from_time'></span><span id='topic+convert_time'></span><span id='topic+convert_to_time'></span>

<h3>Description</h3>

<p>Functions perform interconversion between &quot;HH:MM:SS&quot; format and seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_from_time(x)

convert_to_time(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_time_+3A_x">x</code></td>
<td>
<p>either a character string of the form &quot;HH:MM:SS&quot; (&quot;HH&quot; is optional)
or numeric <strong>seconds</strong> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>seconds value(s) for <em>from</em>, and &quot;HH:MM:SS&quot; character string(s)
for <em>to</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("00:21:05", "25:51", NA, "00:26:01.1", "01:05:02.0")
x &lt;- convert_from_time(x)
print(x)
x &lt;- convert_to_time(x)
print(x)

</code></pre>

<hr>
<h2 id='cycleRdata'>cycleRdata class</h2><span id='topic+as.cycleRdata'></span><span id='topic+cycleRdata'></span><span id='topic+is.cycleRdata'></span>

<h3>Description</h3>

<p>A class for imported ride files intended to ease integration with package
functionality. Produced by invoking <code><a href="#topic+read_ride">read_ride</a></code> (or equivalent)
with the argument <code>format = TRUE</code>. Fundamentally, <code>cycleRdata</code>
objects are a special type of <code>data.frame</code>; special in the sense that
column names are predefined and assumed to be present in the class'
associated methods. Modification of these column names will lead to errors.
See below for a description of the format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cycleRdata(x)

as.cycleRdata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycleRdata_+3A_x">x</code></td>
<td>
<p>an object to be tested/coerced.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>The columns of cycleRdata objects are structured as such:
</p>

<dl>
<dt>timer.s</dt><dd><p>an ongoing timer (seconds). Stoppages are not recorded per se,
but rather represented as breaks in the continuity of the timer.</p>
</dd>
<dt>timer.min</dt><dd><p>as above, but in units of minutes.</p>
</dd>
<dt>timestamp</dt><dd><p>&quot;POSIXct&quot; values, describing the actual time of day.</p>
</dd>
<dt>delta.t</dt><dd><p>delta time values (seconds).</p>
</dd>
<dt>lat</dt><dd><p>latitude values (degrees).</p>
</dd>
<dt>lng</dt><dd><p>longitude values (degrees).</p>
</dd>
<dt>distance.km</dt><dd><p>cumulative distance (kilometres).</p>
</dd>
<dt>speed.kmh</dt><dd><p>speed in kilometres per hour.</p>
</dd>
<dt>elevation.m</dt><dd><p>altitude in metres.</p>
</dd>
<dt>delta.elev</dt><dd><p>delta elevation (metres).</p>
</dd>
<dt>VAM</dt><dd><p>&quot;vertical ascent metres per second&quot;.</p>
</dd>
<dt>power.W</dt><dd><p>power readings (Watts).</p>
</dd>
<dt>power.smooth.W</dt><dd><p>an exponentially-weighted 25-second moving average of power values.</p>
</dd>
<dt>work.kJ</dt><dd><p>cumulative work (kilojoules).</p>
</dd>
<dt>Wexp.kJ</dt><dd><p>W' expended in units of kilojoules. See <code>?Wbal</code> and references therein.</p>
</dd>
<dt>cadence.rpm</dt><dd><p>pedalling cadence (revolutions per minute).</p>
</dd>
<dt>hr.bpm</dt><dd><p>Heart rate (beats per minute).</p>
</dd>
<dt>lap</dt><dd><p>a numeric vector of lap &quot;levels&quot;. Will only have values &gt; 1 if lap data is available.</p>
</dd>
</dl>

<hr>
<h2 id='diff_section'>Section data according to breaks.</h2><span id='topic+diff_section'></span>

<h3>Description</h3>

<p>Generates a vector of &quot;section&quot; values/levels according to differences in
the supplied vector. The function simply rolls over <code>x</code>, incrementing
the return vector every time there is a significant break (<code>stop</code>
argument) in the pattern of differences between adjacent elements of
<code>x</code>. In practical terms, if <code>x</code> is a series of timestamp values
(see example), every time there is a significant break in the timer (e.g.
&gt;10 sec), the return vector is incremented by 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_section(x, br)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_section_+3A_x">x</code></td>
<td>
<p>a numeric vector (e.g. a timer column) that increments uniformly.
When there is a <strong>significant</strong> break in this uniformity, a new
section is created, and so forth.</p>
</td></tr>
<tr><td><code id="diff_section_+3A_br">br</code></td>
<td>
<p>criterion for a significant break in terms of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_sec &lt;- c(1:10, 40:60, 100:150)       # Discontinuous timer values.
pwr   &lt;- runif(length(t_sec), 0, 400)  # Some power values.
x     &lt;- data.frame(t_sec, pwr)

## Generate section levels.
x$section &lt;- diff_section(x$t_sec, br = 10) # 10 second breaks.
print(x)
split(x, x$section)

## Using "intervaldata", which has a large stop.
data(intervaldata)
intervaldata$section &lt;- diff_section(intervaldata$timer.s, br = 20)
sp &lt;- split(intervaldata, intervaldata$section)

## Plot.
eplot &lt;- function(x) cycleRtools:::elev_plot(x, "timer.min")
layout(matrix(c(1, 2, 1, 3), 2, 2))
eplot(cycleRtools:::expand_stops(intervaldata))
eplot(sp[[1]])
eplot(sp[[2]])

</code></pre>

<hr>
<h2 id='download_elev_data'>Download geographical elevation data.</h2><span id='topic+download_elev_data'></span>

<h3>Description</h3>

<p>Downloads elevation data files to the working directory for use with
<code><a href="#topic+elevation_correct">elevation_correct</a></code>. Requires package <code>raster</code> to be
installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_elev_data(country = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_elev_data_+3A_country">country</code></td>
<td>
<p>character string; the ISO3 country code (see
<code>raster::getData("ISO3")</code>) for which to download the data. If &quot;all&quot;,
then all available data is downloaded - this may take some time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, files are downloaded to the working directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elevation_correct">elevation_correct</a></code>.
</p>

<hr>
<h2 id='elevation_correct'>Generate reliable elevation data.</h2><span id='topic+elevation_correct'></span>

<h3>Description</h3>

<p>Using the latitude and longitude columns of the supplied <em>formatted</em>
data, a vector of elevation values is returned of the same length. If no
elevation data files exist within the working directory, files are first
downloaded. Note that NAs in the data will return corresponding NAs in the
corrected elevation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elevation_correct(data, country)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elevation_correct_+3A_data">data</code></td>
<td>
<p>a dataset with longitude (&quot;lng&quot;) and lattitude (&quot;lon&quot;) columns.</p>
</td></tr>
<tr><td><code id="elevation_correct_+3A_country">country</code></td>
<td>
<p>character string; the country to which the data pertain, given
as an ISO3 code (see <code>raster::getData("ISO3")</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of elevation values. If there is an error at any stage, a
vector of NAs is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+download_elev_data">download_elev_data</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ridedata)

## When run the first time, geographical data will need to be downloaded.
ridedata$elevation.corrected &lt;- elevation_correct(ridedata, "GBR")

## A Bland-Altman-type plot.
difference &lt;- ridedata$elevation.m - ridedata$elevation.corrected
plot(difference ~ ridedata$timer.min, cex = 0.2, ylab = "raw minus corrected")
m &lt;- mean(difference, na.rm = TRUE); stdev &lt;- sd(difference, na.rm = TRUE)
abline(h = c(m + c(-stdev, 0, stdev)), lty = c(1, 2, 1), col = "red")

## End(Not run)

</code></pre>

<hr>
<h2 id='GC'>GoldenCheetah (&gt;v3.3) interface.</h2><span id='topic+GC'></span><span id='topic+GC_activity'></span><span id='topic+GC_metrics'></span><span id='topic+GC_mmvs'></span>

<h3>Description</h3>

<p>Functions for interfacing R with
<a href="https://github.com/GoldenCheetah/GoldenCheetah">GoldenCheetah</a>.
Requires the <code>RCurl</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GC_activity(athlete.name, activity, port = 12021, format = TRUE)

GC_metrics(athlete.name, date.rng = NULL, port = 12021)

GC_mmvs(type = "watts", date.rng = NULL, port = 12021)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GC_+3A_athlete.name">athlete.name</code></td>
<td>
<p>character; athlete of interest in the GoldenCheetah data
directory. Typically of the form &quot;First Last&quot;.</p>
</td></tr>
<tr><td><code id="GC_+3A_activity">activity</code></td>
<td>
<p>character; file path to a GoldenCheetah activity(.json) file.
Typically located in &quot;~/.goldencheetah/Athlete Name/activities/&quot;.</p>
</td></tr>
<tr><td><code id="GC_+3A_port">port</code></td>
<td>
<p>http server port number. 12021 unless deliberatley changed in the
httpserver.ini file.</p>
</td></tr>
<tr><td><code id="GC_+3A_format">format</code></td>
<td>
<p>format activity data to an object of class &quot;cycleRdata&quot;.
Ensures compatibility with other functions in this package &ndash; see
<code><a href="#topic+read_ride">read_ride</a></code>.</p>
</td></tr>
<tr><td><code id="GC_+3A_date.rng">date.rng</code></td>
<td>
<p>a vector of length two that can be converted to an object of
class <code>"Date"</code> via <code><a href="base.html#topic+as.Date">as.Date</a></code>. Must be specified for
<code>GC_mmvs</code>; optional for <code>GC_metrics</code>.</p>
</td></tr>
<tr><td><code id="GC_+3A_type">type</code></td>
<td>
<p>the type of maximal mean values to return. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of GoldenCheetah (GC) version 3.3, the application is ran with a
background restful web service api to ease integration with external analysis software
(such as R). When an instance of GoldenCheetah is running, or the application
is initiated from the command line with the '&ndash;server' option, these
functions can be used to interface with athlete data. Relevant documentation
can be found
<a href="https://github.com/GoldenCheetah/GoldenCheetah/wiki/UG_Special-Topics_REST-API-documentation">here</a>.
</p>
<p><code>GC_activity</code> behaves similarly to <code><a href="#topic+read_ride">read_ride</a></code> functions in
this package, importing data from saved GC .json files.
</p>
<p><code>GC_metrics</code> returns summary metrics for either: all available rides if
<code>date.rng = NULL</code>; or rides within a specified date range if dates are
given.
</p>
<p><code>GC_mmvs</code> retuns best maximal mean values for data specified in the
<code>type</code> argument. Possible options for <code>type</code> are: &quot;watts&quot;, &quot;hr&quot;,
&quot;cad&quot;, &quot;speed&quot;, &quot;nm&quot;, &quot;vam&quot;, &quot;xPower&quot;, or &quot;NP&quot;. See also <code><a href="#topic+mmv">mmv</a></code>.
</p>

<hr>
<h2 id='interval_detect'>Detect Intervals in a Ride.</h2><span id='topic+interval_detect'></span>

<h3>Description</h3>

<p>Section a ride file according to power output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_detect(data, sections, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_detect_+3A_data">data</code></td>
<td>
<p>a <strong>formatted</strong> dataset produced by <code>read*()</code>.</p>
</td></tr>
<tr><td><code id="interval_detect_+3A_sections">sections</code></td>
<td>
<p>how many sections should be identified? Includes stoppages.</p>
</td></tr>
<tr><td><code id="interval_detect_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code>, graphically displays the resultant sections.</p>
</td></tr>
<tr><td><code id="interval_detect_+3A_...">...</code></td>
<td>
<p>graphical parameters to be passed to <code>par()</code>. Ignored if
<code>plot = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often a ride will contain intervals/efforts that are not in any way marked in
the device data (e.g. as &quot;laps&quot;). Using changepoint analysis, it is possible
to retrospectively identify these efforts. This is contingent on supplying
the number of changepoints to the underlying algorithm, simplified here as a
<code>"sections"</code> argument.
</p>
<p>For example, if there are two efforts amidst a
ride, this means we are looking to identify 5 <em>sections</em> (i.e.
neutral-effort-neutral-effort-neutral). See examples.
</p>
<p>Depends on the package <code>"changepoint"</code>.
</p>


<h3>Value</h3>

<p>if <code>plot = TRUE</code> nothing is returned. If <code>plot = FALSE</code>
(default) a vector of section &quot;levels&quot; is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(intervaldata)

## "intervaldata" is a ride that includes two efforts (2 &amp; 5 minutes) and a cafe
## stop. The efforts are marked in the lap column, which we can use as a
## criterion.

with(intervaldata, tapply(X = delta.t, INDEX = lap, sum)) / 60  # Minutes.

## The above shows the efforts were laps two and four. What was the power?
with(intervaldata, tapply(X = power.W, INDEX = lap, mean))[c(2, 4)]

## And for the sake of example, some other summary metrics...
l &lt;- split(intervaldata, intervaldata$lap)
names(l) &lt;- paste("Lap", names(l))  # Pretty names.
vapply(l, FUN.VALUE = numeric(3), FUN = function(x)
  c(t.min = ride_time(x$timer.s) / 60, NP = NP(x), TSS = TSS(x)))

## Could we have gotten the same information without the lap column?
## Two efforts and a cafe stop == 7 sections.
interval_detect(intervaldata, sections = 7, plot = TRUE)

## An overzealous start to the first effort is being treated as a seperate section,
## so let's allow for an extra section...
interval_detect(intervaldata, sections = 8, plot = TRUE)

## Looks okay, so save the output and combine the second and third sections.
intervaldata$intv &lt;- interval_detect(intervaldata, sections = 8, plot = FALSE)
intervaldata$intv[intervaldata$intv == 3] &lt;- 2

## Are the timings as expected?
with(intervaldata, tapply(X = delta.t, INDEX = intv, sum)) / 60  # Minutes.

## Close enough!

i &lt;- split(intervaldata, intervaldata$intv)
names(i) &lt;- paste("Interval", seq_along(i))  # Pretty names.
toplot &lt;- vapply(i, FUN.VALUE = numeric(3), FUN = function(x)
  c(t.min = ride_time(x$timer.s) / 60, NP = NP(x), TSS = TSS(x)))

print(toplot)

par(mfrow = c(3, 1))
mapply(function(r, ylab) barplot(
  toplot[r, c(1:3, 5:7)], names.arg = seq_along(toplot[r, c(1:3, 5:7)]),
  xlab = "Section", ylab = ylab),
  r = 1:3, ylab = c("Ride time (minutes)", "NP", "TSS"))

</code></pre>

<hr>
<h2 id='LT'>Lactate Thresholds</h2><span id='topic+LT'></span>

<h3>Description</h3>

<p>Model lactate threshold markers from work rate (power) and blood lactate
values. Requires package &quot;pspline&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LT(WR, La, sig_rise = 1.5, plots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LT_+3A_wr">WR</code></td>
<td>
<p>a numeric vector of work rate values. Typically these would be the
work rates associated with stages in an incremental exercise test.</p>
</td></tr>
<tr><td><code id="LT_+3A_la">La</code></td>
<td>
<p>a numeric vector of blood lactate values (mmol/L) associated with
the stages described in <code>WR</code>.</p>
</td></tr>
<tr><td><code id="LT_+3A_sig_rise">sig_rise</code></td>
<td>
<p>numeric; a rise in blood [Lactate] that is deemed
significant. Default is 1.5 mmol/L.</p>
</td></tr>
<tr><td><code id="LT_+3A_plots">plots</code></td>
<td>
<p>should outputs be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a slightly modified version of that written by
Newell <em>et al.</em> (2007) and published in the Journal of Sport Sciences
(see references). The original source code, which also includes other
functions for lactate analysis, can be found
<a href="http://www.nuigalway.ie/maths/jn/Lactate/html/lactate-r.html">here</a>.
</p>


<h3>Value</h3>

<p>a data frame of model outputs, and optionally a matrix of plots.
</p>


<h3>References</h3>

<p>John Newell , David Higgins , Niall Madden , James Cruickshank ,
Jochen Einbeck , Kenny McMillan &amp; Roddy McDonald (2007) Software for
calculating blood lactate endurance markers, Journal of Sports Sciences,
25:12, 1403-1409, <a href="http://dx.doi.org/10.1080/02640410601128922">DOI</a>.
</p>


<h3>See Also</h3>

<p>Newell <em>et al.</em>'s
<a href="https://orreco.shinyapps.io/lactate/">Shiny app.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This data is included with Newell et al's source code.
WR &lt;- c(50, 75, 100, 125, 150, 175, 200, 225, 250)
La &lt;- c(2.8, 2.4, 2.4, 2.9, 3.1, 4.0, 5.8, 9.3, 12.2)
LT(WR, La, 1.5, TRUE)

</code></pre>

<hr>
<h2 id='mmv'>Maximal mean values.</h2><span id='topic+mmv'></span>

<h3>Description</h3>

<p>Calculate maximal mean values for specified time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmv(data, column, windows, deltat = NULL, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmv_+3A_data">data</code></td>
<td>
<p>a <strong>formatted</strong> dataset produced by <code>read*()</code>.</p>
</td></tr>
<tr><td><code id="mmv_+3A_column">column</code></td>
<td>
<p>column in <code>data</code> giving the values of interest. Needn't be
quoted.</p>
</td></tr>
<tr><td><code id="mmv_+3A_windows">windows</code></td>
<td>
<p>window size(s) for which to generate best averages, given in
seconds.</p>
</td></tr>
<tr><td><code id="mmv_+3A_deltat">deltat</code></td>
<td>
<p>the sampling frequency of <code>data</code> in seconds per sample;
typically 0.5 or 1. If <code>NULL</code>, this is estimated.</p>
</td></tr>
<tr><td><code id="mmv_+3A_character.only">character.only</code></td>
<td>
<p>are column name arguments given as character strings? A
backdoor around non-standard evaluation. Mainly for internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix object with two rows: 1) best mean values and 2) the time
at which those values were recorded
</p>


<h3>See Also</h3>

<p>For a more generic and efficient version of this function, see
<code><a href="#topic+mmv2">mmv2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

## Best power for 5 and 20 minutes.
tsec &lt;- c(5, 20) * 60
mmv(ridedata, power.W, tsec)

## Generate a simple critical power estimate.
tsec &lt;- 2:20 * 60
pwrs &lt;- mmv(ridedata, power.W, tsec)
m &lt;- lm(pwrs[1, ] ~ {1 / tsec})  # Simple inverse model.
coef(m)[1]  # Intercept = critical power.

## More complex models...
m &lt;- Pt_model(pwrs[1, ], tsec)
print(m)
## Extract the asymptote of the exponential model.
coef(m)$exp["CP"]

</code></pre>

<hr>
<h2 id='mmv2'>Efficient maximal mean values.</h2><span id='topic+mmv2'></span>

<h3>Description</h3>

<p>A more efficient implementation of <code><a href="#topic+mmv">mmv</a></code>. Simply takes a vector
(<code>x</code>) of values and rolls over them element wise by <code>windows</code>.
Returns a vector of maximum mean values for each window. <code>NA</code>s are not
ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmv2(x, windows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmv2_+3A_x">x</code></td>
<td>
<p>a numeric vector of values.</p>
</td></tr>
<tr><td><code id="mmv2_+3A_windows">windows</code></td>
<td>
<p>window size(s) (in element units) for which to
generate maximum mean values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <code>length(windows)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, 500, 200)
mmv2(x, windows = c(5, 10, 20))

</code></pre>

<hr>
<h2 id='plot.cycleRdata'>Plot cycling data.</h2><span id='topic+plot.cycleRdata'></span>

<h3>Description</h3>

<p>Generate plots to effectively summarise a cycling dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cycleRdata'
plot(x, y = 1:3, xvar = "timer.s", xlab = NULL,
  xlim = NULL, CP = attr(x, "CP"), laps = FALSE, breaks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cycleRdata_+3A_x">x</code></td>
<td>
<p>a <code>"cycleRdata"</code> object produced by <code>read*()</code>.</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_y">y</code></td>
<td>
<p>numeric; plots to be created (see details).</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_xvar">xvar</code></td>
<td>
<p>character; name of the column to be plotted as the xvariable.</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_xlab">xlab</code></td>
<td>
<p>character; x axis label for bottom plot.</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_xlim">xlim</code></td>
<td>
<p>given in terms of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_cp">CP</code></td>
<td>
<p>a value for critical power annotation.</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_laps">laps</code></td>
<td>
<p>logical; should laps be seperately coloured?</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_breaks">breaks</code></td>
<td>
<p>logical; should plot lines be broken when stationary? Will only
show when <code>xvar</code> represents time values.</p>
</td></tr>
<tr><td><code id="plot.cycleRdata_+3A_...">...</code></td>
<td>
<p>graphical parameters, and/or arguments to be passed to or from
other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>y</code> argument describes plot options such that: </p>
<ol>
<li>
<p>plots W' balance (kJ). </p>
</li>
<li><p> plots power data (W). </p>
</li>
<li><p> plots an elevation
profile (m).</p>
</li></ol>
<p> These options can be combined to produce a stack of plots as
desired.
</p>


<h3>Value</h3>

<p>a variable number of plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ridedata)

plot(ridedata, xvar = "timer.min")
plot(ridedata, xvar = "distance.km")

## With only two plots.
plot(ridedata, y = c(2, 1))

## Using xlim, note that title metrics adjust.
plot(ridedata, xvar = "timer.min", xlim = c(100, 150))

## Lap colouring.
data(intervaldata)
plot(intervaldata, xvar = "timer.min", laps = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.Ptmodels'>Predict Power or Time</h2><span id='topic+predict.Ptmodels'></span>

<h3>Description</h3>

<p>Given a Ptmodels <code>object</code>, the predict.Ptmodels will produce a named
numeric vector of either time (seconds) or power (watts) values according to
the <code>x</code> and <code>y</code> arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Ptmodels'
predict(object, x, xtype = c("pwr", "time"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.Ptmodels_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Ptmodels&quot;.</p>
</td></tr>
<tr><td><code id="predict.Ptmodels_+3A_x">x</code></td>
<td>
<p>the value for which to make a prediction.</p>
</td></tr>
<tr><td><code id="predict.Ptmodels_+3A_xtype">xtype</code></td>
<td>
<p>what is <code>x</code>? A power or a time value?</p>
</td></tr>
<tr><td><code id="predict.Ptmodels_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector of predicted values. Names correspond to their
respective models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pt_prof)  # Example power-time profile.

P    &lt;- Pt_prof$pwr
tsec &lt;- Pt_prof$time

mdls &lt;- Pt_model(P, tsec)  ## Model.
print(mdls)

## What is the best predicted 20 minute power?
predict(mdls, x = 60 * 20, xtype = "time")

## How sustainable is 500 Watts?
predict(mdls, x = 500, xtype = "P") / 60  # Minutes.

## Create some plots of the models.
par(mfrow = c(2, 2), mar = c(3.1, 3.1, 1.1, 1.1))
plotargs &lt;- alist(x = tsec, y = P, cex = 0.2, ann = FALSE, bty = "l")
mapply(function(f, m) {
  do.call(plot, plotargs)
  curve(f(x), col = "red", add = TRUE)
  title(main = paste0(rownames(m),"; RSE = ", round(m$RSE, 2)))
  legend("topleft", legend = m$formula, bty = "n")
  return()
}, f = mdls$Pfn, m = split(mdls$table, seq_len(nrow(mdls$table))))

</code></pre>

<hr>
<h2 id='Pt_model'>Power-time modelling.</h2><span id='topic+Pt_model'></span>

<h3>Description</h3>

<p>Model the Power-time (Pt) relationship for a set of data. This is done via
nonlinear least squares regression of four models: an inverse model; an
exponential model; a bivariate power function model; and a three parameter
inverse model. An S3 object of class &quot;Ptmodels&quot; is returned, which currently
has methods for <a href="base.html#topic+print">print</a>, <a href="stats.html#topic+coef">coef</a>, <a href="base.html#topic+summary">summary</a>,
and <a href="stats.html#topic+predict">predict</a>. If inputs do not conform well to the models, a
warning message is generated. This function will make use of
<code>minpack.lm::nlsLM</code> if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pt_model(P, tsec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pt_model_+3A_p">P</code></td>
<td>
<p>a numeric vector of maximal mean power values for time periods given
in the <code>tsec</code> argument.</p>
</td></tr>
<tr><td><code id="Pt_model_+3A_tsec">tsec</code></td>
<td>
<p>a numeric vector of time values that (positionally) correspond to
elements in <code>P</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an S3 object of class &quot;Ptmodels&quot;.
</p>


<h3>References</h3>

<p>R. Hugh Morton (1996) A 3-parameter critical power model,
Ergonomics, 39:4, 611-619,
<a href="http://dx.doi.org/10.1080/00140139608964484">DOI</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.Ptmodels">predict.Ptmodels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pt_prof)  # Example power-time profile.

P    &lt;- Pt_prof$pwr
tsec &lt;- Pt_prof$time

mdls &lt;- Pt_model(P, tsec)  # Model.
print(mdls)

coef(mdls)
summary(mdls)

</code></pre>

<hr>
<h2 id='Pt_prof'>Power-time profile.</h2><span id='topic+Pt_prof'></span>

<h3>Description</h3>

<p>An example power profile; i.e. best mean powers for periods of 30 seconds
through to 1 hour, in increments of 10 seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pt_prof
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> with two columns: time (seconds) and power
(Watts), respectively.</p>

<hr>
<h2 id='read_ride'>Read cycling device data.</h2><span id='topic+read_fit'></span><span id='topic+read_pwx'></span><span id='topic+read_ride'></span><span id='topic+read_srm'></span><span id='topic+read_tcx'></span>

<h3>Description</h3>

<p>Read data from a cycling head unit into the R environment; optionally
formatting it for use with other functions in this package. Critical power
and session RPE metrics can also be associated with the data and used by
other functions (e.g. <a href="#topic+summary.cycleRdata">summary.cycleRdata</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ride(file = file.choose(), format = TRUE, CP = NULL, sRPE = NULL)

read_fit(file = file.choose(), format = TRUE, CP = NULL, sRPE = NULL)

read_pwx(file = file.choose(), format = TRUE, CP = NULL, sRPE = NULL)

read_srm(file = file.choose(), format = TRUE, CP = NULL, sRPE = NULL)

read_tcx(file = file.choose(), format = TRUE, CP = NULL, sRPE = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ride_+3A_file">file</code></td>
<td>
<p>character; path to the file.</p>
</td></tr>
<tr><td><code id="read_ride_+3A_format">format</code></td>
<td>
<p>logical; should data be formatted?</p>
</td></tr>
<tr><td><code id="read_ride_+3A_cp">CP</code>, <code id="read_ride_+3A_srpe">sRPE</code></td>
<td>
<p>optional; critical power and session RPE values to be
associated with the data. Ignored if <code>format = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that most functions within this package depend on imported data being
formatted; i.e. <code>read*("file_path", format = TRUE)</code>. Hence, unless the
raw data is of particular interest and/or the user wants to process it
manually, the format argument should be TRUE (default). When working with a
formatted dataset, do not change existing column names. The formatted data
structure is described in detail in <a href="#topic+ridedata">ridedata</a>.
</p>
<p>Garmin .fit file data is parsed with the java command line tool provided in
the <a href="http://www.thisisant.com/resources/fit">FIT SDK</a>. The latest source
code and licensing information can be found at the previous link.
</p>
<p>SRM device files (.srm) are also parsed at the command line, provided
<a href="http://www.zuto.de/project/srmio/">Rainer Clasen's srmio library</a> is
installed and available. The associated GitHub repo' can be found
<a href="https://github.com/rclasen/srmio">here</a>.
</p>


<h3>Value</h3>

<p>a data frame object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>read_ride</code>: A wrapper for read_* functions that chooses the
appropriate function based on file extension.
</p>
</li>
<li> <p><code>read_fit</code>: Read a Garmin (Ltd) device .fit file. This invokes
<code><a href="base.html#topic+system2">system2</a></code> to execute the FitCSVTool.jar command line tool
(see <a href="http://www.thisisant.com/resources/fit">FIT SDK</a>). Hence, this
function requires that Java (JRE/JDK) binaries be on the system path.
</p>
</li>
<li> <p><code>read_pwx</code>: Read a Training Peaks .pwx file. Requires the &quot;xml2&quot; package
to be installed.
</p>
</li>
<li> <p><code>read_srm</code>: Read an SRM (.srm) file. This requires
<a href="http://www.zuto.de/project/srmio/">Rainer Clasen's srmio library</a> to
be installed and on the system path.
</p>
</li>
<li> <p><code>read_tcx</code>: Read a Garmin .tcx file. Requires the &quot;xml2&quot; package to be
installed.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fl  &lt;- system.file("extdata/example_files.tar.gz",
                   package = "cycleRtools")
fls &lt;- untar(fl, list = TRUE)
untar(fl)  # Extract to working directory.

dat &lt;- lapply(fls, read_ride, format = TRUE, CP = 300, sRPE = 5)

file.remove(fls)

## End(Not run)

</code></pre>

<hr>
<h2 id='reset'>Reset a dataset or vector.</h2><span id='topic+reset'></span>

<h3>Description</h3>

<p>if <code>x</code> is a <code>"cycleRdata"</code> object, all columns are reset as
appropriate. This can be useful after subsetting a ride dataset, for example.
Otherwise, this is a wrapper for <code>x - x[[1]]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_+3A_x">x</code></td>
<td>
<p>a numeric vector or formatted cycling dataset (i.e. class <code>"cycleRdata"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a data frame or vector, depending on the class of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

# Remove first minute of data and reset.
data_raw   &lt;- ridedata[ridedata$timer.s &gt; 60, ]
data_reset &lt;- reset(data_raw)

</code></pre>

<hr>
<h2 id='ride_examples'>Example cycling data.</h2><span id='topic+intervaldata'></span><span id='topic+ride_examples'></span><span id='topic+ridedata'></span>

<h3>Description</h3>

<p>Formatted cycling data from a Garmin head-unit. Imported via
<code>read_fit("file_path", format = TRUE, CP = 310, sRPE = 7)</code>.
</p>
<p><code>"ridedata"</code> is a typical group ride. <code>"intervaldata"</code> is a session
(of sorts) that included two efforts and a cafe stop. The latter is included
to demonstrate the use of <code><a href="#topic+interval_detect">interval_detect</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridedata

intervaldata
</code></pre>


<h3>Format</h3>

<p>An object of class <code>c("cycleRdata", "data.frame")</code>, and
additional attributes of <code>CP = 300</code> &amp; <code>sRPE = 7</code>. The latter are
used by several methods in this package. See <code><a href="#topic+cycleRdata">cycleRdata</a></code> for a
description of columns.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cycleRdata">cycleRdata</a></code>.
</p>

<hr>
<h2 id='rollmean_'>Rolling average smoothing.</h2><span id='topic+rollmean_'></span><span id='topic+rollmean_smth'></span>

<h3>Description</h3>

<p>Smooth data with a right-aligned (zero-padded) rolling average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmean_(x, window, ema, narm)

rollmean_smth(data, column, smth.pd, deltat = NULL, ema = FALSE,
  character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmean__+3A_x">x</code></td>
<td>
<p>numeric; values to be rolled over.</p>
</td></tr>
<tr><td><code id="rollmean__+3A_window">window</code></td>
<td>
<p>numeric; size of the rolling window in terms of elements in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="rollmean__+3A_ema">ema</code></td>
<td>
<p>logical; should the moving average be exponentially weighted?</p>
</td></tr>
<tr><td><code id="rollmean__+3A_narm">narm</code></td>
<td>
<p>logical; should <code>NA</code>s be removed?</p>
</td></tr>
<tr><td><code id="rollmean__+3A_data">data</code></td>
<td>
<p>a dataset of class <code>cycleRdata</code>.</p>
</td></tr>
<tr><td><code id="rollmean__+3A_column">column</code></td>
<td>
<p>the column name of the data to be smoothed, needn't be quoted.</p>
</td></tr>
<tr><td><code id="rollmean__+3A_smth.pd">smth.pd</code></td>
<td>
<p>numeric; the time period over which to smooth (seconds).</p>
</td></tr>
<tr><td><code id="rollmean__+3A_deltat">deltat</code></td>
<td>
<p>the sampling frequency of <code>data</code> in seconds per sample;
typically 0.5 or 1. If <code>NULL</code>, this is estimated.</p>
</td></tr>
<tr><td><code id="rollmean__+3A_character.only">character.only</code></td>
<td>
<p>are column name arguments given as character strings? A
backdoor around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rollmean_</code> is the core Rcpp function, which rolls over elements in
<code>x</code> by a window given in <code>window</code>; optionally applying exponential
weights and/or removing <code>NA</code>s. <code>rollmean_smth</code> is a wrapper for
<code>rollmean_</code> that only has a method for <code>cycleRdata</code> objects. The
latter will pre-process the data and permits what is effectively the
<code>window</code> argument being given in time units.
</p>


<h3>Value</h3>

<p>a vector of the same length as the <code>data[, column]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ridedata)

## Smooth power data with a 30 second moving average.
rollmean_smth(ridedata, power.W, 30)

## Or use an exponentially weighted moving average.
rollmean_smth(ridedata, power.W, 30, ema = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rollmean_nunif'>Rolling mean for nonuniform data.</h2><span id='topic+rollmean_nunif'></span>

<h3>Description</h3>

<p>Produce a rolling average for data sampled at non-uniform time intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmean_nunif(x, t, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmean_nunif_+3A_x">x</code></td>
<td>
<p>numeric vector of values to be rolled.</p>
</td></tr>
<tr><td><code id="rollmean_nunif_+3A_t">t</code></td>
<td>
<p>numeric vector of time values corresponding to elements in <code>x</code>.</p>
</td></tr>
<tr><td><code id="rollmean_nunif_+3A_window">window</code></td>
<td>
<p>size of the window in terms of <code>t</code>. E.g. <code>30</code> (seconds).</p>
</td></tr>
</table>

<hr>
<h2 id='smth_plot'>Smoothed data plot.</h2><span id='topic+smth_plot'></span>

<h3>Description</h3>

<p>Create a plot with both raw and smoothed data lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smth_plot(data, x = "timer.s", yraw = "power.W", ysmth = "power.smooth.W",
  colour = "lap", ..., character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smth_plot_+3A_data">data</code></td>
<td>
<p>the dataset to be used.</p>
</td></tr>
<tr><td><code id="smth_plot_+3A_x">x</code></td>
<td>
<p>column identifier for the x axis data.</p>
</td></tr>
<tr><td><code id="smth_plot_+3A_yraw">yraw</code></td>
<td>
<p>column identifier for the (underlying) raw data.</p>
</td></tr>
<tr><td><code id="smth_plot_+3A_ysmth">ysmth</code></td>
<td>
<p>column identifier for the smoothed data.</p>
</td></tr>
<tr><td><code id="smth_plot_+3A_colour">colour</code></td>
<td>
<p>level identifier in <code>data</code> by which to colour lines. Or a
colour name.</p>
</td></tr>
<tr><td><code id="smth_plot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="smth_plot_+3A_character.only">character.only</code></td>
<td>
<p>are column name arguments given as character strings? A
backdoor around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

## Plot with a single blue line (default arguments):
smth_plot(ridedata, colour = "blue", main = "Single Colour",
          xlab = "Time (seconds)", ylab = "Power (watts)")

## Create some laps.
ridedata$lap &lt;- ceiling(seq(from = 1.1, to = 5, length.out = nrow(ridedata)))
## Plot with lap colours.
smth_plot(ridedata, timer.min, power.W, power.smooth.W, colour = "lap",
          xlab = "Time (mins)", ylab = "Power (watts)", main = "Lap Colours")

</code></pre>

<hr>
<h2 id='summary_metrics'>Summary metrics.</h2><span id='topic+NP'></span><span id='topic+TSS'></span><span id='topic+pwr_TRIMP'></span><span id='topic+ride_time'></span><span id='topic+summary_metrics'></span><span id='topic+xPower'></span>

<h3>Description</h3>

<p>Common summary measures of interest to cyclists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ride_time(x, deltat = NULL)

xPower(data)

NP(data)

pwr_TRIMP(data, CP = attr(data, "CP"))

TSS(data, CP = attr(data, "CP"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_metrics_+3A_x">x</code></td>
<td>
<p>a vector of time values.</p>
</td></tr>
<tr><td><code id="summary_metrics_+3A_deltat">deltat</code></td>
<td>
<p>numeric; the typical interval between time values, if
<code>NULL</code> a best estimate is used.</p>
</td></tr>
<tr><td><code id="summary_metrics_+3A_data">data</code></td>
<td>
<p>a &quot;cycleRdata&quot; object, produced from a <code><a href="#topic+read_ride">read_ride</a></code>
function.</p>
</td></tr>
<tr><td><code id="summary_metrics_+3A_cp">CP</code></td>
<td>
<p>a Critical Power value - e.g. CP or FTP.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NP</code> calculates a Normalised Power value. &quot;Normalised Power&quot; is a
registered trademark of Peaksware Inc.
</p>
<p><code>xPower</code>; Dr. Philip Skiba/Golden Cheetah's answer to NP.
</p>
<p><code>pwr_TRIMP</code>: Power-Based TRaining IMPulse. Calculates a
<em>normalised</em> TRIMP value using power data. This is a power-based
adaptation of Bannister's TRIMP, whereby critical power (CP) is assumed to
represent 90
to the score associated with one-hour's riding at CP, to aid interpretation.
</p>
<p><code>ride_time</code> is a simple function for calculating ride time, as opposed
to elapsed time.
</p>
<p><code>TSS</code> calculates a Training Stress Score (TSS). TSS is a registered
trademark of Peaksware Inc.
</p>


<h3>Value</h3>

<p>a single numeric value.
</p>


<h3>References</h3>

<p>Morton, R.H., Fitz-Clarke, J.R., Banister, E.W., 1990. Modeling
human performance in running. Journal of Applied Physiology 69, 1171-1177.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

## Display all summary metrics with an *apply call.
fns   &lt;- list("ride_time", "xPower", "NP", "pwr_TRIMP", "TSS")
argl  &lt;- list(data = ridedata, x = ridedata$timer.s, CP = 300)
metrs &lt;- vapply(fns, function(f) {
  do.call(f, argl[names(argl) %in% names(formals(f))])
}, numeric(1))

names(metrs) &lt;- fns
print(metrs)
</code></pre>

<hr>
<h2 id='summary.cycleRdata'>Summary method for cycleRdata class.</h2><span id='topic+summary.cycleRdata'></span>

<h3>Description</h3>

<p>Relevant summary metrics for cycling data (method for class
<code>"cycleRdata"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cycleRdata'
summary(object, sRPE = attr(object, "sRPE"),
  CP = attr(object, "CP"), .smoothpwr = "power.smooth.W", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cycleRdata_+3A_object">object</code></td>
<td>
<p>object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.cycleRdata_+3A_srpe">sRPE</code></td>
<td>
<p>optional; session Rating of Percieved Exertion (value between 1
and 10; Foster 1998).</p>
</td></tr>
<tr><td><code id="summary.cycleRdata_+3A_cp">CP</code></td>
<td>
<p>optional; Critical Power value (Watts).</p>
</td></tr>
<tr><td><code id="summary.cycleRdata_+3A_.smoothpwr">.smoothpwr</code></td>
<td>
<p>character string; column name of smoothed power values.
Used for xP metric.</p>
</td></tr>
<tr><td><code id="summary.cycleRdata_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object of class <code>"cyclesummary"</code>, which has an associated
print method.
</p>


<h3>References</h3>

<p>Foster C. Monitoring training in athletes with reference to
overtraining syndrome. Medicine &amp; Science in Sports &amp; Exercise 30: 1164-1168,
1998.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(intervaldata)
summary(intervaldata)

</code></pre>

<hr>
<h2 id='Wbal_'>W' balance.</h2><span id='topic+Wbal'></span><span id='topic+Wbal_'></span>

<h3>Description</h3>

<p>Generate a vector of W' balance values from time and power data. The
underlying algorithm is published in Skiba <em>et al.</em> (2012). <code>Wbal</code>
is a wrapper for the Rcpp function <code>Wbal_</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wbal_(t, P, CP)

Wbal(data, time = "timer.s", pwr = "power.smooth.W", CP = attr(data,
  "CP"), noisy = TRUE, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wbal__+3A_t">t</code>, <code id="Wbal__+3A_p">P</code></td>
<td>
<p>numeric vectors of time and power, respectively.</p>
</td></tr>
<tr><td><code id="Wbal__+3A_cp">CP</code></td>
<td>
<p>a critical power value for use in the calculation.</p>
</td></tr>
<tr><td><code id="Wbal__+3A_data">data</code></td>
<td>
<p>a data.frame/matrix object with time and power columns.</p>
</td></tr>
<tr><td><code id="Wbal__+3A_time">time</code></td>
<td>
<p>character; name of the time (seconds) column in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Wbal__+3A_pwr">pwr</code></td>
<td>
<p>character; name of the power (watts) column in <code>data</code>.</p>
</td></tr>
<tr><td><code id="Wbal__+3A_noisy">noisy</code></td>
<td>
<p>logical; create smoother data by pooling power data into sub-
and supra-CP sections.</p>
</td></tr>
<tr><td><code id="Wbal__+3A_character.only">character.only</code></td>
<td>
<p>are column name arguments given as character strings? A
backdoor around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used here, while based on Dr Phil Skiba's model, differs in
that values are positive as opposed to negative. The original published model
expressed W' balance as W' minus W' expended, the latter recovering with an
exponential time course when P &lt; CP. An issue with this approach is that an
athlete might be seen to go into negative W' balance. Hence, to avoid
assumptions regarding available W', this algorithm returns W' expended (and
its recovery) as positive values; i.e. a ride is begun at 0 W' expended, and
it will <em>increase</em> in response to supra-CP efforts.
</p>
<p>It is advisable on physiological grounds to enter smoothed power values to
the function, hence this is the default behaviour. If nothing else, this
prevents an unrealistic inflation of W' values that are inconsistent with
estimates derived from power-time modelling.
</p>
<p>The essence of the algorithm can be seen in the function
<a href="https://github.com/jmackie4/cycleRtools/blob/master/tests/testthat/test_Wbal.R">test
file.</a>
</p>
<p>Note that if there are <code>NA</code> values in the power column, these are
ignored and the correspoding W' expended value assumes that of the last
available power value. <code>NA</code> values are not allowed in the time column.
</p>


<h3>Value</h3>

<p>A numeric vector of W' balance values, in kilojoules or joules for
<code>Wbal</code> or <code>Wbal_</code> respectively.
</p>


<h3>References</h3>

<p>Skiba, P. F., W. Chidnok, A. Vanhatalo, and A. M. Jones. Modeling
the Expenditure and Reconstitution of Work Capacity above Critical Power.
Med. Sci. Sports Exerc., Vol. 44, No. 8, pp. 1526-1532, 2012.
<a href="http://www.ncbi.nlm.nih.gov/pubmed/22382171">PubMed link</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cycleRdata">plot.cycleRdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ridedata)

## Basic usage.
ridedata$Wexp.kJ &lt;- Wbal(ridedata, timer.s, power.W, 310)

## Data can be noisy or "smooth"; e.g.
Wbal_noisy &lt;- Wbal(ridedata, timer.s, power.W, 310, noisy = TRUE)
Wbal_smth  &lt;- Wbal(ridedata, timer.s, power.W, 310, noisy = FALSE)

## Plot:
ylim &lt;- rev(extendrange(Wbal_noisy))  # Reverse axes.

plot(ridedata$timer.min, Wbal_noisy, type = "l", ylim = ylim,
     main = "NOISY")
plot(ridedata$timer.min, Wbal_smth, type = "l", ylim = ylim,
     main = "Smooooth")

## Example of NA handling.
d &lt;- data.frame(t = seq_len(20), pwr = rnorm(20, 300, 50), Wexp.J = NA)
d[14:16, "pwr"] &lt;- NA
d[, "Wexp.J"]   &lt;- Wbal(d, "t", "pwr", CP = 290)
print(d)

## Using underlying Rcpp function:
Wbal_(t = 1:20, P = rnorm(20, 300, 50), CP = 300)  # Values are in joules.

## End(Not run)

</code></pre>

<hr>
<h2 id='zdist_plot'>Zone-time distribution plot.</h2><span id='topic+zdist_plot'></span>

<h3>Description</h3>

<p>Display the time distribution of values within a dataset. The distribution
can also be partitioned into zones if the <code>zbounds</code> argument is not
<code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zdist_plot(data, column = "power.W", binwidth = 10, zbounds = NULL,
  character.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zdist_plot_+3A_data">data</code></td>
<td>
<p>a &quot;cycleRdata&quot; object, produced from a <code><a href="#topic+read_ride">read_ride</a></code>
function.</p>
</td></tr>
<tr><td><code id="zdist_plot_+3A_column">column</code></td>
<td>
<p>column in <code>data</code> giving the values of interest. Needn't be
quoted.</p>
</td></tr>
<tr><td><code id="zdist_plot_+3A_binwidth">binwidth</code></td>
<td>
<p>how should values in <code>column</code> be binned? E.g.
<code>bindiwdth = 10</code> will create 10 watt bins if <code>column</code> is power
data.</p>
</td></tr>
<tr><td><code id="zdist_plot_+3A_zbounds">zbounds</code></td>
<td>
<p>optional; a numeric vector of zone boundaries.</p>
</td></tr>
<tr><td><code id="zdist_plot_+3A_character.only">character.only</code></td>
<td>
<p>are column name arguments given as character strings? A
backdoor around non-standard evaluation.</p>
</td></tr>
<tr><td><code id="zdist_plot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>barplot()</code> and/or graphical
parameters (<code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; a plot is sent to the current graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

## Using power.
zdist_plot(
 data = ridedata, column = power.W,
 binwidth = 10,  # 10 watt bins.
 zbounds = c(100, 200, 300),
 xlim = c(110, 500), xlab = "Power (Watts)",
 main = "Power distribution" # Argument passed to barplot.
)

## Using speed.
zdist_plot(
  data = ridedata, column = speed.kmh,
  binwidth = 2,  # 2 km/hr bins.
  zbounds = c(10, 20, 30),
  xlab = "Speed (km/hr)",
  main = "Speed distribution"
)

## Without zone colouring (produces a warning).
zdist_plot(
  data = ridedata, column = speed.kmh,
  binwidth = 5,  # 2 km/hr bins.
  xlab = "Speed (km/hr)", main = "Dull"
)

</code></pre>

<hr>
<h2 id='zone_index'>Index zones.</h2><span id='topic+zone_index'></span>

<h3>Description</h3>

<p>Generate a vector of zone &quot;levels&quot; from an input vector and defined
boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zone_index(x, zbounds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zone_index_+3A_x">x</code></td>
<td>
<p>numeric; values to be &quot;zoned&quot;.</p>
</td></tr>
<tr><td><code id="zone_index_+3A_zbounds">zbounds</code></td>
<td>
<p>numeric; values for zone boundaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of zone values of the same length as <code>x</code>. The
number of zone levels will be <code>length(zbounds) + 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

## Best used to append to existing data.
ridedata$zone &lt;- zone_index(ridedata$power.W, c(100, 200, 300))

## How much distance was covered in each zone?
ridedata$delta.dist &lt;- c(0, diff(ridedata$distance.km))
with(ridedata, tapply(delta.dist, zone, sum, na.rm = TRUE))  # Km.

</code></pre>

<hr>
<h2 id='zone_time'>Calculate time in zones.</h2><span id='topic+zone_time'></span>

<h3>Description</h3>

<p>Given a vector of zone boundaries, sums the time spent in each zone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zone_time(data, column = "power.W", zbounds, pct = FALSE,
  character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zone_time_+3A_data">data</code></td>
<td>
<p>a &quot;cycleRdata&quot; object, produced from a <code><a href="#topic+read_ride">read_ride</a></code>
function.</p>
</td></tr>
<tr><td><code id="zone_time_+3A_column">column</code></td>
<td>
<p>the column name of the data to which the zone boundaries
relate.</p>
</td></tr>
<tr><td><code id="zone_time_+3A_zbounds">zbounds</code></td>
<td>
<p>numeric; zone boundaries.</p>
</td></tr>
<tr><td><code id="zone_time_+3A_pct">pct</code></td>
<td>
<p>should percentage values be returned?</p>
</td></tr>
<tr><td><code id="zone_time_+3A_character.only">character.only</code></td>
<td>
<p>are column name arguments given as character strings? A
backdoor around non-standard evaluation. Mainly for internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of zone times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ridedata)

## Time spent above and below critical power...
zone_time(ridedata, "power.W", zbounds = 300) / 60  # Minutes.

## Or with more zones...
zone_time(ridedata, "power.W", zbounds = c(100, 200, 300)) / 60

## Or given as a percentage...
zone_time(ridedata, "power.W", zbounds = c(100, 200, 300), pct = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
