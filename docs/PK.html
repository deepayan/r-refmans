<!DOCTYPE html><html><head><title>Help for package PK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all.class'><p>Different generic functions for class PK.</p></a></li>
<li><a href='#auc'><p>Estimation of confidence intervals for the area under the concentration versus time curve in complete and incomplete data designs</p></a></li>
<li><a href='#auc.complete'><p>Confidence intervals for the area under the concentration versus time curve in complete data designs</p></a></li>
<li><a href='#biexp'><p>Two-phase half-life estimation by biexponential model</p></a></li>
<li><a href='#ci'><p>Function to extract confidence interval(s)</p></a></li>
<li><a href='#CPI975'><p>Plasma levels of CPI975 in rats following a single oral dose</p></a></li>
<li><a href='#eqv'><p>Bioequivalence between AUCs</p></a></li>
<li><a href='#estimator'><p>Function to extract point estimate(s)</p></a></li>
<li><a href='#Glucose'><p>Baseline adjusted glucose levels following alcohol ingestion</p></a></li>
<li><a href='#lee'><p>Two-phase half-life estimation by linear fitting</p></a></li>
<li><a href='#nca'><p>Estimation of various PK parameters</p></a></li>
<li><a href='#PKNews'><p>Shows changes and news</p></a></li>
<li><a href='#plot.halflife'><p>Plot regression lines used for half-life estimation</p></a></li>
<li><a href='#Rats'><p>Plasma levels in female rats following a single oral dose</p></a></li>
<li><a href='#Rep.tox'><p>Plasma levels in rats following daily intravenous administration in a repeated dose toxicity study</p></a></li>
<li><a href='#test'><p>Function for hypothesis testing for objects of class PK</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Non-Compartmental Pharmacokinetics</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Jaki &lt;jaki.thomas@gmail.com&gt; and Martin J. Wolfsegger
        &lt;wolfseggerm@gmx.at&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Jaki &lt;jaki.thomas@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.1), utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of pharmacokinetic parameters using non-compartmental theory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-12 07:18:52 UTC; jack</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-12 09:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='all.class'>Different generic functions for class PK.</h2><span id='topic+plot.PK'></span><span id='topic+print.PK'></span><span id='topic+summary.PK'></span>

<h3>Description</h3>

<p>Generic functions for summarizing an object of class PK</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PK'
print(x, digits=max(3, getOption("digits") - 4), ...)

## S3 method for class 'PK'
summary(object, ...)

## S3 method for class 'PK'
plot(x, bygroup=FALSE, col=NULL, pch=NULL, main=NULL, xlab="Time", 
         ylab="Concentration", ylim=NULL, xlim=NULL, add=FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.class_+3A_x">x</code></td>
<td>
<p> An output object of class PK.</p>
</td></tr>
<tr><td><code id="all.class_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to be printed.</p>
</td></tr>
<tr><td><code id="all.class_+3A_object">object</code></td>
<td>
<p> An output object of class PK.</p>
</td></tr>
<tr><td><code id="all.class_+3A_bygroup">bygroup</code></td>
<td>
<p> A logical value indicating whether the plot should highlight the groups.</p>
</td></tr>
<tr><td><code id="all.class_+3A_col">col</code></td>
<td>
<p>A specification for the default plotting color (default=<code>NULL</code>). See <code>par</code> for more details.</p>
</td></tr>
<tr><td><code id="all.class_+3A_pch">pch</code></td>
<td>
<p>Either an integer specifying a symbol or a single character
to be used as the default in plotting points (default=<code>NULL</code>). See <code>par</code> for more details.</p>
</td></tr>
<tr><td><code id="all.class_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>). The default setting produces <code>"Concentration versus time plot (Design)"</code>.</p>
</td></tr>
<tr><td><code id="all.class_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis (default=<code>"time"</code>).</p>
</td></tr>
<tr><td><code id="all.class_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis (default=<code>"concentration"</code>).</p>
</td></tr>
<tr><td><code id="all.class_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2, giving the x coordinates range. (default=<code>"NULL"</code>).</p>
</td></tr>
<tr><td><code id="all.class_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates range. (default=<code>"NULL"</code>).</p>
</td></tr>
<tr><td><code id="all.class_+3A_add">add</code></td>
<td>
<p> A logical value indicating whether to add plot to current plot (default=<code>FALSE</code>). </p>
</td></tr>
<tr><td><code id="all.class_+3A_...">...</code></td>
<td>
<p>Further (graphical) arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.PK</code> produces a minimal summary of an estimation object from class PK including point estimate, standard error and confidence interval. The confidence interval is the first of <code>"boott"</code>, <code>"fieller"</code>, <code>"t"</code> or <code>"z"</code> that was originally requested. <br /><br />
</p>
<p><code>summary.PK</code> prints a more detailed summary of an estimation object from class PK. Most notably all confidence intervals originally requested are printed.<br /><br />
</p>
<p><code>plot.PK</code> produces as concentration versus time plot of the data used of an estimation object from class PK.
</p>


<h3>Value</h3>

<p>Screen or graphics output.</p>


<h3>Author(s)</h3>

<p>Thomas Jaki and Martin J. Wolfsegger</p>


<h3>References</h3>

<p>Hand, D. and Crowder, M. (1996), <em>Practical Longitudinal Data Analysis</em>, Chapman and Hall, London.<br /><br />
</p>
<p>Holder D. J., Hsuan F., Dixit R. and Soper K. (1999). A method for estimating and testing area under the curve in serial sacrifice, batch, and complete data designs. <em>Journal of Biopharmaceutical Statistics</em>, 9(3):451-464.<br /><br />
</p>
<p>Jaki T. and Wolfsegger M. J. (2009). A theoretical framework for estimation of AUCs in complete and incomplete sampling designs. <em>Statistics in Biopharmaceutical Research</em>, 1(2):176-184. <br /><br />
</p>
<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br /><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimator">estimator</a></code>, <code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+test">test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## serial sampling desing: example from Nedelman et al. (1995)
conc &lt;- c(2790, 3280, 4980, 7550, 5500, 6650, 2250, 3220, 213, 636)
time &lt;- c(1, 1, 2, 2, 4, 4, 8, 8, 24, 24)

obj &lt;- auc(conc=conc, time=time, method=c("z", "t"), design="ssd")

print(obj)

summary(obj)

## serial sampling design: example from Nedelman et al. (1995)
conc.m &lt;- c(391, 396, 649, 1990, 3290, 3820, 844, 1650, 75.7, 288)
conc.f &lt;- c(353, 384, 625, 1410, 1020, 1500, 933, 1030, 0, 80.5)
time &lt;- c(1, 1, 2, 2, 4, 4, 8, 8, 24, 24)

res1 &lt;- auc(conc=conc.m, time=time, method=c('t','z'), design='ssd')
res2 &lt;- auc(conc=conc.f, time=time, method=c('t','z'), design='ssd')

plot(res1, pch=19, ylim=c(0,5000), xlim=c(0,25))
plot(res2, pch=21, col='red', add=TRUE)
legend(x=25, y=5000, xjust=1, pch=c(19,21), col=c('black','red'), 
       legend=c('Male', 'Female'))


## batch design: example from Jaki and Wolfsegger (2009),
## originally in Holder et al. (1999) using data for call
data(Rats)

data1 &lt;- subset(Rats,Rats$dose==100)
data2 &lt;- subset(Rats,Rats$dose==300)
res1 &lt;- auc(data=data1,method='t', design='batch')
res2 &lt;- auc(data=data2,method='t', design='batch')

plot(res1, col='black', ylim=c(0,8), xlim=c(0,25))
plot(res2, col='red', add=TRUE)
legend(x=0, y=8, xjust=0, lty=1, col=c('black','red'), 
       legend=c('Dose of 100', 'Dose of 300'))

data3 &lt;- subset(Rats,Rats$dose==100 | Rats$dose==300)
data3$group &lt;- data3$dose
res3 &lt;- auc(data=data3,method='t', design='batch')
plot(res3,bygroup=TRUE)

## complete data design example
## originally in Hand and Crowler (1996)
data(Glucose)
data1 &lt;- subset(Glucose, date==1)
data2 &lt;- subset(Glucose, date==2)
res1 &lt;- auc(conc=data1$conc, time=data1$time, design='complete', method='t')
res2 &lt;- auc(conc=data2$conc, time=data2$time, design='complete', method='t')
plot(res1, pch=19, col='black', ylim=c(0,5))
plot(res2, pch=21, col='red', add=TRUE)

## more informative plot 
plot(x=c(0, 30), y=c(0, 5), type='n', main='Complete Data Design', xlab='Time', 
      ylab='Concentration')
for(i in unique(Glucose$id)){
   for(j in unique(Glucose$date)){
        temp &lt;- subset(Glucose, id==i &amp; date==j)
        col &lt;- ifelse(j==1, 'black', 'red')
        lty &lt;- ifelse(j==1, 1, 2)
        pch &lt;- ifelse(j==1, 19, 21)
	points(x=temp$time, y=temp$conc, col=col, lty=lty, pch=pch, type='b')
   }
}
legend(x=30, y=5, xjust=1, pch=c(19,21), col=c('black','red'), lty=c(1,2), 
       legend=c('Date 1', 'Date 2'))


</code></pre>

<hr>
<h2 id='auc'>Estimation of confidence intervals for the area under the concentration versus time curve in complete and incomplete data designs</h2><span id='topic+auc'></span><span id='topic+auc.ssd'></span><span id='topic+auc.batch'></span>

<h3>Description</h3>

<p>Calculation of confidence intervals for an area under the concentration versus time curve (AUC) or for the difference between two AUCs assessed in complete and incomplete data designs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(conc, time, group=NULL, method=c("t", "z", "boott"), 
     alternative=c("two.sided", "less", "greater"), 
     conf.level=0.95, strata=NULL, nsample=1000, 
     design=c("ssd","batch","complete"), data)	     

auc.ssd(conc, time, group=NULL, method=c("t", "z", "boott"), 
     alternative=c("two.sided", "less", "greater"), 
     conf.level=0.95, strata=NULL, nsample=1000, data)	     

auc.batch(conc, time, group=NULL, method=c("t", "z", "boott"), 
     alternative=c("two.sided", "less", "greater"), 
     conf.level=0.95, nsample=1000, data)	     

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_conc">conc</code></td>
<td>
<p> Levels of concentrations. For batch designs a list is required, while a vector is expected otherwise.</p>
</td></tr>
<tr><td><code id="auc_+3A_time">time</code></td>
<td>
<p> Time points of concentration assessment. For batch designs a list is required, while a vector is expected otherwise. One time point for each concentration measured needs to be specified.</p>
</td></tr>
<tr><td><code id="auc_+3A_group">group</code></td>
<td>
<p> A grouping variable (default=<code>NULL</code>). For batch designs a list is required, while a vector is expected otherwise. If specified, a confidence interval for the difference of independent AUCs will be calculated. </p>
</td></tr>
<tr><td><code id="auc_+3A_method">method</code></td>
<td>
<p> A character string specifying the method for calculation of confidence intervals (default=<code>c("t", "z", "boott")</code>). </p>
</td></tr>
<tr><td><code id="auc_+3A_alternative">alternative</code></td>
<td>
<p> A character string specifying the alternative hypothesis. Possible values are <code>"less"</code>, <code>"greater"</code> and <code>"two.sided"</code> (the default).</p>
</td></tr> 
<tr><td><code id="auc_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level (default=<code>0.95</code>). </p>
</td></tr>
<tr><td><code id="auc_+3A_strata">strata</code></td>
<td>
<p> A vector of one strata variable (default=<code>NULL</code>). Only available for method <code>boott</code> in a serial sampling design. </p>
</td></tr>
<tr><td><code id="auc_+3A_nsample">nsample</code></td>
<td>
<p> Number of bootstrap iterations for method <code>boott</code> (default=<code>1000</code>). </p>
</td></tr> 
<tr><td><code id="auc_+3A_design">design</code></td>
<td>
<p> A character string indicating the type of design used. Possible values are <code>"ssd"</code> for a serial sampling design, <code>"batch"</code> for a batch design and <code>"complete"</code> for a complete data design. </p>
</td></tr>
<tr><td><code id="auc_+3A_data">data</code></td>
<td>
<p>Optional data frame containing variables named as <code>id</code>, <code>conc</code>, <code>time</code> and <code>group</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of confidence intervals for an AUC (from 0 to the last time point) or for the difference between two AUCs for serial sampling, batch and complete data designs. In a serial sampling design only one measurement is available per subject, while in a batch design multiple (but not necessarily all) time points are measured for each subject. In a complete data design measurements are taken for all subjects at all time points. The AUC (from 0 to the last time point) is calculated using the linear trapezoidal rule on the arithmetic means at the different time points.<br /><br />
</p>
<p>If group=NULL a confidence interval for an AUC is calculated. If group specifies a factor variable with exactly two levels, a confidence interval for the difference between two independent AUCs is calculated. To obtain confidence intervals for dependent AUCs simply use the difference in concentrations for <code>conc</code>. See the example below.<br /><br />
</p>
<p>The <code>t</code> method uses the critical value from a t-distribution with Satterthwaite's approximation (Satterthwaite, 1946) to the degrees of freedom for calculation of confidence intervals as presented in Tang-Liu and Burke (1988), Nedelman et al (1995), Holder et al (1999), Jaki and Wolfsegger (2009) and Jaki and Wolfsegger (2012). The <code>z</code> method uses the critical value from a normal distribution for calculation of confidence intervals as presented in Bailer (1988) or in Jaki and Wolfsegger (2009). The <code>boott</code> method uses bootstrap-<em>t</em> confidence intervals as presented in Jaki and Wolfsegger (2009). Using <code>boott</code> an additional strata variable for bootstrapping can be specified in the case of serial sampling. <br /><br />
</p>
<p>For serial sampling designs missing data are omitted and unequal sample sizes per time point are allowed. For batch designs missing values are not permitted and at least two subjects are required per batch.<br /><br />
</p>
<p>If <code>data</code> is specified the variable names <code>conc</code>, <code>time</code> and <code>group</code> are required and represent the corresponding variables. If <code>design</code> is <code>batch</code> an additional variable <code>id</code> is required to identify the subject.<br /><br />
</p>
<p>NOTE: Confidence intervals for AUCs assessed in complete data designs are found using a batch design with one batch based on the asymptotic normal distribution. Conventionally, AUCs are assumed to be log-normal distributed. See the help file <a href="#topic+auc.complete">auc.complete</a> for some corresponding examples.
</p>


<h3>Value</h3>

<p>An object of the class PK  containing the following components: <br /> 
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>Point estimates.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>Point estimates, standard errors and confidence intervals. </p>
</td></tr>
<tr><td><code>conc</code></td>
<td>
<p>Levels of concentrations. </p>
</td></tr> 
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>Sampling design used.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Grouping variable.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time points measured.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a wrapper function for <code><a href="#topic+auc.complete">auc.complete</a>, <a href="#topic+auc.batch">auc.batch</a></code> and <code><a href="#topic+auc.ssd">auc.ssd</a></code>. 
The function calculates point and interval estimates for AUC (from 0 to the last time point).</p>


<h3>Author(s)</h3>

<p>Thomas Jaki and Martin J. Wolfsegger</p>


<h3>References</h3>

<p>Bailer A. J. (1988). Testing for the equality of area under the curves when using destructive measurement techniques. <em>Journal of Pharmacokinetics and Biopharmaceutics</em>, 16(3):303-309. <br /><br />
</p>
<p>Gibaldi M. and Perrier D. (1982). <em>Pharmacokinetics</em>. Marcel Dekker, New York and Basel.<br /><br />
</p>
<p>Holder D. J., Hsuan F., Dixit R. and Soper K. (1999). A method for estimating and testing area under the curve in serial sacrifice, batch, and complete data designs. <em>Journal of Biopharmaceutical Statistics</em>, 9(3):451-464.<br /><br />
</p>
<p>Jaki T. and Wolfsegger M. J. (2012). Non-compartmental estimation of pharmacokinetic parameters for flexible sampling designs. <em>Statistics in Medicine</em>, 31(11-12):1059-1073. <br /><br />
</p>
<p>Jaki T. and Wolfsegger M. J. (2009). A theoretical framework for estimation of AUCs in complete and incomplete sampling designs. <em>Statistics in Biopharmaceutical Research</em>, 1(2):176-184. <br /><br />
</p>
<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br /><br />
</p>
<p>Satterthwaite F. E. (1946). An approximate distribution of estimates of variance components. <em>Biometrics Bulletin</em>, 2:110-114.  <br /><br />
</p>
<p>Tang-Liu D. D.-S. and Burke P. J. (1988). The effect of azone on ocular levobunolol absoprtion: Calculating the area under the curve and its standard error using tissue sampling compartments. <em>Pharmaceutical Research</em>, 5(4):238-241. <br /><br />
</p>
<p>Wolfsegger M. J. and Jaki T. (2009) Assessing systemic drug exposure in repeated dose toxicity studies in the case of complete and incomplete sampling. <em>Biometrical Journal</em>, 51(6):1017:1029.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc.complete">auc.complete</a></code>, <code><a href="#topic+nca">nca</a></code>, <code><a href="#topic+eqv">eqv</a></code>, <code><a href="#topic+estimator">estimator</a></code>, <code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+test">test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### serial sampling design:
## example from Bailer (1988)
time &lt;- c(rep(0,4), rep(1.5,4), rep(3,4), rep(5,4), rep(8,4))
grp1 &lt;- c(0.0658, 0.0320, 0.0338, 0.0438, 0.0059, 0.0030, 0.0084,
          0.0080, 0.0000, 0.0017, 0.0028, 0.0055, 0.0000, 0.0037,
          0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000)

grp2 &lt;- c(0.2287, 0.3824, 0.2402, 0.2373, 0.1252, 0.0446, 0.0638,
          0.0511, 0.0182, 0.0000, 0.0117, 0.0126, 0.0000, 0.0440,
          0.0039, 0.0040, 0.0000, 0.0000, 0.0000, 0.0000)

grp3 &lt;- c(0.4285, 0.5180, 0.3690, 0.5428, 0.0983, 0.0928, 0.1128,
          0.1157, 0.0234, 0.0311, 0.0344, 0.0349, 0.0032, 0.0052,
          0.0049, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000)

auc(conc=grp1, time=time, method='z', design='ssd')
auc(conc=grp2, time=time, method='z', design='ssd')
auc(conc=grp3, time=time, method='z', design='ssd')

## function call with data frame using simultaneous confidence intervals based 
## on bonferroni adjustment
data &lt;- data.frame(conc=c(grp1, grp2, grp3), time=rep(time, 3),
                   group=c(rep(1, length(grp1)), rep(2, length(grp2)), 
                   rep(3, length(grp3))))

auc(subset(data, group==1 | group==2)$conc, subset(data, group==1 | group==2)$time, 
    group=subset(data, group==1 | group==2)$group, method=c('z', 't'), 
    conf.level=1-0.05/3, design='ssd')

auc(subset(data, group==1 | group==3)$conc, subset(data, group==1 | group==2)$time, 
    group=subset(data, group==1 | group==3)$group, method=c('z', 't'), 
    conf.level=1-0.05/3, design='ssd')

auc(subset(data, group==2 | group==3)$conc, subset(data, group==1 | group==2)$time, 
    group=subset(data, group==2 | group==3)$group, method=c('z', 't'), 
    conf.level=1-0.05/3, design='ssd')

## example from Nedelman et al. (1995)
data(CPI975)
data &lt;- CPI975[CPI975[,'dose']&gt;=30 ,]

auc(data=subset(data,sex=='m' &amp; dose==30), method=c('z', 't'), design='ssd')
auc(data=subset(data,sex=='f' &amp; dose==30), method=c('z', 't'), design='ssd')

auc(data=subset(data,sex=='m' &amp; dose==100), method=c('z', 't'), design='ssd')
auc(data=subset(data,sex=='f' &amp; dose==100), method=c('z', 't'), design='ssd')

## comparing dose levels
data$concadj &lt;- data$conc / data$dose
data.100 &lt;- subset(data, dose==100)
data.030 &lt;- subset(data, dose==30)
res.100 &lt;- auc(conc=data.030$concadj, time=data.030$time, method='t', design='ssd')
res.030 &lt;- auc(conc=data.100$concadj, time=data.100$time, method='t', design='ssd')
plot(res.030, ylim=c(0, 140), xlim=c(0,25), pch=19, ylab='Dose-normalized concentration', 
      main='Comparison of doses')
plot(res.100, col='red', pch=21, add=TRUE)
legend(x=25, y=140, xjust=1, lty=1, col=c('black','red'), 
       legend=c('Dose of 30', 'Dose of 100'))

res &lt;- auc(conc=data$concadj, time=data$time, group=data$dose, method=c('t','z'), 
            design='ssd')
print(res)
summary(res)

## comparing two dose level using stratified resampling per gender
## caution this might take a few minutes
set.seed(260151)
auc(conc=data$concadj, time=data$time, group=data$dose, method='boott',
    strata=data$sex, design='ssd', nsample=500)

#### batch design:
## a batch design example from Holder et al. (1999).
data(Rats)
data &lt;- subset(Rats,Rats$dose==100)

# two-sided CI: data call
auc(data=data,method=c('z','t'), design='batch')
# one-sided CI: data call
auc(data=data,method=c('z','t'), alternative="less", design='batch')

## difference of two AUCs in batch design from Jaki and Wolfsegger (2009),
## originally in Holder et al. (1999).
data &lt;- subset(Rats,Rats$dose==100 | Rats$dose==300 )
data$group &lt;- data$dose
data$conc &lt;- data$conc / data$dose

## data call
res1 &lt;- auc(data=subset(data, dose==100), method='z', design='batch')
res2 &lt;- auc(data=subset(data, dose==300), method='z', design='batch')
plot(res1, col='black', ylim=c(0,0.06), xlim=c(0,25), ylab='Dose-normalized concentration', 
      main='Comparison of doses')
plot(res2, col='red', add=TRUE)
legend(x=0, y=0.06, lty=1, col=c('black','red'), 
       legend=c('Dose of 100', 'Dose of 300'))

auc(data=data, method='z', design='batch')


## difference of two dependent AUCs in a batch design from Wolfsegger and Jaki (2009)
conc &lt;- list(batch1=c(0.46,0.2,0.1,0.1, 1.49,1.22,1.27,0.53, 0.51,0.36,0.44,0.28),
             batch2=c(1.51,1.80,2.52,1.91, 0.88,0.66,0.96,0.48),
             batch3=c(1.52,1.46,2.55,1.04, 0.54,0.61,0.55,0.27))
time &lt;- list(batch1=c(0,0,0,0,1.5,1.5,1.5,1.5,10.5,10.5,10.5,10.5),
             batch2=c(5/60,5/60,5/60,5/60,4,4,4,4),
             batch3=c(0.5,0.5,0.5,0.5,7,7,7,7))
group &lt;- list(batch1=c(1,1,2,2,1,1,2,2,1,1,2,2),batch2=c(1,1,2,2,1,1,2,2),
              batch3=c(1,1,2,2,1,1,2,2))

# find difference in concentration and the corresponding times
dconc &lt;- NULL
dtime &lt;- NULL
grps &lt;- unique(unlist(group))
B &lt;- length(conc)
for(i in 1:B){
    dconc[[i]] &lt;- conc[[i]][group[[i]]==grps[1]] - conc[[i]][group[[i]]==grps[2]]
    dtime[[i]] &lt;- time[[i]][group[[i]]==grps[1]]
}
names(dconc) &lt;- names(conc)

auc(conc=dconc, time=dtime, group=NULL, method="t", conf.level=0.90, design="batch")

## example with overlapping batches (Treatment A in Example of Jaki &amp; Wolfsegger 2012)
conc &lt;- list(batch1=c(0,0,0,0, 69.7,37.2,213,64.1,  167,306,799,406, 602,758,987,627,
                      1023,1124,1301,880, 1388,1374,1756,1120, 1481,1129,1665,1598,
                      1346,1043,1529,1481, 658,576,772,851, 336,325,461,492, 
                      84,75.9,82.6,116),
             batch2=c(0,0,0, 29.2,55.9,112.2, 145,153,169, 282,420,532, 727,1033,759, 
                      1360,1388,1425, 1939,1279,1318, 1614,1205,1542, 1238,1113,1386,
                      648,770,786, 392,438,511, 77.3,90.1,97.9))
time &lt;- list(batch1=rep(c(0,0.5,0.75,1,1.5,2,3,4,8,12,24),each=4),
             batch2=rep(c(0,0.25,0.5,0.75,1,1.5,2,3,4,8,12,24),each=3))

auc.batch(conc,time,method=c("t","z"),conf.level=0.9)

#### complete data design:
## example from Gibaldi and Perrier (1982, page 436) for an individual AUC
time &lt;- c(0, 0.165, 0.5, 1, 1.5, 3, 5, 7.5, 10)
conc &lt;- c(0, 65.03, 28.69, 10.04, 4.93, 2.29, 1.36, 0.71, 0.38)
auc(conc=conc, time=time, design="complete")

## data Indometh
require(datasets)
Indometh$id &lt;- as.character(Indometh$Subject)
Indometh &lt;- Indometh[order(Indometh$id, Indometh$time),]
Indometh &lt;- Indometh[order(Indometh$time),]
res &lt;- auc.complete(conc=Indometh$conc, time=Indometh$time, method='t')
plot(res)

## more informative plot 
split.screen(c(1,2))
screen(1)
plot(x=c(0,8), y=c(0, 3), type='n', main='Observed concentration time-profiles', 
     xlab='Time', ylab='Concentration', las=1)
for(i in unique(Indometh$Subject)){
   temp &lt;- subset(Indometh, Subject==i)
   points(x=temp$time, y=temp$conc, type='b')
}
screen(2)
plot(x=c(0,8), y=c(0.01, 9), type='n', main='Log-linear concentration time-profiles', 
     xlab='Time', ylab='Log of concentration', yaxt='n', log='y')
axis(side=2, at=c(0.01, 0.1, 1, 10), labels=c('0.01', '0.1', '1', '10'), las=1)
axis(side=2, at=seq(0.01, 0.1, 0.01), tcl=-0.2, labels=FALSE)
axis(side=2, at=seq(0.1, 1, 0.1), tcl=-0.2, labels=FALSE)
axis(side=2, at=seq(1, 10, 1), tcl=-0.2, labels=FALSE)
for(i in unique(Indometh$Subject)){
   temp &lt;- subset(Indometh, Subject==i)
   points(x=temp$time, y=temp$conc, type='b')
}
close.screen(all = TRUE)
</code></pre>

<hr>
<h2 id='auc.complete'>Confidence intervals for the area under the concentration versus time curve in complete data designs</h2><span id='topic+auc.complete'></span>

<h3>Description</h3>

<p>Examples to find confidence intervals for the area under the concentration versus time curve (AUC) in complete data designs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc.complete(conc, time, group=NULL, method=c("t", "z", "boott"), 
        alternative=c("two.sided", "less", "greater"), 
        conf.level=0.95, nsample=1000, data) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc.complete_+3A_conc">conc</code></td>
<td>
<p> Levels of concentrations as a vector. </p>
</td></tr>
<tr><td><code id="auc.complete_+3A_time">time</code></td>
<td>
<p> Time points of concentration assessment as a vector. One time point for each concentration measured needs to be specified.</p>
</td></tr>
<tr><td><code id="auc.complete_+3A_group">group</code></td>
<td>
<p> A grouping variable as a vector (default=<code>NULL</code>). If specified, a confidence interval for the difference of independent AUCs will be calculated. </p>
</td></tr>
<tr><td><code id="auc.complete_+3A_method">method</code></td>
<td>
<p> A character string specifying the method for calculation of confidence intervals (default=<code>c("t", "z", "boott")</code>). </p>
</td></tr>
<tr><td><code id="auc.complete_+3A_alternative">alternative</code></td>
<td>
<p> A character string specifying the alternative hypothesis. Possible values are <code>"less"</code>, <code>"greater"</code> and <code>"two.sided"</code> (the default). </p>
</td></tr> 
<tr><td><code id="auc.complete_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level (default=<code>0.95</code>). </p>
</td></tr>
<tr><td><code id="auc.complete_+3A_nsample">nsample</code></td>
<td>
<p> Number of bootstrap iterations for method <code>boott</code> (default=<code>1000</code>). </p>
</td></tr> 
<tr><td><code id="auc.complete_+3A_data">data</code></td>
<td>
<p>Optional data frame containing variables named as <code>conc</code>, <code>time</code> and <code>group</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes confidence intervals for an AUC (from 0 to the last time point) or for the difference between two AUCs in complete data designs. <br /><br />
</p>
<p>To compute confidence intervals in complete data designs the design is treated as a batch design with a single batch. More information can therefore be found under <code><a href="#topic+auc">auc</a></code>. A corresponding reminder message is produced if confidence intervals can be computed, ie when at least 2 measurements at each time point are available.<br /><br />
</p>
<p>The above approach, though correct, is often inefficient and so we will illustrate alternative methods in this help file. A general implementation is not provided as the most efficient analysis strongly depends on the context. The interested reader is refered to chapter 8 of Cawello (2003).<br /><br />
</p>
<p>If <code>data</code> is specified the variable names <code>conc</code>, <code>time</code> and <code>group</code> are required and represent the corresponding variables. 
</p>


<h3>Value</h3>

<p>An object of the class PK  containing the following components: <br /> 
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>Point estimates.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>Point estimates, standard errors and confidence intervals. </p>
</td></tr>
<tr><td><code>conc</code></td>
<td>
<p>Levels of concentrations. </p>
</td></tr> 
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>Sampling design used.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Grouping variable.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time points measured.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Jaki and Martin Wolfsegger</p>


<h3>References</h3>

<p>Cawello W. (2003). <em>Parameters for Compartment-free Pharmacokinetics. Standardisation of Study Design, Data Analysis and Reporting</em>. Shaker Verlag, Aachen. <br /><br />
</p>
<p>Gibaldi M. and Perrier D. (1982). <em>Pharmacokinetics</em>. Marcel Dekker, New York and Basel.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+estimator">estimator</a></code>, <code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+test">test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from Gibaldi and Perrier (1982, page 436) for an individual AUC
time &lt;- c(0, 0.165, 0.5, 1, 1.5, 3, 5, 7.5, 10)
conc &lt;- c(0, 65.03, 28.69, 10.04, 4.93, 2.29, 1.36, 0.71, 0.38)
auc.complete(conc=conc, time=time)

## dataset Indometh of package datasets
## calculate individual AUCs
require(datasets)
row &lt;- 1
res &lt;- data.frame(matrix(nrow=length(unique(Indometh$Subject)), ncol=2))
colnames(res) &lt;- c('id', 'auc')
for(i in unique(Indometh$Subject)){
   temp &lt;- subset(Indometh, i==Subject)
   res[row, 1] &lt;- i
   res[row, 2] &lt;- auc.complete(data=temp[,c("conc","time")])$est[1,1]
   row &lt;- row + 1
}
print(res)

# function to get geometric mean and corresponding CI
gm.ci &lt;- function(x, conf.level=0.95){
   res &lt;- t.test(x=log(x), conf.level=conf.level)
   out &lt;- data.frame(gm=as.double(exp(res$estimate)), lower=exp(res$conf.int[1]), 
                      upper=exp(res$conf.int[2]))
   return(out)
}    

# geometric mean and corresponding CI: assuming log-normal distributed AUCs
gm.ci(res[,2], conf.level=0.95)

# arithmetic mean and corresponding CI: assuming normal distributed AUCs 
# or at least asymptotic normal distributed arithmetic mean 
t.test(x=res[,2], conf.level=0.95)
     
# alternatively: function auc.complete
set.seed(300874)
Indometh$id &lt;- as.character(Indometh$Subject)
Indometh &lt;- Indometh[order(Indometh$id, Indometh$time),]
Indometh &lt;- Indometh[order(Indometh$time),]
auc.complete(conc=Indometh$conc, time=Indometh$time, method=c("t"))


## example for comparing AUCs assessed in a repeated complete data design
## (dataset: Glucose)
## calculate individual AUCs
data(Glucose)
res &lt;- data.frame(matrix(nrow=length(unique(Glucose$id))*2, ncol=3))
colnames(res) &lt;- c('id', 'date', 'auc')
row &lt;- 1
for(i in unique(Glucose$id)){
  for(j in unique(Glucose$date)){
     temp &lt;- subset(Glucose, id==i &amp; date==j)
     res[row, c(1,2)] &lt;- c(i,j)
     res[row, 3] &lt;- auc.complete(data=temp[,c("conc","time")])$est[1,1]
     row &lt;- row + 1
  }
}
res &lt;- res[order(res$id, res$date),]
print(res)

# assuming log-normally distributed AUCs
# geometric means and corresponding two-sided CIs per date           
tapply(res$auc, res$date, gm.ci)

# comparison of AUCs using ratio of geometric means and corresponding two-sided CI 
# repeated experiment
res1&lt;-reshape(res, idvar = "id", timevar = "date", direction = "wide")
model &lt;- t.test(Pair(log(auc.1),log(auc.2))~1,data=res1)
exp(as.double(model$estimate))
exp(model$conf.int)
</code></pre>

<hr>
<h2 id='biexp'>Two-phase half-life estimation by biexponential model</h2><span id='topic+biexp'></span>

<h3>Description</h3>

<p>Estimation of initial and terminal half-life by fitting a biexponential model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>biexp(conc, time, log.scale=FALSE, tol=1E-9, maxit=500)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biexp_+3A_conc">conc</code></td>
<td>
<p> Levels of concentrations as a vector. </p>
</td></tr>
<tr><td><code id="biexp_+3A_time">time</code></td>
<td>
<p> Time points of concentration assessment as a vector. One time point for each concentration measured needs to be specified.</p>
</td></tr>
<tr><td><code id="biexp_+3A_log.scale">log.scale</code></td>
<td>
<p> Logical value indicating whether fitting is performed on the observed or log-scale (default=<code>FALSE</code>). </p>
</td></tr>
<tr><td><code id="biexp_+3A_tol">tol</code></td>
<td>
<p> Relative error tolerance (default=<code>1E-9</code>). </p>
</td></tr> 
<tr><td><code id="biexp_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations (default=<code>500</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of initial and terminal half-life using the biexponential <code>y=a1*exp(-b1*x)+a2*exp(-b2*x)</code> model with a parameterization to ensure b1 &gt; b2 &gt; 0 fitted by the least squares criteria with function <code>optim</code> of package <code>base</code> with <code>method</code> &quot;Nelder-Mead&quot;. Curve peeling (Foss, 1969) is used get start values for nonlinear model fitting. When no adequate starting values are 
determined by curve peeling, a single exponential model is fitted with starting values obtained from an OLS regression on log transformed values with a parameterization to ensure a slope &gt; 0. <br /><br />
</p>
<p>Fitting on the log-scale is based on the transform-both-sides approach described for example in chapter 4 of Bonate (2006) which is useful for some error distributions. An additional discussion regarding weighting schemes can be found in Gabrielsson and Weiner (2000, pages 368-374).
</p>


<h3>Value</h3>

<p>A list of S3 class <code>"halflife"</code> containing the following components: <br />
</p>
<table>
<tr><td><code>parms</code></td>
<td>
<p> half-life and model estimates.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p> time points of concentration assessments. </p>
</td></tr>
<tr><td><code>conc</code></td>
<td>
<p> levels of concentrations. </p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p> &quot;biexp&quot;. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Records including missing values and values below or equal to zero are omitted. </p>


<h3>Author(s)</h3>

<p>Martin J. Wolfsegger and Thomas Jaki</p>


<h3>References</h3>

<p>Bonate P. L. (2006). <em>Pharmacokinetic-Pharmacodynamic Modeling and Simulation</em>. Springer, New York. <br /><br />
</p>
<p>Gabrielsson J. and Weiner D. (2000). <em>Pharmacokinetic and Pharmacodynamic Data Analysis: Concepts and Applications</em>. 4th Edition. Swedish Pharmaceutical Press, Stockholm. <br /><br />
</p>
<p>Foss S. D. (1969). A Method for Obtaining Initial Estimates of the Parameters in Exponential Curve Fitting. <em>Biometrics</em>, 25:580-584. <br /><br />
</p>
<p>Pinheiro J. C. and Bates D. M. (2000). <em>Mixed-Effects Models in S and S-PLUS</em>. Springer, New York. <br /><br />
</p>
<p>Wolfsegger M. J. and Jaki T. (2009). Non-compartmental Estimation of Pharmacokinetic Parameters in Serial Sampling Designs. <em>Journal of Pharmacokinetics and Pharmacodynamics</em>, 36(5):479-494. <br />	
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lee">lee</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example from Pinheiro J.C. and Bates D.M. (2000, page 279)
#### dataset Indometh of package datasets
require(datasets)
data &lt;- subset(Indometh, Subject==2) 
time &lt;- data$time
conc &lt;- data$conc 

## fitting on observed and log-scale
res.obs &lt;- biexp(conc=conc, time=time, log.scale=FALSE)
res.log &lt;- biexp(conc=conc, time=time, log.scale=TRUE)

print(res.obs$parms)
print(res.log$parms)

plot(res.obs, ylim=c(0,5), xlim=c(0, max(time)), las=1)
plot(res.log, ylim=c(0,5), xlim=c(0, max(time)), las=1, add=TRUE, lty=2)
legend(x=0, y=5, lty=c(1,2), legend=c("fitted on observed scale", "fitted on log-scale"))

## get residuals using function nls with tol=Inf
parms.obs &lt;- list(a1=res.obs$parms[3,1], b1=res.obs$parms[2,1], a2=res.obs$parms[3,2], 
                  b2=res.obs$parms[2,2])
parms.log &lt;- list(a1=res.log$parms[3,1], b1=res.log$parms[2,1], a2=res.log$parms[3,2], 
                  b2=res.log$parms[2,2])

mod.obs &lt;- nls(conc ~ a1*exp(-b1*time) + a2*exp(-b2*time), start=parms.obs, 
               control=nls.control(tol=Inf))
mod.log &lt;- nls(conc ~ a1*exp(-b1*time) + a2*exp(-b2*time), start=parms.log, 
               control=nls.control(tol=Inf))

## identical estimates to mod.log but different SEs  
summary(nls(log(conc)~log(a1*exp(-b1*time) + a2*exp(-b2*time)), start=parms.log, 
        control=nls.control(tol=Inf)))

## different approach using weighted least squares (WLS) in nls 
mod.ols &lt;- nls(conc ~ a1*exp(-b1*time) + a2*exp(-b2*time), start=parms.obs)
mod.wls1 &lt;- nls(conc ~ a1*exp(-b1*time) + a2*exp(-b2*time), start=parms.obs, 
                weight=1/predict(mod.ols)^1)
mod.wls2 &lt;- nls(conc ~ a1*exp(-b1*time) + a2*exp(-b2*time), start=parms.obs, 
                weight=1/predict(mod.ols)^2)

split.screen(c(2,2))
screen(1)
plot(ylim=c(-0.35,0.35), y=resid(mod.obs), x=predict(mod.obs), las=1, 
    main='Fitted using biexp on observed scale', xlab='Predicted', ylab='Residual')
abline(h=0)
screen(2)
plot(ylim=c(-0.35,0.35), y=resid(mod.log), x=predict(mod.log), las=1, 
     main='Fitted using biexp on log-scale', xlab='Predicted', ylab='Residual')
abline(h=0)
screen(3)
plot(ylim=c(-0.35,0.35), y=resid(mod.wls1), x=predict(mod.wls1), las=1, 
     main='Fitted using nls with weights 1/predict(mod.ols)^1', xlab='Predicted', ylab='Residual')
abline(h=0)
screen(4)
plot(ylim=c(-0.35,0.35), y=resid(mod.wls2), x=predict(mod.wls2), las=1, 
     main='Fitted using nls with weights 1/predict(mod.ols)^2', xlab='Predicted', ylab='Residual')
abline(h=0) 
close.screen(all.screens=TRUE)


#### example for a serial sampling data design from Wolfsegger and Jaki (2009)
conc &lt;- c(2.01, 2.85, 2.43, 0.85, 1.00, 0.91, 0.46, 0.35, 0.63, 0.39, 0.32, 
          0.45, 0.11, 0.18, 0.19, 0.08, 0.09, 0.06)
time &lt;- c(rep(5/60,3), rep(3,3), rep(6,3), rep(9,3), rep(16,3), rep(24,3))

res.biexp1 &lt;- biexp(conc=conc, time=time, log=TRUE)
res.biexp2 &lt;- biexp(conc=conc, time=time, log=FALSE)

print(res.biexp1$parms)
print(res.biexp2$parms)

split.screen(c(1,2)) 
screen(1)
plot(x=c(0,25), y=c(0,3), type='n', las=1, 
ylab='Plasma concentration (IU/mL)', xlab='Time (hours)')
points(x=time, y=conc, pch=21)
plot(res.biexp1, pch=NA, add=TRUE, lty=1)
plot(res.biexp2, pch=NA, add=TRUE, lty=2)
legend(x=25, y=3, xjust=1, col=c('black', 'black'), lty=c(1,2), 
        title='Nonlinear fitting with function biexp:', 
        legend=c('option: log=TRUE', 'option: log=FALSE'))
close.screen(1)
screen(2)
plot(x=c(0,25), y=c(0.01, 10), type='n', log='y', yaxt='n', 
ylab='Plasma concentration (IU/mL)', xlab='Time (hours)')
axis(side=2, at=c(0.01, 0.1, 1, 10), labels=c('0.01', '0.1', '1', '10'), las=1)
axis(side=2, at=seq(2,9,1), tcl=-0.25, labels=FALSE) 
axis(side=2, at=seq(0.2,0.9,0.1), tcl=-0.25, labels=FALSE) 
axis(side=2, at=seq(0.02,0.09,0.01), tcl=-0.25, labels=FALSE) 
points(x=time, y=conc, pch=21)
plot(res.biexp1, pch=NA, add=TRUE, lty=1)
plot(res.biexp2, pch=NA, add=TRUE, lty=2)
legend(x=25, y=10, xjust=1, col=c('black', 'black'), lty=c(1,2), 
        title='Nonlinear fitting with function biexp:', 
        legend=c('option: log=TRUE', 'option: log=FALSE'))
close.screen(all.screens=TRUE)


#### example from Gabrielsson and Weiner (2000, page 743) 
#### endogenous concentration is assumed to be constant over time  
dose &lt;- 36630  
time &lt;- c(-1, 0.167E-01, 0.1167, 0.1670, 0.25, 0.583, 0.8330, 1.083, 1.583, 2.083, 4.083, 8.083,
          12, 23.5, 24.25, 26.75, 32)
conc &lt;- c(20.34, 3683, 884.7, 481.1, 215.6, 114, 95.8, 87.89, 60.19, 60.17, 34.89, 20.99, 20.54, 
          19.28, 18.18, 19.39, 22.72)
data &lt;- data.frame(conc,time)

## get starting values using function biexp using naive adjustment for endogenous concentration 
## by subtraction of pre-value
data$concadj &lt;- data$conc - data$conc[1]
data$concadj[min(which(data$concadj&lt;0)):nrow(data)] &lt;- NA
res.biexp &lt;- biexp(conc=data$concadj[-1], time=data$time[-1])$parms 
start &lt;- list(a1=res.biexp[3,1], k1=res.biexp[2,1], a2=res.biexp[3,2], k2=res.biexp[2,2])  

## specify indicator variable enabling inclusion of pre-dose concentration for fitting  
data$i1 &lt;- ifelse(data$time &lt;0, 1, 0)
data$i2 &lt;- ifelse(data$time &lt;0, 0, 1)

## assuming constant absolute error: ordinary least squares 
mod.ols &lt;- nls(conc ~ i1*base + i2*(base + a1*exp(-k1*time) + a2*exp(-k2*time)), 
               start=c(base=20.34, start), data=data, trace=TRUE)
 
## assuming constant relative error (i.e. proportional error - weight of 2): weighted least
## squares
mod.wls &lt;- nls(conc ~ i1*base + i2*(base + a1*exp(-k1*time) + a2*exp(-k2*time)), 
               start=c(base=20.34, start), data=data, weight=1/predict(mod.ols)^2, trace=TRUE) 

## assuming constant relative error (i.e. proportional error - weight of 2): iteratively 
## re-weighted least squares 
mod.irwls &lt;- mod.wls 
for(i in 1:10){ 
   print(as.vector(coef(mod.irwls))) 
   mod.irwls &lt;- nls(conc ~ i1*base + i2*(base + a1*exp(-k1*time) + a2*exp(-k2*time)), 
                    start=c(base=20.34, start), data=data, weight=1/predict(mod.irwls)^2)
}
 
summary(mod.ols)
summary(mod.wls)
summary(mod.irwls)

newdata &lt;- data.frame(time=seq(0,32,0.01))
newdata$i1 &lt;- ifelse(newdata$time &lt;0, 1, 0)
newdata$i2 &lt;- ifelse(newdata$time &lt;0, 0, 1)
plot(conc ~ time, data=data, ylim=c(10,1E4), log='y', yaxt='n', 
     xlab='Time (hours)', ylab='Log of concentration (pmol/L)')
axis(side=2, at=c(10, 100, 1000, 10000), las=1)
axis(side=2, at=seq(1E1,1E2,1E1), tcl=-0.25, labels=FALSE) 
axis(side=2, at=seq(1E2,1E3,1E2), tcl=-0.25, labels=FALSE) 
axis(side=2, at=seq(1E3,1E4,1E3), tcl=-0.25, labels=FALSE) 
points(x=newdata$time, y=predict(mod.irwls, newdata), type='l')

## get total clearance (cls), inter-compartmental distribution (cld), and volume of distributions 
## from macro constant parametrization according to Gabrielsson and Weiner (2000) 
parm &lt;- coef(mod.wls)[-1]
## get micro constants 
k21 &lt;- as.double((parm[1]*parm[4]+parm[3]*parm[2])/(parm[1]+parm[3]))
k10 &lt;- as.double(parm[2]*parm[4] / k21)
k12 &lt;- as.double(parm[2]+parm[4] - k21 - k10)
## get cls, cld, vc, and vt 
cls &lt;- as.double(dose / (parm[1]/parm[2] + parm[3]/parm[4])) 
vc &lt;- as.double(dose / (parm[1] + parm[2]))
cld &lt;- k12*vc 
vt &lt;- cld / k21 
print(c(cls, cld, vc, vt))

## turnover model to account for endogenous baseline according to Gabrielsson and Weiner 
## using a biexponential (i.e. two-compartment) model parametrized in terms of clearance 

## Not run: require(rgenoud)
require(deSolve)

k &lt;- 2 # assuming proportional error - weighting in function objfun 
tinf &lt;- 1/60 # duration of bolus in hours 
data &lt;- subset(data, time&gt;0) 

defun &lt;- function(time, y, parms) { 
	rte1 &lt;- ifelse(time &lt;= tinf, dose/tinf, 0)
	dCptdt1 &lt;- (rte1 + parms["synt"] - parms["cls"]*y[1] - parms["cld"]*y[1] + 
                    parms["cld"]*y[2]) / parms["vc"]
	dCptdt2 &lt;- (parms["cld"]*y[1] - parms["cld"]*y[2])/parms["vt"] 
	list(c(dCptdt1, dCptdt2))
}

modfun &lt;- function(time, synt, cls, cld, vc, vt) {
	out &lt;- lsoda(y=c(synt/cls, synt/cls), times=c(0, data$time), defun, 
                parms=c(synt=synt, cls=cls, cld=cld, vc=vc, vt=vt), rtol=1e-5, atol=1e-5)[-1,2]
} 

objfun &lt;- function(par) {
        out &lt;- modfun(data$time, par[1], par[2], par[3], par[4], par[5])
        gift &lt;- which(data$conc != 0 )
        sum((data$conc[gift]-out[gift])^2 / data$conc[gift]^k)		
}        

## grid search to get starting values for Nelder-Mead 
## increase values of pop.size and max.generation to get better starting values  
## values of 10 are used for illustration purpose only 
options(warn = -1) # omit warning when hard maximum limit is hit
gen &lt;- genoud(objfun, nvars=5, max=FALSE, pop.size=10, max.generation=10,
             starting.value=c(1500, cls, cld, vc, vt), BFGS=FALSE,
             print.level=1, boundary.enforcement=2,
             Domains=matrix(c(0,0,0,0,0,1E4,1E3,1E3,1E3,1E3),5,2),
             MemoryMatrix=TRUE)
options(warn = 0) # set back to default  

opt &lt;- optim(gen$par, objfun, method="Nelder-Mead") 

trn.wls &lt;- nls(conc ~ modfun(time, synt, cls, cld, vc, vt), data=data, 
               start=list(synt=opt$par[1], cls=opt$par[2], cld=opt$par[3], vc=opt$par[4], 
                          vt=opt$par[5]), 
               trace=TRUE, nls.control(tol=Inf))

summary(trn.wls) 

## End(Not run)
</code></pre>

<hr>
<h2 id='ci'>Function to extract confidence interval(s)</h2><span id='topic+ci'></span>

<h3>Description</h3>

<p>Generic function that extracts the confidence interval(s) of an object of class PK.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(obj, method=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_obj">obj</code></td>
<td>
<p> An output object of class PK.</p>
</td></tr>
<tr><td><code id="ci_+3A_method">method</code></td>
<td>
<p>A character string specifying the method of the confidence interval. If <code>NULL</code> (default) all intervals are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to allow easy extraction of confidence intervals.
</p>


<h3>Value</h3>

<p>A matrix containing confidence interval bounds.</p>


<h3>Author(s)</h3>

<p>Thomas Jaki</p>


<h3>References</h3>

<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimator">estimator</a></code> and <code><a href="#topic+test">test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Nedelman et al. (1995)
conc &lt;- c(2790, 3280, 4980, 7550, 5500, 6650, 2250, 3220, 213, 636)
time &lt;- c(1, 1, 2, 2, 4, 4, 8, 8, 24, 24)

obj &lt;- auc(conc=conc, time=time, method=c("z", "t"), design="ssd")

## all requested ci's
ci(obj)

## a specific ci
ci(obj, method="t")
</code></pre>

<hr>
<h2 id='CPI975'>Plasma levels of CPI975 in rats following a single oral dose</h2><span id='topic+CPI975'></span>

<h3>Description</h3>

<p>The <code>CPI975</code> data frame has 60 rows and 4 columns. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>conc</dt><dd>
<p>a numeric vector giving the measured plasma level (microgram/mL).
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector giving the time since administration (hours).
</p>
</dd>
<dt>sex</dt><dd>
<p>a factor indicating the gender of the rat.
</p>
</dd>
<dt>dose</dt><dd>
<p>a numeric vector indicating the dose administred (mg/kg).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Nedelman <em>et al.</em> (1995), Table 2 describes serial sampling design were the plasma levels are measured at 5 time points over 24 hours for 10 rats. The same experiment was repeated with different oral dosages and gender.<br />
</p>


<h3>Source</h3>

<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br /><br />
</p>

<hr>
<h2 id='eqv'>Bioequivalence between AUCs</h2><span id='topic+eqv'></span><span id='topic+eqv.ssd'></span><span id='topic+eqv.batch'></span><span id='topic+eqv.complete'></span>

<h3>Description</h3>

<p>Confidence intervals for the ratio of independent or dependent area under the concentration versus time curves (AUCs) to the last time point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqv(conc, time, group, dependent=FALSE, method=c("fieller", "z", "boott"), 
     conf.level=0.90, strata=NULL, nsample=1000, 
     design=c("ssd","batch","complete"), data)

eqv.ssd(conc, time, group, dependent=FALSE, method=c("fieller", "z", "boott"), 
        conf.level=0.90, strata=NULL, nsample=1000, data)

eqv.batch(conc, time, group, dependent=FALSE, 
           method=c("fieller", "z", "boott"),
           conf.level=0.90, nsample=1000, data)	

eqv.complete(conc, time, group, dependent=FALSE, 
              method=c("fieller", "z", "boott"),
              conf.level=0.90, nsample=1000, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqv_+3A_conc">conc</code></td>
<td>
<p> Levels of concentrations. For batch designs a list is required, while a vector is expected otherwise.</p>
</td></tr>
<tr><td><code id="eqv_+3A_time">time</code></td>
<td>
<p> Time points of concentration assessment. For batch designs a list is required, while a vector is expected otherwise. One time point for each concentration measured needs to be specified.</p>
</td></tr>
<tr><td><code id="eqv_+3A_group">group</code></td>
<td>
<p> A grouping variable. For batch designs a list is required, while a vector is expected otherwise.</p>
</td></tr>
<tr><td><code id="eqv_+3A_dependent">dependent</code></td>
<td>
<p> Logical variable indicating if concentrations are measured on the same subjects for both AUCs (default=<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="eqv_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for calculation of confidence intervals (default=<code>c("fieller", "z", "boott")</code>). </p>
</td></tr>
<tr><td><code id="eqv_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level (default=<code>0.90</code>). </p>
</td></tr>
<tr><td><code id="eqv_+3A_strata">strata</code></td>
<td>
<p> A vector of one strata variable (default=<code>NULL</code>). Only available for method <code>boott</code> in a serial sampling design. </p>
</td></tr>
<tr><td><code id="eqv_+3A_nsample">nsample</code></td>
<td>
<p> Number of bootstrap iterations for method <code>boott</code> (default=<code>1000</code>). </p>
</td></tr>
<tr><td><code id="eqv_+3A_design">design</code></td>
<td>
<p> A character string indicating the type of design used. Possible values are <code>ssd</code> (the default) for a serial sampling design, <code>batch</code> for a batch design and <code>complete</code> for a complete data design. </p>
</td></tr>
<tr><td><code id="eqv_+3A_data">data</code></td>
<td>
<p>Optional data frame containing variables named as <code>id</code>, <code>conc</code>, <code>time</code> and <code>group</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of confidence intervals for the ratio of (independent or dependent) AUCs (from 0 to the last time point) for serial sampling, batch and complete data designs. In a serial sampling design only one measurement is available per subject, while in a batch design multiple time points are measured for each subject. In a complete data design measurements are taken for all subjects at all time points. The AUC (from 0 to the last time point) is calculated using the linear trapezoidal rule on the arithmetic means at the different time points. <br /><br />
</p>
<p>The estimation for the complete data design is done by treating the complete data design as a batch design with a single batch. This approach, though correct, is often inefficient. A general implementation is not provided as the most efficient analysis strongly depends on the context. The interested reader is refered to chapter 8 of Cawello (2003) while some examples can be found under <code><a href="#topic+auc.complete">auc.complete</a></code>.<br /><br />
</p>
<p><code>dependent</code> specifies if the AUCs are dependent, that is measured on the same subjects. If <code>FALSE</code>, the intervals are based on the method of Jaki <em>et al.</em> (2009) for the serial sampling design and on Jaki <em>et al.</em> (in press) for the batch design. For dependent AUCs the method of Wolfsegger and Jaki (in press), which assumes that animals, batches and time points are equal for both AUCs, is used. Note that the option <code>dependent</code> is not used in serial sampling designs as by definition only one sample is obtained per subject then.<br /><br />
</p>
<p>The <code>fieller</code> method is based on Fieller's theorem (1954) which uses the asymptotic standard errors of the individual AUCs and a critical value from a t-distribution with Satterthwaite's approximation (1946) to the degrees of freedom for calculation of confidence intervals. The <code>z</code> method is based on the limit distribution for the ratio using the critical value from a normal distribution for calculation of confidence intervals. <br /><br />
</p>
<p>The <code>boott</code> method uses the asymptotic standard errors of the ratio of two AUCs while the critical value is obtained by the bootstrap-<em>t</em> approach and follows the idea discussed in the context of serial sampling designs in Jaki T. <em>et al.</em> (2009).  An equivalent approach is used in batch designs as well. Using <code>boott</code> an additional strata variable for bootstrapping can be specified in serial sampling designs.<br /><br />
</p>
<p>If <code>data</code> is specified the variable names <code>conc</code>, <code>time</code> and <code>group</code> are required and represent the corresponding variables. If <code>design</code> is <code>batch</code> an additional variable <code>id</code> is required to identify the subject.
</p>


<h3>Value</h3>

<p>An object of the class PK  containing the following components: <br /> 
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>Point estimates.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>Point estimates, standard errors and confidence intervals. </p>
</td></tr>
<tr><td><code>conc</code></td>
<td>
<p>Levels of concentrations. </p>
</td></tr> 
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>Sampling design used.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Grouping variable.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time points measured.</p>
</td></tr></table>


<h3>Note</h3>

<p>This is a wrapper function for <code><a href="#topic+eqv.complete">eqv.complete</a>, <a href="#topic+eqv.batch">eqv.batch</a></code> and <code><a href="#topic+eqv.ssd">eqv.ssd</a></code>. 
The function calculates point and interval estimates for the ratio of AUCs (from 0 to the last time point).</p>


<h3>Author(s)</h3>

<p>Thomas Jaki</p>


<h3>References</h3>

<p>Cawello W. (2003). <em>Parameters for Compartment-free Pharmacokinetics. Standardisation of Study Design, Data Analysis and Reporting</em>. Shaker Verlag, Aachen. <br /><br />
</p>
<p>Fieller E. C. (1954). Some problems in interval estimation. <em>Journal of the Royal Statistical Society, Series B</em>, 16:175-185. <br /><br />
</p>
<p>Hand D. and Crowder M. (1996). <em>Practical Longitudinal Data Analysis</em>, Chapman and Hall, London.<br /><br />
</p>
<p>Jaki T., Wolfsegger M. J. and Ploner M. (2009). Confidence intervals for ratios of AUCs in the case of serial sampling: A comparison of seven methods. <em>Pharmaceutical Statistics</em>, 8(1):12-24. <br /><br />
</p>
<p>Jaki T., Wolfsegger M. J. and Lawo J-P. (2010). Establishing bioequivalence in complete and incomplete data designs using AUCs. <em>Journal of Biopharmaceutical Statistics</em>, 20(4):803-820. <br /><br />
</p>
<p>Jaki T. and Wolfsegger M. J. (2012). Non-compartmental estimation of pharmacokinetic parameters for flexible sampling designs. <em>Statistics in Medicine</em>, 31(11-12):1059-1073. <br /><br />
</p>
<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br /><br />
</p>
<p>Satterthwaite F. E. (1946). An approximate distribution of estimates of variance components. <em>Biometrics Bulletin</em>, 2:110-114.  <br /><br />
</p>
<p>Wolfsegger M. J. and Jaki T. (2009) Assessing systemic drug exposure in repeated dose toxicity studies in the case of complete and incomplete sampling. <em>Biometrical Journal</em>, 51(6):1017:1029.<br /><br />
</p>
<p>Yeh, C. (1990). Estimation and significant tests of area under the curve derived from incomplete blood sampling. <em>ASA Proceedings of the Biopharmaceutical Section</em>, 74-81.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+estimator">estimator</a></code>, <code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+test">test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example of a serial sampling design from Nedelman et al. (1995)
data(CPI975)
data &lt;- subset(CPI975,dose&gt;=30)

data$concadj &lt;- data$conc / data$dose

# fieller and z-interval for ratio of dose-normalized AUCs
eqv(conc=data$concadj, time=data$time, group=data$dose, method=c("z","fieller"), 
     design="ssd")

# bootstrap-t interval for ratio of dose-normalized AUCs stratified for sex
set.seed(310578)
eqv(conc=data$concadj, time=data$time, group=data$dose, method="boott",
        strata=data$sex, nsample=500, design="ssd")


## Example of an independent batch design from Yeh (1990) 
conc &lt;- list(batch1=c(0,0,0,0,0,0, 4.690,2.070,6.450,0.1,0.852,0.136, 
                      4.690,4.060,6.450,0.531,1.2,0.607),
           batch2=c(4,1.3,3.2,0.074,0.164,0.267, 6.68,3.83,6.08,0.669,1.21,0.878, 
                    8.13,9.54,6.29,0.923,1.65,1.04),
           batch3=c(9.360,13,5.48,1.090,1.370,1.430, 5.180,5.180,2.79,0.804,1.47,1.26, 
                    1.060,2.15,0.827,0.217,0.42,0.35))  
time &lt;- list(batch1=c(rep(0,6),rep(1,6),rep(4,6)),
             batch2=c(rep(0.5,6),rep(2,6),rep(6,6)),
             batch3=c(rep(8,6),rep(12,6),rep(24,6)))
group &lt;- list(batch1=rep(rep(c(1,2),each=3),3), batch2=rep(rep(c(1,2),each=3),3),
              batch3=rep(rep(c(1,2),each=3),3))

eqv(conc=conc, time=time, group=group, dependent=FALSE, method=c("fieller"), 
    conf.level=0.90, design="batch")

## example of independent batch data with overlapping batches 
## (Example 2.3.1 in Jaki and Wolfsegger, 2012)
conc &lt;-list(batch1=c(0,0,0,0,0,0,0, 29.2,55.9,112.2,84.5,32.8,25.8,42.8,
                     145,153,169,192,181,151,136, 282,420,532,629,271,523,442,
                     727,1033,759,873,402,1031,751, 1360,1388,1425,1246,783,1294,1227, 
                     1939,1279,1318,1633,2073,1385,1682, 1614,1205,1542,1375,1842,1291,1517,
                     1238,1113,1386,1006,1610,1143,1379, 648,770,786,616,883,571,791,
                     392,438,511,379,389,334,548, 77.3,90.1,97.9,84.4,75.8,83.3,91.1),
            batch2=c(0,0,0,0,0,0,0, 69.7,37.2,213,64.1,151,57,50, 167,306,799,406,510,544,216,
                     602,758,987,627,1023,975,762, 1023,1124,1301,880,1477,1217,1144,
                     1388,1374,1756,1120,1643,1126,1238, 1481,1129,1665,1598,1524,1759,1605,
                     1346,1043,1529,1481,1126,1564,1472, 658,576,772,851,577,867,880, 
                     336,325,461,492,339,510,511, 84,75.9,82.6,116,77.3,101.9,112.6))

time &lt;- list(batch1=rep(c(0,0.25,0.5,0.75,1,1.5,2,3,4,8,12,24),each=7),
             batch2=rep(c(0,0.5,0.75,1,1.5,2,3,4,8,12,24),each=7))

group &lt;- list(batch1=rep(c(rep(1,3),rep(2,4)),12),
              batch2=rep(c(rep(1,4),rep(2,3)),11))

eqv(conc=conc, time=time, group=group, dependent=FALSE, method=c("fieller"), 
    conf.level=0.90, design="batch")

## example for a dependent batch data design from Wolfsegger and Jaki (2009)
conc &lt;- list(batch1=c(0.46,0.2,0.1,0.1, 1.49,1.22,1.27,0.53, 0.51,0.36,0.44,0.28),
             batch2=c(1.51,1.80,2.52,1.91, 0.88,0.66,0.96,0.48),
             batch3=c(1.52,1.46,2.55,1.04, 0.54,0.61,0.55,0.27))
time &lt;- list(batch1=c(0,0,0,0,1.5,1.5,1.5,1.5,10.5,10.5,10.5,10.5),
             batch2=c(5/60,5/60,5/60,5/60,4,4,4,4),
             batch3=c(0.5,0.5,0.5,0.5,7,7,7,7))
group &lt;- list(batch1=c(1,1,2,2,1,1,2,2,1,1,2,2), batch2=c(1,1,2,2,1,1,2,2),
              batch3=c(1,1,2,2,1,1,2,2))

eqv(conc=conc, time=time, group=group, dependent=TRUE, method=c("fieller"), 
     conf.level=0.90, design="batch")


## example of a complete data design from Hand and Crowder (1996)
data(Glucose)
set.seed(271184)
eqv(conc=Glucose$conc, time=Glucose$time, group=Glucose$date, 
     dependent=TRUE, method=c("fieller", "z"), conf.level=0.90, 
     design="complete")
</code></pre>

<hr>
<h2 id='estimator'>Function to extract point estimate(s)</h2><span id='topic+estimator'></span>

<h3>Description</h3>

<p>Generic function that extracts the point estimate(s) of an object of class PK.</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimator(obj,se=FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimator_+3A_obj">obj</code></td>
<td>
<p> An output object of class PK.</p>
</td></tr>
<tr><td><code id="estimator_+3A_se">se</code></td>
<td>
<p> Logical variable indicating if the standard error should be provided as well (default=<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to allow easy extraction of point estimates.
</p>


<h3>Value</h3>

<p>A matrix containing the point estimate(s) and optionally the standard error(s).</p>


<h3>Author(s)</h3>

<p>Thomas Jaki</p>


<h3>References</h3>

<p>Nedelman J. R., Gibiansky E. and Lau D. T. W. (1995). Applying Bailer's method for AUC confidence intervals to sparse sampling. <em>Pharmaceutical Research</em>, 12(1):124-128. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+test">test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Nedelman et al. (1995)
conc &lt;- c(2790, 3280, 4980, 7550, 5500, 6650, 2250, 3220, 213, 636)
time &lt;- c(1, 1, 2, 2, 4, 4, 8, 8, 24, 24)

obj &lt;- auc(conc=conc, time=time, method=c('z', 't'), design='ssd')

estimator(obj,TRUE)
</code></pre>

<hr>
<h2 id='Glucose'>Baseline adjusted glucose levels following alcohol ingestion</h2><span id='topic+Glucose'></span>

<h3>Description</h3>

<p>The <code>Glucose</code> data frame has 196 rows and 4 columns. The dataset is originally in package nlme as Glucose2.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd>
<p>a factor with levels
<code>1</code> to <code>7</code> identifying the subject whose glucose
level is measured. 
</p>
</dd>
<dt>date</dt><dd>
<p>a factor with levels
<code>1</code> 
<code>2</code>
indicating the occasion in which the experiment was conducted.
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector giving the time since alcohol ingestion (in min/10).
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the blood glucose level (in mg/dl) adjusted for baseline.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hand and Crowder (Table A.14, pp. 180-181, 1996) describe data on
the blood glucose levels measured at 14 time points over 5 hours for 7
volunteers who took alcohol at time 0. The same experiment was
repeated on a second date with the same subjects but with a dietary
additive used for all subjects.<br /><br />
</p>
<p>Dataset was corrected for baseline using the following code:
</p>
<pre>## dataset Glucose2 of package nlme
require(nlme)
Glucose2 &lt;- Glucose2[order(Glucose2$Subject, Glucose2$Date, Glucose2$Time),]
## adjust for pre-infusion levels measured at time points -1 and 0
data &lt;- NULL
for(i in unique(Glucose2$Subject)){
  for(j in unique(Glucose2$Date)){
     temp &lt;- subset(Glucose2, Subject==i &amp; Date==j)
     temp$Conc &lt;- temp$glucose - mean(c(temp$glucose[1], temp$glucose[2]))
     temp$Conc &lt;- ifelse(temp$Conc &lt; 0 | temp$Time &lt;= 0, 0, temp$Conc)
     ## handle intermediate values &gt; 0 
     index1 &lt;- which.max(temp$Conc)
     index2 &lt;- which.min(temp$Conc[-c(1:index1)]) + index1
     if(temp$Conc[index2]==0){temp$Conc[c(index2:nrow(temp))] &lt;- 0}
     data &lt;- rbind(data,temp)
   }
}    
Glucose &lt;- subset(data, Time &gt;= 0, 
                  select=c('Subject', 'Date', 'Time', 'Conc'))
names(Glucose) &lt;- c("id","date","time","conc")
</pre>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.10)
</p>
<p>Hand, D. and Crowder, M. (1996), <em>Practical Longitudinal Data
Analysis</em>, Chapman and Hall, London.
</p>

<hr>
<h2 id='lee'>Two-phase half-life estimation by linear fitting</h2><span id='topic+lee'></span>

<h3>Description</h3>

<p>Estimation of initial and terminal half-life by two-phase linear regression fitting.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lee(conc, time, points=3, method=c("ols", "lad", "hub", "npr"), lt=TRUE) 	     
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lee_+3A_conc">conc</code></td>
<td>
<p> Levels of concentrations. </p>
</td></tr>
<tr><td><code id="lee_+3A_time">time</code></td>
<td>
<p> Time points of concentration assessment. </p>
</td></tr>
<tr><td><code id="lee_+3A_points">points</code></td>
<td>
<p> Minimum number of data points in the terminal phase (default=<code>3</code>). </p>
</td></tr>
<tr><td><code id="lee_+3A_method">method</code></td>
<td>
<p> Method of model fitting (default=<code>ols</code>). </p>
</td></tr> 
<tr><td><code id="lee_+3A_lt">lt</code></td>
<td>
<p> Logical value indicating whether requesting a longer terminal than initial half-life (default=<code>TRUE</code>).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Estimation of initial and terminal half-life based on the method of Lee <em>et al.</em> (1990). This method uses a two-phase linear regression approach separate the model into two straight lines based on the selection of the log10 transformed concentration values. For two-phase models the initial and terminal half-lives were determined from the slopes of the regression lines. If a single-phase model is selected by this method, the corresponding half-life is utilized as both initial and terminal phase half-life. Half-life is determined only for decreasing initial and terminal phases. <br /><br /> 
</p>
<p>The method <code>ols</code> uses the ordinary least squares regression (OLS) to fit regression lines. <br /><br />
</p>
<p>The method <code>lad</code> uses the absolute deviation regression (LAD) to fit regression lines by using the algorithm as described in Birkes and Dodge (chapter 4, 1993) for calculation of regression estimates. <br /><br />
</p>
<p>The method <code>hub</code> uses the Huber M regression to fit regression lines. Huber M-estimates are calculated by non-linear estimation using the function <code>optim</code>, where OLS regression parameters are used as starting values. The function that is minimized involved k = 1.5*1.483*MAD, where MAD is defined as the median of absolute deviation of residuals obtained by a least absolute deviation (LAD) regression based on the observed data. The initial value of MAD is used and not updated during iterations (Holland and Welsch, 1977). <br /><br />
</p>
<p>The method <code>npr</code> uses the nonparametric regression to fit regression lines by using the algorithm as described in Birkes and Dodge (chapter 6, 1993) for calculation of regression estimates. <br /> <br />
</p>
<p>The selection criteria for the best tuple of regression lines is the sum of squared residuals for the <code>ols</code> method, the sum of Huber M residuals for the <code>hub</code> method, the sum of absolute residuals for the <code>lad</code> method and the sum of a function on ranked residuals for the <code>npr</code> method (see Birkes and Dodge (page 115, 1993)). Calculation details can be found in Wolfsegger (2006). <br /> <br />
</p>
<p>When <code>lt=TRUE</code>, the best two-phase model where terminal half-life &gt;= initial half-life &gt;= 0 is selected. When <code>lt=FALSE</code>, the best two-phase model among all possible tuples of regression is selected which can result in longer initial half-life than terminal half-life and/or in half-lifes &lt; 0. <br /> <br />
</p>


<h3>Value</h3>

<p>A list of S3 class <code>"halflife"</code> containing the following components: <br />
</p>
<table>
<tr><td><code>parms</code></td>
<td>
<p> half-life and model estimates.</p>
</td></tr>
<tr><td><code>chgpt</code></td>
<td>
<p> change point between initial and terminal phase. </p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p> time points of concentration assessments. </p>
</td></tr>
<tr><td><code>conc</code></td>
<td>
<p> levels of concentrations. </p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p> &quot;lee&quot;. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Records including missing values and concentration values below or equal to zero are omitted. </p>


<h3>Author(s)</h3>

<p>Martin J. Wolfsegger</p>


<h3>References</h3>

<p>Birkes D. and Dodge Y. (1993). <em>Alternative Methods of Regression</em>. Wiley, New York, Chichester, Brisbane, Toronto, Singapore.  <br /> <br />
</p>
<p>Gabrielsson J. and Weiner D. (2000). <em>Pharmacokinetic and Pharmacodynamic Data Analysis: Concepts and Applications</em>. 4th Edition. Swedish Pharmaceutical Press, Stockholm. <br /><br />
</p>
<p>Holland P. W. and Welsch R. E. (1977). Robust regression using iteratively reweighted least-squares. <em>Commun. Statist.-Theor. Meth.</em> A6(9):813-827. <br /><br />
</p>
<p>Lee M. L., Poon Wai-Yin, Kingdon H. S. (1990). A two-phase linear regression model for biologic half-life data. <em>Journal of Laboratory and Clinical Medicine.</em> 115(6):745-748. <br /><br />
</p>
<p>Wolfsegger M. J. (2006). The R Package PK for Basic Pharmacokinetics. <em>Biometrie und Medizin</em>, 5:61-68. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example for preparation 1 from Lee et al. (1990)
time &lt;- c(0.5, 1.0, 4.0, 8.0, 12.0, 24.0)
conc &lt;- c(75, 72, 61, 54, 36, 6)
res1 &lt;- lee(conc=conc, time=time, method='ols', points=2, lt=TRUE)
res2 &lt;- lee(conc=conc, time=time, method='ols', points=2, lt=FALSE)
plot(res1, log='y', ylim=c(1,100))
plot(res2, add=TRUE, lty=2)

#### example for preparation 2 from Lee et al. (1990)
time &lt;- c(0.5, 1.0, 2.0, 6.5, 8.0, 12.5, 24.0)
conc &lt;- c(75, 55, 48, 51, 39, 9, 5)
res3 &lt;- lee(conc=conc, time=time, method='ols', points=2, lt=FALSE)
print(res3$parms)
plot(res2, log='y', ylim=c(1,100), lty=1, pch=20)
plot(res3, add=TRUE, lty=2, pch=21)
legend(x=0, y=10, pch=c(20,21), lty=c(1,2), legend=c('Preperation 1','Preperation 2'))

#### artificial example
time &lt;- seq(1:10)
conc &lt;- c(1,2,3,4,5,5,4,3,2,1)
res4 &lt;- lee(conc=conc, time=time, method='lad', points=2, lt=FALSE)
plot(res4, log='y', ylim=c(1,7), main='', xlab='', ylab='', pch=19)

#### dataset Indometh of package datasets
require(datasets)
res5 &lt;- data.frame(matrix(ncol=3, nrow=length(unique(Indometh$Subject))))
colnames(res5) &lt;- c('ID', 'initial', 'terminal')
row &lt;- 1
for(i in unique(Indometh$Subject)){
   temp &lt;- subset(Indometh, Subject==i)
   res5[row, 1] &lt;- unique(temp$Subject)
   res5[row, c(2:3)] &lt;- lee(conc=temp$conc, time=temp$time, method='lad')$parms[1,]
   row &lt;- row + 1
}
print(res5)

## geometric means and corresponding two-sided CIs
exp(mean(log(res5$initial)))
exp(t.test(log(res5$initial), conf.level=0.95)$conf.int)

exp(mean(log(res5$terminal)))
exp(t.test(log(res5$terminal), conf.level=0.95)$conf.int)

#### example from Gabrielsson and Weiner (2000, page 743) 
#### endogenous concentration is assumed to be constant over time 
time &lt;- c(-1, 0.167E-01, 0.1167, 0.1670, 0.25, 0.583, 0.8330, 1.083, 1.583, 2.083, 4.083, 8.083,
          12, 23.5, 24.25, 26.75, 32)
conc &lt;- c(20.34, 3683, 884.7, 481.1, 215.6, 114, 95.8, 87.89, 60.19, 60.17, 34.89, 20.99, 20.54, 
          19.28, 18.18, 19.39, 22.72)
data &lt;- data.frame(conc,time)

## naive adjustment for endogenous concentration by subtraction of pre-value
## see also help for function biexp for modelling approaches  
data$concadj &lt;- data$conc - data$conc[1]
data$concadj[min(which(data$concadj&lt;0)):nrow(data)] &lt;- NA
res6 &lt;- lee(conc=data$concadj[-1], time=data$time[-1]) 

## plot results 
split.screen(c(1,2)) 
screen(1)
plot(res6, xlab='Time (hours)', ylab='Baseline-adjusted concentration (pmol/L)')
screen(2)
plot(res6, log='y', ylim=c(0.1, 1E4), xlab='Time (hours)', 
     ylab='Log of baseline-adjusted concentration (pmol/L)')
close.screen(all.screens=TRUE)

</code></pre>

<hr>
<h2 id='nca'>Estimation of various PK parameters</h2><span id='topic+nca'></span><span id='topic+nca.ssd'></span><span id='topic+nca.batch'></span><span id='topic+nca.complete'></span>

<h3>Description</h3>

<p>Non-compartmental estimation of the area under the concentration versus time curve (AUC) to the last time point, AUC to infinity, area under the first moment curve (AUMC) to infinity, mean residence time (MRT), non-compartmental half-life, total clearance and volume of distribution at steady state.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nca(conc, time, n.tail=3, dose=0, method=c("z", "boott"), conf.level=0.95, 
     nsample=1000, design=c("ssd","batch","complete"), data)

nca.ssd(conc, time, n.tail=3, dose=0, method=c("z", "boott"), 
         conf.level=0.95, nsample=1000, data)

nca.batch(conc, time, n.tail=3, dose=0, method=c("z", "boott"), 
         conf.level=0.95, nsample=1000, data)

nca.complete(conc, time, n.tail=3, dose=0, method=c("z", "boott"), 
         conf.level=0.95, nsample=1000, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nca_+3A_conc">conc</code></td>
<td>
<p> Levels of concentrations. For batch designs a list is required, while a vector is expected otherwise.</p>
</td></tr>
<tr><td><code id="nca_+3A_time">time</code></td>
<td>
<p> Time points of concentration assessment. For batch designs a list is required, while a vector is expected otherwise. One time point for each concentration measured needs to be specified.</p>
</td></tr>
<tr><td><code id="nca_+3A_n.tail">n.tail</code></td>
<td>
<p> Number of last data points used for tail area correction (default=<code>3</code>). </p>
</td></tr>
<tr><td><code id="nca_+3A_dose">dose</code></td>
<td>
<p> Dose administered as an IV bolus (default=<code>0</code>).</p>
</td></tr>
<tr><td><code id="nca_+3A_method">method</code></td>
<td>
<p> A character string specifying the method for calculation of confidence intervals (default=<code>c("z", "boott")</code>). </p>
</td></tr>
<tr><td><code id="nca_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level (default=<code>0.95</code>). </p>
</td></tr>
<tr><td><code id="nca_+3A_nsample">nsample</code></td>
<td>
<p> Number of bootstrap iterations for bootstrap-<em>t</em> interval (default=<code>1000</code>). </p>
</td></tr> 
<tr><td><code id="nca_+3A_design">design</code></td>
<td>
<p> A character string indicating the type of design used. Possible values are <code>ssd</code> (the default) for a serial sampling design, <code>batch</code> for a batch design and <code>complete</code> for a complete data design. </p>
</td></tr>
<tr><td><code id="nca_+3A_data">data</code></td>
<td>
<p>Optional data frame containing variables named as <code>id</code>, <code>conc</code> and <code>time</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the area under the concentration versus time curve from zero to the last time point (AUC 0-tlast), total area under the concentration versus time curve from zero to infinity (AUC 0-Inf), area under the first moment curve for zero to infinity (AUMC 0-Inf), mean residence time (MRT), non-compartmental half-life (HL), total clearance (CL) and volume of distribution at steady state (Vss). In a serial sampling design only one measurement is available per subject at a specific time point, while in a batch design multiple time points are measured for each subject. In a complete data design measurements are taken for all subjects at all time points.<br /><br /> 
</p>
<p>A constant coefficient of variation at the last <code>n.tail</code> time points is assumed.<br /><br />
</p>
<p>The use of the standard errors and confidence intervals for the MRT and Vss from batch designs is depreciated due to very slow asymptotic that usually lead to severe undercoverage. For complete data designs only point estimates are provided. The parameters <code>method</code>, <code>conf.level</code> and <code>nsample=1000</code> are therefore not used. If data for only one subject is provided, the parameters are estimated for this subject while the geometric mean of the estimated parameters is found for multiple subjects (see Cawello, 2003, p. 114). <br /><br />
</p>
<p>The AUC 0-tlast is calculated using the linear trapezoidal rule on the arithmetic means at the different time points while the extrapolation necessary for the AUC 0-Inf and AUMC 0-Inf is achieved assuming an exponential decay on the last <code>n.tail</code> time points. The other parameters are functions of these PK parameters and of the dosage and are defined as in Wolfsegger and Jaki (2009).<br /><br />
</p>
<p>Two different confidence intervals are computed: an asymptotic confidence interval and a bootstrap-<em>t</em> interval. The <code>z</code> method is based on the limit distribution of the parameter using the critical value from a normal distribution for calculation of confidence intervals together with asymptotic variances. The bootstrap-<em>t</em> interval uses the same asymptotic variances, but while the critical value is obtained by the bootstrap-<em>t</em> approach. If <code>nsample=0</code> only the asymptotic interval will be computed.<br /><br />
</p>
<p>If <code>data</code> is specified the variable names <code>conc</code> and <code>time</code> are required and represent the corresponding variables.<br /><br />
</p>
<p>Note that some estimators as provided assume IV bolus administration. If an oral administration is used<br />
- The clearance needs to be adjusted by the bioavailability, f. This can be achieved by either multiplying the obtained estimator by f or adjusting the dose parameter accordingly. <br />
- The MRT estimate produced corresponds to the mean transit time (MTT) which is the sum of MRT and mean absorption time (MAT).<br />
- HL and Vss are functions of the MRT and hence they will not be valid under oral administration.
</p>


<h3>Value</h3>

<p>An object of the class PK containing the following components: <br /> 
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>Point estimates.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>Point estimates, standard errors and confidence intervals. </p>
</td></tr>
<tr><td><code>conc</code></td>
<td>
<p>Levels of concentrations. </p>
</td></tr> 
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>Sampling design used.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Time points measured.</p>
</td></tr></table>


<h3>Note</h3>

<p>At present only the option serial sampling design is available.</p>


<h3>Author(s)</h3>

<p>Thomas Jaki and Martin J. Wolfsegger</p>


<h3>References</h3>

<p>Cawello W. (2003). <em>Parameters for compartment-free pharmacokinetics. Standardisation of study
design, data analysis and reporting</em>. Shaker Verlag, Aachen.<br /><br />
</p>
<p>Gibaldi M. and Perrier D. (1982). <em>Pharmacokinetics</em>. Marcel Dekker, New York and Basel.<br /><br />
</p>
<p>Jaki T. and Wolfsegger M. J. (2012). Non-compartmental estimation of pharmacokinetic parameters for flexible sampling designs. <em>Statistics in Medicine</em>, 31(11-12):1059-1073. <br /><br />
</p>
<p>Wolfsegger M. J. and Jaki T. (2009). Non-compartmental Estimation of Pharmacokinetic Parameters in Serial Sampling Designs. <em>Journal of Pharmacokinetics and Pharmacodynamics</em>, 36(5):479-494. <br />	
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+estimator">estimator</a></code>, <code><a href="#topic+ci">ci</a></code> and <code><a href="#topic+test">test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### serial sampling designs
## example for a serial sampling data design from Wolfsegger and Jaki (2009)
conc &lt;- c(0, 0, 0, 2.01, 2.85, 2.43, 0.85, 1.00, 0.91, 0.46, 0.35, 0.63, 0.39, 0.32, 
          0.45, 0.11, 0.18, 0.19, 0.08, 0.09, 0.06)
time &lt;- c(rep(0,3), rep(5/60,3), rep(3,3), rep(6,3), rep(9,3), rep(16,3), rep(24,3))

# Direct call of the function
# CAUTION: this might take a few minutes
# Note: 1E4 bootstrap replications were used in the example given 
# in Wolfsegger and Jaki (2009)
set.seed(34534)
nca.ssd(conc=conc, time=time, n.tail=4, dose=200, method=c("z","boott"), 
         conf.level=0.95, nsample=500)

# Call through the wrapper function using data
data &lt;- data.frame(conc=conc, time=time)
nca(data=data, n.tail=4, dose=200, method="z", 
     conf.level=0.95, design="ssd")



#### batch design:
## a batch design example from Holder et al. (1999).
data(Rats)
data &lt;- subset(Rats,Rats$dose==100)

# using the wrapper function
nca(data=data, n.tail=4, dose=100, method="z", 
     conf.level=0.95, design="batch")
# direct call
nca.batch(data=data, n.tail=4, dose=100, method="z", 
     conf.level=0.95)

## example with overlapping batches (Treatment A in Example of Jaki &amp; Wolfsegger 2012)
conc &lt;- list(batch1=c(0,0,0,0, 69.7,37.2,213,64.1,  167,306,799,406, 602,758,987,627,
                      1023,1124,1301,880, 1388,1374,1756,1120, 1481,1129,1665,1598,
                      1346,1043,1529,1481, 658,576,772,851, 336,325,461,492, 
                      84,75.9,82.6,116),
             batch2=c(0,0,0, 29.2,55.9,112.2, 145,153,169, 282,420,532, 727,1033,759, 
                      1360,1388,1425, 1939,1279,1318, 1614,1205,1542, 1238,1113,1386,
                      648,770,786, 392,438,511, 77.3,90.1,97.9))
time &lt;- list(batch1=rep(c(0,0.5,0.75,1,1.5,2,3,4,8,12,24),each=4),
             batch2=rep(c(0,0.25,0.5,0.75,1,1.5,2,3,4,8,12,24),each=3))

nca.batch(conc,time,method="z",n.tail=4,dose=80)


#### complete data design
## example from Gibaldi and Perrier (1982, page 436) for individual PK parameters
time &lt;- c(0, 0.165, 0.5, 1, 1.5, 3, 5, 7.5, 10)
conc &lt;- c(0, 65.03, 28.69, 10.04, 4.93, 2.29, 1.36, 0.71, 0.38)
# using the wrapper function
nca(conc=conc, time=time, n.tail=3, dose=1E6, design="complete")
# direct call
nca.complete(conc=conc, time=time, n.tail=3, dose=1E6)
</code></pre>

<hr>
<h2 id='PKNews'>Shows changes and news</h2><span id='topic+PKNews'></span>

<h3>Description</h3>

<p>Functions showing changes since previous versions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNews()
</code></pre>


<h3>Details</h3>

<p>Displays the changes and news given in the NEWS file of the package.
</p>


<h3>Value</h3>

<p>Screen output.</p>


<h3>Author(s)</h3>

<p>Thomas Jaki</p>


<h3>Examples</h3>

<pre><code class='language-R'>PKNews()
</code></pre>

<hr>
<h2 id='plot.halflife'>Plot regression lines used for half-life estimation</h2><span id='topic+plot.halflife'></span>

<h3>Description</h3>

<p>This method plots objects of S3 class <code>"halflife"</code> (<a href="#topic+biexp">biexp</a> and <a href="#topic+lee">lee</a>). </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'halflife'
plot(x, xlab='Time', ylab='Concentration', 
        main='Half-life Estimation', xlim=NULL, ylim=NULL, add=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.halflife_+3A_x">x</code></td>
<td>
<p> An object of S3 class <code>"halflife"</code> (<a href="#topic+biexp">biexp</a> and <a href="#topic+lee">lee</a>).</p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_xlab">xlab</code></td>
<td>
<p> A label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_ylab">ylab</code></td>
<td>
<p> A label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_main">main</code></td>
<td>
<p> A main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_xlim">xlim</code></td>
<td>
<p> The x limits (min, max) of the plot. </p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_ylim">ylim</code></td>
<td>
<p> The y limits (min, max) of the plot. </p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_add">add</code></td>
<td>
<p> A logical value indicating whether to add plot to current plot (default=<code>FALSE</code>). </p>
</td></tr>
<tr><td><code id="plot.halflife_+3A_...">...</code></td>
<td>
<p> Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none</p>


<h3>Author(s)</h3>

<p>Martin J. Wolfsegger</p>

<hr>
<h2 id='Rats'>Plasma levels in female rats following a single oral dose</h2><span id='topic+Rats'></span>

<h3>Description</h3>

<p>The <code>Rats</code> data frame has 126 rows and 4 columns. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd>
<p>a numeric vector identifying the animal whose plasma level is measured.
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the measured plasma level (microgram/mL).
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector giving the time since administration (hours).
</p>
</dd>
<dt>dose</dt><dd>
<p>a numeric vector indicating the dose administred (mg/kg).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Holder <em>et al.</em> (1999), Table 4 describes data on the plasma levels measured at 6 time points over 24 hours for 9
female rats. The same experiment was repeated with different oral dosages.<br />
</p>


<h3>Source</h3>

<p>Holder D. J., Hsuan F., Dixit R. and Soper K. (1999). A method for estimating and testing area under the curve in serial sacrifice, batch, and complete data designs. <em>Journal of Biopharmaceutical Statistics</em>, 9(3):451-464.
</p>

<hr>
<h2 id='Rep.tox'>Plasma levels in rats following daily intravenous administration in a repeated dose toxicity study</h2><span id='topic+Rep.tox'></span>

<h3>Description</h3>

<p>The <code>Rep.tox</code> data frame has 28 rows and 4 columns and gives the plasma levels of 6 rats in a repeated dose toxicity study. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>id</dt><dd>
<p>a numeric vector identifying the animal whose plasma level is measured.
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the measured plasma level (IU/mL).
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector giving the time since administration (hours).
</p>
</dd>
<dt>day</dt><dd>
<p>a numeric vector indicating the day the data were collected. 
</p>
</dd>
</dl>



<h3>Details</h3>

<p>In this study the compound is administered daily to 6 Rats over 14 days. Plasma levels are measured at 7 time points over 12 hours after the first administration and after the 14th administration.<br />
</p>


<h3>Source</h3>

<p>Wolfsegger M. J. and Jaki T. (2009) Assessing systemic drug exposure in repeated dose toxicity studies in the case of complete and incomplete sampling. <em>Biometrical Journal</em>, 51(6):1017:1029.
</p>

<hr>
<h2 id='test'>Function for hypothesis testing for objects of class PK</h2><span id='topic+test'></span><span id='topic+print.PKtest'></span><span id='topic+summary.PKtest'></span>

<h3>Description</h3>

<p>Generic function for hypothesis testing based on an object of class <code>PK</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test(obj, theta=0, method = c("t", "fieller", "z", "resample"), nsample = 1000) 

## S3 method for class 'PKtest'
print(x,hyp=FALSE,...)

## S3 method for class 'PKtest'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_+3A_obj">obj</code></td>
<td>
<p> An output object of class PK.</p>
</td></tr>
<tr><td><code id="test_+3A_x">x</code></td>
<td>
<p> An output object of class PKtest.</p>
</td></tr>
<tr><td><code id="test_+3A_object">object</code></td>
<td>
<p> An output object of class PK test.</p>
</td></tr>
<tr><td><code id="test_+3A_theta">theta</code></td>
<td>
<p> The reference value to be tested against. If multiple parameters are to be tested a vector can be supplied.</p>
</td></tr>
<tr><td><code id="test_+3A_method">method</code></td>
<td>
<p> A character string specifying the method for calculation of the test statistic. Possible values are <code>t</code> (the default) and <code>fieller</code> for a t-test based method, <code>z</code> for a z-test and <code>resample</code> for either a bootstrap or a permutation test.</p>
</td></tr>
<tr><td><code id="test_+3A_nsample">nsample</code></td>
<td>
<p> Number of resamples for the permutation/bootstrap test (default=<code>1000</code>). </p>
</td></tr> 
<tr><td><code id="test_+3A_hyp">hyp</code></td>
<td>
<p> Logical variable indicating if hypothesis tests should be printed explicitly (default=<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="test_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to perform hypothesis test(s). <br /><br />
</p>
<p>The reference value for the test is to be specified in <code>theta</code>. If multiple tests are performed theta can be a vector.<br /><br />
</p>
<p>For method <code>"resample"</code> a permutation test is used for the difference of AUCs while a one-sample bootstrap test based on inverting a bootstrap-t statistic is implemented.
</p>


<h3>Value</h3>

<p>An object of the class PKtest containing the following components: <br /> 
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>Test statistics.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-values. </p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Reference value(s) tested against.</p>
</td></tr> 
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of alternative used.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom of method <code>"t"</code>.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>Sampling design used.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Type of test used.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Thomas Jaki</p>


<h3>References</h3>

<p>Efron B and Tibshirani R. J. (1993). <em>An introduction to the bootstrap</em>, Chapman and Hall, New York.<br /><br />
</p>
<p>Holder D. J., Hsuan F., Dixit R. and Soper K. (1999). A method for estimating and testing area under the curve in serial sacrifice, batch, and complete data designs. <em>Journal of Biopharmaceutical Statistics</em>, 9(3):451-464.<br /><br />
</p>
<p>Wolfsegger M. J. and Jaki T. (2009) Assessing systemic drug exposure in repeated dose toxicity studies in the case of complete and incomplete sampling. <em>Biometrical Journal</em>, 51(6):1017:1029.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc">auc</a></code>, <code><a href="#topic+eqv">eqv</a></code> and <code><a href="#topic+nca">nca</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example for a serial sampling data design from Wolfsegger and Jaki (2009)
conc &lt;- c(0, 0, 0, 2.01, 2.85, 2.43, 0.85, 1.00, 0.91, 0.46, 0.35, 0.63, 0.39, 0.32, 
          0.45, 0.11, 0.18, 0.19, 0.08, 0.09, 0.06)
time &lt;- c(rep(0,3), rep(5/60,3), rep(3,3), rep(6,3), rep(9,3), rep(16,3), rep(24,3))

obj &lt;- nca(conc=conc, time=time, n.tail=4, dose=200, method="z", 
            conf.level=0.95, design="ssd")

## testing all parameters against different values using a z-test
res &lt;- test(obj, theta=c(11, 12, 90, 7, 5, 16, 120), method="z")

print(res)

## a batch design example from Holder et al. (1999).
data(Rats)
data &lt;- subset(Rats,Rats$dose==100)

obj &lt;- auc(data=data,method=c('z','t'), design='batch')

## t-test
res &lt;- test(obj, theta=100, method="t")

## making the hypothesis explicit
summary(res)

## bootstrap test for bioequivalence
# Note: This can take a few seconds
data(Glucose)
## one-sided permutation test
obj &lt;- auc(conc=Glucose$conc, time=Glucose$time, group=Glucose$date, 
     method=c("t"), conf.level=0.90, alternative='less', 
     nsample=100, design="complete")

test(obj, theta=1, method="resample", nsample=100)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
