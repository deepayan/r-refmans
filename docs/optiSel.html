<!DOCTYPE html><html><head><title>Help for package optiSel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optiSel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optiSel-package'>
<p>Optimum Contribution Selection and Population Genetics</p></a></li>
<li><a href='#agecont'><p>Contributions of age cohorts to the population</p></a></li>
<li><a href='#candes'><p>Candidate Description</p></a></li>
<li><a href='#Cattle'><p>Phenotypes of Genotyped Cattle</p></a></li>
<li><a href='#Chr1.phased'><p>Phased Cattle Genotypes from Chromosome 1</p></a></li>
<li><a href='#Chr2.phased'><p>Phased Cattle Genotypes from Chromosome 2</p></a></li>
<li><a href='#completeness'><p>Calculates Pedigree Completeness</p></a></li>
<li><a href='#conttac'><p>Calculates <b>Cont</b>ributions <b>T</b>o <b>A</b>ge <b>C</b>ohorts</p></a></li>
<li><a href='#ExamplePed'><p>Pedigree of Hinterwald Cattle</p></a></li>
<li><a href='#freqlist'><p>Combines Objects Computed with Function haplofreq() into a List</p></a></li>
<li><a href='#genecont'><p>Calculates Genetic Contributions using Pedigrees.</p></a></li>
<li><a href='#haplofreq'><p>Evaluates the Occurrence of Haplotype Segments in Particular Breeds</p></a></li>
<li><a href='#makeA'><p>Calculates the Pedigree-based Additive Relationship Matrix</p></a></li>
<li><a href='#map'><p>Marker Map for Cattle</p></a></li>
<li><a href='#matings'><p>Mate Allocation</p></a></li>
<li><a href='#noffspring'><p>Calculates Optimum Numbers of Offspring</p></a></li>
<li><a href='#opticomp'><p>Calculates the Optimum Breed Composition</p></a></li>
<li><a href='#opticont'><p>Optimum Contributions of Selection Candidates</p></a></li>
<li><a href='#pedBreedComp'><p>Calculates the Pedigree Based Breed Composition of Individuals</p></a></li>
<li><a href='#pedIBD'><p>Calculates the Pedigree-based Kinship Matrix</p></a></li>
<li><a href='#pedIBDatN'><p>Calculates the Pedigree Based Kinship at Native Alleles</p></a></li>
<li><a href='#pedIBDorM'><p>Calculates Kinships taking Allele Origin into Account</p></a></li>
<li><a href='#PedigWithErrors'><p>Pedigree of Hinterwald cattle</p></a></li>
<li><a href='#pedInbreeding'><p>Calculates Pedigree Based Inbreeding</p></a></li>
<li><a href='#pedplot'><p>Plots a Pedigree</p></a></li>
<li><a href='#Phen'><p>Simulated Phenotypes of Hinterwald Cattle</p></a></li>
<li><a href='#plot.HaploFreq'><p>Plots Frequencies of Haplotype Segments in Specified Breeds</p></a></li>
<li><a href='#prePed'><p><b>Pre</b>pares a <b>Ped</b>igree</p></a></li>
<li><a href='#read.indiv'><p>Reads Individual IDs from a Genotype File</p></a></li>
<li><a href='#sampleIndiv'><p>Sample Individuals from Pedigree</p></a></li>
<li><a href='#segBreedComp'>
<p>Calculates the Segment-Based Breed Composition of Individuals</p></a></li>
<li><a href='#segIBD'><p>Calculates the Segment Based Kinship Matrix</p></a></li>
<li><a href='#segIBDandN'><p>Calculates Probabilities that Alleles belong to a Shared Native Segment</p></a></li>
<li><a href='#segIBDatN'><p>Segment-Based Kinship at Native Alleles.</p></a></li>
<li><a href='#segInbreeding'><p>Calculates Segment Based Inbreeding</p></a></li>
<li><a href='#segN'><p>Calculates Probabilities of Alleles to belong to Native Segments</p></a></li>
<li><a href='#sim2dis'><p>Converts a Similarity Matrix into a Dissimilarity Matrix</p></a></li>
<li><a href='#subPed'><p>Creates a Subset of a Large Pedigree</p></a></li>
<li><a href='#summary.candes'><p>Population Genetic Parameters at Different Times</p></a></li>
<li><a href='#summary.Pedig'><p>Calculates Summary Statistics for Pedigrees.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimum Contribution Selection and Population Genetics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-08</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for the optimization of breeding programs via optimum contribution selection and mate allocation. An easy to use set of function for computation of optimum contributions of selection candidates, and of the population genetic parameters to be optimized. These parameters can be estimated using pedigree or genotype information, and include kinships, kinships at native haplotype segments, and breed composition of crossbred individuals. They are suitable for managing genetic diversity, removing introgressed genetic material, and accelerating genetic gain. Additionally, functions are provided for computing genetic contributions from ancestors, inbreeding coefficients, the native effective size, the native genome equivalent, pedigree completeness, and for preparing and plotting pedigrees. The methods are described in:\n Wellmann, R., and Pfeiffer, I. (2009) &lt;<a href="https://doi.org/10.1017%2FS0016672309000202">doi:10.1017/S0016672309000202</a>&gt;.\n Wellmann, R., and Bennewitz, J. (2011) &lt;<a href="https://doi.org/10.2527%2Fjas.2010-3709">doi:10.2527/jas.2010-3709</a>&gt;.\n Wellmann, R., Hartwig, S., Bennewitz, J. (2012) &lt;<a href="https://doi.org/10.1186%2F1297-9686-44-34">doi:10.1186/1297-9686-44-34</a>&gt;.\n de Cara, M. A. R., Villanueva, B., Toro, M. A., Fernandez, J. (2013) &lt;<a href="https://doi.org/10.1111%2Fmec.12560">doi:10.1111/mec.12560</a>&gt;.\n Wellmann, R., Bennewitz, J., Meuwissen, T.H.E. (2014) &lt;<a href="https://doi.org/10.1017%2FS0016672314000196">doi:10.1017/S0016672314000196</a>&gt;.\n Wellmann, R. (2019) &lt;<a href="https://doi.org/10.1186%2Fs12859-018-2450-5">doi:10.1186/s12859-018-2450-5</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, plyr, kinship2, nadiv, pedigree, pspline, stringr,
MASS, methods, stats, purrr, graphics, quadprog, data.table,
magic, parallel, doParallel, foreach, ECOSolveR, reshape2,
optiSolve, Rcpp (&ge; 0.12.4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ggplot2, rmarkdown, alabama, cccp, nloptr, Rsymphony,
smacof</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-08 11:43:57 UTC; rowel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-08 12:20:02 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Wellmann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Wellmann &lt;r.wellmann@uni-hohenheim.de&gt;</td>
</tr>
</table>
<hr>
<h2 id='optiSel-package'>
Optimum Contribution Selection and Population Genetics
</h2><span id='topic+optiSel-package'></span><span id='topic+optiSel'></span>

<h3>Description</h3>

<p>A framework for the optimization of breeding programs via optimum contribution selection and mate allocation. An easy to use set of function for computation of optimum contributions of selection candidates, and of the population genetic parameters to be optimized. These parameters can be estimated using pedigree or genotype information, and include kinships, kinships at native haplotype segments, and breed composition of crossbred individuals. They are suitable for managing genetic diversity, removing introgressed genetic material, and accelerating genetic gain. Additionally, functions are provided for computing genetic contributions from ancestors, inbreeding coefficients, the native effective size, the native genome equivalent, pedigree completeness, and for preparing and plotting pedigrees. The methods are described in:\n Wellmann, R., and Pfeiffer, I. (2009) &lt;doi:10.1017/S0016672309000202&gt;.\n Wellmann, R., and Bennewitz, J. (2011) &lt;doi:10.2527/jas.2010-3709&gt;.\n Wellmann, R., Hartwig, S., Bennewitz, J. (2012) &lt;doi:10.1186/1297-9686-44-34&gt;.\n de Cara, M. A. R., Villanueva, B., Toro, M. A., Fernandez, J. (2013) &lt;doi:10.1111/mec.12560&gt;.\n Wellmann, R., Bennewitz, J., Meuwissen, T.H.E. (2014) &lt;doi:10.1017/S0016672314000196&gt;.\n Wellmann, R. (2019) &lt;doi:10.1186/s12859-018-2450-5&gt;.
</p>


<h3>Details</h3>

<p><b>Optimum Contribution Selection</b>
</p>
<p>After kinships, breeding values and/or native contributions of the selection candidates have been computed, function <a href="#topic+candes">candes</a> can be used to create an R-object containing all this information.
The current average kinships and trait values are estimated by this function, and the available objective functions and constraints for optimum contribution selection are reported.
The following function can then be used to compute optimum contributions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+opticont">opticont</a>      </td><td style="text-align: left;">  Calculates optimum genetic contributions of selection candidates to the next generation, </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> and checks if all constraints are fulfilled.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td>
</tr>

</table>

<p>Function <a href="#topic+noffspring">noffspring</a> can be used to  compute the optimum numbers of offspring of selection candidates from their optimum contributions. Function <a href="#topic+matings">matings</a> can be used for mate allocation. 
</p>
<p><b>Kinships</b>
</p>
<p>For pairs of individuals the following kinships can be computed:
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+pedIBD">pedIBD</a>    </td><td style="text-align: left;">  Calculates <b>ped</b>igree based probability of alleles to be <b>IBD</b> ("pedigree based kinship""),</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+segIBD">segIBD</a>    </td><td style="text-align: left;">  Calculates <b>seg</b>ment based probability of alleles to  be <b>IBD</b>  ("segment based kinship"),</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+pedIBDatN">pedIBDatN</a> </td><td style="text-align: left;">  Calculates <b>ped</b>igree based probability of alleles to be <b>IBD</b> <b>at</b> segments with <b>N</b>ative origin,</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+segIBDatN">segIBDatN</a> </td><td style="text-align: left;">  Calculates <b>seg</b>ment based probability of alleles to be <b>IBD</b>  <b>at</b> segments with <b>N</b>ative origin,</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+pedIBDorM">pedIBDorM</a> </td><td style="text-align: left;">  Calculates <b>ped</b>igree based probability of alleles to be <b>IBD</b> <b>or</b> <b>M</b>igrant alleles,</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+segIBDandN">segIBDandN</a> </td><td style="text-align: left;"> Calculates <b>seg</b>ment based probability of alleles to be <b>IBD</b>  <b>and</b> have <b>N</b>ative origin,</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+segN">segN</a>       </td><td style="text-align: left;"> Calculates <b>seg</b>ment based probability of alleles to have <b>N</b>ative origin,</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+makeA">makeA</a> </td><td style="text-align: left;"> Calculates the pedigree-based additive relationship matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Phenotypes and results from these functions can be combined with function <a href="#topic+candes">candes</a> into a single R object, which can then be used as an argument
to function <a href="#topic+opticont">opticont</a>.
</p>
<p>The segment based kinship can be used to calculate the optimum contributions of different breeds to a hypothetical multi-breed population with maximum genetic diversity by using function <a href="#topic+opticomp">opticomp</a>.
</p>
<p>Function <a href="#topic+sim2dis">sim2dis</a> can be used to convert a similarity matrix (e.g. a kinship matrix) into a dissimilarity matrix which is suitable for multidimensional scaling. 
</p>
<p><b>Breed Composition</b>
</p>
<p>The breed composition of crossbred individuals can be accessed with
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+pedBreedComp">pedBreedComp</a> </td><td style="text-align: left;"> Calculates <b>ped</b>igree based the <b>Breed</b> <b>Comp</b>osition, which is the genetic contribution</td>
</tr>
<tr>
 <td style="text-align: left;"> 
                    </td><td style="text-align: left;"> of each individual from other breeds and from native founders. The native contribution </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                    </td><td style="text-align: left;"> is the proportion of the genome not originating from other breeds.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+segBreedComp">segBreedComp</a> </td><td style="text-align: left;">  Calculates <b>seg</b>ment based the <b>Breed</b> <b>Comp</b>osition. The native contribution is the </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                    </td><td style="text-align: left;"> proportion of the genome belonging to segments that have low frequency in </td>
</tr>
<tr>
 <td style="text-align: left;">
                    </td><td style="text-align: left;"> other breeds.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The native contributions obtained by the above functions can be constrained or maximized with function <a href="#topic+opticont">opticont</a>  to remove introgressed genetic material, or alternatively, the segment-based native contribution can be considered a quantitative trait and included in a selection index.
</p>
<p><b>Haplotype frequencies</b> 
</p>
<p>Frequencies of haplotype segments in particular breeds can be computed and plotted with 
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+haplofreq">haplofreq</a> </td><td style="text-align: left;">  Calculates the maximum frequency each segment has in a set of reference breeds,</td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td><td style="text-align: left;"> and the name of the breed in which the segment has maximum frequency. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td><td style="text-align: left;"> Identification of native segments.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+freqlist">freqlist</a> </td><td style="text-align: left;"> Combines results obtained with function <a href="#topic+haplofreq">haplofreq</a> for different reference breeds </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: left;"> into a single R object which is suitable for plotting.</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+plot.HaploFreq">plot.HaploFreq</a> </td><td style="text-align: left;"> Plots frequencies of haplotype segments in particular reference breeds.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><b>Inbreeding Coefficients and Genetic Contributions</b> 
</p>
<p>The inbreeding coefficients and genetic contributions from ancestors can be computed with:
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+pedInbreeding">pedInbreeding</a>  </td><td style="text-align: left;">  Calculates  <b>ped</b>igree based  <b>Inbreeding</b>.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+segInbreeding">segInbreeding</a>  </td><td style="text-align: left;">  Calculates  <b>seg</b>ment based  <b>Inbreeding</b>, i.e. inbreeding based on </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                      </td><td style="text-align: left;">  runs of homozygosity (ROH).</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+genecont">genecont</a>   </td><td style="text-align: left;">  Calculates  <b>gene</b>tic  <b>cont</b>ributions  each individual has from all it's ancestors in </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> the pedigree.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td>
</tr>

</table>

<p><b>Preparing and plotting pedigree data</b> 
</p>
<p>There are some functions for preparing and plotting pedigree data
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+prePed">prePed</a>      </td><td style="text-align: left;"> <b>pre</b>pares a <b>Ped</b>igree by sorting, adding founders and pruning the pedigree,</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+completeness">completeness</a></td><td style="text-align: left;"> Calculates pedigree <b>completeness</b> in all ancestral generations,</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+summary.Pedig">summary.Pedig</a></td><td style="text-align: left;"> Calculates number of equivalent complete generations, number of fully </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                    </td><td style="text-align: left;"> traced  generations, number of maximum generations traced, index of </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                    </td><td style="text-align: left;"> pedigree completeness, inbreeding coefficients,</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+subPed">subPed</a>       </td><td style="text-align: left;"> Creates a <b>sub</b>set of a large <b>Ped</b>igree,</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+pedplot">pedplot</a>      </td><td style="text-align: left;"> Plots a pedigree,</td>
</tr>
<tr>
 <td style="text-align: left;"> 
<a href="#topic+sampleIndiv">sampleIndiv</a>  </td><td style="text-align: left;"> Samples individuals from a pedigree.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td>
</tr>

</table>

<p><b>Population Parameters</b> 
</p>
<p>Finally, there are some functions for estimating population parameters:
</p>

<table>
<tr>
 <td style="text-align: left;">
<a href="#topic+conttac">conttac</a>   </td><td style="text-align: left;"> Calculates genetic <b>cont</b>ributions of breeds <b>t</b>o  <b>a</b>ge <b>c</b>ohorts,</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="#topic+summary.candes">summary.candes</a> </td><td style="text-align: left;"> Calculates for every age cohort several genetic parameters. These may </td>
</tr>
<tr>
 <td style="text-align: left;">
                      </td><td style="text-align: left;"> include average kinships, kinships at native loci,</td>
</tr>
<tr>
 <td style="text-align: left;">
                      </td><td style="text-align: left;"> the native effective size, and the native genome equivalent.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><b>Genotype File Format</b>
</p>
<p>All functions reading genotype data assume that the files are in the following format:
</p>
<p>Genotypes are phased and missing genotypes have been imputed. Each file has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. There can be some extra columns on the left hand side containing no genotype data. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should be repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. 
</p>
<p>Use function <a href="#topic+read.indiv">read.indiv</a> to extract the IDs of the individuals from a genotype file. 
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann [aut, cre]
</p>
<p>Maintainer: Robin Wellmann &lt;r.wellmann@uni-hohenheim.de&gt;
</p>


<h3>References</h3>

<p>de Cara MAR, Villanueva B, Toro MA, Fernandez J (2013). Using genomic tools to maintain diversity and fitness in conservation programmes. Molecular Ecology. 22: 6091-6099
</p>
<p>Wellmann, R., and Pfeiffer, I. (2009). Pedigree analysis for conservation of genetic diversity and purging. Genet. Res.  91: 209-219
</p>
<p>Wellmann, R., and Bennewitz, J. (2011). Identification and characterization of hierarchical structures in dog breeding schemes, a novel method applied to the Norfolk Terrier. Journal of Animal Science. 89: 3846-3858
</p>
<p>Wellmann, R., Hartwig, S., Bennewitz, J. (2012). Optimum contribution selection for conserved populations with historic migration; with application to rare cattle breeds. Genetics Selection Evolution. 44: 34
</p>
<p>Wellmann, R., Bennewitz, J., Meuwissen, T.H.E. (2014) A unified approach to characterize and conserve adaptive and neutral genetic diversity in subdivided populations. Genet Res (Camb). 69: e16
</p>
<p>Wellmann, R. (2019). Optimum Contribution Selection and Mate
Allocation for Breeding: The R Package optiSel. BMC Bioinformatics 20:25
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#See ?opticont for optimum contribution selection 
#These examples demonstrate computation of some population genetic parameters.

data(ExamplePed)
Pedig &lt;- prePed(ExamplePed, thisBreed="Hinterwaelder", lastNative=1970)
head(Pedig)

############################################
# Evaluation of                            #
#    - kinships                            #
#    - genetic diversities                 #
#    - native effective size               #
#    - native genome equivalent            #
############################################

phen    &lt;- Pedig[Pedig$Breed=="Hinterwaelder",]
pKin    &lt;- pedIBD(Pedig)
pKinatN &lt;- pedIBDatN(Pedig, thisBreed="Hinterwaelder")
pop     &lt;- candes(phen=phen, pKin=pKin, pKinatN=pKinatN, quiet=TRUE, reduce.data=FALSE)
Param   &lt;- summary(pop, tlim=c(1970,2005), histNe=150, base=1800, df=4)


plot(Param$t, Param$Ne, type="l", ylim=c(0,150), 
     main="Native Effective Size", ylab="Ne", xlab="")

matplot(Param$t, Param[,c("pKin", "pKinatN")], 
        type="l",ylim=c(0,1),main="Kinships", xlab="Year", ylab="mean Kinship")
abline(0,0)
legend("topleft", legend = c("pKin", "pKinatN"), lty=1:2, col=1:2, cex=0.6)

info &lt;- paste("Base Year =", attributes(Param)$base, "  historic Ne =", attributes(Param)$histNe)

plot(Param$t,Param$NGE,type="l",main="Native Genome Equivalents", 
     ylab="NGE",xlab="",ylim=c(0,7))
mtext(info, cex=0.7)


############################################
# Genetic contributions from other breeds  #
############################################

cont &lt;- pedBreedComp(Pedig, thisBreed='Hinterwaelder')
contByYear &lt;- conttac(cont, Pedig$Born, use=Pedig$Breed=="Hinterwaelder", mincont=0.04, long=FALSE)
round(contByYear,2)

barplot(contByYear, ylim=c(0,1), col=1:10, ylab="genetic contribution",
        legend=TRUE, args.legend=list(x="topleft",cex=0.6))


######################################################
# Frequencies of haplotype segments in other breeds  #
######################################################

data(map)
data(Cattle)
dir   &lt;- system.file("extdata", package="optiSel")
files &lt;- file.path(dir, paste("Chr", 1:2, ".phased", sep=""))

Freq &lt;- freqlist(
  haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Rotbunt",   minSNP=20),
  haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Holstein",  minSNP=20),
  haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Fleckvieh", minSNP=20)
  )

plot(Freq, ID=1, hap=2, refBreed="Rotbunt")


</code></pre>

<hr>
<h2 id='agecont'>Contributions of age cohorts to the population</h2><span id='topic+agecont'></span>

<h3>Description</h3>

<p>Contributions of age classes to the population are calculated such that the contribution of each age class to the population is proportional to the expected proportion of offspring that is not yet born. 
</p>
<p>Note that the contribution of a class to the population is not equal to the proportion of individuals belonging to the class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agecont(Pedig, use=Pedig$Born &gt;= quantile(Pedig$Born, 0.75), maxAge=NA)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agecont_+3A_pedig">Pedig</code></td>
<td>
<p>Pedigree with colums <code>Indiv</code>, <code>Sire</code>, <code>Dam</code>, and <code>Born</code>, usually created with function <a href="#topic+prePed">prePed</a>.</p>
</td></tr>
<tr><td><code id="agecont_+3A_use">use</code></td>
<td>
<p>Logical vector or character vector with IDs indicating 
the individuals from the current population.</p>
</td></tr>
<tr><td><code id="agecont_+3A_maxage">maxAge</code></td>
<td>
<p>Parents that are more than <code>maxAge</code> years older than their offspring are ignored. By default, old parents are not ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contributions of age classes to the population are calculated such that the contribution of each age class to the population is proportional to the expected proportion of offspring that is not yet born. 
</p>
<p>More precisely:
</p>
<p>Individuals born in the current year are in age class <code>k=1</code>. Typically, each age class spans one year. No individual can have offspring in the same age class. Males and females that are not born in the current year are assumed to have equal contributions to the population. Moreover, as stated above, it is assumed that the contribution of each class to the population is proportional to the proportion of offspring from this class that is not yet born when the individuals leaves the class. 
</p>
<p>This approach to define contributions has the advantage that it does not need to be known which individuals are still alive and which are removed from the breeding pool. Moreover, it causes old age classes to have a smaller contribution to the population than young age classes.
</p>
<p>The contributions are estimated from the ages of the parents when the individuals in vector <code>use</code> were born. Obviously, the contributions of age classes to the offspring in the next year do not coincide with the contributions of the age classes to the population.
</p>


<h3>Value</h3>

<p>Data frame containing the contributions of all age cohorts to the current population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(PedigWithErrors)
Pedig &lt;- prePed(PedigWithErrors)
use   &lt;- Pedig$Breed=="Hinterwaelder" &amp; !is.na(Pedig$Born)
use   &lt;- use &amp; Pedig$Born&gt;=2000 &amp; Pedig$Born&lt;=2004 

# Calculate the contribution of each age class ##

cont &lt;- agecont(Pedig, use)

# Contribution of each age class to 
# the current population:

head(cont)

# Note: In this case, young males have a higher contribution to the  
# population than young females because they are used for breeding 
# for a shorter time span, i.e. they are culled earlier.

# Males and females (excluding the newborn individuals)
# have equal contributions to the current population:

sum(cont$male[-1])
#[1] 0.3925894

sum(cont$female[-1])
#[1] 0.3925894


# The total contribution of classes to the curent population is equal to 1 

sum(cont$female) + sum(cont$male) 
#[1] 1

# When used for OCS, the contribution of the offspring to the 
# population in the next year is equal to the contribution of the individuals
# born in this year to the current population:

cont$male[1]+cont$female[1]
#[1] 0.2148212

# This is approximately 1/L, where L is the generation interval.

</code></pre>

<hr>
<h2 id='candes'>Candidate Description</h2><span id='topic+candes'></span>

<h3>Description</h3>

<p>An R-Object is created containing all information describing the individuals, which is usually a sample from the current population and includes the selection candidates. Average kinships and trait values, and the available objective functions and constraints for optimum contribution selection (OCS) are reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>candes(phen,  cont=NULL, N=1000, quiet=FALSE, t=NA, bc=NULL, reduce.data=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="candes_+3A_phen">phen</code></td>
<td>
<p>Data frame with column <code>Indiv</code> containing animal IDs and possibly <code>Sex</code> containng sexes, coded as <code>'male'</code> and <code>'female'</code>, or <code>NA</code> if sexes are to be ignored. It also contains column <code>Born</code> with year of birth if generations are assumed to be overlapping. The other columns may contain traits, e.g. breeding values or native contributions, column <code>Breed</code> with breed names for multi-breed evaluations, logical column <code>isCandidate</code> indicating the selection candidates, and columns <code>Sire</code> and <code>Dam</code> with IDs of sires and dams.</p>
</td></tr>
<tr><td><code id="candes_+3A_cont">cont</code></td>
<td>
<p>Data frame frame with column <code>age</code> (equal to the row number), and columns <code>male</code>, and <code>female</code>, containing the contributions of males and females from each age class to the population. It is usually created with function <a href="#topic+agecont">agecont</a>. The default means that non-overlapping generations are  assumed, so there is only one age class for males and one for females.</p>
</td></tr>
<tr><td><code id="candes_+3A_n">N</code></td>
<td>
<p>The population size. A small value accelerates the increase in kinship due to genetic drift. For overlapping generations it can be calculated as <code>N=N0/r0</code>, where <code>N0</code> is the number of individuals born each year, and <code>r0&lt;=1</code> is the  percentage which this age class represents in the population. The default is <code>N=1000</code>.</p>
</td></tr>
<tr><td><code id="candes_+3A_quiet">quiet</code></td>
<td>
<p>Should the report be suppressed?</p>
</td></tr>
<tr><td><code id="candes_+3A_t">t</code></td>
<td>
<p>The time at which the population should be evaluated. The default means that <code>t=max(floor(phen$Born))</code>.</p>
</td></tr>
<tr><td><code id="candes_+3A_bc">bc</code></td>
<td>
<p>Only needed if multi-breed data is provided. Named vector with breed contributions, with component names being the names of the breeds in <code>phen</code>.  It contains the proportion of each breed to a hypothetical multi-breed population for which the diversity across breeds should be managed. Alternatively, <code>bc</code> can be a character string containig the name of a kinship. In this case, optimum contributions of the breeds are determined automatically so that the mean kinship across breeds is minimized.
</p>
</td></tr>
<tr><td><code id="candes_+3A_reduce.data">reduce.data</code></td>
<td>
<p>Logical. Should data from individuals not contributing to the population at time <code>t</code> be removed from the output?</p>
</td></tr>
<tr><td><code id="candes_+3A_...">...</code></td>
<td>
<p>One or more objects of class <code>'matrix'</code>, <code>'quadFun'</code>, or <code>'ratioFun'</code> defining the pairwise kinships and native kinships of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An R-Object is created containing all information describing the individuals, which is usually the current population and includes the selection candidates. Average kinships and trait values are estimated and reported. The weights of Age x Sex classes are in accordance with argument <code>cont</code>. The available objective functions and constraints for optimum contribution selection are reported.
</p>


<h3>Value</h3>

<p>List of class candes with the following components:
</p>
<table>
<tr><td><code>kinship</code></td>
<td>
<p>Objects of class <code>'quadFun'</code>, or <code>'ratioFun'</code>, one for each additional parameter. These objects define the functions needed to estimate the mean kinships and mean native kinships in the next year or generation.</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>Supplied data frame <code>phen</code> containing phenotypes, individual IDs, and some appended columns that are needed for OCS. These are
</p>
<p>* Column <code>Age</code> with the ages of the individuals,  
</p>
<p>* Column <code>Class</code> with the <code>Breed x Age x Sex</code> or <code>Breed x Age</code> classes to which the individuals belong. 
</p>
<p>* Column <code>c0</code> containing the contribution each individual itself has to the current population. 
</p>
<p>* Column <code>c1</code> containing the contribution each individual itself has to the population in the next year (for overlapping generations) or to the next generation (for non-overlapping generations). In the latter case, <code>c1</code> contains zeros.
</p>
<p>* Column <code>isCandidate</code> indicating the selection candidates. </p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Data frame containing estimates of the current mean values (at time <code>t</code>) of the parameters in a population consisting of <code>N</code> individuals for which the individuals in argument <code>phen</code> are representative. </p>
</td></tr>
<tr><td><code>current</code></td>
<td>
<p>Data frame containing the same values as component <code>mean</code>, but also some additional information on the parameters.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>Character vector with optimum breed contributions (see above).</p>
</td></tr>
<tr><td><code>classes</code></td>
<td>
<p>Data frame containing the number of individuals in each class (column <code>n</code>), the contribution of each class to the population in this year/generation (column <code>rcont0</code>) and in the next year/generation (column <code>rcont1</code>), and the expected proportion of offspring animals from a given sex have at a particular age.</p>
</td></tr>
<tr><td><code>breed</code></td>
<td>
<p>List describing the breeds included in the data set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)

Pedig      &lt;- prePed(PedigWithErrors, thisBreed="Hinterwaelder", lastNative=1970, 
                   keep=PedigWithErrors$Born%in%1992)
use        &lt;- Pedig$Born %in% (1980:1990) &amp; Pedig$Breed=="Hinterwaelder"
Population &lt;- Pedig$Indiv[use]

Pedig$NC   &lt;- pedBreedComp(Pedig, thisBreed="Hinterwaelder")$native
pKin       &lt;- pedIBD(Pedig, keep.only=Population)
pKinatN    &lt;- pedIBDatN(Pedig, thisBreed="Hinterwaelder",  keep.only=Population)
Phen       &lt;- Pedig[Population, ]

### Example 1: Overlapping Generations
### Old individuals contribute only little to the means:

cont &lt;- agecont(Pedig, Population, maxAge=10)
cand &lt;- candes(phen=Phen, pKin=pKin, pKinatN=pKinatN, cont=cont)

cand$current[,c("Name", "Type", "Breed", "Val", "Var")]
#     Name      Type         Breed         Val     Var
#1      BV     trait Hinterwaelder -0.55979308      BV
#2      NC     trait Hinterwaelder  0.56695077      NC
#3    pKin   kinship Hinterwaelder  0.02230896    pKin
#4 pKinatN nat. kin. Hinterwaelder  0.04678453 pKinatN

# BV:      simulated breeding values
# NC:      native genetic contribution computed from pedigree
# pKin:    pedigree-based kinship
# pKinatN: pedigree-based native kinship


### Example 2: Discrete Generations (cont=NULL). 
### Old individuals and young individuals contribute equally to the means:

Phen$Born &lt;- 1
cand &lt;- candes(phen=Phen, pKin=pKin, pKinatN=pKinatN, cont=NULL)

cand$current[,c("Name", "Type", "Breed", "Val", "Var")]

#     Name      Type         Breed         Val     Var
#1      BV     trait Hinterwaelder -0.71910508      BV
#2      NC     trait Hinterwaelder  0.58226604      NC
#3    pKin   kinship Hinterwaelder  0.01979228    pKin
#4 pKinatN nat. kin. Hinterwaelder  0.04053012 pKinatN


### Shorthand:

cand$mean
#          BV       NC       pKin    pKinatN
#1 -0.7191051 0.582266 0.01979228 0.04053012

cand$mean$pKin
#[1] 0.01979228

</code></pre>

<hr>
<h2 id='Cattle'>Phenotypes of Genotyped Cattle</h2><span id='topic+Cattle'></span>

<h3>Description</h3>

<p>Simulated phenotypes of cattle whose genotypes are included in files <a href="#topic+Chr1.phased">Chr1.phased</a>, and <a href="#topic+Chr2.phased">Chr2.phased</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Cattle)</code></pre>


<h3>Format</h3>

<p>Data frame containing information on genotyped cattle.
The columns contain the ID of the individual (<code>Indiv</code>), the year of birth (<code>Born</code>), the breed name (<code>Breed</code>), a breeding value (<code>BV</code>), the sex (<code>Sex</code>), and the herd (<code>herd</code>).
</p>

<hr>
<h2 id='Chr1.phased'>Phased Cattle Genotypes from Chromosome 1</h2><span id='topic+Chr1.phased'></span>

<h3>Description</h3>

<p>Phased genotypes of cattle from chromosome 1 (only the first part of the chromosome). Further information on these animals is included in data frame <a href="#topic+Cattle">Cattle</a>.
</p>


<h3>Format</h3>

<p>All functions reading phased genotype data assume that the files are in the following format:
</p>
<p>Each file has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. There can be some extra columns on the left hand side containing no genotype data. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should be repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces.
</p>
<p>Use function <a href="#topic+read.indiv">read.indiv</a> to extract the IDs of the individuals from a genotype file. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GTfile &lt;- system.file("extdata/Chr1.phased", package="optiSel")
file.show(GTfile)
GT     &lt;- read.table(GTfile, header=TRUE, skip=2, check.names=FALSE)
GT[1:10,1:5]
</code></pre>

<hr>
<h2 id='Chr2.phased'>Phased Cattle Genotypes from Chromosome 2</h2><span id='topic+Chr2.phased'></span>

<h3>Description</h3>

<p>Phased genotypes from Chromosome 2 (only the first part of the chromosome). Further information on these animals is included in data frame <a href="#topic+Cattle">Cattle</a>.
</p>


<h3>Format</h3>

<p>All functions reading phased genotype data assume that the files are in the following format:
</p>
<p>Each file has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. There can be some extra columns on the left hand side containing no genotype data. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should be repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces.
</p>
<p>Use function <a href="#topic+read.indiv">read.indiv</a> to extract the IDs of the individuals from a genotype file. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GTfile &lt;- system.file("extdata/Chr2.phased", package="optiSel")
file.show(GTfile)
GT &lt;- read.table(GTfile, header=TRUE, skip=2, check.names=FALSE)
GT[1:10,1:5]
</code></pre>

<hr>
<h2 id='completeness'>Calculates Pedigree Completeness</h2><span id='topic+completeness'></span>

<h3>Description</h3>

<p>Calculates completeness of the pedigree for individuals and for groups of individuals in each ancestral generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeness(Pedig, keep=NULL, maxd=50, by="Indiv")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completeness_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree, where the first columns are <code>Indiv</code> (Individual ID),  <code>Sire</code>, and <code>Dam</code>. More columns can be passed in the <code>Pedig</code> argument, in particular a column for grouping with the name defined by argument <code>by</code>.</p>
</td></tr>
<tr><td><code id="completeness_+3A_keep">keep</code></td>
<td>
<p>Vector with IDs of the individuals for which the completeness will be calculated, or a logical vector indicating the individuals. By default, all individuals are used.</p>
</td></tr>
<tr><td><code id="completeness_+3A_maxd">maxd</code></td>
<td>
<p>Number of generations for which completeness should be calculated.</p>
</td></tr>
<tr><td><code id="completeness_+3A_by">by</code></td>
<td>
<p>Name of a column in data frame <code>Pedig</code>. The completeness will be computed separately for each group defined by the column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the completeness of the pedigree for the specified individuals and for groups of individuals. It is the proportion of known ancestors in each generation. Generation 0 corresponds to the individual itself, so the completeness is always 1 in generation 0.
</p>


<h3>Value</h3>

<p>Data frame with the following columns
</p>
<table>
<tr><td><code>Indiv (or 'by')</code></td>
<td>
<p>ID of the individual or level of the grouping factor,</p>
</td></tr>
<tr><td><code>Generation</code></td>
<td>
<p>Generation number,</p>
</td></tr>
<tr><td><code>Completeness</code></td>
<td>
<p>Completeness of the pedigree in the respective generation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>


<h3>See Also</h3>

<p>Another function for characterizing pedigree completeness is <code><a href="#topic+summary.Pedig">summary.Pedig</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Computes the pedigree completeness of Hinterwald cattle 
#born between 2006 and 2007 in each ancestral generation.

data(PedigWithErrors)
Pedig &lt;- prePed(PedigWithErrors)
compl &lt;- completeness(Pedig, keep=Pedig$Born %in% (2006:2007), maxd=50, by="Indiv")
head(compl)

#Summary statistics can be computed directly from the pedigree:
Summary &lt;- summary(Pedig, keep=Pedig$Born %in% (2006:2007))
head(Summary)

hist(Summary$PCI,        xlim=c(0,1),  main="Pedigree Completeness")
hist(Summary$Inbreeding, xlim=c(0,1),  main="Inbreeding")
hist(Summary$equiGen,    xlim=c(0,20), main="Number of Equivalent Complete Generations")
hist(Summary$fullGen,    xlim=c(0,20), main="Number of Fully Traced Generations")
hist(Summary$maxGen,     xlim=c(0,20), main="Number of Maximum Generations Traced")

compl &lt;- completeness(Pedig, keep=Pedig$Born %in% (2006:2007), maxd=50, by="Sex")
head(compl)


library("ggplot2")
ggplot(compl, aes(Generation, Completeness, col=Sex))+geom_line()

</code></pre>

<hr>
<h2 id='conttac'>Calculates <b>Cont</b>ributions <b>T</b>o <b>A</b>ge <b>C</b>ohorts
</h2><span id='topic+conttac'></span>

<h3>Description</h3>

<p>Calculates genetic contributions of other breeds to age cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conttac(cont, cohort, use=rep(TRUE,length(cohort)), mincont=0.05, long=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conttac_+3A_cont">cont</code></td>
<td>
<p>Data frame containing the genetic contributions of several ancestors or breeds to all individuals. This is typically the output of function <a href="#topic+pedBreedComp">pedBreedComp</a>.</p>
</td></tr>
<tr><td><code id="conttac_+3A_cohort">cohort</code></td>
<td>
<p>Numeric vector indicating for every individual the age cohort to which it belongs (typically year of birth).</p>
</td></tr>
<tr><td><code id="conttac_+3A_use">use</code></td>
<td>
<p>Logical vector indicating for every individual whether it should be included in an age cohort (typically <code>TRUE</code> for individuals belonging to the breed of interest).</p>
</td></tr>
<tr><td><code id="conttac_+3A_mincont">mincont</code></td>
<td>
<p>Contributions of breeeds with average contribution smaller than <code>mincont</code> will be summarized in one row</p>
</td></tr>
<tr><td><code id="conttac_+3A_long">long</code></td>
<td>
<p>Should the resutling data frame be melted for easy plotting?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genetic contributions from other breeds to all age cohorts are computed. The genetic contribution from a breed is the fraction of genes in the gene pool originating from the respective breed.
</p>


<h3>Value</h3>

<p>Data frame containing the genetic contribution from every breed to every age cohort.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExamplePed)
Pedig      &lt;- prePed(ExamplePed, thisBreed="Hinterwaelder", lastNative=1970)
cont       &lt;- pedBreedComp(Pedig, thisBreed="Hinterwaelder")
contByYear &lt;- conttac(cont, Pedig$Born, use=Pedig$Breed=="Hinterwaelder", mincont=0.04, long=FALSE)
round(contByYear,2)

barplot(contByYear, ylim=c(0,1), col=1:10, ylab="genetic contribution",
        legend=TRUE, args.legend=list(x="bottomleft",cex=0.5))

</code></pre>

<hr>
<h2 id='ExamplePed'>Pedigree of Hinterwald Cattle</h2><span id='topic+ExamplePed'></span>

<h3>Description</h3>

<p>This data set gives a small subset of the pedigree of Hinterwald cattle suitable for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ExamplePed)</code></pre>


<h3>Format</h3>

<p>Data frame with columns <code>Indiv</code> (individual ID), <code>Sire</code>, <code>Dam</code>, <code>Sex</code>, <code>Breed</code>, <code>Born</code> with year of birth, and simulated breeding value <code>BV</code>.</p>

<hr>
<h2 id='freqlist'>Combines Objects Computed with Function haplofreq() into a List</h2><span id='topic+freqlist'></span>

<h3>Description</h3>

<p>The function combines objects computed with function <a href="#topic+haplofreq">haplofreq</a> into a list with class <code>HaploFreq</code> and adds some attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqlist(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqlist_+3A_...">...</code></td>
<td>
<p>R-objects computed with function <a href="#topic+haplofreq">haplofreq</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function combines objects computed with function <a href="#topic+haplofreq">haplofreq</a> into a list with class <code>HaploFreq</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>HaploFreq</code>
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir   &lt;- system.file("extdata", package="optiSel")
files &lt;- paste(dir, "/Chr", 1:2, ".phased", sep="")

Freq &lt;- freqlist(
 haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Rotbunt",   minL=2.0),
 haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Holstein",  minL=2.0),
 haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Fleckvieh", minL=2.0)
  )

#The component names are the reference breeds by default:
names(Freq)

plot(Freq, ID=1, hap=2, refBreed="Rotbunt")

plot(Freq, ID=1, hap=2, refBreed="Holstein", Chr=1)

</code></pre>

<hr>
<h2 id='genecont'>Calculates Genetic Contributions using Pedigrees. 
</h2><span id='topic+genecont'></span>

<h3>Description</h3>

<p>Calculates the genetic contributions each individual has from specified ancestors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genecont(Pedig, from=NULL, to=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genecont_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree, where the first columns are <code>Indiv</code> (Individual ID),  <code>Sire</code>, and <code>Dam</code>.</p>
</td></tr>
<tr><td><code id="genecont_+3A_from">from</code></td>
<td>
<p>Vector with ancestors whose contributions to the individuals should be calculated. By default, the contributions from all individuals will be calculated.</p>
</td></tr>
<tr><td><code id="genecont_+3A_to">to</code></td>
<td>
<p>Vector with individuals for which the contributions from ancestors should be calculated. By default, the contributions are calculated for all individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates genetic contributions of specified ancestors to each individual.
</p>


<h3>Value</h3>

<p>Lower triangular matrix with genetic contributions for each pair of individuals. Column i contains the genetic contribution of ancestor i to all individuals.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ExamplePed)
Pedig &lt;- prePed(ExamplePed)
cont  &lt;- genecont(Pedig)

plot(Pedig$Born, cont[,"276000803611144"], pch=18, ylim=c(0,1))
Pedig["276000803611144",]

#faster:
cont  &lt;- genecont(Pedig, from="276000803611144")
head(cont)
plot(Pedig$Born, cont[,"276000803611144"], pch=18, ylim=c(0,1))
</code></pre>

<hr>
<h2 id='haplofreq'>Evaluates the Occurrence of Haplotype Segments in Particular Breeds</h2><span id='topic+haplofreq'></span>

<h3>Description</h3>

<p>For each haplotype from <code>thisBreed</code> and every SNP the occurence of the haplotype segment containing the SNP in a set of reference breeds is evaluated. The maximum frequency each segment has in one of these reference breeds is computed, and the breed in which the segment has maximum frequency is identified. Results are either returned in a list or saved to files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplofreq(files, phen, map, thisBreed, refBreeds="others", minSNP=20, minL=1.0, 
  unitL="Mb", ubFreq=0.01, keep=NULL, skip=NA, cskip=NA, w.dir=NA, 
  what=c("freq", "match"), cores=1, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haplofreq_+3A_files">files</code></td>
<td>
<p>Either a character vector with file names, or a list containing character vectors with file names. The files contain phased genotypes,  one file for each chromosome. File names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>. The required format of the marker files is described under <code>Details</code>.
</p>
<p>If <code>file</code> is a character vector then, genotypes of all animals must be in the same files. Alternatively, <code>files</code> can be a list with the following two components:
</p>
<p><code>hap.thisBreed</code>: Character vector with names of the phased marker files for the individuals from <code>thisBreed</code>, one file for each chromosome.
</p>
<p><code>hap.refBreeds</code>: Character vector with names of the phased marker files for the individuals from the reference breeds (<code>refBreeds</code>), one file for each chromosome. If this component is missing, then it is assumed that the haplotypes of these animals are also included in <code>hap.thisBreed</code>.
</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_phen">phen</code></td>
<td>
<p>Data frame containing the ID (column <code>"Indiv"</code>) and the breed name (column <code>"Breed"</code>) of each genotyped individual.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_map">map</code></td>
<td>
<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in mega base pairs <code>'Mb'</code>, and the position in centimorgan <code>'cM'</code>. The order of the markers must be the same as in the files <code>files</code>. Marker names must have no white spaces.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_thisbreed">thisBreed</code></td>
<td>
<p>Name of a breed from column <code>Breed</code> in <code>phen</code>: The occurence of each haplotype segment from this breed in the reference breeds will be evaluated.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_refbreeds">refBreeds</code></td>
<td>
<p>Vector with names of breeds from column <code>Breed</code> in <code>phen</code>. These breeds are used as reference breeds.  The occurence of haplotype segments in these breeds will be evaluated. By default, all breeds in <code>phen</code>, except <code>thisBreed</code> are used as reference breeds. In contrast, for <code>refBreeds="all"</code>, all genotyped breeds are used as reference breeds.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_minsnp">minSNP</code></td>
<td>
<p>Minimum number of marker SNPs included in a segment.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_minl">minL</code></td>
<td>
<p>Minimum length of a segment in <code>unitL</code> (e.g. in cM or Mb).</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_unitl">unitL</code></td>
<td>
<p>The unit for measuring the length of a segment. Possible units are the number of marker SNPs included in the segment (<code>'SNP'</code>), the number of mega base pairs (<code>'Mb'</code>), and the genetic  distances between the first and the last marker in centiMorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_ubfreq">ubFreq</code></td>
<td>
<p>If a haplotype segment has frequency smaller than <code>ubFreq</code> in all reference breeds then the breed name is replaced by <code>'1'</code>, which indicates that the segment is native.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_keep">keep</code></td>
<td>
<p>Subset of the IDs of the individuals from data frame <code>phen</code>, or a logical vector indicating the animals in data frame <code>phen</code> that should be used.
The default <code>keep=NULL</code> means that all individuals included in <code>phen</code> will be considered.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_skip">skip</code></td>
<td>
<p>Take line <code>skip+1</code> of the files as the line with column names. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_cskip">cskip</code></td>
<td>
<p>Take column <code>cskip+1</code> of the files as the first column with genotypes. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_w.dir">w.dir</code></td>
<td>
<p>Output file directory. Writing results to files has the advantage that much less working memory is required. By default, no files are created. The function returns only the file names if files are created. </p>
</td></tr>
<tr><td><code id="haplofreq_+3A_what">what</code></td>
<td>
<p>For <code>what="freq"</code>, the maximum frequency each haplotype segment has in the reference breeds will be computed. For <code>what="match"</code>, the name of the reference breed in which the segment has maximum frequency will be determined. By default, the frequencies and the breed names both are determined.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used for parallel processing of chromosomes. By default one core is used. For <code>cores=NA</code> the number of cores will be chosen automatically. Using more than one core increases execution time if the function is already fast.</p>
</td></tr>
<tr><td><code id="haplofreq_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each haplotype from <code>thisBreed</code> and every SNP the occurence of the haplotype segment containing the SNP in a set of reference breeds is evaluated. The maximum frequency each segment has in one of these reference breeds is computed, and the breed in which the segment has maximum frequency is identified. Results are either returned in a list or saved to files.
</p>
<p><b>Marker file format</b>: Each marker file containing phased genotypes has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. The first <code>cskip</code> columns are ignored. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. 
</p>


<h3>Value</h3>

<p>If <code>w.dir=NA</code> then a list is returned. The list may have the following components:
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>Mx(2N) - matrix containing for every SNP and for each of the 2N haplotypes from <code>thisBreed</code> the maximum frequency the segment containing the SNP has in a the reference breeds.</p>
</td></tr>
<tr><td><code>match</code></td>
<td>
<p>Mx(2N) - matrix containing for every SNP and for each of the 2N haplotypes from <code>thisBreed</code> the first letter of the name of the reference breed in which the segment containing the SNP has maximum frequency. Segments with frequencies smaller than <code>ubFreq</code> in all reference breeds are marked as <code>'1'</code>, which indicates that the segment is native for <code>thisBreed</code>.
</p>
</td></tr>
</table>
<p>The list has attributes <code>thisBreed</code>, and <code>map</code>. 
</p>
<p>If <code>w.dir</code> is the name of a directory, then results are written to files, whereby each file corresponds to one  chromosome, and a data frame with file names is returned.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir   &lt;- system.file("extdata", package="optiSel")
files &lt;- file.path(dir, paste("Chr", 1:2, ".phased", sep=""))

Freq &lt;- freqlist(
 haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Rotbunt",   minL=2.0),
 haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Holstein",  minL=2.0),
 haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Fleckvieh", minL=2.0)
  )

plot(Freq, ID=1, hap=2, refBreed="Rotbunt")
plot(Freq, ID=1, hap=2, refBreed="Holstein", Chr=1)


## Test for using multiple cores:

Freq1 &lt;- haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Rotbunt", 
                   minL=2.0, cores=NA)$freq
range(Freq[[1]]-Freq1)
#[1] 0 0


## Creating output files with allele frequencies and allele origins:

rdir  &lt;- system.file("extdata", package = "optiSel")
wdir  &lt;- file.path(tempdir(), "HaplotypeEval")
chr   &lt;- unique(map$Chr)
files &lt;- file.path(rdir, paste("Chr", chr, ".phased", sep=""))
wfile &lt;- haplofreq(files, Cattle, map, thisBreed="Angler", minL=2.0, w.dir=wdir)

View(read.table(wfile$match[1],skip=1))
#unlink(wdir, recursive = TRUE)


</code></pre>

<hr>
<h2 id='makeA'>Calculates the Pedigree-based Additive Relationship Matrix 
</h2><span id='topic+makeA'></span>

<h3>Description</h3>

                                                 
<p>Calculates the the Pedigree-based Additive Relationship Matrix. This is twice the pedigree based kinship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeA(Pedig, keep.only=NULL, keep=keep.only, AFounder=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeA_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the Pedigree. The data frame has columns (1) Individual, (2) Sire, (3) Dam. Missing parents are coded as NA. Both parents must either be missing or present. If this is not the case use <a href="#topic+prePed">prePed</a>.</p>
</td></tr>
<tr><td><code id="makeA_+3A_keep">keep</code></td>
<td>
<p>If <code>keep</code> is provided then kinships are computed only for these animals and their ancestors.</p>
</td></tr>
<tr><td><code id="makeA_+3A_keep.only">keep.only</code></td>
<td>
<p>If <code>keep.only</code> is provided then kinships are computed only for these animals.</p>
</td></tr>
<tr><td><code id="makeA_+3A_afounder">AFounder</code></td>
<td>
<p>Additive relationship matrix of the founders. The row names are the ids of the founders. By default, founders are assumed to be unrelated. Founders not included in this matrix are also assumed to be unrelated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of pedigree based additive relationship matrix A which is twice the kinship matrix. For individuals i and j it is defined as
</p>

<table>
<tr>
 <td style="text-align: left;">
 Aij = 2*(Probability that two alleles chosen from individuals i and j are IBD). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Additive relationship matrix.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
data(Phen)
Pedig &lt;- prePed(PedigWithErrors)
keep  &lt;- Pedig$Indiv[summary(Pedig)$equiGen&gt;5 &amp; Pedig$Indiv %in% Phen$Indiv]
A     &lt;- makeA(Pedig, keep.only=keep)
A[1:3,1:3]
</code></pre>

<hr>
<h2 id='map'>Marker Map for Cattle</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Marker map for SNPs from cattle chromosomes 1 - 2  (only the first parts of the chromosomes). The corresponding genotypes are included in <a href="#topic+Chr1.phased">Chr1.phased</a> and  <a href="#topic+Chr2.phased">Chr2.phased</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(map)</code></pre>


<h3>Format</h3>

<p>Data frame containing the marker map including marker name (<code>Name</code>), chromosome number (<code>Chr</code>), position in base pairs (<code>Position</code>), position in centiMorgan (<code>cM</code>), and position in mega base pairs (<code>Mb</code>).
</p>

<hr>
<h2 id='matings'>Mate Allocation</h2><span id='topic+matings'></span>

<h3>Description</h3>

<p>Males and females are allocated for mating such that all breeding animals have the desired number of matings. The mean inbreeding coefficient in the offspring is minimized if matrix <code>Kin</code> contains pairwise kinships of the selection candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matings(phen, Kin,  alpha=1, 
    ub.n=NA, max=FALSE, solver="default", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matings_+3A_phen">phen</code></td>
<td>
<p>Data frame with desired number of matings (column <code>n</code>), sexes (column <code>Sex</code>), and IDs (column <code>Indiv</code>) of the selection candidates. The data frame may also contain column <code>herd</code> containing the names of the herds to which the females belong (<code>NA</code> for males).</p>
</td></tr>
<tr><td><code id="matings_+3A_kin">Kin</code></td>
<td>
<p>Kinship matrix (or an other similarity matrix) for selection candidates.</p>
</td></tr>
<tr><td><code id="matings_+3A_alpha">alpha</code></td>
<td>
<p>If <code>alpha&lt;1</code> then the proportion of matings with the same male is at most <code>alpha</code> in each herd. A value <code>alpha&lt;1</code> increases genetic connectedness between herds and enables to estimate more accurate breeding values.</p>
</td></tr>
<tr><td><code id="matings_+3A_ub.n">ub.n</code></td>
<td>
<p>Maximum number of matings of the same individuals. Without this constraint (i.e. <code>ub.n=NA</code>), some superior animals may always be mated to the same inferior animal, so their offspring would likely not be suitable for breeding.</p>
</td></tr>
<tr><td><code id="matings_+3A_max">max</code></td>
<td>
<p>The default <code>max=FALSE</code> means that the objective function is minimized.</p>
</td></tr>
<tr><td><code id="matings_+3A_solver">solver</code></td>
<td>
<p>Either <code>solver="default"</code>, or <code>solver=Rsymphony_solve_LP</code>. The latter is possible only if package <code>Rsymbhony</code> is loaded, which is not available for all platforms. </p>
</td></tr>
<tr><td><code id="matings_+3A_...">...</code></td>
<td>
<p>Further optimization parameters. By default, they are passed to function <a href="ECOSolveR.html#topic+ecos.control">ecos.control</a></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Males and females are allocated for mating such that all breeding animals have the desired number of matings. If <code>Kin</code> is a kinship matrix, then the mean inbreeding coefficient in the offspring is minimized. In general, the mean similarity of the parents is minimized.
</p>
<p>The maximum number of matings of the same individuals can be constrained. For each herd, the proportion <code>alpha</code> of matings with the same male can be constrained as well, but this increases computation time. 
</p>


<h3>Value</h3>

<p>Data frame with columns <code>Sire</code>, <code>Dam</code>, <code>n</code>, and possibly <code>herd</code>, whereby column <code>n</code> contains the desired number of matings, and column <code>herd</code> contains the herd of the dam.
</p>
<p>The data frame has attributes <code>objval</code> with the value of the objective function (usually the mean inbreeding coefficient), and attribute <code>info</code> describing the solution as reported by the solver.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("map")
data("Cattle")
dir   &lt;- system.file("extdata", package = "optiSel")
files &lt;- paste(dir, "/Chr", 1:2, ".phased", sep="")

sKin  &lt;- segIBD(files, map, minSNP=20, minL=2.0)
Phen  &lt;- Cattle[Cattle$Breed=="Angler", ]

cont  &lt;- data.frame(
  age   = c(   1,    2,    3,    4,    5,    6), 
  male  = c(0.11, 0.11, 0.10, 0.08, 0.06, 0.04),
  female= c(0.11, 0.11, 0.10, 0.08, 0.06, 0.04))

cand  &lt;- candes(phen=Phen, sKin = sKin, cont=cont)
con   &lt;- list(uniform="female", ub.sKin = 0.047)
Offspring &lt;- opticont("max.BV", cand, con, trace=FALSE)


#####  Minimize inbreeding   #####
Candidate   &lt;- Offspring$parent
Candidate$n &lt;- noffspring(Candidate, N=20)$nOff
Mating      &lt;- matings(Candidate, sKin)
Mating 
attributes(Mating)$objval



library("Rsymphony")
Mating &lt;- matings(Candidate, sKin, alpha=0.30, solver=Rsymphony_solve_LP)
Mating
attributes(Mating)$objval

attributes(Mating)$info
#[1] "Optimum solution found"


</code></pre>

<hr>
<h2 id='noffspring'>Calculates Optimum Numbers of Offspring</h2><span id='topic+noffspring'></span>

<h3>Description</h3>

<p>Calculates the optimum numbers of offspring from optimum contributions of selection candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noffspring(cand, N, random=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noffspring_+3A_cand">cand</code></td>
<td>
<p>Data frame with optimum contributions (column <code>oc</code>), sexes (column <code>Sex</code>), and IDs (column <code>Indiv</code>) of the selection candidates.</p>
</td></tr>
<tr><td><code id="noffspring_+3A_n">N</code></td>
<td>
<p>Desired number of individuals in the offspring population.</p>
</td></tr>
<tr><td><code id="noffspring_+3A_random">random</code></td>
<td>
<p>Logical. If <code>2*N*oc[i]</code> is not an integer value (say <code>2*N*oc[i]=11.4</code>) then individual <code>i</code> will have either 11 or 12 offspring. The actual number is either determined randomly or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the optimum numbers of offspring of the selection candidates from the optimum contributions <code>cand$oc</code> and the size <code>N</code> of the offspring population.
</p>


<h3>Value</h3>

<p>Data frame with column <code>Indiv</code> containing the individual IDs and column <code>nOff</code> containing the optimum numbers of offspring. 
</p>
<p>Column <code>nOff</code> is approximately <code>2*N*cand$oc</code> with <code>sum(noff[cand$Sex=="male"])=N</code> and <code>sum(noff[cand$Sex=="female"])=N</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data(PedigWithErrors)

Pedig      &lt;- prePed(PedigWithErrors, thisBreed="Hinterwaelder")
use        &lt;- Pedig$Born %in% (1998:2008) &amp; Pedig$Breed=="Hinterwaelder"
Population &lt;- sampleIndiv(Pedig[use, ], each=50)
pKin       &lt;- pedIBD(Pedig, keep.only=Population)
Phen       &lt;- Pedig[Population, ]
Phen$isCandidate &lt;- Phen$Born %in% (2003:2008)

cont       &lt;- agecont(Pedig, Population)
cand       &lt;- candes(phen=Phen, fA=pedIBD(Pedig, keep.only=Phen$Indiv), cont=cont)
con        &lt;- list(ub.fA=0.0175, uniform="female")
Offspring  &lt;- opticont("max.BV", cand, con, trace = FALSE)

N &lt;- 250
Candidate &lt;- Offspring$parent
Candidate$nOff &lt;- noffspring(Candidate, N)$nOff

sum(Candidate$nOff[Candidate$Sex=="male"])
#[1] 250

sum(Candidate$nOff[Candidate$Sex=="female"])
#[1] 250

round(2*N*Candidate$oc-Candidate$nOff, 2)
</code></pre>

<hr>
<h2 id='opticomp'>Calculates the Optimum Breed Composition</h2><span id='topic+opticomp'></span>

<h3>Description</h3>

<p>Calculates optimum contributions of breeds to a hypothetical multi-breed population with maximum diversity. Additionally the average kinship within and
between breeds and the genetic distances between breeds are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opticomp(f, phen, obj.fun="NGD", lb=NULL, ub=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opticomp_+3A_f">f</code></td>
<td>
<p>Kinship matrix (e.g. a segment based kinship matrix).</p>
</td></tr>
<tr><td><code id="opticomp_+3A_phen">phen</code></td>
<td>
<p>Data frame with column <code>Indiv</code> containing the IDs of the individuals and <code>Breed</code> with breed names.</p>
</td></tr>
<tr><td><code id="opticomp_+3A_obj.fun">obj.fun</code></td>
<td>
<p>The objective function to be maximized. For <code>"NGD"</code> the objective is to maximize the genetic diversity 1-<b>c</b>'<b>f</b><b>c</b> in the multi-breed population, where <b>f</b> is the matrix containing the mean kinships within and between breeds.
</p>
<p>For <code>"NTD"</code> the term <b>c</b>'(<b>1</b>-<b>F</b>)+<b>c</b>'(<b>F</b><b>1</b>' - 2<b>f</b> + <b>1</b><b>F</b>')<b>c</b> is maximized, where <b>F</b>=diag(<b>f</b>). This puts more weight on between population diversity.
</p>
</td></tr>
<tr><td><code id="opticomp_+3A_lb">lb</code></td>
<td>
<p>Named vector providing lower bounds for the contributions of the breeds can be provided. The names of the components are the breed names. The default <code>lb=NULL</code> means that the lower bound is 0 for all breeds.</p>
</td></tr>
<tr><td><code id="opticomp_+3A_ub">ub</code></td>
<td>
<p>Named vector providing upper bounds for the contributions of the breeds can be provided. The names of the components are the breed names. The default <code>ub=NULL</code> means that the upper bound is 1 for all breeds.</p>
</td></tr>
<tr><td><code id="opticomp_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the solver <a href="quadprog.html#topic+solve.QP">solve.QP</a> of R package <code>quadprog</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates optimum contributions of breeds to a hypothetical multi-breed population with maximum diversity. Additionally the average kinship within and
between breeds and the genetic distances between breeds are computed.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>bc</code></td>
<td>
<p>Vector with optimum contributions of breeds to a hypothetical multi-breed population with maximum  diversity</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the objective function, i.e. the maximum diversity that can be achieved.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Matrix containing the mean kinships within and between breeds.</p>
</td></tr>
<tr><td><code>Dist</code></td>
<td>
<p>Genetic distances between breeds.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>References</h3>

<p>Wellmann, R., Bennewitz, J., Meuwissen, T.H.E. (2014) A unified approach to characterize and conserve adaptive and neutral genetic diversity in subdivided populations. Genetics Selection Evolution. 69, e16
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(optiSel)
data(map) 
data(Cattle)
dir   &lt;- system.file("extdata", package = "optiSel")
files &lt;- paste(dir, "/Chr", 1:2, ".phased", sep="")

#####################################################################
#   Find the optimum breed composition using segment based kinship  #
#####################################################################
IBD &lt;- segIBD(files, minSNP=20, map=map, minL=2.0)
mb  &lt;- opticomp(IBD, Cattle, obj.fun="NGD")

#### Optimum breed composition: ###
round(mb$bc,3)
#   Angler Fleckvieh  Holstein   Rotbunt 
#    0.469     0.444     0.041     0.046 

#### Average kinships within and between breeds: ###
round(mb$f,4)
#          Angler Fleckvieh Holstein Rotbunt
#Angler    0.0523    0.0032   0.0414  0.0417
#Fleckvieh 0.0032    0.0625   0.0036  0.0032
#Holstein  0.0414    0.0036   0.1074  0.0894
#Rotbunt   0.0417    0.0032   0.0894  0.1057

#### Genetic distances between breeds: ###
round(mb$Dist,4)
#         Angler Fleckvieh Holstein Rotbunt
#Angler    0.0000    0.2329   0.1960  0.1930
#Fleckvieh 0.2329    0.0000   0.2853  0.2844
#Holstein  0.1960    0.2853   0.0000  0.1309
#Rotbunt   0.1930    0.2844   0.1309  0.0000

#####################################################################
#   The optimum breed composition depends on the kinship matrix     #
#   and the objective function:                                     #
#####################################################################

bc &lt;- opticomp(IBD, Cattle, obj.fun="NTD")$bc
round(bc,3)
#   Angler Fleckvieh  Holstein   Rotbunt 
#    0.264     0.447     0.148     0.141 

</code></pre>

<hr>
<h2 id='opticont'>Optimum Contributions of Selection Candidates</h2><span id='topic+opticont'></span>

<h3>Description</h3>

<p>The optimum contributions of selection candidates to the offspring are calculated. The optimization procedure can take into account conflicting breeding goals, which are to achieve genetic gain, to reduce the rate of inbreeding, and to recover the original genetic background of a breed. 
</p>
<p>It can be used for overlapping as well as for non-overlapping generations. In the case of overlapping generations, average values of the parameters for the population in the next year will be optimized, whereas for non-overlapping generations, average values of the parameters in the next generation will be optimized. Below, the &quot;next evaluation time&quot; means the next year for populations with overlapping generations, but the next generation for populations with non-overlapping generations. 
</p>
<p>Optimization can be done for several breeds or breeding lines simultaneously, which is adviseable if the aim is to increase diversity or genetic distance between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opticont(method, cand, con, bc=NULL,  solver="default", quiet=FALSE, 
         make.definite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opticont_+3A_method">method</code></td>
<td>
<p>Character string <code>"min.VAR"</code>, or <code>"max.VAR"</code>, whereby <code>VAR</code> is the name of the variable to be minimized or maximized. Available methods are reported by function <a href="#topic+candes">candes</a>.</p>
</td></tr>
<tr><td><code id="opticont_+3A_cand">cand</code></td>
<td>
<p>An R-Object containing all information describing the individuals (phenotypes and kinships). These indivdiuals are a sample from the population that includes the selection candidates. It can be created with function <a href="#topic+candes">candes</a>. This object also defines whether generations are overlapping or non-overlapping.
</p>
<p>* If the aim is to increase genetic distance between breeds, then samples from several breeds are needed.
</p>
<p>* If column <code>Sex</code> of data frame <code>cand$phen</code> contains <code>NA</code> for one breed, then the constraint stating that contributions of both sexes must be equal is omitted.</p>
</td></tr>
<tr><td><code id="opticont_+3A_con">con</code></td>
<td>
<p>List defining threshold values for constraints. The components are described in the Details section. If one is missing, then the respective constraint is not applied. Permitted constraint names are reported by function <a href="#topic+candes">candes</a>.</p>
</td></tr>
<tr><td><code id="opticont_+3A_bc">bc</code></td>
<td>
<p>Named numeric vector with breed contributions, which is only needed if <code>cand$phen</code> contains individuals from different breeds. It contains the proportion of each breed in a hypothetical multi-breed population for which the diversity across breeds should be managed. The names of the components are the breed names. </p>
</td></tr>
<tr><td><code id="opticont_+3A_solver">solver</code></td>
<td>
<p>Name of the solver used for optimization. Available solvers are  <code>"alabama"</code>, <code>"cccp"</code>, <code>"cccp2"</code>, and <code>"slsqp"</code>. Solver <code>"csdp"</code> is disabled because the package Rcsdp has been removed from Cran. By default, the solver is chosen automatically. The solvers are the same as for function <a href="optiSolve.html#topic+solvecop">solvecop</a> from package <code>optiSolve</code>.</p>
</td></tr>
<tr><td><code id="opticont_+3A_quiet">quiet</code></td>
<td>
<p>If <code>quiet=FALSE</code> then detailed information is shown.</p>
</td></tr>
<tr><td><code id="opticont_+3A_make.definite">make.definite</code></td>
<td>
<p>Logical variable indicating whether non-positive-semidefinite matrices should be approximated by positive-definite matrices. This is always done for solvers that are known not to convergue otherwise.</p>
</td></tr>
<tr><td><code id="opticont_+3A_...">...</code></td>
<td>
<p>Tuning parameters of the solver. The available parameters depend on the solver and will be printed when function <code>opticont</code> is used with default values. Definitions of the tuning parameters can be found for <code>alabama</code>  in <a href="alabama.html#topic+auglag">auglag</a> and <a href="stats.html#topic+optim">optim</a>, for <code>cccp</code> and <code>cccp2</code> in <a href="cccp.html#topic+ctrl">ctrl</a>, and for <code>slsqp</code>  in <a href="nloptr.html#topic+nl.opts">nl.opts</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimum contributions of selection candidates to the offspring are calculated. The proportion of offspring that should have a particular selection candidate as parent is twice its optimum contribution.
</p>
<p><b>Constraints</b>
</p>
<p>Argument <code>con</code> is a list defining the constraints. Permitted names for the components are displayed by  function <a href="#topic+candes">candes</a>. Their meaning is as follows:
</p>
<p><b>uniform</b>: Character vector specifying the breeds or sexes for which the contributions are not to be optimized. Within each of these groups it is assumed that all individuals have equal (uniform) contributions. Character string <code>"BREED.female"</code> means that all females from breed <code>BREED</code> have equal contributions and thus equal numbers of offspring. Column 'isCandidate' of <code>cand$phen</code> is ignored for these individuals.
</p>
<p><b>lb</b>: Named numeric vector containing lower bounds for the contributions of the selection candidates. The component names are their IDs. By default the lower bound is 0 for all individuals.
</p>
<p><b>ub</b>: Named numeric vector containing upper bounds for the contributions of the selection candidates. Their component names are the IDs. By default no upper bound is specified.
</p>
<p><b>ub.VAR</b>: Upper bound for the expected mean value of kinship or trait <b>VAR</b> in the population at the next evaluation time. Upper bounds for an arbitrary number of different kinships and traits may be provided. If data frame <code>cand$phen</code> contains individuals from several breeds, the bound refers to the mean value of the kinship or trait in the multi-breed population.
</p>
<p><b>ub.VAR.BREED</b>: Upper bound for the expected mean value of kinship or trait <b>VAR</b> in the  breed <b>BREED</b> at the next evaluation time. Upper bounds for an arbitrary number of different kinships and traits may be provided. 
</p>
<p>Note that <b>VAR</b> must be replaced by the name of the variable and <b>BREED</b> by the name of the breed. For traits, lower bounds can be defined as <b>lb.VAR</b> or <b>lb.VAR.BREED</b>. Equality constraints can be defined as  <b>eq.VAR</b> or <b>eq.VAR.BREED</b>.
</p>
<p><b>Application to multi-breed data</b>
</p>
<p>Optimization can be done for several breeds or breeding lines simultaneously, which is adviseable if the aim is to increase genetic diversity in a multi-breed population, or to increase the genetic distances between breeds or breeding lines. However, for computing the kinship of individuals from different breeds, marker data is needed. 
</p>
<p>The multi-breed population referred above is a hypothetical subdivided population consisting of purebred animals from the breeds included in column <code>Breed</code> of <code>cand$phen</code>. The proportion of individuals from a given breed in this population is its breed contribution specified in argument <code>bc</code>. It is not the proportion of individuals of this breed in data frame <code>cand$phen</code>.
</p>
<p>The aim is to minimize or to constrain the average genomic kinship in this multi-breed population. This causes the genetic distance between the breeds to increase, and thus may increase the conservation value of the breeds, or the heterosis effects in crossbred animals.
</p>
<p><b>Remark</b>
</p>
<p>If the function does not provide a valid result due to numerical problems then try to use another solver, use other optimization parameters, define upper or lower bounds instead of equality constraints, or relax the constraints to ensure that the optimization problem is solvable. 
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>parent</code></td>
<td>
<p>Data frame <code>cand$phen</code> with some appended columns. Column <code>oc</code> contains the optimum contributions of the selection candidates, column <code>lb</code> the lower bounds, and <code>ub</code> the upper bounds for the contributions.</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>Data frame with component <code>valid</code> indicating if all constraints are fulfilled, component <code>solver</code> containing the name of the solver used for optimization, and component <code>status</code> describing the solution as reported by the solver.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Data frame containing the expected mean value of each kinship and trait in the population at the next evaluation time.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>Data frame with breed contributions in the hypothetical multi-breed population used for computing the average kinship across breeds.</p>
</td></tr>
<tr><td><code>obj.fun</code></td>
<td>
<p>Named numeric value with value and name of the objective function.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Data frame containing one row for each constraint with the value of the constraint in column <code>Val</code>, and the bound for the constraint in column <code>Bound</code>. Column <code>OK</code> states if the constraint is fulfilled, and column <code>Breed</code> contains the name of the breed to which the constraint applies.  The value of the objective function is shown in the first row.  Additional rows contain the mean values of traits and kinships in the population at the next evaluation time which are not constrained.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>References</h3>

<p>Wellmann, R. (2018). Optimum Contribution Selection and Mate
Allocation for Breeding: The R Package optiSel. submitted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## For other objective functions and constraints see the vignettes


######################################################
# Example 1: Advanced OCS with overlapping           #
#            generations using pedigree data         #
#   - maximize genetic gain                 (BV)     #
#   - restrict increase of mean kinship     (pKin)   #
#   - restrict increase of native kinship   (pKinatN)#
#   - avoid decrease of native contribution (NC)     #
######################################################

### Define object cand containing all required 
### information on the individuals

data(PedigWithErrors)
Pedig    &lt;- prePed(PedigWithErrors, thisBreed="Hinterwaelder", lastNative=1970, 
                   keep=PedigWithErrors$Born%in%1992)
Pedig$NC &lt;- pedBreedComp(Pedig, thisBreed="Hinterwaelder")$native
use      &lt;- Pedig$Born %in% (1980:1990) &amp; Pedig$Breed=="Hinterwaelder"
use      &lt;- use &amp; summary(Pedig)$equiGen&gt;=3
cont     &lt;- agecont(Pedig, use, maxAge=10)

Phen     &lt;- Pedig[use, ]
pKin     &lt;- pedIBD(Pedig, keep.only=Phen$Indiv)
pKinatN  &lt;- pedIBDatN(Pedig, thisBreed="Hinterwaelder",  keep.only=Phen$Indiv)
Phen$isCandidate &lt;-  Phen$Born &lt; 1990
cand     &lt;- candes(phen=Phen, pKin=pKin, pKinatN=pKinatN, cont=cont)

### Mean values of the parameters in the population:

cand$mean
#          BV        NC      pKin    pKinatN
#1 -0.5648208 0.5763161 0.02305245 0.0469267


### Define constraints for OCS
### Ne: Effective population size
### L:  Generation interval

Ne   &lt;- 100
L    &lt;- 1/(4*cont$male[1]) + 1/(4*cont$female[1])
con &lt;- list(uniform    = "female",
            ub.pKin    = 1-(1-cand$mean$pKin)*(1-1/(2*Ne))^(1/L),
            ub.pKinatN = 1-(1-cand$mean$pKinatN)*(1-1/(2*Ne))^(1/L),
            lb.NC      = cand$mean$NC)

### Solve the optimization problem

Offspring  &lt;- opticont("max.BV", cand, con, trace=FALSE)

### Expected average values of traits and kinships 
### in the population now and at the next evaluation time

rbind(cand$mean, Offspring$mean)   
#          BV        NC       pKin    pKinatN
#1 -0.5648208 0.5763161 0.02305245 0.04692670
#2 -0.4972679 0.5763177 0.02342014 0.04790944

### Data frame with optimum contributions

Candidate &lt;- Offspring$parent
Candidate[Candidate$oc&gt;0.01, c("Indiv", "Sex", "BV", "NC", "lb", "oc", "ub")] 


######################################################
# Example 2: Advanced OCS with overlapping           #
#            generations using genotype data         #
#   - minimize mean kinship                 (sKin)   #
#   - restrict increase of native kinship   (sKinatN)#
#   - avoid decrease of breeding values     (BV)     #
#   - cause increase of native contribution (NC)     #
######################################################


### Prepare genotype data

data(map) 
data(Cattle)

### Compute genomic kinship and genomic kinship at native segments
dir     &lt;- system.file("extdata", package = "optiSel")
files   &lt;- file.path(dir, paste("Chr", 1:2, ".phased", sep=""))
sKin    &lt;- segIBD(files, map, minL=1.0)
sKinatN &lt;- segIBDatN(files, Cattle, map, thisBreed="Angler",  minL=1.0)

### Compute migrant contributions of selection candidates 
Haplo   &lt;- haplofreq(files, Cattle, map, thisBreed="Angler", minL=1.0, what="match")
Comp    &lt;- segBreedComp(Haplo$match, map)
Cattle[Comp$Indiv, "NC"] &lt;- Comp$native

Phen  &lt;- Cattle[Cattle$Breed=="Angler",]
cand  &lt;- candes(phen=Phen, sKin=sKin, sKinatN=sKinatN, cont=cont)

### Define constraints for OCS
### Ne: Effective population size
### L:  Generation interval

Ne &lt;- 100 
L  &lt;- 4.7 
con &lt;- list(uniform    = "female",
            ub.sKinatN = 1-(1-cand$mean$sKinatN)*(1-1/(2*Ne))^(1/L),
            lb.NC      = 1.03*cand$mean$NC,
            lb.BV      = cand$mean$BV)

# Compute optimum contributions; the objective is to minimize mean kinship 
Offspring   &lt;- opticont("min.sKin", cand, con=con)

# Check if the optimization problem is solved 
Offspring$info           

# Average values of traits and kinships 
rbind(cand$mean, Offspring$mean)         
#           BV        NC       sKin    sKinatN
#1 -0.07658022 0.4117947 0.05506277 0.07783431
#2 -0.07657951 0.4308061 0.04830328 0.06395410

# Value of the objective function 
Offspring$obj.fun
#      sKin 
#0.04830328 

### Data frame with optimum contributions

Candidate &lt;- Offspring$parent
Candidate[Candidate$oc&gt;0.01, c("Indiv", "Sex", "BV", "NC", "lb", "oc", "ub")] 


#######################################################
# Example 3: Advanced OCS with overlapping            #
#            generations using genotype data          #
#            for multiple breeds or beeding lines     #
#   - Maximize breeding values in all breeds          #
#   - restrict increase of kinships within each breed #
#   - reduce average kinship across breeds            #
#   - restrict increase of native kinship in Angler   #
#   - cause increase of native contribution in Angler #
# by optimizing contributions of males from all breeds#
#######################################################


cand &lt;- candes(phen=Cattle, sKin=sKin, sKinatN.Angler=sKinatN, cont=cont)
L  &lt;- 5
Ne &lt;- 100

con  &lt;- list(uniform          = "female", 
             ub.sKin          = cand$mean$sKin - 0.01/L,
             ub.sKin.Angler   = 1-(1-cand$mean$sKin.Angler)*(1-1/(2*Ne))^(1/L),
             ub.sKin.Holstein = 1-(1-cand$mean$sKin.Holstein)*(1-1/(2*Ne))^(1/L),
             ub.sKin.Rotbunt  = 1-(1-cand$mean$sKin.Rotbunt)*(1-1/(2*Ne))^(1/L),
             ub.sKin.Fleckvieh= 1-(1-cand$mean$sKin.Fleckvieh)*(1-1/(2*Ne))^(1/L),
             ub.sKinatN.Angler= 1-(1-cand$mean$sKinatN.Angler)*(1-1/(2*Ne))^(1/L), 
             lb.NC            = cand$mean$NC + 0.05/L)
            
Offspring &lt;- opticont("max.BV", cand, con, trace=FALSE, solver="slsqp")

Offspring$mean


Candidate &lt;- Offspring$parent[Offspring$parent$Sex=="male", ]
Candidate[Candidate$oc&gt;0.01, c("Indiv", "Sex", "BV", "NC", "lb", "oc", "ub")] 



</code></pre>

<hr>
<h2 id='pedBreedComp'>Calculates the Pedigree Based Breed Composition of Individuals
</h2><span id='topic+pedBreedComp'></span>

<h3>Description</h3>

<p>Computes for every individual the genetic contribution from native founders and from other breeds according to the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedBreedComp(Pedig, thisBreed)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedBreedComp_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree with the first 3 columns being <code>Indiv</code> (individual ID), <code>Sire</code>, and <code>Dam</code>. Additional columns include column <code>Breed</code> with breed names. Missing parents are coded as <code>NA</code>. All animals have no parent or both parents missing. It is usually created with function <a href="#topic+prePed">prePed</a>.</p>
</td></tr>
<tr><td><code id="pedBreedComp_+3A_thisbreed">thisBreed</code></td>
<td>
<p>Name of the breed of interest as denoted in column <code>Breed</code> of the pedigree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every individual the genetic contribution from native founders and from other breeds is computed. It is the fraction of genes that originate from the respective breed.
</p>


<h3>Value</h3>

<p>Data frame with one row for each individual and the following columns
</p>
<table>
<tr><td><code>Indiv</code></td>
<td>
<p>IDs of the individuals</p>
</td></tr>
<tr><td><code>native</code></td>
<td>
<p>Native Contribution: The genetic contribution from native founders.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Genetic contributions from other breeds, one column for each breed. The columns are ordered, so that the most influential breeds come first.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExamplePed)
Pedig    &lt;- prePed(ExamplePed, thisBreed="Hinterwaelder", lastNative=1970)
cont     &lt;- pedBreedComp(Pedig, thisBreed="Hinterwaelder")
cont[1000:1010,2:5]

contByYear &lt;- conttac(cont, Pedig$Born, use=Pedig$Breed=="Hinterwaelder", mincont=0.04, long=FALSE)
round(contByYear,2)

barplot(contByYear,ylim=c(0,1), col=1:10, ylab="genetic contribution",
        legend=TRUE, args.legend=list(x="bottomleft",cex=0.6))
</code></pre>

<hr>
<h2 id='pedIBD'>Calculates the Pedigree-based Kinship Matrix 
</h2><span id='topic+pedIBD'></span>

<h3>Description</h3>

                                                 
<p>Calculates the <b>ped</b>igree based probability of alleles to be <b>IBD</b>. This pedigree based kinship matrix is also called coancestry matrix and is half the additive relationship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedIBD(Pedig, keep.only=NULL, keep=keep.only, kinFounder=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedIBD_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree with <code>Indiv</code> (individual ID), <code>Sire</code>, and <code>Dam</code> in the first 3 columns.
Missing parents are coded as NA. Both parents must either be missing or present. If this is not the case use function <a href="#topic+prePed">prePed</a> to prepare the pedigree.</p>
</td></tr>
<tr><td><code id="pedIBD_+3A_keep">keep</code></td>
<td>
<p>If <code>keep</code> is provided then kinships are computed only for these animals and their ancestors.</p>
</td></tr>
<tr><td><code id="pedIBD_+3A_keep.only">keep.only</code></td>
<td>
<p>If <code>keep.only</code> is provided then kinships are computed only for these animals.</p>
</td></tr>
<tr><td><code id="pedIBD_+3A_kinfounder">kinFounder</code></td>
<td>
<p>Kinship matrix for the founders. The row names are the ids of the founders. By default, founders are assumed to be unrelated. Founders not included in this matrix are also assumed to be unrelated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of pedigree based kinship matrix f which is half the additive relationship matrix. For individuals i and j it is defined as
</p>

<table>
<tr>
 <td style="text-align: left;">
 fij = Probability that two alleles chosen from individuals i and j are IBD. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Kinship matrix.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
data(Phen)
keep  &lt;- Phen$Indiv
Pedig &lt;- prePed(PedigWithErrors, keep=keep, thisBreed="Hinterwaelder", lastNative=1970)
pedA  &lt;- pedIBD(Pedig, keep.only=keep)
</code></pre>

<hr>
<h2 id='pedIBDatN'>Calculates the Pedigree Based Kinship at Native Alleles
</h2><span id='topic+pedIBDatN'></span>

<h3>Description</h3>

<p>Calculates the kinship at native alleles, which is the pedigree based probability of native alleles to be IBD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedIBDatN(Pedig, thisBreed=NA, keep.only=NULL, keep=keep.only, nGen=NA, quiet=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedIBDatN_+3A_pedig">Pedig</code></td>
<td>

<p>Data frame containing the pedigree with <code>Indiv</code> (Individual ID), <code>Sire</code>, and <code>Dam</code> in the first 3 columns, column <code>Breed</code> with breed names, and possibly column <code>Sex</code>. Missing parents are coded as NA, 0, or &quot;0&quot;.
</p>
</td></tr>
<tr><td><code id="pedIBDatN_+3A_thisbreed">thisBreed</code></td>
<td>
<p>Name of the breed for which the kinships are to be computed.</p>
</td></tr>
<tr><td><code id="pedIBDatN_+3A_keep">keep</code></td>
<td>
<p>If <code>keep</code> is provided then kinships are computed only for these animals and their ancestors.</p>
</td></tr>
<tr><td><code id="pedIBDatN_+3A_keep.only">keep.only</code></td>
<td>
<p>If <code>keep.only</code> is provided then kinships are computed only for these animals.</p>
</td></tr>
<tr><td><code id="pedIBDatN_+3A_ngen">nGen</code></td>
<td>
<p>Number of generations taken into account for estimating the native effective size. The default means that the native effective size is not estimated, which requires less memory.</p>
</td></tr>
<tr><td><code id="pedIBDatN_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a list containing matrices needed to compute pedigree based kinships at native alleles, defined as the conditional probability that two randomly chosen alleles are IBD, given that both originate from native founders.
A native founder is an individual with unkown parents belonging to <code>thisBreed</code>.
</p>
<p>The kinship at native alleles between individuals i and j is <code>Q1[i,j]/Q2[i,j]</code>.
</p>
<p>The mean kinship at native alleles in the offspring is <code>(x'Q1x+d1)/(x'Q2x+d2)</code>, where <code>x</code> is the vector with genetic contributions of the selection candidates.
</p>
<p>The native effective size is estimated from <code>nGen</code> generations only if <code>nGen</code> is not <code>NA</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>ratioFun</code> including components:
</p>
<table>
<tr><td><code>Q1</code></td>
<td>
<p>matrix with <code>Q1[i,j]</code>  = Probability that two alleles chosen from individuals i and j are IBD and are native.</p>
</td></tr>
<tr><td><code>Q2</code></td>
<td>
<p>matrix with <code>Q2[i,j]</code> = Probability that two alleles chosen from individuals i and j are both native.</p>
</td></tr>
<tr><td><code>d1</code></td>
<td>
<p>The value by which the probability that two alleles chosen from the offspring are IBD and native increases due to genetic drift.</p>
</td></tr>
<tr><td><code>d2</code></td>
<td>
<p>The value by which the probability that two alleles chosen from the offspring are native increases due to genetic drift.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>IDs of the individuals for which the probabilites have been computed.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean kinship at native alleles of the individuals specified in argument <code>keep.only</code>. Note that <code>1-mean</code> is the genetic diversity at native segments of the specified individuals from <code>thisBreed</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
data(Phen)
keep  &lt;- Phen$Indiv
Pedig &lt;- prePed(PedigWithErrors, keep=keep, thisBreed="Hinterwaelder", lastNative=1970)
pKinatN &lt;- pedIBDatN(Pedig, thisBreed="Hinterwaelder", keep.only=keep, nGen=6)

#Number of Migrant Founders: 237
#Number of Native  Founders: 150
#Individuals in Pedigree   : 1658
#Native effective size     : 49.5

## Mean kinship at native segments:
pKinatN$mean
#[1] 0.0776925

## Note that this can not be computed as mean(pKinatN$of).

## Results for individuals:
pKinatN$of &lt;- pKinatN$Q1/pKinatN$Q2
pKinatN$of["276000812497583","276000812496823"]
#[1] 0.05941229


</code></pre>

<hr>
<h2 id='pedIBDorM'>Calculates Kinships taking Allele Origin into Account
</h2><span id='topic+pedIBDorM'></span>

<h3>Description</h3>

<p>Calculates the <b>ped</b>igree based probability of alleles to be <b>IBD</b> (identical by descent) <b>or</b> <b>M</b>igrant alleles: 
For each pair of individuals the probability is computed that two alleles taken at random are IBD or are migrant alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedIBDorM(Pedig, thisBreed=NA, keep.only=NULL, keep=keep.only)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedIBDorM_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the Pedigree. The data frame has columns (1) Individual, (2) Sire, (3) Dam, (4) Sex, and (5) Breed. Missing parents are coded as NA. Both parents must either be missing or present. If this is not the case use <a href="#topic+prePed">prePed</a>.</p>
</td></tr>
<tr><td><code id="pedIBDorM_+3A_thisbreed">thisBreed</code></td>
<td>
<p>Name of the breed in column (5) of the pedigree for which the kinships are to be computed.</p>
</td></tr>
<tr><td><code id="pedIBDorM_+3A_keep">keep</code></td>
<td>
<p>If <code>keep</code> is provided then kinships are computed only for these animals and their ancestors.</p>
</td></tr>
<tr><td><code id="pedIBDorM_+3A_keep.only">keep.only</code></td>
<td>
<p>If <code>keep.only</code> is provided then kinships are computed only for these animals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of modified pedigree based kinship matrices taking allele origin into account. 
</p>
<p>A native founder is an individual with unkown parents belonging to <code>thisBreed</code>. A migrant is an individual with unkown parents not belonging to <code>thisBreed</code>. 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>pedIBDorM</code></td>
<td>
<p>Matrix containing for  individuals i and j the probability that two alleles chosen from the individuals are IBD or at least one of them is a migrant allele (only computed if 1 is in <code>method</code>)</p>
</td></tr>
<tr><td><code>pedIBDorMM</code></td>
<td>
<p>Matrix containing for  individuals i and j the probability that two alleles chosen from the individuals are IBD or both are migrant alleles (only computed if 2 is in <code>method</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
data(Phen)
keep  &lt;- Phen$Indiv
Pedig &lt;- prePed(PedigWithErrors, keep=keep, thisBreed="Hinterwaelder", lastNative=1970)
Kin   &lt;- pedIBDorM(Pedig, thisBreed="Hinterwaelder", keep.only=keep)

mean(Kin$pedIBDorM)
#[1] 0.8201792
mean(Kin$pedIBDorMM)
#[1] 0.335358
</code></pre>

<hr>
<h2 id='PedigWithErrors'>Pedigree of Hinterwald cattle</h2><span id='topic+PedigWithErrors'></span>

<h3>Description</h3>

<p>This data set gives the pedigree of Hinterwald cattle with some artificially introduced errors and simulated breeding values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PedigWithErrors)</code></pre>


<h3>Format</h3>

<p>A data frame with columns <code>Indiv</code> (individual ID), <code>Sire</code>, <code>Dam</code>, <code>Sex</code>, <code>Breed</code>, <code>Born</code> with year of birth, and column <code>BV</code> with simulated breeding values.</p>

<hr>
<h2 id='pedInbreeding'>Calculates Pedigree Based Inbreeding 
</h2><span id='topic+pedInbreeding'></span>

<h3>Description</h3>

                                                 
<p>Calculates Pedigree Based Inbreeding 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedInbreeding(Pedig)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedInbreeding_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the Pedigree with the first 3 columns being <code>Indiv</code> (individual ID), <code>Sire</code>, and <code>Dam</code>, which is usually obtained with function <a href="#topic+prePed">prePed</a>. Missing parents are coded as NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of pedigree based inbreeding.
This function is a wrapper function for <code><a href="pedigree.html#topic+calcInbreeding">pedigree</a></code> from package  <code><a href="pedigree.html#topic+pedigree-package">pedigree</a></code>. 
</p>


<h3>Value</h3>

<p>A data frame with column <code>Indiv</code> containing the individual IDs and column <code>Inbr</code> containing the inbreeding coefficients.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
data(Phen)
keep  &lt;- Phen$Indiv 
Pedig &lt;- prePed(PedigWithErrors, keep=keep)
Res   &lt;- pedInbreeding(Pedig)
mean(Res$Inbr[Res$Indiv %in% keep])
#[1] 0.01943394
</code></pre>

<hr>
<h2 id='pedplot'>Plots a Pedigree</h2><span id='topic+pedplot'></span>

<h3>Description</h3>

<p>Plots a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedplot(Pedig, affected=NULL, status=NULL, label="Indiv", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedplot_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree with columns <code>Indiv</code> (indivdual ID), <code>Sire</code>, <code>Dam</code>, and <code>Sex</code>. Use <a href="#topic+subPed">subPed</a> to ensure that the pedigree is in the correct format.</p>
</td></tr>
<tr><td><code id="pedplot_+3A_affected">affected</code></td>
<td>

<p>Logical vector indicating for each individual if its symbol should be plotted in colour. The default <code>NULL</code> means that the individuals in column <code>keep</code> of data frame <code>Pedig</code> are plotted in colour (if present).
</p>
</td></tr>
<tr><td><code id="pedplot_+3A_status">status</code></td>
<td>
<p>Logical vector indicating for each individual if its symbol in the plot should be crossed out. The default <code>NULL</code> means that animals from other breeds than those plotted in colour are crossed out.</p>
</td></tr>
<tr><td><code id="pedplot_+3A_label">label</code></td>
<td>
<p>Character vector containing the columns of data frame <code>Pedig</code> to be used as labels.</p>
</td></tr>
<tr><td><code id="pedplot_+3A_...">...</code></td>
<td>
<p>Options passed to the underlying function <a href="kinship2.html#topic+plot.pedigree">plot.pedigree</a> from package <code>kinship2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a pedigree. If data frame <code>Pedig</code> has logical column <code>keep</code> then the default values mean that the symbols of these animals are plotted in color and for animals from other breeds the symbol is crossed out.
</p>


<h3>Value</h3>

<p>An invisible list returned by the underlying function <a href="kinship2.html#topic+plot.pedigree">plot.pedigree</a> from package <code>kinship2</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)

sPed  &lt;- subPed(PedigWithErrors, keep="276000810087543", prevGen=3, succGen=2)
pedplot(sPed, mar=c(2,4,2,4), label=c("Indiv", "Born", "Breed"), cex=0.4)
</code></pre>

<hr>
<h2 id='Phen'>Simulated Phenotypes of Hinterwald Cattle</h2><span id='topic+Phen'></span>

<h3>Description</h3>

<p>A data frame simulated breeding values of some Hinterwald cattle
with offspring born in 2006 or 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Phen)</code></pre>


<h3>Format</h3>

<p> A data frame with individual IDs (<code>Indiv</code>), sexes (<code>Sex</code>), breeding values (<code>BV</code>), and native contribution (<code>NC</code>).</p>

<hr>
<h2 id='plot.HaploFreq'>Plots Frequencies of Haplotype Segments in Specified Breeds</h2><span id='topic+plot.HaploFreq'></span>

<h3>Description</h3>

<p>For a particular haplotype from <code>thisBreed</code> and each marker <code>m</code> the frequency of the segment containing marker <code>m</code> in a specified reference breed is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HaploFreq'
plot(x, ID=1, hap=1, refBreed=NULL, Chr=NULL, show.maxFreq=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.HaploFreq_+3A_x">x</code></td>
<td>
<p>This is either an R-Object obtained with function <a href="#topic+haplofreq">haplofreq</a> or a list obtained with function <a href="#topic+freqlist">freqlist</a>. 
</p>
</td></tr>
<tr><td><code id="plot.HaploFreq_+3A_id">ID</code></td>
<td>
<p>Either the ID of the animal from this breed to be plotted, or the position of the animal in R-Object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.HaploFreq_+3A_hap">hap</code></td>
<td>
<p>Number of the haplotype to be plotted (<code>1</code> or <code>2</code>)</p>
</td></tr>
<tr><td><code id="plot.HaploFreq_+3A_refbreed">refBreed</code></td>
<td>
<p>Breed name. The frequencies  the haplotype segments have in this reference breed will be plotted. Parameter <code>refBreeds="others"</code> means that the maximum frequency will be plotted the segments have in other breeds.
</p>
</td></tr>
<tr><td><code id="plot.HaploFreq_+3A_chr">Chr</code></td>
<td>
<p>Vector with chromosomes to be plotted. The default means that all chromosomes will be plotted.</p>
</td></tr>
<tr><td><code id="plot.HaploFreq_+3A_show.maxfreq">show.maxFreq</code></td>
<td>
<p>If <code>show.maxFreq=TRUE</code> then a peak of the grey curve means that a haplotype segment exist in the breed which has high frequency in one of the reference breeds. This frequency is shown. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.HaploFreq_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a particular haplotype from <code>thisBreed</code> and each marker <code>m</code> from chromosomes <code>Chr</code> the frequency of the segment containing marker <code>m</code> in reference breed <code>refBreed</code> is plotted (red line), as well as the maximum frequency the segment has in one of the evaluated breeds (black line), and the maximum frequency a segment from <code>thisBreed</code> has in one of the evaluated breeds (grey area, if <code>show.maxFreq=TRUE</code>).
</p>


<h3>Value</h3>

<p>No return value, called for plotting.</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir   &lt;- system.file("extdata", package="optiSel")
files &lt;- paste(dir, "/Chr", 1:2, ".phased", sep="")

Freq &lt;- freqlist(
  haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Rotbunt",   minSNP=20),
  haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Holstein",  minSNP=20),
  haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Fleckvieh", minSNP=20)
  )

names(Freq)

plot(Freq, ID=1, hap=2, refBreed="Rotbunt")

Freq &lt;- haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="others",   minSNP=20)

plot(Freq, ID=1, hap=2)
plot(Freq, ID=1, hap=2, show.maxFreq=TRUE)

Freq &lt;- haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="Angler",   minSNP=20)
plot(Freq, ID=1, hap=2)

</code></pre>

<hr>
<h2 id='prePed'><b>Pre</b>pares a <b>Ped</b>igree 
</h2><span id='topic+prePed'></span>

<h3>Description</h3>

<p>Prepares a pedigree by sorting and adding founders and pruning the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prePed(Pedig, keep=NULL, thisBreed=NA, lastNative=NA, addNum=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prePed_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree where the first 3 columns correspond to: Individual ID,  Sire, and Dam. More columns can be passed in the <code>Pedig</code> argument including columns named <code>Sex</code>, <code>Breed</code> (with breed names), and <code>Born</code> (with years of birth or generation numbers). Missing parents are coded as NA, 0, or &quot;0&quot;.</p>
</td></tr>
<tr><td><code id="prePed_+3A_keep">keep</code></td>
<td>
<p>Vector with IDs of individuals, or <code>NULL</code>, or a logical vector indicating the individuals to be kept. If this parameter is not <code>NULL</code>, then only these individuals and their ancestors will be kept in the pedigree.</p>
</td></tr>
<tr><td><code id="prePed_+3A_thisbreed">thisBreed</code></td>
<td>
<p>Name of the breed.</p>
</td></tr>
<tr><td><code id="prePed_+3A_lastnative">lastNative</code></td>
<td>
<p>Last year of birth for which individuals with unknown pedigree are considered native.</p>
</td></tr>
<tr><td><code id="prePed_+3A_addnum">addNum</code></td>
<td>
<p>If <code>TRUE</code>, then columns with IDs of individuals, sires, and dams in integer form will be added.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a pedigree, adds missing founders, and sorts the pedigree. If parameter <code>keep</code> contains IDs of individuals then only these individuals and their ancestors will be kept in the pedigree.
</p>
<p>If the pedigree contains loops, then the loops will be broken by setting the parents of one animal in each loop to <code>NA</code>. 
</p>
<p>If the pedigree contains columnn <code>Sex</code> then the sexes will be recoded as  <code>'male'</code> and <code>'female'</code>. Missing sexes will be determined from pedigree structure if possible. 
</p>
<p>If the pedigree contains column <code>Breed</code> then for ancestors with missing breed the breed name is estimated. If parameter <code>lastNative</code> is not <code>NA</code> then for each animal with one missing parent an imaginary founder is added to the pedigree in order to enable classifying the breed names of all founders as follows: 
In general animals with missing breed are assumed to have the same breed as most of their offspring. But there is one exception: For founders belonging to <code>thisBreed</code> who are born after <code>lastNative</code> the breed name will be set to <code>"unknown"</code>. Moreover for founders from <code>thisBreed</code> with unknown year of birth the breed name will be set to <code>"unknown"</code> if all their descendants are born after <code>lastNative+I</code>. 
</p>


<h3>Value</h3>

<p>Data frame containing the pedigree with columns:
</p>
<table>
<tr><td><code>Indiv</code></td>
<td>
<p>Character column with IDs of the individuals</p>
</td></tr>
<tr><td><code>Sire</code></td>
<td>
<p>Character column with IDs of the sires</p>
</td></tr>
<tr><td><code>Dam</code></td>
<td>
<p>Character column with IDs of the dams</p>
</td></tr>
<tr><td><code>Sex</code></td>
<td>
<p>Character column with sexes of the individuals denoted as <code>"male"</code> and <code>"female"</code>.</p>
</td></tr>
<tr><td><code>Breed</code></td>
<td>
<p>Character column with adjusted breed names of the individuals (only if <code>Pedig</code> has column <code>Breed</code>.).</p>
</td></tr>
<tr><td><code>Born</code></td>
<td>
<p>Numeric column with Year-of-Birth of the individuals (only if <code>Pedig</code> has column <code>Born</code>.).</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>Numeric column with the average age of the parents when the respective individual was born (only if <code>Pedig</code> has column <code>Born</code>.).</p>
</td></tr>
<tr><td><code>numIndiv</code></td>
<td>
<p>Numeric IDs of the individuals, which are equal to the row numbers (only if <code>addNum=TRUE</code>). </p>
</td></tr>
<tr><td><code>numSire</code></td>
<td>
<p>Numeric IDs of the sires (only if <code>addNum=TRUE</code>).</p>
</td></tr>
<tr><td><code>numDam</code></td>
<td>
<p>Numeric IDs of the dams (only if <code>addNum=TRUE</code>).</p>
</td></tr>
<tr><td><code>Offspring</code></td>
<td>
<p>Logical column indicating the individuals with offspring.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
Pedig &lt;- prePed(PedigWithErrors)

tail(Pedig)
hist(Pedig$I, freq=FALSE, ylim=c(0,0.2))
</code></pre>

<hr>
<h2 id='read.indiv'>Reads Individual IDs from a Genotype File</h2><span id='topic+read.indiv'></span>

<h3>Description</h3>

<p>Reads individual IDs from a genotype file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.indiv(file, skip=NA, cskip=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.indiv_+3A_file">file</code></td>
<td>
<p>Name of the genotype file.</p>
</td></tr>
<tr><td><code id="read.indiv_+3A_skip">skip</code></td>
<td>
<p>Take line <code>skip+1</code> of the genotype files as the row with column names. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="read.indiv_+3A_cskip">cskip</code></td>
<td>
<p>Take column <code>cskip+1</code> of the genotype files as the first column with genotypes. By default, the number is determined automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reading individual IDs from phased marker files. 
</p>
<p><b>Marker file format</b>: Each marker file containing phased genotypes has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. The first <code>cskip</code> columns are ignored. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. The name of each file must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>.
</p>


<h3>Value</h3>

<p>Vector with the IDs of the individuals.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cattle)

dir   &lt;- system.file("extdata", package = "optiSel")
file  &lt;- file.path(dir, "Chr1.phased")
ID    &lt;- read.indiv(file)

identical(Cattle$Indiv, ID)
#[1] TRUE


</code></pre>

<hr>
<h2 id='sampleIndiv'>Sample Individuals from Pedigree</h2><span id='topic+sampleIndiv'></span>

<h3>Description</h3>

<p>Sampling Individuals from a Pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleIndiv(Pedig, from="Born", each=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleIndiv_+3A_pedig">Pedig</code></td>
<td>
<p>Pedigree with column <code>Indiv</code> and the column specified in parameter <code>from</code>.</p>
</td></tr>
<tr><td><code id="sampleIndiv_+3A_from">from</code></td>
<td>
<p>Column name. From each cohort specified in this column (e.g. year of birth), the number of individuals specified in parameter <code>each</code> is sampled. If a cohort contains less individuals, then all individuals are chosen.</p>
</td></tr>
<tr><td><code id="sampleIndiv_+3A_each">each</code></td>
<td>
<p>Number of individuals to be sampled from each cohort.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From each cohort, a specified number of individuals will be sampled. If a cohort contains less individuals, then all individuals are sampled.
This may be needed for estimating population specific parameters from a subset of a large pedigree to reduce computation time.
</p>


<h3>Value</h3>

<p>Character vector containing the IDs of the individuals.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("PedigWithErrors")
set.seed(1)
Pedig &lt;- prePed(PedigWithErrors)
use   &lt;- Pedig$Breed=="Hinterwaelder"
keep  &lt;- sampleIndiv(Pedig[use, ], from="Born", each=5)
keep
</code></pre>

<hr>
<h2 id='segBreedComp'>
Calculates the Segment-Based Breed Composition of Individuals
</h2><span id='topic+segBreedComp'></span>

<h3>Description</h3>

<p>Calculates the <b>seg</b>ment based <b>Breed</b> <b>Comp</b>osition: 
For every individual the breed composition is estimated, including the genetic contribution from native ancestors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segBreedComp(Native, map, unitP="Mb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segBreedComp_+3A_native">Native</code></td>
<td>
<p>This parameter is either
</p>
<p>(1) Mx(2N) logical matrix, with <code>TRUE</code>, if the segment containing the SNP is considered native, and <code>FALSE</code> otherwise. The row names are the marker names, and the non-unique column names are the IDs of the individuals. The matrix is typically computed from component <code>freq</code> of the output from function <a href="#topic+haplofreq">haplofreq</a>.
</p>
<p>or
</p>
<p>(2) Mx(2N) character matrix, with components being the first characters of the names of the breeds in which the respective segment has maximum frequency. Segments considered native are coded as <code>'1'</code>. The row names are the marker names, and the non-unique column names are the IDs of the individuals. The matrix is typically component <code>match</code> from the output of function <a href="#topic+haplofreq">haplofreq</a>.
</p>
<p>or
</p>
<p>(3)  Vector with file names. The files contain for every SNP and for each haplotype 1 if the segment containing the SNP is considered native. Otherwise it is the first letter of the name of the breed in which the segment has maximum frequency. These files are typically created by function <a href="#topic+haplofreq">haplofreq</a>.
There is one file per chromosome and file names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.nat"</code>.
</p>
</td></tr>
<tr><td><code id="segBreedComp_+3A_map">map</code></td>
<td>

<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in Mega base pairs <code>'Mb'</code>, and the position in centimorgan <code>'cM'</code>. The markers must be in the same order as in  in <code>Native</code>.
</p>
</td></tr>
<tr><td><code id="segBreedComp_+3A_unitp">unitP</code></td>
<td>
<p>The unit for measuring the proportion of the genome included in native segments.
Possible units are the number of marker SNPs included in shared segments (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the total length of the shared segments in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every individual the breed composition is computed, including the genetic contribution from native ancestors (native contribution). The native contribution is the proportion of the genome belonging to segments whose frequency is smaller than a predefined value in all other breeds. 
</p>
<p>Additionally, for each introgressed breed,
the proportion of the genome of each individual is computed that is non-native and has maximum frequency in the respective breed (not if option (1) is used).
</p>


<h3>Value</h3>

<p>Data frame with the number of rows being the number of individuals. The columns are
</p>
<table>
<tr><td><code>Indiv</code></td>
<td>
<p>IDs of the individuals,</p>
</td></tr>
<tr><td><code>native</code></td>
<td>
<p>Genetic contributions from native ancestors,</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Contributions from other breeds.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir     &lt;- system.file("extdata", package = "optiSel")
GTfiles &lt;- file.path(dir, paste("Chr", unique(map$Chr), ".phased", sep=""))
Haplo   &lt;- haplofreq(GTfiles, Cattle, map, thisBreed="Angler", minSNP=20, minL=1.0)
Comp    &lt;- segBreedComp(Haplo$freq&lt;0.01, map)
mean(Comp$native)
#[1] 0.3853432

Comp &lt;- segBreedComp(Haplo$match, map)
apply(Comp[, -1], 2, mean)

## Reading native segments from files:

wdir &lt;- file.path(tempdir(), "HaplotypeEval")
file &lt;- haplofreq(GTfiles, Cattle, map, thisBreed="Angler", minSNP=20, 
           minL=1.0, ubFreq=0.01, what="match", w.dir=wdir)
Comp &lt;- segBreedComp(file$match, map)
head(Comp)

apply(Comp[, -1], 2, mean)
#    native          F          H          R 
#0.38534317 0.05503451 0.25986508 0.29975724 

#unlink(wdir, recursive = TRUE)

</code></pre>

<hr>
<h2 id='segIBD'>Calculates the Segment Based Kinship Matrix</h2><span id='topic+segIBD'></span>

<h3>Description</h3>

<p><b>Seg</b>ment based probability of alleles to be <b>IBD</b> (identical by descent): For each pair of individuals the probability is computed that two alleles taken at random position from randomly chosen haplotypes belong to a shared segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segIBD(files, map, minSNP=20, minL=1.0, unitP="Mb", unitL="Mb", 
   a=0.0, keep=NULL, skip=NA, cskip=NA, cores=1, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segIBD_+3A_files">files</code></td>
<td>
<p>This parameter is either
</p>
<p>(1) A vector with names of phased marker files, one file for each chromosome,
</p>
<p>or
</p>
<p>(2) A list with two components. Each component is a vector with names of phased marker files, one file for each chromosome. Each components corresponds to a different set of individuals. This enables to compute the kinship between individuals stored in two different files.
</p>
<p>File names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>. The required format of the marker files is described under <code>Details</code>.
</p>
</td></tr>
<tr><td><code id="segIBD_+3A_map">map</code></td>
<td>
<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in mega base pairs <code>'Mb'</code>, and the position in centimorgan <code>'cM'</code>. (The position in base pairs could result in an integer overflow.) The order of the markers must be the same as in the files.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_minsnp">minSNP</code></td>
<td>
<p>Minimum number of marker SNPs included in a segment.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_minl">minL</code></td>
<td>
<p>Minimum length of a segment in <code>unitL</code> (e.g. in cM or Mb).</p>
</td></tr>
<tr><td><code id="segIBD_+3A_unitp">unitP</code></td>
<td>
<p>The unit for measuring the proportion of the genome included in shared segments.
Possible units are the number of marker SNPs included in shared segments (<code>'SNP'</code>), the number of mega base pairs (<code>'Mb'</code>), and the total length of the shared segments in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.
</p>
</td></tr>
<tr><td><code id="segIBD_+3A_unitl">unitL</code></td>
<td>
<p>The unit for measuring the length of a segment. Possible units are the number of marker SNPs included in the segment (<code>'SNP'</code>), the number of mega base pairs (<code>'Mb'</code>), and the genetic  distances between the first and the last marker in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_a">a</code></td>
<td>
<p>The Function providing the weighting factor for each segment is w(x)=x*x/(a+x*x). The parameter of the function is the length of the segment in <code>unitL</code>. The default value <code>a=0.0</code> implies no weighting, whereas <code>a&gt;0.0</code> implies that old inbreeding has less influence on the result than new inbreeding.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_keep">keep</code></td>
<td>
<p>If <code>keep</code> is a vector containing IDs of individuals then kinships will be computed only for these individuals. The default <code>keep=NULL</code> means that kinship will be computed for all individuals included in the files.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_skip">skip</code></td>
<td>
<p>Take line <code>skip+1</code> of the files as the row with column names. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_cskip">cskip</code></td>
<td>
<p>Take column <code>cskip+1</code> of the files as the first column with genotypes. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used for parallel processing of chromosomes. By default one core is used. For <code>cores=NA</code> the number of cores will be chosen automatically. Using more than one core increases execution time if the function is already fast.</p>
</td></tr>
<tr><td><code id="segIBD_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of individuals the probability is computed that two SNPs taken at random position from randomly chosen haplotypes belong to a shared segment.
</p>
<p><b>Genotype file format</b>: Each file containing phased genotypes has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. The first <code>cskip</code> columns are ignored. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. 
</p>


<h3>Value</h3>

<p><code>NxN</code> segment-based kinship matrix with <code>N</code> being the number of individuals.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>References</h3>

<p>de Cara MAR, Villanueva B, Toro MA, Fernandez J (2013). Using genomic tools to maintain diversity and fitness in conservation programmes. Molecular Ecology. 22: 6091-6099
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
dir   &lt;- system.file("extdata", package = "optiSel")
files &lt;- file.path(dir, paste("Chr", unique(map$Chr), ".phased", sep=""))
f     &lt;- segIBD(files, map, minSNP=15, minL=1.0)
mean(f)
#[1] 0.05677993


f     &lt;- segIBD(files, map, minSNP=15, minL=1.0, cores=NA)
mean(f)
#[1] 0.05677993



## Multidimensional scaling of animals:
## (note that only few markers are used)

data(Cattle)
library("smacof")
D     &lt;- sim2dis(f, 4)
color &lt;- c(Angler="red", Rotbunt="green", Fleckvieh="blue", Holstein="black")
col   &lt;- color[as.character(Cattle$Breed)]
Res   &lt;- smacofSym(D, itmax = 5000, eps = 1e-08)
plot(Res$conf, pch=18, col=col, main="Multidimensional Scaling", cex=0.5)
mtext(paste("segIBD Stress1 = ", round(Res$stress,3)))

</code></pre>

<hr>
<h2 id='segIBDandN'>Calculates Probabilities that Alleles belong to a Shared Native Segment</h2><span id='topic+segIBDandN'></span>

<h3>Description</h3>

<p>Calculates the <b>seg</b>ment based probability of alleles to be <b>IBD</b> (identical by descent) <b>and</b> <b>N</b>ative: 
For each pair of individuals the probability is computed that two SNPs taken at random position from randomly chosen haplotypes belong to a shared segment and are native.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segIBDandN(files, Native, map, minSNP=20, unitP="Mb", minL=1.0, 
   unitL="Mb", a=0.0, keep=NULL, skip=NA, cskip=NA, cores=1, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segIBDandN_+3A_files">files</code></td>
<td>
<p>Vector with names of the phased marker files, one file for each chromosome. The required format is described under <code>Details</code>. File names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>.
</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_native">Native</code></td>
<td>
<p>This parameter is either
</p>
<p>(1) Mx(2N) indicator matrix, with 1, if the segment containing the SNP is considered native, and 0 otherwise. The row names are the marker names, and the non-unique column names are the IDs of the individuals. The matrix is typically computed from the output of function <a href="#topic+haplofreq">haplofreq</a>.
</p>
<p>or
</p>
<p>(2)  Vector with file names. The files contain for every SNP and for each haplotype from this breed 1 if the segment containing the SNP is considered native. These files are typically created by function <a href="#topic+haplofreq">haplofreq</a>.
There is one file per chromosome and file names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.nat"</code>.
</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_map">map</code></td>
<td>

<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in mega base pairs <code>'Mb'</code>, and the position in centimorgan <code>'cM'</code>. The markers must be in the same order as in <code>files</code> and in <code>Native</code>.
</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_minsnp">minSNP</code></td>
<td>
<p>Minimum number of marker SNPs included in a segment.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_unitp">unitP</code></td>
<td>
<p>The unit for measuring the proportion of the genome included in shared segments.
Possible units are the number of marker SNPs included in shared segments (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the total length of the shared segments in centiMorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.
</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_minl">minL</code></td>
<td>
<p>Minimum length of a segment in <code>unitL</code> (e.g. in cM or Mb).</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_unitl">unitL</code></td>
<td>
<p>The unit for measuring the length of a segment. Possible units are the number of marker SNPs included in the segment (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the genetic  distances between the first and the last marker in centiMorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_a">a</code></td>
<td>
<p>The Function providing the weighting factor for each segment is w(x)=x*x/(a+x*x). The parameter of the function is the length of the segment in <code>unitL</code>. The default value <code>a=0.0</code> implies no weighting, whereas <code>a&gt;0.0</code> implies that old inbreeding has less influence on the result than new inbreeding.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_keep">keep</code></td>
<td>
<p>Vector with IDs of individuals (from this breed) for which the probabilities are to be computed. By default, they will be computed for all individuals included in <code>Native</code>.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_skip">skip</code></td>
<td>
<p>Take line <code>skip+1</code> of the genotype files as the line with column names. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_cskip">cskip</code></td>
<td>
<p>Take column <code>cskip+1</code> of the genotype files as the first column with genotypes. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used for parallel processing of chromosomes. By default one core is used. For <code>cores=NA</code> the number of cores will be chosen automatically. Using more than one core increases execution time if the function is already fast.</p>
</td></tr>
<tr><td><code id="segIBDandN_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of individuals the probability is computed that two SNPs taken at random position from randomly chosen haplotypes belong to a shared segment and are native. That is, they are not introgressed from other breeds.
</p>
<p><b>Genotype file format</b>: Each file containing phased genotypes has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. The first <code>cskip</code> columns are ignored. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. The name of each file must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>.
</p>


<h3>Value</h3>

<p><code>NxN</code> matrix with <code>N</code> being the number of individuals from this breed included in all files (and in parameter <code>keep</code>).
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir    &lt;- system.file("extdata", package = "optiSel")
GTfile &lt;- file.path(dir, paste("Chr", unique(map$Chr), ".phased", sep=""))
Freq   &lt;- haplofreq(GTfile, Cattle, map, thisBreed="Angler", refBreeds="others", minSNP=20)$freq

fIBDN  &lt;- segIBDandN(GTfile, Freq&lt;0.01, map=map, minSNP=20)
mean(fIBDN)
#[1] 0.01032261


fIBDN  &lt;- segIBDandN(GTfile, Freq&lt;0.01, map=map, minSNP=20, cores=NA)
mean(fIBDN)
#[1] 0.01032261


## using files:

wdir   &lt;- file.path(tempdir(),"HaplotypeEval")
chr    &lt;- unique(map$Chr)
GTfile &lt;- file.path( dir, paste("Chr", chr, ".phased",     sep=""))
file   &lt;- haplofreq(GTfile, Cattle, map, thisBreed="Angler", minSNP=20, ubFreq=0.01, w.dir=wdir)

fIBDN  &lt;- segIBDandN(GTfile, file$match, map=map, minSNP=20)
mean(fIBDN)
#[1] 0.01032261

fIBDN  &lt;- segIBDandN(GTfile, file$match, map=map, minSNP=20, cores=NA)
mean(fIBDN)
#[1] 0.01032261


#unlink(wdir, recursive = TRUE)


</code></pre>

<hr>
<h2 id='segIBDatN'>Segment-Based Kinship at Native Alleles.</h2><span id='topic+segIBDatN'></span>

<h3>Description</h3>

<p>Calculates the kinship at native alleles, which is the segment based probability of native alleles to be IBD.</p>


<h3>Usage</h3>

<pre><code class='language-R'>segIBDatN(files, phen, map, thisBreed, refBreeds="others", ubFreq=0.01, minSNP=20,
  unitP="Mb", minL=1.0, unitL="Mb", a=0.0, keep=NULL, lowMem=TRUE, 
  skip=NA, cskip=NA, cores=1, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segIBDatN_+3A_files">files</code></td>
<td>
<p>This can be a character vector with names of the phased marker files, one file for each chromosome. 
Alternatively <code>files</code> can be a list with the following components:
</p>
<p>a) <code>hap.thisBreed</code>: A character vector with names of the phased marker files for the individuals from <code>thisBreed</code>, one file for each chromosome.
</p>
<p>b) <code>hap.refBreeds</code>: A character vector with names of the phased marker files for the individuals from the reference breeds (<code>refBreeds</code>), one file for each chromosome. If this component is missing, then it is assumed that the haplotypes of these animals are also included in <code>hap.thisBreed</code>.
</p>
<p>c) <code>match</code>: If present, a character vector with file names containing the origin of the marker alleles. The files are typically created with function <code>haplofreq</code>. If this vector is missing, then the default method is used to estimate the origins. 
</p>
<p>File names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>. The required format of the marker files is described under <code>Details</code>.
</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_phen">phen</code></td>
<td>
<p>Data frame containing the ID (column <code>"Indiv"</code>),  breed name (column <code>"Breed"</code>), and sex (column <code>Sex</code>) of each individual.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_map">map</code></td>
<td>
<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in Mega base pairs <code>'Mb'</code>, and the position in centimorgan <code>'cM'</code>. (The position in base pairs could result in an integer overflow). The order of the markers must bethe same as in the files.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_thisbreed">thisBreed</code></td>
<td>
<p>Breed name: Results will be computed for individuals from <code>thisBreed</code>.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_refbreeds">refBreeds</code></td>
<td>
<p>Vector containing names of genotyped breeds. A segment is considered native if its frequency is smaller than <code>ubFreq</code>  in all <code>refBreeds</code>. The default <code>"others"</code> means that all genotyped breeds except <code>thisBreed</code> are considered.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_ubfreq">ubFreq</code></td>
<td>
<p>A segment is considered native if its frequency is smaller than <code>ubFreq</code> in all reference breeds.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_minsnp">minSNP</code></td>
<td>
<p>Minimum number of marker SNPs included in a segment.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_unitp">unitP</code></td>
<td>
<p>The unit for measuring the proportion of the genome included in native segments.
Possible units are the number of marker SNPs included in shared segments (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the total length of the shared segments in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_minl">minL</code></td>
<td>
<p>Minimum length of a segment in <code>unitL</code> (e.g. in cM).</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_unitl">unitL</code></td>
<td>
<p>The unit for measuring the length of a segment. Possible units are the number of marker SNPs included in the segment (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the genetic  distances between the first and the last marker in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_a">a</code></td>
<td>
<p>The function providing the weighting factor for each segment is w(x)=x*x/(a+x*x). The parameter of the function is the length of the segment in <code>unitL</code>. The default value <code>a=0.0</code> implies no weighting, whereas <code>a&gt;0.0</code> implies that old inbreeding has less influence on the result than new inbreeding.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_keep">keep</code></td>
<td>

<p>Subset of the IDs of the individuals from data frame <code>phen</code> (including individuals from other breeds) or a logical vector indicating the animals in data frame <code>phen</code> that should be used. By default all individuals included in <code>phen</code> will be used.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_lowmem">lowMem</code></td>
<td>
<p>If <code>lowMem=TRUE</code> then temporary files will be created and deleted.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_skip">skip</code></td>
<td>
<p>Take line <code>skip+1</code> of the genotype files as the row with column names. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_cskip">cskip</code></td>
<td>
<p>Take column <code>cskip+1</code> of the genotype files as the first column with genotypes. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used for parallel processing of chromosomes. By default one core is used. For <code>cores=NA</code> the number of cores will be chosen automatically. Using more than one core increases execution time if the function is already fast.</p>
</td></tr>
<tr><td><code id="segIBDatN_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a list containing matrices needed to compute segment based kinships at native alleles, defined as the conditional probability that two randomly chosen alleles are IBD, given that both originate from native ancestors. An allele is considered to originate from a native ancesor if the segment containing the allele has low frequency in all reference breeds.
</p>
<p>The kinship at native alleles between individuals i and j is <code>Q1[i,j]/Q2[i,j]</code>.
</p>
<p>The mean kinship at native alleles in the offspring is <code>(x'Q1x+d1)/(x'Q2x+d2)</code>, where <code>x</code> is the vector with genetic contributions of the selection candidates.
</p>
<p><b>Genotype file format</b>: Each file containing phased genotypes has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. The first <code>cskip</code> columns are ignored. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. The name of each file must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>ratioFun</code> including components:
</p>
<table>
<tr><td><code>Q1</code></td>
<td>
<p>matrix with <code>Q1[i,j]</code>  = Probability that two alleles chosen from individuals i and j are IBD and are native.</p>
</td></tr>
<tr><td><code>Q2</code></td>
<td>
<p>matrix with <code>Q2[i,j]</code> = Probability that two alleles chosen from individuals i and j are both native.</p>
</td></tr>
<tr><td><code>d1</code></td>
<td>
<p>The value by which the probability that two alleles chosen from the offspring are IBD and native increases due to genetic drift.</p>
</td></tr>
<tr><td><code>d2</code></td>
<td>
<p>The value by which the probability that two alleles chosen from the offspring are native increases due to genetic drift.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>IDs of the individuals for which the probabilites have been computed.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean kinship at native alleles of the specified individuals. Note that <code>1-mean</code> is the genetic diversity at native segments of the specified individuals from <code>thisBreed</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir     &lt;- system.file("extdata", package = "optiSel")
files   &lt;- paste(dir, "/Chr", 1:2, ".phased", sep="")
sKinatN &lt;- segIBDatN(files, Cattle, map, thisBreed="Angler", 
                   ubFreq=0.01, minL=1.0, lowMem=FALSE)
               
## Mean kinship at native segments:
sKinatN$mean
#[1] 0.06695171

## Note that this can not be computed as mean(sKinatN$of).


## Results for individuals:
sKinatN$of &lt;- sKinatN$Q1/sKinatN$Q2
sKinatN$of["Angler1","Angler5"]
#[1] 0.4394066

## Use temporary files to reduce working memory:

sKinatN &lt;- segIBDatN(files, Cattle, map, thisBreed="Angler", ubFreq=0.01,  minL=1.0)
               
## Mean kinship at native segments:
sKinatN$mean
#[1] 0.06695171


</code></pre>

<hr>
<h2 id='segInbreeding'>Calculates Segment Based Inbreeding</h2><span id='topic+segInbreeding'></span>

<h3>Description</h3>

<p><b>Seg</b>ment based <b>Inbreeding</b>: For each individual the probability is computed that the paternal allele and the maternal allele, sampled from random position, belong to a shared segment (i.e. a run of homozygosity, ROH). The arguments are the same as for function <a href="#topic+segIBD">segIBD</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segInbreeding(files, map, minSNP=20, minL=1.0, unitP="Mb", unitL="Mb", 
   a=0.0, keep=NULL, skip=NA, cskip=NA, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segInbreeding_+3A_files">files</code></td>
<td>
<p>This parameter is either
</p>
<p>(1) A vector with names of phased marker files, one file for each chromosome,
</p>
<p>or
</p>
<p>(2) A list with two components. Each component is a vector with names of phased marker files, one file for each chromosome. Each components corresponds to a different set of individuals. 
</p>
<p>File names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.phased"</code>. The required format of the marker files is described under <code>Details</code>.
</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_map">map</code></td>
<td>
<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in Mega base pairs <code>'Mb'</code>, and the position in centimorgan <code>'cM'</code>. (The position in base pairs could result in an integer overflow.) The order of the markers must be the same as in the files.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_minsnp">minSNP</code></td>
<td>
<p>Minimum number of marker SNPs included in a segment.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_minl">minL</code></td>
<td>
<p>Minimum length of a segment in <code>unitL</code> (e.g. in cM or Mb).</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_unitp">unitP</code></td>
<td>
<p>The unit for measuring the proportion of the genome included in shared segments.
Possible units are the number of marker SNPs included in shared segments (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the total length of the shared segments in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.
</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_unitl">unitL</code></td>
<td>
<p>The unit for measuring the length of a segment. Possible units are the number of marker SNPs included in the segment (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the genetic  distances between the first and the last marker in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_a">a</code></td>
<td>
<p>The Function providing the weighting factor for each segment is w(x)=x*x/(a+x*x). The parameter of the function is the length of the segment in <code>unitL</code>. The default value <code>a=0.0</code> implies no weighting, whereas <code>a&gt;0.0</code> implies that old inbreeding has less influence on the result than new inbreeding.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_keep">keep</code></td>
<td>
<p>If <code>keep</code> is a vector containing IDs of individuals then inbreeding will be computed only for these individuals. The default <code>keep=NULL</code> means that inbreeding will be computed for all individuals included in the files.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_skip">skip</code></td>
<td>
<p>Take line <code>skip+1</code> of the files as the row with column names. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_cskip">cskip</code></td>
<td>
<p>Take column <code>cskip+1</code> of the files as the first column with genotypes. By default, the number is determined automatically.</p>
</td></tr>
<tr><td><code id="segInbreeding_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of individuals the probability is computed that two SNPs taken at random position from randomly chosen haplotypes belong to a shared segment.
</p>
<p><b>Genotype file format</b>: Each file containing phased genotypes has a header and no row names. Cells are separated by blank spaces. The number of rows is equal to the number of markers from the respective chromosome and the markers are in the same order as in the <code>map</code>. The first <code>cskip</code> columns are ignored. The remaining columns contain genotypes of individuals written as two alleles separated by a character, e.g. A/B, 0/1, A|B, A B, or 0 1. The same two symbols must be used for all markers. Column names are the IDs of the individuals. If the blank space is used as separator then the ID of each individual should repeated in the header to get a regular delimited file. The columns to be skipped and the individual IDs must have no white spaces. 
</p>


<h3>Value</h3>

<p>A data frame with column <code>Indiv</code> containing the individual IDs and column <code>Inbr</code> containing the inbreeding coefficients.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>References</h3>

<p>de Cara MAR, Villanueva B, Toro MA, Fernandez J (2013). Using genomic tools to maintain diversity and fitness in conservation programmes. Molecular Ecology. 22: 6091-6099
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir   &lt;- system.file("extdata", package = "optiSel")
files &lt;- file.path(dir, paste("Chr", 1:2, ".phased", sep=""))
f     &lt;- segInbreeding(files, map, minSNP=20, minL=2.0)

Cattle2 &lt;- merge(Cattle, f, by="Indiv")
tapply(Cattle2$Inbr, Cattle2$Breed, mean)
#    Angler  Fleckvieh   Holstein    Rotbunt 
#0.03842552 0.05169508 0.12431393 0.08386849 

boxplot(Inbr~Breed, data=Cattle2, ylim=c(0,1), main="Segment Based Inbreeding")

fIBD  &lt;- segIBD(files, map, minSNP=20, minL=2.0)
identical(rownames(fIBD), f$Indiv)
#[1] TRUE

range(2*diag(fIBD)-1-f$Inbr)
#[1] -2.220446e-16  2.220446e-16
</code></pre>

<hr>
<h2 id='segN'>Calculates Probabilities of Alleles to belong to Native Segments</h2><span id='topic+segN'></span>

<h3>Description</h3>

<p><b>Seg</b>ment based probability of alleles to be <b>N</b>ative:
For each pair of individuals the probability is computed that two SNPs taken at random position from randomly chosen haplotypes both belong to native segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segN(Native, map, unitP="Mb", keep=NULL, cores=1, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segN_+3A_native">Native</code></td>
<td>
<p>This parameter is either
</p>
<p>(1) Mx(2N) indicator matrix, with 1, if the segment containing the SNP is considered native, and 0 otherwise. The row names are the marker names, and the non-unique column names are the IDs of the individuals. The matrix is typically computed from the output of function <a href="#topic+haplofreq">haplofreq</a>.
</p>
<p>or
</p>
<p>(2)  Vector with file names. The files contain for every SNP and for each haplotype from this breed 1 if the segment containing the SNP is considered native. These files are typically created by function <a href="#topic+haplofreq">haplofreq</a>.
There is one file per chromosome and file names must contain the chromosome name as specified in the <code>map</code> in the form <code>"ChrNAME."</code>, e.g. <code>"Breed2.Chr1.nat"</code>.
</p>
</td></tr>
<tr><td><code id="segN_+3A_map">map</code></td>
<td>

<p>Data frame providing the marker map with columns including marker name <code>'Name'</code>, chromosome number <code>'Chr'</code>, and possibly the position on the chromosome in Mega base pairs <code>'Mb'</code>, and the position in centiMorgan <code>'cM'</code>. The markers must be in the same order as in <code>Native</code>.
</p>
</td></tr>
<tr><td><code id="segN_+3A_unitp">unitP</code></td>
<td>
<p>The unit for measuring the proportion of the genome included in native segments.
Possible units are the number of marker SNPs included in shared segments (<code>'SNP'</code>), the number of Mega base pairs (<code>'Mb'</code>), and the total length of the shared segments in centimorgan (<code>'cM'</code>). In the last two cases the map must include columns with the respective names.</p>
</td></tr>
<tr><td><code id="segN_+3A_keep">keep</code></td>
<td>
<p>Vector with IDs of individuals (from this breed) for which the probabilities are to be computed. By default, they will be computed for all individuals included in <code>Native</code>.</p>
</td></tr>
<tr><td><code id="segN_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used for parallel processing of chromosomes. By default one core is used. For <code>cores=NA</code> the number of cores will be chosen automatically. Using more than one core increases execution time if the function is already fast.</p>
</td></tr>
<tr><td><code id="segN_+3A_quiet">quiet</code></td>
<td>
<p>Should console output be suppressed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of individuals the probability is computed that two SNPs taken at random position from randomly chosen haplotypes both belong to native segments. That is, they are not introgressed from other breeds.
</p>


<h3>Value</h3>

<p><code>NxN</code> matrix with <code>N</code> being the number of genotyped individuals from this breed (which are also included in vector <code>keep</code>).
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
data(Cattle)
dir   &lt;- system.file("extdata", package = "optiSel")
files &lt;- file.path(dir, paste("Chr", unique(map$Chr), ".phased", sep=""))
Freq  &lt;- haplofreq(files, Cattle, map, thisBreed="Angler", refBreeds="others", minSNP=20)$freq
fN   &lt;- segN(Freq&lt;0.01, map)
mean(fN)
#[1] 0.15418


fN   &lt;- segN(Freq&lt;0.01, map, cores=NA)
mean(fN)
#[1] 0.15418



## using files:

wdir   &lt;- file.path(tempdir(),"HaplotypeEval")
chr    &lt;- unique(map$Chr)
GTfile &lt;- file.path( dir, paste("Chr", chr, ".phased",     sep=""))
files  &lt;- haplofreq(GTfile, Cattle, map, thisBreed="Angler", w.dir=wdir)

fN     &lt;- segN(files$match, map)
mean(fN)
#[1] 0.15418

fN     &lt;- segN(files$match, map, cores=NA)
mean(fN)
#[1] 0.15418

#unlink(wdir, recursive = TRUE)



</code></pre>

<hr>
<h2 id='sim2dis'>Converts a Similarity Matrix into a Dissimilarity Matrix</h2><span id='topic+sim2dis'></span>

<h3>Description</h3>

<p>Converts a similarity matrix (e.g. a kinship matrix) into a dissimilarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim2dis(f, a=4.0, baseF=0.03, method=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim2dis_+3A_f">f</code></td>
<td>
<p>Similarity matrix.</p>
</td></tr>
<tr><td><code id="sim2dis_+3A_a">a</code></td>
<td>
<p>Exponent</p>
</td></tr>
<tr><td><code id="sim2dis_+3A_basef">baseF</code></td>
<td>
<p>Old inbreeding not measured by <code>f</code></p>
</td></tr>
<tr><td><code id="sim2dis_+3A_method">method</code></td>
<td>
<p>Either <code>1</code> or <code>2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a similarity matrix <code>f</code> with values between 0 and 1 (e.g. a kinship matrix) into a dissimilarity matrix.
At first, the similarity is adjusted as
</p>
<p><code>f &lt;- baseF + (1-baseF)*f</code>.
</p>
<p>Then, for Method 1, the dissimilarity between individuals <code>i</code> and <code>j</code> is computed as
</p>
<p><code>Dij = (-log(fij))^a</code>,
</p>
<p>whereas for Method 2, the dissimilarity is computed as
</p>
<p><code>Dij = sqrt((fii+fjj)/2-fij)^a</code>.
</p>
<p>Although Method 2 may provide lower stress values in some cases, Method 1 has the advantage that the area reflects the diversity of a population more reasonable.
</p>


<h3>Value</h3>

<p>Dissimilarity matrix D.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(map)
dir   &lt;- system.file("extdata", package = "optiSel")
files &lt;- file.path(dir, paste("Chr", unique(map$Chr), ".phased", sep=""))
f     &lt;- segIBD(files, map, minSNP=15, minL=1.0)
D     &lt;- sim2dis(f, 4)

## Multidimensional scaling of animals:

data(Cattle)
library("smacof")
color &lt;- c(Angler="red", Rotbunt="green", Fleckvieh="blue", Holstein="black")
col   &lt;- color[as.character(Cattle$Breed)]
Res   &lt;- smacofSym(D, itmax = 5000, eps = 1e-08)
plot(Res$conf, pch=18, col=col, main="Multidimensional Scaling", cex=0.5)
mtext(paste("segIBD Stress1 = ", round(Res$stress,3)))



</code></pre>

<hr>
<h2 id='subPed'>Creates a Subset of a Large Pedigree</h2><span id='topic+subPed'></span>

<h3>Description</h3>

<p>Creates a subset of a large pedigree that includes only individuals related with specified individuals in a predefined way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subPed(Pedig, keep, prevGen=3, succGen=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subPed_+3A_pedig">Pedig</code></td>
<td>
<p>Data frame containing the pedigree where the first 3 columns correspond to: Individual ID,  Sire, and Dam. More columns can be passed in the <code>Pedig</code> argument including columns named <code>Sex</code>, <code>Breed</code> (with breed names), and <code>Born</code> (with years of birth). Missing parents are coded as NA, 0, or &quot;0&quot;.</p>
</td></tr>
<tr><td><code id="subPed_+3A_keep">keep</code></td>
<td>
<p>Vector with IDs of individuals. Only these individuals and individuals related with them in a predefined way will be kept in the pedigree.</p>
</td></tr>
<tr><td><code id="subPed_+3A_prevgen">prevGen</code></td>
<td>
<p>Number of previous (ancestral) generations to be included in the pedigree.</p>
</td></tr>
<tr><td><code id="subPed_+3A_succgen">succGen</code></td>
<td>
<p>Number of succeeding (descendant) generations to be included in the pedigree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a subset of a large pedigree that includes only individuals related with the individuals specified in the vector <code>keep</code> in a predefined way.
</p>


<h3>Value</h3>

<p>A data frame containing the reduced pedigree. A column <code>keep</code> is appended indicating which individuals were included in parameter <code>keep</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(PedigWithErrors)

sPed &lt;- subPed(PedigWithErrors, keep="276000891974272", prevGen=3, succGen=2)
sPed

label &lt;- c("Indiv", "Born", "Breed")
pedplot(sPed, mar=c(2,4,2,4), label=label, cex=0.7)

</code></pre>

<hr>
<h2 id='summary.candes'>Population Genetic Parameters at Different Times</h2><span id='topic+summary.candes'></span>

<h3>Description</h3>

<p>For every time point (age cohort), several population genetic parameters are estimated. These may include the generation interval, the average kinship, the average native kinship, the native effective size (native Ne), and the native genome equivalent (NGE) of the population at that point in time. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'candes'
summary(object, tlim=range(object$phen$Born, na.rm=TRUE), 
     histNe=NA, base=tlim[1], df=4, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.candes_+3A_object">object</code></td>
<td>
<p>R-Object created with function <a href="#topic+candes">candes</a> containing phenotypes and kinship information on individuals from the same breed. Data frame <code>cand$phen</code> has columns <code>Indiv</code> (with IDs of the individuals),  <code>Born</code> (with the years-of-birth or generation-numbers), <code>Sex</code>, <code>I</code> (average age of the parents at date of birth), and <code>Offspring</code> (indicating if the individual has offspring). Typically function <code>prePed</code> is used to create them. For computing the native Ne the individuals must be from different age cohorts.</p>
</td></tr>
<tr><td><code id="summary.candes_+3A_tlim">tlim</code></td>
<td>
<p>Numeric vector with 2 components giving the time span for which genetic parameters are to be computed.</p>
</td></tr>
<tr><td><code id="summary.candes_+3A_histne">histNe</code></td>
<td>
<p>The historic effective size of the population assumed for the time between year <code>base</code> and <code>tlim[1]</code>, which affects the NGE.</p>
</td></tr>
<tr><td><code id="summary.candes_+3A_base">base</code></td>
<td>
<p>The base year in which individuals are assumed to be unrelated. The base year affects the NGE. The default is <code>tlim[1]</code>.</p>
</td></tr> 
<tr><td><code id="summary.candes_+3A_df">df</code></td>
<td>
<p>Smoothing parameter used for computing the native effective size. The default is <code>df=4</code>.</p>
</td></tr>
<tr><td><code id="summary.candes_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every time point (age cohort), several population genetic parameters are estimated. These may include the generation interval, the average kinship, the average native kinship, the native effective size (native Ne), and the native genome equivalent (NGE) of the population at that point in time. The population at a time t consists of all individuals born between t-I and t, where I is the generation interval. The population genetic parameters are described below. 
</p>


<h3>Value</h3>

<p>A data frame providing for each time point (age cohort) several population genetic parameters. These may include 
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>The age cohort, containing e.g. year-of-birth or the generation number. These are the levels of column <code>Born</code> from data frame <code>cand$phen</code>.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>The estimated generation interval at the time when the individuals were born.</p>
</td></tr>
<tr><td><code>KIN</code></td>
<td>
<p>The average kinship <code>KIN</code> in the population at the time when the individuals were born, where <code>KIN</code> is the name of a kinship. It is an estimate of the probability that 2 alleles chosen from the population are IBD.
</p>
</td></tr>
<tr><td><code>NATKIN</code></td>
<td>
<p>The average native kinship <code>NATKIN</code> in the population at the time when the individuals were born, where <code>NATKIN</code> is the name of a native kinship. It is an estimate of the conditional probability that 2 alleles chosen from the population are IBD, given that both are from native ancestors.</p>
</td></tr>
<tr><td><code>Ne</code></td>
<td>
<p>The native effective size of the population at the time when the individuals were born. The native effective size, quantifies how fast the smoothed native kinship is increasing. The native kinship may decrease for a short time span, in which case the estimate would be NA. Use a smaller value for parameter <code>df</code> to get a smoother estimate.</p>
</td></tr>
<tr><td><code>NGE</code></td>
<td>
<p>The native genome equivalents of the population at the time when the individuals were born. The NGE estimates the  number of unrelated individuals that would be needed to establish a hypothetical new population that has the same genetic diversity at native alleles as the population under study, whereby the individuals born in the base-year are assumed to be unrelated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ExamplePed)
Pedig   &lt;- prePed(ExamplePed, thisBreed="Hinterwaelder", lastNative=1970)
phen    &lt;- Pedig[Pedig$Breed=="Hinterwaelder",]
pKin    &lt;- pedIBD(Pedig)
pKinatN &lt;- pedIBDatN(Pedig, thisBreed="Hinterwaelder")
pop     &lt;- candes(phen=phen, pKin=pKin, pKinatN=pKinatN, quiet=TRUE, reduce.data=FALSE)
Param   &lt;- summary(pop, tlim=c(1970,1995), histNe=150, base=1800, df=4)

plot(Param$t, Param$pKinatN,type="l", ylim=c(0,0.1))
lines(Param$t,Param$pKin, col="red")

plot(Param$t, Param$Ne,  type="l", ylim=c(0,100))
plot(Param$t, Param$NGE, type="l", ylim=c(0,10))
plot(Param$t, Param$I,   type="l", ylim=c(0,10))
</code></pre>

<hr>
<h2 id='summary.Pedig'>Calculates Summary Statistics for Pedigrees.
</h2><span id='topic+summary.Pedig'></span>

<h3>Description</h3>

<p>Calculates summary statistics for pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Pedig'
summary(object, keep.only=NULL, maxd=50, d=4, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Pedig_+3A_object">object</code></td>
<td>
<p>An object from class <code>Pedig</code>, which is usually created with function <a href="#topic+prePed">prePed</a>.</p>
</td></tr>
<tr><td><code id="summary.Pedig_+3A_keep.only">keep.only</code></td>
<td>
<p>The individuals to be included in the summary.</p>
</td></tr>
<tr><td><code id="summary.Pedig_+3A_maxd">maxd</code></td>
<td>
<p>Maximum pedigree depth.</p>
</td></tr>
<tr><td><code id="summary.Pedig_+3A_d">d</code></td>
<td>
<p>Number of generations taken into account for computing the PCI.</p>
</td></tr>
<tr><td><code id="summary.Pedig_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes summary statistics for pedigrees, including the numbers of equivalent complete generations, numbers of fully traced generations, numbers of maximum generations traced, indexes of pedigree completeness (MacCluer et al, 1983), and the inbreeding coefficients.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Indiv</code> </td><td style="text-align: left;"> IDs of the individuals, </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>equiGen</code> </td><td style="text-align: left;"> Number of equivalent complete generations, </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fullGen</code> </td><td style="text-align: left;"> Number of fully traced generations, </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>maxGen</code> </td><td style="text-align: left;"> Number of maximum generations traced, </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>PCI</code> </td><td style="text-align: left;"> Index of pedigree completeness (MacCluer et al, 1983) in generation <code>d</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Inbreeding</code> </td><td style="text-align: left;"> Inbreeding coefficient. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Robin Wellmann</p>


<h3>References</h3>

<p>MacCluer J W, Boyce A J, Dyke B, Weitkamp L R, Pfenning D W, Parsons C J (1983). Inbreeding and pedigree structure in Standardbred horses. J Hered 74 (6): 394-399. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PedigWithErrors)
Pedig &lt;- prePed(PedigWithErrors)
Summary &lt;- summary(Pedig, keep.only=Pedig$Born %in% (2006:2007))
head(Summary)

hist(Summary$PCI,        xlim=c(0,1),  main="Pedigree Completeness")
hist(Summary$Inbreeding, xlim=c(0,1),  main="Inbreeding")
hist(Summary$equiGen,    xlim=c(0,20), main="Number of Equivalent Complete Generations")
hist(Summary$fullGen,    xlim=c(0,20), main="Number of Fully Traced Generations")
hist(Summary$maxGen,     xlim=c(0,20), main="Number of Maximum Generations Traced")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
