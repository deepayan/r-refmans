<!DOCTYPE html><html><head><title>Help for package crone</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crone}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anomalous_data'><p>Theoretical scattering factors for all atomic species</p></a></li>
<li><a href='#atom_gauss'><p>Gaussian atom</p></a></li>
<li><a href='#atoms'><p>Atom names and atomic number</p></a></li>
<li><a href='#choose_a'><p>Suggests unit cell side, a, based on atom content</p></a></li>
<li><a href='#diffraction'><p>Simulation of 1D diffraction pattern</p></a></li>
<li><a href='#erf'><p>Error function for real values</p></a></li>
<li><a href='#expand_to_cell'><p>Expand content of asymmetric unit to whole unit cell</p></a></li>
<li><a href='#fluorescent_scan'><p>Find optimal wavelength for anomalous phasing</p></a></li>
<li><a href='#fousynth'><p>From structure factors to density using Fourier synthesis</p></a></li>
<li><a href='#heaviside'><p>Heaviside function (step function)</p></a></li>
<li><a href='#invfousynth'><p>From density to structure factors using inverse Fourier synthesis</p></a></li>
<li><a href='#kgauss'><p>Constant normalizing wrapped gaussian</p></a></li>
<li><a href='#load_anomalous_data'><p>Load anomalous data for a specific chemical element</p></a></li>
<li><a href='#load_data'><p>Load observed structure factors from 1D structure data in workspace.</p></a></li>
<li><a href='#load_structure'><p>Load 1D structure data in workspace.</p></a></li>
<li><a href='#local_maxima'><p>Find local maxima in a vector of real values.</p></a></li>
<li><a href='#plot_absorption_curves'><p>Plot of absorption curves</p></a></li>
<li><a href='#read_h'><p>Read data from a reflections file</p></a></li>
<li><a href='#read_x'><p>Read unit cell content (atom and coordinates).</p></a></li>
<li><a href='#reduce_to_asu'><p>Reduce content of unit cell to asymmetric unit.</p></a></li>
<li><a href='#scafac'><p>Scattering factor for 1D gaussian atoms</p></a></li>
<li><a href='#sfobs'><p>Generation of structure factors with errors</p></a></li>
<li><a href='#standardise_fdata'><p>Standardise reflections data</p></a></li>
<li><a href='#standardise_sdata'><p>Organise atom data in a standard format for later use</p></a></li>
<li><a href='#structure_gauss'><p>Structure of gaussian atoms</p></a></li>
<li><a href='#strufac'><p>Calculation of structure factors</p></a></li>
<li><a href='#write_h'><p>Write structure factors to a reflections file</p></a></li>
<li><a href='#write_x'><p>Write atomic coordinates to a file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structural Crystallography in 1d</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-08-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to carry out the most important crystallographic calculations for crystal 
             structures made of 1d Gaussian-shaped atoms, especially useful for methods development.
             Main reference: E. Smith, G. Evans, J. Foadi (2017) &lt;<a href="https://doi.org/10.1088%2F1361-6404%2Faa8188">doi:10.1088/1361-6404/aa8188</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-24 14:15:46 UTC; james</td>
</tr>
<tr>
<td>Author:</td>
<td>James Foadi [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Foadi &lt;j.foadi@bath.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-24 14:40:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='anomalous_data'>Theoretical scattering factors for all atomic species</h2><span id='topic+anomalous_data'></span>

<h3>Description</h3>

<p>This dataset is a list where each element is an atomic species.
Each element of the list is a dataframe with 3 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomalous_data
</code></pre>


<h3>Format</h3>

<p>A list whose elements are dataframes corresponding to atomic
elements. Each dataframe has the following columns:
</p>

<dl>
<dt>lambda</dt><dd><p>Specific value of wavelength in angstroms.</p>
</dd>
<dt>f1</dt><dd><p>Real scattering component.</p>
</dd>
<dt>f2</dt><dd><p>Imaginary scattering component.</p>
</dd>
</dl>

<hr>
<h2 id='atom_gauss'>Gaussian atom</h2><span id='topic+atom_gauss'></span>

<h3>Description</h3>

<p>Gaussian atom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom_gauss(x, a, x0 = 0, Z = 1, B = 0, k = ksigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atom_gauss_+3A_x">x</code></td>
<td>
<p>Point in the 1D cell at which this function is calculated.</p>
</td></tr>
<tr><td><code id="atom_gauss_+3A_a">a</code></td>
<td>
<p>A real number. The width of the unit cell in which the gaussian
atom is placed.</p>
</td></tr>
<tr><td><code id="atom_gauss_+3A_x0">x0</code></td>
<td>
<p>A real number. The point corresponding to the atom's peak.</p>
</td></tr>
<tr><td><code id="atom_gauss_+3A_z">Z</code></td>
<td>
<p>An integer number. Z is the atomic number of the atom (Z(H)=1,
Z(He)=2,Z(Li)=3,Z(B)=4, etc).</p>
</td></tr>
<tr><td><code id="atom_gauss_+3A_b">B</code></td>
<td>
<p>A real number. This is the B factor characterizing the atom's
thermal agitation. It is given as B=8*pi^2*U, where U is the variance
of the position of the atoms' nucleus around the equilibrium position.</p>
</td></tr>
<tr><td><code id="atom_gauss_+3A_k">k</code></td>
<td>
<p>A real number. It controls the standard deviation of the 
gaussian function describing the atom and, thus, the shape of the
associated peak. The standard deviation sigma is given by:
<code>sigma = k * sqrt(Z)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length equal to the length of vector x, with
values equal to the evaluated gaussian atom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Carbon gaussian atom in the middle of a cell
a &lt;- 10
x0 &lt;- 5
Z &lt;- 6
x &lt;- seq(0,a,length=1000)
rho &lt;- atom_gauss(x,a,x0,Z)
plot(x,rho,type="l",xlab="x",ylab=expression(rho))
</code></pre>

<hr>
<h2 id='atoms'>Atom names and atomic number</h2><span id='topic+atoms'></span>

<h3>Description</h3>

<p>This is a dataframe including a 2-characters string indicating the atomic
element name and an integer indicating the atomic number Z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atoms
</code></pre>


<h3>Format</h3>

<p>The dataframe has the following columns:
</p>

<dl>
<dt>anames</dt><dd><p>2-character string indicating the atomic name.</p>
</dd>
<dt>Z</dt><dd><p>Integer. The atomic number.</p>
</dd>
</dl>

<hr>
<h2 id='choose_a'>Suggests unit cell side, a, based on atom content</h2><span id='topic+choose_a'></span>

<h3>Description</h3>

<p>The unit cell side is roughly calculated by adding two times the half-width
of the widest gaussian atom to the largest inter-atomic distance. The
half-width of the largest gaussian is computed as Ma times the gaussian
sigma. If the &quot;P-1&quot; symmetry is present, D is doubled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_a(Z, D, SG = "P1", k = ksigma, Ma = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choose_a_+3A_z">Z</code></td>
<td>
<p>A vector of atom Z numbers.</p>
</td></tr>
<tr><td><code id="choose_a_+3A_d">D</code></td>
<td>
<p>A real number. The distance between the two furthest atoms
in the cell.</p>
</td></tr>
<tr><td><code id="choose_a_+3A_sg">SG</code></td>
<td>
<p>2-letters character string. Symmetry. There are only two
symmetries possible when working within 1D crystallography, P1 (no
symmetry)and P-1 (inversion through the origin). SG can be either &quot;P1&quot;
or &quot;P-1&quot; for this function.</p>
</td></tr>
<tr><td><code id="choose_a_+3A_k">k</code></td>
<td>
<p>A real number. It controls the standard deviation of the 
gaussian function describing the atom and, thus, the shape of the
associated peak. The standard deviation sigma is given by:
<code>sigma = k * sqrt(Z)</code></p>
</td></tr>
<tr><td><code id="choose_a_+3A_ma">Ma</code></td>
<td>
<p>A real number. Each gaussian atom has tails truncated at a
distance of Ma * sigma from its peak.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number that suggests a feasible unit cell side 
containing all atoms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 carbon atoms, a sulphur and an oxygen
Z &lt;- c(6,8,16,6)

# Distance between the two carbons is 15 angstroms
D &lt;- 15
a &lt;- choose_a(Z,D)
</code></pre>

<hr>
<h2 id='diffraction'>Simulation of 1D diffraction pattern</h2><span id='topic+diffraction'></span>

<h3>Description</h3>

<p>Analytic Fourier transform of electron density corresponding to
an array of <code>Ncell</code> unit cells calculated using numerical 
integration with the trapezoid rule. The diffraction peaks' height is 
proportional to the number of unit cells ( <code>Ncell</code>). The 
number of diffraction peaks included in the 1D diffraction pattern is 
related to the maximum resolution <code>D</code> provided in the input. 
The number of grid points for both the simulated electron density and
the resulting diffraction pattern can also be provided as input. A
further input parameter is the radius of the beamstop disc to stop
diffraction close to the incoming beam (as the resulting intensity far
outweigh the rest of the diffracted intensities).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffraction(sdata, D, Ncell = 10, N = 1000, n = 100, bstop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffraction_+3A_sdata">sdata</code></td>
<td>
<p>A named list, normally obtained through the use of
functions <code><a href="#topic+read_x">read_x</a></code> or <code><a href="#topic+standardise_sdata">standardise_sdata</a></code>. 
The list names correspond to different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
<tr><td><code id="diffraction_+3A_d">D</code></td>
<td>
<p>Real numeric. Maximum resolution in angstroms.</p>
</td></tr>
<tr><td><code id="diffraction_+3A_ncell">Ncell</code></td>
<td>
<p>Positive integer. It is the number of unit cells in 
the 1D crystal. The default value is <code>Ncell=10</code>.</p>
</td></tr>
<tr><td><code id="diffraction_+3A_n">N</code></td>
<td>
<p>Positive integer indicating the number of grid points for the
electron density. The default value is <code>N=1000</code>.</p>
</td></tr>
<tr><td><code id="diffraction_+3A_n">n</code></td>
<td>
<p>Positive integer determining the reciprocal space grid. The
grid is made of <code>2*n+1</code> regularly-spaced points from <code>-1/D</code> 
to <code>1/D</code>. The value 0 is always at the centre of the grid. The 
default value is <code>n=100</code>.</p>
</td></tr>
<tr><td><code id="diffraction_+3A_bstop">bstop</code></td>
<td>
<p>Real numeric. Is the radius of the backstop disc. Intensities
at points closer to the origin than <code>bstop</code> are reduced to 
0. The presence of a backstop improves the contrast for all diffracted
intensities because it gets rid of the overwhelming intensity corresponding
to the origin of the reciprocal space. The default is not to include
any backstop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two vectors of real numbers, the values of the
reciprocal space grid points (in 1/angstrom units) <code>xstar</code> 
and the intensities <code>Imod</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Diffraction from just two unit cells of cyanate
sdata &lt;- load_structure("cyanate")

# Max resolution is 1 angstroms; no backstop
ltmp &lt;- diffraction(sdata,D=1,Ncell=1)

# Plot diffraction pattern
plot(ltmp$xstar,ltmp$Imod,type="l",
 xlab=expression(paste("x"^"*")),ylab="Intensity")

# Diffraction from 20 unit cells with backstop of 20 angstroms diameter
ltmp &lt;- diffraction(sdata,D=1,bstop=10)
plot(ltmp$xstar,ltmp$Imod,type="l",
 xlab=expression(paste("x"^"*")),ylab="Intensity")


</code></pre>

<hr>
<h2 id='erf'>Error function for real values</h2><span id='topic+erf'></span>

<h3>Description</h3>

<p>Error function for real values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erf_+3A_x">x</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number. The integral of the gaussian, centred on zero and
with standard deviation equal to 1, between 0 and x, multiplied by
2/sqrt(pi).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-1,1,length=1000)
y &lt;- erf(x)
plot(x,y,type="l")

</code></pre>

<hr>
<h2 id='expand_to_cell'>Expand content of asymmetric unit to whole unit cell</h2><span id='topic+expand_to_cell'></span>

<h3>Description</h3>

<p>Atom positions, types, B factors and occupancies are duplicated if
input space group (SG) is P-1; otherwise they are left untouched
(space group P1). Value of the occupancy for special positions is
barely checked for values outside [0,1] range. Extra-care needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_to_cell(sdata, SG = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_to_cell_+3A_sdata">sdata</code></td>
<td>
<p>A named list, normally obtained through the use of
function <code><a href="#topic+read_x">read_x</a></code>. The list names correspond to 
different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
<tr><td><code id="expand_to_cell_+3A_sg">SG</code></td>
<td>
<p>2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no symmetry)
and P-1 (inversion through the origin). SG can be either &quot;P1&quot; or
&quot;P-1&quot; for this function. Default is NULL, in which case the space
group is assumed to be equal to the one of the input structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p>a.   Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.  Character string. Name of the space group, either &quot;P1&quot;
or &quot;P-1&quot;.
</p>
</li>
<li><p>x0. Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.  Vector of integers indicating the expanded atomic numbers
for all atoms in the unit cell.
</p>
</li>
<li><p>B.  Vector of real numerics indicating the expanded B factors
for all atoms in the unit cell.
</p>
</li>
<li><p>occ. Vector of real numerics indicating the expanded occupancies
for all atoms in the unit cell.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Asymmetric unit includes 3 atoms between 0 and a/2
a &lt;- 10
SG &lt;- "P-1"
x0 &lt;- c(1,2,4)
Z &lt;- c(6,8,6)
B &lt;- c(1,1.2,1.1)
occ &lt;- c(1,1,0.8)
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
ltmp &lt;- expand_to_cell(sdata)
print(ltmp)  # Positions, atomic numbers, etc. have doubled

# Nothing changes if imposed SG is "P1" (but you get a warning!)
ltmp &lt;- expand_to_cell(sdata,SG="P1")
print(ltmp)
</code></pre>

<hr>
<h2 id='fluorescent_scan'>Find optimal wavelength for anomalous phasing</h2><span id='topic+fluorescent_scan'></span>

<h3>Description</h3>

<p>This function mimics the behaviour of the fluorescent scan operated at
synchrotron beamlines to find out the optimal wavelength which maximises
the anomalous signal used to phase a structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluorescent_scan(chem_el, lambda_range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluorescent_scan_+3A_chem_el">chem_el</code></td>
<td>
<p>1- or 2-letters character string. The chemical symbol of
interest.</p>
</td></tr>
<tr><td><code id="fluorescent_scan_+3A_lambda_range">lambda_range</code></td>
<td>
<p>Real vector of length 2. The two values are the extremes of
the wavelength window inside which to carry out the search. Default is
for the search to be carried out across the full available range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two elements: 1) idx is the integer indicating the
row in the anomalous_data dataframe related to the specific chemical
element, corresponding to the optimal wavelength; 2) the optimal wavelength
in angstroms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Optimal wavelength for iron
lFe &lt;- fluorescent_scan("Fe")
print(lFe$lambda)
idx &lt;- lFe$idx

# Load anomalous dataframe for Fe
adFe &lt;- load_anomalous_data("Fe")
print(adFe[idx,])  # Same wavelength as before!

# Optimal wavelength with window restriction
lFe &lt;- fluorescent_scan("Fe",lambda_range=c(6,8))
print(lFe$lambda)

</code></pre>

<hr>
<h2 id='fousynth'>From structure factors to density using Fourier synthesis</h2><span id='topic+fousynth'></span>

<h3>Description</h3>

<p>Given a set of structure factors, separately as a vector of amplitudes 
and a vector of phases in degrees, corresponding to a set of 1D
Miller indices, the length of the 1D unit cell, the set of Miller indices
and the number of grid points used to calculate the 1D density, this
function calculates the 1D density corresponding to the given structure
factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fousynth(a, Fmod, Fpha, hidx, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fousynth_+3A_a">a</code></td>
<td>
<p>A real number. The unit cell side length.</p>
</td></tr>
<tr><td><code id="fousynth_+3A_fmod">Fmod</code></td>
<td>
<p>A vector of real numbers. The structure factors' amplitudes
corresponding to the 1D density to be calculated.</p>
</td></tr>
<tr><td><code id="fousynth_+3A_fpha">Fpha</code></td>
<td>
<p>A vector of real numbers. The structure factors' phases
(in degrees) corresponding to the 1D density to be calculated.</p>
</td></tr>
<tr><td><code id="fousynth_+3A_hidx">hidx</code></td>
<td>
<p>A vector of integer numbers. The set of 1D Miller indices
corresponding to the set of structure factors F.</p>
</td></tr>
<tr><td><code id="fousynth_+3A_n">N</code></td>
<td>
<p>An integer number. The number of grid points used to calculate the
1D density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of N real numbers representing the calculated 1D density at
each of the regular N grid points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create the crystal structure (in P1)
a &lt;- 10
SG &lt;- "P1"
x0 &lt;- c(1,4,6.5)
Z &lt;- c(8,26,6)
B &lt;- c(18,20,17)
occ &lt;- c(1,1,1)
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)

# Enough Fourier components (Miller indices)
hidx &lt;- 0:20

# Compute the structure factors
ftmp &lt;- strufac(hidx,sdata)

# Number of grid points
N &lt;- 1000

# Density
rtmp &lt;- fousynth(a,ftmp$Fmod,ftmp$Fpha,hidx,N)

# Density plot in the unit cell
x &lt;- rtmp$x
rho &lt;- rtmp$rr
plot(x,rho,type="l",xlab="x",ylab=expression(rho))
</code></pre>

<hr>
<h2 id='heaviside'>Heaviside function (step function)</h2><span id='topic+heaviside'></span>

<h3>Description</h3>

<p>Heaviside function (step function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heaviside(x, x0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heaviside_+3A_x">x</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
<tr><td><code id="heaviside_+3A_x0">x0</code></td>
<td>
<p>A real number. The x value at which the function step occurs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One of the two numbers 0 or 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-3,5,length=1000)
x0 &lt;- 1
y &lt;- heaviside(x,x0)
plot(x,y,type="l")
# Step up and step down
x1 &lt;- seq(-3,5,length=1000)
x10 &lt;- 1
y1 &lt;- heaviside(x1,x10)
x2 &lt;- seq(1,9,length=1000)
x20 &lt;- 5
y2 &lt;- heaviside(x2,x20)
y2 &lt;- 1-y2
plot(x1,y1,type="l",xlim=c(-3,9),xlab="x",ylab="y")
points(x2,y2,type="l")
</code></pre>

<hr>
<h2 id='invfousynth'>From density to structure factors using inverse Fourier synthesis</h2><span id='topic+invfousynth'></span>

<h3>Description</h3>

<p>Given a density as vector calculated in N grid points, the unit cell
size and an array of Miller indices hidx, this function calculates
amplitudes and phases of the structure factors corresponding to this
density, via inverse Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invfousynth(a, rho, hidx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invfousynth_+3A_a">a</code></td>
<td>
<p>A real number. The unit cell side length.</p>
</td></tr>
<tr><td><code id="invfousynth_+3A_rho">rho</code></td>
<td>
<p>A vector of N real numbers representing the 1D density at
each of the regular N grid point.</p>
</td></tr>
<tr><td><code id="invfousynth_+3A_hidx">hidx</code></td>
<td>
<p>A vector of integer numbers. The set of 1D Miller indices
corresponding to the set of structure factors F, to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of N real numbers representing the calculated 1D 
density at each one of the regular N grid points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create the crystal structure (in P1)
a &lt;- 10
SG &lt;- "P1"
x0 &lt;- c(1,4,6.5)
Z &lt;- c(8,26,6)
B &lt;- c(18,20,17)
occ &lt;- c(1,1,1)
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)

# 10 Miller indices plus DC component
hidx &lt;- 0:10

# Compute structure factors
ftmp1 &lt;- strufac(hidx,sdata)

# Number of grid points
N &lt;- 1000

# Density
rtmp &lt;- fousynth(a,ftmp1$Fmod,ftmp1$Fpha,hidx,N)

# Using inverse Fourier to obtain structure factors
ftmp2 &lt;- invfousynth(a,rtmp$rr,hidx)

# Comparison
print(abs(ftmp1$Fmod-ftmp2$Fmod))
print(abs(ftmp1$Fpha-ftmp2$Fpha))

</code></pre>

<hr>
<h2 id='kgauss'>Constant normalizing wrapped gaussian</h2><span id='topic+kgauss'></span>

<h3>Description</h3>

<p>Constant normalizing wrapped gaussian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kgauss(sigma, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kgauss_+3A_sigma">sigma</code></td>
<td>
<p>A real number. Is the standard deviation of the wrapped
gaussian.</p>
</td></tr>
<tr><td><code id="kgauss_+3A_a">a</code></td>
<td>
<p>A real number. The unit cell side length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number, the multiplicative constant normalizing the
wrapped gaussian atom so that the area under the curve is equal to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- 16  # Sulphur atom
sigma &lt;- 0.05*sqrt(Z)
a &lt;- 15  # Unit cell size
kk &lt;- kgauss(sigma,a)
print(kk)

</code></pre>

<hr>
<h2 id='load_anomalous_data'>Load anomalous data for a specific chemical element</h2><span id='topic+load_anomalous_data'></span>

<h3>Description</h3>

<p>Returns a dataframe with f' and f&rdquo; at various wavelengths
for the specific chemical element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_anomalous_data(chem_el)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_anomalous_data_+3A_chem_el">chem_el</code></td>
<td>
<p>1- or 2-letters character string. The chemical symbol of
interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with 3 columns, the specific wavelength in angstroms
(lambda), f' (f1) and f&rdquo; (f2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load anomalous data for Fe
ano_Fe &lt;- load_anomalous_data("Fe")
print(ano_Fe[1:10,])
</code></pre>

<hr>
<h2 id='load_data'>Load observed structure factors from 1D structure data in workspace.</h2><span id='topic+load_data'></span>

<h3>Description</h3>

<p>Function to load structure factors corresponding to one of the many 1D 
structures available within the <em>crone</em> package. The structure
factors amplitudes have been generated from calculated data with some
simulated error, so that they mimic observed data. Phases are calculated
from the correct structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_data(sname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_data_+3A_sname">sname</code></td>
<td>
<p>A character string. Name of the structure whose data
are to be loaded in the workspace. It can be one of:
</p>

<ul>
<li><p>beryllium_fluoride
</p>
</li>
<li><p>carbon_dioxide
</p>
</li>
<li><p>cyanate
</p>
</li>
<li><p>nitronium
</p>
</li>
<li><p>thiocyanate
</p>
</li>
<li><p>xenon_difluoride
</p>
</li>
<li><p>pinkerton2015
</p>
</li></ul>

<p>Default is NULL, in which case the function returns a list of all
structures available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named fdata-type list with the following elements:
</p>

<ul>
<li><p>a    Real numeric. Unit cell length in angstroms. Always 
included.
</p>
</li>
<li><p>SG.   Spacegroup 2-letters character string. There are only two 
symmetries possible when working within 1D 
crystallography, P1 (no symmetry) and P-1 (inversion 
through the origin). SG can be either &quot;P1&quot; or &quot;P-1&quot;. 
Always included.
</p>
</li>
<li><p>hidx. Real numeric array. 1D unique (positive in the 1D context) 
Miller indices. Always included.
</p>
</li>
<li><p>Fobs.      Real numeric array. Amplitudes of observed structure 
factors. Not always included.
</p>
</li>
<li><p>sigFobs.   Real numeric array. Errors associated with Fobs. Not 
always included.
</p>
</li>
<li><p>Phicalc.   Real numeric array. Phases (in degrees) of structure 
factors calculated from the correct 1D structure. 
They are normally used to check correctness of 
Phiobs. Not always included.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load thiocyanate data
fdata &lt;- load_data("thiocyanate")
print(fdata)

# Default returns all names of structures included
load_data()

</code></pre>

<hr>
<h2 id='load_structure'>Load 1D structure data in workspace.</h2><span id='topic+load_structure'></span>

<h3>Description</h3>

<p>Function to load data from one of the many 1D structures available
within the <em>crone</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_structure(sname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_structure_+3A_sname">sname</code></td>
<td>
<p>A character string. Name of the structure whose data
are to be loaded in the workspace. It can be one of:
</p>

<ul>
<li><p>beryllium_fluoride
</p>
</li>
<li><p>carbon_dioxide
</p>
</li>
<li><p>cyanate
</p>
</li>
<li><p>nitronium
</p>
</li>
<li><p>thiocyanate
</p>
</li>
<li><p>xenon_difluoride
</p>
</li>
<li><p>pinkerton2015
</p>
</li></ul>

<p>Default is NULL, in which case the function returns a list of all
structures available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p>a    Real numeric. Unit cell length in angstroms.
</p>
</li>
<li><p>SG   2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no 
symmetry) and P-1 (inversion through the origin). SG can be 
either &quot;P1&quot; or &quot;P-1&quot;.
</p>
</li>
<li><p>x0    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load thiocyanate data
sdata &lt;- load_structure("thiocyanate")
print(sdata)

# Default returns all names of structures included
load_structure()

</code></pre>

<hr>
<h2 id='local_maxima'>Find local maxima in a vector of real values.</h2><span id='topic+local_maxima'></span>

<h3>Description</h3>

<p>Find local maxima in a vector of real values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_maxima(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_maxima_+3A_x">x</code></td>
<td>
<p>A vector of real numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers corresponding to local maxima positions 
in vector x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- seq(-10,10,length=1000)
x &lt;- dnorm(t,mean=3)+dnorm(t,mean=7)
yM &lt;- local_maxima(x)
</code></pre>

<hr>
<h2 id='plot_absorption_curves'>Plot of absorption curves</h2><span id='topic+plot_absorption_curves'></span>

<h3>Description</h3>

<p>Plot f' and f&rdquo; absorption curves for the specified chemical element.
Curves can be plotted in specified wavelength regions using parameter
&quot;zoom&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_absorption_curves(chem_el, zoom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_absorption_curves_+3A_chem_el">chem_el</code></td>
<td>
<p>1- or 2-letters character string. The chemical symbol of
interest.</p>
</td></tr>
<tr><td><code id="plot_absorption_curves_+3A_zoom">zoom</code></td>
<td>
<p>Real vector of length 2. The two values are the extremes of
the wavelength window inside which to plot the two curves. Default is
for both curves to be plotted across the full available range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, but causes a 2D plot to be displayed in a graphical window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># No zoom
plot_absorption_curves("Fe")

# Zoom
plot_absorption_curves("Fe",c(1,3))
</code></pre>

<hr>
<h2 id='read_h'>Read data from a reflections file</h2><span id='topic+read_h'></span>

<h3>Description</h3>

<p>Read data from a *_h.dat-type file containing cell size, spacegroup
symbol and amplitudes and/or phases of observed and/or calculated
structure factors. This function loads the file data into a standardised
named list for structure factors data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_h(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_h_+3A_filename">filename</code></td>
<td>
<p>A character string. Existing file that includes structure 
factors information. The file name in general has the form 
&quot;[prefix]_h.dat&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p>a    Real numeric. Unit cell length in angstroms. Always 
included.
</p>
</li>
<li><p>SG.   Spacegroup 2-letters character string. There are only two 
symmetries possible when working within 1D 
crystallography, P1 (no symmetry) and P-1 (inversion 
through the origin). SG can be either &quot;P1&quot; or &quot;P-1&quot;. 
Always included.
</p>
</li>
<li><p>hidx. Real numeric array. 1D unique (positive in the 1D context) 
Miller indices. Always included.
</p>
</li>
<li><p>Fobs.      Real numeric array. Amplitudes of observed structure 
factors. Not always included.
</p>
</li>
<li><p>sigFobs.   Real numeric array. Errors associated with Fobs. Not 
always included.
</p>
</li>
<li><p>Fp.        Real numeric vector. Amplitudes of the positive 
component of Friedel (or Bijvoet) pairs (F+). Not
always included.
</p>
</li>
<li><p>sigFp.     Real numeric vector. Errors associated with Fp. 
Not always included.
</p>
</li>
<li><p>Fm.        Real numeric vector. Amplitudes of the negative 
component of Friedel (or Bijvoet) pairs (F-). Not always
included.
</p>
</li>
<li><p>sigFm.     Real numeric vector. Errors associated with Fm. Not
always included.
</p>
</li>
<li><p>Phiobs.    Real numeric array. Phases (in degrees) of structure 
factors obtained with one of the methods used for 
structure solution. Not always included.
</p>
</li>
<li><p>Phicalc.   Real numeric array. Phases (in degrees) of structure 
factors calculated from the correct 1D structure. 
They are normally used to check correctness of 
Phiobs. Not always included.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Observed structure factors amplitudes and calculated phases
# from thiocyanate structure
datadir &lt;- system.file("extdata",package="crone")
filename &lt;- file.path(datadir,"thiocyanate_h.dat")
fdata &lt;- read_x(filename)
print(names(fdata))
print(fdata$Fobs)
print(fdata$sigFobs)

</code></pre>

<hr>
<h2 id='read_x'>Read unit cell content (atom and coordinates).</h2><span id='topic+read_x'></span>

<h3>Description</h3>

<p>Read unit cell length, space group, atom coordinates and all other
parameters from a coordinate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_x(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_x_+3A_filename">filename</code></td>
<td>
<p>A character string. Existing file that includes all structural
information. The file name in general has the form &quot;[prefix]_x.dat&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p>a.    Real numeric. Unit cell length in angstroms.
</p>
</li>
<li><p>SG.   SG 2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no 
symmetry) and P-1 (inversion through the origin). SG can be 
either &quot;P1&quot; or &quot;P-1&quot;.
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="crone")
filename &lt;- file.path(datadir,"carbon_dioxide_x.dat")
sdata &lt;- read_x(filename)
print(names(sdata))
print(sdata)

</code></pre>

<hr>
<h2 id='reduce_to_asu'>Reduce content of unit cell to asymmetric unit.</h2><span id='topic+reduce_to_asu'></span>

<h3>Description</h3>

<p>Atom types, B factors and occupancies are restricted to those corresponding
to positions in the asymmetric unit, if the input space group (SG) is P-1.
Otherwise they are only sorted according to increasing atom positions. If
the starting positions do not correspond to a properly symmetry-expanded
set, then a warning is issued. If no symmetry is used (P1) the starting set
is forced to have values inside the unit cell and it is sorted according
to increasing atom positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_to_asu(adata, SG = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_to_asu_+3A_adata">adata</code></td>
<td>
<p>A named list, normally obtained through the use of
function <code><a href="#topic+read_x">read_x</a></code>. The list names correspond to 
different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
<tr><td><code id="reduce_to_asu_+3A_sg">SG</code></td>
<td>
<p>2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no symmetry)
and P-1 (inversion through the origin). SG can be either &quot;P1&quot; or
&quot;P-1&quot; for this function. Default is NULL, in which case the space
group is assumed to be equal to the one of the input structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p>x0. Vector of real numerics indicating the reduced atomic
positions in the asymmetric unit.
</p>
</li>
<li><p>Z.  Vector of integers indicating the reduced atomic numbers
for all atoms in the asymmetric unit.
</p>
</li>
<li><p>B.  Vector of real numerics indicating the reduced B factors
for all atoms in the asymmetric unit.
</p>
</li>
<li><p>occ. Vector of real numerics indicating the reduced occupancies
for all atoms in the asymmetric unit.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Asymmetric unit includes 4 atoms between 0 and a/2, 1 in special position
a &lt;- 10
SG &lt;- "P-1"
x0 &lt;- c(1,2,4,5)
Z &lt;- c(6,8,6,16)
B &lt;- c(1,1.2,1.1,0.8)
occ &lt;- c(1,1,1,0.5)
adata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
ltmp &lt;- expand_to_cell(adata)
print(ltmp)  # Positions, atomic numbers, etc. have doubled

# Now these expanded values are used as input for reduction
ltmp2 &lt;- reduce_to_asu(ltmp)

# Compare
print(x0)
print(ltmp2$x0)

# SG is "P1"
a &lt;- 16
SG &lt;- "P1"
x0 &lt;- c(1,2,7,9,12,16)
Z &lt;- c(6,6,8,8,7,6)
B &lt;- c(0,0,0,0,0,0)
occ &lt;- c(1,1,1,1,1,1)
adata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
ltmp3 &lt;- reduce_to_asu(adata)
print(ltmp3) # Now all positions are inside the unit cell
</code></pre>

<hr>
<h2 id='scafac'>Scattering factor for 1D gaussian atoms</h2><span id='topic+scafac'></span>

<h3>Description</h3>

<p>Given unit cell length, atomic number, B factor, occupancy and Miller
index h, this function returns the corresponding value of the analytical
scattering factor calculated as Fourier transform of the 1D gaussian atom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scafac(h, a, Zj, occj, Bj = NULL, k = ksigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scafac_+3A_h">h</code></td>
<td>
<p>Real numeric. One or more 1D Miller indices. h can also have
non-integer values in between integer values. This enables plotting
of scattering curves.</p>
</td></tr>
<tr><td><code id="scafac_+3A_a">a</code></td>
<td>
<p>Real numeric. Length of 1D unit cell.</p>
</td></tr>
<tr><td><code id="scafac_+3A_zj">Zj</code></td>
<td>
<p>Integer numeric. Atomic number (e.g. Oxygen has Zj &lt;- 8)</p>
</td></tr>
<tr><td><code id="scafac_+3A_occj">occj</code></td>
<td>
<p>Real numeric. Atomic occupancy, a real number between 0 and 1,
where 0 means that the atom is missing in the crystal and 1 means that
is present in all unit cells of the crystal.</p>
</td></tr>
<tr><td><code id="scafac_+3A_bj">Bj</code></td>
<td>
<p>Real numeric. This is the B factor associated with the thermal
vibration of the atom. It is measured in squared angstroms and it is
equal to 8*pi^2*sigma^2, where sigma is the gaussian atom width.</p>
</td></tr>
<tr><td><code id="scafac_+3A_k">k</code></td>
<td>
<p>A real number. It controls the standard deviation of the 
gaussian function describing the atom and, thus, the shape of the
associated peak. The standard deviation sigma is given by:
<code>sigma = k * sqrt(Z)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real numeric. The value of the scattering factor at the sprcified
Miller idex or corresponding real value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Values for some Miller indices
h &lt;- 0:10
a &lt;- 20
Zj &lt;- 16
Bj &lt;- 18  # Roughly corresponding to sigma 0.23
occj &lt;- 1
fval &lt;- scafac(h,a,Zj,occj,Bj)
plot(h,fval,pch=16,xlab="Miller index",ylab="Scattering factor",
     ylim=c(0,16))

# Continuous resolution
h &lt;- seq(0,10,length=1000)
fval &lt;- scafac(h,a,Zj,occj,Bj)
points(h,fval,type="l",col=2)

# Scattering curve for a lighter atom
Zj &lt;- 8
fval &lt;- scafac(h,a,Zj,occj,Bj)
points(h,fval,type="l",col=3)

# Scattering curve for the same atom, just with smaller Bj (colder)
Bj &lt;- 10
fval &lt;- scafac(h,a,Zj,occj,Bj)
points(h,fval,type="l",col=4)
</code></pre>

<hr>
<h2 id='sfobs'>Generation of structure factors with errors</h2><span id='topic+sfobs'></span>

<h3>Description</h3>

<p>This function generates structure factors calculated starting from
the given structure and subject to two types of errors: poissonian
counting errors due to the statistical nature of the photons hitting
the crystal and normal errors due to the slight random shifting of
atoms position in all the unit cells forming the lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfobs(hidx, sdata, vx0err = NULL, ntrialP = 100, ntrialG = 100,
  anoflag = FALSE, aK = anoK, lbda = 1, k = ksigma,
  f1f2out = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfobs_+3A_hidx">hidx</code></td>
<td>
<p>Real numeric. One or more 1D Miller indices.</p>
</td></tr>
<tr><td><code id="sfobs_+3A_sdata">sdata</code></td>
<td>
<p>A named list, normally obtained through the use of
function <code><a href="#topic+read_x">read_x</a></code> or <code><a href="#topic+standardise_sdata">standardise_sdata</a></code>. 
The list names correspond to different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sfobs_+3A_vx0err">vx0err</code></td>
<td>
<p>A real number. The standard deviation of the random 
displacement of all atoms composing the structure from their correct
position. Default value is NULL, corresponding to the generation of
structure factors, with no errors, from the correct structure.</p>
</td></tr>
<tr><td><code id="sfobs_+3A_ntrialp">ntrialP</code></td>
<td>
<p>Integer. The number of simulated Poisson counts for each
set of structure factor amplitudes. More counts (high ntrialP) return
smaller errors for the structure factor amplitudes. If ntrialP less or 
equal 0, then poissonian counting errors are not generated.</p>
</td></tr>
<tr><td><code id="sfobs_+3A_ntrialg">ntrialG</code></td>
<td>
<p>Integer. This is the number of randomly generated shifts of
each atom of the structure from its true position. The shifts follow a
gaussian distribution with mean 0 and standard deviation vx0err.</p>
</td></tr>
<tr><td><code id="sfobs_+3A_anoflag">anoflag</code></td>
<td>
<p>Logical variable. If TRUE it forces scattering factors
to include anomalous contributions. As a consequence, theoretical
Friedel's pairs will not be equal.</p>
</td></tr>
<tr><td><code id="sfobs_+3A_ak">aK</code></td>
<td>
<p>Real numeric. This is a fudge factor included to decrease the
strength of the anomalous contributions. Without aK the strength is too
high for 1D structures, compared to real 3D structures. So aK helps
bringing down the anomalous contribution within the 5
met with large-size structures. The default value is aK=0.3 (anoK is
included as internal data).</p>
</td></tr>
<tr><td><code id="sfobs_+3A_lbda">lbda</code></td>
<td>
<p>Real numeric. This is the wavelength in angstroms. Its value
is important in relation to anomalous scattering.</p>
</td></tr>
<tr><td><code id="sfobs_+3A_k">k</code></td>
<td>
<p>A real number. It controls the standard deviation of the 
gaussian function describing the atom and, thus, the shape of the
associated peak. The standard deviation sigma is given by:
<code>sigma = k * sqrt(Z)</code>
The default value is k=0.05 (ksigma is included as internal data).</p>
</td></tr>
<tr><td><code id="sfobs_+3A_f1f2out">f1f2out</code></td>
<td>
<p>Logical variable. This variable controls output of a small
table of f' and f&rdquo; values for all chemical elements in the structure.
Default is for the table to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two elements:
</p>

<ul>
<li><p>F Array of mean structure factor amplitudes, among all structure
factor arrays simulated with specific errors.
</p>
</li>
<li><p>sF  Array of structure factors errors. These coincide with the
standard deviations of all structure factors arrays simulated
with specific errors.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load thiocyanate data
sdata &lt;- load_structure("thiocyanate")

# Miller indices used
hidx &lt;- 1:10

# Correct amplitudes and phases
ftmp &lt;- strufac(hidx,sdata)
Ftrue &lt;- ftmp$Fmod
phitrue &lt;- ftmp$Fpha

# Only poissonian errors
ltmp &lt;- sfobs(hidx,sdata,ntrialP=2)
print(names(ltmp))
Fpois &lt;- ltmp$F

# True density
rtmptrue &lt;- fousynth(sdata$a,Fmod=Ftrue,Fpha=phitrue,hidx,1000)
plot(rtmptrue$x,rtmptrue$rr,type="l",xlab="x",ylab=expression(rho),
 lwd=3)

# Density with poissonian errors
rtmppois &lt;- fousynth(sdata$a,Fmod=Fpois,Fpha=phitrue,hidx,1000)
points(rtmppois$x,rtmppois$rr,type="l",
 lty=2,col=2,lwd=2) # Very small differences

# Only random atomic errors with standard deviation 0.3 angstroms
ltmp &lt;- sfobs(hidx,sdata,ntrialP=0,vx0err=0.3)
Fcoords &lt;- ltmp$F

# Density with gaussian errors on atom coordinates
rtmpcoords &lt;- fousynth(sdata$a,Fmod=Fcoords,Fpha=phitrue,hidx,1000)
points(rtmpcoords$x,rtmpcoords$rr,type="l",
 lty=3,col=3,lwd=2) # Larger differences
</code></pre>

<hr>
<h2 id='standardise_fdata'>Standardise reflections data</h2><span id='topic+standardise_fdata'></span>

<h3>Description</h3>

<p>This function output a list with fields needed by most of the
functions dealing with structure factors. It is the equivalent
of the function <cite>standardise_sdata</cite>, used to prepare atomic
structures data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardise_fdata(a, SG, hidx, Fobs = NULL, sigFobs = NULL,
  Fp = NULL, sigFp = NULL, Fm = NULL, sigFm = NULL,
  Phiobs = NULL, Phicalc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardise_fdata_+3A_a">a</code></td>
<td>
<p>Real numeric. Unit cell length in angstroms.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_sg">SG</code></td>
<td>
<p>SG 2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no 
symmetry) and P-1 (inversion through the origin). SG can be 
either &quot;P1&quot; or &quot;P-1&quot;.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_hidx">hidx</code></td>
<td>
<p>Real numeric array. 1D unique (positive in the 1D context)
Miller indices.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_fobs">Fobs</code></td>
<td>
<p>Real numeric array. Amplitudes of structure factors.
If Fp and Fm are not NULL and Fobs is NULL, then Fobs are calculated
as averages of Fp and Fm. If both Fp, Fm and Fobs are included, input
Fobs are used, instead of Fp and Fm averages.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_sigfobs">sigFobs</code></td>
<td>
<p>Real numeric array. Errors associated with Fobs. If
sigFobs = NULL, errors are estimated from Fp and Fm. Default is NULL.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_fp">Fp</code></td>
<td>
<p>Real numeric vector. Amplitudes of the positive 
component of Friedel (or Bijvoet) pairs (F+). Default is NULL,
i.e. no Fp included.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_sigfp">sigFp</code></td>
<td>
<p>Real numeric vector. Errors associated with Fp. Default
is NULL, i.e. no sigFp included.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_fm">Fm</code></td>
<td>
<p>Real numeric vector. Amplitudes of the negative 
component of Friedel (or Bijvoet) pairs (F-). Default is NULL,
i.e. no Fm included.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_sigfm">sigFm</code></td>
<td>
<p>Real numeric vector. Errors associated with Fm. Default
is NULL, i.e. no sigFm included.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_phiobs">Phiobs</code></td>
<td>
<p>Real numeric array. Phases (in degrees) of structure 
factors obtained with one of the methods used for structure solution.
Default is NULL.</p>
</td></tr>
<tr><td><code id="standardise_fdata_+3A_phicalc">Phicalc</code></td>
<td>
<p>Real numeric array. Phases (in degrees) of structure 
factors calculated from the correct 1D structure. They are normally 
used to check correctness of Phiobs. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with a variable number of elements. Some of them
are always included; others are not:
</p>

<ul>
<li><p>a    Real numeric. Unit cell length in angstroms. Always 
included.
</p>
</li>
<li><p>SG.   Spacegroup 2-letters character string. There are only two 
symmetries possible when working within 1D 
crystallography, P1 (no symmetry) and P-1 (inversion 
through the origin). SG can be either &quot;P1&quot; or &quot;P-1&quot;. 
Always included.
</p>
</li>
<li><p>hidx. Real numeric array. 1D unique (positive in the 1D context) 
Miller indices. Always included.
</p>
</li>
<li><p>Fobs.      Real numeric array. Amplitudes of observed structure 
factors. Not always included.
</p>
</li>
<li><p>sigFobs.   Real numeric array. Errors associated with Fobs. Not 
always included.
</p>
</li>
<li><p>Fp.        Real numeric vector. Amplitudes of the positive 
component of Friedel (or Bijvoet) pairs (F+). Not
always included.
</p>
</li>
<li><p>sigFp.     Real numeric vector. Errors associated with Fp. 
Not always included.
</p>
</li>
<li><p>Fm.        Real numeric vector. Amplitudes of the negative 
component of Friedel (or Bijvoet) pairs (F-). Not always
included.
</p>
</li>
<li><p>sigFm.     Real numeric vector. Errors associated with Fm. Not
always included.
</p>
</li>
<li><p>Phiobs.    Real numeric array. Phases (in degrees) of structure 
factors obtained with one of the methods used for 
structure solution. Not always included.
</p>
</li>
<li><p>Phicalc.   Real numeric array. Phases (in degrees) of structure 
factors calculated from the correct 1D structure. 
They are normally used to check correctness of 
Phiobs. Not always included.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create an arbitrary structure with a heavy atom (Fe)
a &lt;- 20
SG &lt;- "P1"
x0 &lt;- c(1,2,6,16)
Z &lt;- c(6,8,26,7)
B &lt;- c(8,7,5,8)
occ &lt;- c(1,1,1,1)
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)

# Miller indices, from -5 to 5 (to include negatives for anomalous)
hidx &lt;- -5:5

# Experimental structure factors with anomalous contribution
# (lambda = 1.74) for creating Fm and Fp. Errors only due to
# photons fluctuations.
set.seed(9195)   # For demo purposes.
ltmp &lt;- sfobs(hidx,sdata,ntrialP=10,anoflag=TRUE,lbda=1.74)

# Fp and sigFp (Miller indices from 1 to 5)
isel &lt;- 1:5
idx &lt;- match(isel,hidx)
Fp &lt;- ltmp$F[idx]
sigFp &lt;- ltmp$sF[idx]

# Fm and sigFm
isel &lt;- (-1):(-5)
idx &lt;- match(isel,hidx)
Fm &lt;- ltmp$F[idx]
sigFm &lt;- ltmp$sF[idx]

# Now only positive Miller indices
hidx &lt;- 1:5

# Create standardised data for reciprocal space
fdata &lt;- standardise_fdata(a,SG,hidx,Fp=Fp,sigFp=sigFp,
         Fm=Fm,sigFm=sigFm)
         
# Fp and Fm
print(fdata$Fp)
print(fdata$sigFp)
print(fdata$Fm)
print(fdata$sigFm)

# Fobs and sigFobs automatically created
print(fdata$Fobs)
print(fdata$sigFobs)

# Structure factors without anomalous data for the same structure
hidx &lt;- 1:5
set.seed(9195)   # For demo purposes.
ltmp &lt;- sfobs(hidx,sdata,ntrialP=10)
Fobs &lt;- ltmp$F
sigFobs &lt;- ltmp$sF
fdata &lt;- standardise_fdata(a,SG,hidx,Fobs=Fobs,sigFobs=sigFobs)
print(fdata)

</code></pre>

<hr>
<h2 id='standardise_sdata'>Organise atom data in a standard format for later use</h2><span id='topic+standardise_sdata'></span>

<h3>Description</h3>

<p>Function to put any group consisting of cell size a, space group SG,
atom coordinates x0, atomic numbers Z, atomic B factors B and atomic
occupancies occ, into a named list with 6 fields. This is then used
as standard input/output format throughout the <em>crone</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardise_sdata(a, SG, x0, Z, B, occ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardise_sdata_+3A_a">a</code></td>
<td>
<p>Real numeric. Unit cell length in angstroms.</p>
</td></tr>
<tr><td><code id="standardise_sdata_+3A_sg">SG</code></td>
<td>
<p>SG 2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no 
symmetry) and P-1 (inversion through the origin). SG can be 
either &quot;P1&quot; or &quot;P-1&quot;.</p>
</td></tr>
<tr><td><code id="standardise_sdata_+3A_x0">x0</code></td>
<td>
<p>Vector of real numerics indicating the expanded atomic
positions in the unit cell.</p>
</td></tr>
<tr><td><code id="standardise_sdata_+3A_z">Z</code></td>
<td>
<p>Vector of integers indicating the expanded atomic 
numbers for all atoms in the unit cell.</p>
</td></tr>
<tr><td><code id="standardise_sdata_+3A_b">B</code></td>
<td>
<p>Vector of real numerics indicating the expanded B factors 
for all atoms in the unit cell.</p>
</td></tr>
<tr><td><code id="standardise_sdata_+3A_occ">occ</code></td>
<td>
<p>Vector of real numerics indicating the expanded occupancies
for all atoms in the unit cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p>a.    Real numeric. Unit cell length in angstroms.
</p>
</li>
<li><p>SG.   SG 2-letters character string. There are only two symmetries
possible when working within 1D crystallography, P1 (no 
symmetry) and P-1 (inversion through the origin). SG can be 
either &quot;P1&quot; or &quot;P-1&quot;.
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create standard format for an arbitrary structure in P1
a &lt;- 20
SG &lt;- "P1"
x0 &lt;- c(2,11,16,19)
Z &lt;- c(6,6,16,8)
B &lt;- c(13,14,5,10)
occ &lt;- c(1,1,1,1)
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
print(sdata)

</code></pre>

<hr>
<h2 id='structure_gauss'>Structure of gaussian atoms</h2><span id='topic+structure_gauss'></span>

<h3>Description</h3>

<p>Structure formed by all gaussian atoms in the unit cell. Positions, 
atomic numbers and thermal factors are given by vectors of a same 
length. Each atom forming the structure is also characterised by a given 
occupancy (between 0 and 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structure_gauss(sdata, x = NULL, N = NULL, k = ksigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structure_gauss_+3A_sdata">sdata</code></td>
<td>
<p>A named list, normally obtained through the use of
function <code><a href="#topic+read_x">read_x</a></code> or <code><a href="#topic+standardise_sdata">standardise_sdata</a></code>. 
The list names correspond to  different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
<tr><td><code id="structure_gauss_+3A_x">x</code></td>
<td>
<p>Point in the 1D cell at which this function is calculated.
Default is NULL, in which case a grid is set up internally.</p>
</td></tr>
<tr><td><code id="structure_gauss_+3A_n">N</code></td>
<td>
<p>Integer. Number of points in the regular grid, if the grid
is not provided directly.</p>
</td></tr>
<tr><td><code id="structure_gauss_+3A_k">k</code></td>
<td>
<p>A real number. It controls the standard deviation of the 
gaussian function describing the atom and, thus, the shape of the
associated peak. The standard deviation sigma is given by:
<code>sigma = k * sqrt(Z)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of length 2: x is the grid (either input by
user or set up internally), rr is a vector of length equal to the 
length of vector x, with values equal to the evaluated gaussian atoms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cell, atom types, positions and B factors
a &lt;- 10
SG &lt;- "P1"
x0 &lt;- c(2,5,7)
Z &lt;- c(6,16,8)
B &lt;- c(0,0,0)

# All occupancies to 1
occ &lt;- c(1,1,1)

# Standard data format
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)

# Grid for unit cell
x &lt;- seq(0,a,length=1000)

# Structure density
rtmp &lt;- structure_gauss(sdata,x)
plot(rtmp$x,rtmp$rr,type="l",xlab="x",ylab=expression(rho))

# Now reduce occupancy of sulphur
occ[2] &lt;- 0.5
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
rtmp &lt;- structure_gauss(sdata,x)
points(rtmp$x,rtmp$rr,type="l",col=2)

# Increase temperature of oxygen
B[3] &lt;- 10
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
rtmp &lt;- structure_gauss(sdata,x)
points(rtmp$x,rtmp$rr,type="l",col=3)

</code></pre>

<hr>
<h2 id='strufac'>Calculation of structure factors</h2><span id='topic+strufac'></span>

<h3>Description</h3>

<p>Calculates structure factors corresponding to one or more 1D Miller 
indices, given the atomic content of one unit cell. Anomalous scattering 
can be included using logical flag &quot;anoflag&quot; (default is FALSE). Crystal 
structures are always considered with no symmetry. Thus a 1D structure 
with the P-1 symmetry will have to be expanded first with function 
&quot;expand_to_cell&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strufac(hidx, sdata, anoflag = FALSE, aK = anoK, lbda = 1,
  k = ksigma, f1f2out = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strufac_+3A_hidx">hidx</code></td>
<td>
<p>Real numeric. One or more 1D Miller indices.</p>
</td></tr>
<tr><td><code id="strufac_+3A_sdata">sdata</code></td>
<td>
<p>A named list, normally obtained through the use of
functions <code><a href="#topic+read_x">read_x</a></code> or <code><a href="#topic+standardise_sdata">standardise_sdata</a></code>. 
The list names correspond to different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
<tr><td><code id="strufac_+3A_anoflag">anoflag</code></td>
<td>
<p>Logical variable. If TRUE it forces scattering factors
to include anomalous contributions. As a consequence, Friedel's
pairs will not be equal.</p>
</td></tr>
<tr><td><code id="strufac_+3A_ak">aK</code></td>
<td>
<p>Real numeric. This is a fudge factor included to decrease the
strength of the anomalous contributions. Without aK the strength is too
high for 1D structures, compared to real 3D structures. So aK helps
bringing down the anomalous contribution within the 5
met with large-size structures. The default value is aK=0.3 (anoK is
included as internal data).</p>
</td></tr>
<tr><td><code id="strufac_+3A_lbda">lbda</code></td>
<td>
<p>Real numeric. This is the wavelength in angstroms. Its value
is important in relation to anomalous scattering.</p>
</td></tr>
<tr><td><code id="strufac_+3A_k">k</code></td>
<td>
<p>A real number. It controls the standard deviation of the 
gaussian function describing the atom and, thus, the shape of the
associated peak. The standard deviation sigma is given by:
<code>sigma = k * sqrt(Z)</code>
The default value is k=0.05 (ksigma is included as internal data).</p>
</td></tr>
<tr><td><code id="strufac_+3A_f1f2out">f1f2out</code></td>
<td>
<p>Logical variable. This variable controls output of a small
table of f' and f&rdquo; values for all chemical elements in the structure.
Default is for the table to be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two vectors of real numbers, the structure 
factors amplitudes, Fmod, and phases, Fpha, corresponding to the Miller 
indices in input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create the crystal structure (P1)
a &lt;- 10
SG &lt;- "P1"
x0 &lt;- c(1,4,6.5)
Z &lt;- c(8,26,6)
B &lt;- c(18,20,17)
occ &lt;- c(1,1,1)
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
lbda &lt;- 1.7   # Close to Fe's absorption

# Miller indices (including DC (h=0) component)
hidx &lt;- 0:10

# Now structure factors without anomalous contribution
ftmp &lt;- strufac(hidx,sdata,lbda=lbda)
print(length(ftmp$Fmod))  # Includes DC component (h=0)
print(ftmp)          # Amplitudes decrease with increasing
                     # resolution (Miller indices)
                  
# Now try with anomalous contributions
ftmp &lt;- strufac(hidx,sdata,lbda=lbda,anoflag=TRUE)
print(ftmp)  # DC component is not any longer real

</code></pre>

<hr>
<h2 id='write_h'>Write structure factors to a reflections file</h2><span id='topic+write_h'></span>

<h3>Description</h3>

<p>This function writes standardised structure factors data into an ASCII
file. The files includes cell size, space group character symbol and
Miller indices vector. It can include all of some of observed and/or
calculated structure factors amplitudes and phases, either for anomalous
or non-anomalous data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_h(filename, fdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_h_+3A_filename">filename</code></td>
<td>
<p>A character string. Prefix of the structure factors
file name. The file name has the form &quot;[prefix]_h.dat&quot;.</p>
</td></tr>
<tr><td><code id="write_h_+3A_fdata">fdata</code></td>
<td>
<p>A names list, usually created with functions 
<code><a href="#topic+standardise_fdata">standardise_fdata</a></code> or <code><a href="#topic+read_h">read_h</a></code>, and consisting of
the following fields:
</p>

<ul>
<li><p>a    Real numeric. Unit cell length in angstroms. Always 
included.
</p>
</li>
<li><p>SG.   Spacegroup 2-letters character string. There are only two 
symmetries possible when working within 1D 
crystallography, P1 (no symmetry) and P-1 (inversion 
through the origin). SG can be either &quot;P1&quot; or &quot;P-1&quot;. 
Always included.
</p>
</li>
<li><p>hidx. Real numeric array. 1D unique (positive in the 1D context) 
Miller indices. Always included.
</p>
</li>
<li><p>Fobs.      Real numeric array. Amplitudes of observed structure 
factors. Not always included.
</p>
</li>
<li><p>sigFobs.   Real numeric array. Errors associated with Fobs. Not 
always included.
</p>
</li>
<li><p>Fp.        Real numeric vector. Amplitudes of the positive 
component of Friedel (or Bijvoet) pairs (F+). Not
always included.
</p>
</li>
<li><p>sigFp.     Real numeric vector. Errors associated with Fp. 
Not always included.
</p>
</li>
<li><p>Fm.        Real numeric vector. Amplitudes of the negative 
component of Friedel (or Bijvoet) pairs (F-). Not always
included.
</p>
</li>
<li><p>sigFm.     Real numeric vector. Errors associated with Fm. Not
always included.
</p>
</li>
<li><p>Phiobs.    Real numeric array. Phases (in degrees) of structure 
factors obtained with one of the methods used for 
structure solution. Not always included.
</p>
</li>
<li><p>Phicalc.   Real numeric array. Phases (in degrees) of structure 
factors calculated from the correct 1D structure. 
They are normally used to check correctness of 
Phiobs. Not always included.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything, but will create an ASCII 
file of name *_h.dat which contains structure factors and other type of 
information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data from thiocyanate structure
datadir &lt;- system.file("extdata",package="crone")
filename &lt;- file.path(datadir,"thiocyanate_x.dat")
sdata &lt;- read_x(filename)

# Miller indices
hidx &lt;- 1:10

# Observed structure factors with errors
ltmp &lt;- sfobs(hidx,sdata)
Fobs &lt;- ltmp$F
sigFobs &lt;- ltmp$sF

# Phases from calculated structure factors
ftmp &lt;- strufac(hidx,sdata)
phicalc &lt;- ftmp$Fpha

# Create standardised fdata structure
fdata &lt;- standardise_fdata(sdata$a,sdata$SG,hidx,Fobs=Fobs,
                     sigFobs=sigFobs,Phicalc=phicalc)
 
# Name of structure factors file (in temporary directory)
wd &lt;- tempdir()
fname &lt;- file.path(wd,"test")

# Write data to file
write_h(fname,fdata)

</code></pre>

<hr>
<h2 id='write_x'>Write atomic coordinates to a file.</h2><span id='topic+write_x'></span>

<h3>Description</h3>

<p>Function to export all information concerning a given structure to a
so-called coordinates file of type *_x.dat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_x(filename, sdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_x_+3A_filename">filename</code></td>
<td>
<p>A character string. Prefix of the output ASCII file to
include all structural information. The file name will be &quot;[Prefix]_x.dat&quot;.</p>
</td></tr>
<tr><td><code id="write_x_+3A_sdata">sdata</code></td>
<td>
<p>A named list, normally obtained through the use of
function <code><a href="#topic+read_x">read_x</a></code>. The list names correspond to 
different object types:
</p>

<ul>
<li><p>a.     Real numeric. The size of the unit cell.
</p>
</li>
<li><p>SG.    Character string. Space group symbol; either &quot;P1&quot; 
or &quot;P-1&quot;
</p>
</li>
<li><p>x0.    Vector of real numerics indicating the expanded atomic
positions in the unit cell.
</p>
</li>
<li><p>Z.     Vector of integers indicating the expanded 
atomic numbers for all atoms in the unit cell.
</p>
</li>
<li><p>B.    Vector of real numerics indicating the expanded 
B factors for all atoms in the unit cell.
</p>
</li>
<li><p>occ.  Vector of real numerics indicating the expanded 
occupancies for all atoms in the unit cell.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything, but will create an ASCII 
file of name *_x.dat which contains all coordinates of the atoms in the 
structure and other type of information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an arbitrary structure in P1
a &lt;- 23
SG &lt;- "P1"
x0 &lt;- c(2,11,16,19)
Z &lt;- c(6,6,16,8)
B &lt;- c(13,14,5,10)
occ &lt;- c(1,1,1,1)
wd &lt;- tempdir()
prfx &lt;- file.path(wd,"test")
sdata &lt;- standardise_sdata(a,SG,x0,Z,B,occ)
write_x(prfx,sdata)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
