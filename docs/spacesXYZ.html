<!DOCTYPE html><html><head><title>Help for package spacesXYZ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spacesXYZ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapt'>
<p>Chromatic Adaptation Functions</p></a></li>
<li><a href='#adaptation'>
<p>Chromatic Adaptation Transforms (CATs)</p></a></li>
<li><a href='#Correlated Color Temperature'><p>Compute Correlated Color Temperature (CCT) and Points on the Planckian Locus</p></a></li>
<li><a href='#daylight'><p>Compute Points on the Daylight Locus, in multiple Chromaticity Spaces</p></a></li>
<li><a href='#DeltaE'><p>Calculate the Color Difference between Two Colors</p></a></li>
<li><a href='#fromPolar'><p>Convert CIE Lab and Luv from Polar Form to Rectangular Form</p></a></li>
<li><a href='#fromXYZ'><p>Convert from XYZ to other Color Spaces</p></a></li>
<li><a href='#Planckian Loci'><p>Planckian Loci - stored as Lookup Tables</p></a></li>
<li><a href='#spacesXYZ-package'><p>CIE XYZ and some of Its Derived Color Spaces</p></a></li>
<li><a href='#standardXYZ'><p>Query the Standardized XYZ and xy values of Standard Illuminants and Whitepoints</p></a></li>
<li><a href='#toPolar'><p>Convert CIE Lab and Luv to Polar Form</p></a></li>
<li><a href='#toXYZ'><p>Convert other Color Spaces to XYZ</p></a></li>
<li><a href='#uvfrom'><p>Convert from XYZ or xy to Uniform Chromaticity Spaces</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>CIE XYZ and some of Its Derived Color Spaces</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Glenn Davis [aut,cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Glenn Davis &lt;gdavis@gluonics.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for converting among CIE XYZ, xyY, Lab, and Luv.
      Calculate Correlated Color Temperature (CCT) and the Planckian and daylight loci.  
      The XYZs of some standard illuminants and some standard linear chromatic adaptation transforms (CATs) are included.
      Three standard color difference metrics are included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, microbenchmark</td>
</tr>
<tr>
<td>Enhances:</td>
<td>colorSpec</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 03:15:30 UTC; Glenn</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 05:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapt'>
Chromatic Adaptation Functions
</h2><span id='topic+adaptxyY.CAT'></span><span id='topic+adaptxyY'></span><span id='topic+adaptXYZ.CAT'></span><span id='topic+adaptXYZ'></span><span id='topic+adaptLab.CAT'></span><span id='topic+adaptLab'></span><span id='topic+adaptLuv.CAT'></span><span id='topic+adaptLuv'></span>

<h3>Description</h3>

<p>Adapt XYZ, xyY, Lab, or Luv from a source viewing enviroment with a given illuminant,
to a target viewing environment with a different illuminant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CAT'
adaptXYZ( x, XYZ.src )

## S3 method for class 'CAT'
adaptxyY( x, xyY.src )
## S3 method for class 'CAT'
adaptLab( x, Lab.src )
## S3 method for class 'CAT'
adaptLuv( x, Luv.src )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt_+3A_x">x</code></td>
<td>

<p>a <b>CAT</b> object as returned from <code><a href="#topic+CAT">CAT</a>()</code>
</p>
</td></tr>
<tr><td><code id="adapt_+3A_xyz.src">XYZ.src</code></td>
<td>

<p>an Nx3 matrix, or a vector that can be converted to such a matrix, by rows.
Each row has an XYZ in the source viewing environment.</p>
</td></tr>
<tr><td><code id="adapt_+3A_xyy.src">xyY.src</code></td>
<td>

<p>an Nx3 matrix, or a vector that can be converted to such a matrix, by rows.
Each row has an xyY in the source viewing environment.</p>
</td></tr>
<tr><td><code id="adapt_+3A_lab.src">Lab.src</code></td>
<td>

<p>an Nx3 matrix, or a vector that can be converted to such a matrix, by rows.
Each row has an Lab in the source viewing environment.</p>
</td></tr>
<tr><td><code id="adapt_+3A_luv.src">Luv.src</code></td>
<td>

<p>an Nx3 matrix, or a vector that can be converted to such a matrix, by rows.
Each row has an Luv in the source viewing environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adaptXYZ()</code> is the most fundamental of the group;
it simply multiplies each of the input XYZs by <code>x$M</code>.
</p>
<p><code>adaptxyY()</code> converts xyY.src to XYZ,
calls <code>adaptXYZ()</code>,
and then converts back to xyY.tgt.
And it does an additional check:
if the xy of xyY.src is equal to the xy of <code>x$source.xyY</code>,
then the xy of the returned xyY.tgt is set to be the xy of <code>x$target.xyY</code>.
</p>
<p><code>adaptLab()</code> and <code>adaptLuv()</code> work in a similar way.
When <code>Lab.src</code> is transformed to XYZ, the whitepoint is set to <code>x$source.XYZ</code>.
And when the adapted XYZ is transformed to adapted Lab, the whitepoint is set to <code>target.XYZ</code>.
</p>


<h3>Value</h3>

<p><code>adaptXYZ()</code> returns an Nx3 matrix with adapted XYZ.  
Each row has an XYZ in the target viewing environment.
<br />
<code>adaptxyY()</code> returns an Nx3 matrix with adapted xyY.
Each row has an xyY in the target viewing environment.
</p>
<p><code>adaptLab()</code> and <code>adaptLuv()</code> return adapted Lab and Luv respectively.
</p>


<h3>References</h3>

<p>Hunt, R. W. G.
<b>The Reproduction of Colour</b>.  6th Edition.
John Wiley &amp; Sons.
2004.
</p>
<p>International Color Consortium.
ICC.1:2001-04.
File Format for Color Profiles.
2001.
</p>
<p>Lindbloom, Bruce.
Chromatic Adaptation.
<a href="http://brucelindbloom.com/Eqn_ChromAdapt.html">http://brucelindbloom.com/Eqn_ChromAdapt.html</a>
</p>
<p>Wikipedia.
CIECAM02.
<a href="https://en.wikipedia.org/wiki/CIECAM02">https://en.wikipedia.org/wiki/CIECAM02</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAT">CAT</a>()</code>,
<code><a href="#topic+standardXYZ">standardXYZ</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># try the Bradford method
bCAT = CAT( 'D50', 'D65', method='bradford' )

adaptXYZ( bCAT, c(1,1,0.5) )
##               X         Y         Z
##  [1,] 0.9641191 0.9921559 0.6567701


adaptLab( bCAT, c(50,20,-10) )
##              L        a         b
##  [1,] 49.97396 20.84287 -10.19661      # as expected, there is a change

adaptLab( bCAT, c(40,0,0) )
##        L a b
##  [1,] 40 0 0   # but adaptLab() always preserves neutrals


adaptLuv( bCAT, c(40,0,0) )
##        L u v
##  [1,] 40 0 0   # and adaptLuv() also preserves neutrals



# try the scaling method - now XYZ are scaled independently
sCAT = CAT( 'D50', 'D65', method='scaling' )

adaptLab( sCAT, c(50,20,-10) )
##        L  a   b
##  [1,] 50 20 -10    with sCAT, adaptLab() is now the identity for *all* colors


adaptLuv( sCAT, c(50,-20,10) )
##        L         u        v
##  [1,] 50 -18.32244 11.29946    but adaptLuv() is NOT the identity for all colors
</code></pre>

<hr>
<h2 id='adaptation'>
Chromatic Adaptation Transforms (CATs)
</h2><span id='topic+CAT'></span>

<h3>Description</h3>

<p>Construct transforms from a source viewing enviroment with a given illuminant,
to a target viewing environment with a different illuminant.
Some standard linear von-Kries-based CAT methods are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAT( source.XYZ, target.XYZ, method="Bradford" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptation_+3A_source.xyz">source.XYZ</code></td>
<td>

<p>the XYZ of the illuminant in the source viewing environment.
<code>source.XYZ</code> can also be a string with the name of a standard illuminant
as in the function <code>standardXYZ()</code>.
</p>
</td></tr>
<tr><td><code id="adaptation_+3A_target.xyz">target.XYZ</code></td>
<td>

<p>the XYZ of the illuminant in the target viewing environment.
<code>target.XYZ</code> can also be a string with the name of a standard illuminant
as in the function <code>standardXYZ()</code>.
</p>
</td></tr>
<tr><td><code id="adaptation_+3A_method">method</code></td>
<td>

<p>the method used for the chromatic adaptation. Available methods are:
<code>"Bradford"</code>, <code>"VonKries"</code>, <code>"MCAT02"</code>, <code>"Bianco+Schettini"</code>,
and <code>"scaling"</code>;
see <b>References</b>.
Partial matching is enabled, and matching is case-insensitive.
<br />
<code>method</code> can also be a 3x3 matrix, which is the cone response matrix
used to construct a von-Kries-based CAT.
The matrix must be invertible and map both <code>source.XYZ</code> and <code>target.XYZ</code>
to the positive octant.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CAT()</code> returns an object with S3 class <b>CAT</b>, which can be passed to 
<code><a href="#topic+adaptXYZ">adaptXYZ</a>()</code>, 
<code><a href="#topic+adaptxyY">adaptxyY</a>()</code>, 
<code><a href="#topic+adaptLab">adaptLab</a>()</code>, or 
<code><a href="#topic+adaptLuv">adaptLuv</a>()</code>.
</p>
<p>An object with S3 class <b>CAT</b> is a list with the following items:
</p>

<dl>
<dt>method</dt><dd><p>full name of the adaptation method, as in <b>Arguments</b>.
If argument <code>method</code> is a 3x3 matrix, then this <code>method</code> is <code>NA</code>.</p>
</dd>
<dt>Ma</dt><dd><p>3x3 <em>cone response matrix</em> <code class="reqn">M_A</code> for the method, as defined in <cite>Lindbloom</cite></p>
</dd>
<dt>source.XYZ</dt><dd><p>XYZ of the illuminant in the source viewing environment</p>
</dd>
<dt>source.xyY</dt><dd><p>xyY of the illuminant in the source viewing environment</p>
</dd>
<dt>target.XYZ</dt><dd><p>XYZ of the illuminant in the target viewing environment</p>
</dd>
<dt>target.xyY</dt><dd><p>xyY of the illuminant in the target viewing environment</p>
</dd>
<dt>M</dt><dd><p>3x3 matrix defining the CAT.  
The matrix is written on the left and the source XYZ is
written as a column vector on the right.
This matrix depends continuously on source.XYZ and target.XYZ,
and when these are equal, M is the identity.
Therefore, when source.XYZ and target.XYZ are close, M is close to the identity.
Compare with <cite>Lindbloom</cite>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Chromatic adaptation can be viewed as an Aristotelian Analogy of Proportions.
For more about this, see the vignette
<a href="../doc/adaptation.html"><b>Chromatic Adaptation</b></a>.
</p>


<h3>References</h3>

<p>Bianco, Simone and Raimondo Schettini.
<b>Two new von Kries based chromatic adaptation transforms found by numerical optimization</b>.
Color Research &amp; Application.
v. 35. i. 3.
Jan 2010.
</p>
<p>Hunt, R. W. G.
<b>The Reproduction of Colour</b>.  6th Edition.
John Wiley &amp; Sons.
2004.
</p>
<p>International Color Consortium.
ICC.1:2001-04.
File Format for Color Profiles.
2001.
</p>
<p>Lindbloom, Bruce.
Chromatic Adaptation.
<a href="http://brucelindbloom.com/Eqn_ChromAdapt.html">http://brucelindbloom.com/Eqn_ChromAdapt.html</a>
</p>
<p>Pascale, Danny.
A Review of RGB Color Spaces ...from xyY to R'G'B'.
<a href="https://babelcolor.com/index_htm_files/A%20review%20of%20RGB%20color%20spaces.pdf">https://babelcolor.com/index_htm_files/A%20review%20of%20RGB%20color%20spaces.pdf</a>
2003.
</p>
<p>Wikipedia.
CIECAM02.
<a href="https://en.wikipedia.org/wiki/CIECAM02">https://en.wikipedia.org/wiki/CIECAM02</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardXYZ">standardXYZ</a>()</code>,
<code><a href="#topic+adaptXYZ">adaptXYZ</a>()</code>, 
<code><a href="#topic+adaptxyY">adaptxyY</a>()</code>, 
<code><a href="#topic+adaptLab">adaptLab</a>()</code>, 
<code><a href="#topic+adaptLuv">adaptLuv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D65toC = CAT( 'D65', 'C' )
D65toC

##  $method
##  [1] "Bradford"
##  
##  $Ma
##          X       Y       Z
##  L  0.8951  0.2664 -0.1614
##  M -0.7502  1.7135  0.0367
##  S  0.0389 -0.0685  1.0296
##  
##  $source.XYZ
##            X Y       Z
##  D65 0.95047 1 1.08883
##  
##  $source.xyY
##              x         y Y
##  D65 0.3127266 0.3290231 1
##  
##  $target.XYZ
##          X Y       Z
##  C 0.98074 1 1.18232
##  
##  $target.xyY
##            x         y Y
##  C 0.3100605 0.3161496 1
##  
##  $M
##              X            Y           Z
##  X 1.009778519  0.007041913 0.012797129
##  Y 0.012311347  0.984709398 0.003296232
##  Z 0.003828375 -0.007233061 1.089163878
##  
##  attr(,"class")
##  [1] "CAT"  "list"


adaptXYZ( D65toC, c(1,1,0.5) )
##              X         Y         Z
##  [1,] 1.023219 0.9986689 0.5411773
</code></pre>

<hr>
<h2 id='Correlated+20Color+20Temperature'>Compute Correlated Color Temperature (CCT) and Points on the Planckian Locus</h2><span id='topic+CCTfromXYZ'></span><span id='topic+CCTfromxy'></span><span id='topic+CCTfromuv'></span><span id='topic+planckLocus'></span>

<h3>Description</h3>

<p>Compute the CCT in Kelvin, of XYZ, xy, and uv, by multiple methods.
And compute points on the Planckian locus.
</p>
<p>The <em>reference</em> Planckian locus is defined spectrally - from
the famous equation for the Planckian radiator
(with <code class="reqn">c_2 = 1.4388 \times 10^{-2}</code>)
and from the tabulated CIE 1931 standard observer color matching functions,
from 360 to 830nm in 1nm steps.
The reference locus is a <code class="reqn">C^\infty</code> curve, parameterized by temperature,
in a 2D chromaticity space, 
usually either xy (1931) or uv (1960).
Computing uv values (and derivatives) is lengthy because there are 471 wavelengths.
An approximation to the reference locus is desirable.
</p>
<p>The default locus approximation is a spline
(using <code><a href="stats.html#topic+splinefun">stats::splinefun</a>()</code> with <code>method="fmm"</code>)
through the 31 uv locus points in <cite>Robertson</cite> and <cite>Wyszecki &amp; Stiles</cite>.
This spline does not appear in <cite>Robertson</cite>, but I think he would approve of it.
It has <code class="reqn">C^2</code> continuity and good agreement with the reference locus.
The maximum RMS error in the uv-plane is about <code class="reqn">7.3 \times 10^{-6}</code>
over the valid temperature interval [1667,<code class="reqn">\infty</code>] K.
A similar piecewise-linear interpolating path has a maximum RMS error about 10 times larger.
The 31 uv values in the table are accurate to the given 5 decimal places
(but see <b>Note</b>), and the rounding to 5 places is a big limitation in accuracy.
The locus is parameterized directly by reciprocal color temperature (<code class="reqn">10^6/T</code>),
and therefore indirectly by <code class="reqn">T</code>.
We call either of these the <em>native pameterization</em> of the locus.
See <a href="#topic+RobertsonLocus">Planckian Loci</a>.
The lines that are perpendicular to the locus are called the <em>native isotherms</em>.
</p>
<p>The second available locus is a quintic spline through 65 points (knots),
that were computed and saved with full precision.
The maximum RMS error in the uv-plane is about <code class="reqn">7.2 \times 10^{-12}</code>
over the valid temperature interval [1000,<code class="reqn">\infty</code>] K.
For this one the 1st and 2nd derivatives were also computed,
so the normal vectors at the knots are accurate,
and the curve is also <code class="reqn">C^2</code>.
See <a href="#topic+RobertsonLocus">Planckian Loci</a>.
The lines that are perpendicular to the locus are also called the <em>native isotherms</em>.
</p>
<p>Two more families of isotherms are available.
The <cite>Robertson</cite> isotherms are tabulated just like the points on the locus,
and a special linear interpolation is used for intermediate temperatures.
The <cite>McCamy</cite> isotherms are defined by a single cubic rational function in xy,
and no interpolation is necessary. 
Each isotherm family <em>induces</em> a slightly different parameterization of the locus -
the temperature at a locus point is the temperature of the isotherm
passing through that point.
<br />
The Robertson parameterization is only continuous of class <code class="reqn">C^0</code>,
but the <em>geometric continuity</em> class is <code class="reqn">G^2</code>.
The McCamy parameterization is as smooth as the locus itself, which is <code class="reqn">C^2</code>.
<br />
For the Robertson parameterization the 
valid temperature interval is [1667,<code class="reqn">\infty</code>] K.
For the McCamy parameterization the valid temperature interval
is at most [1621,34530] K, and may be smaller depending on the locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCTfromXYZ( XYZ, isotherms='robertson',  locus='robertson', strict=FALSE )
CCTfromxy( xy, isotherms='robertson',  locus='robertson', strict=FALSE )
CCTfromuv( uv, isotherms='robertson', locus='robertson', strict=FALSE )

planckLocus( temperature, locus='robertson', param='robertson', delta=0, space=1960 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_xyz">XYZ</code></td>
<td>
<p>a numeric Mx3 matrix with XYZ tristimulus values (CIE 1931) in the rows,
or a numeric vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_xy">xy</code></td>
<td>
<p>a numeric Mx2 matrix with xy chromaticity values (CIE 1931) in the rows,
or a numeric vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_uv">uv</code></td>
<td>
<p>a numeric Mx2 matrix with uv chromaticity values (CIE UCS 1960) in the rows,
or a numeric vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_isotherms">isotherms</code></td>
<td>
<p>A character vector whose elements match one
of the available isotherm families:
<code>'robertson'</code>, <code>'mccamy'</code>, and <code>'native'</code>.
Matching is partial and case-insensitive.
When more than one family is given, a matrix is returned, see <b>Value</b>.
When <code>isotherms='native'</code> the isotherms are defined implicitly
as lines perpendicular to the locus, see <b>Details</b>.
The character <code>NA</code> (<code>NA_character_</code>) is taken as
a synonym for <code>'native'</code>.
</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_locus">locus</code></td>
<td>

<p>valid values are <code>'robertson'</code> and <code>'precision'</code>, see above.
Matching is partial and case-insensitive.
</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_strict">strict</code></td>
<td>
<p>The CIE considers the CCT of a chromaticity <code>uv</code> to be meaningful only
if the distance from <code>uv</code> to the Planckian locus is less than or equal to 0.05 
[in CIE UCS 1960].
If <code>strict=FALSE</code>, then this condition is ignored.
Otherwise, the distance is computed along the corresponding isotherm,
and if it exceeds 0.05 the returned CCT is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_temperature">temperature</code></td>
<td>
<p>a M-vector of temperatures (in K) at which to compute points on the 
Planckian locus, either for <code>uv</code>, <code>u'v'</code>, or <code>xy</code>; see <code>space</code>.
</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_param">param</code></td>
<td>
<p>the desired parameterization of the locus.
It can be either <code>'native'</code>, or a parameterization induced by the
<code>'robertson'</code> or <code>'mccamy'</code> isotherms.
The character <code>NA</code> (<code>NA_character_</code>) is taken as
a synonym for <code>'native'</code>.
</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_delta">delta</code></td>
<td>
<p>a vector of offset distances in <code>uv</code> (CIE UCS 1960), 
along the corresponding isotherms, from the locus.
Positive offsets are above the locus, and negative are below.
<code>delta</code> can have length M or 1, where M is the length of <code>temperature</code>.
If <code>delta</code> has length 1, that value is replicated to length M.
</p>
</td></tr>
<tr><td><code id="Correlated+2B20Color+2B20Temperature_+3A_space">space</code></td>
<td>
<p>the year of the chromaticity space to return.
Valid values are 1960 (the default <code>uv</code>),
1976 (<code>u'v'</code>), and 1931 (<code>xy</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the isotherm families correspond to a parameterization of the locus.
All this is designed so a round trip:
temperature   &rarr;   uv     &rarr;   CCT
(with the same choice of isotherm/parameterization)
has neglible error.
</p>
<p>When <code>isotherms='native'</code>
the tangent line at a point on the locus is computed using the <code>deriv=1</code> argument to
<code><a href="stats.html#topic+splinefun">stats::splinefun</a>()</code>
and the normal line - the isotherm at the point - is then easily computed from the tangent line.
</p>
<p>When <code>isotherms='robertson'</code> or <code>isotherms='mccamy'</code> the locus curve
has no effect on the computed CCT.
The locus is only used when computing the distance from the given uv point to the locus
(along the corresponding isotherm),
and therefore only affects the decision whether the CCT is meaningful
when <code>strict=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>CCTfromXYZ()</code>, <code>CCTfromxy()</code>, and <code>CCTfromuv()</code> 
return a numeric vector of length M, or an MxN matrix.
It returns a matrix iff <code>length(isotherms) = N</code> <code class="reqn">\ge</code> 2,
and the column names are set to the isotherm family names.
The names or rownames are set to the rownames of the input.
In case of error, the element of the vector or matrix is set to <code>NA_real_</code>.
In case there is an error in the arguments, the functions return <code>NULL</code>.
In these functions, the locus is not used unless
<code>isotherms='native'</code> or <code>strict=TRUE</code>.
</p>
<p><code>planckLocus()</code> returns an Mx2 matrix with chromaticies in the rows.
The column names are set appropriately for the value of <code>space</code>.
The row names are set from <code>temperature</code>.
In case of a single error, both entries in the row are set to <code>NA_real_</code>.
In case there is an error in the arguments, the functions return <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The lookup table on page 228 in <cite>Wyszecki &amp; Stiles</cite>
contains an error at 325 mired,
which was corrected by Bruce Lindbloom (see <b>Source</b>).
</p>


<h3>Source</h3>

<p><a href="http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_T.html">http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_T.html</a>
</p>


<h3>References</h3>

<p>McCamy, C. S.
<em>Correlated color temperature as an explicit function of chromaticity coordinates</em>.
Color Research &amp; Application.
Volume 17.
Issue 2.
pages 142-144.
April 1992.
</p>
<p>Robertson, A. R.
Computation of correlated color temperature and distribution temperature.
Journal of the Optical Society of America.
58. pp. 1528-1535 (1968).
</p>
<p>Wyszecki, G端nther and W. S. Stiles.
<b>Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition.</b>
John Wiley &amp; Sons, 1982.
Table 1(3.11). pp. 227-228.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+splinefun">stats::splinefun</a>()</code>,
<code><a href="colorSpec.html#topic+computeCCT">colorSpec::computeCCT</a>()</code>,
<code><a href="#topic+RobertsonLocus">RobertsonLocus</a></code>,
<code><a href="#topic+PrecisionLocus">PrecisionLocus</a></code>,
the vignette <a href="../doc/isotherms.pdf"><b>Correlated Color Temperature Isotherms</b></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do a round trip and then compare
temperature = c(5003,6504)
uv  = planckLocus( temperature, delta=0.05 )
CCTfromuv( uv ) - temperature  
##  2.772227e-05 5.094369e-05 

# find some points on the daylight locus, and then their CCT
temperature = seq( 2000, 10000, by=1000 )
xy = daylightLocus( temperature )
cbind( xy, CCT=CCTfromxy(xy,iso='mccamy') )
##                x         y      CCT
## D2000         NA        NA       NA
## D3000         NA        NA       NA
## D4000  0.3823436 0.3837663 4005.717
## D5000  0.3457410 0.3586662 4999.998
## D6000  0.3216915 0.3377984 5999.437
## D7000  0.3053570 0.3216459 6997.542
## D8000  0.2937719 0.3092195 7985.318
## D9000  0.2852645 0.2995816 8948.809
## D10000 0.2787996 0.2919672 9881.115

# compare all 3 different isotherms
CCTfromxy( xy, isotherms=c('robertson',NA,'mccamy') )
##        Robertson   native   McCamy
## D2000         NA       NA       NA
## D3000         NA       NA       NA
## D4000   4000.096 4000.062 4005.717
## D5000   4999.749 4999.608 4999.998
## D6000   5998.015 5999.242 5999.437
## D7000   6997.858 6998.258 6997.542
## D8000   7997.599 7996.985 7985.318
## D9000   8999.301 8993.811 8948.809
## D10000  9991.920 9992.672 9881.115

cbind( default=CCTfromxy(xy), prec.native=CCTfromxy(xy,locus='prec',iso=NA) )
##         default prec.native
## 2000K        NA          NA
## 3000K        NA          NA
## 4000K  4000.096    4000.052
## 5000K  4999.749    4999.767
## 6000K  5998.015    5999.097
## 7000K  6997.858    6997.857
## 8000K  7997.599    7997.951
## 9000K  8999.301    8995.835
## 10000K 9991.920    9992.839
</code></pre>

<hr>
<h2 id='daylight'>Compute Points on the Daylight Locus, in multiple Chromaticity Spaces</h2><span id='topic+daylightLocus'></span>

<h3>Description</h3>

<p>Compute points on the daylight locus, in multiple chromaticity spaces</p>


<h3>Usage</h3>

<pre><code class='language-R'>daylightLocus( temperature, space=1931 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daylight_+3A_temperature">temperature</code></td>
<td>
<p>an M-vector of temperatures (in K) at which to compute points on the 
daylight locus.
The valid temperatures range is 4000K to 25000K;
outside this range the output is set to <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="daylight_+3A_space">space</code></td>
<td>
<p>the year of the output chromaticity space desired - valid values are
1931, 1976 and 1960.
The 1931 is the original and denoted by xy;  the others are derived from it.
The 1960 coordinates are usually denoted by uv,
and the 1976 coordinates by u'v'.
The only difference is that <code class="reqn">v' = (3/2) v</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric Mx2 matrix with xy, uv, or u'v' coordinates in the rows.
The colnames of the output are set appropriately.
</p>
<p>The names of the temperature are copied to the rownames of the output,
unless these names are <code>NULL</code> when the temperatures followed by 'K' are used.
</p>
<p>If the input is invalid, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Wyszecki, G端nther and W. S. Stiles.
<b>Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition.</b>
John Wiley &amp; Sons, 1982.
pp. 145-146.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uvfromxy">uvfromxy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># find some points on the daylight locus, and then their CCT
temp = seq( 2000, 10000, by=1000 )
xy = daylightLocus( temp )
cbind( xy, CCT=CCTfromxy(xy) )
##                x         y      CCT
## D2000         NA        NA       NA
## D3000         NA        NA       NA
## D4000  0.3823436 0.3837663 4000.096
## D5000  0.3457410 0.3586662 4999.749
## D6000  0.3216915 0.3377984 5998.015
## D7000  0.3053570 0.3216459 6997.858
## D8000  0.2937719 0.3092195 7997.599
## D9000  0.2852645 0.2995816 8999.301
## D10000 0.2787996 0.2919672 9991.920
</code></pre>

<hr>
<h2 id='DeltaE'>Calculate the Color Difference between Two Colors</h2><span id='topic+DeltaE'></span>

<h3>Description</h3>

<p>Calculate Standard CIE Color Differences between two Colors 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaE( Lab1, Lab2, metric=1976 ) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeltaE_+3A_lab1">Lab1</code></td>
<td>
<p>a numeric Nx3 matrix with Lab values in the rows, or a vector that can be converted to such a matrix, by row.
<code>Lab1</code> can also be a numeric 3-vector with a single Lab, and it is then replicated
to match the size of <code>Lab2</code>.
</p>
</td></tr>
<tr><td><code id="DeltaE_+3A_lab2">Lab2</code></td>
<td>
<p>a numeric Nx3 matrix with Lab values in the rows, or a vector that can be converted to such a matrix, by row.
<code>Lab2</code> can also be a numeric 3-vector with a single Lab, and it is then replicated
to match the size of <code>Lab1</code>.
</p>
</td></tr>
<tr><td><code id="DeltaE_+3A_metric">metric</code></td>
<td>
<p>a vector of color metric specifiers.
Valid values are <code>'1976'</code>, <code>'1994'</code>, and <code>'2000'</code>, 
which refer to the year the metric was recommended by the CIE.
They can also be given as integers, as shown.
These metrics are often denoted 
<code class="reqn">\Delta E_{1976}</code>, <code class="reqn">\Delta E_{1994}</code>, and <code class="reqn">\Delta E_{2000}</code>.
When more than one metric is given, a matrix is returned, see <b>Value</b>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DeltaE()</code> returns a numeric vector of length N, or an NxM matrix.
It returns a matrix iff <code>length(metric)=</code> M<code class="reqn">\ge</code> 2;
the column names are set to the metric names.
The elements of the output are the pairwise differences, 
i.e. between row i of <code>Lab1</code> and  row i of <code>Lab2</code>.
The names or rownames are set to the rownames of one of the input matrices.
</p>
<p>For <code>metric=1976</code>
the distance is simply the Euclidean distance between the two points in Lab, see <cite>Hunt</cite> p. 111.
<br />
For <code>metric=1994</code> the symmetric variant is used, see <cite>Hunt</cite> p. 670.
There is an asymmetric variant which is not available in this package.
The weighting coefficients are for <b>graphic arts</b> (not for <b>textiles</b>).
<br />
For <code>metric=2000</code> the distance is insanely complicated, see <cite>Hunt</cite> p. 671.
<br />
All these metrics are <em>symmetric</em>,
which means that swapping <code>Lab1</code> and <code>Lab2</code> does not change the result.
</p>


<h3>References</h3>

<p>Hunt, R. W. G.
<b>The Reproduction of Colour</b>.  6th Edition.
John Wiley &amp; Sons.
2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DeltaE( c(50,0,0),  c(51,2,2,  52,10,11,  46,-13,16)  )
## [1]  3 15 21

path = system.file( "extdata/ciede2000testdata.txt", package='spacesXYZ' )
df   = read.table( path, sep='\t', quote='', head=TRUE )
Lab1 = as.matrix( df[ , 1:3 ] )
Lab2 = as.matrix( df[ , 4:6 ] )
cbind( Lab1, Lab2, DeltaE( Lab1, Lab2, metric=c(1976,2000) ) )[ 1:10, ]

##       LAB_L_REF LAB_A_REF LAB_B_REF LAB_L_SAM LAB_A_SAM LAB_B_SAM DeltaE.1976 DeltaE.2000
##  [1,]   50.0000    2.6772  -79.7751   50.0000    0.0000  -82.7485   4.0010633   2.0424597
##  [2,]   50.0000    3.1571  -77.2803   50.0000    0.0000  -82.7485   6.3141501   2.8615102
##  [3,]   50.0000    2.8361  -74.0200   50.0000    0.0000  -82.7485   9.1776999   3.4411906
##  [4,]   50.0000   -1.3802  -84.2814   50.0000    0.0000  -82.7485   2.0627008   0.9999989
##  [5,]   50.0000   -1.1848  -84.8006   50.0000    0.0000  -82.7485   2.3695707   1.0000047
##  [6,]   50.0000   -0.9009  -85.5211   50.0000    0.0000  -82.7485   2.9152927   1.0000130
##  [7,]   50.0000    0.0000    0.0000   50.0000   -1.0000    2.0000   2.2360680   2.3668588
##  [8,]   50.0000   -1.0000    2.0000   50.0000    0.0000    0.0000   2.2360680   2.3668588
##  [9,]   50.0000    2.4900   -0.0010   50.0000   -2.4900    0.0009   4.9800004   7.1791720
## [10,]   50.0000    2.4900   -0.0010   50.0000   -2.4900    0.0010   4.9800004   7.1791626
</code></pre>

<hr>
<h2 id='fromPolar'>Convert CIE Lab and Luv from Polar Form to Rectangular Form</h2><span id='topic+LabfromLCHab'></span><span id='topic+LuvfromLCHuv'></span>

<h3>Description</h3>

<p>Convert the Polar Form of CIE Lab and Luv to Rectangular Form</p>


<h3>Usage</h3>

<pre><code class='language-R'>LabfromLCHab( LCHab ) 
LuvfromLCHuv( LCHuv ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromPolar_+3A_lchab">LCHab</code></td>
<td>
<p> a numeric Nx3 matrix with CIE LCHab coordinates in the rows, or a vector that can be converted to such a matrix, by row.  The hue angle H must be in degrees.</p>
</td></tr>
<tr><td><code id="fromPolar_+3A_lchuv">LCHuv</code></td>
<td>
<p> a numeric Nx3 matrix with CIE LCHuv coordinates in the rows, or a vector that can be converted to such a matrix, by row.  The hue angle H must be in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>LabfromLCHab()</code></td>
<td>
<p> returns a numeric Nx3 matrix with CIE Lab coordinates in the rows.
</p>
</td></tr>
<tr><td><code>LuvfromLCHuv()</code></td>
<td>
<p> returns a numeric Nx3 matrix with CIE Luv coordinates in the rows.
</p>
</td></tr>
</table>
<p>In both cases, the rownames are copied from input to output.
If the input is invalid, the functions return <code>NULL</code>.
</p>


<h3>References</h3>

<p>Wikipedia.
CIE 1931 color space.
<a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCHabfromLab">LCHabfromLab</a>()</code>,
<code><a href="#topic+LCHuvfromLuv">LCHuvfromLuv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LabfromLCHab( c(50,10,45) ) 
##        L        a        b
##  [1,] 50 7.071068 7.071068     #  on line with slope 1
</code></pre>

<hr>
<h2 id='fromXYZ'>Convert from XYZ to other Color Spaces</h2><span id='topic+xyYfromXYZ'></span><span id='topic+LabfromXYZ'></span><span id='topic+LuvfromXYZ'></span>

<h3>Description</h3>

<p>Convert from XYZ to other Color Spaces</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyYfromXYZ( XYZ ) 
LabfromXYZ( XYZ, white ) 
LuvfromXYZ( XYZ, white ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromXYZ_+3A_xyz">XYZ</code></td>
<td>
<p> a numeric Nx3 matrix with CIE XYZ coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="fromXYZ_+3A_white">white</code></td>
<td>
<p>a numeric 3-vector giving the XYZ of reference white; all 3 numbers must be positive.
<code>white</code> can also be a character string with the name of a standard illuminant,
which is passed to <code><a href="#topic+standardXYZ">standardXYZ</a>()</code> to get the XYZ.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>xyYfromXYZ()</code></td>
<td>
<p> returns a numeric Nx3 matrix with CIE xyY coordinates in the rows.
If the sum <code>X+Y+Z==0</code>, <code>xy</code> are set to <code>NA</code>.
</p>
</td></tr>
<tr><td><code>LabfromXYZ()</code></td>
<td>
<p> returns a numeric Nx3 matrix with CIE Lab coordinates in the rows</p>
</td></tr>
<tr><td><code>LuvfromXYZ()</code></td>
<td>
<p> returns a numeric Nx3 matrix with CIE Luv coordinates in the rows</p>
</td></tr>
</table>
<p>In all cases, the rownames are copied from input to output.
If the input is invalid, the functions return <code>NULL</code>.
</p>


<h3>References</h3>

<p>Wikipedia.
CIE 1931 color space.
<a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardXYZ">standardXYZ</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D65 = standardXYZ( 'D65' )

xyYfromXYZ( D65 )
##              x         y Y
##  D65 0.3127266 0.3290231 1     # probably not familiar

round( xyYfromXYZ(D65), 4 )
##           x     y Y
##  D65 0.3127 0.329 1        # probably more familiar


LabfromXYZ( 0.18*D65, D65 )   # 18% gray card
##             L a b
##  D65 49.49611 0 0          # exactly neutral, and L is about 50


D50 = standardXYZ( 'D50' )

LabfromXYZ( D50, D65 )
##        L        a        b
##  D50 100 2.399554 17.65321   # D50 is far from neutral (yellowish) in D65 viewing environment
</code></pre>

<hr>
<h2 id='Planckian+20Loci'>Planckian Loci - stored as Lookup Tables</h2><span id='topic+RobertsonLocus'></span><span id='topic+PrecisionLocus'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>RobertsonLocus</code> </td><td style="text-align: left;"> the table from Robertson, with 31 points from 0 to 600 mired </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>PrecisionLocus</code> </td><td style="text-align: left;"> a precomputed table, with 65 points from 0 to 1000 mired </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>Both objects are <code>data.frame</code>s with these columns
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>mired</code>  </td><td style="text-align: left;"> the reciprocal temperature <code class="reqn">10^6/T</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>u</code>      </td><td style="text-align: left;"> the u chromaticity, in 1960 CIE </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v</code>      </td><td style="text-align: left;"> the v chromaticity, in 1960 CIE </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>PrecisionLocus</code>  <code>data.frame</code>  has these additional columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>up</code>  </td><td style="text-align: left;"> the 1st derivative of <code>u</code> with respect to <code>mired</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vp</code>  </td><td style="text-align: left;"> the 1st derivative of <code>v</code> with respect to <code>mired</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>upp</code> </td><td style="text-align: left;"> the 2nd derivative of <code>u</code> with respect to <code>mired</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vpp</code> </td><td style="text-align: left;"> the 2nd derivative of <code>v</code> with respect to <code>mired</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>For <code>RobertsonLocus</code>, the values are taken from
<cite>Wyszecki &amp; Stiles</cite>.
The lookup table on page 228 
contains an error at 325 mired,
which was corrected by Bruce Lindbloom (see <b>Source</b>).
</p>
<p>For <code>PrecisionLocus</code>, the chromaticity values <code>u</code> and <code>v</code>
are computed from first principles, 
from the famous equation for the Planckian radiator
(with <code class="reqn">c_2 = 1.4388 \times 10^{-2}</code>)
and from the tabulated CIE 1931 standard observer color matching functions,
by summing from 360 to 830nm.
Let <code class="reqn">\beta</code> denote the reciprocal temperature <code class="reqn">10^6/T</code>.
We think of <code>u</code> as a function <code class="reqn">u(\beta)</code>.
The column <code>up</code> is <code class="reqn">u'(\beta)</code>, and <code>upp</code> is <code class="reqn">u''(\beta)</code>.
And similarly for <code>v</code>.
The derivatives are computed from first principles, by summing the derivatives
of the Planckian formula from 360 to 830nm.
This includes the limiting case <code class="reqn">\beta=0</code>.
</p>
<p>When this package is loaded (during <code>.onLoad()</code>),
cubic splines are computed from <code>RobertsonLocus</code>,
using <code><a href="stats.html#topic+splinefun">stats::splinefun</a>()</code> with <code>method="fmm"</code>).
And quintic splines are computed from <code>PrecisionLocus</code>.
Both splines are <code class="reqn">C^2</code> continuous.
</p>


<h3>Source</h3>

<p><a href="http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_T.html">http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_T.html</a>
</p>


<h3>References</h3>

<p>Robertson, A. R.
Computation of correlated color temperature and distribution temperature.
Journal of the Optical Society of America.
58. pp. 1528-1535. 1968.
</p>
<p>Wyszecki, G端nther and W. S. Stiles.
<b>Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition.</b>
John Wiley &amp; Sons, 1982.
Table 1(3.11). pp. 227-228.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCTfromuv">CCTfromuv</a>()</code>,
<code><a href="#topic+planckLocus">planckLocus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RobertsonLocus[ 1:10, ]
##    mired       u       v
## 1      0 0.18006 0.26352
## 2     10 0.18066 0.26589
## 3     20 0.18133 0.26846
## 4     30 0.18208 0.27119
## 5     40 0.18293 0.27407
## 6     50 0.18388 0.27709
## 7     60 0.18494 0.28021
## 8     70 0.18611 0.28342
## 9     80 0.18740 0.28668
## 10    90 0.18880 0.28997

PrecisionLocus[ 1:10, ]
##    mired         u         v           up           vp          upp          vpp
## 1      0 0.1800644 0.2635212 5.540710e-05 0.0002276279 7.115677e-07 1.977793e-06
## 2     10 0.1806553 0.2658948 6.291429e-05 0.0002469232 7.900243e-07 1.873208e-06
## 3     20 0.1813253 0.2684554 7.120586e-05 0.0002649377 8.679532e-07 1.722425e-06
## 4     30 0.1820820 0.2711879 8.026143e-05 0.0002812384 9.423039e-07 1.531723e-06
## 5     40 0.1829329 0.2740733 9.002982e-05 0.0002954676 1.010028e-06 1.309700e-06
## 6     50 0.1838847 0.2770894 1.004307e-04 0.0003073613 1.068393e-06 1.066350e-06
## 7     60 0.1849432 0.2802122 1.113592e-04 0.0003167582 1.115240e-06 8.120582e-07
## 8     70 0.1861132 0.2834161 1.226923e-04 0.0003235990 1.149155e-06 5.566812e-07
## 9     80 0.1873980 0.2866757 1.342971e-04 0.0003279171 1.169532e-06 3.088345e-07
## 10    90 0.1887996 0.2899664 1.460383e-04 0.0003298241 1.176525e-06 7.543963e-08
</code></pre>

<hr>
<h2 id='spacesXYZ-package'>CIE XYZ and some of Its Derived Color Spaces</h2><span id='topic+spacesXYZ-package'></span>

<h3>Description</h3>

<p>This package covers the basic CIE 1931 space, and derived spaces CIE xyY, Lab, and Luv.
The equations are taken from Bruce Lindbloom's <cite>CIE Color Calculator</cite>.
Color areas that are *not* covered are:
</p>

<ul>
<li><p> spectral color data
</p>
</li>
<li><p> device color spaces, e.g. RGB and CMYK
</p>
</li>
<li><p> color order systems, e.g. Munsell, DIN, NCS, Ostwald, ...
</p>
</li></ul>



<h3>The API</h3>

<p>The API is small.  There are functions to
</p>

<ul>
<li><p> convert between CIE XYZ and other CIE spaces
</p>
</li>
<li><p> create and perform some standard chromatic adaptation transforms (CATs)
</p>
</li>
<li><p> compute 3 standard color difference <code class="reqn">\Delta</code>E metrics
</p>
</li>
<li><p> retrieve XYZ and xy of some standard illuminants
</p>
</li></ul>



<h3>Other Packages</h3>

<p>Package <span class="pkg">colorscience</span> is a superset of this one.
<br />
Package <span class="pkg">colorspace</span> has similar functionality, and is much faster because it in compiled C.
<br />
Package <span class="pkg">grDevices</span> also has similar functionality
(in the function <code><a href="grDevices.html#topic+convertColor">convertColor</a>()</code>),
but is missing chromaticities xy, uv, and u'v'.
</p>


<h3>Author(s)</h3>

<p>Glenn Davis &lt;gdavis@gluonics.com&gt;
</p>


<h3>References</h3>

<p>Lindbloom, Bruce.
<b>CIE Color Calculator</b>.
<a href="http://brucelindbloom.com/index.html?ColorCalculator.html">http://brucelindbloom.com/index.html?ColorCalculator.html</a>
</p>
<p>Lindbloom, Bruce.
<b>Color Difference Calculator</b>.
<a href="http://brucelindbloom.com/index.html?ColorDifferenceCalc.html">http://brucelindbloom.com/index.html?ColorDifferenceCalc.html</a>
</p>

<hr>
<h2 id='standardXYZ'>Query the Standardized XYZ and xy values of Standard Illuminants and Whitepoints</h2><span id='topic+standardXYZ'></span><span id='topic+standardxy'></span>

<h3>Description</h3>

<p>In careful calcuations with standard illuminants and whitepoints,
it is often helpful to have the 'official' values of XYZ and xy,
i.e. with the right number of decimal places.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardXYZ( name )

standardxy( name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardXYZ_+3A_name">name</code></td>
<td>
<p>a subvector of
<code>c('A','B','C','C.NBS','C.NTSC','C.JOSA','D50','D50.ICC',</code><br />
<code>'D55','D60','D65','D75','E','F2','F7','F11','ACES','DCI')</code>, 
which are the names of some standard illuminants and white points.
Matching is partial and case-insensitive.
<br />
<code>name</code> can also be <code>NULL</code> or <code>'*'</code> which
means to return <em>all</em> available data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All XYZ values are taken from the ASTM publication in <b>References</b>,
except <code>B</code> which is taken from <cite>Wyszecki &amp; Stiles</cite>
and <code>D50.ICC</code> which is taken from ICC publications.
</p>
<p>xy values were taken from <cite>CIE</cite>, <cite>BT.709</cite>, <cite>SMPTE EG 432-1</cite>,
and <cite>TB-2018-001</cite>.
For D65 the values in <cite>CIE</cite> and <cite>BT.709</cite> disagree;
the former has 5 digits and the latter has 4.
We have selected the value in <cite>BT.709</cite> (page 3) since is far more commonly used.
Three of the Illuminant C variants are rarely used and obsolete.
</p>


<h3>Value</h3>

<p><code>standardXYZ()</code> returns
an Mx3 matrix where M is the length of <code>name</code>.
But if <code>name</code> is <code>NULL</code> or <code>'*'</code>, M is the number of records available.
Each row filled with the official XYZ, but if the illuminant name is not recognized
or if there is no data, the row is all <code>NA</code>s.
The output XYZ is normalized so that <code>Y=1</code>.
The matrix <code>rownames</code> are set to the full illuminant names, and <code>colnames</code> to <code>c('X','Y','Z')</code>.
</p>
<p>Similarly, <code>standardxy()</code> returns an Mx2 matrix 
with <code>colnames</code> set to <code>c('x','y')</code>.
</p>


<h3>Warning</h3>

<p>The returned XYZs are normalized so that Y=1.
In other color domains, it is common to normalize so that Y=100;
in these cases be sure to multiply by 100.
</p>
<p>Some illuminants have no standard XYZ available and some have no standard xy.
In these cases, the rows are filled with NAs.
</p>


<h3>References</h3>

<p>ASTM E 308 - 01.
Standard Practice for Computing the Colors of Objects by Using the CIE System.
2001.
</p>
<p>BT.709.
Parameter values for the HDTV standards for production and international programme exchange.
June 2015.
</p>
<p>CIE 015:2004 - Colorimetry, 3rd edition.
International Commission on Illumination (CIE).
Vienna Austria. 
Technical Report.
2004.
</p>
<p>G端nther Wyszecki and W. S. Stiles.
Color Science: Concepts and Methods, Quantitative Data and Formulae, Second Edition.
John Wiley &amp; Sons, 1982.
Table I(3.3.8) p. 769.
</p>
<p>TB-2018-001.
<b>Derivation of the ACES White Point CIE Chromaticity Coordinates</b>.
The Academy of Motion Picture Arts and Sciences.
Science and Technology Council.
Academy Color Encoding System (ACES) Project.
June 15, 2018.
</p>
<p>SMPTE RP 431-2.
<b>D-Cinema Quality - Reference Projector and Environment for the Display of DCDM in Review Rooms and Theaters</b>.
2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>standardXYZ( c('a','d50','D50.ICC','D65') ) 
#                 X Y         Z
# A       1.0985000 1 0.3558500
# D50     0.9642200 1 0.8252100
# D50.ICC 0.9642029 1 0.8249054
# D65     0.9504700 1 1.0888300

standardxy( c('a','D65','D60','D60.ACES','E','F2') )
#                x       y
# A        0.44758 0.40745
# D65      0.31270 0.32900
# D60      0.32163 0.33774
# D60.ACES 0.32168 0.33767
# E        0.33333 0.33333
# F2            NA      NA
</code></pre>

<hr>
<h2 id='toPolar'>Convert CIE Lab and Luv to Polar Form</h2><span id='topic+LCHabfromLab'></span><span id='topic+LCHuvfromLuv'></span>

<h3>Description</h3>

<p>Convert the Rectangular Form of CIE Lab and Luv to Polar Form</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCHabfromLab( Lab ) 
LCHuvfromLuv( Luv ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toPolar_+3A_lab">Lab</code></td>
<td>
<p> a numeric Nx3 matrix with CIE Lab coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="toPolar_+3A_luv">Luv</code></td>
<td>
<p> a numeric Nx3 matrix with CIE Luv coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric Nx3 matrix with LCH coordinates in the rows.
The lightness L is simply copied from input to output.
The chroma C corresponds to radius in polar coordinates,
and the hue H corresponds to theta.
H is in degrees, not radians.
The rownames are copied from input to output.
</p>


<h3>References</h3>

<p>Wikipedia.
CIE 1931 color space.
<a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LabfromLCHab">LabfromLCHab</a>()</code>,
<code><a href="#topic+LuvfromLCHuv">LuvfromLCHuv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LCHabfromLab( c(50,0,0) )   #  a neutral gray
##        L Cab Hab
##  [1,] 50   0   0         # Hue is undefined, but set to 0

LCHabfromLab( c(50,0,20) ) 
##        L Cab Hab
##  [1,] 50  20  90         # 90 degrees, on yellow axis


LCHabfromLab( c(50,0,-20) ) 
##        L Cab Hab
##  [1,] 50  20 270         # 270 degrees, on blue axis

</code></pre>

<hr>
<h2 id='toXYZ'>Convert other Color Spaces to XYZ</h2><span id='topic+XYZfromxyY'></span><span id='topic+XYZfromLab'></span><span id='topic+XYZfromLuv'></span>

<h3>Description</h3>

<p>Convert other Color Spaces to XYZ</p>


<h3>Usage</h3>

<pre><code class='language-R'>XYZfromxyY( xyY ) 
XYZfromLab( Lab, white ) 
XYZfromLuv( Luv, white ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXYZ_+3A_xyy">xyY</code></td>
<td>
<p> a numeric Nx3 matrix with CIE xyY coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="toXYZ_+3A_lab">Lab</code></td>
<td>
<p> a numeric Nx3 matrix with CIE Lab coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="toXYZ_+3A_luv">Luv</code></td>
<td>
<p> a numeric Nx3 matrix with CIE Luv coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="toXYZ_+3A_white">white</code></td>
<td>
<p>a numeric 3-vector giving the XYZ of reference white.
<code>white</code> can also be a character string with the name of a standard illuminant,
which is passed to <code><a href="#topic+standardXYZ">standardXYZ</a>()</code> to get the XYZ.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric Nx3 matrix with XYZ coordinates in the rows.
The rownames are copied from input to output.
<br />
In <code>XYZfromxyY()</code> if <code>y==0</code> then <code>X</code> and <code>Z</code> are set to <code>NA</code>.
Exception: <code>Y==0</code> is treated as a special case (pure black);
<code>x</code> and <code>y</code> are ignored, and <code>XYZ</code> are all set to 0.
</p>


<h3>References</h3>

<p>Wikipedia.
CIE 1931 color space.
<a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardXYZ">standardXYZ</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XYZfromxyY(c(0.310897, 0.306510, 74.613450))
##              X        Y        Z
##  [1,] 75.68137 74.61345 93.13427


XYZfromLab( c(50,2,-3), 'D50' )
##               X         Y         Z
##  [1,] 0.1813684 0.1841865 0.1643335
</code></pre>

<hr>
<h2 id='uvfrom'>Convert from XYZ or xy to Uniform Chromaticity Spaces</h2><span id='topic+uvfromXYZ'></span><span id='topic+uvfromxy'></span>

<h3>Description</h3>

<p>Convert from XYZ or xy to Uniform Chromaticity Spaces</p>


<h3>Usage</h3>

<pre><code class='language-R'>uvfromXYZ( XYZ, space=1976 )

uvfromxy( xy, space=1976 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uvfrom_+3A_xyz">XYZ</code></td>
<td>
<p> a numeric Nx3 matrix with CIE XYZ coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="uvfrom_+3A_xy">xy</code></td>
<td>
<p> a numeric Nx2 matrix with CIE xy coordinates in the rows, or a vector that can be converted to such a matrix, by row.</p>
</td></tr>
<tr><td><code id="uvfrom_+3A_space">space</code></td>
<td>
<p>the year of the space of output uv desired - valid spaces are 1976 and 1960.
The default <code>space=1976</code> has largely superseded <code>space=1960</code>,
but the latter is still used for computing Correlated Color Temperature; 
see <code><a href="#topic+CCTfromuv">CCTfromuv</a>()</code>.
The 1976 space is used in the function <code><a href="#topic+LuvfromXYZ">LuvfromXYZ</a>()</code>.
The 1960 coordinates are usually denoted by uv, and the 1976 coordinates by u'v'.
The only difference is that <code class="reqn">v' = (3/2) v</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric Nx2 matrix with u'v' (or uv) coordinates in the rows.
</p>
<p>For <code>uvfromXYZ()</code>,
if <code class="reqn">X + 15Y + 3Z \le 0</code>, uv are set to <code>NA</code>.
</p>
<p>For <code>uvfromxy()</code>,
if <code class="reqn">-2x + 12y + 3 \le 0</code>, uv are set to <code>NA</code>.
</p>
<p>The rownames are copied from input to output.
If the input is invalid, the function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Wikipedia.
CIE 1931 color space.
<a href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a>
</p>
<p>Wikipedia.
CIE 1960 color space.
<a href="https://en.wikipedia.org/wiki/CIE_1960_color_space">https://en.wikipedia.org/wiki/CIE_1960_color_space</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LuvfromXYZ">LuvfromXYZ</a>()</code>,
<code><a href="#topic+standardXYZ">standardXYZ</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate some standard illuminants on the 1976 UCS diagram
uvfromXYZ( standardXYZ( c('C','D50','D65','E')  ) )

##             u'        v'
##  C   0.2008921 0.4608838
##  D50 0.2091601 0.4880734
##  D65 0.1978398 0.4683363
##  E   0.2105263 0.4736842
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
