<!DOCTYPE html><html><head><title>Help for package act</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {act}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#act'><p>Aligned Corpus Toolkit</p></a></li>
<li><a href='#annotations_all'><p>All annotations in a corpus</p></a></li>
<li><a href='#annotations_delete'><p>Delete annotations</p></a></li>
<li><a href='#annotations_delete_empty'><p>Delete empty annotations</p></a></li>
<li><a href='#annotations_matrix'><p>Search and replace contents of annotations using a matrix</p></a></li>
<li><a href='#annotations_replace_copy'><p>Search, replace and copy the contents of annotations</p></a></li>
<li><a href='#corpus_export'><p>Export transcripts of a corpus</p></a></li>
<li><a href='#corpus_import'><p>Import annotation files into corpus object</p></a></li>
<li><a href='#corpus_new'><p>Create a new corpus object</p></a></li>
<li><a href='#corpus-class'><p>Corpus object</p></a></li>
<li><a href='#examplecorpus'><p>Example corpus for the act package</p></a></li>
<li><a href='#export_eaf'><p>Export a transcript object to a 'ELAN' .eaf file</p></a></li>
<li><a href='#export_exb'><p>Export a transcript object to a 'EXMARaLDA' .exb file</p></a></li>
<li><a href='#export_printtranscript'><p>Export a transcript object to a print transcript</p></a></li>
<li><a href='#export_rpraat'><p>Export a transcript object to a 'rPraat' TextGrid object</p></a></li>
<li><a href='#export_srt'><p>Export a transcript object to a .srt subtitle file</p></a></li>
<li><a href='#export_textgrid'><p>Export a transcript object to a 'Praat' .TextGrid file</p></a></li>
<li><a href='#helper_format_time'><p>Formats time as HH:MM:SS,mmm</p></a></li>
<li><a href='#helper_tiers_merge_tables'><p>Helper: Merge tier tables</p></a></li>
<li><a href='#helper_tiers_new_table'><p>Helper: Create a tier table</p></a></li>
<li><a href='#helper_tiers_sort_table'><p>Helper: Sort a tier table</p></a></li>
<li><a href='#helper_transcriptNames_get'><p>Helper: Get names of all transcripts in a corpus</p></a></li>
<li><a href='#helper_transcriptNames_make'><p>Helper: Makes valid names for all transcripts in a corpus</p></a></li>
<li><a href='#helper_transcriptNames_set'><p>Helper: Set names of all transcripts in a corpus</p></a></li>
<li><a href='#import'><p>Import a single annotation file</p></a></li>
<li><a href='#import_eaf'><p>Import a single 'ELAN' '*.eaf' file</p></a></li>
<li><a href='#import_exb'><p>Import a single 'EXMARaLDA' .exb file</p></a></li>
<li><a href='#import_rpraat'><p>Import a single 'rPraat' TextGrid object</p></a></li>
<li><a href='#import_textgrid'><p>Import a single 'Praat' .TextGrid file</p></a></li>
<li><a href='#info'><p>Information about corpus and transcript objects</p></a></li>
<li><a href='#info_summarized'><p>Summarized information about corpus and transcript objects</p></a></li>
<li><a href='#layout-class'><p>Layout object, defining the layout of print transcripts</p></a></li>
<li><a href='#matrix_load'><p>Load replacement matrix</p></a></li>
<li><a href='#matrix_save'><p>Save replacement matrix</p></a></li>
<li><a href='#media_assign'><p>Assign media file links to transcript objects</p></a></li>
<li><a href='#media_delete'><p>Delete media files links from transcript objects</p></a></li>
<li><a href='#media_getPathToExistingFile'><p>Gets the path of a media file for a transcript</p></a></li>
<li><a href='#options_delete'><p>delete all options set by the package from R options</p></a></li>
<li><a href='#options_reset'><p>Reset options to default values</p></a></li>
<li><a href='#options_show'><p>Options of the package</p></a></li>
<li><a href='#search_concordance'><p>Make concordance for search results</p></a></li>
<li><a href='#search_cuts'><p>Create print transcripts, media cutlists and srt subtitles for all search results</p></a></li>
<li><a href='#search_cuts_media'><p>Create cut lists for 'FFmpeg'</p></a></li>
<li><a href='#search_cuts_printtranscript'><p>Create print transcripts for all search results</p></a></li>
<li><a href='#search_cuts_srt'><p>Create .srt subtitles for all search results</p></a></li>
<li><a href='#search_makefilter'><p>Makes a filter for transcript and tier names</p></a></li>
<li><a href='#search_new'><p>Create a new search</p></a></li>
<li><a href='#search_openresult_inelan'><p>Open a search result in 'ELAN'</p></a></li>
<li><a href='#search_openresult_inpraat'><p>Open a search result in 'Praat'</p></a></li>
<li><a href='#search_openresult_inquicktime'><p>Open a search result in 'Quicktime' (and play it)</p></a></li>
<li><a href='#search_playresults_inquicktime'><p>Open all search results in 'Quicktime' and play them</p></a></li>
<li><a href='#search_results_export'><p>Exports search results</p></a></li>
<li><a href='#search_results_import'><p>Import search results</p></a></li>
<li><a href='#search_run'><p>Run a search</p></a></li>
<li><a href='#search_searchandopen_inpraat'><p>Search corpus and open first result in Praat</p></a></li>
<li><a href='#search_sub'><p>Add a sub search to a prior search</p></a></li>
<li><a href='#search_transcript_content'><p>Search in original content of a single transcript</p></a></li>
<li><a href='#search_transcript_fulltext'><p>Search in full text of a single transcript</p></a></li>
<li><a href='#search-class'><p>Search object</p></a></li>
<li><a href='#tiers_add'><p>Add tiers</p></a></li>
<li><a href='#tiers_all'><p>All tiers in a corpus</p></a></li>
<li><a href='#tiers_convert'><p>Convert tiers</p></a></li>
<li><a href='#tiers_delete'><p>Delete tiers</p></a></li>
<li><a href='#tiers_rename'><p>Rename tiers</p></a></li>
<li><a href='#tiers_sort'><p>Reorder tiers in all transcripts of a corpus</p></a></li>
<li><a href='#transcript-class'><p>transcript object</p></a></li>
<li><a href='#transcripts_add'><p>Add transcripts to a corpus</p></a></li>
<li><a href='#transcripts_cure'><p>Cure all transcript objects in a corpus</p></a></li>
<li><a href='#transcripts_cure_single'><p>Cure a single transcript</p></a></li>
<li><a href='#transcripts_delete'><p>Delete transcripts from a corpus</p></a></li>
<li><a href='#transcripts_filter'><p>Filter all transcripts in a corpus</p></a></li>
<li><a href='#transcripts_filter_single'><p>Filter a single transcript</p></a></li>
<li><a href='#transcripts_merge'><p>Merge several transcripts</p></a></li>
<li><a href='#transcripts_merge2'><p>Merge several transcripts (works with transcript objects directly)</p></a></li>
<li><a href='#transcripts_rename'><p>Rename transcripts in a corpus</p></a></li>
<li><a href='#transcripts_update_fulltexts'><p>Update full texts</p></a></li>
<li><a href='#transcripts_update_normalization'><p>Normalize transcriptions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Aligned Corpus Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oliver Ehmer &lt;oliver.ehmer@uos.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Aligned Corpus Toolkit (act) is designed for linguists that work with time aligned transcription data. It offers functions to import and export various annotation file formats ('ELAN' .eaf, 'EXMARaLDA .exb and 'Praat' .TextGrid files), create print transcripts in the style of conversation analysis, search transcripts (span searches across multiple annotations, search in normalized annotations, make concordances etc.), export and re-import search results (.csv and 'Excel' .xlsx format), create cuts for the search results (print transcripts, audio/video cuts using 'FFmpeg' and video sub titles in 'Subrib title' .srt format), modify the data in a corpus (search/replace, delete, filter etc.), interact with 'Praat' using 'Praat'-scripts, and exchange data with the 'rPraat' package. The package is itself written in R and may be expanded by other users.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stringr, stringi, tools, textutils, utils, progress,
XML, xml2, openxlsx</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.oliverehmer.de">http://www.oliverehmer.de</a>, <a href="https://github.com/oliverehmer/act">https://github.com/oliverehmer/act</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-07 13:18:41 UTC; oliverehmer</td>
</tr>
<tr>
<td>Author:</td>
<td>Oliver Ehmer [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-07 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='act'>Aligned Corpus Toolkit</h2><span id='topic+act'></span>

<h3>Description</h3>

<p>The Aligned Corpus Toolkit (act) is designed for linguists that work with time aligned transcription data. It offers functions to import and export various annotation file formats ('ELAN' .eaf, 'EXMARaLDA .exb and 'Praat' .TextGrid files), create print transcripts in the style of conversation analysis, search transcripts (span searches across multiple annotations, search in normalized annotations, make concordances etc.), export and re-import search results (.csv and 'Excel' .xlsx format), create cuts for the search results (print transcripts, audio/video cuts using 'FFmpeg' and video sub titles in 'Subrib title' .srt format), modify the data in a corpus (search/replace, delete, filter etc.), interact with 'Praat' using 'Praat'-scripts, and exchange data with the 'rPraat' package. The package is itself written in R and may be expanded by other users.
</p>


<h3>act functions</h3>

<p>...
</p>


<h3>Package options</h3>

<p>The package has numerous options that change the internal workings of the package.
Please see <code>act::options_show</code> and the information given there.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# ========== Example data set
# There is an example data set consisting of annotation files and corresponding 
# media files. 
# While the annotation files are copied to your computer when installing 
# the media files are not.
# You can either download the full data set from GitHub or decide to work 
# only with the annotation files.

# The example data set (only annotation files) is stored at the following location:
path &lt;- system.file("extdata", "examplecorpus", package="act")

# Since this folder is quite difficult to access, you might consider copying the 
# contents of this folder to a more convenient location.
# The following commands will create a new folder called 'examplecorpus' in the
# folder 'path'.
# You will find the data there.
## Not run: 
path &lt;- "EXISTING_FOLDER_ON_YOUR_COMPUTER"
sourcepath &lt;- system.file("extdata", "examplecorpus", package="act")
if (!dir.exists(path)) {dir.create(path)}
file.copy(sourcepath, dirname(path), recursive=TRUE)

## End(Not run)

# To download the full data set (including media files) from GitHub
# use the following code.
# In the first line specify an existing folder on your computer. 
# The following lines will then download the example data set from GitHub 
# and copy them to a sub folder called 'examplecorpus' in the folder 'path'.  
# You will find the data there.
## Not run: 
path &lt;- "EXISTING_FOLDER_ON_YOUR_COMPUTER"
path &lt;- "/Users/oliverehmer/Desktop"
sourceurl &lt;- "https://github.com/oliverehmer/act_examplecorpus/archive/master.zip"
temp &lt;- tempfile()
download.file(sourceurl, temp)
unzip(zipfile=temp, exdir=path)
path &lt;- file.path(path, "act_examplecorpus-main")

## End(Not run)

# ========== Create a corpus object and load data
# Now that we have the example data accessible, we can create a corpus object.
# The corpus object is a structured collection of all the information that you can 
# work with using act.
# It will contain the information of each transcript, links to media files and further 
# meta data.

# --- Locate folder with annotation files
# When creating a corpus object you will need to specify where your annotation 
# files ('Praat' '.TextGrids' or 'ELAN' .eaf) are located.
# We will use the example data, that we have just located in 'path'.
path

# In case that you want to use your own data, you can set the path here:
## Not run: 
	path &lt;- "EXISTING_FOLDER_ON_YOUR_COMPUTER"

## End(Not run)

# --- Create corpus object and load annotation files
# The following command will create a corpus object, with the name 'examplecorpus'.
examplecorpus &lt;- act::corpus_new(
	pathsAnnotationFiles = path,
	pathsMediaFiles = path,
	name = "examplecorpus"
)

# The act package assumes, that annotation files and media files have the same base  
# name and differ only in the suffix (e.g. 'filename.TextGrid' and 'filename.wav'/
# 'filename.mp4').
# This allows act to automatically link media files to the transcripts.

# --- Information about your corpus
# The following command will give you a summary of the data contained in your corpus object.
examplecorpus
# More detailed information about the transcripts in your corpus object is available by 
# calling the function act::info()
act::info(examplecorpus)
# If you are working in R studio, a nice way of inspecting this information is the following:
## Not run: 
	View(act::info(examplecorpus)$transcripts)
	View(act::info(examplecorpus)$tiers)

## End(Not run)

# ========== all data
# You can also get all data that is in the loaded annotation files in a data frame:
all_annotations &lt;- act::annotations_all(examplecorpus)
## Not run: 
	View(all_annotations)

## End(Not run)

# ========== Search
# Let's do some searches in the data.
# Search for the 1. Person Singular Pronoun in Spanish 'yo' in the examplecorpus
mysearch &lt;- act::search_new(x=examplecorpus, 
							pattern= "yo")
# Have a look at the result:
mysearch

# Directly view all search results in the viewer
## Not run: 
	View(mysearch@results)

## End(Not run)

# --- Search original vs. normalized content
# You can either search in the original 'content' of the annotations,
# or you can search in a 'normalized' version of the annotations.
# Let's compare the two modes.
mysearch.norm  &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=TRUE)
mysearch.org   &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=FALSE)
# There is a difference in the number of results.
mysearch.norm@results.nr
mysearch.org@results.nr

# The difference is because during in the normalized version, for instance, capital letters 
# will be converted to small letters. 
# In our case, one annotation in the example corpus contains a "yO" with a
# capital letter:
mysearch &lt;- act::search_new(examplecorpus, pattern="yO", searchNormalized=FALSE)
mysearch@results$hit

# During normalization a range of normalization procedures will be applied, using a 
# replacement matrix. This matrix searches and replaces certain patterns, that you want to 
# exclude from the normalized content.
# By default, normalization gets rid of all transcription conventions of GAT. 
# You may, in addition, also customize the replacement matrix to your own needs/transcription
# conventions.

# --- Search original content vs. full text
# There are two search modes.
# The 'fulltext' mode will will find matches across annotations.
# The 'content' mode will will respect the temporal boundaries of the original annotations.

# Let's define a search pattern with a certain span.
myRegEx &lt;- "\\bno\\b.{1,20}pero"
# This regular expression matches the Spanish word "no" 'no' followed by a "pero" 'but'
# in a distance ranging from 1 to 20 characters.

# The 'content' search mode will not find any hit.
mysearch &lt;- act::search_new(examplecorpus, pattern=myRegEx, searchMode="content")
mysearch@results.nr

# The 'fulltext' search mode will not find two hits that extend over several annotations.
mysearch &lt;- act::search_new(examplecorpus, pattern=myRegEx, searchMode="fulltext")
mysearch@results.nr
cat(mysearch@results$hit[1])
cat(mysearch@results$hit[2])

</code></pre>

<hr>
<h2 id='annotations_all'>All annotations in a corpus</h2><span id='topic+annotations_all'></span>

<h3>Description</h3>

<p>Merges annotations from all transcripts in a corpus and returns a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotations_all(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_all_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(act)

#Get data frame with all annotations
allannotations &lt;- act::annotations_all(examplecorpus)

#Have a look at the number of annotations
nrow(allannotations)

</code></pre>

<hr>
<h2 id='annotations_delete'>Delete annotations</h2><span id='topic+annotations_delete'></span>

<h3>Description</h3>

<p>Delete annotations in a corpus object.
If only certain transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code> and <code>filterTierNames</code>.
In case that you want to select transcripts and/or tiers by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotations_delete(
  x,
  pattern = "",
  filterTranscriptNames = NULL,
  filterTierNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_delete_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="annotations_delete_+3A_pattern">pattern</code></td>
<td>
<p>Character string; regular expression; all annotations that match this expression will be deleted.</p>
</td></tr>
<tr><td><code id="annotations_delete_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
<tr><td><code id="annotations_delete_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Character string; names of the tiers to be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Set the regular expression which annotations should be deleted.
# In this case: all annotations that contain the letter "a"
myRegEx &lt;- "a"

# Have a look at all annotations in the first transcript
examplecorpus@transcripts[[1]]@annotations$content

# Some of them match to the regular expression
hits &lt;- grep(pattern=myRegEx, x=examplecorpus@transcripts[[1]]@annotations$content)
examplecorpus@transcripts[[1]]@annotations$content[hits]
# Others don't match the regular expression
examplecorpus@transcripts[[1]]@annotations$content[-hits]

# Run the function and delete the annotations that match the regular expression
test &lt;- act::annotations_delete (x=examplecorpus, pattern=myRegEx)

# Compare how many data rows are in the first transcript in 
# the example corpus and in the newly created test corpus:
nrow(examplecorpus@transcripts[[1]]@annotations)
nrow(test@transcripts[[1]]@annotations)

# Only the annotations are left, that did not match the regular expression:
test@transcripts[[1]]@annotations$content
</code></pre>

<hr>
<h2 id='annotations_delete_empty'>Delete empty annotations</h2><span id='topic+annotations_delete_empty'></span>

<h3>Description</h3>

<p>Delete empty annotations in a corpus object.
If only certain transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code> and <code>filterTierNames</code>.
In case that you want to select transcripts and/or tiers by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotations_delete_empty(
  x,
  trimBeforeCheck = FALSE,
  filterTranscriptNames = NULL,
  filterTierNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_delete_empty_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="annotations_delete_empty_+3A_trimbeforecheck">trimBeforeCheck</code></td>
<td>
<p>Logical; if <code>TRUE</code> leading and trailing spaces will be deleted before checking (as a consequence record sets that contain only spaces will be deleted, too).</p>
</td></tr>
<tr><td><code id="annotations_delete_empty_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
<tr><td><code id="annotations_delete_empty_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Character string; names of the tiers to be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# In the example corpus are no empty annotations.
# Empty annotations are deleted by default when annotation files are loaded.
# So let's first make an empty annotation.

# Check the first annotation in the first transcript
examplecorpus@transcripts[[1]]@annotations$content[[1]]

# Empty the contents of this annotation
examplecorpus@transcripts[[1]]@annotations$content[[1]] &lt;- ""

# Run the function
test &lt;- act::annotations_delete_empty (x=examplecorpus)

# Compare how many data rows are in the first transcript in
# the example corpus and in the newly created test corpus:
nrow(examplecorpus@transcripts[[1]]@annotations)
nrow(test@transcripts[[1]]@annotations)

</code></pre>

<hr>
<h2 id='annotations_matrix'>Search and replace contents of annotations using a matrix</h2><span id='topic+annotations_matrix'></span>

<h3>Description</h3>

<p>This functions performs a search and replace in the contents of an annotation.
A simple matrix consisting of two columns will be used.
The first column of the matrix needs to contain the search string, the second column  the replacement string.
The matrix needs to be in CSV format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotations_matrix(x, path_replacementMatrixCSV, filterTranscriptNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_matrix_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="annotations_matrix_+3A_path_replacementmatrixcsv">path_replacementMatrixCSV</code></td>
<td>
<p>Character string; path to replacement matrix (a CSV file).</p>
</td></tr>
<tr><td><code id="annotations_matrix_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix_load">matrix_load()</a></code> for loading the matrix
and <code><a href="#topic+matrix_save">matrix_save()</a></code> for saving the matrix to a CSV file.
</p>
<p>If only certain transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code>.
In case that you want to select transcripts  by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>
<p><a href="#topic+media_delete">media_delete</a>, <a href="#topic+media_getPathToExistingFile">media_getPathToExistingFile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# An example replacement matrix comes with the package.
# It replaces most of the GAT conventions.
path &lt;- system.file("extdata", "normalization", "normalizationMatrix.csv", package="act")

# Have a look at the matrix
mymatrix &lt;- act::matrix_load(path)
mymatrix

# Apply matrix to examplecorpus
test &lt;- act::annotations_matrix(x=examplecorpus, path_replacementMatrixCSV=path)

# Compare some annotations in the original examplecorpus object and
# in the modified corpus object test
examplecorpus@transcripts[[1]]@annotations$content[[1]]
test@transcripts[[1]]@annotations$content[[1]]

examplecorpus@transcripts[[2]]@annotations$content[[3]]
test@transcripts[[2]]@annotations$content[[3]]
</code></pre>

<hr>
<h2 id='annotations_replace_copy'>Search, replace and copy the contents of annotations</h2><span id='topic+annotations_replace_copy'></span>

<h3>Description</h3>

<p>The function searches within the contents of annotations and replaces the search hits.
In addition the search hit may be copied to another tier.
In case that there is NO overlapping annotation in the destination tier a new annotation will be created (based on the time values of the original annotation).
In case that there is an overlapping annotation in the destination tier, the search result will be added at the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotations_replace_copy(
  x,
  pattern,
  replacement = NULL,
  destTier = NULL,
  addDestTierIfMissing = TRUE,
  filterTranscriptNames = NULL,
  filterTierNames = NULL,
  collapseString = " | "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_replace_copy_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_pattern">pattern</code></td>
<td>
<p>Character string; search pattern as regular expression.</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_replacement">replacement</code></td>
<td>
<p>Character string; replacement.</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_desttier">destTier</code></td>
<td>
<p>Character string; name of the tier to which the hit should be copied (if no copying is intended set to NA).</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_adddesttierifmissing">addDestTierIfMissing</code></td>
<td>
<p>Logical; if <code>TRUE</code> the destination tier will be added if missing in the transcript object, if <code>FALSE</code> an error will be raised if the destination tier is missing.</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Character string; names of the tiers to be included.</p>
</td></tr>
<tr><td><code id="annotations_replace_copy_+3A_collapsestring">collapseString</code></td>
<td>
<p>Character string; will be used to collapse multiple search results into one string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only certain transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code> and <code>filterTierNames</code>.
In case that you want to select transcripts and/or tiers by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Have a look at the first transcript in the examplecorpus:
printtranscript &lt;- act::export_printtranscript(examplecorpus@transcripts[[1]])
cat(printtranscript)
# In line 01 there is the word "UN".

# Replace this word by "XXX" in the entire corpus
test &lt;- act::annotations_replace_copy(x=examplecorpus,
									  pattern="\\bUN\\b",
									  replacement="XXX")

# Have a look at the first transcript in the corprus object test:
printtranscript &lt;- act::export_printtranscript(test@transcripts[[1]])
cat(printtranscript)
# In line 01 there is now "XXX" instead of "UN"

# Insert a tier called "newTier" into all transcripts in the corpus:
for (t in examplecorpus@transcripts) {
	sortVector &lt;- c(t@tiers$name, "newTier")
	examplecorpus &lt;- act::tiers_sort(x=examplecorpus,
	sortVector=sortVector,
	filterTranscriptNames=t@name,
	addMissingTiers=TRUE)
}
# Check that the first transcript now contains the newTier
examplecorpus@transcripts[[1]]@tiers

# Now replace "UN" by "YYY" in the entire corpus and
# copy the search hit to "newTier".
test &lt;- act::annotations_replace_copy(x=examplecorpus,
									  pattern="\\bUN\\b",
									  replacement="YYY",
									  destTier = "newTier")

# Have a look again at the first transcript in the corpus object test.
printtranscript &lt;- act::export_printtranscript(test@transcripts[[1]])
cat(printtranscript)
# In line 01 you see that "UN" has been replaced by "YYY.
# In line 02 you see that it has been copied to the tier "newTier".

# If you only want to copy a search hit but not replace it in the original
# leave replacement="", which is the default
test &lt;- act::annotations_replace_copy(x=examplecorpus,
									  pattern="\\bUN\\b",
									  destTier = "newTier")
printtranscript &lt;- act::export_printtranscript(test@transcripts[[1]])
cat(printtranscript)
# In line 01 you see that "UN" has been maintained.
# In line 02 you see that "UN" it has been copied to the tier "newTier".
</code></pre>

<hr>
<h2 id='corpus_export'>Export transcripts of a corpus</h2><span id='topic+corpus_export'></span>

<h3>Description</h3>

<p>Exports all (or some) transcript objects in a corpus object to different annotation file formats.
If only some transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code> and <code>filterTierNames</code>.
In case that you want to select transcripts and/or tiers by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corpus_export(
  x,
  outputFolder,
  filterTranscriptNames = NULL,
  filterTierNames = NULL,
  formats = c("eaf", "exb", "srt", "textgrid", "printtranscript"),
  createMediaLinks = TRUE,
  createOutputfolder = TRUE,
  l = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus_export_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Character string; path to a folder where the transcription files will be saved. By default the forlder will be created recursively it does not exist.</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of transcripts to be included. If left unspecified, all transcripts will be exported.</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_formats">formats</code></td>
<td>
<p>Vector with one or more character strings; output formats, accepted values: 'eaf', 'exb', 'srt', 'textgrid', 'printtranscript'. If left unspecified, all supported formats will be exported.</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_createmedialinks">createMediaLinks</code></td>
<td>
<p>Logical; if <code>TRUE</code> media links will be created (affects only 'eaf' and 'exb' files).</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_createoutputfolder">createOutputfolder</code></td>
<td>
<p>Logical; if <code>TRUE</code> the outputfolder will be created recursively in case that it does not exist.</p>
</td></tr>
<tr><td><code id="corpus_export_+3A_l">l</code></td>
<td>
<p>Layout object. layout of print transcripts (affects only 'printtranscript' files).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+export_eaf">export_eaf</a>, <a href="#topic+export_textgrid">export_textgrid</a>, <a href="#topic+import_textgrid">import_textgrid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Set destination folder
outputFolder &lt;- tempdir()

# It makes more sense, however, to you define a folder
# that is easier to access on your computer
## Not run: 
outputFolder &lt;- "PATH_TO_AN_EMPTY_FOLDER_ON_YOUR_COMPUTER"

## End(Not run)

# Exports all transcript objects in all supported formats
act::corpus_export(x=examplecorpus,
							   outputFolder=outputFolder)

# Exports all transcript objects in 'Praat' .TextGrid format
act::corpus_export(x=examplecorpus,
                              outputFolder=outputFolder,
                              formats="textgrid")

# Exports all transcript objects in 'ELAN' .eaf format.
# By default WITH media links
act::corpus_export(x=examplecorpus,
						outputFolder=outputFolder,
						formats="eaf")


# Same same, but now WITHOUT media links.
# Only Media links are only exported that are in
# the '@media.path' attribute in the transcript object(s))
act::corpus_export(x=examplecorpus,
						outputFolder=outputFolder,
						formats="eaf",
						createMediaLinks=FALSE)

# Exports in 'ELAN' .eaf and Praat' .TextGrid format
act::corpus_export(x=examplecorpus,
                                 outputFolder=outputFolder,
                                 formats=c("eaf", "textgrid"))

</code></pre>

<hr>
<h2 id='corpus_import'>Import annotation files into corpus object</h2><span id='topic+corpus_import'></span>

<h3>Description</h3>

<p>Scans all path specified in if <code>x@paths.annotation.files</code> for annotation files.
Supported file formats will be loaded as transcript objects into the corpus object.
All previously loaded transcript objects will be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corpus_import(x, createFullText = TRUE, assignMedia = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus_import_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="corpus_import_+3A_createfulltext">createFullText</code></td>
<td>
<p>Logical; if <code>TRUE</code> full text will be created.</p>
</td></tr>
<tr><td><code id="corpus_import_+3A_assignmedia">assignMedia</code></td>
<td>
<p>Logical; if <code>TRUE</code> the folder(s) specified in <code>@paths.media.files</code> of your corpus object will be scanned for media.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>assignMedia=TRUE</code> the paths defined in <code>x@paths.media.files</code> will be scanned for media files.
Based on their file names the media files and annotations files will be matched.
Only the the file types set in <code>options()$act.fileformats.audio</code> and <code>options()$act.fileformats.video</code> will be recognized.
You can modify these options to recognize other media types.
</p>
<p>See <code>@import.results</code> of the corpus object to check the results of importing the files.
To get a detailed overview of the corpus object use <code>act::info(x)</code>, for a summary use <code>act::info_summarized(x)</code>.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+corpus_new">corpus_new</a>, <a href="#topic+examplecorpus">examplecorpus</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# The example files that come with the act library are located here:
path &lt;- system.file("extdata", "examplecorpus", package="act")

# This is the examplecorpus object that comes with the library
examplecorpus

# Make sure that the input folder of the example corpus object is set correctly
examplecorpus@paths.annotation.files &lt;- path
examplecorpus@paths.media.files &lt;- path

# Load annotation files into the corpus object (again)
examplecorpus &lt;- act::corpus_import(x=examplecorpus)

# Creating the full texts may take a long time.
# If you do NOT want to create the full texts immediately use the following command:
examplecorpus &lt;- act::corpus_import(x=examplecorpus, createFullText=FALSE )
</code></pre>

<hr>
<h2 id='corpus_new'>Create a new corpus object</h2><span id='topic+corpus_new'></span>

<h3>Description</h3>

<p>Create a new corpus object and loads annotation files. Currently 'ELAN' .eaf, 'EXMARaLDA .exb and 'Praat' .TextGrid files are supported.
</p>
<p>The parameter <code>pathsAnnotationFiles</code> defines where the annotation files are located.
If <code>skipDoubleFiles=TRUE</code> duplicated files will be skipped, otherwise the will be renamed.
If <code>importFiles=TRUE</code> the corpus object will be created but files will not be loaded. To load the files then call <a href="#topic+corpus_import">corpus_import</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corpus_new(
  pathsAnnotationFiles,
  pathsMediaFiles = NULL,
  name = "New Corpus",
  importFiles = TRUE,
  skipDoubleFiles = TRUE,
  createFullText = TRUE,
  assignMedia = TRUE,
  pathNormalizationMatrix = NULL,
  namesInclude = character(),
  namesExclude = character(),
  namesSearchPatterns = character(),
  namesSearchReplacements = character(),
  namesToUpperCase = FALSE,
  namesToLowerCase = FALSE,
  namesTrim = TRUE,
  namesDefaultForEmptyNames = "no_name"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus_new_+3A_pathsannotationfiles">pathsAnnotationFiles</code></td>
<td>
<p>Vector of character strings; paths to annotations files or folders that contain annotation files.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_pathsmediafiles">pathsMediaFiles</code></td>
<td>
<p>Vector of character strings; paths to media files or folders that contain media files.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_name">name</code></td>
<td>
<p>Character string; name of the corpus to be created.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_importfiles">importFiles</code></td>
<td>
<p>Logical; if <code>TRUE</code> annotation files will be imported immediately when the function is called, if <code>FALSE</code> corpus object will be created without importing the annotation files.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_skipdoublefiles">skipDoubleFiles</code></td>
<td>
<p>Logical; if <code>TRUE</code> transcripts with the same names will be skipped (only one of them will be added), if <code>FALSE</code> transcripts will be renamed to make the names unique.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_createfulltext">createFullText</code></td>
<td>
<p>Logical; if <code>TRUE</code> full text will be created.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_assignmedia">assignMedia</code></td>
<td>
<p>Logical; if <code>TRUE</code> the folder(s) specified in <code>@paths.media.files</code> of your corpus object will be scanned for media.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_pathnormalizationmatrix">pathNormalizationMatrix</code></td>
<td>
<p>Character string; path to the replacement matrix used for normalizing the annotations; if argument left open, the default normalization matrix of the package will be used.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namesinclude">namesInclude</code></td>
<td>
<p>Vector of character strings; Only files matching this regular expression will be imported into the corpus.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namesexclude">namesExclude</code></td>
<td>
<p>Vector of character strings; Files matching this regular expression will be skipped and not imported into the corpus.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namessearchpatterns">namesSearchPatterns</code></td>
<td>
<p>Vector of character strings; Search pattern as regular expression. Leave empty for no search-replace in the names.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namessearchreplacements">namesSearchReplacements</code></td>
<td>
<p>Vector of character strings; Replacements for search. Leave empty for no search-replace in the names.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namestouppercase">namesToUpperCase</code></td>
<td>
<p>Logical; Convert transcript names all to upper case.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namestolowercase">namesToLowerCase</code></td>
<td>
<p>Logical; Convert transcript names all to lower case.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namestrim">namesTrim</code></td>
<td>
<p>Logical; Remove leading and trailing spaces in names.</p>
</td></tr>
<tr><td><code id="corpus_new_+3A_namesdefaultforemptynames">namesDefaultForEmptyNames</code></td>
<td>
<p>Character string; Default value for empty transcript names (e.g., resulting from search-replace operations)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>pathsMediaFiles</code> defines where the corresponding media files are located.
If <code>assignMedia=TRUE</code> the paths defined in <code>x@paths.media.files</code> will be scanned for media files and will be matched to the transcript object based on their names.
Only the the file types set in <code>options()$act.fileformats.audio</code> and <code>options()$act.fileformats.video</code> will be recognized.
You can modify these options to recognize other media types.
</p>
<p>See <code>@import.results</code> of the corpus object to check the results of importing the files.
To get a detailed overview of the corpus object use <code>act::info(x)</code>, for a summary use <code>act::info_summarized(x)</code>.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+corpus_import">corpus_import</a>, <a href="#topic+examplecorpus">examplecorpus</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# The example files that come with the act library are located here:
path &lt;- system.file("extdata", "examplecorpus", package="act")

# The example corpus comes without media files.
# It is recommended to download a full example corpus also including the media files.
# You can use the following commands.
## Not run: 
   path &lt;- "EXISTING_FOLDER_ON_YOUR_COMPUTER/examplecorpus"
   temp &lt;- tempfile()
   download.file(options()$act.examplecorpusURL, temp)
   unzip(zipfile=temp, exdir=path)

## End(Not run)

# The following command creates a new corpus object
mycorpus &lt;- act::corpus_new(name = "mycorpus",
	pathsAnnotationFiles = path,
	pathsMediaFiles = path)

# Get a summary
mycorpus

</code></pre>

<hr>
<h2 id='corpus-class'>Corpus object</h2><span id='topic+corpus-class'></span>

<h3>Description</h3>

<p>This is the main object the act package uses.
It collects the annotations and meta data from loaded annotation files.
</p>


<h3>Details</h3>

<p>Some of the slots are defined by the user.
Some slots report results, such as <code>@import.results</code> and <code>@history</code> and .
Other slots are settings and are used when performing functions on the corpus oibject.
To change the normalization matrix use <code>x@normalization.matrix &lt;- act::matrix_load(path="...")</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Character string; Name of the corpus.</p>
</dd>
<dt><code>transcripts</code></dt><dd><p>List of transcript objects; Each annotation file that has been load is stored in this list as a transcript object.</p>
</dd>
<dt><code>paths.annotation.files</code></dt><dd><p>Vector of character strings; Path(s) to one or several folders where your annotation files are located.</p>
</dd>
<dt><code>paths.media.files</code></dt><dd><p>Vector of character strings; Path(s) to one or several folders where your media files are located.</p>
</dd>
<dt><code>normalization.matrix</code></dt><dd><p>Data.frame; Replacement matrix used for normalizing the annotations.</p>
</dd>
<dt><code>import.skip.double.files</code></dt><dd><p>Logical; if <code>TRUE</code> files with the same names will be skipped (only one of them will be loaded), if <code>FALSE</code> transcripts will be renamed to make the names unique.</p>
</dd>
<dt><code>import.names.include</code></dt><dd><p>Vector of character strings; Only files matching this regular expression will be imported into the corpus.</p>
</dd>
<dt><code>import.names.exclude</code></dt><dd><p>Vector of character strings; Files matching this regular expression will be skipped and not imported into the corpus.</p>
</dd>
<dt><code>import.names.modify</code></dt><dd><p>List; Options how to modify the names of the transcript objects when they are added to the corpus. These options are useful, for instacne, if your annotation files contain character sequences that you do not want to include into the transcript name in the corpus (e.g. if you regularly add a date to the file name of your annotations files  as 'myFile_2020-09-21.TextGrid').</p>
</dd>
<dt><code>import.results</code></dt><dd><p>Data.frame; information about the import of the annotation files.</p>
</dd>
<dt><code>history</code></dt><dd><p>List; History of modifications made by any of the package functions to the corpus.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

examplecorpus

</code></pre>

<hr>
<h2 id='examplecorpus'>Example corpus for the act package</h2><span id='topic+examplecorpus'></span>

<h3>Description</h3>

<p>Example corpus with data loaded from the example annotations files that come with the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(examplecorpus)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"corpus"</code>
</p>


<h3>Details</h3>

<p>You can download the corresponding media files from www.oliverehmer.de in the section &quot;Digital Humanities&quot;.
Alternatively you can use the download commands in the example section.
</p>


<h3>Source</h3>


<ul>
<li><p> GAT: Ehmer, Oliver/Satti, Luis Ignacio/Martinez, Angelita/Pfaender, Stefan (2019): Un sistema para transcribir el habla en la interaccion: GAT 2.0 Gespraechsforschung - Online-Zeitschrift zur verbalen Interaktion (www.gespraechsforschung-ozs.de) 20, 64-114. http://www.gespraechsforschung-online.de/2019.html
</p>
</li>
<li><p> SYNC:	Ehmer, Oliver (2020, in press): Synchronization in demonstrations. Multimodal practices for instructing body knowledge. Linguistics Vanguard. https://www.degruyter.com/view/journals/lingvan/lingvan-overview.xml
</p>
</li></ul>



<h3>See Also</h3>

<p>, <a href="#topic+corpus_new">corpus_new</a>, <a href="#topic+corpus_import">corpus_import</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Summary of the data in the corpus
examplecorpus

# Summary of the data in th second transcripts in the corpus
examplecorpus@transcripts[[2]]

## Not run: 
# Download example corpus with media files
destinationpath &lt;- "/EXISTING_FOLDERON_YOUR_COMPUTER/examplecorpus"
temp &lt;- tempfile()
download.file(options()$act.examplecorpusURL, temp)
unzip(zipfile=temp, exdir=destinationpath)

## End(Not run)
</code></pre>

<hr>
<h2 id='export_eaf'>Export a transcript object to a 'ELAN' .eaf file</h2><span id='topic+export_eaf'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_export</code> for exporting annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_eaf(
  t,
  outputPath = NULL,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  createMediaLinks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_eaf_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to be exported.</p>
</td></tr>
<tr><td><code id="export_eaf_+3A_outputpath">outputPath</code></td>
<td>
<p>Character string; path where .eaf file will be saved.</p>
</td></tr>
<tr><td><code id="export_eaf_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="export_eaf_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_eaf_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_eaf_+3A_createmedialinks">createMediaLinks</code></td>
<td>
<p>Logical; if <code>TRUE</code> media links will be created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The .eaf file will be written to the file specified in <code>outputPath</code>.
If <code>outputPath</code> is left empty, the function will return the contents of the .eaf itself.
</p>


<h3>Value</h3>

<p>Contents of the .eaf file (only if <code>outputPath</code> is left empty)
</p>


<h3>See Also</h3>

<p><code>corpus_export</code>, <code>export_exb</code>, <code>export_printtranscript</code>, <code>export_rpraat</code>, <code>export_srt</code>, <code>export_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Get the transcript you want to export
t &lt;- examplecorpus@transcripts[[1]]

# Create temporary file path
path &lt;- tempfile(pattern = t@name, tmpdir = tempdir(), fileext = ".eaf")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer
## Not run: 
path &lt;- file.path("PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
                   paste(t@name, ".eaf", sep=""))

## End(Not run)

# Export WITH media links
act::export_eaf(t=t, outputPath=path)

# Export WITHOUT media links
act::export_eaf(t=t, outputPath=path, createMediaLinks = FALSE)

</code></pre>

<hr>
<h2 id='export_exb'>Export a transcript object to a 'EXMARaLDA' .exb file</h2><span id='topic+export_exb'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_export</code> for exporting annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_exb(
  t,
  outputPath = NULL,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  createMediaLinks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_exb_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to be exported.</p>
</td></tr>
<tr><td><code id="export_exb_+3A_outputpath">outputPath</code></td>
<td>
<p>Character string; path where .exb file will be saved.</p>
</td></tr>
<tr><td><code id="export_exb_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="export_exb_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_exb_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_exb_+3A_createmedialinks">createMediaLinks</code></td>
<td>
<p>Logical; if <code>TRUE</code> media links will be created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The .exb file will be written to the file specified in <code>outputPath</code>.
If <code>outputPath</code> is left empty, the function will return the contents of the .exb itself.
</p>


<h3>Value</h3>

<p>Contents of the .exb file (only if <code>outputPath</code> is left empty)
</p>


<h3>See Also</h3>

<p><code>corpus_export</code>, <code>export_eaf</code>, <code>export_printtranscript</code>, <code>export_rpraat</code>, <code>export_srt</code>, <code>export_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Get the transcript you want to export
t &lt;- examplecorpus@transcripts[[1]]

# Create temporary file path
path &lt;- tempfile(pattern = t@name, tmpdir = tempdir(), fileext = ".exb")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer
## Not run: 
path &lt;- file.path("PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
                   paste(t@name, ".exb", sep=""))

## End(Not run)

# Export WITH media links
act::export_exb(t=t, outputPath=path)

# Export WITHOUT media links
act::export_exb(t=t, outputPath=path, createMediaLinks = FALSE)

</code></pre>

<hr>
<h2 id='export_printtranscript'>Export a transcript object to a print transcript</h2><span id='topic+export_printtranscript'></span>

<h3>Description</h3>

<p>If you want to modify the layout of the print transcripts, create a new layout object with <code>mylayout &lt;- methods::new("layout")</code>, modify the settings and pass it as argument <code>l</code>.
In the layout object you may also set additional filters to include/exclude tiers matching regular expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_printtranscript(
  t,
  l = NULL,
  outputPath = NULL,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  insert_arrow_annotationID = "",
  header_heading = "",
  header_firstinfo = "",
  collapse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_printtranscript_+3A_t">t</code></td>
<td>
<p>Transcript object.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_l">l</code></td>
<td>
<p>Layout object.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_outputpath">outputPath</code></td>
<td>
<p>Character string; path where to save the transcript.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_insert_arrow_annotationid">insert_arrow_annotationID</code></td>
<td>
<p>Integer; ID of the annotation in front of which the arrow will be placed.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_header_heading">header_heading</code></td>
<td>
<p>Character string; text that will be used as heading.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_header_firstinfo">header_firstinfo</code></td>
<td>
<p>Character string; text that will used as first information in the header.</p>
</td></tr>
<tr><td><code id="export_printtranscript_+3A_collapse">collapse</code></td>
<td>
<p>Logical; if <code>FALSE</code> a vector will be created, each element corresponding to one annotation. if <code>TRUE</code> a single string will be created, collapsed by linebreaks \n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string; transcript as text.
</p>


<h3>See Also</h3>

<p><code>corpus_export</code>, <code>export_eaf</code>, <code>export_exb</code>, <code>export_rpraat</code>, <code>export_srt</code>, <code>export_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Get a transcript
t &lt;- examplecorpus@transcripts[[1]]

# Create print transcript
printtranscript &lt;- act::export_printtranscript (t=t)

# Display on screen
cat(printtranscript)

</code></pre>

<hr>
<h2 id='export_rpraat'>Export a transcript object to a 'rPraat' TextGrid object</h2><span id='topic+export_rpraat'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_export</code> for exporting annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_rpraat(
  t,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_rpraat_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to be converted.</p>
</td></tr>
<tr><td><code id="export_rpraat_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="export_rpraat_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_rpraat_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end of selection in seconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to create compatibility with the <code>rPraat</code> package.
It converts an act transcript to a rPraat TextGrid object.
</p>
<p>Credits: Thanks to Tomáš Bořil, the author of the rPraat package, for commenting on the exchange functions.
</p>


<h3>Value</h3>

<p>rPraat TextGrid object
</p>


<h3>See Also</h3>

<p><code>import_rpraat</code>, <code>corpus_export</code>, <code>export_eaf</code>, <code>export_exb</code>, <code>export_printtranscript</code>, <code>export_srt</code>, <code>export_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Convert
rpraat.tg &lt;- act::export_rpraat(t=examplecorpus@transcripts[[1]])

# Now you can use the object in the rPraat pachage.
# For instance you can plot the TextGrid
## Not run: 
	rPraat::tg.plot(rpraat.tg)

## End(Not run)
</code></pre>

<hr>
<h2 id='export_srt'>Export a transcript object to a .srt subtitle file</h2><span id='topic+export_srt'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_export</code> for exporting annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_srt(
  t,
  outputPath = NULL,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  speaker.show = TRUE,
  speaker.width = 3,
  speaker.ending = ":"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_srt_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to be saved.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_outputpath">outputPath</code></td>
<td>
<p>Character string; path where .srt will be saved.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_speaker.show">speaker.show</code></td>
<td>
<p>Logical; if <code>TRUE</code> name of speaker will be shown before the content of the annotation.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_speaker.width">speaker.width</code></td>
<td>
<p>Integer; width of speaker abbreviation, -1 for full name without shortening.</p>
</td></tr>
<tr><td><code id="export_srt_+3A_speaker.ending">speaker.ending</code></td>
<td>
<p>Character string; string that is added at the end of the speaker name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a 'Subrip title' .srt subtitle file.
It will be written to the file specified in <code>outputPath</code>.
If <code>outputPath</code> is left empty, the function will return the contents of the .srt itself.
</p>


<h3>Value</h3>

<p>Contents of the .srt file (only if <code>outputPath</code> is left empty)
</p>


<h3>See Also</h3>

<p><code>corpus_export</code>, <code>export_eaf</code>, <code>export_exb</code>, <code>export_printtranscript</code>, <code>export_rpraat</code>, <code>export_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Get the transcript you want to export
t &lt;- examplecorpus@transcripts[[1]]

# Create temporary file path
path &lt;- tempfile(pattern = t@name, tmpdir = tempdir(),
                 fileext = ".srt")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer:
## Not run: 
path &lt;- file.path("PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
                    paste(t@name, ".srt", sep=""))

## End(Not run)

# Export
act::export_srt(t=t, outputPath=path)

</code></pre>

<hr>
<h2 id='export_textgrid'>Export a transcript object to a 'Praat' .TextGrid file</h2><span id='topic+export_textgrid'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_export</code> for exporting annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_textgrid(
  t,
  outputPath = NULL,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_textgrid_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to be saved.</p>
</td></tr>
<tr><td><code id="export_textgrid_+3A_outputpath">outputPath</code></td>
<td>
<p>Character string; path where .TextGrid will be saved.</p>
</td></tr>
<tr><td><code id="export_textgrid_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included. If left unspecified, all tiers will be exported.</p>
</td></tr>
<tr><td><code id="export_textgrid_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start of selection in seconds.</p>
</td></tr>
<tr><td><code id="export_textgrid_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end of selection in seconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The .TextGrid file will be written to the file specified in <code>outputPath</code>.
If <code>outputPath</code> is left empty, the function will return the contents of the .TextGrid itself.
</p>


<h3>Value</h3>

<p>Contents of the .TextGrid file (only if <code>outputPath</code> is left empty)
</p>


<h3>See Also</h3>

<p><code>corpus_export</code>, <code>export_eaf</code>, <code>export_exb</code>, <code>export_printtranscript</code>, <code>export_rpraat</code>, <code>export_srt</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Get the transcript you want to export
t &lt;- examplecorpus@transcripts[[1]]

# Create temporary file path
path &lt;- tempfile(pattern = t@name, tmpdir = tempdir(),
                 fileext = ".TextGrid")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer:
## Not run: 
path &lt;- file.path("PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
                    paste(t@name, ".TextGrid", sep=""))

## End(Not run)

# Export
act::export_textgrid(t=t, outputPath=path)

</code></pre>

<hr>
<h2 id='helper_format_time'>Formats time as HH:MM:SS,mmm</h2><span id='topic+helper_format_time'></span>

<h3>Description</h3>

<p>Formats time as HH:MM:SS,mmm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_format_time(
  t,
  digits = 1,
  addHrsMinSec = FALSE,
  addTimeInSeconds = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_format_time_+3A_t">t</code></td>
<td>
<p>Double; time in seconds.</p>
</td></tr>
<tr><td><code id="helper_format_time_+3A_digits">digits</code></td>
<td>
<p>Integer; number of digits.</p>
</td></tr>
<tr><td><code id="helper_format_time_+3A_addhrsminsec">addHrsMinSec</code></td>
<td>
<p>Logical; if <code>TRUE</code> 'hrs' 'min' 'sec' will be used instead of ':'.</p>
</td></tr>
<tr><td><code id="helper_format_time_+3A_addtimeinseconds">addTimeInSeconds</code></td>
<td>
<p>Logical; if <code>TRUE</code> time value in seconds will be shown, too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)


helper_format_time(12734.2322345)
helper_format_time(2734.2322345)
helper_format_time(34.2322345)
helper_format_time(0.2322345)

helper_format_time(12734.2322345, addHrsMinSec=TRUE)
helper_format_time(2734.2322345, addHrsMinSec=TRUE)
helper_format_time(34.2322345, addHrsMinSec=TRUE)
helper_format_time(0.2322345, addHrsMinSec=TRUE)

helper_format_time(12734.2322345, digits=3)
helper_format_time(2734.2322345, digits=3)
helper_format_time(34.2322345, digits=3)
helper_format_time(0.2322345, digits=3)

helper_format_time(12734.2322345, addHrsMinSec=TRUE, digits=3)
helper_format_time(2734.2322345, addHrsMinSec=TRUE, digits=3)
helper_format_time(34.2322345, addHrsMinSec=TRUE, digits=3)
helper_format_time(0.2322345, addHrsMinSec=TRUE, digits=3)

helper_format_time(12734.2322345, addHrsMinSec=TRUE, addTimeInSeconds=TRUE)
helper_format_time(2734.2322345, addHrsMinSec=TRUE, addTimeInSeconds=TRUE)
helper_format_time(34.2322345, addHrsMinSec=TRUE, addTimeInSeconds=TRUE)
helper_format_time(0.2322345, addHrsMinSec=TRUE, addTimeInSeconds=TRUE)

helper_format_time(12734.2322345, addHrsMinSec=TRUE, digits=3, addTimeInSeconds=TRUE)
helper_format_time(2734.2322345, addHrsMinSec=TRUE, digits=3, addTimeInSeconds=TRUE)
helper_format_time(34.2322345, addHrsMinSec=TRUE, digits=3, addTimeInSeconds=TRUE)
helper_format_time(0.2322345, addHrsMinSec=TRUE, digits=3, addTimeInSeconds=TRUE)


</code></pre>

<hr>
<h2 id='helper_tiers_merge_tables'>Helper: Merge tier tables</h2><span id='topic+helper_tiers_merge_tables'></span>

<h3>Description</h3>

<p>Merges several the tier tables into one tier table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_tiers_merge_tables(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_tiers_merge_tables_+3A_...">...</code></td>
<td>
<p>accepts different kinds of objects; transcript objects, lists of transcript objects (as in @transcripts of a corpus object) and tier tables (as in @tiers of a transcript object).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: To actually modify the tiers in a transcript object or a corpus object corpus use the functions of the package, e.g. <code>act::transcripts_merge</code>.
This function is only a helper function and for people that like experiments.
If tiers with the same name are of different types ('IntervalTier', 'TextTier') an error will be raised.
In that case can use, for example,  'act::tier_convert()' to change the tier types.
</p>


<h3>Value</h3>

<p>Data.frame
</p>


<h3>See Also</h3>

<p><a href="#topic+helper_tiers_sort_table">helper_tiers_sort_table</a>, <a href="#topic+helper_tiers_merge_tables">helper_tiers_merge_tables</a>, <a href="#topic+tiers_convert">tiers_convert</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+tiers_sort">tiers_sort</a>, <a href="#topic+transcripts_merge">transcripts_merge</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# --- Create two tier tables from scratch
tierTable1 &lt;- act::helper_tiers_new_table(c("a","b","c","d"),
c("IntervalTier", "TextTier","IntervalTier","TextTier"))

tierTable2 &lt;- act::helper_tiers_new_table(c("a","b","x","y"),
c("IntervalTier", "TextTier","IntervalTier","TextTier"))

tierTable3 &lt;- act::helper_tiers_merge_tables(tierTable1,tierTable2)
tierTable3

</code></pre>

<hr>
<h2 id='helper_tiers_new_table'>Helper: Create a tier table</h2><span id='topic+helper_tiers_new_table'></span>

<h3>Description</h3>

<p>Creates a new tier table as necessary in <code>@tiers</code> of a transcript object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_tiers_new_table(tierNames, tierTypes = NULL, tierPositions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_tiers_new_table_+3A_tiernames">tierNames</code></td>
<td>
<p>Vector of character strings; names of the tiers.</p>
</td></tr>
<tr><td><code id="helper_tiers_new_table_+3A_tiertypes">tierTypes</code></td>
<td>
<p>Vector of character strings; types of the tiers. Allowed values: &quot;IntervalTier&quot;,&quot;TextTier&quot;. Needs to have the same length as 'tierNames'.</p>
</td></tr>
<tr><td><code id="helper_tiers_new_table_+3A_tierpositions">tierPositions</code></td>
<td>
<p>Vector of integer values; Sort order of the tiers. Needs to have the same length as 'tierNames'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: To actually modify the tiers in a transcript object or a corpus object corpus use the functions of the package.
This function is only a helper function and for people that like experiments.
</p>


<h3>Value</h3>

<p>Data.frame
</p>


<h3>See Also</h3>

<p><a href="#topic+helper_tiers_sort_table">helper_tiers_sort_table</a>, <a href="#topic+helper_tiers_merge_tables">helper_tiers_merge_tables</a>, <a href="#topic+tiers_convert">tiers_convert</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+tiers_sort">tiers_sort</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# --- Create a tier table from scratch
tierTable &lt;- act::helper_tiers_new_table(c("a","b","c", "d"), 
c("IntervalTier", "TextTier","IntervalTier","TextTier"))
tierTable
</code></pre>

<hr>
<h2 id='helper_tiers_sort_table'>Helper: Sort a tier table</h2><span id='topic+helper_tiers_sort_table'></span>

<h3>Description</h3>

<p>NOTE: To actually reorder the tiers in a transcript object or a corpus object corpus use <code>act::tiers_sort</code>.
This function is only a helper function and for people that like experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_tiers_sort_table(
  tierTable,
  sortVector,
  addMissingTiers = TRUE,
  deleteTiersThatAreNotInTheSortVector = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_tiers_sort_table_+3A_tiertable">tierTable</code></td>
<td>
<p>Data frame; tiers as specified and necessary in <code>@tiers</code> of a transcript object.</p>
</td></tr>
<tr><td><code id="helper_tiers_sort_table_+3A_sortvector">sortVector</code></td>
<td>
<p>Vector of character strings; regular expressions to match the tier names. The order within the vector presents the new order of the tiers. Use &quot;\*&quot; (=two backslashes and a star) to indicate where tiers that are not present in the sort vector but in the transcript should be inserted.</p>
</td></tr>
<tr><td><code id="helper_tiers_sort_table_+3A_addmissingtiers">addMissingTiers</code></td>
<td>
<p>Logical; if <code>TRUE</code> all tiers that are given in 'the 'sortVector' but are missing in 'tierTable' will be added.</p>
</td></tr>
<tr><td><code id="helper_tiers_sort_table_+3A_deletetiersthatarenotinthesortvector">deleteTiersThatAreNotInTheSortVector</code></td>
<td>
<p>Logical; if <code>TRUE</code> tiers that are not matched by the regular expressions in 'sortVector' will be deleted. Otherwise the will be inserted at the end of the table or at the position defined by '&quot;\*' in  'sortVector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sort a tier table by a predefined vector of regular expression strings.
Tiers that are missing in the table but are present in the sort vector may be inserted.
Tiers that are present in the table but not in the sort vector may be deleted or inserted. These tiers will be inserted by default at the end of the table. You may also use a element '\*' in  'sortVector' to define the position where they should be placed..
</p>


<h3>Value</h3>

<p>Data.frame
</p>


<h3>See Also</h3>

<p><a href="#topic+tiers_sort">tiers_sort</a>, <a href="#topic+helper_tiers_new_table">helper_tiers_new_table</a>, <a href="#topic+helper_tiers_merge_tables">helper_tiers_merge_tables</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function applies to the tier tables that are necessary in \code{@tiers} of a transcript.
# object. For clarity, we will create such a table from scratch.

library(act)

# --- Create a tier table from scratch
tierTable &lt;- helper_tiers_new_table(c("a","b","c", "d"), 
c("IntervalTier", "TextTier","IntervalTier","TextTier"))

# --- Create a vector, defining the new order of the tiers.
sortVector &lt;- c("c","a","d","b")

# Sort the table
tierTable.1 &lt;- act::helper_tiers_sort_table(tierTable=tierTable, sortVector=sortVector)
tierTable.1

# --- Create a vector, in which the tier "c" is missing.
sortVector &lt;- c("a","b","d")

# Sort the table, the missing tier will be inserted at the end.
tierTable.1 &lt;- act::helper_tiers_sort_table(tierTable=tierTable, sortVector=sortVector)
tierTable.1

# --- Create a vector, in which the tier "c" is missing, 
# but define the place, where missing tiers will be inserted by "*"
sortVector &lt;- c("a","\\*", "b","d")

# Sort the table. The missing tier "c" will be inserted in second place.
tierTable.2 &lt;- act::helper_tiers_sort_table(tierTable=tierTable, sortVector=sortVector)
tierTable.2

# Sort the table, but delete tiers that are missing in the sort vector
# Note: If 'deleteTiersThatAreNotInTheSortVector=TRUE' tiers that are missing in the
# will be deleted, even if the 'sortVector' contains a "\*".
tierTable.3 &lt;- act::helper_tiers_sort_table(tierTable=tierTable, 
sortVector=sortVector, 
deleteTiersThatAreNotInTheSortVector=TRUE)
tierTable.3

# --- Create a vector, which contains tier names that are not present in 'tierTable'.
sortVector &lt;- c("c","a","x", "y", "d","b")
tierTable.4 &lt;- act::helper_tiers_sort_table(tierTable=tierTable, sortVector=sortVector)
tierTable.4

</code></pre>

<hr>
<h2 id='helper_transcriptNames_get'>Helper: Get names of all transcripts in a corpus</h2><span id='topic+helper_transcriptNames_get'></span>

<h3>Description</h3>

<p>Gets the names of all transcript objects in a corpus object based from the <code>@name</code> attribute of each transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_transcriptNames_get(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_transcriptNames_get_+3A_x">x</code></td>
<td>
<p>Corpus object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

act::helper_transcriptNames_get(examplecorpus)

</code></pre>

<hr>
<h2 id='helper_transcriptNames_make'>Helper: Makes valid names for all transcripts in a corpus</h2><span id='topic+helper_transcriptNames_make'></span>

<h3>Description</h3>

<p>Makes valid names for all transcript objects in a corpus object based on the names passed in 'transcriptNames' parameter.
In particular, the functions also corrects names, which have to be non-empty and unique.
The following options are performed in the mentioned order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_transcriptNames_make(
  transcriptNames,
  searchPatterns = character(),
  searchReplacements = character(),
  toUpperCase = FALSE,
  toLowerCase = FALSE,
  trim = FALSE,
  defaultForEmptyNames = "no_name"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_transcriptNames_make_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; Names of the transcripts to validate.</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_make_+3A_searchpatterns">searchPatterns</code></td>
<td>
<p>Vector of character strings; Search pattern as regular expression. Leave empty for no search-replace in the names.</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_make_+3A_searchreplacements">searchReplacements</code></td>
<td>
<p>Vector of character strings; Replacements for search. Leave empty for no search-replace in the names.</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_make_+3A_touppercase">toUpperCase</code></td>
<td>
<p>Logical; Convert transcript names all to upper case.</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_make_+3A_tolowercase">toLowerCase</code></td>
<td>
<p>Logical; Convert transcript names all to lower case.</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_make_+3A_trim">trim</code></td>
<td>
<p>Logical; Remove leading and trailing spaces in names.</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_make_+3A_defaultforemptynames">defaultForEmptyNames</code></td>
<td>
<p>Character string; Default value for empty transcript names (e.g., resulting from search-replace operations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# make some names with an empty value "" and a duplivate "d"
transcriptNames &lt;- c("a", "b", "", "d", "d")
act::helper_transcriptNames_make(transcriptNames)

</code></pre>

<hr>
<h2 id='helper_transcriptNames_set'>Helper: Set names of all transcripts in a corpus</h2><span id='topic+helper_transcriptNames_set'></span>

<h3>Description</h3>

<p>Sets the names of all transcript objects in a corpus object both in the names of the list <code>x@transcripts</code> and in the slot <code>@name</code> of each transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_transcriptNames_set(x, transcriptNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helper_transcriptNames_set_+3A_x">x</code></td>
<td>
<p>Corpus object</p>
</td></tr>
<tr><td><code id="helper_transcriptNames_set_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; new names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# get current names of the transcripts
names.old &lt;- act::helper_transcriptNames_get(examplecorpus)

# rename giving numbers as names
names.test &lt;- as.character(seq(1:length(names.old)))
test &lt;-  act::helper_transcriptNames_set(examplecorpus, names.test)
names(test@transcripts)

# create an error: empty name
## Not run: 
names.test &lt;- names.old
names.test[2] &lt;- " "
test &lt;-  act::helper_transcriptNames_set(examplecorpus, names.test)

## End(Not run)

# create an error: double names
## Not run: 
names.test &lt;- names.old
names.test[2] &lt;- names.test[1]
test &lt;-  act::helper_transcriptNames_set(examplecorpus, names.test)

## End(Not run)
</code></pre>

<hr>
<h2 id='import'>Import a single annotation file</h2><span id='topic+import'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_new</code>, <code>act::corpus_import</code> for importing annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import(..., transcriptName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_+3A_...">...</code></td>
<td>
<p>file path, contents of an annotation file or rPraat object; see description above.</p>
</td></tr>
<tr><td><code id="import_+3A_transcriptname">transcriptName</code></td>
<td>
<p>Character string; name of the transcript, if this parameter is set, the default name of the transcript will be changed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imports the contents of an annotation file and returns a transcript object.
</p>
<p>The input to this function in the parameter '...' may either be
(1) the path to an annotation file (Currently 'ELAN' .eaf, 'EXMARaLDA .exb and 'Praat' .TextGrid files),
(2) the contents of an annotation file obtained from the <code>@file.content</code> or by reading the contents of the files directly with <code>read.lines()</code> or
(3) a <code>rPraat</code> TextGrid object.
</p>
<p>Only the first input to '...' will be processed
</p>


<h3>Value</h3>

<p>Transcript object.
</p>


<h3>See Also</h3>

<p><code>corpus_import</code>, <code>corpus_new</code>, <code>import_eaf</code>, <code>import_exb</code>, <code>import_rpraat</code>, <code>import_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# To import an annotation file of your choice:
## Not run: 
	path &lt;- "PATH_TO_AN_EXISTING_FILE_ON_YOUR_COMPUTER"

## End(Not run)

# Path to a .TextGrid file that you want to read
filePath &lt;- system.file("extdata", "examplecorpus", "GAT", 
						"ARG_I_PAR_Beto.TextGrid", package="act")
t &lt;- act::import(filePath=filePath)
t

# Path to an .eaf file that you want to read
filePath &lt;- system.file("extdata", "examplecorpus", "SYNC", 
						"SYNC_rotar_y_flexionar.eaf", package="act")
t &lt;- act::import(filePath=filePath)
t

# Content of a .TextGrid file, e.g. as stored in \code{@file.content} 
# of a transcript object.
fileContent &lt;- examplecorpus@transcripts[['ARG_I_CHI_Santi']]@file.content
t &lt;- act::import(fileContent=fileContent)
t

# Content of an .eaf file, e.g. as stored in \code{@file.content} 
# of a transcript object.
fileContent &lt;- examplecorpus@transcripts[['SYNC_rotar_y_flexionar']]@file.content
t &lt;- act::import(fileContent=fileContent)
t

</code></pre>

<hr>
<h2 id='import_eaf'>Import a single 'ELAN' '*.eaf' file</h2><span id='topic+import_eaf'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_new</code>, <code>act::corpus_import</code> for importing annotation files.
</p>
<p>Imports the contents of a 'ELAN' .eaf file and returns a transcript object.
The input to this function is either the path to an .eaf file or the contents of a .eaf file obtained from the <code>@file.content</code> of an existing transcript object by <code>readLines()</code>.
If you pass 'fileContent' you need to pass 'transcriptName' as parameter, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_eaf(filePath = NULL, fileContent = NULL, transcriptName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_eaf_+3A_filepath">filePath</code></td>
<td>
<p>Character string; input path of a single 'ELAN' .eaf file.</p>
</td></tr>
<tr><td><code id="import_eaf_+3A_filecontent">fileContent</code></td>
<td>
<p>Vector of character strings; contents of an 'ELAN' .eaf file read by <code>readLines()</code>.</p>
</td></tr>
<tr><td><code id="import_eaf_+3A_transcriptname">transcriptName</code></td>
<td>
<p>Character string; name of the transcript.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note:
</p>

<ul>
<li><p> 'ELAN' offers a variety of tier types, some including dependencies from other tiers. Therefore not all annotations do actually have a time value. Missing values will be detected in the superordinate tier or will be interpolated. You will not be able to recognize interpolated values in the annotations.
</p>
</li>
<li><p> Please also note that dependencies between tiers in you .eaf file are not reflected in the transcript object within the act package.
</p>
</li></ul>



<h3>Value</h3>

<p>Transcript object.
</p>


<h3>See Also</h3>

<p><code>corpus_import</code>, <code>corpus_new</code>, <code>import</code>, <code>import_exb</code>, <code>import_rpraat</code>, <code>import_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Path to an .eaf file that you want to read
path &lt;- system.file("extdata", "examplecorpus", "SYNC", 
					"SYNC_rotar_y_flexionar.eaf", package="act")


# To import a .eaf file of your choice:
## Not run: 
path &lt;- "PATH_TO_AN_EXISTING_EAF_ON_YOUR_COMPUTER"

## End(Not run)


t &lt;- act::import_eaf(filePath=path)
t

# Content of an .eaf file (already read by \code{readLines}), 
# e.g. from an existing transcript object:
mycontent &lt;- examplecorpus@transcripts[['SYNC_rotar_y_flexionar']]@file.content
t &lt;- act::import_eaf(fileContent=mycontent, transcriptName="test")
t

</code></pre>

<hr>
<h2 id='import_exb'>Import a single 'EXMARaLDA' .exb file</h2><span id='topic+import_exb'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_new</code>, <code>act::corpus_import</code> for importing annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_exb(filePath = NULL, fileContent = NULL, transcriptName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_exb_+3A_filepath">filePath</code></td>
<td>
<p>Character string; input path of a single 'EXMARaLDA' .exb file.</p>
</td></tr>
<tr><td><code id="import_exb_+3A_filecontent">fileContent</code></td>
<td>
<p>Vector of character strings; contents of a 'EXMARaLDA' .exb file .</p>
</td></tr>
<tr><td><code id="import_exb_+3A_transcriptname">transcriptName</code></td>
<td>
<p>Character string; name of the transcript.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imports the contents of a 'EXMARaLDA' .exb file and returns a transcript object.
The source is either the path to a .exb file or the contents of a .exb file obtained from the <code>@file.content</code> of an existing transcript object.
If you pass 'fileContent' you need to pass 'transcriptName' as parameter, too.
</p>
<p>Please note:
</p>

<ul>
<li><p> 'EXMARaLDA' allows for empty time slots without a time values. Missing values will be interpolated during the import. You will not be able to recognize interpolated values in the data.
</p>
</li>
<li><p> Meta data for tiers (such as the display name etc.) will not be imported.
</p>
</li>
<li><p> Media files are referenced not by their path but only as file names in .exb files. The names will be imported but will not work as paths in act.
</p>
</li></ul>



<h3>Value</h3>

<p>Transcript object.
</p>


<h3>See Also</h3>

<p><code>corpus_import</code>, <code>corpus_new</code>, <code>import</code>, <code>import_eaf</code>, <code>import_rpraat</code>, <code>import_textgrid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

## Not run: 
	# To import a .TextGrid file of your choice:
	filePath &lt;- "PATH_TO_AN_EXISTING_TEXTGRID_ON_YOUR_COMPUTER"
	
	t &lt;- act::import_exb(filePath=filePath)
	t

## End(Not run)



</code></pre>

<hr>
<h2 id='import_rpraat'>Import a single 'rPraat' TextGrid object</h2><span id='topic+import_rpraat'></span>

<h3>Description</h3>

<p>This function is to create compatibility with the <code>rPraat</code> package.
It converts a 'rPraat' TextGrid object into an act transcript object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_rpraat(rPraatTextGrid, transcriptName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_rpraat_+3A_rpraattextgrid">rPraatTextGrid</code></td>
<td>
<p>List; rPraat TextGrid object.</p>
</td></tr>
<tr><td><code id="import_rpraat_+3A_transcriptname">transcriptName</code></td>
<td>
<p>Character string; name of the transcript.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note:
</p>

<ul>
<li><p> Time values of annotations in TextGrids may be below 0 seconds. Negative time values will be recognized corretly in the first place. When exporting transcript object to other formats like 'ELAN' .eaf, 'EXMARaLDA' .exb ect. annotations that are completely before 0 sec will be deleted, annotations that start before but end after 0 sec will be truncated. Please see also the function <code>act::transcripts_cure_single</code>.
</p>
</li>
<li><p> TextGrids and contained tiers may start and end at different times. These times do not need to match each other. The act package does not support start and end times of TextGrids and tiers and will. The default start of a TextGrid will be 0 seconds or the lowest value in case that annotations start below 0 seconds.
</p>
</li></ul>

<p>Credits: Thanks to Tomáš Bořil, the author of the rPraat package, for commenting on the exchange functions.
</p>


<h3>Value</h3>

<p>Transcript object.
</p>


<h3>See Also</h3>

<p><code>corpus_import</code>, <code>corpus_new</code>, <code>import</code>, <code>import_eaf</code>, <code>import_exb</code>, <code>import_textgrid</code>
</p>
<p><a href="#topic+export_rpraat">export_rpraat</a>, <a href="#topic+import">import</a>, <a href="#topic+import_textgrid">import_textgrid</a>, <a href="#topic+import_eaf">import_eaf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Path to the .TextGrid file that you want to read
path &lt;- system.file("extdata", "examplecorpus", "GAT", 
					"ARG_I_PAR_Beto.TextGrid", package="act")

# To import a .TextGrid file of your choice:
## Not run: 
	path &lt;- "PATH_TO_AN_EXISTING_TEXTGRID_ON_YOUR_COMPUTER"

## End(Not run)

# Make sure to have rPraat installed before you try the following
## Not run: 
	# Read TextGrid file with rPraat
	rPraat.tg &lt;- rPraat::tg.read(path)

	# Convert to an act transcript
	t &lt;- act::import_rpraat(rPraat.tg)
	
	# Change the name and add it to the examplecorpus
	t@name &lt;-"rpraat"
	newcorpus &lt;- act::transcripts_add(examplecorpus, t)
	
	# Have a look
	newcorpus@transcripts[["rpraat"]]
	
	# Alternatively, you can use the general import function
	t &lt;- act::import(rPraat.tg)

## End(Not run)
</code></pre>

<hr>
<h2 id='import_textgrid'>Import a single 'Praat' .TextGrid file</h2><span id='topic+import_textgrid'></span>

<h3>Description</h3>

<p>Advice: In most situations it is more convenient to use <code>act::corpus_new</code>, <code>act::corpus_import</code> for importing annotation files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_textgrid(filePath = NULL, fileContent = NULL, transcriptName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_textgrid_+3A_filepath">filePath</code></td>
<td>
<p>Character string; input path of a single 'Praat' .TextGrid file.</p>
</td></tr>
<tr><td><code id="import_textgrid_+3A_filecontent">fileContent</code></td>
<td>
<p>Vector of character strings; contents of a 'Praat' .TextGrid file read with <code>readLines()</code>.</p>
</td></tr>
<tr><td><code id="import_textgrid_+3A_transcriptname">transcriptName</code></td>
<td>
<p>Character string; name of the transcript.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imports the contents of a 'Praat' .TextGrid file and returns a transcript object.
The source is either the path to a .TextGrid file or the contents of a .TextGrid file obtained from the <code>@file.content</code> of an existing transcript object by <code>readLines()</code>.
If you pass 'fileContent' you need to pass 'transcriptName' as parameter, too.
</p>
<p>Please note:
</p>

<ul>
<li><p> Time values of annotations in TextGrids may be below 0 seconds. Negative time values will be recognized corretly in the first place. When exporting transcript object to other formats like 'ELAN' .eaf, 'EXMARaLDA' .exb ect. annotations that are completely before 0 sec will be deleted, annotations that start before but end after 0 sec will be truncated. Please see also the function <code>act::transcripts_cure_single</code>.
</p>
</li>
<li><p> TextGrids and contained tiers may start and end at different times. These times do not need to match each other. The act package does not support start and end times of TextGrids and tiers and will. The default start of a TextGrid will be 0 seconds or the lowest value in case that annotations start below 0 seconds.
</p>
</li></ul>



<h3>Value</h3>

<p>Transcript object.
</p>


<h3>See Also</h3>

<p><code>corpus_import</code>, <code>corpus_new</code>, <code>import</code>, <code>import_eaf</code>, <code>import_exb</code>, <code>import_rpraat</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Path to the .TextGrid file that you want to read
path &lt;- system.file("extdata", "examplecorpus", "GAT", 
					"ARG_I_PAR_Beto.TextGrid", package="act")

# To import a .TextGrid file of your choice:
## Not run: 
path &lt;- "PATH_TO_AN_EXISTING_TEXTGRID_ON_YOUR_COMPUTER"

## End(Not run)


t &lt;- act::import_textgrid(filePath=path)
t


# Content of a .TextGrid (already read by \code{readLines}), 
# e.g. from an existing transcript object:
mycontent &lt;- examplecorpus@transcripts[[1]]@file.content
t &lt;- act::import_textgrid(fileContent=mycontent, transcriptName="test")
t

</code></pre>

<hr>
<h2 id='info'>Information about corpus and transcript objects</h2><span id='topic+info'></span>

<h3>Description</h3>

<p>Gives detailed information about the contents of a corpus object or a transcript object that is passed as parameter to the function.
In the case that you want to pass a transcript object form a corpus object, make sure that you access the transcript using double [[]] brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_+3A_...">...</code></td>
<td>
<p>object; either  a corpus or a transcript object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get summarized information about the transcript and corpus objects use <code>act::info_summarized</code>.
</p>


<h3>Value</h3>

<p>List.
</p>


<h3>See Also</h3>

<p><a href="#topic+info_summarized">info_summarized</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

act::info(examplecorpus)

act::info(examplecorpus@transcripts[[1]])


</code></pre>

<hr>
<h2 id='info_summarized'>Summarized information about corpus and transcript objects</h2><span id='topic+info_summarized'></span>

<h3>Description</h3>

<p>Gives summarized information about the contents of a corpus object or a transcript object that is passed as parameter to the function.
In the case that you want to pass a transcript object form a corpus object, make sure that you access the transcript using double [[]] brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_summarized(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_summarized_+3A_...">...</code></td>
<td>
<p>object; either  a corpus or a transcript object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get more detailed information about the tiers in a corpus object use <code>act::info</code>.
</p>


<h3>Value</h3>

<p>List.
</p>


<h3>See Also</h3>

<p><a href="#topic+info">info</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

act::info_summarized(examplecorpus)

act::info_summarized(examplecorpus@transcripts[[1]])

</code></pre>

<hr>
<h2 id='layout-class'>Layout object, defining the layout of print transcripts</h2><span id='topic+layout-class'></span>

<h3>Description</h3>

<p>You can create an new layout object with <code>methods::new("layout")</code>.
This will give you a new layout object with the default settings uses by act.
If you want to modify the layout of the print transcripts, create a new layout object with <code>mylayout &lt;- methods::new("layout")</code>, modify the values in the <code>@slots</code> and pass it as argument <code>l</code> to the respective functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Character string; Name of the layout.</p>
</dd>
<dt><code>filter.tier.includeRegEx</code></dt><dd><p>Character string; as regular expression, tiers matching the expression will be included in the print transcript.</p>
</dd>
<dt><code>filter.tier.excludeRegEx</code></dt><dd><p>Character string; as regular expression, tiers matching the expression will be excluded from the print transcript.</p>
</dd>
<dt><code>transcript.width</code></dt><dd><p>Integer; width of transcript, -1 for no line wrapping.</p>
</dd>
<dt><code>speaker.width</code></dt><dd><p>Integer; width of speaker abbreviation, -1 for full name without shortening.</p>
</dd>
<dt><code>speaker.ending</code></dt><dd><p>Character string; string that is added at the end of the speaker name.</p>
</dd>
<dt><code>spacesbefore</code></dt><dd><p>Integer; number of spaces inserted before line number.</p>
</dd>
<dt><code>additionalline1.insert</code></dt><dd><p>Logical; if <code>TRUE</code> an additional dummy line will be inserted after each annotation line, the text is defined in <code>.additionalline1.text</code>.</p>
</dd>
<dt><code>additionalline1.text</code></dt><dd><p>Character string; Content of additional dummy line 1.</p>
</dd>
<dt><code>additionalline1.indent</code></dt><dd><p>Logical; if <code>TRUE</code> the content of the dummy line 1 will be indented to begin where the content of the annotations start.</p>
</dd>
<dt><code>additionalline2.insert</code></dt><dd><p>Logical; if <code>TRUE</code> an additional dummy line will be inserted after each annotation line, the text is defined in <code>.additionalline2.text</code>.</p>
</dd>
<dt><code>additionalline2.text</code></dt><dd><p>Character string; Content of additional dummy line 2.</p>
</dd>
<dt><code>additionalline2.indent</code></dt><dd><p>Logical; if <code>TRUE</code> the content of the dummy line 2 will be indented to begin where the content of the annotations start.</p>
</dd>
<dt><code>brackets.tryToAlign</code></dt><dd><p>Logical; if <code>TRUE</code> act will try to align brackets [] for parallel speaking (Attention: experimental function; results may not satisfy).</p>
</dd>
<dt><code>pauseTierRegEx</code></dt><dd><p>Character string; regular expression to identify pause tier for auto formatting pauses.</p>
</dd>
<dt><code>header.insert</code></dt><dd><p>Logical; if <code>TRUE</code> a transcript header is inserted.</p>
</dd>
<dt><code>header.heading.fromColumnName</code></dt><dd><p>Character string; is only used when transcripts are made based on a search results; defines from which column of a search results table the heading is taken (if <code>object@.header.insert==TRUE</code>)</p>
</dd>
<dt><code>header.firstInfo.fromColumnName</code></dt><dd><p>Character string; is only used when transcripts are made based on a search results; defines from which column of a search results table the first info is taken (if <code>object@.header.insert==TRUE</code>)</p>
</dd>
<dt><code>arrow.insert</code></dt><dd><p>Logical; is only used when transcripts are made based on a search results; if <code>TRUE</code> an arrow will be inserted, highlighting the transcript line containing the search hit.</p>
</dd>
<dt><code>arrow.shape</code></dt><dd><p>Character string; shape of the arrow.</p>
</dd>
</dl>

<hr>
<h2 id='matrix_load'>Load replacement matrix</h2><span id='topic+matrix_load'></span>

<h3>Description</h3>

<p>This function is only for checking how the normalization matrix will be loaded internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_load(path = NULL, myFileEncoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_load_+3A_path">path</code></td>
<td>
<p>Character string; path to the replacement matrix (a CSV file). If argument is left open, the default replacement matrix of the package will be returned.</p>
</td></tr>
<tr><td><code id="matrix_load_+3A_myfileencoding">myFileEncoding</code></td>
<td>
<p>Character string; encoding of the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# An example replacement matrix comes with the package.
path &lt;- system.file("extdata", "normalization", "normalizationMatrix.csv", package="act")

# Load the matrix
mymatrix &lt;- act::matrix_load(path)

# Have a look at the matrix
colnames(mymatrix)
mymatrix

#the original path of the matrix is stored in the attributes
attr(mymatrix, 'path') 
</code></pre>

<hr>
<h2 id='matrix_save'>Save replacement matrix</h2><span id='topic+matrix_save'></span>

<h3>Description</h3>

<p>Save replacement matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_save(replacementMatrix, path, myFileEncoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_save_+3A_replacementmatrix">replacementMatrix</code></td>
<td>
<p>Data frame; replacement matrix.</p>
</td></tr>
<tr><td><code id="matrix_save_+3A_path">path</code></td>
<td>
<p>Character string; path where the matrix will be saved.</p>
</td></tr>
<tr><td><code id="matrix_save_+3A_myfileencoding">myFileEncoding</code></td>
<td>
<p>Character string; encoding of the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# An example replacement matrix comes with the package.
path &lt;- system.file("extdata", "normalization", "normalizationMatrix.csv", package="act")

# Load the matrix
mymatrix &lt;- act::matrix_load(path)

# ' # Create temporary file path
path &lt;- tempfile(pattern = "mymatrix", tmpdir=tempdir(),  fileext = ".csv")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer:
## Not run: 
path &lt;- file.path("PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
                  "mymatrix.csv")

## End(Not run)

# Save the matrix
act::matrix_save(mymatrix, path=path)

</code></pre>

<hr>
<h2 id='media_assign'>Assign media file links to transcript objects</h2><span id='topic+media_assign'></span>

<h3>Description</h3>

<p>Searches for media files in folders and assigns the links to transcript objects in a corpus.
The function uses the name of the transcript to find the media files,
e.g. the function assumes that the annotation files have the same name as the media files, except from the suffix/the file type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>media_assign(
  x,
  searchPaths = NULL,
  searchInSubfolders = TRUE,
  filterFile = "",
  transcriptNames = NULL,
  deleteExistingMedia = TRUE,
  onlyUniqueFiles = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="media_assign_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="media_assign_+3A_searchpaths">searchPaths</code></td>
<td>
<p>Vector of character strings; paths where media files should be searched; if path is not defined, the paths given in <code>x@paths.media.files</code> will be used).</p>
</td></tr>
<tr><td><code id="media_assign_+3A_searchinsubfolders">searchInSubfolders</code></td>
<td>
<p>Logical; if <code>FALSE</code> only the main level of the directory will be scanned for media, if <code>TRUE</code> sub folders will be scanned for media, too.</p>
</td></tr>
<tr><td><code id="media_assign_+3A_filterfile">filterFile</code></td>
<td>
<p>Character string; Regular expression of files to look for.</p>
</td></tr>
<tr><td><code id="media_assign_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; Names of the transcripts for which you want to search media files; leave empty if you want to search media for all transcripts in the corpus object.</p>
</td></tr>
<tr><td><code id="media_assign_+3A_deleteexistingmedia">deleteExistingMedia</code></td>
<td>
<p>Logical; if <code>TRUE</code> existing media links will be deleted, if <code>FALSE</code> existing media links will be preserved and new links will be added.</p>
</td></tr>
<tr><td><code id="media_assign_+3A_onlyuniquefiles">onlyUniqueFiles</code></td>
<td>
<p>Logical; if <code>TRUE</code> media files with the same name (in different locations) will only be added once; if <code>FALSE</code> all media files found will be added, irrespective of possible doublets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the the file types set in <code>options()$act.fileformats.audio</code> and <code>options()$act.fileformats.video</code> will be recognized.
You can modify these options to recognize other media types.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+media_delete">media_delete</a>, <a href="#topic+media_getPathToExistingFile">media_getPathToExistingFile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Set the folder(s) where your media files are located in the corpus object
# Please be aware that that the example corpus that comes with the package
# does NOT contain media files. Please download the entire example corpus
# with media files if you want to use this function reasonably.
examplecorpus@paths.media.files &lt;- c("", "")

examplecorpus &lt;- act::media_assign(examplecorpus)

</code></pre>

<hr>
<h2 id='media_delete'>Delete media files links from transcript objects</h2><span id='topic+media_delete'></span>

<h3>Description</h3>

<p>Delete media files links from transcript objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>media_delete(x, transcriptNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="media_delete_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="media_delete_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; Names of the transcripts for which you want to search media files; leave empty if you want to search media for all transcripts in the corpus object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+media_assign">media_assign</a>, <a href="#topic+media_getPathToExistingFile">media_getPathToExistingFile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

examplecorpus &lt;- act::media_delete(examplecorpus)

</code></pre>

<hr>
<h2 id='media_getPathToExistingFile'>Gets the path of a media file for a transcript</h2><span id='topic+media_getPathToExistingFile'></span>

<h3>Description</h3>

<p>Gets the path of a media file for a transcript
</p>


<h3>Usage</h3>

<pre><code class='language-R'>media_getPathToExistingFile(
  t,
  filterMediaFile = c(".*\\.(mp4|mov)", ".*\\.(aiff|aif|wav)", ".*\\.mp3")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="media_getPathToExistingFile_+3A_t">t</code></td>
<td>
<p>transcript object; transcript for which you want to get the media path.</p>
</td></tr>
<tr><td><code id="media_getPathToExistingFile_+3A_filtermediafile">filterMediaFile</code></td>
<td>
<p>Vector of character strings; Each element of the vector is a regular expression. Expressions will be checked consecutively. The first match with an existing media file will be used for playing. The default checking order is video &gt; uncompressed audio &gt; compressed audio.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string; path to a media file, or <code>NULL</code> if no existing media file has been found.
</p>


<h3>See Also</h3>

<p><a href="#topic+media_assign">media_assign</a>, <a href="#topic+media_delete">media_delete</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Please be aware that that the example corpus that comes with the package
# does NOT contain media files. Please download the entire example corpus
# with media files if you want to use this function reasonably.

# You can access the media files linked to a transcript directly using
# the object properties.
examplecorpus@transcripts[["SYNC_rotar_y_flexionar"]]@media.path

# Get only media files of a certain type, e.g. a wav file, and return only the first match:
act::media_getPathToExistingFile(examplecorpus@transcripts[["SYNC_rotar_y_flexionar"]],
 filterMediaFile=".*\\.wav")
</code></pre>

<hr>
<h2 id='options_delete'>delete all options set by the package from R options</h2><span id='topic+options_delete'></span>

<h3>Description</h3>

<p>delete all options set by the package from R options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_delete()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)
act::options_delete()
</code></pre>

<hr>
<h2 id='options_reset'>Reset options to default values</h2><span id='topic+options_reset'></span>

<h3>Description</h3>

<p>Reset options to default values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_reset()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)
act::options_reset()
</code></pre>

<hr>
<h2 id='options_show'>Options of the package</h2><span id='topic+options_show'></span>

<h3>Description</h3>

<p>The package has numerous options that change the internal workings of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_show()
</code></pre>


<h3>Details</h3>

<p>There are several options that change the way the package works. They are set globally.
</p>

<ul>
<li><p> Use <code>options(name.of.option = value)</code> to set an option.
</p>
</li>
<li><p> Use <code>options()$name.of.option</code> to get the current value of an option.
</p>
</li>
<li><p> Use <code>act::options_reset</code> to set all options to the default value.
</p>
</li>
<li><p> Use <code>act::options_delete</code> to clean up and delete all option settings.
</p>
</li></ul>

<p>The package uses the following options.
</p>
<p><em>Program</em>
</p>

<ul>
<li> <p><code>act.excamplecorpusURL</code> character strings; where to download example media files.
</p>
</li>
<li> <p><code>act.updateX</code> Logical; If <code>TRUE</code> the original corpus object 'x' passed passed to the search functions <code>search_new</code> and <code>search_run</code> will also be updated, in case that during the search fulltexts are created or the normalization is performed.
</p>
</li>
<li> <p><code>act.showprogress</code> logical; if <code>TRUE</code> a progress bar will be shown during (possibly) time consuming operations.
</p>
</li></ul>

<p><em>Paths</em>
</p>

<ul>
<li> <p><code>act.path.praat</code> Character string; path to the 'Praat' executable on your computer. Only necessary if you use the functions to remote control Praat using Praat scripts.
</p>
</li>
<li> <p><code>act.path.sendpraat</code> Character string; path to the 'sendpraat' executable on your computer. Only necessary if you use the functions to remote control Praat using Praat scripts.
</p>
</li>
<li> <p><code>act.path.elan</code> Character string; path to the 'ELAN' executable on your computer. Only necessary if you want to open search results in ELAN.
</p>
</li></ul>

<p><em>File formats</em>
</p>

<ul>
<li> <p><code>act.fileformats.video</code> Vector of character strings; Suffixes of video files that will be identified; default is 'c(&quot;mp4&quot;, &quot;mov&quot;)'.
</p>
</li>
<li> <p><code>act.fileformats.audio</code> Vector of character strings; Suffixes of audio files that will be identified; default is 'c(&quot;wav&quot;, &quot;aif&quot;, &quot;mp3&quot;)'.
</p>
</li></ul>

<p><em>FFMPEG commands and options</em>
</p>

<ul>
<li> <p><code>act.ffmpeg.command</code> Character string; 'FFmpeg' command that is used for cutting video files.
</p>
</li>
<li> <p><code>act.ffmpeg.command.fastVideoPostioning</code> Character string; 'FFmpeg' command that is used for cutting video files using the 'FFmpeg' option  'fast video positioning'. This is considerably faster when working with long video files.
</p>
</li>
<li> <p><code>act.ffmpeg.command.audio</code> Character string; 'FFmpeg' command that is used for cutting/generating uncompressed audio files.
</p>
</li>
<li> <p><code>act.ffmpeg.exportchannels.fromColumnName</code> Character string; Name of the column in the data frame <code>s@results</code> from information, which audio channel to export, will be taken.
</p>
</li></ul>

<p><em>Import annotation files</em>
</p>

<ul>
<li> <p><code>act.import.readEmptyIntervals</code> Logical; if <code>TRUE</code> empty intervals in you annotation files will be read, if <code>FALSE</code> empty intervals will be skipped.
</p>
</li>
<li> <p><code>act.import.scanSubfolders</code> Logical; if <code>TRUE</code> sub folders will also be scanned for annotation files; if <code>FALSE</code> only the main level of the folders specified in <code>paths.annotation.files</code> of your corpus object will be scanned.
</p>
</li>
<li> <p><code>act.import.storeFileContentInTranscript</code> if <code>TRUE</code> the contents of the original annotation file will be stored in <code>transcript@file.content</code>. Set to <code>FALSE</code> if you want to keep your corpus object small.
</p>
</li></ul>

<p><em>Export</em>
</p>

<ul>
<li> <p><code>act.export.foldergrouping1.fromColumnName</code> Character string; Name of sub folders that will be created in the folder of the search result, level 1.
</p>
</li>
<li> <p><code>act.export.foldergrouping2.fromColumnName</code>  Character string; Name of sub folders that will be created in the folder of the search result, level 2.
</p>
</li>
<li> <p><code>act.export.filename.fromColumnName</code>  Character string; Name of the column from which the file names for exported files will be taken.
</p>
</li></ul>

<p><em>Miscellaneous</em>
</p>

<ul>
<li> <p><code>act.separator_between_intervals</code> Character; Single character that is used for separating intervals when creating the full text.
</p>
</li>
<li> <p><code>act.separator_between_tiers</code> Character; Single character that is used for separating tiers when creating the full text.
</p>
</li>
<li> <p><code>act.separator_between_words</code> Character string; regular expression with alternatives that count as separators between words. Used for preparing the concordance.
</p>
</li>
<li> <p><code>act.wordCountRegEx</code> Character string; regular expression that is used to count words.
</p>
</li></ul>



<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)
## Not run: 
act::options_show()

## End(Not run)


</code></pre>

<hr>
<h2 id='search_concordance'>Make concordance for search results</h2><span id='topic+search_concordance'></span>

<h3>Description</h3>

<p>Make concordance for search results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_concordance(x, s, searchNormalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_concordance_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_concordance_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_concordance_+3A_searchnormalized">searchNormalized</code></td>
<td>
<p>Logical; if <code>TRUE</code> function will search in the normalized content, if <code>FALSE</code> function will search in the original content.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Search object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search for the 1. Person Singular Pronoun in Spanish
# Search without creating the concordance immediately.
# This is for example useful if you are working with a large corpus, since
# making the concordance may take a while.
mysearch &lt;- act::search_new(examplecorpus, pattern="yo", concordanceMake=FALSE)
mysearch@results[1,]


# The results do not contain the concordance, it is only 15 columns
ncol(mysearch@results)

# Make the concordance
mysearch.new &lt;- act::search_concordance(x=examplecorpus, s=mysearch)
ncol(mysearch.new@results)
</code></pre>

<hr>
<h2 id='search_cuts'>Create print transcripts, media cutlists and srt subtitles for all search results</h2><span id='topic+search_cuts'></span>

<h3>Description</h3>

<p>This function will call the following functions:
</p>

<ul>
<li> <p><code>act_cuts_printtranscript</code> to create print transcripts,
</p>
</li>
<li> <p><code>act::cuts_media</code> to create FFmpeg cutlist to make media snippets,
</p>
</li>
<li> <p><code>act::search_cuts_srt()</code> to create .srt subtitles,
for all  search results.
</p>
</li></ul>

<p>For a detailed description including examples please refer to the documentation of the indidival functions.
They also offer some more parameters than this functions. If you want to use those, call the functions individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cuts(
  x,
  s,
  cutSpanBeforesec = NULL,
  cutSpanAftersec = NULL,
  l = NULL,
  outputFolder = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cuts_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_cuts_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_cuts_+3A_cutspanbeforesec">cutSpanBeforesec</code></td>
<td>
<p>Double; Start the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_+3A_cutspanaftersec">cutSpanAftersec</code></td>
<td>
<p>Double; End the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_+3A_l">l</code></td>
<td>
<p>Layout object.</p>
</td></tr>
<tr><td><code id="search_cuts_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Character string; if parameter is not set, the print transcripts will only be inserted in <code>s@results</code>; if the path to a existing folder is given transcripts will be saved in '.txt' format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Search object;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# IMPORTANT: In the example corpus all transcripts are assigned media links.
# The actual media files are, however, not included in when installing the package 
# due to size limitations of CRAN.
# But you may download the media files separately.
# Please see the section 'examplecorpus' for instructions. 
# --&gt; You will need the media files to execute the following example code.

## Not run: 
	# Search
	mysearch &lt;- act::search_new(examplecorpus, pattern="yo")
	
	# Create print transcripts, media cutlists and .srt subtitles 
	# for all search results
	test &lt;- act::search_cuts(x=examplecorpus, s=mysearch)
	
	# Display all print transcripts on screen from @cuts.printtranscripts
	cat(test@cuts.printtranscripts)
	
	# Display cutlist on screen from @cuts.cutlist.mac
	cat(test@cuts.cutlist.mac)
	
	# Display .srt subtitles
	cat(test@results[, mysearch@cuts.column.srt])

## End(Not run)

</code></pre>

<hr>
<h2 id='search_cuts_media'>Create cut lists for 'FFmpeg'</h2><span id='topic+search_cuts_media'></span>

<h3>Description</h3>

<p>This function creates FFmpeg commands to cut media files for each search results.
If you want to execute the commands (and cut the media files) you need to have FFmpeg installed on you computer. To install FFmpeg you can follow the instructions given in the vignette 'installation-ffmpeg'. Show the vignette with <code>vignette("installation-ffmpeg")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cuts_media(
  x,
  s,
  cutSpanBeforesec = NULL,
  cutSpanAftersec = NULL,
  outputFolder = NULL,
  filterMediaInclude = "",
  fastVideoPostioning = TRUE,
  videoCodecCopy = FALSE,
  audioCutsAsMP3 = FALSE,
  Panning = NULL,
  filename.append.medianame = FALSE,
  filename.append.separator = "__"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cuts_media_+3A_x">x</code></td>
<td>
<p>Corpus object; Please note: all media paths for a transcript need to be given as a list in the corpus object in <code>corpus@transcripts[[ ]]@media.path</code> . You can use the respective media functions. .</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_cutspanbeforesec">cutSpanBeforesec</code></td>
<td>
<p>Double; Start the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_cutspanaftersec">cutSpanAftersec</code></td>
<td>
<p>Double; End the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Character string; path to folder where files will be written.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_filtermediainclude">filterMediaInclude</code></td>
<td>
<p>Character string; regular expression to match only some of the media files in <code>corpus@transcripts[[ ]]@media.path</code>.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_fastvideopostioning">fastVideoPostioning</code></td>
<td>
<p>Logical; If <code>TRUE</code> the FFmpeg command will be using the parameter fast video positioning as specified in <code>options()$act.ffmpeg.command.fastVideoPostioning</code>.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_videocodeccopy">videoCodecCopy</code></td>
<td>
<p>Logical; if <code>TRUE</code> FFMPEG will use the option <em>codec copy</em> for videos.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_audiocutsasmp3">audioCutsAsMP3</code></td>
<td>
<p>Logical; If <code>TRUE</code> audio cuts will be exported as '.mp3' files, using  <code>options()$act.ffmpeg.command.audioCutsAsMP3</code>.</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_panning">Panning</code></td>
<td>
<p>Integer; 0=leave audio as is (ch1&amp;ch2) , 1=only channel 1 (ch1), 2=only channel 2 (ch2), 3=both channels separated (ch1&amp;ch2), 4=all three versions (ch1&amp;ch2, ch1, ch2). This setting will override the option made in 'act.ffmpeg.exportchannels.fromColumnName' .</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_filename.append.medianame">filename.append.medianame</code></td>
<td>
<p>Logical; if <code>TRUE</code> the file name of the original media file will be appended to the snippet(s).</p>
</td></tr>
<tr><td><code id="search_cuts_media_+3A_filename.append.separator">filename.append.separator</code></td>
<td>
<p>Character string; characters that separate the result id and the media file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Cut lists</em><br />
The commands are collected in cut lists.
The cut lists will be stored in different ways:
</p>

<ul>
<li><p> A cut list for for ALL search results will be stored in <code>s@cuts.cutlist.mac</code> to be used on MacOS and <code>s@cuts.cutlist.win</code> to be used on Windows.
</p>
</li>
<li><p> Individual cut lists for EACH search result will be stored in additional columns in the data frame <code>s@results</code>.
The cut lists that can be executed in the Terminal (Apple) or the Command Line Interface (Windows).
</p>
</li></ul>

<p><em>Input media files</em><br />
The function will use all files in  <code>corpus@transcripts[[ ]]@media.path</code>.
Therefore you will need to set the options <code>filterMediaInclude</code> filtering for which input media files you want to create the cuts.
The filter is a regular expression, e.g.  <code>'\.(wav|aif)'</code> for '.wav' and '.aif' audio files or <code>'\.mp4'</code> for '.mp4' video files.
</p>
<p><em>Output format</em><br />
The output format is predefined by in the options:
</p>

<ul>
<li> <p><code>act.ffmpeg.command</code> defines the basic FFmpeg command
</p>
</li>
<li> <p><code>act.ffmpeg.command.fastVideoPostioning</code> defines the FFmpeg command to be used with large video files.
</p>
</li></ul>

<p>The default is to generate mp4 video cuts. You can also use the following commands to change the output format:<br /><br />
MP4 video cuts with original video quality:
</p>

<ul>
<li> <p><code>options(act.ffmpeg.command                     = 'ffmpeg -i "INFILEPATH" -ss TIMESTART -t TIMEDURATION OPTIONS -y "OUTFILEPATH.mp4" -hide_banner')</code>
</p>
</li>
<li> <p><code>options(act.ffmpeg.command.fastVideoPostioning = 'ffmpeg -ss TIMESTARTMINUS10SECONDS -i "INFILEPATH" -ss 10.000 -t TIMEDURATION OPTIONS -y "OUTFILEPATH.mp4" -hide_banner')</code>
</p>
</li></ul>

<p>MP4 video cuts with reduced video quality:
</p>

<ul>
<li> <p><code>options(act.ffmpeg.command                     = 'ffmpeg -i "INFILEPATH" -ss TIMESTART -t TIMEDURATION OPTIONS -vf scale=1920:-1 -b:v 1M -b:a 192k -y "OUTFILEPATH.mp4" -hide_banner')</code>
</p>
</li>
<li> <p><code>options(act.ffmpeg.command.fastVideoPostioning = 'ffmpeg -ss TIMESTARTMINUS10SECONDS -i "INFILEPATH" -ss 10.000 -t TIMEDURATION OPTIONS -vf scale=1920:-1 -b:v 6M -b:a 192k -y "OUTFILEPATH.mp4" -hide_banner')</code>
</p>
</li></ul>

<p>WAV audio cuts:
</p>

<ul>
<li> <p><code>options(act.ffmpeg.command                     = 'ffmpeg -i "INFILEPATH" -ss TIMESTART -t TIMEDURATION OPTIONS -y "OUTFILEPATH.wav" -hide_banner')</code>
</p>
</li>
<li> <p><code>options(act.ffmpeg.command                     = 'ffmpeg -i "INFILEPATH" -ss TIMESTART -t TIMEDURATION OPTIONS -y "OUTFILEPATH.mp3" -hide_banner')</code>
</p>
</li></ul>

<p><em>Advanced options</em><br />
You can adjust the FFmpeg commands according to your needs.
The following options define the FFmpeg command that will be used by the package. The command needs to contain place holders which will be replaced by the actual values in the package. If you want to define your own ffmpeg command, please make sure to use the following placeholders:
</p>

<ul>
<li> <p><code>INFILEPATH</code> path to the input media file.
</p>
</li>
<li> <p><code>OUTFILEPATH</code> path where the output media file will be saved
</p>
</li>
<li> <p><code>OPTIONS</code> FFmpeg options that will be applied additionally, in particular fast video positioning.
</p>
</li>
<li> <p><code>TIMESTART</code> time in seconds where to begin the cutting
</p>
</li>
<li> <p><code>TIMESTARTMINUS10SECONDS</code> time in seconds where to begin the cutting, in case that fast video positioning is being used.
</p>
</li>
<li> <p><code>TIMEDURATION</code> duration of cuts.
</p>
</li></ul>



<h3>Value</h3>

<p>Search object; cut lists will be stored in <code>s@cuts.cutlist.mac</code> and <code>s@cuts.cutlist.win</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# IMPORTANT: In the example corpus all transcripts are assigned media links.
# The actual media files are, however, not included in when installing the package 
# due to size limitations of CRAN.
# But you may download the media files separately.
# Please see the section 'examplecorpus' for instructions. 
# --&gt; You will need the media files to execute the following example code.

## Not run: 
	# Search
	mysearch &lt;- act::search_new(examplecorpus, pattern="yo")
	
	# Create cut lists 
	mysearch &lt;- act::search_cuts_media (x=examplecorpus, s=mysearch)
	
	# Check results for Mac:
	# Get entire cut list for Mac and display on screen, 
	# so you can copy&amp;paste this into the Terminal
	mycutlist &lt;- mysearch@cuts.cutlist.mac 
	cat(mycutlist)
	# Cut list for first search result
	mycutlist &lt;- mysearch@results$cuts.cutlist.mac[[1]]
	cat(mycutlist)
	
	# Check results for Windows:
	# Get entire cut list for Mac and display on screen, 
	# so you can copy&amp;paste this into the CLI
	mycutlist &lt;- mysearch@cuts.cutlist.win 
	cat(mycutlist)
	# Cut list for first search result
	mycutlist &lt;- mysearch@results$cuts.cutlist.win[[1]]
	cat(mycutlist)
	
	# It is, however, more convenient to specify the argument 'outputFolder' in order to get
	# the cut list as a (executable) file/batch list.

## End(Not run)
</code></pre>

<hr>
<h2 id='search_cuts_printtranscript'>Create print transcripts for all search results</h2><span id='topic+search_cuts_printtranscript'></span>

<h3>Description</h3>

<p>Print transcripts in the style of conversation analysis will be created for each search result.
The transcripts will be inserted into the column defined in <code>s@cuts.column.printtranscript</code>.
All transcripts will be stored in <code>s@cuts.printtranscripts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cuts_printtranscript(
  x,
  s,
  cutSpanBeforesec = NULL,
  cutSpanAftersec = NULL,
  l = NULL,
  outputFolder = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cuts_printtranscript_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_cuts_printtranscript_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_cuts_printtranscript_+3A_cutspanbeforesec">cutSpanBeforesec</code></td>
<td>
<p>Double; Start the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_printtranscript_+3A_cutspanaftersec">cutSpanAftersec</code></td>
<td>
<p>Double; End the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_printtranscript_+3A_l">l</code></td>
<td>
<p>Layout object.</p>
</td></tr>
<tr><td><code id="search_cuts_printtranscript_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Character string; if parameter is not set, the print transcripts will only be inserted in <code>s@results</code>; if the path to a existing folder is given transcripts will be saved in '.txt' format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to modify the layout of the print transcripts, create a new layout object with <code>mylayout &lt;- methods::new("layout")</code>, modify the settings and pass it as argument <code>l</code>.
</p>


<h3>Value</h3>

<p>Search object;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search
mysearch &lt;- act::search_new(examplecorpus, pattern="yo")

# Create print transcripts for all search results
test &lt;- act::search_cuts_printtranscript (x=examplecorpus, s=mysearch)

# Display all print transcripts on screen from @cuts.printtranscripts
cat(test@cuts.printtranscripts)

# Display all print transcripts from results data frame
cat(test@results[,mysearch@cuts.column.printtranscript])
cat(test@results[,mysearch@cuts.column.printtranscript])

# Only single print transcript from results data frame
cat(test@results[1,mysearch@cuts.column.printtranscript])

# Create print transcript snippets including 1 sec before and 5 sec after
mysearch@cuts.span.beforesec =1
mysearch@cuts.span.aftersec = 5
test &lt;- act::search_cuts_printtranscript (x=examplecorpus,
s=mysearch)

# Display all transcript snippets on screen
cat(test@results[,mysearch@cuts.column.printtranscript])
</code></pre>

<hr>
<h2 id='search_cuts_srt'>Create .srt subtitles for all search results</h2><span id='topic+search_cuts_srt'></span>

<h3>Description</h3>

<p>Subtitles in 'Subrib Title' .srt format will be created for each search result.
The subtitles will be inserted into the column defined in <code>s@cuts.column.srt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_cuts_srt(
  x,
  s,
  cutSpanBeforesec = NULL,
  cutSpanAftersec = NULL,
  outputFolder = NULL,
  speaker.show = TRUE,
  speaker.width = 3,
  speaker.ending = ":"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_cuts_srt_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_cutspanbeforesec">cutSpanBeforesec</code></td>
<td>
<p>Double; Start the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_cutspanaftersec">cutSpanAftersec</code></td>
<td>
<p>Double; End the cut some seconds before the hit to include some context; the default NULL will take the value as set in @cuts.span.beforesec of the search object.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Character string; if parameter is not set, the srt subtitles will only be inserted in <code>s@results</code>; if the path to a existing folder is given transcripts will be saved in '.srt' format.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_speaker.show">speaker.show</code></td>
<td>
<p>Logical; if <code>TRUE</code> name of speaker will be shown before the content of the annotation.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_speaker.width">speaker.width</code></td>
<td>
<p>Integer; width of speaker abbreviation, -1 for full name without shortening.</p>
</td></tr>
<tr><td><code id="search_cuts_srt_+3A_speaker.ending">speaker.ending</code></td>
<td>
<p>Character string; string that is added at the end of the speaker name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Span</em> <br />
If you want to extend the cut before or after each search result, you can modify <code>@cuts.span.beforesec</code> and <code>@cuts.span.aftersec</code> in your search object.
If you want to modify the layout of the print transcripts, create a new layout object with <code>mylayout &lt;- methods::new("layout")</code>, modify the settings and pass it as argument <code>l</code>.
</p>


<h3>Value</h3>

<p>Search object;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search
mysearch &lt;- act::search_new(examplecorpus, pattern="yo")

# Create srt subtitles for all search results
test &lt;- act::search_cuts_srt (x=examplecorpus, s=mysearch)

# Display srt subtitle of first three results
cat(test@results[1:3, mysearch@cuts.column.srt])

# Create srt subtitle including 1 sec before and 5 sec after
mysearch@cuts.span.beforesec = 1
mysearch@cuts.span.aftersec = 5
test &lt;- act::search_cuts_srt (x=examplecorpus,
								s=mysearch)

# Display srt subtitle of first  results
cat(test@results[1,mysearch@cuts.column.srt])
</code></pre>

<hr>
<h2 id='search_makefilter'>Makes a filter for transcript and tier names</h2><span id='topic+search_makefilter'></span>

<h3>Description</h3>

<p>Search a corpus object and return the names of all transcripts and tiers that match the given parameters.
You can define parameters to include and/or exclude transcripts and tiers based on their names.
All parameters passed to the function will be combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_makefilter(
  x,
  filterTranscriptNames = NULL,
  filterTranscriptIncludeRegEx = NULL,
  filterTranscriptExcludeRegEx = NULL,
  filterTierNames = NULL,
  filterTierIncludeRegEx = NULL,
  filterTierExcludeRegEx = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_makefilter_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_makefilter_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; Names of the transcripts that you want to include; to include all transcripts in the corpus object leave parameter empty or set to  <code>character()</code> or <code>""</code>.</p>
</td></tr>
<tr><td><code id="search_makefilter_+3A_filtertranscriptincluderegex">filterTranscriptIncludeRegEx</code></td>
<td>
<p>Character string; as regular expression, include transcripts matching the expression.</p>
</td></tr>
<tr><td><code id="search_makefilter_+3A_filtertranscriptexcluderegex">filterTranscriptExcludeRegEx</code></td>
<td>
<p>Character string; as regular expression, exclude transcripts matching the expression.</p>
</td></tr>
<tr><td><code id="search_makefilter_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; Names of the tiers that you want to include; to include all tiers in the corpus object leave parameter empty or set to  <code>character()</code> or <code>""</code>.</p>
</td></tr>
<tr><td><code id="search_makefilter_+3A_filtertierincluderegex">filterTierIncludeRegEx</code></td>
<td>
<p>Character string; as regular expression, include tiers matching the expression.</p>
</td></tr>
<tr><td><code id="search_makefilter_+3A_filtertierexcluderegex">filterTierExcludeRegEx</code></td>
<td>
<p>Character string; as regular expression, exclude tiers matching the expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions is useful if you want to use functions of the package such as <code>transcripts_update_normalization</code>, <code>transcripts_update_fulltexts</code>, <code>corpus_export</code> and limit them to only some of the transcripts.
</p>


<h3>Value</h3>

<p>List of character vectors. <code>$filterTranscriptNames</code> contains all transcript names in the corpus matching the expressions, <code>$filterTierNames</code> contains all tier names in the corpus matching the expressions.
</p>


<h3>See Also</h3>

<p><a href="#topic+search_new">search_new</a>, <a href="#topic+search_run">search_run</a>, <a href="#topic+search_sub">search_sub</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search all transcripts that have "ARG" (ignoring case sensitivity) in their name
myfilter &lt;- act::search_makefilter(x=examplecorpus, filterTranscriptIncludeRegEx="(?i)arg")
myfilter$transcript.names

# Search all transcripts that don't have "ARG" in their name
myfilter &lt;- act::search_makefilter(x=examplecorpus, filterTranscriptExcludeRegEx="ARG")
myfilter$transcript.names

# Search all tiers that have an "A" or an "a" in their name
myfilter &lt;- act::search_makefilter(x=examplecorpus, filterTierIncludeRegEx="(?i)A")
myfilter$tier.names

# Search all tiers that have a capital "A" in their name
myfilter &lt;- act::search_makefilter(x=examplecorpus, filterTierIncludeRegEx="A")
myfilter$tier.names

# In which transcripts do these tiers occur?
myfilter$transcript.names

# Let's check the first of the transcripts, if this is really the case...
examplecorpus@transcripts[[myfilter$transcript.names[1]]]@tiers

</code></pre>

<hr>
<h2 id='search_new'>Create a new search</h2><span id='topic+search_new'></span>

<h3>Description</h3>

<p>Creates a new search object and runs the search in a corpus object.
Only 'x' and 'pattern' are obligatory.
The other arguments can be left to their default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_new(
  x,
  pattern,
  searchMode = c("content", "fulltext", "fulltext.byTime", "fulltext.byTier"),
  searchNormalized = TRUE,
  name = "mysearch",
  resultid.prefix = "result",
  resultid.start = 1,
  filterTranscriptNames = NULL,
  filterTranscriptIncludeRegEx = NULL,
  filterTranscriptExcludeRegEx = NULL,
  filterTierNames = NULL,
  filterTierIncludeRegEx = NULL,
  filterTierExcludeRegEx = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  concordanceMake = TRUE,
  concordanceWidth = NULL,
  cutSpanBeforesec = 0,
  cutSpanAftersec = 0,
  runSearch = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_new_+3A_x">x</code></td>
<td>
<p>Corpus object; basis in which will be searched.</p>
</td></tr>
<tr><td><code id="search_new_+3A_pattern">pattern</code></td>
<td>
<p>Character string; search pattern as regular expression.</p>
</td></tr>
<tr><td><code id="search_new_+3A_searchmode">searchMode</code></td>
<td>
<p>Character string; takes the following values: <code>content</code>, <code>fulltext</code> (=default, includes both full text modes), <code>fulltext.byTime</code>, <code>fulltext.byTier</code>.</p>
</td></tr>
<tr><td><code id="search_new_+3A_searchnormalized">searchNormalized</code></td>
<td>
<p>Logical; if <code>TRUE</code> function will search in the normalized content, if <code>FALSE</code> function will search in the original content.</p>
</td></tr>
<tr><td><code id="search_new_+3A_name">name</code></td>
<td>
<p>Character string; name of the search. Will be used, for example, as name of the sub folder when creating media cuts.</p>
</td></tr>
<tr><td><code id="search_new_+3A_resultid.prefix">resultid.prefix</code></td>
<td>
<p>Character string; search results will be numbered consecutively; This character string will be placed before the consecutive numbers.</p>
</td></tr>
<tr><td><code id="search_new_+3A_resultid.start">resultid.start</code></td>
<td>
<p>Integer; search results will be numbered consecutively; This is the start number of the identifiers.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of transcripts to be included.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtertranscriptincluderegex">filterTranscriptIncludeRegEx</code></td>
<td>
<p>Character string; as regular expression, limit search to certain transcripts matching the expression.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtertranscriptexcluderegex">filterTranscriptExcludeRegEx</code></td>
<td>
<p>Character string; as regular expression, exclude certain transcripts matching the expression.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be included.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtertierincluderegex">filterTierIncludeRegEx</code></td>
<td>
<p>Character string; as regular expression, limit search to certain tiers matching the expression.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtertierexcluderegex">filterTierExcludeRegEx</code></td>
<td>
<p>Character string; as regular expression, exclude certain tiers matching the expression.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double; start time of region for search.</p>
</td></tr>
<tr><td><code id="search_new_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double; end time of region for search.</p>
</td></tr>
<tr><td><code id="search_new_+3A_concordancemake">concordanceMake</code></td>
<td>
<p>Logical; if <code>TRUE</code> concordance will be added to search results.</p>
</td></tr>
<tr><td><code id="search_new_+3A_concordancewidth">concordanceWidth</code></td>
<td>
<p>Integer; number of characters  to the left and right of the search hit in the concordance , the default is <code>120</code>.</p>
</td></tr>
<tr><td><code id="search_new_+3A_cutspanbeforesec">cutSpanBeforesec</code></td>
<td>
<p>Double; Start the media and transcript cut some seconds before the hit to include some context, the default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="search_new_+3A_cutspanaftersec">cutSpanAftersec</code></td>
<td>
<p>Double; End the media and transcript cut some seconds before the hit to include some context, the default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="search_new_+3A_runsearch">runSearch</code></td>
<td>
<p>Logical; if <code>TRUE</code> search will be run in corpus object, if <code>FALSE</code> only the search object will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Search object.
</p>


<h3>See Also</h3>

<p><a href="#topic+search_run">search_run</a>, <a href="#topic+search_makefilter">search_makefilter</a>, <a href="#topic+search_sub">search_sub</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search for the 1. Person Singular Pronoun in Spanish.
mysearch &lt;- act::search_new(examplecorpus, pattern= "yo")
mysearch
# Search in normalized content vs. original content
mysearch.norm  &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=TRUE)
mysearch.org   &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=FALSE)
mysearch.norm@results.nr
mysearch.org@results.nr

# The difference is because during normalization capital letters will be converted
# to small letters. One annotation in the example corpus contains a "yo" with a
# capital letter:
mysearch &lt;- act::search_new(examplecorpus, pattern="yO", searchNormalized=FALSE)
mysearch@results$hit

# Search in full text vs. original content.
# Full text search will find matches across annotations.
# Let's define a regular expression with a certain span.
# Search for the word "no" 'no' followed by a "pero" 'but'
# in a distance ranging from 1 to 20 characters.
myRegEx &lt;- "\\bno\\b.{1,20}pero"
mysearch &lt;- act::search_new(examplecorpus, pattern=myRegEx, searchMode="fulltext")
mysearch
mysearch@results$hit

</code></pre>

<hr>
<h2 id='search_openresult_inelan'>Open a search result in 'ELAN'</h2><span id='topic+search_openresult_inelan'></span>

<h3>Description</h3>

<p>The function creates an temporary .eaf file and a .psfx file that locates the search hit.
These files will then be opened in ELAN.
To make this function work you need to have 'ELAN' installed on your computer and tell the act package where ELAN is located.
Therefore you need to set the path to the ELAN executable in the option 'act.path.elan' using <code>options(act.path.elan='PATHTOYOURELANEXECUTABLE')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_openresult_inelan(
  x,
  s,
  resultNr,
  openOriginalEafFileIfAvailable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_openresult_inelan_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_openresult_inelan_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_openresult_inelan_+3A_resultnr">resultNr</code></td>
<td>
<p>Integer; Number of the search result (row in the data frame <code>s@results</code>) to be opened.</p>
</td></tr>
<tr><td><code id="search_openresult_inelan_+3A_openoriginaleaffileifavailable">openOriginalEafFileIfAvailable</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function will check if the original annotation file was an .eaf file and if it still exists in the original location. If so, the function will not create a temporary .eaf file but open the original file. Warning: The original .pfsx file (if it exists) will be overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: This function will overwrite existing .psfx files.
</p>
<p>Credits: Thanks to Han Sloetjes for feedback on the structure of the temporary .pfsx files. He actually made the code work.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

mysearch &lt;- act::search_new(x=examplecorpus, pattern = "yo")

# You can only use this function if you have installed ELAN on our computer.
## Not run: 
options(act.path.elan='PATHTOYOURELANEXECUTABLE')
act::search_openresult_inelan(x=examplecorpus, s=mysearch, resultNr=1, TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='search_openresult_inpraat'>Open a search result in 'Praat'</h2><span id='topic+search_openresult_inpraat'></span>

<h3>Description</h3>

<p>The function remote controls 'Praat' by using 'sendpraat' and a 'Praat' script.
It opens a search result in the 'Praat' TextGrid Editor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_openresult_inpraat(
  x,
  s,
  resultNr,
  play = TRUE,
  closeAfterPlaying = FALSE,
  filterMediaFile = c(".*\\.(aiff|aif|wav)", ".*\\.mp3"),
  delayBeforeOpen = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_openresult_inpraat_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_openresult_inpraat_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_openresult_inpraat_+3A_resultnr">resultNr</code></td>
<td>
<p>Integer; Number of the search result (row in the data frame <code>s@results</code>) to be played.</p>
</td></tr>
<tr><td><code id="search_openresult_inpraat_+3A_play">play</code></td>
<td>
<p>Logical; If <code>TRUE</code> selection will be played.</p>
</td></tr>
<tr><td><code id="search_openresult_inpraat_+3A_closeafterplaying">closeAfterPlaying</code></td>
<td>
<p>Logical; If <code>TRUE</code> TextGrid editor will be closed after playing (Currently non functional!)</p>
</td></tr>
<tr><td><code id="search_openresult_inpraat_+3A_filtermediafile">filterMediaFile</code></td>
<td>
<p>Vector of character strings; Each element of the vector is a regular expression. Expressions will be checked consecutively. The first match with an existing media file will be used for playing. The default checking order is uncompressed audio &gt; compressed audio.</p>
</td></tr>
<tr><td><code id="search_openresult_inpraat_+3A_delaybeforeopen">delayBeforeOpen</code></td>
<td>
<p>Double; Time in seconds before the section will be opened in Praat. This is useful if Praat opens but the section does not. In that case increase the delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make this function work you need to do two things first:
</p>

<ul>
<li><p> Install 'sendpraat' on your computer. To do so  follow the  instructions in the vignette 'installation-sendpraat'. Show the vignette with <code>vignette("installation-sendpraat")</code>.
</p>
</li>
<li><p> Set the path to the 'sendpraat' executable correctly by using 'options(act.path.sendpraat = ...)'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(act)

mysearch &lt;- act::search_new(x=examplecorpus, pattern = "pero")

# You can only use this functions if you have installed and 
# located the 'sendpraat' executable properly in the package options.
## Not run: 
act::search_openresult_inpraat(x=examplecorpus, s=mysearch, resultNr=1, TRUE, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='search_openresult_inquicktime'>Open a search result in 'Quicktime' (and play it)</h2><span id='topic+search_openresult_inquicktime'></span>

<h3>Description</h3>

<p>The function remote controls 'Quicktime' by using an Apple Script.
It opens a search result in 'Quicktime' and plays it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_openresult_inquicktime(
  x,
  s,
  resultNr,
  play = TRUE,
  closeAfterPlaying = FALSE,
  bringQuicktimeToFront = TRUE,
  filterFile = c(".*\\.(mp4|mov)", ".*\\.(aiff|aif|wav)", ".*\\.mp3")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_openresult_inquicktime_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_openresult_inquicktime_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_openresult_inquicktime_+3A_resultnr">resultNr</code></td>
<td>
<p>Integer; Number of the search result (row in the data frame <code>s@results</code>) to be played.</p>
</td></tr>
<tr><td><code id="search_openresult_inquicktime_+3A_play">play</code></td>
<td>
<p>Logical; If <code>TRUE</code> selection will be played.</p>
</td></tr>
<tr><td><code id="search_openresult_inquicktime_+3A_closeafterplaying">closeAfterPlaying</code></td>
<td>
<p>Logical; if <code>TRUE</code> the Quicktime player will be closed after playing the cuts.</p>
</td></tr>
<tr><td><code id="search_openresult_inquicktime_+3A_bringquicktimetofront">bringQuicktimeToFront</code></td>
<td>
<p>Logical; if <code>TRUE</code> the Quicktime player will be activated and placed before all other windows.</p>
</td></tr>
<tr><td><code id="search_openresult_inquicktime_+3A_filterfile">filterFile</code></td>
<td>
<p>Vector of character strings; Each element of the vector is a regular expression. Expressions will be checked consecutively. The first match with an existing media file will be used for playing. The default checking order is video &gt; uncompressed audio &gt; compressed audio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: You need to be on a Mac to use this function.
</p>
<p><em>Span</em> <br />
If you want to extend the cut before or after each search result, you can modify <code>@cuts.span.beforesec</code> and <code>@cuts.span.aftersec</code> in your search object.
</p>


<h3>Value</h3>

<p>Logical; <code>TRUE</code> if media file has been played, or <code>FALSE</code> if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

mysearch &lt;- act::search_new(x=examplecorpus, pattern = "pero")

# You can only use this function if you are on a Mac.
# In addition, you need to have downloaded the example media. 
## Not run: 

# Assign media files
examplecorpus@paths.media.files &lt;- c("FOLDERWHEREMEDIAFILESARELOCATED")
examplecorpus &lt;- act::media_assign(examplecorpus)
	
# Play the media for the first search result
act::search_openresult_inquicktime(x=examplecorpus, 
s=mysearch, 
resultNr = 1,
play=TRUE,
closeAfterPlaying=TRUE)

# Play all search results after one another.
	for (i in 1:nrow(mysearch@results)) {
		print(mysearch@results$content[i])
		act::search_openresult_inquicktime(x=examplecorpus, 
s=mysearch, 
resultNr = i, 
play=TRUE,
closeAfterPlaying=TRUE)
	}

## End(Not run)
</code></pre>

<hr>
<h2 id='search_playresults_inquicktime'>Open all search results in 'Quicktime' and play them</h2><span id='topic+search_playresults_inquicktime'></span>

<h3>Description</h3>

<p>The function remote controls 'Quicktime' by using an Apple Script.
It opens consecutively all search results in 'Quicktime' and plays them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_playresults_inquicktime(x, s, bringQuicktimeToFront = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_playresults_inquicktime_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_playresults_inquicktime_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_playresults_inquicktime_+3A_bringquicktimetofront">bringQuicktimeToFront</code></td>
<td>
<p>Logical; if <code>TRUE</code> the Quicktime player will be activated and placed before all other windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: You need to be on a Mac to use this function.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

mysearch &lt;- act::search_new(x=examplecorpus, pattern = "pero")

# You can only use this function if you are on a Mac.
# In addition, you need to have downloaded the example media files. 
## Not run: 
	# Assign media files
	examplecorpus@paths.media.files &lt;- c("FOLDERWHEREMEDIAFILESARELOCATED")
	examplecorpus &lt;- act::media_assign(examplecorpus)
	
	# Create print transcripts. This is not necessary.
	# But its nice to see them when playing all results.
	mysearch &lt;- act::search_cuts_printtranscript (x=examplecorpus, s=mysearch)
	
	# Play all search results
	act::search_playresults_inquicktime(x=examplecorpus, s=mysearch)

## End(Not run)
</code></pre>

<hr>
<h2 id='search_results_export'>Exports search results</h2><span id='topic+search_results_export'></span>

<h3>Description</h3>

<p>Search results from a search object will be saved to a Excel-XLSX or a CSV (comma separated values) file.
By default a XLSX file will be saved. If you want to save a CSV file, use <code>saveAsCSV=TRUE</code>.
Please note:
</p>

<ul>
<li><p> The function will '=' signs at the beginning of annotation by &quot;.=&quot;. This is because the content would be interpreted as the beginning of a formula (leading to an error).
</p>
</li>
<li><p> In the case of writing to an excel file, line breaks will be replaced by &quot;|&quot;. This is because line breaks will lead to an error.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>search_results_export(
  s,
  path,
  sheetNameXLSX = "data",
  saveAsCSV = FALSE,
  encodingCSV = "UTF-8",
  separatorCSV = ";",
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_results_export_+3A_s">s</code></td>
<td>
<p>Search object. Search object containing the results you wish to export.</p>
</td></tr>
<tr><td><code id="search_results_export_+3A_path">path</code></td>
<td>
<p>Character string; path where file will be saved. Please add the suffix '.csv' or '.xlsx' to the file name.</p>
</td></tr>
<tr><td><code id="search_results_export_+3A_sheetnamexlsx">sheetNameXLSX</code></td>
<td>
<p>Character string, set the name of the excel sheet.</p>
</td></tr>
<tr><td><code id="search_results_export_+3A_saveascsv">saveAsCSV</code></td>
<td>
<p>Logical; if <code>TRUE</code> results will be saved as CSV file; Logical; if <code>FALSE</code> a XLS file will be saved.</p>
</td></tr>
<tr><td><code id="search_results_export_+3A_encodingcsv">encodingCSV</code></td>
<td>
<p>Character string; text encoding for CSV files.</p>
</td></tr>
<tr><td><code id="search_results_export_+3A_separatorcsv">separatorCSV</code></td>
<td>
<p>Character; single character that is used to separate the columns.</p>
</td></tr>
<tr><td><code id="search_results_export_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; if <code>TRUE</code> existing files will be overwritten</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search
mysearch &lt;- act::search_new(examplecorpus, pattern="yo")
nrow(mysearch@results)

# Create temporary file path
path &lt;- tempfile(pattern = "searchresults", tmpdir = tempdir(),
    			 fileext = ".xlsx")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer:
## Not run: 
	path &lt;- tempfile(pattern = "searchresults",
 					 tmpdir = "PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
 					 fileext = ".xlsx")

## End(Not run)

# Save search results
act::search_results_export(s=mysearch, path=path)

# Do your coding of the search results somewhere outside of act
# ...

# Load search results
mysearch.import &lt;- act::search_results_import(path=path)
nrow(mysearch.import@results)
</code></pre>

<hr>
<h2 id='search_results_import'>Import search results</h2><span id='topic+search_results_import'></span>

<h3>Description</h3>

<p>Search results will be imported from an Excel '.xlsx' file or a comma separated values '.csv' file into a search object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_results_import(
  path,
  revertReplacements = TRUE,
  sheetNameXLSX = "data",
  encodingCSV = "UTF-8",
  separatorCSV = ";"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_results_import_+3A_path">path</code></td>
<td>
<p>Character string; path to file from where data will be loaded.</p>
</td></tr>
<tr><td><code id="search_results_import_+3A_revertreplacements">revertReplacements</code></td>
<td>
<p>Logical, when exporting search results from act, '=' at the beginning of lines are replaced by '.=&quot;, and in numbers the decimal separator '.' is replaced by a &quot;,&quot;. If <code>TRUE</code>, this replacement will be reverted when importing search results.</p>
</td></tr>
<tr><td><code id="search_results_import_+3A_sheetnamexlsx">sheetNameXLSX</code></td>
<td>
<p>Character string, set the name of the excel sheet containing the data.</p>
</td></tr>
<tr><td><code id="search_results_import_+3A_encodingcsv">encodingCSV</code></td>
<td>
<p>Character string; text encoding in the case of CVS files.</p>
</td></tr>
<tr><td><code id="search_results_import_+3A_separatorcsv">separatorCSV</code></td>
<td>
<p>Character; single character that is used to separate the columns in CSV files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Search object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search
mysearch &lt;- act::search_new(examplecorpus, pattern="yo")
nrow(mysearch@results)

# Create temporary file path
path &lt;- tempfile(pattern = "searchresults", tmpdir = tempdir(),
    			 fileext = ".xlsx")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer:
## Not run: 
	path &lt;- tempfile(pattern = "searchresults",
 					 tmpdir = "PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
 					 fileext = ".xlsx")

## End(Not run)

# Save search results
act::search_results_export(s=mysearch, path=path)

# Do your coding of the search results somewhere outside of act
# ...

# Load search results
mysearch.import &lt;- act::search_results_import(path=path)
nrow(mysearch.import@results)
</code></pre>

<hr>
<h2 id='search_run'>Run a search</h2><span id='topic+search_run'></span>

<h3>Description</h3>

<p>Runs a search, based on an existing search object s, in a corpus object x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_run(x, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_run_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_run_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Search object.
</p>


<h3>See Also</h3>

<p><a href="#topic+search_new">search_new</a>, <a href="#topic+search_makefilter">search_makefilter</a>, <a href="#topic+search_sub">search_sub</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search for the 1. Person Singular Pronoun in Spanish.
# Only create the search object without running the search.
mysearch &lt;- act::search_new(x=examplecorpus, pattern= "yo", runSearch=FALSE)

# Run the search
mysearch &lt;- act::search_run(x=examplecorpus, s=mysearch)
mysearch
mysearch@results$hit

# Search Only in tiers called "A", in any transcript
mysearch@filter.tier.names &lt;-"A"
mysearch@filter.transcript.names &lt;-""
mysearch &lt;- act::search_run(x=examplecorpus, s=mysearch)
cbind(mysearch@results$transcript.name, mysearch@results$tier.name, mysearch@results$hit)

# Search Only in tiers called "A", only in transcript "ARG_I_PER_Alejo"
mysearch@filter.tier.names &lt;-"A"
mysearch@filter.transcript.names &lt;-"ARG_I_PER_Alejo"
mysearch &lt;- act::search_run(x=examplecorpus, s=mysearch)
cbind(mysearch@results$transcript.name, mysearch@results$tier.name, mysearch@results$hit)


</code></pre>

<hr>
<h2 id='search_searchandopen_inpraat'>Search corpus and open first result in Praat</h2><span id='topic+search_searchandopen_inpraat'></span>

<h3>Description</h3>

<p>The function remote controls 'Praat' by using 'sendpraat' and a 'Praat' script.
It first searches your corpus object and uses the first search hit.
The corresponding TextGrid will be opened in the 'Praat' TextGrid Editor and the search hit will be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_searchandopen_inpraat(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_searchandopen_inpraat_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_searchandopen_inpraat_+3A_pattern">pattern</code></td>
<td>
<p>Character string; search pattern as regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make this function work you need to do two things first:
</p>

<ul>
<li><p> Install 'sendpraat' on your computer. To do so  follow the  instructions in the vignette 'installation-sendpraat'. Show the vignette with <code>vignette("installation-sendpraat")</code>.
</p>
</li>
<li><p> Set the path to the 'sendpraat' executable correctly by using 'options(act.path.sendpraat = ...)'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# You can only use this functions if you have installed 
# and located the 'sendpraat' executable properly in the package options.
## Not run: 
act::search_searchandopen_inpraat(x=examplecorpus, "pero")

## End(Not run)



</code></pre>

<hr>
<h2 id='search_sub'>Add a sub search to a prior search</h2><span id='topic+search_sub'></span>

<h3>Description</h3>

<p>This function starts from the results of a prior search and performs a sub search for a temporal co-occurence.
In the sub search all results from the prior search will be checked.
The sub search will check annotations in other tiers that temporally overlap with the original search result.
Those annotation will be checked if they match a search pattern.
If so, the search hit of the sub search will be added to a new column in the original search results data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_sub(
  x,
  s,
  pattern,
  searchMode = c("content", "fulltext", "fulltext.byTime", "fulltext.byTier"),
  searchNormalized = TRUE,
  filterTierIncludeRegEx = "",
  filterTierExcludeRegEx = "",
  destinationColumn = "subsearch",
  deleteLinesWithNoResults = FALSE,
  excludeHitsWithinSameTier = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_sub_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="search_sub_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
<tr><td><code id="search_sub_+3A_pattern">pattern</code></td>
<td>
<p>Character string; search pattern as regular expression</p>
</td></tr>
<tr><td><code id="search_sub_+3A_searchmode">searchMode</code></td>
<td>
<p>Character string; takes the following values: <code>content</code>, <code>fulltext</code> (=default, includes both full text modes), <code>fulltext.byTime</code>, <code>fulltext.byTier</code>.</p>
</td></tr>
<tr><td><code id="search_sub_+3A_searchnormalized">searchNormalized</code></td>
<td>
<p>Logical; if <code>TRUE</code> function will search in the normalized content, if <code>FALSE</code> function will search in the original content.</p>
</td></tr>
<tr><td><code id="search_sub_+3A_filtertierincluderegex">filterTierIncludeRegEx</code></td>
<td>
<p>Character string; limit search to tiers that match the regular expression</p>
</td></tr>
<tr><td><code id="search_sub_+3A_filtertierexcluderegex">filterTierExcludeRegEx</code></td>
<td>
<p>Character string; limit search to tiers that match the regular expression</p>
</td></tr>
<tr><td><code id="search_sub_+3A_destinationcolumn">destinationColumn</code></td>
<td>
<p>Character string; name of column where results of sub search will be stored</p>
</td></tr>
<tr><td><code id="search_sub_+3A_deletelineswithnoresults">deleteLinesWithNoResults</code></td>
<td>
<p>Logical; if <code>TRUE</code> search results will be deleted for which the sub search does not give any results</p>
</td></tr>
<tr><td><code id="search_sub_+3A_excludehitswithinsametier">excludeHitsWithinSameTier</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function will not add hits from the same tier as the original search result; if <code>FALSE</code> hits from the same tier as the original search result will be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Search object.
</p>


<h3>See Also</h3>

<p><a href="#topic+search_new">search_new</a>, <a href="#topic+search_run">search_run</a>, <a href="#topic+search_makefilter">search_makefilter</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Lets search for instances where participants laugh together
# First search for annotations that contain laughter (in original content)
myRegEx &lt;- "(\\brie\\b|\\briendo\\b)"
mysearch &lt;- act::search_new(x=examplecorpus,
							pattern=myRegEx,
							searchNormalized = FALSE)
mysearch@results.nr

# Now perform sub search, also on laughs/laughing
test &lt;- act::search_sub(x=examplecorpus,
						s=mysearch,
						pattern=myRegEx)

# Check the co-occurring search hits
test@results$subsearch
</code></pre>

<hr>
<h2 id='search_transcript_content'>Search in original content of a single transcript</h2><span id='topic+search_transcript_content'></span>

<h3>Description</h3>

<p>Search in original content of a single transcript
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_transcript_content(t, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_transcript_content_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to search in.</p>
</td></tr>
<tr><td><code id="search_transcript_content_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Data.frame</code> data frame with search results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search for the 1. Person Singular Pronoun in Spanish.
# Only create the search object without running the search.
mysearch &lt;- act::search_new(x=examplecorpus, pattern= "yo", runSearch=FALSE)

# Run the search

df &lt;- act::search_transcript_content(t=examplecorpus@transcripts[[3]],
s=mysearch)
nrow(df)
</code></pre>

<hr>
<h2 id='search_transcript_fulltext'>Search in full text of a single transcript</h2><span id='topic+search_transcript_fulltext'></span>

<h3>Description</h3>

<p>Search in full text of a single transcript
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_transcript_fulltext(t, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_transcript_fulltext_+3A_t">t</code></td>
<td>
<p>Transcript object; transcript to search in.</p>
</td></tr>
<tr><td><code id="search_transcript_fulltext_+3A_s">s</code></td>
<td>
<p>Search object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Data.frame</code> data frame with search results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search for the 1. Person Singular Pronoun in Spanish.
# Only create the search object without running the search.
mysearch &lt;- act::search_new(x=examplecorpus, pattern= "yo", runSearch=FALSE)

# Run the search
df &lt;- act::search_transcript_fulltext(t=examplecorpus@transcripts[[3]],
                                      s=mysearch)
nrow(df)
</code></pre>

<hr>
<h2 id='search-class'>Search object</h2><span id='topic+search-class'></span>

<h3>Description</h3>

<p>This object defines the properties of a search in act.
It also contains the results of this search in a specific corpus, if the search has already been run. (Note that you can also create a search without running it immediately).
A search object can be run on different corpora.
</p>
<p>Some of the slots are defined by the user.
Other slots are <code>[READ ONLY]</code>, which means that they can be accessed by the user but
should not be changed. They contain values that are filled when you execute functions
on the object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Character string; name of the search. Will be used, for example, as name of the sub folder when creating media cuts</p>
</dd>
<dt><code>pattern</code></dt><dd><p>Character string; search pattern as a regular expression.</p>
</dd>
<dt><code>search.mode</code></dt><dd><p>Character string; defines if the original contents of the annotations should be searched or if the full texts should be searched. Slot takes the following values: <code>content</code>, <code>fulltext</code> (=default, includes both full text modes), <code>fulltext.byTime</code>, <code>fulltext.byTier</code>.</p>
</dd>
<dt><code>search.normalized</code></dt><dd><p>logical. if <code>TRUE</code> the normalized annotations will be used for searching.</p>
</dd>
<dt><code>resultid.prefix</code></dt><dd><p>Character string; search results will be numbered consecutively; This character string will be placed before the consecutive numbers.</p>
</dd>
<dt><code>resultid.start</code></dt><dd><p>Integer; search results will be numbered consecutively; This is the start number of the identifiers.</p>
</dd>
<dt><code>filter.transcript.names</code></dt><dd><p>Vector of character strings; names of transcripts to include in the search. If the value is <code>character()</code> or <code>""</code> filter will be ignored.</p>
</dd>
<dt><code>filter.transcript.includeRegEx</code></dt><dd><p>Character string; Regular expression that defines which transcripts should be INcluded in the search (matching the name of the transcript).</p>
</dd>
<dt><code>filter.transcript.excludeRegEx</code></dt><dd><p>Character string; Regular expression that defines which transcripts should be EXcluded in the search (matching the name of the transcript).</p>
</dd>
<dt><code>filter.tier.names</code></dt><dd><p>Vector of character strings; names of tiers to include in the search. If the value is <code>character()</code> or <code>""</code> filter will be ignored.</p>
</dd>
<dt><code>filter.tier.includeRegEx</code></dt><dd><p>Character string; Regular expression that defines which tiers should be INcluded in the search (matching the name of the tier).</p>
</dd>
<dt><code>filter.tier.excludeRegEx</code></dt><dd><p>Character string; Regular expression that defines which tiers should be EXcluded in the search (matching the name of the tier).</p>
</dd>
<dt><code>filter.section.startsec</code></dt><dd><p>Double; Time value in seconds, limiting the search to a certain time span in each transcript, defining the start of the search window.</p>
</dd>
<dt><code>filter.section.endsec</code></dt><dd><p>Double; Time value in seconds, limiting the search to a certain time span in each transcript, defining the end of the search window.</p>
</dd>
<dt><code>concordance.make</code></dt><dd><p>Logical; If a concordance should be created when the search is run.</p>
</dd>
<dt><code>concordance.width</code></dt><dd><p>Integer; number of characters to include in the concordance.</p>
</dd>
<dt><code>cuts.span.beforesec</code></dt><dd><p>Double; Seconds how much the cuts (media and print transcripts) should start before the start of the search hit.</p>
</dd>
<dt><code>cuts.span.aftersec</code></dt><dd><p>Double; Seconds how much the cuts (media and print transcripts) should end after the end of the search hit.</p>
</dd>
<dt><code>cuts.column.srt</code></dt><dd><p>Character string; name of  destination column in the search results data frame where the srt substitles will be inserted; column will be created if not present in data frame; set to &quot;&quot; for no insertion.</p>
</dd>
<dt><code>cuts.column.printtranscript</code></dt><dd><p>Character string; name of  destination column in the search results data frame where the print transcripts will be inserted; column will be created if not present in data frame; set to &quot;&quot; for no insertion.</p>
</dd>
<dt><code>cuts.printtranscripts</code></dt><dd><p>Character string; <code>[READ ONLY]</code> All print transcripts for the search results (if generated previously)</p>
</dd>
<dt><code>cuts.cutlist.mac</code></dt><dd><p>Character string; <code>[READ ONLY]</code> 'FFmpeg' cut list for use on a Mac, to cut the media files for the search results.</p>
</dd>
<dt><code>cuts.cutlist.win</code></dt><dd><p>Character string; <code>[READ ONLY]</code> 'FFmpeg' cut list for use on Windows, to cut the media files for the search results.</p>
</dd>
<dt><code>results</code></dt><dd><p>Data.frame; Results of the search.1</p>
</dd>
<dt><code>results.nr</code></dt><dd><p>Integer; <code>[READ ONLY]</code> Number of search results.</p>
</dd>
<dt><code>results.tiers.nr</code></dt><dd><p>Integer; <code>[READ ONLY]</code> Number of tiers over which the search results are distrubuted.</p>
</dd>
<dt><code>results.transcripts.nr</code></dt><dd><p>Integer; <code>[READ ONLY]</code> Number of transcripts over which the search results are distrubuted.</p>
</dd>
<dt><code>x.name</code></dt><dd><p>Character string; <code>[READ ONLY]</code> name of the corpus object on which the search has been run.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Search for the 1. Person Singular Pronoun in Spanish.
mysearch &lt;- act::search_new(examplecorpus, pattern= "yo")
mysearch
# Search in normalized content vs. original content
mysearch.norm  &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=TRUE)
mysearch.org   &lt;- act::search_new(examplecorpus, pattern="yo", searchNormalized=FALSE)
mysearch.norm@results.nr
mysearch.org@results.nr

# The difference is because during normalization capital letters will be converted
# to small letters. One annotation in the example corpus contains a "yo" with a
# capital letter:
mysearch &lt;- act::search_new(examplecorpus, pattern="yO", searchNormalized=FALSE)
mysearch@results$hit

# Search in full text vs. original content.
# Full text search will find matches across annotations.
# Let's define a regular expression with a certain span.
# Search for the word "no" 'no' followed by a "pero" 'but'
# in a distance ranging from 1 to 20 characters.
myRegEx &lt;- "\\bno\\b.{1,20}pero"
mysearch &lt;- act::search_new(examplecorpus, pattern=myRegEx, searchMode="fulltext")
mysearch
mysearch@results$hit

</code></pre>

<hr>
<h2 id='tiers_add'>Add tiers</h2><span id='topic+tiers_add'></span>

<h3>Description</h3>

<p>Adds a tiers in all transcript objects of a corpus.
If tiers should be added only in certain transcripts, set the parameter <code>filterTranscriptNames</code>.
In case that you want to select transcripts by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiers_add(
  x,
  tierName,
  tierType = c("IntervalTier", "TextTier"),
  absolutePosition = NULL,
  destinationTier = NULL,
  relativePositionToDestinationTier = 0,
  insertOnlyIfDestinationExists = FALSE,
  filterTranscriptNames = NULL,
  skipIfTierAlreadyExists = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiers_add_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_tiername">tierName</code></td>
<td>
<p>Character string; names of the tier to be added.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_tiertype">tierType</code></td>
<td>
<p>Character string; type of the tier to be added.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_absoluteposition">absolutePosition</code></td>
<td>
<p>Integer; Absolute position where the tier will be inserted. Value 1 and values beloe 1 will insert the tier in the first position; To insert the tier at the end, leave 'absolutePosition' and 'destinationTier' open.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_destinationtier">destinationTier</code></td>
<td>
<p>Character string; insert the tier relative to this tier.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_relativepositiontodestinationtier">relativePositionToDestinationTier</code></td>
<td>
<p>Integer; position relative to the destination tier; 1=immediately after; 0 and -1=immediately before;  bigger numbers are also allowed.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_insertonlyifdestinationexists">insertOnlyIfDestinationExists</code></td>
<td>
<p>Logical; if <code>TRUE</code> the new tier will only be added if the destination tier 'destinationTier' exists in the transcript object. If <code>FALSE</code> the new tier will only be added in any case. If the destination tier 'destinationTier' does not exist in the transcript object, the tier will be inserted at the end.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be modified. If left open, the tier will be added to all transcripts in the corpus.</p>
</td></tr>
<tr><td><code id="tiers_add_+3A_skipiftieralreadyexists">skipIfTierAlreadyExists</code></td>
<td>
<p>Logical; if <code>TRUE</code> the new tier will be skipped if a tier with this name already exists in the transcript; if <code>FALSE</code> an error will be raised.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can either insert the new tier at a specific position (e.g. 'absolutePosition=1') or in relation to a existing tier (e.g. destinationTier='speaker1').
To insert a tier at the end, leave 'absolutePosition' and 'destinationTier' open.
</p>
<p>Results will be reported in <code>@history</code> of the transcript objects.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+tiers_delete">tiers_delete</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+tiers_convert">tiers_convert</a>, <a href="#topic+tiers_sort">tiers_sort</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# --- Add new interval tier.
# Since not position is set it will be inserted in the end, by default.
x &lt;- act::tiers_add(examplecorpus,
					tierName="TEST")
#check results
x@history[length(x@history)]
#have a look at the first transcript
x@transcripts[[1]]@tiers
#--&gt; New tier is inserted in the end.

# --- Add new interval tier in position 2
x &lt;- act::tiers_add(examplecorpus,
					tierName="TEST",
					absolutePosition=2)
#check results
x@history[length(x@history)]
#have a look at the first transcript
x@transcripts[[1]]@tiers
#--&gt; New tier is inserted as second tier.


# --- Add new interval tier at the position of "Entrevistador", only if this tier exists,
# If the destination tier does not exist, the new tier will NOT be inserted.

#Have a look at the first and the second transcript. 
examplecorpus@transcripts[[1]]@tiers
#Transcript 1 does contain a tier "Entrevistador" in the first position.
examplecorpus@transcripts[[2]]@tiers
#Transcript 2 does contain a tier "Entrevistador" in the first position.

#Insert new tier
x &lt;- act::tiers_add(examplecorpus,
					tierName="TEST",
					destinationTier="Entrevistador",
					relativePositionToDestinationTier=0,
					insertOnlyIfDestinationExists=TRUE)

#Check results
x@history[length(x@history)]
#Have a look at the transcript 1:
# Tier 'TEST' was in first position (e.g. where 'Entrevistador' was before).
x@transcripts[[1]]@tiers
#Have a look at the transcript 2:
#Tier 'TEST' was not inserted, since there was no destination tier 'Entrevistador'.
x@transcripts[[2]]@tiers

# --- Add new interval tier AFTER tier="Entrevistador"
# If the destination tier does not exist, the new tier will be inserted at the end in any case.
x &lt;- act::tiers_add(examplecorpus,
					tierName="TEST",
					destinationTier="Entrevistador",
					relativePositionToDestinationTier=1,
					insertOnlyIfDestinationExists=FALSE)
#check results
x@history[length(x@history)]
#Have a look at the transcript 1:
# Tier 'TEST' was inserted after the tier 'Entrevistador'.
x@transcripts[[1]]@tiers
#Have a look at the transcript 2:
#Tier 'TEST' was insertedat the end.
x@transcripts[[2]]@tiers

</code></pre>

<hr>
<h2 id='tiers_all'>All tiers in a corpus</h2><span id='topic+tiers_all'></span>

<h3>Description</h3>

<p>Merges tiers from all transcripts in a corpus object into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiers_all(x, compact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiers_all_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="tiers_all_+3A_compact">compact</code></td>
<td>
<p>Logical; if <code>TRUE</code> a condensed overview will be returned,  if <code>FALSE</code> a detailed overview will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(act)

#Get data frame with all tiers
alltiers &lt;- act::tiers_all(examplecorpus)
alltiers

#Get data frame with a simplified version
alltiers &lt;- act::tiers_all(examplecorpus, compact=TRUE)
alltiers

</code></pre>

<hr>
<h2 id='tiers_convert'>Convert tiers</h2><span id='topic+tiers_convert'></span>

<h3>Description</h3>

<p>Converts tier types between 'interval' and 'point' tier.
Applies to all tiers in all transcript objects of a corpus.
If only certain transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code>.
In case that you want to select transcripts by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiers_convert(
  x,
  intervalToPoint = FALSE,
  pointToInterval = FALSE,
  filterTierNames = NULL,
  filterTranscriptNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiers_convert_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="tiers_convert_+3A_intervaltopoint">intervalToPoint</code></td>
<td>
<p>Logical; if <code>TRUE</code> interval tiers will be converted to point/text tiers.</p>
</td></tr>
<tr><td><code id="tiers_convert_+3A_pointtointerval">pointToInterval</code></td>
<td>
<p>Logical; if <code>TRUE</code> point/text tiers will be converted to interval tiers.</p>
</td></tr>
<tr><td><code id="tiers_convert_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of the tiers to be included.</p>
</td></tr>
<tr><td><code id="tiers_convert_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be checked. If left open, all transcripts will be checked</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: When converting from interval &gt; point tier, the original end times of the annotations will be lost definitely.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+tiers_add">tiers_add</a>, <a href="#topic+tiers_delete">tiers_delete</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+tiers_sort">tiers_sort</a>, <a href="#topic+helper_tiers_new_table">helper_tiers_new_table</a>, <a href="#topic+helper_tiers_sort_table">helper_tiers_sort_table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Check the names and types of the existing tiers in the first two transcripts
examplecorpus@transcripts[[1]]@tiers
examplecorpus@transcripts[[2]]@tiers

# Convert interval tiers to point tiers
newcorpus &lt;- act::tiers_convert(examplecorpus, intervalToPoint=TRUE)

# the names and types of the existing tiers
newcorpus@transcripts[[1]]@tiers
newcorpus@transcripts[[2]]@tiers

# Convert point tiers to interval tiers
newcorpus &lt;- act::tiers_convert(newcorpus, pointToInterval=TRUE)

# Note: In this round trip conversion from 'interval &gt; point &gt; interval tier' 
# the original end times of the annotations get lost (when converting from interval &gt; point).
</code></pre>

<hr>
<h2 id='tiers_delete'>Delete tiers</h2><span id='topic+tiers_delete'></span>

<h3>Description</h3>

<p>Deletes tiers in all transcript objects of a corpus.
If only tiers in certain transcripts should be affected set the parameter <code>filterTranscriptNames</code>.
In case that you want to select tiers and/or transcripts by using regular expressions use the function <code>act::search_makefilter</code> first.
Results  will be reported in <code>@history</code> of the transcript objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiers_delete(x, tierNames, filterTranscriptNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiers_delete_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="tiers_delete_+3A_tiernames">tierNames</code></td>
<td>
<p>Character string; names of the tiers to be deleted.</p>
</td></tr>
<tr><td><code id="tiers_delete_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be modified. If left open, all transcripts will be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+tiers_add">tiers_add</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+tiers_convert">tiers_convert</a>, <a href="#topic+tiers_sort">tiers_sort</a>, <a href="#topic+helper_tiers_new_table">helper_tiers_new_table</a>, <a href="#topic+helper_tiers_sort_table">helper_tiers_sort_table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# get info about all tiers
all.tiers &lt;- act::info(examplecorpus)$tiers

# tiers 'A' and 'B' occur 6 times in 6 transcripts
all.tiers["A", "tier.count"]
all.tiers["B", "tier.count"]

# delete tiers
tierNames &lt;- c("A", "B")
x&lt;- examplecorpus
x &lt;- act::tiers_delete(examplecorpus, tierNames=tierNames)
x@history[length(x@history)]

# tiers 'A' and 'B' do not occur anymore
act::info(x)$tiers$tier.name
</code></pre>

<hr>
<h2 id='tiers_rename'>Rename tiers</h2><span id='topic+tiers_rename'></span>

<h3>Description</h3>

<p>Renames all tiers in all transcript objects of a corpus.
If only certain transcripts should be affected set the parameter <code>filterTranscriptNames</code>.
In case that you want to select transcripts by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiers_rename(x, searchPattern, searchReplacement, filterTranscriptNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiers_rename_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="tiers_rename_+3A_searchpattern">searchPattern</code></td>
<td>
<p>Character string; search pattern as regular expression.</p>
</td></tr>
<tr><td><code id="tiers_rename_+3A_searchreplacement">searchReplacement</code></td>
<td>
<p>Character string; replacement string.</p>
</td></tr>
<tr><td><code id="tiers_rename_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tiers will only be renamed if the resulting names preserve the uniqueness of the tier names.
Results  will be reported in <code>@history</code> of the transcript objects.
Please be aware that this function is not optimized for speed and may take quite a while to run, depending on the size of your corpus object.
</p>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+tiers_add">tiers_add</a>, <a href="#topic+tiers_convert">tiers_convert</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+tiers_sort">tiers_sort</a>, <a href="#topic+helper_tiers_new_table">helper_tiers_new_table</a>, <a href="#topic+helper_tiers_sort_table">helper_tiers_sort_table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Check the names of the existing tiers in the first two transcripts
examplecorpus@transcripts[[1]]@tiers$name
examplecorpus@transcripts[[2]]@tiers$name

x &lt;- act::tiers_rename(examplecorpus, "Entrevistador", "E")

x@transcripts[[1]]@tiers$name
x@transcripts[[2]]@tiers$name

</code></pre>

<hr>
<h2 id='tiers_sort'>Reorder tiers in all transcripts of a corpus</h2><span id='topic+tiers_sort'></span>

<h3>Description</h3>

<p>Reorder the positions of tiers in all transcripts of a corpus object.
The ordering of the tiers will be done according to a vector of regular expressions defined in 'sortVector'.
If only certain transcripts or tiers should be affected set the parameter <code>filterTranscriptNames</code>.
In case that you want to select transcripts by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiers_sort(
  x,
  sortVector,
  filterTranscriptNames = NULL,
  addMissingTiers = FALSE,
  deleteTiersThatAreNotInTheSortVector = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiers_sort_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="tiers_sort_+3A_sortvector">sortVector</code></td>
<td>
<p>Vector of character strings; regular expressions to match the tier names. The order within the vector presents the new order of the tiers. Use &quot;\\*&quot; (=two backslashes and a star) to indicate where tiers that are not present in the sort vector but in the transcript should be inserted.</p>
</td></tr>
<tr><td><code id="tiers_sort_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
<tr><td><code id="tiers_sort_+3A_addmissingtiers">addMissingTiers</code></td>
<td>
<p>Logical; if <code>TRUE</code> all tiers that are given in 'the 'sortVector' but are missing in the transcripts will be added.</p>
</td></tr>
<tr><td><code id="tiers_sort_+3A_deletetiersthatarenotinthesortvector">deleteTiersThatAreNotInTheSortVector</code></td>
<td>
<p>Logical; if <code>TRUE</code> tiers that are not matched by the regular expressions in 'sortVector' will be deleted. Otherwise the will be inserted at the end of the table or at the position defined by '&quot;\*' in  'sortVector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>See Also</h3>

<p><a href="#topic+tiers_add">tiers_add</a>, <a href="#topic+tiers_convert">tiers_convert</a>, <a href="#topic+tiers_delete">tiers_delete</a>, <a href="#topic+tiers_rename">tiers_rename</a>, <a href="#topic+helper_tiers_new_table">helper_tiers_new_table</a>, <a href="#topic+helper_tiers_sort_table">helper_tiers_sort_table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Check the order of the existing tiers in the first two transcripts
examplecorpus@transcripts[[1]]@tiers$name[order(examplecorpus@transcripts[[1]]@tiers$position)]
examplecorpus@transcripts[[2]]@tiers$name[order(examplecorpus@transcripts[[2]]@tiers$position)]

# Get tier names to create the sort vector
sortVector &lt;- c(examplecorpus@transcripts[[1]]@tiers$name,
                examplecorpus@transcripts[[2]]@tiers$name)

# Revert the vector for demonstration.
sortVector &lt;- sortVector[length(sortVector):1]

# This will only reorder the tiers.
examplecorpus &lt;- act::tiers_sort(x=examplecorpus, 
sortVector=sortVector)

# Check again the order of the tiers
examplecorpus@transcripts[[1]]@tiers$name[order(examplecorpus@transcripts[[1]]@tiers$position)]
examplecorpus@transcripts[[2]]@tiers$name[order(examplecorpus@transcripts[[2]]@tiers$position)]

# This will reorder the tiers and additionally add tiers that are given  
# in the sort vector but not present in the transcript.
examplecorpus &lt;- act::tiers_sort(x=examplecorpus,
sortVector=sortVector,
addMissingTiers=TRUE)
# Check again the order of the tiers
examplecorpus@transcripts[[1]]@tiers$name[order(examplecorpus@transcripts[[1]]@tiers$position)]
examplecorpus@transcripts[[2]]@tiers$name[order(examplecorpus@transcripts[[2]]@tiers$position)]

# Insert a tier called "newTier" into all transcripts in the corpus:
for (t in examplecorpus@transcripts) {
 sortVector &lt;- c(t@tiers$name, "newTier")
 examplecorpus &lt;- act::tiers_sort(x=examplecorpus,
sortVector=sortVector,
filterTranscriptNames=t@name,
addMissingTiers=TRUE)
}
# Check for example the first transcript: it now contains a tier called "newTier"
examplecorpus@transcripts[[1]]@tiers


# To get more examples and information about sorting see 'helper_tiers_sort_table()'.
</code></pre>

<hr>
<h2 id='transcript-class'>transcript object</h2><span id='topic+transcript-class'></span>

<h3>Description</h3>

<p>A transcript object contains the annotations of a loaded annotation file and some meta data .
In addition, it contains information that is auto generated by the act package, which is necessary for some functions (e.g. the full text search)
</p>


<h3>Details</h3>

<p>Some of the slots are defined by the user.
Other slots are <code>[READ ONLY]</code>, which means that they can be accessed by the user but
should not be changed. They contain values that are filled when you execute functions
on the object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Name of the transcript, generated from the annotation file name.</p>
</dd>
<dt><code>file.path</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Original location of the annotation file.</p>
</dd>
<dt><code>file.encoding</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Encoding applied to the file when reading.</p>
</dd>
<dt><code>file.type</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Type of the original annotation file/object, e.g. 'eaf' or 'textgrid' for files and 'rpraat' for a rPraat .TextGrid object.</p>
</dd>
<dt><code>file.content</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Content of the original annotation file/object.</p>
</dd>
<dt><code>import.result</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Information about the success of the import of the annotation file.</p>
</dd>
<dt><code>load.message</code></dt><dd><p>Character string; <code>[READ ONLY]</code> Possibly messages about errors that occurred on importing the annotation file.</p>
</dd>
<dt><code>length.sec</code></dt><dd><p>Double; <code>[READ ONLY]</code> Duration of the transcript in seconds.</p>
</dd>
<dt><code>tiers</code></dt><dd><p>Data.frame; <code>[READ ONLY]</code> Table with the tiers. To modify the tiers it is highly recommended to use functions of the package to ensure for consistency of the data.</p>
</dd>
<dt><code>annotations</code></dt><dd><p>Data.frame; Table with the annotations.</p>
</dd>
<dt><code>media.path</code></dt><dd><p>Character string; Path(s) to the media files that correspond to this transcript object.</p>
</dd>
<dt><code>normalization.systime</code></dt><dd><p>POSIXct; Time of the last normalization.</p>
</dd>
<dt><code>fulltext.systime</code></dt><dd><p>POSIXct; <code>[READ ONLY]</code> Time of the last creation of the full texts.</p>
</dd>
<dt><code>fulltext.filter.tier.names</code></dt><dd><p>Vector of character strings; names of tiers that were included in the full text..</p>
</dd>
<dt><code>fulltext.bytime.orig</code></dt><dd><p>Character string; <code>[READ ONLY]</code> full text of the transcript based on the ORIGINAL content of the annotations, sorting the annotations by TIME</p>
</dd>
<dt><code>fulltext.bytime.norm</code></dt><dd><p>Character string; <code>[READ ONLY]</code> full text of the transcript based on the NORMALIZED content of the annotations, sorting the annotations by TIME</p>
</dd>
<dt><code>fulltext.bytier.orig</code></dt><dd><p>Character string; <code>[READ ONLY]</code> full text of the transcript based on the ORIGINAL content of the annotations, sorting the annotations first by TIERS and then by time</p>
</dd>
<dt><code>fulltext.bytier.norm</code></dt><dd><p>Character string; <code>[READ ONLY]</code> full text of the transcript based on the NORMALIZED content of the annotations, sorting the annotations first by TIERS and then by time</p>
</dd>
<dt><code>modification.systime</code></dt><dd><p>POSIXct; <code>[READ ONLY]</code> Time of the last modification of the transcript. Modifications after importing the annotation file by applying one/some of the packages function(s). Manual changes of the transcript by the user are not tracked!</p>
</dd>
<dt><code>history</code></dt><dd><p>List; <code>[READ ONLY]</code> History of the modifications made to the transcript object.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

examplecorpus@transcripts[[1]]

</code></pre>

<hr>
<h2 id='transcripts_add'>Add transcripts to a corpus</h2><span id='topic+transcripts_add'></span>

<h3>Description</h3>

<p>Add a single or multiple transcript objects to a corpus object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_add(
  x,
  ...,
  skipDuplicates = FALSE,
  createFullText = TRUE,
  assignMedia = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_add_+3A_x">x</code></td>
<td>
<p>Corpus object</p>
</td></tr>
<tr><td><code id="transcripts_add_+3A_...">...</code></td>
<td>
<p>transcript object, list of transcript objects, corpus object.</p>
</td></tr>
<tr><td><code id="transcripts_add_+3A_skipduplicates">skipDuplicates</code></td>
<td>
<p>Logical; If <code>FALSE</code> double transcripts will be renamed to make the names unique, if <code>TRUE</code> double transcripts will not be added.</p>
</td></tr>
<tr><td><code id="transcripts_add_+3A_createfulltext">createFullText</code></td>
<td>
<p>Logical; if <code>TRUE</code> full text will be created.</p>
</td></tr>
<tr><td><code id="transcripts_add_+3A_assignmedia">assignMedia</code></td>
<td>
<p>Logical; if <code>TRUE</code> the folder(s) specified in <code>@paths.media.files</code> of your corpus object will be scanned for media.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the transcript objects have to be unique in the act package.
The <code>@name</code> attribute of each transcript object will be set as identifier in the list of transcripts in the corpus object.
By default, transcripts with non unique names will be renamed.
If you prefer to import.skip.double.files, set the parameter <code>skipDuplicates=TRUE</code>.
Skipped/renamed transcripts will be reported in
</p>


<h3>Value</h3>

<p>Corpus object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# get one of the already existing transcript in the examplecorpus
newtrans &lt;- examplecorpus@transcripts[[1]]

# add this transcript to the examplecorpus
newcorpus &lt;- act::transcripts_add(examplecorpus, newtrans)

# compare the two corpus objects
length(examplecorpus@transcripts)
length(newcorpus@transcripts)

names(examplecorpus@transcripts)
names(newcorpus@transcripts)
</code></pre>

<hr>
<h2 id='transcripts_cure'>Cure all transcript objects in a corpus</h2><span id='topic+transcripts_cure'></span>

<h3>Description</h3>

<p>Transcript object may contain errors, e.g. because of defect annotation input files or user modifications.
This function may cure some of these errors in all transcript objects of a corpus.
</p>

<ul>
<li><p> Annotations with reversed times: annotations with <code>endSec</code> lower than <code>startSec</code> will be deleted.
</p>
</li>
<li><p> Overlapping annotations: earlier annotations will end where the next annotation starts.
</p>
</li>
<li><p> Annotations below 0 sec: Annotations that are starting and ending before 0 sec will be deleted; Annotations starting before but ending after 0 sec will be truncated.
</p>
</li>
<li><p> Missing tiers: Tiers that are present in the annotations but missing in the list of tiers in <code>@tiers</code> of the transcript object will be added.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>transcripts_cure(
  x,
  filterTranscriptNames = NULL,
  annotationsWithReversedTimes = TRUE,
  overlappingAnnotations = TRUE,
  annotationsWithTimesBelowZero = TRUE,
  missingTiers = TRUE,
  showWarning = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_cure_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="transcripts_cure_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcripts to be included.</p>
</td></tr>
<tr><td><code id="transcripts_cure_+3A_annotationswithreversedtimes">annotationsWithReversedTimes</code></td>
<td>
<p>Logical; If <code>TRUE</code> annotations with reversed times will be deleted</p>
</td></tr>
<tr><td><code id="transcripts_cure_+3A_overlappingannotations">overlappingAnnotations</code></td>
<td>
<p>Logical; If <code>TRUE</code> overlapping annotations will be corrected.</p>
</td></tr>
<tr><td><code id="transcripts_cure_+3A_annotationswithtimesbelowzero">annotationsWithTimesBelowZero</code></td>
<td>
<p>Logical; If <code>TRUE</code> annotations before 0 sec will be corrected.</p>
</td></tr>
<tr><td><code id="transcripts_cure_+3A_missingtiers">missingTiers</code></td>
<td>
<p>Logical; If <code>TRUE</code> tiers missing in <code>@tiers</code> slot of the transcript object will be added.</p>
</td></tr>
<tr><td><code id="transcripts_cure_+3A_showwarning">showWarning</code></td>
<td>
<p>Logical; If <code>TRUE</code> a warning notice will be shown upon correction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object;
</p>


<h3>See Also</h3>

<p><a href="#topic+transcripts_cure_single">transcripts_cure_single</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# The example corpus does not contain any errors.
# But let's use the function anyway.
x&lt;- act::transcripts_cure(examplecorpus)
x@history[[length(x@history)]]

# See \code{act::cure_transcript} for actual examples.

</code></pre>

<hr>
<h2 id='transcripts_cure_single'>Cure a single transcript</h2><span id='topic+transcripts_cure_single'></span>

<h3>Description</h3>

<p>Transcript object may contain errors, e.g. because of defect annotation input files or user modifications.
This function may cure some of these errors.
</p>

<ul>
<li><p> Annotations with reversed times: annotations with <code>endSec</code> lower than <code>startSec</code> will be deleted.
</p>
</li>
<li><p> Overlapping annotations: earlier annotations will end where the next annotation starts.
</p>
</li>
<li><p> Annotations below 0 sec: Annotations that are starting and ending before 0 sec will be deleted; Annotations starting before but ending after 0 sec will be truncated.
</p>
</li>
<li><p> Missing tiers: Tiers that are present in the annotations but missing in the list of tiers in <code>@tiers</code> of the transcript object will be added.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>transcripts_cure_single(
  t,
  annotationsWithReversedTimes = TRUE,
  overlappingAnnotations = TRUE,
  annotationsWithTimesBelowZero = TRUE,
  missingTiers = TRUE,
  showWarning = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_cure_single_+3A_t">t</code></td>
<td>
<p>Transcript object.</p>
</td></tr>
<tr><td><code id="transcripts_cure_single_+3A_annotationswithreversedtimes">annotationsWithReversedTimes</code></td>
<td>
<p>Logical; If <code>TRUE</code> annotations with reversed times will be deleted</p>
</td></tr>
<tr><td><code id="transcripts_cure_single_+3A_overlappingannotations">overlappingAnnotations</code></td>
<td>
<p>Logical; If <code>TRUE</code> overlapping annotations will be corrected.</p>
</td></tr>
<tr><td><code id="transcripts_cure_single_+3A_annotationswithtimesbelowzero">annotationsWithTimesBelowZero</code></td>
<td>
<p>Logical; If <code>TRUE</code> annotations before 0 sec will be corrected.</p>
</td></tr>
<tr><td><code id="transcripts_cure_single_+3A_missingtiers">missingTiers</code></td>
<td>
<p>Logical; If <code>TRUE</code> tiers missing in <code>@tiers</code> slot of the transcript object will be added.</p>
</td></tr>
<tr><td><code id="transcripts_cure_single_+3A_showwarning">showWarning</code></td>
<td>
<p>Logical; If <code>TRUE</code> a warning notice will be shown upon correction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transcript object;
</p>


<h3>See Also</h3>

<p><a href="#topic+transcripts_cure">transcripts_cure</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# --- annotationsWithReversedTimes: will be deleted
# get example transcript and reverse the times of an annotation
t &lt;- examplecorpus@transcripts[[1]]
t@annotations$startSec[1] &lt;- 20
t@annotations$endSec[1] &lt;- 10
t2 &lt;- act::transcripts_cure_single(t)
tail(t2@history, n=1)


# --- annotationsWithTimesBelowZero: will be deleted or start at 0 sec
t &lt;- examplecorpus@transcripts[[1]]
t@annotations$startSec[1] &lt;- -2
t@annotations$endSec[1]   &lt;- -1
t2 &lt;- act::transcripts_cure_single(t)
tail(t2@history, n=1)

t &lt;- examplecorpus@transcripts[[1]]
t@annotations$startSec[2] &lt;- -5
t2 &lt;- act::transcripts_cure_single(t)
tail(t2@history, n=1)


# --- overlappingAnnotations: will end where the next starts
t&lt;- examplecorpus@transcripts[[1]]
t@annotations &lt;- t@annotations[order(t@annotations$tier.name, t@annotations$startSec), ]
t@annotations$endSec[1] &lt;- 8
t2 &lt;- act::transcripts_cure_single(t)
tail(t2@history, n=1)


# --- missingTiers: will be added to @tiers in transcript object
t&lt;- examplecorpus@transcripts[[1]]
t@annotations &lt;- t@annotations[order(t@annotations$tier.name, t@annotations$startSec), ]
t@annotations$tier.name[1] &lt;- "NEW"
t2 &lt;- act::transcripts_cure_single(t)
tail(t2@history, n=1)
t2@tiers
# compare with original tiers
t@tiers


# --- several things at once
t&lt;- examplecorpus@transcripts[[1]]
t@annotations &lt;- t@annotations[order(t@annotations$tier.name, t@annotations$startSec), ]
# annotation completely below 0 sec
t@annotations$startSec[1] &lt;- -6
t@annotations$endSec[1]   &lt;- -5
# annotation starts before but ends after 0 sec
t@annotations$startSec[2] &lt;- -3
# annotation with reversed times
t@annotations$startSec[3] &lt;- 6.9
t@annotations$endSec[3]   &lt;- -6.8
# annotation overlaps with next annotation
t@annotations$endSec[6]   &lt;- 9
# new tier, missing tier list
t@annotations$tier.name[8] &lt;- "NEW"
t2 &lt;- act::transcripts_cure_single(t, showWarning=TRUE)
tail(t2@history, n=1)


examplecorpus@transcripts[[1]]@history
</code></pre>

<hr>
<h2 id='transcripts_delete'>Delete transcripts from a corpus</h2><span id='topic+transcripts_delete'></span>

<h3>Description</h3>

<p>Delete transcript objects from a corpus object.
You need to name the transcripts to delete directly in the parameter 'transcriptNames'.
If you want to delete transcripts based on a search pattern (regular expression) use <code>act::search_sub</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_delete(x, transcriptNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_delete_+3A_x">x</code></td>
<td>
<p>Corpus object</p>
</td></tr>
<tr><td><code id="transcripts_delete_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; names of the transcript object to be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# delete two transcripts by their name
test &lt;- act::transcripts_delete(examplecorpus, 
c("BOL_CCBA_SP_MeryGaby1", 
"BOL_CCBA_SP_MeryGaby2"))

# compare the the original and modified corpus object
length(examplecorpus@transcripts)
length(test@transcripts)
setdiff(names(examplecorpus@transcripts), names(test@transcripts))
test@history[length(test@history)]

# delete transcripts that match a filter, e.g. all transcripts from Bolivia "BOL_"
myfilter &lt;- act::search_makefilter(examplecorpus, filterTranscriptIncludeRegEx = "BOL_")
test &lt;- act::transcripts_delete(examplecorpus, 
myfilter$transcript.names)

# compare the the original and modified corpus object
length(examplecorpus@transcripts)
length(test@transcripts)
setdiff(names(examplecorpus@transcripts), names(test@transcripts))
</code></pre>

<hr>
<h2 id='transcripts_filter'>Filter all transcripts in a corpus</h2><span id='topic+transcripts_filter'></span>

<h3>Description</h3>

<p>Filter all transcript objects in a corpus and return the filtered corpus object.
It is possible to filter out temporal sections and tiers.
In case that you want to select tiers by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_filter(
  x,
  filterTranscriptNames = NULL,
  filterOnlyTheseTranscripts = NULL,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  preserveTimes = TRUE,
  sort = c("none", "tier&gt;startSec", "startSec&gt;tier")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_filter_+3A_x">x</code></td>
<td>
<p>Corpus object;</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_filtertranscriptnames">filterTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of transcripts to remain in the transcripts. If left unspecified, all transcripts will  remain in the transcripts.</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_filteronlythesetranscripts">filterOnlyTheseTranscripts</code></td>
<td>
<p>Vector of character strings; names of transcripts to which filters will be applied. If left unspecified, all transcripts will be filtered.</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to remain in the transcripts. If left unspecified, all tiers will remain in the transcripts.</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double, start of selection in seconds.</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double, end of selection in seconds.</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_preservetimes">preserveTimes</code></td>
<td>
<p>Logical; Parameter is used if <code>filterSectionStartsec</code> it set. If <code>TRUE</code> start times will be preserved, if <code>FALSE</code> the selection will start from 0.</p>
</td></tr>
<tr><td><code id="transcripts_filter_+3A_sort">sort</code></td>
<td>
<p>Logical; Annotations will be sorted: 'none' (=no sorting), 'tier&gt;startSec' (=sort first by tier, then by startSec), 'startSec&gt;tier' (=sort first by startSec, then by tier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# Filter corpus to only contain some tiers
all.tier.names &lt;- unique(act::tiers_all(examplecorpus)$name)
some.tier.names &lt;- all.tier.names[1:10]
x &lt;- act::transcripts_filter(examplecorpus, filterTierNames=some.tier.names)
x@history[[length(x@history)]]
</code></pre>

<hr>
<h2 id='transcripts_filter_single'>Filter a single transcript</h2><span id='topic+transcripts_filter_single'></span>

<h3>Description</h3>

<p>Filter a transcript object and return the filtered transcript object.
It is possible to filter out temporal sections and tiers.
In case that you want to select tiers by using regular expressions use the function <code>act::search_makefilter</code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_filter_single(
  t,
  filterTierNames = NULL,
  filterSectionStartsec = NULL,
  filterSectionEndsec = NULL,
  preserveTimes = TRUE,
  sort = c("none", "tier&gt;startSec", "startSec&gt;tier")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_filter_single_+3A_t">t</code></td>
<td>
<p>Transcript object.</p>
</td></tr>
<tr><td><code id="transcripts_filter_single_+3A_filtertiernames">filterTierNames</code></td>
<td>
<p>Vector of character strings; names of tiers to be remain in the transcripts. If left unspecified, all tiers will remain in the transcript exported.</p>
</td></tr>
<tr><td><code id="transcripts_filter_single_+3A_filtersectionstartsec">filterSectionStartsec</code></td>
<td>
<p>Double, start of selection in seconds.</p>
</td></tr>
<tr><td><code id="transcripts_filter_single_+3A_filtersectionendsec">filterSectionEndsec</code></td>
<td>
<p>Double, end of selection in seconds.</p>
</td></tr>
<tr><td><code id="transcripts_filter_single_+3A_preservetimes">preserveTimes</code></td>
<td>
<p>Logical; Parameter is used if <code>filterSectionStartsec</code> it set. If <code>TRUE</code> start times will be preserved, if <code>FALSE</code> the selection will start from 0.</p>
</td></tr>
<tr><td><code id="transcripts_filter_single_+3A_sort">sort</code></td>
<td>
<p>Logical; Annotations will be sorted: 'none' (=no sorting), 'tier&gt;startSec' (=sort first by tier, then by startSec), 'startSec&gt;tier' (=sort first by startSec, then by tier)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transcript object;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# get an example transcript
t1 &lt;- examplecorpus@transcripts[[1]]

# --- Filter by tiers
# The example transcript contains two tiers that contain four annotations each.
t1@tiers
table(t1@annotations$tier.name)

# Filter transcript to only contain annotations of the FIRST tier
t2 &lt;- act::transcripts_filter_single(t1, filterTierNames=t1@tiers$name[1])
t2@tiers
table(t2@annotations$tier.name)

# Use act::search_makefilter() first to get the tier names, 
# in this case search for tiers with a capital 'I',
# which is the second tier, called 'ISanti'
myfilter &lt;- act::search_makefilter(examplecorpus, 
				filterTranscriptNames=t2@name,
				filterTierIncludeRegEx="I"
				)
t2 &lt;- act::transcripts_filter_single(t1, filterTierNames=myfilter$tier.names)
t2@tiers
table(t2@annotations$tier.name)

# --- Filter by time section
# only set start of section (until the end of the transcript)
t2 &lt;- act::transcripts_filter_single(t1, filterSectionStartsec=6)
cbind(t2@annotations$startSec,t2@annotations$endSec) 
	  
# only set end of section (from the beginning of the transcript)
t2 &lt;- act::transcripts_filter_single(t1, filterSectionEndsec=8)
cbind(t2@annotations$startSec,t2@annotations$endSec) 

# set start and end of section
t2 &lt;- act::transcripts_filter_single(t1, filterSectionStartsec=6, filterSectionEndsec=8)
cbind(t2@annotations$startSec,t2@annotations$endSec) 

# set start and end of section, start new times from 0
t2 &lt;- act::transcripts_filter_single(t1, 
 filterSectionStartsec=6, 
 filterSectionEndsec=8,
 preserveTime=FALSE)
cbind(t2@annotations$startSec,t2@annotations$endSec) 

</code></pre>

<hr>
<h2 id='transcripts_merge'>Merge several transcripts</h2><span id='topic+transcripts_merge'></span>

<h3>Description</h3>

<p>Merges several transcript objects in a corpus object.
One transcript is the destination transcript (the transcript that will be updated and receives the new data).
The other transcripts are the update transcripts (they contain the data that will replace data in teh destination transcript).
The update transcripts need to contain a tier in which the update sections are marked with a specific character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_merge(
  x,
  destinationTranscriptName,
  updateTranscriptNames,
  identifierTier = "update",
  identifierPattern = ".+",
  eraseUpdateSectionsCompletely = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_merge_+3A_x">x</code></td>
<td>
<p>Corpus object;</p>
</td></tr>
<tr><td><code id="transcripts_merge_+3A_destinationtranscriptname">destinationTranscriptName</code></td>
<td>
<p>Character strings; name of transcript hat willl be updated.</p>
</td></tr>
<tr><td><code id="transcripts_merge_+3A_updatetranscriptnames">updateTranscriptNames</code></td>
<td>
<p>Vector of character strings; names of transcripts that contain the updates.</p>
</td></tr>
<tr><td><code id="transcripts_merge_+3A_identifiertier">identifierTier</code></td>
<td>
<p>Character string;  regular expression that identifies the tier in which the sections are marked, that will be inserted into transDestination.</p>
</td></tr>
<tr><td><code id="transcripts_merge_+3A_identifierpattern">identifierPattern</code></td>
<td>
<p>Character string; regular expression that identifies the sections that will be inserted into transDestination.</p>
</td></tr>
<tr><td><code id="transcripts_merge_+3A_eraseupdatesectionscompletely">eraseUpdateSectionsCompletely</code></td>
<td>
<p>Logical; if <code>TRUE</code> update sections in destination transcript will be erased completely, if <code>FALSE</code> update sections in the destination tier will not be erased completely but only the tiers that are present in the transUpdates be erased.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You may chose between the following two options:
</p>

<ul>
<li><p> The update sections in the destination transcript will first be erased completely and then the updates will be filled in.
</p>
</li>
<li><p> The update sections in the destination transcript will NOT be erased completely. Rater only the contents of tiers will be erased that are also present in the update tiers. e.g. if your destination transcript contains more tiers than the update transcripts, the contents of those tiers will be preserved in the destination tier during the update.
</p>
</li></ul>



<h3>Value</h3>

<p>Transcript object
</p>


<h3>See Also</h3>

<p><a href="#topic+transcripts_merge2">transcripts_merge2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# We need three transcripts  to demonstrate the function \code{transcripts_merge}:
# - the destination transcript: "update_destination"
# - two transcripts that contain updates: "update_update1 and "update_update2"

#Have a look at the annotations in the destination transcript first. 
#It contains 2 annotations:
examplecorpus@transcripts[["update_destination"]]@annotations
#Have a look at the annotations in the update_update1 transcript, too: 
#It contains 3 annotations:
examplecorpus@transcripts[["update_update1"]]@annotations

# Run the function with only one update:
test &lt;- act::transcripts_merge(x=examplecorpus,
   destinationTranscriptName="update_destination", 
   updateTranscriptNames = "update_update1")

#Have a look at the annotations in the destination transcript again.
#It now contains 5 annotations:
test@transcripts[["update_destination"]]@annotations


# Run the function with two transcript objects for updates:
test &lt;- act::transcripts_merge(x=examplecorpus,
	destinationTranscriptName="update_destination", 
	updateTranscriptNames = c("update_update1","update_update2"))

#Have a look at the annotations in the destination transcript again.
#It now contains 8 annotations:
test@transcripts[["update_destination"]]@annotations

# Compare the transcript in the original and in the modified corpus object. 
# The update transcript objects are gone:
act::info_summarized(examplecorpus)$transcript.names
act::info_summarized(test)$transcript.names
	
#Have a look at the history of the corpus object
test@history
</code></pre>

<hr>
<h2 id='transcripts_merge2'>Merge several transcripts (works with transcript objects directly)</h2><span id='topic+transcripts_merge2'></span>

<h3>Description</h3>

<p>Merges several transcripts. One transcript is the destination transcript (the transcript that will be updated).
The other transcripts are the update transcripts and contain the updates.
The update transcripts need to contain a tier in which the update sections are marked with a specific character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_merge2(
  destinationTranscript,
  updateTranscripts,
  identifierTier = "update",
  identifierPattern = ".+",
  eraseUpdateSectionsCompletely = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_merge2_+3A_destinationtranscript">destinationTranscript</code></td>
<td>
<p>Transcript object; transcript that serves as destination (and will receive the updates).</p>
</td></tr>
<tr><td><code id="transcripts_merge2_+3A_updatetranscripts">updateTranscripts</code></td>
<td>
<p>List of transcript objects; transcript objects that will be inserted into the destination transcripts (entirely or in part).</p>
</td></tr>
<tr><td><code id="transcripts_merge2_+3A_identifiertier">identifierTier</code></td>
<td>
<p>Character string;  regular expression that identifies the tier in which the sections are marked, that will be inserted into destinationTranscript.</p>
</td></tr>
<tr><td><code id="transcripts_merge2_+3A_identifierpattern">identifierPattern</code></td>
<td>
<p>Character string; regular expression that identifies the sections that will be inserted into destinationTranscript.</p>
</td></tr>
<tr><td><code id="transcripts_merge2_+3A_eraseupdatesectionscompletely">eraseUpdateSectionsCompletely</code></td>
<td>
<p>Logical; if <code>TRUE</code> update sections in destination transcript will be erased completely, if <code>FALSE</code> update sections in the destination tier will not be erased completely but only the tiers that are present in the updateTranscripts be erased.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You may chose between the following two options:
</p>

<ul>
<li><p> The update sections in the destination transcript will first be erased completely and then the updates will be filled in.
</p>
</li>
<li><p> The update sections in the destination transcript will NOT be erased completely. Rater only the contents of tiers will be erased that are also present in the update tiers. e.g. if your destination transcript contains more tiers than the update transcripts, the contents of those tiers will be preserved in the destination tier during the update.
</p>
</li></ul>



<h3>Value</h3>

<p>Transcript object
</p>


<h3>See Also</h3>

<p><a href="#topic+transcripts_merge">transcripts_merge</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# We need three transcripts  to demonstrate the function \code{transcripts_merge}:
# - the destination transcript
destinationTranscript &lt;- 	examplecorpus@transcripts[["update_destination"]]
# - two transcripts that contain updates
updateTranscripts &lt;- 		c(examplecorpus@transcripts[["update_update1" ]],
                           examplecorpus@transcripts[["update_update2" ]])

# Run the function
test &lt;- transcripts_merge2(destinationTranscript, updateTranscripts)

# Save the transcript to a TextGrid file.
# Set the destination file path
path &lt;- tempfile(pattern = "merge_test", tmpdir = tempdir(),
                 fileext = ".TextGrid")

# It makes more sense, however, to you define a destination folder
# that is easier to access on your computer:
## Not run: 
path &lt;- file.path("PATH_TO_AN_EXISTING_FOLDER_ON_YOUR_COMPUTER",
                    paste(t@name, ".TextGrid", sep=""))

## End(Not run)

# Export
act::export_textgrid( t=test, outputPath=path)

</code></pre>

<hr>
<h2 id='transcripts_rename'>Rename transcripts in a corpus</h2><span id='topic+transcripts_rename'></span>

<h3>Description</h3>

<p>Rename transcript objects in a corpus object.
This function changes both the names of the transcripts in the list <code>x@transcripts</code> and in the <code>@name</code> slot of the transcript.
The function ensures that each transcript object preserves a unique name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_rename(
  x,
  newTranscriptNames = NULL,
  searchPatterns = NULL,
  searchReplacements = NULL,
  toUpperCase = FALSE,
  toLowerCase = FALSE,
  trim = FALSE,
  stopIfNotUnique = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_rename_+3A_x">x</code></td>
<td>
<p>Corpus object</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_newtranscriptnames">newTranscriptNames</code></td>
<td>
<p>Vector of character strings; new names for the transcripts. If left open, the current names in the corpus object will be taken as basis.</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_searchpatterns">searchPatterns</code></td>
<td>
<p>Character string; Search pattern as regular expression applied to the names of the transcripts.</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_searchreplacements">searchReplacements</code></td>
<td>
<p>Character string; String to replace the hits of the search.</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_touppercase">toUpperCase</code></td>
<td>
<p>Logical; Convert transcript names all to upper case.</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_tolowercase">toLowerCase</code></td>
<td>
<p>Logical; Convert transcript names all to lower case.</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_trim">trim</code></td>
<td>
<p>Logical; Remove leading and trailing spaces in names.</p>
</td></tr>
<tr><td><code id="transcripts_rename_+3A_stopifnotunique">stopIfNotUnique</code></td>
<td>
<p>Logical; If <code>TRUE</code> the function will stop if replacement would lead to non-unique names; If <code>FALSE</code> names will be automatically changed to be unique.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

# get current names 
old.names &lt;- names(examplecorpus@transcripts)

# make vector of names with the same length
new.names &lt;- paste("transcript", 1:length(old.names), sep="")

# rename the transcripts
test &lt;- act::transcripts_rename(examplecorpus, newTranscriptNames=new.names)

# check
names(test@transcripts)
test@transcripts[[1]]@name
test@history[length(test@history)]

# convert to lower case
test &lt;- act::transcripts_rename(examplecorpus, toLowerCase=TRUE)
test@history[length(test@history)]

# search replace
test &lt;- act::transcripts_rename(examplecorpus, 
 searchPatterns=c("ARG", "BOL"), 
 searchReplacements = c("ARGENTINA", "BOLIVIA")
)
test@history[length(test@history)]

# search replace ignoring upper and lower case
test &lt;- act::transcripts_rename(examplecorpus, 
 searchPatterns=c("(?i)arg", "(?i)bol"), 
 searchReplacements = c("ARGENTINA", "BOLIVIA")
)
test@history[length(test@history)]


# search replace too much
test &lt;- act::transcripts_rename(x=examplecorpus, 
 searchPatterns="ARG_I_CHI_Santi", 
 searchReplacements = "")
names(test@transcripts)[1]

</code></pre>

<hr>
<h2 id='transcripts_update_fulltexts'>Update full texts</h2><span id='topic+transcripts_update_fulltexts'></span>

<h3>Description</h3>

<p>Creates/updates the full texts of the transcripts in a corpus.
The full text may be created in two different ways:
</p>

<ul>
<li><p> The contents of a transcription will be joined consecutively based on the time information.
</p>
</li>
<li><p> The contents of each tier will be joined consecutively, and then the next tier will be joined.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>transcripts_update_fulltexts(
  x,
  searchMode = c("fulltext", "fulltext.bytier", "fulltext.bytime"),
  transcriptNames = NULL,
  tierNames = NULL,
  forceUpdate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_update_fulltexts_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="transcripts_update_fulltexts_+3A_searchmode">searchMode</code></td>
<td>
<p>Character string; Which full text should be created; accepts the following values: <code>fulltext.bytier, fulltext.bytime, fulltext</code>.</p>
</td></tr>
<tr><td><code id="transcripts_update_fulltexts_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; Names of the transcripts you want to update; leave empty if you want to process all transcripts that need an update.</p>
</td></tr>
<tr><td><code id="transcripts_update_fulltexts_+3A_tiernames">tierNames</code></td>
<td>
<p>Vector of character strings; Names of the tiers to include in the fulltext.</p>
</td></tr>
<tr><td><code id="transcripts_update_fulltexts_+3A_forceupdate">forceUpdate</code></td>
<td>
<p>Logical; If <code>TRUE</code> fulltexts will be created in any case, if <code>FALSE</code> fulltexts will be only be created if there was a modification to the transcript since the last creation of the fulltexts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corpus object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

examplecorpus &lt;- act::transcripts_update_fulltexts(x=examplecorpus)

</code></pre>

<hr>
<h2 id='transcripts_update_normalization'>Normalize transcriptions</h2><span id='topic+transcripts_update_normalization'></span>

<h3>Description</h3>

<p>Normalizes the contents of transcriptions in a corpus object using a normalization matrix.
Function returns a corpus object with normalized transcription and updates the original corpus object passed as argument to x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcripts_update_normalization(
  x,
  path_replacementMatrixCSV = "",
  transcriptNames = NULL,
  forceUpdate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcripts_update_normalization_+3A_x">x</code></td>
<td>
<p>Corpus object.</p>
</td></tr>
<tr><td><code id="transcripts_update_normalization_+3A_path_replacementmatrixcsv">path_replacementMatrixCSV</code></td>
<td>
<p>Character string; path to replacement matrix in CSV format. If empty, the default replacement matrix that comes with the package will be used.</p>
</td></tr>
<tr><td><code id="transcripts_update_normalization_+3A_transcriptnames">transcriptNames</code></td>
<td>
<p>Vector of character strings; Names of the transcripts for which you want to search media files; leave empty if you want to search media for all transcripts in the corpus object.</p>
</td></tr>
<tr><td><code id="transcripts_update_normalization_+3A_forceupdate">forceUpdate</code></td>
<td>
<p>Logical; If <code>TRUE</code> transcripts will be normalized in any case, if <code>FALSE</code> transcripts will be only normalized if there was a modification to the transcript since the last normalization.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(act)

examplecorpus &lt;- act::transcripts_update_normalization(x=examplecorpus)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
