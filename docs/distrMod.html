<!DOCTYPE html><html lang="en"><head><title>Help for package distrMod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distrMod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distrMod-package'>
<p>distrMod &ndash; Object Oriented Implementation of Probability Models</p></a></li>
<li><a href='#.checkEstClassForParamFamily-methods'><p> Methods for Function .checkEstClassForParamFamily in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#addAlphTrsp2col'><p>&quot;addAlphTrsp2col&quot;</p></a></li>
<li><a href='#asBias'><p>Generating function for asBias-class</p></a></li>
<li><a href='#asBias-class'><p>Standardized Asymptotic Bias</p></a></li>
<li><a href='#asCov'><p>Generating function for asCov-class</p></a></li>
<li><a href='#asCov-class'><p>Asymptotic covariance</p></a></li>
<li><a href='#asGRisk-class'><p>Convex asymptotic risk</p></a></li>
<li><a href='#asHampel'><p>Generating function for asHampel-class</p></a></li>
<li><a href='#asHampel-class'><p>Asymptotic Hampel risk</p></a></li>
<li><a href='#asMSE'><p>Generating function for asMSE-class</p></a></li>
<li><a href='#asMSE-class'><p>Asymptotic mean square error</p></a></li>
<li><a href='#asRisk-class'><p>Aymptotic risk</p></a></li>
<li><a href='#asRiskwithBias-class'><p>Aymptotic risk</p></a></li>
<li><a href='#asSemivar'><p>Generating function for asSemivar-class</p></a></li>
<li><a href='#asSemivar-class'><p>Semivariance Risk Type</p></a></li>
<li><a href='#asUnOvShoot'><p>Generating function for asUnOvShoot-class</p></a></li>
<li><a href='#asUnOvShoot-class'><p>Asymptotic under-/overshoot probability</p></a></li>
<li><a href='#asymmetricBias'><p>Generating function for asymmetricBias-class</p></a></li>
<li><a href='#asymmetricBias-class'><p>asymmetric Bias Type</p></a></li>
<li><a href='#BetaFamily'><p>Generating function for Beta families</p></a></li>
<li><a href='#BiasType-class'><p>Bias Type</p></a></li>
<li><a href='#BinomFamily'><p>Generating function for Binomial families</p></a></li>
<li><a href='#CauchyLocationFamily'><p>Generating function for Cauchy location families</p></a></li>
<li><a href='#CauchyLocationScaleFamily'><p>Generating function for Cauchy location and scale families</p></a></li>
<li><a href='#checkL2deriv'><p>Generic function for checking L2-derivatives</p></a></li>
<li><a href='#Confint-class'><p>Confint-class</p></a></li>
<li><a href='#confint-methods'><p> Methods for function confint in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#distrModMASK'><p>Masking of/by other functions in package &quot;distrMod&quot;</p></a></li>
<li><a href='#distrModOptions'><p>Function to change the global variables of the package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#Estimate-class'><p>Estimate-class.</p></a></li>
<li><a href='#Estimator'><p> Function to compute estimates</p></a></li>
<li><a href='#EvenSymmetric'><p>Generating function for EvenSymmetric-class</p></a></li>
<li><a href='#EvenSymmetric-class'><p>Class for Even Functions</p></a></li>
<li><a href='#existsPIC-methods'><p> Methods for Function existsPIC in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#ExpScaleFamily'><p>Generating function for exponential scale families</p></a></li>
<li><a href='#fiBias'><p>Generating function for fiBias-class</p></a></li>
<li><a href='#fiBias-class'><p>Finite-sample Bias</p></a></li>
<li><a href='#fiCov'><p>Generating function for fiCov-class</p></a></li>
<li><a href='#fiCov-class'><p>Finite-sample covariance</p></a></li>
<li><a href='#fiHampel'><p>Generating function for fiHampel-class</p></a></li>
<li><a href='#fiHampel-class'><p>Finite-sample Hampel risk</p></a></li>
<li><a href='#fiMSE'><p>Generating function for fiMSE-class</p></a></li>
<li><a href='#fiMSE-class'><p>Finite-sample mean square error</p></a></li>
<li><a href='#fiRisk-class'><p>Finite-sample risk</p></a></li>
<li><a href='#fiUnOvShoot'><p>Generating function for fiUnOvShoot-class</p></a></li>
<li><a href='#fiUnOvShoot-class'><p>Finite-sample under-/overshoot probability</p></a></li>
<li><a href='#FunctionSymmetry-class'><p>Class of Symmetries for Functions</p></a></li>
<li><a href='#FunSymmList'><p>Generating function for FunSymmList-class</p></a></li>
<li><a href='#FunSymmList-class'><p>List of Symmetries for a List of Functions</p></a></li>
<li><a href='#GammaFamily'><p>Generating function for Gamma families</p></a></li>
<li><a href='#InfoNorm'><p>Generating function for InfoNorm-class</p></a></li>
<li><a href='#internal_mlehelpers_for_distrMod'><p>Internal helper functions for treating MCEstimators in package distrMod</p></a></li>
<li><a href='#InternalClassUnions'><p>Class unions in 'distrMod'</p></a></li>
<li><a href='#InternalReturnClasses-class'><p>Internal return classes for generating functions</p></a></li>
<li><a href='#internals_for_distrMod'><p>Internal functions of package distrMod</p></a></li>
<li><a href='#internals_for_qqplot'><p>Internal functions for qqplot of package distrMod</p></a></li>
<li><a href='#isKerAinKerB'><p>isKerAinKerB</p></a></li>
<li><a href='#L2GroupParamFamily-class'><p>L2 differentiable parametric group family</p></a></li>
<li><a href='#L2LocationFamily'><p>Generating function for L2LocationFamily-class</p></a></li>
<li><a href='#L2LocationFamily-class'><p>L2 differentiable parametric group family</p></a></li>
<li><a href='#L2LocationScaleFamily'><p>Generating function for L2LocationScaleFamily-class</p></a></li>
<li><a href='#L2LocationScaleFamily-class'><p>L2 differentiable parametric group family</p></a></li>
<li><a href='#L2LocationUnknownScaleFamily'><p>Generating function for L2LocationScaleFamily-class in nuisance situation</p></a></li>
<li><a href='#L2ParamFamily'><p>Generating function for L2ParamFamily-class</p></a></li>
<li><a href='#L2ParamFamily-class'><p>L2 differentiable parametric family</p></a></li>
<li><a href='#L2ScaleFamily'><p>Generating function for L2ScaleFamily-class</p></a></li>
<li><a href='#L2ScaleFamily-class'><p>L2 differentiable parametric group family</p></a></li>
<li><a href='#L2ScaleUnknownLocationFamily'><p>Generating function for L2LocationScaleFamily-class in nuisance situation</p></a></li>
<li><a href='#LnormScaleFamily'><p>Generating function for lognormal scale families</p></a></li>
<li><a href='#LogisticLocationScaleFamily'><p>Generating function for Logistic location and scale families</p></a></li>
<li><a href='#mceCalc-methods'><p> Methods for functions mceCalc and mleCalc in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#MCEstimate-class'><p>MCEstimate-class.</p></a></li>
<li><a href='#MCEstimator'><p> Function to compute minimum criterion estimates</p></a></li>
<li><a href='#MDEstimator'><p> Function to compute minimum distance estimates</p></a></li>
<li><a href='#meRes'><p>helper functions for mceCalc and mleCalc</p></a></li>
<li><a href='#MLEstimator'><p> Function to compute maximum likelihood estimates</p></a></li>
<li><a href='#modifyModel-methods'><p> Methods for function modifyModel in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#NbinomFamily'><p>Generating function for Nbinomial families</p></a></li>
<li><a href='#negativeBias'><p>Generating function for onesidedBias-class</p></a></li>
<li><a href='#NonSymmetric'><p>Generating function for NonSymmetric-class</p></a></li>
<li><a href='#NonSymmetric-class'><p>Class for Non-symmetric Functions</p></a></li>
<li><a href='#norm'><p>Norm functions</p></a></li>
<li><a href='#NormLocationFamily'><p>Generating function for normal location families</p></a></li>
<li><a href='#NormLocationScaleFamily'><p>Generating function for normal location and scale families</p></a></li>
<li><a href='#NormLocationUnknownScaleFamily'><p>Generating function for normal location families with unknown scale as nuisance</p></a></li>
<li><a href='#NormScaleFamily'><p>Generating function for normal scale families</p></a></li>
<li><a href='#NormScaleUnknownLocationFamily'><p>Generating function for normal scale families with unknown location as nuisance</p></a></li>
<li><a href='#NormType'><p>Generating function for NormType-class</p></a></li>
<li><a href='#NormType-class'><p>Norm Type</p></a></li>
<li><a href='#OddSymmetric'><p>Generating function for OddSymmetric-class</p></a></li>
<li><a href='#OddSymmetric-class'><p>Class for Odd Functions</p></a></li>
<li><a href='#onesidedBias-class'><p>onesided Bias Type</p></a></li>
<li><a href='#ParamFamily'><p>Generating function for ParamFamily-class</p></a></li>
<li><a href='#ParamFamily-class'><p>Parametric family of probability measures.</p></a></li>
<li><a href='#ParamFamParameter'><p>Generating function for ParamFamParameter-class</p></a></li>
<li><a href='#ParamFamParameter-class'><p>Parameter of a parametric family of probability measures</p></a></li>
<li><a href='#PoisFamily'><p>Generating function for Poisson families</p></a></li>
<li><a href='#positiveBias'><p>Generating function for onesidedBias-class</p></a></li>
<li><a href='#print-methods'><p>Common &lsquo;print&rsquo; Methods for S4 classes in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#ProbFamily-class'><p>Family of probability measures</p></a></li>
<li><a href='#QFNorm'><p>Generating function for QFNorm-class</p></a></li>
<li><a href='#QFNorm-class'><p>Norm classes for norms based on quadratic forms</p></a></li>
<li><a href='#qqplot'><p>Methods for Function qqplot in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#returnlevelplot'><p>Methods for Function returnlevelplot in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#RiskType-class'><p>Risk</p></a></li>
<li><a href='#SelfNorm'><p>Generating function for SelfNorm-class</p></a></li>
<li><a href='#symmetricBias'><p>Generating function for symmetricBias-class</p></a></li>
<li><a href='#symmetricBias-class'><p>symmetric Bias Type</p></a></li>
<li><a href='#trafo-methods'><p> Methods for function trafo in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#trafoEst'><p> Function trafoEst in Package &lsquo;distrMod&rsquo;</p></a></li>
<li><a href='#trAsCov'><p>Generating function for trAsCov-class</p></a></li>
<li><a href='#trAsCov-class'><p>Trace of asymptotic covariance</p></a></li>
<li><a href='#trFiCov'><p>Generating function for trFiCov-class</p></a></li>
<li><a href='#trFiCov-class'><p>Trace of finite-sample covariance</p></a></li>
<li><a href='#validParameter-methods'><p> Methods for function validParameter in Package &lsquo;distrMod&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.9.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Object Oriented Implementation of Probability Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements S4 classes for probability models based on packages 'distr' and
            'distrEx'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), distr(&ge; 2.8.0), distrEx(&ge; 2.8.0), RandVar(&ge;
1.2.0), MASS, stats4, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>startupmsg, sfsmisc, graphics, stats, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ismev, evd,</td>
</tr>
<tr>
<td>Enhances:</td>
<td>RobExtremes, RobAStBase</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://distr.r-forge.r-project.org/">http://distr.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2024-10-23 22:45:36 +0200 (Mi, 23
Okt 2024) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1480 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1501</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-11 23:28:36 UTC; ruckdesc</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl [aut, cph],
  Peter Ruckdeschel [cre, cph],
  R Core Team [ctb, cph] (for source file 'format.perc')</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Ruckdeschel &lt;peter.ruckdeschel@uni-oldenburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-14 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='distrMod-package'>
distrMod &ndash; Object Oriented Implementation of Probability Models
</h2><span id='topic+distrMod-package'></span><span id='topic+distrMod'></span>

<h3>Description</h3>

<p>Based on the packages <span class="pkg">distr</span> and <span class="pkg">distrEx</span> package <span class="pkg">distrMod</span>
provides a flexible framework which allows computation of estimators like
maximum likelihood or minimum distance estimators for probability models.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> distrMod </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.9.7 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2025-01-12 </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.4), distr(&gt;= 2.8.0), distrEx(&gt;= 2.8.0), RandVar(&gt;= 1.2.0), MASS, stats4,methods </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> startupmsg(&gt;= 1.0.0), sfsmisc, graphics, stats, grDevices </td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> ismev, evd, </td>
</tr>
<tr>
 <td style="text-align: left;">
Enhances: RobExtremes</td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://distr.r-forge.r-project.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
VCS/SVNRevision: </td><td style="text-align: left;"> 1501 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Classes</h3>

<pre>
[*]: there is a generating function with the same name
##########################
ProbFamily classes
##########################
slots: [&lt;name&gt;(&lt;class&gt;)]
name(character), distribution(Distribution),
distrSym(DistributionSymmetry), props(character)
"ProbFamily"
|&gt;"ParamFamily"     [*]
additional slots:
param(ParamFamParameter), modifyParam(function),
startPar(function), makeOKPar(function), fam.call(call)
|&gt;|&gt;"L2ParamFamily" [*]
additional slots:
L2deriv(EuclRandVarList), L2deriv.fct(function),
L2derivSymm(FunSymmList), L2derivDistr(DistrList),
L2derivDistrSymm(DistrSymmList), FisherInfo(PosSemDefSymmMatrix),
FisherInfo.fct(function)
|&gt;|&gt;|&gt;"BinomFamily" [*]
|&gt;|&gt;|&gt;"PoisFamily"  [*]
|&gt;|&gt;|&gt;"BetaFamily"  [*]
|&gt;|&gt;|&gt;"NbinomFamily" [*]
|&gt;|&gt;|&gt;"NbinomwithSizeFamily" [*]
|&gt;|&gt;|&gt;"NbinomMeanSizeFamily" [*]
|&gt;|&gt;|&gt;"L2GroupParamFamily"
additional slots:
LogDeriv(function)
|&gt;|&gt;|&gt;|&gt;"L2ScaleShapeUnion"  /VIRTUAL/
|&gt;|&gt;|&gt;|&gt;|&gt;"GammaFamily" [*]
|&gt;|&gt;|&gt;|&gt;"L2LocationScaleUnion"  /VIRTUAL/
additional slots:
locscalename(character)
|&gt;|&gt;|&gt;|&gt;|&gt;"L2LocationFamily"              [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"NormLocationFamily"          [*]
|&gt;|&gt;|&gt;|&gt;|&gt;"L2ScaleFamily"                 [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"NormScaleFamily"             [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"ExpScaleFamily"              [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"LnormScaleFamily"            [*]
|&gt;|&gt;|&gt;|&gt;|&gt;"L2LocationScaleFamily"         [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"NormLocationScaleFamily"     [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"CauchyLocationScaleFamily"   [*]
|&gt;|&gt;|&gt;|&gt;|&gt;|&gt;"LogisticLocationScaleFamily" [*]
and a (virtual) class union "L2ScaleUnion"  between
   "L2LocationScaleUnion"  and "L2ScaleShapeUnion"
##########################
ParamFamParameter
##########################
"ParamFamParameter" [*] is subclass of class "Parameter" of package "distr".
Additional slots:
main(numeric), nuisance(OptionalNumeric), fixed(OptionalNumeric),
trafo(MatrixorFunction)
##########################
Class unions
##########################
"MatrixorFunction" = union("matrix", "OptionalFunction")
"PrintDetails" = union("Estimate", "Confint",
                   "PosSemDefSymmMatrix",
                   "ParamFamParameter", "ParamFamily")
##########################
Symmetry classes            (other classes moved to package "distr")
##########################
slots:
type(character), SymmCenter(ANY)
"Symmetry"   (from package "distr")
|&gt;"FunctionSymmetry"
|&gt;|&gt;"NonSymmetric"      [*]
|&gt;|&gt;"EvenSymmetric"     [*]
|&gt;|&gt;"OddSymmetric"      [*]
list thereof
"FunSymmList"           [*]
##########################
Matrix classes              (moved to package "distr")
##########################
slots:
none
"PosSemDefSymmMatrix" [*] is subclass of class "matrix" of package "base".
|&gt;"PosDefSymmMatrix"  [*]
##########################
Norm Classes
##########################
slots:
name(character), fct(function)
"NormType"        [*]
|&gt;"QFNorm"        [*]
Additional slots:
QuadForm(PosSemDefSymmMatrix)
|&gt;|&gt;"InfoNorm"    [*]
|&gt;|&gt;"SelfNorm"    [*]
##########################
Bias Classes
##########################
slots:
name(character)
"BiasType"
|&gt;"symmetricBias"   [*]
|&gt;"onesidedBias"
Additional slots:
sign(numeric)
|&gt;"asymmetricBias"  [*]
Additional slots:
nu(numeric)
##########################
Risk Classes
##########################
slots:
type(character)
"RiskType"
|&gt;"asRisk"
|&gt;|&gt;"asCov"       [*]
|&gt;|&gt;"trAsCov"     [*]
|&gt;"fiRisk"
|&gt;|&gt;"fiCov"       [*]
|&gt;|&gt;"trfiCov"     [*]
|&gt;|&gt;"fiHampel"    [*]
Additional slots:
bound(numeric)
|&gt;|&gt;"fiMSE"       [*]
|&gt;|&gt;"fiBias"      [*]
|&gt;|&gt;"fiUnOvShoot" [*]
Additional slots:
width(numeric)
Risk with Bias:
"asRiskwithBias"
slots: biastype(BiasType), normtype(NormType),
|&gt;"asHampel"      [*]
Additional slots:
bound(numeric)
|&gt;"asBias"        [*]
|&gt;"asGRisk"
|&gt;|&gt;"asMSE"       [*]
|&gt;|&gt;"asUnOvShoot" [*]
Additional slots:
width(numeric)
|&gt;|&gt;"asSemivar"   [*]
##########################
Estimate Classes
##########################
slots:
name(character), estimate(ANY),
samplesize(numeric), asvar(OptionalMatrix),
Infos(matrix), nuis.idx(OptionalNumeric)
fixed.estimate(OptionalNumeric),
estimate.call(call), trafo(list[of function, matrix]),
untransformed.estimate(ANY),
untransformed.asvar(OptionalMatrix)
criterion.fct(function), method(character),
"Estimate"
|&gt;"MCEstimate",
Additional slots:
criterion(numeric)
##########################
Confidence interval class
##########################
slots:
type(character), confint(array),
estimate.call(call), name.estimate(character),
trafo.estimate(list[of function, matrix]),
nuisance.estimate(OptionalNumeric)
"Confint"
</pre>


<h3>Methods</h3>

<p>besides accessor and replacement functions, we have
methods
<code>solve</code>, <code>sqrt</code> for matrices
<code>checkL2deriv</code>, <code>existsPIC</code> for class <code>L2ParamFamily</code>
<code>LogDeriv</code> for  class <code>L2GroupParamFamily</code>
<code>validParameter</code> for classes <code>ParamFamily</code>, <code>L2ScaleFamily</code>,
<code>L2LocationFamily</code>, and <code>L2LocationScaleFamily</code>
<code>modifyModel</code> for the pairs of classes
<code>L2ParamFamily</code> and <code>ParamFamParameter</code>,
<code>L2LocationFamily</code> and <code>ParamFamParameter</code>,
<code>L2ScaleFamily</code> and <code>ParamFamParameter</code>,
<code>L2LocationScaleFamily</code> and <code>ParamFamParameter</code>,
<code>GammaFamily</code> and <code>ParamFamParameter</code>, and
<code>ExpScaleFamily</code> and <code>ParamFamParameter</code>
<code>mceCalc</code> for the pair of classes <code>numeric</code> and <code>ParamFamily</code>
<code>mleCalc</code> for the pairs of classes
<code>numeric</code> and <code>ParamFamily</code>,
<code>numeric</code> and <code>BinomFamily</code>,
<code>numeric</code> and <code>PoisFamily</code>,
<code>numeric</code> and <code>NormLocationFamily</code>,
<code>numeric</code> and <code>NormScaleFamily</code>, and
<code>numeric</code> and <code>NormLocationScaleFamily</code>
<code>coerce</code> from class <code>MCEstimate</code> to class <code>mle</code>
<code>confint</code> for  class <code>Estimate</code>
<code>profile</code> for  class <code>MCEstimate</code>
</p>


<h3>Functions</h3>

<pre>
Management of global options:
"distrModOptions", "distrModoptions", "getdistrModOption",
check for ker of matrix: "isKerAinKerB"
particular norms: "EuclideanNorm", "QuadFormNorm"
onesided bias: "positiveBias", "negativeBias",
Estimators:
"Estimator", "MCEstimator", "MLEstimator", "MDEstimator"
special location/scale models:
"L2LocationUnknownScaleFamily", "L2ScaleUnknownLocationFamily"
some special normal models:
"NormScaleUnknownLocationFamily", "NormLocationUnknownScaleFamily",
</pre>

<h3>Start-up-Banner</h3>

<p>You may suppress the start-up banner/message completely by setting
<code>options("StartupBanner"="off")</code> somewhere before loading this
package by <code>library</code> or <code>require</code> in your R-code / R-session.
If option <code>"StartupBanner"</code> is not defined (default) or setting
<code>options("StartupBanner"=NULL)</code> or
<code>options("StartupBanner"="complete")</code> the complete start-up banner is
displayed.
For any other value of option <code>"StartupBanner"</code>
(i.e., not in <code>c(NULL,"off","complete")</code>)
only the version information is displayed.
The same can be achieved by wrapping the <code>library</code> or <code>require</code>
call into either <code>suppressStartupMessages()</code> or
<code>onlytypeStartupMessages(.,atypes="version")</code>.
As for general <code>packageStartupMessage</code>'s, you may also suppress all
the start-up banner by wrapping the <code>library</code> or <code>require</code>
call into <code>suppressPackageStartupMessages()</code> from
<span class="pkg">startupmsg</span>-version 0.5 on.
</p>


<h3>Demos</h3>

<p>Demos are available &mdash; see <code>demo(package="distrMod")</code>.</p>


<h3>Scripts</h3>

<p>Example scripts are available &mdash; see folder &lsquo;<span class="file">scripts</span>&rsquo;
in the package folder to package <span class="pkg">distrMod</span> in your library.
</p>


<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
distrXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Note</h3>

<p>Some functions of packages <span class="pkg">stats</span>, <span class="pkg">base</span> have intentionally been masked,
but completely retain their functionality &mdash; see <code>distrModMASK()</code>.
If any of the packages <span class="pkg">stats4</span>, <span class="pkg">fBasics</span> is to be used
together with <span class="pkg">distrMod</span>, the latter must be attached <em>after</em> any of the
first mentioned. Otherwise <code>confint()</code> defined as <em>method</em>
in <span class="pkg">distrMod</span> may get masked.<br />  To re-mask, you
may use  <code>confint &lt;- distrMod::confint</code>.
See also <code>distrModMASK()</code>
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
<em>Maintainer:</em> Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>M. Kohl and P. Ruckdeschel (2010):
R Package distrMod: S4 Classes and Methods for Probability Models.
Journal of Statistical Software, 35(10), 1-27.
<a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>
(see also <code>vignette("distrMod")</code>)
P. Ruckdeschel, M. Kohl, T. Stabla, F. Camphausen (2006):
S4 Classes for Distributions, <em>R News</em>, <em>6</em>(2), 2-6.
<a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf">https://CRAN.R-project.org/doc/Rnews/Rnews_2006-2.pdf</a>
A vignette for packages <span class="pkg">distr</span>, <span class="pkg">distrSim</span>, <span class="pkg">distrTEst</span>, and
<span class="pkg">distrEx</span> is included into the mere documentation package <span class="pkg">distrDoc</span>
and may be called by
<code>require("distrDoc");vignette("distr")</code>
</p>

<hr>
<h2 id='.checkEstClassForParamFamily-methods'> Methods for Function .checkEstClassForParamFamily in Package &lsquo;distrMod&rsquo; </h2><span id='topic+.checkEstClassForParamFamily'></span><span id='topic+.checkEstClassForParamFamily-methods'></span><span id='topic+.checkEstClassForParamFamily+2CANY-method'></span><span id='topic+.checkEstClassForParamFamily+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>.checkEstClassForParamFamily-methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkEstClassForParamFamily(PFam, estimator)
## S4 method for signature 'ANY,ANY'
.checkEstClassForParamFamily(PFam, estimator)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".checkEstClassForParamFamily-methods_+3A_pfam">PFam</code></td>
<td>
<p>a parametric family. </p>
</td></tr>
<tr><td><code id=".checkEstClassForParamFamily-methods_+3A_estimator">estimator</code></td>
<td>
<p>an estimator. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The respective methods can be used to cast an estimator to
a model-specific subclass with particular methods.
</p>


<h3>Value</h3>

<p>The (default) <code>ANY,ANY</code>-method returns the estimator unchanged.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>

<hr>
<h2 id='addAlphTrsp2col'>&quot;addAlphTrsp2col&quot;</h2><span id='topic+addAlphTrsp2col'></span>

<h3>Description</h3>

<p>Adds alpha transparency to a given color.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAlphTrsp2col(col, alpha=255)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addAlphTrsp2col_+3A_col">col</code></td>
<td>
<p>any valid color</p>
</td></tr>
<tr><td><code id="addAlphTrsp2col_+3A_alpha">alpha</code></td>
<td>
<p>tranparancy; an integer value in [0,255]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color in rgb coordinates</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
  addAlphTrsp2col(rgb(1,0.3,0.03), 25)
  ## gives "#FF4C0819" on 32bit and "#FF4D0819" on 64bit
## IGNORE_RDIFF_END
  addAlphTrsp2col("darkblue", 25)
  addAlphTrsp2col("#AAAAAAAA",25)
  palette(rainbow(6))
  addAlphTrsp2col(2, 25)
</code></pre>

<hr>
<h2 id='asBias'>Generating function for asBias-class</h2><span id='topic+asBias'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asBias"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asBias(biastype = symmetricBias(), normtype = NormType())</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asBias_+3A_biastype">biastype</code></td>
<td>
<p> a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="asBias_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asBias"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asBias-class">asBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asBias()

## The function is currently defined as
function(biastype = symmetricBias(), normtype = NormType()){ 
     new("asBias",biastype = biastype, normtype = normtype) }
</code></pre>

<hr>
<h2 id='asBias-class'>Standardized Asymptotic Bias</h2><span id='topic+asBias-class'></span>

<h3>Description</h3>

<p>Class of standardized asymptotic bias; i.e., 
the neighborhood radius is omitted respectively, set to <code class="reqn">1</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asBias", ...)</code>.
More frequently they are created via the generating function 
<code>asBias</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;asymptotic bias&rdquo;. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>: 
norm in which a multivariate parameter is considered</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asRiskwithBias"</code>, directly.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code><br />
Class <code>"RiskType"</code>, by class <code>"asRisk"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asRisk-class">asRisk-class</a></code>, <code><a href="#topic+asBias">asBias</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asBias")
</code></pre>

<hr>
<h2 id='asCov'>Generating function for asCov-class</h2><span id='topic+asCov'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asCov"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asCov()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"asCov"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asCov-class">asCov-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asCov()

## The function is currently defined as
function(){ new("asCov") }
</code></pre>

<hr>
<h2 id='asCov-class'>Asymptotic covariance</h2><span id='topic+asCov-class'></span>

<h3>Description</h3>

<p>Class of asymptotic covariance.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asCov", ...)</code>.
More frequently they are created via the generating function 
<code>asCov</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;asymptotic covariance&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"asRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;asCov&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asRisk-class">asRisk-class</a></code>, <code><a href="#topic+asCov">asCov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asCov")
</code></pre>

<hr>
<h2 id='asGRisk-class'>Convex asymptotic risk</h2><span id='topic+asGRisk-class'></span>

<h3>Description</h3>

<p>Class of special convex asymptotic risks.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>: 
norm in which a multivariate parameter is considered</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"asRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;asGRisk&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asRisk-class">asRisk-class</a></code></p>

<hr>
<h2 id='asHampel'>Generating function for asHampel-class</h2><span id='topic+asHampel'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asHampel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asHampel(bound = Inf, biastype = symmetricBias(), normtype = NormType())</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asHampel_+3A_bound">bound</code></td>
<td>
<p> positive real: bias bound </p>
</td></tr>
<tr><td><code id="asHampel_+3A_biastype">biastype</code></td>
<td>
<p> a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="asHampel_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>asHampel</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asHampel-class">asHampel-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asHampel()

## The function is currently defined as
function(bound = Inf, biastype = symmetricBias(), normtype = NormType()){ 
    new("asHampel", bound = bound, biastype = biastype, normtype = normtype) }
</code></pre>

<hr>
<h2 id='asHampel-class'>Asymptotic Hampel risk</h2><span id='topic+asHampel-class'></span><span id='topic+bound'></span><span id='topic+bound+2CasHampel-method'></span><span id='topic+show+2CasHampel-method'></span>

<h3>Description</h3>

<p>Class of asymptotic Hampel risk which is
the trace of the asymptotic covariance subject to
a given bias bound (bound on gross error sensitivity). </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asHampel", ...)</code>.
More frequently they are created via the generating function 
<code>asHampel</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;trace of asymptotic covariance for given bias bound&rdquo;. </p>
</dd>
<dt><code>bound</code></dt><dd><p>Object of class <code>"numeric"</code>: 
given positive bias bound. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asRiskwithBias"</code>, directly.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.
Class <code>"RiskType"</code>, by class <code>"asRisk"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>bound</dt><dd><p><code>signature(object = "asHampel")</code>: 
accessor function for slot <code>bound</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "asHampel")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asRisk-class">asRisk-class</a></code>, <code><a href="#topic+asHampel">asHampel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asHampel")
</code></pre>

<hr>
<h2 id='asMSE'>Generating function for asMSE-class</h2><span id='topic+asMSE'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asMSE"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asMSE(biastype = symmetricBias(), normtype = NormType())</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asMSE_+3A_biastype">biastype</code></td>
<td>
<p>a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="asMSE_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asMSE"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asMSE-class">asMSE-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asMSE()

## The function is currently defined as
function(biastype = symmetricBias(), normtype = NormType()){ 
         new("asMSE", biastype = biastype, normtype = normtype) }
</code></pre>

<hr>
<h2 id='asMSE-class'>Asymptotic mean square error</h2><span id='topic+asMSE-class'></span>

<h3>Description</h3>

<p>Class of asymptotic mean square error.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asMSE", ...)</code>.
More frequently they are created via the generating function 
<code>asMSE</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;asymptotic mean square error&rdquo;. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>: 
norm in which a multivariate parameter is considered</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asGRisk"</code>, directly.<br />
Class <code>"asRiskwithBias"</code>, by class <code>"asGRisk"</code>.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.<br />
Class <code>"RiskType"</code>, by class <code>"asGRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;asMSE&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asGRisk-class">asGRisk-class</a></code>, <code><a href="#topic+asMSE">asMSE</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asMSE")
</code></pre>

<hr>
<h2 id='asRisk-class'>Aymptotic risk</h2><span id='topic+asRisk-class'></span>

<h3>Description</h3>

<p>Class of asymptotic risks.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RiskType"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;asRisk&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions (submitted).
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RiskType-class">RiskType-class</a></code></p>

<hr>
<h2 id='asRiskwithBias-class'>Aymptotic risk</h2><span id='topic+asRiskwithBias-class'></span><span id='topic+biastype+2CasRiskwithBias-method'></span><span id='topic+biastype+3C-+2CasRiskwithBias-method'></span><span id='topic+normtype+2CasRiskwithBias-method'></span><span id='topic+normtype+3C-+2CasRiskwithBias-method'></span><span id='topic+norm+2CasRiskwithBias-method'></span><span id='topic+normtype'></span><span id='topic+normtype+3C-'></span><span id='topic+norm'></span><span id='topic+biastype'></span><span id='topic+biastype+3C-'></span>

<h3>Description</h3>

<p>Class of asymptotic risks.</p>


<h3>Objects from the Class</h3>

<p>A &ldquo;virtual&rdquo; Class (although it does not contain &quot;VIRTUAL&quot;): No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>.</p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RiskType"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>biastype</dt><dd><p><code>signature(object = "asRiskwithBias")</code>: 
accessor function for slot <code>biastype</code>. </p>
</dd>
<dt>biastype&lt;-</dt><dd><p><code>signature(object = "asRiskwithBias", value = "BiasType")</code>: 
replacement function for slot <code>biastype</code>. </p>
</dd>
<dt>normtype</dt><dd><p><code>signature(object = "asRiskwithBias")</code>: 
accessor function for slot <code>normtype</code>. </p>
</dd>
<dt>normtype&lt;-</dt><dd><p><code>signature(object = "asRiskwithBias", value = "NormType")</code>: 
replacement function for slot <code>normtype</code>. </p>
</dd>
<dt>norm</dt><dd><p><code>signature(object = "asRiskwithBias")</code>: 
accessor function for slot <code>fct</code> of slot <code>norm</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asRisk-class">asRisk-class</a></code></p>

<hr>
<h2 id='asSemivar'>Generating function for asSemivar-class</h2><span id='topic+asSemivar'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asSemivar"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSemivar(sign = 1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asSemivar_+3A_sign">sign</code></td>
<td>
<p> positive (=1) or negative Bias (=-1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asSemivar"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onesidedBias-class">onesidedBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asSemivar()

</code></pre>

<hr>
<h2 id='asSemivar-class'>Semivariance Risk Type</h2><span id='topic+asSemivar-class'></span><span id='topic+sign+2CasSemivar-method'></span><span id='topic+sign+3C-+2CasSemivar-method'></span>

<h3>Description</h3>

<p>Class for semi-variance risk.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asSemivar", ...)</code>.
More frequently they are created via the generating function 
<code>asSemivar</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;asymptotic mean square error&rdquo;. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>: 
norm in which a multivariate parameter is considered</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>sign</dt><dd><p><code>signature(object = "asSemivar")</code>:
accessor function for slot <code>sign</code>. </p>
</dd>
<dt>sign&lt;-</dt><dd><p><code>signature(object = "asSemivar", value = "numeric")</code>:
replacement function for slot <code>sign</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asGRisk"</code>, directly.<br />
Class <code>"asRiskwithBias"</code>, by class <code>"asGRisk"</code>.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.<br />
Class <code>"RiskType"</code>, by class <code>"asGRisk"</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asGRisk-class">asGRisk-class</a></code>, <code><a href="#topic+asMSE">asMSE</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asSemivar()
</code></pre>

<hr>
<h2 id='asUnOvShoot'>Generating function for asUnOvShoot-class</h2><span id='topic+asUnOvShoot'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asUnOvShoot"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asUnOvShoot(width = 1.960, biastype = symmetricBias())</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asUnOvShoot_+3A_width">width</code></td>
<td>
<p> positive real: half the width of given confidence interval. </p>
</td></tr>
<tr><td><code id="asUnOvShoot_+3A_biastype">biastype</code></td>
<td>
<p> a bias type of class <code>BiasType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asUnOvShoot"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asUnOvShoot-class">asUnOvShoot-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asUnOvShoot()

## The function is currently defined as
function(width = 1.960, biastype = symmetricBias()){ 
     new("asUnOvShoot", width = width, biastype = biastype) }
</code></pre>

<hr>
<h2 id='asUnOvShoot-class'>Asymptotic under-/overshoot probability</h2><span id='topic+asUnOvShoot-class'></span><span id='topic+width'></span><span id='topic+width+2CasUnOvShoot-method'></span><span id='topic+show+2CasUnOvShoot-method'></span>

<h3>Description</h3>

<p>Class of asymptotic under-/overshoot probability.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asUnOvShoot", ...)</code>.
More frequently they are created via the generating function 
<code>asUnOvShoot</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;asymptotic under-/overshoot probability&rdquo;. </p>
</dd>
<dt><code>width</code></dt><dd><p>Object of class <code>"numeric"</code>: 
half the width of given confidence interval. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asGRisk"</code>, directly.<br />
Class <code>"asRiskwithBias"</code>, by class <code>"asGRisk"</code>.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.<br />
Class <code>"RiskType"</code>, by class <code>"asGRisk"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>width</dt><dd><p><code>signature(object = "asUnOvShoot")</code>: 
accessor function for slot <code>width</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "asUnOvShoot")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asGRisk-class">asGRisk-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asUnOvShoot")
</code></pre>

<hr>
<h2 id='asymmetricBias'>Generating function for asymmetricBias-class</h2><span id='topic+asymmetricBias'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asymmetricBias"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymmetricBias(name = "asymmetric Bias", nu = c(1,1) )</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asymmetricBias_+3A_name">name</code></td>
<td>
<p> name of the bias type</p>
</td></tr>
<tr><td><code id="asymmetricBias_+3A_nu">nu</code></td>
<td>
<p>weights for negative and positive bias, respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asymmetricBias"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asymmetricBias-class">asymmetricBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asymmetricBias()

## The function is currently defined as
function(){ new("asymmetricBias", name = "asymmetric Bias", nu = c(1,1)) }
</code></pre>

<hr>
<h2 id='asymmetricBias-class'>asymmetric Bias Type</h2><span id='topic+asymmetricBias-class'></span><span id='topic+nu+2CasymmetricBias-method'></span><span id='topic+nu+3C-+2CasymmetricBias-method'></span><span id='topic+nu'></span><span id='topic+nu+3C-'></span>

<h3>Description</h3>

<p>Class of asymmetric bias types.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asymmetricBias", ...)</code>.
More frequently they are created via the generating function 
<code>asymmetricBias</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>nu</code></dt><dd><p>Object of class <code>"numeric"</code>; 
to be in (0,1] x (0,1] with maximum 1; weights for 
negative and positive bias, respectively</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>nu</dt><dd><p><code>signature(object = "asymmetricBias")</code>: 
accessor function for slot <code>nu</code>. </p>
</dd>
<dt>nu&lt;-</dt><dd><p><code>signature(object = "asymmetricBias", value = "numeric")</code>: 
replacement function for slot <code>nu</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"BiasType"</code>, directly.<br />
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiasType-class">BiasType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asymmetricBias()
## The function is currently defined as
function(){ new("asymmetricBias", name = "asymmetric Bias", nu = c(1,1)) }

aB &lt;- asymmetricBias()
nu(aB)
try(nu(aB) &lt;- -2) ## error
nu(aB) &lt;- c(0.3,1)
</code></pre>

<hr>
<h2 id='BetaFamily'>Generating function for Beta families</h2><span id='topic+BetaFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ParamFamily"</code> which
represents a Beta family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BetaFamily(shape1 = 1, shape2 = 1, trafo, withL2derivDistr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BetaFamily_+3A_shape1">shape1</code></td>
<td>
<p> positive real: shape1 parameter </p>
</td></tr>
<tr><td><code id="BetaFamily_+3A_shape2">shape2</code></td>
<td>
<p> positive real: shape2 parameter </p>
</td></tr>
<tr><td><code id="BetaFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter </p>
</td></tr>
<tr><td><code id="BetaFamily_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>TRUE</code>; setting it to <code>FALSE</code>
speeds up computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Beta-class">Beta-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(B1 &lt;- BetaFamily())
FisherInfo(B1)
## IGNORE_RDIFF_BEGIN
checkL2deriv(B1)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='BiasType-class'>Bias Type</h2><span id='topic+BiasType-class'></span><span id='topic+name+2CBiasType-method'></span><span id='topic+name+3C-+2CBiasType-method'></span>

<h3>Description</h3>

<p>Class of bias types.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "BiasType")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "BiasType", value = "character")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RiskType-class">RiskType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aB &lt;- positiveBias()
name(aB)
</code></pre>

<hr>
<h2 id='BinomFamily'>Generating function for Binomial families</h2><span id='topic+BinomFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ParamFamily"</code> which
represents a Binomial family where the probability of
success is the parameter of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinomFamily(size = 1, prob = 0.5, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BinomFamily_+3A_size">size</code></td>
<td>
<p> number of trials </p>
</td></tr>
<tr><td><code id="BinomFamily_+3A_prob">prob</code></td>
<td>
<p> probability of success </p>
</td></tr>
<tr><td><code id="BinomFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the 
Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Binom-class">Binom-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(B1 &lt;- BinomFamily(size = 25, prob = 0.25))
plot(B1)
FisherInfo(B1)
checkL2deriv(B1)
</code></pre>

<hr>
<h2 id='CauchyLocationFamily'>Generating function for Cauchy location families</h2><span id='topic+CauchyLocationFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationFamily"</code> which
represents a Cauchy location family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CauchyLocationFamily(loc = 0, scale = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CauchyLocationFamily_+3A_loc">loc</code></td>
<td>
<p> location </p>
</td></tr>
<tr><td><code id="CauchyLocationFamily_+3A_scale">scale</code></td>
<td>
<p> scale </p>
</td></tr>
<tr><td><code id="CauchyLocationFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@uni-oldenburg.de">Peter.Ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Cauchy-class">Cauchy-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(C1 &lt;- CauchyLocationFamily())
plot(C1)
FisherInfo(C1)
### need smaller integration range:
checkL2deriv(C1)
</code></pre>

<hr>
<h2 id='CauchyLocationScaleFamily'>Generating function for Cauchy location and scale families</h2><span id='topic+CauchyLocationScaleFamily'></span><span id='topic+CauchyFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> which
represents a Cauchy location and scale family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CauchyLocationScaleFamily(loc = 0, scale = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CauchyLocationScaleFamily_+3A_loc">loc</code></td>
<td>
<p> location </p>
</td></tr>
<tr><td><code id="CauchyLocationScaleFamily_+3A_scale">scale</code></td>
<td>
<p> scale </p>
</td></tr>
<tr><td><code id="CauchyLocationScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Cauchy-class">Cauchy-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(C1 &lt;- CauchyLocationScaleFamily())
## synonymous: C1 &lt;- CauchyFamily()
plot(C1)
FisherInfo(C1)
### need smaller integration range:
distrExoptions("ElowerTruncQuantile"=1e-4,"EupperTruncQuantile"=1e-4)
checkL2deriv(C1)
distrExoptions("ElowerTruncQuantile"=1e-7,"EupperTruncQuantile"=1e-7)
</code></pre>

<hr>
<h2 id='checkL2deriv'>Generic function for checking L2-derivatives</h2><span id='topic+checkL2deriv'></span><span id='topic+print.relMatrix'></span>

<h3>Description</h3>

<p>Generic function for checking the L2-derivative of
an L2-differentiable family of probability measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkL2deriv(L2Fam, ...)
## S3 method for class 'relMatrix'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkL2deriv_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures </p>
</td></tr>
<tr><td><code id="checkL2deriv_+3A_x">x</code></td>
<td>
<p> argument to be printed </p>
</td></tr>
<tr><td><code id="checkL2deriv_+3A_...">...</code></td>
<td>
<p> additional parameters (ignored/for compatibility with S3 generic 
in case <code>print.relMatrix</code>) </p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The precisions of the centering and the Fisher information
are computed.
</p>


<h3>Value</h3>

<p>A list with items <code>maximum.deviation</code>, <code>cent</code>, <code>consist</code>,
and <code>condition</code> is invisibly returned, where <code>maximum.deviation</code>
comprises the maximal absolute value of all entries in <code>cent</code> and <code>consist</code>,
<code>cent</code> shows the expectation of <code>L2deriv(L2Fam)</code>
(which should be 0), <code>consist</code> shows the difference
between the Fisher information and <code>cov(L2deriv(L2Fam))</code> (which should be 0), and
<code>condition</code> is the condition number of the Fisher information.</p>


<h3>Note</h3>

<p>The return value gives the non-rounded values (which will be machine dependent),
whereas on argument <code>out==TRUE</code> (the default) we only issue the values up to
5 digits which should be independent of the machine. For the output of relative
differences, we adjust accuracy to the size of the maximal (absolute) value of 
the Fisher information. In case of the consistency condition, at positions where
the denominator is 0, we print a &quot;.&quot;; this is done through helper S3 method
<code>print.relMatrix</code>.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("L2ParamFamily")
checkL2deriv(F1)
</code></pre>

<hr>
<h2 id='Confint-class'>Confint-class</h2><span id='topic+Confint-class'></span><span id='topic+type+2CConfint-method'></span><span id='topic+call.estimate'></span><span id='topic+call.estimate+2CConfint-method'></span><span id='topic+confint+2CConfint+2Cmissing-method'></span><span id='topic+name.estimate'></span><span id='topic+name.estimate+2CConfint-method'></span><span id='topic+trafo.estimate'></span><span id='topic+trafo.estimate+2CConfint-method'></span><span id='topic+samplesize.estimate'></span><span id='topic+samplesize.estimate+2CConfint-method'></span><span id='topic+completecases.estimate'></span><span id='topic+completecases.estimate+2CConfint-method'></span><span id='topic+nuisance.estimate'></span><span id='topic+nuisance.estimate+2CConfint-method'></span><span id='topic+fixed.estimate'></span><span id='topic+fixed.estimate+2CConfint-method'></span><span id='topic+show+2CConfint-method'></span><span id='topic+print+2CConfint-method'></span>

<h3>Description</h3>

<p>Return value S4 classes for method &ldquo;confint&rdquo;.</p>


<h3>Objects from the Class</h3>

<p>Objects could in principle be created by calls of the 
form <code>new("Confint", ...)</code>.
The preferred form is to have them created via a call to 
<code><a href="#topic+confint">confint</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
type of the confidence interval (asymptotic, bootstrap,...). 
Can be of length <code>&gt;2</code>. Then in printing, the first element
is printed in the gap '[...]' in 'an [...] confidence interval',
while the other elements are printed below.</p>
</dd>
<dt><code>confint</code></dt><dd><p>Object of class <code>"array"</code>:
the confidence interval(s).</p>
</dd>
<dt><code>call.estimate</code></dt><dd><p>Object of class <code>"call"</code>:
the estimate(s) for which the confidence intervals are produced.</p>
</dd>
<dt><code>name.estimate</code></dt><dd><p>Object of class <code>"character"</code>:
the name of the estimate(s) for which the confidence intervals are produced.</p>
</dd>
<dt><code>samplesize.estimate</code>:</dt><dd><p>Object of class <code>"numeric"</code>:
the sample size of the estimate(s) for which the confidence intervals
are (only complete cases) produced.</p>
</dd>
<dt><code>completecases.estimate</code>:</dt><dd><p>Object of class <code>"logical"</code>:
complete cases at which the estimate was evaluated. </p>
</dd>
<dt><code>trafo.estimate</code></dt><dd><p>Object of class <code>"matrix"</code>:
the trafo/derivative matrix of the estimate(s) for which 
the confidence intervals are produced.</p>
</dd>
<dt><code>nuisance.estimate</code></dt><dd><p>Object of class <code>"OptionalNumeric"</code>:
the nuisance parameter (if any) at which the confidence 
intervals are produced.</p>
</dd>
<dt><code>fixed.estimate</code></dt><dd><p>Object of class <code>"OptionalNumeric"</code>:
the fixed part of the parameter (if any) at which the confidence 
intervals are produced.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>type</dt><dd><p><code>signature(object = "Confint")</code>: 
accessor function for slot <code>type</code>. </p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "Confint", method = "missing")</code>: 
accessor function for slot <code>type</code>. </p>
</dd>
<dt>call.estimate</dt><dd><p><code>signature(object = "Confint")</code>: 
accessor function for slot <code>call.estimate</code>. </p>
</dd>
<dt>name.estimate</dt><dd><p><code>signature(object = "Confint")</code>: 
accessor function for slot <code>name.estimate</code>. </p>
</dd>
<dt>trafo.estimate</dt><dd><p><code>signature(object = "Confint")</code>: 
accessor function for slot <code>trafo.estimate</code>. </p>
</dd>
<dt>samplesize.estimate</dt><dd><p><code>signature(object = "Confint")</code>:
(with additional argument <code>onlycompletecases</code>
defaulting to <code>TRUE</code> returns the sample size;
in case there are any incomplete cases and argument
<code>onlycompletecases</code> is <code>FALSE</code>, the number of
these is added to slot <code>samplesize</code>. </p>
</dd>
<dt>completecases.estimate</dt><dd><p><code>signature(object = "Confint")</code>:
accessor function for slot <code>completecases.estimate</code>. </p>
</dd>
<dt>nuisance.estimate</dt><dd><p><code>signature(object = "Confint")</code>: 
accessor function for slot <code>nuisance.estimate</code>. </p>
</dd>
<dt>fixed.estimate</dt><dd><p><code>signature(object = "Confint")</code>: 
accessor function for slot <code>fixed.estimate</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Confint")</code>: shows a detailed view
of the object; slots <code>nuisance.estimate</code> and
<code>fixed.estimate</code> are only shown if non-null,
and slot <code>trafo.estimate</code> only if different from a unit matrix.</p>
</dd>
<dt>print</dt><dd><p><code>signature(object = "Confint")</code>: just as <code>show</code>, 
but with additional arguments <code>digits</code>.</p>
</dd>
</dl>



<h3>Details for methods 'show', 'print'</h3>

<p>Detailedness of output by methods <code>show</code>, <code>print</code> is controlled
by the global option <code>show.details</code> to be set by 
<code><a href="#topic+distrModoptions">distrModoptions</a></code>.
</p>
<p>As method <code>show</code> is used when inspecting an object by typing the object's 
name into the console, <code>show</code> comes without extra arguments and hence 
detailedness must be controlled  by global options. 
</p>
<p>Method <code>print</code> may be called with a (partially matched) argument
<code>show.details</code>, and then the global option is temporarily set to this
value.
</p>
<p>More specifically, when <code>show.detail</code> is matched to <code>"minimal"</code>
you will be shown only the type of the confidence interval(s) and its/their 
values. When <code>show.detail</code> is matched to <code>"medium"</code>, you will in
addition see the type of the estimator(s) for which it is produced,
the corresponding call of the estimater, its sample size, and, if present, the 
value of the corresponding nuisance parameter. 
Finally, when <code>show.detail</code> is matched to <code>"maximal"</code>, additionally 
you will be shown the fixed part of the parameter (if present) and 
the transformation of the estimator (if non-trivial, i.e. the 
identity) in form of its function code respectively of its derivative matrix.
</p>


<h3>Note</h3>

<p>The pretty-printing code for methods <code>show</code> and <code>print</code> 
has been borrowed from <code>confint.default</code> in package <span class="pkg">stats</span>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimator">Estimator</a></code>, <code><a href="#topic+confint">confint</a></code>, <code><a href="#topic+Estimate-class">Estimate-class</a></code>,
<code><a href="#topic+trafo-methods">trafo-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## some transformation
mtrafo &lt;- function(x){
     nms0 &lt;- c("scale","shape")
     nms &lt;- c("shape","rate")
     fval0 &lt;- c(x[2], 1/x[1])
     names(fval0) &lt;- nms
     mat0 &lt;- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
                     dimnames = list(nms,nms0))                          
     list(fval = fval0, mat = mat0)}

x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2, trafo = mtrafo)
## MLE
res &lt;- MLEstimator(x = x, ParamFamily = G)
ci &lt;- confint(res)
print(ci, digits = 4, show.details="maximal")
print(ci, digits = 4, show.details="medium")
print(ci, digits = 4, show.details="minimal")
</code></pre>

<hr>
<h2 id='confint-methods'> Methods for function confint in Package &lsquo;distrMod&rsquo; </h2><span id='topic+confint-methods'></span><span id='topic+confint'></span><span id='topic+confint+2CANY+2Cmissing-method'></span><span id='topic+confint+2CEstimate+2Cmissing-method'></span><span id='topic+confint+2Cmle+2Cmissing-method'></span><span id='topic+confint+2Cprofile.mle+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function <code>confint</code> in package <span class="pkg">distrMod</span>;
by default uses <code><a href="stats.html#topic+confint">confint</a></code> and its corresponding
S3-methods, but also computes
(asymptotic) confidence intervals for objects of class <code>Estimate</code>.
Computes confidence intervals for one or more parameters in a fitted
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint(object, method, ...)
## S4 method for signature 'ANY,missing'
confint(object, method, parm, level = 0.95, ...)
## S4 method for signature 'Estimate,missing'
confint(object, method, level = 0.95)
## S4 method for signature 'mle,missing'
confint(object, method, parm, level = 0.95, ...)
## S4 method for signature 'profile.mle,missing'
confint(object, method, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint-methods_+3A_object">object</code></td>
<td>
<p>in default / signature <code>ANY</code> case: a fitted model object,
in signature <code>Estimate</code> case, an object of class <code>Estimate</code></p>
</td></tr>
<tr><td><code id="confint-methods_+3A_parm">parm</code></td>
<td>
<p>only used in default / signature <code>ANY</code> case: 
a specification of which parameters are to be given
confidence intervals, either a vector of numbers or a vector of
names.  If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_method">method</code></td>
<td>
<p>not yet used (only as <code>missing</code>; later to allow
for various methods</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint</code> is a generic function.  Its behavior differs according to
its arguments.
</p>

<dl>
<dt>signature <code>ANY,missing</code>:</dt><dd><p>the default method;
uses the S3 generic of package <span class="pkg">stats</span>,
see <code><a href="stats.html#topic+confint">confint</a></code>;
its return value is a matrix (or vector) with columns giving lower and upper confidence
limits for each parameter. These will be labelled as (1-level)/2 and
1 - (1-level)/2 in % (by default 2.5% and 97.5%).</p>
</dd>
<dt>signature <code>Estimate,missing</code>:</dt><dd> 
<p>will return an object of class <code>Confint</code> which corresponds to a 
confidence interval assuming
asymptotic normality, and hence needs suitably filled slot <code>asvar</code>
in argument <code>object</code>. Besides the actual bounds, organized in 
an array just as in the S3 generic, the return value also captures 
the name of the estimator for which it is produced, as well as the corresponding
call producing the estimator, and the corresponding 
<code>trafo</code> and <code>nuisance</code> slots/parts.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>,
<code><a href="MASS.html#topic+confint">confint.glm</a></code> and <code><a href="MASS.html#topic+confint">confint.nls</a></code> in
package <span class="pkg">MASS</span>, <code><a href="#topic+Confint-class">Confint-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for signature ANY examples confer stats::confint
## (empirical) Data
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

## Maximum likelihood estimator
res &lt;- MLEstimator(x = x, ParamFamily = G)
confint(res)

### for comparison:
require(MASS)
(res1 &lt;- fitdistr(x, "gamma"))
## add a convenient (albeit wrong)
## S3-method for vcov:
## --- wrong as in general cov-matrix
##     will not be diagonal
## but for conf-interval this does
## not matter...
vcov.fitdistr &lt;- function(object, ...){
     v&lt;-diag(object$sd^2)
     rownames(v) &lt;- colnames(v) &lt;- names(object$estimate) 
     v}

## explicitely transforming to
## MASS parametrization:
mtrafo &lt;- function(x){
     nms0 &lt;- names(c(main(param(G)),nuisance(param(G))))
     nms &lt;- c("shape","rate")
     fval0 &lt;- c(x[2], 1/x[1])
     names(fval0) &lt;- nms
     mat0 &lt;- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
                     dimnames = list(nms,nms0))                          
     list(fval = fval0, mat = mat0)}

G2 &lt;- G
trafo(G2) &lt;- mtrafo
res2 &lt;- MLEstimator(x = x, ParamFamily = G2)

old&lt;-getdistrModOption("show.details")
distrModoptions("show.details" = "minimal")
res
res1
res2
confint(res)
confint(res1)
confint(res2)
confint(res,level=0.99)
distrModoptions("show.details" = old)
 
</code></pre>

<hr>
<h2 id='distrModMASK'>Masking of/by other functions in package &quot;distrMod&quot;</h2><span id='topic+distrModMASK'></span><span id='topic+MASKING'></span>

<h3>Description</h3>

<p>Provides information on the (intended) masking of
and (non-intended) masking by other other functions in package <span class="pkg">distrMod</span></p>


<h3>Usage</h3>

<pre><code class='language-R'>distrModMASK(library = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distrModMASK_+3A_library">library</code></td>
<td>
<p>a character vector with path names of R libraries, or <code>NULL</code>.
The default value of <code>NULL</code> corresponds to all libraries
currently known.  If the default is used, the loaded packages
are searched before the libraries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
distrModMASK()
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='distrModOptions'>Function to change the global variables of the package &lsquo;distrMod&rsquo; </h2><span id='topic+distrModOptions'></span><span id='topic+getdistrModOption'></span><span id='topic+distrModoptions'></span><span id='topic+show.details'></span>

<h3>Description</h3>

<p>With <code>distrModOptions</code> you can inspect and change 
the global variables of the package <span class="pkg">distrMod</span>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>distrModOptions(...)
getdistrModOption(x)
distrModoptions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distrModOptions_+3A_...">...</code></td>
<td>
<p> any options can be defined, using name = value or by passing a 
list of such tagged values. </p>
</td></tr>
<tr><td><code id="distrModOptions_+3A_x">x</code></td>
<td>
<p> a character string holding an option name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invoking <code>distrModoptions()</code> with no arguments returns a list 
with the current values of the options.  To access the value of a single 
option, one should use <code>getdistrModOption("show.details")</code>, 
e.g., rather than <code>distrModoptions("show.details")</code> which is 
a <em>list</em> of length one.</p>


<h3>Value</h3>

<p><code>distrModoptions()</code> returns a list of the global options of 
<span class="pkg">distrMod</span>. <br />
<code>distrModoptions("show.details")</code> returns  the global option 
<code>show.details</code> as a list of length 1. <br />
<code>distrModoptions("show.details" = "minimal")</code> sets the value of the 
global option  <code>show.details</code> to <code>"minimal"</code>. 
<code>getdistrModOption("show.details")</code> the current value set for 
option <code>show.details</code>. 
</p>


<h3>distrModoptions</h3>

<p>For compatibility with spelling in package <span class="pkg">distr</span>, <code>distrModoptions</code> is 
just a synonym to <code>distrModoptions</code>.
</p>


<h3>Currently available options</h3>


<dl>
<dt>show.details</dt><dd><p>degree of detailedness for method <code>show</code> for
objects of classes of the <span class="pkg">distrXXX</span> family of packages. Possible
values are
</p>

<dl>
<dt><code>"maximal"</code></dt><dd><p>all information is shown</p>
</dd>
<dt><code>"minimal"</code></dt><dd><p>only the most important information is shown</p>
</dd>
<dt><code>"medium"</code></dt><dd><p>somewhere in the middle; see actual <code>show</code>-methods
for details.</p>
</dd>
</dl>

<p>The default value is <code>"maximal"</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+options">getOption</a></code>,
<code><a href="distr.html#topic+distroptions">distroptions</a></code>, <code><a href="distr.html#topic+distroptions">getdistrOption</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>distrModoptions()
distrModoptions("show.details")
distrModoptions("show.details" = "maximal")
distrModOptions("show.details" = "minimal")
# or
getdistrModOption("show.details")
</code></pre>

<hr>
<h2 id='Estimate-class'>Estimate-class.</h2><span id='topic+Estimate-class'></span><span id='topic+name+2CEstimate-method'></span><span id='topic+name+3C-+2CEstimate-method'></span><span id='topic+estimate'></span><span id='topic+estimate+2CEstimate-method'></span><span id='topic+estimate.call'></span><span id='topic+estimate.call+2CEstimate-method'></span><span id='topic+Infos'></span><span id='topic+Infos+2CEstimate-method'></span><span id='topic+samplesize'></span><span id='topic+samplesize+2CEstimate-method'></span><span id='topic+completecases'></span><span id='topic+completecases+2CEstimate-method'></span><span id='topic+asvar'></span><span id='topic+asvar+2CEstimate-method'></span><span id='topic+fixed+2CEstimate-method'></span><span id='topic+asvar+3C-'></span><span id='topic+asvar+3C-+2CEstimate-method'></span><span id='topic+nuisance+2CEstimate-method'></span><span id='topic+main+2CEstimate-method'></span><span id='topic+Infos+3C-'></span><span id='topic+Infos+3C-+2CEstimate-method'></span><span id='topic+addInfo+3C-'></span><span id='topic+addInfo+3C-+2CEstimate-method'></span><span id='topic+show+2CEstimate-method'></span><span id='topic+print+2CEstimate-method'></span><span id='topic+untransformed.estimate'></span><span id='topic+untransformed.estimate+2CEstimate-method'></span><span id='topic+untransformed.asvar'></span><span id='topic+untransformed.asvar+2CEstimate-method'></span>

<h3>Description</h3>

<p>Class of estimates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Estimate", ...)</code>.
More frequently they are created via the generating function 
<code>Estimator</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. </p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate.</p>
</dd>
<dt><code>estimate.call</code></dt><dd><p>Object of class <code>"call"</code>:
call by which estimate was produced.</p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the estimator. </p>
</dd>
<dt><code>samplesize</code></dt><dd><p> object of class <code>"numeric"</code> &mdash;
the samplesize (only complete cases are counted)
at which the estimate was evaluated. </p>
</dd>
<dt><code>completecases</code></dt><dd><p> object of class <code>"logical"</code> &mdash;
complete cases at which the estimate was evaluated. </p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
indices of <code>estimate</code> belonging to the nuisance part. </p>
</dd>
<dt><code>fixed</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
the fixed and known part of the parameter. </p>
</dd>
<dt><code>trafo</code></dt><dd><p> object of class <code>"list"</code>: 
a list with components <code>fct</code> and <code>mat</code> (see below). </p>
</dd>
<dt><code>untransformed.estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
untransformed estimate. </p>
</dd>
<dt><code>untransformed.asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the untransformed 
estimator. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "Estimate")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
<dt>estimate</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>estimate</code>. </p>
</dd>
<dt>untransformed.estimate</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>untransformed.estimate</code>. </p>
</dd>
<dt>estimate.call</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>estimate.call</code>. </p>
</dd>
<dt>samplesize</dt><dd><p><code>signature(object = "Estimate")</code>:
(with additional argument <code>onlycompletecases</code>
defaulting to <code>TRUE</code> returns the sample size;
in case there are any incomplete cases and argument
<code>onlycompletecases</code> is <code>FALSE</code>, the number of
these is added to slot <code>samplesize</code>. </p>
</dd>
<dt>completecases</dt><dd><p><code>signature(object = "Estimate")</code>:
accessor function for slot <code>completecases</code>. </p>
</dd>
<dt>asvar</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>asvar</code>. </p>
</dd>
<dt>asvar&lt;-</dt><dd><p><code>signature(object = "Estimate")</code>: 
replacement function for slot <code>asvar</code>. </p>
</dd>
<dt>untransformed.asvar</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>untransformed.asvar</code>. </p>
</dd>
<dt>nuisance</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for <code>nuisance</code> part of slot <code>estimate</code>. </p>
</dd>
<dt>main</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for <code>main</code> part of slot <code>estimate</code>. </p>
</dd>
<dt>fixed</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>fixed</code>. </p>
</dd>
<dt>Infos</dt><dd><p><code>signature(object = "Estimate")</code>: 
accessor function for slot <code>Infos</code>. </p>
</dd>
<dt>Infos&lt;-</dt><dd><p><code>signature(object = "Estimate")</code>: 
replacement function for slot <code>Infos</code>. </p>
</dd>
<dt>addInfo&lt;-</dt><dd><p><code>signature(object = "Estimate")</code>: 
function to add an information to slot <code>Infos</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Estimate")</code></p>
</dd>
<dt>print</dt><dd><p><code>signature(object = "Estimate")</code>: just as <code>show</code>, 
but with additional arguments <code>digits</code>.</p>
</dd>
</dl>



<h3>Details for methods 'show', 'print'</h3>

<p>Detailedness of output by methods <code>show</code>, <code>print</code> is controlled
by the global option <code>show.details</code> to be set by 
<code><a href="#topic+distrModoptions">distrModoptions</a></code>.
</p>
<p>As method <code>show</code> is used when inspecting an object by typing the object's 
name into the console, <code>show</code> comes without extra arguments and hence 
detailedness must be controlled  by global options. 
</p>
<p>Method <code>print</code> may be called with a (partially matched) argument
<code>show.details</code>, and then the global option is temporarily set to this
value.
</p>
<p>More specifically, when <code>show.detail</code> is matched to <code>"minimal"</code>
you will be shown only the name/type of the estimator, the value of its main
part, and, if present, the corresponding standard errors, as well as, 
also if present, the value of the nuisance part. 
When <code>show.detail</code> is matched to <code>"medium"</code>, you will in
addition see the class of the estimator, its call and its sample-size
and, if present, the fixed part of the parameter and 
the asymptotic covariance matrix. Also the information
gathered in the <code>Infos</code> slot is shown.
Finally, when <code>show.detail</code> is matched to <code>"maximal"</code>, 
and if, in addition, you estimate non-trivial (i.e. not the identity)
transformation of the parameter of the parametric family, you will also be 
shown this transformation in form of its function and its derivative matrix
at the estimated parameter value, as well as the estimator (with standard errors,
if present) and (again, if present) the corresponding asymptotic covariance
of the untransformed, total (i.e. main and nuisance part) parameter.
</p>
<p><code>trafo</code> realizes partial influence curves; i.e.; we are only
interested is some possibly lower dimensional smooth (not necessarily
linear or even coordinate-wise) aspect/transformation <code class="reqn">\tau</code>
of the parameter <code class="reqn">\theta</code>.
</p>
<p>To be coherent with the corresponding <em>nuisance</em>
implementation, we make the following convention:
</p>
<p>The full parameter <code class="reqn">\theta</code> is split up coordinate-wise
in a main parameter <code class="reqn">\theta'</code> and a nuisance parameter
<code class="reqn">\theta''</code> (which is unknown, too, hence has to be
estimated, but only is of secondary interest) and a fixed,
known part <code class="reqn">\theta'''</code>.
</p>
<p>Without loss of generality, we restrict ourselves to the case that
transformation <code class="reqn">\tau</code> only acts on the main parameter
<code class="reqn">\theta'</code> &mdash; if we want to transform the whole
parameter, we only have to assume that both nuisance parameter
<code class="reqn">\theta''</code> and fixed, known part of the parameter
<code class="reqn">\theta'''</code> have length 0.
</p>
<p>To the implementation:
</p>
<p>Slot <code>trafo</code> can either contain a (constant) matrix
<code class="reqn">D_\theta</code> or a function
</p>
<p style="text-align: center;"><code class="reqn">\tau\colon \Theta' \to \tilde \Theta,\qquad \theta \mapsto \tau(\theta)</code>
</p>
 
<p>mapping main parameter
<code class="reqn">\theta'</code> to some range <code class="reqn">\tilde \Theta</code>.
</p>
<p>If <em>slot value</em> <code>trafo</code> is a function, besides <code class="reqn">\tau(\theta)</code>, 
it will also return the corresponding derivative matrix
<code class="reqn">\frac{\partial}{\partial \theta}\tau(\theta)</code>.
More specifically, the return value of this function <code>theta</code> is a
list with entries <code>fval</code>, the function value <code class="reqn">\tau(\theta)</code>,
and <code>mat</code>, the derivative matrix.
</p>
<p>In case <code>trafo</code> is a matrix <code class="reqn">D</code>, we interpret it as such a derivative
matrix <code class="reqn">\frac{\partial}{\partial \theta}\tau(\theta)</code>,
and, correspondingly, <code class="reqn">\tau(\theta)</code> as the linear mapping
<code class="reqn">\tau(\theta)=D\,\theta</code>.<br />
</p>


<h3>Note</h3>

<p>The pretty-printing code for methods <code>show</code> and <code>print</code> 
has been borrowed from <code>print.fitdistr</code> in package <span class="pkg">MASS</span> by B.D. Ripley.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimator">Estimator</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
Estimator(x, estimator = mean, name = "mean")

x1 &lt;- x; x1[sample(1:100,10)] &lt;- NA
myEst1 &lt;- Estimator(x1, estimator = mean, name = "mean")
samplesize(myEst1)
samplesize(myEst1, onlycomplete = FALSE)
</code></pre>

<hr>
<h2 id='Estimator'> Function to compute estimates </h2><span id='topic+Estimator'></span>

<h3>Description</h3>

<p>The function <code>Estimator</code> provides a general way to compute 
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estimator(x, estimator, name, Infos, asvar = NULL, nuis.idx,
          trafo = NULL, fixed = NULL, asvar.fct, na.rm = TRUE, ...,
          ParamFamily = NULL, .withEvalAsVar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Estimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="Estimator_+3A_estimator">estimator</code></td>
<td>
<p> function: estimator to be evaluated on <code>x</code>. </p>
</td></tr>
<tr><td><code id="Estimator_+3A_name">name</code></td>
<td>
<p> optional name for estimator. </p>
</td></tr>
<tr><td><code id="Estimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="Estimator_+3A_asvar">asvar</code></td>
<td>
<p> optionally the asymptotic (co)variance of the estimator </p>
</td></tr>
<tr><td><code id="Estimator_+3A_nuis.idx">nuis.idx</code></td>
<td>
<p> optionally the indices of the estimate belonging 
to nuisance parameter</p>
</td></tr>
<tr><td><code id="Estimator_+3A_fixed">fixed</code></td>
<td>
<p> optionally (numeric) the fixed part of the parameter</p>
</td></tr>
<tr><td><code id="Estimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="Estimator_+3A_asvar.fct">asvar.fct</code></td>
<td>
<p>optionally: a function to determine the corresponding
asymptotic variance; if given, <code>asvar.fct</code> takes arguments
<code>L2Fam</code>(the parametric model as object of class <code>L2ParamFamily</code>)
and <code>param</code> (the parameter value as object of class 
<code>ParamFamParameter</code>); arguments are called by name; <code>asvar.fct</code>
may also process further arguments passed through the <code>...</code> argument. </p>
</td></tr>
<tr><td><code id="Estimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="Estimator_+3A_...">...</code></td>
<td>
<p> further arguments to <code>estimator</code>.</p>
</td></tr>
<tr><td><code id="Estimator_+3A_paramfamily">ParamFamily</code></td>
<td>
<p>an optional object of class <code>ParamFamily</code>. Passed on
to <code>asvar.fct</code> to compute asymptotic variances.</p>
</td></tr>
<tr><td><code id="Estimator_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical: shall slot <code>asVar</code> be evaluated
(if <code>asvar.fct</code> is given) or
just the call be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>criterion</code> has to be a function with arguments the 
empirical data as well as an object of class <code>"Distribution"</code> 
and possibly <code>...</code>.
</p>


<h3>Value</h3>

<p>An object of S4-class <code>"Estimate"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimate-class">Estimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
Estimator(x, estimator = mean, name = "mean")

X &lt;- matrix(rnorm(1000), nrow = 10)
Estimator(X, estimator = rowMeans, name = "mean")
</code></pre>

<hr>
<h2 id='EvenSymmetric'>Generating function for EvenSymmetric-class</h2><span id='topic+EvenSymmetric'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"EvenSymmetric"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvenSymmetric(SymmCenter = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EvenSymmetric_+3A_symmcenter">SymmCenter</code></td>
<td>
<p> numeric: center of symmetry </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"EvenSymmetric"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EvenSymmetric-class">EvenSymmetric-class</a></code>, <code><a href="#topic+FunctionSymmetry-class">FunctionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>EvenSymmetric()

## The function is currently defined as
function(SymmCenter = 0){ 
    new("EvenSymmetric", SymmCenter = SymmCenter) 
}
</code></pre>

<hr>
<h2 id='EvenSymmetric-class'>Class for Even Functions</h2><span id='topic+EvenSymmetric-class'></span>

<h3>Description</h3>

<p>Class for even functions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("EvenSymmetric")</code>.
More frequently they are created via the generating function 
<code>EvenSymmetric</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
contains &ldquo;even function&rdquo; </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"numeric"</code>:
center of symmetry </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"FunctionSymmetry"</code>, directly.<br />
Class <code>"Symmetry"</code>, by class <code>"FunctionSymmetry"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+EvenSymmetric">EvenSymmetric</a></code>, <code><a href="#topic+FunctionSymmetry-class">FunctionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("EvenSymmetric")
</code></pre>

<hr>
<h2 id='existsPIC-methods'> Methods for Function existsPIC in Package &lsquo;distrMod&rsquo;</h2><span id='topic+existsPIC-methods'></span><span id='topic+existsPIC'></span><span id='topic+existsPIC+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>existsPIC-methods to check whether in a given L2 differentiable model at parameter value theta there exist
(partial) influence curves to Trafo <code class="reqn">D_\theta</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>existsPIC(object, ...)
## S4 method for signature 'L2ParamFamily'
existsPIC(object, warning = TRUE, tol = .Machine$double.eps^.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="existsPIC-methods_+3A_object">object</code></td>
<td>
<p>L2ParamFamily</p>
</td></tr>
<tr><td><code id="existsPIC-methods_+3A_...">...</code></td>
<td>
<p>further arguments used by specific methods.</p>
</td></tr>
<tr><td><code id="existsPIC-methods_+3A_warning">warning</code></td>
<td>
<p>logical: should a warning be issued if there exist no (partial) influence curves?</p>
</td></tr>
<tr><td><code id="existsPIC-methods_+3A_tol">tol</code></td>
<td>
<p> the tolerance the linear algebraic operations.  Default is <code>.Machine$double.eps^.5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To check the existence of (partial) influence curves and, simultaneously, for bounded
(partial) influence curves, by Lemma 1.1.3 in Kohl(2005) [resp. the fact that <code class="reqn">{\rm ker} I={\rm ker} J</code>
for <code class="reqn">J= {\rm E} (\Lambda',1)' (\Lambda',1) w</code> and
<code class="reqn">w={\rm min}(1, b/|(\Lambda',1)|</code>], it suffices to check that
<code class="reqn">{\rm ker }I</code> is a subset of <code class="reqn">{\rm ker }D_\theta</code>. This is done by
a call to <code>isKerAinKerB</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isKerAinKerB">isKerAinKerB</a></code></p>

<hr>
<h2 id='ExpScaleFamily'>Generating function for exponential scale families</h2><span id='topic+ExpScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ScaleFamily"</code> which
represents an exponential scale family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpScaleFamily(scale = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpScaleFamily_+3A_scale">scale</code></td>
<td>
<p> scale (= 1/rate) </p>
</td></tr>
<tr><td><code id="ExpScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: optional transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled. The scale parameter corresponds
to <code class="reqn">1/\code{rate}</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Exp-class">Exp-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(E1 &lt;- ExpScaleFamily())
plot(E1)
Map(L2deriv(E1)[[1]])
## IGNORE_RDIFF_BEGIN
checkL2deriv(E1)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='fiBias'>Generating function for fiBias-class</h2><span id='topic+fiBias'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"fiBias"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiBias()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"fiBias"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiBias-class">fiBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fiBias()

## The function is currently defined as
function(){ new("fiBias") }
</code></pre>

<hr>
<h2 id='fiBias-class'>Finite-sample Bias</h2><span id='topic+fiBias-class'></span>

<h3>Description</h3>

<p>Class of finite-sample bias.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fiBias", ...)</code>.
More frequently they are created via the generating function 
<code>fiBias</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;finite-sample bias&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fiRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"fiRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;fiBias&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiRisk-class">fiRisk-class</a></code>, <code><a href="#topic+fiBias">fiBias</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("fiBias")
</code></pre>

<hr>
<h2 id='fiCov'>Generating function for fiCov-class</h2><span id='topic+fiCov'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"fiCov"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiCov()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"fiCov"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiCov-class">fiCov-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fiCov()

## The function is currently defined as
function(){ new("fiCov") }
</code></pre>

<hr>
<h2 id='fiCov-class'>Finite-sample covariance</h2><span id='topic+fiCov-class'></span>

<h3>Description</h3>

<p>Class of finite-sample covariance.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fiCov", ...)</code>.
More frequently they are created via the generating function 
<code>fiCov</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;finite-sample covariance&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fiRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"fiRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;fiCov&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiRisk-class">fiRisk-class</a></code>, <code><a href="#topic+fiCov">fiCov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("fiCov")
</code></pre>

<hr>
<h2 id='fiHampel'>Generating function for fiHampel-class</h2><span id='topic+fiHampel'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"fiHampel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiHampel(bound = Inf)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fiHampel_+3A_bound">bound</code></td>
<td>
<p> positive real: bias bound </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>fiHampel</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiHampel-class">fiHampel-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fiHampel()

## The function is currently defined as
function(bound = Inf){ new("fiHampel", bound = bound) }
</code></pre>

<hr>
<h2 id='fiHampel-class'>Finite-sample Hampel risk</h2><span id='topic+fiHampel-class'></span><span id='topic+bound+2CfiHampel-method'></span><span id='topic+show+2CfiHampel-method'></span>

<h3>Description</h3>

<p>Class of finite-sample Hampel risk which is
the trace of the finite-sample covariance subject to
a given bias bound (bound on gross error sensitivity). </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fiHampel", ...)</code>.
More frequently they are created via the generating function 
<code>fiHampel</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;trace of finite-sample covariance for given bias bound&rdquo;. </p>
</dd>
<dt><code>bound</code></dt><dd><p>Object of class <code>"numeric"</code>: 
given positive bias bound. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fiRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"fiRisk"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>bound</dt><dd><p><code>signature(object = "fiHampel")</code>: 
accessor function for slot <code>bound</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "fiHampel")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiRisk-class">fiRisk-class</a></code>, <code><a href="#topic+fiHampel">fiHampel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("fiHampel")
</code></pre>

<hr>
<h2 id='fiMSE'>Generating function for fiMSE-class</h2><span id='topic+fiMSE'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"fiMSE"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiMSE()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"fiMSE"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiMSE-class">fiMSE-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fiMSE()

## The function is currently defined as
function(){ new("fiMSE") }
</code></pre>

<hr>
<h2 id='fiMSE-class'>Finite-sample mean square error</h2><span id='topic+fiMSE-class'></span>

<h3>Description</h3>

<p>Class of asymptotic mean square error.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fiMSE", ...)</code>.
More frequently they are created via the generating function 
<code>fiMSE</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;finite-sample mean square error&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fiRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"fiRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;fiMSE&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiRisk-class">fiRisk-class</a></code>, <code><a href="#topic+fiMSE">fiMSE</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("fiMSE")
</code></pre>

<hr>
<h2 id='fiRisk-class'>Finite-sample risk</h2><span id='topic+fiRisk-class'></span>

<h3>Description</h3>

<p>Class of finite-sample risks.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"RiskType"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;fiRisk&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RiskType-class">RiskType-class</a></code></p>

<hr>
<h2 id='fiUnOvShoot'>Generating function for fiUnOvShoot-class</h2><span id='topic+fiUnOvShoot'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"fiUnOvShoot"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiUnOvShoot(width = 1.960)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fiUnOvShoot_+3A_width">width</code></td>
<td>
<p> positive real: half the width of given confidence interval. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"fiUnOvShoot"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1989) A finite-sample minimax regression estimator. 
Statistics <b>20</b>(2): 211&ndash;221.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiUnOvShoot-class">fiUnOvShoot-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fiUnOvShoot()

## The function is currently defined as
function(width = 1.960){ new("fiUnOvShoot", width = width) }
</code></pre>

<hr>
<h2 id='fiUnOvShoot-class'>Finite-sample under-/overshoot probability</h2><span id='topic+fiUnOvShoot-class'></span><span id='topic+width+2CfiUnOvShoot-method'></span><span id='topic+show+2CfiUnOvShoot-method'></span>

<h3>Description</h3>

<p>Class of finite-sample under-/overshoot probability.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fiUnOvShoot", ...)</code>.
More frequently they are created via the generating function 
<code>fiUnOvShoot</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;finite-sample under-/overshoot probability&rdquo;. </p>
</dd>
<dt><code>width</code></dt><dd><p>Object of class <code>"numeric"</code>: 
half the width of given confidence interval. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fiRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"fiRisk"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>width</dt><dd><p><code>signature(object = "fiUnOvShoot")</code>: 
accessor function for slot <code>width</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "fiUnOvShoot")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1989) A finite-sample minimax regression estimator. 
Statistics <b>20</b>(2): 211&ndash;221.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) Computation of the Finite Sample Risk 
of M-estimators on Neighborhoods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiRisk-class">fiRisk-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("fiUnOvShoot")
</code></pre>

<hr>
<h2 id='FunctionSymmetry-class'>Class of Symmetries for Functions</h2><span id='topic+FunctionSymmetry-class'></span>

<h3>Description</h3>

<p>Class of symmetries for functions.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
discribes type of symmetry. </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"OptionalNumeric"</code>:
center of symmetry. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Symmetry"</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Symmetry-class">Symmetry-class</a></code>, <code><a href="distr.html#topic+internalClassUnions-class">OptionalNumeric-class</a></code></p>

<hr>
<h2 id='FunSymmList'>Generating function for FunSymmList-class</h2><span id='topic+FunSymmList'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"FunSymmList"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FunSymmList(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FunSymmList_+3A_...">...</code></td>
<td>
<p> Objects of class <code>"FunctionSymmetry"</code> which
shall form the list of symmetry types. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> Object of class <code>"FunSymmList"</code> </p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FunSymmList-class">FunSymmList-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>FunSymmList(NonSymmetric(), EvenSymmetric(SymmCenter = 1), 
            OddSymmetric(SymmCenter = 2))

## The function is currently defined as
function (...){
    new("FunSymmList", list(...))
}
</code></pre>

<hr>
<h2 id='FunSymmList-class'>List of Symmetries for a List of Functions</h2><span id='topic+FunSymmList-class'></span>

<h3>Description</h3>

<p>Create a list of symmetries for a list of functions</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FunSymmList", ...)</code>.
More frequently they are created via the generating function 
<code>FunSymmList</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p> Object of class <code>"list"</code>. A list 
of objects of class <code>"FunctionSymmetry"</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"list"</code>, from data part.<br />
Class <code>"vector"</code>, by class <code>"list"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FunctionSymmetry-class">FunctionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("FunSymmList", list(NonSymmetric(), EvenSymmetric(SymmCenter = 1), 
                        OddSymmetric(SymmCenter = 2)))
</code></pre>

<hr>
<h2 id='GammaFamily'>Generating function for Gamma families</h2><span id='topic+GammaFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ParamFamily"</code> which
represents a Gamma family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GammaFamily(scale = 1, shape = 1, trafo, withL2derivDistr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GammaFamily_+3A_scale">scale</code></td>
<td>
<p> positive real: scale parameter </p>
</td></tr>
<tr><td><code id="GammaFamily_+3A_shape">shape</code></td>
<td>
<p> positive real: shape parameter </p>
</td></tr>
<tr><td><code id="GammaFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter </p>
</td></tr>
<tr><td><code id="GammaFamily_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>TRUE</code>; setting it to <code>FALSE</code>
speeds up computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Gammad-class">Gammad-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(G1 &lt;- GammaFamily())
FisherInfo(G1)
## IGNORE_RDIFF_BEGIN
checkL2deriv(G1)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='InfoNorm'>Generating function for InfoNorm-class</h2><span id='topic+InfoNorm'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"InfoNorm"</code> &mdash;
used for information-standardized influence curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InfoNorm()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"InfoNorm"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InfoNorm-class">InfoNorm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
InfoNorm()

## The function is currently defined as
function(){ new("InfoNorm") }
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='internal_mlehelpers_for_distrMod'>Internal helper functions for treating MCEstimators in package distrMod</h2><span id='topic+internal_mlehelpers_for_distrMod'></span><span id='topic+.negLoglikelihood'></span><span id='topic+.process.meCalcRes'></span><span id='topic+.samplesize'></span><span id='topic+.callParamFamParameter'></span>

<h3>Description</h3>

<p>These functions are used internally by functions <code>MCEstimator</code> and
<code>MLEstimator</code> in package &ldquo;distrMod&rdquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.negLoglikelihood(x, Distribution, ..., dropZeroDensity = TRUE)
.process.meCalcRes(res, PFam, trafo, res.name, call, asvar.fct, check.validity,
                   ..., toClass="", .withEvalAsVar = TRUE, x = NULL, nmsffx = "")
.callParamFamParameter(PFam, theta, idx, nuis, fixed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_x">x</code></td>
<td>
<p>numeric; the data at which to evaluate the negative log likelihood</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_distribution">Distribution</code></td>
<td>
<p>an object of class <code>Distribution</code>; 
the distribution at which to evaluate the negative log likelihood</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_...">...</code></td>
<td>
<p>in case of <code>.negLoglikelihood</code> simply to be able to use
the general calling for the criterion function;
in case of <code>.process.meCalcRes</code> further arguments to be passed 
to function <code>asvar.fct</code></p>
</td></tr> 
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_res">res</code></td>
<td>
<p>a list; the return value of <code>mleCalc</code> or <code>mceCalc</code></p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_pfam">PFam</code></td>
<td>
<p>an object of class <code>ParamFamily</code>; 
the parametric family at which to evaluate the MCE</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_trafo">trafo</code></td>
<td>
<p>the trafo matrix or a function returning it or <code>NULL</code></p>
</td></tr> 
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_res.name">res.name</code></td>
<td>
<p>the name of the corresponding estimator</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_call">call</code></td>
<td>
<p>the original call with which the estimate was produced</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_asvar.fct">asvar.fct</code></td>
<td>
<p>a function producing an asymptotic covariance matrix or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_check.validity">check.validity</code></td>
<td>
<p>logical: shall return parameter value be checked for
validity?</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_theta">theta</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_idx">idx</code></td>
<td>
<p>indices of the main part of the component</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_nuis">nuis</code></td>
<td>
<p>nuisance part of the parameter</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_fixed">fixed</code></td>
<td>
<p>fixed part of the parameter</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical: shall slot <code>asVar</code> be evaluated
(if <code>asvar.fct</code> is given) or
just the call be returned?</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_dropzerodensity">dropZeroDensity</code></td>
<td>
<p>logical of length 1; shall observations with
density zero be dropped? Optimizers like <code>optim</code> require finite
values, so get problems when negative loglikelihood is evaluated. </p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_nmsffx">nmsffx</code></td>
<td>
<p>character: a potential suffix to be appended to the estimator name.</p>
</td></tr>
<tr><td><code id="internal_mlehelpers_for_distrMod_+3A_toclass">toClass</code></td>
<td>
<p>character: if not <code>""</code> the name of a more specific return class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.negLoglikelihood</code> uses the <code>log</code> -argument of the corresponding <code>d</code>-slot
of the distribution if available; else produces <code>log(d(Distribution)(x))</code>.
</p>
<p><code>.process.meCalcRes</code> processes the resulting return value list of methods
<code>mceCalc</code> and <code>mleCalc</code> to give a corresponding object of
class <code>MCEstimate</code>. 
</p>
<p><code>.callParamFamParameter</code> determines by means of the family-slot
parameter whether this is of a subclass of <code>ParamFamParameter</code>,
and if so manipulates the call to generating function <code>ParamFamParameter</code>
accordingly (such that the result has the convenient type and the
convenient extra slots).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>negLoglikelihood</code></td>
<td>
<p>the (numeric) value of the negative log likelihood
evaluated at the data and the given distribution</p>
</td></tr>
<tr><td><code>.get.criterion.fct</code></td>
<td>
<p>a function as described in section &ldquo;details&rdquo;</p>
</td></tr>
<tr><td><code>.process.meCalcRes</code></td>
<td>
<p>an object of class <code>MCEstimate</code></p>
</td></tr>
<tr><td><code>.callParamFamParameter</code></td>
<td>
<p>an object of class <code>ParamFamParameter</code>
or if necessary a corresponding subclass.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCEstimate-class">MCEstimate-class</a></code>,
<code><a href="stats4.html#topic+mle-class">mle-class</a></code>,
</p>

<hr>
<h2 id='InternalClassUnions'>Class unions in 'distrMod'</h2><span id='topic+InternalClassUnions'></span><span id='topic+OptionalNumericOrMatrix-class'></span><span id='topic+OptionalNumericOrMatrixOrCall-class'></span><span id='topic+OptionalDistrListOrCall-class'></span><span id='topic+MatrixorFunction-class'></span><span id='topic+ShowDetails-class'></span><span id='topic+L2LocationScaleUnion-class'></span><span id='topic+L2ScaleShapeUnion-class'></span><span id='topic+locscalename'></span><span id='topic+locscalename+2CL2LocationScaleUnion-method'></span><span id='topic+locscalename+3C-'></span><span id='topic+locscalename+3C-+2CL2LocationScaleUnion-method'></span><span id='topic+scaleshapename'></span><span id='topic+scaleshapename+2CL2ScaleShapeUnion-method'></span><span id='topic+scaleshapename+3C-'></span><span id='topic+scaleshapename+3C-+2CL2ScaleShapeUnion-method'></span><span id='topic+scalename'></span><span id='topic+scalename+2CL2ScaleShapeUnion-method'></span><span id='topic+scalename+2CL2LocationScaleUnion-method'></span><span id='topic+withPosRestr+2CL2ScaleShapeUnion-method'></span><span id='topic+withPosRestr+3C-+2CL2ScaleShapeUnion-method'></span><span id='topic+L2ScaleUnion-class'></span>

<h3>Description</h3>

<p>Class unions in package <span class="pkg">distrMod</span> defined for internal 
purposes; these are <code>OptionalNumeric</code>, <code>OptionalMatrix</code>,
<code>MatrixorFunction</code>, <code>ShowDetails</code></p>


<h3>Details</h3>

<p>These classes are used internally to make available methods or to allow
slots of classes to be filled with varying types. In particular
</p>

<dl>
<dt><code>"OptionalNumericOrMatrix"</code></dt><dd><p>may contain objects of class
<code>"OptionalNumeric"</code> or <code>"matrix"</code>;</p>
</dd>
<dt><code>"OptionalNumericOrMatrixOrCall"</code></dt><dd><p>may contain objects of class
<code>"OptionalNumericOrMatrix"</code> or <code>"call"</code>; it is used e.g. for
slot <code>asvar</code> of class <code>"Estimate"</code>, as it may or may not be 
present or be a call; otherwise it has to be a number (numeric) or a matrix.</p>
</dd>
<dt><code>"OptionalDistrListOrCall"</code></dt><dd><p>may contain objects of class
<code>"DistrList"</code> or <code>"call"</code>; it is used e.g. for
slot <code>L2derivDistr</code> of class <code>"L2ParamFammily"</code>,
as it may or may not be present or be a call;
otherwise it has to be a list of distributions.</p>
</dd>
<dt><code>"MatrixorFunction"</code></dt><dd><p>may contain objects of class
<code>"OptionalFunction"</code> or <code>"matrix"</code>; it is used e.g. for 
slot <code>trafo</code> of class <code>"ParamFamParameter"</code>, as it may or may not be 
present and if it is present, it has to either be a function or a matrix,
see <code><a href="#topic+trafo-methods">trafo-methods</a></code>.</p>
</dd>
<dt><code>"ShowDetails"</code></dt><dd><p>may contain objects of class  
<code>"Estimate"</code>, <code>"MCEstimate"</code>, <code>"Confint"</code>, <code>"PosSemDefSymmMatrix"</code>
<code>"ParamFamily"</code>, or <code>"ParamFamParameter"</code>; used to provide 
sort of a &ldquo;<code>show</code> with extra arguments&rdquo;, in form of a common 
<code>print</code> method for these S4  classes, which essentially just 
temporarily sets the global options according to the optional arguments
<code>digits</code> and <code>show.details</code>, calls <code>show</code> and then re-sets
the options to their global settings.</p>
</dd>
<dt><code>"L2LocationScaleUnion"</code></dt><dd><p>is a proper, but virtual in-between class
between class <code>"L2GroupParamFamily"</code> and <code>"L2LocationFamily"</code>, 
<code>"L2ScaleFamily"</code>, and <code>"L2LocationScaleFamily"</code>;
in addition to class <code>"L2GroupParamFamily"</code> it has a slot
<code>locscalename</code> (with corresponding accessor and replacement method)
to capture the fact that location and scale 
parameter may carry names other than <code>"loc"</code> resp. <code>"scale"</code>;
used to provide a common class for (parts of) methods <code>modifyModel</code>
<code>locscalename</code> and <code>locscalename&lt;-</code>.</p>
</dd>
<dt><code>"L2ScaleShapeUnion"</code></dt><dd><p>is a proper, but virtual in-between class
between class <code>"L2GroupParamFamily"</code> and, e.g., <code>"GammaFamily"</code>,
<code>"GParetoFamily"</code>, and <code>"EVDFamily"</code> (the latter from
extension package <span class="pkg">RobExtremes</span>; it has a slot
<code>scaleshapename</code> (with corresponding accessor and replacement method)
to capture the fact that location and scale
parameter may carry names other than <code>"shape"</code> resp. <code>"scale"</code>;
used to provide a common class for (parts of) methods
<code>scaleshapename</code> and <code>scaleshapename&lt;-</code>. </p>
</dd>
<dt><code>"L2ScaleUnion"</code></dt><dd><p>is a class union between <code>"L2ScaleShapeUnion"</code>
and <code>"L2LocationScaleUnion"</code> to allow for specific general
scaling methods; to this end there is method <code>scalename</code>. </p>
</dd>
</dl>



<h3>Objects from the Class</h3>

<p>All of these classes are virtual: 
No objects may be created from them.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+BasicClasses">numeric-class</a></code>,
<code><a href="methods.html#topic+BasicClasses">matrix-class</a></code>,
<code><a href="methods.html#topic+BasicClasses">function-class</a></code>,
<code><a href="#topic+MCEstimate-class">MCEstimate-class</a></code>,
<code><a href="#topic+Estimate-class">Estimate-class</a></code>,
<code><a href="#topic+Confint-class">Confint-class</a></code>,
<code><a href="distr.html#topic+PosDefSymmMatrix-class">PosSemDefSymmMatrix-class</a></code>,
<code><a href="#topic+L2GroupParamFamily-class">L2GroupParamFamily-class</a></code>,
<code><a href="#topic+L2LocationFamily-class">L2LocationFamily-class</a></code>,
<code><a href="#topic+L2ScaleFamily-class">L2ScaleFamily-class</a></code>,
<code><a href="#topic+GammaFamily-class">GammaFamily-class</a></code>,
<code><a href="#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code>,
<code><a href="#topic+ParamFamParameter-class">ParamFamParameter-class</a></code>
<code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code>
</p>

<hr>
<h2 id='InternalReturnClasses-class'>Internal return classes for generating functions</h2><span id='topic+InternalReturnClasses-class'></span><span id='topic+BinomFamily-class'></span><span id='topic+PoisFamily-class'></span><span id='topic+NormLocationFamily-class'></span><span id='topic+NormScaleFamily-class'></span><span id='topic+ExpScaleFamily-class'></span><span id='topic+LnormScaleFamily-class'></span><span id='topic+GammaFamily-class'></span><span id='topic+GParetoFamily-class'></span><span id='topic+BetaFamily-class'></span><span id='topic+NormLocationScaleFamily-class'></span><span id='topic+CauchyLocationFamily-class'></span><span id='topic+CauchyLocationScaleFamily-class'></span><span id='topic+LogisticLocationScaleFamily-class'></span>

<h3>Description</h3>

<p>internal return classes for generating functions 'L2ParamFamily' and 
'L2LocationFamily' (and friends); used for particular method dispatch only</p>


<h3>Described classes</h3>

<p>In this file we describe classes 
<code>BinomFamily</code>, <code>PoisFamily</code>, <code>GammaFamily</code>,
<code>BetaFamily</code>, and class <code>GParetoFamily</code> &ldquo;extending&rdquo; (no new slots!)
class <code>L2ParamFamily</code> (the latter via <code>L2ScaleShapeUnion</code>),
class <code>NormLocationFamily</code>, class <code>CauchyLocationFamily</code>
&ldquo;extending&rdquo; (no new slots!) class <code>"L2LocationFamily"</code>, classes
<code>NormScaleFamily</code>, <code>ExpScaleFamily</code>, and <code>LnormScaleFamily</code> 
&ldquo;extending&rdquo; (no new slots!) class <code>"L2ScaleFamily"</code>, and classes
<code>CauchyLocationScaleFamily</code>, <code>LogisticLocationScaleFamily</code> and
<code>NormLocationScaleFamily</code>, &ldquo;extending&rdquo; (no new slots!)
class <code>"L2LocationScaleFamily"</code>.
</p>


<h3>Objects from these classes</h3>

<p>Objects are only generated internally by the mentioned generating functions. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code>:</dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code>:</dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code>:</dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code>:</dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code>:</dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code>:</dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code>:</dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code>:</dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>L2deriv</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"EuclRandVariable"</code>:
L2 derivative of the family. </p>
</dd>
<dt><code>L2deriv.fct</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: mapping from 
the parameter space (argument <code>param</code> of class 
<code>"ParamFamParameter"</code>) to a mapping from observation <code>x</code> to the  
value of the L2derivative; <code>L2deriv.fct</code> is then used from observation
<code>x</code> to value of the L2derivative; <code>L2deriv.fct</code> is used by 
<code>modifyModel</code> to  move the L2deriv according to a change in the 
parameter </p>
</dd>
<dt><code>L2derivSymm</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"FunSymmList"</code>:
symmetry of the maps included in <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistr</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"UnivarDistrList"</code>:
list which includes the distribution of <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistrSymm</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"DistrSymmList"</code>:
symmetry of the distributions included in <code>L2derivDistr</code>. </p>
</dd>
<dt><code>FisherInfo.fct</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: 
mapping from the parameter space (argument  <code>param</code> of class 
<code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</dd> 
<dt><code>FisherInfo</code>:</dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"PosDefSymmMatrix"</code>:
Fisher information of the family. </p>
</dd>
<dt><code>LogDeriv</code>:</dt><dd><p>(only loc/scale classes)[inherited from class <code>"L2GroupParamFamily"</code>]
object of class <code>"function"</code>: has argument <code>x</code>; 
the negative logarithmic derivative of the density of the model distribution at 
the &quot;standard&quot; parameter value. </p>
</dd>
<dt><code>locscalename</code>:</dt><dd><p>(only loc/scale classes)[inherited from class <code>"L2LocationScaleUnion"</code>]
object of class <code>"character"</code>: names of location and scale parameter. </p>
</dd>
<dt><code>scaleshapename</code>:</dt><dd><p>(only scale/shape classes)[inherited from class <code>"L2ScaleShapeUnion"</code>]
object of class <code>"character"</code>: names of location and scale parameter. </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Classes <code>BinomFamily</code>, <code>PoisFamily</code>, <code>GammaFamily</code>
<code>BetaFamily</code> &ldquo;extend&rdquo; (no new slots!):<br />
Class <code>"L2ParamFamily"</code>,  directly.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
<br />
Class <code>NormLocationFamily</code>, class <code>CauchyLocationFamily</code>
&ldquo;extend&rdquo; (no new slots!):<br />
Class <code>"L2LocationFamily"</code>, directly.<br />
Class <code>"L2LocationScaleUnion"</code>, by class <code>"L2LocationFamily"</code>.<br />
Class <code>"L2GroupParamFamily"</code>, by class <code>"L2LocationScaleUnion"</code>.<br />
Class <code>"L2ParamFamily"</code>,  directly.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
<br />
<code>NormScaleFamily</code>, <code>ExpScaleFamily</code>, and <code>LnormScaleFamily</code> 
&ldquo;extend&rdquo; (no new slots!):<br />
Class <code>"L2ScaleFamily"</code>, directly.<br />
Class <code>"L2LocationScaleUnion"</code>, by class <code>"L2ScaleFamily"</code>.<br />
Class <code>"L2GroupParamFamily"</code>, by class <code>"L2LocationScaleUnion"</code>.<br />
Class <code>"L2ParamFamily"</code>,  directly.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
<br />
<code>CauchyLocationScaleFamily</code>, <code>LogisticLocationScaleFamily</code>,
and <code>NormLocationScaleFamily</code>
&ldquo;extend&rdquo; (no new slots!):<br />
Class <code>"L2LocationScaleFamily"</code>, directly.<br />
Class <code>"L2LocationScaleUnion"</code>, by class <code>"L2LocationScaleFamily"</code>.<br />
Class <code>"L2GroupParamFamily"</code>, by class <code>"L2LocationScaleUnion"</code>.<br />
Class <code>"L2ParamFamily"</code>,  directly.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
</p>


<h3>Methods</h3>

<p>not yet done...
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+BasicClasses">numeric-class</a></code>,
<code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>,
<code><a href="#topic+L2GroupParamFamily-class">L2GroupParamFamily-class</a></code>,
<code><a href="#topic+L2LocationFamily-class">L2LocationFamily-class</a></code>,
<code><a href="#topic+L2ScaleFamily-class">L2ScaleFamily-class</a></code>,
<code><a href="#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code>,
</p>

<hr>
<h2 id='internals_for_distrMod'>Internal functions of package distrMod</h2><span id='topic+internals_for_distrMod'></span><span id='topic+.inArgs'></span><span id='topic+.isUnitMatrix'></span><span id='topic+.validTrafo'></span><span id='topic+.CvMMDCovariance'></span><span id='topic+.CvMMDCovarianceWithMux'></span><span id='topic+.oldCvMMDCovariance'></span><span id='topic+.show.with.sd'></span><span id='topic+.getLogDeriv'></span><span id='topic+.csimpsum'></span><span id='topic+.deleteDim'></span>

<h3>Description</h3>

<p>These functions are used internally by package &ldquo;distrMod&rdquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.inArgs(arg, fct)
.isUnitMatrix(m)
.csimpsum(fx)
.validTrafo(trafo, dimension, dimensionwithN)

.CvMMDCovariance(L2Fam, param, mu = distribution(L2Fam),
                 withplot = FALSE, withpreIC = FALSE,
                 N = 1021, rel.tol=.Machine$double.eps^0.3,
                 TruncQuantile = getdistrOption("TruncQuantile"), 
                 IQR.fac = 15, ..., diagnostic = FALSE)
.oldCvMMDCovariance(L2Fam, param, mu = distribution(L2Fam),
                 withplot = FALSE, withpreIC = FALSE,
                 N = getdistrOption("DefaultNrGridPoints")+1,
                 rel.tol=.Machine$double.eps^0.3,
                 TruncQuantile = getdistrOption("TruncQuantile"),
                 IQR.fac = 15, ...)
.CvMMDCovarianceWithMux(L2Fam, param, withplot = FALSE, withpreIC = FALSE,
                        N = 1021, rel.tol=.Machine$double.eps^0.3,
                        TruncQuantile = getdistrOption("TruncQuantile"),
                        IQR.fac = 15, ..., x=NULL)

.show.with.sd(est, s)
.getLogDeriv(distr, 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
                         IQR.fac = getdistrExOption("IQR.fac"))
.deleteDim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internals_for_distrMod_+3A_arg">arg</code></td>
<td>
<p>a formal argument as character</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_fct">fct</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr> 
<tr><td><code id="internals_for_distrMod_+3A_est">est</code></td>
<td>
<p>an estimator; usually a vector</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_s">s</code></td>
<td>
<p>a standard deviation</p>
</td></tr> 
<tr><td><code id="internals_for_distrMod_+3A_trafo">trafo</code></td>
<td>
<p>an object of class <code>MatrixorFunction</code></p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_dimension">dimension</code></td>
<td>
<p>a numeric &mdash; length of main part of the parameter</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_dimensionwithn">dimensionwithN</code></td>
<td>
<p>a numeric &mdash; length of main and nuisance part of the parameter</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_l2fam">L2Fam</code></td>
<td>
<p>an object of class <code>L2ParamFamily</code> &mdash; for
which we want to determine the IC resp. the as. [co]variance of the corresponding
Minimum CvM estimator</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_param">param</code></td>
<td>
<p>an object of class <code>ParamFamParameter</code>, the parameter value
at which we want to determine the IC resp. the as. [co]variance of the corresponding
Minimum CvM estimator</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_mu">mu</code></td>
<td>
<p>an object of class <code>UnivariateDistribution</code>: integration 
measure (resp. distribution) for CvM distance</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td></tr> 
<tr><td><code id="internals_for_distrMod_+3A_truncquantile">TruncQuantile</code></td>
<td>
<p>quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_lowertruncquantile">lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_uppertruncquantile">upperTruncQuantile</code></td>
<td>
<p>upper quantile for quantile based integration range.</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_iqr.fac">IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_withplot">withplot</code></td>
<td>
<p>logical: shall we plot corresponding ICs?</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_withpreic">withpreIC</code></td>
<td>
<p>logical: shall we return a list with components <code>preIC</code> 
and <code>var</code> or just <code>var</code>; here <code>var</code> is the corresponding
asymptotic variance and <code>preIC</code> the corresponding
<code>EuclRandVarList</code> featuring as argument <code>Curve</code> in <code>IC</code>s of
package <span class="pkg">RobAStBase</span></p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_n">N</code></td>
<td>
<p>a numeric: the number of gridpoints for constructing the 
<code class="reqn">\mu</code>- resp. <code class="reqn">P_\theta</code>-&ldquo;primitive&rdquo;
function</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_fx">fx</code></td>
<td>
<p>a vector of function evaluations multiplied by the gridwidth</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_distr">distr</code></td>
<td>
<p>an object of class <code>AbscontDistribution</code></p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_...">...</code></td>
<td>
<p>further argument to be passed through &mdash; so 
<code>.CvMMDCovariance</code> can digest more arguments.</p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_x">x</code></td>
<td>
<p>in <code>deleteDim</code>: a possibly named vector, which may have a
<code>dim</code> attribute; in <code>.CvMMDCovarianceWithMux</code>: <code>NULL</code>
(default) or the vector with observations to build integration
measure <code class="reqn">mu</code> as the empirical cdf.  </p>
</td></tr>
<tr><td><code id="internals_for_distrMod_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value of <code>.CvMMDCovariance</code>
obtains an attribute <code>"diagnostic"</code> (usually a lengthy list)
with diagnostic information on the call and on the integration, the latter
inherited from the calls to <code>distrExIntegrate</code> and <code>E</code> in this function.
Depending on the actually used <code>E</code> method, this comprises entries
<code>method</code> (<code>"integrate"</code> or <code>"GLIntegrate"</code>),
<code>result</code> (the complete return value of the integration method),
<code>args</code> (the args with which the integration method was called),
and <code>time</code> (the time to compute the integral). </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.inArgs</code> (borrowed from package <span class="pkg">distr</span>)
checks whether an argument <code>arg</code> is a formal argument of 
<code>fct</code> &mdash; not vectorized.
</p>
<p><code>.csimpsum</code> (borrowed from package <span class="pkg">distr</span>) 
produces a primitimive function out of function evaluations by means 
of vectorized Simpson quadrature method, returning already the function values
of the prime function on a grid; it is to mimick the behaviour
of <code>cumsum</code>. 
</p>
<p><code>.isUnitMatrix</code> checks whether the argument is a unit matrix. 
</p>
<p><code>.validTrafo</code> checks whether the argument is a valid transformation.
</p>
<p><code>.CvMMDCovariance</code> determines the IC resp. the as. [co]variance of 
the corresponding Minimum CvM estimator (numerical integration is done on
quantile scale).
</p>
<p><code>.oldCvMMDCovariance</code> determines the IC resp. the as. [co]variance of
the corresponding Minimum CvM estimator (numerical integration is done on
the original scale).
<code>.CvMMDCovariance</code> is a wrapper to <code>.CvMMDCovariance</code> which uses 
emp. cdf as mu.
</p>
<p><code>.show.with.sd</code> is code borrowed from <code>print.fitdistr</code> in
package <span class="pkg">MASS</span> by B.D. Ripley. It pretty-prints estimates with corresponding
sd's below.
</p>
<p><code>.getLogDeriv</code> determines numerically the negative logarithmic derivative of the 
density of distribution <code>distr</code>; to this end uses <code>D1ss</code>, 
<code>D2ss</code> from Martin Maechler's package <span class="pkg">sfsmisc</span>. 
</p>
<p><code>.deleteDim</code> deletes a possible <code>dim</code> argument (sets it to <code>NULL</code>)
but retains all other possible attributes, in particular a <code>name</code> attribute.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>.getLogderiv</code></td>
<td>
<p>a function in one argument <code>x</code> &mdash; the negative logarithmic
derivative of the density</p>
</td></tr>
<tr><td><code>.inArgs</code></td>
<td>
<p><code>logical</code> (length 1)</p>
</td></tr>
<tr><td><code>.csimpsum</code></td>
<td>
<p><code>numeric</code> (of length half the input length)</p>
</td></tr>
<tr><td><code>.isUnitMatrix</code></td>
<td>
<p><code>logical</code> (length 1)</p>
</td></tr>
<tr><td><code>.validTrafo</code></td>
<td>
<p><code>logical</code> (length 1)</p>
</td></tr>
<tr><td><code>.CvMMDCovariance</code></td>
<td>
<p>corresponding as. [co]variance of
the corresponding Minimum CvM estimator or list withcomponents
<code>preIC</code> and <code>var</code> &mdash;see above</p>
</td></tr>
<tr><td><code>.show.with.sd</code></td>
<td>
<p><code>invisible()</code></p>
</td></tr>
<tr><td><code>.deleteDim</code></td>
<td>
<p>vector <code>x</code> without <code>dim</code> attribute</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MLEstimator">MLEstimator</a></code>,
<code><a href="#topic+Estimate-class">Estimate-class</a></code>,
<code><a href="#topic+MCEstimate-class">MCEstimate-class</a></code>,
<code><a href="#topic+Confint-class">Confint-class</a></code>,
<code><a href="#topic+ParamFamParameter-class">ParamFamParameter-class</a></code>
</p>

<hr>
<h2 id='internals_for_qqplot'>Internal functions for qqplot of package distrMod</h2><span id='topic+internals_for_qqplot'></span><span id='topic+.labelprep'></span>

<h3>Description</h3>

<p>These functions are used internally by qqplot of package distrMod.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.labelprep(x,y,lab.pts,col.lbs,cex.lbs,adj.lbs,which.lbs,
           which.Order,order.traf, which.nonlbs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internals_for_qqplot_+3A_x">x</code></td>
<td>
<p>a (numeric) vector</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_y">y</code></td>
<td>
<p>a (numeric) vector of same length as <code>x</code></p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_cex.lbs">cex.lbs</code></td>
<td>
<p>magnification factor for the plotted observation labels</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_col.lbs">col.lbs</code></td>
<td>
<p>color for the plotted observation labels</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_adj.lbs">adj.lbs</code></td>
<td>
<p>adjustment factor for the plotted observation labels</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or <code>NULL</code>; observation labels to be used</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_which.lbs">which.lbs</code></td>
<td>
<p>integer or <code>NULL</code>; which observations shall be labelled</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_which.order">which.Order</code></td>
<td>
<p>integer or <code>NULL</code>; which of the ordered (remaining) observations shall be labelled</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_order.traf">order.traf</code></td>
<td>
<p>function or <code>NULL</code>; an optional trafo by which the observations are ordered (as order(trafo(obs)).</p>
</td></tr>
<tr><td><code id="internals_for_qqplot_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.labelprep</code> prepares the labels for later output:
first some indices among <code>x</code> according
to <code>which.lbs</code> are (optionally) selected, 
then orders both <code>x</code> and <code>y</code> according to the
order of the remaining (optionally transformed by <code>order.traf</code>) values of
<code>x</code> (decreasing); finally only the order statistics (w.r.t. the preceding
ordering) as specified in <code>which.Order</code> are returned;
correspondingly, labels, colors, and magnification factors, are ordered
respectively thinned out.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>.labelprep</code></td>
<td>
<p>a list with components
<code>x0</code> (the thinned out and ordered vector <code>x</code>),
<code>y0</code> (the thinned out and ordered vector <code>y</code>),
<code>lab</code> (the thinned out and ordered vector of labels <code>lab.pts</code>),
<code>col</code> (the thinned out and ordered vector of colors <code>col.lbs</code>),
<code>cex</code> (the thinned out and ordered vector of magnification factors <code>cex.lbs</code>),
<code>ord</code> (the (ordered according to y) indices of the observations selected for labelling),
<code>ns</code> (the (ordered) indices of the selected non-labelled observations).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ks.test">ks.test</a></code>, <code><a href="distr.html#topic+qqplot">qqplot</a></code>
,<code><a href="distr.html#topic+internals-qqplot">internals_qqplot</a></code>
, <code><a href="#topic+qqplot">qqplot</a></code>, <code><a href="RobAStBase.html#topic+qqplot">qqplot</a></code>
</p>

<hr>
<h2 id='isKerAinKerB'>isKerAinKerB</h2><span id='topic+isKerAinKerB'></span>

<h3>Description</h3>

<p>For two matrices <code>A</code> and <code>B</code> checks whether the null space of <code>A</code> is a subspace
of the null space of <code>B</code>, in other words, if <code class="reqn">Ax=0</code> entails <code>Bx=0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isKerAinKerB(A, B, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isKerAinKerB_+3A_a">A</code></td>
<td>
<p> a matrix; if  <code>A</code> is a vector, <code>A</code> is coerced to a matrix by <code>as.matrix</code>. </p>
</td></tr>
<tr><td><code id="isKerAinKerB_+3A_b">B</code></td>
<td>
<p> a matrix; if  <code>B</code> is a vector, <code>B</code> is coerced to a matrix by <code>as.matrix</code>. </p>
</td></tr>
<tr><td><code id="isKerAinKerB_+3A_tol">tol</code></td>
<td>
<p> the tolerance for detecting linear dependencies in the
columns of <code>a</code> and up to which the two projectors are seen as equal (see below). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>via calls to <code><a href="base.html#topic+svd">svd</a></code>, the projectors <code class="reqn">\pi_A</code> and <code class="reqn">\pi_B</code>
onto the respective orthogonal complements of <code class="reqn">{\rm ker}(A)</code> and
<code class="reqn">{\rm ker}(B)</code> are calculated and then is checked whether 
<code class="reqn">\pi_B\pi_A=\pi_B</code>.
</p>


<h3>Value</h3>

<p>logical</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ma &lt;- cbind(1,1,c(1,1,7))
D &lt;- t(ma %*% c(0,1,-1))
## IGNORE_RDIFF_BEGIN
## note that results may vary according to BLAS
isKerAinKerB(D,ma)
isKerAinKerB(ma,D)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='L2GroupParamFamily-class'>L2 differentiable parametric group family</h2><span id='topic+L2GroupParamFamily-class'></span><span id='topic+LogDeriv'></span><span id='topic+LogDeriv+2CL2GroupParamFamily-method'></span><span id='topic+LogDeriv+3C-'></span><span id='topic+LogDeriv+3C-+2CL2GroupParamFamily-method'></span>

<h3>Description</h3>

<p>Class of L2 differentiable parametric group families.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("L2GroupParamFamily", ...)</code>.
More frequently, this class is just used as an intermediate class to classes of
specific group models like <code><a href="#topic+L2LocationFamily-class">L2LocationFamily-class</a></code>,
<code><a href="#topic+L2ScaleFamily-class">L2ScaleFamily-class</a></code>, and <code><a href="#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>L2deriv</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"EuclRandVariable"</code>:
L2 derivative of the family. </p>
</dd>
<dt><code>L2deriv.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: mapping from 
the parameter space (argument <code>param</code> of class 
<code>"ParamFamParameter"</code>) to a mapping from observation <code>x</code> to the  
value of the L2derivative; <code>L2deriv.fct</code> is then used from observation
<code>x</code> to value of the L2derivative; <code>L2deriv.fct</code> is used by 
<code>modifyModel</code> to  move the L2deriv according to a change in the 
parameter </p>
</dd>
<dt><code>L2derivSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"FunSymmList"</code>:
symmetry of the maps included in <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistr</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"UnivarDistrList"</code>:
list which includes the distribution of <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistrSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"DistrSymmList"</code>:
symmetry of the distributions included in <code>L2derivDistr</code>. </p>
</dd>
<dt><code>FisherInfo.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: 
mapping from the parameter space (argument  <code>param</code> of class 
<code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</dd> 
<dt><code>FisherInfo</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"PosDefSymmMatrix"</code>:
Fisher information of the family. </p>
</dd>
<dt><code>LogDeriv</code></dt><dd>
<p>object of class <code>"function"</code>: has argument <code>x</code>; 
the negative logarithmic derivative of the density of the model distribution at 
the &quot;standard&quot; parameter value. </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"L2ParamFamily"</code>, directly.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>LogDeriv</dt><dd><p><code>signature(object = "L2GroupParamFamily")</code>: 
accessor function for slot <code>LogDeriv</code>. </p>
</dd>
<dt>LogDeriv&lt;-</dt><dd><p><code>signature(object = "L2GroupParamFamily")</code>: 
replacement function for slot <code>LogDeriv</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("L2GroupParamFamily")
plot(F1)
</code></pre>

<hr>
<h2 id='L2LocationFamily'>Generating function for L2LocationFamily-class</h2><span id='topic+L2LocationFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationFamily"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2LocationFamily(loc = 0, name, centraldistribution = Norm(),
                 locname = "loc", modParam, LogDeriv,  
                 L2derivDistr.0, FisherInfo.0, distrSymm, L2derivSymm, 
                 L2derivDistrSymm, trafo, .returnClsName = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2LocationFamily_+3A_loc">loc</code></td>
<td>
<p>numeric: location parameter of the model. </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_name">name</code></td>
<td>
<p>character: name of the parametric family. </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_centraldistribution">centraldistribution</code></td>
<td>
<p>object of class <code>"AbscontDistribution"</code>;
we assume from the beginning, that centraldistribution
is symmetric about its median.</p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_modparam">modParam</code></td>
<td>
<p> optional function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_locname">locname</code></td>
<td>
<p>a character vector of length 1 containing the name
of the location parameter</p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_logderiv">LogDeriv</code></td>
<td>
<p>function with argument <code>x</code>: the negative logarithmic 
derivative of the density of the central distribution; if missing, it is
determined numerically using numeric differentiation. </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_l2derivdistr.0">L2derivDistr.0</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code>:
distribution of the L2derivative at the central distribution </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_fisherinfo.0">FisherInfo.0</code></td>
<td>
<p>object of class <code>"PosSemDefSymmMatrix"</code>:
Fisher information of the model at the &quot;standard&quot; parameter value</p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>: 
symmetry of the maps contained in <code>L2deriv</code> </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>: 
symmetry of the distributions contained in <code>L2derivDistr</code> </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or  function in <code>param</code>: transformation of the parameter </p>
</td></tr>
<tr><td><code id="L2LocationFamily_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p> the class name of the return value; by default this
argument is <code>NULL</code> whereupon the return class will be 
<code>L2LocationScaleFamily</code>; but, internally, this generating function is also 
used to produce objects of class Classes <code>NormLocationFamily</code> and 
<code>GumbelLocationFamily</code> (the latter in package <span class="pkg">RobExtremes</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;L2 location family&rdquo; is used.
The function <code>modParam</code> is optional. If it is missing, it is 
constructed from <code>centraldistribution</code> using the location structure
of the model.
Slot <code>param</code> is filled accordingly with the argument 
<code>trafo</code> passed to <code>L2LocationFamily</code>.
In case <code>L2derivDistr.0</code> is missing, <code>L2derivDistr</code> is computed 
via <code>imageDistr</code>, else <code>L2derivDistr</code> is assigned 
<code>L2derivDistr.0</code>, coerced to <code>"UnivariateDistributionList"</code>.
In case <code>FisherInfo.0</code> is missing, Fisher information is computed 
from <code>L2deriv</code> using <code>E</code>.
If <code>distrSymm</code> is missing, it is set to symmetry about <code>loc</code>.
If <code>L2derivSymm</code> is missing, it is set to no symmetry, and
if <code>L2derivDistrSymm</code> is missing, it is set to no symmetry, too. 
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2LocationFamily-class">L2LocationFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- L2LocationFamily()
plot(F1)
</code></pre>

<hr>
<h2 id='L2LocationFamily-class'>L2 differentiable parametric group family</h2><span id='topic+L2LocationFamily-class'></span>

<h3>Description</h3>

<p>Class of L2 differentiable parametric group families.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("L2LocationFamily", ...)</code>.
More frequently they are created via the generating function 
<code>L2LocationFamily</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>L2deriv</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"EuclRandVariable"</code>:
L2 derivative of the family. </p>
</dd>
<dt><code>L2deriv.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: mapping from 
the parameter space (argument <code>param</code> of class 
<code>"ParamFamParameter"</code>) to a mapping from observation <code>x</code> to the  
value of the L2derivative; <code>L2deriv.fct</code> is then used from observation
<code>x</code> to value of the L2derivative; <code>L2deriv.fct</code> is used by 
<code>modifyModel</code> to  move the L2deriv according to a change in the 
parameter </p>
</dd>
<dt><code>L2derivSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"FunSymmList"</code>:
symmetry of the maps included in <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistr</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"UnivarDistrList"</code>:
list which includes the distribution of <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistrSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"DistrSymmList"</code>:
symmetry of the distributions included in <code>L2derivDistr</code>. </p>
</dd>
<dt><code>FisherInfo.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: 
mapping from the parameter space (argument  <code>param</code> of class 
<code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</dd> 
<dt><code>FisherInfo</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"PosDefSymmMatrix"</code>:
Fisher information of the family. </p>
</dd>
<dt><code>LogDeriv</code></dt><dd><p>[inherited from class <code>"L2GroupParamFamily"</code>]
object of class <code>"function"</code>: has argument <code>x</code>; 
the negative logarithmic derivative of the density of the model distribution at 
the &quot;standard&quot; parameter value. </p>
</dd>
<dt><code>locscalename</code></dt><dd><p>[inherited from class <code>"L2LocationScaleUnion"</code>]
object of class <code>"character"</code>: names of location and scale parameter </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"L2LocationScaleUnion"</code>, directly.<br />
Class <code>"L2GroupParamFamily"</code>, by class <code>"L2LocationScaleUnion"</code>.<br />
Class <code>"L2ParamFamily"</code>, by class <code>"L2GroupParamFamily"</code>.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>modifyModel</dt><dd><p><code>signature(model = "L2LocationFamily", param = "ParamFamParameter")</code>:
moves the L2-location family <code>model</code> to parameter <code>param</code> </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2LocationFamily">L2LocationFamily</a></code>, <code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("L2LocationFamily")
plot(F1)
</code></pre>

<hr>
<h2 id='L2LocationScaleFamily'>Generating function for L2LocationScaleFamily-class</h2><span id='topic+L2LocationScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2LocationScaleFamily(loc = 0, scale = 1, name, centraldistribution = Norm(),
                      locscalename = c("loc", "scale"), modParam, LogDeriv,  
                      L2derivDistr.0, FisherInfo.0, distrSymm, L2derivSymm, 
                      L2derivDistrSymm, trafo, .returnClsName = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2LocationScaleFamily_+3A_loc">loc</code></td>
<td>
<p>numeric: location parameter of the model. </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_scale">scale</code></td>
<td>
<p>positive number: scale of the model. </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_name">name</code></td>
<td>
<p>character: name of the parametric family. </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_centraldistribution">centraldistribution</code></td>
<td>
<p>object of class <code>"AbscontDistribution"</code>:
central distribution; we assume by default, that centraldistribution
is symmetric about <code class="reqn">0</code></p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_modparam">modParam</code></td>
<td>
<p> optional function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_locscalename">locscalename</code></td>
<td>
<p>a character vector of length 2 containing the names
of the location and scale parameter; either unnamed, then order must
be <code>c(loc,scale)</code>, or named, then names must be <code>"loc"</code> and 
<code>"scale"</code></p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_logderiv">LogDeriv</code></td>
<td>
<p>function with argument <code>x</code>: the negative logarithmic 
derivative of the density of the central distribution; if missing, it is
determined numerically using numeric differentiation. </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_l2derivdistr.0">L2derivDistr.0</code></td>
<td>
<p>list of length 2 of objects of class <code>"UnivariateDistribution"</code>:
(marginal) distributions of the coordinates of the L2derivative at the 
central distribution </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_fisherinfo.0">FisherInfo.0</code></td>
<td>
<p>object of class <code>"PosSemDefSymmMatrix"</code>:
Fisher information of the model at the &quot;standard&quot; parameter value</p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>: 
symmetry of the maps contained in <code>L2deriv</code> </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>: 
symmetry of the distributions contained in <code>L2derivDistr</code> </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or  function in <code>param</code>: transformation of the parameter </p>
</td></tr>
<tr><td><code id="L2LocationScaleFamily_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p> the class name of the return value; by default this
argument is <code>NULL</code> whereupon the return class will be 
<code>L2LocationScaleFamily</code>; but, internally, this generating function is also 
used to produce objects of class <code>NormalLocationScaleFamily</code>, 
<code>CauchyLocationScaleFamily</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;L2 location and scale family&rdquo; is used.  
The function <code>modParam</code> is optional. If it is missing, it is 
constructed from <code>centraldistribution</code> using the location and
scale structure of the model.
Slot <code>param</code> is filled accordingly with the argument 
<code>trafo</code> passed to <code>L2LocationScaleFamily</code>.
In case <code>L2derivDistr.0</code> is missing, <code>L2derivDistr</code> is computed 
via <code>imageDistr</code>, else <code>L2derivDistr</code> is assigned 
<code>L2derivDistr.0</code>, coerced to <code>"UnivariateDistributionList"</code>.
In case <code>FisherInfo.0</code> is missing, Fisher information is computed 
from <code>L2deriv</code> using <code>E</code>.
If <code>distrSymm</code> is missing, it is set to symmetry about <code>loc</code>.
If <code>L2derivSymm</code> is missing, its location and scale components are set 
to no symmetry , respectively.
if <code>L2derivDistrSymm</code> is missing, its location and scale components are set 
to no  symmetry, respectively.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- L2LocationScaleFamily()
plot(F1)
</code></pre>

<hr>
<h2 id='L2LocationScaleFamily-class'>L2 differentiable parametric group family</h2><span id='topic+L2LocationScaleFamily-class'></span>

<h3>Description</h3>

<p>Class of L2 differentiable parametric group families.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("L2LocationScaleFamily", ...)</code>.
More frequently they are created via the generating function 
<code>L2LocationScaleFamily</code>. </p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>L2deriv</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"EuclRandVariable"</code>:
L2 derivative of the family. </p>
</dd>
<dt><code>L2deriv.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: mapping from 
the parameter space (argument <code>param</code> of class 
<code>"ParamFamParameter"</code>) to a mapping from observation <code>x</code> to the  
value of the L2derivative; <code>L2deriv.fct</code> is then used from observation
<code>x</code> to value of the L2derivative; <code>L2deriv.fct</code> is used by 
<code>modifyModel</code> to  move the L2deriv according to a change in the 
parameter </p>
</dd>
<dt><code>L2derivSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"FunSymmList"</code>:
symmetry of the maps included in <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistr</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"UnivarDistrList"</code>:
list which includes the distribution of <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistrSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"DistrSymmList"</code>:
symmetry of the distributions included in <code>L2derivDistr</code>. </p>
</dd>
<dt><code>FisherInfo.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: 
mapping from the parameter space (argument  <code>param</code> of class 
<code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</dd> 
<dt><code>FisherInfo</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"PosDefSymmMatrix"</code>:
Fisher information of the family. </p>
</dd>
<dt><code>LogDeriv</code></dt><dd><p>[inherited from class <code>"L2GroupParamFamily"</code>]
object of class <code>"function"</code>: has argument <code>x</code>; 
the negative logarithmic derivative of the density of the model distribution at 
the &quot;standard&quot; parameter value. </p>
</dd>
<dt><code>locscalename</code></dt><dd><p>[inherited from class <code>"L2LocationScaleUnion"</code>]
object of class <code>"character"</code>: names of location and scale parameter </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"L2LocationScaleUnion"</code>, directly.<br />
Class <code>"L2GroupParamFamily"</code>, by class <code>"L2LocationScaleUnion"</code>.<br />
Class <code>"L2ParamFamily"</code>, by class <code>"L2GroupParamFamily"</code>.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>modifyModel</dt><dd><p><code>signature(model = "L2LocationScaleFamily", param = "ParamFamParameter")</code>:
moves the L2-location and scale family <code>model</code> to parameter <code>param</code> </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2LocationScaleFamily">L2LocationScaleFamily</a></code>, <code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("L2LocationScaleFamily")
plot(F1)
</code></pre>

<hr>
<h2 id='L2LocationUnknownScaleFamily'>Generating function for L2LocationScaleFamily-class in nuisance situation</h2><span id='topic+L2LocationUnknownScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> in the situation
where location is main, scale nuisance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2LocationUnknownScaleFamily(loc = 0, scale = 1, name, centraldistribution = Norm(),
                      locscalename = c("loc", "scale"), modParam, LogDeriv,  
                      L2derivDistr.0, FisherInfo.0, distrSymm, L2derivSymm, 
                      L2derivDistrSymm, trafo, .returnClsName = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_loc">loc</code></td>
<td>
<p>numeric: location parameter of the model. </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_scale">scale</code></td>
<td>
<p>positive number: scale of the model. </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_name">name</code></td>
<td>
<p>character: name of the parametric family. </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_centraldistribution">centraldistribution</code></td>
<td>
<p>object of class <code>"AbscontDistribution"</code>:
central distribution; we assume by default, that centraldistribution
is symmetric about <code class="reqn">0</code></p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_modparam">modParam</code></td>
<td>
<p> optional function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_locscalename">locscalename</code></td>
<td>
<p>a character vector of length 2 containing the names
of the location and scale parameter; either unnamed, then order must
be <code>c(loc,scale)</code>, or named, then names must be <code>"loc"</code> and 
<code>"scale"</code></p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_logderiv">LogDeriv</code></td>
<td>
<p>function with argument <code>x</code>: the negative logarithmic 
derivative of the density of the central distribution; if missing, it is
determined numerically using numeric differentiation. </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_l2derivdistr.0">L2derivDistr.0</code></td>
<td>
<p>list of length 2 of objects of class <code>"UnivariateDistribution"</code>:
(marginal) distributions of the coordinates of the L2derivative at the 
central distribution </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_fisherinfo.0">FisherInfo.0</code></td>
<td>
<p>object of class <code>"PosSemDefSymmMatrix"</code>:
Fisher information of the model at the &quot;standard&quot; parameter value</p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>: 
symmetry of the maps contained in <code>L2deriv</code> </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>: 
symmetry of the distributions contained in <code>L2derivDistr</code> </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or  function in <code>param</code>: transformation of the parameter </p>
</td></tr>
<tr><td><code id="L2LocationUnknownScaleFamily_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p> the class name of the return value; by default this
argument is <code>NULL</code> whereupon the return class will be 
<code>L2LocationScaleFamily</code>; but, internally, this generating function is also 
used to produce objects of class <code>NormalLocationScaleFamily</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;L2 location family with unknown scale (as nuisance)&rdquo; is used.  
The function <code>modParam</code> is optional. If it is missing, it is 
constructed from <code>centraldistribution</code> using the location and
scale structure of the model.
Slot <code>param</code> is filled accordingly with the argument 
<code>trafo</code> passed to <code>L2LocationUnknownScaleFamily</code>.
In case <code>L2derivDistr.0</code> is missing, <code>L2derivDistr</code> is computed 
via <code>imageDistr</code>, else <code>L2derivDistr</code> is assigned 
<code>L2derivDistr.0</code>, coerced to <code>"UnivariateDistributionList"</code>.
In case <code>FisherInfo.0</code> is missing, Fisher information is computed 
from <code>L2deriv</code> using <code>E</code>.
If <code>distrSymm</code> is missing, it is set to symmetry about <code>loc</code>.
If <code>L2derivSymm</code> is missing, its location and scale components are set 
to no symmetry, respectively.
if <code>L2derivDistrSymm</code> is missing, its location and scale components are set 
to no symmetry, respectively.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- L2LocationUnknownScaleFamily()
plot(F1)
</code></pre>

<hr>
<h2 id='L2ParamFamily'>Generating function for L2ParamFamily-class</h2><span id='topic+L2ParamFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ParamFamily"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2ParamFamily(name, distribution = Norm(), distrSymm, 
              main = main(param), nuisance = nuisance(param),
              fixed = fixed(param), trafo = trafo(param),
              param = ParamFamParameter(name = paste("Parameter of", name),  
                          main = main, nuisance = nuisance, 
                          fixed = fixed, trafo = trafo),
              props = character(0),
              startPar = NULL, makeOKPar = NULL,
              modifyParam = function(theta){ Norm(mean=theta) },
              L2deriv.fct = function(param) {force(theta &lt;- param@main)
                           return(function(x) {x-theta})},
              L2derivSymm, L2derivDistr, L2derivDistrSymm, 
              FisherInfo.fct, FisherInfo = FisherInfo.fct(param),
              .returnClsName = NULL, .withMDE = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2ParamFamily_+3A_name">name</code></td>
<td>
<p> character string: name of the family </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_distribution">distribution</code></td>
<td>
<p> object of class <code>"Distribution"</code>:
member of the family </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_main">main</code></td>
<td>
<p> numeric vector: main parameter </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_nuisance">nuisance</code></td>
<td>
<p> numeric vector: nuisance parameter </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_fixed">fixed</code></td>
<td>
<p> numeric vector: fixed part of the parameter </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_param">param</code></td>
<td>
<p> object of class <code>"ParamFamParameter"</code>:
parameter of the family </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_startpar">startPar</code></td>
<td>
<p><code>startPar</code> is a function in the observations <code>x</code>
returning initial information for <code>MCEstimator</code> used 
by <code>optimize</code> resp. <code>optim</code>; i.e; if (total) parameter is of 
length 1, <code>startPar</code> returns a search interval, else it returns an initial 
parameter value.</p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_makeokpar">makeOKPar</code></td>
<td>
<p><code>makeOKPar</code> is a function in the (total)
parameter <code>param</code>; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one; if <code>NULL</code>
slot <code>makeOKPar</code> of <code>ParamFamily</code> is used to produce it.</p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_modifyparam">modifyParam</code></td>
<td>
<p> function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_props">props</code></td>
<td>
<p> character vector: properties of the family </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_l2deriv.fct">L2deriv.fct</code></td>
<td>
<p> function: mapping from the parameter space (argument
<code>param</code> of class <code>"ParamFamParameter"</code>) to a mapping from 
observation <code>x</code> to the value of the L2derivative;  
<code>L2deriv.fct</code> is used by <code>modifyModel</code> to 
move the L2deriv according to a change in the parameter,
and to fill slot <code>L2deriv</code>.
More specifically, let us call the parts <code>main</code> and <code>nuisance</code>
of the parameter the <em>unknown</em> parameter. If this unknown parameter is
one-dimensional, the return value of <code>L2deriv.fct</code> must be a function
in argument <code>x</code>, which is vectorized, (i.e.,
callable for a vector-valued <code>x</code>), and has a one-dimensional, numeric
return value. In case the dimension of the unknown parameter is larger
than one, the return value must be a list of functions, each of which
satisfies the conditions formulated for the case of a one-dimensional
parameter of interest. The order of the components of this list is
the same as the order of the parameter coordinates in <code>main</code>, followed
by the ones in <code>nuisance</code>.</p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>: 
symmetry of the maps contained in <code>L2deriv</code>; a list
of symmetry properties of the same length as the return value of
<code> L2deriv.fct </code>.</p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_l2derivdistr">L2derivDistr</code></td>
<td>
<p> object of class <code>"UnivarDistrList"</code>: 
distribution of <code>L2deriv</code>; the length of this list
of univariate distributions must be of the same length as the
return value of <code> L2deriv.fct </code>.</p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>: 
symmetry of the distributions contained in <code>L2derivDistr</code>;
the length of this list of symmetry properties must be
of the same length as the  return value of <code> L2deriv.fct </code>. </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_fisherinfo.fct">FisherInfo.fct</code></td>
<td>
<p>function: mapping from the parameter space (argument
<code>param</code> of class <code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</td></tr> 
<tr><td><code id="L2ParamFamily_+3A_fisherinfo">FisherInfo</code></td>
<td>
<p> object of class <code>"PosSemDefSymmMatrix"</code>:
Fisher information of the family </p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p> the class name of the return value; by default this
argument is <code>NULL</code> whereupon the return class will be 
<code>L2ParamFamily</code>; but, internally, this generating function is also 
used to e.g. produce objects of class <code>BinomialFamily</code>, <code>PoisFamily</code>
<code>GammaFamily</code>, <code>BetaFamily</code>.</p>
</td></tr>
<tr><td><code id="L2ParamFamily_+3A_.withmde">.withMDE</code></td>
<td>
<p> logical of length 1: Tells R how to use the function from
slot <code>startPar</code> in case of a <code>kStepEstimator</code>&mdash;use it as is or
to compute the starting point for a minimum distance estimator which in
turn then serves as starting point for <code>roptest</code> / <code>robest</code>
(from package <span class="pkg">ROptEst</span>). If <code>TRUE</code> (default) the latter
alternative is used. Ignored if <span class="pkg">ROptEst</span> is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;L2 differentiable parametric family of probability measures&rdquo; 
is used. In case <code>distrSymm</code> is missing it is set to
<code>NoSymmetry()</code>.
If <code>param</code> is missing, the parameter is created via
<code>main</code>, <code>nuisance</code> and <code>trafo</code> as described
in <code><a href="#topic+ParamFamParameter">ParamFamParameter</a></code>. In case <code>L2derivSymm</code> is
missing, it is filled with an object of class <code>FunSymmList</code> 
with entries <code>NonSymmetric()</code>. In case <code>L2derivDistr</code> is missing, 
it is computed via <code>imageDistr</code>. If <code>L2derivDistrSymm</code> is missing, 
it is set to an object of class <code>DistrSymmList</code> with entries 
<code>NoSymmetry()</code>. In case <code>FisherInfo</code> is missing, it is computed 
from <code>L2deriv</code> using <code>E</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- L2ParamFamily()
plot(F1)
</code></pre>

<hr>
<h2 id='L2ParamFamily-class'>L2 differentiable parametric family</h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+L2ParamFamily-class'></span><span id='topic+FisherInfo'></span><span id='topic+FisherInfo+2CL2ParamFamily+2Cmissing-method'></span><span id='topic+FisherInfo+2CL2ParamFamily+2CParamFamParameter-method'></span><span id='topic+L2deriv'></span><span id='topic+L2deriv+2CL2ParamFamily+2Cmissing-method'></span><span id='topic+L2deriv+2CL2ParamFamily+2CParamFamParameter-method'></span><span id='topic+L2derivSymm'></span><span id='topic+L2derivSymm+2CL2ParamFamily-method'></span><span id='topic+L2derivDistr'></span><span id='topic+L2derivDistr+2CL2ParamFamily-method'></span><span id='topic+L2derivDistrSymm'></span><span id='topic+L2derivDistrSymm+2CL2ParamFamily-method'></span><span id='topic+checkL2deriv+2CL2ParamFamily-method'></span><span id='topic+E+2CL2ParamFamily+2CEuclRandVariable+2Cmissing-method'></span><span id='topic+E+2CL2ParamFamily+2CEuclRandMatrix+2Cmissing-method'></span><span id='topic+E+2CL2ParamFamily+2CEuclRandVarList+2Cmissing-method'></span><span id='topic+plot+2CL2ParamFamily+2Cmissing-method'></span>

<h3>Description</h3>

<p>Class of L2 differentiable parametric families.</p>


<h3>Details</h3>

<p>In the <code>E</code>-methods, diagnostics on the involved integrations are available
if argument   <code>diagnostic</code> is <code>TRUE</code>. Then there is attribute
<code>diagnostic</code> attached to the return value, which may be inspected
and accessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("L2ParamFamily", ...)</code>.
More frequently they are created via the generating function 
<code>L2ParamFamily</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>L2deriv</code></dt><dd>
<p>object of class <code>"EuclRandVariable"</code>:
L2 derivative of the family. Its map slot must contain a list of functions.
Each function in this list must have just one argument <code>x</code>,
which is vectorized, (i.e., callable for a vector-valued <code>x</code>),
and has a one-dimensional, numeric return value.</p>
</dd>
<dt><code>L2deriv.fct</code></dt><dd>
<p>object of class <code>"function"</code>: mapping from 
the parameter space (argument <code>param</code> of class 
<code>"ParamFamParameter"</code>) to a mapping from observation <code>x</code> to the  
value of the L2derivative; <code>L2deriv.fct</code> is then used from observation
<code>x</code> to value of the L2derivative; <code>L2deriv.fct</code> is used by 
<code>modifyModel</code> to  move the L2deriv according to a change in the 
parameter.
More specifically, let us call the parts <code>main</code> and <code>nuisance</code>
of the parameter the <em>unknown</em> parameter. If this unknown parameter is
one-dimensional, the return value of <code>L2deriv.fct</code> must be a function
in argument <code>x</code>, which is vectorized, (i.e.,
callable for a vector-valued <code>x</code>), and has a one-dimensional, numeric
return value. In case the dimension of the unknown parameter is larger
than one, the return value must be a list of functions, each of which
satisfies the conditions formulated for the case of a one-dimensional
parameter of interest. The order of the components of this list is
the same as the order of the parameter coordinates in <code>main</code>, followed
by the ones in <code>nuisance</code>.</p>
</dd>
<dt>L2derivSymm</dt><dd><p> object of class <code>"FunSymmList"</code>:
symmetry of the maps contained in <code>L2deriv</code>; a list
of symmetry properties of the same length as the return value of
<code> L2deriv.fct </code>.</p>
</dd>
<dt>L2derivDistr</dt><dd><p>object of class <code>"OptionalDistrListOrCall"</code>
(i.e., <code>NULL</code> or an object of class <code>"DistrList"</code> or
the respective call to generate the latter object): if non-null
and non-call, a list which includes the distribution of <code>L2deriv</code>;
the length of this list of univariate distributions must be of the same
length as the return value of <code> L2deriv.fct </code>.</p>
</dd>
<dt>L2derivDistrSymm</dt><dd><p> object of class <code>"DistrSymmList"</code>:
symmetry of the distributions contained in <code>L2derivDistr</code>;
the length of this list of symmetry properties must be
of the same length as the  return value of <code> L2deriv.fct </code>. </p>
</dd>
<dt><code>FisherInfo.fct</code></dt><dd>
<p>object of class <code>"function"</code>: 
mapping from the parameter space (argument  <code>param</code> of class 
<code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</dd> 
<dt><code>FisherInfo</code></dt><dd>
<p>object of class <code>"PosDefSymmMatrix"</code>:
Fisher information of the family. </p>
</dd>
<dt><code>.withEvalL2derivDistr</code></dt><dd>
<p>logical  of length one: if <code>TRUE</code> slot <code>L2derivDistr</code> gets
evaluated, otherwise it is only kept as call. </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"ParamFamily"</code>, directly.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv</dt><dd><p><code>signature(object = "L2ParamFamily")</code>: 
accessor function for <code>L2deriv</code>. </p>
</dd>
<dt>L2deriv</dt><dd><p><code>signature(object = "L2ParamFamily", 
                                   param = "ParamFamParameter")</code>: 
returns the L2derivative at <code>param</code>, i.e.
evaluates slot function <code>L2deriv.fct</code> at <code>param</code>. </p>
</dd>
<dt>L2derivSymm</dt><dd><p><code>signature(object = "L2ParamFamily")</code>: 
accessor function for <code>L2derivSymm</code>. </p>
</dd>
<dt>L2derivDistr</dt><dd><p><code>signature(object = "L2ParamFamily")</code>:
accessor function for <code>L2derivDistr</code>. </p>
</dd>
<dt>L2derivDistrSymm</dt><dd><p><code>signature(object = "L2ParamFamily")</code>:
accessor function for <code>L2derivDistrSymm</code>. </p>
</dd>
<dt>FisherInfo</dt><dd><p><code>signature(object = "L2ParamFamily")</code>:
accessor function for <code>FisherInfo</code>. </p>
</dd>
<dt>FisherInfo</dt><dd><p><code>signature(object = "L2ParamFamily", 
                                   param = "ParamFamParameter")</code>: 
returns the Fisher Information at <code>param</code>, i.e.
evaluates slot function <code>FisherInfo.fct</code> at <code>param</code>. </p>
</dd>
<dt>checkL2deriv</dt><dd><p><code>signature(object = "L2ParamFamily")</code>: 
check centering of <code>L2deriv</code> and compute precision 
of Fisher information. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "L2ParamFamily", fun = "EuclRandVariable", cond = "missing")</code>:
expectation of <code>fun</code> under the distribution of <code>object</code>. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "L2ParamFamily", fun = "EuclRandMatrix", cond = "missing")</code>:
expectation of <code>fun</code> under the distribution of <code>object</code>. </p>
</dd>
<dt>E</dt><dd><p><code>signature(object = "L2ParamFamily", fun = "EuclRandVarList", cond = "missing")</code>:
expectation of <code>fun</code> under the distribution of <code>object</code>. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "L2ParamFamily")</code>: 
plot of <code>distribution</code> and <code>L2deriv</code>. More precisely,
this method has arguments
<code>
      plot(x, withSweave = getdistrOption("withSweave"), 
             main = FALSE, inner = TRUE, sub = FALSE, 
             col.inner = par("col.main"), cex.inner = 0.8, 
             bmar = par("mar")[1], tmar = par("mar")[3], ...,
             mfColRow = TRUE, to.draw.arg = NULL, withSubst = TRUE)
      </code> where </p>

<dl>
<dt>x</dt><dd><p>object of class <code>"L2ParamFamily"</code></p>
</dd>
<dt>withSweave</dt><dd><p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>) 
no extra device is opened and height/width are not set</p>
</dd>
<dt>main</dt><dd><p>logical: is a main title to be used? or <br />
just as argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</dd>
<dt>inner</dt><dd><p>logical: do panels have their own titles? or <br />
character vector of / cast to length 'number of plotted 
panels' with the corresponding panel titles. For further 
information, see also 
<code><a href="distr.html#topic+plot-methods">plot</a></code> and the 
description of argument <code>main</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</dd> 
<dt>sub</dt><dd><p>logical: is a sub-title to be used? or <br />
just as argument <code>sub</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</dd>
<dt>tmar</dt><dd><p>top margin &ndash; useful for non-standard main title sizes</p>
</dd>
<dt>bmar</dt><dd><p>bottom margin &ndash; useful for non-standard sub title sizes</p>
</dd>
<dt>cex.inner</dt><dd><p>magnification to be used for inner titles relative
to the current setting of <code>cex</code>; as in 
<code><a href="graphics.html#topic+par">par</a></code>; can be a vector of length 2; in this
case the first component is for the distribution panels, the 
second for the L2-derivative-panels.</p>
</dd>
<dt>col.inner</dt><dd><p>character or integer code; color for the inner title</p>
</dd>              
<dt>mfColRow</dt><dd><p>shall default partition in panels be used &mdash; 
defaults to <code>TRUE</code></p>
</dd>
<dt>to.draw.arg</dt><dd><p>Either <code>NULL</code> (default; 
everything is plotted) or a vector of either integers 
(the indices of the subplots to be drawn) or characters 
&mdash; the names of the subplots to be drawn: these
names are to be chosen among 
<code>c("d","p","q", dimnms)</code> where <code>dimnms</code> is
either the row names of the trafo matrix 
<code>rownames(trafo(x@param))</code> or if the last expression
is <code>NULL</code> a vector <code>"dim&lt;dimnr&gt;"</code>, 
<code>dimnr</code> running through the number of rows of the 
trafo matrix.
</p>
</dd>
<dt>withSubst</dt><dd><p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</dd>
<dt>...</dt><dd><p>addtional arguments for <code>plot</code> &mdash; see 
<code><a href="graphics.html#topic+plot">plot</a></code>, 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, 
<code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code> </p>
</dd>
</dl>
 
<p>If <code>...</code> contains argument <code>ylim</code>, this may either be
as in <code>plot.default</code> (i.e. a vector of length 2) or a vector of 
length 4, where the first two elements are the values for <code>ylim</code> 
in panels &quot;d.c&quot; and &quot;d.d&quot;, and the last
two elements are the values for <code>ylim</code> resp. <code>xlim</code> in panels 
&quot;p&quot;, &quot;p.c&quot;, &quot;p.d&quot; and &quot;q&quot;, &quot;q.c&quot;, &quot;q.d&quot;.
In all title and axis label arguments, if <code>withSubst</code> is <code>TRUE</code>,
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>x</code></p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument <code>x</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>

<p>In addition, argument <code>...</code> may contain arguments <code>panel.first</code>,
<code>panel.last</code>, i.e., hook expressions to be evaluated at the very beginning
and at the very end of each panel (within the then valid coordinates).
To be able to use these hooks for each panel individually, they may also be
lists of expressions (of the same length as the number of panels and
run through in the same order as the panels).
</p>
<p>The return value of the plot methods is an S3 object of class
<code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>
</dd>
<dt>modifyModel</dt><dd><p><code>signature(model = "L2ParamFamily", param = "ParamFamParameter")</code>:
moves the L2-parametric Family <code>model</code> to parameter <code>param</code> </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily">L2ParamFamily</a></code>, <code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("L2ParamFamily")
plot(F1)

## selection of subpanels for plotting
F2 &lt;- L2LocationScaleFamily()
layout(matrix(c(1,2,3,3), nrow=2, byrow=TRUE))
plot(F2,mfColRow = FALSE,
     to.draw.arg=c("p","q","loc"))
plot(F2,mfColRow = FALSE, inner=list("empirical cdf","pseudo-inverse",
     "L2-deriv, loc.part"), to.draw.arg=c("p","q","loc"))
</code></pre>

<hr>
<h2 id='L2ScaleFamily'>Generating function for L2ScaleFamily-class</h2><span id='topic+L2ScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ScaleFamily"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2ScaleFamily(scale = 1, loc = 0,  name, centraldistribution = Norm(),
              locscalename = c("loc", "scale"), modParam, LogDeriv,  
              L2derivDistr.0, FisherInfo.0, distrSymm, L2derivSymm, 
              L2derivDistrSymm, trafo, .returnClsName = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2ScaleFamily_+3A_scale">scale</code></td>
<td>
<p>positive number: scale parameter of the model </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_loc">loc</code></td>
<td>
<p>numeric: location parameter of the model </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_name">name</code></td>
<td>
<p>character: name of the parametric family. </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_centraldistribution">centraldistribution</code></td>
<td>
<p>object of class <code>"AbscontDistribution"</code>:
central distribution; we assume from the beginning, that centraldistribution
is symmetric about <code class="reqn">0</code>  </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_locscalename">locscalename</code></td>
<td>
<p>a character vector of length 1 or 2 containing the names
of the scale resp. of location and scale parameter; if length is 2, 
<code>locscalename</code> is either unnamed, then order must
be <code>c(scale,loc)</code>, or named, then names must be <code>"loc"</code> and 
<code>"scale"</code>.</p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_modparam">modParam</code></td>
<td>
<p> optional function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_logderiv">LogDeriv</code></td>
<td>
<p>function with argument <code>x</code>: the negative logarithmic 
derivative of the density of the central distribution; if missing, it is
determined numerically using numeric differentiation. </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_l2derivdistr.0">L2derivDistr.0</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code>:
distribution of the L2derivative at the central distribution </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_fisherinfo.0">FisherInfo.0</code></td>
<td>
<p>object of class <code>"PosSemDefSymmMatrix"</code>:
Fisher information of the model at the &quot;standard&quot; parameter value</p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>: 
symmetry of the maps contained in <code>L2deriv</code> </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>: 
symmetry of the distributions contained in <code>L2derivDistr</code> </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or  function in <code>param</code>: transformation of the parameter </p>
</td></tr>
<tr><td><code id="L2ScaleFamily_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p> the class name of the return value; by default this
argument is <code>NULL</code> whereupon the return class will be 
<code>L2ScaleFamily</code>; but, internally, this generating function is also 
used to produce objects of class <code>NormScaleFamily</code>, <code>ExpScaleFamily</code>, 
and <code>LnormScaleFamily</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;L2 scale family&rdquo; is used.  
The function <code>modParam</code> is optional. If it is missing, it is 
constructed from <code>centraldistribution</code> using the scale structure 
of the model.
Slot <code>param</code> is filled accordingly with the argument 
<code>trafo</code> passed to <code>L2ScaleFamily</code>.
In case <code>L2derivDistr.0</code> is missing, <code>L2derivDistr</code> is computed 
via <code>imageDistr</code>, else <code>L2derivDistr</code> is assigned 
<code>L2derivDistr.0</code>, coerced to <code>"UnivariateDistributionList"</code>.
In case <code>FisherInfo.0</code> is missing, Fisher information is computed 
from <code>L2deriv</code> using <code>E</code>.
If <code>distrSymm</code> is missing, it is set to symmetry about <code>loc</code>.
If <code>L2derivSymm</code> is missing, it is set to no symmetry, and
if <code>L2derivDistrSymm</code> is missing, it is set to no symmetry. 
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ScaleFamily-class">L2ScaleFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- L2ScaleFamily()
plot(F1)
</code></pre>

<hr>
<h2 id='L2ScaleFamily-class'>L2 differentiable parametric group family</h2><span id='topic+L2ScaleFamily-class'></span>

<h3>Description</h3>

<p>Class of L2 differentiable parametric group families.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("L2ScaleFamily", ...)</code>.
More frequently they are created via the generating function 
<code>L2ScaleFamily</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code></dt><dd><p>[inherited from class <code>"ParamFamily"</code>]
object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>L2deriv</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"EuclRandVariable"</code>:
L2 derivative of the family. </p>
</dd>
<dt><code>L2deriv.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: mapping from 
the parameter space (argument <code>param</code> of class 
<code>"ParamFamParameter"</code>) to a mapping from observation <code>x</code> to the  
value of the L2derivative; <code>L2deriv.fct</code> is then used from observation
<code>x</code> to value of the L2derivative; <code>L2deriv.fct</code> is used by 
<code>modifyModel</code> to  move the L2deriv according to a change in the 
parameter </p>
</dd>
<dt><code>L2derivSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"FunSymmList"</code>:
symmetry of the maps included in <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistr</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"UnivarDistrList"</code>:
list which includes the distribution of <code>L2deriv</code>. </p>
</dd>
<dt><code>L2derivDistrSymm</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"DistrSymmList"</code>:
symmetry of the distributions included in <code>L2derivDistr</code>. </p>
</dd>
<dt><code>FisherInfo.fct</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"function"</code>: 
mapping from the parameter space (argument  <code>param</code> of class 
<code>"ParamFamParameter"</code>) to the set of positive
semidefinite matrices; <code>FisherInfo.fct</code> is used by <code>modifyModel</code> to 
move the Fisher information according to a change in the parameter </p>
</dd> 
<dt><code>FisherInfo</code></dt><dd><p>[inherited from class <code>"L2ParamFamily"</code>]
object of class <code>"PosDefSymmMatrix"</code>:
Fisher information of the family. </p>
</dd>
<dt><code>LogDeriv</code></dt><dd><p>[inherited from class <code>"L2GroupParamFamily"</code>]
object of class <code>"function"</code>: has argument <code>x</code>; 
the negative logarithmic derivative of the density of the model distribution at 
the &quot;standard&quot; parameter value. </p>
</dd>
<dt><code>locscalename</code></dt><dd><p>[inherited from class <code>"L2LocationScaleUnion"</code>]
object of class <code>"character"</code>: names of location and scale parameter </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"L2LocationScaleUnion"</code>, directly.<br />
Class <code>"L2GroupParamFamily"</code>, by class <code>"L2LocationScaleUnion"</code>.<br />
Class <code>"L2ParamFamily"</code>, by class <code>"L2GroupParamFamily"</code>.<br />
Class <code>"ParamFamily"</code>, by class <code>"L2ParamFamily"</code>.<br />
Class <code>"ProbFamily"</code>, by class <code>"ParamFamily"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>modifyModel</dt><dd><p><code>signature(model = "L2ScaleFamily", param = "ParamFamParameter")</code>:
moves the L2-scale family <code>model</code> to parameter <code>param</code> </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ScaleFamily">L2ScaleFamily</a></code>, <code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("L2ScaleFamily")
plot(F1)
</code></pre>

<hr>
<h2 id='L2ScaleUnknownLocationFamily'>Generating function for L2LocationScaleFamily-class in nuisance situation</h2><span id='topic+L2ScaleUnknownLocationFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> 
in the situation where scale is main, location nuisance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2ScaleUnknownLocationFamily(loc = 0, scale = 1, name, centraldistribution = Norm(),
                      locscalename = c("loc", "scale"), modParam, LogDeriv,  
                      L2derivDistr.0, FisherInfo.0, distrSymm, L2derivSymm, 
                      L2derivDistrSymm, trafo, .returnClsName = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_loc">loc</code></td>
<td>
<p>numeric: location parameter of the model. </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_scale">scale</code></td>
<td>
<p>positive number: scale of the model. </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_name">name</code></td>
<td>
<p>character: name of the parametric family. </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_centraldistribution">centraldistribution</code></td>
<td>
<p>object of class <code>"AbscontDistribution"</code>:
central distribution; we assume by default, that centraldistribution
is symmetric about <code class="reqn">0</code></p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_modparam">modParam</code></td>
<td>
<p> optional function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_locscalename">locscalename</code></td>
<td>
<p>a character vector of length 2 containing the names
of the location and scale parameter; either unnamed, then order must
be <code>c(loc,scale)</code>, or named, then names must be <code>"loc"</code> and 
<code>"scale"</code></p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_logderiv">LogDeriv</code></td>
<td>
<p>function with argument <code>x</code>: the negative logarithmic 
derivative of the density of the central distribution; if missing, it is
determined numerically using numeric differentiation. </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_l2derivdistr.0">L2derivDistr.0</code></td>
<td>
<p>list of length 2 of objects of class <code>"UnivariateDistribution"</code>:
(marginal) distributions of the coordinates of the L2derivative at the 
central distribution </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_fisherinfo.0">FisherInfo.0</code></td>
<td>
<p>object of class <code>"PosSemDefSymmMatrix"</code>:
Fisher information of the model at the &quot;standard&quot; parameter value</p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>: 
symmetry of the maps contained in <code>L2deriv</code> </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>: 
symmetry of the distributions contained in <code>L2derivDistr</code> </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix or  function in <code>param</code>: transformation of the parameter </p>
</td></tr>
<tr><td><code id="L2ScaleUnknownLocationFamily_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p> the class name of the return value; by default this
argument is <code>NULL</code> whereupon the return class will be 
<code>L2LocationScaleFamily</code>; but, internally, this generating function is also 
used to produce objects of class <code>NormalLocationScaleFamily</code>, 
<code>CauchyLocationScaleFamily</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;L2 scale family with unknown location (as nuisance)&rdquo; is used.  
The function <code>modParam</code> is optional. If it is missing, it is 
constructed from <code>centraldistribution</code> using the location and
scale structure of the model.
Slot <code>param</code> is filled accordingly with the argument 
<code>trafo</code> passed to <code>L2ScaleUnknownLocationFamily</code>.
In case <code>L2derivDistr.0</code> is missing, <code>L2derivDistr</code> is computed 
via <code>imageDistr</code>, else <code>L2derivDistr</code> is assigned 
<code>L2derivDistr.0</code>, coerced to <code>"UnivariateDistributionList"</code>.
In case <code>FisherInfo.0</code> is missing, Fisher information is computed 
from <code>L2deriv</code> using <code>E</code>.
If <code>distrSymm</code> is missing, it is set to symmetry about <code>loc</code>.
If <code>L2derivSymm</code> is missing, its location and scale components are set 
to no symmetry, respectively.
if <code>L2derivDistrSymm</code> is missing, its location and scale components are set 
to no symmetry, respectively.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2LocationScaleFamily-class">L2LocationScaleFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- L2ScaleUnknownLocationFamily()
plot(F1)
</code></pre>

<hr>
<h2 id='LnormScaleFamily'>Generating function for lognormal scale families</h2><span id='topic+LnormScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ScaleFamily"</code> which
represents a lognormal scale family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LnormScaleFamily(meanlog = 0, sdlog = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LnormScaleFamily_+3A_meanlog">meanlog</code></td>
<td>
<p> mean of the distribution on the log scale </p>
</td></tr>
<tr><td><code id="LnormScaleFamily_+3A_sdlog">sdlog</code></td>
<td>
<p> standard deviation of the distribution on the log scale </p>
</td></tr>
<tr><td><code id="LnormScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Lnorm-class">Lnorm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(L1 &lt;- LnormScaleFamily())
plot(L1)
Map(L2deriv(L1)[[1]])
checkL2deriv(L1)
</code></pre>

<hr>
<h2 id='LogisticLocationScaleFamily'>Generating function for Logistic location and scale families</h2><span id='topic+LogisticLocationScaleFamily'></span><span id='topic+LogisticFamily'></span><span id='topic+LOGISTINT2'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> which
represents a normal location and scale family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticLocationScaleFamily(location = 0, scale = 1, trafo)
LOGISTINT2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogisticLocationScaleFamily_+3A_location">location</code></td>
<td>
<p> location </p>
</td></tr>
<tr><td><code id="LogisticLocationScaleFamily_+3A_scale">scale</code></td>
<td>
<p> scale </p>
</td></tr>
<tr><td><code id="LogisticLocationScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
<code>LOGISTINT2</code> is a constant used for the scale part of the Fisher information.
More precisely <code>LOGISTINT2</code> equals to
<code class="reqn">\int_{-\infty}^{\infty} (\tanh(x/2)\,x-1)^2\,{\rm dlogis}(x)\,dx</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@uni-oldenburg.de">Peter.Ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Logis-class">Logis-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(L1 &lt;- LogisticLocationScaleFamily())
## synonymous: L1 &lt;- LogisticFamily()
plot(L1)
FisherInfo(L1)
### need smaller integration range:
distrExoptions("ElowerTruncQuantile"=1e-4,"EupperTruncQuantile"=1e-4)
checkL2deriv(L1)
distrExoptions("ElowerTruncQuantile"=1e-7,"EupperTruncQuantile"=1e-7)
##
set.seed(123)
x &lt;- rlogis(100,location=1,scale=2)
CvMMDEstimator(x, L1)
</code></pre>

<hr>
<h2 id='mceCalc-methods'> Methods for functions mceCalc and mleCalc in Package &lsquo;distrMod&rsquo; </h2><span id='topic+mceCalc-methods'></span><span id='topic+mleCalc-methods'></span><span id='topic+mceCalc'></span><span id='topic+mleCalc'></span><span id='topic+mceCalc+2Cnumeric+2CParamFamily-method'></span><span id='topic+mleCalc+2Cnumeric+2CParamFamily-method'></span><span id='topic+mleCalc+2Cnumeric+2CBinomFamily-method'></span><span id='topic+mleCalc+2Cnumeric+2CPoisFamily-method'></span><span id='topic+mleCalc+2Cnumeric+2CNormLocationFamily-method'></span><span id='topic+mleCalc+2Cnumeric+2CNormScaleFamily-method'></span><span id='topic+mleCalc+2Cnumeric+2CNormLocationScaleFamily-method'></span>

<h3>Description</h3>

<p>Methods for functions <code>mceCalc</code> and <code>mleCalc</code> in package <span class="pkg">distrMod</span>;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mceCalc(x, PFam, ...)
mleCalc(x, PFam, ...)
## S4 method for signature 'numeric,ParamFamily'
mceCalc(x, PFam, criterion, 
                   startPar = NULL, penalty = 1e20, crit.name,
                   Infos = NULL, validity.check = TRUE,
                   withthetaPar = FALSE,...)
## S4 method for signature 'numeric,ParamFamily'
mleCalc(x, PFam, startPar = NULL, 
                   penalty = 1e20, dropZeroDensity = TRUE, Infos = NULL,
                    validity.check = TRUE, ...)
## S4 method for signature 'numeric,BinomFamily'
mleCalc(x, PFam, ...)
## S4 method for signature 'numeric,PoisFamily'
mleCalc(x, PFam, ...)
## S4 method for signature 'numeric,NormLocationFamily'
mleCalc(x, PFam, ...)
## S4 method for signature 'numeric,NormScaleFamily'
mleCalc(x, PFam, ...)
## S4 method for signature 'numeric,NormLocationScaleFamily'
mleCalc(x, PFam, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mceCalc-methods_+3A_x">x</code></td>
<td>
<p>numeric; data at which to evaluate the estimator</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_pfam">PFam</code></td>
<td>
<p>an object of class <code>ParamFamily</code>; the parametric family at
which to evaluate the estimator</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_criterion">criterion</code></td>
<td>
<p>a function measuring the &ldquo;goodness of fit&rdquo;</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_startpar">startPar</code></td>
<td>
<p>in case <code>optim</code> is used: a starting value for the parameter fit;
in case <code>optimize</code> is used: a vector containing a search interval for the
(one-dim) parameter</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_penalty">penalty</code></td>
<td>
<p>numeric; penalizes non-permitted parameter values</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_crit.name">crit.name</code></td>
<td>
<p>character; the name of the criterion; may be missing</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_withthetapar">withthetaPar</code></td>
<td>
<p>logical; shall Parameter theta be transmitted?</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_infos">Infos</code></td>
<td>
<p>matrix; info slot to be filled in object of class <code>MCEstimate</code>; 
may be missing</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_validity.check">validity.check</code></td>
<td>
<p>logical: shall return parameter value be checked for
validity?</p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_dropzerodensity">dropZeroDensity</code></td>
<td>
<p>logical of length 1; shall observations with
density zero be dropped? Optimizers like <code>optim</code> require finite
values, so get problems when negative loglikelihood is evaluated. </p>
</td></tr>
<tr><td><code id="mceCalc-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s) for <code>optim</code> / <code>optimize</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mceCalc</code> is used internally by function <code>MCEstimator</code> to allow
for method dispatch according to argument <code>PFam</code>;
similarly, and for the same purpose  <code>mleCalc</code> is used internally by function 
<code>MLEstimator</code>.
This way we / or any other developper can write particular methods
for special cases where we may avoid using numerical optimization
without interfering with existing code. 
For programming one's own <code>mleCalc</code> / <code>mceCalc</code> methods, there is
the helper function <code><a href="#topic+meRes">meRes</a></code> to produce consistent return values. 
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p> &mdash; the estimate as a named vector of <code>numeric</code></p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p> &mdash; the criterion value (i.e.; a <code>numeric</code> of length 1); 
e.g. the neg. log likelihood</p>
</td></tr>
<tr><td><code>est.name</code></td>
<td>
<p> &mdash; the name of the estimator</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p> &mdash; estimate coerced to class <code>ParamFamParameter</code></p>
</td></tr>
<tr><td><code>crit.fct</code></td>
<td>
<p> &mdash; a function with the named components of <code>theta</code>
as arguments returning the criterion value; used for
profiling / coercing to class <code>mle</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> &mdash; a character reporting how the estimate was obtained, i.e.,
by  <code>optim</code>, by <code>optimize</code> or by explicit calculations</p>
</td></tr>
<tr><td><code>crit.name</code></td>
<td>
<p>character; the name of the criterion; may be <code>""</code></p>
</td></tr>
<tr><td><code>Infos</code></td>
<td>
<p>matrix; info slot to be filled in object of class <code>MCEstimate</code>; 
may be <code>NULL</code></p>
</td></tr>
<tr><td><code>samplesize</code></td>
<td>
<p>numeric; sample size of <code>x</code></p>
</td></tr>
</table>

<hr>
<h2 id='MCEstimate-class'>MCEstimate-class.</h2><span id='topic+MCEstimate-class'></span><span id='topic+MDEstimate-class'></span><span id='topic+MLEstimate-class'></span><span id='topic+CvMMDEstimate-class'></span><span id='topic+criterion'></span><span id='topic+criterion+2CMCEstimate-method'></span><span id='topic+criterion.fct'></span><span id='topic+criterion.fct+2CMCEstimate-method'></span><span id='topic+startPar+2CMCEstimate-method'></span><span id='topic+method'></span><span id='topic+method+2CMCEstimate-method'></span><span id='topic+optimwarn'></span><span id='topic+optimwarn+2CMCEstimate-method'></span><span id='topic+optimReturn'></span><span id='topic+optimReturn+2CMCEstimate-method'></span><span id='topic+criterion+3C-'></span><span id='topic+criterion+3C-+2CMCEstimate-method'></span><span id='topic+coerce+2CMCEstimate+2Cmle-method'></span><span id='topic+show+2CMCEstimate-method'></span><span id='topic+profile+2CMCEstimate-method'></span>

<h3>Description</h3>

<p>Class of minimum criterion estimates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MCEstimate", ...)</code>.
More frequently they are created via the generating functions
<code>MCEstimator</code>, <code>MDEstimator</code> or <code>MLEstimator</code>.
More specifically, <code>MDEstimator</code>, <code>CvMMDEstimator</code>,
and <code>MLEstimator</code> return objects of classes <code>MDEstimate</code>,
<code>CvMMDEstimate</code>, and <code>MLEstimate</code> respectively, which each
are immediate subclasses of <code>MCEstimate</code> (without further slots,
for internal use in method dispatch).
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. </p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate.</p>
</dd>
<dt><code>estimate.call</code></dt><dd><p>Object of class <code>"call"</code>:
call by which estimate was produced.</p>
</dd>
<dt><code>criterion</code></dt><dd><p>Object of class <code>"numeric"</code>:
minimum value of the considered criterion.</p>
</dd>
<dt><code>criterion.fct</code></dt><dd><p>Object of class <code>"function"</code>:
the considered criterion function; used for compatibility with class
<code>"mle"</code> from package <span class="pkg">stats4</span>; should be a function
returning the criterion; i.e. a numeric of length 1 and should have
as arguments all named components of argument 
<code>untransformed.estimate</code></p>
</dd>
<dt><code>method</code></dt><dd><p>Object of class <code>"character"</code>:
the method by which the estimate was calculated, i.e.;
<code>"optim"</code>, <code>"optimize"</code>, or <code>"explicit calculation"</code>; 
used for compatibility with class <code>"mle"</code> from package 
<span class="pkg">stats4</span>, could be any character value.</p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. </p>
</dd>
<dt><code>optimwarn</code></dt><dd><p> object of class <code>"character"</code>
warnings issued during optimization. </p>
</dd>
<dt><code>optimReturn</code></dt><dd><p> object of class <code>"ANY"</code>
the return value of the optimizer (or <code>NULL</code> if, e.g.,
closed form solutions are used). </p>
</dd>
<dt><code>startPar</code></dt><dd><p> &mdash; object of class <code>"ANY"</code>; filled either
with <code>NULL</code> (no starting value used) or with <code>"numeric"</code>
&mdash; the value of the starting parameter. </p>
</dd>
<dt><code>asvar</code></dt><dd><p> object of class <code>"OptionalMatrix"</code>
which may contain the asymptotic (co)variance of the estimator. </p>
</dd>
<dt><code>samplesize</code></dt><dd><p> object of class <code>"numeric"</code> &mdash;
the samplesize at which the estimate was evaluated. </p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
indices of <code>estimate</code> belonging to the nuisance part</p>
</dd>
<dt><code>fixed</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
the fixed and known part of the parameter. </p>
</dd>
<dt><code>trafo</code></dt><dd><p> object of class <code>"list"</code>:
a list with components <code>fct</code> and <code>mat</code> (see below). </p>
</dd>
<dt><code>untransformed.estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
untransformed estimate.</p>
</dd>
<dt><code>untransformed.asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the untransformed 
estimator. </p>
</dd>
<dt><code>completecases</code></dt><dd><p> object of class <code>"logical"</code> &mdash;
complete cases at which the estimate was evaluated. </p>
</dd>
<dt><code>startPar</code></dt><dd><p> object of class <code>"ANY"</code>; usually filled with
argument <code>startPar</code> of generating function <code>MCEstimator</code>,
<code>MLEstimator</code>, <code>MDEstimator</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Estimate"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>criterion</dt><dd><p><code>signature(object = "MCEstimate")</code>: 
accessor function for slot <code>criterion</code>. </p>
</dd>
<dt>criterion&lt;-</dt><dd><p><code>signature(object = "MCEstimate")</code>: 
replacement function for slot <code>criterion</code>. </p>
</dd>
<dt>optimwarn</dt><dd><p><code>signature(object = "MCEstimate")</code>:
accessor function for slot <code>optimwarn</code>. </p>
</dd>
<dt>optimReturn</dt><dd><p><code>signature(object = "MCEstimate")</code>:
accessor function for slot <code>optimReturn</code>. </p>
</dd>
<dt>startPar</dt><dd><p><code>signature(object = "MCEstimate")</code>:
accessor function for slot <code>startPar</code>. </p>
</dd>
<dt>criterion.fct</dt><dd><p><code>signature(object = "MCEstimate")</code>:
accessor function for slot <code>criterion.fct</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Estimate")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "MCEstimate", to = "mle")</code>:
create a <code>"mle"</code> object from a <code>"MCEstimate"</code> object</p>
</dd>
<dt>profile</dt><dd><p><code>signature(fitted = "MCEstimate")</code>:
coerces <code>fitted</code> to class <code>"mle"</code> and then calls
the corresponding <code><a href="stats4.html#topic+profile-methods">profile</a></code>-method
from package <span class="pkg">stats4</span>; for details we confer to the corresponding
man page.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Estimate-class">Estimate-class</a></code>, <code><a href="#topic+MCEstimator">MCEstimator</a></code>, 
<code><a href="#topic+MDEstimator">MDEstimator</a></code>, <code><a href="#topic+MLEstimator">MLEstimator</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

MDEstimator(x, G)
(m &lt;- MLEstimator(x, G))
m.mle &lt;- as(m,"mle")
par(mfrow=c(1,2))
profileM &lt;- profile(m)
## plot-profile throws an error
</code></pre>

<hr>
<h2 id='MCEstimator'> Function to compute minimum criterion estimates </h2><span id='topic+MCEstimator'></span>

<h3>Description</h3>

<p>The function <code>MCEstimator</code> provides a general way to compute 
estimates for a given parametric family of probability measures which 
can be obtain by minimizing a certain criterion. For instance, 
the negative log-Likelihood in case of the maximum likelihood
estimator or some distance between distributions like in 
case of minimum distance estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCEstimator(x, ParamFamily, criterion, crit.name, 
            startPar = NULL, Infos, trafo = NULL, 
            penalty = 1e20, validity.check = TRUE, asvar.fct, na.rm = TRUE,
            ..., .withEvalAsVar = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCEstimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_paramfamily">ParamFamily</code></td>
<td>
<p> object of class <code>"ParamFamily"</code> </p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_criterion">criterion</code></td>
<td>
<p> function: criterion to minimize; see Details section. </p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_crit.name">crit.name</code></td>
<td>
<p> optional name for criterion. </p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_startpar">startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is 
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_penalty">penalty</code></td>
<td>
<p>(non-negative) numeric: penalizes non valid parameter-values</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_validity.check">validity.check</code></td>
<td>
<p>logical: shall return parameter value be checked for
validity? Defaults to yes (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_asvar.fct">asvar.fct</code></td>
<td>
<p>optionally: a function to determine the corresponding
asymptotic variance; if given, <code>asvar.fct</code> takes arguments
<code>L2Fam</code>((the parametric model as object of class <code>L2ParamFamily</code>)) 
and <code>param</code> (the parameter value as object of class 
<code>ParamFamParameter</code>); arguments are called by name; <code>asvar.fct</code>
may also process further arguments passed through the <code>...</code> argument</p>
</td></tr>              
<tr><td><code id="MCEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_...">...</code></td>
<td>
<p> further arguments to <code>criterion</code> or <code>optimize</code>
or <code>optim</code>, respectively. </p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical: shall slot <code>asVar</code> be evaluated
(if <code>asvar.fct</code> is given) or
just the call be returned?</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_nmsffx">nmsffx</code></td>
<td>
<p>character: a potential suffix to be appended to the estimator name.</p>
</td></tr>
<tr><td><code id="MCEstimator_+3A_.with.checkestclassforparamfamily">.with.checkEstClassForParamFamily</code></td>
<td>
<p>logical: Should a the end of the
function <code>.checkEstClassForParamFamily</code>; defaults to <code>TRUE</code>;
can be switched off for computational time or because this is already
checked in a calling wrapper function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>criterion</code> has to be a function with arguments the 
empirical data as well as an object of class <code>"Distribution"</code> 
and possibly <code>...</code>. Uses <code><a href="#topic+mceCalc">mceCalc</a></code>
for method dispatch.
</p>


<h3>Value</h3>

<p>An object of S4-class <code>"MCEstimate"</code> which inherits from class 
<code>"Estimate"</code>.
</p>


<h3>Note</h3>

<p>The criterion function may be called together with a parameter <code>thetaPar</code>
which is the current parameter value under consideration, i.e.; the value
under which the model distribution is considered. Hence, if desired,
particular criterion functions could make use of this information, by, say
computing the criterion differently for different parameter values.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code>, <code><a href="#topic+ParamFamily">ParamFamily</a></code>, 
<code><a href="#topic+MCEstimate-class">MCEstimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

## Maximum Likelihood estimator
## Note: you can directly use function MLEstimator!
negLoglikelihood &lt;- function(x, Distribution){
    res &lt;- -sum(log(Distribution@d(x)))
    names(res) &lt;- "Negative Log-Likelihood"
    return(res)
}
MCEstimator(x = x, ParamFamily = G, criterion = negLoglikelihood)

## Kolmogorov(-Smirnov) minimum distance estimator
## Note: you can also use function MDEstimator!
MCEstimator(x = x, ParamFamily = G, criterion = KolmogorovDist, 
            crit.name = "Kolmogorov distance")

## Total variation minimum distance estimator
## Note: you can also use function MDEstimator!
## discretize Gamma distribution

## IGNORE_RDIFF_BEGIN
MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist,
            crit.name = "Total variation distance")
## IGNORE_RDIFF_END

## or smooth empirical distribution (takes some time!)
#MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist, 
#            asis.smooth.discretize = "smooth", crit.name = "Total variation distance")

## Hellinger minimum distance estimator
## Note: you can also use function MDEstimator!
## discretize Gamma distribution
distroptions(DistrResolution = 1e-8)
MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
            crit.name = "Hellinger Distance", startPar = c(1,2))
distroptions(DistrResolution = 1e-6)

## or smooth empirical distribution (takes some time!)
#MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
#            asis.smooth.discretize = "smooth", crit.name = "Hellinger distance")
</code></pre>

<hr>
<h2 id='MDEstimator'> Function to compute minimum distance estimates </h2><span id='topic+MDEstimator'></span><span id='topic+CvMMDEstimator'></span><span id='topic+KolmogorovMDEstimator'></span><span id='topic+TotalVarMDEstimator'></span><span id='topic+HellingerMDEstimator'></span><span id='topic+CvMDist2'></span>

<h3>Description</h3>

<p>The function <code>MDEstimator</code> provides a general way to compute 
minimum distance estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDEstimator(x, ParamFamily, distance = KolmogorovDist, dist.name, 
            paramDepDist = FALSE, startPar = NULL, Infos, trafo = NULL,
            penalty = 1e20, validity.check = TRUE, asvar.fct, na.rm = TRUE,
            ..., .withEvalAsVar = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
CvMMDEstimator(x, ParamFamily, muDatOrMod = c("Mod","Dat", "Other"),
            mu = NULL, paramDepDist = FALSE, startPar = NULL, Infos,
            trafo = NULL, penalty = 1e20, validity.check = TRUE, 
            asvar.fct = .CvMMDCovariance, na.rm = TRUE, ...,
            .withEvalAsVar = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
KolmogorovMDEstimator(x, ParamFamily, paramDepDist = FALSE, startPar = NULL, Infos, 
            trafo = NULL, penalty = 1e20, validity.check = TRUE, asvar.fct, 
            na.rm = TRUE, ..., .withEvalAsVar = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
TotalVarMDEstimator(x, ParamFamily, paramDepDist = FALSE, startPar = NULL, Infos, 
            trafo = NULL, penalty = 1e20, validity.check = TRUE, asvar.fct, 
            na.rm = TRUE, ..., .withEvalAsVar = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
HellingerMDEstimator(x, ParamFamily, paramDepDist = FALSE, startPar = NULL, Infos, 
            trafo = NULL, penalty = 1e20, validity.check = TRUE, asvar.fct, 
            na.rm = TRUE, ..., .withEvalAsVar = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
CvMDist2(e1,e2,... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MDEstimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_paramfamily">ParamFamily</code></td>
<td>
<p> object of class <code>"ParamFamily"</code> </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_distance">distance</code></td>
<td>
<p> (generic) function: to compute distance beetween (emprical)
data and objects of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_dist.name">dist.name</code></td>
<td>
<p> optional name of distance </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_mudatormod">muDatOrMod</code></td>
<td>
<p> a character string specifying whether
as integration measure <code class="reqn">mu</code> in Cramer-von-Mises distance,
the empirical cdf (corresponding to argument value
<code>"Dat"</code>) or the current model distribution
(corresponding to argument value <code>"Mod"</code>) or a given
integration (probability) measure / distribution <code>mu</code>
(corresponding to argument value <code>"Other"</code>) is to be used;
must be one of &quot;Dat&quot; (default) or &quot;Mod&quot; or &quot;Other&quot;.
You can specify just the initial letter; the default is <code>"Mod"</code>.</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_mu">mu</code></td>
<td>
<p> optional integration (probability) measure for CvM MDE.
defaults to <code>NULL</code> and is ignored in options
<code>muDatOrMod</code> in <code>"Dat"</code> and <code>"Mod"</code>;
in case <code>"Other"</code>, it must be of class
<code>UnivariateDistribution</code>. </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_paramdepdist">paramDepDist</code></td>
<td>
<p>logical; will computation of distance be parameter
dependent (see also note below)? if <code>TRUE</code>, distance function
must be able to digest a parameter <code>thetaPar</code>; otherwise
this parameter will be eliminated if present in <code>...</code>-argument.</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_startpar">startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is 
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_penalty">penalty</code></td>
<td>
<p>(non-negative) numeric: penalizes non valid parameter-values</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_validity.check">validity.check</code></td>
<td>
<p>logical: shall return parameter value be checked for
validity? Defaults to yes (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_asvar.fct">asvar.fct</code></td>
<td>
<p>optionally: a function to determine the corresponding
asymptotic variance; if given, <code>asvar.fct</code> takes arguments
<code>L2Fam</code>((the parametric model as object of class <code>L2ParamFamily</code>)) 
and <code>param</code> (the parameter value as object of class 
<code>ParamFamParameter</code>); arguments are called by name; <code>asvar.fct</code>
may also process further arguments passed through the <code>...</code> argument</p>
</td></tr>              
<tr><td><code id="MDEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_...">...</code></td>
<td>
<p> for the estimators: further arguments to <code>criterion</code> or <code>optimize</code>
or <code>optim</code>, respectively; for <code>CvMDist2</code>,
these can be used e.g. by <code>E()</code>. </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical: shall slot <code>asVar</code> be evaluated
(if <code>asvar.fct</code> is given) or
just the call be returned?</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_nmsffx">nmsffx</code></td>
<td>
<p>character: a potential suffix to be appended to the estimator name.</p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_e1">e1</code></td>
<td>
<p>object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_e2">e2</code></td>
<td>
<p>object of class <code>"Distribution"</code> </p>
</td></tr>
<tr><td><code id="MDEstimator_+3A_.with.checkestclassforparamfamily">.with.checkEstClassForParamFamily</code></td>
<td>
<p>logical: Should a the end of the
function <code>.checkEstClassForParamFamily</code>; defaults to <code>TRUE</code>;
can be switched off for computational time or because this is already
checked in a calling wrapper function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>distance</code> has to be a (generic) function with arguments 
the empirical data as well as an object of class <code>"Distribution"</code> 
and possibly <code>...</code>; e.g. <code>KolmogorovDist</code> (default), 
<code>TotalVarDist</code> or <code>HellingerDist</code>. Uses <code><a href="#topic+mceCalc">mceCalc</a></code>
for method dispatch.
</p>
<p>The functions <code>CvMMDEstimator</code>, <code>KolmogorovMDEstimator</code>,
<code>TotalVarMDEstimator</code>, and <code>HellingerMDEstimator</code> are aliases
where the distance is fixed. More specifically, <code>CvMMDEstimator</code>
uses Cramer-von-Mises distance, see <code><a href="distrEx.html#topic+CvMDist">CvMDist</a></code>
with integration measure <code class="reqn">mu</code> either
equal to the empirical cdf or to the current best fitting model distribution;
the alternative is selected by argument <code>muDatOrMod</code>).
As it is asymptotically linear, asymptotic variances are available.
In case of alternative <code>"Dat"</code>, this variance is computed by means
of helper function <code>.CvMMDCovarianceWithMux</code>, case of alternative
<code>"Mod"</code> we use helper function <code>.CvMMDCovariance</code>. In both
case one may use these helper function to get hand on the respective
influence function. For covariances computed by <code>.CvMMDCovariance</code>,
diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>
<p><code>KolmogorovMDEstimator</code> uses Kolmogorov distance, see
<code><a href="distrEx.html#topic+KolmogorovDist">KolmogorovDist</a></code>, <code>TotalVarMDEstimator</code>,
uses total variation distance, see <code><a href="distrEx.html#topic+TotalVarDist">TotalVarDist</a></code>
and <code>HellingerMDEstimator</code>
uses Hellinger distance, see <code><a href="distrEx.html#topic+HellingerDist">HellingerDist</a></code>.
</p>
<p>Function <code>CvMDist2</code> calls <code><a href="distrEx.html#topic+CvMDist">CvMDist</a></code> and
computes the Cramer-von-Mises distance between
distributions <code>e1</code> and <code>e2</code> with integration
measure <code>mu</code> equal to <code>e2</code>; it is used in alternative
<code>"Mod"</code> in <code>CvMMDEstimator</code>.
</p>


<h3>Value</h3>

<p>The estimators return an object of S4-class <code>"MCEstimate"</code> which inherits from class
<code>"Estimate"</code>. <code>CvMDist2</code> returns the respective distance.
</p>


<h3>Theoretical Background</h3>

<p>It should be noted that <code>CvMMDEstimator</code>
results in an asymptotically linear (hence asymptotically normal) estimator
with an influence function which is always bounded;
<code>HellingerMDEstimator</code> adapts, for growing sample size,
the MLE estimator, hence is asymptotically efficient, while for finite
sample size is bias robust. <code>KolmogorovMDEstimator</code> is square-root-n
consistent but, due to the facetted level sets of the distance fails to
be asymptotically normal. In the terminology of Donoho/Liu,
<code>TotalVarMDEstimator</code> and <code>HellingerMDEstimator</code> rely on
strong distances, while <code>CvMMDEstimator</code> and
<code>KolmogorovMDEstimator</code> use weak distances, so the latter ensure
protection against larger classes of contamination (simply because the
distribution balls based on the respective distances contain more elements).
</p>


<h3>Note</h3>

<p>The distance function may be called together with a parameter <code>thetaPar</code>
which is the current parameter value under consideration, i.e.; the value
under which the model distribution is considered. Hence, if desired,
particular distance functions could make use of this information, by, say
computing the distance differently for different parameter values.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Beran, R. (1977). Minimum Hellinger distance estimates for parametric models.
<em>Annals of Statistics</em>, <b>5</b>(3), 445-463.
</p>
<p>Donoho, D.L. and Liu, R.C. (1988). The &quot;automatic&quot; robustness of minimum
distance functionals. <em>Annals of Statistics</em>, <b>16</b>(2), 552-586.
</p>
<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>Parr, W.C. and Schucany, W.R. (1980). Minimum distance and robust estimation.
<em>Journal of the American Statistical Association</em>, <b>75</b>(371),
616-624.
</p>
<p>Rao, P.V., Schuster, E.F., and Littell, R.C. (1975).
Estimation of Shift and Center of Symmetry Based on Kolmogorov-Smirnov
Statistics. <em>Annals of Statistics</em>, <b>3</b>, 862-873.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code>, <code><a href="#topic+ParamFamily">ParamFamily</a></code>, 
<code><a href="#topic+MCEstimator">MCEstimator</a></code>, <code><a href="#topic+MCEstimate-class">MCEstimate-class</a></code>,
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## (empirical) Data
set.seed(123)
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

## Kolmogorov(-Smirnov) minimum distance estimator
MDEstimator(x = x, ParamFamily = G, distance = KolmogorovDist)
## or
KolmogorovMDEstimator(x = x, ParamFamily = G)

## von Mises minimum distance estimator with default mu = Mod
MDEstimator(x = x, ParamFamily = G, distance = CvMDist)


### these examples take too much time for R CMD check --as-cran

## von Mises minimum distance estimator with default mu = Mod
MDEstimator(x = x, ParamFamily = G, distance = CvMDist,
            asvar.fct = .CvMMDCovarianceWithMux)
## or
CvMMDEstimator(x = x, ParamFamily = G)
## or
CvMMDEstimator(x = x, ParamFamily = G, muDatOrMod="Mod")

## or with data based integration measure:
CvMMDEstimator(x = x, ParamFamily = G, muDatOrMod="Dat")

## von Mises minimum distance estimator with mu = N(0,1)
MDEstimator(x = x, ParamFamily = G, distance = CvMDist, mu = Norm())
## or, with asy Var
MDEstimator(x = x, ParamFamily = G, distance = CvMDist, mu = Norm(),
            asvar.fct = function(L2Fam, param, ...){
            .CvMMDCovariance(L2Fam=L2Fam, param=param, mu=Norm(), N = 400)
            } )
## synomymous to
CvMMDEstimator(x = x, ParamFamily = G, muDatOrMod="Other", mu = Norm())

## Total variation minimum distance estimator
## gamma distributions are discretized
MDEstimator(x = x, ParamFamily = G, distance = TotalVarDist)
## or
TotalVarMDEstimator(x = x, ParamFamily = G)
## or smoothing of emprical distribution (takes some time!)
#MDEstimator(x = x, ParamFamily = G, distance = TotalVarDist, asis.smooth.discretize = "smooth")

## Hellinger minimum distance estimator
## gamma distributions are discretized
distroptions(DistrResolution = 1e-10)
MDEstimator(x = x, ParamFamily = G, distance = HellingerDist, startPar = c(1,2))
## or
HellingerMDEstimator(x = x, ParamFamily = G, startPar = c(1,2))
distroptions(DistrResolution = 1e-6) # default
## or smoothing of emprical distribution (takes some time!)
MDEstimator(x = x, ParamFamily = G, distance = HellingerDist, asis.smooth.discretize = "smooth")

</code></pre>

<hr>
<h2 id='meRes'>helper functions for mceCalc and mleCalc</h2><span id='topic+meRes'></span><span id='topic+get.criterion.fct'></span><span id='topic+samplesize+2Cnumeric-method'></span>

<h3>Description</h3>

<p>helper functions to produce consistent lists to be digested 
in functions <code><a href="#topic+mceCalc">mceCalc</a></code> and <code><a href="#topic+mleCalc">mleCalc</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>meRes(x, estimate, criterion.value, param, crit.fct, method = "explicit solution",
      crit.name = "Maximum Likelihood", Infos, warns = "", startPar = NULL,
      optReturn = NULL)
get.criterion.fct(theta, Data, ParamFam, criterion.ff, fun, ...)
## S4 method for signature 'numeric'
samplesize(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meRes_+3A_x">x</code></td>
<td>
<p>numeric; the data at which to evaluate the estimate</p>
</td></tr>
<tr><td><code id="meRes_+3A_estimate">estimate</code></td>
<td>
<p>numeric; the estimate</p>
</td></tr> 
<tr><td><code id="meRes_+3A_criterion.value">criterion.value</code></td>
<td>
<p>numeric; the value of the criterion</p>
</td></tr>
<tr><td><code id="meRes_+3A_param">param</code></td>
<td>
<p>object of class <code>ParamFamParameter</code>; the parameter value</p>
</td></tr> 
<tr><td><code id="meRes_+3A_crit.fct">crit.fct</code></td>
<td>
<p>a function to fill slot <code>minuslogl</code> when an object of 
class <code>MCEstimate</code> is coerced to class <code>mle</code> 
(from package <span class="pkg">stats4</span>); to this end function <code>get.criterion.fct</code>
(also see details below) is helpful (at least if the dimension of the 
estimator is larger than 1).</p>
</td></tr> 
<tr><td><code id="meRes_+3A_method">method</code></td>
<td>
<p>character; describes how the estimate was obtained</p>
</td></tr> 
<tr><td><code id="meRes_+3A_crit.name">crit.name</code></td>
<td>
<p>character; name of the criterion</p>
</td></tr> 
<tr><td><code id="meRes_+3A_infos">Infos</code></td>
<td>
<p>optional matrix of characters in two columns; 
information to be attached to the estimate</p>
</td></tr> 
<tr><td><code id="meRes_+3A_warns">warns</code></td>
<td>
<p>collected warnings in optimization</p>
</td></tr>
<tr><td><code id="meRes_+3A_samplesize">samplesize</code></td>
<td>
<p>numeric; the sample size at which the estimator 
was evaluated</p>
</td></tr>
<tr><td><code id="meRes_+3A_theta">theta</code></td>
<td>
<p>the parameter value as named numeric vector</p>
</td></tr>
<tr><td><code id="meRes_+3A_data">Data</code></td>
<td>
<p>numeric; the data at which to evaluate the MCE</p>
</td></tr>
<tr><td><code id="meRes_+3A_paramfam">ParamFam</code></td>
<td>
<p>an object of class <code>ParamFamily</code>; 
the parametric family at which to evaluate the MCE</p>
</td></tr>
<tr><td><code id="meRes_+3A_criterion.ff">criterion.ff</code></td>
<td>
<p>the criterion function used in the MCE</p>
</td></tr>
<tr><td><code id="meRes_+3A_fun">fun</code></td>
<td>
<p>wrapper to the criterion function used in the MCE
(with certain checking whether parameter value is permitted and possibly
penalizing if not; see code to , for example.)</p>
</td></tr>
<tr><td><code id="meRes_+3A_startpar">startPar</code></td>
<td>
<p>value of argument <code>StartPar</code> &mdash; starting parameter used.</p>
</td></tr>
<tr><td><code id="meRes_+3A_optreturn">optReturn</code></td>
<td>
<p> object of class <code>"ANY"</code>
the return value of the optimizer (or <code>NULL</code> if, e.g.,
closed form solutions are used). </p>
</td></tr>
<tr><td><code id="meRes_+3A_...">...</code></td>
<td>
<p>further arguments to be passed
to <code>optim</code> / <code>optimize</code></p>
</td></tr> 
<tr><td><code id="meRes_+3A_object">object</code></td>
<td>
<p>numeric; the data at which to evaluate the estimate</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p><code>get.criterion.fct</code> produces a function <code>criterion.fct</code> 
to fill slot <code>minuslogl</code> when an object of class <code>MCEstimate</code>
is coerced to class <code>mle</code> (from package <span class="pkg">stats4</span>);
this way we may use profiling methods introduced there also for objects
of our classes. More specifically, we produce a function where all 
coordinates/components of <code>theta</code> appear as separate named 
arguments, which then calls <code>fun</code> with these separate arguments 
again stacked to one (named) vector argument;
</p>
<p><code>samplesize</code> determines the samplesize of argument <code>object</code>,i.e.;
if <code>object</code> has an attribute <code>dim</code>, it returns <code>dim(object)[2]</code>,
else <code>length(object)</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>meRes</code></td>
<td>
<p>a list of prescribed structure to be digested in functions 
<code><a href="#topic+mceCalc">mceCalc</a></code> and <code><a href="#topic+mleCalc">mleCalc</a></code> by the internal helper function 
<code><a href="#topic+.process.meCalcRes">.process.meCalcRes</a></code>.</p>
</td></tr>
<tr><td><code>get.criterion.fct</code></td>
<td>
<p>a function; see details below;</p>
</td></tr>
<tr><td><code>samplesize</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>

<hr>
<h2 id='MLEstimator'> Function to compute maximum likelihood estimates </h2><span id='topic+MLEstimator'></span>

<h3>Description</h3>

<p>The function <code>MLEstimator</code> provides a general way to compute 
maximum likelihood estimates for a given parametric family of 
probability measures. This is done by calling the function 
<code>MCEstimator</code> which minimizes the negative log-Likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLEstimator(x, ParamFamily, startPar = NULL, 
            Infos, trafo = NULL, penalty = 1e20,
            validity.check = TRUE, na.rm = TRUE, ...,
            .withEvalAsVar = TRUE, dropZeroDensity = TRUE, nmsffx = "",
            .with.checkEstClassForParamFamily = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLEstimator_+3A_x">x</code></td>
<td>
<p> (empirical) data </p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_paramfamily">ParamFamily</code></td>
<td>
<p> object of class <code>"ParamFamily"</code> </p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_startpar">startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is 
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_infos">Infos</code></td>
<td>
<p> character: optional informations about estimator </p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_trafo">trafo</code></td>
<td>
<p> an object of class <code>MatrixorFunction</code> &ndash; a transformation
for the main parameter</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_penalty">penalty</code></td>
<td>
<p>(non-negative) numeric: penalizes non valid parameter-values</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_validity.check">validity.check</code></td>
<td>
<p>logical: shall return parameter value be checked for
validity? Defaults to yes (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_...">...</code></td>
<td>
<p> further arguments to <code>criterion</code> or <code>optimize</code>
or <code>optim</code>, respectively. </p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical: shall slot <code>asVar</code> be evaluated
(if <code>asvar.fct</code> is given) or
just the call be returned?</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_dropzerodensity">dropZeroDensity</code></td>
<td>
<p>logical of length 1; shall observations with
density zero be dropped? Optimizers like <code>optim</code> require finite
values, so get problems when negative loglikelihood is evaluated. </p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_nmsffx">nmsffx</code></td>
<td>
<p>character: a potential suffix to be appended to the estimator name.</p>
</td></tr>
<tr><td><code id="MLEstimator_+3A_.with.checkestclassforparamfamily">.with.checkEstClassForParamFamily</code></td>
<td>
<p>logical: Should a the end of the
function <code>.checkEstClassForParamFamily</code>; defaults to <code>TRUE</code>;
can be switched off for computational time or because this is already
checked in a calling wrapper function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code><a href="#topic+mleCalc">mleCalc</a></code>
for method dispatch; this method by default  
calls <code><a href="#topic+mceCalc">mceCalc</a></code> using the negative log-likelihood
as criterion which should be minimized. 
</p>


<h3>Value</h3>

<p>An object of S4-class <code>"MCEstimate"</code> which inherits from class 
<code>"Estimate"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code>, <code><a href="#topic+ParamFamily">ParamFamily</a></code>, 
<code><a href="#topic+MCEstimator">MCEstimator</a></code>, <code><a href="#topic+MCEstimate-class">MCEstimate-class</a></code>,
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>, <code><a href="stats4.html#topic+mle">mle</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################
## 1. Binomial data
#############################
## (empirical) data
# seed for reproducibility:
set.seed(20200306)
x &lt;- rbinom(100, size=25, prob=.25)

## ML-estimate
MLEstimator(x, BinomFamily(size = 25))


#############################
## 2. Poisson data
#############################
## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))

## ML-estimate
MLEstimator(x, PoisFamily())


#############################
## 3. Normal (Gaussian) location and scale
#############################
## (empirical) data
# seed for reproducibility:
set.seed(20200306)
x &lt;- rnorm(100)

## ML-estimate
MLEstimator(x, NormLocationScaleFamily())
## compare:
c(mean(x),sd(x))


#############################
## 4. Gamma model
#############################
## (empirical) data
# seed for reproducibility:
set.seed(20200306)
x &lt;- rgamma(50, scale = 0.5, shape = 3)

## parametric family of probability measures
G &lt;- GammaFamily(scale = 1, shape = 2)

## Maximum likelihood estimator
(res &lt;- MLEstimator(x = x, ParamFamily = G))

## Asymptotic (CLT-based) confidence interval
confint(res)

## some profiling
par(mfrow=c(1,2))
plot(profile(res))
par(mfrow=c(1,1))

## implementation of ML-estimator of package MASS
require(MASS)
(res1 &lt;- fitdistr(x, "gamma"))

## comparison
## shape
estimate(res)[2]
## rate
1/estimate(res)[1]

## minor differences due to the fact that by default, fitdistr uses
## BFGS, while we use Nelder-Mead instead

## log-likelihood
res1$loglik
## negative log-likelihood
criterion(res)


## explicitely transforming to
## MASS parametrization:
mtrafo &lt;- function(x){
     nms0 &lt;- names(c(main(param(G)),nuisance(param(G))))
     nms &lt;- c("shape","rate")
     fval0 &lt;- c(x[2], 1/x[1])
     names(fval0) &lt;- nms
     mat0 &lt;- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
                     dimnames = list(nms,nms0))                          
     list(fval = fval0, mat = mat0)}

G2 &lt;- G
trafo(G2) &lt;- mtrafo
res2 &lt;- MLEstimator(x = x, ParamFamily = G2)

old &lt;- getdistrModOption("show.details")
distrModoptions("show.details" = "minimal")
res1
res2

## some profiling
par(mfrow=c(1,2))
plot(profile(res2))
par(mfrow=c(1,1))

#############################
## 5. Cauchy Location Scale model
#############################
(C &lt;- CauchyLocationScaleFamily())
loc.true &lt;- 1
scl.true &lt;- 2

## (empirical) data
# seed for reproducibility:
set.seed(20200306)
x &lt;- rcauchy(50, location = loc.true, scale = scl.true)

## Maximum likelihood estimator
(res &lt;- MLEstimator(x = x, ParamFamily = C))
## Asymptotic (CLT-based) confidence interval
confint(res)

</code></pre>

<hr>
<h2 id='modifyModel-methods'> Methods for function modifyModel in Package &lsquo;distrMod&rsquo; </h2><span id='topic+modifyModel-methods'></span><span id='topic+modifyModel'></span><span id='topic+modifyModel+2CParamFamily+2CParamFamParameter-method'></span><span id='topic+modifyModel+2CL2ParamFamily+2CParamFamParameter-method'></span><span id='topic+modifyModel+2CL2LocationFamily+2CParamFamParameter-method'></span><span id='topic+modifyModel+2CL2ScaleFamily+2CParamFamParameter-method'></span><span id='topic+modifyModel+2CL2LocationScaleFamily+2CParamFamParameter-method'></span><span id='topic+modifyModel+2CGammaFamily+2CParamFamParameter-method'></span><span id='topic+modifyModel+2CExpScaleFamily+2CParamFamParameter-method'></span>

<h3>Description</h3>

<p>Methods for function <code>modifyModel</code> in package <span class="pkg">distrMod</span>;
<code>modifyModel</code> moves a model from one parameter value to
another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyModel(model, param,...)
## S4 method for signature 'ParamFamily,ParamFamParameter'
modifyModel(model,param, 
                       .withCall = TRUE, ...)
## S4 method for signature 'L2ParamFamily,ParamFamParameter'
modifyModel(model,param, 
                       .withCall = TRUE, .withL2derivDistr = TRUE, ...)
## S4 method for signature 'L2LocationFamily,ParamFamParameter'
modifyModel(model,param, ...)
## S4 method for signature 'L2ScaleFamily,ParamFamParameter'
modifyModel(model,param, ...)
## S4 method for signature 'L2LocationScaleFamily,ParamFamParameter'
modifyModel(model,
                       param, ...)
## S4 method for signature 'GammaFamily,ParamFamParameter'
modifyModel(model,param, ...)
## S4 method for signature 'ExpScaleFamily,ParamFamParameter'
modifyModel(model,param, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyModel-methods_+3A_model">model</code></td>
<td>
<p>an object of class <code>ParamFamily</code>  &mdash; the model to move.</p>
</td></tr>
<tr><td><code id="modifyModel-methods_+3A_param">param</code></td>
<td>
<p>an object of class <code>ParamFamParameter</code> &mdash; the parameter to move to.</p>
</td></tr>
<tr><td><code id="modifyModel-methods_+3A_.withcall">.withCall</code></td>
<td>
<p>logical: shall slot <code>fam.call</code> be updated?</p>
</td></tr>
<tr><td><code id="modifyModel-methods_+3A_.withl2derivdistr">.withL2derivDistr</code></td>
<td>
<p>logical: shall slot <code>L2derivDistr</code> be updated or
just the call to do the updated be stored?</p>
</td></tr>
<tr><td><code id="modifyModel-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods; not used so far</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modifyModel</code> is merely used internally for moving
the model along modified parameter values during a model
fit.
</p>
<p>It generally simply copies the original model and only
modifies the affected slots, i.e. 
<code>distribution</code>, the distribution of the observations,
<code>param</code>, the parameter,
<code>L2deriv</code>, the L2-derivative at the parameter,
<code>L2FisherInfo</code>, the Fisher information at the parameter,
the symmetry slots <code>distrSymm</code>, <code>L2derivSymm</code>, and 
<code>L2derivDistrSymm</code>,
and, finally, <code>L2derivDistr</code> the (marginal) distribution(s)
of the L2derivative. By default, also slot  <code>fam.call</code> is updated.
</p>
<p>In case <code>model</code> is of class <code>L2LocationFamily</code>,
<code>L2ScaleFamily</code>, or <code>L2LocationScaleFamily</code>,
symmetry slots are updated to be centered about the 
median of the (central) distribution (assuming the latter is
symmetric about the median); as an intermediate step, these methods
call the general <code>modifyModel</code>-method for signature <code>L2ParamFamily</code>;
in this call, however, slot <code>fam.call</code> is not updated (this is
the reason for argument <code>.withCall</code>); this is then
done in the individual parts of the corresponding method.
</p>


<h3>Value</h3>

<p>a corresponding instance of the model in argument <code>model</code> with moved
parameters.
</p>

<hr>
<h2 id='NbinomFamily'>Generating function for Nbinomial families</h2><span id='topic+NbinomFamily'></span><span id='topic+NbinomwithSizeFamily'></span><span id='topic+NbinomMeanSizeFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ParamFamily"</code> which
represents a Nbinomial family where the probability of
success is the parameter of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NbinomFamily(size = 1, prob = 0.5, trafo)
NbinomwithSizeFamily(size = 1, prob = 0.5, trafo, withL2derivDistr = TRUE)
NbinomMeanSizeFamily(size = 1, mean = 0.5, trafo, withL2derivDistr = TRUE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NbinomFamily_+3A_size">size</code></td>
<td>
<p> number of trials </p>
</td></tr>
<tr><td><code id="NbinomFamily_+3A_prob">prob</code></td>
<td>
<p> probability of success </p>
</td></tr>
<tr><td><code id="NbinomFamily_+3A_mean">mean</code></td>
<td>
<p> alternative parameter for negative binomial parameter</p>
</td></tr>
<tr><td><code id="NbinomFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
<tr><td><code id="NbinomFamily_+3A_withl2derivdistr">withL2derivDistr</code></td>
<td>
<p>logical: shall the distribution of the L2 derivative
be computed? Defaults to <code>TRUE</code>; setting it to <code>FALSE</code>
speeds up computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
<code>NbinomFamily</code> assumes <code>size</code> to be known; while
for <code>NbinomwithSizeFamily</code> it is a second (unknown) parameter;
for <code>NbinomMeanSizeFamily</code> is like <code>NbinomwithSizeFamily</code>
but uses the <code>size,mean</code> parametrization instead of the
<code>size,prob</code> one.  
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the 
Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010). 
R Package distrMod: S4 Classes and Methods for
Probability Models. To appear in Journal of Statistical Software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Nbinom-class">Nbinom-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(N1 &lt;- NbinomFamily(size = 25, prob = 0.25))
plot(N1)
FisherInfo(N1)
checkL2deriv(N1)
(N1.w &lt;- NbinomwithSizeFamily(size = 25, prob = 0.25))
plot(N1.w)
FisherInfo(N1.w)
checkL2deriv(N1.w)
(N2.w &lt;- NbinomMeanSizeFamily(size = 25, mean = 75))
plot(N2.w)
FisherInfo(N2.w)
checkL2deriv(N2.w)

</code></pre>

<hr>
<h2 id='negativeBias'>Generating function for onesidedBias-class</h2><span id='topic+negativeBias'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"onesidedBias"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negativeBias(name = "negative Bias")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="negativeBias_+3A_name">name</code></td>
<td>
<p> name of the bias type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"onesidedBias"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onesidedBias-class">onesidedBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>negativeBias()

## The function is currently defined as
function(){ new("onesidedBias", name = "negative Bias", sign = -1) }
</code></pre>

<hr>
<h2 id='NonSymmetric'>Generating function for NonSymmetric-class</h2><span id='topic+NonSymmetric'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"NonSymmetric"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonSymmetric()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"NonSymmetric"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+NonSymmetric-class">NonSymmetric-class</a></code>, <code><a href="#topic+FunctionSymmetry-class">FunctionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>NonSymmetric()

## The function is currently defined as
function(){ new("NonSymmetric") }
</code></pre>

<hr>
<h2 id='NonSymmetric-class'>Class for Non-symmetric Functions</h2><span id='topic+NonSymmetric-class'></span>

<h3>Description</h3>

<p>Class for non-symmetric functions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("NonSymmetric")</code>.
More frequently they are created via the generating function 
<code>NonSymmetric</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
contains &ldquo;non-symmetric function&rdquo; </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"NULL"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"FunctionSymmetry"</code>, directly.<br />
Class <code>"Symmetry"</code>, by class <code>"FunctionSymmetry"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+NonSymmetric">NonSymmetric</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("NonSymmetric")
</code></pre>

<hr>
<h2 id='norm'>Norm functions</h2><span id='topic+EuclideanNorm'></span><span id='topic+QuadFormNorm'></span>

<h3>Description</h3>

<p>Functions to determine certain norms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EuclideanNorm(x)
QuadFormNorm(x,A)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_+3A_x">x</code></td>
<td>
<p>vector or matrix; norm is determined columnwise</p>
</td></tr>
<tr><td><code id="norm_+3A_a">A</code></td>
<td>
<p>pos. semidefinite Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the columnwise evaluated norms</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+onesidedBias-class">onesidedBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mm &lt;- matrix(rnorm(20),2,10)
EuclideanNorm(mm)
QuadFormNorm(mm, A = PosSemDefSymmMatrix(matrix(c(3,1,1,1),2,2)))
</code></pre>

<hr>
<h2 id='NormLocationFamily'>Generating function for normal location families</h2><span id='topic+NormLocationFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationFamily"</code> which
represents a normal location family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormLocationFamily(mean = 0, sd = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormLocationFamily_+3A_mean">mean</code></td>
<td>
<p> mean </p>
</td></tr>
<tr><td><code id="NormLocationFamily_+3A_sd">sd</code></td>
<td>
<p> standard deviation </p>
</td></tr>
<tr><td><code id="NormLocationFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Norm-class">Norm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(N1 &lt;- NormLocationFamily())
plot(N1)
L2derivDistr(N1)
</code></pre>

<hr>
<h2 id='NormLocationScaleFamily'>Generating function for normal location and scale families</h2><span id='topic+NormLocationScaleFamily'></span><span id='topic+NormFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> which
represents a normal location and scale family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormLocationScaleFamily(mean = 0, sd = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormLocationScaleFamily_+3A_mean">mean</code></td>
<td>
<p> mean </p>
</td></tr>
<tr><td><code id="NormLocationScaleFamily_+3A_sd">sd</code></td>
<td>
<p> standard deviation </p>
</td></tr>
<tr><td><code id="NormLocationScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Norm-class">Norm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(N1 &lt;- NormLocationScaleFamily())
## synonymous: N1 &lt;- NormFamily()
plot(N1)
FisherInfo(N1)
checkL2deriv(N1)
</code></pre>

<hr>
<h2 id='NormLocationUnknownScaleFamily'>Generating function for normal location families with unknown scale as nuisance</h2><span id='topic+NormLocationUnknownScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> which
represents a normal location family with unknown scale as nuisance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormLocationUnknownScaleFamily(mean = 0, sd = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormLocationUnknownScaleFamily_+3A_mean">mean</code></td>
<td>
<p> mean </p>
</td></tr>
<tr><td><code id="NormLocationUnknownScaleFamily_+3A_sd">sd</code></td>
<td>
<p> standard deviation </p>
</td></tr>
<tr><td><code id="NormLocationUnknownScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Norm-class">Norm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(N1 &lt;- NormLocationUnknownScaleFamily())
plot(N1)
FisherInfo(N1)
checkL2deriv(N1)
</code></pre>

<hr>
<h2 id='NormScaleFamily'>Generating function for normal scale families</h2><span id='topic+NormScaleFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ScaleFamily"</code> which
represents a normal scale family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormScaleFamily(sd = 1, mean = 0, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormScaleFamily_+3A_sd">sd</code></td>
<td>
<p> standard deviation </p>
</td></tr>
<tr><td><code id="NormScaleFamily_+3A_mean">mean</code></td>
<td>
<p> mean </p>
</td></tr>
<tr><td><code id="NormScaleFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Norm-class">Norm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(N1 &lt;- NormScaleFamily())
plot(N1)
FisherInfo(N1)
checkL2deriv(N1)
</code></pre>

<hr>
<h2 id='NormScaleUnknownLocationFamily'>Generating function for normal scale families with unknown location as nuisance</h2><span id='topic+NormScaleUnknownLocationFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2LocationScaleFamily"</code> which
represents a normal scale family with unknown location as nuisance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormScaleUnknownLocationFamily(sd = 1, mean = 0, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormScaleUnknownLocationFamily_+3A_mean">mean</code></td>
<td>
<p> mean </p>
</td></tr>
<tr><td><code id="NormScaleUnknownLocationFamily_+3A_sd">sd</code></td>
<td>
<p> standard deviation </p>
</td></tr>
<tr><td><code id="NormScaleUnknownLocationFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2LocationScaleFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Norm-class">Norm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(N1 &lt;- NormScaleUnknownLocationFamily())
plot(N1)
FisherInfo(N1)
checkL2deriv(N1)
</code></pre>

<hr>
<h2 id='NormType'>Generating function for NormType-class</h2><span id='topic+NormType'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"NormType"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormType(name = "EuclideanNorm", fct = EuclideanNorm)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormType_+3A_name">name</code></td>
<td>
<p> slot <code>name</code> of the class</p>
</td></tr>
<tr><td><code id="NormType_+3A_fct">fct</code></td>
<td>
<p>  slot <code>fct</code> of the class </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"NormType"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NormType-class">NormType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
NormType()
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='NormType-class'>Norm Type</h2><span id='topic+NormType-class'></span><span id='topic+name+2CNormType-method'></span><span id='topic+name+3C-+2CNormType-method'></span><span id='topic+fct'></span><span id='topic+fct+3C-'></span><span id='topic+fct+2CNormType-method'></span><span id='topic+fct+3C-+2CNormType-method'></span>

<h3>Description</h3>

<p>Class of norm types.</p>


<h3>Objects from the Class</h3>

<p>Could be generated by <code>new("NormType")</code>; more frequently one will use
the generating function <code><a href="#topic+NormType">NormType</a></code></p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>fct</code></dt><dd><p>Object of class <code>"function"</code> &mdash; the norm to be evaluated.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "NormType")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "NormType", value = "character")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
<dt>fct</dt><dd><p><code>signature(object = "NormType")</code>: 
accessor function for slot <code>fct</code>. </p>
</dd>
<dt>fct&lt;-</dt><dd><p><code>signature(object = "NormType", value = "function")</code>: 
replacement function for slot <code>fct</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiasType-class">BiasType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
EuclNorm &lt;- NormType("EuclideanNorm",EuclideanNorm)
fct(EuclNorm)
name(EuclNorm)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='OddSymmetric'>Generating function for OddSymmetric-class</h2><span id='topic+OddSymmetric'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"OddSymmetric"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>OddSymmetric(SymmCenter = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OddSymmetric_+3A_symmcenter">SymmCenter</code></td>
<td>
<p> numeric: center of symmetry </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"OddSymmetric"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+OddSymmetric-class">OddSymmetric-class</a></code>, <code><a href="#topic+FunctionSymmetry-class">FunctionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>OddSymmetric()

## The function is currently defined as
function(SymmCenter = 0){ 
    new("OddSymmetric", SymmCenter = SymmCenter) 
}
</code></pre>

<hr>
<h2 id='OddSymmetric-class'>Class for Odd Functions</h2><span id='topic+OddSymmetric-class'></span>

<h3>Description</h3>

<p>Class for odd functions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("OddSymmetric")</code>.
More frequently they are created via the generating function 
<code>OddSymmetric</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
contains &ldquo;odd function&rdquo; </p>
</dd>
<dt><code>SymmCenter</code></dt><dd><p>Object of class <code>"numeric"</code>:
center of symmetry </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"FunctionSymmetry"</code>, directly.<br />
Class <code>"Symmetry"</code>, by class <code>"FunctionSymmetry"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+OddSymmetric">OddSymmetric</a></code>, <code><a href="#topic+FunctionSymmetry-class">FunctionSymmetry-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("OddSymmetric")
</code></pre>

<hr>
<h2 id='onesidedBias-class'>onesided Bias Type</h2><span id='topic+onesidedBias-class'></span><span id='topic+sign'></span><span id='topic+sign+3C-'></span><span id='topic+sign+2ConesidedBias-method'></span><span id='topic+sign+3C-+2ConesidedBias-method'></span>

<h3>Description</h3>

<p>Class of onesided bias types.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("onesidedBias", ...)</code>.
More frequently they are created via the generating function 
<code>positiveBias</code> or   <code>negativeBias</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>sign</code></dt><dd><p>Object of class <code>"numeric"</code>; 
to be in {-1,1} &mdash; whether bias is to be positive or negative</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>sign</dt><dd><p><code>signature(object = "onesidedBias")</code>: 
accessor function for slot <code>sign</code>. </p>
</dd>
<dt>sign&lt;-</dt><dd><p><code>signature(object = "onesidedBias", value = "numeric")</code>: 
replacement function for slot <code>sign</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"BiasType"</code>, directly.<br />
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiasType-class">BiasType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>positiveBias()
## The function is currently defined as
function(){ new("onesidedBias", name = "positive Bias", sign = 1) }

negativeBias()
## The function is currently defined as
function(){ new("onesidedBias", name = "negative Bias", sign = -1) }

pB &lt;- positiveBias()
sign(pB)
try(sign(pB) &lt;- -2) ## error
sign(pB) &lt;- -1
</code></pre>

<hr>
<h2 id='ParamFamily'>Generating function for ParamFamily-class</h2><span id='topic+ParamFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"ParamFamily"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParamFamily(name, distribution = Norm(), distrSymm, modifyParam,
            main = main(param), nuisance = nuisance(param),
            fixed = fixed(param), trafo = trafo(param),
            param = ParamFamParameter(name = paste("Parameter of", 
                          name),  main = main, nuisance = nuisance, 
                                  fixed = fixed, trafo = trafo),
            props = character(0),
            startPar = NULL, makeOKPar = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ParamFamily_+3A_name">name</code></td>
<td>
<p> character string: name of family </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_distribution">distribution</code></td>
<td>
<p> object of class <code>"Distribution"</code>: 
member of the family </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_distrsymm">distrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_startpar">startPar</code></td>
<td>
<p><code>startPar</code> is a function in the observations <code>x</code>
returning initial information for <code>MCEstimator</code> used 
by <code>optimize</code> resp. <code>optim</code>; i.e; if (total) parameter is of 
length 1, <code>startPar</code> returns a search interval, else it returns an initial 
parameter value.</p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_makeokpar">makeOKPar</code></td>
<td>
<p><code>makeOKPar</code> is a function in the (total)
parameter <code>param</code>; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one; if <code>NULL</code>
slot <code>makeOKPar</code> of <code>ParamFamily</code> is used to produce it.</p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_main">main</code></td>
<td>
<p> numeric vector: main parameter </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_nuisance">nuisance</code></td>
<td>
<p> numeric vector: nuisance parameter </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_fixed">fixed</code></td>
<td>
<p> numeric vector: fixed part of the parameter </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_param">param</code></td>
<td>
<p> object of class <code>"ParamFamParameter"</code>:
parameter of the family </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_modifyparam">modifyParam</code></td>
<td>
<p> function: mapping from the parameter space 
(represented by <code>"param"</code>) to the distribution space 
(represented by <code>"distribution"</code>). </p>
</td></tr>
<tr><td><code id="ParamFamily_+3A_props">props</code></td>
<td>
<p> character vector: properties of the family </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;&quot;parametric family of probability measures&quot;&rdquo; is used. 
In case <code>distrSymm</code> is missing it is set to <code>NoSymmetry()</code>.
If <code>param</code> is missing, the parameter is created via
<code>main</code>, <code>nuisance</code> and <code>trafo</code> as described
in <code><a href="#topic+ParamFamParameter">ParamFamParameter</a></code>.
One has to specify a function which represents a mapping
from the parameter space to the corresponding distribution
space; e.g., in case of normal location a simple version of such
a function would be <code>function(theta){ Norm(mean = theta) }</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ParamFamily-class">ParamFamily-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## "default" (normal location)
F1 &lt;- ParamFamily(modifyParam = function(theta){ Norm(mean = theta) })
plot(F1)

################################
## Some examples:
################################
## 1. Normal location family
theta &lt;- 0
names(theta) &lt;- "mean"
NL &lt;- ParamFamily(name = "Normal location family",
          param = ParamFamParameter(name = "location parameter", main = theta),
          distribution = Norm(mean = 0, sd = 1), ## sd known!
          startPar = function(x,...) c(min(x),max(x)),
          distrSymm &lt;- SphericalSymmetry(SymmCenter = 0),
          modifyParam = function(theta){ Norm(mean = theta, sd = 1) },
          props = paste(c("The normal location family is invariant under",
                    "the group of transformations 'g(x) = x + mean'",
                    "with location parameter 'mean'"), collapse = " "))
NL

## 2. Normal scale family
theta &lt;- 1
names(theta) &lt;- "sd"
NS &lt;- ParamFamily(name = "Normal scale family",
          param = ParamFamParameter(name = "scale parameter", main = theta,
          .returnClsName = "ParamWithScaleFamParameter"),
          distribution = Norm(mean = 0, sd = 1), ## mean known!
          startPar = function(x,...) c(0,-min(x)+max(x)),
          distrSymm &lt;- SphericalSymmetry(SymmCenter = 0),
          modifyParam = function(theta){ Norm(mean = 0, sd = theta) },
          props = paste(c("The normal scale family is invariant under",
                    "the group of transformations 'g(y) = sd*y'",
                    "with scale parameter 'sd'"), collapse = " "))
NS

## 3. Normal location and scale family
theta &lt;- c(0, 1)
names(theta) &lt;- c("mean", "sd")
NLS &lt;- ParamFamily(name = "Normal location and scale family",
          param = ParamFamParameter(name = "location and scale parameter",
                                    main = theta,
                                 .returnClsName = "ParamWithScaleFamParameter"),
          distribution = Norm(mean = 0, sd = 1),
          startPar = function(x,...) c(median(x),mad(x)),
          makeOKPar = function(param) {param[2]&lt;-abs(param[2]); return(param)},
          distrSymm &lt;- SphericalSymmetry(SymmCenter = 0),
          modifyParam = function(theta){
                            Norm(mean = theta[1], sd = theta[2])
                        },
          props = paste(c("The normal location and scale family is",
                    "invariant under the group of transformations",
                    "'g(x) = sd*x + mean' with location parameter",
                    "'mean' and scale parameter 'sd'"),
                    collapse = " "))
NLS

## 4. Binomial family
theta &lt;- 0.3
names(theta) &lt;- "prob"
B &lt;- ParamFamily(name = "Binomial family",
         param = ParamFamParameter(name = "probability of success", 
                                   main = theta),
         startPar = function(x,...) c(0,1),
         distribution = Binom(size = 15, prob = 0.3), ## size known!
         modifyParam = function(theta){ Binom(size = 15, prob = theta) },
         props = paste(c("The Binomial family is symmetric with respect",
                   "to prob = 0.5; i.e.,",
                   "d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)"),
                   collapse = " "))
B

## 5. Poisson family
theta &lt;- 7
names(theta) &lt;- "lambda"
P &lt;- ParamFamily(name = "Poisson family",
          param = ParamFamParameter(name = "positive mean", main = theta),
          startPar = function(x,...) c(0,max(x)),
          distribution = Pois(lambda = 7),
          modifyParam = function(theta){ Pois(lambda = theta) })
P


## 6. Exponential scale family
theta &lt;- 2
names(theta) &lt;- "scale"
ES &lt;- ParamFamily(name = "Exponential scale family",
          param = ParamFamParameter(name = "scale parameter", main = theta,
                           .returnClsName = "ParamWithScaleFamParameter"),
          startPar = function(x,...) c(0,max(x)-min(x)),
          distribution = Exp(rate = 1/2),
          modifyParam = function(theta){ Exp(rate = 1/theta) },
          props = paste(c("The Exponential scale family is invariant under",
                    "the group of transformations 'g(y) = scale*y'",
                    "with scale parameter 'scale = 1/rate'"),
                    collapse = " " ))
ES

## 7. Lognormal scale family
theta &lt;- 2
names(theta) &lt;- "scale"
LS &lt;- ParamFamily(name = "Lognormal scale family",
          param = ParamFamParameter(name = "scale parameter", main = theta,
                           .returnClsName = "ParamWithScaleFamParameter"),
          startPar = function(x,...) c(0,max(x)-min(x)),
          distribution = Lnorm(meanlog = log(2), sdlog = 2),## sdlog known!
          modifyParam = function(theta){ 
                            Lnorm(meanlog = log(theta), sdlog = 2) 
                        },
          props = paste(c("The Lognormal scale family is invariant under",
                    "the group of transformations 'g(y) = scale*y'",
                    "with scale parameter 'scale = exp(meanlog)'"),
                    collapse = " "))
LS

## 8. Gamma family
theta &lt;- c(1, 2)
names(theta) &lt;- c("scale", "shape")
G &lt;- ParamFamily(name = "Gamma family",
        param = ParamFamParameter(name = "scale and shape", main = theta,
                           withPosRestr = TRUE,
                           .returnClsName = "ParamWithScaleAndShapeFamParameter"),
        startPar = function(x,...) {E &lt;- mean(x); V &lt;- var(X); c(V/E,E^2/V)},
        makeOKPar = function(param) abs(param),
        distribution = Gammad(scale = 1, shape = 2),
        modifyParam = function(theta){ 
                          Gammad(scale = theta[1], shape = theta[2]) 
                      },
        props = paste(c("The Gamma family is scale invariant via the",
                  "parametrization '(nu,shape)=(log(scale),shape)'"),
                  collapse = " "))
G
</code></pre>

<hr>
<h2 id='ParamFamily-class'>Parametric family of probability measures.</h2><span id='topic+ParamFamily-class'></span><span id='topic+main+2CParamFamily-method'></span><span id='topic+nuisance+2CParamFamily-method'></span><span id='topic+fixed+2CParamFamily-method'></span><span id='topic+param+2CParamFamily-method'></span><span id='topic+modifyParam'></span><span id='topic+modifyParam+2CParamFamily-method'></span><span id='topic+fam.call'></span><span id='topic+fam.call+2CParamFamily-method'></span><span id='topic+startPar'></span><span id='topic+startPar+2CParamFamily-method'></span><span id='topic+makeOKPar'></span><span id='topic+makeOKPar+2CParamFamily-method'></span><span id='topic+plot+2CParamFamily+2Cmissing-method'></span><span id='topic+show+2CParamFamily-method'></span>

<h3>Description</h3>

<p>Class of parametric families of probability measures.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ParamFamily", ...)</code>.
More frequently they are created via the generating function 
<code>ParamFamily</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"Distribution"</code>:
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>] 
object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>param</code></dt><dd>
<p>object of class <code>"ParamFamParameter"</code>:
parameter of the family. </p>
</dd>
<dt><code>fam.call</code></dt><dd>
<p>object of class <code>"call"</code>:
call by which parametric family was produced.</p>
</dd>
<dt><code>makeOKPar</code></dt><dd>
<p>object of class <code>"function"</code>:
has argument <code>param</code> &mdash; the (total) parameter, 
returns valid parameter; used if <code>optim</code> resp. <code>optimize</code>&mdash;
try to use &ldquo;illegal&rdquo; parameter values; then <code>makeOKPar</code> makes
a valid parameter value out of the illegal one.</p>
</dd>
<dt><code>startPar</code></dt><dd>
<p>object of class <code>"function"</code>:
has argument <code>x</code> &mdash; the data, 
returns starting parameter for <code>optim</code> resp. <code>optimize</code>&mdash;
a starting estimator in case parameter is multivariate
or a search interval in case parameter is univariate.</p>
</dd>
<dt><code>modifyParam</code></dt><dd>
<p>object of class <code>"function"</code>:
mapping from the parameter space (represented by <code>"param"</code>) 
to the distribution space (represented by <code>"distribution"</code>). </p>
</dd>
<dt><code>props</code></dt><dd><p>[inherited from class <code>"ProbFamily"</code>]
object of class <code>"character"</code>:
properties of the family. </p>
</dd>
<dt><code>.withMDE</code></dt><dd>
<p>object of class <code>"logical"</code> (of length 1):
Tells R how to use the function from slot <code>startPar</code> in case
of a <code>kStepEstimator</code> &mdash; use it as is or to compute the
starting point for a minimum distance estimator which in turn then
serves as starting point for <code>roptest</code> / <code>robest</code>
(from package <span class="pkg">ROptEst</span>). If
<code>TRUE</code> (default) the latter alternative is used.
Ignored if <span class="pkg">ROptEst</span> is not used.</p>
</dd>
<dt><code>.withEvalAsVar</code></dt><dd>
<p>object of class <code>"logical"</code> (of length 1):
Tells R whether in determining <code>kStepEstimator</code>s one
evaluates the asymptotic variance or just produces a call to do so.</p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"ProbFamily"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>main</dt><dd><p><code>signature(object = "ParamFamily")</code>: 
wrapped accessor function for slot <code>main</code> of
slot <code>param</code>. </p>
</dd>
<dt>nuisance</dt><dd><p><code>signature(object = "ParamFamily")</code>: 
wrapped accessor function for slot <code>nuisance</code> 
of slot <code>param</code>. </p>
</dd>
<dt>fixed</dt><dd><p><code>signature(object = "ParamFamily")</code>: 
wrapped accessor function for slot <code>fixed</code> 
of slot <code>param</code>. </p>
</dd>
<dt>trafo</dt><dd><p><code>signature(object = "ParamFamily", param = "missing")</code>: 
wrapped accessor function for slot <code>trafo</code> 
of slot <code>param</code>. </p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "ParamFamily")</code>: 
accessor function for slot <code>param</code>. </p>
</dd>
<dt>modifyParam</dt><dd><p><code>signature(object = "ParamFamily")</code>: 
accessor function for slot <code>modifyParam</code>. </p>
</dd>
<dt>fam.call</dt><dd><p><code>signature(object = "ParamFamily")</code>: 
accessor function for slot <code>fam.call</code>. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "ParamFamily")</code>: 
plot of slot <code>distribution</code>.
</p>
<p>The return value of the plot method is an S3 object of class
<code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ParamFamily")</code></p>
</dd>
</dl>



<h3>Details for methods 'show', 'print'</h3>

<p>Detailedness of output by methods <code>show</code>, <code>print</code> is controlled
by the global option <code>show.details</code> to be set by 
<code><a href="#topic+distrModoptions">distrModoptions</a></code>.
</p>
<p>As method <code>show</code> is used when inspecting an object by typing the object's 
name into the console, <code>show</code> comes without extra arguments and hence 
detailedness must be controlled  by global options. 
</p>
<p>Method <code>print</code> may be called with a (partially matched) argument
<code>show.details</code>, and then the global option is temporarily set to this
value.
</p>
<p>For class <code>ParamFamily</code>, this becomes relevant for slot <code>param</code>.
For details therefore confer to <code><a href="#topic+ParamFamParameter-class">ParamFamParameter-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>F1 &lt;- new("ParamFamily") # prototype
plot(F1)
</code></pre>

<hr>
<h2 id='ParamFamParameter'>Generating function for ParamFamParameter-class</h2><span id='topic+ParamFamParameter'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"ParamFamParameter"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParamFamParameter(name, main = numeric(0), nuisance, fixed, trafo,
                  ..., .returnClsName = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ParamFamParameter_+3A_name">name</code></td>
<td>
<p> (optional) character string: name of parameter </p>
</td></tr>
<tr><td><code id="ParamFamParameter_+3A_main">main</code></td>
<td>
<p> numeric vector: main parameter </p>
</td></tr>
<tr><td><code id="ParamFamParameter_+3A_nuisance">nuisance</code></td>
<td>
<p> (optional) numeric vector: nuisance paramter </p>
</td></tr>
<tr><td><code id="ParamFamParameter_+3A_fixed">fixed</code></td>
<td>
<p> (optional) numeric vector: fixed part of the paramter </p>
</td></tr>
<tr><td><code id="ParamFamParameter_+3A_trafo">trafo</code></td>
<td>
<p>(optional) MatrixorFunction: transformation of the parameter </p>
</td></tr>
<tr><td><code id="ParamFamParameter_+3A_...">...</code></td>
<td>
<p>(optional) additional arguments for further return classes,
e.g.\ <code>withPosRestr</code> (only use case so far) for
class <code>ParamWithShapeFamParameter</code></p>
</td></tr>
<tr><td><code id="ParamFamParameter_+3A_.returnclsname">.returnClsName</code></td>
<td>
<p>character or <code>NULL</code>; if non-null, the
generated object will be of class <code>.returnClsName</code>, which must
be a subclass of <code>ParamFamParameter</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>name</code> is missing, the default 
&ldquo;&quot;parameter of a parametric family of probability measures&quot;&rdquo;
is used. If <code>nuisance</code> is missing, the nuisance parameter is 
set to <code>NULL</code>. The number of columns of <code>trafo</code> have
to be equal and the number of rows have to be not larger than 
the sum of the lengths of <code>main</code> and <code>nuisance</code>. 
If <code>trafo</code> is missing, no transformation to the parameter
is applied; i.e., <code>trafo</code> is set to an identity matrix.
</p>


<h3>Value</h3>

<p>Object of class <code>"ParamFamParameter"</code> (or, if non-null, of class
<code>.returnClsName</code>)</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ParamFamParameter-class">ParamFamParameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ParamFamParameter(main = 0, nuisance = 1, fixed = 2,
                  trafo = function(x) list(fval = sin(x), 
                                            mat = matrix(cos(x),1,1))
                  )                          

</code></pre>

<hr>
<h2 id='ParamFamParameter-class'>Parameter of a parametric family of probability measures</h2><span id='topic+ParamFamParameter-class'></span><span id='topic+ParamWithScaleFamParameter-class'></span><span id='topic+ParamWithScaleAndShapeFamParameter-class'></span><span id='topic+ParamWithShapeFamParameter-class'></span><span id='topic+length+2CParamFamParameter-method'></span><span id='topic+dimension+2CParamFamParameter-method'></span><span id='topic+main'></span><span id='topic+main+2CParamFamParameter-method'></span><span id='topic+main+2CParamWithScaleAndShapeFamParameter-method'></span><span id='topic+main+3C-'></span><span id='topic+main+3C-+2CParamFamParameter-method'></span><span id='topic+nuisance'></span><span id='topic+nuisance+2CParamFamParameter-method'></span><span id='topic+nuisance+2CParamWithScaleAndShapeFamParameter-method'></span><span id='topic+nuisance+3C-'></span><span id='topic+nuisance+3C-+2CParamFamParameter-method'></span><span id='topic+fixed'></span><span id='topic+fixed+2CParamFamParameter-method'></span><span id='topic+fixed+2CParamWithScaleAndShapeFamParameter-method'></span><span id='topic+fixed+3C-'></span><span id='topic+fixed+3C-+2CParamFamParameter-method'></span><span id='topic+withPosRestr'></span><span id='topic+withPosRestr+2CParamWithShapeFamParameter-method'></span><span id='topic+withPosRestr+3C-'></span><span id='topic+withPosRestr+3C-+2CParamWithShapeFamParameter-method'></span><span id='topic+show+2CParamFamParameter-method'></span><span id='topic+show+2CParamWithShapeFamParameter-method'></span><span id='topic+show+2CParamWithScaleAndShapeFamParameter-method'></span>

<h3>Description</h3>

<p>Class of the parameter of parametric families 
of probability measures.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ParamFamParameter", ...)</code>.
More frequently they are created via the generating function 
<code>ParamFamParameter</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>main</code></dt><dd><p>Object of class <code>"numeric"</code>: main parameter. </p>
</dd>
<dt><code>nuisance</code></dt><dd><p>Object of class <code>"OptionalNumeric"</code>:
optional nuisance parameter. </p>
</dd>
<dt><code>fixed</code></dt><dd><p>Object of class <code>"OptionalNumeric"</code>:
optional fixed part of the parameter. </p>
</dd>
<dt><code>trafo</code></dt><dd><p>Object of class <code>"MatrixorFunction"</code>: 
transformation of the parameter. </p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the parameter. </p>
</dd>
<dt><code>withPosRestr</code></dt><dd><p>(for <code>ParamWithShapeFamParameter</code> and
<code>ParamWithScaleAndShapeFamParameter</code>): Object of class <code>"logical"</code>:
Is shape restricted to be positive? </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Parameter"</code>, directly.<br />
Class <code>"OptionalParameter"</code>, by class <code>"Parameter"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>main</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
accessor function for slot <code>main</code>. </p>
</dd>
<dt>main&lt;-</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
replacement function for slot <code>main</code>. </p>
</dd>
<dt>nuisance</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
accessor function for slot <code>nuisance</code>. </p>
</dd>
<dt>nuisance&lt;-</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
replacement function for slot <code>nuisance</code>. </p>
</dd>
<dt>fixed</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
accessor function for slot <code>fixed</code>. </p>
</dd>
<dt>fixed&lt;-</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
replacement function for slot <code>fixed</code>. </p>
</dd>
<dt>trafo</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
accessor function for slot <code>trafo</code>. </p>
</dd>
<dt>trafo&lt;-</dt><dd><p><code>signature(object = "ParamFamParameter")</code>: 
replacement function for slot <code>trafo</code>. </p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "ParamFamParameter")</code>: 
sum of the lengths of <code>main</code> and <code>nuisance</code>. </p>
</dd>
<dt>dimension</dt><dd><p><code>signature(x = "ParamFamParameter")</code>: 
length of <code>main</code>. </p>
</dd>
<dt>withPosRestr</dt><dd><p><code>signature(object = "ParamWithShapeFamParameter")</code>:
accessor function for slot <code>trafo</code>. </p>
</dd>
<dt>withPosRestr&lt;-</dt><dd><p><code>signature(object = "ParamWithShapeFamParameter")</code>:
replacement function for slot <code>trafo</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ParamFamParameter")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ParamWithShapeFamParameter")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ParamWithScaleAndShapeFamParameter")</code></p>
</dd>
</dl>



<h3>Details for methods 'show', 'print'</h3>

<p>Detailedness of output by methods <code>show</code>, <code>print</code> is controlled
by the global option <code>show.details</code> to be set by 
<code><a href="#topic+distrModoptions">distrModoptions</a></code>.
</p>
<p>As method <code>show</code> is used when inspecting an object by typing the object's 
name into the console, <code>show</code> comes without extra arguments and hence 
detailedness must be controlled  by global options. 
</p>
<p>Method <code>print</code> may be called with a (partially matched) argument
<code>show.details</code>, and then the global option is temporarily set to this
value.
</p>
<p>More specifically, when <code>show.detail</code> is matched to <code>"minimal"</code>
only class and name as well as main and nuisance part of the
parameter are shown. When <code>show.detail</code> is matched to <code>"medium"</code>, 
and if you estimate non-trivial (i.e. not the identity)
transformation of the parameter of the parametric family, you will in addition 
be shown the derivative matrix, if the transformation is given in form of
this matrix, while, if the transformation is in function form, you will
only be told this.
Finally, when <code>show.detail</code> is matched to <code>"maximal"</code>, 
and you have a non-trivial transformation in function form, you will
also be shown the code to this function.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Parameter-class">Parameter-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("ParamFamParameter")
</code></pre>

<hr>
<h2 id='PoisFamily'>Generating function for Poisson families</h2><span id='topic+PoisFamily'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"L2ParamFamily"</code> which
represents a Poisson family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoisFamily(lambda = 1, trafo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoisFamily_+3A_lambda">lambda</code></td>
<td>
<p> positive mean </p>
</td></tr>
<tr><td><code id="PoisFamily_+3A_trafo">trafo</code></td>
<td>
<p> function in <code>param</code> or matrix: transformation of the parameter </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slots of the corresponding L2 differentiable 
parameteric family are filled.
</p>


<h3>Value</h3>

<p>Object of class <code>"L2ParamFamily"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to 
the Asymptotic Theory of Robustness</em>. Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="distr.html#topic+Pois-class">Pois-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(P1 &lt;- PoisFamily(lambda = 4.5))
plot(P1)
FisherInfo(P1)
checkL2deriv(P1)
</code></pre>

<hr>
<h2 id='positiveBias'>Generating function for onesidedBias-class</h2><span id='topic+positiveBias'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"onesidedBias"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positiveBias(name = "positive Bias")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="positiveBias_+3A_name">name</code></td>
<td>
<p> name of the bias type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"onesidedBias"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onesidedBias-class">onesidedBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>positiveBias()

## The function is currently defined as
function(){ new("onesidedBias", name = "positive Bias", sign = 1) }
</code></pre>

<hr>
<h2 id='print-methods'>Common &lsquo;print&rsquo; Methods for S4 classes in Package &lsquo;distrMod&rsquo; </h2><span id='topic+print-methods'></span><span id='topic+print+2CShowDetails-method'></span>

<h3>Description</h3>

<p>Methods for <code>print</code> to the S4 classes in package <span class="pkg">distrMod</span>;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ShowDetails'
print(x, digits = getOption("digits"),
                show.details = c("maximal", "minimal", "medium"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>ShowDetails</code>, a class union of
classes <code>OptionalNumeric</code>, <code>OptionalMatrix</code>,
<code>MatrixorFunction</code>, <code>Estimate</code>, <code>MCEstimate</code>.</p>
</td></tr>
<tr><td><code id="print-methods_+3A_digits">digits</code></td>
<td>
<p>unchanged w.r.t. default method of package <code>base</code>:
a non-null value for 'digits' specifies the minimum number of
significant digits to be printed in values.  The default,
'NULL', uses 'getOption(digits)'.  (For the interpretation
for complex numbers see 'signif'.) Non-integer values will be
rounded down, and only values greater than or equal to 1 and
no greater than 22 are accepted.</p>
</td></tr>
<tr><td><code id="print-methods_+3A_show.details">show.details</code></td>
<td>
<p>a character, controlling the degree of detailedness
of the output; currently the following values are permitted:
<code>"maximal"</code>, <code>"minimal"</code>, <code>"medium"</code>; for the meaning
for the actual class, confer to the corresponding class help file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method provides sort of a &rdquo;<code>show</code>
with extra arguments&rdquo;, in form of a common <code>print</code> method
for the mentioned S4 classes. Essentially this <code>print</code> method
just temporarily sets the global options according to the optional arguments
<code>digits</code> and <code>show.details</code>, calls <code>show</code> and then re-sets
the options to their global settings.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set options to maximal detailedness
show.old &lt;- getdistrModOption("show.details")
distrModoptions("show.details" = "maximal")
## define a model
NS &lt;- NormLocationScaleFamily(mean=2, sd=3)
## generate data out of this situation
x &lt;- r(distribution(NS))(30)

## want to estimate mu/sigma, sigma^2
## -&gt; new trafo slot:
trafo(NS) &lt;- function(param){
  mu &lt;- param["mean"]
  sd &lt;- param["sd"]
  fval &lt;- c(mu/sd, sd^2)
  nfval &lt;- c("mu/sig", "sig^2")
  names(fval) &lt;- nfval
  mat &lt;- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
  dimnames(mat) &lt;- list(nfval,c("mean","sd"))
  return(list(fval=fval, mat=mat))
}
print(param(NS))
print(param(NS), show.details = "minimal")
print(param(NS), show.details = "medium")
## Maximum likelihood estimator
res &lt;- MLEstimator(x = x, ParamFamily = NS)
print(res) #equivalent to 'show(res)' or 'res'
print(res, digits = 4)
print(res, show.details = "minimal")
print(res, show.details = "medium")
distrModoptions("show.details" = show.old)
</code></pre>

<hr>
<h2 id='ProbFamily-class'>Family of probability measures</h2><span id='topic+ProbFamily-class'></span><span id='topic+addProp+3C-'></span><span id='topic+addProp+3C-+2CProbFamily-method'></span><span id='topic+distribution'></span><span id='topic+distribution+2CProbFamily-method'></span><span id='topic+distrSymm'></span><span id='topic+distrSymm+2CProbFamily-method'></span><span id='topic+name+2CProbFamily-method'></span><span id='topic+name+3C-+2CProbFamily-method'></span><span id='topic+props'></span><span id='topic+props+2CProbFamily-method'></span><span id='topic+props+3C-'></span><span id='topic+props+3C-+2CProbFamily-method'></span><span id='topic+r+2CProbFamily-method'></span><span id='topic+d+2CProbFamily-method'></span><span id='topic+p+2CProbFamily-method'></span><span id='topic+q+2CProbFamily-method'></span><span id='topic+q.l+2CProbFamily-method'></span>

<h3>Description</h3>

<p>Class of families of probability measures.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: 
name of the family. </p>
</dd>
<dt><code>distribution</code></dt><dd><p>Object of class <code>"Distribution"</code>: 
member of the family. </p>
</dd>
<dt><code>distrSymm</code></dt><dd><p>Object of class <code>"DistributionSymmetry"</code>: 
symmetry of <code>distribution</code>. </p>
</dd>
<dt><code>props</code></dt><dd><p>Object of class <code>"character"</code>: 
properties of the family. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>name</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
accessor function for slot <code>name</code>. </p>
</dd>
<dt>name&lt;-</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
replacement function for slot <code>name</code>. </p>
</dd>
<dt>distribution</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
accessor function for slot <code>distribution</code>. </p>
</dd>
<dt>distrSymm</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
accessor function for slot <code>distrSymm</code>. </p>
</dd>
<dt>props</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
accessor function for slot <code>props</code>. </p>
</dd>
<dt>props&lt;-</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
replacement function for slot <code>props</code>. </p>
</dd>
<dt>addProp&lt;-</dt><dd><p><code>signature(object = "ProbFamily")</code>: 
add a property to slot <code>props</code>. </p>
</dd>
<dt>r</dt><dd><p><code>signature(object = "ProbFamily")</code>: wrapped accessor
to slot <code>r</code> of slot <code>"Distribution"</code>.</p>
</dd>
<dt>d</dt><dd><p><code>signature(object = "ProbFamily")</code>: wrapped accessor
to slot <code>d</code> of slot <code>"Distribution"</code>.</p>
</dd>
<dt>p</dt><dd><p><code>signature(object = "ProbFamily")</code>: wrapped accessor
to slot <code>p</code> of slot <code>"Distribution"</code>.</p>
</dd>
<dt>q</dt><dd><p><code>signature(object = "ProbFamily")</code>: wrapped accessor
to slot <code>q</code> of slot <code>"Distribution"</code>.</p>
</dd>
<dt>q.l</dt><dd><p><code>signature(object = "ProbFamily")</code>: wrapped accessor
to slot <code>q</code> of slot <code>"Distribution"</code> &ndash; for compatibility
with RStudio or Jupyter IRKernel / synonymous to <code>q</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+Distribution-class">Distribution-class</a></code></p>

<hr>
<h2 id='QFNorm'>Generating function for QFNorm-class</h2><span id='topic+QFNorm'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"QFNorm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QFNorm(name = "norm based on quadratic form", 
       QuadForm = PosSemDefSymmMatrix(matrix(1)))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QFNorm_+3A_name">name</code></td>
<td>
<p> slot <code>name</code> of the class</p>
</td></tr>
<tr><td><code id="QFNorm_+3A_quadform">QuadForm</code></td>
<td>
<p>  slot <code>QuadForm</code> of the class </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"QFNorm"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QFNorm-class">QFNorm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
QFNorm()

## The function is currently defined as
function(){ new("QFNorm") }
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='QFNorm-class'>Norm classes for norms based on quadratic forms</h2><span id='topic+QFNorm-class'></span><span id='topic+InfoNorm-class'></span><span id='topic+SelfNorm-class'></span><span id='topic+QuadForm+2CQFNorm-method'></span><span id='topic+QuadForm+3C-+2CQFNorm-method'></span><span id='topic+QuadForm'></span><span id='topic+QuadForm+3C-'></span>

<h3>Description</h3>

<p>Classes for norms based on quadratic forms</p>


<h3>Objects from the Class</h3>

<p>could be created by a call to <code>new</code>, but 
normally one would use the generating functions <code>QFNorm</code>, 
<code>InfoNorm</code>, and <code>SelfNorm</code> </p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>fct</code></dt><dd><p>Object of class <code>"function"</code>.</p>
</dd>
<dt><code>QuadForm</code></dt><dd><p>Object of class <code>"PosSemDefSymmMatrix"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p><code>"QFNorm"</code> extends class <code>"NormType"</code>, directly,
and <code>"InfoNorm"</code> and <code>"SelfNorm"</code> each extend 
class <code>"QFNorm"</code>, directly (and do not have extra slots).
</p>


<h3>Methods</h3>


<dl>
<dt>QuadForm</dt><dd><p><code>signature(object = "QFNorm")</code>: 
accessor function for slot <code>QuadForm</code>. </p>
</dd>
<dt>QuadForm&lt;-</dt><dd><p><code>signature(object = "QFNorm")</code>: 
replacement function for slot <code>QuadForm</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NormType-class">NormType-class</a></code></p>

<hr>
<h2 id='qqplot'>Methods for Function qqplot in Package &lsquo;distrMod&rsquo;</h2><span id='topic+qqplot'></span><span id='topic+qqplot-methods'></span><span id='topic+qqplot+2CANY+2CProbFamily-method'></span><span id='topic+qqplot+2CANY+2CEstimate-method'></span><span id='topic+qqplot+2CANY+2CUnivariateDistribution-method'></span>

<h3>Description</h3>

<p>We generalize function <code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> to
be applicable to distribution and probability model objects, as well as
to estimate objects. In this context,
<code>qqplot</code> produces a QQ plot of data (argument <code>x</code>) against
a (model) distribution. If the second argument is of class <code>'Estimate'</code>,
<code>qqplot</code> looks at the <code>estimate.call</code>-slot and checks whether
it can use an argument <code>ParamFamily</code> to conclude on the model
distribution. Graphical parameters may be given as arguments to
<code>qqplot</code>.
In all title and label arguments, if <code>withSubst</code> is <code>TRUE</code>,
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>x</code></p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument <code>x</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>qqplot(x, y, ...)
## S4 method for signature 'ANY,UnivariateDistribution'
qqplot(x,y,
    n = length(x), withIdLine = TRUE,
    withConf = TRUE, withConf.pw  = withConf, withConf.sim = withConf,
    plot.it = TRUE, datax = FALSE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)),
    ..., width = 10, height = 5.5, withSweave = getdistrOption("withSweave"),
    mfColRow = TRUE, n.CI = n, with.lab = FALSE, lab.pts = NULL, which.lbs = NULL,
    which.Order = NULL, which.nonlbs = NULL, attr.pre = FALSE, order.traf = NULL,
    col.IdL = "red", lty.IdL = 2, lwd.IdL = 2, alpha.CI = .95,
    exact.pCI = (n&lt;100), exact.sCI = (n&lt;100), nosym.pCI = FALSE,
    col.pCI = "orange", lty.pCI = 3, lwd.pCI = 2, pch.pCI = par("pch"),
    cex.pCI = par("cex"),
    col.sCI = "tomato2", lty.sCI = 4, lwd.sCI = 2, pch.sCI = par("pch"),
    cex.sCI = par("cex"), added.points.CI = TRUE,
    cex.pch = par("cex"), col.pch = par("col"),
    cex.pts = 1, col.pts = par("col"), pch.pts = 19,
    cex.npts = 1, col.npts = grey(.5), pch.npts = 20,
    cex.lbs = par("cex"), col.lbs = par("col"), adj.lbs = par("adj"),
    alpha.trsp = NA, jit.fac = 0, jit.tol = .Machine$double.eps,
    check.NotInSupport = TRUE, col.NotInSupport = "red",
    with.legend = TRUE, legend.bg = "white",
    legend.pos = "topleft", legend.cex = 0.8, 
    legend.pref = "", legend.postf = "",  legend.alpha = alpha.CI,
    debug = FALSE, withSubst = TRUE)
## S4 method for signature 'ANY,ProbFamily'
qqplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...)
## S4 method for signature 'ANY,Estimate'
qqplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqplot_+3A_x">x</code></td>
<td>
<p>data to be checked for compatibility with distribution/model <code>y</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_y">y</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code> or of
class <code>"ProbFamily"</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_n">n</code></td>
<td>
<p>numeric; assumed sample size (by default length of <code>x</code>).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withidline">withIdLine</code></td>
<td>
<p>logical; shall line <code>y = x</code> be plotted in?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf">withConf</code></td>
<td>
<p>logical; shall confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_plot.it">plot.it</code></td>
<td>
<p>logical; shall be plotted at all (inherited from
<code><a href="stats.html#topic+qqnorm">qqplot</a></code>)?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_datax">datax</code></td>
<td>
<p>logical; shall data be plotted on x-axis?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_xlab">xlab</code></td>
<td>
<p>x-label</p>
</td></tr>
<tr><td><code id="qqplot_+3A_ylab">ylab</code></td>
<td>
<p>y-label</p>
</td></tr>
<tr><td><code id="qqplot_+3A_...">...</code></td>
<td>
<p>further parameters for method <code>qqplot</code> with signature
<code>ANY,UnivariateDistribution</code> or with function <code>plot</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_width">width</code></td>
<td>
<p>width (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="qqplot_+3A_height">height</code></td>
<td>
<p>height (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>)
no extra device is opened and height/width are not set</p>
</td></tr>
<tr><td><code id="qqplot_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_n.ci">n.CI</code></td>
<td>
<p>numeric; number of points to be used for confidence interval</p>
</td></tr>
<tr><td><code id="qqplot_+3A_with.lab">with.lab</code></td>
<td>
<p>logical; shall observation labels be plotted in?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or <code>NULL</code>; observation labels to be used</p>
</td></tr>
<tr><td><code id="qqplot_+3A_attr.pre">attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="qqplot_+3A_which.lbs">which.lbs</code></td>
<td>
<p>integer or <code>NULL</code>; which observations shall be labelled</p>
</td></tr>
<tr><td><code id="qqplot_+3A_which.order">which.Order</code></td>
<td>
<p>integer or <code>NULL</code>; which of the ordered (remaining)
observations shall be labelled</p>
</td></tr>
<tr><td><code id="qqplot_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_order.traf">order.traf</code></td>
<td>
<p>function or <code>NULL</code>; an optional trafo by which the
observations are ordered (as order(trafo(obs)).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.idl">col.IdL</code></td>
<td>
<p>color for the identity line</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lty.idl">lty.IdL</code></td>
<td>
<p>line type for the identity line</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lwd.idl">lwd.IdL</code></td>
<td>
<p>line width for the identity line</p>
</td></tr>
<tr><td><code id="qqplot_+3A_alpha.ci">alpha.CI</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exact.pci">exact.pCI</code></td>
<td>
<p>logical; shall pointwise CIs be determined with exact
Binomial distribution?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_exact.sci">exact.sCI</code></td>
<td>
<p>logical; shall simultaneous CIs be determined with
exact Kolmogorov distribution?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_nosym.pci">nosym.pCI</code></td>
<td>
<p>logical; shall we use (shortest) asymmetric CIs?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.pci">col.pCI</code></td>
<td>
<p>color for the pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lty.pci">lty.pCI</code></td>
<td>
<p>line type for the pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lwd.pci">lwd.pCI</code></td>
<td>
<p>line width for the pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_pch.pci">pch.pCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.pci">cex.pCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in
pointwise CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.sci">col.sCI</code></td>
<td>
<p>color for the simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lty.sci">lty.sCI</code></td>
<td>
<p>line type for the simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_lwd.sci">lwd.sCI</code></td>
<td>
<p>line width for the simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_pch.sci">pch.sCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.sci">cex.sCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in
simultaneous CI</p>
</td></tr>
<tr><td><code id="qqplot_+3A_added.points.ci">added.points.CI</code></td>
<td>
<p>logical; should CIs be plotted through additional points
(and not only through data points)? </p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.pch">cex.pch</code></td>
<td>
<p>magnification factor for the plotted symbols (for backward
compatibility); it is ignored once <code>col.pts</code> is specified.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.pch">col.pch</code></td>
<td>
<p>color for the plotted symbols (for backward compatibility); it is
ignored once <code>col.pts</code> is specified.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>size of the points of the second argument plotted, can be a vector;
if argument <code>attr.pre</code> is <code>TRUE</code>, it is recycled to the length
of all observations and determines the sizes of all plotted symbols,
i.e., the selection is done within this argument; in this case argument
<code>col.npts</code> is ignored. If <code>attr.pre</code> is <code>FALSE</code>,
<code>cex.pts</code> is recycled to the number of the observations selected
for labelling and refers to the index ordering after the
selection. Then argument <code>cex.npts</code> deteremines the sizes
of the shown but non-labelled observations as given in argument
<code>which.nonlbs</code>.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.pts">col.pts</code></td>
<td>
<p>color of the points of the second argument plotted, can
be a vector as in <code>cex.pts</code> (with <code>col.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of the points of the second argument plotted, can
be a vector as in <code>cex.pts</code> (with <code>pch.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.npts">col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted; (may be a vector).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_pch.npts">pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (may be a vector).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.npts">cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (may be a vector).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_cex.lbs">cex.lbs</code></td>
<td>
<p>magnification factor for the plotted observation labels</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.lbs">col.lbs</code></td>
<td>
<p>color for the plotted observation labels</p>
</td></tr>
<tr><td><code id="qqplot_+3A_adj.lbs">adj.lbs</code></td>
<td>
<p>adj parameter for the plotted observation labels</p>
</td></tr>
<tr><td><code id="qqplot_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbs</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="qqplot_+3A_jit.fac">jit.fac</code></td>
<td>
<p>jittering factor used for discrete distributions.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_jit.tol">jit.tol</code></td>
<td>
<p>threshold for jittering: if distance between points is smaller
than <code>jit.tol</code>, points are considered replicates.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_check.notinsupport">check.NotInSupport</code></td>
<td>
<p>logical; shall we check if all <code>x</code>-quantiles lie
in <code>support(y)</code>?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_col.notinsupport">col.NotInSupport</code></td>
<td>
<p>logical; if preceding check <code>TRUE</code> color of
<code>x</code>-quantiles if not in <code>support(y)</code></p>
</td></tr>
<tr><td><code id="qqplot_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>position for the legend</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.pref">legend.pref</code></td>
<td>
<p>character to be prepended to legend text</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.postf">legend.postf</code></td>
<td>
<p>character to be appended to legend text</p>
</td></tr>
<tr><td><code id="qqplot_+3A_legend.alpha">legend.alpha</code></td>
<td>
<p>nominal coverage probability</p>
</td></tr>
<tr><td><code id="qqplot_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code> additional output to debug confidence bounds.</p>
</td></tr>
<tr><td><code id="qqplot_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and axis lables is used; otherwise no substitution is used. </p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "UnivariateDistribution")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of distribution <code>y</code>.</p>
</dd>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "ProbFamily")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of the model distribution of model <code>y</code>. Passed through
the <code>...</code> argument, all arguments valid for
<code>signature(x = "ANY", y = "UnivariateDistribution")</code>
are also valid for this signature.</p>
</dd>
<dt>qqplot</dt><dd><p><code>signature(x = "ANY", y = "Estimate")</code>:
produces a QQ plot of a dataset <code>x</code> against the theoretical
quantiles of the model distribution of the model that can be reconstructed
from the estimator <code>y</code>; more specifically, it tries to get hand at the
argument <code>'ParamFamily'</code> of the esimator's call; if this is available,
internally this model is shifted to the estimated parameter by a call to
<code>modifyModel</code>, and then this shifted model is used in a call to the
<code>(x = "ANY", y = "UnivariateDistribution")</code>-method. Passed through
the <code>...</code> argument, all arguments valid for
<code>signature(x = "ANY", y = "UnivariateDistribution")</code>
are also valid for this signature.</p>
</dd>
</dl>



<h3>Value</h3>

<p>As for function <code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span>: a
list with components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that were/would be plotted</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The corresponding quantiles of the second distribution,
<em>including <code><a href="base.html#topic+NA">NA</a></code>s</em>.</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>A matrix with the lower and upper confidence bounds
(computed by <code>qqbounds</code>).</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>logical vector of length 2.</p>
</td></tr>
</table>
<p>(elements <code>crit</code> and <code>err</code> are taken from the return
value(s) of <code>qqbounds</code>).
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> &ndash; the standard QQ plot
function,  <code><a href="distr.html#topic+qqplot">qqplot</a></code> from package <span class="pkg">distr</span> for
comparisons of distributions, and
<code><a href="distr.html#topic+qqbounds">qqbounds</a></code>, used by <code>qqplot</code> to produce confidence
intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(40,mean=15,sd=30)
qqplot(x, Chisq(df=15))
NF &lt;- NormLocationScaleFamily(mean=15, sd=30)
qqplot(x, NF, with.lab=TRUE, which.Order=1:5, cex.lbs=1.3)
mlE &lt;- MLEstimator(x, NF)
qqplot(x, mlE)
</code></pre>

<hr>
<h2 id='returnlevelplot'>Methods for Function returnlevelplot in Package &lsquo;distrMod&rsquo;</h2><span id='topic+returnlevelplot'></span><span id='topic+returnlevelplot-methods'></span><span id='topic+returnlevelplot+2CANY+2CProbFamily-method'></span><span id='topic+returnlevelplot+2CANY+2CUnivariateDistribution-method'></span><span id='topic+returnlevelplot+2CANY+2CEstimate-method'></span>

<h3>Description</h3>

<p>We generalize the return level plot (which is one of the diagnostical
plots provided package <span class="pkg">ismev</span>, e.g., in function
<code><a href="ismev.html#topic+gev.diag">gev.diag</a></code>), see also Coles' book below,  to
be applicable to distribution and probability model objects. In this context,
<code>returnlevelplot</code> produces a rescaled QQ plot of data (argument <code>x</code>) 
against a (model) distribution.
Graphical parameters may be given as arguments to <code>returnlevelplot</code>.
In all title and label arguments, if <code>withSubst</code> is <code>TRUE</code>,
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>x</code></p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument <code>x</code></p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>returnlevelplot(x, y, ...)
## S4 method for signature 'ANY,UnivariateDistribution'
returnlevelplot(x,y,
    n = length(x), withIdLine = TRUE,
    withConf = TRUE, withConf.pw  = withConf, withConf.sim = withConf,
    plot.it = TRUE, datax = FALSE, MaxOrPOT = c("Max","POT"), npy = 365,
    threshold = if(is(y,"GPareto")) NA else 0,    
    xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)),
    main = "",
    ..., width = 10, height = 5.5, withSweave = getdistrOption("withSweave"),
    mfColRow = TRUE, n.CI = n, with.lab = FALSE, lab.pts = NULL, which.lbs = NULL,
    which.Order = NULL, which.nonlbs = NULL, attr.pre = FALSE, order.traf = NULL,
    col.IdL = "red", lty.IdL = 2, lwd.IdL = 2, alpha.CI = .95,
    exact.pCI = (n&lt;100), exact.sCI = (n&lt;100), nosym.pCI = FALSE,
    col.pCI = "orange", lty.pCI = 3, lwd.pCI = 2, pch.pCI = par("pch"),
    cex.pCI = par("cex"),
    col.sCI = "tomato2", lty.sCI = 4, lwd.sCI = 2, pch.sCI = par("pch"),
    cex.sCI = par("cex"), added.points.CI = TRUE,
    cex.pch = par("cex"), col.pch = par("col"),
    cex.pts = 1, col.pts = par("col"), pch.pts = 19,
    cex.npts = 1, col.npts = grey(.5), pch.npts = 20,
    cex.lbs = par("cex"), col.lbs = par("col"), adj.lbs = par("adj"),
    alpha.trsp = NA, jit.fac = 0,  jit.tol = .Machine$double.eps,
    check.NotInSupport = TRUE, col.NotInSupport = "red",
    with.legend = TRUE, legend.bg = "white",
    legend.pos = "topleft", legend.cex = 0.8,
    legend.pref = "", legend.postf = "",  legend.alpha = alpha.CI,
    debug = FALSE, withSubst = TRUE)
## S4 method for signature 'ANY,ProbFamily'
returnlevelplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...)
## S4 method for signature 'ANY,Estimate'
returnlevelplot(x, y,
   n = length(x), withIdLine = TRUE, withConf = TRUE,
   withConf.pw  = withConf,  withConf.sim = withConf,
    plot.it = TRUE, xlab = deparse(substitute(x)),
    ylab = deparse(substitute(y)), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="returnlevelplot_+3A_x">x</code></td>
<td>
<p>data to be checked for compatibility with distribution/model <code>y</code>.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_y">y</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code> or of
class <code>"ProbFamily"</code>.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_n">n</code></td>
<td>
<p>numeric; assumed sample size (by default length of <code>x</code>).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withidline">withIdLine</code></td>
<td>
<p>logical; shall line <code>y = x</code> be plotted in?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withconf">withConf</code></td>
<td>
<p>logical; shall confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withconf.pw">withConf.pw</code></td>
<td>
<p>logical; shall pointwise confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withconf.sim">withConf.sim</code></td>
<td>
<p>logical; shall simultaneous confidence lines be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_plot.it">plot.it</code></td>
<td>
<p>logical; shall be plotted at all (inherited from
<code><a href="stats.html#topic+qqnorm">returnlevelplot</a></code>)?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_datax">datax</code></td>
<td>
<p>logical; shall data be plotted on x-axis?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_maxorpot">MaxOrPOT</code></td>
<td>
<p>a character string specifying whether it is used for
block maxima (&quot;Max&quot;) or for points over threshold (&quot;POT&quot;);
must be one of &quot;Max&quot; (default) or &quot;POT&quot;.
You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_npy">npy</code></td>
<td>
<p>number of observations per year/block.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_threshold">threshold</code></td>
<td>
<p>numerical; in case of <code>MaxOrPot=="POT"</code>, this captures
the (removed) threshold. If it is <code>NA</code>, it is reconstructed
from the distribution <code>y</code>.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_xlab">xlab</code></td>
<td>
<p>x-label</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_ylab">ylab</code></td>
<td>
<p>y-label</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_...">...</code></td>
<td>
<p>further parameters for method <code>returnlevelplot</code> with signature
<code>ANY,UnivariateDistribution</code> or with function <code>plot</code></p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_width">width</code></td>
<td>
<p>width (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_height">height</code></td>
<td>
<p>height (in inches) of the graphics device opened</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withsweave">withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>)
no extra device is opened and height/width are not set</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_mfcolrow">mfColRow</code></td>
<td>
<p>shall default partition in panels be used &mdash; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_n.ci">n.CI</code></td>
<td>
<p>numeric; number of points to be used for confidence interval</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_with.lab">with.lab</code></td>
<td>
<p>logical; shall observation labels be plotted in?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or <code>NULL</code>; observation labels to be used</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_attr.pre">attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_which.lbs">which.lbs</code></td>
<td>
<p>integer or <code>NULL</code>; which observations shall be labelled</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_which.order">which.Order</code></td>
<td>
<p>integer or <code>NULL</code>; which of the ordered (remaining)
observations shall be labelled</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_order.traf">order.traf</code></td>
<td>
<p>function or <code>NULL</code>; an optional trafo by which the
observations are ordered (as order(trafo(obs)).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.idl">col.IdL</code></td>
<td>
<p>color for the identity line</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lty.idl">lty.IdL</code></td>
<td>
<p>line type for the identity line</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lwd.idl">lwd.IdL</code></td>
<td>
<p>line width for the identity line</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_alpha.ci">alpha.CI</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_exact.pci">exact.pCI</code></td>
<td>
<p>logical; shall pointwise CIs be determined with exact
Binomial distribution?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_exact.sci">exact.sCI</code></td>
<td>
<p>logical; shall simultaneous CIs be determined with
exact Kolmogorov distribution?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_nosym.pci">nosym.pCI</code></td>
<td>
<p>logical; shall we use (shortest) asymmetric CIs?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.pci">col.pCI</code></td>
<td>
<p>color for the pointwise CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lty.pci">lty.pCI</code></td>
<td>
<p>line type for the pointwise CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lwd.pci">lwd.pCI</code></td>
<td>
<p>line width for the pointwise CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_pch.pci">pch.pCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in pointwise CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.pci">cex.pCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in
pointwise CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.sci">col.sCI</code></td>
<td>
<p>color for the simultaneous CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lty.sci">lty.sCI</code></td>
<td>
<p>line type for the simultaneous CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_lwd.sci">lwd.sCI</code></td>
<td>
<p>line width for the simultaneous CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_pch.sci">pch.sCI</code></td>
<td>
<p>symbol for points (for discrete mass points) in simultaneous CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.sci">cex.sCI</code></td>
<td>
<p>magnification factor for points (for discrete mass points) in
simultaneous CI</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_added.points.ci">added.points.CI</code></td>
<td>
<p>logical; should CIs be plotted through additional points
(and not only through data points)? </p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.pch">cex.pch</code></td>
<td>
<p>magnification factor for the plotted symbols (for backward
compatibility); it is ignored once <code>col.pts</code> is specified.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.pch">col.pch</code></td>
<td>
<p>color for the plotted symbols (for backward compatibility); it is
ignored once <code>col.pts</code> is specified.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.pts">cex.pts</code></td>
<td>
<p>size of the points of the second argument plotted, can be a vector;
if argument <code>attr.pre</code> is <code>TRUE</code>, it is recycled to the length
of all observations and determines the sizes of all plotted symbols,
i.e., the selection is done within this argument; in this case argument
<code>col.npts</code> is ignored. If <code>attr.pre</code> is <code>FALSE</code>,
<code>cex.pts</code> is recycled to the number of the observations selected
for labelling and refers to the index ordering after the
selection. Then argument <code>cex.npts</code> deteremines the sizes
of the shown but non-labelled observations as given in argument
<code>which.nonlbs</code>.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.pts">col.pts</code></td>
<td>
<p>color of the points of the second argument plotted, can
be a vector as in <code>cex.pts</code> (with <code>col.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of the points of the second argument plotted, can
be a vector as in <code>cex.pts</code> (with <code>pch.npts</code> as counterpart).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.npts">col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted; (may be a vector).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_pch.npts">pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (may be a vector).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.npts">cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (may be a vector).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_cex.lbs">cex.lbs</code></td>
<td>
<p>magnification factor for the plotted observation labels</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.lbs">col.lbs</code></td>
<td>
<p>color for the plotted observation labels</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_adj.lbs">adj.lbs</code></td>
<td>
<p>adj parameter for the plotted observation labels</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbs</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_jit.fac">jit.fac</code></td>
<td>
<p>jittering factor used for discrete distributions.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_jit.tol">jit.tol</code></td>
<td>
<p>threshold for jittering: if distance between points is smaller
than <code>jit.tol</code>, points are considered replicates.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_check.notinsupport">check.NotInSupport</code></td>
<td>
<p>logical; shall we check if all <code>x</code>-quantiles lie
in <code>support(y)</code>?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_col.notinsupport">col.NotInSupport</code></td>
<td>
<p>logical; if preceding check <code>TRUE</code> color of
<code>x</code>-quantiles if not in <code>support(y)</code></p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_with.legend">with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_legend.bg">legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>position for the legend</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_legend.cex">legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_legend.pref">legend.pref</code></td>
<td>
<p>character to be prepended to legend text</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_legend.postf">legend.postf</code></td>
<td>
<p>character to be appended to legend text</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_legend.alpha">legend.alpha</code></td>
<td>
<p>nominal coverage probability</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_debug">debug</code></td>
<td>
<p>logical; if <code>TRUE</code> additional output to debug confidence bounds.</p>
</td></tr>
<tr><td><code id="returnlevelplot_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and axis lables is used; otherwise no substitution is used. </p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>returnlevelplot</dt><dd><p><code>signature(x = "ANY", y = "UnivariateDistribution")</code>:
produces a return level plot of a dataset <code>x</code> against the theoretical
quantiles of distribution <code>y</code>.</p>
</dd>
<dt>returnlevelplot</dt><dd><p><code>signature(x = "ANY", y = "ProbFamily")</code>:
produces a return level plot of a dataset <code>x</code> against the theoretical
quantiles of the model distribution of model <code>y</code>. Passed through
the <code>...</code> argument, all arguments valid for
<code>signature(x = "ANY", y = "UnivariateDistribution")</code>
are also valid for this signature.</p>
</dd>
<dt>returnlevelplot</dt><dd><p><code>signature(x = "ANY", y = "Estimate")</code>:
produces a return level plot of a dataset <code>x</code> against the theoretical
quantiles of the model distribution of the model that can be reconstructed
from the estimator <code>y</code>; more specifically, it tries to get hand at the
argument <code>'ParamFamily'</code> of the esimator's call; if this is available,
internally this model is shifted to the estimated parameter by a call to
<code>modifyModel</code>, and then this shifted model is used in a call to the
<code>(x = "ANY", y = "UnivariateDistribution")</code>-method. Passed through
the <code>...</code> argument, all arguments valid for
<code>signature(x = "ANY", y = "UnivariateDistribution")</code>
are also valid for this signature.</p>
</dd>
</dl>



<h3>Value</h3>

<p>As for function <code><a href="stats.html#topic+qqnorm">returnlevelplot</a></code> from package <span class="pkg">stats</span>: a
list with components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the points that were/would be plotted</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The corresponding quantiles of the second distribution,
<em>including <code><a href="base.html#topic+NA">NA</a></code>s</em>.</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>A matrix with the lower and upper confidence bounds
(computed by <code>qqbounds</code>).</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>logical vector of length 2.</p>
</td></tr>
</table>
<p>(elements <code>crit</code> and <code>err</code> are taken from the return
value(s) of <code>qqbounds</code>).
</p>


<h3>Note</h3>

<p>The confidence bands given in our version of the return level plot differ
from the ones given in package <span class="pkg">ismev</span>. We use non-parametric bands,
hence also allow for non-parametric deviances from the model, whereas in
in package <span class="pkg">ismev</span> they are based on profiling, hence only check for
variability within the parametric class.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>ismev: An   Introduction to Statistical Modeling of Extreme Values. R package
version 1.39. https://CRAN.R-project.org/package=ismev; original S functions
written by Janet E. Heffernan with R port and R documentation provided by
Alec G. Stephenson. (2012).
</p>
<p>Coles, S. (2001). <em>An introduction
to statistical modeling of extreme values.</em> London: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">qqplot</a></code> from package <span class="pkg">stats</span> &ndash; the standard QQ plot
function,  <code><a href="distr.html#topic+qqplot">qqplot</a></code> from package <span class="pkg">distr</span> for
comparisons of distributions, <code>qqplot</code> from this package and
<code><a href="distr.html#topic+qqbounds">qqbounds</a></code>, used by <code>returnlevelplot</code> to produce confidence
intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20190331)
returnlevelplot(r(Norm(15,sqrt(30)))(40), Chisq(df=15))
### more could be seen after installing RobExtremes and ismev
#

## IGNORE_RDIFF_BEGIN
 ## at R CMD check --as-cran, it does not find package cluster
           ## when trying to attach package rrcov
           ## so remove this from testing
if(require(RobExtremes) &amp;&amp; require(ismev)){

 data(portpirie)
 gevfit &lt;- gev.fit(portpirie[,2]) ## taken from example from ismev::gev.fit
 GEVF &lt;- GEVFamily(scale=gevfit$mle[2],shape=gevfit$mle[3],loc=gevfit$mle[1])
 erg &lt;- returnlevelplot(portpirie[,2], GEVF)
 print(names(erg))
 print(names(erg$plotArgs))
 print(names(erg$IdLineArgs))
 returnlevelplot(portpirie[,2], GEVF, datax=TRUE)

 data(rain)
 gpdfit &lt;- gpd.fit(rain,10) ## taken from example from ismev::gpd.fit
 GPDF &lt;- GParetoFamily(scale=gpdfit$mle[1],shape=gpdfit$mle[2],loc=10)
 returnlevelplot(rain, GPDF, MaxOrPOT="POT", xlim=c(1e-1,1e3))
}

## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='RiskType-class'>Risk</h2><span id='topic+RiskType-class'></span><span id='topic+show+2CRiskType-method'></span><span id='topic+type+2CRiskType-method'></span>

<h3>Description</h3>

<p>Class of risks; e.g., estimator risks.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
type of risk. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>type</dt><dd><p><code>signature(object = "RiskType")</code>: 
accessor function for slot <code>type</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "RiskType")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>

<hr>
<h2 id='SelfNorm'>Generating function for SelfNorm-class</h2><span id='topic+SelfNorm'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"SelfNorm"</code> &mdash;
used for self-standardized influence curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelfNorm()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"SelfNorm"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SelfNorm-class">SelfNorm-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
SelfNorm()

## The function is currently defined as
function(){ new("SelfNorm") }
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='symmetricBias'>Generating function for symmetricBias-class</h2><span id='topic+symmetricBias'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"symmetricBias"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetricBias(name = "symmetric Bias")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symmetricBias_+3A_name">name</code></td>
<td>
<p> name of the bias type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"symmetricBias"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symmetricBias-class">symmetricBias-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricBias()

## The function is currently defined as
function(){ new("symmetricBias", name = "symmetric Bias") }
</code></pre>

<hr>
<h2 id='symmetricBias-class'>symmetric Bias Type</h2><span id='topic+symmetricBias-class'></span>

<h3>Description</h3>

<p>Class of symmetric bias types.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("symmetricBias", ...)</code>.
More frequently they are created via the generating function 
<code>symmetricBias</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;symmetricBias&quot; in the signature.
</p>


<h3>Extends</h3>

<p>Class <code>"BiasType"</code>, directly.<br />
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiasType-class">BiasType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>symmetricBias()
## The function is currently defined as
function(){ new("symmetricBias", name = "symmetric Bias") }
</code></pre>

<hr>
<h2 id='trafo-methods'> Methods for function trafo in Package &lsquo;distrMod&rsquo; </h2><span id='topic+trafo-methods'></span><span id='topic+trafo'></span><span id='topic+trafo+2CEstimate+2Cmissing-method'></span><span id='topic+trafo+2CEstimate+2CParamFamParameter-method'></span><span id='topic+trafo+2CParamFamParameter+2Cmissing-method'></span><span id='topic+trafo+2CParamWithScaleAndShapeFamParameter+2Cmissing-method'></span><span id='topic+trafo+2CParamFamily+2Cmissing-method'></span><span id='topic+trafo+2CParamFamily+2CParamFamParameter-method'></span><span id='topic+trafo.fct'></span><span id='topic+trafo.fct-methods'></span><span id='topic+trafo.fct+2CParamFamily-method'></span><span id='topic+trafo+3C-'></span><span id='topic+trafo+3C-+2CParamFamParameter-method'></span><span id='topic+trafo+3C-+2CParamFamily-method'></span>

<h3>Description</h3>

<p>Methods for function <code>trafo</code> in package <span class="pkg">distrMod</span>;
there are accessor (<code>trafo</code>) and replacement (<code>trafo&lt;-</code>)
versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafo(object, param, ...)
## S4 method for signature 'Estimate,missing'
trafo(object,param)
## S4 method for signature 'ParamFamParameter,missing'
trafo(object,param)
## S4 method for signature 'ParamWithScaleAndShapeFamParameter,missing'
trafo(object,param)
## S4 method for signature 'ParamFamily,missing'
trafo(object,param)
## S4 method for signature 'ParamFamily,ParamFamParameter'
trafo(object,param)
## S4 method for signature 'Estimate,ParamFamParameter'
trafo(object,param)
trafo.fct(object)
trafo(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trafo-methods_+3A_object">object</code></td>
<td>
<p>an object of either class <code>Estimate</code>,
<code>ParamFamParameter</code>, <code>ParamFamily</code></p>
</td></tr>
<tr><td><code id="trafo-methods_+3A_param">param</code></td>
<td>
<p>an object of class <code>ParamFamParameter</code>; the parameter
value at which to evaluate the transformation</p>
</td></tr>
<tr><td><code id="trafo-methods_+3A_value">value</code></td>
<td>
<p>a matrix or a function; if it is a matrix, dimensions must
be consistent to the parametric setting; if it is function, it should
take one argument <code>param</code> of class <code>ParamFamParameter</code> and
return a list of length two with named components <code>fval</code>
(the function value, see below)
and <code>mat</code> (a matrix &mdash; with the same dimensions consistency
conditions as above).</p>
</td></tr>
<tr><td><code id="trafo-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods; not used so far.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>trafo</code> is a slot of class <code>ParamFamParameter</code>, which
in turn is a slot of class <code>ParamFamily</code>. It also sort of
arises in class <code>Estimate</code>, i.e., all slots can be identified
by the information contained in an instance thereof.
</p>
<p>As usual, <code>trafo</code> also is the accessor and replacement method 
for this slot. Its corresponding return value depends on the signature
for which the accessor / replacement method is used. More specifically,
for <code>trafo</code>, we have methods for the following signatures:
</p>

<dl>
<dt>signature <code>Estimate,missing</code>:</dt><dd><p>returns a list of length two with components
<code>fct</code> and <code>mat</code> (see below)</p>
</dd>
<dt>signature <code>Estimate,ParamFamParameter</code>:</dt><dd><p>returns a list of length two with components
<code>fct</code> and <code>mat</code> (see below)</p>
</dd>
<dt>signature <code>ParamFamParameter,missing</code>:</dt><dd><p>returns a matrix (see below)</p>
</dd>
<dt>signature <code>ParamFamily,missing</code>:</dt><dd><p>returns a matrix (see below)</p>
</dd>
<dt>signature <code>ParamFamily,ParamFamParameter</code>:</dt><dd><p>returns a list of length two
with components <code>fct</code> and <code>mat</code> (see below)</p>
</dd>
</dl>

<p><code>trafo</code> realizes partial influence curves; i.e.; we are only
interested in some possibly lower dimensional smooth (not necessarily
linear or even coordinate-wise) aspect/transformation <code class="reqn">\tau</code>
of the parameter <code class="reqn">\theta</code>.
</p>
<p>For the this function <code class="reqn">\tau()</code>, we provide an accessor 
<code>trafo.fct</code> for signature <code>ParamFamily-method</code>
returning this function.  
</p>
<p>To be coherent with the corresponding <em>nuisance</em>
implementation, we make the following convention:
</p>
<p>The full parameter <code class="reqn">\theta</code> is split up coordinate-wise
in a main parameter <code class="reqn">\theta'</code> and a nuisance parameter
<code class="reqn">\theta''</code> (which is unknown, too, hence has to be
estimated, but only is of secondary interest) and a fixed,
known part <code class="reqn">\theta'''</code>.
</p>
<p>Without loss of generality, we restrict ourselves to the case that
transformation <code class="reqn">\tau</code> only acts on the main parameter
<code class="reqn">\theta'</code> &mdash; if we want to transform the whole
parameter, we only have to assume that both nuisance parameter
<code class="reqn">\theta''</code> and fixed, known part of the parameter
<code class="reqn">\theta'''</code> have length 0.
</p>
<p>To the implementation:
</p>
<p>Slot <code>trafo</code> can either contain a (constant) matrix
<code class="reqn">D_\theta</code> or a function
</p>
<p style="text-align: center;"><code class="reqn">\tau\colon \Theta' \to \tilde \Theta,\qquad \theta \mapsto \tau(\theta)</code>
</p>
 
<p>mapping main parameter
<code class="reqn">\theta'</code> to some range <code class="reqn">\tilde \Theta</code>.
</p>
<p>If <em>slot value</em> <code>trafo</code> is a function, besides <code class="reqn">\tau(\theta)</code>, 
it will also return the corresponding derivative matrix
<code class="reqn">\frac{\partial}{\partial \theta}\tau(\theta)</code>.
More specifically, the return value of this function <code>theta</code> is a
list with entries <code>fval</code>, the function value <code class="reqn">\tau(\theta)</code>,
and <code>mat</code>, the derivative matrix.
</p>
<p>In case <code>trafo</code> is a matrix <code class="reqn">D</code>, we interpret it as such a derivative
matrix <code class="reqn">\frac{\partial}{\partial \theta}\tau(\theta)</code>,
and, correspondingly, <code class="reqn">\tau(\theta)</code> as the linear mapping
<code class="reqn">\tau(\theta)=D\,\theta</code>.<br />
</p>
<p>According to the signature, <em>method</em> <code>trafo</code> will return different
return value types. For signature
</p>

<dl>
<dt><code>Estimate,missing</code>:</dt><dd><p>it will return a list with entries
<code>fct</code>, the function  <code class="reqn">\tau</code>, and <code>mat</code>, the matrix
<code class="reqn">\frac{\partial}{\partial \theta}\tau(\theta)</code>.
function <code class="reqn">\tau</code> will then return the list <code>list(fval, mat)</code>
mentioned above.
</p>
</dd>
<dt><code>Estimate,ParamFamParameter</code>:</dt><dd><p>as signature
<code>Estimate,missing</code>.</p>
</dd>
<dt><code>ParamFamParameter,missing</code>:</dt><dd><p>it will just return the
corresponding matrix.</p>
</dd>
<dt><code>ParamFamily,missing</code>:</dt><dd><p>is just wrapper to signature
<code>ParamFamParameter,missing</code>.</p>
</dd>
<dt><code>ParamFamily,ParamFamParameter</code>:</dt><dd><p>as signature
<code>Estimate,missing</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Gaussian location and scale
NS &lt;- NormLocationScaleFamily(mean=2, sd=3)
## generate data out of this situation
x &lt;- r(distribution(NS))(30)

## want to estimate mu/sigma, sigma^2
## -&gt; new trafo slot:
trafo(NS) &lt;- function(param){
  mu &lt;- param["mean"]
  sd &lt;- param["sd"]
  fval &lt;- c(mu/sd, sd^2)
  nfval &lt;- c("mu/sig", "sig^2")
  names(fval) &lt;- nfval
  mat &lt;- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
  dimnames(mat) &lt;- list(nfval,c("mean","sd"))
  return(list(fval=fval, mat=mat))
}

## Maximum likelihood estimator
(res &lt;- MLEstimator(x = x, ParamFamily = NS))
## confidence interval
 confint(res)

</code></pre>

<hr>
<h2 id='trafoEst'> Function trafoEst in Package &lsquo;distrMod&rsquo; </h2><span id='topic+trafoEst'></span>

<h3>Description</h3>

<p><code>trafoEst</code> takes a <code class="reqn">\tau</code> like function (compare 
<code><a href="#topic+trafo-methods">trafo-methods</a></code>) and transforms an existing estimator by means 
of this transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafoEst(fct, estimator)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trafoEst_+3A_fct">fct</code></td>
<td>
<p>a <code class="reqn">\tau</code> like function, i.e., a function
in the main part <code class="reqn">\theta</code> of the parameter returning a list <code>list(fval, mat)</code>
where  <code>fval</code> is the function value <code class="reqn">\tau(\theta)</code>
of the transformation, and <code>mat</code>, its derivative matrix at
<code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="trafoEst_+3A_estimator">estimator</code></td>
<td>
<p>an object of class <code>Estimator</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The disadvantage of this proceeding is that the transformation is
not accounted for in determining the estimate (e.g. in a corresponding
optimality); it simply transforms an existing estimator, without
reapplying it to data. This becomes important in optimally robust
estimation.
</p>


<h3>Value</h3>

<p>exactly the argument <code>estimator</code>, but with modified slots
<code>estimate</code>,   <code>asvar</code>, and   <code>trafo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gaussian location and scale
NS &lt;- NormLocationScaleFamily(mean=2, sd=3)
## generate data out of this situation
x &lt;- r(distribution(NS))(30)

## want to estimate mu/sigma, sigma^2
## -&gt; without new trafo slot:
mtrafo &lt;- function(param){
  mu &lt;- param["mean"]
  sd &lt;- param["sd"]
  fval &lt;- c(mu/sd, sd^2)
  nfval &lt;- c("mu/sig", "sig^2")
  names(fval) &lt;- nfval
  mat &lt;- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
  dimnames(mat) &lt;- list(nfval,c("mean","sd"))
  return(list(fval=fval, mat=mat))
}

## Maximum likelihood estimator in the original problem
res0 &lt;- MLEstimator(x = x, ParamFamily = NS)
## transformation
res &lt;- trafoEst(mtrafo, res0)
## confidence interval
 confint(res)
</code></pre>

<hr>
<h2 id='trAsCov'>Generating function for trAsCov-class</h2><span id='topic+trAsCov'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"trAsCov"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trAsCov()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"trAsCov"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trAsCov-class">trAsCov-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>trAsCov()

## The function is currently defined as
function(){ new("trAsCov") }
</code></pre>

<hr>
<h2 id='trAsCov-class'>Trace of asymptotic covariance</h2><span id='topic+trAsCov-class'></span>

<h3>Description</h3>

<p>Class of trace of asymptotic covariance.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("trAsCov", ...)</code>.
More frequently they are created via the generating function 
<code>trAsCov</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;trace of asymptotic covariance&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"asRisk"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asRisk-class">asRisk-class</a></code>, <code><a href="#topic+trAsCov">trAsCov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("trAsCov")
</code></pre>

<hr>
<h2 id='trFiCov'>Generating function for trFiCov-class</h2><span id='topic+trFiCov'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"trFiCov"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trFiCov()</code></pre>


<h3>Value</h3>

<p>Object of class <code>"trFiCov"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trFiCov-class">trFiCov-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>trFiCov()

## The function is currently defined as
function(){ new("trFiCov") }
</code></pre>

<hr>
<h2 id='trFiCov-class'>Trace of finite-sample covariance</h2><span id='topic+trFiCov-class'></span>

<h3>Description</h3>

<p>Class of trace of finite-sample covariance.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("trFiCov", ...)</code>.
More frequently they are created via the generating function 
<code>trFiCov</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>:
&ldquo;trace of finite-sample covariance&rdquo;. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fiRisk"</code>, directly.<br />
Class <code>"RiskType"</code>, by class <code>"fiRisk"</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Ruckdeschel, P. and Kohl, M. (2005) How to approximate 
the finite sample risk of M-estimators. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fiRisk-class">fiRisk-class</a></code>, <code><a href="#topic+trFiCov">trFiCov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("trFiCov")
</code></pre>

<hr>
<h2 id='validParameter-methods'> Methods for function validParameter in Package &lsquo;distrMod&rsquo; </h2><span id='topic+validParameter-methods'></span><span id='topic+validParameter'></span><span id='topic+validParameter+2CParamFamily-method'></span><span id='topic+validParameter+2CL2ScaleUnion-method'></span><span id='topic+validParameter+2CL2ScaleFamily-method'></span><span id='topic+validParameter+2CL2LocationFamily-method'></span><span id='topic+validParameter+2CL2LocationScaleFamily-method'></span><span id='topic+validParameter+2CBinomFamily-method'></span><span id='topic+validParameter+2CPoisFamily-method'></span><span id='topic+validParameter+2CL2ScaleShapeUnion-method'></span>

<h3>Description</h3>

<p>Methods for function <code>validParameter</code> in package <span class="pkg">distrMod</span>
to check whether a new parameter (e.g. &quot;proposed&quot; by an optimization)
is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validParameter(object, ...)
## S4 method for signature 'ParamFamily'
validParameter(object, param)
## S4 method for signature 'L2ScaleUnion'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'L2ScaleFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'L2LocationFamily'
validParameter(object, param)
## S4 method for signature 'L2LocationScaleFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'BinomFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'PoisFamily'
validParameter(object, param, tol=.Machine$double.eps)
## S4 method for signature 'L2ScaleShapeUnion'
validParameter(object, param, tol=.Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validParameter-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>ParamFamily</code></p>
</td></tr>
<tr><td><code id="validParameter-methods_+3A_param">param</code></td>
<td>
<p>either a numeric vector or an object of class 
<code>ParamFamParameter</code></p>
</td></tr>
<tr><td><code id="validParameter-methods_+3A_tol">tol</code></td>
<td>
<p>accuracy upto which the conditions have to be fulfilled</p>
</td></tr>
<tr><td><code id="validParameter-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>method for signature
</p>

<dl>
<dt><code>ParamFamily</code></dt><dd><p>checks if all parameters are finite by <code>is.finite</code>
if their length is between 1 and the joint length of main and nuisance parameter
of <code>object</code>, and finally, if a call to <code>modifyParam(object)</code> with
argument <code>param</code> would throw an error.
</p>
</dd>
<dt><code>L2ScaleUnion</code></dt><dd><p>checks if the parameter is finite by <code>is.finite</code>,
and if it is strictly larger than 0 (upto argument <code>tol</code>). </p>
</dd>
<dt><code>L2ScaleFamily</code></dt><dd><p>checks if the parameter length is 1,
and otherwise uses <code>L2ScaleUnion</code>-method.</p>
</dd>
<dt><code>L2LocationFamily</code></dt><dd><p>checks if the parameter is finite by <code>is.finite</code>,
if its length is 1</p>
</dd>
<dt><code>L2LocationScaleFamily</code></dt><dd><p>checks if the parameter length is 1 or 2
(e.g. if one features as nuisance parameter), and also uses <code>L2ScaleUnion</code>-method. </p>
</dd>
<dt><code>BinomFamily</code></dt><dd><p>checks if the parameter is finite by <code>is.finite</code>,
if its length is 1, and if it is strictly larger than 0 and strictly smaller than 1 
(upto argument <code>tol</code>)</p>
</dd>
<dt><code>PoisFamily</code></dt><dd><p>checks if the parameter is finite by <code>is.finite</code>,
if its length is 1, and if it is strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
<dt><code>L2ScaleShapeUnion</code></dt><dd><p>uses <code>L2ScaleUnion</code>-method, checks if parameter
length is 1 or 2 (e.g. if one features as nuisance parameter), and if
<code>shape</code> is strictly larger than 0 (upto argument <code>tol</code>)</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>logical</code> of length 1 &mdash; valid or not</p>


<h3>Examples</h3>

<pre><code class='language-R'> NS &lt;- NormLocationScaleFamily()
 validParameter(NS, c(scale=0.1, loc=2))
 validParameter(NS, c(scale=-0.1, loc=2))
 validParameter(NS, c(scale=0, loc=2))
 validParameter(NS, c(mean=2, sd=2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
