<!DOCTYPE html><html lang="en"><head><title>Help for package FatTailsR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FatTailsR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FatTailsR-package'><p>Package FatTailsR</p></a></li>
<li><a href='#aw2k'><p>Local Conversion Functions Between Kiener Distribution Parameters</p></a></li>
<li><a href='#checkcoefk'><p>Check Coefk</p></a></li>
<li><a href='#checkquantiles'><p>Check Quantiles and Probabilities</p></a></li>
<li><a href='#ckiener1234'><p>Quantile (VaR) and Expected Shortfall Corrective Functions</p></a></li>
<li><a href='#dfData'><p>Datasets dfData, mData, tData, xData, zData, extractData : dfData</p></a></li>
<li><a href='#dimdim'><p>Length and Dimensions of Vector, Matrix, Array, Data.Frame, List</p></a></li>
<li><a href='#elevate'><p>Elevate</p></a></li>
<li><a href='#elevenprobs'><p>Eleven, Seven, Five Probabilities</p></a></li>
<li><a href='#estimkiener11'><p>Estimation Functions with 5, 7 or 11 Quantiles</p></a></li>
<li><a href='#exfit0'><p>Parameter Subsets</p></a></li>
<li><a href='#exphp'><p>Power Hyperbolas and Power Hyperbolic Functions</p></a></li>
<li><a href='#extractData'><p>Datasets dfData, mData, tData, xData, zData, extractData : extractData</p></a></li>
<li><a href='#fatreturns'><p>Simple and Elaborated Prices to Returns</p></a></li>
<li><a href='#fitkienerX'><p>Estimation and Regression Functions for Kiener Distributions</p></a></li>
<li><a href='#getDSdata'><p>Get DS Dataset</p></a></li>
<li><a href='#getnamesk'><p>Generate a list of vectors of characters from a vector of probabilities</p></a></li>
<li><a href='#kashp'><p>Kashp Function</p></a></li>
<li><a href='#kiener1'><p>Symmetric Kiener Distribution K1</p></a></li>
<li><a href='#kiener2'><p>Asymmetric Kiener Distribution K2</p></a></li>
<li><a href='#kiener3'><p>Asymmetric Kiener Distribution K3</p></a></li>
<li><a href='#kiener4'><p>Asymmetric Kiener Distribution K4</p></a></li>
<li><a href='#kiener7'><p>Asymmetric Kiener Distribution K7 (K2)</p></a></li>
<li><a href='#kmoments'><p>Moments Associated To Kiener Distribution Parameters</p></a></li>
<li><a href='#laplacegaussnorm'><p>Laplace-Gauss Normal Distribution Object</p></a></li>
<li><a href='#loghp'><p>Inverse Power Hyperbolas and Inverse Power Hyperbolic Functions</p></a></li>
<li><a href='#logishp'><p>The Power Hyperbola Logistic Distribution</p></a></li>
<li><a href='#logit'><p>Logit and Invlogit Functions</p></a></li>
<li><a href='#mData'><p>Datasets dfData, mData, tData, xData, zData, extractData : mData</p></a></li>
<li><a href='#pk2pk'><p>Global Conversion Function Between Kiener Distribution Parameters</p></a></li>
<li><a href='#pprobs0'><p>Several Vectors of Probabilities</p></a></li>
<li><a href='#regkienerLX'><p>Regression Function for Kiener Distributions</p></a></li>
<li><a href='#roundcoefk'><p>Round Coefk</p></a></li>
<li><a href='#tData'><p>Datasets dfData, mData, tData, xData, zData, extractData : tData</p></a></li>
<li><a href='#xData'><p>Datasets dfData, mData, tData, xData, zData, extractData : xData</p></a></li>
<li><a href='#zData'><p>Datasets dfData, mData, tData, xData, zData, extractData : zData</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Kiener Distributions and Fat Tails in Finance</td>
</tr>
<tr>
<td>Description:</td>
<td>Kiener distributions K1, K2, K3, K4 and K7 to characterize
    distributions with left and right, symmetric or asymmetric fat tails in market
    finance, neuroscience and other disciplines. Two algorithms to estimate with
    a high accuracy distribution parameters, quantiles, value-at-risk and expected
    shortfall. Include power hyperbolas and power hyperbolic functions. </td>
</tr>
<tr>
<td>Version:</td>
<td>1.8-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-03</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>minpack.lm, timeSeries, parallel, methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>zoo, xts</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrice Kiener <a href="https://orcid.org/0000-0002-0505-9920"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrice Kiener &lt;fattailsr@inmodelia.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.inmodelia.com/fattailsr-en.html">https://www.inmodelia.com/fattailsr-en.html</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'FatTailsR-package.R' 'a_data.R' 'b_fatreturns.R'
'c_trigohp.R' 'd_logishp.R' 'e_conversion.R' 'f_kiener1.R'
'g_kiener2.R' 'h_kiener3.R' 'i_kiener4.R' 'j_kiener7.R'
'k_kienerES.R' 'l_moments.R' 'm_laplaceroll.R' 'n_estimation.R'
'o_estimation2.R' 'p_regression.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 14:40:48 UTC; Patrice</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 15:22:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='FatTailsR-package'>Package FatTailsR</h2><span id='topic+FatTailsR-package'></span><span id='topic+FatTailsR'></span>

<h3>Description</h3>

<p>This package includes Kiener distributions K1, K2, K3, K4 and K7 and two estimation 
algorithms to characterize with a high precision symmetric or asymmetric 
distributions with left and right fat tails that appear in market finance, 
neuroscience and many other disciplines. The estimation of the distribution parameters, 
quantiles, value-at-risk and expected shortfall is usually very accurate. 
Two datasets are provided, as well as power hyperbolas and power hyperbolic 
functions which are simplified versions of symmetric distribution K1.
</p>
<p>Download the pdf cited in the references to get an overview of  
the theoretical part and several examples on stocks and indices. 
</p>
<p>A commercial package, <code>FatTailsRplot</code>, with advanced plotting functions 
and calculation of matrix of stocks over rolling windows is also developped 
by the author.
</p>


<h3>Details</h3>

<p>With so many functions, this package could look fat. But it's not! 
It's rather agile and easy to use! The various functions included in this package 
can be assigned to the following groups:
</p>

<ol>
<li><p> Two datasets presented in different formats:   
list, data.frame, matrix, timeSeries, xts, zoo:
</p>

<ul>
<li> <p><code><a href="#topic+getDSdata">getDSdata</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+extractData">extractData</a></code>, dfData, mData, tData, xData, zData.
</p>
</li></ul>

</li>
<li><p> Functions to check the dimensions of vector, matrix, array, list:
</p>

<ul>
<li> <p><code><a href="#topic+dimdim">dimdim</a></code>, dimdim1, dimdimc.
</p>
</li></ul>

</li>
<li><p> Functions to calculate (positive, negative) prices to returns 
on vector, matrix, array, list, data.frame, timeSeries, xts, zoo:
</p>

<ul>
<li> <p><code><a href="#topic+elevate">elevate</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+fatreturns">fatreturns</a></code>, logreturns.
</p>
</li></ul>

</li>
<li><p> Several predefined vectors of probability. One function to check them.
A conversion function from probabilities to characters 
</p>

<ul>
<li> <p><code><a href="#topic+pprobs0">pprobs0</a></code>, pprobs1, pprobs2, ..., pprobs9.
</p>
</li>
<li> <p><code><a href="#topic+checkquantiles">checkquantiles</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+getnamesk">getnamesk</a></code>.
</p>
</li></ul>

</li>
<li><p> Miscellaneous functions related to the logistic function:
</p>

<ul>
<li> <p><code><a href="#topic+logit">logit</a></code>, invlogit, ltmlogis, rtmlogis, eslogis.
</p>
</li></ul>

</li>
<li><p> Power hyperbolas, power hyperbolic functions and their reciprocal functions: 
</p>

<ul>
<li> <p><code><a href="#topic+exphp">exphp</a></code>, coshp, sinhp, tanhp, sechp, cosechp, 
cotanhp.
</p>
</li>
<li> <p><code><a href="#topic+loghp">loghp</a></code>, acoshp, asinhp, atanhp, asechp, 
acosechp, acotanhp.
</p>
</li>
<li> <p><code><a href="#topic+kashp">kashp</a></code>, dkashp_dx, ashp.
</p>
</li></ul>

</li>
<li><p> Logishp function, kogit and invkogit = logistic function + power hyperbolas: 
</p>

<ul>
<li><p> d, p, q, r, dp, dq, l, dl, ql <code><a href="#topic+logishp">logishp</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+kogit">kogit</a></code>, invkogit.
</p>
</li></ul>

</li>
<li><p> Conversion functions between parameters related to Kiener distributions K1, K2, K3, K4:
</p>

<ul>
<li> <p><code><a href="#topic+aw2k">aw2k</a></code>, aw2d, aw2e, ad2e, ad2k, ad2w, ae2d, ae2k, 
ae2w, ak2e, ak2w, de2a, de2k, de2w, dk2a, dk2e, dw2a, dw2e, 
dw2k, ek2a, ak2d, ek2w, aw2a, aw2d, ew2a, aw2d, ew2k, kd2a, 
kd2e, kd2w, ke2a, ke2d, ke2w, kw2a, kw2d, kw2e.
</p>
</li>
<li> <p><code><a href="#topic+pk2pk">pk2pk</a></code>.
</p>
</li></ul>

</li>
<li><p> Kiener distributions K1, K2, K3, K4 and the new K7 (introduced in v1.7-0):
</p>

<ul>
<li><p> d, p, q, r, dp, dq, l, dl, ql, var, ltm, rtm, dtmq, es <code><a href="#topic+kiener1">kiener1</a></code>,
</p>
</li>
<li><p> d, p, q, r, dp, dq, l, dl, ql, var, ltm, rtm, dtmq, es <code><a href="#topic+kiener2">kiener2</a></code>,
</p>
</li>
<li><p> d, p, q, r, dp, dq, l, dl, ql, var, ltm, rtm, dtmq, es <code><a href="#topic+kiener3">kiener3</a></code>,
</p>
</li>
<li><p> d, p, q, r, dp, dq, l, dl, ql, var, ltm, rtm, dtmq, es <code><a href="#topic+kiener4">kiener4</a></code>,
</p>
</li>
<li><p> d, p, q, r, dp, dq, l, dl, ql, var, ltm, rtm, dtmq, es <code><a href="#topic+kiener7">kiener7</a></code>.
</p>
</li></ul>

</li>
<li><p> Quantile (VaR) corrective function (as a multiplier of the logistic function). 
Expected shortfall corrective function (as a multiplier of the expected shortfall 
of the logistic distribution):
</p>

<ul>
<li> <p><code><a href="#topic+ckiener1">ckiener1</a></code>, ckiener2, ckiener3, ckiener4, ckiener7.
</p>
</li>
<li> <p><code><a href="#topic+hkiener1">hkiener1</a></code>, hkiener2, hkiener3, hkiener4, hkiener7.
</p>
</li></ul>

</li>
<li><p> Moments of the distribution estimated from the dataset and from 
the regression parameters:
</p>

<ul>
<li> <p><code><a href="#topic+xmoments">xmoments</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+kmoments">kmoments</a></code>, kmoment, kcmoment, kmean, 
kstandev, kvariance, kskewness, kkurtosis, kekurtosis.
</p>
</li></ul>

</li>
<li><p> Regression and estimation functions to estimate Kiener distribution
parameters on a given dataset. <code>*fit*</code> and <code>*param*</code> 
are wrappers of algorithms <code>reg</code> and <code>estim</code>.
<code>reg</code> uses an unweighted nonlinear regression function. 
<code>estim</code> uses a fast estimation based on quantiles:
</p>

<ul>
<li> <p><code><a href="#topic+regkienerLX">regkienerLX</a></code>, <code><a href="#topic+laplacegaussnorm">laplacegaussnorm</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+fitkienerX">fitkienerX</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+paramkienerX">paramkienerX</a>, paramkienerX5, paramkienerX7</code>.
</p>
</li></ul>

</li>
<li><p> Functions related to <code>paramkienerX</code>:
</p>

<ul>
<li> <p><code><a href="#topic+elevenprobs">elevenprobs</a></code>, sevenprobs, fiveprobs.
</p>
</li>
<li> <p><code><a href="#topic+estimkiener11">estimkiener11</a></code>, estimkiener7, estimkiener5.
</p>
</li>
<li> <p><code><a href="#topic+roundcoefk">roundcoefk</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+checkcoefk">checkcoefk</a></code>.
</p>
</li></ul>

</li>
<li><p> Predefined subsets of parameters to extract them 
from the long vector <code>fitk</code> obtained after regression/estimation 
<code>regkienerLX</code>, <code>fitkienerX</code> :
</p>

<ul>
<li> <p><code><a href="#topic+exfit0">exfit0</a></code>, ..., <code>exfit7</code>.
</p>
</li></ul>

</li></ol>

<p>For a quick start, jump to the functions <code><a href="#topic+regkienerLX">regkienerLX</a></code>,  
<code><a href="#topic+fitkienerX">fitkienerX</a></code> and run the examples. 
Then, download and read the documents in pdf format cited in the references 
to get an overview on the major functions. Finally, explore the other 
examples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Patrice Kiener <a href="mailto:fattailsr@inmodelia.com">fattailsr@inmodelia.com</a> (<a href="https://orcid.org/0000-0002-0505-9920">ORCID</a>)
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014. Download it from: 
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.inmodelia.com/fattailsr-en.html">https://www.inmodelia.com/fattailsr-en.html</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    

require(graphics)
require(minpack.lm)
require(timeSeries)

### Load the datasets and select one number (1-16)
DS     &lt;- getDSdata()
j      &lt;- 5

### and run this block
X      &lt;- DS[[j]]
nameX  &lt;- names(DS)[j]
reg    &lt;- regkienerLX(X)
lgn    &lt;- laplacegaussnorm(X)
lleg   &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", 
           "logit(0.95)   = 2.9", "logit(0.50)   = 0", 
           "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
pleg   &lt;- c( paste("m =",  reg$coefr4[1]), paste("g  =", reg$coefr4[2]), 
             paste("k  =", reg$coefr4[3]), paste("e  =", reg$coefr4[4]) )

## Main plot
op     &lt;- par(mfrow = c(1,1), mgp = c(1.5,0.8,0), mar = c(3,3,2,1))
plot(reg$dfrXP, main = nameX)
legend("top", legend = pleg, cex = 0.9, inset = 0.02 )
lines(reg$dfrEP, col = 2, lwd = 2)
points(reg$dfrQkPk, pch = 3, col = 2, lwd = 2, cex = 1.5)
lines(lgn$dfrXPn, col = 7, lwd = 2)

## Plot F(X) &gt; 0,97
front = c(0.06, 0.39, 0.50, 0.95)
par(fig = front, new = TRUE, mgp = c(1.5, 0.6, 0), las = 0)
plot( reg$dfrXP[which(reg$dfrXP$P &gt; 0.97),] , pch = 1, xlab = "", ylab = "", main = "F(X) &gt; 0,97" )
lines(reg$dfrEP[which(reg$dfrEP$P &gt; 0.97),], type="l", col = 2, lwd = 3 )
lines(lgn$dfrXPn[which(lgn$dfrXPn$Pn &gt; 0.97),], type = "l", col = 7, lwd= 2 )
points(reg$dfrQkPk, pch = 3, col = 2, lwd = 2, cex = 1.5)
points(lgn$dfrQnPn, pch = 3, col = 7, lwd = 2, cex = 1)

## Plot F(X) &lt; 0,03
front = c(0.58, 0.98, 0.06, 0.61)
par(fig = front, new = TRUE, mgp = c(0.5, 0.6, 0), las = 0 )
plot( reg$dfrXP[which(reg$dfrXP$P &lt; 0.03),] , pch = 1, xlab = "", ylab = "", main = "F(X) &lt; 0,03")
lines(reg$dfrEP[which(reg$dfrEP$P &lt; 0.03),], type = "l", col = 2, lwd = 3 )
lines(lgn$dfrXPn[which(lgn$dfrXPn$Pn &lt; 0.03),], type = "l", col= 7, lwd= 2 )
points(reg$dfrQkPk, pch = 3, col = 2, lwd = 2, cex = 1.5)
points(lgn$dfrQnPn, pch = 3, col = 7, lwd = 2, cex = 1)

## Moments from the parameters (k) and from the Dataset (X)
round(cbind("k" = kmoments(reg$coefk, lengthx = nrow(reg$dfrXL)), "X" = xmoments(X)), 2)
attributes(reg)
### End block


</code></pre>

<hr>
<h2 id='aw2k'>Local Conversion Functions Between Kiener Distribution Parameters</h2><span id='topic+aw2k'></span><span id='topic+aw2d'></span><span id='topic+aw2e'></span><span id='topic+ad2e'></span><span id='topic+ad2k'></span><span id='topic+ad2w'></span><span id='topic+ae2d'></span><span id='topic+ae2k'></span><span id='topic+ae2w'></span><span id='topic+ak2d'></span><span id='topic+ak2e'></span><span id='topic+ak2w'></span><span id='topic+de2a'></span><span id='topic+de2k'></span><span id='topic+de2w'></span><span id='topic+dk2a'></span><span id='topic+dk2e'></span><span id='topic+dk2w'></span><span id='topic+dw2a'></span><span id='topic+dw2e'></span><span id='topic+dw2k'></span><span id='topic+ek2a'></span><span id='topic+ek2d'></span><span id='topic+ek2w'></span><span id='topic+ew2a'></span><span id='topic+ew2d'></span><span id='topic+ew2k'></span><span id='topic+kd2a'></span><span id='topic+kd2e'></span><span id='topic+kd2w'></span><span id='topic+ke2a'></span><span id='topic+ke2d'></span><span id='topic+ke2w'></span><span id='topic+kw2a'></span><span id='topic+kw2d'></span><span id='topic+kw2e'></span>

<h3>Description</h3>

<p>Conversion functions between parameters <code>a</code>, <code>k</code>, <code>w</code>, 
<code>d</code>, <code>e</code> used in Kiener distributions K2, K3 and K4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw2k(a, w)

aw2d(a, w)

aw2e(a, w)

ad2e(a, d)

ad2k(a, d)

ad2w(a, d)

ae2d(a, e)

ae2k(a, e)

ae2w(a, e)

ak2d(a, k)

ak2e(a, k)

ak2w(a, k)

de2a(d, e)

de2k(d, e)

de2w(d, e)

dk2a(d, k)

dk2e(d, k)

dk2w(d, k)

dw2a(d, w)

dw2e(d, w)

dw2k(d, w)

ek2a(e, k)

ek2d(e, k)

ek2w(e, k)

ew2a(e, w)

ew2d(e, w)

ew2k(e, w)

kd2a(k, d)

kd2e(k, d)

kd2w(k, d)

ke2a(k, e)

ke2d(k, e)

ke2w(k, e)

kw2a(k, w)

kw2d(k, w)

kw2e(k, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aw2k_+3A_a">a</code></td>
<td>
<p>a numeric value.</p>
</td></tr>
<tr><td><code id="aw2k_+3A_w">w</code></td>
<td>
<p>a numeric value.</p>
</td></tr>
<tr><td><code id="aw2k_+3A_d">d</code></td>
<td>
<p>a numeric value.</p>
</td></tr>
<tr><td><code id="aw2k_+3A_e">e</code></td>
<td>
<p>a numeric value.</p>
</td></tr>
<tr><td><code id="aw2k_+3A_k">k</code></td>
<td>
<p>a numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>a</code> (alpha) is the left tail parameter, 
<code>w</code> (omega) is the right tail parameter, 
<code>d</code> (delta) is the distortion parameter, 
<code>e</code> (epsilon) is the eccentricity parameter. 
<code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> and 
describes a global tail parameter. 
They are defined by: 
</p>
<p style="text-align: center;"><code class="reqn"> aw2k(a, w) = k = 2 / (1/a + 1/w) = \frac{2}{\frac{1}{a} +\frac{1}{w}}  </code>
</p>

<p style="text-align: center;"><code class="reqn"> aw2d(a, w) = d = (-1/a + 1/w) / 2 = \frac{-\frac{1}{a} +\frac{1}{w}}{2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> aw2e(a, w) = e = (a - w) / (a + w) = \frac{a-w}{a+w} </code>
</p>

<p style="text-align: center;"><code class="reqn"> kd2a(k, d) = a = 1 / ( 1/k - d) = \frac{1}{\frac{1}{k} - d} </code>
</p>

<p style="text-align: center;"><code class="reqn"> kd2w(k, d) = w = 1 / ( 1/k + d) = \frac{1}{\frac{1}{k} + d} </code>
</p>

<p style="text-align: center;"><code class="reqn"> ke2a(k, e) = a = k / (1 - e) = \frac{k}{1-e} </code>
</p>

<p style="text-align: center;"><code class="reqn"> ke2w(k, e) = w = k / (1 + e) = \frac{k}{1+e} </code>
</p>

<p style="text-align: center;"><code class="reqn"> ke2d(k, e) = d = e / k = \frac{e}{k} </code>
</p>

<p style="text-align: center;"><code class="reqn"> kd2e(k, d) = e = k * d </code>
</p>

<p style="text-align: center;"><code class="reqn"> de2k(k, e) = k = e / d = \frac{e}{d} </code>
</p>



<h3>See Also</h3>

<p>The asymmetric Kiener distributions K2, K3, K4:  
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aw2k(4, 6); aw2d(4, 6); aw2e(4, 6)
outer(1:6, 1:6, aw2k)

</code></pre>

<hr>
<h2 id='checkcoefk'>Check Coefk</h2><span id='topic+checkcoefk'></span>

<h3>Description</h3>

<p>Check that coefk is either a vector of length 7 or a matrix with 7 columns
or an array with length of last dimension equal to 7.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkcoefk(coefk, dim = c(1, 2), STOP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkcoefk_+3A_coefk">coefk</code></td>
<td>
<p>numeric, matrix or data.frame representing
parameters <code>c(m,g,a,k,w,d,e)</code>.</p>
</td></tr>
<tr><td><code id="checkcoefk_+3A_dim">dim</code></td>
<td>
<p>numeric. Accepted dimension(s) for coefk: 1 for vector, 
2 for matrix, 3 for array. List is not accepted.  
Default is c(1, 2).</p>
</td></tr>
<tr><td><code id="checkcoefk_+3A_stop">STOP</code></td>
<td>
<p>boolean. If an error is encountered, TRUE stops
the function and returns an error message. 
FALSE just returns FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    

(coefk &lt;- paramkienerX(getDSdata()))
checkcoefk(coefk)
checkcoefk(t(coefk), STOP = FALSE)

</code></pre>

<hr>
<h2 id='checkquantiles'>Check Quantiles and Probabilities</h2><span id='topic+checkquantiles'></span>

<h3>Description</h3>

<p>Check that quantiles (or probabilities) are all 
different from each other and correctly ordered. 
If <code>proba = TRUE</code>, check that values are in range (0, 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkquantiles(x, proba = FALSE, acceptNA = FALSE, STOP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkquantiles_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="checkquantiles_+3A_proba">proba</code></td>
<td>
<p>boolean. If TRUE, check range (0,1).</p>
</td></tr>
<tr><td><code id="checkquantiles_+3A_acceptna">acceptNA</code></td>
<td>
<p>boolean. If FALSE, NA value are not accepted.</p>
</td></tr>
<tr><td><code id="checkquantiles_+3A_stop">STOP</code></td>
<td>
<p>boolean. If an error is encountered, TRUE stops
the function and returns an error message. 
FALSE just returns FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    

lst &lt;- list(
  0.8,
  c(0.1, 0.5, 0.8),
  c(0.1, 0.5, 0.8, 0.2),
  c(2, 3, 1),
  c(2, 3),
  -0.01,
  NA,
  c(NA, NA),
  c(0.1, NA),
  c(0.1, NA, 0.5, 0.8),
  c(0.1, NA, 0.8, NA, 0.5),
  c(12, NA)
)

## Evaluate
for (i in seq_along(lst)) { 
  cat(i, lst[[i]], " : ",
      checkquantiles(lst[[i]], proba = FALSE, STOP = FALSE), 
      checkquantiles(lst[[i]], proba = TRUE, STOP = FALSE), 
      checkquantiles(lst[[i]], proba = FALSE, acceptNA = TRUE, STOP = FALSE), 
      checkquantiles(lst[[i]], proba = TRUE,  acceptNA = TRUE, STOP = FALSE), 
	     "\n") 
}

sapply(lst, checkquantiles, proba = TRUE, acceptNA = TRUE, STOP = FALSE)

## Not run: 
checkquantiles(matrix((1:12)/16, ncol=3), proba = TRUE, STOP = FALSE)
## End(Not run)

</code></pre>

<hr>
<h2 id='ckiener1234'>Quantile (VaR) and Expected Shortfall Corrective Functions</h2><span id='topic+ckiener1234'></span><span id='topic+hkiener1'></span><span id='topic+hkiener2'></span><span id='topic+hkiener3'></span><span id='topic+hkiener4'></span><span id='topic+hkiener7'></span><span id='topic+ckiener1'></span><span id='topic+ckiener2'></span><span id='topic+ckiener3'></span><span id='topic+ckiener4'></span><span id='topic+ckiener7'></span>

<h3>Description</h3>

<p>Quantile functions (or VaR) and Expected Shortfall of Kiener distributions 
K1, K2, K3 and K4, usually calculated at pprobs2 = c(0.01, 0.025, 0.05, 0.95, 0.975, 0.99), 
can be expressed as: 
</p>

<ol>
<li><p> Quantile of the logit function multiplied by a fat tail 
(c)orrective function <code>ckiener1234</code>;
</p>
</li>
<li><p> Expected s(h)ortfall of the logistic function multiplied 
by a corrective function <code>hkiener1234</code>. 
</p>
</li></ol>

<p>Both functions <code>ckiener1234</code> and <code>hkiener1234</code> are independant from 
the scale parameter <code>g</code> and are indirect measures of the tail curvature. 
A value close to <code>1</code> indicates a model similar to the logistic function with  
almost no curvature and probably parameter <code>k &gt; 8</code>. When <code>k</code> (or <code>a,w</code>) 
decreases, the values of <code>c</code> and <code>h</code> increase and indicate some more 
pronounced symmetric or asymmetric curvature, depending on values of <code>d,e</code>. 
Note that if <code>(min(a,k,w) &lt;= 1)</code>, <code>ckiener1234</code> still exists but 
the expected shortfall and <code>hkiener1234</code> become undefined (<code>NA</code>).
</p>
<p>Some financial applications use threshold values on <code>ckiener1234</code> or 
<code>hkiener1234</code> to select or discard stocks over time as they become 
less or more risky.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hkiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE, log.p = FALSE)

hkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

hkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

hkiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

hkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

ckiener1(p, k = 3.2, lower.tail = TRUE, log.p = FALSE)

ckiener2(p, a = 3.2, w = 3.2, lower.tail = TRUE, log.p = FALSE)

ckiener3(p, k = 3.2, d = 0, lower.tail = TRUE, log.p = FALSE)

ckiener4(p, k = 3.2, e = 0, lower.tail = TRUE, log.p = FALSE)

ckiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ckiener1234_+3A_p">p</code></td>
<td>
<p>numeric or vector of probabilities.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_m">m</code></td>
<td>
<p>numeric. parameter m used in model K1, K2, K3 and K4.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_g">g</code></td>
<td>
<p>numeric. parameter g used in model K1, K2, K3 and K4.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_k">k</code></td>
<td>
<p>numeric. parameter k used in model K1, K3 and K4.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_a">a</code></td>
<td>
<p>numeric. parameter a used in model K2.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_w">w</code></td>
<td>
<p>numeric. parameter w used in model K2.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_d">d</code></td>
<td>
<p>numeric. parameter d used in model K3.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_e">e</code></td>
<td>
<p>numeric. parameter e used in model K4.</p>
</td></tr>
<tr><td><code id="ckiener1234_+3A_coefk">coefk</code></td>
<td>
<p>vector or 7 columns-matrix representing parameters 
<code>c(m,g,a,k,w,d,e)</code> obtained from <code><a href="#topic+paramkienerX">paramkienerX</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logit">logit</a></code>, <code><a href="#topic+qkiener1">qkiener1</a></code>, <code><a href="#topic+qkiener2">qkiener2</a></code>, 
<code><a href="#topic+qkiener3">qkiener3</a></code>, <code><a href="#topic+qkiener4">qkiener4</a></code>, <code><a href="#topic+fitkienerX">fitkienerX</a></code>.
</p>

<hr>
<h2 id='dfData'>Datasets dfData, mData, tData, xData, zData, extractData : dfData</h2><span id='topic+dfData'></span>

<h3>Description</h3>

<p>A list of datasets in data.frame, matrix, timeSeries, xts and zoo formats. 
This is the data.frame format. 
Visit <code><a href="#topic+extractData">extractData</a></code> for more information.
</p>

<hr>
<h2 id='dimdim'>Length and Dimensions of Vector, Matrix, Array, Data.Frame, List</h2><span id='topic+dimdim'></span><span id='topic+dimdim1'></span><span id='topic+dimdimc'></span>

<h3>Description</h3>

<p>Dimensions and length of vector, matrix, array, data.frame and list. 
A friendly version of <code>dim</code> that returns the true dimension 
rather than the sometimes unexpected <code>NULL</code> value. 
The number of dimensions appears first, then the length in each dimension. 
A special case is list: the list's length (number of items) is turned into a 
negative integer and the dimension/length of each item is either positive 
if the item is a vector, matrix, array or data.frame or negative if the item 
is itself a list. Only the first level of the list is explored. 
</p>
<p><code>dimdim1</code> and <code>dimdimc</code> return the first item of <code>dimdim</code>, 
thus the true dimension, either as an integer or as a character 
and, in this latest case, always <code>"-1"</code> for lists. 
</p>
<p>Notes: From version 1.6.2 (April 2016), <code>dimdim(NULL) = c(0, 0)</code>.  
(before <code>c(1, 0)</code>). Hence, <code>dimdim1(NULL) = 0</code> and 
<code>dimdimc(NULL) = "0"</code>. 
Some problems may occur with S4 objects like 
<code>dimdim(qualityTools::fracDesign(k = 3, gen = "C = AB"))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimdim(x)

dimdim1(x)

dimdimc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimdim_+3A_x">x</code></td>
<td>
<p>vector, matrix, array, data.frame, list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
require(timeSeries)

dimdim(NULL) 
dimdim(NA); dimdim(NaN); dimdim(Inf); dimdim(TRUE); dimdim(FALSE)
dimdim(11:39)
dimdim(LETTERS[1:8])
dimdim(matrix(1:60, ncol=5))
dimdim(extractData())
dimdim(as.data.frame(extractData()))
dimdim(data.frame(X=1:2, Y=1:4, Z=LETTERS[1:8]))
dimdim(array(1:240, c(8,6,5)))
dimdim(array(1:240, c(4,2,6,5)))
dimdim(getDSdata())
dimdim(zData)
dimdim(xData)
dimdim(tData)

dimdim1(matrix(1:60, ncol=5))
dimdimc(matrix(1:60, ncol=5))
dimdim1(tData)
dimdimc(tData)

</code></pre>

<hr>
<h2 id='elevate'>Elevate</h2><span id='topic+elevate'></span>

<h3>Description</h3>

<p>A transformation to turn negative prices into positive prices
and maintain at the same time the hierachy between all prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elevate(X, e = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elevate_+3A_x">X</code></td>
<td>
<p>The prices.</p>
</td></tr>
<tr><td><code id="elevate_+3A_e">e</code></td>
<td>
<p>numeric. The focal point of the hyperbola.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Negative prices in financial markets, like interest rates in Europe, are a 
nightmare as the rough calculation of the returns generates non-sense values.
<code>elevate</code> uses an hyperbola and implements the following formula: 
</p>
<p style="text-align: center;"><code class="reqn"> elevate(x, e) = (x + sqrt(x*x + e*e)) / 2 </code>
</p>

<p>There is currently no rule of thumb to calculate <code>e</code>. 
When <code class="reqn">e = NULL</code>, there is no change and the output is identical to the input.
When <code class="reqn">e = 0</code>, all negative values are turned to 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
require(graphics)

X &lt;- (-50:100)/5
plot( X, elevate(X, e = 5), type = "l", ylim = c(0, 20) )
lines(X, elevate(X, e = 2),   col = 2)
lines(X, elevate(X, e = 1),   col = 3)
lines(X, elevate(X, e = 0.5), col = 4)
lines(X, elevate(X, e = 0),   col = 1)

</code></pre>

<hr>
<h2 id='elevenprobs'>Eleven, Seven, Five Probabilities</h2><span id='topic+elevenprobs'></span><span id='topic+sevenprobs'></span><span id='topic+fiveprobs'></span>

<h3>Description</h3>

<p>Extract from a dataset <code>X</code> a vector of 11, 7 or 5 probabilities: 
</p>

<ul>
<li> <p><code>c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code> 
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code> 
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code> 
</p>
</li></ul>

<p>where p1, p2 and p3 are the most extreme probabilities with values finishing 
by <code>..01</code>, <code>..025</code> or <code>..05</code> that can be extracted from the 
dataset <code>X</code>. Parameters names are displayed if <code>parnames = TRUE</code>.
</p>
<p>From version 1.8-0, p1 and 1-p1 can be associated to the i-th and (N-i)-th element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elevenprobs(X, parnames = FALSE)

sevenprobs(X, parnames = FALSE)

fiveprobs(X, i = 4, parnames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elevenprobs_+3A_x">X</code></td>
<td>
<p>numeric. Vector of quantiles.</p>
</td></tr>
<tr><td><code id="elevenprobs_+3A_parnames">parnames</code></td>
<td>
<p>boolean. Output parameter vector with or without names.</p>
</td></tr>
<tr><td><code id="elevenprobs_+3A_i">i</code></td>
<td>
<p>integer. The i-th and (N-i)-th elements for which the 
probabilities p1 and 1-p1 are calculated. If (i == 0), the 
method used before version 1.8-0 : the extreme finishing 
by <code>..01</code>, <code>..025</code> or <code>..05</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fitkienerX">fitkienerX</a></code>, <code><a href="#topic+estimkiener11">estimkiener11</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(timeSeries)

## DS
DS  &lt;- getDSdata()
for (j in 1:16) { print(round(elevenprobs(DS[[j]]), 6)) }
z   &lt;- cbind(t(sapply(DS, elevenprobs)), sapply(DS, length))
colnames(z) &lt;- c("p1","p2","p3","p.25","p.35","p.50","p.65","p.75","1-p3","1-p2","1-p1","length")
z

## Choose j in 1:16
j   &lt;- 1
X   &lt;- sort(DS[[j]])
leX &lt;- logit(eX &lt;- elevenprobs(X))
lpX &lt;- logit(ppoints(length(X), a = 0))
plot(X, lpX)
abline(h = leX, lty = 3)
mtext(eX, side = 4, at = leX, las = 1, line = -3.3)



</code></pre>

<hr>
<h2 id='estimkiener11'>Estimation Functions with 5, 7 or 11 Quantiles</h2><span id='topic+estimkiener11'></span><span id='topic+estimkiener7'></span><span id='topic+estimkiener5'></span>

<h3>Description</h3>

<p>Several functions to estimate the parameters of asymmetric Kiener distributions 
with just 5, 7 or 11 quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimkiener11(x11, p11, ord = 7, maxk = 10)

estimkiener7(x7, p7, maxk = 10)

estimkiener5(x5, p5, maxk = 20, maxe = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimkiener11_+3A_ord">ord</code></td>
<td>
<p>integer. Option for probability selection and treatment.</p>
</td></tr>
<tr><td><code id="estimkiener11_+3A_maxk">maxk</code></td>
<td>
<p>numeric. Maximum value for k (kappa).</p>
</td></tr>
<tr><td><code id="estimkiener11_+3A_x5">x5</code>, <code id="estimkiener11_+3A_x7">x7</code>, <code id="estimkiener11_+3A_x11">x11</code></td>
<td>
<p>vector of 5, 7 or 11 quantiles.</p>
</td></tr>
<tr><td><code id="estimkiener11_+3A_p5">p5</code>, <code id="estimkiener11_+3A_p7">p7</code>, <code id="estimkiener11_+3A_p11">p11</code></td>
<td>
<p>vector of 5, 7 or 11 probabilities.</p>
</td></tr>
<tr><td><code id="estimkiener11_+3A_maxe">maxe</code></td>
<td>
<p>numeric. Maximum value for abs(e) (epsilon).
Maximum is <code>maxe = 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions, called by <code>paramkienerX5</code>, <code>paramkienerX7</code>, 
<code><a href="#topic+paramkienerX">paramkienerX</a></code>, use 5, 7 or 11 probabilites and quantiles 
to estimate the parameters of Kiener distributions.   
</p>
<p><code>p5, x5</code> are obtained with functions <code>fiveprobs(X)</code> and <code>quantile(p5)</code>.  
</p>
<p><code>p7, x7</code> are obtained with functions <code>sevenprobs(X)</code> and <code>quantile(p7)</code>.  
</p>
<p><code>p11, x11</code> are obtained with functions <code>elevenprobs(X)</code> and <code>quantile(p11)</code>.
</p>
<p>The extraction of the 11 probabilities is controlled with the option <code>ord</code> 
which can take 12 integer values, <code>ord = 7</code> being the default. 
Small dataset should consider <code>ord = 5</code> and 
large dataset can consider <code>ord = 12</code>: 
</p>

<ol>
<li> <p><code>c(p1, 0.35, 0.50, 0.65, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.35, 0.50, 0.65, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.35, 0.50, 0.65, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.35, 0.50, 0.65, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.50, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.50, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li></ol>

<p><code>p5 = fiveprobs(X)</code> corresponds to <code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code>.
</p>
<p><code>p7 = sevenprobs(X)</code> corresponds to <code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code>.
</p>
<p>The above probabilities are then transfered to the <code><a href="stats.html#topic+quantile">quantile</a></code> function 
whose parameter <code>type</code> can change significantly the extracted quantiles. 
Our experience is that <code>type = 6</code> is appropriate when <code>k &gt; 1.9</code> and 
<code>type = 5</code> is appropriate when <code>k &lt; 1.9</code>. 
Other types <code>type = 8</code> and <code>type = 9</code> can be considered as well. 
The other types should be ignored. 
(Note: when <code>k &lt; 1.5</code>, algorithm <code>algo = "reg"</code> returns better  
results).
</p>
<p>Parameter maxk controls the maximum allowed value for estimated parameter k. 
Reasonnable values are <code>maxk = 10, 15, 20</code>. Default is <code>maxk = 10</code> 
to be consistent with <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elevenprobs">elevenprobs</a></code>, <code><a href="#topic+paramkienerX">paramkienerX</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="#topic+roundcoefk">roundcoefk</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    

require(timeSeries)

## Choose j in 1:16. Choose ord in 1:12 (7 is default)
j    &lt;- 5
ord  &lt;- 5
DS   &lt;- getDSdata()
p11  &lt;- elevenprobs(DS[[j]])
x11  &lt;- quantile(DS[[j]], probs = p11, na.rm = TRUE, names = TRUE, type = 6) 
round(estimkiener11(x11, p11, ord), 3)

## Compare the results obtained with the 12 different values of ord on stock j
compare &lt;- function(ord, x11, p11) {estimkiener11(x11, p11, ord)}
coefk   &lt;- t(sapply(1:12, compare, x11, p11)) 
rownames(coefk) &lt;- 1:12
mcoefk  &lt;- apply(coefk, 2, mean) # the mean of the 12 results above
roundcoefk(rbind(coefk, mcoefk), 13)


</code></pre>

<hr>
<h2 id='exfit0'>Parameter Subsets</h2><span id='topic+exfit0'></span><span id='topic+exfit1'></span><span id='topic+exfit2'></span><span id='topic+exfit3'></span><span id='topic+exfit4'></span><span id='topic+exfit5'></span><span id='topic+exfit6'></span><span id='topic+exfit7'></span>

<h3>Description</h3>

<p>Some vectors of parameter names to be used with parameter <code>exfitk</code> in 
functions regkienerLX(.., exfitk = ...) and <code>fitkienerX(.., exfitk = ...)</code>
or to subset the vector (or matrix) <code>fitk </code> obtained after regression 
<code>fitk &lt;- regkienerLX(..)$fitk</code> or estimation <code>fitk &lt;- fitkienerX(..)</code>. 
Visit <code><a href="#topic+fitkienerX">fitkienerX</a></code> for details on each parameter.
</p>
<p><code>exfit0 &lt;- c("lh", "ret")</code>
</p>
<p><code>exfit1 &lt;- c("m", "g", "a", "k", "w", "d", "e")</code>
</p>
<p><code>exfit2 &lt;- c("m1", "sd", "sk", "ke", "m1x", "sdx", "skx", "kex")</code>
</p>
<p><code>exfit3 &lt;- c("q.01", "q.05", "q.95", "q.99", "ltm.025", "rtm.975")</code>
</p>
<p><code>exfit4 &lt;- c("VaR.01", "VaR.05", "VaR.95", "VaR.99", "ES.025", "ES.975")</code>
</p>
<p><code>exfit5 &lt;- c("c.01", "c.05", "c.95", "c.99", "h.025", "h.975")</code>
</p>
<p><code>exfit6 &lt;- c(exfit1, exfit2, exfit3, exfit4, exfit5)</code>
</p>
<p><code>exfit7 &lt;- c(exfit0, exfit1, exfit2, exfit3, exfit4, exfit5)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exfit0

exfit1

exfit2

exfit3

exfit4

exfit5

exfit6

exfit7
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 2.
</p>
<p>An object of class <code>character</code> of length 7.
</p>
<p>An object of class <code>character</code> of length 8.
</p>
<p>An object of class <code>character</code> of length 6.
</p>
<p>An object of class <code>character</code> of length 6.
</p>
<p>An object of class <code>character</code> of length 6.
</p>
<p>An object of class <code>character</code> of length 33.
</p>
<p>An object of class <code>character</code> of length 35.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    

require(minpack.lm)
require(timeSeries)

### Load the datasets and select one number j in 1:16
j      &lt;- 5
DS     &lt;- getDSdata()
(fitk  &lt;- regkienerLX(DS[[j]])$fitk)
fitk[exfit3]
fitkienerX(DS[[j]], exfitk = exfit3)


</code></pre>

<hr>
<h2 id='exphp'>Power Hyperbolas and Power Hyperbolic Functions</h2><span id='topic+exphp'></span><span id='topic+coshp'></span><span id='topic+sinhp'></span><span id='topic+tanhp'></span><span id='topic+sechp'></span><span id='topic+cosechp'></span><span id='topic+cotanhp'></span>

<h3>Description</h3>

<p>These functions define the power hyperbola <code>exphp</code> and the associated 
power hyperbolic cosine, sine, tangent, secant, cosecant, cotangent. 
They are similar to the traditional hyperbolic functions with term
<code>x</code> receiving a nonlinear transformation via the function 
<code><a href="#topic+kashp">kashp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exphp(x, k = 1)

coshp(x, k = 1)

sinhp(x, k = 1)

tanhp(x, k = 1)

sechp(x, k = 1)

cosechp(x, k = 1)

cotanhp(x, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exphp_+3A_x">x</code></td>
<td>
<p>a numeric value, vector or matrix.</p>
</td></tr>
<tr><td><code id="exphp_+3A_k">k</code></td>
<td>
<p>a numeric value, preferably strictly positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>exphp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> exphp(x, k) =  exp( kashp(x, k) )  
                         =  exp( k * asinh(x / 2 / k) ) </code>
</p>

<p><code>coshp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> coshp(x, k) = cosh( kashp(x, k) ) </code>
</p>

<p><code>sinhp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> sinhp(x, k) = sinh( kashp(x, k) ) </code>
</p>

<p><code>tanhp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> tanhp(x, k) = tanh( kashp(x, k) ) </code>
</p>

<p><code>sechp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> sechp(x, k) = 1 / coshp(x, k) </code>
</p>

<p><code>cosechp</code> function is defined for x in (-Inf, 0) U (0, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> cosechp(x, k) = 1 / sinhp(x, k) </code>
</p>

<p><code>cotanhp</code> function is defined for x in (-Inf, 0) U (0, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> cotanhp(x, k) = 1 / tanhp(x, k) </code>
</p>

<p>The undesired case k = 0 returns 0 for sinhp and tanhp, 
1 for exphp, coshp and sechp, Inf for cosechp and cotanhp.
</p>
<p>If k is a vector of length &gt; 1, then the use of the function 
<code><a href="base.html#topic+outer">outer</a></code> is recommanded.
</p>


<h3>See Also</h3>

<p>The nonlinear transformation <code><a href="#topic+kashp">kashp</a></code>, the inverse power 
hyperbolas and the inverse power hyperbolic functions <code><a href="#topic+loghp">loghp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1
x  &lt;- (-3:3)*3 
exphp(x, k = 4)
coshp(x, k = 4)
sinhp(x, k = 4) 
tanhp(x, k = 4)

### Example 2 outer + plot(exphp, coshp, sinhp, tanhp)
xmin  &lt;- -10
xd    &lt;- 0.5
x     &lt;- seq(xmin, -xmin, xd) ; names(x) &lt;- x
k     &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(k) &lt;- k
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 4, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
op    &lt;- par(mfrow = c(2,2), mgp = c(1.5,0.8,0), mar = c(3,3,2,1))

## exphp(x, k)
Texphp &lt;- ts(cbind(outer(-x, k, exphp), "exp(-x/2)" = exp(-x/2)), 
             start = xmin, deltat = xd)
plot(Texphp, plot.type = "single", ylim = c(0,20), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", xlab = "", 
       ylab = "", main = "exphp(-x, k)" )
legend("topright", title = expression(kappa), legend = colnames(Texphp), 
       inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

## coshp(x, k)
Tcoshp &lt;- ts(cbind(outer(x, k, coshp), "cosh(x/2)" = cosh(x/2)), 
             start = xmin, deltat = xd)
plot(Tcoshp, plot.type = "single", ylim = c(0,20), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", 
       xlab = "", ylab = "", main = "coshp(x, k)" )
legend("top", title = expression(kappa), legend = colnames(Tcoshp), 
       inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

## sinhp(x, k)
Tsinhp &lt;- ts(cbind(outer(x, k, sinhp), "sinh(x/2)" = sinh(x/2)), 
             start = xmin, deltat=xd)
plot(Tsinhp, plot.type = "single", ylim = c(-10,10), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", 
       xlab = "", ylab = "", main = "sinhp(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Tsinhp), 
       inset = 0.02, lty = olty, lwd=  olwd, col = ocol, cex = 0.7 )

## tanhp(x, k)
Ttanhp &lt;- ts(cbind(outer(x, k, tanhp), "tanh(x/2)" = tanh(x/2)), 
             start = xmin, deltat = xd)
plot(Ttanhp, plot.type = "single", ylim = c(-1,1), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", xlab = "", 
       ylab = "", main = "tanhp(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Ttanhp), 
       inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End Example 3

</code></pre>

<hr>
<h2 id='extractData'>Datasets dfData, mData, tData, xData, zData, extractData : extractData</h2><span id='topic+extractData'></span>

<h3>Description</h3>

<p>dfData, mData, tData, xData, zData are datasets made of lists of data.frame, matrix, 
timeSeries, xts and zoo components. They describe prices and returns of 10 financial series
used in the documents and demos presented at 8th and 9th R/Rmetrics conferences  
(2014, 2015). See the references. 
The last serie (CHF, interest rates in Switzerland) exhibits negative prices. 
All distributions of logreturns exhibit fat tails.
Function <code>extractData</code> converts subsets of mData, tData, xData, zData.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractData(pr = "p", ft = "tss", start = "2007-01-01",
  end = "2013-12-31")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractData_+3A_pr">pr</code></td>
<td>
<p>character. Extract prices or returns: <code>c("p","r","prices","returns")</code>.</p>
</td></tr>
<tr><td><code id="extractData_+3A_ft">ft</code></td>
<td>
<p>character. Output format among <code>c("tss","xts","zoo","dfr","bfr","mat")</code>.</p>
</td></tr>
<tr><td><code id="extractData_+3A_start">start</code></td>
<td>
<p>character. Start date.</p>
</td></tr>
<tr><td><code id="extractData_+3A_end">end</code></td>
<td>
<p>character. End date.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>   

library(zoo) 
library(xts) 
library(timeSeries) 

### dfData, tData, xData, zData : prices only
attributes(dfData); attributes(tData); attributes(xData); attributes(zData) 
lapply(dfData, head, 3)
lapply( mData, head, 3)
lapply( tData, head, 3)
lapply( xData, head, 3)
lapply( zData, head, 3)

### extractData : prices and logreturns
head(ptD &lt;- extractData("p", "tss", "2009-01-01", "2012-12-31")) ; tail(ptD)
head(rtD &lt;- extractData("r", "tss")) 
head(pxD &lt;- extractData("p", "xts")) 
head(rxD &lt;- extractData("r", "xts")) 
head(pzD &lt;- extractData("p", "zoo")) 
head(rzD &lt;- extractData("r", "zoo")) 
head(pbD &lt;- extractData("p", "bfr")) 
head(rbD &lt;- extractData("r", "bfr")) 
head(pmD &lt;- extractData("p", "mat")) 
head(rmD &lt;- extractData("r", "mat")) 

### Remove item CHF (negative prices) from dfData, tData, xData, zData
Z &lt;- dfData[names(dfData)[1:9]]; attributes(Z)
Z &lt;- tData[names(tData)[1:9]]; attributes(Z)
Z &lt;- xData[names(xData)[1:9]]; attributes(Z)
Z &lt;- zData[names(zData)[1:9]]; attributes(Z)

</code></pre>

<hr>
<h2 id='fatreturns'>Simple and Elaborated Prices to Returns</h2><span id='topic+fatreturns'></span><span id='topic+logreturns'></span><span id='topic+replaceNA'></span>

<h3>Description</h3>

<p><code>fatreturns</code> is an elaborated function to compute prices to returns. 
It includes a pre-treatment for negative prices. 
It computes either log-returns (default) or percentage-returns. 
It handles properly NA values in the input vector, replacing them by 0
in the output vector. Doing so, it warrants that the sum of the log-returns 
(when selected) is equal to the difference of the log-prices. 
It works with vector, matrix, data.frame, timeSeries, xts, zoo, list, list of lists 
and even list of vector, data.frame, timeSeries, xts, zoo mixed together.
The returned object is of same dimension and same class than the input object 
with the first line filled with 0.
The results may be as per one, per cent (default), per thousand and per ten thousand. 
</p>
<p><code>logreturns</code> is an improved version of function <code>100*diff(log(x))</code> to handle 
vector, matrix, data.frame and list. It handles properly the first line and the NA values. 
It does not control time, rownames and colnames but may return them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatreturns(x, log = TRUE, per = "cent", e = NULL, dfrcol = 1,
  na.rm = TRUE)

logreturns(x)

replaceNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fatreturns_+3A_x">x</code></td>
<td>
<p>The prices (vector, data.frame, matrix, timeSeries, xts, zoo, list).</p>
</td></tr>
<tr><td><code id="fatreturns_+3A_log">log</code></td>
<td>
<p>boolean. log returns or percentage returns.</p>
</td></tr>
<tr><td><code id="fatreturns_+3A_per">per</code></td>
<td>
<p>character. Either &quot;one&quot;, &quot;cent, &quot;thousand&quot;, &quot;tenthousand&quot; or 
&quot;o&quot;, &quot;c&quot;, &quot;th&quot;, &quot;te&quot;. Multiply the result by 1, 100, 1000, 10000.</p>
</td></tr>
<tr><td><code id="fatreturns_+3A_e">e</code></td>
<td>
<p>NULL or positive numeric. NULL is for no change <code>f(x)=x</code>. 
A positive numeric designates the focal point of the hyperbola 
to turn negative prices into positive prices, keeping the hierarchy:  
<code>f(x)=(x+sqrt(x*x+e*e))/2</code>. There is currently no rules of thumb 
for the optimal value of <code>e</code>.</p>
</td></tr>
<tr><td><code id="fatreturns_+3A_dfrcol">dfrcol</code></td>
<td>
<p>integer. For data.frame only, designates the column that handles the time 
and must be processed separately. Use <code>dfrcol = 0</code> if all columns 
must be processed and there is no time (or turn the data.frame to a matrix).</p>
</td></tr>
<tr><td><code id="fatreturns_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. Replace <code>x[t]=NA</code> with the previous non-NA value available 
in the price serie such that <code>(x[t-1], x[t]=x[t-1], x[t+1])</code> and 
calculate the returns accordingly. Force 0 in the first line of the returns 
if <code>x[1]=NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Negative prices in financial markets, like interest rates in Europe, are a 
nightmare as the rough calculation of the returns generates non-sense values.
<code>elevate</code> uses an hyperbola and implements the following formula: 
</p>
<p style="text-align: center;"><code class="reqn"> elevate(x, e) = (x + sqrt(x*x + e*e)) / 2 </code>
</p>

<p>There is currently no rule of thumb to calculate <code>e</code>. 
When <code class="reqn">e = NULL</code>, there is no change and the output is identical to the input.
When <code class="reqn">e = 0</code>, all negative values are turned to 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fatreturns(extractData())
logreturns(getDSdata())

</code></pre>

<hr>
<h2 id='fitkienerX'>Estimation and Regression Functions for Kiener Distributions</h2><span id='topic+fitkienerX'></span><span id='topic+paramkienerX'></span><span id='topic+paramkienerX7'></span><span id='topic+paramkienerX5'></span>

<h3>Description</h3>

<p>Several functions to estimate the parameters of asymmetric Kiener distributions 
and display the results in a numeric vector or in a matrix. 
Algorithm <code>"reg"</code> (the default) uses a nonlinear regression and handle 
difficult cases. Algorithm <code>"estim"</code> has been completely rewritten 
in version 1.8-0 and is now very accurate, even for <code>k&lt;1</code>. Adjustement 
on extreme quantiles can be controlled very precisely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitkienerX(X, algo = c("r", "reg", "e", "estim"), ord = 7, maxk = 10,
  mink = 1.53, maxe = 0.5, probak = pprobs2, dgts = NULL,
  exfitk = NULL, dimnames = FALSE, ncores = 1)

paramkienerX(X, algo = c("r", "reg", "e", "estim"), ord = 7, maxk = 10,
  mink = 1.53, maxe = 0.5, dgts = 3, parnames = TRUE,
  dimnames = FALSE, ncores = 1)

paramkienerX7(X, dgts = 3, n = 10, maxk = 20, maxe = 0.9,
  parnames = TRUE, dimnames = FALSE, ncores = 1)

paramkienerX5(X, dgts = 3, i = 4, maxk = 20, maxe = 0.9,
  parnames = TRUE, dimnames = FALSE, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitkienerX_+3A_x">X</code></td>
<td>
<p>numeric. Vector, matrix, array or list of quantiles.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_algo">algo</code></td>
<td>
<p>character. The algorithm used: <code>"r"</code> or <code>"reg"</code>
for regression (default) and <code>"e"</code> or <code>"estim"</code>
for quantile estimation.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_ord">ord</code></td>
<td>
<p>integer. Option for probability selection and treatment.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_maxk">maxk</code></td>
<td>
<p>numeric. The maximum value of tail parameter <code>k</code>.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_mink">mink</code></td>
<td>
<p>numeric. The minimum value of tail parameter <code>k</code>.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_maxe">maxe</code></td>
<td>
<p>numeric. The maximum value of absolute tail parameter <code>|e|</code>.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_probak">probak</code></td>
<td>
<p>numeric. Ordered vector of probabilities.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_dgts">dgts</code></td>
<td>
<p>integer. The rounding of output parameters.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_exfitk">exfitk</code></td>
<td>
<p>character. A vector of parameter names to subset the output.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_dimnames">dimnames</code></td>
<td>
<p>boolean. Display dimnames.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_ncores">ncores</code></td>
<td>
<p>integer. The number of cores for parallel processing of arrays.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_parnames">parnames</code></td>
<td>
<p>boolean. Display parameter names.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_n">n</code></td>
<td>
<p>integer. The 1:n and (N+i-n):N elements of <code>X</code> used to 
calculate synthetic quantiles at probability levels p1 and 1-p1.</p>
</td></tr>
<tr><td><code id="fitkienerX_+3A_i">i</code></td>
<td>
<p>integer. The i-th and (N-i)-th elements of <code>X</code> used to 
extract probabilities p1 and 1-p1 and quantiles x(p) and x(1-p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FatTailsR package currently uses two different algorithms to estimate the 
parameters of Kiener distributions K1, K2, K3 and K4.
</p>

<ul>
<li><p>Functions <code>fitkienerX(algo = "reg")</code>, <code>paramkienerX(algo = "reg")</code> 
and <code><a href="#topic+regkienerLX">regkienerLX</a></code> use an unweighted  
nonlinear regression from <code>logit(p)</code> to <code>X</code> over the whole dataset.  
Depending the size of the dataset, calculation can be slow but is usually
accurate and describes very well the last 1-10 points in the tails 
(except if there is a huge outlier). 
</p>
</li>
<li><p>Functions <code>fitkienerX(algo = "estim")</code>, <code>paramkienerX(algo = "estim")</code>, 
<code>paramkienerX5</code> and <code>paramkienerX7</code> estimate the parameters with 
just 5 to 11 quantiles, 5 being the minimum. For averaging purpose, 
11 quantiles are proposed (see below). Computation is almost instantaneous 
and reasonnably accurate. This is the recommanded method for intensive computation.
</p>
</li></ul>

<p>A typical input is a numeric vector or a matrix that describes the returns of a stock. 
A matrix must be in the format DS with DATES as rownames, STOCKS as colnames and 
(log-)returns as the content of the matrix. 
An array must be in the format DSL with DATES as rownames, STOCKS as colnames 
LAGS in the third dimension and (log-)returns as the content of the array. 
A list can be a list of numeric but neither a list of matrix, a list of data.frame 
or a list of arrays.
</p>
<p>Conversion from a (possible) time series format to a sorted numeric vector 
is done automatically and without any check of the initial format. 
Empirical probabilities of each point in the sorted dataset is calculated 
with the function <code><a href="stats.html#topic+ppoints">ppoints</a></code> whose parameter <code>a</code> has been set to 
<code>a = 0</code> as large datasets are very common in finance. 
The lowest acceptable size of a dataset is not clear at this moment. A minimum 
of 11 points has been set in <code>"reg"</code> algorithm and a minimum of 15 points 
has been set in <code>"estim"</code> algorithm. It might change in the future. 
If possible, use at least 21 points. 
</p>
<p>Parameter <code>algo</code> controls the algorithm used. Default is &quot;reg&quot;.
</p>
<p>When <code>algo = "reg"</code> (or <code>algo = "r"</code>), a nonlinear regression is performed 
with <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> from the logit of the empirical probabilities 
<code>logit(p)</code> over the quantiles X with the function <code><a href="#topic+qlkiener4">qlkiener4</a></code>. 
The maximum value of the tail parameter <code>k</code> is controlled by <code>maxk</code>.
An upper value <code>maxk = 10</code> is appropriate for datasets
of low and medium size, less than 20.000 or 50.000 points. For larger datasets, the
upper limit can be extended up to <code>maxk = 20</code>. When this limit is reached, 
the shape of the distribution is very similar to the logistic distribution 
(at least when <code>e = 0</code>) and the use of this distribution should be considered. 
Remember that value <code>k &lt; 2</code> describes a distribution with no stable variance and 
<code>k &lt; 1</code> describes a distribution with no stable mean.
</p>
<p>When <code>algo = "estim"</code> (or <code>algo = "e"</code>),
5 to 11 quantiles are used to estimate the parameters. 
The minimum is 5 quantiles : the median x.50, two quantiles at medium distance 
to the median, usually x.25 and x.75 and two quantiles located close to the extremes 
of the dataset, for instance x.01 and x.99 if the dataset <code>X</code> has more 
than 100 points, x.0001 and x.9999 if the dataset <code>X</code> has more than 
10.000 points and so on if the dataset is larger. 
These quantiles are extracted with function <code><a href="#topic+fiveprobs">fiveprobs</a></code>. 
Small datasets must contain at least 15 different points. 
</p>
<p>With the idea of averaging the results (but without any guarantee of better 
estimates), calculation has been extended to 11 probabilities  
extracted from <code>X</code> with the function <code><a href="#topic+elevenprobs">elevenprobs</a></code> where    
p1, p2 and p3 are the most extreme probabilities of the dataset <code>X</code>  
with values finishing either by <code>.x01</code> or <code>.x025</code> or <code>.x05</code>:
</p>

<ul>
<li><p><code>p11 = c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li></ul>

<p>Selection of subsets among these 11 probabilities is controlled with the option 
<code>ord</code> which can take 12 different values.  
For instance, the default <code>ord = 7</code> computes the  parameters at probabilities 
<code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code> and <code>c(p2, 0.25, 0.50, 0.75, 1-p2)</code>.
Parameters <code>d</code> and <code>k</code> are averaged first and the results of these 
averages are used to compute the other parameters <code>g, a, w, e</code>. 
Small dataset should consider <code>ord = 5</code> and 
large dataset can consider <code>ord = 12</code>. 
The 12 possible values of <code>ord</code> are: 
</p>

<ol>
<li> <p><code>c(p1, 0.35, 0.50, 0.65, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.35, 0.50, 0.65, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.35, 0.50, 0.65, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.35, 0.50, 0.65, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.50, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.50, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li></ol>

<p><code>paramkienerX5</code> is a simplified version of <code>paramkienerX</code> with  
predefined values <code>algo = "estim"</code>, <code>ord = 5</code>, <code>maxk = 10</code> 
and direct access to internal subfunctions. 
It uses the following probabilities:
</p>

<ul>
<li> <p><code>p5 = c(p1, 0.25, 0.50, 0.75, 1-p1)</code> 
</p>
</li></ul>

<p><code>paramkienerX7</code> is a simplified version of <code>paramkienerX</code> with 
predefined values <code>algo = "estim"</code>, <code>ord = 7</code>, <code>maxk = 10</code> 
and direct access to internal subfunctions.
It uses the following probabilities:
</p>

<ul>
<li> <p><code>p7 = c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code> 
</p>
</li></ul>

<p>The quantiles corresponding to the above probabilities are then extracted 
with the function <code><a href="stats.html#topic+quantile">quantile</a></code> whose parameter <code>type</code> 
has been set to <code>type = 6</code> as it returns the closest values 
to the true quantiles (according to our experience) for all <code>k &gt; 1.9</code>. 
(Note: when <code>k &lt; 1.5</code>, algorithm <code>algo = "reg"</code> returns better  
results). 
Both probabilities and quantiles are then transfered to <code><a href="#topic+estimkiener11">estimkiener11</a></code> 
for calculation.
</p>
<p><code>probak</code> controls the probabilities at which the model is tested with the parameter 
estimates. <code>fitkienerX</code> and <code><a href="#topic+regkienerLX">regkienerLX</a></code> share the same subroutines.
The default for <code>fitkienerX</code> and <code>regkienerLX</code> is 
<code>pprobs2 = c(0.01, 0.025, 0.05, 0.95, 0.975, 0.99)</code> as those values 
are usual in finance. Other sets of values are provided at <code><a href="#topic+pprobs0">pprobs0</a></code>.
</p>
<p>Rounding the results is useful to display nice results, especially 
in a matrix or in a data.frame. <code>dgts = 13</code> is recommanded 
as <code>a</code>, <code>k</code>, <code>w</code> are usually significant at 1 digit.
</p>

<ul>
<li> <p><code>dgts = NULL</code> does not perform any rounding. 
</p>
</li>
<li> <p><code>dgts = 0 to 9</code> rounds all parameters at the same level. 
</p>
</li>
<li> <p><code>dgts = 10 to 27</code> rounds the parameters at various levels for nice display.  
See <code><a href="#topic+roundcoefk">roundcoefk</a></code> for the details. (Note: the
rounding <code>10 to 27</code> currently works with <code>paramkienerX</code>, <code>paramkienerX5</code>,  
<code>paramkienerX7</code> but not yet with <code>fitkienerX</code>). 
</p>
</li></ul>
 
<p>Extracting the most useful parameters from the (quite long) vector/matrix 
<code>fitk</code> is controlled by parameter <code>exfitk</code> that calls user-defined or
predefined parameter subsets like <code><a href="#topic+exfit0">exfit0</a></code>, ..., <code><a href="#topic+exfit7">exfit7</a></code>.
IMPORTANT: never subset <code>fitk</code> by rank number as new items may be added 
in the future and rank may vary.
</p>
<p>Calculation of vectors, matrices and lists is not parallelized. Parallelization 
of code for arrays was introduced in version 1.5-0 and improved in version 1.5-1. 
<code>ncores</code> controls the number of cores allowed to the process (through 
<code><a href="parallel.html#topic+parApply">parApply</a></code> which runs on Unices and Windows and requires
about 2 seconds to start). <code>ncores = 1</code> means no parallelization. 
<code>ncores = 0</code> is the recommanded option. It uses the maximum number of cores 
available on the computer, as detected by <code><a href="parallel.html#topic+detectCores">detectCores</a></code>,  
minus 1 core, which gives the best performance in most cases. 
Although appealing, this automatic selection may be sometimes dangerous. For instance, 
the instruction <code>f(X, ncores_max) - f(X, ncores_max)</code>, a nice way to compute 
an array of 0, will call <code>2 ncores_max</code> and crash R. <code>ncores = 2,..,99</code> 
sets manually the number of cores. If the requested value is larger than the maximum 
number of cores, this value is automatically reduced (with a warning) to this maximum.
Hence, this latest option provides one core more than option <code>ncores = 0</code>.
</p>
<p>NOTE: <code>fitkienerLX</code>, <code>regkienerX</code>, <code>estimkiener(X,5,7)</code> were   
introduced in v1.2-0 and replaced in version v1.4-1 by <code>fitkienerX</code> and 
<code>paramkiener(X,5,7)</code> to accomodate vector, matrix, arrays and lists. 
We apologize to early users who need to rewrite their codes.
</p>


<h3>Value</h3>

<p><code>paramkienerX</code>: a vector (or a matrix) of parameter estimates 
<code>c(m, g, a, k, w, d, e)</code>.
</p>
<p><code>fitkienerX</code>: a vector (or a matrix) made of several parts:
</p>

<ul>
<li> <p><code>ret</code> : the return over the period calculated with <code>sum(x)</code>. 
Thus, assume log-returns.  
</p>
</li>
<li> <p><code>m, g, a, k, w, d, e</code> : the parameter estimates.  
</p>
</li>
<li> <p><code>m1, sd, sk, ke</code> : the mean, standard deviation, 
skewness and excess of kurtosis computed from the parameter estimates.  
</p>
</li>
<li> <p><code>m1x, sdx, skx, kex</code> : The mean, standard deviation,  
skewness and excess of kurtosis computed from the dataset.  
</p>
</li>
<li> <p><code>lh</code> : the length of the dataset over the period.  
</p>
</li>
<li> <p><code>q.</code> : quantile estimated with the parameter estimates. 
</p>
</li>
<li> <p><code>VaR.</code> : Value-at-Risk, positive in most cases.  
</p>
</li>
<li> <p><code>c.</code> : corrective tail coefficient = (q - m) / (q_logistic_function - m). 
</p>
</li>
<li> <p><code>ltm.</code> : left tail mean (signed ES on the left tail, usually negative).  
</p>
</li>
<li> <p><code>rtm.</code> : right tail mean (signed ES on the right tail, usually positive). 
</p>
</li>
<li> <p><code>dtmq.</code> : (p&lt;=0.5 left, p&gt;0.5 right) tail mean minus quantile. 
</p>
</li>
<li> <p><code>ES.</code> : expected shortfall, positive in most cases. 
</p>
</li>
<li> <p><code>h.</code> : corrective ES  = (ES - m) / (ES_logistic_function - m). 
</p>
</li>
<li> <p><code>desv.</code> : ES - VaR, usually positive.  
</p>
</li>
<li> <p><code>l.</code> : quantile estimated by the tangent logistic function. 
</p>
</li>
<li> <p><code>dl.</code> : quantile - quantile_logistic_function. 
</p>
</li>
<li> <p><code>g.</code> : quantile estimated by the Laplace-Gauss function.  
</p>
</li>
<li> <p><code>dg.</code> : quantile - quantile_Laplace_Gauss_function. 
</p>
</li></ul>

<p>IMPORTANT : if you need to subset <code>fitk</code>, always subset it by parameter names 
and never subset it by rank number as new items may be added in the future and rank may vary. 
Use for instance <code><a href="#topic+exfit0">exfit0</a></code>, ..., <code><a href="#topic+exfit7">exfit7</a></code>.
</p>


<h3>References</h3>

<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regkienerLX">regkienerLX</a></code>, <code><a href="#topic+estimkiener11">estimkiener11</a></code>, 
<code><a href="#topic+roundcoefk">roundcoefk</a></code>, <code><a href="#topic+exfit6">exfit6</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    

require(minpack.lm)
require(timeSeries)

### Load the datasets and choose j in 1:16
DS     &lt;- getDSdata()
j      &lt;- 5

### and run this block
probak &lt;- c(0.01, 0.05, 0.95, 0.99)
X      &lt;- DS[[j]] ; names(DS)[j]
elevenprobs(X)
fitkienerX(X, algo = "reg", dgts = 3, probak = probak)
fitkienerX(X, algo = "estim", ord = 5, probak = probak, dgts = 3)
paramkienerX(X)
paramkienerX5(X)

### Compare the 12 values of paramkienerX(ord/row = 1:12) and paramkienerX (row 13)
compare &lt;- function(ord, X) { paramkienerX(X, ord, algo = "estim", dgts = 13) }
rbind(t(sapply( 1:12, compare, X)), paramkienerX(X, algo = "reg", dgts = 13))

### Analyze DS in one step
t(sapply(DS, paramkienerX, algo = "reg", dgts = 13))
t(sapply(DS, paramkienerX, algo = "estim", dgts = 13))
paramkienerX(DS, algo = "reg", dgts = 13)
paramkienerX(DS, algo = "estim", dgts = 13)
system.time(fitk_rDS &lt;- fitkienerX(DS, algo = "r", probak = pprobs2, dgts = 3))
system.time(fitk_eDS &lt;- fitkienerX(DS, algo = "e", probak = pprobs2, dgts = 3))
fitk_rDS
fitk_eDS

### Subset rDS and eDS with exfit0,..,exfit7
fitk_rDS[,exfit4]
fitk_eDS[,exfit7]
fitkienerX(DS, algo = "e", probak = pprobs2, dgts = 3, exfitk = exfit7)

### Array (new example introduced in v1.5-1)
### Increase the number of cores and crash R.
## Not run:
arr &lt;- array(rkiener1(3000), c(4,3,250))
paramkienerX7(arr, ncores = 2)
## paramkienerX7(arr, ncores = 2) - paramkienerX(arr, ncores = 2)
## End(Not run)

### End


</code></pre>

<hr>
<h2 id='getDSdata'>Get DS Dataset</h2><span id='topic+getDSdata'></span>

<h3>Description</h3>

<p>A function to extract the log-returns 
of 16 financial series and time series provided by the packages <code>datasets</code> 
(EuStockMarkets, sunspot.year) and <code>timeSeries</code> (USDCHF, MSFT, LPP2005REC).
The 16 datasets are converted to a list of numeric without any reference 
to the original dates. This list is usually called <code>DS</code>, hence the name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDSdata()
</code></pre>


<h3>Details</h3>

<p>The dataset is usually created by the instruction <code>DS &lt;- getDSdata()</code>.
Then, it is used with a call to DS[[j]] with j in 1:16. 
</p>

<ol>
<li><p> &quot;USDCHF&quot; (USDCHF, timeSeries) 
</p>
</li>
<li><p> &quot;MSFT&quot; (MSFT, timeSeries) 
</p>
</li>
<li><p> &quot;DAX&quot; (EuStockMarkets, datasets) 
</p>
</li>
<li><p> &quot;SMI&quot; (EuStockMarkets, datasets) 
</p>
</li>
<li><p> &quot;CAC&quot; (EuStockMarkets, datasets) 
</p>
</li>
<li><p> &quot;FTSE&quot; (EuStockMarkets, datasets) 
</p>
</li>
<li><p> &quot;SBI&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;SPI&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;SII&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;LMI&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;MPI&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;ALT&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;LPP25&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;LPP40&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;LPP60&quot; (LPP2005REC, timeSeries) 
</p>
</li>
<li><p> &quot;sunspot&quot; (sunspot.year, datasets) 
</p>
</li></ol>

<p>Note that <code>sunspot.year</code> is regularly updated with each new version of  
<code>R</code>. The generated dataset is <code>logreturn(sunspot.year + 1000)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="datasets.html#topic+EuStockMarkets">EuStockMarkets</a></code>, <code><a href="datasets.html#topic+sunspot.year">sunspot.year</a></code>, 
<code><a href="timeSeries.html#topic+TimeSeriesData">TimeSeriesData</a></code>, <code><a href="#topic+regkienerLX">regkienerLX</a></code>, 
<code><a href="#topic+fitkienerX">fitkienerX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   

require(timeSeries) 

getDSdata
DS  &lt;- getDSdata()
attributes(DS)
sapply(DS, length)
sapply(DS, head)

</code></pre>

<hr>
<h2 id='getnamesk'>Generate a list of vectors of characters from a vector of probabilities</h2><span id='topic+getnamesk'></span><span id='topic+getnprobak'></span>

<h3>Description</h3>

<p>Generate vector of characters from a vector of probabilities, replacing 
<code>0.</code> by letters:
</p>

<ul>
<li> <p><code>p.</code> : probability. 
</p>
</li>
<li> <p><code>q.</code> : quantile. 
</p>
</li>
<li> <p><code>VaR.</code> : Value-at-Risk, positive in most cases.  
</p>
</li>
<li> <p><code>c.</code> : corrective tail coefficient = (q - m) / (q_logistic_function - m). 
</p>
</li>
<li> <p><code>ltm.</code> : left tail mean (signed ES on the left tail, usually negative).  
</p>
</li>
<li> <p><code>rtm.</code> : right tail mean (signed ES on the right tail, usually positive). 
</p>
</li>
<li> <p><code>dtmq.</code> : (p&lt;=0.5 left, p&gt;0.5 right) tail mean minus quantile. 
</p>
</li>
<li> <p><code>ES.</code> : expected shortfall, positive in most cases. 
</p>
</li>
<li> <p><code>h.</code> : corrective ES  = (ES - m) / (ES_logistic_function - m). 
</p>
</li>
<li> <p><code>desv.</code> : ES - VaR, usually positive.  
</p>
</li>
<li> <p><code>l.</code> : quantile of the tangent logistic function. 
</p>
</li>
<li> <p><code>dl.</code> : quantile - quantile_logistic_function. 
</p>
</li>
<li> <p><code>g.</code> : quantile of the Laplace-Gauss function.  
</p>
</li>
<li> <p><code>dg.</code> : quantile - quantile_Laplace_Gauss_function. 
</p>
</li></ul>

<p>, <code>q.</code>, <code>VaR.</code>, <code>c.</code>, <code>ltm.</code>,
<code>rtm.</code>, <code>ES.</code>, <code>h.</code>, <code>l.</code>, <code>dl.</code>, <code>g.</code>, <code>dg.</code>.
The result is a list of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnamesk(probak = pprobs2, check = TRUE)

getnprobak(probak = pprobs2, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getnamesk_+3A_probak">probak</code></td>
<td>
<p>a vector of ordered probabilities with 0 and 1 excluded.</p>
</td></tr>
<tr><td><code id="getnamesk_+3A_check">check</code></td>
<td>
<p>boolean. Apply <code><a href="#topic+checkquantiles">checkquantiles</a></code> function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Probabilities: <code><a href="#topic+pprobs0">pprobs0</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
getnamesk(pprobs1)
getnamesk(pprobs8)

</code></pre>

<hr>
<h2 id='kashp'>Kashp Function</h2><span id='topic+kashp'></span><span id='topic+dkashp_dx'></span><span id='topic+ashp'></span>

<h3>Description</h3>

<p><code>kashp</code>, which stands for kappa times arc-sine-hyperbola-power  
is the nonlinear transformation of x at the heart 
of power hyperbolas, power hyperbolic functions and symmetric Kiener 
distributions.
<code>dkashp_dx</code> is its derivative with respect to <code>x</code>. 
<code>ashp</code> is provided for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kashp(x, k = 1)

dkashp_dx(x, k = 1)

ashp(x, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kashp_+3A_x">x</code></td>
<td>
<p>a numeric value, vector or matrix.</p>
</td></tr>
<tr><td><code id="kashp_+3A_k">k</code></td>
<td>
<p>a numeric value or vector, preferably strictly positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ashp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> ashp(x, k) = asinh(x / 2 / k)  </code>
</p>

<p><code>kashp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> kashp(x, k) = k * asinh(x / 2 / k)  </code>
</p>

<p><code>dkashp_dx</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dkashp_dx(x, k) = 1 / sqrt( x*x/k/k + 4 ) 
             = 1 / 2 / cosh( ashp(x, k) ) </code>
</p>

<p>If k is a vector, then the use of the function <code><a href="base.html#topic+outer">outer</a></code> 
is recommanded.
</p>
<p>The undesired case k=0 returns 0 for kashp and dkashp_dx, 1 for exphp, 
-Inf, NaN, +Inf for ashp.
</p>


<h3>See Also</h3>

<p>The power hyperbolas and the power hyperbolic functions 
<code><a href="#topic+exphp">exphp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)

### Example 1
x    &lt;- (-3:3)*3 ; names(x) &lt;- x
kashp(x, k=2)
k    &lt;- c(-2, 0, 1, 2, 3, 5, 10) ; names(k) &lt;- k
outer(x, k, kashp)
outer(x, k, exphp)

### Example 2
xmin   &lt;- -10
xd     &lt;- 0.5
x      &lt;- seq(xmin, -xmin, xd) ; names(x) &lt;- x
k      &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(k) &lt;- k
olty   &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd   &lt;- c(1, 1, 2, 2, 3, 4, 2)
ocol   &lt;- c(2, 2, 4, 4, 3, 3, 1)
op     &lt;- par(mfrow = c(2,2), mgp = c(1.5,0.8,0), mar = c(3,3,2,1))

Tkashp &lt;- ts(cbind(outer(x, k, kashp), "x/2" = x/2), start = xmin, deltat = xd)
plot(Tkashp, plot.type = "single", ylim = c(-5, +5), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", xlab = "", 
       ylab = "", main = "kashp(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Tkashp), 
       inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

Tdkashp &lt;- ts(cbind(outer(x, k, dkashp_dx)), start = xmin, deltat = xd)
plot(Tdkashp, plot.type = "single", ylim = c(0, 0.8), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", xlab = "", 
       ylab = "", main="dkashp_dx(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Tdkashp), 
       inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

Tashp &lt;- ts(cbind(outer(x, k, ashp), "x/2" = x/2), start = xmin, deltat = xd)
plot(Tashp, plot.type = "single", ylim = c(-5, +5), 
       lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", xlab = "", 
       ylab = "", main = "ashp(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Tashp), 
       inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 2

</code></pre>

<hr>
<h2 id='kiener1'>Symmetric Kiener Distribution K1</h2><span id='topic+kiener1'></span><span id='topic+dkiener1'></span><span id='topic+pkiener1'></span><span id='topic+qkiener1'></span><span id='topic+rkiener1'></span><span id='topic+dpkiener1'></span><span id='topic+dqkiener1'></span><span id='topic+lkiener1'></span><span id='topic+dlkiener1'></span><span id='topic+qlkiener1'></span><span id='topic+varkiener1'></span><span id='topic+ltmkiener1'></span><span id='topic+rtmkiener1'></span><span id='topic+dtmqkiener1'></span><span id='topic+eskiener1'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation, 
value-at-risk, expected shortfall (+ signed left/right tail mean) 
and additional formulae for symmetric Kiener distribution K1. 
This distribution is similar to the power hyperbola logistic distribution 
but with additional parameters for location (<code>m</code>) and scale (<code>g</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkiener1(x, m = 0, g = 1, k = 3.2, log = FALSE)

pkiener1(q, m = 0, g = 1, k = 3.2, lower.tail = TRUE, log.p = FALSE)

qkiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE, log.p = FALSE)

rkiener1(n, m = 0, g = 1, k = 3.2)

dpkiener1(p, m = 0, g = 1, k = 3.2, log = FALSE)

dqkiener1(p, m = 0, g = 1, k = 3.2, log = FALSE)

lkiener1(x, m = 0, g = 1, k = 3.2)

dlkiener1(lp, m = 0, g = 1, k = 3.2, log = FALSE)

qlkiener1(lp, m = 0, g = 1, k = 3.2, lower.tail = TRUE)

varkiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE,
  log.p = FALSE)

ltmkiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE,
  log.p = FALSE)

rtmkiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE,
  log.p = FALSE)

dtmqkiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE,
  log.p = FALSE)

eskiener1(p, m = 0, g = 1, k = 3.2, lower.tail = TRUE, log.p = FALSE,
  signedES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kiener1_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_m">m</code></td>
<td>
<p>numeric. The median.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_g">g</code></td>
<td>
<p>numeric. The scale parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_k">k</code></td>
<td>
<p>numeric. The tail parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_log">log</code></td>
<td>
<p>logical. If TRUE, densities are given in log scale.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="kiener1_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_lp">lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td></tr>
<tr><td><code id="kiener1_+3A_signedes">signedES</code></td>
<td>
<p>logical. FALSE (default) returns positive numbers for 
left and right tails. TRUE returns negative number 
(= <code>ltmkiener1</code>) for left tail and positive number 
(= <code>rtmkiener1</code>) for right tail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code><a href="#topic+aw2k">aw2k</a></code> and <code><a href="#topic+pk2pk">pk2pk</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution,. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p>Kiener distributions <code>K1(m, g, k, ...)</code> describe distributions  
with symmetric left and right fat tails with tail parameter <code>k</code>. 
This parameter is the power exponent mentionned in Pareto formula and 
Karamata theorems.
</p>
<p><code>m</code> is the median of the distribution. <code>g</code> is the scale parameter 
and the inverse of the density at the median: <code class="reqn"> g = 1 / 8 / f(m) </code>.
As a first estimate, it is approximatively one fourth of the standard 
deviation <code class="reqn"> g  \approx \sigma / 4 </code> but is independant from it.
</p>
<p><code>dkiener1</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dkiener1(x, m, g, k) = 
                1 / 4 / g / cosh(  ashp((x - m)/g, k) ) 
                     / (1 + cosh( kashp((x - m)/g, k))) </code>
</p>

<p><code>pkiener1</code> function is defined for q in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> pkiener1(q, m, g, k) = 1/(1 + exp(- kashp((q - m)/g, k))) </code>
</p>

<p><code>qkiener1</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qkiener1(p, m, g, k) = m + 2 * g * k * sinh( logit(p)/k ) </code>
</p>

<p><code>rkiener1</code> generates <code>n</code> random quantiles.
</p>
<p>In addition to the classical d, p, q, r functions, the prefixes 
dp, dq, l, dl, ql are also provided.
</p>
<p><code>dpkiener1</code> is the density function calculated from the probability p. 
It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dpkiener1(p, m, g, k) = p * (1 - p) / 2 / g / cosh( logit(p)/k ) </code>
</p>

<p><code>dqkiener1</code> is the derivate of the quantile function calculated from 
the probability p. It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqkiener1(p, m, g, k) = 2 * g / p / (1 - p) * cosh( logit(p)/k ) </code>
</p>

<p><code>lkiener1</code> function is equivalent to kashp function but with additional 
parameters <code>m</code> and <code>g</code>. Being computed from the x (or q) vector, 
it can be compared to the logit of the empirical probability logit(p) 
through a nonlinear regression with ordinary or weighted least squares 
to estimate the distribution parameters. 
It is defined for x in (-Inf, +Inf) by:
</p>
<p style="text-align: center;"><code class="reqn"> lkiener1(x, m, g, k) = kashp((x - m)/g, k) </code>
</p>

<p><code>dlkiener1</code> is the density function calculated from the logit of the 
probability lp = logit(p). It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlkiener1(lp, m, g, k) = p * (1 - p) / 2 / g / cosh( lp/k ) </code>
</p>

<p><code>qlkiener1</code> is the quantile function calculated from the logit of the 
probability lp = logit(p). It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qlkiener1(lp, m, g, k) = m + g * k * 2 * sinh( lp/k ) </code>
</p>

<p><code>varkiener1</code> designates the Value a-risk and turns negative numbers 
into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> varkiener1 &lt;- if(p &lt;= 0.5) (- qkiener1) else (qkiener1) </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.05</code>, <code>p = 0.95</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>ltmkiener1</code>, <code>rtmkiener1</code> and <code>eskiener1</code> are respectively the 
left tail mean, the right tail mean and the expected shortfall of the distribution 
(sometimes called average VaR, conditional VaR or tail VaR). 
Left tail mean is the integrale from <code>-Inf</code> to <code>p</code> of the quantile function 
<code>qkiener1</code> divided by <code>p</code>.
Right tail mean is the integrale from <code>p</code> to <code>+Inf</code> of the quantile function 
<code>qkiener1</code> divided by 1-p.
Expected shortfall turns negative numbers into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> eskiener1 &lt;- if(p &lt;= 0.5) (- ltmkiener1) else (rtmkiener1) </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.025</code>, <code>p = 0.975</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>dtmqkiener1</code> is the difference between the left tail mean and the quantile 
when (p &lt;= 0.5) and the difference between the right tail mean and the quantile 
when (p &gt; 0.5). It is in quantile unit and is an indirect measure of the tail curvature.
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014.  Download it from: 
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>C. Acerbi, D. Tasche, Expected shortfall: a natural coherent alternative to 
Value at Risk, 9 May 2001. Download it from: 
<a href="https://www.bis.org/bcbs/ca/acertasc.pdf">https://www.bis.org/bcbs/ca/acertasc.pdf</a>
</p>


<h3>See Also</h3>

<p>Power hyperbola logistic distribution <code><a href="#topic+logishp">logishp</a></code>, 
asymmetric Kiener distributions K2, K3, K4 and K7  
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>, 
<code><a href="#topic+kiener7">kiener7</a></code>,  
regression function <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)

### Example 1
pp &lt;- c(ppoints(11, a = 1), NA, NaN) ; pp
qkiener1(p = pp, k = 4)


### Example 2: Try various value of k = 1.5, 3, 5, 10
k       &lt;- 5  # 1.5, 3, 5, 10
set.seed(2014)
mainTC  &lt;- paste("qkiener1(p, m = 0, g = 1, k = ", k, ")")
mainsum &lt;- paste("cumulated qkiener1(p, m = 0, g = 1, k = ", k, ")")
T       &lt;- 500
C       &lt;- 4
TC      &lt;- qkiener1(p = runif(T*C), m = 0, g = 1, k = k)
matTC   &lt;- matrix(TC, nrow = T, ncol = C, dimnames = list(1:T, letters[1:C]))
head(matTC)
plot.ts(matTC, main = mainTC)
#
matsum  &lt;- apply(matTC, MARGIN=2, cumsum) 
head(matsum)
plot.ts(matsum, plot.type = "single", main = mainsum)
### End example 2


### Example 3 (four plots: probability, density, logit, logdensity)
x  &lt;- q  &lt;- seq(-15, 15, length.out=101)
k     &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(k) &lt;- k ; k
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 3, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
lleg  &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", "logit(0.95)   = 2.9", 
           "logit(0.50)   = 0", "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(x, plogis(x, scale = 2), type = "b", lwd = 2, ylim = c(0, 1),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "pkiener1(q, m, g, k)")
for (i in 1:length(k)) lines(x, pkiener1(x, k = k[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(kappa), legend = c(k, "logistic"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, dlogis(x, scale = 2), type = "b", lwd = 2, ylim = c(0, 0.14), 
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", main = "dkiener1(x, m, g, k)" )
for (i in 1:length(k)) lines(x, dkiener1(x, k = k[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topright", title = expression(kappa), legend = c(k, "logistic"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, x/2, type = "b", lwd = 2, ylim = c(-7.5, 7.5), yaxt="n", xaxs = "i", 
     yaxs = "i", xlab = "", ylab = "", main = "logit(pkiener1(q, m, g, k))")
axis(2, las=1, at=c(-6.9, -4.6, -2.9, 0, 2.9, 4.6, 6.9) )
for (i in 1:length(k)) lines(x, lkiener1(x, k = k[i]),  
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
lines(x, logit(pnorm(x, 0, 3.192)), type="l", lty=1, lwd=3, col=7) # erfx
legend("topleft", legend = lleg, cex = 0.7, inset = 0.02 )
legend("bottomright", title = expression(kappa), 
       legend = c(k, "logistic", "Gauss"), cex = 0.7, inset = 0.02, 
       lty = c(olty, 1), lwd = c(olwd, 3), col = c(ocol , 7) )

plot(x, log(dlogis(x, scale = 2)), lwd = 2, type = "b", ylim = c(-8, -1.5), 
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", main = "log(dkiener1(x, m, g, k))") 
for (i in 1:length(k)) lines(x, log(dkiener1(x, k = k[i])),  
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
lines(x, dnorm(x, 0, 3.192, log = TRUE), type = "l", lty = 1, lwd = 3, col = 7)
legend("bottom", title = expression(kappa), legend = c(k, "logistic", "Gauss"), 
       cex = 0.7, inset = 0.02, lty = c(olty, 1), lwd = c(olwd, 3), col = c(ocol , 7) )
### End example 3


### Example 4 (four plots: quantile, derivate, density and quantiles from p)
p   &lt;- ppoints(199, a=0)
k   &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(k) &lt;- k ; k
op  &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))
plot(p, qlogis(p, scale = 2), type = "o", lwd = 2, ylim = c(-15, 15),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener1(p, m, g, k)")
for (i in 1:length(k)) lines(p, qkiener1(p, k = k[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(kappa), legend = c(k, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(p, 2/p/(1-p), type = "o", lwd = 2, xlim = c(0, 1), ylim = c(0, 100),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dqkiener1(p, m, g, k)")
for (i in 1:length(k)) lines(p, dqkiener1(p, k = k[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("top", title = expression(kappa), legend = c(k, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p*(1-p)/2, type = "o", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 0.14), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener1, dpkiener1(p, m, g, k)")
for (i in 1:length(k)) lines(qkiener1(p, k = k[i]), dpkiener1(p, k = k[i]),
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(kappa), legend = c(k, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 4


### Example 5 (q and VaR, ltm, rtm, and ES)
pp &lt;- c(0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
        0.10, 0.20, 0.35, 0.5, 0.65, 0.80, 0.90,
        0.95, 0.975, 0.99, 0.995, 0.9975, 0.999)
m &lt;- -10 ; g &lt;- 1 ; k &lt;- 4
round(c(m = m, g = g, a = k, k = k, w = k, d = 0, e = 0), 2) 
plot(qkiener1(pp, m, g, k), pp, type = "b")
round(cbind(p = pp, "1-p" = 1-pp, 
	q   =   qkiener1(pp, m, g, k), 
	ltm = ltmkiener1(pp, m, g, k), 
	rtm = rtmkiener1(pp, m, g, k), 
	es  =  eskiener1(pp, m, g, k), 
	VaR = varkiener1(pp, m, g, k)), 4)
round(kmean(c(m, g, k), model = "K1"), 4) # limit value of ltm, rtm
round(cbind(p = pp, "1-p" = 1-pp, 
	q   =   qkiener1(pp, m, g, k, lower.tail = FALSE), 
	ltm = ltmkiener1(pp, m, g, k, lower.tail = FALSE), 
	rtm = rtmkiener1(pp, m, g, k, lower.tail = FALSE), 
	es  =  eskiener1(pp, m, g, k, lower.tail = FALSE), 
	VaR = varkiener1(pp, m, g, k, lower.tail = FALSE)), 4)
### End example 5


</code></pre>

<hr>
<h2 id='kiener2'>Asymmetric Kiener Distribution K2</h2><span id='topic+kiener2'></span><span id='topic+dkiener2'></span><span id='topic+pkiener2'></span><span id='topic+qkiener2'></span><span id='topic+rkiener2'></span><span id='topic+dpkiener2'></span><span id='topic+dqkiener2'></span><span id='topic+lkiener2'></span><span id='topic+dlkiener2'></span><span id='topic+qlkiener2'></span><span id='topic+varkiener2'></span><span id='topic+ltmkiener2'></span><span id='topic+rtmkiener2'></span><span id='topic+dtmqkiener2'></span><span id='topic+eskiener2'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation,
value-at-risk, expected shortfall (+ signed left/right tail mean) 
and additional formulae for asymmetric Kiener distribution K2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkiener2(x, m = 0, g = 1, a = 3.2, w = 3.2, log = FALSE)

pkiener2(q, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

qkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

rkiener2(n, m = 0, g = 1, a = 3.2, w = 3.2)

dpkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, log = FALSE)

dqkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, log = FALSE)

lkiener2(x, m = 0, g = 1, a = 3.2, w = 3.2)

dlkiener2(lp, m = 0, g = 1, a = 3.2, w = 3.2, log = FALSE)

qlkiener2(lp, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE)

varkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

ltmkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

rtmkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

dtmqkiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE)

eskiener2(p, m = 0, g = 1, a = 3.2, w = 3.2, lower.tail = TRUE,
  log.p = FALSE, signedES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kiener2_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_m">m</code></td>
<td>
<p>numeric. The median.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_g">g</code></td>
<td>
<p>numeric. The scale parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_a">a</code></td>
<td>
<p>numeric. The left tail parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_w">w</code></td>
<td>
<p>numeric. The right tail parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_log">log</code></td>
<td>
<p>logical. If TRUE, densities are given in log scale.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="kiener2_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_lp">lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td></tr>
<tr><td><code id="kiener2_+3A_signedes">signedES</code></td>
<td>
<p>logical. FALSE (default) returns positive numbers for 
left and right tails. TRUE returns negative number 
(= <code>ltmkiener4</code>) for left tail and positive number 
(= <code>rtmkiener4</code>) for right tail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code><a href="#topic+aw2k">aw2k</a></code> and <code><a href="#topic+pk2pk">pk2pk</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution,. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p>Kiener distributions <code>K2(m, g, a, w)</code> are distributions 
with asymmetrical left 
and right fat tails described by the parameters <code>a</code> (alpha) for 
the left tail and <code>w</code> (omega) for the right tail. These parameters 
correspond to the power exponent that appear in Pareto formula and 
Karamata theorems. 
</p>
<p>As <code>a</code> and <code>w</code> are highly correlated, the use of Kiener distributions
(<code>K3(..., k, d)</code> K4 (<code>K4(..., k, e)</code> is an alternate solution.
</p>
<p><code>m</code> is the median of the distribution. <code>g</code> is the scale parameter 
and the inverse of the density at the median: <code class="reqn"> g = 1 / 8 / f(m) </code>.
As a first estimate, it is approximatively one fourth of the standard 
deviation <code class="reqn"> g  \approx \sigma / 4 </code> but is independant from it.
</p>
<p>The d, p functions have no explicit forms. They are provided here for 
convenience. They are estimated from a reverse optimization on the quantile 
function and can be (very) slow, depending the number of points to estimate. 
We recommand to use the quantile function as far as possible. 
WARNING: Results may become inconsistent when <code>a</code> or <code>w</code> are
smaller than 1. Hopefully, this case seldom happens in finance.
</p>
<p><code>qkiener2</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qkiener2(p, m, g, a, w) = 
                  m + g * k * (- exp(-logit(p)/a) + exp(logit(p)/w) ) </code>
</p>

<p>where k is the harmonic mean of the tail parameters <code>a</code> and <code>w</code> 
calculated by <code class="reqn">k = aw2k(a, w)</code>.
</p>
<p><code>rkiener2</code> generates <code>n</code> random quantiles.
</p>
<p>In addition to the classical d, p, q, r functions, the prefixes 
dp, dq, l, dl, ql are also provided.
</p>
<p><code>dpkiener2</code> is the density function calculated from the probability p. 
It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dpkiener2(p, m, g, a, w) = 
         p * (1 - p) / k / g / ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w </code>
</p>

<p><code>dqkiener2</code> is the derivate of the quantile function calculated from 
the probability p. It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqkiener2(p, m, g, a, w) = 
         k * g / p / (1 - p) * ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w ) </code>
</p>

<p><code>lkiener2</code> function is estimated from a reverse optimization and can 
be (very) slow depending the number of points to estimate. Initialization 
is done by assuming a symmetric distribution <code><a href="#topic+lkiener1">lkiener1</a></code> 
around the harmonic mean <code>k</code>, then optimization is performed to 
take into account the true values <code>a</code> and <code>w</code>. 
The result can be then compared to the empirical probability logit(p). 
WARNING: Results may become inconsistent when <code>a</code> or <code>w</code> are
smaller than 1. Hopefully, this case seldom happens in finance.
</p>
<p><code>dlkiener2</code> is the density function calculated from the logit of the 
probability lp = logit(p).  
it is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlkiener2(lp, m, g, a, w) = 
          p * (1 - p) / k / g / ( exp(-lp/a)/a + exp(lp/w)/w ) </code>
</p>

<p><code>qlkiener2</code> is the quantile function calculated from the logit of the 
probability. It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qlkiener2(lp, m, g, a, w) = 
          m + g * k * ( - exp(-lp/a) + exp(lp/w) ) </code>
</p>

<p><code>varkiener2</code> designates the Value a-risk and turns negative numbers 
into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> varkiener2 &lt;- if(p &lt;= 0.5) { - qkiener2 } else { qkiener2 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.05</code>, <code>p = 0.95</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>ltmkiener2</code>, <code>rtmkiener2</code> and <code>eskiener2</code> are respectively the 
left tail mean, the right tail mean and the expected shortfall of the distribution 
(sometimes called average VaR, conditional VaR or tail VaR). 
Left tail mean is the integrale from <code>-Inf</code> to <code>p</code> of the quantile function 
<code>qkiener2</code> divided by <code>p</code>.
Right tail mean is the integrale from <code>p</code> to <code>+Inf</code> of the quantile function 
<code>qkiener2</code> divided by 1-p.
Expected shortfall turns negative numbers into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> eskiener2 &lt;- if(p &lt;= 0.5) { - ltmkiener2 } else { rtmkiener2 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.025</code>, <code>p = 0.975</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>dtmqkiener2</code> is the difference between the left tail mean and the quantile 
when (p &lt;= 0.5) and the difference between the right tail mean and the quantile 
when (p &gt; 0.5). It is in quantile unit and is an indirect measure of the tail curvature.
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014.  Download it from:  
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>C. Acerbi, D. Tasche, Expected shortfall: a natural coherent alternative to 
Value at Risk, 9 May 2001. Download it from: 
<a href="https://www.bis.org/bcbs/ca/acertasc.pdf">https://www.bis.org/bcbs/ca/acertasc.pdf</a>
</p>


<h3>See Also</h3>

<p>Symmetric Kiener distribution K1 <code><a href="#topic+kiener1">kiener1</a></code>, 
asymmetric Kiener distributions K3, K4 and K7
<code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>, <code><a href="#topic+kiener7">kiener7</a></code>, 
conversion functions <code><a href="#topic+aw2k">aw2k</a></code>, 
estimation function <code><a href="#topic+fitkienerX">fitkienerX</a></code>, 
regression function <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)

### Example 1
pp &lt;- c(ppoints(11, a = 1), NA, NaN) ; pp
lp &lt;- logit(pp) ; lp
qkiener2(  p = pp, m = 2, g = 1.5, a = 4, w = 6)
qkiener2(  p = pp, m = 2, g = 1.5, a = 4, w = 6)
qlkiener2(lp = lp, m = 2, g = 1.5, a = 4, w = 6)
dpkiener2( p = pp, m = 2, g = 1.5, a = 4, w = 6)
dlkiener2(lp = lp, m = 2, g = 1.5, a = 4, w = 6)
dqkiener2( p = pp, m = 2, g = 1.5, a = 4, w = 6)


### Example 2
a       &lt;- 6
w       &lt;- 4
set.seed(2014)
mainTC  &lt;- paste("qkiener2(p, m = 0, g = 1, a = ", a, ", w = ", w, ")")
mainsum &lt;- paste("cumulated qkiener2(p, m = 0, g = 1, a = ", a, ", w = ", w, ")")
T       &lt;- 500
C       &lt;- 4
TC      &lt;- qkiener2(p = runif(T*C), m = 0, g = 1, a = a, w = w)
matTC   &lt;- matrix(TC, nrow = T, ncol = C, dimnames = list(1:T, letters[1:C]))
head(matTC)
plot.ts(matTC, main = mainTC)
#
matsum  &lt;- apply(matTC, MARGIN=2, cumsum) 
head(matsum)
plot.ts(matsum, plot.type = "single", main = mainsum)
### End example 2


### Example 3 (four plots: probability, density, logit, logdensity)
x     &lt;- q  &lt;- seq(-15, 15, length.out=101)
w     &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(w) &lt;- w
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 3, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
lleg  &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", "logit(0.95)   = 2.9", 
           "logit(0.50)   = 0", "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(x, plogis(x, scale = 2), type = "n", lwd = 2, ylim = c(0, 1),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "pkiener2(q, m, g, a=2, w=...)")
for (i in 1:length(w)) lines(x, pkiener2(x, a = 2, w = w[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(omega), legend = c(w), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, dlogis(x, scale = 2), type = "n", lwd = 2, ylim = c(0, 0.17),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dkiener2(q, m, g, a=2, w=...)")
for (i in 1:length(w)) lines(x, dkiener2(x, a = 2, w = w[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topright", title = expression(omega), legend = c(w), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, x/2, type = "n", lwd = 1, ylim = c(-7.5, 7.5), yaxt="n", xaxs = "i", 
     yaxs = "i", xlab = "", ylab = "", 
     main = "logit(pkiener2(q, m, g, a=2, w=...))")
axis(2, las=1, at=c(-6.9, -4.6, -2.9, 0, 2.9, 4.6, 6.9) )
for (i in 1:length(w)) lines(x, lkiener2(x, a = 2, w = w[i]),  
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", legend = lleg, cex = 0.7, inset = 0.02 )
legend("bottomright", title = expression(omega), legend = c(w), 
       cex = 0.7, inset = 0.02, lty = c(olty), lwd = c(olwd), col = c(ocol) )

plot(x, dlogis(x, scale = 2, log=TRUE), type = "n", lwd = 2, ylim = c(-8, -1.5),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "log(dkiener2(q, m, g, a=2, w=...))")
for (i in 1:length(w)) lines(x, dkiener2(x, a = 2, w = w[i], log=TRUE), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("bottom", title = expression(omega), legend = c(w), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )
### End example 3


### Example 4 (four plots: quantile, derivate, density and quantiles from p)
p     &lt;- ppoints(199, a=0)
w     &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(w) &lt;- w ; w
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(p, qlogis(p, scale = 2), type = "l", lwd = 2, xlim = c(0, 1), 
     ylim = c(-15, 15), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener2(p, m, g, a=2, w=...)")
for (i in 1:length(w)) lines(p, qkiener2(p, a = 2, w = w[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(omega), legend = c(w, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(p, 2/p/(1-p), type = "l", lwd = 2, xlim = c(0, 1), ylim = c(0, 100),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dqkiener2(p, m, g, a=2, w=...)")
for (i in 1:length(w)) lines(p, dqkiener2(p, a = 2, w = w[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("top", title = expression(omega), legend = c(w, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p*(1-p)/2, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 0.18), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener2, dpkiener2(p, m, g, a=2, w=...)")
for (i in 1:length(w)) { 
     lines(qkiener2(p, a = 2, w = w[i]), dpkiener2(p, a = 2, w = w[i]),
           lty = olty[i], lwd = olwd[i], col = ocol[i] ) }
legend("topleft", title = expression(omega), legend = c(w, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 1), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "inverse axis qkiener2(p, m, g, a=2, w=...)")
for (i in 1:length(w)) lines(qkiener2(p, a = 2, w = w[i]), p,
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(omega), legend = c(w, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 4


### Example 5 (q and VaR, ltm, rtm, and ES)
pp &lt;- c(0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
        0.10, 0.20, 0.35, 0.5, 0.65, 0.80, 0.90,
        0.95, 0.975, 0.99, 0.995, 0.9975, 0.999)
m &lt;- -10 ; g &lt;- 1 ; a &lt;- 5 ; w = 3 
k &lt;- aw2k(a, w) ; d &lt;- aw2d(a, w) ; e &lt;- aw2e(a, w)
round(c(m = m, g = g, a = a, k = k, w = w, d = d, e = e), 2) 
plot(qkiener2(pp, m, g, a, w), pp, type = "b")
round(cbind(p = pp, "1-p" = 1-pp,
	q   =   qkiener2(pp, m, g, a, w), 
	ltm = ltmkiener2(pp, m, g, a, w), 
	rtm = rtmkiener2(pp, m, g, a, w), 
	ES  =  eskiener2(pp, m, g, a, w), 
	VaR = varkiener2(pp, m, g, a, w)), 4)
round(kmean(c(m, g, a, w), model = "K2"), 4) # limit value for ltm and rtm
round(cbind(p = pp, "1-p" = 1-pp, 
	q   =   qkiener2(pp, m, g, a, w, lower.tail = FALSE), 
	ltm = ltmkiener2(pp, m, g, a, w, lower.tail = FALSE), 
	rtm = rtmkiener2(pp, m, g, a, w, lower.tail = FALSE), 
	ES  =  eskiener2(pp, m, g, a, w, lower.tail = FALSE), 
	VaR = varkiener2(pp, m, g, a, w, lower.tail = FALSE)), 4)
### End example 5


</code></pre>

<hr>
<h2 id='kiener3'>Asymmetric Kiener Distribution K3</h2><span id='topic+kiener3'></span><span id='topic+dkiener3'></span><span id='topic+pkiener3'></span><span id='topic+qkiener3'></span><span id='topic+rkiener3'></span><span id='topic+dpkiener3'></span><span id='topic+dqkiener3'></span><span id='topic+lkiener3'></span><span id='topic+dlkiener3'></span><span id='topic+qlkiener3'></span><span id='topic+varkiener3'></span><span id='topic+ltmkiener3'></span><span id='topic+rtmkiener3'></span><span id='topic+dtmqkiener3'></span><span id='topic+eskiener3'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation,
value-at-risk, expected shortfall (+ signed left/right tail mean) 
and additional formulae for asymmetric Kiener distribution K3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkiener3(x, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

pkiener3(q, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

qkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

rkiener3(n, m = 0, g = 1, k = 3.2, d = 0)

dpkiener3(p, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

dqkiener3(p, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

lkiener3(x, m = 0, g = 1, k = 3.2, d = 0)

dlkiener3(lp, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

qlkiener3(lp, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE)

varkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

ltmkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

rtmkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

dtmqkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

eskiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE, signedES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kiener3_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_m">m</code></td>
<td>
<p>numeric. The median.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_g">g</code></td>
<td>
<p>numeric. The scale parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_k">k</code></td>
<td>
<p>numeric. The tail parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_d">d</code></td>
<td>
<p>numeric. The distortion parameter between left and right tails.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_log">log</code></td>
<td>
<p>logical. If TRUE, densities are given in log scale.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="kiener3_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_lp">lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td></tr>
<tr><td><code id="kiener3_+3A_signedes">signedES</code></td>
<td>
<p>logical. FALSE (default) returns positive numbers for 
left and right tails. TRUE returns negative number 
(= <code>ltmkiener3</code>) for left tail and positive number 
(= <code>rtmkiener3</code>) for right tail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code><a href="#topic+aw2k">aw2k</a></code> and <code><a href="#topic+pk2pk">pk2pk</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution,. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p>Kiener distributions <code>K3(m, g, k, d, ...)</code> are distributions 
with asymmetrical left and right fat tails described by a global tail 
parameter <code>k</code> and a distortion parameter <code>d</code>. 
</p>
<p>Distributions K3 (<code><a href="#topic+kiener3">kiener3</a></code>) 
with parameters <code>k</code> (kappa) and <code>d</code> (delta) and
distributions K4 (<code><a href="#topic+kiener4">kiener4</a></code>)
with parameters <code>k</code> (kappa) and <code>e</code> (epsilon))
have been created to disantangle the parameters 
<code>a</code> (alpha) and <code>w</code> (omega) of distributions of 
distribution K2 (<code><a href="#topic+kiener2">kiener2</a></code>). 
The tiny difference between distributions K3 and K4 (<code class="reqn">d = e/k</code>) 
has not yet been fully evaluated. Both should be tested at that moment.
</p>
<p><code>k</code> is the harmonic mean of <code>a</code> and <code>w</code> and represents a 
global tail parameter.
</p>
<p><code>d</code> is a distortion parameter between the left tail parameter
<code>a</code> and the right tail parameter <code>w</code>.
It verifies the inequality: <code class="reqn">-k &lt; d &lt; k</code> 
(whereas <code>e</code> of distribution K4 verifies <code class="reqn">-1 &lt; e &lt; 1</code>).
The conversion functions (see <code><a href="#topic+aw2k">aw2k</a></code>) are:
</p>
<p style="text-align: center;"><code class="reqn">1/k = (1/a + 1/w)/2 </code>
</p>

<p style="text-align: center;"><code class="reqn">  d = (-1/a + 1/w)/2 </code>
</p>
 
<p style="text-align: center;"><code class="reqn">1/a = 1/k - d </code>
</p>
 
<p style="text-align: center;"><code class="reqn">1/w = 1/k + d</code>
</p>

<p><code>d</code> (and <code>e</code>) should be of the same sign than the skewness. 
A negative value <code class="reqn"> d &lt; 0 </code> implies <code class="reqn"> a &lt; w </code> and indicates a left  
tail heavier than the right tail. A positive value <code class="reqn"> d &gt; 0 </code> implies 
<code class="reqn"> a &gt; w </code> and a right tail heavier than the left tail.  
</p>
<p><code>m</code> is the median of the distribution. <code>g</code> is the scale parameter 
and the inverse of the density at the median: <code class="reqn"> g = 1 / 8 / f(m) </code>.
As a first estimate, it is approximatively one fourth of the standard 
deviation <code class="reqn"> g  \approx \sigma / 4 </code> but is independant from it.
</p>
<p>The d, p functions have no explicit forms. They are provided here for 
convenience. They are estimated from a reverse optimization on the quantile 
function and can be (very) slow, depending the number of points to estimate. 
We recommand to use the quantile function as far as possible.
WARNING: Results may become inconsistent when <code>k</code> is
smaller than 1 or for very large absolute values of <code>d</code>. 
Hopefully, this case seldom happens in finance.
</p>
<p><code>qkiener3</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qkiener3(p, m, g, k, d) = 
              m + 2 * g * k * sinh(logit(p) / k) * exp(d * logit(p)) </code>
</p>

<p><code>rkiener3</code> generates <code>n</code> random quantiles.
</p>
<p>In addition to the classical d, p, q, r functions, the prefixes 
dp, dq, l, dl, ql are also provided.
</p>
<p><code>dpkiener3</code> is the density function calculated from the probability p. 
The formula is adapted from distribution K2. It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dpkiener3(p, m, g, k, d) = 
         p * (1 - p) / k / g / ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w </code>
</p>

<p>with <code>a</code> and <code>w</code> defined from <code>k</code> and <code>d</code> 
with the formula presented above.
</p>
<p><code>dqkiener3</code> is the derivate of the quantile function calculated from 
the probability p. The formula is adapted from distribution K2. 
It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqkiener3(p, m, g, k, d) = 
         k * g / p / (1 - p) * ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w ) </code>
</p>
 
<p>with <code>a</code> and <code>w</code> defined above. 
</p>
<p><code>lkiener3</code> function is estimated from a reverse optimization and can 
be (very) slow depending the number of points to estimate. Initialization 
is done with a symmetric distribution <code><a href="#topic+lkiener1">lkiener1</a></code> 
of parameter <code>k</code> (thus <code class="reqn"> d = 0</code>). Then optimization is performed  
to take into account the true value of <code>d</code>. 
The results can then be compared to the empirical probability logit(p).
WARNING: Results may become inconsistent when <code>k</code> is
smaller than 1 or for very large absolute values of <code>d</code>. 
Hopefully, this case seldom happens in finance.
</p>
<p><code>dlkiener3</code> is the density function calculated from the logit of the 
probability lp = logit(p). The formula is adapted from distribution K2. 
it is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlkiener3(lp, m, g, k, d) = 
          p * (1 - p) / k / g / ( exp(-lp/a)/a + exp(lp/w)/w ) </code>
</p>

<p>with <code>a</code> and <code>w</code> defined above. 
</p>
<p><code>qlkiener3</code> is the quantile function calculated from the logit of the 
probability. It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qlkiener3(lp, m, g, k, d) = 
          m + 2 * g * k * sinh(lp / k) * exp(d * lp) </code>
</p>

<p><code>varkiener3</code> designates the Value a-risk and turns negative numbers 
into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> varkiener3 &lt;- if(p &lt;= 0.5) { - qkiener3 } else { qkiener3 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.05</code>, <code>p = 0.95</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>ltmkiener3</code>, <code>rtmkiener3</code> and <code>eskiener3</code> are respectively the 
left tail mean, the right tail mean and the expected shortfall of the distribution 
(sometimes called average VaR, conditional VaR or tail VaR). 
Left tail mean is the integrale from <code>-Inf</code> to <code>p</code> of the quantile function 
<code>qkiener3</code> divided by <code>p</code>.
Right tail mean is the integrale from <code>p</code> to <code>+Inf</code> of the quantile function 
<code>qkiener3</code> divided by 1-p.
Expected shortfall turns negative numbers into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> eskiener3 &lt;- if(p &lt;= 0.5) { - ltmkiener3 } else { rtmkiener3 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.025</code>, <code>p = 0.975</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>dtmqkiener3</code> is the difference between the left tail mean and the quantile 
when (p &lt;= 0.5) and the difference between the right tail mean and the quantile 
when (p &gt; 0.5). It is in quantile unit and is an indirect measure of the tail curvature.
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014. Download it from:  
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>C. Acerbi, D. Tasche, Expected shortfall: a natural coherent alternative to 
Value at Risk, 9 May 2001. Download it from: 
<a href="https://www.bis.org/bcbs/ca/acertasc.pdf">https://www.bis.org/bcbs/ca/acertasc.pdf</a>
</p>


<h3>See Also</h3>

<p>Symmetric Kiener distribution K1 <code><a href="#topic+kiener1">kiener1</a></code>, 
asymmetric Kiener distributions K2, K4 and K7
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>, <code><a href="#topic+kiener7">kiener7</a></code>, 
conversion functions <code><a href="#topic+aw2k">aw2k</a></code>,  
estimation function <code><a href="#topic+fitkienerX">fitkienerX</a></code>, 
regression function <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)

### Example 1
pp &lt;- c(ppoints(11, a = 1), NA, NaN) ; pp
lp &lt;- logit(pp) ; lp
qkiener3(  p = pp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
qlkiener3(lp = lp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
dpkiener3( p = pp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
dlkiener3(lp = lp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
dqkiener3( p = pp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))


### Example 2
k       &lt;- 4.8
d       &lt;- 0.042
set.seed(2014)
mainTC  &lt;- paste("qkiener3(p, m = 0, g = 1, k = ", k, ", d = ", d, ")")
mainsum &lt;- paste("cumulated qkiener3(p, m = 0, g = 1, k = ", k, ", d = ", d, ")")
T       &lt;- 500
C       &lt;- 4
TC      &lt;- qkiener3(p = runif(T*C), m = 0, g = 1, k = k, d = d)
matTC   &lt;- matrix(TC, nrow = T, ncol = C, dimnames = list(1:T, letters[1:C]))
head(matTC)
plot.ts(matTC, main = mainTC)
#
matsum  &lt;- apply(matTC, MARGIN=2, cumsum) 
head(matsum)
plot.ts(matsum, plot.type = "single", main = mainsum)
### End example 2


### Example 3 (four plots: probability, density, logit, logdensity)
x     &lt;- q  &lt;- seq(-15, 15, length.out=101)
k     &lt;- 3.2
d     &lt;- c(-0.1, -0.03, -0.01, 0.01, 0.03, 0.1) ; names(d) &lt;- d
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 3, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
lleg  &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", "logit(0.95)   = 2.9", 
           "logit(0.50)   = 0", "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(x, pkiener3(x, k = 3.2, d = 0), type = "l", lwd = 3, ylim = c(0, 1),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "pkiener3(q, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(x, pkiener3(x, k = 3.2, d = d[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, dkiener3(x, k = 3.2, d = 0), type = "l", lwd = 3, ylim = c(0, 0.14),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dkiener3(q, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(x, dkiener3(x, k = 3.2, d = d[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topright", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, lkiener3(x, k = 3.2, d = 0), type = "l", lwd =3, ylim = c(-7.5, 7.5), 
     yaxt="n", xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "logit(pkiener3(q, m, g, k=3.2, d=...))")
axis(2, las=1, at=c(-6.9, -4.6, -2.9, 0, 2.9, 4.6, 6.9) )
for (i in 1:length(d)) lines(x, lkiener3(x, k = 3.2, d = d[i]),  
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", legend = lleg, cex = 0.7, inset = 0.02 )
legend("bottomright", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = c(olty), lwd = c(olwd), col = c(ocol) )

plot(x, dkiener3(x, k = 3.2, d = 0, log = TRUE), type = "l", lwd = 3, 
     ylim = c(-8, -1.5), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "log(dkiener3(q, m, g, k=2, d=...))")
for (i in 1:length(d)) lines(x, dkiener3(x, k = 3.2, d = d[i], log=TRUE), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("bottom", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )
### End example 3


### Example 4 (four plots: quantile, derivate, density and quantiles from p)
p     &lt;- ppoints(199, a=0)
d     &lt;- c(-0.1, -0.03, -0.01, 0.01, 0.03, 0.1) ; names(d) &lt;- d
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(p, qlogis(p, scale = 2), type = "l", lwd = 2, xlim = c(0, 1),
      ylim = c(-15, 15), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(p, qkiener3(p, k = 3.2, d = d[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(delta), legend = c(d, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(p, 2/p/(1-p), type = "l", lwd = 2, xlim = c(0, 1), ylim = c(0, 100),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dqkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(p, dqkiener3(p, k = 3.2, d = d[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("top", title = expression(delta), legend = c(d, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p*(1-p)/2, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 0.14), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener3, dpkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) { 
     lines(qkiener3(p, k = 3.2, d = d[i]), dpkiener3(p, k = 3.2, d = d[i]),
           lty = olty[i], lwd = olwd[i], col = ocol[i] ) }
legend("topleft", title = expression(delta), legend = c(d, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 1), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "inverse axis qkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(qkiener3(p, k = 3.2, d = d[i]), p,
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(delta), legend = c(d, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 4


### Example 5 (q and VaR, ltm, rtm, and ES)
pp &lt;- c(0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
        0.10, 0.20, 0.35, 0.5, 0.65, 0.80, 0.90,
        0.95, 0.975, 0.99, 0.995, 0.9975, 0.999)
m &lt;- -10 ; g &lt;- 1 ; k &lt;- 4 ; d &lt;- 0.06 
a &lt;- dk2a(d, k) ; w &lt;- dk2w(d, k) ; e &lt;- dk2e(d, k)
round(c(m = m, g = g, a = a, k = k, w = w, d = d, e = e), 2) 
plot(qkiener3(  pp, m=m, k=k, d=d), pp, type ="b")
round(cbind(p = pp, "1-p" = 1-pp,
	q   =   qkiener3(pp, m, g, k, d),
	ltm = ltmkiener3(pp, m, g, k, d),
	rtm = rtmkiener3(pp, m, g, k, d),
	ES  =  eskiener3(pp, m, g, k, d),
	VaR = varkiener3(pp, m, g, k, d)), 4)
round(kmean(c(m, g, k, d), model = "K3"), 4) # limit value for ltm and rtm
round(cbind(p = pp, "1-p" = 1-pp,
	q   =   qkiener3(pp, m, g, k, d, lower.tail = FALSE),
	ltm = ltmkiener3(pp, m, g, k, d, lower.tail = FALSE),
	rtm = rtmkiener3(pp, m, g, k, d, lower.tail = FALSE),
	ES  =  eskiener3(pp, m, g, k, d, lower.tail = FALSE),
	VaR = varkiener3(pp, m, g, k, d, lower.tail = FALSE)), 4)
### End example 5


</code></pre>

<hr>
<h2 id='kiener4'>Asymmetric Kiener Distribution K4</h2><span id='topic+kiener4'></span><span id='topic+dkiener4'></span><span id='topic+pkiener4'></span><span id='topic+qkiener4'></span><span id='topic+rkiener4'></span><span id='topic+dpkiener4'></span><span id='topic+dqkiener4'></span><span id='topic+lkiener4'></span><span id='topic+dlkiener4'></span><span id='topic+qlkiener4'></span><span id='topic+varkiener4'></span><span id='topic+ltmkiener4'></span><span id='topic+rtmkiener4'></span><span id='topic+dtmqkiener4'></span><span id='topic+eskiener4'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation,
value-at-risk, expected shortfall (+ signed left/right tail mean) 
and additional formulae for asymmetric Kiener distribution K4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkiener4(x, m = 0, g = 1, k = 3.2, e = 0, log = FALSE)

pkiener4(q, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

qkiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

rkiener4(n, m = 0, g = 1, k = 3.2, e = 0)

dpkiener4(p, m = 0, g = 1, k = 3.2, e = 0, log = FALSE)

dqkiener4(p, m = 0, g = 1, k = 3.2, e = 0, log = FALSE)

lkiener4(x, m = 0, g = 1, k = 3.2, e = 0)

dlkiener4(lp, m = 0, g = 1, k = 3.2, e = 0, log = FALSE)

qlkiener4(lp, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE)

varkiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

ltmkiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

rtmkiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

dtmqkiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE)

eskiener4(p, m = 0, g = 1, k = 3.2, e = 0, lower.tail = TRUE,
  log.p = FALSE, signedES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kiener4_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_m">m</code></td>
<td>
<p>numeric. The median.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_g">g</code></td>
<td>
<p>numeric. The scale parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_k">k</code></td>
<td>
<p>numeric. The tail parameter, preferably strictly positive.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_e">e</code></td>
<td>
<p>numeric. The eccentricity parameter between left and right tails.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_log">log</code></td>
<td>
<p>logical. If TRUE, densities are given in log scale.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="kiener4_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_lp">lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td></tr>
<tr><td><code id="kiener4_+3A_signedes">signedES</code></td>
<td>
<p>logical. FALSE (default) returns positive numbers for 
left and right tails. TRUE returns negative number 
(= <code>ltmkiener4</code>) for left tail and positive number 
(= <code>rtmkiener4</code>) for right tail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code><a href="#topic+aw2k">aw2k</a></code> and <code><a href="#topic+pk2pk">pk2pk</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution,. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p>Kiener distributions <code>K4(m, g, k, e, ...)</code> are distributions 
with asymmetrical left and right fat tails described by a global tail 
parameter <code>k</code> and an eccentricity parameter <code>e</code>. 
</p>
<p>Distributions K3 (<code><a href="#topic+kiener3">kiener3</a></code>) 
with parameters <code>k</code> (kappa) and <code>d</code> (delta) and
distributions K4 (<code><a href="#topic+kiener4">kiener4</a></code>)
with parameters <code>k</code> (kappa) and <code>e</code> (epsilon))
have been created to disantangle the parameters 
<code>a</code> (alpha) and <code>w</code> (omega) of distributions K2
(<code><a href="#topic+kiener2">kiener2</a></code>). 
The tiny difference between distributions K3 and K4 (<code class="reqn">d = e/k</code>) 
has not yet been fully evaluated. Both should be tested at that moment.
</p>
<p><code>k</code> is the harmonic mean of <code>a</code> and <code>w</code> and represents a 
global tail parameter.
</p>
<p><code>e</code> is an eccentricity parameter between the left tail parameter
<code>a</code> and the right tail parameter <code>w</code>.
It verifies the inequality: <code class="reqn">-1 &lt; e &lt; 1</code> 
(whereas <code>d</code> of distribution K3 verifies <code class="reqn">-k &lt; d &lt; k</code>).
The conversion functions (see <code><a href="#topic+aw2k">aw2k</a></code>) are:
</p>
<p style="text-align: center;"><code class="reqn">1/k = (1/a + 1/w)/2 </code>
</p>

<p style="text-align: center;"><code class="reqn">  e = (a - w)/(a + w) </code>
</p>

<p style="text-align: center;"><code class="reqn">  a = k/(1 - e) </code>
</p>

<p style="text-align: center;"><code class="reqn">  w = k/(1 + e) </code>
</p>

<p><code>e</code> (and <code>d</code>) should be of the same sign than the skewness. 
A negative value <code class="reqn"> e &lt; 0 </code> implies <code class="reqn"> a &lt; w </code> and indicates a left 
tail heavier than the right tail. A positive value <code class="reqn"> e &gt; 0 </code> implies 
<code class="reqn"> a &gt; w </code> and a right tail heavier than the left tail.  
</p>
<p><code>m</code> is the median of the distribution. <code>g</code> is the scale parameter 
and the inverse of the density at the median: <code class="reqn"> g = 1 / 8 / f(m) </code>.
As a first estimate, it is approximatively one fourth of the standard 
deviation <code class="reqn"> g  \approx \sigma / 4 </code> but is independant from it.
</p>
<p>The d, p functions have no explicit forms. They are provided here for 
convenience. They are estimated from a reverse optimization on the quantile 
function and can be (very) slow, depending the number of points to estimate. 
We recommand to use the quantile function as far as possible. 
WARNING: Results may become inconsistent when <code>k</code> is
smaller than 1 or for very large absolute values of <code>e</code>. 
Hopefully, these cases seldom happen in finance.
</p>
<p><code>qkiener4</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qkiener4(p, m, g, k, e) = 
              m + 2 * g * k * sinh(logit(p) / k) * exp(e / k * logit(p)) </code>
</p>

<p><code>rkiener4</code> generates <code>n</code> random quantiles.
</p>
<p>In addition to the classical d, p, q, r functions, the prefixes 
dp, dq, l, dl, ql are also provided.
</p>
<p><code>dpkiener4</code> is the density function calculated from the probability p. 
The formula is adapted from distribution K2. It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dpkiener4(p, m, g, k, e) = 
         p * (1 - p) / k / g / ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w </code>
</p>

<p>with <code>a</code> and <code>w</code> defined from <code>k</code> and <code>e</code>.
</p>
<p><code>dqkiener4</code> is the derivate of the quantile function calculated from 
the probability p. The formula is adapted from distribution K2. 
It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqkiener4(p, m, g, k, e) = 
         k * g / p / (1 - p) * ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w ) </code>
</p>
 
<p>with <code>a</code> and <code>w</code> defined with the formula presented above. 
</p>
<p><code>lkiener4</code> function is estimated from a reverse optimization and can 
be (very) slow depending the number of points to estimate. Initialization 
is done with a symmetric distribution <code><a href="#topic+lkiener1">lkiener1</a></code> 
of parameter <code>k</code> (thus <code class="reqn"> e = 0</code>). Then optimization is performed  
to take into account the true value of <code>e</code>.  
The results can then be compared to the empirical probability logit(p).
WARNING: Results may become inconsistent when <code>k</code> is
smaller than 1 or for very large absolute values of <code>e</code>. 
Hopefully, these cases seldom happen in finance.
</p>
<p><code>dlkiener4</code> is the density function calculated from the logit of the 
probability lp = logit(p). The formula is adapted from distribution K2.
it is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlkiener4(lp, m, g, k, e) = 
          p * (1 - p) / k / g / ( exp(-lp/a)/a + exp(lp/w)/w ) </code>
</p>

<p>with <code>a</code> and <code>w</code> defined above. 
</p>
<p><code>qlkiener4</code> is the quantile function calculated from the logit of the 
probability. It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qlkiener4(lp, m, g, k, e) = 
          m + 2 * g * k * sinh(lp / k) * exp(e / k * lp) </code>
</p>

<p><code>varkiener4</code> designates the Value a-risk and turns negative numbers 
into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> varkiener4 &lt;- if(p &lt;= 0.5) { - qkiener4 } else { qkiener4 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.05</code>, <code>p = 0.95</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>ltmkiener4</code>, <code>rtmkiener4</code> and <code>eskiener4</code> are respectively the 
left tail mean, the right tail mean and the expected shortfall of the distribution 
(sometimes called average VaR, conditional VaR or tail VaR). 
Left tail mean is the integrale from <code>-Inf</code> to <code>p</code> of the quantile function 
<code>qkiener4</code> divided by <code>p</code>.
Right tail mean is the integrale from <code>p</code> to <code>+Inf</code> of the quantile function 
<code>qkiener4</code> divided by 1-p.
Expected shortfall turns negative numbers into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> eskiener4 &lt;- if(p &lt;= 0.5) { - ltmkiener4 } else { rtmkiener4 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.025</code>, <code>p = 0.975</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>dtmqkiener4</code> is the difference between the left tail mean and the quantile 
when (p &lt;= 0.5) and the difference between the right tail mean and the quantile 
when (p &gt; 0.5). It is in quantile unit and is an indirect measure of the tail curvature.
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014. Download it from:  
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>C. Acerbi, D. Tasche, Expected shortfall: a natural coherent alternative to 
Value at Risk, 9 May 2001. Download it from: 
<a href="https://www.bis.org/bcbs/ca/acertasc.pdf">https://www.bis.org/bcbs/ca/acertasc.pdf</a>
</p>


<h3>See Also</h3>

<p>Symmetric Kiener distribution K1 <code><a href="#topic+kiener1">kiener1</a></code>, 
asymmetric Kiener distributions K2, K3 and K7
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener7">kiener7</a></code>, 
conversion functions <code><a href="#topic+aw2k">aw2k</a></code>, 
estimation function <code><a href="#topic+fitkienerX">fitkienerX</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)

### Example 1
pp &lt;- c(ppoints(11, a = 1), NA, NaN) ; pp
lp &lt;- logit(pp) ; lp
qkiener4(  p = pp, m = 2, g = 1.5, k = aw2k(4, 6), e = aw2e(4, 6))
qlkiener4(lp = lp, m = 2, g = 1.5, k = aw2k(4, 6), e = aw2e(4, 6))
dpkiener4( p = pp, m = 2, g = 1.5, k = aw2k(4, 6), e = aw2e(4, 6))
dlkiener4(lp = lp, m = 2, g = 1.5, k = aw2k(4, 6), e = aw2e(4, 6))
dqkiener4( p = pp, m = 2, g = 1.5, k = aw2k(4, 6), e = aw2e(4, 6))


### Example 2
k       &lt;- 4.8
e       &lt;- 0.2
set.seed(2014)
mainTC  &lt;- paste("qkiener4(p, m = 0, g = 1, k = ", k, ", e = ", e, ")")
mainsum &lt;- paste("cumulated qkiener4(p, m = 0, g = 1, k = ", k, ", e = ", e, ")")
T       &lt;- 500
C       &lt;- 4
TC      &lt;- qkiener4(p = runif(T*C), m = 0, g = 1, k = k, e = e)
matTC   &lt;- matrix(TC, nrow = T, ncol = C, dimnames = list(1:T, letters[1:C]))
head(matTC)
plot.ts(matTC, main = mainTC)
#
matsum  &lt;- apply(matTC, MARGIN=2, cumsum) 
head(matsum)
plot.ts(matsum, plot.type = "single", main = mainsum)
### End example 2


### Example 3 (four plots: probability, density, logit, logdensity)
x     &lt;- q  &lt;- seq(-15, 15, length.out=101)
k     &lt;- 3.2
e     &lt;- c(-0.3, -0.15, -0.07, 0.07, 0.15, 0.30) ; names(e) &lt;- e
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 3, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
lleg  &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", "logit(0.95)   = 2.9", 
           "logit(0.50)   = 0", "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(x, pkiener4(x, k = 3.2, e = 0), type = "l", lwd = 3, ylim = c(0, 1),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "pkiener4(q, m, g, k=3.2, e=...)")
for (i in 1:length(e)) lines(x, pkiener4(x, k = 3.2, e = e[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(epsilon), legend = c(e, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, dkiener4(x, k = 3.2, e = 0), type = "l", lwd = 3, ylim = c(0, 0.14),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dkiener4(q, m, g, k=3.2, e=...)")
for (i in 1:length(e)) lines(x, dkiener4(x, k = 3.2, e = e[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topright", title = expression(epsilon), legend = c(e, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, lkiener4(x, k = 3.2, e = 0), type = "l", lwd =3, ylim = c(-7.5, 7.5), 
     yaxt="n", xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "logit(pkiener4(q, m, g, k=3.2, e=...))")
axis(2, las=1, at=c(-6.9, -4.6, -2.9, 0, 2.9, 4.6, 6.9) )
for (i in 1:length(e)) lines(x, lkiener4(x, k = 3.2, e = e[i]),  
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", legend = lleg, cex = 0.7, inset = 0.02 )
legend("bottomright", title = expression(epsilon), legend = c(e, "0"), 
       cex = 0.7, inset = 0.02, lty = c(olty), lwd = c(olwd), col = c(ocol) )

plot(x, dkiener4(x, k = 3.2, e = 0, log = TRUE), type = "l", lwd = 3, 
     ylim = c(-8, -1.5), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "log(dkiener4(q, m, g, k=2, e=...))")
for (i in 1:length(e)) lines(x, dkiener4(x, k = 3.2, e = e[i], log=TRUE), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("bottom", title = expression(epsilon), legend = c(e, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )
### End example 3


### Example 4 (four plots: quantile, derivate, density and quantiles from p)
p     &lt;- ppoints(199, a=0)
e     &lt;- c(-0.3, -0.15, -0.07, 0.07, 0.15, 0.30) ; names(e) &lt;- e
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(p, qlogis(p, scale = 2), type = "l", lwd = 2, xlim = c(0, 1),
     ylim = c(-15, 15), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener4(p, m, g, k=3.2, e=...)")
for (i in 1:length(e)) lines(p, qkiener4(p, k = 3.2, e = e[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(epsilon), legend = c(e, "qlogis(x/2)"), 
        inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(p, 2/p/(1-p), type = "l", lwd = 2, xlim = c(0, 1), ylim = c(0, 100),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dqkiener4(p, m, g, k=3.2, e=...)")
for (i in 1:length(e)) lines(p, dqkiener4(p, k = 3.2, e = e[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("top", title = expression(epsilon), legend = c(e, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p*(1-p)/2, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 0.14), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener4, dpkiener4(p, m, g, k=3.2, e=...)")
for (i in 1:length(e)) { 
     lines(qkiener4(p, k = 3.2, e = e[i]), dpkiener4(p, k = 3.2, e = e[i]),
           lty = olty[i], lwd = olwd[i], col = ocol[i] ) }
legend("topleft", title = expression(epsilon), legend = c(e, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 1), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "inverse axis qkiener4(p, m, g, k=3.2, e=...)")
for (i in 1:length(e)) lines(qkiener4(p, k = 3.2, e = e[i]), p,
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(epsilon), legend = c(e, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 4


pp &lt;- c(0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
        0.10, 0.20, 0.35, 0.5, 0.65, 0.80, 0.90,
        0.95, 0.975, 0.99, 0.995, 0.9975, 0.999)
m &lt;- -5 ; g &lt;- 1 ; k &lt;- 4 ; e = -0.20
a &lt;- ek2a(e, k) ; w &lt;- ek2w(e, k) ; d &lt;- ek2d(e, k) 
round(c(m = m, g = g, a = a, k = k, w = w, d = d, e = e), 2) 
plot(qkiener4(pp, m, g, k, e), pp, type = "b")
round(cbind(p = pp, "1-p" = 1-pp,
	q   =   qkiener4(pp, m, g, k, e),
	ltm = ltmkiener4(pp, m, g, k, e),
	rtm = rtmkiener4(pp, m, g, k, e),
	ES  =  eskiener4(pp, m, g, k, e),
	VaR = varkiener4(pp, m, g, k, e)), 4)
round(kmean(c(m, g, k, e), model = "K4"), 4) # limit value for ltm and rtm
round(cbind(p = pp, "1-p" = 1-pp, 
	q   =   qkiener4(pp, m, g, k, e, lower.tail = FALSE), 
	ltm = ltmkiener4(pp, m, g, k, e, lower.tail = FALSE), 
	rtm = rtmkiener4(pp, m, g, k, e, lower.tail = FALSE), 
	ES  =  eskiener4(pp, m, g, k, e, lower.tail = FALSE), 
	VaR = varkiener4(pp, m, g, k, e, lower.tail = FALSE)), 4)
### End example 5


</code></pre>

<hr>
<h2 id='kiener7'>Asymmetric Kiener Distribution K7 (K2)</h2><span id='topic+kiener7'></span><span id='topic+dkiener7'></span><span id='topic+pkiener7'></span><span id='topic+qkiener7'></span><span id='topic+rkiener7'></span><span id='topic+dpkiener7'></span><span id='topic+dqkiener7'></span><span id='topic+lkiener7'></span><span id='topic+dlkiener7'></span><span id='topic+qlkiener7'></span><span id='topic+varkiener7'></span><span id='topic+ltmkiener7'></span><span id='topic+rtmkiener7'></span><span id='topic+dtmqkiener7'></span><span id='topic+eskiener7'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation,
value-at-risk, expected shortfall (+ signed left/right tail mean) 
and additional formulae for asymmetric Kiener distribution K7 = K2.
With K7, the vector of parameters is provided as <code>coefk</code>, usually estimated 
with <code><a href="#topic+paramkienerX">paramkienerX</a></code> (and ~X5,~X7) or <code><a href="#topic+regkienerLX">regkienerLX</a>$coefk</code>. 
Main inputs can be supplied as vector (<code>x,q,p</code>) and matrix (<code>coefk</code>)  
and the resulting output is a matrix (useful for simulation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkiener7(x, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), log = FALSE)

pkiener7(q, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

qkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

rkiener7(n, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), same_p = FALSE)

dpkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), log = FALSE)

dqkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), log = FALSE)

lkiener7(x, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0))

dlkiener7(lp, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), log = FALSE)

qlkiener7(lp, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE)

varkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

ltmkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

rtmkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

dtmqkiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE)

eskiener7(p, coefk = c(0, 1, 3.2, 3.2, 3.2, 0, 0), lower.tail = TRUE,
  log.p = FALSE, signedES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kiener7_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_coefk">coefk</code></td>
<td>
<p>vector of 7 parameters <code>c(m,g,a,k,w,d,e)</code> 
or matrix with 7 columns.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_log">log</code></td>
<td>
<p>logical. If TRUE, densities are given in log scale.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="kiener7_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_n">n</code></td>
<td>
<p>integer. Number of observations. If length(n) &gt; 1, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_same_p">same_p</code></td>
<td>
<p>logical. If FALSE (default), random probabilies are generated 
on the fly. If TRUE, the same set of random probabilities is 
used for each line of coefk (if coefk is a matrix).</p>
</td></tr>
<tr><td><code id="kiener7_+3A_lp">lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td></tr>
<tr><td><code id="kiener7_+3A_signedes">signedES</code></td>
<td>
<p>logical. FALSE (default) returns positive numbers for 
left and right tails. TRUE returns negative number 
(= <code>ltmkiener7</code>) for left tail and positive number 
(= <code>rtmkiener7</code>) for right tail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code><a href="#topic+aw2k">aw2k</a></code> and <code><a href="#topic+pk2pk">pk2pk</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p>Kiener distribution <code>K7</code> is designed after <code><a href="#topic+kiener2">kiener2</a></code> 
but uses as input <code>coefk</code> rather than <code>m</code>, <code>g</code>, <code>a</code> 
and <code>w</code>. 
</p>
<p>The d, p functions have no explicit forms. They are provided here for 
convenience. They are estimated from a reverse optimization on the quantile 
function and can be (very) slow, depending the number of points to estimate. 
We recommand to use the quantile function as much as possible. 
WARNING: Results may become inconsistent when <code>a</code> or <code>w</code> are
smaller than 1. 
</p>
<p><code>qkiener7</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qkiener7(p, coefk) = 
                  m + g * k * (- exp(-logit(p)/a) + exp(logit(p)/w) ) </code>
</p>

<p>where k is the harmonic mean of the tail parameters <code>a</code> and <code>w</code> 
calculated by <code class="reqn">k = aw2k(a, w)</code>.
</p>
<p><code>rkiener7</code> generates <code>n</code> random quantiles.
</p>
<p>In addition to the classical d, p, q, r functions, the prefixes 
dp, dq, l, dl, ql are also provided.
</p>
<p><code>dpkiener7</code> is the density function calculated from the probability p. 
It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dpkiener7(p, coefk) = 
         p * (1 - p) / k / g / ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w </code>
</p>

<p><code>dqkiener7</code> is the derivate of the quantile function calculated from 
the probability p. It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqkiener7(p, coefk) = 
         k * g / p / (1 - p) * ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w ) </code>
</p>

<p><code>lkiener7</code> function is estimated from a reverse optimization and can 
be (very) slow depending the number of points to estimate. Initialization 
is done by assuming a symmetric distribution <code><a href="#topic+lkiener1">lkiener1</a></code> 
around the harmonic mean <code>k</code>, then optimization is performed to 
take into account the true values <code>a</code> and <code>w</code>. 
The result can be then compared to the empirical probability logit(p). 
WARNING: Results may become inconsistent when <code>a</code> or <code>w</code> are
smaller than 1. 
</p>
<p><code>dlkiener7</code> is the density function calculated from the logit of the 
probability lp = logit(p).  
it is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlkiener7(lp, coefk) = 
          p * (1 - p) / k / g / ( exp(-lp/a)/a + exp(lp/w)/w ) </code>
</p>

<p><code>qlkiener7</code> is the quantile function calculated from the logit of the 
probability. It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qlkiener7(lp, coefk) = 
          m + g * k * ( - exp(-lp/a) + exp(lp/w) ) </code>
</p>

<p><code>varkiener7</code> designates the Value a-risk and turns negative numbers 
into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> varkiener7 &lt;- if(p &lt;= 0.5) { - qkiener7 } else { qkiener7 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.05</code>, <code>p = 0.95</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>ltmkiener7</code>, <code>rtmkiener7</code> and <code>eskiener7</code> are respectively the 
left tail mean, the right tail mean and the expected shortfall of the distribution 
(sometimes called average VaR, conditional VaR or tail VaR). 
Left tail mean is the integrale from <code>-Inf</code> to <code>p</code> of the quantile function 
<code>qkiener7</code> divided by <code>p</code>.
Right tail mean is the integrale from <code>p</code> to <code>+Inf</code> of the quantile function 
<code>qkiener7</code> divided by 1-p.
Expected shortfall turns negative numbers into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> eskiener7 &lt;- if(p &lt;= 0.5) { - ltmkiener7 } else { rtmkiener7 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.025</code>, <code>p = 0.975</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>dtmqkiener7</code> is the difference between the left tail mean and the quantile 
when (p &lt;= 0.5) and the difference between the right tail mean and the quantile 
when (p &gt; 0.5). It is in quantile unit and is an indirect measure of the tail curvature.
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014.  Download it from:  
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>C. Acerbi, D. Tasche, Expected shortfall: a natural coherent alternative to 
Value at Risk, 9 May 2001. Download it from: 
<a href="https://www.bis.org/bcbs/ca/acertasc.pdf">https://www.bis.org/bcbs/ca/acertasc.pdf</a>
</p>


<h3>See Also</h3>

<p>Symmetric Kiener distribution K1 <code><a href="#topic+kiener1">kiener1</a></code>, 
asymmetric Kiener distributions K2, K3 and K4 
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>, 
conversion functions <code><a href="#topic+aw2k">aw2k</a></code>, 
estimation function <code><a href="#topic+paramkienerX">paramkienerX</a></code>, 
estimation function <code><a href="#topic+fitkienerX">fitkienerX</a></code>, 
regression function <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(ED &lt;- fatreturns(extractData())) 
(coefk  &lt;- paramkienerX(ED, dgts = 3))  
x  &lt;- -4
xx &lt;- -4:4
p  &lt;- 0.1
pp &lt;- pprobs2

dkiener7(x)
dkiener7(x,  coefk) 
dkiener7(xx)
dkiener7(xx, coefk)

pkiener7(x)
pkiener7(x,  coefk) 
pkiener7(xx)
pkiener7(xx, coefk)

qkiener7(p)
qkiener7(p,  coefk) 
qkiener7(pp)
qkiener7(pp, coefk)

rkiener7(10)
rkiener7(10, coefk)

varkiener7(p)
varkiener7(p, coefk)
varkiener7(pp)
varkiener7(pp, coefk) 

ltmkiener7(p)
ltmkiener7(p, coefk)
ltmkiener7(pp)
ltmkiener7(pp, coefk)

eskiener7(p)
eskiener7(p, coefk)
eskiener7(pp)
eskiener7(pp, coefk) 


</code></pre>

<hr>
<h2 id='kmoments'>Moments Associated To Kiener Distribution Parameters</h2><span id='topic+kmoments'></span><span id='topic+xmoments'></span><span id='topic+kmoment'></span><span id='topic+kcmoment'></span><span id='topic+kmean'></span><span id='topic+kstandev'></span><span id='topic+kvariance'></span><span id='topic+kskewness'></span><span id='topic+kkurtosis'></span><span id='topic+kekurtosis'></span>

<h3>Description</h3>

<p>Non-central moments, central moments, mean, standard deviation, variance, 
skewness, kurtosis, excess of kurtosis and cumulants associated to  
the parameters of Kiener distributions K1, K2, K3 and K4. 
All-in-one vectors <code>kmoments</code> (estimated from the parameters) 
and <code>xmoments</code> (estimated from the vector of quantiles) are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmoments(coefk, model = "K2", lengthx = NA, dgts = NULL,
  dimnames = FALSE)

xmoments(x, dgts = NULL, dimnames = FALSE)

kmoment(n, coefk, model = "K2", dgts = NULL)

kcmoment(n, coefk, model = "K2", dgts = NULL)

kmean(coefk, model = "K2", dgts = NULL)

kstandev(coefk, model = "K2", dgts = NULL)

kvariance(coefk, model = "K2", dgts = NULL)

kskewness(coefk, model = "K2", dgts = NULL)

kkurtosis(coefk, model = "K2", dgts = NULL)

kekurtosis(coefk, model = "K2", dgts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmoments_+3A_coefk">coefk</code></td>
<td>
<p>vector. Parameters of the distribution of length 3 (&quot;K1&quot;),
length 4 (model = K2, K3, K4) and length 7 (&quot;K7&quot;).</p>
</td></tr>
<tr><td><code id="kmoments_+3A_model">model</code></td>
<td>
<p>character. Model type, either &quot;K2&quot;, &quot;K3&quot; or &quot;K4&quot; if <code>coefk</code> is 
of length 4. Type &quot;K1&quot; and &quot;K7&quot; may be provided but are ignored.</p>
</td></tr>
<tr><td><code id="kmoments_+3A_lengthx">lengthx</code></td>
<td>
<p>integer. The length of the vector <code>x</code> used to calculate the parameters.
See the details for matrix and lists.</p>
</td></tr>
<tr><td><code id="kmoments_+3A_dgts">dgts</code></td>
<td>
<p>integer. The rounding applied to the output.</p>
</td></tr>
<tr><td><code id="kmoments_+3A_dimnames">dimnames</code></td>
<td>
<p>boolean. Display dimnames.</p>
</td></tr>
<tr><td><code id="kmoments_+3A_x">x</code></td>
<td>
<p>numeric. Vector of quantiles.</p>
</td></tr>
<tr><td><code id="kmoments_+3A_n">n</code></td>
<td>
<p>integer. The moment order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The non-central moments <code>m1,m2,m3,m4,..,mn</code>, 
the central moments <code>u1,u2,u3,u4,..,un</code> (where u stands for mu in Greek)
and the cumulants <code>k1,k2,k3,k4,..,kn</code> (where k stands for kappa in Greek; 
not to be confounded with tail parameter &quot;k&quot; and models &quot;K1&quot;, &quot;K2&quot;, &quot;K3&quot;, &quot;K4&quot;) 
of order <code class="reqn">n</code> exist only if <code class="reqn">min(a, k, w) &gt; n</code>. 
The mean <code>m1</code> exists only if <code class="reqn">min(a, k, w) &gt; 1</code>. 
The standard deviation <code>sd</code> and the variance <code>u2</code> exist only
if <code class="reqn">min(a, k, w) &gt; 2</code>. 
The skewness <code>sk</code> exists only if <code class="reqn">min(a, k, w) &gt; 3</code>. 
The kurtosis <code>ku</code> and the excess of kurtosis <code>ke</code> exist only 
if <code class="reqn">min(a, k, w) &gt; 4</code>. 
</p>
<p><code>coefk</code> may take five different forms :
</p>

<ul>
<li><p><code>c(m, g, k) </code> of length 3 for distribution &quot;K1&quot;.
</p>
</li>
<li><p><code>c(m, g, a, w) </code> of length 4 for distribution &quot;K2&quot;.
</p>
</li>
<li><p><code>c(m, g, k, d) </code> of length 4 for distribution &quot;K3&quot;.
</p>
</li>
<li><p><code>c(m, g, k, e) </code> of length 4 for distribution &quot;K4&quot;.
</p>
</li>
<li><p><code>c(m, g, a, k, w, d, e) </code> of length 7 (sometimes referred as &quot;K7&quot;) 
provided by estimation/regression functions <code>paramkienerX</code>, 
<code>fitkienerX</code>, <code>regkienerLX</code> (via <code>"reg$coefk"</code>)
and conversion function <code>pk2pk</code>.        
</p>
</li></ul>

<p>Forms of length 3 and 7 are automatically recognized and do not require 
<code>model = "K1"</code> or <code>"K7"</code> which are ignored. 
Forms of length 4 require <code>model = "K2"</code>, <code>"K3"</code> or <code>"K4"</code>. 
Visit <code><a href="#topic+pk2pk">pk2pk</a></code> for details on the parameter conversion function 
used within <code>kmoments</code>.
</p>
<p><code>xmoments</code> and <code>kmoments</code> provide all-in-one vectors. 
</p>
<p><code>xmoments</code> is the traditional mean of squares, cubic and power 4 functions 
of non-central and central values of x, from which NA values have been removed. 
Therefore, length of x ignores NA values and may be different from the true length.
</p>
<p><code>kmoments</code> calls every specialized functions from order 1 to order 4 and 
uses the estimated parameters as inputs, not the initial dataset <code>x</code>.
As it does not know <em>a priori</em> the length of <code>x</code>, this latest can 
be provided separately via <code>lengthx = length(x)</code>, <code>lengthx = nrow(x)</code> 
and <code>lengthx = sapply(x, length)</code> if <code>x</code> is a vector, a matrix or a list. 
See the examples.
</p>


<h3>Value</h3>

<p>Vectors <code>kmoments</code> and <code>xmoments</code> have the following structure 
(with a third letter <code>x</code> added to <code>xmoments</code>):
</p>
<table role = "presentation">
<tr><td><code>ku</code></td>
<td>
<p>Kurtosis.</p>
</td></tr>
<tr><td><code>ke</code></td>
<td>
<p>Excess of kurtosis.</p>
</td></tr>
<tr><td><code>sk</code></td>
<td>
<p>Skewness.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Standard deviation. Square root of the variance <code>u2</code></p>
</td></tr>
<tr><td><code>m1</code></td>
<td>
<p>Mean.</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>Non-central moment of second order.</p>
</td></tr>
<tr><td><code>m3</code></td>
<td>
<p>Non-central moment of third order.</p>
</td></tr>
<tr><td><code>m4</code></td>
<td>
<p>Non-central moment of fourth order.</p>
</td></tr>
<tr><td><code>u1</code></td>
<td>
<p>Central moment of first order. Should be 0.</p>
</td></tr>
<tr><td><code>u2</code></td>
<td>
<p>Central moment of second order. Variance</p>
</td></tr>
<tr><td><code>u3</code></td>
<td>
<p>Central moment of third order.</p>
</td></tr>
<tr><td><code>u4</code></td>
<td>
<p>Central moment of fourth order.</p>
</td></tr>
<tr><td><code>k1</code></td>
<td>
<p>Cumulant of first order. Should be 0.</p>
</td></tr>
<tr><td><code>k2</code></td>
<td>
<p>Cumulant of second order.</p>
</td></tr>
<tr><td><code>k3</code></td>
<td>
<p>Cumulant of third order.</p>
</td></tr>
<tr><td><code>k4</code></td>
<td>
<p>Cumulant of fourth order.</p>
</td></tr>
<tr><td><code>lh</code></td>
<td>
<p>Length of x, from which NA values were removed.</p>
</td></tr>
<tr><td><code>......</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pk2pk">pk2pk</a></code>, <code><a href="#topic+paramkienerX">paramkienerX</a></code>, <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
kcmoment(2, c(-1, 1, 6, 9), model = "K2")
kcmoment(2, c(-1, 1, 7.2, -0.2/7.2), model = "K3")
kcmoment(2, c(-1, 1, 7.2, -0.2), model = "K4")
kcmoment(2, c(-1, 1, 6, 7.2, 9, -0.2/7.2, -0.2))
kvariance(c(-1, 1, 6, 9))
kmoments(c(-1, 1, 6, 9), dgts = 3)

## Example 2: "K2" and "K7" are preferred input formats for kmoments
## Moments fall at expected parameter values (=&gt; NA).
## apply and direct calculation (= transpose)
(mat4 &lt;- matrix(c(rep(0,4), rep(1,4), c(1.9,2.1,3.9,4.1), rep(5,4)),
                nrow = 4, byrow = TRUE, 
                dimnames = list(c("m","g","a","w"), paste0("b",1:4))))
round(mat7 &lt;- apply(mat4, 2, pk2pk), 2)
round(rbind(mat7, apply(mat7, 2, kmoments)[2:5,]), 2) 
round(cbind(t(mat7), kmoments(t(mat7), dgts = 2)[,2:5]), 2) 

## Example 3: Matrix, timeSeries, xts, zoo + apply 
matret    &lt;- 100*diff(log((EuStockMarkets)))
(matcoefk &lt;- apply(matret, 2, paramkienerX5, dgts = 2))
(matmomk  &lt;- apply(matcoefk, 2, kmoments, lengthx = nrow(matret), dgts = 2))
(matmomx  &lt;- apply(matret, 2, xmoments, dgts = 2))
rbind(matcoefk, matmomk[2:5,], matmomx[2:5,])

## Example 4: List + direct calculation = transpose
DS   &lt;- getDSdata() ; dimdim(DS) ; class(DS)
(pDS &lt;- paramkienerX5(DS, dimnames = FALSE))
(kDS &lt;- kmoments(pDS, lengthx = sapply(DS, length), dgts = 3))
(xDS &lt;- xmoments( DS, dgts = 3))
cbind(pDS, kDS[,2:5], xDS[,2:5])


</code></pre>

<hr>
<h2 id='laplacegaussnorm'>Laplace-Gauss Normal Distribution Object</h2><span id='topic+laplacegaussnorm'></span>

<h3>Description</h3>

<p>An object designed after regkienerLX to summarize the information related to 
a given dataset when the Laplace-Gauss normal distribution is applied on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacegaussnorm(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laplacegaussnorm_+3A_x">X</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed after regkienerLX to provide a 
similar framework.
</p>


<h3>Value</h3>

<p>A list with the following data.frame:
</p>

<ul>
<li><p> dfrXPn: data.frame. X = initial quantiles. Pn = estimated normal probabilites.
</p>
</li>
<li><p> dfrXLn: data.frame. X = initial quantiles. Ln = logit of estimated normal probabilites.
</p>
</li>
<li><p> dfrXDn: data.frame. X = initial quantiles. Dn = estimated normal density.
</p>
</li>
<li><p> coefn: numeric. The mean and the standard deviation of the dataset.
</p>
</li>
<li><p> dfrQnPn: data.frame. Qn = estimated quantiles of interest. Pn = probability. 
</p>
</li>
<li><p> dfrQnPn: data.frame. Qn = estimated quantiles of interest. Pn = logit of probability.
</p>
</li></ul>



<h3>See Also</h3>

<p>The regression function <code><a href="#topic+regkienerLX">regkienerLX</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
prices2returns &lt;- function(x) { 100*diff(log(x)) }
CAC  &lt;- prices2returns(as.numeric(EuStockMarkets[,3])) 
lgn  &lt;- laplacegaussnorm( CAC )
attributes(lgn)
head(lgn$dfrXPn)
head(lgn$dfrXLn)
head(lgn$dfrXDn)
lgn$coefn
lgn$dfrQnPn
lgn$dfrQnLn

</code></pre>

<hr>
<h2 id='loghp'>Inverse Power Hyperbolas and Inverse Power Hyperbolic Functions</h2><span id='topic+loghp'></span><span id='topic+acoshp'></span><span id='topic+asinhp'></span><span id='topic+atanhp'></span><span id='topic+asechp'></span><span id='topic+acosechp'></span><span id='topic+acotanhp'></span>

<h3>Description</h3>

<p>The inverse power hyperbolas and the inverse power hyperbolic functions: 
arc-cosine-hp, arc-sine-hp, arc-tangent-hp, 
arc-secant-hp, arc-cosecant-hp and arc-cotangent-hp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loghp(x, k = 1)

acoshp(x, k = 1)

asinhp(x, k = 1)

atanhp(x, k = 1)

asechp(x, k = 1)

acosechp(x, k = 1)

acotanhp(x, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loghp_+3A_x">x</code></td>
<td>
<p>a numeric value, vector or matrix.</p>
</td></tr>
<tr><td><code id="loghp_+3A_k">k</code></td>
<td>
<p>a numeric value, preferably strictly positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loghp</code> function is defined on (0, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn">  logshp(x, k) = 2 * k * sinh( log(x) / k) </code>
</p>

<p><code>acoshp</code> function is defined on [1, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> acoshp(x, k) = 2 * k * sinh( acosh(x) / k) </code>
</p>

<p><code>asinhp</code> function is defined on (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> asinhp(x, k) = 2 * k * sinh( asinh(x) / k) </code>
</p>

<p><code>atanhp</code> function is defined on (-1, +1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> atanhp(x, k) = 2 * k * sinh( atanh(x) / k) </code>
</p>

<p><code>asechp</code> function is defined on (0, +1] by: 
</p>
<p style="text-align: center;"><code class="reqn"> asechp(x, k) = 2 * k * sinh( acosh(1/x) / k) </code>
</p>

<p><code>acosechp</code> function is defined on (-Inf, 0) U (0, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> acosechp(x, k) = 2 * k * sinh( asinh(1/x) / k) </code>
</p>

<p><code>acotanhp</code> function is defined on (-Inf, -1) U (1, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> acotanhp(x, k) = 2 * k * sinh( atanh(1/x) / k) </code>
</p>

<p>If k is a vector of length &gt; 1, then the use of the function 
<code><a href="base.html#topic+outer">outer</a></code> is recommanded.
</p>


<h3>See Also</h3>

<p>The power hyperbolic functions <code><a href="#topic+exphp">exphp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1 (acoshp, asinhp, atanhp)
 loghp( c(ppoints(10), 1, 1/rev(ppoints(10))), k = 2)
acoshp( 1:10, k = 2)
asinhp( -5:5, k = 2)
atanhp( seq(-1, 1, by = 0.1), k = 2)
asechp( ppoints(20), k = 2)
acosechp( -5:5, k = 2)
acotanhp( c( -1/ppoints(10), 1/rev(ppoints(10))), k = 2)

x  &lt;- (-3:3)*3 
 loghp(exphp(x, k = 4), k = 4)
acoshp(coshp(x, k = 4), k = 4)
asinhp(sinhp(x, k = 4), k = 4)
atanhp(tanhp(x, k = 4), k = 4)


### Example 2 (loghp, acoshp, asinhp, atanhp)
k     &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(k) &lt;- k
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 4, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
op    &lt;- par(mfrow = c(2, 2), mgp = c(1.5, 0.8, 0), mar = c(3, 3, 2, 1))

xld     &lt;- 0.05
xl      &lt;- seq(0.05, 20, xld) ; names(xl) &lt;- xl
Tlcoshp &lt;- ts(cbind(outer(xl, k, loghp), "2*log(x)" = 2*log(xl)), 
              start = xl[1], deltat = xld)
plot(Tlcoshp, plot.type = "single", xlim = c(0,20), ylim = c(-5,15), 
     lty = olty, lwd = olwd, col = ocol, xaxs = "i", yaxs = "i", 
     xlab="", ylab = "", main = "loghp(x, k)" )
legend("bottomright", title = expression(kappa), legend = colnames(Tlcoshp), 
     inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

## acoshp(x, k)
xcd     &lt;- 0.5
xc      &lt;- seq(1, 20, xcd) ; names(xc) &lt;- xc
Tacoshp &lt;- ts(cbind(outer(xc, k, acoshp), "2*acosh(x)" = 2*acosh(xc)), 
              start = xc[1], deltat = xcd)
plot(Tacoshp, plot.type = "single", ylim = c(0,15), lty = olty, lwd = olwd, col = ocol,
        xaxs = "i", yaxs = "i", xlab = "", ylab = "", main = "acoshp(x, k)" )
legend("bottomright", title = expression(kappa), legend = colnames(Tacoshp), 
        inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

## asinhp(x, k)
xsd     &lt;- 0.5
xs      &lt;- seq(-10, 10, xsd) ; names(xs) &lt;- xs
Tasinhp &lt;- ts(cbind(outer(xs, k, asinhp), "2*asinh(x)" = 2*asinh(xs)), 
              start = xs[1], deltat = xsd)
plot(Tasinhp, plot.type = "single", ylim = c(-10,10), lty = olty, lwd = olwd, col = ocol,
        xaxs = "i", yaxs = "i", xlab = "", ylab = "", main = "asinhp(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Tasinhp), 
        inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

## atanhp(x, k)
xtd     &lt;- 0.01
xt      &lt;- seq(-1, 1, xtd) ; names(xt) &lt;- xt
Tatanhp &lt;- ts(cbind(outer(xt, k, atanhp), "2*atanh(x)" = 2*atanh(xt)), 
              start = xt[1], deltat = xtd)
plot(Tatanhp, plot.type = "single", ylim = c(-10,10), lty = olty, lwd = olwd, col = ocol,
        xaxs = "i", yaxs = "i", xlab = "", ylab = "", main = "atanhp(x, k)" )
legend("topleft", title = expression(kappa), legend = colnames(Tatanhp), 
        inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End Example 2


</code></pre>

<hr>
<h2 id='logishp'>The Power Hyperbola Logistic Distribution</h2><span id='topic+logishp'></span><span id='topic+dlogishp'></span><span id='topic+plogishp'></span><span id='topic+invkogit'></span><span id='topic+qlogishp'></span><span id='topic+kogit'></span><span id='topic+rlogishp'></span><span id='topic+dplogishp'></span><span id='topic+dqlogishp'></span><span id='topic+llogishp'></span><span id='topic+dllogishp'></span><span id='topic+qllogishp'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the power hyperbola logistic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogishp(x, k = 1, log = FALSE)

plogishp(q, k = 1)

invkogit(q, k = 1)

qlogishp(p, k = 1)

kogit(p, k = 1)

rlogishp(n, k = 1)

dplogishp(p, k = 1, log = FALSE)

dqlogishp(p, k = 1, log = FALSE)

llogishp(x, k = 1)

dllogishp(lp, k = 1, log = FALSE)

qllogishp(lp, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logishp_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="logishp_+3A_k">k</code></td>
<td>
<p>numeric. The tail parameter, preferably strictly positive.
Can be a vector (see details).</p>
</td></tr>
<tr><td><code id="logishp_+3A_log">log</code></td>
<td>
<p>boolean.</p>
</td></tr>
<tr><td><code id="logishp_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="logishp_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="logishp_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is 
taken to be the number required.</p>
</td></tr>
<tr><td><code id="logishp_+3A_lp">lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dlogishp</code> function (log is available) is defined for 
x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlogishp(x, k) = 
             dkashp\_dx(x, k) * plogishp(x, k) * plogishp(-x, k) </code>
</p>

<p><code>invkogit=plogishp</code> functions are defined for q in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> invkogit(q, k) = plogishp(q, k) = 1/(1 + exp(- kashp(q, k))) </code>
</p>

<p><code>kogit=qlogishp</code> functions are defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> kogit(p, k) = qlogishp(p, k) = 2 * k * sinh(logit(p) / k) </code>
</p>

<p><code>rlogishp</code> function generates <code>n</code> random values.
</p>
<p>In addition to the classical formats, the prefixes dp, dq, l, dl, ql 
are also provided:
</p>
<p><code>dplogishp</code> function (log is available) is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dplogishp(p, k = 1) = p * (1 - p) / 2 / cosh( logit(p)/k ) </code>
</p>

<p><code>dqlogishp</code> function (log is available) is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqlogishp(p, k = 1) = 2 / p / (1 - p) * cosh( logit(p)/k ) </code>
</p>

<p><code>llogishp</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> llogishp(x, k) = kashp(x, k) </code>
</p>

<p><code>dllogishp</code> function is defined for lp = logit(p) in (-Inf, +Inf) by : 
</p>
<p style="text-align: center;"><code class="reqn"> dllogishp(lp, k) = p * (1 - p) / 2 / cosh( lp/k ) </code>
</p>

<p><code>qllogishp</code> function is defined for lp = logit(p) in (-Inf, +Inf) by : 
</p>
<p style="text-align: center;"><code class="reqn"> qllogishp(lp, k) = 2 * k * sinh(lp / k) </code>
</p>

<p>If k is a vector, then the use of the function <code><a href="base.html#topic+outer">outer</a></code> 
is recommanded.
</p>


<h3>See Also</h3>

<p>Kiener distribution K1 <code><a href="#topic+kiener1">kiener1</a></code> which has 
location (<code>m</code>) and scale (<code>g</code>) parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)

### Example 1
pp &lt;- c(ppoints(11, a = 1), NA, NaN) ; pp
plogishp(-5:5, k = 4)
dlogishp(-5:5, k = 4)
qlogishp(pp, k = 4)
outer(-5:5, 1:6, plogishp)
outer(-5:5, 1:6, dlogishp)
outer(runif(20), 1:6, qlogishp)

### Example 2
x     &lt;- seq(-15, 15, length.out = 101)
k     &lt;- c(0.6, 1, 1.5, 2, 3.2, 10) ; names(k) &lt;- k ; k
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 4, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
op    &lt;- par(mfrow = c(2,2), mgp = c(1.5,0.8,0), mar = c(3,3,2,1))

plot(x, plogis(x, scale = 2), type = "b", lwd = 2, ylim = c(0, 1),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", main = "plogishp(x, k)")
for (i in 1:length(k)) lines(x, plogishp(x, k = k[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(kappa), legend = c(k, "plogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(x, dlogis(x, scale = 2), type = "b", lwd = 2, xaxs = "i", 
     yaxs = "i", xlab = "", ylab = "", main = "dlogishp(x, k)")
for (i in 1:length(k)) lines(x, dlogishp(x, k = k[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )

plot(x, x/2, type = "b", lwd = 2, ylim = c(-7.5, 7.5), xaxs = "i", 
     yaxs = "i", xlab = "", ylab = "", main = "logit(logishp(h, k))")
for (i in 1:length(k)) lines(x, llogishp(x, k = k[i]),  
          lty = olty[i], lwd = olwd[i], col = ocol[i] )

plot(x, log(dlogis(x, scale = 2)), lwd = 2, type = "b", xaxs = "i", 
     yaxs = "i", xlab = "", ylab = "", main = "log(dlogishp(x, k))") 
for (i in 1:length(k)) lines(x, dlogishp(x, k = k[i], log = TRUE),  
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
### End example 2

### Example 3
p &lt;- ppoints(199, a=0)
plot(p, qlogis(p, scale = 2), type = "o", lwd = 2, ylim = c(-15, 15),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qlogishp(p, k)")
for (i in 1:length(k)) lines(p, qlogishp(p, k = k[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(kappa), legend = c(k, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(p, 2/p/(1-p), type = "o", lwd = 2, xlim = c(0, 1), ylim = c(0, 100),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dqlogishp(p, k)")
for (i in 1:length(k)) lines(p, dqlogishp(p, k = k[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("top", title = expression(kappa), legend = c(k, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p*(1-p)/2, type = "o", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 0.14), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qlogishp, dplogishp(p, k)")
for (i in 1:length(k)) lines(qlogishp(p, k = k[i]), dplogishp(p, k = k[i]),
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(kappa), legend = c(k, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 3

</code></pre>

<hr>
<h2 id='logit'>Logit and Invlogit Functions</h2><span id='topic+logit'></span><span id='topic+invlogit'></span><span id='topic+ltmlogis'></span><span id='topic+rtmlogis'></span><span id='topic+eslogis'></span>

<h3>Description</h3>

<p>The logit and invlogit functions, widely used in this package, are wrappers  
of <code><a href="stats.html#topic+qlogis">qlogis</a></code> and <code><a href="stats.html#topic+plogis">plogis</a></code> functions. 
</p>
<p>Functions <code>eslogis</code> is the expected shortfall of the logistic function 
(times a factor 2). 
When <code>p&lt;=0.5</code>, it is equivalent (times -1) to the left tail mean <code>ltmlogis</code>. 
When <code>p&gt;0.5</code>, it is equivalent to the right tail mean <code>rtmlogis</code>. 
<code>ltmlogis</code> and <code>rtmlogis</code> are used to calculate the <code>h</code> parameter 
in <code><a href="#topic+hkiener1">hkiener1</a></code>, <code>hkiener2</code>, <code>hkiener3</code>, <code>hkiener4</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)

invlogit(x)

ltmlogis(p, m = 0, g = 1, lower.tail = TRUE, log.p = FALSE)

rtmlogis(p, m = 0, g = 1, lower.tail = TRUE, log.p = FALSE)

eslogis(p, m = 0, g = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>numeric. one value or a vector between 0 and 1.</p>
</td></tr>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>numeric. one value or a vector of numerics.</p>
</td></tr>
<tr><td><code id="logit_+3A_m">m</code></td>
<td>
<p>numeric. a central parameter (also used in model K1, K2, K3 and K4).</p>
</td></tr>
<tr><td><code id="logit_+3A_g">g</code></td>
<td>
<p>numeric. a scale parameter (also used in model K1, K2, K3 and K4).</p>
</td></tr>
<tr><td><code id="logit_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td></tr>
<tr><td><code id="logit_+3A_log.p">log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>logit</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> logit(p) = log( p/(1-p) ) </code>
</p>

<p><code>invlogit</code> function is defined for x in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> invlogit(x) = exp(x)/(1+exp(x)) = plogis(x) </code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>    
logit( c(ppoints(11, a = 1), NA, NaN) )
invlogit( c(-Inf, -10:10, +Inf, NA, NaN) )

</code></pre>

<hr>
<h2 id='mData'>Datasets dfData, mData, tData, xData, zData, extractData : mData</h2><span id='topic+mData'></span>

<h3>Description</h3>

<p>A list of datasets in data.frame, matrix, timeSeries, xts and zoo formats. 
This is the matrix format. 
Visit <code><a href="#topic+extractData">extractData</a></code> for more information.
</p>

<hr>
<h2 id='pk2pk'>Global Conversion Function Between Kiener Distribution Parameters</h2><span id='topic+pk2pk'></span>

<h3>Description</h3>

<p>A conversion function between Kiener distribution parameters 
<code>K1(m, g, k)</code>, <code>K2(m, g, a, w)</code>,
<code>K3(m, g, k, d)</code> and <code>K4(m, g, k, e)</code> to and from
<code>coefk = c(m, g, a, k, w, d, e)</code> extracted from <code><a href="#topic+regkienerLX">regkienerLX</a></code> 
and <code><a href="#topic+paramkienerX">paramkienerX</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk2pk(coefk, model = "K2", to = "K7", dgts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk2pk_+3A_coefk">coefk</code></td>
<td>
<p>vectors of numeric of length 3, 4 or 7.</p>
</td></tr>
<tr><td><code id="pk2pk_+3A_model">model</code></td>
<td>
<p>character. Either &quot;K1&quot;, &quot;K2&quot;, &quot;K3&quot;, &quot;K4&quot;, &quot;K7&quot;.</p>
</td></tr>
<tr><td><code id="pk2pk_+3A_to">to</code></td>
<td>
<p>character. Either &quot;K1&quot;, &quot;K2&quot;, &quot;K3&quot;, &quot;K4&quot;, &quot;K7&quot;.</p>
</td></tr>
<tr><td><code id="pk2pk_+3A_dgts">dgts</code></td>
<td>
<p>integer. The rounding applied to the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See also <code><a href="#topic+aw2k">aw2k</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution,. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p><code>pk2pk()</code> performs the conversion between the various representation, from and to:
</p>

<ul>
<li><p> &quot;K1&quot; : <code>kiener1(m, g, k)</code>    
</p>
</li>
<li><p> &quot;K2&quot; : <code>kiener2(m, g, a, w)</code> 
</p>
</li>
<li><p> &quot;K3&quot; : <code>kiener3(m, g, k, d)</code> 
</p>
</li>
<li><p> &quot;K4&quot; : <code>kiener4(m, g, k, e)</code> 
</p>
</li>
<li><p> &quot;K7&quot; : <code>c(m, g, a, k, w, d, e)</code> 
</p>
</li></ul>

<p><code>coefk</code> can take any of the above form. When length(coefk) is 4, 
<code>model = "K2", "K3" or "K4"</code> is required to differentiate the three models.
When length(coefk) is 3 or 7, recognition is automatic and  
<code>model = "K1" or "K7"</code> is ignored. The vector is assumed to be correct 
and there is no check of the consistency between the 
parameters <code>a, k, w, d</code> and <code>e</code>.
</p>
<p>The output may be any of the above forms. Default is <code>"K7" = c(m, g, a, k, w, d, e)</code> 
which is <code>coefk</code> provided by the regression function <code><a href="#topic+regkienerLX">regkienerLX</a></code>
or the parameter estimation function <code><a href="#topic+paramkienerX">paramkienerX</a></code>. It is widely in many plots.
</p>
<p>An integer rounding parameter is provided trough <code>dgts</code>. Default is no rounding.
</p>


<h3>See Also</h3>

<p>Local conversion functions <code><a href="#topic+aw2k">aw2k</a></code>, 
Kiener distributions K1, K2, K3 and K4: <code><a href="#topic+kiener1">kiener1</a></code>, 
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
c2 &lt;- c(1, 2, 3, 5)
pk2pk(c2, model = "K2", to = "K1") # loose the asymmetry.
pk2pk(c2, model = "K2", to = "K2")
pk2pk(c2, model = "K2", to = "K3")
pk2pk(c2, model = "K2", to = "K4")
pk2pk(c2, model = "K2", to = "K4")
(c7 &lt;- pk2pk(c2, model = "K2", to = "K7", dgts = 3))
pk2pk(c7, model = "K7", to = "K2")

## Example 2 ("K2" to "K7")
(mat4 &lt;- matrix( c(rep(0,9), rep(1,9), seq(0.5,4.5,0.5), seq(1,5,0.5)), 
         nrow = 4, byrow = TRUE, dimnames = list(c("m","g","a","w"), paste0("b",1:9))))
(mat7 &lt;- round(apply(mat4, 2, pk2pk), 3))


</code></pre>

<hr>
<h2 id='pprobs0'>Several Vectors of Probabilities</h2><span id='topic+pprobs0'></span><span id='topic+pprobs1'></span><span id='topic+pprobs2'></span><span id='topic+pprobs3'></span><span id='topic+pprobs4'></span><span id='topic+pprobs5'></span><span id='topic+pprobs6'></span><span id='topic+pprobs7'></span><span id='topic+pprobs8'></span><span id='topic+pprobs9'></span>

<h3>Description</h3>

<p>Several vectors of probabilities used in FatTailsR. 
Remark: pprobs5 &lt;- sort(c(pprobs2, pprobs3, pprobs4)).
</p>
<p>pprobs0 &lt;- c(0.01, 0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95, 0.99)
</p>
<p>pprobs1 &lt;- c(0.01, 0.05, 0.95, 0.99)
</p>
<p>pprobs2 &lt;- c(0.01, 0.025, 0.05, 0.95, 0.975, 0.99)
</p>
<p>pprobs3 &lt;- c(0.001, 0.0025, 0.005, 0.995, 0.9975, 0.999)
</p>
<p>pprobs4 &lt;- c(0.0001, 0.00025, 0.0005, 0.9995, 0.99975, 0.9999)
</p>
<p>pprobs5 &lt;- c(0.0001, 0.00025, 0.0005, 0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
0.95, 0.975, 0.99, 0.995, 0.9975, 0.999, 0.9995, 0.99975, 0.9999)
</p>
<p>pprobs6 &lt;- c(0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.50, 
0.95, 0.99, 0.995, 0.999, 0.9995, 0.9999) 
</p>
<p>pprobs7 &lt;- c(0.01, 0.025, 0.05, 
0.10, 0.17, 0.25, 0.33, 0.41, 0.50, 0.59, 0.67, 0.75, 0.83, 0.90, 
0.95, 0.975, 0.99) 
</p>
<p>pprobs8 &lt;- c(0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
0.10, 0.17, 0.25, 0.33, 0.41, 0.50, 0.59, 0.67, 0.75, 0.83, 0.90, 
0.95, 0.975, 0.99, 0.995, 0.9975, 0.999) 
</p>
<p>pprobs9 &lt;- c(0.0001, 0.00025, 0.0005, 0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
0.10, 0.17, 0.25, 0.33, 0.41, 0.50, 0.59, 0.67, 0.75, 0.83, 0.90, 
0.95, 0.975, 0.99, 0.995, 0.9975, 0.999, 0.9995, 0.99975, 0.9999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pprobs0

pprobs1

pprobs2

pprobs3

pprobs4

pprobs5

pprobs6

pprobs7

pprobs8

pprobs9
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 9.
</p>
<p>An object of class <code>numeric</code> of length 4.
</p>
<p>An object of class <code>numeric</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 6.
</p>
<p>An object of class <code>numeric</code> of length 18.
</p>
<p>An object of class <code>numeric</code> of length 13.
</p>
<p>An object of class <code>numeric</code> of length 17.
</p>
<p>An object of class <code>numeric</code> of length 23.
</p>
<p>An object of class <code>numeric</code> of length 29.
</p>


<h3>See Also</h3>

<p>The conversion function <code><a href="#topic+getnamesk">getnamesk</a></code>
</p>

<hr>
<h2 id='regkienerLX'>Regression Function for Kiener Distributions</h2><span id='topic+regkienerLX'></span>

<h3>Description</h3>

<p>One function to estimate the parameters of Kiener distributions K1, K2,  
K3 and K4 and display the results in a list with many data.frame 
ready to use for plotting. This function performs an unweighted nonlinear
regression of the logit of the empirical probabilities logit(p) on 
the quantiles X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regkienerLX(X, model = "K4", pdgts = c(3, 3, 1, 1, 1, 3, 2, 4, 4, 2, 2),
  maxk = 10, mink = 0.2, app = 0, probak = pprobs2, dgts = NULL,
  exfitk = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regkienerLX_+3A_x">X</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_model">model</code></td>
<td>
<p>the model used for the regression: &quot;K1&quot;, &quot;K2&quot;, &quot;K3&quot;, &quot;K4&quot;.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_pdgts">pdgts</code></td>
<td>
<p>vector of length 11. Control the rounding of output parameters.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_maxk">maxk</code></td>
<td>
<p>numeric. The maximum value of tail parameter <code>k</code>.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_mink">mink</code></td>
<td>
<p>numeric. The minimum value of tail parameter <code>k</code>.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_app">app</code></td>
<td>
<p>numeric. The parameter &quot;<code>a</code>&quot; in the function <code>ppoints</code>.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_probak">probak</code></td>
<td>
<p>vector of probabilities used in output regk$fitk.
For instance <code><a href="#topic+pprobs0">pprobs0</a></code>.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_dgts">dgts</code></td>
<td>
<p>rounding parameter applied globally to output regk$fitk.</p>
</td></tr>
<tr><td><code id="regkienerLX_+3A_exfitk">exfitk</code></td>
<td>
<p>character. A vector of parameter names to subset regk$fitk. 
For instance <code><a href="#topic+exfit0">exfit0</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to estimate the parameters of Kiener distributions
for a given dataset. It encapsulates the four distributions described in
this package. 
&quot;K1&quot; uses model <code>lqkiener1</code>, &quot;K2&quot; uses model <code>lqkiener2</code>, 
&quot;K3&quot; uses model <code>lqkiener3</code> and &quot;K4&quot; uses model <code>lqkiener4</code>. 
</p>
<p>A typical input is a numeric vector that describes the returns of a stock. 
Conversion from a (possible) time series format to a sorted numeric vector 
is done automatically and without any check of the initial format. 
There is also no check of missing values, <code>Na</code>, <code>NaN</code>, 
<code>-Inf</code>, <code>+Inf</code>. 
Empirical probabilities of each point in the sorted dataset is calculated 
with the function <code><a href="stats.html#topic+ppoints">ppoints</a></code>. The parameter <code>app</code> 
corresponds to the parameter <code>a</code> in <code>ppoints</code> but has been  
limited to the range (0, 0.5). Default value is 0 as large datasets are 
very common in finance. 
</p>
<p>A nonlinear regression is performed with <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> 
from the logit of the probabilities <code>logit(p)</code> over the quantiles X 
with one of the functions <code>lqkiener1234</code>. 
These functions have been selected as they
have an explicit form in the four types (this is unfortunately not the case 
for <code>dkiener234</code>) and return satisfactory results with ordinary least 
squares. The median is calculated before the regression and is injected 
as a mandatory value in the regression function. 
</p>
<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code><a href="#topic+aw2k">aw2k</a></code> and <code><a href="#topic+pk2pk">pk2pk</a></code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li></ul>

<p>Where:
</p>

<ul>
<li><p>c(m, g, k) of length 3 for distribution &quot;K1&quot;.
</p>
</li>
<li><p>c(m, g, a, w) of length 4 for distribution &quot;K2&quot;.
</p>
</li>
<li><p>c(m, g, k, d) of length 4 for distribution &quot;K3&quot;.
</p>
</li>
<li><p>c(m, g, k, e) of length 4 for distribution &quot;K4&quot;.
</p>
</li>
<li><p>c(m, g, a, k, w, d, e) of length 7 extracted from object of class 
<code>clregk</code> like <code>regkienerLX</code> (typically <code>"reg$coefk"</code>).
</p>
</li></ul>

<p>Model <code>"K1"</code> return results with 1+2=3 parameters and describes a 
(assumed) symmetric distribution. Parameters <code>d</code> and <code>e</code> are set 
to 0. Models <code>"K2"</code>, <code>"K3"</code> and <code>"K4"</code> describe asymmetric 
distributions. They return results with 1+3=4 parameters.
Model &quot;K2&quot; has a very clear parameter definition but unfortunately 
parameters <code>a</code> and <code>w</code> are highly correlated. 
Model <code>"K3"</code> has the least correlated parameters but the meaning of 
the distortion parameter <code>d</code>, usually of order 1e-3, is not simple. 
</p>
<p>Model <code>"K4"</code> exhibits a reasonable correlation between each parameter
and should be the preferred intermediate model between &quot;K1&quot; and &quot;K2&quot; models.
The eccentricity parameter <code>e</code> is well defined and easy to understand:
<code class="reqn">e=(a-w)/(a+w)</code>, <code class="reqn">a=k/(1-e)</code> and <code class="reqn">w=k/(1+e)</code>. It varies between
<code>-1</code> and <code>+1</code> and can be understood as a percentage (if times 100)
of eccentricty. <code>e = -1</code> corresponds to <code>w = infinity</code>,  
<code>e = +1</code> corresponds to <code>a = infinity</code> and the model becomes a single
log-logistic funtion with a right / left stopping point and a left / right tail.
</p>
<p>Tail parameter lower and upper values are controlled by <code>maxk</code> and 
<code>mink</code>. An upper value <code class="reqn">maxk = 10</code> is appropriate for datasets
of low and medium size, less than 50.000 points. For larger datasets, the
upper limit can be extended up to <code class="reqn">maxk = 20</code>. Such a limit returns 
results which are very closed to the logistic distribution, an alternate 
distribution which could be more appropriate. The lower limit <code>mink</code> 
is intended to avoid the value <code class="reqn">k=0</code>. Remind 
that value <code class="reqn">k &lt; 2</code> describes distribution with no stable variance and 
<code class="reqn">k &lt; 1</code> describes distribution with no stable mean.
</p>
<p>The output is an object in a flat format of class <code>clregk</code>. It can be 
listed with the function <code><a href="base.html#topic+attributes">attributes</a></code>. 
</p>

<ul>
<li><p> First are the data.frames with the initial data and the estimated results. 
</p>
</li>
<li><p> Second is the result of the regression <code>regk0</code> given by 
<code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> from which a few information 
have been extracted and listed here. 
</p>
</li>
<li><p> Third are the regression parameters (without the median) in plain format  
(no rounding), the variance-covariance matrix, the variance-covariance 
matrix times 1e+6 and the correlation matrix in a rounded format.
Note that <code>regk0</code>, <code>coefk0</code>, <code>coefk0tt</code>, <code>vcovk0</code>, 
<code>mcork0</code> have a polymorphic format and changing parameters that 
depend from the selected model: &quot;K1&quot;, &quot;K2&quot;, &quot;K3&quot;, &quot;K4&quot;. They should be  
used with care in subsequent calculations.  
</p>
</li>
<li><p> Fourth are the distribution parameters tailored to every model &quot;K1&quot;, &quot;K2&quot;, 
&quot;K3&quot;, &quot;K4&quot; plus estimated quantiles at levels: 
c(0.001, 0.005, 0.01, 0.05, 0.5, 0.95, 0.99, 0.995, 0.999). 
They are intended to subsequent calculations. 
</p>
</li>
<li> 
<p>Fifth are the same parameters presented in a more readable format thanks 
to the vector <code>pdgts</code> which controls the rounding of the parameters in
the following order: 
</p>
</li>
<li> <p><code>pdgts = c("m","g","a","k","w","d","e","vcovk0","vcovk0m","mcork0","quantr")</code>. 
</p>
</li>
<li><p> Sixth are some probabilities and the corresponding estimated quantiles 
and estimated Expected Shortfall stored in a data.frame format. 
</p>
</li>
<li><p> Last is <code>fitk</code> which returns all parameters in the same format 
than <code><a href="#topic+fitkienerX">fitkienerX</a></code>, eventually subsetted by <code>exfitk</code>. 
IMPORTANT : if you need to subset <code>fitk</code>, always subset it by parameter names 
and never subset it by rank number as new items may be added in the future. 
Use for instance <code>exfitk =</code> <code><a href="#topic+exfit0">exfit0</a></code>, ..., <code><a href="#topic+exfit7">exfit7</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dfrXP</code></td>
<td>
<p>data.frame. X = initial quantiles. P = empirical probabilities.</p>
</td></tr>
<tr><td><code>dfrXL</code></td>
<td>
<p>data.frame. X = initial quantiles. L = logit of probabilities.</p>
</td></tr>
<tr><td><code>dfrXR</code></td>
<td>
<p>data.frame. X = initial quantiles. R = residuals after regression.</p>
</td></tr>
<tr><td><code>dfrEP</code></td>
<td>
<p>data.frame. E = estimated quantiles. P = probabilities.</p>
</td></tr>
<tr><td><code>dfrEL</code></td>
<td>
<p>data.frame. E = estimated quantiles. L = logit of probabilities.</p>
</td></tr>
<tr><td><code>dfrED</code></td>
<td>
<p>data.frame. E = estimated quantiles. 
D = estimated density (from probabilities).</p>
</td></tr>
<tr><td><code>regk0</code></td>
<td>
<p>object of class <code>nls</code> extracted from 
the regression function <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code>.</p>
</td></tr>
<tr><td><code>coefk0</code></td>
<td>
<p>the regression parameters in plain format. 
The median is out of the regression.</p>
</td></tr> 
<tr><td><code>vcovk0</code></td>
<td>
<p>rounded variance-covariance matrix.</p>
</td></tr> 
<tr><td><code>vcovk0m</code></td>
<td>
<p>rounded 1e+6 times variance-covariance matrix.</p>
</td></tr> 
<tr><td><code>mcork0</code></td>
<td>
<p>rounded correlation matrix.</p>
</td></tr> 
<tr><td><code>coefk</code></td>
<td>
<p>all parameters in plain format.</p>
</td></tr> 
<tr><td><code>coefk1</code></td>
<td>
<p>parameters for model &quot;K1&quot;.</p>
</td></tr> 
<tr><td><code>coefk2</code></td>
<td>
<p>parameters for model &quot;K2&quot;.</p>
</td></tr> 
<tr><td><code>coefk3</code></td>
<td>
<p>parameters for model &quot;K3&quot;.</p>
</td></tr> 
<tr><td><code>coefk4</code></td>
<td>
<p>parameters for model &quot;K4&quot;.</p>
</td></tr> 
<tr><td><code>quantk</code></td>
<td>
<p>quantiles of interest.</p>
</td></tr> 
<tr><td><code>coefr</code></td>
<td>
<p>all parameters in a rounded format.</p>
</td></tr> 
<tr><td><code>coefr1</code></td>
<td>
<p>rounded parameters for model &quot;K1&quot;.</p>
</td></tr> 
<tr><td><code>coefr2</code></td>
<td>
<p>rounded parameters for model &quot;K2&quot;.</p>
</td></tr> 
<tr><td><code>coefr3</code></td>
<td>
<p>rounded parameters for model &quot;K3&quot;.</p>
</td></tr> 
<tr><td><code>coefr4</code></td>
<td>
<p>rounded parameters for model &quot;K4&quot;.</p>
</td></tr> 
<tr><td><code>quantr</code></td>
<td>
<p>quantiles of interest in a rounded format.</p>
</td></tr> 
<tr><td><code>dfrQkPk</code></td>
<td>
<p>data.frame. Qk = Estimated quantiles of interest. 
Pk = probabilities.</p>
</td></tr> 
<tr><td><code>dfrQkLk</code></td>
<td>
<p>data.frame. Qk = Estimated quantiles of interest. 
Lk = Logit of probabilities.</p>
</td></tr> 
<tr><td><code>dfrESkPk</code></td>
<td>
<p>data.frame. ESk = Estimated Expected Shortfall. 
Pk = probabilities.</p>
</td></tr> 
<tr><td><code>dfrESkLk</code></td>
<td>
<p>data.frame. ESk = Estimated Expected Shortfall. 
Lk = Logit of probabilities.</p>
</td></tr> 
<tr><td><code>fitk</code></td>
<td>
<p>Parameters, quantiles, moments, VaR, ES and other parameters (not rounded). 
Length of <code>fitk</code> depends on the choice applied to probak. 
IMPORTANT : if you need to subset <code>fitk</code>, always subset it by parameter names 
and never subset it by rank number as new items may be added in the future. 
Use for instance <code><a href="#topic+exfit0">exfit0</a></code>, ..., <code><a href="#topic+exfit7">exfit7</a></code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code>, <code><a href="#topic+laplacegaussnorm">laplacegaussnorm</a></code>, 
Kiener distributions K1, K2, K3 and K4: <code><a href="#topic+kiener1">kiener1</a></code>
<code><a href="#topic+kiener2">kiener2</a></code>, <code><a href="#topic+kiener3">kiener3</a></code>, <code><a href="#topic+kiener4">kiener4</a></code>.
Other estimation function: <code><a href="#topic+fitkienerX">fitkienerX</a></code> and its derivatives.
<code>fitk</code> subsetting: <code><a href="#topic+exfit0">exfit0</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    

require(graphics)
require(minpack.lm)
require(timeSeries)

### Load the datasets and select one number (1-16)
DS     &lt;- getDSdata()
j      &lt;- 5


### and run this block
X      &lt;- DS[[j]]
nameX  &lt;- names(DS)[j]
reg    &lt;- regkienerLX(X)

## Plotting
lleg   &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", 
           "logit(0.95)   = 2.9", "logit(0.50)   = 0", 
           "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
pleg   &lt;- c( paste("m =",  reg$coefr4[1]), paste("g  =", reg$coefr4[2]), 
             paste("k  =", reg$coefr4[3]), paste("e  =", reg$coefr4[4]) )
op     &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))
plot(X, type="l", main = nameX)
plot(reg$dfrXL, main = nameX, yaxt = "n")
axis(2, las=1, at=c(-9.2, -6.9, -4.6, -2.9, 0, 2.9, 4.6, 6.9, 9.2))
abline(h = c(-4.6, 4.6), lty = 4)
abline(v = c(reg$quantk[5], reg$quantk[9]), lty = 4)
legend("topleft", legend = lleg, cex = 0.7, inset = 0.02, bg = "#FFFFFF")
lines(reg$dfrEL, col = 2, lwd = 2)
points(reg$dfrQkLk, pch = 3, col = 2, lwd = 2, cex = 1.5)
plot(reg$dfrXP, main = nameX)
legend("topleft", legend = pleg, cex = 0.9, inset = 0.02 )
lines(reg$dfrEP, col = 2, lwd = 2)
plot(density(X), main = nameX)
lines(reg$dfrED, col = 2, lwd = 2)
round(cbind("k" = kmoments(reg$coefk, lengthx = nrow(reg$dfrXL)), "X" = xmoments(X)), 2)

## Attributes
attributes(reg)
head(reg$dfrXP)
head(reg$dfrXL)
head(reg$dfrXR)
head(reg$dfrEP)
head(reg$dfrEL)
head(reg$dfrED)
reg$regk0
reg$coefk0
reg$vcovk0
reg$vcovk0m
reg$mcork0
reg$coefk
reg$coefk1
reg$coefk2
reg$coefk3
reg$coefk4
reg$quantk
reg$coefr
reg$coefr1
reg$coefr2
reg$coefr3
reg$coefr4
reg$quantr
reg$dfrQkPk
reg$dfrQkLk
reg$dfrESkPk
reg$dfrESkLk
reg$fitk

## subset fitk
names(reg$fitk)
reg$fitk[exfit6]
reg$fitk[c(exfit1, exfit4)]
### End block

</code></pre>

<hr>
<h2 id='roundcoefk'>Round Coefk</h2><span id='topic+roundcoefk'></span>

<h3>Description</h3>

<p>Round coefk parameters in a standard manner or in a special manner, 
the latest being useful to display nice matrix or data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundcoefk(coefk, dgts = NULL, parnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roundcoefk_+3A_coefk">coefk</code></td>
<td>
<p>numeric, matrix or data.frame representing
parameters <code>c(m,g,a,k,w,d,e)</code>.</p>
</td></tr>
<tr><td><code id="roundcoefk_+3A_dgts">dgts</code></td>
<td>
<p>integer. The number of rounded digits.</p>
</td></tr>
<tr><td><code id="roundcoefk_+3A_parnames">parnames</code></td>
<td>
<p>boolean. Output displayed with or without parameter names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>dgts</code> between 1 and 9, rounding is done in the standard way
and all parameters are rounded at the same number of digits.
</p>
<p>For <code>dgts</code> between 10 and 27, rounding of parameters 
<code>c(m,g,a,k,w,d,e)</code> is done in the following way: 
</p>

<ul>
<li><p> dgts = 10 : c(0, 0, 1, 1, 1, 3, 2)
</p>
</li>
<li><p> dgts = 11 : c(1, 1, 1, 1, 1, 3, 2)
</p>
</li>
<li><p> dgts = 12 : c(2, 2, 1, 1, 1, 3, 2)
</p>
</li>
<li><p> dgts = 13 : c(3, 3, 1, 1, 1, 3, 2)
</p>
</li>
<li><p> dgts = 14 : c(4, 4, 1, 1, 1, 3, 2)
</p>
</li>
<li><p> dgts = 15 : c(5, 5, 1, 1, 1, 3, 2)
</p>
</li>
<li><p> dgts = 16 : c(0, 0, 2, 2, 2, 3, 2)
</p>
</li>
<li><p> dgts = 17 : c(1, 1, 2, 2, 2, 3, 2)
</p>
</li>
<li><p> dgts = 18 : c(2, 2, 2, 2, 2, 3, 2)
</p>
</li>
<li><p> dgts = 19 : c(3, 3, 2, 2, 2, 3, 2)
</p>
</li>
<li><p> dgts = 20 : c(4, 4, 2, 2, 2, 3, 2)
</p>
</li>
<li><p> dgts = 21 : c(5, 5, 2, 2, 2, 3, 2)
</p>
</li>
<li><p> dgts = 22 : c(0, 0, 3, 3, 3, 4, 3)
</p>
</li>
<li><p> dgts = 23 : c(1, 1, 3, 3, 3, 4, 3)
</p>
</li>
<li><p> dgts = 24 : c(2, 2, 3, 3, 3, 4, 3)
</p>
</li>
<li><p> dgts = 25 : c(3, 3, 3, 3, 3, 4, 3)
</p>
</li>
<li><p> dgts = 26 : c(4, 4, 3, 3, 3, 4, 3)
</p>
</li>
<li><p> dgts = 27 : c(5, 5, 3, 3, 3, 4, 3)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>    

mat   &lt;- matrix(runif(35), ncol=7) 
coefk &lt;- mat[1,]

roundcoefk(coefk, dgts = 2, parnames = FALSE)
roundcoefk(coefk, dgts = 15)
roundcoefk(mat, dgts = 15)


</code></pre>

<hr>
<h2 id='tData'>Datasets dfData, mData, tData, xData, zData, extractData : tData</h2><span id='topic+tData'></span>

<h3>Description</h3>

<p>A list of datasets in data.frame, matrix, timeSeries, xts and zoo formats. 
This is the timeSeries format. 
Visit <code><a href="#topic+extractData">extractData</a></code> for more information.
</p>

<hr>
<h2 id='xData'>Datasets dfData, mData, tData, xData, zData, extractData : xData</h2><span id='topic+xData'></span>

<h3>Description</h3>

<p>A list of datasets in data.frame, matrix, timeSeries, xts and zoo formats. 
This is the xts format. 
Visit <code><a href="#topic+extractData">extractData</a></code> for more information.
</p>

<hr>
<h2 id='zData'>Datasets dfData, mData, tData, xData, zData, extractData : zData</h2><span id='topic+zData'></span>

<h3>Description</h3>

<p>A list of datasets in data.frame, matrix, timeSeries, xts and zoo formats. 
This is the zoo format. 
Visit <code><a href="#topic+extractData">extractData</a></code> for more information.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
