<!DOCTYPE html><html><head><title>Help for package IndTestPP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IndTestPP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BinPer'><p>Percentage of concordant intervals</p></a></li>
<li><a href='#ComplPos'><p>Changes  format of the vector of occurrence times in a point process</p></a></li>
<li><a href='#CondTest'><p>Conditional test of independence between two Poisson process</p></a></li>
<li><a href='#CountingCor'><p>Correlation between the  counting variables in two point processes</p></a></li>
<li><a href='#CPSPpoints'><p>Identifying the  occurrence points  of the indicator processes in a CPSP</p></a></li>
<li><a href='#CPSPPOTevents'><p>Identifying the  occurrence points  of the indicator processes in  the CPSP from a POT approach</p></a></li>
<li><a href='#depchi'><p>Estimating extremal dependence coefficientes</p></a></li>
<li><a href='#DepCPSPNHK'><p>Estimating cross K-function  and envelopes for marginal processes of a CPSP</p></a></li>
<li><a href='#DepNHCPSP'><p>Generating a Common Poisson Shock Process</p></a></li>
<li><a href='#DepNHNeyScot'><p>Generating a multivariate  Neyman-Scott cluster process</p></a></li>
<li><a href='#DepNHPPMarked'><p>Generating dependent  point processes from  a marked Poison Process</p></a></li>
<li><a href='#DepNHPPqueue'><p>Generating   dependent point processes by a tandem queueing network</p></a></li>
<li><a href='#DepqueueNHK'><p>Estimating cross K-function  and envelopes for the marginal processes of a  queue</p></a></li>
<li><a href='#DistObs'><p>Calculates the set of close points and the mean distance in a vector of processes,</p>
for each point in the first process</a></li>
<li><a href='#DistShift'><p>Generates  by translation a vector  of independent  processes,   and calculates the set of close points</p>
and the mean distance  for each point in  the first  process</a></li>
<li><a href='#DistSim'><p>Generates a vector  of independent  processes,   and calculates the set of close points</p>
and the mean distance  for each point in  the first  process</a></li>
<li><a href='#DutilleulPlot'><p>A graphical test to assess independence between two point processes</p></a></li>
<li><a href='#IndNHNeyScot'><p>Generating a vector of independent  Neyman-Scott cluster processes</p></a></li>
<li><a href='#IndNHPP'><p>Generates trajectories of independent Poisson processes</p></a></li>
<li><a href='#IndTestPP-package'><p>Tests of Independence  and Analysis of Dependence between  Point Processes in Time</p></a></li>
<li><a href='#IntMPP'><p>Simulated intervals  in a vector of point processes</p></a></li>
<li><a href='#nearestdist'><p>Distance to the nearest point</p></a></li>
<li><a href='#NHD'><p>Estimating the D-function</p></a></li>
<li><a href='#NHF'><p>Estimating the F-function</p></a></li>
<li><a href='#NHJ'><p>Estimating the cross J-function  and testing independence</p></a></li>
<li><a href='#NHK'><p>Estimating cross K-function   and testing independence</p></a></li>
<li><a href='#PlotICPSP'><p>Plotting  the  occurrence points  of the indicator processes in  a CPSP</p></a></li>
<li><a href='#PlotMargP'><p>Plotting  the  occurrence points  of a vector of point processes</p></a></li>
<li><a href='#PlotMCPSP'><p>Plotting  the  occurrence points  of the marginal processes in  a CPSP</p></a></li>
<li><a href='#simHPc'><p>Generating points in a homogenous Poisson process</p></a></li>
<li><a href='#simNHPc'><p>Generating points in a Poisson process</p></a></li>
<li><a href='#SpecGap'><p>Stationary distribution of a matrix and its spectral gap</p></a></li>
<li><a href='#TestIndLS'><p>Lotwick-Silverman test  of independence between point processes</p></a></li>
<li><a href='#TestIndNH'><p>Parametric bootstrap  test  of independence between point processes</p></a></li>
<li><a href='#TranM'><p>Estimation of the transition matrix of a Markov chain</p></a></li>
<li><a href='#TxBHZ'><p>Daily maximum temperature at Barcelona, Huesca and Zaragoza</p></a></li>
<li><a href='#uniongentri'><p>Calculating the set of close points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tests of Independence and Analysis of Dependence Between Point
Processes in Time</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Ana C. Cebrian</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ana C. Cebrian &lt;acebrian@unizar.es&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>It provides a general framework to analyse dependence between point processes in time. It includes parametric and non-parametric tests to study independence,  and functions for generating and analysing  different types of dependence.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-28 14:25:15 UTC; sucarrat</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-28 19:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='BinPer'>Percentage of concordant intervals</h2><span id='topic+BinPer'></span>

<h3>Description</h3>

<p>It calculates the proportion of  the number of intervals with at least 
one point in both processes, and  the sum of  the number 
of intervals with at least one point in  one process, <code class="reqn">n_{x,y}/(n_{x,y}+n_{x,0}+n_{0,y})</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinPer(posx, posy, ll, T)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinPer_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Occurrence points in the first process, <code class="reqn">N_x</code>.</p>
</td></tr>
<tr><td><code id="BinPer_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Occurrence points in the second process, <code class="reqn">N_y</code>.</p>
</td></tr>
<tr><td><code id="BinPer_+3A_ll">ll</code></td>
<td>
<p>Numeric value. Lenght of the intervals where the number of points are counted.</p>
</td></tr>
<tr><td><code id="BinPer_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period of the point processes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to be useful, an adequate length of interval ll,  depending on the expected dependence,
has to be selected.</p>


<h3>Value</h3>

<table>
<tr><td><code>binper</code></td>
<td>
<p>Percentage of concordant intervals.</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+depchi">depchi</a></code>, <code><a href="#topic+CountingCor">CountingCor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generation of two HPP
aux1&lt;-simNHPc(lambda=rep(0.08,200),fixed.seed=123)
aux2&lt;-simNHPc(lambda=rep(0.12,200),fixed.seed=125)
BinPer(aux1$posNH, aux2$posNH,ll=5, T=200)
</code></pre>

<hr>
<h2 id='ComplPos'>Changes  format of the vector of occurrence times in a point process</h2><span id='topic+ComplPos'></span>

<h3>Description</h3>

<p>It changes the format of the vector of occurrence points in a point process.  It builds a vector  of 
length T, the length of the observation period, which takes value 0 at  the non occurrence times and 
the position value (type=&quot;Pos&quot;),  or 1 (type=&quot;Bin&quot;),  at the occurence times.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComplPos(pos, T, type='Pos')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComplPos_+3A_pos">pos</code></td>
<td>
<p>Numeric vector. Occurrence times.</p>
</td></tr>
<tr><td><code id="ComplPos_+3A_t">T</code></td>
<td>
<p>Integer. Length of the observed period.</p>
</td></tr>
<tr><td><code id="ComplPos_+3A_type">type</code></td>
<td>
<p>Character string, 'Pos' or 'Bin'. Type of the new format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the format of the occurrence points in a point process. The new format is useful
when several point processes, in the same observed period, must be specfied; for example, in function 
<code><a href="#topic+NHJ">NHJ</a></code> or <code><a href="#topic+NHD">NHD</a></code>, where the occurrence times of   different point processes 
must be   introduced as a matrix. Since the number of occurrences in each process can be different,  
in the new format,  occurrences in each process are specified as a vector  of length T, which takes value  0 
at non occurrence times  and  the time position  (if type='Pos') or 1 (if type='Bin') at the occurrence times.</p>


<h3>Value</h3>

<table>
<tr><td><code>Npos</code></td>
<td>
<p>Numeric vector of lenght T containing the occurrence times in the new format.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+NHD">NHD</a></code>, <code><a href="#topic+NHF">NHF</a></code>, <code><a href="#topic+NHK">NHK</a></code>, <code><a href="#topic+NHJ">NHJ</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pos&lt;-c(4,15,18,34,36,67,98)
Npos&lt;-ComplPos(pos, T=100)
</code></pre>

<hr>
<h2 id='CondTest'>Conditional test of independence between two Poisson process</h2><span id='topic+CondTest'></span><span id='topic+calcNmu'></span>

<h3>Description</h3>

<p>It calculates a test of independence between 
two Poisson process, based on the analysis of the occurrences in the second process, 
given that there is an occurrence in the first one.  Two different approaches to calculate  
the p-value are implemented. 
</p>
<p>It calls the  auxiliary function  <code>calcNmu</code>, not intended for the users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CondTest(posx, posy, lambday, r, changer = TRUE, type = "All", 
	plotRes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CondTest_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Occurrence points in the first process, <code class="reqn">N_x</code>.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Occurrence points in the second process, <code class="reqn">N_y</code>.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_lambday">lambday</code></td>
<td>
<p>Numeric vector. Intensity at each  time in <code class="reqn">N_y</code>.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_r">r</code></td>
<td>
<p>Numeric value. The radius of the intervals centered on the occurrence times in <code class="reqn">N_x</code>.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_changer">changer</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, when the defined intervals overlap, their lengths are 
changed to  obtain disjoint intervals. The two  overlapping intervals are shortened by  half of the overlapped
period.  In general, the resulting intervals are not centered.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_type">type</code></td>
<td>
<p>Optional. Label &quot;Poisson&quot;,  &quot;Normal&quot; or &quot;All&quot;. Approach to be used to calculate test p-values.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_plotres">plotRes</code></td>
<td>
<p>Logical flag. If it is TRUE,  the  residual differences   <code class="reqn">(y_i-\mu_i)/\mu_i^{(1/2)}</code> are  
plotted.</p>
</td></tr>
<tr><td><code id="CondTest_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function  <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  underlying idea of the tests is to analyze the behaviour of the  second process <code class="reqn">N_y</code>, given that
a point has occured in  the first one, <code class="reqn">N_x</code>. Under independence between <code class="reqn">N_x</code> and <code class="reqn">N_y</code>, <code class="reqn">N_y</code>
should be a Poisson process with intensity lambday.
</p>
<p>Intervals of length 2r centered on  each point in <code class="reqn">N_x</code> are defined. To analyze
the behaviour of <code class="reqn">N_y</code>, two approaces are implemented, both based on the idea that the number  of points 
in each interval should be a Poisson  of mean <code class="reqn">\mu_i</code> equal to the integral of lambday in the interval.
</p>
<p>&quot;Poisson&quot; option: under the null,  and if the intervals  are independent (that is if they do not overlap)
the number of points in all them should be a Poisson of mean  <code class="reqn">\mu</code>, equal to the sum of all the <code class="reqn">\mu_i</code>.
The p-values is calculated as  <code class="reqn">2*min (  (P(Y&lt;yo)+P(Y=yo)/2), (P(X&gt;yo)+P(Y=yo)/2))</code>, where Y is a r.v.
with distibution Poisson(<code class="reqn">\mu</code>) and <code class="reqn">yo</code> is the sum of the observed number 
of points in all the intervals.   Since  the  p-values are based on a discrete distribution, they 
are valid but not exact p-values.
</p>
<p>&quot;Normal&quot; option: under  the null,  the variables <code class="reqn">(N_i-\mu_i)/(\mu_i^{1/2})</code>  must be
zero mean  and variance one variables but they are not identically distributed. Under general conditions, 
the mean of the variables  <code class="reqn">(N_i-\mu_i)/(\mu_i^{1/2})</code> can be approximated by 
a Normal distribution using the   Central limit theorem  under the Lindeberg condition for r.v which are independent 
but not identically distributed.   The conditions  to have a valid Normal aprroximation are quite weak,  even  
with  a complex intensity, mean values  of <code class="reqn">\mu_i</code>  around 0.6 are valid with <code class="reqn">n_x=50</code>, and around  
0.3 with <code class="reqn">n_x=100</code>.
</p>


<h3>Value</h3>

<p> A list with elements
</p>
<table>
<tr><td><code>pvP</code></td>
<td>
<p>P-value obtained with the 'Poisson' approach.</p>
</td></tr>
<tr><td><code>PvN</code></td>
<td>
<p>P-value obtained with the 'Normal' approach.</p>
</td></tr>
<tr><td><code>Ni</code></td>
<td>
<p>Number of  occurrences in each  interval.</p>
</td></tr>
<tr><td><code>mui</code></td>
<td>
<p>Theoretical mean of the number of  occurrences in each  interval under the independence assumption.</p>
</td></tr>
<tr><td><code>Res</code></td>
<td>
<p>Vector of th residual differences.</p>
</td></tr>
<tr><td><code>linf</code></td>
<td>
<p>Lower bound of each interval.</p>
</td></tr>
<tr><td><code>lsup</code></td>
<td>
<p>Upper bound of each interval.</p>
</td></tr>
<tr><td><code>mmu</code></td>
<td>
<p> Mean of the mui vector. It is used to  check the conditions of the approximation of the Normal test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+TestIndNH">TestIndNH</a></code>,  <code><a href="#topic+NHK">NHK</a></code>,  <code><a href="#topic+NHJ">NHJ</a></code>,  <code><a href="#topic+DutilleulPlot">DutilleulPlot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Two dependent Poisson processes from  a NHCPSP
set.seed(30)
lambdao1&lt;-runif(3000)/20
set.seed(31)
lambdao2&lt;-runif(3000)/10
set.seed(32)
lambda12&lt;-runif(3000)/20
lambdaiM&lt;-cbind(lambdao1,lambdao2,lambda12)
aux&lt;-DepNHCPSP(lambdaiM=lambdaiM, d=2,fixed.seed=123, dplot=FALSE)

zz&lt;-CondTest(posx=aux$posNH[[1]],posy=aux$posNH[[2]],lambday=aux$lambdaM[,2], r=2)
zz$pvP
zz$pvN

# Two independent non homogeneous  Poisson processes  
lambdao1&lt;-runif(6000)/20
set.seed(124)
lambdao2&lt;-runif(6000)/10
aux1&lt;-simNHPc(lambda=lambdao1, fixed.seed=123)
aux2&lt;-simNHPc(lambda=lambdao2, fixed.seed=124)

zz&lt;-CondTest(posx=aux1$posNH, posy=aux2$posNH, lambday= aux2$lambda, r=3)
zz$pvP
zz$pvN

</code></pre>

<hr>
<h2 id='CountingCor'>Correlation between the  counting variables in two point processes</h2><span id='topic+CountingCor'></span><span id='topic+countP'></span>

<h3>Description</h3>

<p>This function  calculates the correlation coefficient between the  number of points
in intervals  of length <code class="reqn">ll</code>,  in two point processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountingCor(posx, posy, ll, T,  method='spearman', lambdax=NULL, 
	lambday=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountingCor_+3A_posx">posx</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the first  point process.</p>
</td></tr>
<tr><td><code id="CountingCor_+3A_posy">posy</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the second  point process.</p>
</td></tr>
<tr><td><code id="CountingCor_+3A_ll">ll</code></td>
<td>
<p>Numeric value. Lenght of the intervals where the number of points are counted.</p>
</td></tr>
<tr><td><code id="CountingCor_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period of the point processes.</p>
</td></tr>
<tr><td><code id="CountingCor_+3A_method">method</code></td>
<td>
<p>Character string.  Correlation coefficient  to be calculated. One of &quot;pearson&quot;, &quot;kendall&quot;, 
or &quot;spearman&quot;; 	see <code><a href="stats.html#topic+cor.test">cor.test</a></code> for definitions.</p>
</td></tr>
<tr><td><code id="CountingCor_+3A_lambdax">lambdax</code></td>
<td>
<p>Numeric vector. Intensity vector  of the first point process.</p>
</td></tr>
<tr><td><code id="CountingCor_+3A_lambday">lambday</code></td>
<td>
<p>Numeric vector. Intensity vector  of the second point process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates <code class="reqn">\rho_{xy,I_l}=Cor(X_{I_l}, Y_{I_l})</code>, where  
<code class="reqn">X_{I_l}</code> and <code class="reqn">Y_{I_l}</code> are the number of points  in an  interval <code class="reqn">I_l</code> 
in processes <code class="reqn">N_x</code> and <code class="reqn">N_y</code>, respectively.
</p>
<p>In order to calculate the number of points in each interval in a process, the function  <code>CountP</code> is used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ccor</code></td>
<td>
<p>Estimated correlation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+depchi">depchi</a></code>,<code><a href="#topic+BinPer">BinPer</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>#generation of two HPP
aux1&lt;-simNHPc(lambda=rep(0.08,200),fixed.seed=123)
aux2&lt;-simNHPc(lambda=rep(0.12,200),fixed.seed=125)

CountingCor(aux1$posNH, aux2$posNH,ll=20, method="kendall",T=200)
</code></pre>

<hr>
<h2 id='CPSPpoints'>Identifying the  occurrence points  of the indicator processes in a CPSP</h2><span id='topic+CPSPpoints'></span><span id='topic+marca'></span>

<h3>Description</h3>

<p>It calculates the  occurrence  points
in the three indicator processes of a bivariate Common Poisson Shock Process (CPSP), using as input
the two marginal processes <code class="reqn">N_1</code> and <code class="reqn">N_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPSPpoints(N1,N2,date=NULL, dplot=T, pmfrow=c(2,1), axispoints=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPSPpoints_+3A_n1">N1</code></td>
<td>
<p>Binary vector of the first CPSP marginal process; occurrence points must be marked with 1 and the other with 0.</p>
</td></tr>
<tr><td><code id="CPSPpoints_+3A_n2">N2</code></td>
<td>
<p>Binary vector of the second CPSP marginal process; occurrence points must be marked with 1 and the other with 0.</p>
</td></tr>
<tr><td><code id="CPSPpoints_+3A_date">date</code></td>
<td>
<p>Optional. A vector or matrix indicating the date of each observation.</p>
</td></tr>
<tr><td><code id="CPSPpoints_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  marginal and indicator processes  are plotted.</p>
</td></tr>
<tr><td><code id="CPSPpoints_+3A_pmfrow">pmfrow</code></td>
<td>
<p>Optional.  A vector of  the form (nr, nc) to be supplied as value of the argument <code>mfrow</code> in  
<code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="CPSPpoints_+3A_axispoints">axispoints</code></td>
<td>
<p>Optional. Numeric vector with the  points in the time index where axis ticks and labels (from the first column in <code>date</code>)
have to be drawn.</p>
</td></tr>
<tr><td><code id="CPSPpoints_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A  bivariate CPSP <code class="reqn">N</code>   is usually specified by its two marginal,  and possibly dependent, processes
<code class="reqn">N_1</code> and <code class="reqn">N_2</code>, which are the  observed processes. However,  <code class="reqn">N</code> can be  decomposed into 
three independent indicator processes: <code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  
and <code class="reqn">N_{(12)}</code>, which are the processes of the points  occurring
only in the first  marginal process, only in the second and  in both of them (simultaneous points).
The union of  <code class="reqn">N_{(1)}</code>  and <code class="reqn">N_{(12)}</code>, and <code class="reqn">N_{(2)}</code>  
and <code class="reqn">N_{(12)}</code>  gives  respectively the two marginal processes. 
</p>
<p>The  points in the  marginal  <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code>  and indicator  
<code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  and <code class="reqn">N_{(12)}</code>  processes can be optionally plotted. 
If  <code>date</code> is NULL, default axis are used. Otherwise, the values in <code>axispoints</code> are used 
as the  points in the time index where axis ticks and labels, from  the first column in <code>date</code>,  
have to be drawn.  If  <code>axispoints</code> is NULL, a default grid of points  is built  using  the 
function <code>marca</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>Px1</code></td>
<td>
<p>Vector of the  occurrence points  in <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>Px2</code></td>
<td>
<p>Vector of the  occurrence points  in <code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>Px12</code></td>
<td>
<p>Vector of the  occurrence points  in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>N1</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>N2</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>, 22(1), 127-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CPSPPOTevents">CPSPPOTevents</a></code>, <code><a href="#topic+PlotMCPSP">PlotMCPSP</a></code>, <code><a href="#topic+PlotICPSP">PlotICPSP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
X&lt;-as.numeric(runif(100)&lt;0.10)
set.seed(124)
Y&lt;-as.numeric(runif(100)&lt;0.15)

aux&lt;-CPSPpoints(N1=X,N2=Y)
</code></pre>

<hr>
<h2 id='CPSPPOTevents'>Identifying the  occurrence points  of the indicator processes in  the CPSP from a POT approach</h2><span id='topic+CPSPPOTevents'></span>

<h3>Description</h3>

<p>This function calculates the  occurrence times and other characteristics (length, maximum and mean intensity) of the  extreme events
of the three indicator processes of a bivariate Common Poisson Shock Process (CPSP) obtained from a 
Peak Over Threshold (POT) approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPSPPOTevents(N1,N2,thres1,thres2, date=NULL, dplot=T, pmfrow=c(2,1), 
	axispoints=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPSPPOTevents_+3A_n1">N1</code></td>
<td>
<p>Numeric vector. Series <code class="reqn">(x_i)</code> whose threshold exceedances define the first CPSP marginal process.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_n2">N2</code></td>
<td>
<p>Numeric vector. Series <code class="reqn">(y_i)</code> whose threshold exceedances define the second CPSP marginal process.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_thres1">thres1</code></td>
<td>
<p>Numeric value. Threshold  used to define the extreme events in <code class="reqn">(x_i)</code>.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_thres2">thres2</code></td>
<td>
<p>Numeric value. Threshold used to define the extreme events  in <code class="reqn">(y_i)</code>.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_date">date</code></td>
<td>
<p>Optional. A vector or matrix indicating the date of each observation.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  marginal and indicator processes  are plotted.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_pmfrow">pmfrow</code></td>
<td>
<p>Optional.  A vector of  the form (nr, nc) to be supplied as value of the argument <code>mfrow</code> in  <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_axispoints">axispoints</code></td>
<td>
<p>Optional. Numeric vector with the  points in the time index where axis ticks and labels (from the first column in <code>date</code>)
have to be drawn.</p>
</td></tr>
<tr><td><code id="CPSPPOTevents_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A CPSP <code class="reqn">N</code> can be  decomposed into three independent indicator processes: <code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  
and <code class="reqn">N_{(12)}</code>,  the processes of the points  occurring
only in the first  marginal process, only in the second and  in both of them (simultaneous points).
In the CPSP resulting from applying a POT approach, the events in  <code class="reqn">N_{(1)}</code>
are  a run of consecutive observations where <code class="reqn">x_i</code> exceeds its  extreme threshold but <code class="reqn">y_i</code> does not exceed 
its extreme threshold. An extreme event  in  <code class="reqn">N_{(2)}</code> is defined analogously. A simultaneous  event,  or event 
in  <code class="reqn">N_{(12)}</code>, is a run where both series  exceed  their thresholds. 
</p>
<p>For the events  defined in each indicator process, three magnitudes (length, maximum intensity and mean intensity) 
are calculated together with the   initial point and the point of maximum excess of each event. In  
<code class="reqn">N_{(12)}</code>, the maximum and the  mean intensity  in  both  series <code class="reqn">(x_i)</code> and
<code class="reqn">(y_i)</code> are  calculated. 
</p>
<p>The occurrence point of each event is  the time  in the run where the maximum   of the sum of the excesses of   
<code class="reqn">(x_i)</code> and <code class="reqn">(y_i)</code> over their threholds   occurs;  if an observation does not exceed  
its corresponding threshold,  that  excess is 0. According to this definition, the occurrence point in 
<code class="reqn">N_{(1)}</code> is the point  with maximum intensity in <code class="reqn">(x_i)</code> within  the run. 
</p>
<p>The vectors <code>inddat1</code>, <code>inddat2</code> and <code>inddat12</code>, elements of the output list,
mark the observations  that should be used in the estimation of each indicator  process.  The 
observations in an extreme event which are not the occurrence point are marked with 0
and treated as non observed in the estimation process.  The rest are marked with 1  and 
must be included in the likelihood function. See  function <code>fitPP.fun</code> in package NHPoisson
for more details on the use of these indexes in the estiamtion of a point process.
</p>
<p>The  points in the  marginal  <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code>  and indicator  
<code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  and <code class="reqn">N_{(12)}</code>  processes can be optionally plotted. 
If  <code>date</code> is NULL, default axis are used. Otherwise, the values in <code>axispoints</code> are used 
as the  points in the time index where axis ticks and labels, from  the first column in <code>date</code>,  
have to be drawn.  If  <code>axispoints</code> is NULL, a default grid of points  is built  using  the 
function <code>marca</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>Im1</code></td>
<td>
<p>Vector of  mean excesses (over the threshold) of the extreme events in <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>Ix1</code></td>
<td>
<p>Vector of  maximum excesses (over the threshold) of the extreme events in <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>L1</code></td>
<td>
<p>Vector of  lengths of the extreme events in <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>Px1</code></td>
<td>
<p>Vector of  points of  maximum excess of the extreme events in <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>Pi1</code></td>
<td>
<p>Vector of  initial points of the extreme events in <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>inddat1</code></td>
<td>
<p>Index  of the observations to be used in the estimation process  of <code class="reqn">N_{(1)}</code>.</p>
</td></tr>
<tr><td><code>Im2</code></td>
<td>
<p>Vector of  mean excesses (over the threshold) of the extreme events in <code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>IxY</code></td>
<td>
<p>Vector of maximum excesses (over the threshold) of the extreme events in <code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>L2</code></td>
<td>
<p>Vector of  lengths of the extreme events in <code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>Px2</code></td>
<td>
<p>Vector of  points of  maximum excess of the extreme events in <code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>Pi2</code></td>
<td>
<p>Vector of   initial points of the extreme events in <code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>inddat2</code></td>
<td>
<p>Index of the observations to be used in the estimation process  of  
<code class="reqn">N_{(2)}</code>.</p>
</td></tr>
<tr><td><code>Im121</code></td>
<td>
<p>Vector of  mean excesses of the series <code class="reqn">(x_i)</code> in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>Ix121</code></td>
<td>
<p>Vector of  maximum excesses  the series <code class="reqn">(x_i)</code> in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>Im122</code></td>
<td>
<p>Vector of  mean excesses of the series <code class="reqn">(y_i)</code> in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>Ix122</code></td>
<td>
<p>Vector of  maximum excesses  the series <code class="reqn">(y_i)</code> in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>L12</code></td>
<td>
<p>Vector of lengths of the extreme events in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>Px12</code></td>
<td>
<p>Vector of points of  maximum excess of the extreme events in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>Pi12</code></td>
<td>
<p>Vector of  initial points of the extreme events in <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>inddat12</code></td>
<td>
<p>Index of the observations to be used in the estimation process  of <code class="reqn">N_{(12)}</code>.</p>
</td></tr>
<tr><td><code>N1</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>N2</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>thres1</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>thres1</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>date</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>, 22(1), 127-144.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CPSPpoints">CPSPpoints</a></code>, <code><a href="#topic+PlotMCPSP">PlotMCPSP</a></code>, <code><a href="#topic+PlotICPSP">PlotICPSP</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TxBHZ)
dateT&lt;-cbind(TxBHZ$year,TxBHZ$month,TxBHZ$day)  #year, month and day of the month
marca&lt;- c(1:length(TxBHZ$TxH))[c(1,diff(dateT[,1]))==1]  # points at  first day  of the year
BivEv&lt;-CPSPPOTevents(N1=TxBHZ$TxH,N2=TxBHZ$TxZ,thres1=378,thres2=364, date=dateT, 
       axispoints=marca)
</code></pre>

<hr>
<h2 id='depchi'>Estimating extremal dependence coefficientes</h2><span id='topic+depchi'></span>

<h3>Description</h3>

<p>This function estimates  and plots the  extremal dependence functions
<code class="reqn">\chi(u)</code> and <code class="reqn">\bar \chi(u)</code>  against a grid of values in [0,1] 
to analyse the extremal dependence of two variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>depchi(X, Y, thresval = c(0:99)/100, tit = "", indgraph = TRUE, bothest = TRUE, 
       xlegend = "topleft",mfrow=c(1,2),...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depchi_+3A_x">X</code></td>
<td>
<p>Numeric vector. Values of the   first variable.</p>
</td></tr>
<tr><td><code id="depchi_+3A_y">Y</code></td>
<td>
<p>Numeric vector. Values of the  second variable.</p>
</td></tr>
<tr><td><code id="depchi_+3A_thresval">thresval</code></td>
<td>
<p>Numeric vector. Grid  values   where the functions  <code class="reqn">\chi(u)</code> and <code class="reqn">\bar \chi(u)</code> are evaluated.</p>
</td></tr>
<tr><td><code id="depchi_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plots.</p>
</td></tr>
<tr><td><code id="depchi_+3A_indgraph">indgraph</code></td>
<td>
<p>Logical flag. If it is TRUE, plots are shown in separate windows. 
If it is FALSE, the layout in <code>mfrow</code> is used.</p>
</td></tr>
<tr><td><code id="depchi_+3A_bothest">bothest</code></td>
<td>
<p>Logical flag. If it is TRUE,  two estimated  coefficientes (for X given Y  and  for Y given X)
are displayed in the same plot. Otherwise, only the coefficient  for Y given X is plotted.</p>
</td></tr>
<tr><td><code id="depchi_+3A_xlegend">xlegend</code></td>
<td>
<p>Optional. Label &quot;topleft&quot;,&quot;bottomright&quot;, etc. Position where the legend on the graph  will be located.</p>
</td></tr>
<tr><td><code id="depchi_+3A_mfrow">mfrow</code></td>
<td>
<p>Optional. A vector of the form c(2, 1) or c(1,2). It gives the layout to draw the two figures in the function. </p>
</td></tr>  
<tr><td><code id="depchi_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extremal dependence between  two variables X and Y
is the tendency for one variable to be large, given that the other one is large.
The  extremal dependence coefficients <code class="reqn">\chi</code> and <code class="reqn">\bar \chi</code>  are defined as
<code class="reqn">\chi= \lim_{u \to 1} \chi(u)</code> where <code class="reqn">\chi(u)= P(U&gt;u |V&gt;u)</code>  and  (U,V) are  the  
transformed uniform marginals of the variables X and Y.
</p>
<p><code class="reqn">\bar \chi= \lim_{u \to 1} \bar \chi(u)</code> where <code class="reqn">\bar \chi(u)= 2log P(U&gt;u)/log P(U&gt;u, V&gt;u)-1</code>.
</p>
<p>The function plots  <code class="reqn">\chi(u)</code> and <code class="reqn">\bar \chi(u)</code>. These graphs 
can be used to estimate <code class="reqn">\hat \chi</code> and <code class="reqn">\widehat{\bar \chi}</code>, the limits of the functions.
In the <code class="reqn">\chi (u)</code> plot, the expected behaviour under independence of X and Y is also plotted.
</p>
<p><code class="reqn">\chi</code> is on the scale [0, 1], with the set (0, 1] corresponding to asymptotic
dependence, and the measure <code class="reqn">\bar \chi</code> falls within the range [-1, 1], with the set [-1, 1) 
corresponding to asymptotic independence. See  Coles  et al. (1999) for more details on the definition 
and interpretation of these indexes.
</p>


<h3>Value</h3>

<p> A list with elements
</p>
<table>
<tr><td><code>chiX</code></td>
<td>
<p>Estimated <code class="reqn">\chi (u)</code> function for Y given X evaluated at the threshold grid.</p>
</td></tr>
<tr><td><code>chiY</code></td>
<td>
<p>Estimated <code class="reqn">\chi (u)</code> function for X given Y evaluated at the threshold grid.</p>
</td></tr>
<tr><td><code>chiBX</code></td>
<td>
<p>Estimated <code class="reqn">\bar \chi (u) </code> function for Y given X evaluated at the threshold grid.</p>
</td></tr>
<tr><td><code>chiBY</code></td>
<td>
<p>Estimated <code class="reqn">\bar \chi (u)</code> function for X given Y evaluated at the threshold grid.</p>
</td></tr>
<tr><td><code>PX</code></td>
<td>
<p>Estimation of the probabilities <code class="reqn">P(U&lt;thresval)</code>.</p>
</td></tr>
<tr><td><code>PY</code></td>
<td>
<p>Estimation of the probabilities <code class="reqn">P(V&lt;thresval)</code>.</p>
</td></tr>
<tr><td><code>PXY</code></td>
<td>
<p>Estimation of the probabilities <code class="reqn">P[(U&lt;thresval)\&amp;(V&lt;thresval)]</code>. </p>
</td></tr>
<tr><td><code>thresval</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Coles, S., Heffernan, J. and Tawn, J. (1999) Dependence measures for extreme value analysis.
Extremes, 2, 339-365.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CountingCor">CountingCor</a></code>, <code><a href="#topic+BinPer">BinPer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(TxBHZ)

aux&lt;-depchi(X=TxBHZ$TxZ,Y=TxBHZ$TxH, thresval = c(0:99)/100, 
	tit = "Tx Zaragoza and Tx Huesca", xlegend = "bottom",indgraph="FALSE")
</code></pre>

<hr>
<h2 id='DepCPSPNHK'>Estimating cross K-function  and envelopes for marginal processes of a CPSP</h2><span id='topic+DepCPSPNHK'></span><span id='topic+DepCPSPKenv'></span>

<h3>Description</h3>

<p>This function estimates the  cross K-function  between 
two (homogenous or nonhomogeneous)  point processes in time, <code class="reqn">N_{x}</code> and <code class="reqn">N_{y}</code>.  
It  is evaluated in a grid of distances <code class="reqn">r</code> and plotted. An envelope built  by simulation under the  hypothesis
that the processes are the marginal processes of a bivariate CPSP is also plotted.
</p>
<p>It calls the auxiliary function DepCPSPKenv, not intended for users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepCPSPNHK(posx, posy, lambdaix, lambdaiy, lambdaixy, r=NULL, typeEst=1, 
                  nsim=1000, conf=0.95,tit=NULL, cores=1,fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepCPSPNHK_+3A_posx">posx</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the first point process <code class="reqn">N_{x}</code> .</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_posy">posy</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the second point process <code class="reqn">N_{y}</code> .</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_lambdaix">lambdaix</code></td>
<td>
<p>Numeric vector. Intensity values of <code class="reqn">N_{(x)}</code>.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_lambdaiy">lambdaiy</code></td>
<td>
<p>Numeric vector. Intensity values of <code class="reqn">N_{(y)}</code>.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_lambdaixy">lambdaixy</code></td>
<td>
<p>Numeric vector. Intensity values of <code class="reqn">N_{(xy)}</code>.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector.  Grid values where  the K-function  must be evaluated. If it  is NULL, 
a default vector is used; see Details.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_typeest">typeEst</code></td>
<td>
<p>Optional. Two possible values: 1 or 2. They determines which one of the two  available estimators  
of the function <code class="reqn">K_{ij}</code> has to be used; see Details. </p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_nsim">nsim</code></td>
<td>
<p>Optional. Numeric value.  Number of simulations  to obtain the envelope.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_conf">conf</code></td>
<td>
<p>Optional. Numeric value  in (0,1). Confidence level of the envelope for the K-function.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_tit">tit</code></td>
<td>
<p>Optional.  Title to be used in the plot of the K-function. </p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the calculations. </p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. If it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="DepCPSPNHK_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the cross K function  between two (homogenous or nonhomogeneous)  point processes 
in time, <code class="reqn">N_{x}</code> and <code class="reqn">N_{y}</code>. Two different estimators
are available, see  <code><a href="#topic+NHK">NHK</a></code> for  more details.
</p>
<p>An envelope for the cross K function is built  under the hypothesis that the  processes are the marginal processes of a  bivariate CPSP with intensities of the indicator processes
<code>lambdaxi</code>, <code>lambdayi</code> and <code>lambdaxyi</code>. The envelope is based on the simulation of CPSPs,
gnerated by function <code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code>.
</p>
<p>If argument <code>r</code> is NULL,   the following r-grid is used to evaluate the function:
</p>
<p>r1&lt;-max(20, floor(T/20))
</p>
<p>r&lt;-seq(1,r1,by=2)
</p>
<p>if (length(r)&gt;200) r&lt;-seq(1,r1,length.out=200)
</p>
<p>where <code>T</code> is the length of the observed period.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Vector of values <code class="reqn">r</code> where the cross K-function is estimated.</p>
</td></tr>
<tr><td><code>NHKr</code></td>
<td>
<p>Estimated values of  <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KenvL</code></td>
<td>
<p>Lower bounds of the envelope of <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KenvU</code></td>
<td>
<p>Upper bounds of the envelope of <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the observed period of the processes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+NHK">NHK</a></code>, <code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(123)
lambdai1&lt;-runif(500,0.005,0.01)
set.seed(124)
lambdai2&lt;-runif(500,0.005,0.01)
set.seed(125)
lambdai12&lt;-runif(500,0.005,0.02)

#Observed process: independent Poisson processes
posx&lt;-simNHPc(lambda = (lambdai1+lambdai12), fixed.seed = 13)$posNH
posy&lt;-simNHPc(lambda = (lambdai2+lambdai12), fixed.seed = 14)$posNH
aux&lt;-DepCPSPNHK(posx=posx, posy=posy, lambdaix=lambdai1, lambdaiy=lambdai2, 
	       lambdaixy=lambdai12, fixed.seed=123, r=c(1:10), nsim=500)

#Observed processes: dependent marginal processes of a CPSP
#pos&lt;-DepNHCPSP(lambdaiM=cbind(lambdai1, lambdai2, lambdai12), d=2,
#	fixed.seed=123, dplot=F)$posNH
#aux&lt;-DepCPSPNHK(posx=pos$N1, posy=pos$N2, lambdaix=lambdai1, 
#	lambdaiy=lambdai2, lambdaixy=lambdai12, fixed.seed=125, r=c(1:10))
</code></pre>

<hr>
<h2 id='DepNHCPSP'>Generating a Common Poisson Shock Process</h2><span id='topic+DepNHCPSP'></span><span id='topic+PsimNHPc'></span>

<h3>Description</h3>

<p>This function  generates  the <code class="reqn">d</code> marginal processes of a Common Poisson Shock Process,  
which are <code class="reqn">d</code> dependent Poisson processes. 
Both homogeneous  and nonhomogeneous processes can be generated.  In the case <code class="reqn">d=2</code>, 
the processes can be optionally plotted.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepNHCPSP(lambdaiM, d,dplot=TRUE, pmfrow=c(2,1), fixed.seed = NULL, ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepNHCPSP_+3A_lambdaim">lambdaiM</code></td>
<td>
<p>Matrix. Each column contains the intensity values  of a indicator process .</p>
</td></tr>
<tr><td><code id="DepNHCPSP_+3A_d">d</code></td>
<td>
<p>Numeric value.  Dimension (number of marginal processes) of the CPSP.</p>
</td></tr>
<tr><td><code id="DepNHCPSP_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE and d=2,  the  marginal and indicator processes  are plotted.</p>
</td></tr>
<tr><td><code id="DepNHCPSP_+3A_pmfrow">pmfrow</code></td>
<td>
<p>Optional.  A vector of  the form (nr, nc) to be supplied as argument <code>mfrow</code> in  <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="DepNHCPSP_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. Value used to set the seed 
in random generation processes; if it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="DepNHCPSP_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A   CPSP <code class="reqn">N</code>   is usually specified by its  marginal,  and possibly dependent, processes
<code class="reqn">N_1</code>,  <code class="reqn">N_2</code>...,  <code class="reqn">N_d</code>, which are the  observed processes. However,  <code class="reqn">N</code> can be  decomposed into 
m independent indicator processes: <code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>, ..., <code class="reqn">N_{(12)}</code>, ..., <code class="reqn">N_{(1...d)}</code>,
which are the processes of the points  occurring
only in the first  marginal process, only in the second,...,  simultaneously in  the two first marginal processes, ...
and  in all the marginal processes simultaneously.  The number of indicator processes is m, the sum of 
n choose i for <code class="reqn">i=1, ..., d</code>. The value m must also be the number of columns of the matrix in argument <code>lambdaiM</code>.
The marginal process <code class="reqn">N_{i}</code>  is obtained as the union of all the indicator processes where the index i appears, 
<code class="reqn">N_{.i.}</code>. The intensity of  <code class="reqn">N_{i}</code> is the sum of the intensities of all the indicator processes <code class="reqn">N_{.i.}</code>.
</p>
<p>The decomposition into indicator processes can be readily applied  for the generation of a CPSP: it reduces
to the generation of m independet PPs, see Cebrian et al. (2020) for details.  
Points are generated in continuous time.
</p>
<p>In order to  generate d independent Poisson processes, the function  <code><a href="#topic+IndNHPP">IndNHPP</a></code> has be used. 
</p>
<p>In the bivariate case <code class="reqn">d=2</code>, the  points in the  marginal  <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code>  and indicator  
<code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  and <code class="reqn">N_{(12)}</code>  processes can be optionally plotted. 
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>A list of d vectors containing the occurrence points of the d marginal processes. 
The name of the elements of the list are N1, N2...,Nd.</p>
</td></tr>
<tr><td><code>posNHG</code></td>
<td>
<p>A list of m vectors containing the occurrence points of the m indicator processes.</p>
</td></tr>
<tr><td><code>lambdaM</code></td>
<td>
<p>Matrix. Each column is the intensity vector  of  a marginal process.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). Modeling and projecting the occurrence of bivariate extreme heat events using a nonhomogeneous
common Poisson shock process. Stochastic and Environmental Research and risk assessment, 29(1), 309-322.
</p>
<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DepNHNeyScot">DepNHNeyScot</a></code>, <code><a href="#topic+DepNHPPqueue">DepNHPPqueue</a></code>, <code><a href="#topic+DepNHPPMarked">DepNHPPMarked</a></code>, <code><a href="#topic+IndNHPP">IndNHPP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
lambdai1&lt;-runif(200,0,0.1)
set.seed(124)
lambdai2&lt;-runif(200,0,0.07)
set.seed(125)
lambdai12&lt;-runif(200,0,0.05)
set.seed(126)
lambdai123&lt;-runif(200,0,0.01)
lambdaiM&lt;-cbind(lambdai1, lambdai2,lambdai1, lambdai12, lambdai12, lambdai12, lambdai123)
aux&lt;-DepNHCPSP(lambdaiM=lambdaiM, d=3, fixed.seed=123)

#lambdaiM&lt;-cbind(lambdai1, lambdai2, lambdai12)
#aux&lt;-DepNHCPSP(lambdaiM=lambdaiM, d=2,fixed.seed=123, dplot=TRUE)
</code></pre>

<hr>
<h2 id='DepNHNeyScot'>Generating a multivariate  Neyman-Scott cluster process</h2><span id='topic+DepNHNeyScot'></span><span id='topic+GenSons'></span>

<h3>Description</h3>

<p>This function  generates  a multivariate  Neyman-Scott cluster process,
that is  a vector of <code class="reqn">d</code> dependent  (homogeneous or nonhomogeneous) point processes
which are Neyman-Scott processes with the same trajectory of  cluster centers. 
</p>
<p>It calls the auxiliary function <code>GenSons</code> (not intended for the
users), see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepNHNeyScot(lambdaParent, d, lambdaNumP = 1, dist = "normal", sigmaC = 1, 
                    minC = -1, maxC = 1, dplot=TRUE, fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepNHNeyScot_+3A_lambdaparent">lambdaParent</code></td>
<td>
<p>Numeric vector. Intensity values  of the  Poisson process used to generate 
the  centers of the clusters of the Neyman-Scott process.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_d">d</code></td>
<td>
<p>Integer. Number of dependent processes to be generated.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_lambdanump">lambdaNumP</code></td>
<td>
<p>Optional. Numeric vector. Mean values of the number of sons of each dependent process. If its length
is equal to 1, the same value is used to generate all the dependent processes.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_dist">dist</code></td>
<td>
<p>Optional. Label &quot;normal&quot; or &quot;uniform&quot;. Distribution  used to generate the  points of each 
cluster.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_sigmac">sigmaC</code></td>
<td>
<p>Optional. Numeric vector.  Only used if dist=&quot;normal&quot;. Standard deviation of the normal distribution.   
If its length is equal to 1, the same value is used in the <code class="reqn">d</code> processes.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_minc">minC</code></td>
<td>
<p>Optional. Numeric  vector. Only used if dist=&quot;uniform&quot;. Lower bounds of the  Uniform distribution.  If its length
is equal to 1, the same value is used in the d processes.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_maxc">maxC</code></td>
<td>
<p>Optional. Numeric  vector. Only used if dist=&quot;uniform&quot;. Upper bounds of the  Uniform distribution. If its length
is equal to 1, the same value is used in the <code class="reqn">d</code> processes.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  generated marginal  processes  are plotted.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. Value used to set the seed 
in random generation processes; if it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="DepNHNeyScot_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Neyman-Scott  process is a Poisson cluster process  where the points in each cluster are randomly
distributed around the cluster center, see Neyman and Scott (1958) and Entekhabi et al. (1989).  
</p>
<p>Homogeneous  or NH Neyman-Scott processes in continuous time and with the same trajectory of  cluster centers
are generated, so that <code class="reqn">d</code> dependent processe are obtained.   First, the Poisson 
process of the cluster centers  is generated. Then, the number  of points in each cluster  
is generated using a Poisson distribution with  means which can be different in each process. 
The distances of each point in the cluster to its centre  can be generated using  two distributions 
a N(0, sigmaC)  or a Uniform(minC, maxC).  
</p>
<p>It is noteworthy that high values of <code>sigmaC</code>  or  the range <code>maxC-minC</code> lead to a high variability 
around the centre and  to a low dependence between the  processes.
</p>
<p>The marginal processes of the generated vector  can be optionally plotted.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>A list of  d vectors, containing the occurrence points of  the <code class="reqn">d</code> dependent processes. The name of the 
elements of the list are N1, N2,..., Nd.</p>
</td></tr>
<tr><td><code>sizeCL</code></td>
<td>
<p>A list of  d vectors. Each vector contains the  size (number of points) of each cluster in  a processes. The name of the 
elements of the list are size1, size2,..., sized.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>
<p>Neyman, J., &amp; Scott, E. L. (1958). Statistical approach to problems of cosmology. 
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, 1-43.
</p>
<p>Entekhabi, D., Rodriguez-Iturbe, I., &amp; Eagleson, P. S. (1989). Probabilistic 
representation of the temporal rainfall process by a modified Neyman-Scott 
Rectangular Pulses Model: Parameter estimation and validation. 
<em>Water Resources Research</em>, 25(2), 295-302.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IndNHNeyScot">IndNHNeyScot</a></code>, <code><a href="#topic+DepNHPPqueue">DepNHPPqueue</a></code>, <code><a href="#topic+DepNHPPMarked">DepNHPPMarked</a></code>, <code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Generation of three dependent Neyman-Scott processes with  normal distances 
set.seed(123)
lambdaParent&lt;-runif(100,0,0.1)

DepNHNeyScot(lambdaParent=lambdaParent, d=3, lambdaNumP = c(2,3,2),
	 dist = "normal", sigmaC = c(3,2,2),fixed.seed=123)

</code></pre>

<hr>
<h2 id='DepNHPPMarked'>Generating dependent  point processes from  a marked Poison Process</h2><span id='topic+DepNHPPMarked'></span>

<h3>Description</h3>

<p> This function  generates <code class="reqn">d</code> dependent  (homogeneous or nonhomogeneous) point processes 
using a marked Poisson process, where the marks are generated by a Markov chain process defined by a  transition matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepNHPPMarked(lambdaTot, MarkovM, inival = 1, dplot=TRUE, fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepNHPPMarked_+3A_lambdatot">lambdaTot</code></td>
<td>
<p>Numeric vector. Intensity values  of the Poisson process used to generate the dependent processes.</p>
</td></tr>
<tr><td><code id="DepNHPPMarked_+3A_markovm">MarkovM</code></td>
<td>
<p>Matrix. Trasition probabilities of  the d-state Markov chain used to generate the marks of the process.</p>
</td></tr>
<tr><td><code id="DepNHPPMarked_+3A_inival">inival</code></td>
<td>
<p>Optional. Initial  mark value used to generate the series of marks.</p>
</td></tr>
<tr><td><code id="DepNHPPMarked_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  marginal processes  are plotted.</p>
</td></tr>
<tr><td><code id="DepNHPPMarked_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. Value used to set the seed 
in random generation processes; if it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="DepNHPPMarked_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Points  of the marked Poisson process are generated in continuous time, using the  following procedure: 
First, a trajectory of the underlying Poisson process is generated.  Then, the  mark series is generated 
using a d-state Markov chain. The mark series takes values in 1,2,...,d and determines in which of the d processes  
the points occur.
</p>
<p>The  marginal processes defined by the marks  are not Poisson  unless the generated marks are
independent observations,  see Isham (1980).  
</p>
<p>A transition matrix <code class="reqn">P = (p_{ij})</code> with equal rows leads to <code class="reqn">d</code> independent point processes, and the more 
similar the rows of P, the less dependent the resulting processes.   The spectral gap (<code><a href="#topic+SpecGap">SpecGap</a></code>) 
measures  the dependence between the generated processes,   see Abaurrea et al. (2014).
</p>
<p>Tha marginal processes of the marked process can be optionally plotted using <code>dplot=TRUE</code>.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>A list of  <code class="reqn">d</code> vectors,  containing the occurrence points in each  marginal point process. The name of the 
elements of the list are N1, N2,..., Nd.</p>
</td></tr>
<tr><td><code>posNHG</code></td>
<td>
<p>Numeric vector of the occurrences times of the generated Poisson process.</p>
</td></tr>
<tr><td><code>mark</code></td>
<td>
<p>Vector of the  generated marks.</p>
</td></tr>
<tr><td><code>lambdaTot</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>MarkovM</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>,  22(1), 127-144.
</p>
<p>Isham, V. (1980). Dependent thinning of point processes. <em>J. Appl. Probab.</em>, 17(4), 987-95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DepNHPPqueue">DepNHPPqueue</a></code>, <code><a href="#topic+DepNHNeyScot">DepNHNeyScot</a></code>, <code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code>, 
<code><a href="#topic+IndNHPP">IndNHPP</a></code>, <code><a href="#topic+SpecGap">SpecGap</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generation of three dependent  point processes using a marked PP
set.seed(123)
lambdaTot&lt;-runif(1000)/10
aux&lt;-DepNHPPMarked(lambdaTot=lambdaTot,
	MarkovM=cbind(c(0.3,0.1,0.6), c(0.1, 0.6, 0.3), c(0.6, 0.3,0.1)),fixed.seed=123)
print(cbind(aux$posNH, aux$mark))
print(aux$posNHs)
</code></pre>

<hr>
<h2 id='DepNHPPqueue'>Generating   dependent point processes by a tandem queueing network</h2><span id='topic+DepNHPPqueue'></span><span id='topic+DepNHPPqueueI'></span><span id='topic+DepNHPPqueue1'></span>

<h3>Description</h3>

<p>It  generates <code class="reqn">d</code> dependent  (homogeneous or nonhomogeneous)  Poisson processes  
using  <code class="reqn">d-1</code>  queues in tandem.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepNHPPqueue(lambda, d,   T=NULL,  nEv=NULL,  nserv="infty", Clambda=TRUE,
	            ddist='exp',argd=1,dplot=TRUE, fixed.seed=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepNHPPqueue_+3A_lambda">lambda</code></td>
<td>
<p>Numeric value or vector. Intensity  of  the first Poisson process. If  its length is 1,
homogeneous processes are generated.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_d">d</code></td>
<td>
<p>Integer. Number of dependent processes to be generated.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_t">T</code></td>
<td>
<p>Optional. Positive integer. Length of the period where the point are  going to be generated. 
Only used in homogeneous processes (if lambda is a constant).</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_nev">nEv</code></td>
<td>
<p>Optional. Positive integer. Number of points to be generated in the processs. Only used in homogeneous processes.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_clambda">Clambda</code></td>
<td>
<p>Optional logical  flag. Only used in nonhomogeneous processes. If it is TRUE, the intensity vectors of the generated point 
processes is calculated.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_nserv">nserv</code></td>
<td>
<p>Optional.  Number of servers in the queue system; only two  values are possible: 1 or &quot;infty&quot; if the  number of servers is infinity.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_ddist">ddist</code></td>
<td>
<p>Character string.  Identification of the probability distribution of the  serving time. It must be one 
of the  names of the probability distributions available in the stats package, 
see <code><a href="stats.html#topic+Distributions">Distributions</a></code>; for example &quot;gamma&quot;, &quot;geom&quot;, etc.</p>
</td></tr></table>
<p>. 
</p>
<table>
<tr><td><code id="DepNHPPqueue_+3A_argd">argd</code></td>
<td>
<p>Optional. A  value, vector or a matrix (with d-1 rows) containing the arguments to be used in the probability distribution  in <code>ddist</code>; see Details.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  marginal processes  are plotted.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. Value used to set the seed 
in random generation processes; if it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="DepNHPPqueue_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation algorithm is described in Cebrian et al. (2020).
The generation of dependent homogeneous Poisson processes   can be  based on  a  M\ M\ 1 or a M\ M \ <code class="reqn">\infty</code>  
queue, and the intensity of each output process is equal to the intensity of the input process, see Burke(1956).
The generation of dependent nonhomogeneous Poisson processes  is based on  a  M(t)\ G \ <code class="reqn">\infty</code>  queue 
and the intensity of each output process is equal to the convolution  <code class="reqn">\lambda_{out}(t)=\lambda_{inp}(t)*f(t)</code>,  
where  <code class="reqn">\lambda_{inp}(t)</code> is the input intensity and <code class="reqn">f(t)</code>  the density function of the
service time, see Keilson and Servi (1994).
</p>
<p>In the homogeneous processes, the argument <code class="reqn">\lambda</code> can be  an integer or
a vector with equal values. In the first case,  the argument <code>nEv</code> or <code>T</code> must be specified;  in the second,
the length of the vector determines the length of period where the points are 
generated (as in the nonhomogeneous case).
</p>
<p>The  serving times in all the queues must have a probability distribution in the same family (<code>ddist</code>) 
but the parameters of that distribution can be different in each queue. If the parameters are  the same in all the queues, 
argument <code>argd</code>  is a numeric value (if there is only one parameter) or a  vector; if the parameters are different in each
queue,  <code>argd</code>  must be a matrix with (d-1) rows, even if there is only one parameter it must be  a (d-1) <code class="reqn">\times</code> 1 matrix.
</p>
<p>The occurrence times  in each  output process are sorted, so that the output time in row i does not always 
correspond to the input time in the same row.  The number of points in the output process may be lower than  in the input (if some outputs 
have not been observed).
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>A list of  <code class="reqn">d</code> vectors,  containing the occurrence points in each point process. The name of the 
elements in the list are N1, N2,..., Nd.</p>
</td></tr>
<tr><td><code>lambdaM</code></td>
<td>
<p>A <code class="reqn">d</code>-column matrix containing the  intensity vectors of  the <code class="reqn">d</code> dependent processes,  in nonhomogeneous processes and
if <code>Clambda=TRUE</code>. Otherwise, the input argument <code>lambda</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Burke, P. J. (1956). The Output of a Queuing System. <em>Operations Research</em>. 4(6), 699-704.
</p>
<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>
</p>
<p>Keilson, J. Servi, L.D. (1994). Networks of nonhomogeneous
M G <code class="reqn">\infty</code>. <em>J. Appl. Probab.</em>, 31, 157-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IndNHPP">IndNHPP</a></code>, <code><a href="#topic+DepNHNeyScot">DepNHNeyScot</a></code>, 
<code><a href="#topic+DepNHPPMarked">DepNHPPMarked</a></code>, <code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generation of 3 dependent HPPs, with  one server  and exponential service time equal to 10
aux&lt;-DepNHPPqueue(lambda=0.05, d=3,  nEv=25,fixed.seed=123,nserv=1, argd=0.1)
aux$posNH

#Generation of 4 dependent NHPPs, with infinity servers and different mean service times
#at each queue
lambda&lt;-runif(200,0,0.1)
aux&lt;-DepNHPPqueue(lambda=lambda, d=4, fixed.seed=123, argd=cbind(c(0.1, 0.3, 0.1)))
aux$posNH


#Generation of 3 dependent NHPPs, with infinity servers and  Gamma service times 
#with different parameters at each queue
lambda&lt;-runif(200,0,0.1)
aux&lt;-DepNHPPqueue(lambda=lambda, d=3, ddist='gamma',fixed.seed=123, 
                  argd=cbind(c(0.1, 0.3), c(1,2)))
aux$posNH

</code></pre>

<hr>
<h2 id='DepqueueNHK'>Estimating cross K-function  and envelopes for the marginal processes of a  queue</h2><span id='topic+DepqueueNHK'></span><span id='topic+DepqueueKenv'></span>

<h3>Description</h3>

<p>This function estimates the  cross K-function  between 
two (homogenous or nonhomogeneous)  point processes in time, <code class="reqn">N_x</code> and <code class="reqn">N_y</code>.  
It  is evaluated in a grid of distances <code class="reqn">r</code> and plotted. An envelope built  by simulation under the  hypothesis
that the processes are the marginal processes (the input and the output) of a queue is also plotted.
</p>
<p>It calls the auxiliary functions NHKaux, NHKaux2, NHKaux3 and DepqueueKenv, not intended for users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepqueueNHK(posx, posy, lambda,  T=NULL, nserv='infty', ddist='exp',argd=1,r=NULL, 
	typeEst=1, nsim=1000, conf=0.95,tit=NULL, cores=1,fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepqueueNHK_+3A_posx">posx</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the first point processes <code class="reqn">N_x</code>.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_posy">posy</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the second point processes <code class="reqn">N_y</code>.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_lambda">lambda</code></td>
<td>
<p>Numeric vector. Intensity values of  the input process <code class="reqn">N_x</code>.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_t">T</code></td>
<td>
<p>Optional. Positive integer. Length of the period where the point are  going to be generated. 
Only used in homogeneous processes (if lambda is a constant).</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_nserv">nserv</code></td>
<td>
<p>Optional.  Number of servers in the queue system; only two  values are possible: 1 or &quot;infty&quot; if the  number of servers is infinity.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_ddist">ddist</code></td>
<td>
<p>Character string.  Identification of the probability distribution of the  serving time. It must be one of the  names of the probability distributions available in the stats package, 
see <code><a href="stats.html#topic+Distributions">Distributions</a></code>; for example &quot;gamma&quot;, &quot;geom&quot;, etc.</p>
</td></tr></table>
<p>. 
</p>
<table>
<tr><td><code id="DepqueueNHK_+3A_argd">argd</code></td>
<td>
<p>Optional. Numeric  value or vector  containing the arguments to be used in the probability distribution  in <code>ddist</code>.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector.  Grid values where  the K-function  must be evaluated. If it  is NULL, a default vector is used; 
see Details.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_typeest">typeEst</code></td>
<td>
<p>Optional. Two possible values: 1 or 2. They determine which one of the two  available estimators  
of the function <code class="reqn">K_{ij}</code> has to be used; see Details. </p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_nsim">nsim</code></td>
<td>
<p>Optional. Numeric value.  Number of simulations  to obtain the envelope.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_conf">conf</code></td>
<td>
<p>Optional. Numeric value  in (0,1). Confidence level of the envelope for the K-function.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_tit">tit</code></td>
<td>
<p>Optional.  Title to be used in the plot of the K-function. </p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the calculations. </p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="DepqueueNHK_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the cross K function  between two (homogenous or nonhomogeneous)  point processes 
in time, <code class="reqn">N_x</code> and <code class="reqn">N_y</code>. Two different estimators are available, see  <code><a href="#topic+NHK">NHK</a></code> for  details.
</p>
<p>An envelope for the cross K function is built  under the hypothesis that the  processes are the input and the 
output processes of a queue.  The envelope is based on simulations, where processes generated by
<code><a href="#topic+DepNHPPqueue">DepNHPPqueue</a></code> are used. The distribution of the serving time is specified
in arguments <code>ddist</code> and  <code>argd</code>. The queue can have one or infinity servers.
</p>
<p>If argument <code>r</code> is NULL,   the following r-grid is used to evaluate the function
</p>
<p>r1&lt;-max(20, floor(T/20))
</p>
<p>r&lt;-seq(1,r1,by=2)
</p>
<p>if (length(r)&gt;200) r&lt;-seq(1,r1,length.out=200)
</p>
<p>where <code>T</code> is the length of the observed period.
</p>


<h3>Value</h3>

<p> A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Vector of values <code class="reqn">r</code> where the cross K-function is estimated.</p>
</td></tr>
<tr><td><code>NHKr</code></td>
<td>
<p>Estimated values of  <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KenvL</code></td>
<td>
<p>Lower bounds of the envelope of<code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KenvU</code></td>
<td>
<p>Upper bounds of the envelope of <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the observed period of the processes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+NHK">NHK</a></code>, <code><a href="#topic+DepNHPPqueue">DepNHPPqueue</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Observed process: independent Poisson processes
set.seed(123)
T&lt;-1000
lambda1&lt;-runif(T,0,0.05)
dendist&lt;- dexp(c(1:T), 1)
lambda2&lt;-convolve(lambda1,rev(dendist),type='o')[1:T]
posx&lt;-simNHPc(lambda = lambda1, fixed.seed = 134)$posNH
posy&lt;-simNHPc(lambda = lambda2, fixed.seed = 135)$posNH

DepqueueNHK(posx=posx, posy=posy, lambda=lambda1,  ddist='exp',argd=1, 
	r=seq(1,40, by=5), fixed.seed=123,nsim=500)

#Observed process: input and output processes  of a queue
#aux&lt;-DepNHPPqueue(lambda=lambda1, d=2, fixed.seed=123, argd=1, dplot=FALSE)$posNH
#DepqueueNHK(posx=aux[[1]], posy=aux[[2]], lambda=lambda1,  ddist='exp',argd=1, 
#	r=seq(1,40, by=5), fixed.seed=123)

	

</code></pre>

<hr>
<h2 id='DistObs'>Calculates the set of close points and the mean distance in a vector of processes,
for each point in the first process</h2><span id='topic+DistObs'></span><span id='topic+calcdist'></span>

<h3>Description</h3>

<p>Given  a set of two or three processes, this function calculates the set of close points and 
the mean distance for each point in the  first process.
</p>
<p>It calls  the functions  <code><a href="#topic+calcdist">calcdist</a></code>, not intended for the users, and <code><a href="#topic+uniongentri">uniongentri</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistObs(posx, posy, posz=NULL, info = FALSE, PA = FALSE, procName=c('X','Y','Z'),...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistObs_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the first process.</p>
</td></tr>
<tr><td><code id="DistObs_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the second process.</p>
</td></tr>
<tr><td><code id="DistObs_+3A_posz">posz</code></td>
<td>
<p>Optional. Numeric vector. Position of the occurrence points in the third process.</p>
</td></tr>
<tr><td><code id="DistObs_+3A_info">info</code></td>
<td>
<p>Optional logical flag. If it is TRUE,  information about the generated points is showed  on the screen and
dotcharts  and bivariate charts of the  occurrence points of the processes are displayed.</p>
</td></tr>
<tr><td><code id="DistObs_+3A_pa">PA</code></td>
<td>
<p>Optional logical flag. If it is TRUE, the close point relation  is
broadened by including the previous and the following points to the overlapping
intervals.</p>
</td></tr>
<tr><td><code id="DistObs_+3A_procname">procName</code></td>
<td>
<p>Vector of character strings. Labels for the first, second and third processes.</p>
</td></tr>
<tr><td><code id="DistObs_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>,  if  argument <em>info=&quot;TRUE&quot;</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of two or three  point proccesses,  for each  point <code class="reqn">t_{x_i}</code> in the first process of the set,
this function calcultes its set of close points  and the mean distance
to its close points. The definition of set of close points can be found in  Abaurrea et al. (2015),
and the  distances  are defined as <code class="reqn">|t_{y_j}-t_{x_i}|</code> if there are two processes, and 
as <code class="reqn">|t_{y_j}-t_{x_i}|+|t_{z_k}-t_{x_i}|</code>  if there are three.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DistTri</code></td>
<td>
<p>The vector of the mean distances of   points <code class="reqn">t_{x_i}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>, 22(1), 127-144.</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndNH">TestIndNH</a></code>, <code><a href="#topic+DistSim">DistSim</a></code>, <code><a href="#topic+uniongentri">uniongentri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TxBHZ)
dateT&lt;-cbind(TxBHZ$year,TxBHZ$month,TxBHZ$day)  #year, month and day of the month
BivEv&lt;-CPSPPOTevents(N1=TxBHZ$TxH,N2=TxBHZ$TxZ,thres1=36.4, thres2=37.8, date=dateT)
aux&lt;-DistObs(BivEv$Px1, BivEv$Px2, BivEv$Px12,info = TRUE)
</code></pre>

<hr>
<h2 id='DistShift'>Generates  by translation a vector  of independent  processes,   and calculates the set of close points 
and the mean distance  for each point in  the first  process</h2><span id='topic+DistShift'></span>

<h3>Description</h3>

<p>This function generates   a vector  of two (or three) independent  processes,  conditionally on the first one,   
by shifting the second (and the third) process. 
</p>
<p>It also calculates the set of close points and the  mean distance  in the generated vector, 
for each point <code class="reqn">t_{x_i}</code> in the first process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistShift(posx,posy,posz=NULL, T,  shii1, shii2=NULL, PA = FALSE, info=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistShift_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the first process.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the second process.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_posz">posz</code></td>
<td>
<p>Optional. Numeric vector. Position of the occurrence points in the third process.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period of the processes.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_shii1">shii1</code></td>
<td>
<p>Numeric value. Distance used to shift the points in the second process. It must be a positive 
value lower than  T.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_shii2">shii2</code></td>
<td>
<p>Optional. Numeric value. Distance used to shift the points in the third process. It must be NULL, 
if there are two processes, and a positive value lower than T, if there are three.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_pa">PA</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, the close point relation  is
broadened by including the previous and the following points to the overlapping intervals.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_info">info</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE,  information about the generated points is shown  
on the screen and dotcharts  and bivariate charts of the  occurrence points of the three processes 
are displayed.</p>
</td></tr>
<tr><td><code id="DistShift_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the functions <code><a href="graphics.html#topic+plot">plot</a></code> and  <code><a href="graphics.html#topic+dotchart">dotchart</a></code> 
if  the argument <code>info=T</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is  mainly used  in the application of the Lotwicck- Silverman approach, see Lotwick and Silverman (1982),    to  generate  a pair of independent
processes with the same marginal distributions than the observed ones. These processes are used for example to build  
a test to assess  independence between two or three processes, see <code><a href="#topic+TestIndLS">TestIndLS</a></code>.
</p>
<p>The key idea is to wrap  the processes onto a  circumference by identifying the opposite sides of the time interval where they are observed.
The first process is fixed, while the others are shifted over the circumference a  given amount. 
The idea of this translation is to  keep the  marginal distribution of the processes   but  to break any dependence between them, without the 
need of parametric models to describe the  marginal patterns. 
</p>
<p>The function  also calculates the set of close points and the  mean distance 
for each point <code class="reqn">t_{x_i}</code> in the first process, in the  new shifted vector of processes.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DistTri</code></td>
<td>
<p>The vector of the mean distances of   points <code class="reqn">t_{x_i}</code> in the shifted processes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lotwick, H.W. and Silverman, B.W. (1982). Methods for analysing Spatial processes of several types of points. 
<em>J.R. Statist. Soc. B</em>, 44(3), pp. 406-13
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndLS">TestIndLS</a></code>, <code><a href="#topic+DistSim">DistSim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
lambdax&lt;-runif(200, 0.01,0.17)
set.seed(124)
lambday&lt;-runif(200, 0.015,0.15)
set.seed(125)
lambdaz&lt;-runif(200, 0.005,0.1)
posx&lt;-simNHPc(lambda=lambdax, fixed.seed=123)$posNH
posy&lt;-simNHPc(lambda=lambday, fixed.seed=123)$posNH
posz&lt;-simNHPc(lambda=lambdaz, fixed.seed=123)$posNH

aux&lt;-DistShift(posx=posx, posy=posy, posz=posz, T=200, shii1=59, shii2=125 )

</code></pre>

<hr>
<h2 id='DistSim'>Generates a vector  of independent  processes,   and calculates the set of close points 
and the mean distance  for each point in  the first  process</h2><span id='topic+DistSim'></span><span id='topic+DistSimfix'></span>

<h3>Description</h3>

<p>This function generates   a vector  of two (or three) independent homogeneous or nonhomogeneous 
processes  conditionally on the first one,  by simulating the second (and  the third) process  using a parametric model 
(Poisson processes or  Neyman-Scott  cluster processes).  
</p>
<p>It also calculates the set of close points  and the  mean distance in the generated vector, for each point <code class="reqn">t_{x_i}</code> 
in the first process. 
</p>
<p><code>DistSimfix</code> allows to  fix a seed in the  generation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistSim(posx, NumProcess=2, type = "Poisson", lambdaMarg = NULL, 
	lambdaParent = NULL, lambdaNumP=NULL, dist = "normal", sigmaC = 1, 
	minC = -1, maxC = 1, PA = FALSE,info=FALSE,...)

DistSimfix(posx, NumProcess=2, type = "Poisson", lambdaMarg = NULL, 
	lambdaParent = NULL,lambdaNumP=NULL, dist = "normal", sigmaC = 1, 
	minC = -1, maxC = 1, PA = FALSE,info=FALSE,fixed.seed=1,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistSim_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the first process.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_numprocess">NumProcess</code></td>
<td>
<p>Optional. Integer equal to 2 or 3,  the number of processes in the vector.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_type">type</code></td>
<td>
<p>Optional. Label &quot;Poisson&quot; or &quot;PoissonCluster&quot;. Type of point processes to be generated. 
Up to now, only two types are available: Poisson processes (&quot;Poisson&quot;) and Neyman-Scott cluster 
processes  (&quot;PoissonCluster&quot;).</p>
</td></tr>
<tr><td><code id="DistSim_+3A_lambdamarg">lambdaMarg</code></td>
<td>
<p>Two-column matrix. Only used when <em>type=&quot;Poisson&quot;</em>. Each column
is the intensity  <code class="reqn">\lambda (t)</code> used  to generate the processes.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_lambdaparent">lambdaParent</code></td>
<td>
<p>Numeric vector. Only used when <em>type=&quot;PoissonCluster&quot;</em>. Intensity values  
of the Poisson process used to generate the  centres of the clusters of the Neyman-Scott process.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_lambdanump">lambdaNumP</code></td>
<td>
<p>Numeric vector (length <code class="reqn">\le 2</code>). Only used when <em>type=&quot;PoissonCluster&quot;</em>. 
Mean values of the number of sons in each  process. If its length is 1 and <code>NumProcess=2</code>,
the same value is used for both	processes.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_dist">dist</code></td>
<td>
<p>Optional. Label &quot;normal&quot; or &quot;uniform&quot;. Only used when <em>type=&quot;PoissonCluster&quot;</em>.   
Distribution  used to generate the  point distances in each cluster.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_sigmac">sigmaC</code></td>
<td>
<p>Optional. Numeric vector.  Only used when <em>type=&quot;PoissonCluster&quot;</em> and  <em>dist=&quot;normal&quot;</em>.
Standard deviation of the normal distribution.   If its length	is  1 and <code>NumProcess=2</code>,
the same value is used for both processes.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_minc">minC</code></td>
<td>
<p>Optional. Numeric vector. Only used when <em>type=&quot;PoissonCluster&quot;</em> and  <em>dist=&quot;uniform&quot;</em>.
Lower bounds of the  Uniform distribution.  If its length is 1 and <code>NumProcess=2</code>,
the same value is used for both processes.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_maxc">maxC</code></td>
<td>
<p>Optional. Numeric vector. Only used when <em>type=&quot;PoissonCluster&quot;</em> and  <em>dist=&quot;uniform&quot;</em>.
Upper bounds of the  Uniform distribution. If its length is 1 and <code>NumProcess=2</code>,
the same value is used for both processes.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_pa">PA</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, the close point relation  is
broadened by including the previous and the following points to the overlapping intervals.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_info">info</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE,  information about the generated points is shown  
on the screen and dotcharts  and bivariate charts of the  occurrence points of the three processes 
are displayed.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. Only available in <code>DistSimfix</code>. Integer value used to set the seed 
in random generation procedures.</p>
</td></tr>
<tr><td><code id="DistSim_+3A_...">...</code></td>
<td>
<p>Further arguments to be passes to  the functions <code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+dotchart">dotchart</a></code> if  argument
<code>info=T</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is  mainly used  in the application of a parametric bootstrap approach   to  generate  a pair of independent
processes with the same marginal distributions than the observed ones. To that aim, the first process is fixed and the others are generated using a parametric model.
These processes are used for example to build  a test to assess the independecne
between two or three processes, see <code><a href="#topic+TestIndNH">TestIndNH</a></code>.
</p>
<p>Two types of processes (Poisson, &quot;Poisson&quot;, and Neyman-Scott cluster 
processes,&quot;PoissonCluster&quot;)  can be generated. Generation of nonhomogeneous Poisson processes is done using the inversion algorithm, see 
<code><a href="#topic+simNHPc">simNHPc</a></code>. For generation of Neyman-Scott processes, see <code><a href="#topic+IndNHNeyScot">IndNHNeyScot</a></code>.
</p>
<p>The function  also calculates the set of close points and the  mean distance 
for each point <code class="reqn">t_{x_i}</code> in the first process, in the  new generated vector of processes.
</p>
<p>The lenght of the period where the processes are generated is  determined by the length of 
the argument <code>lambdaParent</code> or the number of rows of <code>lambdaMarg</code>. Homogenous  processes  are  generated if the intensity vectors in  <code>lambdaParent</code> or in
<code>lambdaMarg</code> are  constant (that is if  all the values in the vector are equal).
</p>
<p>If a seed  must be fixed in the  generation process, function <code>DistSimfix</code>  has to be used.
The functions <code>DistSim</code> and <code>DistSimfix</code> are  similar, the difference is that the first one uses a 
random seed  to generate the processes, while the second one uses a seed  set by the argument <code>fixed.seed</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DistTri</code></td>
<td>
<p>Vector of the mean distances of each point <code class="reqn">t_{x_i}</code>  calculated in the generated processes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>, 22(1), 127-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndNH">TestIndNH</a></code>, <code><a href="#topic+DistObs">DistObs</a></code>,  <code><a href="#topic+IndNHNeyScot">IndNHNeyScot</a></code>,  
<code><a href="#topic+simNHPc">simNHPc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Calculation of the distances in a vector of  three independent Poisson processes   
#conditionally to the first one

set.seed(123)
lambdax&lt;-runif(200, 0.01,0.15)
posaux&lt;-simNHPc(lambda=lambdax, fixed.seed=123)$posNH

set.seed(124)
lambday&lt;-runif(200, 0.005,0.1)
set.seed(125)
lambdaz&lt;-runif(200, 0.005,0.2)

DistSimfix(posx=posaux, type = "Poisson", lambdaMarg = cbind(lambday,lambdaz), 
	fixed.seed=123, info=TRUE)
#DistSim(posx=posaux, type = "Poisson", lambdaMarg = cbind(lambday,lambdaz))

</code></pre>

<hr>
<h2 id='DutilleulPlot'>A graphical test to assess independence between two point processes</h2><span id='topic+DutilleulPlot'></span><span id='topic+fn3'></span>

<h3>Description</h3>

<p>This function  applies the  Diggle's randomization testing procedure  
extended  by Dutilleul(2011), and performs a plot  which  graphically  assesses 
the independence between two point proceses. 
It is implemented for  homogenous and non homogenous Poisson processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DutilleulPlot(posx, posy, lambday, nsim = 1000, lenve = c(0.025, 0.975), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DutilleulPlot_+3A_posx">posx</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the first  point process.</p>
</td></tr>
<tr><td><code id="DutilleulPlot_+3A_posy">posy</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in the second  point process.</p>
</td></tr>
<tr><td><code id="DutilleulPlot_+3A_lambday">lambday</code></td>
<td>
<p>Numeric vector. Intensity vector  of the  second point process. If the process is homogeneous, 
a vector of length  <code class="reqn">T</code>,  with equal values must be provided; see Details.</p>
</td></tr>
<tr><td><code id="DutilleulPlot_+3A_nsim">nsim</code></td>
<td>
<p>Optional. Positive integer. Number of simulations  to calculate the confidence band.</p>
</td></tr>
<tr><td><code id="DutilleulPlot_+3A_lenve">lenve</code></td>
<td>
<p>Optional.  Numeric vector. The order of the lower and the upper percentiles  to build 
the confidence band.</p>
</td></tr>
<tr><td><code id="DutilleulPlot_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This  graphical approach is  based on the comparison of the 
cumulative relative frequency  of the nearest neighbour distances 
between the points in  the two  observed processes, with their counterpart in  two  independent processes  with the same 
marginal distributions, which are obtained by simulation.
</p>
<p>The function plots the cumulative relative frequency of the observed processes and a 
confidence band calculated from <em>nsim</em> simulated independent processes.
</p>
<p>The length of the observed period  <code class="reqn">T</code> is determined by the length of the argument  <code>lambday</code>.
</p>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>quantobs</code></td>
<td>
<p>Vector of the observed percentiles of the nearest neighbour distances.</p>
</td></tr>
<tr><td><code>enve1</code></td>
<td>
<p>Vector of the lower bounds of the confidence band.</p>
</td></tr>
<tr><td><code>enve2</code></td>
<td>
<p> Vector of the upper bounds of the confidence band.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dutilleul, P. (2011), <em>Spatio-temporal heterogeneity: Concepts and analyses</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndNH">TestIndNH</a></code>, <code><a href="#topic+CondTest">CondTest</a></code>,<code><a href="#topic+nearestdist">nearestdist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Two independent NHPPs
set.seed(123)
lambdax&lt;-runif(200, 0.01,0.1)
set.seed(124)
lambday&lt;-runif(200, 0.015,0.15)
posx&lt;-simNHPc(lambdax,fixed.seed=123)$posNH
posy&lt;-simNHPc(lambday, fixed.seed=123)$posNH

aux&lt;-DutilleulPlot(posx, posy, lambday,  nsim = 100)


#Two dependent Neyman Scott processes
#set.seed(123)
#lambdaParent&lt;-runif(200)/10
#DepPro&lt;-DepNHNeyScot(lambdaParent=lambdaParent, d=2, lambdaNumP = 3, 
#	dist = "normal", sigmaC = 3,fixed.seed=123)
#posx&lt;-DepPro$PP1
#posy&lt;-DepPro$PP2
#aux&lt;-DutilleulPlot(posx, posy, lambday, nsim = 100)
</code></pre>

<hr>
<h2 id='IndNHNeyScot'>Generating a vector of independent  Neyman-Scott cluster processes</h2><span id='topic+IndNHNeyScot'></span>

<h3>Description</h3>

<p> This function  generates a vector of <code class="reqn">d</code> independent  
(homogeneous or nonhomogeneous) Neyman-Scott cluster processes  with  independent 
trajectories of  cluster centers with the same intensity. 
</p>
<p>It calls the auxiliary function <code>GenSons</code> (not intended for the
users), see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndNHNeyScot(lambdaParent, d, lambdaNumP = 1,  dist = "normal", 
	sigmaC = 1, minC = -1, maxC = 1, dplot=TRUE,fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndNHNeyScot_+3A_lambdaparent">lambdaParent</code></td>
<td>
<p>Numeric vector. Intensity   of the Poisson process used to generate 
the  independent trajectories of the cluster centres of the Neyman-Scott process.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_d">d</code></td>
<td>
<p>Integer. Number of independent processes to be generated.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_lambdanump">lambdaNumP</code></td>
<td>
<p>Optional. Numeric vector. Mean values of the number of sons of each marginal process. If its length
is equal to 1, the same value is used to generate all the processes.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_dist">dist</code></td>
<td>
<p>Optional. Label &quot;normal&quot; or &quot;uniform&quot;. Distribution  used to generate the  point locations of each 
cluster.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_sigmac">sigmaC</code></td>
<td>
<p>Optional. Numeric vector. Standard deviation of the normal distribution.  Only used if dist=&quot;normal&quot;. 
If its length is equal to 1, the same value is used in the d processes.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_minc">minC</code></td>
<td>
<p>Optional. Numeric  vector. Lower bounds of the  Uniform distribution. Only used if dist=&quot;uniform&quot;. If its length
is equal to 1, the same value is used in the d processes.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_maxc">maxC</code></td>
<td>
<p>Optional. Numeric  vector. Upper bounds of the  Uniform distribution. Only used if dist=&quot;uniform&quot;. If its length
is equal to 1, the same value is used in the d processes.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  generated marginal  processes  are plotted.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. Value used to set the seed 
in random generation processes; if it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="IndNHNeyScot_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr></table>


<h3>Details</h3>

<p>A Neyman-Scott  process is a Poisson cluster process  where the points in each cluster are randomly
distributed around the cluster center, see Neyman and Scott (1958) and Entekhabi et al. (1989).  
</p>
<p>To generate each process in the vector, an independent  trajectory  of the Poisson 
process of the cluster centres  is generated first. Then, the number  of points in each cluster  
is generated using a Poisson distribution  with mean value <code class="reqn">\mu_{P_i}</code>  (i=1,...d). Finally, 
the distances to the centre of each point  in the cluster is be generated using  
one of the two distributions available, N(0, sigmaC)  or Uniform(minC, maxC).  
</p>
<p>The lenght of the period where the processes are generated is  determined by the length of 
the argument <code>lambdaParent</code>.
</p>
<p>Homogenous  processes  are  generated if the intensity vector  <code>lambdaParent</code> is  constant 
(that is if  all the values are equal).
</p>
<p>The marginal processes of the generated vector  can be optionally plotted.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>A list of  <code class="reqn">d</code> vectors, each one containing the time occurrences of one of the 
marginal processes. The name of the elements of the list are N1, N2,...,Nd.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>
<p>Neyman, J., &amp; Scott, E. L. (1958). Statistical approach to problems of cosmology. 
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, 1-43.
</p>
<p>Entekhabi, D., Rodriguez-Iturbe, I., &amp; Eagleson, P. S. (1989). Probabilistic 
representation of the temporal rainfall process by a modified Neyman-Scott 
Rectangular Pulses Model: Parameter estimation and validation. 
<em>Water Resources Research</em>, 25(2), 295-302.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DepNHNeyScot">DepNHNeyScot</a></code>, <code><a href="#topic+IndNHPP">IndNHPP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
lambda&lt;-runif(1000)/10

IndNHNeyScot(lambdaParent=lambda, d=3, lambdaNumP = c(2,3,2),  dist = "normal", 
	sigmaC = 2, fixed.seed=123)

</code></pre>

<hr>
<h2 id='IndNHPP'>Generates trajectories of independent Poisson processes</h2><span id='topic+IndNHPP'></span>

<h3>Description</h3>

<p>This function  generates independent  Poisson processes, which can be homogeneous or nonhomogeneous 
depending on the  value of the intensity vectors. </p>


<h3>Usage</h3>

<pre><code class='language-R'>IndNHPP(lambdas,dplot=TRUE, fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndNHPP_+3A_lambdas">lambdas</code></td>
<td>
<p>Matrix where each column contains the  intensity vector to generate a Poisson process.</p>
</td></tr>
<tr><td><code id="IndNHPP_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the  marginal  processes  are plotted.</p>
</td></tr>
<tr><td><code id="IndNHPP_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="IndNHPP_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of generated processes is determined by the number of columns of the argument <code>lambdas</code>. The lenght of the 
period where the processes are generated is  determined by the number of rows of <code>lambdas</code>.
</p>
<p>Homogenous  processes  are  generated if the corresponding intensity vector is  constant (that is if  all the rows 
of the corresponding column are equal).
</p>
<p>For the generation algorithm of each Poisson process, see <code><a href="#topic+simNHPc">simNHPc</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>posNHs</code></td>
<td>
<p>A list of  d vectors, each one containing the time occurrences of  the independent NHPPs. The name of the 
elements of the list are N1, N2,..., Nd.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+IndNHNeyScot">IndNHNeyScot</a></code>, <code><a href="#topic+simNHPc">simNHPc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
lambdas&lt;-cbind(runif(500)/10, rep(0.05,500))

IndNHPP(lambdas=lambdas, fixed.seed=123)

</code></pre>

<hr>
<h2 id='IndTestPP-package'>Tests of Independence  and Analysis of Dependence between  Point Processes in Time</h2><span id='topic+IndTestPP-package'></span><span id='topic+IndTestPP'></span>

<h3>Description</h3>

<p>It provides  a  general framework to analyse dependence between point processes in time. The package
includes several parametric and non-parametric tests to check the independence  
between two or more homogeneous and nonhomogeneous point processes and some tools to characterize the dependence
between them, if it exists. In addition, it includes functions for generating and analysing dependent
point processes in time with different types of dependence.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> IndTestPP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-08-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Ana C. Cebrian 
Maintainer: Ana C. Cebrian  &lt;acebrian@unizar.es&gt;
</p>

<hr>
<h2 id='IntMPP'>Simulated intervals  in a vector of point processes</h2><span id='topic+IntMPP'></span><span id='topic+funMPPGen'></span><span id='topic+firstt'></span><span id='topic+NumI'></span>

<h3>Description</h3>

<p>This function calculates a  point estimation and a confidence interval
for a  given parameter related to a  vector of point processes using a Monte Carlo  
(or parametric bootstrap) approach. The  estimator of the parameter must be a function 
of the occurrence points of   the (possibly dependent)  marginal  processes of the vector of processes.
</p>
<p>It calls the auxiliary function <code>funMPPGen</code> (not intended
for the users), see  Details.</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntMPP(funMPP.name, funMPP.args, fun.name, fun.args = NULL, nsim=1000, clevel = 0.95, 
    cores = 1, fixed.seed = NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntMPP_+3A_funmpp.name">funMPP.name</code></td>
<td>
<p>Name of the function defining the  distribution of the vector of point processes.</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_funmpp.args">funMPP.args</code></td>
<td>
<p>Additional arguments for the function <code>funMPP.name</code>.</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_fun.name">fun.name</code></td>
<td>
<p>Name of the function to calculate the estimation of the parameters. 
The  first argument of this function must be  a list called posNH.</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_fun.args">fun.args</code></td>
<td>
<p>A list whose elements are the additional arguments for the function <code>fun.name</code>.</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to be carried out.</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of the interval. A value  in (0,1).</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_cores">cores</code></td>
<td>
<p>Optional.  Number of cores of the computer to be used in the calculations. Default: one core is used.</p>
</td></tr>
<tr><td><code id="IntMPP_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function  calculates a  point estimation and a confidence interval of a  
parameter related to a  vector of point processes. It calls the auxiliary function <code>funMPPGen</code>, which generates  a  sample of  vectors of processes  using a
parametric model. The parameter of interest  is estimated using  each process in that sample, so that a sample of values 
of the estimator is obtained. The mean of that sample is the point estimator, and the adequate sample percentiles give 
the lower and upper bounds of the confidence interval. 
</p>
<p>The parametric model is specified by the arguments <code>funMPP.name</code> and 
<code>funMPP.args</code>.  Functions <code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code>, <code><a href="#topic+DepNHNeyScot">DepNHNeyScot</a></code>, <code><a href="#topic+DepNHPPqueue">DepNHPPqueue</a></code> and 
<code><a href="#topic+DepNHPPMarked">DepNHPPMarked</a></code> can be used  as input of the argument <code>funMPP.name</code> to generate
the corresponding vector of processes. 
</p>
<p>The  considered estimator must be a function of the occurrence points of the vector of processes and  
any additional arguments, provided by argument  <code>fun.args</code>, which must be a list. The first argument of the
function <code>fun.name</code> must be  a list called <code>posNH</code> whose elements are  numeric vectors containing the
occurrence points of  each point process in the vector. For example,  the first element of the output list of 
<code><a href="#topic+DepNHCPSP">DepNHCPSP</a></code>  can be used as first argument of <code>fun.name</code>.
</p>


<h3>Value</h3>

<p> A list with elements:
</p>
<table>
<tr><td><code>valmed</code></td>
<td>
<p>Point estimation (mean value) of the parameter.</p>
</td></tr>
<tr><td><code>valinf</code></td>
<td>
<p>Lower bound of the generated interval.</p>
</td></tr>
<tr><td><code>valsup</code></td>
<td>
<p>Upper bound of the generated interval.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>fixed.seed</code></td>
<td>
<p>Input argument.</p>
</td></tr>	
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Calculation of the point estimation and  95% intervals based on 1000 simulations 
#of the   number of accurrences in each marginal process of a bivariate  Neyman-Scot process
# in  the time interval [100,200]
#NumI calculates the   number of occurrences in interval I in each element of  the list posNH

set.seed(123)
lambdai&lt;-runif(1000,0.01,0.02)

aux&lt;-IntMPP(funMPP.name="DepNHNeyScot", funMPP.args=list(lambdaParent=lambdai,d=2, 
  lambdaNumP=c(2,1), dplot=FALSE), fun.name="NumI", fun.args = list(I=c(100,200)), 
  fixed.seed = 125) 


# Calculation of the point estimation and a 95% interval based on 1000 simulations 
#of the  first occurrence time in  a multivariate  CPSP with d=3
#firstt calculates the  minimim occurrence time of  all the elements in the list posNH

#set.seed(124)
#lambdaij&lt;-runif(1000,0.005,0.02)
#set.seed(125)
#lambdaijk&lt;-runif(1000,0.001,0.02)
#lambdaiM&lt;-cbind(lambdai,lambdai, lambdai, lambdaij, lambdaij, lambdaij, lambdaijk)
#aux&lt;-IntMPP(funMPP.name="DepNHCPSP",funMPP.args=list(lambdaiM=lambdaiM,d=3,dplot=FALSE), 
#  fun.name="firstt", fixed.seed = 125) 


</code></pre>

<hr>
<h2 id='nearestdist'>Distance to the nearest point</h2><span id='topic+nearestdist'></span><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Given the  occurrence points in two  point processes, this function   calculates
for each point in  the first process,  the  distance to the nearest occurrence point in the second process. </p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestdist(posx, posy)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestdist_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Occurrence times of the  points in the first  point process.</p>
</td></tr>
<tr><td><code id="nearestdist_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Occurrence times of the  points in the second  point process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance between two points <code class="reqn">x_i</code> and <code class="reqn">y_i</code> in  a point  process in time, is the  absolute value of their 
difference: <code class="reqn">|x_i-y_i|</code>.
</p>
<p>To obtain the vector of nearest points, this function applies to each point in <code>posx</code>,  
the function <code>pdist</code>, which calculates the distance to its nearest point  in  <code>posy</code>.
</p>


<h3>Value</h3>

<p>Vector  of  the distances to the  nearest point in the second process for each point in the 
first process.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DutilleulPlot">DutilleulPlot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>posx&lt;-c(3,8,23,54,57,82)
posy&lt;-c(2,8,14,16,29,32,45,55,65)
nearestdist(posx, posy)
</code></pre>

<hr>
<h2 id='NHD'>Estimating the D-function</h2><span id='topic+NHD'></span><span id='topic+NHDaux'></span><span id='topic+prodN2'></span><span id='topic+HDFaux'></span><span id='topic+nearestD'></span><span id='topic+nMenr'></span>

<h3>Description</h3>

<p>This function estimates
the  cross nearest neighbour distance distribution function, D,  between 
two sets, <code class="reqn">C</code> and <code class="reqn">D</code>, of (homogenous or nonhomogeneous) point processes. 
The D-function  is evaluated in a grid of  values <code class="reqn">r</code>,  and it
can be optionally plotted.
</p>
<p>It calls the auxiliary functions NHDaux and  other  functions, not intended for users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NHD(lambdaC, lambdaD, T=NULL,Ptype='inhom', posC, typeC=1, posD, typeD=1, 
	r = NULL, dplot = TRUE, tit = "D(r)",...)</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="NHD_+3A_lambdac">lambdaC</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point processes in 
<code class="reqn">C</code>. If there is only one process in <code class="reqn">C</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHD_+3A_lambdad">lambdaD</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point process in 
<code class="reqn">D</code>. If there is only one process in <code class="reqn">D</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHD_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period. It only must be specified
if the number of rows in <code>lambdaC</code> and <code>lambdaD</code> is 1.</p>
</td></tr>
<tr><td><code id="NHD_+3A_ptype">Ptype</code></td>
<td>
<p>Optional. Label: &quot;hom&quot; or &quot;inhom&quot;.  The first one indicates that 
all the point processes in sets <code class="reqn">C</code> and <code class="reqn">D</code> are homogeneous.</p>
</td></tr>
<tr><td><code id="NHD_+3A_posc">posC</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in all the point processes in <code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code id="NHD_+3A_typec">typeC</code></td>
<td>
<p>Numeric vector with the same length as <code>posC</code>.  Code of the point process  
in <code class="reqn">C</code>  where  points in <code>posC</code> have occurred. See Details.</p>
</td></tr>
<tr><td><code id="NHD_+3A_posd">posD</code></td>
<td>
<p>Numeric vector. Occurrence times of the  points in all the point processes in <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="NHD_+3A_typed">typeD</code></td>
<td>
<p>Numeric vector with the same length as <code>posD</code>.  Code of the point process  
in <code class="reqn">D</code>  where  points in <code>posD</code> have occurred. </p>
</td></tr>
<tr><td><code id="NHD_+3A_r">r</code></td>
<td>
<p>Numeric vector.  Values where the D-function  must be evaluated. If it  is NULL, a default 
vector is used, see Details.</p>
</td></tr>
<tr><td><code id="NHD_+3A_dplot">dplot</code></td>
<td>
<p>Optional. A logical flag. If it is TRUE,  the D-function is plotted.</p>
</td></tr>
<tr><td><code id="NHD_+3A_tit">tit</code></td>
<td>
<p>Optional.  The title to be used in the plot of the D-function. </p>
</td></tr>
<tr><td><code id="NHD_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information about the processes  is provided by  arguments <code>posC</code>,  the vector of all the occurrence times  
in the processes in <code class="reqn">C</code>, and  <code>typeC</code>,  the vector of  the code of the point process  in set <code class="reqn">C</code>   where each point in <code>posC</code> has occurred;  
the second set D is characterized analogously by <code>typeD</code> and <code>posD</code>. 
</p>
<p>This function estimates the  D-function  between 
two sets,  <code class="reqn">C</code> and <code class="reqn">D</code>, of (homogenous or nonhomogeneous)  point processes, see 
Cebrian et al (2020) for details of the estimation.  The  D-function  is the distribution 
function of the  distances from a point in a process 
in <code class="reqn">C</code> to the nearest point in a process  <code class="reqn">D</code>. 
In homogeneous proceesses, it  estimates the probability that  at least one point  
in a process  in set <code class="reqn">D</code> occurs  at a  distance lower than <code class="reqn">r</code> of a given point in a process in set <code class="reqn">C</code>. 
If the processes are nonhomogenous, the  inhomogenous  version of the function, adjusted for time varying intensities, 
is used. It is calculated using the Hanisch estimator,  see Van Lieshout (2006)
Small values of the D-function suggest  few points in processes in <code class="reqn">D</code> in the r-neighbourhood 
of points of processes in <code class="reqn">C</code>.
Large values indicate that points in processes in <code class="reqn">D</code> are attracted by those of processes in <code class="reqn">C</code>.
</p>
<p>For inference about independence of the processes, K and J-functions should be used.
</p>
<p>If argument <code>r</code> is NULL,   the following grid is used to evaluate the function
</p>
<p>r1&lt;-max(20, floor(T/20))
</p>
<p>r&lt;-seq(1,r1,by=2)
</p>
<p>if (length(r)&gt;200) r&lt;-seq(1,r1,length.out=200)
</p>


<h3>Value</h3>

<p> A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Vector of values <code class="reqn">r</code> where the  D-function is estimated.</p>
</td></tr>
<tr><td><code>NHDr</code></td>
<td>
<p>Estimated values of <code class="reqn">D_{CD}(r)</code>.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the observed period.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>
<p>Van Lieshout, M.N.M. (2006) A J-function for marked point patterns. AISM, 58, 235-259. DOI
10.1007/s10463-005-0015-7
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NHK">NHK</a></code>, <code><a href="#topic+NHJ">NHJ</a></code>, <code><a href="#topic+NHF">NHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Sets C and D with  independent NHPPs
set.seed(123)
lambda1&lt;-runif(500, 0.05, 0.1)
set.seed(124)
lambda2&lt;-runif(500, 0.01, 0.2)
pos1&lt;-simNHPc(lambda=lambda1, fixed.seed=123)$posNH
pos2&lt;-simNHPc(lambda=lambda2, fixed.seed=123)$posNH
aux&lt;-NHD(lambdaC=lambda1, lambdaD=lambda2, posC=pos1, typeC=1, posD=pos2, typeD=1)
aux$NHDr

#Example with  independent NHPPs
#pos3&lt;-simNHPc(lambda=lambda1, fixed.seed=321)$posNH
#pos4&lt;-simNHPc(lambda=lambda2, fixed.seed=321)$posNH
#aux&lt;-NHD(lambdaC=cbind(lambda1,lambda2),lambdaD=cbind(lambda1,lambda2),posC=c(pos1,pos2),
# typeC=c(rep(1, length(pos1)), rep(2, length(pos2))), posD=c(pos3, pos4),
# typeD=c(rep(1, length(pos3)), rep(2, length(pos4))))
#aux$NHDr

</code></pre>

<hr>
<h2 id='NHF'>Estimating the F-function</h2><span id='topic+NHF'></span><span id='topic+NHFaux'></span>

<h3>Description</h3>

<p>This function estimates the  F-function in a set  of homogenous or nonhomogeneous  point processes, <code class="reqn">D</code>. 
The F-function  is evaluated in a grid of  values <code class="reqn">r</code>,  and it can be optionally plotted.
</p>
<p>It calls the auxiliary functions NHFaux and other functions not intended for users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NHF(lambdaD, T=NULL, Ptype='inhom', posD, typeD=1, r=NULL,L=NULL, dplot=TRUE,
tit='F(r)',...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NHF_+3A_lambdad">lambdaD</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point process in 
<code class="reqn">D</code>. If there is only one process in <code class="reqn">D</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHF_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period. It only must be specified
if the number of rows in <code>lambdaC</code> and <code>lambdaD</code> is 1.</p>
</td></tr>
<tr><td><code id="NHF_+3A_ptype">Ptype</code></td>
<td>
<p>Optional. Label: &quot;hom&quot; or &quot;inhom&quot;.  The first one indicates that 
all the point processes in sets <code class="reqn">C</code> and <code class="reqn">D</code> are homogeneous. </p>
</td></tr>
<tr><td><code id="NHF_+3A_posd">posD</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in all the point processes in <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="NHF_+3A_typed">typeD</code></td>
<td>
<p>Numeric vector with the same length as <code>posD</code>.  Code of the point process  
in <code class="reqn">D</code>  where the point  in the same row in <code>posD</code>  has occurred. The code must be the  
column number  where the intensity of that process  is in matrix <code>lambdaD</code>. </p>
</td></tr>
<tr><td><code id="NHF_+3A_r">r</code></td>
<td>
<p>Numeric vector. Values where the  F-function  must be evaluated. If it  is NULL, a default 
vector is used, see Details</p>
</td></tr>
<tr><td><code id="NHF_+3A_l">L</code></td>
<td>
<p>Optional. Numeric vector. Values in the observed period used to calculate 
the  F-function. If it  is NULL, a default vector is used, see Details.</p>
</td></tr>
<tr><td><code id="NHF_+3A_dplot">dplot</code></td>
<td>
<p>Optional. Logical flag. If it is true, the  F-function is plotted.</p>
</td></tr>
<tr><td><code id="NHF_+3A_tit">tit</code></td>
<td>
<p>Optional.  The title to be used in the plot of the F-function.</p>
</td></tr>
<tr><td><code id="NHF_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information about the processes  is provided by  arguments <code>posD</code>,  the vector of all the occurrence times  
in the processes in <code class="reqn">C</code>, and  <code>typeD</code>,  the vector of  the code of the point process  in set <code class="reqn">D</code>
where each point in <code>posD</code> has occurred.
</p>
<p>This function estimates the  F-function in a set <code class="reqn">D</code> of homogenous or nonhomogeneous time point processes,  see 
Cebrian et al (2020) for details of the estimation. 
The F-function, also known as empty space function,  is the distribution function of 
the distances from an arbitray point in  the space to the nearest point in a process in <code class="reqn">D</code>.
In homogeneous processes, it  estimates  the probability that  at least one point  in  processes
in <code class="reqn">D</code> occurs  at a  distance lower than <code class="reqn">r</code> of an arbitray point in the space. 
If the processes are nonhomogenous, the  inhomogenous  version of the function, adjusted for time varying intensities, 
is used. 
</p>
<p>If argument <code>r</code> is NULL,   the following grid is used to evaluate the function
</p>
<p>r1&lt;-max(20, floor(T/20))
</p>
<p>r&lt;-seq(1,r1,by=2)
</p>
<p>if (length(r)&gt;200) r&lt;-seq(1,r1,length.out=200)
</p>
<p>If argument <code>L</code> is NULL, the following grid is used 
</p>
<p>L &lt;- seq(1, T, by = 2)
if (length(L) &gt; 5000)  L &lt;- seq(1, T, by = round((T - 1)/199))
</p>


<h3>Value</h3>

<p> A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Vector of values <code class="reqn">r</code> where the  F-function is estimated.</p>
</td></tr>
<tr><td><code>NHFr</code></td>
<td>
<p>Estimated values of <code class="reqn">F_{D}(r)</code>.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the observed period of the process.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Grid of  L values to calculate the F-funtion. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NHK">NHK</a></code>, <code><a href="#topic+NHJ">NHJ</a></code>, <code><a href="#topic+NHD">NHD</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
lambda1&lt;-runif(500, 0.05, 0.1)
pos1&lt;-simNHPc(lambda=lambda1, fixed.seed=123)$posNH

aux&lt;-NHF(lambdaD=lambda1, posD=pos1, typeD=1)
aux$NHFr

#Set D with two processes ***
#lambda2&lt;-runif(1000, 0.01, 0.2)
#pos2&lt;-simNHPc(lambda=lambda2, fixed.seed=123)$posNH
#aux&lt;-NHF(lambdaD=cbind(lambda1,lambda2), posD=c(pos1,pos2), 
#	typeD=c(rep(1, length(pos1)), rep(2, length(pos2))) )
#aux$NHFr

</code></pre>

<hr>
<h2 id='NHJ'>Estimating the cross J-function  and testing independence</h2><span id='topic+NHJ'></span><span id='topic+NHJaux'></span><span id='topic+NHDFaux'></span><span id='topic+Jenv'></span>

<h3>Description</h3>

<p>This function estimates the  cross J-function  between 
two sets, <code class="reqn">C</code> and <code class="reqn">D</code>,  of (homogenous or nonhomogeneous)  point processes in time.  
It  is evaluated in a grid of distances <code class="reqn">r</code>,  and it can be optionally plotted.  A test to 
assess the independence between the sets of processes, based on  the cross J-function,   is also implemented.
</p>
<p>It calls the auxiliary functions NHJaux and Jenv, not intended for users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NHJ(lambdaC, lambdaD,T=NULL, Ptype="inhom", posC, typeC=1, posD, typeD=1, r=NULL,
L=NULL,test=FALSE,nTrans=100, rTest=NULL, conf=0.95, dplot=NULL, 
tit=c("J-function","D-function","F-function"),mfrow=NULL,cores=1,fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NHJ_+3A_lambdac">lambdaC</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point processes in 
<code class="reqn">C</code>. If there is only one process in <code class="reqn">C</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_lambdad">lambdaD</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point process in 
<code class="reqn">D</code>. If there is only one process in <code class="reqn">D</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period. It only must be specified
if the number of rows in <code>lambdaC</code> and <code>lambdaD</code> is 1.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_ptype">Ptype</code></td>
<td>
<p>Optional. Label: &quot;hom&quot; or &quot;inhom&quot;.  The first one indicates that 
all the point processes in sets <code class="reqn">C</code> and <code class="reqn">D</code> are homogeneous.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_posc">posC</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in all the point processes in <code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_typec">typeC</code></td>
<td>
<p>Numeric vector with the same length as <code>posC</code>.  Code of the point process  
in <code class="reqn">C</code>  where the points in <code>posC</code>  have occurred. See Details.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_posd">posD</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in all the point processes in <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_typed">typeD</code></td>
<td>
<p>Numeric vector with the same length as <code>posD</code>.  Code of the point process  
in <code class="reqn">D</code>  where the points in <code>posD</code>  have occurred.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector. Values where J-function  must be evaluated. If it  is NULL, a default 
vector is used, see Details.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_l">L</code></td>
<td>
<p>Optional. Numeric vector. Values in the observed period used to calculate 
the J-function. If it  is NULL, a default vector is used, see Details.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_test">test</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, a  test of independence
and a 95%  envelope   for the J-function are calculated.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_ntrans">nTrans</code></td>
<td>
<p>Optional. Numeric value. Only used if <code>test=TRUE</code>. Number of translations to
be performed in the test and envelope calculation.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_rtest">rTest</code></td>
<td>
<p>Optional. Numeric value. Maximum value of <code class="reqn">r</code> used to calculate the 
independence test statistc, see Details.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_conf">conf</code></td>
<td>
<p>Optional. Numeric value  in (0,1). Confidence level of the envelope for the J-function.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_dplot">dplot</code></td>
<td>
<p>Optional. Label &quot;JDF&quot; or &quot;J&quot;. If it is &quot;JDF&quot;, plots of J, D and F-functions
are displayed. If it is &quot;J&quot;, only  J-function is plotted.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_tit">tit</code></td>
<td>
<p>Optional.  A vector with  one or  three titles to be used in the plots of J, D and F-functions.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_mfrow">mfrow</code></td>
<td>
<p>Optional. Argument to be passed to <code><a href="graphics.html#topic+par">par</a></code> for the plot of the J-function.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the calculations. </p>
</td></tr>
<tr><td><code id="NHJ_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="NHJ_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information about the processes  is provided by  arguments <code>posC</code>,  the vector of all the occurrence times  
in the processes in <code class="reqn">C</code>, and  <code>typeC</code>,  the vector of  the code of the point process  in set <code class="reqn">C</code>
where each point in <code>posC</code> has occurred;  the second set <code class="reqn">D</code> is characterized analogously by 
<code>typeD</code> and <code>posD</code>. 
</p>
<p>This function estimates the cross J-function  between 
two sets,  <code class="reqn">C</code> and <code class="reqn">D</code>, of (homogenous or nonhomogeneous)  time point processes, see 
Cebrian et al (2020) for details of the estimation. The J-function measures the interpoint dependence between points in any 
of the processes in <code class="reqn">D</code>,  and points in any of the processes in <code class="reqn">C</code>, adjusted for time varying intensity in the case 
of nonhomogenous processes. The cross J-function is defined as <code class="reqn">J_{CD}(r)=(1-D_{CD}(r))/(1-F_D(r))</code>, 
if <code class="reqn">F_D(r)&lt;1</code> and it is not calculated otherwise.  It compares <code class="reqn">D_{CD}(r)</code>, the distribution 
function of the distances from a  point  in any of the processes in set <code class="reqn">C</code> to the nearest
point in any of the processes in set <code class="reqn">D</code>,  to <code class="reqn">F_{D}(r)</code>,  the distribution 
function of the distances from a fixed point   in the space to the nearest
point in any of the processes in set <code class="reqn">D</code>.
</p>
<p>If argument <code>r</code> is NULL,   the following grid is used to evaluate the function
</p>
<p>r1&lt;-max(20, floor(T/20))
</p>
<p>r&lt;-seq(1,r1,by=2)
</p>
<p>if (length(r)&gt;200) r&lt;-seq(1,r1,length.out=200)
</p>
<p>If argument <code>L</code> is NULL, the following grid is used 
</p>
<p>L &lt;- seq(1, T, by = 2)
if (length(L) &gt; 5000)  L &lt;- seq(1, T, by = round((T - 1)/199))
</p>
<p>Testing independence:
</p>
<p>If the processes in <code class="reqn">C</code>  are independent of the processes in <code class="reqn">D</code> given the marginal structure 
of the processes, the J-funtion is equal to 1, since D(r)=F(r). Hence, deviations of J(r) estimations from 1, 
suggest dependence betweent  the two sets of processes. The test  statistic is based on the  mean
of   values <code class="reqn">|J(r)-1|</code> evaluated in a given grid of r values.
</p>
<p>A test based on a Lotwick-Silverman approach, see Lotwick and Silverman (1982),  is implemented. This test 
provides a nonparametric way to test independence given the marginal intensities of the processes. 
Using the Lotwick-Silverman approach,  not only the p-value of 
the test  but also an envelope for the <code class="reqn">J(r)</code> values is calculated. 
</p>
<p>In point  processes, dependence often appears between close observations,  and  with high <code class="reqn">r</code> values it is more 
difficult that the J-function is able to discriminate  between dependent and independent processes.
By this reason, the argument <code>rTest</code> allows us to fix a maximum value of <code class="reqn">r</code>
so that only <code class="reqn">J(r)</code> estimations for <code class="reqn">r&lt;rTest</code>  will be used to
calculate the  test statistic. The value <code>rTest</code> is  drawn in the plot of the J-function
as a vertical grey line.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Vector of values <code class="reqn">r</code> where the J-function is estimated.</p>
</td></tr>
<tr><td><code>NHJr</code></td>
<td>
<p>Estimated values of <code class="reqn">J_{CD}(r)</code>.</p>
</td></tr>
<tr><td><code>NHDr</code></td>
<td>
<p>Estimated values of <code class="reqn">D_{CD}(r)</code>.</p>
</td></tr>
<tr><td><code>NHFr</code></td>
<td>
<p>Estimated values of <code class="reqn">F_{D}(r)</code>.</p>
</td></tr>
<tr><td><code>JenvL</code></td>
<td>
<p>Lower bounds of the envelope of <code class="reqn">J_{CD}(r)</code>.</p>
</td></tr>
<tr><td><code>JenvU</code></td>
<td>
<p>Upper bounds of the envelope for <code class="reqn">J_{CD}(r)</code>.</p>
</td></tr>
<tr><td><code>JStatOb</code></td>
<td>
<p>Observed value of the statistic.</p>
</td></tr>
<tr><td><code>JStatTr</code></td>
<td>
<p>Sample of the values of the  test statistic obtained by random translations.</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>
<p>P-value of the independence test.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the observed period of the process.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Grid of  L values to calculate  the F-funtion. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>
<p>Cronie, O. and van Lieshout, M.N.M. (2015). Summary statistics for inhomogeneous marked point
processes. <em>Ann Inst Stat Math</em>. 
</p>
<p>Lotwick, H.W. and Silverman, B.W. (1982). Methods for analysing Spatial processes of several types of points. 
<em>J.R. Statist. Soc. B</em>, 44(3), pp. 406-13
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NHK">NHK</a></code>, <code><a href="#topic+NHD">NHD</a></code>, <code><a href="#topic+NHF">NHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(120)
lambda1&lt;-runif(100, 0.05, 0.1)
set.seed(121)
lambda2&lt;-runif(100, 0.01, 0.2)
pos1&lt;-simNHPc(lambda=lambda1,fixed.seed=123)$posNH  
pos2&lt;-simNHPc(lambda=lambda2,fixed.seed=123)$posNH

aux&lt;-NHJ(lambdaC=lambda1, lambdaD=lambda2, posC=pos1,nTrans=50, 
	 posD=pos2, rTest=7, dplot='J', cores=1,test=TRUE)
aux$pv

#Sets with two processes
#pos3&lt;-simNHPc(lambda=lambda1,fixed.seed=300)$posNH  
#pos4&lt;-simNHPc(lambda=lambda2,fixed.seed=30)$posNH 
#aux&lt;-NHJ(lambdaC=cbind(lambda1,lambda2), lambdaD=cbind(lambda1,lambda2), 
#	posC=c(pos1,pos2), typeC=c(rep(1, length(pos1)), rep(2, length(pos2))), 
#	posD=c(pos3, pos4), typeD=c(rep(1, length(pos3)), rep(2, length(pos4))), 
#	dplot='J', test=TRUE)
#aux$pv
</code></pre>

<hr>
<h2 id='NHK'>Estimating cross K-function   and testing independence</h2><span id='topic+NHK'></span><span id='topic+NHKaux'></span><span id='topic+NHKaux2'></span><span id='topic+NHKaux3'></span><span id='topic+Kenv'></span>

<h3>Description</h3>

<p>This function estimates the  cross K-function  between 
two sets, <code class="reqn">C</code> and <code class="reqn">D</code>,  of (homogenous or nonhomogeneous)  point processes in time.  
It  is evaluated in a grid of distances <code class="reqn">r</code>,  and it can be optionally plotted.  A test to 
assess the independence between the sets of processes, based on  the cross K-function,   is also implemented.
</p>
<p>It calls the auxiliary functions NHKaux, NHKaux2, NHKaux3 and Kenv, not intended for users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NHK(lambdaC, lambdaD, T=NULL, posC, typeC=1, posD, typeD=1, r=NULL, test=TRUE,
 typeEst=2,  nTrans=1000, conf=0.95, rTest=NULL, typePlot=" ",tit=NULL,
 cores=1,fixed.seed=NULL,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NHK_+3A_lambdac">lambdaC</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point processes in 
<code class="reqn">C</code>. If there is only one process in <code class="reqn">C</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHK_+3A_lambdad">lambdaD</code></td>
<td>
<p>A matrix of positive values. Each column is the intensity vector of one of the point process in 
<code class="reqn">D</code>. If there is only one process in <code class="reqn">D</code>, it can be a vector or even a numeric value
if the process is homogeneous.</p>
</td></tr>
<tr><td><code id="NHK_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period. It only must be specified
if all the processes are homogeneous, that is if the number of rows in <code>lambdaC</code> and <code>lambdaD</code> is 1.</p>
</td></tr>
<tr><td><code id="NHK_+3A_posc">posC</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in all the point processes in <code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code id="NHK_+3A_typec">typeC</code></td>
<td>
<p>Numeric vector with the same length as <code>posC</code>.  Code of the point process  
in <code class="reqn">C</code>  where the points in <code>posC</code>  have occurred; see Details.</p>
</td></tr>
<tr><td><code id="NHK_+3A_posd">posD</code></td>
<td>
<p>Numeric vector.  Occurrence times of the  points in all the point processes in <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="NHK_+3A_typed">typeD</code></td>
<td>
<p>Numeric vector with the same length as <code>posD</code>.  Code of the point process  
in <code class="reqn">D</code>  where the points in <code>posD</code>  have occurred.  </p>
</td></tr>
<tr><td><code id="NHK_+3A_r">r</code></td>
<td>
<p>Optional. Numeric vector.  Grid values where  the K-function  must be evaluated. If it  is NULL, 
a default vector is used; see Details.</p>
</td></tr>
<tr><td><code id="NHK_+3A_test">test</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, a  test of independence
and a 95%  envelope   for the K-function are calculated.</p>
</td></tr>
<tr><td><code id="NHK_+3A_typeest">typeEst</code></td>
<td>
<p>Optional. Two possible values: 1 or 2, which determines which one of the two  available estimators  
of the function <code class="reqn">K_{ij}</code> has to be used; see Details.</p>
</td></tr>
<tr><td><code id="NHK_+3A_ntrans">nTrans</code></td>
<td>
<p>Optional. Numeric value. Only used if <code>test=TRUE</code>. Number of translations to
be performed in the test and envelope calculation.</p>
</td></tr>
<tr><td><code id="NHK_+3A_conf">conf</code></td>
<td>
<p>Optional. Numeric value  in (0,1). Confidence level of the envelope for the K-function.</p>
</td></tr>
<tr><td><code id="NHK_+3A_rtest">rTest</code></td>
<td>
<p>Optional. Numeric value. Maximum value of <code class="reqn">r</code> used to calculate the test statistc, see Details.</p>
</td></tr>
<tr><td><code id="NHK_+3A_typeplot">typePlot</code></td>
<td>
<p>Optional. Character string. If it is &quot;Kfun&quot;  or &quot;Kest&quot; a plot of the values <code class="reqn">\hat K_{xy}(r)</code>  
or <code class="reqn">\hat K_{xy}(r)/2r</code> is shown. With any other value, no plot is carried out.</p>
</td></tr>
<tr><td><code id="NHK_+3A_tit">tit</code></td>
<td>
<p>Optional.  Title to be used in the plot of the K-function. </p>
</td></tr>
<tr><td><code id="NHK_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the calculations. </p>
</td></tr>
<tr><td><code id="NHK_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="NHK_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information about the processes  is provided by  arguments <code>posC</code>,  the vector of all the occurrence times  
in the processes in <code class="reqn">C</code>, and  <code>typeC</code>,  the vector of  the code of the point process  in set <code class="reqn">C</code>   
where each point in <code>posC</code> has occurred; the second set <code class="reqn">D</code> is characterized analogously by 
<code>typeD</code> and <code>posD</code>. 
</p>
<p>This function estimates the cross K function  between 
two sets,  <code class="reqn">C</code> and <code class="reqn">D</code>, of (homogenous or nonhomogeneous)  point processes. Two different estimators
are available, see Cebrian et al (2020) for  details. The cross K-function measures the  dependence between two 
point processes (or  two sets of point processes) and counts the expected number of points  in any 
of the processes in <code class="reqn">D</code>,  within a given distance of a point in any of the processes in <code class="reqn">C</code>, 
adjusted for time varying intensity in the case of nonhomogenous processes.  
The cross K-function  of independent  Poisson processes  is the length of the considered intervals,  
<code class="reqn">K_{CD}(r)=2r</code>. Then, values <code class="reqn">K_{CD}(r)/2r&gt;1</code> indicate attraction between the 
processes, while values lower than 1 indicate repulsion.
</p>
<p>If argument <code>r</code> is NULL,   the following r-grid is used to evaluate the function
</p>
<p>r1&lt;-max(20, floor(T/20))
</p>
<p>r&lt;-seq(1,r1,by=2)
</p>
<p>if (length(r)&gt;200) r&lt;-seq(1,r1,length.out=200)
</p>
<p>Testing independence:
</p>
<p>In order to test the independence hypothesis using this function,  a test based on a Lotwick-Silverman approach,
see Lotwick and Silverman (1982),  is implemented. This test provides a nonparametric way to test independence 
given the marginal intensities of the processes. Using the Lotwick-Silverman approach,  not only the p-value of 
the test  but also an envelope for the <code class="reqn">K(r)</code> values is calculated. The test  statistic is based on the  mean
of   values <code class="reqn">K(r)/(2r)</code> evaluated in a given grid of r values.
</p>
<p>In point  processes, dependence often appears between close observations,  and  with high <code class="reqn">r</code> values it is more difficult that the
K-function is able to discriminate  between dependent and independent processes.
By this reason, the argument <code>rTest</code> allows us to fix a maximum value of <code class="reqn">r</code>
so that only K(r) estimations for <code class="reqn">r&lt;rTest</code>  will be used to
calculate the  test statistic. The value <code>rTest</code> is  drawn in the plot of the K-function
as a vertical grey line.
</p>


<h3>Value</h3>

<p> A list with elements:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Vector of values <code class="reqn">r</code> where the cross K-function is estimated.</p>
</td></tr>
<tr><td><code>NHKr</code></td>
<td>
<p>Estimated values of  <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KenvL</code></td>
<td>
<p>Lower bounds of the envelope of<code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KenvU</code></td>
<td>
<p>Upper bounds of the envelope of <code class="reqn">K_{ij}(r)</code>.</p>
</td></tr>
<tr><td><code>KStatOb</code></td>
<td>
<p>Observed value of the test statistic.</p>
</td></tr>
<tr><td><code>KStatTr</code></td>
<td>
<p>Sample of the values of the  test statistic obtained by random translations.</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>
<p>P-value of the test.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the observed period of the processes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>
<p>Lotwick, H.W. and Silverman, B.W. (1982). Methods for analysing Spatial processes of several types of points. 
<em>J.R. Statist. Soc. B</em>, 44(3), pp. 406-13
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NHD">NHD</a></code>, <code><a href="#topic+NHJ">NHJ</a></code>, <code><a href="#topic+NHF">NHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(122)
lambda1&lt;-runif(100, 0.05, 0.1)
set.seed(121)
lambda2&lt;-runif(100, 0.01, 0.2)
pos1&lt;-simNHPc(lambda=lambda1, fixed.seed=123)$posNH 
pos2&lt;-simNHPc(lambda=lambda2, fixed.seed=123)$posNH

aux&lt;-NHK(lambdaC=lambda1, lambdaD=lambda2, posC=pos1, posD=pos2, typePlot='Kest',
	nTrans=200, cores=1, typeEst=2, fixed.seed=120)
aux$pv

#Sets with two processes
#pos3&lt;-simNHPc(lambda=lambda1, fixed.seed=321)$posNH
#pos4&lt;-simNHPc(lambda=lambda2, fixed.seed=321)$posNH
#aux&lt;-NHK(lambdaC=cbind(lambda1,lambda2), lambdaD=cbind(lambda1,lambda2), posC=c(pos1,pos2), 
#	typeC=c(rep(1, length(pos1)), rep(2, length(pos2))), posD=c(pos3, pos4), 
#	typeD=c(rep(1, length(pos3)), rep(2, length(pos4))),  typeplot='Kest', fixed.seed=120)
#aux$pv

</code></pre>

<hr>
<h2 id='PlotICPSP'>Plotting  the  occurrence points  of the indicator processes in  a CPSP</h2><span id='topic+PlotICPSP'></span>

<h3>Description</h3>

<p>This function  plots the points in the three indicator processes <code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  
and <code class="reqn">N_{(12)}</code> of a bivariate Common Poisson shock process (CPSP). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotICPSP(posi1,posi2, posi12, T, date=NULL,axispoints=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotICPSP_+3A_posi1">posi1</code></td>
<td>
<p>Numeric vector  of the  points in  <code class="reqn">N_{(1)}</code> </p>
</td></tr>
<tr><td><code id="PlotICPSP_+3A_posi2">posi2</code></td>
<td>
<p>Numeric vector  of the  points in  <code class="reqn">N_{(2)}</code></p>
</td></tr>
<tr><td><code id="PlotICPSP_+3A_posi12">posi12</code></td>
<td>
<p>Numeric vector  of the  points in  <code class="reqn">N_{(12)}</code></p>
</td></tr>
<tr><td><code id="PlotICPSP_+3A_t">T</code></td>
<td>
<p>Numeric value. The length of the observed period of the CPSP.</p>
</td></tr>
<tr><td><code id="PlotICPSP_+3A_date">date</code></td>
<td>
<p>Optional. A vector indicating the date of each observation to be used in the axis of the plot.</p>
</td></tr>
<tr><td><code id="PlotICPSP_+3A_axispoints">axispoints</code></td>
<td>
<p>Optional. Numeric vector with the  points in the time index in which axis ticks and labels 
(from <code>date</code>) will be drawn.</p>
</td></tr>
<tr><td><code id="PlotICPSP_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to  the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A CPSP <code class="reqn">N</code> can be  decomposed into three independent indicator processes: <code class="reqn">N_{(1)}</code>, <code class="reqn">N_{(2)}</code>  
and <code class="reqn">N_{(12)}</code>,  the processes of the points  occurring
only in the first  marginal process, only in the second and  in both of them (simultaneous points).
</p>
<p>The  points in  the three indicator processes are plotted versus the time index. If  one of the arguments <code>date</code> and
<code>axispoints</code> is NULL, default axis are used. Otherwise, the values in <code>axispoints</code> are used as
the  points in the time index in which axis ticks and labels from <code>date</code> are drawn.
</p>


<h3>Value</h3>

<p>A plot.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CPSPpoints">CPSPpoints</a></code>, <code><a href="#topic+PlotMCPSP">PlotMCPSP</a></code>, <code><a href="#topic+PlotMargP">PlotMargP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(TxBHZ)
T&lt;-length(TxBHZ$TxH)
dateT&lt;-cbind(TxBHZ$year,TxBHZ$month,TxBHZ$day)  #year, month and day of the month
marca&lt;- c(1:length(TxBHZ$TxH))[c(1,diff(dateT[,1]))==1]  #points at first day of the year
BivEv&lt;-CPSPPOTevents(N1=TxBHZ$TxH,N2=TxBHZ$TxZ,thres1=37.8, thres2=36.4, date=dateT, 
                     axispoints=marca)
PlotICPSP(posi1=BivEv$Px1,posi2=BivEv$Px2, posi12=BivEv$Px12, T=T)
PlotICPSP(posi1=BivEv$Px1,posi2=BivEv$Px2, posi12=BivEv$Px12, T=T, date=dateT[,1], 
          axispoints=marca)
</code></pre>

<hr>
<h2 id='PlotMargP'>Plotting  the  occurrence points  of a vector of point processes</h2><span id='topic+PlotMargP'></span>

<h3>Description</h3>

<p>This function  plots the points in the marginal processes <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code>,..., <code class="reqn">N_{d}</code>   
of a vector of point processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMargP(listpos, T, date=NULL,axispoints=NULL, tcex=1.2, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotMargP_+3A_listpos">listpos</code></td>
<td>
<p>A list of vectors. Each  element of the list  is the vector of the occurrences in a marginal process.</p>
</td></tr>
<tr><td><code id="PlotMargP_+3A_t">T</code></td>
<td>
<p>Numeric value. The length of the observed period of the processes.</p>
</td></tr>
<tr><td><code id="PlotMargP_+3A_date">date</code></td>
<td>
<p>Optional. A vector indicating the date of each observation to be used in the axis of the plot.</p>
</td></tr>
<tr><td><code id="PlotMargP_+3A_axispoints">axispoints</code></td>
<td>
<p>Optional. Numeric vector with the  points in the time index in which axis ticks and labels (from <code>date</code>)
will be drawn.</p>
</td></tr>
<tr><td><code id="PlotMargP_+3A_tcex">tcex</code></td>
<td>
<p>Optional.  cex argument, see <code><a href="graphics.html#topic+par">par</a></code>, for the text  labels in the plot.</p>
</td></tr>
<tr><td><code id="PlotMargP_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  points in  the  d marginal processes <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code> ,..., <code class="reqn">N_{d}</code>   of a  vector 
of point processes are plotted versus the time index. 
</p>
<p>If  one of the arguments <code>date</code> and <code>axispoints</code> is NULL, default axis are used. 
Otherwise, the values in <code>axispoints</code> are used as the  points in the time index in which axis ticks 
and labels, from <code>date</code>,  are drawn.
</p>


<h3>Value</h3>

<p>A plot.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PlotMCPSP">PlotMCPSP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
N1&lt;-runif(50,0,5000)
set.seed(124)
N2&lt;-runif(42,0,5000)

PlotMargP(list(N1=N1, N2=N2),T=5000)
</code></pre>

<hr>
<h2 id='PlotMCPSP'>Plotting  the  occurrence points  of the marginal processes in  a CPSP</h2><span id='topic+PlotMCPSP'></span>

<h3>Description</h3>

<p>This function  plots the points in the  two marginal processes <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code>  
of a bivariate Common Poisson shock process (CPSP). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMCPSP(pos1,pos2, T, date=NULL, axispoints=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotMCPSP_+3A_pos1">pos1</code></td>
<td>
<p>Numeric vector  of the  points in  <code class="reqn">N_{1}</code> </p>
</td></tr>
<tr><td><code id="PlotMCPSP_+3A_pos2">pos2</code></td>
<td>
<p>Numeric vector  of the  points in  <code class="reqn">N_{2}</code></p>
</td></tr>
<tr><td><code id="PlotMCPSP_+3A_t">T</code></td>
<td>
<p>Numeric value. The length of the observed period of the CPSP.</p>
</td></tr>
<tr><td><code id="PlotMCPSP_+3A_date">date</code></td>
<td>
<p>Optional. A vector indicating the date of each observation to be used in the axis of the plot.</p>
</td></tr>
<tr><td><code id="PlotMCPSP_+3A_axispoints">axispoints</code></td>
<td>
<p>Optional. Numeric vector with the  points in the time index in which axis ticks and labels 
(from <code>date</code>) will be drawn.</p>
</td></tr>
<tr><td><code id="PlotMCPSP_+3A_...">...</code></td>
<td>
<p>Further arguments to  be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  points in  the  two marginal processes <code class="reqn">N_{1}</code>, <code class="reqn">N_{2}</code>   of a bivariate CPSP are plotted versus the time index. 
The simultaneous points (points of the indicator process  <code class="reqn">N_{(12)}</code>) are drawn in red.
</p>
<p>If  one of the arguments <code>date</code> and <code>axispoints</code> is NULL, default axis are used. 
Otherwise, the values in <code>axispoints</code> are used as the  points in the time index in which axis ticks 
and labels, from <code>date</code>,  are drawn.
</p>


<h3>Value</h3>

<p>A plot.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CPSPpoints">CPSPpoints</a></code>, <code><a href="#topic+PlotICPSP">PlotICPSP</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TxBHZ)
T&lt;-length(TxBHZ$TxH)
dateT&lt;-cbind(TxBHZ$year,TxBHZ$month,TxBHZ$day)  #year, month and day of the month
marca&lt;- c(1:T)[c(1,diff(dateT[,1]))==1]  # points at  first day  of the year
BivEv&lt;-CPSPPOTevents(N1=TxBHZ$TxH,N2=TxBHZ$TxZ,thres1=37.8, thres2=36.4, date=dateT,
                    axispoints=marca)
PlotMCPSP(pos1=union(BivEv$Px1, BivEv$Px12),pos2=union(BivEv$Px2,BivEv$Px12), T=T)

marca&lt;- c(1:T)[c(1,diff(dateT[,1]))==1]
PlotMCPSP(pos1=union(BivEv$Px1, BivEv$Px12),pos2=union(BivEv$Px2,BivEv$Px12), T=T, 
	date=dateT[,1], axispoints=marca)

</code></pre>

<hr>
<h2 id='simHPc'>Generating points in a homogenous Poisson process</h2><span id='topic+simHPc'></span>

<h3>Description</h3>

<p>This function generates  a given number of occurrence points  
in a homogenous Poisson process (HPP)  in continuous time. </p>


<h3>Usage</h3>

<pre><code class='language-R'>simHPc(lambda, nEv, fixed.seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simHPc_+3A_lambda">lambda</code></td>
<td>
<p>Numeric  positive value. Intensity <code class="reqn">\lambda</code>  used to generate the HPP.</p>
</td></tr>
<tr><td><code id="simHPc_+3A_nev">nEv</code></td>
<td>
<p>Optional. Positive integer. Number of points to be generated in the HPPs.</p>
</td></tr>
<tr><td><code id="simHPc_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The points in a HPP are  generated using 
independent exponentials with mean <code class="reqn">\lambda</code>. 
</p>
<p>Points in a HPP can also be generated using <code><a href="#topic+simNHPc">simNHPc</a></code>. The main difference
is that  in <code><a href="#topic+simHPc">simHPc</a></code> the number of points to be generated  is given, while  <code><a href="#topic+simNHPc">simNHPc</a></code>
generates points in a period of a given length T.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>posN</code></td>
<td>
<p>Numeric vector. Occurrence points of the HPP.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Length of the period where the given number of points are generated.</p>
</td></tr>
<tr><td><code>fixed.seed</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ross, S.M. (2006). <em>Simulation.</em> Academic Press.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+simNHPc">simNHPc</a></code>,  <code><a href="#topic+IndNHPP">IndNHPP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aux&lt;-simHPc(lambda=0.01, nEv=50,fixed.seed=123)
aux$posH


</code></pre>

<hr>
<h2 id='simNHPc'>Generating points in a Poisson process</h2><span id='topic+simNHPc'></span><span id='topic+buscar'></span>

<h3>Description</h3>

<p>This function generates the occurrence points  
in a homogenous or nonhomogeneous Poisson process (NHPP) with  a given  intensity <code class="reqn">\lambda(t)</code>, 
in a  continuous period  of time (0, T). 
</p>
<p>It calls the auxiliary function <code>buscar</code> (not intended for the users), see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNHPc(lambda, fixed.seed=NULL, algor="Thinning")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simNHPc_+3A_lambda">lambda</code></td>
<td>
<p>Numeric vector. Intensity <code class="reqn">\lambda(t)</code>  used to generate the Poisson process.  Its length determines  
the length of the observed period.</p>
</td></tr>
<tr><td><code id="simNHPc_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="simNHPc_+3A_algor">algor</code></td>
<td>
<p> Optional. Character string.  The algorithm  used to generate the process, it can be
&quot;Inversion&quot; or &quot;Thinning&quot;; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two algorithms  to generate the NHPP points  are implemented. &quot;Inversion&quot; is based on the inversion algortihm, 
see Ross(2006), and it consists in two steps. 
First,  the points of a homogeneous Poisson process  of intensity one are generated using 
independent exponentials. Then, the  homogeneous occurrence times are transformed into 
the points  of a  nonhomogeneous process with intensity <code class="reqn">\lambda(t)</code>.
This transformation is performed by the auxiliary function <code>buscar</code> 
(not intended for the user).
</p>
<p>The algorithm &quot;Thinning&quot;, see Banerjee et al. (2014),  generates  the occurrences times
in a homogeneous Poisson process with intensity <code class="reqn">\lambda_{max}=\max_t \lambda(t)</code> and the resulting points are retained 
with probability <code class="reqn">\lambda(t_i)/\lambda_{max}</code>.
</p>
<p>The &quot;Inversion&quot; algorithm requires positive values of  the argument <code>lambda</code> and it is slower, but
the &quot;Thinning&quot; algorithm may yield excesive rejection according to Ross (2006).
</p>
<p>The lenght of the period where the processes are generated is  determined by the length of 
the argument <code>lambda</code>.
</p>
<p>Homogenous  processes  are  generated if the intensity vector  <code>lambda</code> is  constant 
(that is if all the values are equal).
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>Numeric vector. Occurrence points of the Poisson process.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>fixed.seed</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P. and Gelfand, A. E. (2014) <em>Hierarchical modeling and 
analysis for spatial data</em>.CRC Press.
</p>
<p>Ross, S.M. (2006). <em>Simulation.</em> Academic Press.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+simHPc">simHPc</a></code>,  <code><a href="#topic+IndNHPP">IndNHPP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generation  of a Homogeneous Poisson process 
aux&lt;-simNHPc(lambda=rep(0.1,200),fixed.seed=123, algor='Inversion')
aux$posNH

#Generation of a NHPP 
set.seed(123)
lambdat&lt;-runif(500, 0.01,0.1)
aux&lt;-simNHPc(lambda=lambdat,fixed.seed=123, algor='Thinning')
aux$posNH
</code></pre>

<hr>
<h2 id='SpecGap'>Stationary distribution of a matrix and its spectral gap</h2><span id='topic+SpecGap'></span>

<h3>Description</h3>

<p>This function calculates the stationary distribution of  the transition matrix 
of a Markov chain process and its spectral gap.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecGap(P)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpecGap_+3A_p">P</code></td>
<td>
<p>Matrix. It must be a markovian matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectral gap of a matrix <code class="reqn">P</code> measures the convergence speed of <code class="reqn">P</code> to a matrix <code class="reqn">P_I</code>
with  all the rows  equal to <code class="reqn">(\pi_1,\pi_2,... \pi_k)</code>, the stationary
distribution of <code class="reqn">P</code>. It takes values in [0,1].
</p>
<p>The spectral gap of a transition matrix can be used as a dependence measure between the  marginal processes
defined by a  marked Poisson procces with  discrete marks generated by a Markov chain  with that transition matrix, see
Cebrian et al (2020) for details.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>SG</code></td>
<td>
<p>Spectral gap value of the matrix.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>Vector of the stationary distribution of the matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+DepNHPPMarked">DepNHPPMarked</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-cbind(c(0.7, 0.1, 0.2), c(0.2, 0.7, 0.1), c(0.1, 0.2, 0.7))
SpecGap(P)
</code></pre>

<hr>
<h2 id='TestIndLS'>Lotwick-Silverman test  of independence between point processes</h2><span id='topic+TestIndLS'></span><span id='topic+fn2B'></span>

<h3>Description</h3>

<p>This function calculates a  test  based on the Lotwick-Silverman  (LoS) approach to study the independence 
between  two or three homogeneous point processes in time.
The statistic  is based on the close point  sets of the points in the first process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestIndLS(posx, posy, posz=NULL, T,  alpha = 0.05, nTrans = 100, PA = FALSE, 
	cores=1,fixed.seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestIndLS_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the first process.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the second process.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_posz">posz</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the third process. Only
used if there are 3 processes.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_t">T</code></td>
<td>
<p>Numeric value. Length of the observed period of the processes.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_alpha">alpha</code></td>
<td>
<p>Optional. Significance level  used to obtain  a decision (reject-no reject)  based on the  test p-value.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_ntrans">nTrans</code></td>
<td>
<p>Optional. Positive integer. Number of translations to calculate the  test.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_pa">PA</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, the close point relation  is
broadened by including the previous and the following points to the overlapping
intervals.</p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the calculations. </p>
</td></tr>
<tr><td><code id="TestIndLS_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. If it is an integer, that is the value used to set the seed 
in random generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The underlying idea  of the test is to compare, for  each  point in  the first process, the behavior  of its  set of close points 
in the  vector of observed   processes <code class="reqn">(N_x, N_y, N_z)</code>, and in  new  vectors of  independent processes with the
same marginal distribution. The new independent vectors are obtained using a LoS approach, see Lotwick and Silverman (1982):
the process <code class="reqn">N_x</code> is fixed and  second and third processes are  obtained by shifting the original ones a random amount. 
This  translation keeps the distribution of the homogeneous processes,   but breaks any dependence between them.
If the observed  behavior is significantly different,  independence is rejected. More details can be foun in Cebrian et al. (2020).
</p>
<p>The test statistic is the 
one used in <code><a href="#topic+TestIndNH">TestIndNH</a></code>, but the p-value is obtained using a  LoS approach,
so that it does not require any assumption about the marginal distribution of the processes,
not even the marginal intensities. The test <code><a href="#topic+TestIndNH">TestIndNH</a></code>,   
can be applied  to study nonhomogeneous processes, but it requires a parametric model for the second process.
</p>


<h3>Value</h3>

<p>A list with elements:    
</p>
<table>
<tr><td><code>pv</code></td>
<td>
<p>P-value of the independence test.</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>
<p>Binary variable indicating if the test is rejected (1) or not (0) at an  alpha significance level.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>Sample of the KS statistics. The first value corresponds to the observed processes and the others to the generated processes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J.  and Asin, J. (2020).   Testing  independence between two  point processes in time.
<em>Journal of Simulation and Computational Statistics</em>.
</p>
<p>Lotwick, H.W. and Silverman, B.W. (1982). Methods for analysing Spatial processes of several types of points. 
<em>J.R. Statist. Soc. B</em>, 44(3), pp. 406-13
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndNH">TestIndNH</a></code>, <code><a href="#topic+CondTest">CondTest</a></code>, <code><a href="#topic+DutilleulPlot">DutilleulPlot</a></code>, 
<code><a href="#topic+DistShift">DistShift</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Test applied to three independent HPP

posx&lt;-simNHPc(lambda=rep(0.1,200),fixed.seed=123)$posNH
posz&lt;-simNHPc(lambda=rep(0.15,200),fixed.seed=124)$posNH
posy&lt;-simNHPc(lambda=rep(0.1,200),fixed.seed=125)$posNH


aux&lt;-TestIndLS(posx, posy, posz,T=200,
	cores=1,fixed.seed=321)
aux$pv

</code></pre>

<hr>
<h2 id='TestIndNH'>Parametric bootstrap  test  of independence between point processes</h2><span id='topic+TestIndNH'></span><span id='topic+mirank'></span><span id='topic+miKS'></span><span id='topic+fn2'></span><span id='topic+fn2fix'></span>

<h3>Description</h3>

<p>This function calculates a parametric bootstrap test (PaB)  to study the independence 
between  two or three homogeneous or nonhomogeneous point processes in time.
The statistic  is based on the close point  sets of the points in the first process.  Currently, it is implemented for Poisson processes and for Neyman-Scott cluster 
processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestIndNH(posx, posy, posz=NULL,  alpha = 0.05, nsim = 100, PA = FALSE, cores = 1, 
	type = "Poisson", lambdaMarg = NULL,   lambdaParent = NULL, lambdaNumP = NULL, 
	dist = "normal", sigmaC = 1, minC = -1, maxC = 1,fixed.seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestIndNH_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the first process.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the second process.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_posz">posz</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the third process.  By default is null,
and only two processes are tested.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_alpha">alpha</code></td>
<td>
<p>Optional. Significance level  used to obtain  a decision (reject-no reject)  based on the  test p-value.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_nsim">nsim</code></td>
<td>
<p>Optional. Positive integer. Number of simulations to calculate the  test.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_pa">PA</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, the close point relation  is
broadened by including the previous and the following points to the overlapping
intervals.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the calculations. </p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_type">type</code></td>
<td>
<p>Optional. Label &quot;Poisson&quot; or &quot;PoissonCluster&quot;. Type of point processes to be generated in 
the parametric bootstrap. Up to now, only two types are available: Poisson processes (&quot;Poisson&quot;) and Neyman-Scott cluster processes  (&quot;PoissonCluster&quot;).</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_lambdamarg">lambdaMarg</code></td>
<td>
<p>Matrix of positive values and dimension <code class="reqn">T \times N_P</code> with <code class="reqn">N_P</code>=1 or 2.
Only used if <em>type=&quot;Poisson&quot;</em>. Each column is the  intensity vector to generate the  processes <code class="reqn">N_y</code> and <code class="reqn">N_z</code>.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_lambdaparent">lambdaParent</code></td>
<td>
<p>Numeric vector. Only used if <em>type=&quot;PoissonCluster&quot;</em>. Intensity vector of the  process 
used to generate the  centers of the clusters of the Neyman-Scott process.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_lambdanump">lambdaNumP</code></td>
<td>
<p>Numeric vector with 1 or 2 values. Only used if <em>type=&quot;PoissonCluster&quot;</em>.
Mean values of the number of 	sons of  the  processes to be generated. If its length	is equal to 1 and 
there are three processes, the same value is used  to generate <code class="reqn">N_y</code> and <code class="reqn">N_z</code>.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_dist">dist</code></td>
<td>
<p>Optional. Label &quot;normal&quot; or &quot;uniform&quot;.  Only used if <em>type=&quot;PoissonCluster&quot;</em>.
Distribution  used to generate the  point  distances to the centre in each cluster.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_sigmac">sigmaC</code></td>
<td>
<p>Optional. Numeric vector with 1 or 2 values.  Only used if <em>type=&quot;PoissonCluster&quot;</em>
and <em>dist='normal'</em>. Standard deviation of the normal distribution.   If its length is equal to 1, 
the same value is used in both processes.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_minc">minC</code></td>
<td>
<p>Optional. Numeric vector with 1 or 2 values. Only used if <em>type=&quot;PoissonCluster&quot;</em> and <em>dist='uniform'</em>. 
Lower bounds of the  Uniform distribution.  If its length is equal to 1 and there are three processes, the same value is used  
to generate <code class="reqn">N_y</code> and <code class="reqn">N_z</code>.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_maxc">maxC</code></td>
<td>
<p>Optional. Numeric vector with 1 or 2 values. Only used if <em>type=&quot;PoissonCluster&quot;</em> and <em>dist='uniform'</em>. 
Upper bounds of the  Uniform distribution.  If its length is equal to 1 and there are three processes, the same value is used  
to generate <code class="reqn">N_y</code> and <code class="reqn">N_z</code>.</p>
</td></tr>
<tr><td><code id="TestIndNH_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>Optional. An integer or NULL. If it is an integer, that is the value used to set the seed 
in random generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The underlying idea  of the test is to compare, for  each  point in  the first process, the behavior  of its  set of close points 
in the  vector of observed   processes <code class="reqn">(N_x, N_y, N_z)</code>, and in  new  vectors of  independent processes with the
observed  marginal distribution. The new independent vectors are obtained using a parametric bootstrap approach, 
see Abaurrea et al. (2015): the process <code class="reqn">N_x</code> is fixed and  second and third processes are   generated using a parametric model with  intensities  <code class="reqn">\lambda_y</code> and <code class="reqn">\lambda_z</code>. 
Currently, it is implemented for Poisson processes and for Neyman-Scott cluster  processes.
If the observed  behavior is significantly different,  independence is rejected. 
</p>
<p>The test statistic is  the one used in <code><a href="#topic+TestIndLS">TestIndLS</a></code>, but the p-value is obtained using a  
Monte Carlo approach if the intensities <code class="reqn">\lambda_y(t)</code> and <code class="reqn">\lambda_z(t)</code> 
are known, or a parametric bootstrap if they have  been estimated. The test <code><a href="#topic+TestIndLS">TestIndLS</a></code> 
can only be applied to  homogeneous  processes, but it does not require any assumption about
the distribution of the marginal processes.
</p>
<p>It is noteworthy that  when the test is applied, it is being assumed that the processes  follow a parametric model 
with the given intensities. If necessary,  validation of that assumption should be previously carried out.
</p>
<p>The lenght of the  observed period is  determined by the length of  the intensity vector <code class="reqn">\lambda</code>, that
is <em>lambdaParent</em> (if  <em>type=&quot;PoissonCluster&quot;</em>)  or the  first  element of the dimension of <em>lambdaMarg</em> (if 
<em>type=&quot;PoissonC&quot;</em>. It can be applied to homogeneous processes, using an intensity vector  (<code>lambda</code>) 
with equal values.
</p>


<h3>Value</h3>

<p>A list with elements:   
</p>
<table>
<tr><td><code>pv</code></td>
<td>
<p>P-value of the independence test.</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>
<p>Binary variable indicating if the test is rejected (1) or not (0) at an  alpha significance level.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>Sample of the KS statistics. The first value corresponds to the observed processes and the others to the generated processes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndLS">TestIndLS</a></code>,<code><a href="#topic+CondTest">CondTest</a></code>, <code><a href="#topic+DutilleulPlot">DutilleulPlot</a></code>,
<code><a href="#topic+DistSim">DistSim</a></code>, <code><a href="#topic+DistObs">DistObs</a></code>, <code><a href="#topic+uniongentri">uniongentri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Test applied to 3  independent NHPP
set.seed(123)
lambdax&lt;-runif(150, 0.01,0.1)
set.seed(124)
lambday&lt;-runif(150, 0.02,0.1)
set.seed(125)
lambdaz&lt;-runif(150, 0.015,0.1)
posx&lt;-simNHPc(lambdax, fixed.seed=123)$posNH
posy&lt;-simNHPc(lambday, fixed.seed=124)$posNH
posz&lt;-simNHPc(lambdaz, fixed.seed=125)$posNH

aux&lt;-TestIndNH(posx, posy, posz, nsim=50, type='Poisson', 
	lambdaMarg=cbind(lambday,lambdaz), fixed.seed=321)
aux$pv


#Test applied to 3 dependent NS cluster processes with 2 cores
#set.seed(123)
#lambdaParent&lt;-runif(500,0,0.1)
#DepPro&lt;-DepNHNeyScot(lambdaParent=lambdaParent, d=3, lambdaNumP = 3, 
#	 dist = "normal", sigmaC = 1, fixed.seed=123,cores=2)
#posx&lt;-DepPro$PP1
#posy&lt;-DepPro$PP2
#posz&lt;-DepPro$PP3
#aux&lt;-TestIndNH(posx, posy, posz, cores=1, type='PoissonCluster',
#	lambdaParent = lambdaParent, lambdaNumP = 3, 
#	dist = "normal", sigmaC = 1, fixed.seed=123, nsim=200)
#aux$pv


</code></pre>

<hr>
<h2 id='TranM'>Estimation of the transition matrix of a Markov chain</h2><span id='topic+TranM'></span>

<h3>Description</h3>

<p>It estimates the transition matrix of a Makov chain  to model the dependence between
the  discrete marks of a marked point process.  The estimator is the MLE based on count data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TranM(marcas = NULL, d = NULL, vecpro = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TranM_+3A_marcas">marcas</code></td>
<td>
<p>Integer vector. It contains the  discrete marks of the marked point process. The order 
of the  marks in the vector must correspond to  the points in the process sorted over time.</p>
</td></tr>
<tr><td><code id="TranM_+3A_d">d</code></td>
<td>
<p>Integer. Number of states of the Markov chain, that is the  number of different marks of the 
marked point process.</p>
</td></tr>
<tr><td><code id="TranM_+3A_vecpro">vecpro</code></td>
<td>
<p>A list with d elements.  Element &quot;i&quot; of the list  must  be a vector including the  occurrence  times of the
points  in the marked point process with marks equal to &quot;i&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of this function must  be a marked point process. It can be defined  by the sequence of marks of 
all the points in the process (arguments <code>marcas</code> and <code>d</code>), or alternatively  by a vector of <code>d</code>
point processes (argument <code>vecpro</code>). If  <code>marcas</code>  or <code>d</code> are NULL, 
<code>vecpro</code> must be provided. If they are not NULL, they are used to define the marked Poisson process.
</p>


<h3>Value</h3>

 <table>
<tr><td><code>prob</code></td>
<td>
<p>The  estimated transition matrix of probabilities.</p>
</td></tr> </table>


<h3>See Also</h3>

<p><code><a href="#topic+DepNHPPMarked">DepNHPPMarked</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
TranM(marcas = c(1,3,3,2,1,2,1,1), d = 3)

TranM(vecpro=list(n1=c(2,7,9,23), n2=c(4,5,21), n3=c(2,8,9,12,16)))
</code></pre>

<hr>
<h2 id='TxBHZ'>Daily maximum temperature at Barcelona, Huesca and Zaragoza</h2><span id='topic+TxBHZ'></span>

<h3>Description</h3>

<p>Daily maximum temperature series during the summer months (May, June, July, 
August and September) from  1951 to 2016 at three Spanish locations: Barcelona, Huesca and Zaragoza.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TxBHZ)</code></pre>


<h3>Details</h3>

<p>Variables
</p>
<p>year: Year, from 1951 to 2016.
</p>
<p>month: Month, from 5 (May) to 9 (September).
</p>
<p>day: Postion of the day in the month, from 1  up to 31.
</p>
<p>dayyear: Postion of the day in the year, from 121 (1st of May) to 253 (30th of September).
</p>
<p>TxB: Daily maximum temperature at Barcelona in Celsius degrees.
</p>
<p>TxH: Daily maximum temperature at Huesca in Celsius degrees.
</p>
<p>TxZ: Daily maximum temperature at Zaragoza in Celsius degrees.
</p>
<p>Txm31B: Local maximum temperature signal in Celsius degrees. Moving average of TxB with a  window of the last past 31 days.
</p>
<p>Txm31H: Local maximum temperature signal in Celsius degrees. Moving average of TxH with a  window of the last past 31 days.
</p>
<p>Txm31Z: Local maximum temperature signal in Celsius degrees. Moving average of TxZ with a  window of the last past 31 days.
</p>
<p>lambdaOZ: estimated intensities of the first indicator processes  of a CPSP fitted to model
the occurrence times  of the extreme events in the series of Zaragoza and Huesca, TxZ and TxH. The  first indicator process
includes the extreme events occurring only at TxZ.
</p>
<p>lambdaOH: estimated intensities of the second indicator processes  of a CPSP fitted to model
the occurrence times  of the extreme events in the series of Zaragoza and Huesca, TxZ and TxH. The  second indicator process
includes the extreme events occurring only at TxH.
</p>
<p>lambdaZH: estimated intensities of the third indicator processes  of a CPSP fitted to model
the occurrence times  of the extreme events in the series of Zaragoza and Huesca, TxZ and TxH. The  third indicator process
includes the simultaneous  extreme events occurring both at TxZ and TxH.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TxBHZ)
</code></pre>

<hr>
<h2 id='uniongentri'>Calculating the set of close points</h2><span id='topic+uniongentri'></span><span id='topic+genbiPos'></span><span id='topic+gentriPos'></span>

<h3>Description</h3>

<p>This function calculates the set of close points
of each  occurence point in the first process of a vector of two or three processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniongentri(posx, posy, posz=NULL,  info = FALSE, PA = FALSE,
	procName=c('X','Y','Z'),...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniongentri_+3A_posx">posx</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the first process.</p>
</td></tr>
<tr><td><code id="uniongentri_+3A_posy">posy</code></td>
<td>
<p>Numeric vector. Position of the occurrence points in the second process.</p>
</td></tr>
<tr><td><code id="uniongentri_+3A_posz">posz</code></td>
<td>
<p>Optional. Numeric vector. Position of the occurrence points in the third process. Only used when three
processes are involved.</p>
</td></tr>
<tr><td><code id="uniongentri_+3A_info">info</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE,  information about the generated points is shown  on the screen and
dotcharts and bivariate charts of the  occurrence points in the processes are displayed.</p>
</td></tr>
<tr><td><code id="uniongentri_+3A_procname">procName</code></td>
<td>
<p>Vector of character strings. Names of the processes.</p>
</td></tr>
<tr><td><code id="uniongentri_+3A_pa">PA</code></td>
<td>
<p>Optional. Logical flag. If it is TRUE, the close point relation  is
broadened by including the previous and the following points to the overlapping
intervals.</p>
</td></tr>
<tr><td><code id="uniongentri_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the function <code><a href="graphics.html#topic+plot">plot</a></code>  if  <code>info=T</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A point in a process is close to a point in another
process,  if  their time intervals overlap; the time interval of a point is the interval
between itself and the previous  point in the same process. If there are three processes,  
the set of close points of <code class="reqn">t_{x_k}</code>,<code class="reqn">S_{x_i; xyz}</code>, is defined as
the set of  the pairs of points <code class="reqn">(t_{y_j}, t_{z_k})</code> such that  <code class="reqn">t_{x_i}</code> is  close to <code class="reqn">t_{y_j}</code> and <code class="reqn">t_{y_j}</code> is  close to 
<code class="reqn">t_{z_k}</code>. If there are  two processes,  <code class="reqn">S_{x_i; xy}</code> is the set of   points
<code class="reqn">t_{y_j}</code> such that  <code class="reqn">t_{x_i}</code> is  close to <code class="reqn">t_{y_j}</code>.
This definition can be broadened, see  argument <code>PA</code>, by adding to the set two more points, the previous and the following ones.
</p>
<p>The algortihm to calculate the sets of close points  (in the case of three processes) is the following, 
see Abaurrea et al. (2015) for details: First,  given two processes, the pairs of close points  in those
processes are calculated. If the  last
point occurs in the first process,  there is a censored time interval in the second process (the point overlaps a time interval whose occurrence point has not been observed)
and that pair is not considered). This step is performed for all the combinations of  pairs of processes. The basic
close point relation is commutative,   and only three different  pairs (XY, YZ, XZ) must be considered. 
This is not the case of the broadened  definition, where the six pairs (XY, YX, YZ, ZY, XZ, ZX) must be  calculated.
</p>
<p>Once all the pairs of close points are obtained,  the set of close points for each point <code class="reqn">t_{x_i}</code> is obtained
by concatenating the adequate pairs of points from all the  possible orders of the three  processes: XYZ,
XZY and YXZ for the basic definition, and the six possible permutations for the broadened definition.
The final set of close points of <code class="reqn">t_{x_i}</code> is  the union of the different pairs  from  all the possible permutations.
</p>


<h3>Value</h3>

<p> A list with elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>First elements of the 3-tuples  of points <code class="reqn">(t_{x_i}, t_{y_i}, t_{z_i})</code> in the sets of close points.</p>
</td></tr>
<tr><td><code>iX</code></td>
<td>
<p>Position  i (=1,2,3....) of the  point <code class="reqn">t_{x_i}</code> in the first process.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Second elements of the 3-tuples  of points <code class="reqn">(t_{x_i}, t_{y_i}, t_{z_i})</code> in the sets of close points.</p>
</td></tr>
<tr><td><code>iY</code></td>
<td>
<p>Position  i (=1,2,3....) of the  point <code class="reqn">t_{y_i}</code> in the second process.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Third elements of the 3-tuples  of points <code class="reqn">(t_{x_i}, t_{y_i}, t_{z_i})</code> in the sets of close points. 
It is NULL if <code>posz=NULL</code>.</p>
</td></tr>
<tr><td><code>iZ</code></td>
<td>
<p>Position i (=1,2,3....) of the  point <code class="reqn">t_{z_i}</code> in the third process. 
It is NULL if posz=NULL.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J. Asin, J. and Cebrian, A.C. (2015). A Bootstrap Test of Independence Between Three Temporal Nonhomogeneous Poisson Processes 
and its Application to Heat Wave Modeling. <em>Environmental and Ecological Statistics</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+TestIndNH">TestIndNH</a></code>, <code><a href="#topic+DistSim">DistSim</a></code>, <code><a href="#topic+DistObs">DistObs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
posx&lt;-sort(runif(20,0,1000))
posy&lt;-sort(runif(25,0,1000))
posz&lt;-sort(runif(40,0,1000))
aux&lt;-uniongentri(posx, posy, posz, info=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
