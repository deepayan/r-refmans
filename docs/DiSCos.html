<!DOCTYPE html><html><head><title>Help for package DiSCos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiSCos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootCounterfactuals'><p>bootCounterfactuals</p></a></li>
<li><a href='#checks'><p>checks</p>
Carry out checks on the inputs</a></li>
<li><a href='#citation'><p>citation</p></a></li>
<li><a href='#DiSCo'><p>Distributional Synthetic Controls</p></a></li>
<li><a href='#DiSCo_bc'><p>Function for computing barycenters in the DiSCo method at every time period</p></a></li>
<li><a href='#DiSCo_CI'><p>DiSCo_CI</p></a></li>
<li><a href='#DiSCo_CI_iter'><p>DiSCo_CI_iter</p></a></li>
<li><a href='#DiSCo_iter'><p>Estimate DiSCo in a single period</p></a></li>
<li><a href='#DiSCo_mixture'><p>DiSCo_mixture</p></a></li>
<li><a href='#DiSCo_mixture_solve'><p>DiSCo_mixture_solve</p></a></li>
<li><a href='#DiSCo_per'><p>DiSCo_per</p></a></li>
<li><a href='#DiSCo_per_iter'><p>DiSCo_per_iter</p></a></li>
<li><a href='#DiSCo_per_rank'><p>DiSCo_per_rank</p></a></li>
<li><a href='#DiSCo_weights_reg'><p>DiSCo_weights_reg</p></a></li>
<li><a href='#DiSCoT'><p>Store aggregated treatment effects</p></a></li>
<li><a href='#DiSCoTEA'><p>Aggregate treatment effects from DiSCo function.</p></a></li>
<li><a href='#dube'><p>Data from (Dube 2019)</p></a></li>
<li><a href='#ex_gmm'><p>ex_gmm</p></a></li>
<li><a href='#getGrid'><p>getGrid</p></a></li>
<li><a href='#is.integer'><p>Check if a vector is integer</p></a></li>
<li><a href='#mclapply.hack'><p>mclapply.hack</p></a></li>
<li><a href='#myQuant'><p>Compute the empirical quantile function</p></a></li>
<li><a href='#parseBoots'><p>parseBoots</p></a></li>
<li><a href='#permut'><p>permut</p></a></li>
<li><a href='#plotDistOverTime'><p>Plot distribution of treatment effects over time</p></a></li>
<li><a href='#print.permut'><p>print.permut</p></a></li>
<li><a href='#summary.DiSCoT'><p>summary.DiSCoT</p></a></li>
<li><a href='#summary.permut'><p>summary.permut</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Distributional Synthetic Controls Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The method of synthetic controls is a widely-adopted tool for evaluating causal effects of policy changes in settings with observational data. In many settings where it is applicable, researchers want to identify causal effects of policy changes on a treated unit at an aggregate level while having access to data at a finer granularity. This package implements a simple extension of the synthetic controls estimator, developed in Gunsilius (2023) &lt;<a href="https://doi.org/10.3982%2FECTA18260">doi:10.3982/ECTA18260</a>&gt;, that takes advantage of this additional structure and provides nonparametric estimates of the heterogeneity within the aggregate unit. The idea is to replicate the quantile function associated with the treated unit by a weighted average of quantile functions of the control units. The package contains tools for aggregating and plotting the resulting distributional estimates, as well as for carrying out inference on them. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/">https://github.com/</a></td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;link href="https://github.com/" rel="canonical"&gt;, &lt;link
href="http://www.davidvandijcke.com/DiSCos/" rel="canonical"&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>CVXR, pracma, Rdpack, parallel, evmix, utils, extremeStat,
MASS</td>
</tr>
<tr>
<td>Depends:</td>
<td>data.table, R (&ge; 2.10), ggplot2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>haven, latex2exp, knitr, rmarkdown, maps, testthat (&ge;
3.0.0), quadprog</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 18:24:11 UTC; davidvandijcke</td>
</tr>
<tr>
<td>Author:</td>
<td>David Van Dijcke <a href="https://orcid.org/0000-0001-5825-3447"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Florian Gunsilius <a href="https://orcid.org/0000-0002-1698-6324"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Siyun He <a href="https://orcid.org/0000-0001-5825-3447"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Van Dijcke &lt;dvdijcke@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 19:03:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootCounterfactuals'>bootCounterfactuals</h2><span id='topic+bootCounterfactuals'></span>

<h3>Description</h3>

<p>Function for computing the bootstrapped counterfactuals in the DiSCo method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootCounterfactuals(result_t, t, mixture, weights, evgrid, grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootCounterfactuals_+3A_result_t">result_t</code></td>
<td>
<p>A list containing the results of the DiSCo_CI_iter function</p>
</td></tr>
<tr><td><code id="bootCounterfactuals_+3A_t">t</code></td>
<td>
<p>The current time period</p>
</td></tr>
<tr><td><code id="bootCounterfactuals_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bootCounterfactuals_+3A_grid">grid</code></td>
<td>
<p>Grid to recompute the CDF on if <code>mixture</code> option is chosen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the bootstrapped counterfactuals
</p>

<hr>
<h2 id='checks'>checks
Carry out checks on the inputs</h2><span id='topic+checks'></span>

<h3>Description</h3>

<p>checks
Carry out checks on the inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checks(
  df,
  id_col.target,
  t0,
  M,
  G,
  num.cores,
  permutation,
  q_min,
  q_max,
  CI,
  boots,
  cl,
  graph,
  qmethod,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checks_+3A_df">df</code></td>
<td>
<p>Data frame or data table containing the distributional data for the target and control units. The data table should contain the following columns:
</p>

<ul>
<li> <p><code>y_col </code> A numeric vector containing the outcome variable for each unit. Units can be individuals, states, etc., but they should be nested within a larger unit (e.g. individuals or counties within a state)
</p>
</li>
<li> <p><code>id_col </code> A numeric vector containing the aggregate IDs of the units. This could be, for example, the state if the units are counties or individuals
</p>
</li>
<li> <p><code>time_col </code> A vector containing the time period of the observation for each unit. This should be a monotonically increasing integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="checks_+3A_id_col.target">id_col.target</code></td>
<td>
<p>Variable indicating the name of the target unit, as specified in the id_col column of the data table.
This variable can be any type, as long as it is the same type as the id_col column of the data table.</p>
</td></tr>
<tr><td><code id="checks_+3A_t0">t0</code></td>
<td>
<p>Integer indicating period of treatment.</p>
</td></tr>
<tr><td><code id="checks_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="checks_+3A_g">G</code></td>
<td>
<p>Integer indicating the number of grid points for the grid on which the estimated functions are evaluated. Default is 1000.</p>
</td></tr>
<tr><td><code id="checks_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel computation. Default is 1. If the <code>permutation</code> or <code>CI</code> arguments are set to TRUE, this can be slow and it is recommended to set this to 4 or more, if possible.
If you get an error in &quot;all cores&quot; or similar, try setting num.cores=1 to see the precise error value.</p>
</td></tr>
<tr><td><code id="checks_+3A_permutation">permutation</code></td>
<td>
<p>logical, whether to use permutation or not</p>
</td></tr>
<tr><td><code id="checks_+3A_q_min">q_min</code></td>
<td>
<p>Numeric, minimum quantile to use. Set this together with <code>q_max</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 0 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="checks_+3A_q_max">q_max</code></td>
<td>
<p>Numeric, maximum quantile to use. Set this together with <code>q_min</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 1 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="checks_+3A_ci">CI</code></td>
<td>
<p>Logical, indicating whether to compute confidence intervals for the counterfactual quantiles. Default is FALSE.
The confidence intervals are computed using the bootstrap procedure described in Van Dijcke et al. (2024).</p>
</td></tr>
<tr><td><code id="checks_+3A_boots">boots</code></td>
<td>
<p>Integer, number of bootstrap samples to use for computing confidence intervals. Default is 500.</p>
</td></tr>
<tr><td><code id="checks_+3A_cl">cl</code></td>
<td>
<p>Numeric, confidence level for the (two-sided) confidence intervals.</p>
</td></tr>
<tr><td><code id="checks_+3A_graph">graph</code></td>
<td>
<p>Logical, indicating whether to plot the permutation graph as in Figure 3 of the paper. Default is FALSE.</p>
</td></tr>
<tr><td><code id="checks_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="checks_+3A_seed">seed</code></td>
<td>
<p>Integer, seed for the random number generator. This needs to be set explicitly in the function call, since it will invoke <code><a href="base.html#topic+RNGkind">RNGkind</a></code> which will set the seed for each core
when using parallel processes. Default is NULL, which does not set a seed.</p>
</td></tr>
</table>

<hr>
<h2 id='citation'>citation</h2><span id='topic+citation'></span>

<h3>Description</h3>

<p>print the citation for the relevant paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>citation()
</code></pre>

<hr>
<h2 id='DiSCo'>Distributional Synthetic Controls</h2><span id='topic+DiSCo'></span>

<h3>Description</h3>

<p>This function implements the distributional synthetic controls (DiSCo) method from Gunsilius (2023).
as well as the alternative mixture of distributions approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo(
  df,
  id_col.target,
  t0,
  M = 1000,
  G = 1000,
  num.cores = 1,
  permutation = FALSE,
  q_min = 0,
  q_max = 1,
  CI = FALSE,
  boots = 500,
  replace = TRUE,
  uniform = FALSE,
  cl = 0.95,
  graph = FALSE,
  qmethod = NULL,
  qtype = 7,
  seed = NULL,
  simplex = FALSE,
  mixture = FALSE,
  grid.cat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_+3A_df">df</code></td>
<td>
<p>Data frame or data table containing the distributional data for the target and control units. The data table should contain the following columns:
</p>

<ul>
<li> <p><code>y_col </code> A numeric vector containing the outcome variable for each unit. Units can be individuals, states, etc., but they should be nested within a larger unit (e.g. individuals or counties within a state)
</p>
</li>
<li> <p><code>id_col </code> A numeric vector containing the aggregate IDs of the units. This could be, for example, the state if the units are counties or individuals
</p>
</li>
<li> <p><code>time_col </code> A vector containing the time period of the observation for each unit. This should be a monotonically increasing integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DiSCo_+3A_id_col.target">id_col.target</code></td>
<td>
<p>Variable indicating the name of the target unit, as specified in the id_col column of the data table.
This variable can be any type, as long as it is the same type as the id_col column of the data table.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_t0">t0</code></td>
<td>
<p>Integer indicating period of treatment.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_g">G</code></td>
<td>
<p>Integer indicating the number of grid points for the grid on which the estimated functions are evaluated. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel computation. Default is 1. If the <code>permutation</code> or <code>CI</code> arguments are set to TRUE, this can be slow and it is recommended to set this to 4 or more, if possible.
If you get an error in &quot;all cores&quot; or similar, try setting num.cores=1 to see the precise error value.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_permutation">permutation</code></td>
<td>
<p>Logical, indicating whether to use the permutation method for computing the optimal weights. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_q_min">q_min</code></td>
<td>
<p>Numeric, minimum quantile to use. Set this together with <code>q_max</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 0 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_q_max">q_max</code></td>
<td>
<p>Numeric, maximum quantile to use. Set this together with <code>q_min</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 1 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_ci">CI</code></td>
<td>
<p>Logical, indicating whether to compute confidence intervals for the counterfactual quantiles. Default is FALSE.
The confidence intervals are computed using the bootstrap procedure described in Van Dijcke et al. (2024).</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_boots">boots</code></td>
<td>
<p>Integer, number of bootstrap samples to use for computing confidence intervals. Default is 500.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_replace">replace</code></td>
<td>
<p>Logical, indicating whether to sample with replacement when computing the bootstrap samples. Default is TRUE.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_uniform">uniform</code></td>
<td>
<p>Logical, indicating whether to construct uniform bootstrap confidence intervals. Default is FALSE
If FALSE, the confidence intervals are pointwise.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_cl">cl</code></td>
<td>
<p>Numeric, confidence level for the (two-sided) confidence intervals.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_graph">graph</code></td>
<td>
<p>Logical, indicating whether to plot the permutation graph as in Figure 3 of the paper. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_seed">seed</code></td>
<td>
<p>Integer, seed for the random number generator. This needs to be set explicitly in the function call, since it will invoke <code><a href="base.html#topic+RNGkind">RNGkind</a></code> which will set the seed for each core
when using parallel processes. Default is NULL, which does not set a seed.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DiSCo_+3A_grid.cat">grid.cat</code></td>
<td>
<p>List, containing the discrete support points for a discrete grid to be used with the mixture of distributions approach.
This is useful for constructing synthetic distributions for categorical variables. Default is NULL, which uses a continuous grid based on the other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called for every time period in the DiSCo function. It implements the DiSCo method for a single time period, as well as the mixture of distributions approach.
The corresponding results for each time period can be accessed in the <code>results.periods</code> list of the output of the DiSCo function. The DiSCo function returns the average weight for each unit across all periods,
calculated as a uniform mean, as well as the counterfactual target distribution produced as the weighted average of the control distributions for each period, using these averaged weights.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>results.periods</code> A list containing, for each time period, the elements described in the return argument of <code><a href="#topic+DiSCo_iter">DiSCo_iter</a></code>, as well as the following additional elements:
</p>

<ul>
<li> <p><code>DiSco</code>
</p>

<ul>
<li> <p><code>quantile </code> The counterfactual quantiles for the target unit.
</p>
</li>
<li> <p><code>weights </code> The optimal weights for the target unit.
</p>
</li>
<li> <p><code>cdf </code> The counterfactual CDF for the target unit.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>weights</code> A numeric vector containing the synthetic control weights for the control units, averaged over time.
When <code>mixture</code> is TRUE, these are the weights for the mixture of distributions, otherwise they are the weights for the quantile-based approach.
</p>
</li>
<li> <p><code>CI</code> A list containing the confidence intervals for the counterfactual quantiles and CDFs, if <code>CI</code> is TRUE.
Each element contains two named subelements called <code>upper</code>, <code>lower</code>, <code>se</code> which
are the upper and lower confidence bands and the standard error of the estimate, respectively.
They are G x T matrices where G is the specified number of grid points and T is the number of time periods.
The elements are:
</p>

<ul>
<li> <p><code>cdf</code> The bootstrapped CDF
</p>
</li>
<li> <p><code>quantile</code> The bootstrapped quantile
</p>
</li>
<li> <p><code>quantile_diff</code> The bootstrapped quantile difference
</p>
</li>
<li> <p><code>cdf_diff</code> The bootstrapped CDF difference
</p>
</li>
<li> <p><code>bootmat</code> A list containing the raw bootstrapped samples for the counterfactual quantiles and CDFs, if <code>CI</code> is TRUE.
These are not meant to be accessed directly, but are used by <code>DiSCoTEA</code> to compute aggregated standard errors. Advanced users
may wish to access these directly for further analysis. The element names should be self-explanatory.
#' </p>
</li>
<li> <p><code>control_ids</code> A list containing the control unit IDs used for each time period, which can be used to identify the weights
associated with each control as the returned weights have the same order as the control IDs.
</p>
</li>
<li> <p><code>perm </code> A <code><a href="#topic+permut">permut</a></code> object containing the results of the permutation method, if <code>permutation</code> is TRUE.
Call <code>summary</code> on this object to print the overall results of the permutation test.
#' </p>
</li>
<li> <p><code>evgrid</code> A numeric vector containing the grid points on which the quantiles were evaluated.
</p>
</li>
<li> <p><code>params</code> A list containing the parameters used in the function call.
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Gunsilius FF (2023).
&ldquo;Distributional synthetic controls.&rdquo;
<em>Econometrica</em>, <b>91</b>(3), 1105&ndash;1117.<br /><br /> Van Dijcke D, Gunsilius F, Wright AL (2024).
&ldquo;Return to Office and the Tenure Distribution.&rdquo;
Working Paper 2024-56, University of Chicago, Becker Friedman Institute for Economics.()
</p>

<hr>
<h2 id='DiSCo_bc'>Function for computing barycenters in the DiSCo method at every time period</h2><span id='topic+DiSCo_bc'></span>

<h3>Description</h3>

<p>Compute barycenters in the DiSCo method at every time period, as in Definition 1,
Step 4 in Gunsilius (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_bc(controls.q, weights, evgrid = seq(from = 0, to = 1, length.out = 101))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_bc_+3A_controls.q">controls.q</code></td>
<td>
<p>List with matrices of control quantile functions</p>
</td></tr>
<tr><td><code id="DiSCo_bc_+3A_weights">weights</code></td>
<td>
<p>Vector of optimal synthetic control weights, computed using the DiSCo_weights_reg function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantile function of the barycenter associated with the &quot;weights&quot; evaluated at the vector &quot;evgrid&quot;
</p>


<h3>References</h3>

<p>Gunsilius FF (2023).
&ldquo;Distributional synthetic controls.&rdquo;
<em>Econometrica</em>, <b>91</b>(3), 1105&ndash;1117.
</p>

<hr>
<h2 id='DiSCo_CI'>DiSCo_CI</h2><span id='topic+DiSCo_CI'></span>

<h3>Description</h3>

<p>Function for computing the confidence intervals in the DiSCo method
using the bootstrap approach described in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_CI(
  redraw,
  controls,
  target,
  T_max,
  T0,
  grid,
  mc.cores = 1,
  evgrid = seq(from = 0, to = 1, length.out = 1001),
  qmethod = NULL,
  qtype = 7,
  M = 1000,
  mixture = FALSE,
  simplex = FALSE,
  replace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_CI_+3A_redraw">redraw</code></td>
<td>
<p>Integer indicating the current bootstrap redraw</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_controls">controls</code></td>
<td>
<p>A list containing the raw data for the control group</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_target">target</code></td>
<td>
<p>A list containing the raw data for the target group</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_t_max">T_max</code></td>
<td>
<p>Index of last time period</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_t0">T0</code></td>
<td>
<p>Index of the last pre-treatment period</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_grid">grid</code></td>
<td>
<p>Grid to recompute the CDF on if <code>mixture</code> option is chosen</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use for parallelization</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_+3A_replace">replace</code></td>
<td>
<p>Logical, indicating whether to sample with replacement when computing the bootstrap samples. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>

<ul>
<li> <p><code>weights</code> The bootstrapped weights
</p>
</li>
<li> <p><code>disco_boot</code> A list containing the bootstrapped counterfactuals,
with the following elements, each of which contains named elements called <code>upper</code> and <code>lower</code>
which are G x T matrices where G is the specified number of grid points and T is the number of time periods
</p>
</li></ul>


<hr>
<h2 id='DiSCo_CI_iter'>DiSCo_CI_iter</h2><span id='topic+DiSCo_CI_iter'></span>

<h3>Description</h3>

<p>Function for computing the confidence intervals in the DiSCo method in a single period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_CI_iter(
  t,
  controls_t,
  target_t,
  grid,
  T0,
  M = 1000,
  evgrid = seq(from = 0, to = 1, length.out = 1001),
  qmethod = NULL,
  qtype = 7,
  mixture = FALSE,
  simplex = FALSE,
  replace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_CI_iter_+3A_t">t</code></td>
<td>
<p>Time period</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_controls_t">controls_t</code></td>
<td>
<p>List of control unit data for given period</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_target_t">target_t</code></td>
<td>
<p>List of target unit data for given period</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_grid">grid</code></td>
<td>
<p>Grid to recompute the CDF on if <code>mixture</code> option is chosen</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_t0">T0</code></td>
<td>
<p>Index of the last pre-treatment period</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_CI_iter_+3A_replace">replace</code></td>
<td>
<p>Logical, indicating whether to sample with replacement when computing the bootstrap samples. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resampled counterfactual barycenter of the target unit
</p>

<hr>
<h2 id='DiSCo_iter'>Estimate DiSCo in a single period</h2><span id='topic+DiSCo_iter'></span>

<h3>Description</h3>

<p>This function implements the DiSCo method for a single time period, as well as the mixture of distributions approach.
Its return values contain valuable period-specific estimation outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_iter(
  yy,
  df,
  evgrid,
  id_col.target,
  M,
  G,
  T0,
  qmethod = NULL,
  qtype = 7,
  q_min = 0,
  q_max = 1,
  simplex = FALSE,
  controls.id,
  grid.cat,
  mixture
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_iter_+3A_yy">yy</code></td>
<td>
<p>Integer indicating the current year being processed.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_df">df</code></td>
<td>
<p>Data frame or data table containing the distributional data for the target and control units. The data table should contain the following columns:
</p>

<ul>
<li> <p><code>y_col </code> A numeric vector containing the outcome variable for each unit. Units can be individuals, states, etc., but they should be nested within a larger unit (e.g. individuals or counties within a state)
</p>
</li>
<li> <p><code>id_col </code> A numeric vector containing the aggregate IDs of the units. This could be, for example, the state if the units are counties or individuals
</p>
</li>
<li> <p><code>time_col </code> A vector containing the time period of the observation for each unit. This should be a monotonically increasing integer.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_evgrid">evgrid</code></td>
<td>
<p>A vector of grid points on which to evaluate the quantile functions.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_id_col.target">id_col.target</code></td>
<td>
<p>Variable indicating the name of the target unit, as specified in the id_col column of the data table.
This variable can be any type, as long as it is the same type as the id_col column of the data table.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_g">G</code></td>
<td>
<p>Integer indicating the number of grid points for the grid on which the estimated functions are evaluated. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_t0">T0</code></td>
<td>
<p>Integer indicating the last pre-treatment period starting from 1.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_q_min">q_min</code></td>
<td>
<p>Numeric, minimum quantile to use. Set this together with <code>q_max</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 0 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_q_max">q_max</code></td>
<td>
<p>Numeric, maximum quantile to use. Set this together with <code>q_min</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 1 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_controls.id">controls.id</code></td>
<td>
<p>List of strings specifying the column names for the control units' identifiers.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_grid.cat">grid.cat</code></td>
<td>
<p>List, containing the discrete support points for a discrete grid to be used with the mixture of distributions approach.
This is useful for constructing synthetic distributions for categorical variables. Default is NULL, which uses a continuous grid based on the other parameters.</p>
</td></tr>
<tr><td><code id="DiSCo_iter_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is part of the DiSCo method, called for each time period.
It calculates the optimal weights for the DiSCo method and the mixture of
distributions approach for a single time period. The function processes data f
or both the target and control units, computes the quantile functions,
and evaluates these on a specified grid. The function is designed to be used
within the broader context of the DiSCo function, which aggregates results
across multiple time periods.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>DiSCo_weights </code> Weights calculated using the DiSCo method.
</p>
</li>
<li> <p><code>mixture </code>
</p>

<ul>
<li> <p><code>weights </code> Optimal weights for the mixture approach.
</p>
</li>
<li> <p><code>distance </code> Value of the objective function for the mixture approach.
</p>
</li>
<li> <p><code>mean </code> Weighted mixture of the controls' CDFs.
</p>
</li></ul>

</li>
<li> <p><code>target </code>
</p>

<ul>
<li> <p><code>cdf </code> Empirical CDF of the target. Only computed when <code>mixture=TRUE</code>.
</p>
</li>
<li> <p><code>grid </code> Grid on which the quantile and CDF functions were evaluated.
</p>
</li>
<li> <p><code>data </code> Original data for the target unit.
</p>
</li>
<li> <p><code>quantiles </code> Quantiles for the target unit, evaluated on the specified grid.
</p>
</li></ul>

</li>
<li> <p><code>controls </code>
</p>

<ul>
<li> <p><code>data </code> Original data for the control units.
</p>
</li>
<li> <p><code>cdf </code> Empirical CDFs of the control units. Only computed when <code>mixture=TRUE</code>.
</p>
</li>
<li> <p><code>quantiles </code> Quantiles for the control units, evaluated on the specified grid.
.
</p>
</li></ul>

</li>
<li> <p><code>controls.q </code> Quantiles for the control units, evaluated on the specified grid.
</p>
</li></ul>


<hr>
<h2 id='DiSCo_mixture'>DiSCo_mixture</h2><span id='topic+DiSCo_mixture'></span>

<h3>Description</h3>

<p>The alternative mixture of distributions approach in the paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_mixture(controls1, target, grid.min, grid.max, grid.rand, M, simplex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_mixture_+3A_controls1">controls1</code></td>
<td>
<p>A list of controls</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_+3A_target">target</code></td>
<td>
<p>The target unit</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_+3A_grid.min">grid.min</code></td>
<td>
<p>Minimal value of the grid on which the CDFs are evaluated.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_+3A_grid.max">grid.max</code></td>
<td>
<p>Maximal value of the grid on which the CDFs are evaluated.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_+3A_grid.rand">grid.rand</code></td>
<td>
<p>Random grid on which the CDFs are evaluated.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>cdf </code> A matrix containing the CDFs of the target and control units evaluated on the grid.
</p>
</li>
<li> <p><code>distance.opt </code> The optimal value of the Wasserstein distance.
</p>
</li>
<li> <p><code>mean </code> The optimal value of the Wasserstein barycenter.
</p>
</li>
<li> <p><code>target.order </code> The target unit, ordered.
</p>
</li>
<li> <p><code>weights.opt </code> The optimal weights.
</p>
</li></ul>


<hr>
<h2 id='DiSCo_mixture_solve'>DiSCo_mixture_solve</h2><span id='topic+DiSCo_mixture_solve'></span>

<h3>Description</h3>

<p>The solver for the alternative mixture of distributions approach in the paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_mixture_solve(
  c_len,
  CDF.matrix,
  grid.min,
  grid.max,
  grid.rand,
  M,
  simplex
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_mixture_solve_+3A_c_len">c_len</code></td>
<td>
<p>The number of controls</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_solve_+3A_cdf.matrix">CDF.matrix</code></td>
<td>
<p>The matrix of CDFs</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_solve_+3A_grid.min">grid.min</code></td>
<td>
<p>Minimal value of the grid on which the CDFs are evaluated.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_solve_+3A_grid.max">grid.max</code></td>
<td>
<p>Maximal value of the grid on which the CDFs are evaluated.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_solve_+3A_grid.rand">grid.rand</code></td>
<td>
<p>Random grid on which the CDFs are evaluated.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_solve_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_mixture_solve_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>distance.opt </code> The optimal value of the Wasserstein distance.
</p>
</li>
<li> <p><code>mean </code> The optimal value of the Wasserstein barycenter.
</p>
</li>
<li> <p><code>target.order </code> The target unit, ordered.
</p>
</li>
<li> <p><code>weights.opt </code> The optimal weights.
</p>
</li></ul>


<hr>
<h2 id='DiSCo_per'>DiSCo_per</h2><span id='topic+DiSCo_per'></span>

<h3>Description</h3>

<p>Function to implement permutation test for Distributional Synthetic Controls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_per(
  results.periods,
  T0,
  ww = 0,
  peridx = 0,
  evgrid = seq(from = 0, to = 1, length.out = 101),
  graph = TRUE,
  num.cores = 1,
  weights = NULL,
  qmethod = NULL,
  qtype = qtype,
  q_min = 0,
  q_max = 1,
  M = 1000,
  simplex = FALSE,
  mixture = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_per_+3A_results.periods">results.periods</code></td>
<td>
<p>List of period-specific results from DiSCo</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_t0">T0</code></td>
<td>
<p>Integer indicating first year of treatment as counted from 1 (e.g, if treatment year 2002 was the 5th year in the sample, this parameter should be 5).</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_ww">ww</code></td>
<td>
<p>Optional vector of weights indicating the relative importance of each time period. If not specified, each time period is weighted equally.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_peridx">peridx</code></td>
<td>
<p>Optional integer indicating number of permutations. If not specified, by default equal to the number of units in the sample.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_graph">graph</code></td>
<td>
<p>Logical, indicating whether to plot the permutation graph as in Figure 3 of the paper. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_num.cores">num.cores</code></td>
<td>
<p>Integer, number of cores to use for parallel computation. Default is 1. If the <code>permutation</code> or <code>CI</code> arguments are set to TRUE, this can be slow and it is recommended to set this to 4 or more, if possible.
If you get an error in &quot;all cores&quot; or similar, try setting num.cores=1 to see the precise error value.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to use for the &quot;true&quot; treated unit. <code>redo_weights</code> has to be set to FALSE for these weights to be used.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_q_min">q_min</code></td>
<td>
<p>Numeric, minimum quantile to use. Set this together with <code>q_max</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 0 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_q_max">q_max</code></td>
<td>
<p>Numeric, maximum quantile to use. Set this together with <code>q_min</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 1 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_per_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program iterates through all units and computes the optimal weights on the other units
for replicating the unit of iteration's outcome variable, assuming that it is the treated unit.
See Algorithm 1 in Gunsilius (2023) for more details. The only modification is that we take the ratio of post- and pre-treatment
root mean squared Wasserstein distances to calculate the p-value, rather than the level in each period, following @abadie2010synthetic.
</p>


<h3>Value</h3>

<p>List of matrices containing synthetic time path of the outcome variable
for the target unit together with the time paths of the control units
</p>


<h3>References</h3>

<p>Gunsilius FF (2023).
&ldquo;Distributional synthetic controls.&rdquo;
<em>Econometrica</em>, <b>91</b>(3), 1105&ndash;1117.
</p>

<hr>
<h2 id='DiSCo_per_iter'>DiSCo_per_iter</h2><span id='topic+DiSCo_per_iter'></span>

<h3>Description</h3>

<p>This function performs one iteration of the permutation test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_per_iter(
  c_df,
  c_df.q,
  t_df,
  T0,
  peridx,
  evgrid,
  idx,
  grid_df,
  M = 1000,
  ww = 0,
  qmethod = NULL,
  qtype = 7,
  q_min = 0,
  q_max = 1,
  simplex = FALSE,
  mixture = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_per_iter_+3A_c_df">c_df</code></td>
<td>
<p>List of control units</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_c_df.q">c_df.q</code></td>
<td>
<p>List of quantiles of control units</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_t_df">t_df</code></td>
<td>
<p>List of target unit</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_idx">idx</code></td>
<td>
<p>Index of permuted target unit</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_grid_df">grid_df</code></td>
<td>
<p>Grids to evaluate CDFs on, only needed when <code>mixture=TRUE</code></p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_q_min">q_min</code></td>
<td>
<p>Numeric, minimum quantile to use. Set this together with <code>q_max</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 0 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_q_max">q_max</code></td>
<td>
<p>Numeric, maximum quantile to use. Set this together with <code>q_min</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 1 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_per_iter_+3A_mixture">mixture</code></td>
<td>
<p>Logical, indicating whether to use the mixture of distributions approach instead.
See Section 4.3. in Gunsilius (2023). This approach minimizes the distance between the CDFs
instead of the quantile functions, and is preferred for categorical variables. When working with such variables, one should
also provide a list of support points in the <code>grid.cat</code> parameter. When that is provided, this parameter is automatically set to TRUE. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of squared Wasserstein distances between the target unit and the control units
</p>

<hr>
<h2 id='DiSCo_per_rank'>DiSCo_per_rank</h2><span id='topic+DiSCo_per_rank'></span>

<h3>Description</h3>

<p>This function ranks the squared Wasserstein distances and returns the p-values for each time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_per_rank(distt, distp, T0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_per_rank_+3A_distt">distt</code></td>
<td>
<p>List of squared Wasserstein distances between the target unit and the control units</p>
</td></tr>
<tr><td><code id="DiSCo_per_rank_+3A_distp">distp</code></td>
<td>
<p>List of squared Wasserstein distances between the control units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of p-values for each time period
</p>

<hr>
<h2 id='DiSCo_weights_reg'>DiSCo_weights_reg</h2><span id='topic+DiSCo_weights_reg'></span>

<h3>Description</h3>

<p>Function for obtaining the weights in the DiSCo method at every time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCo_weights_reg(
  controls,
  target,
  M = 500,
  qmethod = NULL,
  qtype = 7,
  simplex = FALSE,
  q_min = 0,
  q_max = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCo_weights_reg_+3A_controls">controls</code></td>
<td>
<p>List with matrices of control distributions</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_target">target</code></td>
<td>
<p>Matrix containing the target distribution</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_m">M</code></td>
<td>
<p>Integer indicating the number of control quantiles to use in the DiSCo method. Default is 1000.</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_qmethod">qmethod</code></td>
<td>
<p>Character, indicating the method to use for computing the quantiles of the target distribution. The default is NULL, which uses the <code><a href="stats.html#topic+quantile">quantile</a></code> function from the stats package.
Other options are &quot;<code><a href="evmix.html#topic+qkden">qkden</a></code>&quot; (based on smoothed kernel density function) and &quot;<code><a href="extremeStat.html#topic+distLquantile">extreme</a></code>&quot; (based on parametric extreme value distributions).
Both are substantially slower than the default method but may be useful for fat-tailed distributions with few data points at the upper quantiles. Alternatively, one could use the q_max option to restrict the range of quantiles used.</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_qtype">qtype</code></td>
<td>
<p>Integer, indicating the type of quantile to compute when using  <code><a href="stats.html#topic+quantile">quantile</a></code> in the <code>qmethod</code> argument.
The default 7. See the documentation for the <code><a href="stats.html#topic+quantile">quantile</a></code> function for more information.</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_simplex">simplex</code></td>
<td>
<p>Logical, indicating whether to use to constrain the optimal weights to the unit simplex. Default is FALSE, which only constrains the weights to sum up to 1 but allows them to be negative.</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_q_min">q_min</code></td>
<td>
<p>Numeric, minimum quantile to use. Set this together with <code>q_max</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 0 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
<tr><td><code id="DiSCo_weights_reg_+3A_q_max">q_max</code></td>
<td>
<p>Numeric, maximum quantile to use. Set this together with <code>q_min</code> to restrict the range of quantiles used to construct the synthetic control.
Default is 1 (all quantiles). Currently NOT implemented for the <code>mixture</code> approach.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the optimal weights for the distributional synthetic controls method.
solving the convex minimization problem in Eq. (2) in Gunsilius (2023)..
using a regression of the simulated target quantile on the simulated control quantiles, as in Eq. (3),
<code class="reqn">\underset{\vec{\lambda} \in \Delta^J}{\operatorname{argmin}}\left\|\mathbb{Y}_t \vec{\lambda}_t-\vec{Y}_{1 t}\right\|_2^2</code>.
For the constrained optimization we rely on the package pracma
the control distributions can be given in list form, where each list element contains a
vector of observations for the given control unit, in matrix form;
in matrix- each column corresponds to one unit and each row is one observation.
The list-form is useful, because the number of draws for each control group can be different.
The target must be given as a vector.
</p>


<h3>Value</h3>

<p>Vector of optimal synthetic control weights
</p>


<h3>References</h3>

<p>Gunsilius FF (2023).
&ldquo;Distributional synthetic controls.&rdquo;
<em>Econometrica</em>, <b>91</b>(3), 1105&ndash;1117.
</p>

<hr>
<h2 id='DiSCoT'>Store aggregated treatment effects</h2><span id='topic+DiSCoT'></span>

<h3>Description</h3>

<p>S3 object holding aggregated treatment effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCoT(
  agg,
  treats,
  ses,
  grid,
  ci_lower,
  ci_upper,
  t0,
  call,
  cl,
  N,
  J,
  agg_df,
  perm,
  plot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCoT_+3A_agg">agg</code></td>
<td>
<p>aggregation method</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_treats">treats</code></td>
<td>
<p>list of treatment effects</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_ses">ses</code></td>
<td>
<p>list of standard errors</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_grid">grid</code></td>
<td>
<p>grid</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_ci_lower">ci_lower</code></td>
<td>
<p>list of lower confidence intervals</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_ci_upper">ci_upper</code></td>
<td>
<p>list of upper confidence intervals</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_t0">t0</code></td>
<td>
<p>start time</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_call">call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_cl">cl</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_n">N</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_j">J</code></td>
<td>
<p>number of treated units</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_agg_df">agg_df</code></td>
<td>
<p>dataframe of aggregated treatment effects and their confidence intervals</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_perm">perm</code></td>
<td>
<p>list of per mutation results</p>
</td></tr>
<tr><td><code id="DiSCoT_+3A_plot">plot</code></td>
<td>
<p>a ggplot object containing the plot for the aggregated treatment effects using the <code>agg</code> parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object of class <code>DiSCoT</code> with associated <code>summary</code> and <code>print</code> methods
</p>

<hr>
<h2 id='DiSCoTEA'>Aggregate treatment effects from DiSCo function.</h2><span id='topic+DiSCoTEA'></span>

<h3>Description</h3>

<p>Function to aggregate treatment effects from the output of the
DiSCo function, plot the distribution of the aggregation statistic over time,
and report summary tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiSCoTEA(
  disco,
  agg = "quantileDiff",
  graph = TRUE,
  t_plot = NULL,
  savePlots = FALSE,
  xlim = NULL,
  ylim = NULL,
  samples = c(0.25, 0.5, 0.75)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiSCoTEA_+3A_disco">disco</code></td>
<td>
<p>Output of the DiSCo function.</p>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_agg">agg</code></td>
<td>
<p>String indicating the aggregation statistic to be used. Options include
</p>

<ul>
<li> <p><code>quantileDiff</code>  Difference in quantiles between the target and the weighted average of the controls.
</p>
</li>
<li> <p><code>quantile</code> Plots both the observed and the counterfactual quantile functions. No summary statistics will be produced.
</p>
</li>
<li> <p><code>cdfDiff</code>  Difference in CDFs between the target and the weighted average of the controls.
</p>
</li>
<li> <p><code>cdf</code> Plots both the observed and the counterfactual CDFs. No summary statistics will be produced.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_graph">graph</code></td>
<td>
<p>Boolean indicating whether to plot graphs (default is TRUE).</p>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_t_plot">t_plot</code></td>
<td>
<p>Optional vector of time periods (<code>t_col</code> values in the original dataframe) to be plotted (default is NULL, which plots all time periods).</p>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_saveplots">savePlots</code></td>
<td>
<p>Boolean indicating whether to save the plots to the current working directory (default is FALSE). The plot names will be <code style="white-space: pre;">&#8288;[agg]_[start_year]_[end_year].pdf&#8288;</code>.</p>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_xlim">xlim</code></td>
<td>
<p>Optional vector of length 2 indicating the x-axis limits of the plot. Useful for zooming in on relevant parts of the distribution for fat-tailed distributions.</p>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector of length 2 indicating the y-axis limits of the plot.</p>
</td></tr>
<tr><td><code id="DiSCoTEA_+3A_samples">samples</code></td>
<td>
<p>Numeric vector indicating the range of quantiles of the aggregation statistic (<code>agg</code>) to be summarized in the <code>summary</code> property of the S3 class returned by the function (default is c(0.25, 0.5, 0.75)).
For example, if <code>samples</code> = c(0.25, 0.5, 0.75), the summary table will include the average effect for the 0-25th, 25-50th, 50-75th and 75-100th quantiles of the distribution of the aggregation statistic over time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in the output of the DiSCo_per function and computes aggregate treatment effect using a user-specified aggregation statistic.
The default is the differences between the counterfactual and the observed quantile functions (<code>quantileDiff</code>). If <code>graph</code> is set to TRUE,
the function will plot the distribution of the aggregation statistic over time. The S3 class returned by the function
has a <code>summary</code> property that will print a selection of aggregated effects (specified by the <code>samples</code> parameter) for the chosen <code>agg</code> method, by post-treatment year (see examples below).
This <code>summary</code> call will only print effects if the <code>agg</code> parameter requested a distribution difference (<code>quantileDiff</code> or <code>cdfDiff</code>). The other aggregations are meant to be inspected visually.
If the <code>permutation</code> parameter was set to TRUE in the original <code>DiSCo</code> call, the summary table will include the results of the permutation test.
If the original <code>DiSCo</code> call was restricted to a range of quantiles smaller than <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> (i.e. <code>q_min</code> &gt; 0 or <code>q_max</code> &lt; 1), the <code>samples</code> parameter is ignored
and only the aggregated differences for the quantile range specified in the original call are returned.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DiSCoT">DiSCoT</a></code> object, which is an S3 class that stores a list of treatment effects, their standard errors,
the corresponding confidence intervals (if specified), and a dataframe with treatment effects aggregated
according to the <code>agg</code> input. The S3 class also has a <code>summary</code> property that will print a selection of aggregated effects (specified by the <code>samples</code> parameter)
for the chosen <code>agg</code> method, by post-treatment year, as well as the permutation test results, if specified.
</p>

<hr>
<h2 id='dube'>Data from (Dube 2019)</h2><span id='topic+dube'></span>

<h3>Description</h3>

<p>As used in the empirical application of Gunsilius (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dube
</code></pre>


<h3>Format</h3>



<h4><code>dube</code></h4>

<p>A data frame with 652,870 rows and 3 columns:
</p>

<dl>
<dt>id_col</dt><dd><p>State FIPS</p>
</dd>
<dt>time_col</dt><dd><p>Year</p>
</dd>
<dt>y_col</dt><dd><p><code>adj0contpov</code> variable in Dube (2019). Captures the distribution of equalized family income from wages and salary, defined as multiples of the federal poverty threshold.</p>
</dd>
</dl>
<p>...

</p>


<hr>
<h2 id='ex_gmm'>ex_gmm</h2><span id='topic+ex_gmm'></span>

<h3>Description</h3>

<p>Example data for <code>DiSCo</code> command.
Returns simulated target and control that are mixtures of Gaussian distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_gmm(Ts = 2, num.con = 30, numdraws = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ex_gmm_+3A_ts">Ts</code></td>
<td>
<p>an integer indicating the number of time periods</p>
</td></tr>
<tr><td><code id="ex_gmm_+3A_num.con">num.con</code></td>
<td>
<p>an integer indicating the number of control units</p>
</td></tr>
<tr><td><code id="ex_gmm_+3A_numdraws">numdraws</code></td>
<td>
<p>an integer indicating the number of draws</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>target</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='getGrid'>getGrid</h2><span id='topic+getGrid'></span>

<h3>Description</h3>

<p>Set up a grid for the estimation of the quantile functions and CDFs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGrid(target, controls, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGrid_+3A_target">target</code></td>
<td>
<p>A vector containing the data for the target unit</p>
</td></tr>
<tr><td><code id="getGrid_+3A_controls">controls</code></td>
<td>
<p>A list containing the data for the control units</p>
</td></tr>
<tr><td><code id="getGrid_+3A_g">G</code></td>
<td>
<p>The number of grid points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>grid.min</code> The minimum value of the grid
</p>
</li>
<li> <p><code>grid.max</code> The maximum value of the grid
</p>
</li>
<li> <p><code>grid.rand</code> A vector containing the grid points
</p>
</li>
<li> <p><code>grid.ord</code> A vector containing the grid points, ordered
</p>
</li></ul>


<hr>
<h2 id='is.integer'>Check if a vector is integer</h2><span id='topic+is.integer'></span>

<h3>Description</h3>

<p>Check if a vector is integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.integer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.integer_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is integer, FALSE otherwise
</p>

<hr>
<h2 id='mclapply.hack'>mclapply.hack</h2><span id='topic+mclapply.hack'></span>

<h3>Description</h3>

<p>This function mimics forking (done with mclapply in Mac or Linux) for the
Windows environment.  Designed to be used just like mclapply.  Credit goes to
Nathan VanHoudnos.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclapply.hack(..., verbose = FALSE, mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mclapply.hack_+3A_verbose">verbose</code></td>
<td>
<p>Should users be warned this is hack-y? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="mclapply.hack_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use. Defaults to 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>mclapply
</p>

<hr>
<h2 id='myQuant'>Compute the empirical quantile function</h2><span id='topic+myQuant'></span>

<h3>Description</h3>

<p>Compute the empirical quantile function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myQuant(X, q, qtype = 7, qmethod = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myQuant_+3A_x">X</code></td>
<td>
<p>A vector containing the data</p>
</td></tr>
<tr><td><code id="myQuant_+3A_q">q</code></td>
<td>
<p>A vector containing the quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the empirical quantile function
</p>

<hr>
<h2 id='parseBoots'>parseBoots</h2><span id='topic+parseBoots'></span>

<h3>Description</h3>

<p>Function for parsing the bootstrapped counterfactuals in the DiSCo method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseBoots(CI_temp, cl, q_disco, cdf_disco, q_obs, cdf_obs, uniform = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseBoots_+3A_ci_temp">CI_temp</code></td>
<td>
<p>A list containing the bootstrapped counterfactuals</p>
</td></tr>
<tr><td><code id="parseBoots_+3A_cl">cl</code></td>
<td>
<p>The confidence level</p>
</td></tr>
<tr><td><code id="parseBoots_+3A_q_disco">q_disco</code></td>
<td>
<p>The estimated quantiles around which to center</p>
</td></tr>
<tr><td><code id="parseBoots_+3A_cdf_disco">cdf_disco</code></td>
<td>
<p>The estimated cdfs around which to center</p>
</td></tr>
<tr><td><code id="parseBoots_+3A_q_obs">q_obs</code></td>
<td>
<p>The observed quantiles</p>
</td></tr>
<tr><td><code id="parseBoots_+3A_cdf_obs">cdf_obs</code></td>
<td>
<p>The observed cdfs</p>
</td></tr>
<tr><td><code id="parseBoots_+3A_uniform">uniform</code></td>
<td>
<p>Whether to use uniform or pointwise confidence intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the confidence intervals for the quantiles and cdfs
</p>

<hr>
<h2 id='permut'>permut</h2><span id='topic+permut'></span>

<h3>Description</h3>

<p>Object to hold results of permutation test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permut(distp, distt, p_overall, J_1, q_min, q_max, plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permut_+3A_distp">distp</code></td>
<td>
<p>List of squared Wasserstein distances between the control units</p>
</td></tr>
<tr><td><code id="permut_+3A_distt">distt</code></td>
<td>
<p>List of squared Wasserstein distances between the target unit and the control units</p>
</td></tr>
<tr><td><code id="permut_+3A_p_overall">p_overall</code></td>
<td>
<p>Overall p-value</p>
</td></tr>
<tr><td><code id="permut_+3A_j_1">J_1</code></td>
<td>
<p>Number of control units</p>
</td></tr>
<tr><td><code id="permut_+3A_q_min">q_min</code></td>
<td>
<p>Minimum quantile</p>
</td></tr>
<tr><td><code id="permut_+3A_q_max">q_max</code></td>
<td>
<p>Maximum quantile</p>
</td></tr>
<tr><td><code id="permut_+3A_plot">plot</code></td>
<td>
<p>ggplot object containing plot of squared Wasserstein distances over time for all permutations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class permut, with the same elements as the input arguments.
</p>

<hr>
<h2 id='plotDistOverTime'>Plot distribution of treatment effects over time</h2><span id='topic+plotDistOverTime'></span>

<h3>Description</h3>

<p>Plot distribution of treatment effects over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistOverTime(
  cdf_centered,
  grid_cdf,
  t_start,
  t_max,
  CI,
  ci_lower,
  ci_upper,
  ylim = c(0, 1),
  xlim = NULL,
  cdf = TRUE,
  xlab = "Distribution Difference",
  ylab = "CDF",
  obsLine = NULL,
  savePlots = FALSE,
  plotName = NULL,
  lty = 1,
  lty_obs = 1,
  t_plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistOverTime_+3A_cdf_centered">cdf_centered</code></td>
<td>
<p>list of centered distributional statistics</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_grid_cdf">grid_cdf</code></td>
<td>
<p>grid</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_t_start">t_start</code></td>
<td>
<p>start time</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_t_max">t_max</code></td>
<td>
<p>maximum time</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_ci">CI</code></td>
<td>
<p>logical indicating whether to plot confidence intervals</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_ci_lower">ci_lower</code></td>
<td>
<p>lower confidence interval</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_ci_upper">ci_upper</code></td>
<td>
<p>upper confidence interval</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_cdf">cdf</code></td>
<td>
<p>logical indicating whether to plot CDF or quantile difference</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_xlab">xlab</code></td>
<td>
<p>x label</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_ylab">ylab</code></td>
<td>
<p>y label</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_obsline">obsLine</code></td>
<td>
<p>optional additional line to plot. Default is NULL which means no line is plotted.</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_saveplots">savePlots</code></td>
<td>
<p>logical indicating whether to save plots</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_plotname">plotName</code></td>
<td>
<p>name of plot to save</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_lty">lty</code></td>
<td>
<p>line type for the main line passed as cdf_centered</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_lty_obs">lty_obs</code></td>
<td>
<p>line type for the optional additional line passed as obsLine</p>
</td></tr>
<tr><td><code id="plotDistOverTime_+3A_t_plot">t_plot</code></td>
<td>
<p>optional vector of times to plot. Default is NULL which means all times are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot of distribution of treatment effects over time
</p>

<hr>
<h2 id='print.permut'>print.permut</h2><span id='topic+print.permut'></span>

<h3>Description</h3>

<p>Print permutation test results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'permut'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.permut_+3A_x">x</code></td>
<td>
<p>Object of class permut</p>
</td></tr>
<tr><td><code id="print.permut_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints permutation test results
</p>

<hr>
<h2 id='summary.DiSCoT'>summary.DiSCoT</h2><span id='topic+summary.DiSCoT'></span>

<h3>Description</h3>

<p>Summary of DiSCoT object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiSCoT'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DiSCoT_+3A_object">object</code></td>
<td>
<p>DiSCoT object</p>
</td></tr>
<tr><td><code id="summary.DiSCoT_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary of DiSCoT object
</p>

<hr>
<h2 id='summary.permut'>summary.permut</h2><span id='topic+summary.permut'></span>

<h3>Description</h3>

<p>Summarize permutation test results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'permut'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.permut_+3A_object">object</code></td>
<td>
<p>Object of class permut</p>
</td></tr>
<tr><td><code id="summary.permut_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints permutation test results
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
