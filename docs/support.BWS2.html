<!DOCTYPE html><html lang="en"><head><title>Help for package support.BWS2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {support.BWS2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#support.BWS2-package'>
<p>Tools for Case 2 best-worst scaling</p></a></li>
<li><a href='#agritourism'>
<p>Potential tourists' valuation of agritourism</p></a></li>
<li><a href='#bws2.count'>
<p>Calculating count-based best&ndash;worst scaling scores</p></a></li>
<li><a href='#bws2.dataset'>
<p>Creating a dataset suitable for Case 2 best&ndash;worst scaling analysis using</p>
counting and modeling approaches</a></li>
<li><a href='#bws2.questionnaire'>
<p>Converting an orthogonal main-effect design into Case 2 best&ndash;worst scaling</p>
questions</a></li>
<li><a href='#bws2.response'>
<p>Generating artificial responses to Case 2 best-worst scaling questions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Case 2 Best-Worst Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Hideo Aizaki</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hideo Aizaki &lt;azk-r@spa.nifty.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides three basic functions that support an implementation of Case 2 (profile case) best-worst scaling. The first is to convert an orthogonal main-effect design into questions, the second is to create a dataset suitable for analysis, and the third is to calculate count-based scores. For details, see Aizaki and Fogarty (2019) &lt;<a href="https://doi.org/10.1016%2Fj.jocm.2019.100171">doi:10.1016/j.jocm.2019.100171</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DoE.base, survival</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-24 03:20:43 UTC; user</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-24 03:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='support.BWS2-package'>
Tools for Case 2 best-worst scaling
</h2><span id='topic+support.BWS2-package'></span><span id='topic+support.BWS2'></span>

<h3>Description</h3>

<p>The package has three basic functions that support an implementation of 
Case 2 (profile case) best&ndash;worst scaling. The first is to convert 
an orthogonal main-effect design into questions, the second is to create 
a dataset suitable for analysis, and the third is to calculate 
count-based scores. For details, see Aizaki and Fogarty (2019).
</p>


<h3>Details</h3>

<p>The package is under development and thus may be changed substantially in 
the future.
</p>
<p>1) Outline of Case 2 best&ndash;worst scaling
</p>
<p>Case 2 (profile case) best&ndash;worst scaling (BWS) is a question-based 
survey method to elicit preferences for attribute levels 
(See Flynn 2010, Flynn et al. 2007 and 2008, Louviere et al. 2015, and 
Marley et al. 2008 for details of the subsection). A profile (choice set) 
has three or more attributes and each attribute has two or more levels. 
The profile is expressed as a combination of attribute levels. 
Numerous profiles are constructed using experimental designs. 
Attributes shown in each profile are fixed in all the profiles and 
a combination of attribute levels in each profile is changed according 
to the profiles. A profile selected from all the constructed profiles 
is presented to respondents, who are then asked to choose the best and 
worst attribute levels in the profile. This question is repeated until 
all profiles are evaluated. Analyzing the responses enables us to 
elicit preferences for the attribute levels.
</p>
<p>A basic approach to constructing profiles is using an orthogonal 
main-effect design (OMED). Assume that the profiles have <code class="reqn">K</code> 
attributes and each attribute has <code class="reqn">L_{k}</code> levels. If all the attributes 
have the same number of levels, <code class="reqn">L</code>, a <code class="reqn">L^{K}</code> OMED is used to 
construct the profiles. Columns of the OMED correspond to attributes, 
while the rows to profiles. For example, profiles have four attributes 
and they have three levels: attribute A with levels A1, A2, and A3; 
attribute B with levels B1, B2, and B3; attribute C with levels C1, C2, 
and C3; and attribute D with levels D1, D2, and D3. A <code class="reqn">3^{4}</code> 
OMED corresponding to the assumptions is as follows (see the section 
Examples of the function <code>bws2.dataset()</code> for code to generate 
the OMED):
</p>

<table>
<tr>
 <td style="text-align: center;">
1 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;">
3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
3 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
2 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
3 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;">
2 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Suppose that attributes A, B, C, and D are assigned to the first, second, 
third, and fourth column of the OMED, respectively, and the values 1, 2, 
and 3 used in the OMED correspond to the attribute-level values in each 
attribute: 1 = A1, 2 = A2, and 3 = A3 for attribute A; 1 = B1, 2 = B2, 
and 3 = B3 for attribute B; 1 = C1, 2 = C2, and 3 = C3 for attribute C; 
and 1 = D1, 2 = D2, and 3 = D3 for attribute D. Accordingly, 
the above-mentioned OMED can be transformed into the following:
</p>

<table>
<tr>
 <td style="text-align: center;">
A1 </td><td style="text-align: center;"> B3 </td><td style="text-align: center;"> C2 </td><td style="text-align: center;"> D3 </td>
</tr>
<tr>
 <td style="text-align: center;">
A3 </td><td style="text-align: center;"> B1 </td><td style="text-align: center;"> C2 </td><td style="text-align: center;"> D2 </td>
</tr>
<tr>
 <td style="text-align: center;">
A3 </td><td style="text-align: center;"> B3 </td><td style="text-align: center;"> C3 </td><td style="text-align: center;"> D1 </td>
</tr>
<tr>
 <td style="text-align: center;">
A2 </td><td style="text-align: center;"> B3 </td><td style="text-align: center;"> C1 </td><td style="text-align: center;"> D2 </td>
</tr>
<tr>
 <td style="text-align: center;">
A2 </td><td style="text-align: center;"> B2 </td><td style="text-align: center;"> C2 </td><td style="text-align: center;"> D1 </td>
</tr>
<tr>
 <td style="text-align: center;">
A1 </td><td style="text-align: center;"> B1 </td><td style="text-align: center;"> C1 </td><td style="text-align: center;"> D1 </td>
</tr>
<tr>
 <td style="text-align: center;">
A1 </td><td style="text-align: center;"> B2 </td><td style="text-align: center;"> C3 </td><td style="text-align: center;"> D2 </td>
</tr>
<tr>
 <td style="text-align: center;">
A3 </td><td style="text-align: center;"> B2 </td><td style="text-align: center;"> C1 </td><td style="text-align: center;"> D3 </td>
</tr>
<tr>
 <td style="text-align: center;">
A2 </td><td style="text-align: center;"> B1 </td><td style="text-align: center;"> C3 </td><td style="text-align: center;"> D3</td>
</tr>

</table>

<p>The resultant OMED consists of nine rows: nine profiles, that is, nine 
Case 2 BWS questions, are constructed. For example, a profile 
corresponding to the first row of the OMED comprises A1, B3, C2, and D3. 
This means that respondents who face the question created from 
the first row of the OMED are asked to select their best and worst 
attribute levels from attribute levels A1, B3, C2, and D3, as follows:
</p>

<table>
<tr>
 <td style="text-align: center;">
Please select your best and worst attribute levels from the following four:</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: center;">
Best </td><td style="text-align: center;"> Attribute </td><td style="text-align: center;"> Worst </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> A1 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> B3 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> C2 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> D3 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>There are two approaches for analyzing responses to Case 2 BWS questions: 
a counting approach and modeling approach. The counting approach 
calculates scores on the basis of the number of times  attribute level 
<code class="reqn">i</code> is selected as the best (<code class="reqn">B_{in}</code>: B score for attribute 
level <code class="reqn">i</code>) and the worst (<code class="reqn">W_{in}</code>: W score for attribute 
<code class="reqn">i</code>) among all the questions for respondent <code class="reqn">n</code>. 
A (disaggregated) best-minus-worst (BW) score and its standardized 
variant are defined as 
</p>
<p style="text-align: center;"><code class="reqn">
BW_{in} = B_{in} - W_{in}, 
</code>
</p>

<p style="text-align: center;"><code class="reqn">
std.BW_{in} = \frac{BW_{in}}{f_{i}},
</code>
</p>
 
<p>where <code class="reqn">f_{i}</code> is the frequency with which attribute level <code class="reqn">i</code> 
appears across all questions.
</p>
<p>The modeling approach uses discrete choice models to analyze responses. 
When using the modeling approach, a model type must be selected 
according to the assumption for respondents' choice behavior in 
Case 2 BWS questions and then a dataset must be formatted as per 
the selected model. There are three standard models: paired, marginal, 
and marginal sequential models. Although the three models commonly 
assume that the respondents derive utility for each attribute level 
shown in the profile, the assumption for how they select 
the best and worst attribute levels from the set of attribute levels 
in the profile differs among the three models.
</p>
<p>The number of possible pairs in which attribute level <code class="reqn">i</code> is selected 
as the best and attribute level <code class="reqn">j</code> is selected as 
the worst (<code class="reqn">i \neq j</code>) from <code class="reqn">K</code> attribute levels is 
<code class="reqn">K \times (K - 1)</code>. The paired model assumes that respondents select 
attribute level <code class="reqn">i</code> as the best and attribute level <code class="reqn">j</code> as 
the worst because the difference in utility between <code class="reqn">i</code> and 
<code class="reqn">j</code> represents the greatest utility difference 
among <code class="reqn">K \times (K - 1)</code> utility differences. 
Consider the example profile mentioned above. It contains four 
attribute levels: A1, B3, C2, and D3. The number of possible pairs 
is <code class="reqn">12</code> <code class="reqn">(= 4 \times (4 - 1))</code>. There are 12 possible pairs 
of the best and worst attribute levels (in each pair, 
the former is the best and the latter is the worst): (A1, B3), (A1, C2), 
(A1, D3), (B3, A1), (B3, C2), (B3, D3), (C2, A1), (C2, B3), (C2, D3), 
(D3, A1), (D3, B3), and (D3, C2). 
If a respondent selects A1 as the best attribute level and C2 as 
the worst, the paired model assumes that the respondent calculates 12 
utility differences as per the 12 above-mentioned pairs and that 
the difference in utility between A1 and C2 is the maximum among 
the 12 utility differences.
</p>
<p>The marginal model assumes that there are <code class="reqn">K</code> possible best 
attribute levels and <code class="reqn">K</code> possible worst attribute levels 
in a profile, that attribute level <code class="reqn">i</code> is selected as 
the best from <code class="reqn">K</code> possible best attribute levels in the profile, 
and that attribute level <code class="reqn">j</code> is selected as the worst 
from <code class="reqn">K</code> possible worst attribute levels. This is because the 
utility for attribute level <code class="reqn">i</code> is the maximum among 
the utilities for <code class="reqn">K</code> attribute levels and that for attribute level 
<code class="reqn">j</code> is the minimum. Following the above example, the marginal model 
assumes that there are four possible best attribute levels and four 
possible worst attribute levels in the profile and interprets 
the respondent's choice behavior as follows: utility for A1 is 
the maximum among the four utilities for A1, B3, C2, and D3 and 
that for C2 is the minimum among the four.
</p>
<p>The assumption of the marginal model that the worst attribute level is 
selected from <code class="reqn">K</code> attribute levels would not be appropriate 
because the best attribute level in a profile must differ from 
the worst one in the profile. Thus, the marginal sequential model 
assumes that respondents select attribute level <code class="reqn">i</code> as the best 
from <code class="reqn">K</code> attribute levels in the profile and then attribute level 
<code class="reqn">j</code> as the worst from the remaining <code class="reqn">K - 1</code> attribute levels. 
Following the above example, under the marginal sequential 
model assumption, there are four possible best attribute levels and 
three possible worst attribute levels in the profile. 
The model considers that the respondent selects A1 as the best from 
the four possible attribute levels because the utility for A1 is 
the highest among the utilities for A1, B3, C2, and D3, but selects C2 
as the worst from three possible worst levels, B3, C2, and D3, 
because the utility for C2 is the least among the three.
</p>
<p>The three models generally assume that the utility for attribute level 
<code class="reqn">i</code> selected as the worst is the negative of the one selected as 
the best. Under these assumptions, and given the assumption for 
the stochastic component of utility, the probability of selecting 
attribute level <code class="reqn">i</code> as the best and attribute level <code class="reqn">j</code> as 
the worst can be expressed as a conditional logit model.
</p>
<p>2) Role of the package and other packages needed to complete implementing 
Case 2 BWS
</p>
<p>The package <span class="pkg">support.BWS2</span> provides functions to convert an OMED 
into a series of Case 2 BWS questions, create a dataset for the analysis 
from the OMED and the responses to the questions, and calculate BWS scores. 
Other packages are needed to complete implementing Case 2 BWS with R: 
a package to construct OMEDs and another to analyze the responses 
on the basis of the modeling approach. For example, 
the <code>oa.design()</code> function in <span class="pkg">DoE.base</span> (Groemping 2018) can 
construct OMEDs, while the functions <code>clogit()</code> in <span class="pkg">survival</span> 
(Therneau 2016), <code>mlogit()</code> in <span class="pkg">mlogit</span> (Croissant 2013), 
and <code>gmnl()</code> in <span class="pkg">gmnl</span> (Sarrias and Daziano 2017) can fit 
the conditional logit model. The latter two functions are also used 
to fit advanced discrete choice models 
such as a mixed (random parameters) logit model. Refer to the task views
about experimental designs (Groemping 2016) and econometrics (Zeileis 2017) 
on CRAN for details on packages for experimental designs and 
discrete choice models in R.
</p>


<h3>Acknowledgments</h3>

<p>I would like to thank Professor Kazuo Sato for his kind support. 
This work was supported by JSPS KAKENHI Grant Numbers 25450341, 16K07886, 
and 20K06251.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>References</h3>

<p>Aizaki H, Fogarty J (2019) 
An R package and tutorial for case 2 best-worst scaling. 
<em>Journal of Choice Modelling</em>, <b>32</b>, 100171. 
doi: 10.1016/j.jocm.2019.100171.
</p>
<p>Flynn TN (2010) Valuing citizen and patient preferences in health: 
recent developments in three types of best-worst scaling. 
<em>Expert Review of Pharmacoeconomics &amp; Outcomes Research</em>, 
<b>10</b>(3), 259&ndash;267.
doi: 10.1586/erp.10.29.
</p>
<p>Flynn TN, Louviere JJ, Peters TJ, Coast J (2007) Best-Worst Scaling: 
What it can do for health care research and how to do it. 
<em>Journal of Health Economics</em>, <b>26</b>, 171&ndash;189.
doi: 10.1016/j.jhealeco.2006.04.002.
</p>
<p>Flynn TN, Louviere JJ, Peters TJ, Coast J (2008) Estimating 
preferences for a dermatology consultation using best-worst scaling: 
Comparison of various methods of analysis. 
<em>BMC Medical Research Methodology</em>, <b>8</b>(76). 
doi: 10.1186/1471-2288-8-76.
</p>
<p>Croissant Y (2013) <em>mlogit: multinomial logit model</em>. 
R package version 0.2-4. 
<a href="https://CRAN.R-project.org/package=mlogit">https://CRAN.R-project.org/package=mlogit</a>.
</p>
<p>Groemping U (2018) R Package DoE.base for Factorial Experiments.
<em>Journal of Statistical Software</em>, <b>85</b>(5), 1&ndash;41.
doi: 10.18637/jss.v085.i05.
</p>
<p>Groemping U (2016) <em>CRAN Task View: Design of Experiments (DoE) &amp;
Analysis of Experimental Data</em>. 
<a href="https://CRAN.R-project.org/view=ExperimentalDesign">https://CRAN.R-project.org/view=ExperimentalDesign</a>.
</p>
<p>Hensher DA, Rose JM, Greene WH (2015) <em>Applied Choice Analysis</em>. 
2nd edition. Cambridge University Press.
doi: 10.1017/CBO9781316136232.
</p>
<p>Louviere JJ, Flynn TN, Marley AAJ (2015) <em>Best-Worst Scaling: 
Theory, Methods and Applications</em>. Cambridge University Press.
doi: 10.1017/CBO9781107337855.
</p>
<p>Marley AAJ, Flynn TN, Louviere JJ (2008) Probabilistic models of 
set-dependent and attribute-level best-worst choice. 
<em>Journal of Mathematical Psychology</em>, <b>52</b>, 281&ndash;296.
doi: 10.1016/j.jmp.2008.02.002.
</p>
<p>Sarrias M, Daziano R (2017) 
Multinomial Logit Models with Continuous and Discrete Individual Heterogeneity in R: The gmnl Package.
<em>Journal of Statistical Software</em>, <b>79</b>(2), 1&ndash;46. 
doi: 10.18637/jss.v079.i02.
</p>
<p>Therneau T (2015) <em>A Package for Survival Analysis in S</em>. 
Version 2.38, 
<a href="https://CRAN.R-project.org/package=survival">https://CRAN.R-project.org/package=survival</a>.
</p>
<p>Zeileis A (2017) <em>CRAN Task View: Econometrics</em>. 
<a href="https://CRAN.R-project.org/view=Econometrics">https://CRAN.R-project.org/view=Econometrics</a>.
</p>

<hr>
<h2 id='agritourism'>
Potential tourists' valuation of agritourism
</h2><span id='topic+agritourism'></span>

<h3>Description</h3>

<p>This dataset contains responses to Case 2 BWS questions. Respondents were asked to evaluate agritourism packages provided by dairy farms in Hokkaido, Japan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(agritourism)
</code></pre>


<h3>Format</h3>

<p>A data frame with 240 respondents on the following 21 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identification number of respondents.</p>
</dd>
<dt><code>b1</code></dt><dd><p>Item selected as the best in question 1.</p>
</dd>
<dt><code>w1</code></dt><dd><p>Item selected as the worst in question 1.</p>
</dd>
<dt><code>b2</code></dt><dd><p>Item selected as the best in question 2.</p>
</dd>
<dt><code>w2</code></dt><dd><p>Item selected as the worst in question 2.</p>
</dd>
<dt><code>b3</code></dt><dd><p>Item selected as the best in question 3.</p>
</dd>
<dt><code>w3</code></dt><dd><p>Item selected as the worst in question 3.</p>
</dd>
<dt><code>b4</code></dt><dd><p>Item selected as the best in question 4.</p>
</dd>
<dt><code>w4</code></dt><dd><p>Item selected as the worst in question 4.</p>
</dd>
<dt><code>b5</code></dt><dd><p>Item selected as the best in question 5.</p>
</dd>
<dt><code>w5</code></dt><dd><p>Item selected as the worst in question 5.</p>
</dd>
<dt><code>b6</code></dt><dd><p>Item selected as the best in question 6.</p>
</dd>
<dt><code>w6</code></dt><dd><p>Item selected as the worst in question 6.</p>
</dd>
<dt><code>b7</code></dt><dd><p>Item selected as the best in question 7.</p>
</dd>
<dt><code>w7</code></dt><dd><p>Item selected as the worst in question 7.</p>
</dd>
<dt><code>b8</code></dt><dd><p>Item selected as the best in question 8.</p>
</dd>
<dt><code>w8</code></dt><dd><p>Item selected as the worst in question 8.</p>
</dd>
<dt><code>b9</code></dt><dd><p>Item selected as the best in question 9.</p>
</dd>
<dt><code>w9</code></dt><dd><p>Item selected as the worst in question 9.</p>
</dd>
<dt><code>gender</code></dt><dd><p>Respondents' gender: 1 = male; 2 = female.</p>
</dd>
<dt><code>age</code></dt><dd><p>Respondents' age: 2 = 20s; 3 = 30s; 4 = 40s; 5 = 50s</p>
</dd>
</dl>

<p>See the section Examples for details.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS2-package">support.BWS2-package</a></code>, 
<code><a href="#topic+bws2.dataset">bws2.dataset</a></code>, 
<code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Agritourism refers to various activities offered by farms and ranches
# to visitors, such as hands-on farm work or outdoor recreation.
#
# In the Case 2 BWS questions, respondents were asked to evaluate 
# agritourism packages provided by dairy farms (ranches) in Hokkaido, Japan. 
# We assumed that the agritourism package consists of the following four
# types of activities, each with three activity items:
#  1. Hands-on ranch chores
#    (1) Milking a cow
#    (2) Feeding a cow
#    (3) Nursing a calf
#  2. Hands-on food processing
#    (1) Butter making
#    (2) Ice-cream making
#    (3) Creamy caramel making
#  3. Hands-on craft making
#    (1) Making a product from wool
#    (2) Making a product from wood
#    (3) Making a product from pressed flowers
#  4. Outdoor activities
#    (1) Horse riding
#    (2) Tractor riding
#    (3) Walking with cows
#
# As there are four activities and each activity has three items, 
# a total of nine BWS questions were created using a three-level OMED
# with four columns. Each BWS question asked respondents to select
# the most and least interesting of the four activities shown 
# in the question.
#
# In the following, we assume that the paired and marginal models with
# both attribute and attribute-level variables (Flynn et al. 2007; 2008)
# are fitted to the responses using the conditional logit model, 
# with clogit() in the survival package.

# Load the package needed for the example:
require(survival)

options(digits = 4)

# The following OMED is generated using oa.design() in the DoE.base package:
# require(DoE.base)
# des &lt;- data.matrix(
#    oa.design(nl = c(3,3,3,3), randomize = FALSE))
des &lt;- cbind(
  c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  c(1, 2, 3, 1, 2, 3, 1, 2, 3),
  c(1, 3, 2, 3, 2, 1, 2, 1, 3),
  c(1, 2, 3, 3, 1, 2, 2, 3, 1))

# The names of the attributes (activities) and attribute levels 
# (activity items) were stored in the list attr.lev:
attr.lev &lt;- list(
  chore = c("milking", "feeding", "nursing"),
  food = c("butter", "ice", "caramel"),
  craft = c("wool", "wood", "flower"),
  outdoor = c("horse", "tractor", "cow"))

# A series of Case 2 BWS questions were converted from the OMED using 
# bws2.questionnaire():
bws2.questionnaire(choice.sets = des, attribute.levels = attr.lev,
  position = "left")

# The responses to the questions were stored in the dataset agritourism
# in the support.BWS2 package:
data(agritourism)
dim(agritourism)
colnames(agritourism)

# The names of the response variables used in the dataset agritourism
# were stored in the vector response.vars:
response.vars &lt;- colnames(agritourism)[2:19]
response.vars

# The base level in each attribute was stored in the object base.lev
# in list format:
base.lev &lt;- list(
  chore = c("nursing"),
  food = c("caramel"),
  craft = c("flower"),
  outdoor = c("cow"))

# The datasets for the paired model and the marginal model were created
# using bws2.dataset() and then stored in the objects pr.data1 and mr.data1,
# respectively:
pr.data1 &lt;- bws2.dataset(
  data = agritourism,
  id = "id",
  response = response.vars,  
  choice.sets = des,        
  attribute.levels = attr.lev,
  reverse = TRUE,
  base.level = base.lev,
  model = "paired") 
mr.data1 &lt;- bws2.dataset(
  data = agritourism,
  id = "id",
  response = response.vars,
  choice.sets = des,
  attribute.levels = attr.lev,
  reverse = TRUE,
  base.level = base.lev,
  model = "marginal")
dim(pr.data1)
names(pr.data1)
dim(mr.data1)
names(mr.data1)

# The BWS scores were calculated using bws2.count() with the dataset for
# the marginal model:
scores &lt;- bws2.count(mr.data1)
dim(scores)
names(scores)

# The scores for each level were aggregated among all respondents using
# sum() and bar plots of the scores were drawn using barplot():
sum(scores, "level")
barplot(scores, "bw", "level")

# If we only need aggregated B and W scores, these can be calculated from
# the dataset for a paired model as follows:
apply(pr.data1[pr.data1$RES == 1, c("BEST.LV", "WORST.LV")], 2, table)

# BW scores can be calculated according to groups of respondents. 
# For example, the scores for male and those for female are given as follows:
sum(scores[agritourism$gender == 1, ], "level")
sum(scores[agritourism$gender == 2, ], "level")

# Bar plots for respondents in their 20s and those in their 50s can also be
# drawn using the following lines of code:
barplot(scores[agritourism$age == 2, ], "bw", "level")
barplot(scores[agritourism$age == 5, ], "bw", "level")

# We fitted the conditional logit model to the Case 2 BWS responses 
# on the basis of the paired and marginal models with both attribute
# and attribute-level variables. The systematic component of the utility
# function for the example is
#    v = b1 chore + b2 food + b3 outdoor + 
#        b4 milking + b5 feeding + b6 butter + b7 ice +
#        b8 wool + b9 wood + b10 horse + b11 tractor
# where chore, food, and outdoor are attribute variables (craft has been
# omitted); and milking, feeding, butter, ice, wool, wood, horse, and
# tractor are attribute-level variables (nursing has been omitted for chore,
# caramel has been omitted for food, flower has been omitted for craft,
# and cow has been omitted for outdoor); bs are coefficients to be estimated.
#
# The model formula for clogit(), corresponding to the systematic component
# mentioned above, is described as:
mf &lt;- RES ~ chore + food + outdoor + 
            milking + feeding + butter + ice + 
            wool + wood + horse + tractor +
            strata(STR)

# We fitted the paired model using clogit() with the dataset pr.data1:
pr.out &lt;- clogit(formula = mf, data = pr.data1)
pr.out

# The attribute-level variables are effect-coded ones, and thus the 
# coefficient of the base level in each attribute can be calculated using:
b &lt;- coef(pr.out)
(nursing &lt;- -sum(b[4:5]))
names(nursing) &lt;- "nursing"
(caramel &lt;- -sum(b[6:7]))
names(caramel) &lt;- "caramel"
(flower &lt;- -sum(b[8:9]))
names(flower) &lt;- "flower"
(cow &lt;- -sum(b[10:11]))
names(cow) &lt;- "cow"
craft &lt;- 0
names(craft) &lt;- "craft"
paired.model &lt;- c(b[1:2], craft, b[3], b[4:5], nursing, b[6:7],
  caramel, b[8:9], flower, b[10:11], cow)
barplot(paired.model)

# The following code is for the marginal model: 
mr.out &lt;- clogit(formula = mf, data = mr.data1)
mr.out
b &lt;- coef(mr.out)
(nursing &lt;- -sum(b[4:5]))
names(nursing) &lt;- "nursing"
(caramel &lt;- -sum(b[6:7]))
names(caramel) &lt;- "caramel"
(flower &lt;- -sum(b[8:9]))
names(flower) &lt;- "flower"
(cow &lt;- -sum(b[10:11]))
names(cow) &lt;- "cow"
marginal.model &lt;- c(b[1:2], craft, b[3], b[4:5], nursing, b[6:7],
  caramel, b[8:9], flower, b[10:11], cow)
barplot(marginal.model)

# As mentioned in Flynn et al. (2008), the results from the paired model
# are similar to those from the marginal model: the correlation coefficient
# for the two results is calculated as follows:
cor(marginal.model, paired.model)
plot(marginal.model, paired.model, 
  xlim = c(-0.5, 1), ylim = c(-0.5, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='bws2.count'>
Calculating count-based best&ndash;worst scaling scores
</h2><span id='topic+bws2.count'></span><span id='topic+barplot.bws2.count'></span><span id='topic+sum.bws2.count'></span>

<h3>Description</h3>

<p>This function calculates best, worst, best-minus-worst, and standardized 
best-minus-worst scores for each respondent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws2.count(data, ...)

## S3 method for class 'bws2.count'
barplot(height, score = c("bw", "b", "w"), 
  output = c("level", "attribute"), mfrow = NULL, ...)

## S3 method for class 'bws2.count'
sum(x, output = c("level", "attribute"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws2.count_+3A_data">data</code></td>
<td>

<p>A data frame containing the dataset generated from 
<code>bws2.dataset()</code>.
</p>
</td></tr>
<tr><td><code id="bws2.count_+3A_x">x</code>, <code id="bws2.count_+3A_height">height</code></td>
<td>

<p>An object of the S3 class &lsquo;bws2.count&rsquo;.
</p>
</td></tr>
<tr><td><code id="bws2.count_+3A_output">output</code></td>
<td>

<p>A character showing a type of BWS score calculated by this function: 
<code>"attribute"</code> is assigned to this argument when BWS scores for 
attributes are calculated or <code>"level"</code> is assigned when BWS scores 
for attribute levels are calculated.
</p>
</td></tr>
<tr><td><code id="bws2.count_+3A_score">score</code></td>
<td>

<p>A character showing a type of the output from this function: <code>"b"</code> is 
assigned to this argument when the output is based on best scores, <code>"w"</code> 
is assigned when it is based on worst scores, or <code>"bw"</code> is assigned 
when it is based on best-minus-worst scores.
</p>
</td></tr>
<tr><td><code id="bws2.count_+3A_mfrow">mfrow</code></td>
<td>

<p>A two-element vector <code>c(nr, nc)</code>; bar plots will be drawn in an 
<code>nr</code>-by-<code>nc</code> array on the device by row.
</p>
</td></tr>
<tr><td><code id="bws2.count_+3A_...">...</code></td>
<td>

<p>Arguments passed to function(s) used internally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bws2.count()</code> function calculates disaggregated best (B), 
worst (W), best-minus-worst (BW), and standardized BW scores. 
For details on these scores, refer to the Details section on 
the help page of this package.
</p>
<p>Output from this function is the object of S3 class &lsquo;bws2.count&rsquo;, 
which inherits from the S3 class &lsquo;data.frame&rsquo;. The generic functions 
such as <code>barplot()</code> and <code>sum()</code> are available for the S3 class 
&lsquo;bws2.count&rsquo;. The <code>barplot()</code> function draws the bar plots of 
B, W, or BW scores for each attribute when <code>output = "attribute"</code> or 
those for each attribute level when <code>output = "level"</code>. 
The <code>sum</code> function returns a data frame containing B, W, BW, and 
standardized BW scores for all respondents for each attribute 
when <code>output = "attribute"</code> or for each attribute level 
when <code>output = "level"</code>.
</p>


<h3>Value</h3>

<p>The output from <code>bws2.count()</code>, which is the object of the S3 class 
&lsquo;bws2.count&rsquo;, is a data frame containing six types of variables: 
respondent's identification variable, B score variables, W score variables, 
BW score variables, standardized BW score variables, and respondent's 
characteristic variables. These scores are 
calculated by each respondent. The names of these score variables are 
<code>b.&lt;name of attribute or attribute level&gt;</code>, 
<code>w.&lt;name of attribute or attribute level&gt;</code>, 
<code>bw.&lt;name of attribute or attribute level&gt;</code>, and 
<code>sbw.&lt;name of attribute or attribute level&gt;</code>. 
Part <code>&lt;name of attribute or attribute level&gt;</code> for each score variable 
is set according to the argument <code>attribute.levels</code> in 
<code>bws2.dataset()</code> used to generate a dataset for <code>bws2.count()</code>.
</p>
<p>The output has the following attributes:
</p>
<table role = "presentation">
<tr><td><code>nquestions</code></td>
<td>

<p>A vector showing the number of questions.
</p>
</td></tr>
<tr><td><code>nrespondents</code></td>
<td>

<p>A vector showing the number of respondents.
</p>
</td></tr>
<tr><td><code>freq.levels</code></td>
<td>

<p>A variable showing the frequency of each attribute level in the choice sets.
</p>
</td></tr>
<tr><td><code>attribute.levels</code></td>
<td>

<p>A list of attributes and their levels, which is the same as those assigned 
to argument <code>attribute.levels</code> in <code>bws2.dataset()</code> used to 
generate a dataset assigned to argument <code>data</code> of <code>bws2.count()</code>.
</p>
</td></tr>
<tr><td><code>vnames</code></td>
<td>

<p>A variable showing the names of each attribute level.
</p>
</td></tr>
<tr><td><code>b.names</code></td>
<td>

<p>A variable showing the names of B score by each attribute level.
</p>
</td></tr>
<tr><td><code>w.names</code></td>
<td>

<p>A variable showing the names of W score by each attribute level.
</p>
</td></tr>
<tr><td><code>bw.names</code></td>
<td>

<p>A variable showing the names of BW score by each attribute level.
</p>
</td></tr>
<tr><td><code>sbw.names</code></td>
<td>

<p>A variable showing the names of standardized BW score by each attribute level.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS2-package">support.BWS2-package</a></code>, <code><a href="#topic+bws2.dataset">bws2.dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in bws2.dataset()
</code></pre>

<hr>
<h2 id='bws2.dataset'>
Creating a dataset suitable for Case 2 best&ndash;worst scaling analysis using 
counting and modeling approaches
</h2><span id='topic+bws2.dataset'></span><span id='topic+bws2.dataset.marginal'></span><span id='topic+bws2.dataset.paired'></span>

<h3>Description</h3>

<p>This function creates a dataset used for <code>bws2.count()</code> in 
<span class="pkg">support.BWS2</span> and functions for discrete choice models such as 
<code>clogit()</code> in <span class="pkg">survival</span>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws2.dataset(data, id, response, choice.sets, attribute.levels, 
  base.attribute = NULL, base.level = NULL, 
  reverse = TRUE, model = "paired",
  attribute.variables = NULL, effect = NULL, delete.best = FALSE, 
  type = c("paired", "marginal", "sequential"), 
   ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws2.dataset_+3A_data">data</code></td>
<td>

<p>A data frame containing a respondent dataset.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_id">id</code></td>
<td>

<p>A character showing the name of the respondent identification number 
variable used in the respondent dataset.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_response">response</code></td>
<td>

<p>A vector containing the names of response variables in the respondent 
dataset, showing the best and worst attribute levels selected in each 
Case 2 BWS question.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_choice.sets">choice.sets</code></td>
<td>

<p>A data frame or matrix containing an orthogonal main-effect design.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_attribute.levels">attribute.levels</code></td>
<td>

<p>A list containing the names of the attributes and their levels.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_base.attribute">base.attribute</code></td>
<td>

<p>A character showing the base attribute: the argument is used 
when attribute variables are created as effect coded ones and <code>NULL</code> 
is assigned to the argument when attribute variables are created as
dummy coded ones.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_base.level">base.level</code></td>
<td>

<p>A list containing the base level in each attribute: the argument is used 
when attribute level variables are created as effect coded ones and 
<code>NULL</code> is assigned to the argument when attribute level 
variables are created as dummy coded ones.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_reverse">reverse</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when the signs of the attribute 
variables are reversed for the possible worst, 
or otherwise <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_model">model</code></td>
<td>

<p>A character showing a type of dataset created by this function: 
<code>"paired"</code> for a paired model, <code>"marginal"</code> for a 
marginal model, and <code>"sequential"</code> for a marginal sequential model.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_attribute.variables">attribute.variables</code></td>
<td>

<p>A character showing a type of attribute variables, denoted by 
<code>"reverse"</code> when the attribute variables take the value of 
<code>1</code> for a possible best, <code>-1</code> for a possible worst, and 
<code>0</code> otherwise, or <code>"constant"</code> when the attribute variables 
are created as attribute-specific constants. The argument is deprecated.
Please use the argument <code>reverse</code> instead.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_effect">effect</code></td>
<td>

<p>A list containing the base level in each attribute: the argument is used 
when attribute level variables are created as effect coded ones and 
while <code>NULL</code> is assigned to the argument when attribute level 
variables are created as dummy coded ones. The argument is deprecated.
Please use the argument <code>base.level</code> instead.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_delete.best">delete.best</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when deleting an attribute level 
selected as the best in the worst choice set (that is, using a marginal 
sequential model) or <code>FALSE</code> when not doing so. 
The argument is deprecated. Please use the argument <code>model</code> instead.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_type">type</code></td>
<td>

<p>A character showing a type of dataset created by this function: 
<code>"paired"</code> for a paired model, <code>"marginal"</code> for a 
marginal model, and <code>"sequential"</code> for a marginal sequential model. 
The argument is deprecated. Please use the argument <code>model</code> instead.
</p>
</td></tr>
<tr><td><code id="bws2.dataset_+3A_...">...</code></td>
<td>

<p>Optional arguments; currently not in use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The respondent dataset, in which each row corresponds to a respondent, 
must be organized by users and then assigned to the argument <code>data</code>. 
The dataset must include the respondent's identification number (id) 
variable in the first column and the response variables in the subsequent 
columns, each indicating which attribute levels are selected as 
the best and worst for each question. Other variables in the respondent 
dataset are treated as the respondents' characteristics such as gender 
and age. Respondents' characteristic variables are also stored in 
the resultant dataset created by the function <code>bws2.dataset()</code>. 
Although the names of the id and response variables are left to 
the discretion of the user, those of the id and response variables are 
assigned to the arguments <code>id</code> and <code>response</code>. 
</p>
<p>The response variables must be constructed such that the best attribute 
levels alternate with the worst by question. For example, when there are 
nine BWS questions, the variables are B1, W1, B2, W2, ..., B9, and W9. 
Here, B<code class="reqn">i</code> and W<code class="reqn">i</code> show the attribute levels selected 
as the best and worst in the <code class="reqn">i</code>-th question. 
The row numbers of the attribute levels 
selected as the best and worst are stored in the response variables. 
For example, suppose that a respondent was asked to answer the following 
BWS question, which is the same as that shown on the help page of 
this package, and then selected A1 (attribute level in the first row) as 
the best and C2 (attribute level in the third row) as the worst.
</p>

<table>
<tr>
 <td style="text-align: center;">
Please select your best and worst attribute levels from the following four:</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: center;">
Best </td><td style="text-align: center;"> Attribute </td><td style="text-align: center;"> Worst </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> A1 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> B3 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> C2 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
[_] </td><td style="text-align: center;"> D3 </td><td style="text-align: center;"> [_] </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The response variables B1 and W1, corresponding to the respondent's answer 
to this question, take the value of <code>1</code> (= the attribute level in 
the first row) and <code>3</code> (= the attribute level in the third row).
</p>
<p>The arguments <code>choice.sets</code> and <code>attribute.levels</code> are 
the same as those in <code>bws2.questionnaire()</code>. 
The order of questions in the respondent dataset has to be 
the same as that in <code>choice.sets</code>.
</p>
<p>The arguments <code>type</code>, <code>reverse</code>, <code>base.attribute</code>, 
and <code>base.level</code> are set according to the model you will use: 
argument <code>type</code> is set as <code>"paired"</code> for the paired model, 
<code>"marginal"</code> for the marginal model, or <code>"sequential"</code> for 
the marginal sequential model; 
the argument <code>reverse</code> is set as <code>"TRUE"</code> for a model 
in which the signs of the attribute variables are reversed 
for the possible worst (Flynn et al. 2007 and 2008), 
or <code>FALSE</code> when not doing so (Hensher et al. 2015, Appendix 6B); 
the argument <code>base.attribute</code> is set as a character vector showing 
the base attribute for a marginal (sequential) model with effect-coded 
attribute variables;
and the argument <code>base.level</code> is set as a list containing the base level 
in each attribute for a model with effect-coded level variables 
(Flynn et al. 2007 and 2008), while it is set as <code>NULL</code> for a model
with dummy-coded attribute level variables (Hensher et al. 2015, Appendix 6B).
</p>
<p>Note that the arguments <code>attribute.variables</code>, <code>effect</code>, 
<code>delete.best</code>, and <code>type</code> are deprecated and will be removed 
in the future.
</p>


<h3>Value</h3>

<p>The function returns a dataset in data frame format for the paired model 
or one for the marginal (sequential) model. The dataset for the paired 
model contains the following variables and attribute and/or 
attribute-level variables explained above:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>A respondent's identification number; the actual name and 
values of this variable is set according to the id variable in 
the respondent dataset.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A serial number of BWS questions.</p>
</td></tr>
<tr><td><code>PAIR</code></td>
<td>
<p>A serial number for the possible pairs of the best and worst 
attribute levels for each question.</p>
</td></tr>
<tr><td><code>BEST</code></td>
<td>
<p>An attribute-level number treated as the best in the possible 
pairs of the best and worst attribute levels for each question.</p>
</td></tr>
<tr><td><code>WORST</code></td>
<td>
<p>An attribute-level number treated as the worst in the possible 
pairs of the best and worst attribute levels for each question.</p>
</td></tr>
<tr><td><code>BEST.AT</code></td>
<td>
<p>A character showing the attribute corresponding to 
the attribute level treated as the best in the possible pairs of 
the best and worst attribute levels for each question.</p>
</td></tr>
<tr><td><code>WORST.AT</code></td>
<td>
<p>A character showing the attribute corresponding to 
the attribute level treated as the worst in the possible pairs of 
the best and worst attribute levels for each question.</p>
</td></tr>
<tr><td><code>BEST.LV</code></td>
<td>
<p>A character showing the attribute level treated as 
the best in the possible pairs of the best and worst attribute levels 
for each question.</p>
</td></tr>
<tr><td><code>WORST.LV</code></td>
<td>
<p>A character showing the attribute level treated as 
the worst in the possible pairs of the best and worst attribute levels 
for each question.</p>
</td></tr>
<tr><td><code>RES.B</code></td>
<td>
<p>A row number in the profile corresponding to 
the attribute level selected as the best by respondents.</p>
</td></tr>
<tr><td><code>RES.W</code></td>
<td>
<p>A row number in the profile corresponding to 
the attribute level selected as the worst by respondents.</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>
<p>Responses to BWS questions that takes the value of <code>1</code> 
if a possible pair of the best and worst attribute levels is selected 
by respondents and <code>0</code> otherwise: this variable is used as 
a dependent variable in the model formula of the function for discrete 
choice analysis (e.g., <code>clogit()</code> in the package 
<span class="pkg">survival</span>).</p>
</td></tr>
<tr><td><code>STR</code></td>
<td>
<p>A stratification variable identifying each combination of 
respondent and question; the variable is also used in the model formula 
of <code>clogit()</code>.</p>
</td></tr>
</table>
<p>The dataset for the marginal (sequential) model contains the variables 
<code>id</code>, <code>Q</code>, <code>RES.B</code>, <code>RES.W</code>, and <code>STR</code> 
mentioned above and the following variables:
</p>
<table role = "presentation">
<tr><td><code>ALT</code></td>
<td>
<p>A serial number of alternatives (attribute levels) for 
each question.</p>
</td></tr>
<tr><td><code>BW</code></td>
<td>
<p>A state variable that takes the value of <code>1</code> for 
the possible best attribute levels and <code>-1</code> for 
the possible worst attribute levels.</p>
</td></tr>
<tr><td><code>ATT.cha</code></td>
<td>
<p>A character showing the attribute corresponding to 
the attribute level treated as the possible best or worst for each question.</p>
</td></tr>
<tr><td><code>ATT</code></td>
<td>
<p>An attribute number showing the attribute corresponding to 
the attribute level treated as the possible best or worst for each question.</p>
</td></tr>
<tr><td><code>LEV.cha</code></td>
<td>
<p>A character showing the attribute levels treated as 
the possible best or worst for each question.</p>
</td></tr>
<tr><td><code>LEV</code></td>
<td>
<p>An attribute level number showing the attribute level 
treated as the possible best or worst for each question.</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>
<p>Responses to BWS questions that takes the value of <code>1</code> 
if the possible best or worst attribute level is selected 
by respondents and <code>0</code> otherwise.</p>
</td></tr>
</table>
<p>The output has its attributes that consist of arguments assigned to 
this function (i.e., <code>id</code>, <code>response</code>, <code>choice.sets</code>, 
<code>attribute.levels</code>, <code>reverse</code>, <code>base.attribute</code>, 
<code>base.level</code>, <code>attribute.variables</code>, <code>effect</code>, 
<code>delete.best</code>, and <code>type</code>) and the following:
</p>
<table role = "presentation">
<tr><td><code>design.matrix</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code>lev.var.wo.ref</code></td>
<td>
<p>Names of attribute-level variables excluding 
base levels.</p>
</td></tr>
<tr><td><code>freq.levels</code></td>
<td>
<p>Frequency of attribute levels shown in 
all the questions.</p>
</td></tr>
<tr><td><code>respondent.characteristics</code></td>
<td>
<p>Names of variables corresponding to 
the respondents' characteristics: variables, except for the respondents' 
id and response variables, are considered the respondents' characteristics.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS2-package">support.BWS2-package</a></code>, 
<code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>, 
<code><a href="survival.html#topic+clogit">clogit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load package survival used for a conditional logit model analysis of
# the responses
require(survival)

# Set a three-level orthogonal main-effect design (OMED) with
# four columns
omed &lt;- matrix(
  c(1,3,2,3,
    3,1,2,2,
    3,3,3,1,
    2,3,1,2,
    2,2,2,1,
    1,1,1,1,
    1,2,3,2,
    3,2,1,3,
    2,1,3,3),
  nrow = 9, ncol = 4, byrow = TRUE)
omed
## The OMED is generated by executing the following lines of code:
## require(DoE.base)
## set.seed(123)
## omed &lt;- data.matrix(oa.design(nl = c(3, 3, 3, 3)))

# Set the names of the attributes and attribute levels
attr.lev &lt;- list(
  A = c("A1","A2","A3"), B = c("B1","B2","B3"),
  C = c("C1","C2","C3"), D = c("D1","D2","D3"))

# Convert the OMED into Case 2 BWS questions using three formats:
## Attribute column is located on the left-hand side
bws2.questionnaire(omed, attribute.levels = attr.lev,
  position = "left") 
## Attribute column is located in the center
bws2.questionnaire(omed, attribute.levels = attr.lev,
  position = "center")
## Attribute column is located on the right-hand side
bws2.questionnaire(omed, attribute.levels = attr.lev,
  position = "right") 

# Set respondent dataset containing 20 respondents who answered 
# nine BWS questions
resp.data &lt;- data.frame(
  id = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20),
  B1 = c(2,2,2,1,2,4,2,2,2,2,1,2,2,4,2,3,2,3,2,2),
  W1 = c(1,1,1,4,1,3,3,1,4,1,4,4,1,1,1,4,1,1,4,4),
  B2 = c(1,1,2,1,1,3,1,1,1,1,2,1,1,2,1,3,1,3,1,1),
  W2 = c(2,4,4,4,4,2,4,2,4,2,4,4,4,4,2,4,4,1,4,4),
  B3 = c(1,1,2,1,2,1,1,1,1,2,1,1,1,2,1,1,1,1,3,1),
  W3 = c(4,4,4,2,4,4,4,3,4,3,4,4,3,1,4,4,3,4,4,4),
  B4 = c(1,2,2,1,2,1,2,2,2,1,2,4,2,2,2,4,2,2,1,2),
  W4 = c(3,4,3,2,3,3,3,1,4,3,3,3,4,3,3,1,4,3,4,4),
  B5 = c(1,2,2,1,2,1,2,1,3,1,1,1,3,1,1,1,3,1,1,1),
  W5 = c(4,1,3,4,4,4,3,4,4,4,2,4,4,2,4,2,1,4,3,4),
  B6 = c(2,4,2,1,2,1,4,3,1,1,1,1,3,2,1,2,3,4,1,4),
  W6 = c(4,1,4,4,4,3,3,4,4,2,4,2,4,4,3,4,4,1,4,1),
  B7 = c(3,3,2,3,4,1,2,3,3,3,2,1,3,2,1,2,3,1,3,2),
  W7 = c(1,4,1,4,1,4,4,4,4,2,4,4,4,4,4,4,4,4,4,4),
  B8 = c(1,1,2,1,2,2,1,1,1,2,1,2,1,1,1,3,1,1,1,1),
  W8 = c(3,3,3,3,3,3,3,3,4,3,3,3,4,3,3,4,4,3,4,3),
  B9 = c(3,3,3,1,3,1,1,3,1,1,1,1,3,1,1,1,3,1,1,1),
  W9 = c(2,1,2,2,2,2,4,2,4,2,4,2,2,2,2,4,1,2,2,2))

# Create a dataset and conduct a conditional logit model analysis
## Set response variables
response.vars &lt;- names(resp.data)[2:19]
## Set a base level in each attribute
base.lev &lt;- list(
  A = c("A3"), B = c("B3"), C = c("C3"), D = c("D3"))
## Paired model with attribute and attribute-level variables
pr.data &lt;- bws2.dataset(
  data = resp.data,
  id = "id",
  response = response.vars,  
  choice.sets = omed,        
  attribute.levels = attr.lev,
  reverse = TRUE,
  base.level = base.lev,
  model = "paired")
attributes(pr.data)$design.matrix
head(pr.data, 12)
### Attribute variable D is omitted from the model
pr &lt;- clogit(RES ~ A + B + C + 
  A1 + A2 + B1 + B2 + C1 + C2 + D1 + D2 + strata(STR), 
  data = pr.data)
pr
### Calculate coefficients of base level variables
b.pr &lt;- coef(pr)
-sum(b.pr[4:5]) # attribute level A3
-sum(b.pr[6:7]) # attribute level B3
-sum(b.pr[8:9]) # attribute level C3
-sum(b.pr[10:11]) # attribute level D3
## Marginal model with attribute and attribute-level variables
mr.data &lt;- bws2.dataset(
  data = resp.data,
  id = "id",
  response = response.vars,
  choice.sets = omed,
  attribute.levels = attr.lev,
  reverse = TRUE,
  base.level = base.lev,
  model = "marginal")
attributes(mr.data)$design.matrix
head(mr.data, 8)
### Attribute variable D is omitted from the model
mr &lt;- clogit(RES ~ A + B + C + 
  A1 + A2 + B1 + B2 + C1 + C2 + D1 + D2 + strata(STR), 
  data = mr.data)
mr
### Calculate coefficients of base level variables
b.mr &lt;- coef(mr)
-sum(b.mr[4:5]) # attribute level A3
-sum(b.mr[6:7]) # attribute level B3
-sum(b.mr[8:9]) # attribute level C3
-sum(b.mr[10:11]) # attribute level D3

# Calculate BWS scores
bwscores &lt;- bws2.count(mr.data)
sum(bwscores, "level")
barplot(bwscores, "bw", "level")
</code></pre>

<hr>
<h2 id='bws2.questionnaire'>
Converting an orthogonal main-effect design into Case 2 best&ndash;worst scaling 
questions
</h2><span id='topic+bws2.questionnaire'></span>

<h3>Description</h3>

<p>This function converts an orthogonal main-effect design into a series of 
Case 2 best&ndash;worst scaling questions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws2.questionnaire(choice.sets, attribute.levels = NULL, 
  position = c("left", "center", "right"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws2.questionnaire_+3A_choice.sets">choice.sets</code></td>
<td>

<p>A data frame or matrix containing an orthogonal main-effect design.
</p>
</td></tr>
<tr><td><code id="bws2.questionnaire_+3A_attribute.levels">attribute.levels</code></td>
<td>

<p>A list containing the names of attributes and their levels.
</p>
</td></tr>
<tr><td><code id="bws2.questionnaire_+3A_position">position</code></td>
<td>

<p>A character showing the position where attribute levels are shown 
in questions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bws2.questionnaire()</code> function converts an orthogonal main-effect 
design (OMED) into a series of Case 2 best&ndash;worst scaling (BWS) questions 
and then displays the resultant questions on an R console.
</p>
<p>An OMED is assigned to the argument <code>choice.sets</code>, 
which may be generated by R functions such as <code>oa.design()</code> 
in <span class="pkg">DoE.base</span> or manually copied from text books or websites 
related to experimental designs. 
</p>
<p>Attributes and their levels are assigned to the argument 
<code>attribute.levels</code> in list format. For example, suppose that 
profiles have four attributes, each of which has three levels: 
attribute A with levels A1, A2, and A3; attribute B with levels B1, B2, 
and B3; attribute C with levels C1, C2, and C3; and attribute D with 
levels D1, D2, and D3. In this case, the argument is set as follows:
</p>
<p><code>attribute.levels = list(</code> <br />
<code>    A = c("A1", "A2", "A3"),</code> <br />
<code>    B = c("B1", "B2", "B3"),</code> <br />
<code>    C = c("C1", "C2", "C3"),</code> <br />
<code>    D = c("D1", "D2", "D3"))</code> <br />
</p>
<p>The argument <code>position</code> is used to change the position of the attribute 
column in the resultant questions. When setting <code>position = "left"</code>, 
the attribute column is located on the left-hand side as follows:
</p>
<p><code>Q1</code> <br />
<code> Attribute Best Worst</code> <br />
<code> A1        [ ]  [ ]</code> <br />
<code> B1        [ ]  [ ]</code> <br />
<code> C1        [ ]  [ ]</code> <br />
<code> D1        [ ]  [ ]</code>
</p>
<p>When setting <code>position = "center"</code>, the attribute column is located 
in the center as follows:
</p>
<p><code>Q1</code> <br />
<code> Best Attribute Worst</code> <br />
<code> [ ]  A1        [ ]</code> <br />
<code> [ ]  B1        [ ]</code> <br />
<code> [ ]  C1        [ ]</code> <br />
<code> [ ]  D1        [ ]</code>
</p>
<p>When setting <code>position = "right"</code>, the attribute column is located 
on the right-hand side as follows:
</p>
<p><code>Q1</code> <br />
<code> Best Worst Attribute</code> <br />
<code> [ ]  [ ]   A1</code> <br />
<code> [ ]  [ ]   B1</code> <br />
<code> [ ]  [ ]   C1</code> <br />
<code> [ ]  [ ]   D1</code>
</p>


<h3>Value</h3>

<p>BWS questions converted from the design are returned. 
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS2-package">support.BWS2-package</a></code>, 
<code><a href="#topic+bws2.dataset">bws2.dataset</a></code>, 
<code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in bws2.dataset()
</code></pre>

<hr>
<h2 id='bws2.response'>
Generating artificial responses to Case 2 best-worst scaling questions
</h2><span id='topic+bws2.response'></span>

<h3>Description</h3>

<p>The function synthesizes responses to Case 2 best-worst scaling (BWS) questions on the basis of a paired (maximum difference) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws2.response(design, attribute.levels, base.level = NULL,
 b, n, detail = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws2.response_+3A_design">design</code></td>
<td>

<p>A matrix or data frame containing an orthogonal main-effect design.
</p>
</td></tr>
<tr><td><code id="bws2.response_+3A_attribute.levels">attribute.levels</code></td>
<td>

<p>A list containing the names of the attributes and their levels.
</p>
</td></tr>
<tr><td><code id="bws2.response_+3A_base.level">base.level</code></td>
<td>

<p>A list containing the base level for each attribute.
</p>
</td></tr>
<tr><td><code id="bws2.response_+3A_b">b</code></td>
<td>

<p>A vector containing parameters of independent variables in the model. The vector is used to calculate utilities for alternatives.
</p>
</td></tr>
<tr><td><code id="bws2.response_+3A_n">n</code></td>
<td>

<p>An integer value showing the number of respondents in the resultant dataset.
</p>
</td></tr>
<tr><td><code id="bws2.response_+3A_detail">detail</code></td>
<td>

<p>A logical variable: if <code>TRUE</code>, the dataset is returned in a detailed format; and if <code>FALSE</code> (default), the dataset is returned in a simple format.
</p>
</td></tr>
<tr><td><code id="bws2.response_+3A_seed">seed</code></td>
<td>

<p>Seed for a random number generator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function synthesizes responses to Case 2 BWS questions on the basis of a paired (maximum difference) model with attribute and/or level variables (see Model 1 and Model 2 in Aizaki and Fogarty (2019) for details). The model assumes that a profile has <code class="reqn">m</code> attributes and each attribute has two or more levels. The profile is expressed as a combination of <code class="reqn">m</code> levels. The number of possible pairs where level <code class="reqn">i</code> is selected as the best and level <code class="reqn">j</code> is selected as the worst (<code class="reqn">i \neq j</code>) from <code class="reqn">m</code> levels is given by <code class="reqn">m \times (m - 1)</code>. The model also assumes that the respondents select level <code class="reqn">i</code> as the best and level <code class="reqn">j</code> as the worst because the difference in utility between levels <code class="reqn">i</code> and <code class="reqn">j</code> is the highest among all of the <code class="reqn">m \times (m - 1)</code> differences in utility. The systematic component of the utility is assumed to be a linear additive function of the attribute and level variables (Model 2 has no attribute variables). If the error component of the utility is assumed to be an independently, identically distributed type I extreme value, the probability of selecting level <code class="reqn">i</code> as the best and level <code class="reqn">j</code> as the worst is expressed as a conditional logit model.
</p>
<p>Given the parameter values assigned to the argument <code>b</code> and the choice sets assigned to the argument <code>design</code>, the function <code>bws2.response</code> calculates the utility for the levels. The parameter values assigned to the argument <code>b</code> are set as a numerical vector where the elements correspond to the parameters of attribute and/or level variables. The variables are set according to the model specification. Assume that a profile has four attributes A, B, C, and D with three levels each (e.g., levels A1, A2, and A3 for attribute A). For Model 1, dummy-coded attribute variables and effect-coded level variables are used, an arbitrary attribute is set as the base (reference) level, and an arbitrary level for each attribute is set as the base level. If the parameters of the dummy-coded attribute variables <code class="reqn">D_{A}</code>, <code class="reqn">D_{B}</code>, and <code class="reqn">D_{C}</code> are <code class="reqn">1.75</code>, <code class="reqn">1.31</code>, and <code class="reqn">0.84</code>, respectively (i.e., attribute D is the base attribute), and those of the effect-coded level variables <code class="reqn">D_{A1}</code>, <code class="reqn">D_{A2}</code>, <code class="reqn">D_{B1}</code>, <code class="reqn">D_{B2}</code>, <code class="reqn">D_{C1}</code>, <code class="reqn">D_{C2}</code>, <code class="reqn">D_{D1}</code>, and <code class="reqn">D_{D2}</code> are <code class="reqn">-1.24</code>, <code class="reqn">0.18</code>, <code class="reqn">-1.11</code>, <code class="reqn">0.10</code>, <code class="reqn">-1.11</code>, <code class="reqn">0.39</code>, <code class="reqn">-0.25</code>, and <code class="reqn">-0.37</code>, respectively (i.e., levels A3, B3, C3, and D3 are the base levels), a vector assigned to the argument <code>b</code> is given by <code>c(1.75, 1.31, 0.84, 0, -1.24, 0.18, -1.11, 0.10, -1.11, 0.39, -0.25, -0.37)</code>, where the fourth element corresponds to the base attribute (D), and thus has a value of 0. For Model 2, dummy-coded level variables are used and an arbitrary level is set as the base level. If the parameters of the dummy-coded level variables <code class="reqn">D_{A1}</code>, <code class="reqn">D_{A2}</code>, <code class="reqn">D_{A3}</code>, <code class="reqn">D_{B1}</code>, <code class="reqn">D_{B2}</code>, <code class="reqn">D_{B3}</code>, <code class="reqn">D_{C1}</code>, <code class="reqn">D_{C2}</code>, <code class="reqn">D_{C3}</code>, <code class="reqn">D_{D1}</code>, and <code class="reqn">D_{D2}</code> are <code class="reqn">-0.10</code>, <code class="reqn">1.32</code>, <code class="reqn">2.19</code>, <code class="reqn">-0.42</code>, <code class="reqn">0.79</code>, <code class="reqn">1.69</code>, <code class="reqn">-0.89</code>, <code class="reqn">0.62</code>, <code class="reqn">0.94</code>, <code class="reqn">-0.87</code>, and <code class="reqn">-0.99</code>, respectively (i.e., level D3 is the base level), a vector assigned to the argument <code>b</code> is given as <code>c(-0.10, 1.32, 2.19, -0.42, 0.79, 1.69, -0.89, 0.62, 0.94, -0.87, -0.99, 0)</code>, where the last element corresponds to the base level (D3), and thus has a value of 0. After calculating the utility values (by adding the calculated values of the systematic component of the utility and random numbers generated from a type I extreme value distribution), the function bws2.response finds the pair with the highest difference in utility from the <code class="reqn">m \times (m - 1)</code> differences in utility.
</p>


<h3>Value</h3>

<p>The function <code>bws2.response</code> returns a data frame that contains synthesized responses to Case 2 BWS questions, in either a detailed or a simple format. The detailed format dataset contains the following variables, as well as independent variables according to the arguments <code>attribute.levels</code> and <code>base.level</code>.
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>

<p>An identification number of artificial respondents.
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>

<p>A serial number of questions.
</p>
</td></tr>
<tr><td><code>PAIR</code></td>
<td>

<p>A serial number of possible pairs of the best and worst levels for each question.
</p>
</td></tr>
<tr><td><code>BEST</code></td>
<td>

<p>An alternative number treated as the best in the possible pairs of the best and worst levels.
</p>
</td></tr>
<tr><td><code>WORST</code></td>
<td>

<p>An alternative number treated as the worst in the possible pairs of the best and worst levels.
</p>
</td></tr>
<tr><td><code>BEST.AT</code></td>
<td>

<p>A character showing the attribute corresponding to the level treated as the best in the possible pairs of the best and worst levels for each question.
</p>
</td></tr>
<tr><td><code>WORST.AT</code></td>
<td>

<p>A character showing the attribute corresponding to the level treated as the worst in the possible pairs of the best and worst levels for each question.
</p>
</td></tr>
<tr><td><code>BEST.LV</code></td>
<td>

<p>A character showing the level treated as the best in the possible pairs of the best and worst levels for each question.
</p>
</td></tr>
<tr><td><code>WORST.LV</code></td>
<td>

<p>A character showing the level treated as the worst in the possible pairs of the best and worst levels for each question.
</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>

<p>Responses to BWS questions, taking the value of 1 if a possible pair of the best and worst levels is selected by the synthesized respondents and 0 otherwise.
</p>
</td></tr>
<tr><td><code>STR</code></td>
<td>

<p>A stratification variable used to identify each combination of respondent and question.
</p>
</td></tr>
</table>
<p>The simple format dataset contains the following variables.
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>

<p>An identification number of artificial respondents.
</p>
</td></tr>
<tr><td><code>Bi</code></td>
<td>

<p>A variable describing the row number of the level that is selected as the best in the <code class="reqn">i</code>-th BWS question. The serial number of questions is appended to the tail of the variable name (e.g., <code>B1</code> for the first question, <code>B2</code> for the second question, and <code>B3</code> for the third question).
</p>
</td></tr>
<tr><td><code>Wi</code></td>
<td>

<p>A variable describing the row number of the level that is selected as the worst in the <code class="reqn">i</code>-th BWS question. The serial number of questions is appended to the tail of the variable name (e.g., <code>W1</code> for the first question, <code>W2</code> for the second question, and <code>W3</code> for the third question).
</p>
</td></tr>
</table>
<p>The detailed format dataset includes a dependent variable and independent variables for the analysis, and thus is available for discrete choice analysis functions such as the function <code>clogit</code> in the <b>survival</b> package. On the other hand, the simple format dataset only contains variables that correspond to responses to BWS questions, as well as <code>id</code> variable. It must be converted using the function <code>bws2.dataset</code> in the package for the analysis. For details, see the Examples section.
</p>


<h3>References</h3>

<p>See the help page for <code><a href="#topic+support.BWS2-package">support.BWS2-package</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS2-package">support.BWS2-package</a></code>, 
<code><a href="#topic+bws2.dataset">bws2.dataset</a></code>, 
<code><a href="survival.html#topic+clogit">clogit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following lines of code synthesize responses to Case 2 BWS questions,
# return them in detailed and simple format, and then fit the models using
# the function clogit in the survival package. The profiles are expressed
# by four attributes with three levels each. The parameters for the attribute
# and level variables are the same as those explained in the Details section.

## Not run: 
# Load packages
library(survival)
library(support.BWS2)

# Set design for BWS2 questions
dsgn &lt;- cbind(
  c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  c(1, 2, 3, 1, 2, 3, 1, 2, 3),
  c(1, 3, 2, 3, 2, 1, 2, 1, 3),
  c(1, 2, 3, 3, 1, 2, 2, 3, 1))

# Synthesize responses to BWS2 questions (Model 1)
## attributes and their levels
attr.lev &lt;- list(
  A = c("A1", "A2", "A3"), B = c("B1", "B2", "B3"),
  C = c("C1", "C2", "C3"), D = c("D1", "D2", "D3"))
## base levels
base.lev &lt;- list(A = "A3", B = "B3", C = "C3", D = "D3")
## parameters
b1 &lt;- c(1.75, 1.31, 0.84, 0,       # pars for A, B, C, and D  
        -1.24, 0.18, -1.11, 0.10,  # pars for A1, A2, B1, and B2
        -1.11, 0.39, -0.25, -0.37) # pars for C1, C2, D1, and D2
## dataset in detailed format
dat.detail1 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  base.level = base.lev,
  b = b1,
  n = 100,
  detail = TRUE,
  seed = 123)
str(dat.detail1)
## dataset in simple format 
dat.simple1 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  base.level = base.lev,
  b = b1,
  n = 100,
  detail = FALSE,
  seed = 123) 
str(dat.simple1)

# Convert dat.simple1 into dataset for the analysis
rsp.var1 &lt;- colnames(dat.simple1)[-1]
dat.simple1.pr &lt;- bws2.dataset(
  data = dat.simple1,
  id = "id",
  response = rsp.var1,  
  choice.sets = dsgn,        
  attribute.levels = attr.lev,
  base.level = base.lev,
  model = "paired")

# Fit conditional logit models
mf1 &lt;- RES ~ A + B + C + A1 + A2 + B1 + B2 + C1 + C2 + 
             D1 + D2 + strata(STR)
out.detail1 &lt;- clogit(formula = mf1, data = dat.detail1)
out.simple1 &lt;- clogit(formula = mf1, data = dat.simple1.pr)
out.simple1
all.equal(coef(out.detail1), coef(out.simple1))


# Synthesize responses to BWS2 questions (Model 2)
## parameters
b2 &lt;- c(-0.10, 1.32, 2.19, # pars for A1, A2, and A3
        -0.42, 0.79, 1.69, # pars for B1, B2, and B3
        -0.89, 0.62, 0.94, # pars for C1, C2, and C3
        -0.87, -0.99, 0)   # pars for D1, D2, and D3
## dataset in detailed format
dat.detail2 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  b = b2,
  n = 100,
  detail = TRUE,
  seed = 123)
str(dat.detail2)
## dataset in simple format 
dat.simple2 &lt;- bws2.response(
  design = dsgn,
  attribute.levels = attr.lev,
  b = b2,
  n = 100,
  detail = FALSE,
  seed = 123) 
str(dat.simple2)

# Convert dat.simple2 into dataset for the analysis
rsp.var2 &lt;- colnames(dat.simple2)[-1]
dat.simple2.pr &lt;- bws2.dataset(
  data = dat.simple2,
  id = "id",
  response = rsp.var2,  
  choice.sets = dsgn,        
  attribute.levels = attr.lev,
  model = "paired")

# Fit conditional logit models
mf2 &lt;- RES ~ A1 + A2 + A3 + B1 + B2 + B3 + C1 + C2 + C3 +
             D1 + D2 + strata(STR)
out.detail2 &lt;- clogit(formula = mf2, data = dat.detail2)
out.simple2 &lt;- clogit(formula = mf2, data = dat.simple2.pr)
out.simple2
all.equal(coef(out.detail2), coef(out.simple2))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
