<!DOCTYPE html><html><head><title>Help for package vcvComp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vcvComp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cov.B'><p>Between-group covariance matrix</p></a></li>
<li><a href='#cov.group'><p>Group covariance matrices</p></a></li>
<li><a href='#cov.W'><p>Within-group covariance matrix</p></a></li>
<li><a href='#eigen.test'><p>Difference test for successive relative eigenvalues</p></a></li>
<li><a href='#euclidean.dist'><p>Euclidean distance between two covariance matrices</p></a></li>
<li><a href='#mat.sq.dist'><p>Squared distance matrix</p></a></li>
<li><a href='#minv'><p>Matrix pseudoinverse</p></a></li>
<li><a href='#pr.coord'><p>Principal coordinates ordination</p></a></li>
<li><a href='#prop.vcv.test'><p>Proportionality test of two variance-covariance matrices</p></a></li>
<li><a href='#relative.eigen'><p>Relative eigenanalysis</p></a></li>
<li><a href='#relGV.multi'><p>Ratio of generalized variances</p></a></li>
<li><a href='#scaling.BW'><p>Scaling factor between two matrices</p></a></li>
<li><a href='#Tropheus'><p>Tropheus dataset</p></a></li>
<li><a href='#Tropheus.IK.coord'><p>Tropheus IK coord dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Comparison of Variance - Covariance Patterns</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Comparison of variance - covariance patterns using relative principal component analysis (relative eigenanalysis), as described in Le Maitre and Mitteroecker (2019) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13253">doi:10.1111/2041-210X.13253</a>&gt;. Also provides functions to compute group covariance matrices, distance matrices, and perform proportionality tests. A worked sample on the body shape of cichlid fishes is included, based on the dataset from Kerschbaumer et al. (2013) &lt;<a href="https://doi.org/10.5061%2Fdryad.fc02f">doi:10.5061/dryad.fc02f</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, geomorph, scatterplot3d</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-16 10:17:26 UTC; lemaitre</td>
</tr>
<tr>
<td>Author:</td>
<td>Anne Le Maitre <a href="https://orcid.org/0000-0003-2690-7367"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Philipp Mitteroecker [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anne Le Maitre &lt;anne.le.maitre@univie.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-17 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cov.B'>Between-group covariance matrix</h2><span id='topic+cov.B'></span>

<h3>Description</h3>

<p>Computes the between-group covariance matrix.
The effect of sexual dimorphism can be removed by using, for each group,
the average of the mean of males and the mean of females.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.B(X, groups, sex = NULL, center = FALSE, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.B_+3A_x">X</code></td>
<td>
<p>a data matrix with variables in columns and group names as row names</p>
</td></tr>
<tr><td><code id="cov.B_+3A_groups">groups</code></td>
<td>
<p>a character / factor vector containing grouping variable</p>
</td></tr>
<tr><td><code id="cov.B_+3A_sex">sex</code></td>
<td>
<p>NULL (default). A character / factor vector containing sex variable,
to remove sexual dimorphism by averaging males and females in each group</p>
</td></tr>
<tr><td><code id="cov.B_+3A_center">center</code></td>
<td>
<p>either a logical value or a numeric vector of length equal to the number of columns of X</p>
</td></tr>
<tr><td><code id="cov.B_+3A_weighted">weighted</code></td>
<td>
<p>logical. Should the between-group covariance matrix be weighted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The between-group covariance matrix
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cov</a></code>, <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Between-group covariance matrix for all populations
B &lt;- cov.B(proc.coord, groups = Tropheus.IK.coord$POP.ID)

# Between-group covariance matrix for all populations, pooled by sex
B.mf &lt;- cov.B(proc.coord, groups = Tropheus.IK.coord$POP.ID, sex = Tropheus.IK.coord$Sex)

</code></pre>

<hr>
<h2 id='cov.group'>Group covariance matrices</h2><span id='topic+cov.group'></span>

<h3>Description</h3>

<p>Computes the covariance matrix of each group.
The effect of sexual dimorphism can be removed by using, for each group,
the average of the covariance matrix of males and the covariance matrix of females.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.group(X, groups, sex = NULL, use = "everything")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.group_+3A_x">X</code></td>
<td>
<p>a data matrix with variables in columns and group names as row names</p>
</td></tr>
<tr><td><code id="cov.group_+3A_groups">groups</code></td>
<td>
<p>a character / factor vector containing grouping variable</p>
</td></tr>
<tr><td><code id="cov.group_+3A_sex">sex</code></td>
<td>
<p>NULL (default). A character / factor vector containing sex variable,
to remove sexual dimorphism by averaging males and females in each group</p>
</td></tr>
<tr><td><code id="cov.group_+3A_use">use</code></td>
<td>
<p>an optional character string giving a method for computing covariances in the presence of missing values.
This must be (an abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (p x p x m) array of covariance matrices,
where p is the number of variables and m the number of groups.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cov</a></code> and <code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(proc.coord, groups = Tropheus.IK.coord$POP.ID)

# Covariance matrix of each population, pooled by sex
S.phen.pooled &lt;- cov.group(proc.coord,
groups = Tropheus.IK.coord$POP.ID, sex = Tropheus.IK.coord$Sex)

</code></pre>

<hr>
<h2 id='cov.W'>Within-group covariance matrix</h2><span id='topic+cov.W'></span>

<h3>Description</h3>

<p>Computes the pooled within-group covariance matrix.
The effect of sexual dimorphism can be removed by using, for each group,
the average of the covariance matrix of males and the covariance matrix of females.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.W(X, groups, sex = NULL, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.W_+3A_x">X</code></td>
<td>
<p>a data matrix with variables in columns and group names as row names</p>
</td></tr>
<tr><td><code id="cov.W_+3A_groups">groups</code></td>
<td>
<p>a character / factor vector containing grouping variable</p>
</td></tr>
<tr><td><code id="cov.W_+3A_sex">sex</code></td>
<td>
<p>NULL (default). A character / factor vector containing sex variable,
to remove sexual dimorphism by averaging males and females in each group</p>
</td></tr>
<tr><td><code id="cov.W_+3A_weighted">weighted</code></td>
<td>
<p>logical. If FALSE (default), the average of all the within-group covariance matrices is used.
If TRUE, the within-group covariance matrices are weighted by their sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pooled within-group covariance matrix
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Pooled within-group covariance matrix for all populations (weighted by sample size)
W &lt;- cov.W(proc.coord, groups = Tropheus.IK.coord$POP.ID, weighted = TRUE)

# Pooled within-group covariance matrix for all populations (unweighted)
W &lt;- cov.W(proc.coord, groups = Tropheus.IK.coord$POP.ID)

# Within-group covariance matrix for all populations, pooled by sex
W.mf &lt;- cov.W(proc.coord, groups = Tropheus.IK.coord$POP.ID, sex = Tropheus.IK.coord$Sex)

</code></pre>

<hr>
<h2 id='eigen.test'>Difference test for successive relative eigenvalues</h2><span id='topic+eigen.test'></span>

<h3>Description</h3>

<p>Tests the difference between two successive relative eigenvalues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen.test(n, relValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen.test_+3A_n">n</code></td>
<td>
<p>the sample size(s), given as a number or a vector of length 2</p>
</td></tr>
<tr><td><code id="eigen.test_+3A_relvalues">relValues</code></td>
<td>
<p>a vector of relative eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The P-values for the test of difference between successive eigenvalues
</p>


<h3>References</h3>

<p>Mardia KV, Kent JT, Bibby JM (1979)
<em>Multivariate analysis</em>. Academic Press, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relative.eigen">relative.eigen</a></code> for the computation of relative eigenvalues,
</p>
<p><code><a href="stats.html#topic+Chisquare">pchisq</a></code> for Chi-squared distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Relative PCA = relative eigenanalysis between 2 covariance matrices
# (population IKA1 relative to IKS5)
relEigen.a1s5 &lt;- relative.eigen(S.phen.pop[, , "IKA1"], S.phen.pop[, , "IKS5"])

# Test of the difference between 2 successives eigenvalues
# of the covariance matrix of IKA1 relative to IKS5
n_ika1 &lt;- length(which(Tropheus.IK.coord$POP.ID == "IKA1"))  # sample size for IKA1
n_iks5 &lt;- length(which(Tropheus.IK.coord$POP.ID == "IKS5"))  # sample size for IKS5
eigen.test(n = c(n_ika1, n_iks5), relValues = relEigen.a1s5$relValues)

</code></pre>

<hr>
<h2 id='euclidean.dist'>Euclidean distance between two covariance matrices</h2><span id='topic+euclidean.dist'></span>

<h3>Description</h3>

<p>Computes the Euclidean distance (Frobenius norm) between two variance-covariance matrices of same dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean.dist(S1, S2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean.dist_+3A_s1">S1</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="euclidean.dist_+3A_s2">S2</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidean distance between S1 and S2 following Dryden et al. (2009).
</p>


<h3>References</h3>

<p>Dryden IL, Koloydenko A, Zhou D (2009)
Non-Euclidean statistics for covariance matrices, with applications to diffusion tensor imaging.
<em>The Annals of Applied Statistics 3</em>:1102-1123.
<a href="https://projecteuclid.org/euclid.aoas/1254773280">https://projecteuclid.org/euclid.aoas/1254773280</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Euclidean distance between the covariance matrices of 2 populations
# (IKA1 relative to IKS5)
dist.a1s5 &lt;- euclidean.dist(S.phen.pop[, , "IKA1"], S.phen.pop[, , "IKS5"])

</code></pre>

<hr>
<h2 id='mat.sq.dist'>Squared distance matrix</h2><span id='topic+mat.sq.dist'></span>

<h3>Description</h3>

<p>Computes the squared distance matrix of a set of covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.sq.dist(Sm, dist. = "Riemannian", method = 0, pa = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.sq.dist_+3A_sm">Sm</code></td>
<td>
<p>a (p x p x m) array of covariance matrices,
where p is the number of variables and m the number of groups.</p>
</td></tr>
<tr><td><code id="mat.sq.dist_+3A_dist.">dist.</code></td>
<td>
<p>&quot;Riemannian&quot; or &quot;Euclidean&quot;</p>
</td></tr>
<tr><td><code id="mat.sq.dist_+3A_method">method</code></td>
<td>
<p>an integer for the method of matrix inversion</p>
</td></tr>
<tr><td><code id="mat.sq.dist_+3A_pa">pa</code></td>
<td>
<p>an integer for the parameter of matrix inversion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of squared Riemannian or Euclidean distances
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+minv">minv</a></code> for the method and the parameter used for the matrix inversion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Squared Riemannian distance matrix of the covariance matrices of all populations
eigen.phen.r &lt;- mat.sq.dist(S.phen.pop, dist. = "Riemannian")

# Squared Euclidean distance matrix of the covariance matrices of all populations
eigen.phen.e &lt;- mat.sq.dist(S.phen.pop, dist. = "Euclidean")

</code></pre>

<hr>
<h2 id='minv'>Matrix pseudoinverse</h2><span id='topic+minv'></span>

<h3>Description</h3>

<p>Computes the inverse or the pseudoinverse of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minv(M, method = 0, pa = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minv_+3A_m">M</code></td>
<td>
<p>a numeric matrix (square matrix)</p>
</td></tr>
<tr><td><code id="minv_+3A_method">method</code></td>
<td>
<p>an integer for the method of inversion.
If method = 0, only the nonzero eigenvalues are kept;
if method = 1, only the eigenvalues above a threshold are kept;
if method = 2, only the several first eigenvalues are kept;
if method = 3, a Tikhonov regularization (= ridge regression) is performed.</p>
</td></tr>
<tr><td><code id="minv_+3A_pa">pa</code></td>
<td>
<p>an integer for the parameter of inversion.
If method = 1, pa is the threshold below which the eigenvalues are not kept;
if method = 2, pa is an positive integer number corresponding to number of eigenvalues that are kept;
if method = 3, pa is the scaling factor for the identity matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix corresponding to the pseudoinverse of M
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(proc.coord, groups = Tropheus.IK.coord$POP.ID)

# Pseudo-inversion of a square matrix (covariance matrix of the population IKS5)
S2 &lt;- S.phen.pop[, , "IKS5"]
invS2 &lt;- minv(S2, method = 0, pa = 0)  # Pseudoinverse keeping non-zero eigenvalues
invS2 &lt;- minv(S2, method = 1, pa = 10^-8)  # Pseudoinverse keeping eigenvalues above 10^-8
invS2 &lt;- minv(S2, method = 2, pa = 5)  # Pseudoinverse keeping the first five eigenvalues
invS2 &lt;- minv(S2, method = 3, pa = 0.5)  # Ridge regression with Tikhonov factor of 0.5

</code></pre>

<hr>
<h2 id='pr.coord'>Principal coordinates ordination</h2><span id='topic+pr.coord'></span>

<h3>Description</h3>

<p>Performs a principal coordinates analysis of a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr.coord(V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr.coord_+3A_v">V</code></td>
<td>
<p>a square distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following named components:
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>the number of groups (value)</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>the eigenvectors of the centered inner product matrix (matrix)</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>the eigenvalues of the centered inner product matrix (vector)</p>
</td></tr>
<tr><td><code>PCoords</code></td>
<td>
<p>the principal coordinates = scaled eigenvectors (matrix)</p>
</td></tr>
<tr><td><code>Variance</code></td>
<td>
<p>a dataframe containing the following named variables:
</p>

<dl>
<dt>eigenvalues</dt><dd><p>eigenvalues of the centered inner product matrix</p>
</dd>
<dt>variance</dt><dd><p>variance of each principal coordinate</p>
</dd>
<dt>exVar</dt><dd><p>proportion of the total variation accounted by each principal coordinate</p>
</dd>
<dt>cumVar</dt><dd><p>cumulative proportion of the total variation accounted by principal coordinate</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Squared distance matrix of the covariance matrices of all populations
eigen.phen.pop &lt;- mat.sq.dist(S.phen.pop, dist. = "Riemannian")  # Riemannian distances

# Ordination of the squared distance matrix
prcoa.pop &lt;- pr.coord(eigen.phen.pop)

# Visualization
plot(prcoa.pop$PCoords[, 1], prcoa.pop$PCoords[, 2])
abline(h = 0) ; abline(v = 0)
text(prcoa.pop$PCoords[, 1], prcoa.pop$PCoords[, 1], labels = rownames(prcoa.pop$PCoords))

</code></pre>

<hr>
<h2 id='prop.vcv.test'>Proportionality test of two variance-covariance matrices</h2><span id='topic+prop.vcv.test'></span>

<h3>Description</h3>

<p>Tests the proportionality of two variance-covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.vcv.test(n, S1, S2, method = 0, pa = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.vcv.test_+3A_n">n</code></td>
<td>
<p>the sample size(s), given as a number or a vector of length 2</p>
</td></tr>
<tr><td><code id="prop.vcv.test_+3A_s1">S1</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="prop.vcv.test_+3A_s2">S2</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="prop.vcv.test_+3A_method">method</code></td>
<td>
<p>an integer for the method of matrix inversion (see function 'minv')</p>
</td></tr>
<tr><td><code id="prop.vcv.test_+3A_pa">pa</code></td>
<td>
<p>an integer for the parameter of matrix inversion (see function 'minv')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The P-value for the test of proportionality between two variance-covariance matrices
</p>


<h3>References</h3>

<p>Mardia KV, Kent JT, Bibby JM (1979)
<em>Multivariate analysis</em>. Academic Press, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relative.eigen">relative.eigen</a></code> for the computation of relative eigenvalues,
</p>
<p><code><a href="#topic+minv">minv</a></code> for the method and the parameter used for the matrix inversion,
</p>
<p><code><a href="stats.html#topic+Chisquare">pchisq</a></code> for Chi-squared distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Maximum likelihood test of proportionality between 2 covariance matrices
# (IKA1 relative to IKS5) - 71 and 75 are the sample sizes
prop.vcv.test(n = c(71, 75), S.phen.pop[,,"IKA1"], S.phen.pop[,,"IKS5"])

</code></pre>

<hr>
<h2 id='relative.eigen'>Relative eigenanalysis</h2><span id='topic+relative.eigen'></span>

<h3>Description</h3>

<p>Computes the Riemanian distance between two variance-covariance matrices of same dimensions and the relative eigenvectors and eigenvalues of S1 with respect to S2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative.eigen(S1, S2, method = 0, pa = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative.eigen_+3A_s1">S1</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="relative.eigen_+3A_s2">S2</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="relative.eigen_+3A_method">method</code></td>
<td>
<p>an integer for the method of matrix inversion (see function 'minv')</p>
</td></tr>
<tr><td><code id="relative.eigen_+3A_pa">pa</code></td>
<td>
<p>an integer for the parameter of matrix inversion (see function 'minv')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following named components:
</p>
<table>
<tr><td><code>relValues</code></td>
<td>
<p>the vector of relative eigenvalues</p>
</td></tr>
<tr><td><code>relVectors</code></td>
<td>
<p>the matrix of relative eigenvectors</p>
</td></tr>
<tr><td><code>distCov</code></td>
<td>
<p>the distance between the two covariance matrices</p>
</td></tr>
<tr><td><code>relGV</code></td>
<td>
<p>the product of the nonzero relative eigenvalues = the ratio of the generalized variances.
The generalized variance corresponds to the determinant of the covariance matrix.</p>
</td></tr>
<tr><td><code>logGV</code></td>
<td>
<p>the log ratio of the generalized variances</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>the number of nonzero eigenvalues</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bookstein F, Mitteroecker P (2014)
Comparing covariance matrices by relative eigenanalysis, with applications to organismal biology.
<em>Evolutionary Biology 41</em>: 336-350.
<a href="https://doi.org/10.1007/s11692-013-9260-5">https://doi.org/10.1007/s11692-013-9260-5</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+minv">minv</a></code> for the method and the parameter used for the matrix inversion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Relative PCA = relative eigenanalysis between 2 covariance matrices
# (population IKA1 relative to IKS5)
relEigen.a1s5 &lt;- relative.eigen(S.phen.pop[, , "IKA1"], S.phen.pop[, , "IKS5"])

</code></pre>

<hr>
<h2 id='relGV.multi'>Ratio of generalized variances</h2><span id='topic+relGV.multi'></span>

<h3>Description</h3>

<p>Computes the (log-transformed) ratios of the generalized variances
of a set of covariance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relGV.multi(Sm, logGV = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relGV.multi_+3A_sm">Sm</code></td>
<td>
<p>a (p x p x m) array of covariance matrices,
where p is the number of variables and m the number of groups.</p>
</td></tr>
<tr><td><code id="relGV.multi_+3A_loggv">logGV</code></td>
<td>
<p>a logical argument to indicate if the ratios should be log-transformed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of the (log-transformed) ratios of the generalized variances.
For each row, the ratio corrresponds to the group of the row
relative to the group of a column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Data reduction
phen.pca &lt;- prcomp(proc.coord, rank. = 5, tol = sqrt(.Machine$double.eps))
pc.scores &lt;- phen.pca$x

# Covariance matrix of each population
S.phen.pop &lt;- cov.group(pc.scores, groups = Tropheus.IK.coord$POP.ID)

# Ratio of the generalized variances of 2 populations (IKA1 and IKS5)
relGV.multi(S.phen.pop[, , c("IKA1", "IKS5")], logGV = FALSE)

</code></pre>

<hr>
<h2 id='scaling.BW'>Scaling factor between two matrices</h2><span id='topic+scaling.BW'></span>

<h3>Description</h3>

<p>Computes the maximum-likelihood estimate
of the scaling factor between two proportional covariance matrices.
Note that the scaling factor between the two matrices
is equal to the arithmetic mean of their relative eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaling.BW(S1, S2, method = 0, pa = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaling.BW_+3A_s1">S1</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="scaling.BW_+3A_s2">S2</code></td>
<td>
<p>a variance-covariance matrix</p>
</td></tr>
<tr><td><code id="scaling.BW_+3A_method">method</code></td>
<td>
<p>an integer for the method of matrix inversion (see function 'minv')</p>
</td></tr>
<tr><td><code id="scaling.BW_+3A_pa">pa</code></td>
<td>
<p>an integer for the parameter of matrix inversion (see function 'minv')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scaling factor between the two matrices.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+minv">minv</a></code> for the method and the parameter used for the matrix inversion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data matrix of 2D landmark coordinates
data("Tropheus.IK.coord")
coords &lt;- which(names(Tropheus.IK.coord) == "X1"):which(names(Tropheus.IK.coord) == "Y19")
proc.coord &lt;- as.matrix(Tropheus.IK.coord[coords])

# Between-group (B) and within-group (W) covariance matrices for all populations
B &lt;- cov.B(proc.coord, groups = Tropheus.IK.coord$POP.ID, sex = Tropheus.IK.coord$Sex)
W &lt;- cov.W(proc.coord, groups = Tropheus.IK.coord$POP.ID, sex = Tropheus.IK.coord$Sex)

# ML estimate of the scaling factor between B and W
sc &lt;- scaling.BW(B, W)

# Scaling of B to W
Bsc &lt;- B / sc

</code></pre>

<hr>
<h2 id='Tropheus'>Tropheus dataset</h2><span id='topic+Tropheus'></span>

<h3>Description</h3>

<p>A data frame of 723 observations of 57 variables extracted from a freely available dataset,
downloaded from the Dryad digital repository (<a href="https://doi.org/10.5061/dryad.fc02f">https://doi.org/10.5061/dryad.fc02f</a>).
The observations correspond to cichlid fishes of the species <em>Tropheus moorii</em>
(color morphs 'Kaiser' and 'Kirschfleck') and <em>T. polli</em> collected from eight locations
of Lake Tanganyika (Kerschbaumer et al., 2014).
The main numerical variables provided are the 2D Cartesian coordinates of 19 landmarks
quantifying the external body morphology of adult fishes
and the genotypes for 6 microsatellite markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tropheus)
</code></pre>


<h3>Format</h3>

<p>A data frame with 723 rows and 57 variables
</p>


<h3>Details</h3>


<ul>
<li> <p><strong>List_TropheusData_ID</strong> Specimen ID
</p>
</li>
<li> <p><strong>Extractionnr.</strong> Extraction number for genomic DNA
</p>
</li>
<li> <p><strong>G</strong> Group number
</p>
</li>
<li> <p><strong>POP.ID</strong> Population Id
</p>
</li>
<li> <p><strong>Sex</strong> Sex
</p>
</li>
<li> <p><strong>Allo.Symp</strong> Allopatric or sympatric population
</p>
</li>
<li> <p><strong>X1 ... Y19</strong> Cartesian coordinates of 19 landmarks
</p>
</li>
<li> <p><strong>Pzep3_1 ... UME003_2</strong> Genotype for 6 microsatellite markers
</p>
</li></ul>



<h3>References</h3>

<p>Kerschbaumer M, Mitteroecker P, Sturmbauer C (2014)
Evolution of body shape in sympatric versus non-sympatric Tropheus populations of Lake Tanganyika. <em>Heredity 112(2)</em>: 89–98. <a href="https://doi.org/10.1038/hdy.2013.78">https://doi.org/10.1038/hdy.2013.78</a>
</p>
<p>Kerschbaumer M, Mitteroecker P, Sturmbauer C (2013)
Data from: Evolution of body shape in sympatric versus non-sympatric Tropheus populations of Lake Tanganyika. <em>Dryad Digital Repository</em>. <a href="https://doi.org/10.5061/dryad.fc02f">https://doi.org/10.5061/dryad.fc02f</a>
</p>

<hr>
<h2 id='Tropheus.IK.coord'>Tropheus IK coord dataset</h2><span id='topic+Tropheus.IK.coord'></span>

<h3>Description</h3>

<p>A data frame of 511 observations of 58 variables.
This is a subset of the Tropheus data frame constituted by cichlid fishes
of the species <em>Tropheus moorii</em> (color morph 'Kaiser')
collected from six locations of Lake Tanganyika (Kerschbaumer et al., 2013, 2014).
The coordinates result from the generalised Procrustes analysis, for this subset,
of the 2D Cartesian coordinates of 19 landmarks quantifying the external body morphology of adult fishes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tropheus.IK.coord)
</code></pre>


<h3>Format</h3>

<p>A data frame with 511 rows and 58 variables
</p>


<h3>Details</h3>


<ul>
<li> <p><strong>List_TropheusData_ID</strong> Specimen ID
</p>
</li>
<li> <p><strong>Extractionnr.</strong> Extraction number for genomic DNA
</p>
</li>
<li> <p><strong>G</strong> Group number
</p>
</li>
<li> <p><strong>POP.ID</strong> Population Id
</p>
</li>
<li> <p><strong>Sex</strong> Sex
</p>
</li>
<li> <p><strong>Allo.Symp</strong> Allopatric or sympatric population
</p>
</li>
<li> <p><strong>X1 ... Y19</strong> Procrustes coordinates of 19 landmarks
</p>
</li>
<li> <p><strong>Pzep3_1 ... UME003_2</strong> Genotype for 6 microsatellite markers
</p>
</li></ul>



<h3>References</h3>

<p>Kerschbaumer M, Mitteroecker P, Sturmbauer C (2014)
Evolution of body shape in sympatric versus non-sympatric Tropheus populations of Lake Tanganyika. <em>Heredity 112(2)</em>: 89–98. <a href="https://doi.org/10.1038/hdy.2013.78">https://doi.org/10.1038/hdy.2013.78</a>
</p>
<p>Kerschbaumer M, Mitteroecker P, Sturmbauer C (2013)
Data from: Evolution of body shape in sympatric versus non-sympatric Tropheus populations of Lake Tanganyika. <em>Dryad Digital Repository</em>. <a href="https://doi.org/10.5061/dryad.fc02f">https://doi.org/10.5061/dryad.fc02f</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tropheus">Tropheus</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
