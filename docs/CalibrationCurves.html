<!DOCTYPE html><html><head><title>Help for package CalibrationCurves</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CalibrationCurves}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalibrationCurves'><p>General information on the package and its functions</p></a></li>
<li><a href='#.rcspline.plot'><p>Internal function</p></a></li>
<li><a href='#+25+7B+7D+25'><p>Infix operator to run background jobs</p></a></li>
<li><a href='#+25+26lt+3B+3D+25'><p>Infix operator to run background jobs</p></a></li>
<li><a href='#auc.nonpara.mw'><p>AUC Based on the Mann-Whitney Statistic</p></a></li>
<li><a href='#genCalCurve'><p>Calibration performance using the generalized calibration framework</p></a></li>
<li><a href='#LibraryM'><p>Function to load multiple packages at once</p></a></li>
<li><a href='#print.CalibrationCurve'><p>Print function for a CalibrationCurve object</p></a></li>
<li><a href='#print.GeneralizedCalibrationCurve'><p>Print function for a GeneralizedCalibrationCurve object</p></a></li>
<li><a href='#print.ggplotCalibrationCurve'><p>Print function for a ggplotCalibrationCurve object</p></a></li>
<li><a href='#simulateddata'>
<p>Simulated data sets to illustrate the package functionality</p></a></li>
<li><a href='#simulatedpoissondata'>
<p>Simulated data sets to illustrate the package functionality</p></a></li>
<li><a href='#val.prob.ci.2'><p>Calibration performance</p></a></li>
<li><a href='#valProbggplot'><p>Calibration performance: ggplot version</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calibration Performance</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Plots calibration curves and computes statistics for assessing calibration performance. See De Cock Campo (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2309.08559">doi:10.48550/arXiv.2309.08559</a>&gt; and Van Calster et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jclinepi.2015.12.005">doi:10.1016/j.jclinepi.2015.12.005</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), rms, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, stats, utils, survival, Hmisc,
bookdown, rstudioapi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mgcv, MASS, magrittr, Matrix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bavodc.github.io/websiteCalibrationCurves/">https://bavodc.github.io/websiteCalibrationCurves/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-02 08:02:18 UTC; u0095171</td>
</tr>
<tr>
<td>Author:</td>
<td>De Cock Bavo [aut, cre],
  Nieboer Daan [aut],
  Van Calster Ben [aut],
  Steyerberg Ewout [aut],
  Vergouwe Yvonne [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>De Cock Bavo &lt;bavo.decock@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-02 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalibrationCurves'>General information on the package and its functions
</h2><span id='topic+CalibrationCurves-package'></span>

<h3>Description</h3>

<p>Using this package, you can assess the calibration performance of your prediction model. That is, to which extent the predictions and correspond with what we observe empirically.
To assess the calibration of model with a binary outcome, you can use the <code><a href="#topic+val.prob.ci.2">val.prob.ci.2</a></code> or the <code><a href="#topic+valProbggplot">valProbggplot</a></code> function. If the outcome of your prediction model
is not binary but follows a different distribution of the exponential family, you can employ the <code><a href="#topic+genCalCurve">genCalCurve</a></code> function.
</p>
<p>If you are not familiar with the theory and/or application of calibration, you can consult the vignette of the package. This vignette provides a comprehensive overview of the theory and
contains a tutorial with some practical examples. Further, we suggest the reader to consult the <a href="https://arxiv.org/abs/2309.08559">paper</a> on generalized calibration curves on arXiv.
In this paper, we provide the theoretical background on the generalized calibration framework and illustrate its applicability with some prototypical examples of both statistical and
machine learning prediction models that are well-calibrated, overfit and underfit.
</p>
<p>Originally, the package only contained functions to assess the calibration of prediction models with a binary outcome. The details section provides some background information on the
history of the package's development.
</p>


<h3>Details</h3>

<p>Some years ago, Yvonne Vergouwe and Ewout Steyerberg adapted the function <code><a href="rms.html#topic+val.prob">val.prob</a></code> from the rms-package (<a href="https://cran.r-project.org/package=rms">https://cran.r-project.org/package=rms</a>) into <code>val.prob.ci</code> and added the following functions to <code><a href="rms.html#topic+val.prob">val.prob</a></code>:
</p>

<ul>
<li><p> Scaled Brier score by relating to max for average calibrated Null model
</p>
</li>
<li><p> Risk distribution according to outcome
</p>
</li>
<li><p> 0 and 1 to indicate outcome label; set with <code>d1lab=".."</code>, <code>d0lab=".."</code>
</p>
</li>
<li><p> Labels: y axis: &quot;Observed Frequency&quot;; Triangle: &quot;Grouped observations&quot;
</p>
</li>
<li><p> Confidence intervals around triangles
</p>
</li>
<li><p> A cut-off can be plotted; set x coordinate
</p>
</li></ul>

<p>In December 2015, Bavo De Cock, Daan Nieboer, and Ben Van Calster adapted
this to <code><a href="#topic+val.prob.ci.2">val.prob.ci.2</a></code>:
</p>

<ul>
<li><p> Flexible calibration curves can be obtained using loess (default) or
restricted cubic splines, with pointwise 95% confidence intervals. Flexible calibration curves are now given by default and this decision is based on the findings reported in Van Calster et al. (2016).
</p>
</li>
<li><p> Loess: confidence intervals can be obtained in closed form or using bootstrapping
(CL.BT=T will do bootstrapping with 2000 bootstrap samples, however
this will take a while)
</p>
</li>
<li><p> RCS: 3 to 5 knots can be used
</p>

<ul>
<li><p> the knot locations will be estimated using default quantiles of
x (by <code><a href="Hmisc.html#topic+rcspline.eval">rcspline.eval</a></code>, see <code><a href="Hmisc.html#topic+rcspline.plot">rcspline.plot</a></code> and <code><a href="Hmisc.html#topic+rcspline.eval">rcspline.eval</a></code>)
</p>
</li>
<li><p> if estimation problems occur at the specified number of knots
(nr.knots, default is 5), the analysis is repeated with
nr.knots-1 until the problem has disappeared and the function stops if there is still an estimation problem with 3 knots
</p>
</li></ul>

</li>
<li><p> You can now adjust the plot through use of normal plot commands
(<code>cex.axis</code> etcetera), and the size of the legend now has to be specified in
<code>cex.leg</code>
</p>
</li>
<li><p> Label y-axis: &quot;Observed proportion&quot;
</p>
</li>
<li><p> Stats: added the Estimated Calibration Index (ECI), a statistical
measure to quantify lack of calibration (Van Hoorde et al., 2015)
</p>
</li>
<li><p> Stats to be shown in the plot: by default we show the <code>"abc"</code> of model performance (Steyerberg et al., 2011). That is, calibration intercept (calibration-in-the-large), calibration slope and c-
statistic. Alternatively, the user can select the statistics of
choice (e.g. <code>dostats=c("C (ROC)","R2")</code> or <code>dostats=c(2,3)</code>.
</p>
</li>
<li><p> Vectors p, y and logit no longer have to be sorted
</p>
</li></ul>

<p>In 2023, Bavo De Cock (Campo) published a <a href="https://arxiv.org/abs/2309.08559">paper</a> that introduces the generalized calibration framework. This framework is an extension of the logistic calibration framework to prediction models where the outcome's distribution is a member of the exponential family. As such, we are able to assess the calibration of a wider range of prediction models. The methods in this paper are implemented
in the CalibrationCurves package.
</p>
<p>The most current version of this package can always be found on
<a href="https://github.com/BavoDC">https://github.com/BavoDC</a> and can easily be installed using the following code: <br />
<code>install.packages("devtools") # if not yet installed</code> <br />
<code>require(devtools)</code> <br />
<code>install_github("BavoDC/CalibrationCurves", dependencies = TRUE, build_vignettes = TRUE)</code> <br />
</p>


<h3>References</h3>

<p>De Cock Campo, B. (2023). Towards reliable predictive analytics: a generalized calibration framework. arXiv:2309.08559, available at <a href="https://arxiv.org/abs/2309.08559">https://arxiv.org/abs/2309.08559</a>.
</p>
<p>Steyerberg, E.W.Van Calster, B., Pencina, M.J. (2011). Performance measures for prediction models and markers : evaluation of predictions and classifications. <em>Revista Espanola de Cardiologia</em>, <b>64(9)</b>, pp. 788-794
</p>
<p>Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina M., Steyerberg E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>, <b>74</b>, pp. 167-176
</p>
<p>Van Hoorde, K., Van Huffel, S., Timmerman, D., Bourne, T., Van Calster, B. (2015).
A spline-based tool to assess and visualize the calibration of multiclass risk predictions.
<em>Journal of Biomedical Informatics</em>, <b>54</b>, pp. 283-93
</p>

<hr>
<h2 id='.rcspline.plot'>Internal function</h2><span id='topic+.rcspline.plot'></span>

<h3>Description</h3>

<p>Adjusted version of the <code><a href="Hmisc.html#topic+rcspline.plot">rcspline.plot</a></code> function where only the output is returned and no plot is made
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rcspline.plot(
  x,
  y,
  model = c("logistic", "cox", "ols"),
  xrange,
  event,
  nk = 5,
  knots = NULL,
  show = c("xbeta", "prob"),
  adj = NULL,
  xlab,
  ylab,
  ylim,
  plim = c(0, 1),
  plotcl = TRUE,
  showknots = TRUE,
  add = FALSE,
  plot = TRUE,
  subset,
  lty = 1,
  noprint = FALSE,
  m,
  smooth = FALSE,
  bass = 1,
  main = "auto",
  statloc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rcspline.plot_+3A_x">x</code></td>
<td>
<p>a numeric predictor</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_y">y</code></td>
<td>
<p>a numeric response. For binary logistic regression, <code>y</code> should be either 0 or 1.</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_model">model</code></td>
<td>
<p><code>"logistic"</code> or <code>"cox"</code>. For <code>"cox"</code>, uses the <code>coxph.fit</code> function with <code>method="efron"</code> argument set.</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_xrange">xrange</code></td>
<td>
<p>range for evaluating <code>x</code>, default is <code class="reqn">f</code> and <code class="reqn">1 - f</code> quantiles of <code>x</code>,
where <code class="reqn">f = \frac{10}{\max{(n, 200)}}</code> and <code class="reqn">n</code> the number of observations</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_event">event</code></td>
<td>
<p>event/censoring indicator if <code>model="cox"</code>. If <code>event</code> is present, <code>model</code> is assumed to be <code>"cox"</code></p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_nk">nk</code></td>
<td>
<p>number of knots</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_knots">knots</code></td>
<td>
<p>knot locations, default based on quantiles of <code>x</code> (by <code><a href="Hmisc.html#topic+rcspline.eval">rcspline.eval</a></code>)</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_show">show</code></td>
<td>
<p><code>"xbeta"</code> or <code>"prob"</code> - what is plotted on <code style="white-space: pre;">&#8288;y&#8288;</code>-axis</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_adj">adj</code></td>
<td>
<p>optional matrix of adjustment variables</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_xlab">xlab</code></td>
<td>
<p><code style="white-space: pre;">&#8288;x&#8288;</code>-axis label, default is the &ldquo;label&rdquo; attribute of <code>x</code></p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_ylab">ylab</code></td>
<td>
<p><code style="white-space: pre;">&#8288;y&#8288;</code>-axis label, default is the &ldquo;label&rdquo; attribute of <code>y</code></p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_ylim">ylim</code></td>
<td>
<p><code style="white-space: pre;">&#8288;y&#8288;</code>-axis limits for logit or log hazard</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_plim">plim</code></td>
<td>
<p><code style="white-space: pre;">&#8288;y&#8288;</code>-axis limits for probability scale</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_plotcl">plotcl</code></td>
<td>
<p>plot confidence limits</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_showknots">showknots</code></td>
<td>
<p>show knot locations with arrows</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_add">add</code></td>
<td>
<p>add this plot to an already existing plot</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_plot">plot</code></td>
<td>
<p>logical to indicate whether a plot has to be made. <code>FALSE</code> suppresses the plot.</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_subset">subset</code></td>
<td>
<p>subset of observations to process, e.g. <code>sex == "male"</code></p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_lty">lty</code></td>
<td>
<p>line type for plotting estimated spline function</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_noprint">noprint</code></td>
<td>
<p>suppress printing regression coefficients and standard errors</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_m">m</code></td>
<td>
<p>for <code>model="logistic"</code>, plot grouped estimates with triangles. Each group contains <code>m</code> ordered observations on <code>x</code>.</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_smooth">smooth</code></td>
<td>
<p>plot nonparametric estimate if <code>model="logistic"</code> and <code>adj</code> is not specified</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_bass">bass</code></td>
<td>
<p>smoothing parameter (see <code>supsmu</code>)</p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_main">main</code></td>
<td>
<p>main title, default is <code>"Estimated Spline Transformation"</code></p>
</td></tr>
<tr><td><code id=".rcspline.plot_+3A_statloc">statloc</code></td>
<td>
<p>location of summary statistics. Default positioning by clicking left mouse button where upper left corner of statistics should appear.
Alternative is <code>"ll"</code> to place below the graph on the lower left, or the actual <code>x</code> and <code>y</code> coordinates. Use <code>"none"</code> to suppress statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components (&lsquo;<span class="samp">&#8288;knots&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;xbeta&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;) which are respectively the knot locations, design matrix,
linear predictor, and lower and upper confidence limits
</p>


<h3>See Also</h3>

<p><code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+cph">cph</a></code>, <code><a href="Hmisc.html#topic+rcspline.eval">rcspline.eval</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+supsmu">supsmu</a></code>,
<code><a href="survival.html#topic+survival-internal">coxph.fit</a></code>, <code><a href="rms.html#topic+lrm.fit">lrm.fit</a></code>
</p>

<hr>
<h2 id='+25+7B+7D+25'>Infix operator to run background jobs</h2><span id='topic++25+7B+7D+25'></span>

<h3>Description</h3>

<p>This infix operator can be used to create a background job for a block of code in RStudio/Posit and, once completed,
all objects created in the block of code are imported into the global environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %{}% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B7B+2B7D+2B25_+3A_lhs">lhs</code></td>
<td>
<p>not used, see details and examples</p>
</td></tr>
<tr><td><code id="+2B25+2B7B+2B7D+2B25_+3A_rhs">rhs</code></td>
<td>
<p>the block of code that you want to run</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can use this infix operator in two different ways. Either you set the left-hand side to <code>NULL</code> or you use the syntax
<code>`%{}%`  ({BlockOfCode})</code>
</p>


<h3>Value</h3>

<p>prints the ID of the background job in the console and, once completed, the objects created in the block of code
are imported into the global environment
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Can only be executed in Rstudio
## Not run: 
NULL %{}% {
 x = rnorm(1e7)
 y = rnorm(1e7)
}
`%{}%` ({
 x = rnorm(1e7)
 y = rnorm(1e7)
})

## End(Not run)
</code></pre>

<hr>
<h2 id='+25+26lt+3B+3D+25'>Infix operator to run background jobs</h2><span id='topic++25+3C+3D+25'></span>

<h3>Description</h3>

<p>This infix operator can be used to create a background job in RStudio/Posit and, once completed, the value of rhs is
assigned to lhs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&lt;=% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26lt+2B3B+2B3D+2B25_+3A_lhs">lhs</code></td>
<td>
<p>the object that the rhs value is assigned to</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3B+2B3D+2B25_+3A_rhs">rhs</code></td>
<td>
<p>the value you want to assign to lhs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the ID of the background job in the console and, once completed, the value of lhs is assigned to rhs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Can only be executed in Rstudio
## Not run: x %&lt;=% rnorm(1e7)
</code></pre>

<hr>
<h2 id='auc.nonpara.mw'>AUC Based on the Mann-Whitney Statistic</h2><span id='topic+auc.nonpara.mw'></span>

<h3>Description</h3>

<p>Obtain the point estimate and the confidence interval of the
AUC by various methods based on the Mann-Whitney statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   auc.nonpara.mw(x, y, conf.level=0.95,
                  method=c("newcombe", "pepe", "delong",
                           "jackknife", "bootstrapP", "bootstrapBCa"),
                  nboot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc.nonpara.mw_+3A_x">x</code></td>
<td>
<p>a vector of observations from class P.</p>
</td></tr>
<tr><td><code id="auc.nonpara.mw_+3A_y">y</code></td>
<td>
<p>a vector of observations from class N.</p>
</td></tr>
<tr><td><code id="auc.nonpara.mw_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval. The default
is 0.95.</p>
</td></tr>
<tr><td><code id="auc.nonpara.mw_+3A_method">method</code></td>
<td>
<p>a method used to construct the CI. <code>newcombe</code> is
the method recommended in Newcombe (2006); <code>pepe</code> is the method
proposed in Pepe (2003); <code>delong</code> is the method proposed in
Delong et al. (1988); <code>jackknife</code> uses the
jackknife method; <code>bootstrapP</code> uses the bootstrap with
percentile CI; <code>bootstrapBCa</code> uses bootstrap with
bias-corrected and accelerated CI. The default is <code>newcombe</code>. It can be abbreviated.</p>
</td></tr>
<tr><td><code id="auc.nonpara.mw_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements various methods based on the Mann-Whitney statistic.
</p>


<h3>Value</h3>

<p>Point estimate and lower and upper bounds of the CI of the AUC.
</p>


<h3>Note</h3>

<p>The observations from class P tend to have larger values than that from class N.
</p>
<p>This help-file is a copy of the original help-file of the function <code>auc.nonpara.mw</code> from the auRoc-package. It is important to note
that, when using <code>method="pepe"</code>, the confidence interval is computed as documented in Qin and Hotilovac (2008) and that this is
different from the original function.
</p>


<h3>References</h3>

<p>Elizabeth R Delong, David M Delong, and Daniel L Clarke-Pearson (1988)
Comparing the areas under two or more correlated receiver operating characteristic curves: a nonparametric approach.
<em>Biometrics</em>
<b>44</b> 837-845
</p>
<p>Dai Feng, Giuliana Cortese, and Richard Baumgartner (2015)
A comparison of confidence/credible interval methods for
the area under the ROC curve for continuous diagnostic tests
with small sample size.
<em>Statistical Methods in Medical Research</em>
DOI: 10.1177/0962280215602040
</p>
<p>Robert G Newcombe (2006)
Confidence intervals for an effect size measure based on the Mann-Whitney statistic. Part 2: asymptotic methods and evaluation.
<em>Statistics in medicine</em>
<b>25(4)</b> 559-573
</p>
<p>Margaret Sullivan Pepe (2003)
The statistical evaluation of medical tests for classification and prediction.
<em>Oxford University Press</em>
</p>
<p>Qin, G., &amp; Hotilovac, L. (2008). Comparison of non-parametric confidence intervals for the area under the ROC curve of a continuous-scale
diagnostic test. <em>Statistical Methods in Medical Research</em>, <b>17(2)</b>, pp. 207-21
</p>

<hr>
<h2 id='genCalCurve'>Calibration performance using the generalized calibration framework</h2><span id='topic+genCalCurve'></span>

<h3>Description</h3>

<p>Function to assess the calibration performance of a prediction model where the outcome's distribution is a member of the exponential family (De Cock Campo, 2023).
The function plots the generalized calibration curve and computes the generalized calibration slope and intercept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCalCurve(
  y,
  yHat,
  family,
  plot = TRUE,
  Smooth = FALSE,
  GLMCal = TRUE,
  lwdIdeal = 2,
  colIdeal = "gray",
  ltyIdeal = 1,
  lwdSmooth = 1,
  colSmooth = "blue",
  ltySmooth = 1,
  argzSmooth = alist(degree = 2),
  lwdGLMCal = 1,
  colGLMCal = "red",
  ltyGLMCal = 1,
  AddStats = T,
  Digits = 3,
  cexStats = 1,
  lwdLeg = 1.5,
  Legend = TRUE,
  legendPos = "bottomright",
  xLim = NULL,
  yLim = NULL,
  posStats = NULL,
  confLimitsSmooth = c("none", "bootstrap", "pointwise"),
  confLevel = 0.95,
  Title = "Calibration plot",
  xlab = "Predicted value",
  ylab = "Empirical average",
  EmpiricalDistribution = TRUE,
  length.seg = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCalCurve_+3A_y">y</code></td>
<td>
<p>a vector with the values for the response variable</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_yhat">yHat</code></td>
<td>
<p>a vector with the predicted values</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_family">family</code></td>
<td>
<p>a description of the type of distribution and link function in the model. This can be a character string naming a family function, a family function or the result of a call to a family function.
(See family for details of family functions.)</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_plot">plot</code></td>
<td>
<p>logical, indicating if a plot should be made or not.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_smooth">Smooth</code></td>
<td>
<p>logical, indicating if the flexible calibration curve should be estimated.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_glmcal">GLMCal</code></td>
<td>
<p>logical, indicating if the GLM calibration curve has to be estimated.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_lwdideal">lwdIdeal</code></td>
<td>
<p>the line width of the ideal line.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_colideal">colIdeal</code></td>
<td>
<p>the color of the ideal line.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_ltyideal">ltyIdeal</code></td>
<td>
<p>the line type of the ideal line.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_lwdsmooth">lwdSmooth</code></td>
<td>
<p>the line width of the flexible calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_colsmooth">colSmooth</code></td>
<td>
<p>the color of the flexible calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_ltysmooth">ltySmooth</code></td>
<td>
<p>the line type of the flexible calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_argzsmooth">argzSmooth</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+loess">loess</a></code>.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_lwdglmcal">lwdGLMCal</code></td>
<td>
<p>the line width of the GLM calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_colglmcal">colGLMCal</code></td>
<td>
<p>the color of the GLM calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_ltyglmcal">ltyGLMCal</code></td>
<td>
<p>the line type of the GLM calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_addstats">AddStats</code></td>
<td>
<p>logical, indicating whether to add the values of the generalized calibration slope and intercept to the plot.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_digits">Digits</code></td>
<td>
<p>the number of digits of the generalized calibration slope and intercept.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_cexstats">cexStats</code></td>
<td>
<p>the font size of the statistics shown on the plot.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_lwdleg">lwdLeg</code></td>
<td>
<p>the line width in the legend.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_legend">Legend</code></td>
<td>
<p>logical, indicating whether the legend has to be added.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_legendpos">legendPos</code></td>
<td>
<p>the position of the legend on the plot.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_xlim">xLim</code>, <code id="genCalCurve_+3A_ylim">yLim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges (see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>)</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_posstats">posStats</code></td>
<td>
<p>numeric vector of length 2, specifying the x and y coordinates of the statistics (generalized calibration curve and intercept) printed on the plot. Default is <code>NULL</code>
which places the statistics in the top left corner of the plot.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_conflimitssmooth">confLimitsSmooth</code></td>
<td>
<p>character vector to indicate if and how the confidence limits for the flexible calibration curve have to be computed. <code>"none"</code> omits the confidence limits,
<code>"bootstrap"</code> uses 2000 bootstrap samples to calculate the 95% confidence limits and <code>"pointwise"</code> uses the pointwise confidence limits.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_conflevel">confLevel</code></td>
<td>
<p>the confidence level for the calculation of the pointwise confidence limits of the flexible calibration curve.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_title">Title</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default is <code>"Predicted value"</code>.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default is <code>"Empirical average"</code>.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_empiricaldistribution">EmpiricalDistribution</code></td>
<td>
<p>logical, indicating if the empirical distribution of the predicted values has to be added to the bottom of the plot.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_length.seg">length.seg</code></td>
<td>
<p>controls the length of the histogram lines. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="genCalCurve_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>GeneralizedCalibrationCurve</code> with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>ggPlot</code></td>
<td>
<p>the ggplot object.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>a vector containing performance measures of calibration.</p>
</td></tr>
<tr><td><code>cl.level</code></td>
<td>
<p>the confidence level used.</p>
</td></tr>
<tr><td><code>Calibration</code></td>
<td>
<p>contains the calibration intercept and slope, together with their confidence intervals.</p>
</td></tr>
<tr><td><code>Cindex</code></td>
<td>
<p>the value of the c-statistic, together with its confidence interval.</p>
</td></tr>
<tr><td><code>warningMessages</code></td>
<td>
<p>if any, the warning messages that were printed while running the function.</p>
</td></tr>
<tr><td><code>CalibrationCurves</code></td>
<td>
<p>The coordinates for plotting the calibration curves. </p>
</td></tr>
</table>


<h3>References</h3>

<p>De Cock Campo, B. (2023). Towards reliable predictive analytics: a generalized calibration framework. arXiv:2309.08559, available at <a href="https://arxiv.org/abs/2309.08559">https://arxiv.org/abs/2309.08559</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CalibrationCurves)
library(mgcv)
data("poissontraindata")
data("poissontestdata")

glmFit = glm(Y ~ ., data = poissontraindata, family = poisson)

# Example of a well calibrated poisson prediction model
yOOS = poissontestdata$Y
yHat = predict(glmFit, newdata = poissontestdata, type = "response")
genCalCurve(yOOS, yHat, family = "poisson", plot = TRUE)

# Example of an overfit poisson prediction model
gamFit = gam(Y ~ x1 + x3 + x1:x3 + s(x5), data = poissontraindata, family = poisson)
yHat = as.vector(predict(gamFit, newdata = poissontestdata, type = "response"))
genCalCurve(yOOS, yHat, family = "poisson", plot = TRUE)

# Example of an underfit poisson prediction model
glmFit = glm(Y ~ x2, data = poissontraindata, family = poisson)
yOOS = poissontestdata$Y
yHat = predict(glmFit, newdata = poissontestdata, type = "response")
genCalCurve(yOOS, yHat, family = "poisson", plot = TRUE)
</code></pre>

<hr>
<h2 id='LibraryM'>Function to load multiple packages at once</h2><span id='topic+LibraryM'></span>

<h3>Description</h3>

<p>Function to load multiple packages at once
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LibraryM(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LibraryM_+3A_...">...</code></td>
<td>
<p>the packages that you want to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LibraryM(CalibrationCurves)
</code></pre>

<hr>
<h2 id='print.CalibrationCurve'>Print function for a CalibrationCurve object</h2><span id='topic+print.CalibrationCurve'></span>

<h3>Description</h3>

<p>Prints the call, confidence level and values for the performance measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CalibrationCurve'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CalibrationCurve_+3A_x">x</code></td>
<td>
<p>an object of type CalibrationCurve, resulting from <code><a href="#topic+val.prob.ci.2">val.prob.ci.2</a></code>.</p>
</td></tr>
<tr><td><code id="print.CalibrationCurve_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>CalibrationCurve</code> object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+val.prob.ci.2">val.prob.ci.2</a></code>
</p>

<hr>
<h2 id='print.GeneralizedCalibrationCurve'>Print function for a GeneralizedCalibrationCurve object</h2><span id='topic+print.GeneralizedCalibrationCurve'></span>

<h3>Description</h3>

<p>Prints the call, confidence level and values for the performance measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeneralizedCalibrationCurve'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GeneralizedCalibrationCurve_+3A_x">x</code></td>
<td>
<p>an object of type GeneralizedCalibrationCurve, resulting from <code><a href="#topic+genCalCurve">genCalCurve</a></code>.</p>
</td></tr>
<tr><td><code id="print.GeneralizedCalibrationCurve_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>GeneralizedCalibrationCurve</code> object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genCalCurve">genCalCurve</a></code>
</p>

<hr>
<h2 id='print.ggplotCalibrationCurve'>Print function for a ggplotCalibrationCurve object</h2><span id='topic+print.ggplotCalibrationCurve'></span>

<h3>Description</h3>

<p>Prints the ggplot, call, confidence level and values for the performance measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggplotCalibrationCurve'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ggplotCalibrationCurve_+3A_x">x</code></td>
<td>
<p>an object of type ggplotCalibrationCurve, resulting from <code><a href="#topic+valProbggplot">valProbggplot</a></code>.</p>
</td></tr>
<tr><td><code id="print.ggplotCalibrationCurve_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>ggplotCalibrationCurve</code> object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valProbggplot">valProbggplot</a></code>
</p>

<hr>
<h2 id='simulateddata'>
Simulated data sets to illustrate the package functionality
</h2><span id='topic+testdata'></span><span id='topic+traindata'></span>

<h3>Description</h3>

<p>Both the <code>traindata</code> and <code>testdata</code> dataframe are synthetically generated data sets to illustrate the functionality of the package. The   <code>traindata</code> has 1000 observations and the <code>testdata</code> has 500 observations. The same settings were used to generate both data   sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(traindata)
  data(testdata)
  </code></pre>


<h3>Format</h3>


<dl>
<dt><code>y</code></dt><dd><p>the binary outcome variable</p>
</dd>
<dt><code>x1</code></dt><dd><p>covariate 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>covariate 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>covariate 3</p>
</dd>
<dt><code>x4</code></dt><dd><p>covariate 4</p>
</dd>
</dl>



<h3>Details</h3>

<p>See the examples for how the data sets were generated.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # The data sets were generated as follows
  set.seed(1782)

  # Simulate training data
  nTrain    = 1000
  B         = c(0.1, 0.5, 1.2, -0.75, 0.8)
  X         = replicate(4, rnorm(nTrain))
  p0true    = binomial()$linkinv(cbind(1, X) %*% B)
  y         = rbinom(nTrain, 1, p0true)
  colnames(X) = paste0("x", seq_len(ncol(X)))
  traindata = data.frame(y, X)

  # Simulate validation data
  nTest    = 500
  X        = replicate(4, rnorm(nTest))
  p0true   = binomial()$linkinv(cbind(1, X) %*% B)
  y        = rbinom(nTest, 1, p0true)
  colnames(X) = paste0("x", seq_len(ncol(X)))
  testdata = data.frame(y, X)
</code></pre>

<hr>
<h2 id='simulatedpoissondata'>
Simulated data sets to illustrate the package functionality
</h2><span id='topic+poissontestdata'></span><span id='topic+poissontraindata'></span>

<h3>Description</h3>

<p>Both the <code>traindata</code> and <code>testdata</code> dataframe are synthetically generated data sets to illustrate the functionality of the package. The   <code>traindata</code> has 5000 observations and the <code>testdata</code> has 1000 observations. The same settings were used to generate both data   sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(poissontraindata)
  data(poissontestdata)
  </code></pre>


<h3>Format</h3>


<dl>
<dt><code>y</code></dt><dd><p>the poisson distributed outcome variable</p>
</dd>
<dt><code>x1</code></dt><dd><p>covariate 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>covariate 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>covariate 3</p>
</dd>
<dt><code>x4</code></dt><dd><p>covariate 4</p>
</dd>
<dt><code>x5</code></dt><dd><p>covariate 5</p>
</dd>
</dl>



<h3>Details</h3>

<p>See the examples for how the data sets were generated.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # The data sets were generated as follows
  library(MASS)
  library(magrittr)
  ScaleRange &lt;- function(x, xmin = -1, xmax = 1) {
  xRange = range(x)
  (x - xRange[1]) / diff(xRange) * (xmax - xmin) + xmin
  }

  set.seed(144)
  p    = 5
  N    = 1e6
  n    = 5e3
  nOOS = 1e3
  S    = matrix(NA, 5, 5)
  rho  = c(0.025, 0, 0, 0.05, 0.075, 0, 0, 0.025, 0, 0)
  S[upper.tri(S)] = rho
  S[lower.tri(S)] = t(S)[lower.tri(S)]
  diag(S) = 1
  Matrix::isSymmetric(S)


  X  = mvrnorm(N, rep(0, p), Sigma = S, empirical = TRUE)
  X  = apply(X, 2, ScaleRange)
  B  = c(-2.3, 1.5, 2, -1, -2, -1.5)
  mu = poisson()$linkinv(cbind(1, X) %*% B)
  Y  = rpois(N, mu)

  Df = data.frame(Y, X)
  colnames(Df)[-1] %&lt;&gt;% tolower()

  set.seed(2)
  DfS   = Df[sample(1:nrow(Df), n, FALSE), ]
  DfOOS = Df[sample(1:nrow(Df), nOOS, FALSE), ]

  poissontraindata = DfS
  poissontestdata  = DfOOS
</code></pre>

<hr>
<h2 id='val.prob.ci.2'>Calibration performance</h2><span id='topic+val.prob.ci.2'></span>

<h3>Description</h3>

<p>The function <code>val.prob.ci.2</code> is an adaptation of <code><a href="rms.html#topic+val.prob">val.prob</a></code> from Frank Harrell's rms package,
<a href="https://cran.r-project.org/package=rms">https://cran.r-project.org/package=rms</a>. Hence, the description of some of the functions of <code>val.prob.ci.2</code>
come from the the original <code><a href="rms.html#topic+val.prob">val.prob</a></code>.
<br /> <br /> The key feature of <code>val.prob.ci.2</code> is the generation of logistic and flexible calibration curves and related statistics.
When using this code, please cite: Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina, M.J., Steyerberg,
E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>,
<b>74</b>, pp. 167-176
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val.prob.ci.2(
  p,
  y,
  logit,
  group,
  weights = rep(1, length(y)),
  normwt = FALSE,
  pl = TRUE,
  smooth = c("loess", "rcs", "none"),
  CL.smooth = "fill",
  CL.BT = FALSE,
  lty.smooth = 1,
  col.smooth = "black",
  lwd.smooth = 1,
  nr.knots = 5,
  logistic.cal = FALSE,
  lty.log = 1,
  col.log = "black",
  lwd.log = 1,
  xlab = "Predicted probability",
  ylab = "Observed proportion",
  xlim = c(-0.02, 1),
  ylim = c(-0.15, 1),
  m,
  g,
  cuts,
  emax.lim = c(0, 1),
  legendloc = c(0.5, 0.27),
  statloc = c(0, 0.85),
  dostats = TRUE,
  cl.level = 0.95,
  method.ci = "pepe",
  roundstats = 2,
  riskdist = "predicted",
  cex = 0.75,
  cex.leg = 0.75,
  connect.group = FALSE,
  connect.smooth = TRUE,
  g.group = 4,
  evaluate = 100,
  nmin = 0,
  d0lab = "0",
  d1lab = "1",
  cex.d01 = 0.7,
  dist.label = 0.04,
  line.bins = -0.05,
  dist.label2 = 0.03,
  cutoff,
  las = 1,
  length.seg = 1,
  y.intersp = 1,
  lty.ideal = 1,
  col.ideal = "red",
  lwd.ideal = 1,
  allowPerfectPredictions = FALSE,
  argzLoess = alist(degree = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val.prob.ci.2_+3A_p">p</code></td>
<td>

<p>predicted probability
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_y">y</code></td>
<td>

<p>vector of binary outcomes
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_logit">logit</code></td>
<td>

<p>predicted log odds of outcome.  Specify either <code>p</code> or <code>logit</code>.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_group">group</code></td>
<td>

<p>a grouping variable.  If numeric this variable is grouped into
<code>g.group</code> quantile groups (default is quartiles).  Set <code>group=TRUE</code> to
use the <code>group</code> algorithm but with a single stratum for <code>val.prob</code>.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_weights">weights</code></td>
<td>

<p>an optional numeric vector of per-observation weights (usually frequencies),
used only if <code>group</code> is given.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_normwt">normwt</code></td>
<td>

<p>set to <code>TRUE</code> to make <code>weights</code> sum to the number of non-missing observations.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_pl">pl</code></td>
<td>
<p><code>TRUE</code> to plot the calibration curve(s). If <code>FALSE</code> no calibration curves will be plotted,
but statistics will still be computed and outputted.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_smooth">smooth</code></td>
<td>
<p><code>"loess"</code> generates a flexible calibration curve based on <code><a href="stats.html#topic+loess">loess</a></code>,
<code>"rcs"</code> generates a calibration curves based on restricted cubic splines (see <code><a href="rms.html#topic+rcs">rcs</a></code> and
<code><a href="Hmisc.html#topic+rcspline.plot">rcspline.plot</a></code>), <code>"none"</code> suppresses the flexible curve. We recommend to use loess unless N is large,
for example N&gt;5000. Default is <code>"loess"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cl.smooth">CL.smooth</code></td>
<td>
<p><code>"fill"</code> shows pointwise 95% confidence limits for the flexible calibration curve with a gray
area between the lower and upper limits, <code>TRUE</code> shows pointwise 95% confidence limits for the flexible calibration curve
with dashed lines, <code>FALSE</code> suppresses the confidence limits. Default is <code>"fill"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cl.bt">CL.BT</code></td>
<td>
<p><code>TRUE</code> uses confidence limits based on 2000 bootstrap samples, <code>FALSE</code> uses closed form confidence limits.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_lty.smooth">lty.smooth</code></td>
<td>
<p>the linetype of the flexible calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_col.smooth">col.smooth</code></td>
<td>
<p>the color of the flexible calibration curve. Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_lwd.smooth">lwd.smooth</code></td>
<td>
<p>the line width of the flexible calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_nr.knots">nr.knots</code></td>
<td>
<p>specifies the number of knots for rcs-based calibration curve. The default as well as the highest allowed value is 5.
In case the specified number of knots leads to estimation problems, then the number of knots is automatically reduced to the closest
value without estimation problems.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_logistic.cal">logistic.cal</code></td>
<td>
<p><code>TRUE</code> plots the logistic calibration curve, <code>FALSE</code> suppresses this curve.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_lty.log">lty.log</code></td>
<td>
<p>if <code>logistic.cal=TRUE</code>, the linetype of the logistic calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_col.log">col.log</code></td>
<td>
<p>if <code>logistic.cal=TRUE</code>, the color of the logistic calibration curve. Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_lwd.log">lwd.log</code></td>
<td>
<p>if <code>logistic.cal=TRUE</code>, the line width of the logistic calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default is <code>"Predicted Probability"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default is <code>"Observed proportion"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_xlim">xlim</code>, <code id="val.prob.ci.2_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges (see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>)</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_m">m</code></td>
<td>

<p>If grouped proportions are desired, average no. observations per group
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_g">g</code></td>
<td>

<p>If grouped proportions are desired, number of quantile groups
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cuts">cuts</code></td>
<td>

<p>If grouped proportions are desired, actual cut points for constructing
intervals, e.g. <code>c(0,.1,.8,.9,1)</code> or <code>seq(0,1,by=.2)</code>
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_emax.lim">emax.lim</code></td>
<td>

<p>Vector containing lowest and highest predicted probability over which to
compute <code>Emax</code>.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_legendloc">legendloc</code></td>
<td>
<p>if <code>pl=TRUE</code>, list with components <code>x,y</code> or vector <code>c(x,y)</code> for bottom right corner of legend for
curves and points. Default is <code>c(.50, .27)</code> scaled to lim. Use <code>locator(1)</code> to use the mouse, <code>FALSE</code> to suppress legend.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_statloc">statloc</code></td>
<td>
<p>the &quot;abc&quot; of model performance (Steyerberg et al., 2011)-calibration intercept, calibration slope,
and c statistic-will be added to the plot, using statloc as the upper left corner of a box (default is c(0,.85).
You can specify a list or a vector. Use locator(1) for the mouse, <code>FALSE</code> to suppress statistics. This is plotted after
the curve legends.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_dostats">dostats</code></td>
<td>
<p>specifies whether and which performance measures are shown in the figure.
<code>TRUE</code> shows the <code>"abc"</code> of model performance (Steyerberg et al., 2011): calibration intercept, calibration slope,
and c-statistic. <code>TRUE</code> is default.
<code>FALSE</code> suppresses the presentation of statistics in the figure. A <code>c()</code> list of specific stats shows the specified
stats. The key stats which are also mentioned in this paper are <code>"C (ROC)"</code> for the c statistic, <code>"Intercept"</code> for the
calibration intercept, <code>"Slope"</code> for the calibration slope, and <code>"ECI"</code> for the estimated calibration index
(Van Hoorde et al, 2015). The full list of possible statistics is taken from <code><a href="rms.html#topic+val.prob">val.prob</a></code>
and augmented with the estimated calibration index: <code>"Dxy", "C (ROC)", "R2", "D", "D:Chi-sq", "D:p", "U", "U:Chi-sq",
  "U:p", "Q", "Brier", "Intercept", "Slope", "Emax", "Brier scaled", "Eavg", "ECI"</code>. These statistics are always returned by the function.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cl.level">cl.level</code></td>
<td>
<p>if <code>dostats=TRUE</code>, the confidence level for the calculation of the confidence intervals of the calibration intercept,
calibration slope and c-statistic. Default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_method.ci">method.ci</code></td>
<td>
<p>method to calculate the confidence interval of the c-statistic. The argument is passed to <code><a href="#topic+auc.nonpara.mw">auc.nonpara.mw</a></code> from
the auRoc-package and possible methods to compute the confidence interval are <code>"newcombe"</code>, <code>"pepe"</code>, <code>"delong"</code> or
<code>"jackknife"</code>. Bootstrap-based methods are not available. The default method is <code>"pepe"</code> and here, the confidence interval is
the logit-transformation-based confidence interval as documented in Qin and Hotilovac (2008). See <code><a href="#topic+auc.nonpara.mw">auc.nonpara.mw</a></code> for
more information on the other methods.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_roundstats">roundstats</code></td>
<td>
<p>specifies the number of decimals to which the statistics are rounded when shown in the plot. Default is 2.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_riskdist">riskdist</code></td>
<td>

<p>Use <code>"calibrated"</code> to plot the relative frequency distribution of
calibrated probabilities after dividing into 101 bins from <code>lim[1]</code> to
<code>lim[2]</code>.
Set to <code>"predicted"</code> (the default as of rms 4.5-1) to use raw assigned risk, <code>FALSE</code> to omit risk distribution.
Values are scaled so that highest bar is <code>0.15*(lim[2]-lim[1])</code>.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cex">cex</code>, <code id="val.prob.ci.2_+3A_cex.leg">cex.leg</code></td>
<td>
<p>controls the font size of the statistics (<code>cex</code>) or plot legend (<code>cex.leg</code>). Default is 0.75</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_connect.group">connect.group</code></td>
<td>

<p>Defaults to <code>FALSE</code> to only represent group fractions as triangles.
Set to <code>TRUE</code> to also connect with a solid line.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_connect.smooth">connect.smooth</code></td>
<td>
<p>Defaults to <code>TRUE</code> to draw smoothed estimates using a line. Set to <code>FALSE</code> to instead use dots at individual estimates</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_g.group">g.group</code></td>
<td>

<p>number of quantile groups to use when <code>group</code> is given and variable is
numeric.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_evaluate">evaluate</code></td>
<td>

<p>number of points at which to store the <code>lowess</code>-calibration curve.
Default is 100.  If there are more than <code>evaluate</code> unique predicted
probabilities, <code>evaluate</code> equally-spaced quantiles of the unique
predicted probabilities, with linearly interpolated calibrated values,
are retained for plotting (and stored in the object returned by
<code>val.prob</code>.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_nmin">nmin</code></td>
<td>

<p>applies when <code>group</code> is given.  When <code>nmin</code> <code class="reqn">&gt; 0</code>, <code>val.prob</code> will not
store coordinates of smoothed calibration curves in the outer tails,
where there are fewer than <code>nmin</code> raw observations represented in
those tails.  If for example <code>nmin</code>=50, the <code>plot</code> function will only
plot the estimated calibration curve from <code class="reqn">a</code> to <code class="reqn">b</code>, where there are
50 subjects with predicted probabilities <code class="reqn">&lt; a</code> and <code class="reqn">&gt; b</code>.
<code>nmin</code> is ignored when computing accuracy statistics.
</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_d0lab">d0lab</code>, <code id="val.prob.ci.2_+3A_d1lab">d1lab</code></td>
<td>
<p>controls the labels for events and non-events (i.e. outcome y) for the histograms.
Defaults are <code>d1lab="1"</code> for events and <code>d0lab="0"</code> for non-events.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cex.d01">cex.d01</code></td>
<td>
<p>controls the size of the labels for events and non-events. Default is 0.7.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_dist.label">dist.label</code></td>
<td>
<p>controls the horizontal position of the labels for events and non-events. Default is 0.04.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_line.bins">line.bins</code></td>
<td>
<p>controls the horizontal (y-axis) position of the histograms. Default is -0.05.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_dist.label2">dist.label2</code></td>
<td>
<p>controls the vertical distance between the labels for events and non-events. Default is 0.03.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_cutoff">cutoff</code></td>
<td>
<p>puts an arrow at the specified risk cut-off(s). Default is none.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_las">las</code></td>
<td>
<p>controls whether y-axis values are shown horizontally (1) or vertically (0).</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_length.seg">length.seg</code></td>
<td>
<p>controls the length of the histogram lines. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_y.intersp">y.intersp</code></td>
<td>
<p>character interspacing for vertical line distances of the legend (<code><a href="graphics.html#topic+legend">legend</a></code>)</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_lty.ideal">lty.ideal</code></td>
<td>
<p>linetype of the ideal line. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_col.ideal">col.ideal</code></td>
<td>
<p>controls the color of the ideal line on the plot. Default is <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_lwd.ideal">lwd.ideal</code></td>
<td>
<p>controls the line width of the ideal line on the plot. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_allowperfectpredictions">allowPerfectPredictions</code></td>
<td>
<p>Logical, indicates whether perfect predictions (i.e. values of either 0 or 1) are allowed. Default is <code>FALSE</code>, since we transform
the predictions using the logit transformation to calculate the calibration measures. In case of 0 and 1, this results in minus infinity and infinity, respectively. if
<code>allowPerfectPredictions = TRUE</code>, 0 and 1 are replaced by 1e-8 and 1 - 1e-8, respectively.</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_argzloess">argzLoess</code></td>
<td>
<p>a list with arguments passed to the <code><a href="stats.html#topic+loess">loess</a></code> function</p>
</td></tr>
<tr><td><code id="val.prob.ci.2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the predicted probabilities of an uninformative model (i.e. equal probabilities for all observations), the model has no predictive value.
Consequently, where applicable, the value of the performance measure corresponds to the worst possible theoretical value. For the ECI, for example, this equals 1 (Edlinger et al., 2022).
</p>


<h3>Value</h3>

<p>An object of type <code>CalibrationCurve</code> with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>a vector containing performance measures of calibration.</p>
</td></tr>
<tr><td><code>cl.level</code></td>
<td>
<p>the confidence level used.</p>
</td></tr>
<tr><td><code>Calibration</code></td>
<td>
<p>contains the calibration intercept and slope, together with their confidence intervals.</p>
</td></tr>
<tr><td><code>Cindex</code></td>
<td>
<p>the value of the c-statistic, together with its confidence interval.</p>
</td></tr>
<tr><td><code>warningMessages</code></td>
<td>
<p>if any, the warning messages that were printed while running the function.</p>
</td></tr>
<tr><td><code>CalibrationCurves</code></td>
<td>
<p>The coordinates for plotting the calibration curves. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>In order to make use (of the functions) of the package auRoc, the user needs to install JAGS. However, since our package only uses the
<code>auc.nonpara.mw</code> function which does not depend on the use of JAGS, we therefore copied the code and slightly adjusted it when
<code>method="pepe"</code>.
</p>


<h3>References</h3>

<p>Edlinger, M, van Smeden, M, Alber, HF, Wanitschek, M, Van Calster, B. (2022). Risk prediction models for discrete ordinal outcomes: Calibration and the impact of the proportional odds assumption. <em>Statistics in Medicine</em>, <b>41( 8)</b>, pp. 1334 1360
</p>
<p>Qin, G., &amp; Hotilovac, L. (2008). Comparison of non-parametric confidence intervals for the area under the ROC curve of a continuous-scale diagnostic test. <em>Statistical Methods in Medical Research</em>, <b>17(2)</b>, pp. 207-21
</p>
<p>Steyerberg, E.W., Van Calster, B., Pencina, M.J. (2011). Performance measures for prediction models and markers : evaluation of predictions and classifications. <em>Revista Espanola de Cardiologia</em>, <b>64(9)</b>, pp. 788-794
</p>
<p>Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina M., Steyerberg E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>, <b>74</b>, pp. 167-176
</p>
<p>Van Hoorde, K., Van Huffel, S., Timmerman, D., Bourne, T., Van Calster, B. (2015). A spline-based tool to assess and visualize the calibration of multiclass risk predictions. <em>Journal of Biomedical Informatics</em>, <b>54</b>, pp. 283-93
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load package
library(CalibrationCurves)
set.seed(1783)

# Simulate training data
X      = replicate(4, rnorm(5e2))
p0true = binomial()$linkinv(cbind(1, X) %*% c(0.1, 0.5, 1.2, -0.75, 0.8))
y      = rbinom(5e2, 1, p0true)
Df     = data.frame(y, X)

# Fit logistic model
FitLog = lrm(y ~ ., Df)

# Simulate validation data
Xval   = replicate(4, rnorm(5e2))
p0true = binomial()$linkinv(cbind(1, Xval) %*% c(0.1, 0.5, 1.2, -0.75, 0.8))
yval   = rbinom(5e2, 1, p0true)
Pred   = binomial()$linkinv(cbind(1, Xval) %*% coef(FitLog))

# Default calibration plot
val.prob.ci.2(Pred, yval)

# Adding logistic calibration curves and other additional features
val.prob.ci.2(Pred, yval, CL.smooth = TRUE, logistic.cal = TRUE, lty.log = 2,
 col.log = "red", lwd.log = 1.5)

val.prob.ci.2(Pred, yval, CL.smooth = TRUE, logistic.cal = TRUE, lty.log = 9,
col.log = "red", lwd.log = 1.5, col.ideal = colors()[10], lwd.ideal = 0.5)
</code></pre>

<hr>
<h2 id='valProbggplot'>Calibration performance: ggplot version</h2><span id='topic+valProbggplot'></span>

<h3>Description</h3>

<p>The function <code>valProbggplot</code> is an adaptation of <code><a href="rms.html#topic+val.prob">val.prob</a></code> from Frank Harrell's rms package,
<a href="https://cran.r-project.org/package=rms">https://cran.r-project.org/package=rms</a>. Hence, the description of some of the functions of <code>valProbggplot</code>
come from the the original <code><a href="rms.html#topic+val.prob">val.prob</a></code>.
<br /> <br /> The key feature of <code>valProbggplot</code> is the generation of logistic and flexible calibration curves and related statistics.
When using this code, please cite: Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina, M.J., Steyerberg,
E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>,
<b>74</b>, pp. 167-176
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valProbggplot(
  p,
  y,
  logit,
  group,
  weights = rep(1, length(y)),
  normwt = FALSE,
  pl = TRUE,
  smooth = c("loess", "rcs", "none"),
  CL.smooth = "fill",
  CL.BT = FALSE,
  lty.smooth = 1,
  col.smooth = "black",
  lwd.smooth = 1,
  nr.knots = 5,
  logistic.cal = FALSE,
  lty.log = 1,
  col.log = "black",
  lwd.log = 1,
  xlab = "Predicted probability",
  ylab = "Observed proportion",
  xlim = c(-0.02, 1),
  ylim = c(-0.15, 1),
  m,
  g,
  cuts,
  emax.lim = c(0, 1),
  legendloc = c(0.5, 0.27),
  statloc = c(0, 0.85),
  dostats = TRUE,
  cl.level = 0.95,
  method.ci = "pepe",
  roundstats = 2,
  riskdist = "predicted",
  size = 3,
  size.leg = 5,
  connect.group = FALSE,
  connect.smooth = TRUE,
  g.group = 4,
  evaluate = 100,
  nmin = 0,
  d0lab = "0",
  d1lab = "1",
  size.d01 = 5,
  dist.label = 0.01,
  line.bins = -0.05,
  dist.label2 = 0.04,
  cutoff,
  length.seg = 0.85,
  lty.ideal = 1,
  col.ideal = "red",
  lwd.ideal = 1,
  allowPerfectPredictions = FALSE,
  argzLoess = alist(degree = 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valProbggplot_+3A_p">p</code></td>
<td>

<p>predicted probability
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_y">y</code></td>
<td>

<p>vector of binary outcomes
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_logit">logit</code></td>
<td>

<p>predicted log odds of outcome.  Specify either <code>p</code> or <code>logit</code>.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_group">group</code></td>
<td>

<p>a grouping variable.  If numeric this variable is grouped into
<code>g.group</code> quantile groups (default is quartiles).  Set <code>group=TRUE</code> to
use the <code>group</code> algorithm but with a single stratum for <code>val.prob</code>.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_weights">weights</code></td>
<td>

<p>an optional numeric vector of per-observation weights (usually frequencies),
used only if <code>group</code> is given.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_normwt">normwt</code></td>
<td>

<p>set to <code>TRUE</code> to make <code>weights</code> sum to the number of non-missing observations.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_pl">pl</code></td>
<td>
<p><code>TRUE</code> to plot the calibration curve(s). If <code>FALSE</code> no calibration curves will be plotted,
but statistics will still be computed and outputted.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_smooth">smooth</code></td>
<td>
<p><code>"loess"</code> generates a flexible calibration curve based on <code><a href="stats.html#topic+loess">loess</a></code>,
<code>"rcs"</code> generates a calibration curves based on restricted cubic splines (see <code><a href="rms.html#topic+rcs">rcs</a></code> and
<code><a href="Hmisc.html#topic+rcspline.plot">rcspline.plot</a></code>), <code>"none"</code> suppresses the flexible curve. We recommend to use loess unless N is large,
for example N&gt;5000. Default is <code>"loess"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_cl.smooth">CL.smooth</code></td>
<td>
<p><code>"fill"</code> shows pointwise 95% confidence limits for the flexible calibration curve with a gray
area between the lower and upper limits, <code>TRUE</code> shows pointwise 95% confidence limits for the flexible calibration curve
with dashed lines, <code>FALSE</code> suppresses the confidence limits. Default is <code>"fill"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_cl.bt">CL.BT</code></td>
<td>
<p><code>TRUE</code> uses confidence limits based on 2000 bootstrap samples, <code>FALSE</code> uses closed form confidence limits.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_lty.smooth">lty.smooth</code></td>
<td>
<p>the linetype of the flexible calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_col.smooth">col.smooth</code></td>
<td>
<p>the color of the flexible calibration curve. Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_lwd.smooth">lwd.smooth</code></td>
<td>
<p>the line width of the flexible calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_nr.knots">nr.knots</code></td>
<td>
<p>specifies the number of knots for rcs-based calibration curve. The default as well as the highest allowed value is 5.
In case the specified number of knots leads to estimation problems, then the number of knots is automatically reduced to the closest
value without estimation problems.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_logistic.cal">logistic.cal</code></td>
<td>
<p><code>TRUE</code> plots the logistic calibration curve, <code>FALSE</code> suppresses this curve. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_lty.log">lty.log</code></td>
<td>
<p>if <code>logistic.cal=TRUE</code>, the linetype of the logistic calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_col.log">col.log</code></td>
<td>
<p>if <code>logistic.cal=TRUE</code>, the color of the logistic calibration curve. Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_lwd.log">lwd.log</code></td>
<td>
<p>if <code>logistic.cal=TRUE</code>, the line width of the logistic calibration curve. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default is <code>"Predicted Probability"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default is <code>"Observed proportion"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_xlim">xlim</code>, <code id="valProbggplot_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the x and y coordinates ranges (see <code><a href="graphics.html#topic+xlim">xlim</a></code> and <code><a href="graphics.html#topic+ylim">ylim</a></code>).</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_m">m</code></td>
<td>

<p>If grouped proportions are desired, average no. observations per group
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_g">g</code></td>
<td>

<p>If grouped proportions are desired, number of quantile groups
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_cuts">cuts</code></td>
<td>

<p>If grouped proportions are desired, actual cut points for constructing
intervals, e.g. <code>c(0,.1,.8,.9,1)</code> or <code>seq(0,1,by=.2)</code>
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_emax.lim">emax.lim</code></td>
<td>

<p>Vector containing lowest and highest predicted probability over which to
compute <code>Emax</code>.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_legendloc">legendloc</code></td>
<td>
<p>if <code>pl=TRUE</code>, list with components <code>x,y</code> or vector <code>c(x,y)</code> for bottom right corner of legend for
curves and points. Default is <code>c(.50, .27)</code> scaled to lim. Use <code>locator(1)</code> to use the mouse, <code>FALSE</code> to suppress legend.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_statloc">statloc</code></td>
<td>
<p>the &quot;abc&quot; of model performance (Steyerberg et al., 2011)-calibration intercept, calibration slope,
and c statistic-will be added to the plot, using statloc as the upper left corner of a box (default is c(0,.85).
You can specify a list or a vector. Use locator(1) for the mouse, <code>FALSE</code> to suppress statistics. This is plotted after
the curve legends.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_dostats">dostats</code></td>
<td>
<p>specifies whether and which performance measures are shown in the figure.
<code>TRUE</code> shows the <code>"abc"</code> of model performance (Steyerberg et al., 2011): calibration intercept, calibration slope,
and c-statistic. <code>TRUE</code> is default.
<code>FALSE</code> suppresses the presentation of statistics in the figure. A <code>c()</code> list of specific stats shows the specified
stats. The key stats which are also mentioned in this paper are <code>"C (ROC)"</code> for the c statistic, <code>"Intercept"</code> for the
calibration intercept, <code>"Slope"</code> for the calibration slope, and <code>"ECI"</code> for the estimated calibration index
(Van Hoorde et al, 2015). The full list of possible statistics is taken from <code><a href="rms.html#topic+val.prob">val.prob</a></code>
and augmented with the estimated calibration index: <code>"Dxy", "C (ROC)", "R2", "D", "D:Chi-sq", "D:p", "U", "U:Chi-sq",
  "U:p", "Q", "Brier", "Intercept", "Slope", "Emax", "Brier scaled", "Eavg", "ECI"</code>. These statistics are always returned by the function.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_cl.level">cl.level</code></td>
<td>
<p>if <code>dostats=TRUE</code>, the confidence level for the calculation of the confidence intervals of the calibration intercept,
calibration slope and c-statistic. Default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_method.ci">method.ci</code></td>
<td>
<p>method to calculate the confidence interval of the c-statistic. The argument is passed to <code><a href="#topic+auc.nonpara.mw">auc.nonpara.mw</a></code> from
the auRoc-package and possible methods to compute the confidence interval are <code>"newcombe"</code>, <code>"pepe"</code>, <code>"delong"</code> or
<code>"jackknife"</code>. Bootstrap-based methods are not available. The default method is <code>"pepe"</code> and here, the confidence interval is
the logit-transformation-based confidence interval as documented in Qin and Hotilovac (2008). See <code><a href="#topic+auc.nonpara.mw">auc.nonpara.mw</a></code> for
more information on the other methods.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_roundstats">roundstats</code></td>
<td>
<p>specifies the number of decimals to which the statistics are rounded when shown in the plot. Default is 2.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_riskdist">riskdist</code></td>
<td>

<p>Use <code>"calibrated"</code> to plot the relative frequency distribution of
calibrated probabilities after dividing into 101 bins from <code>lim[1]</code> to
<code>lim[2]</code>.
Set to <code>"predicted"</code> (the default as of rms 4.5-1) to use raw assigned risk, <code>FALSE</code> to omit risk distribution.
Values are scaled so that highest bar is <code>0.15*(lim[2]-lim[1])</code>.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_size">size</code>, <code id="valProbggplot_+3A_size.leg">size.leg</code></td>
<td>
<p>controls the font size of the statistics (<code>size</code>) or plot legend (<code>size.leg</code>). Default is 3 and 5, respectively.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_connect.group">connect.group</code></td>
<td>

<p>Defaults to <code>FALSE</code> to only represent group fractions as triangles.
Set to <code>TRUE</code> to also connect with a solid line.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_connect.smooth">connect.smooth</code></td>
<td>
<p>Defaults to <code>TRUE</code> to draw smoothed estimates using a line. Set to <code>FALSE</code> to instead use dots at individual estimates</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_g.group">g.group</code></td>
<td>

<p>number of quantile groups to use when <code>group</code> is given and variable is
numeric.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_evaluate">evaluate</code></td>
<td>

<p>number of points at which to store the <code>lowess</code>-calibration curve.
Default is 100.  If there are more than <code>evaluate</code> unique predicted
probabilities, <code>evaluate</code> equally-spaced quantiles of the unique
predicted probabilities, with linearly interpolated calibrated values,
are retained for plotting (and stored in the object returned by
<code>val.prob</code>.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_nmin">nmin</code></td>
<td>

<p>applies when <code>group</code> is given.  When <code>nmin</code> <code class="reqn">&gt; 0</code>, <code>val.prob</code> will not
store coordinates of smoothed calibration curves in the outer tails,
where there are fewer than <code>nmin</code> raw observations represented in
those tails.  If for example <code>nmin</code>=50, the <code>plot</code> function will only
plot the estimated calibration curve from <code class="reqn">a</code> to <code class="reqn">b</code>, where there are
50 subjects with predicted probabilities <code class="reqn">&lt; a</code> and <code class="reqn">&gt; b</code>.
<code>nmin</code> is ignored when computing accuracy statistics.
</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_d0lab">d0lab</code>, <code id="valProbggplot_+3A_d1lab">d1lab</code></td>
<td>
<p>controls the labels for events and non-events (i.e. outcome y) for the histograms.
Defaults are <code>d1lab="1"</code> for events and <code>d0lab="0"</code> for non-events.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_size.d01">size.d01</code></td>
<td>
<p>controls the size of the labels for events and non-events. Default is 5.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_dist.label">dist.label</code></td>
<td>
<p>controls the horizontal position of the labels for events and non-events. Default is 0.01.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_line.bins">line.bins</code></td>
<td>
<p>controls the horizontal (y-axis) position of the histograms. Default is -0.05.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_dist.label2">dist.label2</code></td>
<td>
<p>controls the vertical distance between the labels for events and non-events. Default is 0.03.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_cutoff">cutoff</code></td>
<td>
<p>puts an arrow at the specified risk cut-off(s). Default is none.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_length.seg">length.seg</code></td>
<td>
<p>controls the length of the histogram lines. Default is <code>0.85</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_lty.ideal">lty.ideal</code></td>
<td>
<p>linetype of the ideal line. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_col.ideal">col.ideal</code></td>
<td>
<p>controls the color of the ideal line on the plot. Default is <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_lwd.ideal">lwd.ideal</code></td>
<td>
<p>controls the line width of the ideal line on the plot. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_allowperfectpredictions">allowPerfectPredictions</code></td>
<td>
<p>Logical, indicates whether perfect predictions (i.e. values of either 0 or 1) are allowed. Default is <code>FALSE</code>, since we transform
the predictions using the logit transformation to calculate the calibration measures. In case of 0 and 1, this results in minus infinity and infinity, respectively. if
<code>allowPerfectPredictions = TRUE</code>, 0 and 1 are replaced by 1e-8 and 1 - 1e-8, respectively.</p>
</td></tr>
<tr><td><code id="valProbggplot_+3A_argzloess">argzLoess</code></td>
<td>
<p>a list with arguments passed to the <code><a href="stats.html#topic+loess">loess</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the predicted probabilities of an uninformative model (i.e. equal probabilities for all observations), the model has no predictive value.
Consequently, where applicable, the value of the performance measure corresponds to the worst possible theoretical value. For the ECI, for example, this equals 1 (Edlinger et al., 2022).
</p>


<h3>Value</h3>

<p>An object of type <code>ggplotCalibrationCurve</code> with the following slots:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>ggPlot</code></td>
<td>
<p>the ggplot object.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>a vector containing performance measures of calibration.</p>
</td></tr>
<tr><td><code>cl.level</code></td>
<td>
<p>the confidence level used.</p>
</td></tr>
<tr><td><code>Calibration</code></td>
<td>
<p>contains the calibration intercept and slope, together with their confidence intervals.</p>
</td></tr>
<tr><td><code>Cindex</code></td>
<td>
<p>the value of the c-statistic, together with its confidence interval.</p>
</td></tr>
<tr><td><code>warningMessages</code></td>
<td>
<p>if any, the warning messages that were printed while running the function.</p>
</td></tr>
<tr><td><code>CalibrationCurves</code></td>
<td>
<p>The coordinates for plotting the calibration curves. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>In order to make use (of the functions) of the package auRoc, the user needs to install JAGS. However, since our package only uses the
<code>auc.nonpara.mw</code> function which does not depend on the use of JAGS, we therefore copied the code and slightly adjusted it when
<code>method="pepe"</code>.
</p>


<h3>References</h3>

<p>Edlinger, M, van Smeden, M, Alber, HF, Wanitschek, M, Van Calster, B. (2022). Risk prediction models for discrete ordinal outcomes: Calibration and the impact of the proportional odds assumption. <em>Statistics in Medicine</em>, <b>41( 8)</b>, pp. 1334 1360
</p>
<p>Qin, G., &amp; Hotilovac, L. (2008). Comparison of non-parametric confidence intervals for the area under the ROC curve of a continuous-scale diagnostic test. <em>Statistical Methods in Medical Research</em>, <b>17(2)</b>, pp. 207-21
</p>
<p>Steyerberg, E.W., Van Calster, B., Pencina, M.J. (2011). Performance measures for prediction models and markers : evaluation of predictions and classifications. <em>Revista Espanola de Cardiologia</em>, <b>64(9)</b>, pp. 788-794
</p>
<p>Van Calster, B., Nieboer, D., Vergouwe, Y., De Cock, B., Pencina M., Steyerberg E.W. (2016). A calibration hierarchy for risk models was defined: from utopia to empirical data. <em>Journal of Clinical Epidemiology</em>, <b>74</b>, pp. 167-176
</p>
<p>Van Hoorde, K., Van Huffel, S., Timmerman, D., Bourne, T., Van Calster, B. (2015). A spline-based tool to assess and visualize the calibration of multiclass risk predictions. <em>Journal of Biomedical Informatics</em>, <b>54</b>, pp. 283-93
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load package
library(CalibrationCurves)
set.seed(1783)

# Simulate training data
X      = replicate(4, rnorm(5e2))
p0true = binomial()$linkinv(cbind(1, X) %*% c(0.1, 0.5, 1.2, -0.75, 0.8))
y      = rbinom(5e2, 1, p0true)
Df     = data.frame(y, X)

# Fit logistic model
FitLog = lrm(y ~ ., Df)

# Simulate validation data
Xval   = replicate(4, rnorm(5e2))
p0true = binomial()$linkinv(cbind(1, Xval) %*% c(0.1, 0.5, 1.2, -0.75, 0.8))
yval   = rbinom(5e2, 1, p0true)
Pred   = binomial()$linkinv(cbind(1, Xval) %*% coef(FitLog))

# Default calibration plot
valProbggplot(Pred, yval)

# Adding logistic calibration curves and other additional features
valProbggplot(Pred, yval, CL.smooth = TRUE, logistic.cal = TRUE, lty.log = 2,
 col.log = "red", lwd.log = 1.5)

valProbggplot(Pred, yval, CL.smooth = TRUE, logistic.cal = TRUE, lty.log = 9,
col.log = "red", lwd.log = 1.5, col.ideal = colors()[10], lwd.ideal = 0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
