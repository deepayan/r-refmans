<!DOCTYPE html><html lang="en"><head><title>Help for package parma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#parma-package'><p>The parma package</p></a></li>
<li><a href='#cmaes'>
<p>The Covariance Matrix Adaptation Evolution Strategy (cmaes) Solver</p></a></li>
<li><a href='#constraints'>
<p>NLP custom constraint functions</p></a></li>
<li><a href='#etfdata'><p>15 Exchange Traded Funds (ETFs)</p></a></li>
<li><a href='#parmafrontier-methods'><p>Efficient Frontier Generator</p></a></li>
<li><a href='#parmaPort-class'><p>Class <code>"parmaPort"</code></p></a></li>
<li><a href='#parmasolve-methods'><p>Portfolio Allocation Model Solver</p></a></li>
<li><a href='#parmaSpec-class'><p>Class <code>"parmaSpec"</code></p></a></li>
<li><a href='#parmaspec-methods'><p>Portfolio Allocation Model Specification</p></a></li>
<li><a href='#parmautility-methods'><p>Utility Based Optimization</p></a></li>
<li><a href='#riskfun'>
<p>Portfolio Risk Measures</p></a></li>
<li><a href='#Socp'><p>Second-order Cone Programming</p></a></li>
<li><a href='#SocpControl'><p>Control Variables for Socp</p></a></li>
<li><a href='#SocpPhase1'><p>SOCP: Initialising objective variable x in primal form</p></a></li>
<li><a href='#SocpPhase2'><p>SOCP: Initialising objective variable z in dual form</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Portfolio Allocation and Risk Management Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexios Galanos &lt;alexios@4dscape.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provision of a set of models and methods for use in the allocation and management of capital in financial portfolios.</td>
</tr>
<tr>
<td>Collate:</td>
<td>p-cmaes.R p-classes.R p-constraints.R p-timeseries.R p-fun.R
p-Utility.R p-MILP.R p-NLP.R p-GNLP.R p-LP.R p-QP.R p-SOCP.R
p-main.R p-methods.R Socp.R zzz.R</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods, nloptr</td>
</tr>
<tr>
<td>Imports:</td>
<td>slam, Rglpk, quadprog, corpcor, parallel, truncnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xts, R.rsp</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexiosg/parma">https://github.com/alexiosg/parma</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-27 20:19:08 UTC; alexios</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexios Galanos [aut, cre],
  Bernhard Pfaff [ctb],
  Miguel Sousa Lobo [ctb] (SOCP),
  Lieven Vandenberghe [ctb] (SOCP),
  Stephen Boyd [ctb] (SOCP),
  Herve Lebret [ctb] (SOCP)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-27 23:22:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='parma-package'>The parma package</h2><span id='topic+parma-package'></span><span id='topic+parma'></span>

<h3>Description</h3>

<p>Portfolio Allocation and Risk Management. Models and Methods for scenario and 
moment based optimization of portfolios.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> parma</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-07-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> nloptr, Rglpk, quadprog</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> Rsymphony, truncnorm, timeSeries</td>
</tr>

</table>

<p>The portfolio allocation and risk managament applications (parma) package 
contains a unique set of methods and models for the optimal allocation of 
capital in financial portfolios. It uniquely represents certain discontinuous 
problems using their smooth approximation counterparts and implements fractional 
based programming for the direct optimization of risk-to-reward ratios. In 
combination with the rmgarch package, it enables the confident solution to 
scenario based optimization problems using such risk and deviation measures as 
Mean Absolute Deviation (MAD), Variance (EV), Minimax, Conditional Value at 
Risk (CVaR), Conditional Drawdown at Risk (CDaR) and Lower Partial Moments (LPM). 
In addition, it implements moment based optimization for use with the quadratic 
EV problem, and a higher moment CARA utility expansion using the coskewness and 
cokurtosis matrices generated from the GO-GARCH with affine GH or NIG 
distributions. Benchmark relative optimization (tracking error) is also 
implemented as are basic mixed integer cardinality constraints. Finally, for 
non-convex problem formulations such as the upper to lower partial moments 
function, global optimization methods using a penalty based method are 
available. The key functions in the package are <code><a href="#topic+parmaspec">parmaspec</a></code> 
which defines the optimization setup, and <code><a href="#topic+parmasolve">parmasolve</a></code> which solves
the problem given a chosen representation and solver. A portfolio frontier 
function is implemented in <code><a href="#topic+parmafrontier">parmafrontier</a></code>, utility optimization in
<code><a href="#topic+parmautility">parmautility</a></code> and a custom translation of the cmaes global 
optimization solver of Hansen (2006) with full features is implemented in 
<code><a href="#topic+cmaes">cmaes</a></code>.
</p>


<h3>How to cite this package</h3>

<p>Whenever using this package, please cite as<br />
</p>
<pre>@Manual{Galanos_2014,
 author       = {Alexios Galanos and Bernhard Pfaff},
 title        = {{parma}: Portfolio Allocation and Risk Management Applications.},
 year         = {2014},
 note 	      = {R package version 1.5-1.},}</pre>


<h3>License</h3>

<p>The releases of this package is licensed under GPL version 3.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos and Bernhard Pfaff</p>


<h3>References</h3>

<p>Charnes, A. and Cooper, W. 1962, Programming with linear fractional functionals,
<em>Naval Research Logistics Quarterly</em>, <b>9</b>, 181&ndash;186.<br />
Dinkelbach, W. 1967, On nonlinear fractional programming, <em>Management Science</em>,
<b>13(7)</b>, 492&ndash;498.<br />
Fishburn, P.C. 1977, Mean-risk analysis with risk associated with below-target 
returns, <em>The American Economic Review</em>, <b>67(2)</b>, 116-126.<br />
Galanos, A. 2012, Higher Moment Models for Risk and Portfolio Management, 
Thesis (submitted) <em>Cass Business School</em>.<br />
Hansen, N. 2006, The CMA Evolution Strategy: A Comparing Review, <em>Towards 
a New Evolutionary Computation (Studies in Fuzziness and Soft Computing)</em>, 
<b>192</b>, 75&ndash;102.<br />
Holthausen, D. 1981, A risk-return model with risk and return measured as 
deviations from a target return, <em>The American Economic Review</em>, <b>71</b>,
182&ndash;188.<br />
Konno, H. and Yamazaki, H. 1991, Mean-absolute deviation portfolio optimization 
model and its applications to Tokyo stock market, <em>Management Science</em>,
<b>37(5)</b>, 519&ndash;531.<br />
Markowitz, H. 1952, Portfolio selection, <em>The Journal of Finance</em>, <b>7(1)</b>,
77&ndash;91.<br />
Rockafellar, R.T. and Uryasev, S. and Zabarankin, M., 2006, Generalized deviations 
in risk analysis, <em>Finance and Stochastics</em>, <b>10(1)</b>, 51&ndash;74.<br />
Stoyanov, S.V. and Rachev, S.T. and Fabozzi, F.J. 2007, Optimal financial portfolios,
<em>Applied Mathematical Finance</em>, <b>14(5)</b>, 401&ndash;436.<br />
</p>

<hr>
<h2 id='cmaes'>
The Covariance Matrix Adaptation Evolution Strategy (cmaes) Solver
</h2><span id='topic+cmaes'></span><span id='topic+cmaes.control'></span>

<h3>Description</h3>

<p>The direct translation of the Hansen's cmaes matlab code v3.60.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmaes(pars, fun, lower = rep(0, length(pars)), upper = rep(1, length(pars)), 
insigma = 1, ctrl = cmaes.control(), ...)

cmaes.control(
options = list(StopFitness = -Inf, MaxFunEvals = Inf,
MaxIter = '1e3*(N+5)^2/sqrt(popsize)', StopFunEvals = Inf,
StopIter = Inf, TolX = '1e-11*max(insigma)', TolUpX = '1e3*max(insigma)',
TolFun = 1e-12, TolHistFun = 1e-13, StopOnStagnation = TRUE,
StopOnWarnings = TRUE, StopOnEqualFunctionValues = '2 + N/3',
DiffMaxChange = Inf, DiffMinChange = 0, WarnOnEqualFunctionValues = FALSE,
EvalParallel = FALSE, EvalInitialX = TRUE, Restarts = 0,
IncPopSize = 2, PopSize = '4 + floor(3*log(N))', ParentNumber = 'floor(popsize/2)',
RecombinationWeights = c("superlinear", "linear", "constant"), 
DiagonalOnly = '0*(1+100*N/sqrt(popsize))+(N&gt;=1000)', 
CMA = TRUE, Seed = 'as.integer(Sys.time())', DispFinal = TRUE, 
DispModulo = 100, Warnings = FALSE), 
CMA = list(cs = '(mueff+2)/(N+mueff+3)', 
damps = '1 + 2*max(0,sqrt((mueff-1)/(N+1))-1) + cs',
ccum = '(4 + mueff/N) / (N+4 + 2*mueff/N)', ccov1 = '2 / ((N+1.3)^2+mueff)',
ccovmu = '2 * (mueff-2+1/mueff) / ((N+2)^2+mueff)', active = 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmaes_+3A_pars">pars</code></td>
<td>

<p>A numeric vector of starting parameters.</p>
</td></tr>
<tr><td><code id="cmaes_+3A_fun">fun</code></td>
<td>

<p>The user function to be minimized.</p>
</td></tr>
<tr><td><code id="cmaes_+3A_lower">lower</code></td>
<td>

<p>A vector the lower parameter bounds.
</p>
</td></tr>
<tr><td><code id="cmaes_+3A_upper">upper</code></td>
<td>

<p>A vector with the upper parameter bounds.</p>
</td></tr>
<tr><td><code id="cmaes_+3A_insigma">insigma</code></td>
<td>

<p>The initial coordinate wise standard deviations for the search.</p>
</td></tr>
<tr><td><code id="cmaes_+3A_ctrl">ctrl</code></td>
<td>

<p>A list with control parameters as returned from calling the &lsquo;cmaes.control&rsquo;
function.
</p>
</td></tr>
<tr><td><code id="cmaes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the user function.</p>
</td></tr>
<tr><td><code id="cmaes_+3A_options">options</code></td>
<td>
<p>The main options in the cmaes.control which may be optionally
strings which are evaluated on initialization of the solver.</p>
</td></tr>
<tr><td><code id="cmaes_+3A_cma">CMA</code></td>
<td>
<p>The options for the active CMA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This solver has been translated from the matlab version created by Nikolaus 
Hansen and available on his website <a href="http://www.cmap.polytechnique.fr/~nikolaus.hansen/cmaes_inmatlab.html">http://www.cmap.polytechnique.fr/~nikolaus.hansen/cmaes_inmatlab.html</a>.
There is also a <span class="pkg">cmaes</span> on CRAN but this does not offer the same level of
options and flexibility that the matlab version offers. For more details on
what the options mean and generally how the cmaes solver works, consult the 
relevant website and literature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Hansen, N. 2006, The CMA Evolution Strategy: A Comparing Review, <em>Towards 
a New Evolutionary Computation (Studies in Fuzziness and Soft Computing)</em>, 
<b>192</b>, 75&ndash;102.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ctrl = cmaes.control()
ctrl$options$StopOnWarnings = FALSE
ctrl$cma$active = 1
ctrl$options$TolFun = 1e-12
ctrl$options$DispModulo=100
ctrl$options$Restarts = 0
ctrl$options$MaxIter = 3000
ctrl$options$TolUpX = 5
ctrl$options$PopSize = 300
test1 = cmaes(rnorm(10), fun = parma:::fsphere, 
lower = -Inf, upper = Inf, insigma = 1, ctrl = ctrl)
test2 = cmaes(rnorm(10), fun = parma:::frosenbrock, 
lower = -Inf, upper = Inf, insigma = 1, ctrl = ctrl)

ctrl = cmaes.control()
ctrl$options$StopOnWarnings = FALSE
ctrl$cma$active = 1
ctrl$options$TolFun = 1e-12
ctrl$options$DispModulo=100
ctrl$options$Restarts = 0
ctrl$options$MaxIter = 3000
ctrl$options$PopSize = 400
test3 = cmaes(rep(1, 10), fun = parma:::frastrigin10, 
lower = -50, upper = 50, insigma = 1, ctrl = ctrl)

## End(Not run)</code></pre>

<hr>
<h2 id='constraints'>
NLP custom constraint functions
</h2><span id='topic+ineqfun.turnover.min'></span><span id='topic+ineqjac.turnover.min'></span><span id='topic+ineqfun.bsturnover.min'></span><span id='topic+ineqjac.bsturnover.min'></span><span id='topic+ineqfun.turnover.opt'></span><span id='topic+ineqjac.turnover.opt'></span><span id='topic+ineqfun.bsturnover.opt'></span><span id='topic+ineqjac.bsturnover.opt'></span><span id='topic+ineqfun.variance.opt'></span><span id='topic+ineqjac.variance.opt'></span><span id='topic+ineqfun.variance.min'></span><span id='topic+ineqjac.variance.min'></span>

<h3>Description</h3>

<p>Provides a number of custom constraints and their jacobians for use with the NLP 
representation (both minimum risk and the fractional problem).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ineqfun.turnover.min(w, optvars, uservars)
ineqjac.turnover.min(w, optvars, uservars)
ineqfun.bsturnover.min(w, optvars, uservars)
ineqjac.bsturnover.min(w, optvars, uservars)
ineqfun.turnover.opt(w, optvars, uservars)
ineqjac.turnover.opt(w, optvars, uservars)
ineqfun.bsturnover.opt(w, optvars, uservars)
ineqjac.bsturnover.opt(w, optvars, uservars)
ineqfun.variance.opt(w, optvars, uservars)
ineqjac.variance.opt(w, optvars, uservars)
ineqfun.variance.min(w, optvars, uservars)
ineqjac.variance.min(w, optvars, uservars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constraints_+3A_w">w</code></td>
<td>
<p> The decision weight vector.</p>
</td></tr>
<tr><td><code id="constraints_+3A_optvars">optvars</code></td>
<td>
<p> Problem specific list (not for use by user).</p>
</td></tr>
<tr><td><code id="constraints_+3A_uservars">uservars</code></td>
<td>
<p> User specific list with some required parameters to be set 
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions preceded be &ldquo;ineqfun&rdquo; denote the functions which may be
passed to the ineqfun option in the <code>parmaspec</code> function, while 
&ldquo;eqfun&rdquo; to the eqfun option. Functions which include &ldquo;jac&rdquo; in the
first part of the name denote the jacobians of the equivalent constraints and
should be passed to the ineqgrad or eqgrad options in <code>parmaspec</code>. Functions
ending with &ldquo;min&rdquo; denote formulations for use with the minrisk type problems
while functions ending with &ldquo;opt&rdquo; denote the fractional risk formulation.<br />
For the simple turnover constraint, the uservars list must contain an entry
called &lsquo;wold&rsquo; denoting the previous vector of weights with which the
comparison will be made. Additionally, an entry called  &lsquo;turnover&rsquo; 
is required which denotes the (positive) value for the maximum turnover.<br />
For the buy and sell turnover constraint (bsturnover), there should instead
be (positive) &lsquo;buyturnover&rsquo; and &lsquo;sellturnover&rsquo; entries in the
uservars list. Finally note that when using this type of constraints in a fractional 
programming setup, care should be taken that the combination of bounds, turnover 
limits and the forecast return vector do not result in a negative expected return 
in which case the problem is not solvable.<br />
The variance constraint allows the targeting of a maximum acceptable variance.
The extra arguments which must be passed to the uservars list are &lsquo;Cov&rsquo; 
for the asset covariance matrix and &lsquo;varbound&rsquo; representing the maximum 
acceptable upper variance.
</p>


<h3>Value</h3>

<p>Used internally by the NLP solver. The fun return a scalar, while the jac return
a matrix with n.cols equal to the length of the decision vector (which may be
greater than the length of the weights as in the fractional problem which 
contains the fractional multiplier as well as other formulations which have 
additional decision variables).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='etfdata'>15 Exchange Traded Funds (ETFs)</h2><span id='topic+etfdata'></span>

<h3>Description</h3>

<p>The xts dataset consists of the adjusted daily closing prices of 15 
iShare ETFs for the period 2003-05-28 to 2012-06-01 (2272 periods) representing 
a selection of US style and international equity benchmark. The iShare 
series are IWF (Russell 1000 Growth Index), IWD (Russell 1000 Value Index),
IWO (Russell 2000 Growth Index), IWN (Russell 2000 Value Index),
EEM (MSCI Emerging Markets Index), TLT (Barclays 20+ Year T-Bond),
EWC (MSCI Canada Index), EWA (MSCI Australia Index), EWJ (MSCI Japan Index),
EWG (MSCI Germany Index), EWL (MSCI Switzerland Index), EWQ (MSCI France Index),
EWU (MSCI UK Index), EPP (MSCI Pacific ex-Japan), EZA (MSCI South Africa Index).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(etfdata)</code></pre>


<h3>Format</h3>

<p>An xts matrix containing 2272x15 observations.</p>


<h3>Source</h3>

<p>Yahoo Finance</p>

<hr>
<h2 id='parmafrontier-methods'>Efficient Frontier Generator</h2><span id='topic+parmafrontier'></span><span id='topic+parmafrontier-methods'></span><span id='topic+parmafrontier+2CANY-method'></span><span id='topic+parmafrontier+2CparmaSpec-method'></span>

<h3>Description</h3>

<p>Solves for the portfolios on the efficient frontier given a specification
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmafrontier(spec, n.points = 100, miny = NULL, maxy = NULL, type = NULL, 
solver = NULL, solver.control = list(), parma.control = list(ubounds = 10000, 
mbounds = 1e+05, penalty = 10000), cluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parmafrontier-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+parmaSpec-class">parmaSpec</a></code> object.</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_n.points">n.points</code></td>
<td>
<p> The number of portfolios to solve for along the frontier.</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_miny">miny</code></td>
<td>
<p> (Optional) Minimum return from which to calculate the frontier. If 
not provided, will be calculated by a first pass optimization.</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_maxy">maxy</code></td>
<td>
<p> (Optional) Maximum return for which to calculate the frontier. If 
not provided, will be based on the maximum forecast.</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_type">type</code></td>
<td>
<p> The problem type to use (the show method on <code><a href="#topic+parmaSpec-class">parmaSpec</a></code> 
will indicate the available options).</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_solver">solver</code></td>
<td>
<p> For a GNLP type problem the choice of global solver, either
&ldquo;cmaes&rdquo; or &ldquo;crs&rdquo; from the <code>nloptr</code> package. </p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_solver.control">solver.control</code></td>
<td>
<p> A list with optional control parameters passed to the
<code>nloptr</code> or <code><a href="#topic+cmaes">cmaes</a></code> solver.</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_parma.control">parma.control</code></td>
<td>
<p> Internal NLP tuning parameters, where &lsquo;ubounds&rsquo; 
represents the symmetric unconstrained parameter bounds in the fractional 
problem, &lsquo;mbounds&rsquo; the multiplier upper bounds in the fractional 
formulation, &lsquo;penalty&rsquo; the GNLP penalty parameter.</p>
</td></tr>
<tr><td><code id="parmafrontier-methods_+3A_cluster">cluster</code></td>
<td>
<p> A precreated cluster object from the parallel package for the
parallel evaluation of the frontier portfolios (see note). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If using a cluster object, care should be taken since some of the LP based
problems are quite memory intensive. Though some care some gone into using
slam matrices and forcing garbage collection in intermediate setup steps of these
problems, there is no guarantee that memory will not be quickly depleted for
large problems using many cores/sockets.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> object with columns for the weights, risk, reward and
termination status of the solver (not available for the QP solver), and
n.points rows. The user should investigate the non-converged solutions as well
as remove any NA based rows (non-converged with error).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='parmaPort-class'>Class <code>"parmaPort"</code></h2><span id='topic+parmaPort-class'></span><span id='topic+show+2CparmaPort-method'></span><span id='topic+weights+2CparmaPort-method'></span><span id='topic+tictoc+2CparmaPort-method'></span><span id='topic+tictoc+2CANY-method'></span><span id='topic+tictoc'></span><span id='topic+checkarbitrage+2CparmaPort-method'></span><span id='topic+checkarbitrage+2CANY-method'></span><span id='topic+checkarbitrage'></span><span id='topic+parmarisk+2CparmaPort-method'></span><span id='topic+parmarisk+2CANY-method'></span><span id='topic+parmarisk'></span><span id='topic+parmareward+2CparmaPort-method'></span><span id='topic+parmareward+2CANY-method'></span><span id='topic+parmareward'></span><span id='topic+parmastatus+2CparmaPort-method'></span><span id='topic+parmastatus+2CANY-method'></span><span id='topic+parmastatus'></span>

<h3>Description</h3>

<p>The parma optimal portfolio class.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to <code><a href="#topic+parmasolve">parmasolve</a>.</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>solution</code>:</dt><dd><p>Object of class <code>"vector"</code> The list with the
optimal values.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> A list with details of 
the risk model.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "parmaPort")</code>: Summary. </p>
</dd>
<dt>weights</dt><dd><p><code>signature(object = "parmaPort")</code>: Extracts the optimal 
weights.</p>
</dd>
<dt>tictoc</dt><dd><p><code>signature(object = "parmaPort")</code>: Extracts the time 
elapsed to solve the problem.</p>
</dd>
<dt>checkarbitrage</dt><dd><p><code>signature(object = "parmaPort")</code>: Extracts the 
arbitrage check on the scenario.</p>
</dd>
<dt>parmarisk</dt><dd><p><code>signature(object = "parmaPort")</code>: Extracts the expected 
risk of the optimized portfolio.</p>
</dd>
<dt>parmareward</dt><dd><p><code>signature(object = "parmaPort")</code>: Extracts the expected 
reward of the optimized portfolio.</p>
</dd>
<dt>parmastatus</dt><dd><p><code>signature(object = "parmaPort")</code>: Solver termination
code for the LP and NLP solvers.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("parmaPort")
</code></pre>

<hr>
<h2 id='parmasolve-methods'>Portfolio Allocation Model Solver</h2><span id='topic+parmasolve'></span><span id='topic+parmasolve-methods'></span><span id='topic+parmasolve+2CANY-method'></span><span id='topic+parmasolve+2CparmaSpec-method'></span>

<h3>Description</h3>

<p>Solves for the optimal weights given parmaSpec defined model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmasolve(spec, type = NULL, solver = NULL, solver.control = list(), x0 = NULL, 
w0 = NULL, parma.control = list(ubounds = 1e4, mbounds = 1e5, 
penalty = 1e4, eqSlack = 1e-05), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parmasolve-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+parmaSpec-class">parmaSpec</a></code> object.</p>
</td></tr>
<tr><td><code id="parmasolve-methods_+3A_type">type</code></td>
<td>
<p> The problem type to use (the show method on <code><a href="#topic+parmaSpec-class">parmaSpec</a></code> 
will indicate the available options).</p>
</td></tr>
<tr><td><code id="parmasolve-methods_+3A_solver">solver</code></td>
<td>
<p> For a GNLP type problem the choice of global solver, either
&ldquo;cmaes&rdquo; or &ldquo;crs&rdquo; from the <code>nloptr</code> package. For LP type problems,
only glpk ic currently supported.</p>
</td></tr> 
<tr><td><code id="parmasolve-methods_+3A_solver.control">solver.control</code></td>
<td>
<p> A list with optional control parameters passed to the
<code>nloptr</code> or <code><a href="#topic+cmaes">cmaes</a></code> solver.</p>
</td></tr>
<tr><td><code id="parmasolve-methods_+3A_x0">x0</code></td>
<td>
<p> Optional starting parameters for the NLP type problems. This 
may be of size greater than the number of assets depending on whether it takes
extra optimization parameters (CVaR has VaR in position 1, whilst the fractional
formulation has the multiplier in the last position).</p>
</td></tr>
<tr><td><code id="parmasolve-methods_+3A_w0">w0</code></td>
<td>
<p> Optional starting parameters for only the asset weights.</p>
</td></tr>
<tr><td><code id="parmasolve-methods_+3A_parma.control">parma.control</code></td>
<td>
<p> Internal NLP tuning parameters, where &lsquo;ubounds&rsquo; represents
the symmetric unconstrained parameter bounds in the fractional problem, &lsquo;mbounds&rsquo;
the multiplier upper bounds in the fractional formulation, &lsquo;penalty&rsquo; the GNLP
penalty parameter and &lsquo;eqSlack&rsquo; the slack value to use for converting equalities
to inequalities in the SOCP formulation.</p>
</td></tr>
<tr><td><code id="parmasolve-methods_+3A_...">...</code></td>
<td>
<p> Currently only the &lsquo;verbose&rsquo; argument (logical) which is used 
and passed to the GLPK solver (similar to &lsquo;trace&rsquo;). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most of the cases, the intersection of objective and constraints will define
whether a problem is LP, MILP, QP, MIQP, QCQP, NLP, MINLP or GNLP. However, 
there are cases when the problem can be solved by more than one type of solver 
so that the &lsquo;type&rsquo; option allows the user to choose between the options. 
For the GNLP type, the &lsquo;solver&rsquo; allows for a choice of &ldquo;cmaes&rdquo; or 
&ldquo;crs&rdquo;, while the LP type there is a choice of &ldquo;glpk&rdquo; or &ldquo;symphony&rdquo;.
Future development will likely expand on these choices.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+parmaPort-class">parmaPort</a></code> object containing details of the PARMA
optimized portfolio.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='parmaSpec-class'>Class <code>"parmaSpec"</code></h2><span id='topic+parmaSpec-class'></span><span id='topic+show+2CparmaSpec-method'></span><span id='topic+parmaset+3C-'></span><span id='topic+parmaset+3C-+2CANY+2CANY-method'></span><span id='topic+parmaset+3C-+2CparmaSpec+2Cvector-method'></span><span id='topic+parmaget+2CparmaSpec-method'></span><span id='topic+parmaget+2CANY-method'></span><span id='topic+parmaget'></span>

<h3>Description</h3>

<p>Object returned from calling <code><a href="#topic+parmaspec">parmaspec</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("parmaSpec")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>A list with details of the risk and optimization model.</p>
</dd>
<dt><code>modeldata</code>:</dt><dd><p>A list with the data.</p>
</dd>
<dt><code>constraints</code>:</dt><dd><p>A list with details on the optimization 
constraints.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>parmasolve</dt><dd><p><code>signature(spec = "parmaSpec")</code>: 
Solves for the optimal weights. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "parmaSpec")</code>: Summary method. </p>
</dd>
<dt>parmaset&lt;-</dt><dd><p><code>signature(object = "parmaSpec")</code>: Set a specified 
&lsquo;arg&rsquo; from the list of arguments defined in the <code><a href="#topic+parmaspec">parmaspec</a></code> 
to some &lsquo;value&rsquo; and return a modified specification. </p>
</dd>
<dt>parmaget</dt><dd><p><code>signature(object = "parmaSpec")</code>:  Get a specified 
&lsquo;arg&rsquo; from the list of arguments defined in the <code><a href="#topic+parmaspec">parmaspec</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("parmaSpec")
</code></pre>

<hr>
<h2 id='parmaspec-methods'>Portfolio Allocation Model Specification</h2><span id='topic+parmaspec'></span><span id='topic+parmaspec-methods'></span><span id='topic+parmaspec+2CANY-method'></span>

<h3>Description</h3>

<p>Defines the type model and method for optimization using either a scenario or 
covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmaspec(scenario = NULL, probability = NULL, S = NULL, Q = NULL, qB = NULL, 
		benchmark = NULL, benchmarkS = NULL, forecast = NULL, target = NULL, 
		targetType =  c("inequality", "equality"), 
		risk = c("MAD", "MiniMax", "CVaR", "CDaR", "EV", "LPM", "LPMUPM"), 
		riskType = c("minrisk", "optimal", "maxreward"), riskB = NULL,
		options = list(alpha = 0.05, threshold = 999, moment = 1, lmoment=1,
		umoment=1, lthreshold = -0.01, uthreshold = 0.01), 
		LB = NULL, UB = NULL, budget = 1, leverage = NULL, 
		ineqfun = NULL, ineqgrad = NULL, eqfun = NULL, eqgrad = NULL, 
		uservars = list(), ineq.mat = NULL, ineq.LB = NULL, 
		ineq.UB = NULL, eq.mat = NULL, eqB = NULL, max.pos = NULL, 
		asset.names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parmaspec-methods_+3A_scenario">scenario</code></td>
<td>
<p> An n-by-m scenario matrix.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_probability">probability</code></td>
<td>
<p> An optional n-by-1 vector of scenario probabilities which
must sum to 1 (only currently used in LP problems). Default is to assign equal 
weights to each row of the scenario.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_s">S</code></td>
<td>
<p> An m-by-m positive definite covariance matrix.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_q">Q</code></td>
<td>
<p> A list of m-by-m positive definite matrices for QCQP type problems.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_qb">qB</code></td>
<td>
<p> a vector of the same length as Q denoting the upper bound on Q.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_benchmark">benchmark</code></td>
<td>
<p> A n-by-1 scenario benchmark matrix, used when scenario is not 
NULL.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_benchmarks">benchmarkS</code></td>
<td>
<p> An m+1 vector consisting of the benchmark variance (1) and 
covariances (m) with the other m assets, used when S is not NULL.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_forecast">forecast</code></td>
<td>
<p> A vector (m) of forecast values for the assets. If a benchmark
is included, this should then be the active forecast over the benchmark.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_target">target</code></td>
<td>
<p> The target return required when riskType is minrisk. If a benchmark
is used, then this is the active target over the benchmark (given the active
forecasts above).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_targettype">targetType</code></td>
<td>
<p> Whether the target should be a hard equality or inequality.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_risk">risk</code></td>
<td>
<p> The risk measure.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_risktype">riskType</code></td>
<td>
<p> The type of optimization to use, with a choice of minimizing the
risk given the relevant constraints, on optimizing directly the risk to 
reward ratio using established fractional programming methods or maximizing the
reward subject to a risk upper bound and other constraints (only currently supported
by the SOCP solver for covariance matrix type problems).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_riskb">riskB</code></td>
<td>
<p>For the case that riskType is &ldquo;maxreward&rdquo;, then riskB is the
upper bound for the risk constraint.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_options">options</code></td>
<td>
<p> A vector of optional parameters related to the tail risk measures
CVaR, CDaR and LPM.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_lb">LB</code></td>
<td>
<p> The lower bounds for the asset weights. If using a benchmark, this
should be the maximum deviation below the benchmark weights.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_ub">UB</code></td>
<td>
<p> The upper bounds for the asset weights. If using a benchmark, this
should be the maximum deviation above the benchmark weights.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_budget">budget</code></td>
<td>
<p> The investment constraint. If using a benchmark, this is usually
set to zero so that weights represent the active bets on the benchmark.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_leverage">leverage</code></td>
<td>
<p> The leverage constraint for Long/Short optimization.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_ineqfun">ineqfun</code></td>
<td>
<p> A list of user inequality functions for use in an NLP type 
setup (see details).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_ineqgrad">ineqgrad</code></td>
<td>
<p> A list of user inequality gradients if ineqfun was provided.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_eqfun">eqfun</code></td>
<td>
<p> A list of user equality functions for use in an NLP type setup 
(see details).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_eqgrad">eqgrad</code></td>
<td>
<p> A list of user equality gradients if eqfun was provided.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_uservars">uservars</code></td>
<td>
<p> A list of any additional user required values to be used with
user defined inequality and equality functions (for NLP).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_ineq.mat">ineq.mat</code></td>
<td>
<p> A k-by-m inequality matrix (for LP and QP problems).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_ineq.lb">ineq.LB</code></td>
<td>
<p> A vector (k) of the lower bounds for the ineq.mat.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_ineq.ub">ineq.UB</code></td>
<td>
<p> A vector (k) of the upper bounds for the ineq.mat.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_eq.mat">eq.mat</code></td>
<td>
<p> A l-by-m equality matrix (for LP and QP problems).</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_eqb">eqB</code></td>
<td>
<p> A vector (l) of equalities for the eq.mat.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_max.pos">max.pos</code></td>
<td>
<p> Cardinality Constraints. The maximum assets to include in the 
solution, effectively making this a MILP, MIQP or MINLP problem.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_asset.names">asset.names</code></td>
<td>
<p>An optional character vector of asset names.</p>
</td></tr>
<tr><td><code id="parmaspec-methods_+3A_...">...</code></td>
<td>
<p> Not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parmaspec method is the entry point for specifying and solving portfolio 
problems in the parma package. Currently 7 measures of risk are supported, 3 
based on tail measures: Conditional Value at Risk (CVaR), Conditional Drawdown at 
Risk (CDaR) and Lower Partial Moments (LPM), and 3 based on the Lp-Norm: Mean
Absolute Deviation (L_1, MAD), Mean Variance (L_2, EV) and MiniMax 
(L_inf, Minimax). The LPMUPM measure is the ratio of lower to upper partial moments, 
a non convex measure discussed in Holthausen (1981).
Additionally, the problems may be solved based on minimization
of risk subject to a target return, else on the optimal risk-reward ratio using
fractional programming (see references), thus avoiding the estimation of the 
entire frontier. Problems are classified and solved according to whether they
can be formulated as Linear (LP), Mixed Integer LP (MILP), Quadratic (QP), 
Mixed Integer Quadratic (MIQP), Second Order Cone Programming (SOCP), 
Non-Linear (NLP), Mixed Integer NLP (MINLP) and Global NLP (GNLP). This in turn
depends on the intersection of objectives and constraints. It is possible that a
problem may be solved both as an LP and NLP (or QP and NLP), and this can be 
defined during the solver stage (<code><a href="#topic+parmasolve">parmasolve</a></code>). Because all NLP models, 
make use of analytical derivatives, the results should be the same for any 
formulation chosen, and considerations such as memory usage should guide the 
choice of formulation (with some LP models being particularly expensive). Not 
all problem types are supported, but this might change subject to the availability 
of solvers in R which can deal with these specific types e.g. MINLP and MIQP. 
The parmaspec also allows the input of a benchmark so that benchmark relative 
optimization is carried out.
User defined equality and inequality functions for NLP problems need to be 
properly defined to be accepted by the model, and their analytic gradients
also provided, unless the problem is solved as a GNLP in which case a derivative 
free penalty function is used. These custom constraint functions should be 
provided in a list, and should take as arguments the vector of decision 
variables &lsquo;w&rsquo;, an argument called &lsquo;optvars&rsquo; which is used
by the program internally, and an argument called &lsquo;uservars&rsquo; which is a 
list with optional user defined values for the constraints. The examples in the 
inst folder provide some guidance, and the user is left to his own devices to 
study the underlying workings of the program to understand how to supply these.
Finally, the NLP functions which are known to be discontinuous because of the
presence of functions such as the min and max, have been re-written to take
advantage of smooth approximations to such functions, details of which may be
founds in the vignette.
The package support for GNLP is based on a choice of the cmaes solver of the 
<span class="pkg">cmaes</span> package (which is not production level) or the crs solver of the 
<span class="pkg">nloptr</span> package which may be defined in solver.control option of the 
<code><a href="#topic+parmasolve">parmasolve</a></code> method with named argument &lsquo;solver&rsquo;. High quality
GNLP solvers are not available in R and as such support for these types of 
problems is experimental at best and your mileage will vary. The problems which 
must be solved as GNLP include the &lsquo;LPMUPM&rsquo; measure, all problems with
risk type &lsquo;optimal&rsquo; AND cardinality constraints (&lsquo;max.pos&rsquo;), and 
all problems with custom NLP constraints without derivatives, non-convex 
inequalities or non-affine equalities.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+parmaSpec-class">parmaSpec</a></code> object containing details of the PARMA
specification.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='parmautility-methods'>Utility Based Optimization</h2><span id='topic+parmautility'></span><span id='topic+parmautility-methods'></span><span id='topic+parmautility+2CANY-method'></span>

<h3>Description</h3>

<p>Utility based portfolio optimization using either Taylor series expansion of
utility function with moments or scenario based.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmautility(U = c("CARA", "Power"), method = c("moment", "scenario"),
		scenario = NULL, M1 = NULL, M2 =  NULL, M3 = NULL, M4 = NULL, RA = 1, 
		budget = 1, LB = rep(0, length(M1)), UB = rep(1, length(M1)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parmautility-methods_+3A_u">U</code></td>
<td>
<p> The utility function (only CARA curretly implemented).</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_method">method</code></td>
<td>
<p> Whether to use moment or scenario based optimization (only moment
currently implemented).</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_scenario">scenario</code></td>
<td>
<p> A n-by-m scenario matrix.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_m1">M1</code></td>
<td>
<p> A vector (m) of forecasts.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_m2">M2</code></td>
<td>
<p> An m-by-m positive definite covariance matrix.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_m3">M3</code></td>
<td>
<p> An m-by-m^2 third co-moment matrix.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_m4">M4</code></td>
<td>
<p> An m-by-m^3 fourth co-moment matrix.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_ra">RA</code></td>
<td>
<p>Risk Aversion Coefficient for CARA.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_budget">budget</code></td>
<td>
<p> The investment constraint.</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_lb">LB</code></td>
<td>
<p> The lower bounds for the asset weights (positive).</p>
</td></tr>
<tr><td><code id="parmautility-methods_+3A_ub">UB</code></td>
<td>
<p> The upper bounds for the asset weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently only implements the CARA moment based approach, but will
be expanded in the future. The moment approach can take as inputs either M1 and 
M2 (2-moment approximation), or M1, M2, M3 and M4 (4-moment approximation). Not
many models generate M3 and M4, but the &ldquo;gogarch&rdquo; model with manig or 
magh distribution will.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+parmaPort-class">parmaPort</a></code> object containing details of the PARMA
optimized portfolio.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Galanos, A. and Rossi, E. and Urga, G. 2012, Independent Factor Autoregressive
Conditional Density Model <em>submitted-TBA</em><br />
</p>

<hr>
<h2 id='riskfun'>
Portfolio Risk Measures
</h2><span id='topic+riskfun'></span>

<h3>Description</h3>

<p>Calculates a given portfolio risk/deviation measure given a set of weights
and matrix of returns, possible representing a forecast scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskfun(weights, Data, risk = c("mad", "ev", "minimax", "cvar", "cdar", "lpm"), 
benchmark = NULL, alpha = 0.05, moment = 1, threshold = 0, VaR = NULL, DaR = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riskfun_+3A_weights">weights</code></td>
<td>
<p> vector of weights.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_data">Data</code></td>
<td>
<p> Matrix of returns.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_risk">risk</code></td>
<td>
<p> Choice of measure.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_benchmark">benchmark</code></td>
<td>
<p> (Optional) vector of benchmark returns with same number of
rows as Data.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_alpha">alpha</code></td>
<td>
<p> The lower quantile for the &ldquo;cvar&rdquo; and &ldquo;cdar&rdquo; 
measures.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_moment">moment</code></td>
<td>
<p> The &ldquo;lpm&rdquo; measure moment.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_threshold">threshold</code></td>
<td>
<p> The &ldquo;lpm&rdquo; measure threshold. A value of 999 will 
subtract the portfolio mean.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_var">VaR</code></td>
<td>
<p> (Optional) The pre-calculated VaR for the &ldquo;cvar&rdquo; measure.</p>
</td></tr>
<tr><td><code id="riskfun_+3A_dar">DaR</code></td>
<td>
<p> (Optional) The pre-calculated DaR for the &ldquo;cdar&rdquo; measure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple utility function for the calculation and understanding of some of the 
risk and deviation measures implemented in the package.
</p>


<h3>Value</h3>

<p>A numeric value representing the risk/deviation measure.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='Socp'>Second-order Cone Programming</h2><span id='topic+Socp'></span>

<h3>Description</h3>

<p>The function solves second-order cone problem by
primal-dual interior point method. It is a wrapper function to the
<code>C</code>-routines written by Lobo, Vandenberghe and Boyd (see
reference below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Socp(f, A, b, C, d, N,
     x = NULL, z = NULL, w = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Socp_+3A_f">f</code></td>
<td>
<p>Vector defining linear objective, <code>length(f)==length(x)</code> </p>
</td></tr>
<tr><td><code id="Socp_+3A_a">A</code></td>
<td>
<p>Matrix with the <code class="reqn">A_i</code> vertically stacked:  <code class="reqn">A = [
  A_1; A_2; \ldots; A_L]</code>.</p>
</td></tr>
<tr><td><code id="Socp_+3A_b">b</code></td>
<td>
<p>Vector with the <code class="reqn">b_i</code> vertically stacked: <code class="reqn">b = [ b_1;
  b_2; \ldots; b_L]</code>.</p>
</td></tr> 
<tr><td><code id="Socp_+3A_c">C</code></td>
<td>
<p> Matrix with the <code class="reqn">c_i'</code> vertically stacked: <code class="reqn">C = [ c_1';
        c_2'; \ldots; c_L']</code>.</p>
</td></tr>
<tr><td><code id="Socp_+3A_d">d</code></td>
<td>
<p>Vector with the <code class="reqn">d_i</code> vertically stacked: <code class="reqn">d = [ d_1;
  d_2; \ldots;  d_L]</code>.</p>
</td></tr> 
<tr><td><code id="Socp_+3A_n">N</code></td>
<td>
<p>Vector of size <code>L</code>, defining the size of each constraint.</p>
</td></tr>
<tr><td><code id="Socp_+3A_x">x</code></td>
<td>
<p>Primal feasible initial point. Must satisfy: <code class="reqn">|| A_i*x +
  b_i || &lt; c_i' * x + d_i</code> for <code class="reqn">i = 1, \ldots, L</code>.</p>
</td></tr>
<tr><td><code id="Socp_+3A_z">z</code></td>
<td>
<p>Dual feasible initial point.</p>
</td></tr>
<tr><td><code id="Socp_+3A_w">w</code></td>
<td>
<p>Dual feasible initial point.</p>
</td></tr>
<tr><td><code id="Socp_+3A_control">control</code></td>
<td>
<p>A list of control parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primal formulation of an SOCP is given as:
</p>
<p style="text-align: center;"><code class="reqn">minimise f' * x</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">||A_i*x + b_i|| &lt;= c_i' * x + d_i</code>
</p>

<p>for <code class="reqn">i = 1,\ldots, L</code>. Here, <code class="reqn">x</code> is the <code class="reqn">(n \times 1)</code>
vector to be optimised. The dual form of an SOCP is expressed as:
</p>
<p style="text-align: center;"><code class="reqn">maximise \sum_{i = 1}^L -(b' * z_i + d_i * w_i)</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^L (A_i' * z_i + c_i * w_i) = f</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">||z_i || = w_i</code>
</p>

<p>for <code class="reqn">i = 1,\ldots, L</code>, given strictly feasible primal and dual
initial points.<br />
</p>
<p>The algorithm stops, if one of the following criteria is met:
</p>

<ol>
<li> <p><code>abs.tol</code> &ndash; maximum absolute error in objective
function; guarantees that for any x:  <code class="reqn">abs(f'*x - f'*x\_opt) &lt;=
    abs\_tol</code>. 
</p>
</li>
<li> <p><code>rel.tol</code> &ndash; maximum relative error in objective
function; guarantees that for any x: <code class="reqn">abs(f'*x -
    f'*x\_opt)/(f'*x\_opt) &lt;= rel\_tol  (if f'*x\_opt &gt; 0)</code>. Negative
value has special meaning, see target next.
</p>
</li>
<li> <p><code>target</code> &ndash; if <code class="reqn">rel\_tol&lt;0</code>, stops when
<code class="reqn">f'*x &lt; target or -b'*z &gt;= target</code>.
</p>
</li>
<li> <p><code>max.iter</code> &ndash; limit on number of algorithm outer iterations.
Most problems can be solved in less than 50 iterations. Called with
<code>max_iter = 0</code> only checks feasibility of <code>x</code> and <code>z</code>,
(and returns gap and deviation from centrality).
</p>
</li>
<li><p> The target value is reached. <code>rel\_tol</code> is negative and
the primal objective <code class="reqn">p</code> is less than the <code>target</code>.  
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>list</code>-object with the following elements:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Solution to the primal problem.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Solution to the dual problem.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations performed.</p>
</td></tr>
<tr><td><code>hist</code></td>
<td>
<p>see <code>out_mode</code> in <code><a href="#topic+SocpControl">SocpControl</a></code>.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A logical code. <code>TRUE</code> indicates successful
convergence.</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>A numerical code. It indicates if the convergence was
successful.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A character string giving any additional information
returned by the optimiser.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function has been ported from the <span class="pkg">Rsocp</span> package contained
in the Rmetrics-Project on R-Forge. In contrast to the former
implementation, allowance is made for specifying more than one cone
constraint. 
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Lobo, M. and Vandenberghe, L. and Boyd, S., <em>SOCP: Software for
Second-order Cone Programming, User's Guide</em>, Beta Version, April
1997, Stanford University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SocpPhase1">SocpPhase1</a></code>, <code><a href="#topic+SocpPhase2">SocpPhase2</a></code>, <code><a href="#topic+SocpControl">SocpControl</a></code>
</p>

<hr>
<h2 id='SocpControl'>Control Variables for Socp</h2><span id='topic+SocpControl'></span>

<h3>Description</h3>

<p>This function returns a <code>list</code> object of control parameters that
are passed down to the <code>C</code>-function <code>SOCP</code>. It's default
values are used in <code>Socp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SocpControl(abs.tol = 1e-18, rel.tol = 1e-16, target = 0,
            max.iter = 500, Nu = 10, out.mode = 0, BigM.K = 2,
            BigM.iter = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SocpControl_+3A_abs.tol">abs.tol</code></td>
<td>
<p>Absolute tolerance.</p>
</td></tr>
<tr><td><code id="SocpControl_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Relative tolerance.</p>
</td></tr>
<tr><td><code id="SocpControl_+3A_target">target</code></td>
<td>
<p>Target value &lt; 0, only used if rel.tol &lt; 0.</p>
</td></tr>
<tr><td><code id="SocpControl_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iterations, socp is aborted if
more are required for convergence.</p>
</td></tr> 
<tr><td><code id="SocpControl_+3A_nu">Nu</code></td>
<td>
<p>The parameter that controls the rate of convergence, Nu &gt; 1,
recommended range 5 to 50.</p>
</td></tr> 
<tr><td><code id="SocpControl_+3A_out.mode">out.mode</code></td>
<td>
<p>Specifies what should be output: 0 - nothing, 1 -
duality gap for initial point and after each iteration, 2 - duality
gap and deviation from centrality, for initial point and after each
iteration.</p>
</td></tr>
<tr><td><code id="SocpControl_+3A_bigm.k">BigM.K</code></td>
<td>
<p>Iterataion parameter. The default values is <code>BigM.K
  = 2</code>.</p>
</td></tr>
<tr><td><code id="SocpControl_+3A_bigm.iter">BigM.iter</code></td>
<td>
<p>Iterataion parameter. The default values is
<code>BigM.iter = 5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about these control parameters, the reader is referred to
the reference below, in particular sections 2.7, 2.8 and 4.3 to 4.5. A
pdf-version of the user's guide is shipped in the packages <code>doc</code>
subdirectory. 
</p>


<h3>Value</h3>

<p>A <code>list</code> object with the control parameters.</p>


<h3>Note</h3>

<p>This function has been ported from the <span class="pkg">Rsocp</span> package contained
in the Rmetrics-Project on R-Forge.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Lobo, M. and Vandenberghe, L. and Boyd, S., <em>SOCP: Software for
Second-order Cone Programming, User's Guide</em>, Beta Version, April
1997, Stanford University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Socp">Socp</a></code>
</p>

<hr>
<h2 id='SocpPhase1'>SOCP: Initialising objective variable x in primal form</h2><span id='topic+SocpPhase1'></span>

<h3>Description</h3>

<p>This function determines values for <code>x</code>, whence they have not
been specified by the user. Here, a feasibility problem is solved
first and its solution is then used as an initial point for the
original problem.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SocpPhase1(f, A, b, N, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SocpPhase1_+3A_f">f</code></td>
<td>
<p><code>vector</code>: the parameters of the objective function in
its primal form.</p>
</td></tr>
<tr><td><code id="SocpPhase1_+3A_a">A</code></td>
<td>
<p><code>matrix</code>; the parameter matrix of the cone constraints.</p>
</td></tr>
<tr><td><code id="SocpPhase1_+3A_b">b</code></td>
<td>
<p><code>vector</code>: the parameter vector of the cone constraints.</p>
</td></tr>
<tr><td><code id="SocpPhase1_+3A_n">N</code></td>
<td>
<p><code>vector</code>: the count of rows pertinent to each cone constraint.</p>
</td></tr>
<tr><td><code id="SocpPhase1_+3A_control">control</code></td>
<td>
<p><code>list</code>: the list of control parameters for SOCP.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The finding of an initial point <code>x</code> is described in the user's
guide, sectionb 2.8.</p>


<h3>Value</h3>

<p>A vector with the initial point for <code>x</code>.</p>


<h3>Note</h3>

<p>This function has been ported from the <span class="pkg">Rsocp</span> package contained
in the Rmetrics-Project on R-Forge.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Lobo, M. and Vandenberghe, L. and Boyd, S., <em>SOCP: Software for
Second-order Cone Programming, User's Guide</em>, Beta Version, April
1997, Stanford University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Socp">Socp</a></code>, <code><a href="#topic+SocpPhase2">SocpPhase2</a></code>, <code><a href="#topic+SocpControl">SocpControl</a></code>
</p>

<hr>
<h2 id='SocpPhase2'>SOCP: Initialising objective variable z in dual form</h2><span id='topic+SocpPhase2'></span>

<h3>Description</h3>

<p>This function determines values for <code>z</code>, whence they have not
been specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SocpPhase2(f, A, b, N, x, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SocpPhase2_+3A_f">f</code></td>
<td>
<p><code>vector</code>: the parameters of the objective function in
its primal form.</p>
</td></tr>
<tr><td><code id="SocpPhase2_+3A_a">A</code></td>
<td>
<p><code>matrix</code>; the parameter matrix of the cone constraints.</p>
</td></tr>
<tr><td><code id="SocpPhase2_+3A_b">b</code></td>
<td>
<p><code>vector</code>: the parameter vector of the cone constraints.</p>
</td></tr>
<tr><td><code id="SocpPhase2_+3A_n">N</code></td>
<td>
<p><code>vector</code>: the count of rows pertinent to each cone constraint.</p>
</td></tr>
<tr><td><code id="SocpPhase2_+3A_x">x</code></td>
<td>
<p><code>vector</code>: initial point of SOCP in its primal form.</p>
</td></tr>
<tr><td><code id="SocpPhase2_+3A_control">control</code></td>
<td>
<p><code>list</code>: the list of control parameters for SOCP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the initial point for <code>z</code> (dual form of
SOCP).</p>


<h3>Note</h3>

<p>This function has been ported from the <span class="pkg">Rsocp</span> package contained
in the Rmetrics-Project on R-Forge.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Lobo, M. and Vandenberghe, L. and Boyd, S., <em>SOCP: Software for
Second-order Cone Programming, User's Guide</em>, Beta Version, April
1997, Stanford University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Socp">Socp</a></code>, <code><a href="#topic+SocpPhase1">SocpPhase1</a></code>, <code><a href="#topic+SocpControl">SocpControl</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
