<!DOCTYPE html><html lang="en-US"><head><title>Help for package viewscape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {viewscape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_diversity'><p>calculate_diversity</p></a></li>
<li><a href='#calculate_feature'><p>calculate_feature</p></a></li>
<li><a href='#calculate_viewmetrics'><p>calculate_viewmetrics</p></a></li>
<li><a href='#compute_viewshed'><p>compute_viewshed</p></a></li>
<li><a href='#fov_mask'><p>fov_mask</p></a></li>
<li><a href='#Viewshed-class'><p>An S4 class to represent the viewshed</p></a></li>
<li><a href='#visual_magnitude'><p>visual_magnitude</p></a></li>
<li><a href='#visualize_viewshed'><p>visualize_viewshed</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Viewscape Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to make R a more effective viewscape analysis 
    tool for calculating viewscape metrics based on computing the viewable area for 
    given a point/multiple viewpoints and a digital elevation model.The method of calculating 
    viewscape metrics implemented in this package are based on the work of 
    Tabrizian et al. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.landurbplan.2019.103704">doi:10.1016/j.landurbplan.2019.103704</a>&gt;. The algorithm of computing 
    viewshed is based on the work of 
    Franklin &amp; Ray. (1994) <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;amp;type=pdf&amp;amp;doi=555780f6f5d7e537eb1edb28862c86d1519af2be">https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=555780f6f5d7e537eb1edb28862c86d1519af2be</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/land-info-lab/viewscape">https://github.com/land-info-lab/viewscape</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/land-info-lab/viewscape/issues">https://github.com/land-info-lab/viewscape/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, rlang, methods, dplyr, sf, sp, terra, ForestTools (&ge;
1.0.1), parallel, pbmcapply</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-19 20:52:25 UTC; yangxiaohao</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaohao Yang [aut, cre, cph],
  Nathan Fox [aut],
  Derek Van Berkel [aut],
  Mark Lindquist [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaohao Yang &lt;xiaohaoy@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-19 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_diversity'>calculate_diversity</h2><span id='topic+calculate_diversity'></span>

<h3>Description</h3>

<p>The calculate_diversity function is designed to calculate landscape
diversity metrics within a viewshed. It takes as input a land cover raster,
a viewshed object representing the observer's line of sight, and an optional
parameter to compute class proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_diversity(viewshed, land, proportion = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_diversity_+3A_viewshed">viewshed</code></td>
<td>
<p>Viewshed object.</p>
</td></tr>
<tr><td><code id="calculate_diversity_+3A_land">land</code></td>
<td>
<p>Raster. The raster of land use/land cover representing different
land use/cover classes.</p>
</td></tr>
<tr><td><code id="calculate_diversity_+3A_proportion">proportion</code></td>
<td>
<p>logical (Optional), indicating whether to return class
proportions along with the Shannon Diversity Index (SDI). (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. a list containing the Shannon Diversity Index (SDI) and,
if the proportion parameter is set to TRUE, a table of class proportions
within the viewshed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(viewscape)
# Load a viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))
# load dsm raster
dsm &lt;- terra::rast(system.file("test_dsm.tif", package ="viewscape"))
#Compute viewshed
output &lt;- viewscape::compute_viewshed(dsm = dsm,
                                      viewpoints = test_viewpoint,
                                      offset_viewpoint = 6, r = 1600)
# load landuse raster
test_landuse &lt;- terra::rast(system.file("test_landuse.tif",
                                        package ="viewscape"))
diversity &lt;- viewscape::calculate_diversity(output,
                                            test_landuse)

</code></pre>

<hr>
<h2 id='calculate_feature'>calculate_feature</h2><span id='topic+calculate_feature'></span>

<h3>Description</h3>

<p>The calculate_feature function is designed to extract specific
feature-related information within a viewshed. It allows you to compute
the proportion of the feature that is present in the viewshed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_feature(viewshed, feature, type, exclude_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_feature_+3A_viewshed">viewshed</code></td>
<td>
<p>Viewshed object.</p>
</td></tr>
<tr><td><code id="calculate_feature_+3A_feature">feature</code></td>
<td>
<p>Raster. Land cover or land use</p>
</td></tr>
<tr><td><code id="calculate_feature_+3A_type">type</code></td>
<td>
<p>Numeric. The input type of land cover raster.
type=1: percentage raster (that represents the percentage of
area in each cell).
type=2: binary raster (that only uses two values to represent whether
the feature exists in each cell).</p>
</td></tr>
<tr><td><code id="calculate_feature_+3A_exclude_value">exclude_value</code></td>
<td>
<p>Numeric. the value of those cells need to be excluded
in the analysis. If type = 2, exclude_value is reqired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The canopy area in the viewshed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(viewscape)
# Load a viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))
# load dsm raster
dsm &lt;- terra::rast(system.file("test_dsm.tif", package ="viewscape"))
#Compute viewshed
viewshed &lt;- viewscape::compute_viewshed(dsm = dsm,
                                        viewpoints = test_viewpoint,
                                        offset_viewpoint = 6)
# load canopy raster
test_canopy &lt;- terra::rast(system.file("test_canopy.tif",
                                       package ="viewscape"))
# calculate the percentage of canopy coverage
test_canopy_proportion &lt;- viewscape::calculate_feature(viewshed = viewshed,
                                                       feature = test_canopy,
                                                       type = 2,
                                                       exclude_value = 0)
</code></pre>

<hr>
<h2 id='calculate_viewmetrics'>calculate_viewmetrics</h2><span id='topic+calculate_viewmetrics'></span>

<h3>Description</h3>

<p>The calculate_viewmetrics function is designed to compute a set of
configuration metrics based on a given viewshed object and optionally, digital surface
models (DSM) and digital terrain models (DTM) for terrain analysis.
The function calculates various metrics that describe the visibility characteristics
of a landscape from a specific viewpoint.The metrics include:
</p>

<ol>
<li><p> Extent: The total area of the viewshed, calculated as the number of visible grid
cells multiplied by the grid resolution
</p>
</li>
<li><p> Depth: The furthest visible distance within the viewshed from the viewpoint
</p>
</li>
<li><p> Vdepth: The standard deviation of distances to visible points,
providing a measure of the variation in visible distances
</p>
</li>
<li><p> Horizontal: The total visible horizontal or terrestrial area within the viewshed
</p>
</li>
<li><p> Relief: The standard deviation of elevations of the visible ground surface
</p>
</li>
<li><p> Skyline: The standard deviation of the vertical viewscape, including visible
canopy and buildings, when specified
</p>
</li>
<li><p> Number of patches: Visible fragmentation measured by total visible patches
with the viewscape
</p>
</li>
<li><p> Mean shape index: Visible patchiness based on average perimeter-to-area ratio
for all viewscape patches (vegetation and building)
</p>
</li>
<li><p> Edge density: A measure of visible complexity based on the length of
patch edges per unit area
</p>
</li>
<li><p> Patch size: Total average size of a patches over the entire viewscape area
</p>
</li>
<li><p> Patch density: Visible landscape granularity based on measuring patch density
</p>
</li>
<li><p> Shannon diversity index: The abundance and evenness of land cover/use in a viewshed
</p>
</li>
<li><p> Proportion of object: Proportion of a single type of land use or cover in a viewshed
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>calculate_viewmetrics(viewshed, dsm, dtm, masks = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_viewmetrics_+3A_viewshed">viewshed</code></td>
<td>
<p>Viewshed object.</p>
</td></tr>
<tr><td><code id="calculate_viewmetrics_+3A_dsm">dsm</code></td>
<td>
<p>Raster, Digital Surface Model for the calculation of</p>
</td></tr>
<tr><td><code id="calculate_viewmetrics_+3A_dtm">dtm</code></td>
<td>
<p>Raster, Digital Terrain Model</p>
</td></tr>
<tr><td><code id="calculate_viewmetrics_+3A_masks">masks</code></td>
<td>
<p>List, a list including rasters of canopy and building footprints.
For example of canopy raster, the value for cells without canopy should be 0 and
the value for cells with canopy can be any number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>


<h3>References</h3>

<p>Tabrizian, P., Baran, P.K., Berkel, D.B., Mitásová, H., &amp; Meentemeyer, R.K. (2020).
Modeling restorative potential of urban environments by coupling viewscape analysis of lidar
data with experiments in immersive virtual environments. Landscape and Urban Planning, 195, 103704.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load in DSM
test_dsm &lt;- terra::rast(system.file("test_dsm.tif",
                                    package ="viewscape"))
# Load DTM
test_dtm &lt;- terra::rast(system.file("test_dtm.tif",
                                    package ="viewscape"))

# Load canopy raster
test_canopy &lt;- terra::rast(system.file("test_canopy.tif",
                                       package ="viewscape"))

# Load building footprints raster
test_building &lt;- terra::rast(system.file("test_building.tif",
                                         package ="viewscape"))

# Load in the viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp",
                                          package = "viewscape"))

# Compute viewshed
output &lt;- viewscape::compute_viewshed(dsm = test_dsm,
                                      viewpoints = test_viewpoint,
                                      offset_viewpoint = 6, r = 1600)

# calculate metrics given the viewshed, canopy, and building footprints
test_metrics &lt;- viewscape::calculate_viewmetrics(output,
                                                 test_dsm,
                                                 test_dtm,
                                                 list(test_canopy, test_building))


</code></pre>

<hr>
<h2 id='compute_viewshed'>compute_viewshed</h2><span id='topic+compute_viewshed'></span>

<h3>Description</h3>

<p>The compute_viewshed function is designed for computing viewsheds,
which are areas visible from specific viewpoints, based on a Digital Surface
Model (DSM). It provides flexibility for single or multi-viewpoint analyses
and allows options for parallel processing, raster output, and plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_viewshed(
  dsm,
  viewpoints,
  offset_viewpoint = 1.7,
  offset_height = 0,
  r = NULL,
  refraction_factor = 0.13,
  method = "plane",
  parallel = FALSE,
  workers = 1,
  raster = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_viewshed_+3A_dsm">dsm</code></td>
<td>
<p>Raster, the digital surface model/digital elevation model</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_viewpoints">viewpoints</code></td>
<td>
<p>sf point(s) or vector including x,y coordinates of a viewpoint
or a matrix including several viewpoints with x,y coordinates</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_offset_viewpoint">offset_viewpoint</code></td>
<td>
<p>numeric, setting the height of the viewpoint.
(default is 1.7 meters).</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_offset_height">offset_height</code></td>
<td>
<p>numeric, setting the height of positions that a given
viewpoint will look at. (defaut is 0)</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_r">r</code></td>
<td>
<p>Numeric (optional), setting the radius for viewshed analysis.
(The default is 1000m/3281ft)</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_refraction_factor">refraction_factor</code></td>
<td>
<p>Number, indicating the refraction factor.
The refraction factor adjusts the effect of atmospheric refraction
on the apparent curvature of the Earth. In most standard applications, a refraction factor
of 0.13 is used, and so does this function. However, the appropriate refraction factor may
vary depending on environmental conditions.</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_method">method</code></td>
<td>
<p>Character, The algorithm for computing a viewshed:
&quot;plane&quot; and &quot;los&quot; (see details). &quot;plane&quot; is used as default.</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_parallel">parallel</code></td>
<td>
<p>Logical, (default is FALSE) indicating if parallel computing
should be used to compute viewsheds of multiview points. When it is TRUE,
arguements 'raster' and 'plot' are ignored</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_workers">workers</code></td>
<td>
<p>Numeric, indicating the number of CPU cores that will be used
for parallel computing. It is required if 'parallel' is 'TRUE'.</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_raster">raster</code></td>
<td>
<p>Logical, (default is FALSE) if it is TRUE, the raster of
viewshed will be returned.
The default is FALSE</p>
</td></tr>
<tr><td><code id="compute_viewshed_+3A_plot">plot</code></td>
<td>
<p>Logical, (default is FALSE) if it is TRUE, the raster of
viewshed will be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For method, &quot;plane&quot; is the reference plane algorithm introduced by
Wang et al. (2000) and &quot;los&quot; is the line of sight algorithm (Franklin &amp; Ray, 1994).
The reference plane algorithm can be more time-efficient than the line of sight
algorithm, whereas the accuracy of the line of sight is better.
</p>


<h3>Value</h3>

<p>Raster or list. For single-viewpoint analysis, the function returns
either a raster (raster is TRUE) or a viewshed object. Value 1 means visible while
value 0 means invisible. For multi-viewpoint analysis, a list of viewsheds
is returned.
</p>


<h3>References</h3>

<p>Franklin, W. R., &amp; Ray, C. (1994, May).
Higher isn’t necessarily better: Visibility algorithms and experiments.
In Advances in GIS research: sixth international symposium on spatial
data handling (Vol. 2, pp. 751-770). Edinburgh: Taylor &amp; Francis.
</p>
<p>Wang, J., Robinson, G. J., &amp; White, K. (2000).
Generating viewsheds without using sightlines.
Photogrammetric engineering and remote sensing, 66(1), 87-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fov_mask">fov_mask()</a></code> <code><a href="#topic+visual_magnitude">visual_magnitude()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))
# load dsm raster
dsm &lt;- terra::rast(system.file("test_dsm.tif", package ="viewscape"))
#Compute viewshed
output &lt;- viewscape::compute_viewshed(dsm = dsm,
                                      viewpoints = test_viewpoint,
                                      offset_viewpoint = 6, r = 1600)
</code></pre>

<hr>
<h2 id='fov_mask'>fov_mask</h2><span id='topic+fov_mask'></span>

<h3>Description</h3>

<p>The fov_mask function is designed to subset a viewshed based on
its viewpoint and the field of view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fov_mask(viewshed, fov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fov_mask_+3A_viewshed">viewshed</code></td>
<td>
<p>viewshed object, generated by compute_viewshed()</p>
</td></tr>
<tr><td><code id="fov_mask_+3A_fov">fov</code></td>
<td>
<p>Vector, specifying the field of view with two angles in degree (e.g. c(10,100))
for masking a viewshed based on its viewpoints.
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For defining the field of view ('fov'), angles range from 0 to 360 degrees,
with 0 inclusive and 360 exclusive. The initial angle must be smaller than the terminal
angle in the sequence c(a,b) (a &lt; b). To capture the northeast quadrant of a viewshed,
one would use c(0,90), while the eastern quadrant would be delineated by c(45,315) as
shown below:
</p>

<table>
<tr>
 <td style="text-align: right;">
135 </td><td style="text-align: right;"> 90 </td><td style="text-align: right;"> 45 </td>
</tr>
<tr>
 <td style="text-align: right;">
180 </td><td style="text-align: right;"> v </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
225 </td><td style="text-align: right;"> 270 </td><td style="text-align: right;"> 315 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Here, 'v' represents the viewpoint, with angles measured counterclockwise from due north.
</p>


<h3>Value</h3>

<p>viewshed object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_viewshed">compute_viewshed()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))
# load dsm raster
dsm &lt;- terra::rast(system.file("test_dsm.tif", package ="viewscape"))
# Compute viewshed
viewshed &lt;- viewscape::compute_viewshed(dsm,
                                        viewpoints = test_viewpoint,
                                        offset_viewpoint = 6)
# subset viewshed using the field of view
out &lt;- viewscape::fov_mask(viewshed, c(40,160))

</code></pre>

<hr>
<h2 id='Viewshed-class'>An S4 class to represent the viewshed</h2><span id='topic+Viewshed-class'></span>

<h3>Description</h3>

<p>A <code>viewshed</code> object contains a 'matrix' of visible and invisible area,
resolution, extent, and crs
</p>


<h3>Slots</h3>


<dl>
<dt><code>visible</code></dt><dd><p>matrix</p>
</dd>
<dt><code>resolution</code></dt><dd><p>vector</p>
</dd>
<dt><code>extent</code></dt><dd><p>numeric</p>
</dd>
<dt><code>crs</code></dt><dd><p>character</p>
</dd>
</dl>

<hr>
<h2 id='visual_magnitude'>visual_magnitude</h2><span id='topic+visual_magnitude'></span>

<h3>Description</h3>

<p>This function is still in progress.
Visual Magnitude quantifies the extent of a visible region
as perceived by an observer. It is derived from the surface's slope and
angle features, alongside the observer's relative distance from the area
(Chamberlain &amp; Meitner).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visual_magnitude(viewshed, dsm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visual_magnitude_+3A_viewshed">viewshed</code></td>
<td>
<p>Viewshed object.</p>
</td></tr>
<tr><td><code id="visual_magnitude_+3A_dsm">dsm</code></td>
<td>
<p>Raster, the digital surface / elevation model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>References</h3>

<p>Chamberlain, B. C., &amp; Meitner, M. J. (2013).
A route-based visibility analysis for landscape management.
Landscape and Urban Planning, 111, 13-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_viewshed">compute_viewshed()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))
# load dsm raster
dsm &lt;- terra::rast(system.file("test_dsm.tif", package ="viewscape"))
# Compute viewshed
viewshed &lt;- viewscape::compute_viewshed(dsm = dsm,
                                        viewpoints = test_viewpoint,
                                        offset_viewpoint = 6)
# Compute visual magnitude
vm &lt;- viewscape::visual_magnitude(viewshed, dsm)


</code></pre>

<hr>
<h2 id='visualize_viewshed'>visualize_viewshed</h2><span id='topic+visualize_viewshed'></span>

<h3>Description</h3>

<p>The visualize_viewshed function is designed for the visualization
of a viewshed analysis, providing users with various options for visualizing
the results. The function works with a viewshed object and offers multiple
plotting and output types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize_viewshed(viewshed, plottype = "", outputtype = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualize_viewshed_+3A_viewshed">viewshed</code></td>
<td>
<p>Viewshed object</p>
</td></tr>
<tr><td><code id="visualize_viewshed_+3A_plottype">plottype</code></td>
<td>
<p>Character, specifying the type of visualization (&quot;polygon&quot; or
&quot;raster&quot;).</p>
</td></tr>
<tr><td><code id="visualize_viewshed_+3A_outputtype">outputtype</code></td>
<td>
<p>Character, specifying the type of output object (&quot;raster&quot;
or &quot;polygon&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Visualized viewshed as either a raster or polygon object,
depending on the outputtype specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a viewpoint
test_viewpoint &lt;- sf::read_sf(system.file("test_viewpoint.shp", package = "viewscape"))
# load dsm raster
dsm &lt;- terra::rast(system.file("test_dsm.tif", package ="viewscape"))
#Compute viewshed
viewshed &lt;- compute_viewshed(dsm = dsm,
                             viewpoints = test_viewpoint,
                             offset_viewpoint = 6)
# Visualize the viewshed as polygons
visualize_viewshed(viewshed, plottype = "polygon")
# Visualize the viewshed as a raster
visualize_viewshed(viewshed, plottype = "raster")
# Get the visualized viewshed as a polygon object
polygon_viewshed &lt;- visualize_viewshed(viewshed,
                                       plottype = "polygon",
                                       outputtype = "polygon")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
