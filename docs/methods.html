<!DOCTYPE html><html><head><title>Help for package methods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {methods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.BasicFunsList'><p>List of Builtin and Special Functions</p></a></li>
<li><a href='#as'><p>Force an Object to Belong to a Class</p></a></li>
<li><a href='#BasicClasses'><p>Classes Corresponding to Basic Data Types</p></a></li>
<li><a href='#callGeneric'><p>Call the Current Generic Function from a Method</p></a></li>
<li><a href='#callNextMethod'><p>Call an Inherited Method</p></a></li>
<li><a href='#canCoerce'><p>Can an Object be Coerced to a Certain S4 Class?</p></a></li>
<li><a href='#cbind2'><p>Combine two Objects by Columns or Rows</p></a></li>
<li><a href='#Classes'><p>S4 Class Documentation</p></a></li>
<li><a href='#Classes_Details'><p>Class Definitions</p></a></li>
<li><a href='#classesToAM'>
<p>Compute an Adjacency Matrix for Superclasses of Class Definitions</p></a></li>
<li><a href='#className'>
<p>Class names including the corresponding package</p></a></li>
<li><a href='#classRepresentation-class'><p>Class Objects</p></a></li>
<li><a href='#Documentation'><p>Using and Creating On-line Documentation for Classes and</p>
Methods</a></li>
<li><a href='#dotsMethods'><p>The Use of <code>...</code> in Method Signatures</p></a></li>
<li><a href='#EmptyMethodsList-class'><p>Internal Class representing Empty Methods List</p></a></li>
<li><a href='#environment-class'><p>Class <code>"environment"</code></p></a></li>
<li><a href='#envRefClass-class'><p>Class <code>"envRefClass"</code></p></a></li>
<li><a href='#evalSource'>
<p>Use Function Definitions from a Source File without Reinstalling a Package</p></a></li>
<li><a href='#findClass'><p>Find Class Definitions</p></a></li>
<li><a href='#findMethods'><p>Description of the Methods Defined for a Generic Function</p></a></li>
<li><a href='#fixPre1.8'><p>Fix Objects Saved from R Versions Previous to 1.8</p></a></li>
<li><a href='#genericFunction-class'><p>Generic Function Objects</p></a></li>
<li><a href='#GenericFunctions'><p>Tools for Managing Generic Functions</p></a></li>
<li><a href='#getClass'><p>Get Class Definition</p></a></li>
<li><a href='#getMethod'><p>Get or Test for the Definition of a Method</p></a></li>
<li><a href='#getPackageName'><p>The Name associated with a Given Package</p></a></li>
<li><a href='#hasArg'><p>Look for an Argument in the Call</p></a></li>
<li><a href='#implicitGeneric'><p>Manage Implicit Versions of Generic Functions</p></a></li>
<li><a href='#inheritedSlotNames'><p>Names of Slots Inherited From a Super Class</p></a></li>
<li><a href='#initialize-methods'><p>Methods to Initialize New Objects from a Class</p></a></li>
<li><a href='#Introduction'><p>Basic use of S4 Methods and Classes</p></a></li>
<li><a href='#is'><p>Is an Object from a Class?</p></a></li>
<li><a href='#isSealedMethod'><p> Check for a Sealed Method or Class</p></a></li>
<li><a href='#language-class'><p>Classes to Represent Unevaluated Language Objects</p></a></li>
<li><a href='#languageEl'><p>Elements of Language Objects</p></a></li>
<li><a href='#LinearMethodsList-class'><p>Class <code>"LinearMethodsList"</code></p></a></li>
<li><a href='#LocalReferenceClasses'><p>Localized Objects based on Reference Classes</p></a></li>
<li><a href='#makeClassRepresentation'><p>Create a Class Definition</p></a></li>
<li><a href='#method.skeleton'><p>Create a Skeleton File for a New Method</p></a></li>
<li><a href='#MethodDefinition-class'><p>Classes to Represent Method Definitions</p></a></li>
<li><a href='#Methods'><p>S4 Class Documentation</p></a></li>
<li><a href='#Methods_Details'><p>General Information on Methods</p></a></li>
<li><a href='#Methods_for_Nongenerics'><p>Methods for Non-Generic Functions in Other Packages</p></a></li>
<li><a href='#Methods_for_S3'><p>Methods For S3 and S4 Dispatch</p></a></li>
<li><a href='#methods-defunct'><p>Defunct Functions in Package <span class="pkg">methods</span></p></a></li>
<li><a href='#methods-deprecated'><p>Deprecated Functions in Package <span class="pkg">methods</span></p></a></li>
<li><a href='#methods-package'>
<p>Formal Methods and Classes</p></a></li>
<li><a href='#MethodsList'><p><code>MethodsList</code> Objects</p></a></li>
<li><a href='#MethodsList-class'><p>Class <code>"MethodsList"</code>, Defunct Representation of Methods</p></a></li>
<li><a href='#MethodSupport'><p>Additional (Support) Functions for Methods</p></a></li>
<li><a href='#methodUtilities'><p>Utility Functions for Methods and S-Plus Compatibility</p></a></li>
<li><a href='#MethodWithNext-class'><p>Class <code>"MethodWithNext"</code></p></a></li>
<li><a href='#new'><p> Generate an Object from a Class</p></a></li>
<li><a href='#nonStructure-class'><p>A non-structure S4 Class for basic types</p></a></li>
<li><a href='#ObjectsWithPackage-class'><p>A Vector of Object Names, with associated Package Names</p></a></li>
<li><a href='#promptClass'><p>Generate a Shell for Documentation of a Formal Class</p></a></li>
<li><a href='#promptMethods'><p> Generate a Shell for Documentation of Formal Methods</p></a></li>
<li><a href='#RClassUtils'><p>Utilities for Managing Class Definitions</p></a></li>
<li><a href='#ReferenceClasses'><p>Objects With Fields Treated by Reference (<abbr>OOP</abbr>-style)</p></a></li>
<li><a href='#removeMethod'><p> Remove a Method</p></a></li>
<li><a href='#representation'><p> Construct a Representation or a Prototype for a Class Definition</p></a></li>
<li><a href='#RMethodUtils'><p>Method Utilities</p></a></li>
<li><a href='#S3Part'><p> S4 Classes that Contain S3 Classes</p></a></li>
<li><a href='#S4groupGeneric'><p>S4 Group Generic Functions</p></a></li>
<li><a href='#SClassExtension-class'><p>Class to Represent Inheritance (Extension) Relations</p></a></li>
<li><a href='#selectSuperClasses'><p>Super Classes (of Specific Kinds) of a Class</p></a></li>
<li><a href='#setAs'><p>Methods for Coercing an Object to a Class</p></a></li>
<li><a href='#setClass'><p>Create a Class Definition</p></a></li>
<li><a href='#setClassUnion'><p>Classes Defined as the Union of Other Classes</p></a></li>
<li><a href='#setGeneric'><p>Create a Generic Version of a Function</p></a></li>
<li><a href='#setGroupGeneric'><p>Create a Group Generic Version of a Function</p></a></li>
<li><a href='#setIs'><p>Specify a Superclass Explicitly</p></a></li>
<li><a href='#setLoadActions'>
<p>Set Actions For Package Loading</p></a></li>
<li><a href='#setMethod'><p> Create and Save a Method</p></a></li>
<li><a href='#setOldClass'><p>Register Old-Style (S3) Classes and Inheritance</p></a></li>
<li><a href='#show'><p>Show an Object</p></a></li>
<li><a href='#showMethods'><p>Show all the methods for the specified function(s) or class</p></a></li>
<li><a href='#signature-class'><p>Class <code>"signature"</code> For Method Definitions</p></a></li>
<li><a href='#slot'><p>The Slots in an Object from a Formal Class</p></a></li>
<li><a href='#StructureClasses'><p>Classes Corresponding to Basic Structures</p></a></li>
<li><a href='#substituteDirect'><p><code>SubstituteDirect</code></p></a></li>
<li><a href='#testInheritedMethods'>
<p>Test for and Report about  Selection of Inherited Methods</p></a></li>
<li><a href='#TraceClasses'><p>Classes Used Internally to Control Tracing</p></a></li>
<li><a href='#validObject'><p> Test the Validity of an Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.5.0</td>
</tr>
<tr>
<td>Priority:</td>
<td>base</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats</td>
</tr>
<tr>
<td>Title:</td>
<td>Formal Methods and Classes</td>
</tr>
<tr>
<td>Author:</td>
<td>R Core Team</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R Core Team &lt;do-use-Contact-address@r-project.org&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>R-help mailing list &lt;r-help@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Formally defined methods and classes for R objects,
  plus other programming tools, as described in the reference.</td>
</tr>
<tr>
<td>References:</td>
<td>John M. Chambers (2008) ``Software for Data Analysis:
Programming with R''; Springer NY.</td>
</tr>
<tr>
<td>License:</td>
<td>Part of R 4.5.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>codetools</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.5.0; x86_64-apple-darwin22.2.0; 2024-03-31 05:05:34 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='.BasicFunsList'>List of Builtin and Special Functions</h2><span id='topic+.BasicFunsList'></span>

<h3>Description</h3>

<p>A named list providing instructions for turning builtin and special
functions into generic functions.
</p>
<p>Functions in R that are defined as <code>.Primitive(&lt;name&gt;)</code> are not
suitable for formal methods, because they lack the basic reflectance
property.  You can't find the argument list for these functions by
examining the function object itself.
</p>
<p>Future versions of R may fix this by attaching a formal argument list
to the corresponding function.  While generally the names of arguments
are not checked by the internal code implementing the function, the
number of arguments frequently is.
</p>
<p>In any case, some definition of a formal argument list is needed if
users are to define methods for these functions.  In particular, if
methods are to be merged from multiple packages, the different sets
of methods need to agree on the formal arguments.
</p>
<p>In the absence of reflectance, this list provides the relevant
information  via a dummy function associated with each of the known
specials for which methods are allowed.
</p>
<p>At the same, the list flags those specials for which methods are
meaningless (e.g., <code>for</code>) or just a very bad idea (e.g.,
<code>.Primitive</code>).
</p>
<p>A generic function created via <code><a href="#topic+setMethod">setMethod</a></code>, for
example, for one of these special functions will have the argument
list from <code>.BasicFunsList</code>.  If no entry exists, the argument
list <code>(x, ...)</code>  is assumed.
</p>

<hr>
<h2 id='as'>Force an Object to Belong to a Class</h2><span id='topic+as'></span><span id='topic+as+3C-'></span>

<h3>Description</h3>

<p>Coerce an object to a given class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as(object, Class, strict=TRUE, ext)

as(object, Class) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as_+3A_class">Class</code></td>
<td>
<p>the name of the class to which <code>object</code> should be
coerced. </p>
</td></tr>
<tr><td><code id="as_+3A_strict">strict</code></td>
<td>
<p>logical flag.  If <code>TRUE</code>, the returned object
must be strictly from the target class (unless that class is a
virtual class, in which case the object will be from the closest
actual class, in particular the original object, if that class extends the
virtual class directly).
</p>
<p>If <code>strict = FALSE</code>, any simple extension of the target class
will be returned, without further change.  A simple extension is,
roughly, one that just adds slots to an existing class.</p>
</td></tr>
<tr><td><code id="as_+3A_value">value</code></td>
<td>
<p>The value to use to modify <code>object</code> (see the
discussion below).  You should supply an object with class
<code>Class</code>; some coercion is done, but you're unwise to rely on
it.</p>
</td></tr>
<tr><td><code id="as_+3A_ext">ext</code></td>
<td>
<p>an optional object
defining how <code>Class</code> is extended by the class of the
object (as returned by <code><a href="#topic+possibleExtends">possibleExtends</a></code>).
This argument is used internally;
do not use it directly.
</p>
</td></tr>
</table>


<h3>Description</h3>

<p><code>as(object)</code>
returns the version of this object coerced to be the given
<code>Class</code>.  When used in the replacement form on the left of
an assignment, the portion of the object corresponding to
<code>Class</code> is replaced by <code>value</code>.
</p>
<p>The operation of <code>as()</code> in either form depends on the
definition of coerce methods.  Methods are defined automatically
when the two classes are related by inheritance; that is, when
one of the classes is a subclass of the other.
</p>
<p>Coerce methods are also predefined for basic classes (including all
the types of vectors, functions and a few others).
</p>
<p>Beyond these two sources of methods, further methods are defined
by calls to the <code><a href="#topic+setAs">setAs</a></code> function.  See that
documentation also for details of how coerce methods work. Use
<code>showMethods(coerce)</code> for a list of all currently defined methods, as in the
example below.
</p>


<h3>Basic Coercion Methods</h3>

<p>Methods are pre-defined for coercing any object to one of the basic
datatypes.  For example, <code>as(x, "numeric")</code> uses the existing
<code>as.numeric</code> function.  These and all other existing methods
can be listed as shown in the example.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p>If you think of using <code>try(as(x, cl))</code>, consider
<code><a href="#topic+canCoerce">canCoerce</a>(x, cl)</code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Show all the existing methods for as()
showMethods("coerce")

</code></pre>

<hr>
<h2 id='BasicClasses'>Classes Corresponding to Basic Data Types </h2><span id='topic+character-class'></span><span id='topic+complex-class'></span><span id='topic+double-class'></span><span id='topic+expression-class'></span><span id='topic+externalptr-class'></span><span id='topic+integer-class'></span><span id='topic+list-class'></span><span id='topic+logical-class'></span><span id='topic+numeric-class'></span><span id='topic+raw-class'></span><span id='topic+single-class'></span><span id='topic+vector-class'></span><span id='topic+NULL-class'></span><span id='topic+builtin-class'></span><span id='topic+special-class'></span><span id='topic+function-class'></span><span id='topic+ANY-class'></span><span id='topic+VIRTUAL-class'></span><span id='topic+missing-class'></span><span id='topic+S4-class'></span><span id='topic+namedList-class'></span>

<h3>Description</h3>

<p>Formal classes exist corresponding to the basic R object types, allowing
these types to be used in method signatures, as slots in class
definitions, and to be extended by new classes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>### The following are all basic vector classes.
### They can appear as class names in method signatures,
### in calls to as(), is(), and new().
"character"
"complex"
"double"
"expression"
"integer"
"list"
"logical"
"numeric"
"single"
"raw"

### the class
"vector"
### is a virtual class, extended by all the above

### the class
"S4"
### is an object type for S4 objects that do not extend
### any of the basic vector classes.  It is a virtual class.

### The following are additional basic classes
"NULL"     #  NULL objects
"function" #  function objects, including primitives
"externalptr" # raw external pointers for use in C code

"ANY"  # virtual classes used by the methods package itself
"VIRTUAL"
"missing"

"namedList" # the alternative to "list" that preserves
            # the names attribute
</code></pre>


<h3>Objects from the Classes</h3>

<p>If a class is not virtual (see section in <code><a href="#topic+Classes_Details">Classes_Details</a></code>),
objects can be created by calls of the form <code>new(Class, ...)</code>,
where <code>Class</code> is the quoted class name, and the remaining
arguments if any are objects to be interpreted as vectors of this
class.  Multiple arguments will be concatenated.
</p>
<p>The class <code>"expression"</code> is slightly odd, in that the ...
arguments will <em>not</em> be evaluated; therefore, don't enclose them
in a call to <code>quote()</code>.
</p>
<p>Note that class <code>"list"</code> is a pure vector.  Although lists with
names go back to the earliest versions of S, they are an extension
of the vector concept in that they have an attribute (which can now
be a slot) and which is either <code>NULL</code> or a character vector of
the same length as the vector.  If you want to guarantee that list
names are preserved, use class <code>"namedList"</code>, rather than
<code>"list"</code>.  Objects from this class must have a names attribute,
corresponding to slot <code>"names"</code>,
of type <code>"character"</code>.  Internally, R treats names for
lists  specially, which makes it impractical to have the corresponding slot in
class <code>"namedList"</code> be a union of character names and <code>NULL</code>.
</p>


<h3>Classes and Types</h3>

<p>The basic classes include classes for the basic R types.  Note that
objects of these types will not usually be S4 objects
(<code><a href="base.html#topic+isS4">isS4</a></code> will return <code>FALSE</code>), although objects from
classes that contain the basic class will be S4 objects, still with
the same type.  The type as
returned by <code><a href="base.html#topic+typeof">typeof</a></code> will sometimes differ from the class,
either just from a choice of terminology (type <code>"symbol"</code> and
class <code>"name"</code>, for example) or because there is not a one-to-one
correspondence between class and type (most of the classes that
inherit from class <code>"language"</code> have type <code>"language"</code>, for example).
</p>


<h3>Extends</h3>

<p>The vector classes extend <code>"vector"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p>Methods are defined to coerce arbitrary objects to
the vector classes, by calling the corresponding basic function, for
example, <code>as(x, "numeric")</code> calls <code>as.numeric(x)</code>. </p>
</dd>
</dl>


<hr>
<h2 id='callGeneric'>Call the Current Generic Function from a Method</h2><span id='topic+callGeneric'></span>

<h3>Description</h3>

<p>A call to <code>callGeneric</code> can only appear inside a method
definition.  It then results in a call to the current generic
function.  The value of that call is the value of <code>callGeneric</code>.
While it can be called from any method, it is useful and typically
used in methods for group generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callGeneric(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callGeneric_+3A_...">...</code></td>
<td>

<p>Optionally, the arguments to the function in its next call.
</p>
<p>If no arguments are included in the call to <code>callGeneric</code>, the
effect is to call the function with the current arguments.
See the detailed description for what this really means.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name and package of the current generic function is stored in the
environment of the method definition object.  This name is looked up
and the corresponding function called.
</p>
<p>The statement that passing no arguments to <code>callGeneric</code> causes
the generic  function to be called with the current arguments is
more precisely as follows.  Arguments that were missing in the current
call are still missing (remember that <code>"missing"</code> is a valid
class in a method signature).  For a formal argument, say <code>x</code>, that
appears in the original call, there is a corresponding argument in the
generated call equivalent to <code>x = x</code>.  In effect, this
means that the generic function sees the same actual arguments, but
arguments are evaluated only once.
</p>
<p>Using <code>callGeneric</code> with no arguments is prone to creating
infinite recursion, unless one of the arguments in the signature has
been modified in the current method so that a different method is selected.
</p>


<h3>Value</h3>

<p>The value returned by the new call.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer. (Section 10.4 for some details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GroupGenericFunctions">GroupGenericFunctions</a></code> for other information
about group generic functions; <a href="#topic+Methods_Details">Methods_Details</a> for the general behavior
of method dispatch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the method for group generic function Ops
## for signature( e1="structure", e2="vector")
function (e1, e2)
{
    value &lt;- callGeneric(e1@.Data, e2)
    if (length(value) == length(e1)) {
        e1@.Data &lt;- value
        e1
    }
    else value
}

## For more examples
## Not run: 
showMethods("Ops", includeDefs = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='callNextMethod'>Call an Inherited Method</h2><span id='topic+callNextMethod'></span>

<h3>Description</h3>

<p>A call to <code>callNextMethod</code> can only appear inside a method
definition.  It then results in a call to the first inherited method
after the current method, with the arguments to the current method
passed down to the next method.  The value of that method call is the
value of <code>callNextMethod</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callNextMethod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callNextMethod_+3A_...">...</code></td>
<td>

<p>Optionally, the arguments to the function in its next call
(but note that the dispatch is as in the detailed description below;
the arguments have no effect on selecting the next method.)
</p>
<p>If no arguments are included in the call to <code>callNextMethod</code>, the
effect is to call the method with the current arguments.
See the detailed description for what this really means.
</p>
<p>Calling with no arguments is often the natural way to use
<code>callNextMethod</code>; see the examples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;next&rsquo; method (i.e., the first inherited method) is defined
to be that method which <em>would</em> have been called if the current
method did not exist. This is more-or-less literally what happens: The
current method (to be precise, the method with signature given by the
<code>defined</code> slot of the method from which <code>callNextMethod</code> is
called) is deleted from a copy of the methods for the current generic,
and <code><a href="#topic+selectMethod">selectMethod</a></code> is called to find the next method (the
result is cached in the method object where the call occurred, so the search typically
happens only once per session per combination of argument classes).
</p>
<p>The next method is defined from the <em>signature</em> of the current
method, not from the actual classes of the arguments.
In particular, modifying any of the arguments has no effect on the
selection.
As a result, the selected next method can be called with invalid
arguments if the calling function assigns objects of a different
class before the <code>callNextMethod()</code> call.
Be careful of any assignments to such arguments.
</p>
<p>It is possible for the selection of the next method to be ambiguous,
even though the original set of methods was consistent.
See the section &ldquo;Ambiguous Selection&rdquo;.
</p>
<p>The statement that the method is called with the current arguments is
more precisely as follows.  Arguments that were missing in the current
call are still missing (remember that <code>"missing"</code> is a valid
class in a method signature).  For a formal argument, say <code>x</code>, that
appears in the original call, there is a corresponding argument in the
next method call equivalent to <code>x = x</code>.  In effect, this
means that the next method sees the same actual arguments, but
arguments are evaluated only once.
</p>


<h3>Value</h3>

<p>The value returned by the selected method.
</p>


<h3>Ambiguous Selection</h3>

<p>There are two fairly common situations in which the choice of a next
method is ambiguous, even when the original set of methods uniquely
defines all method selection unambiguously.
In these situations, <code>callNextMethod()</code> should be replaced,
either by a call to a specific function or by recalling the generic
with different arguments.
</p>
<p>The most likely situation arises with methods for binary operators,
typically through one of the group generic functions.
See the example for class <code>"rnum"</code> below.
Examples of this sort usually require three methods: two for the case
that the first or the second argument comes from the class, and a
third for the case that both arguments come from the class.
If that last method uses <code>callNextMethod</code>, the other two methods
are equally valid.  The ambiguity is exactly the same that required
defining the two-argument method in the first place.
</p>
<p>In fact, the two possibilities are equally valid conceptually as well
as formally.
As in the example below, the logic of the application usually requires
selecting a computation explicitly or else calling the generic
function with modified arguments to select an appropriate method.
</p>
<p>The other likely source of ambiguity arises from a class that inherits
directly from more than one other class (a &ldquo;mixin&rdquo; in standard
terminology).
If the generic has methods corresponding to both superclasses, a
method for the current class is again needed to resolve ambiguity.
Using <code>callNextMethod</code> will again reimpose the ambiguity.
Again, some explicit choice has to be made in the calling method
instead.
</p>
<p>These ambiguities are not the result of bad design, but they do
require workarounds.
Other ambiguities usually reflect inconsistencies in the tree of
inheritances, such as a class appearing in more than one place among
the superclasses.
Such cases should be rare, but with the independent definition of
classes in multiple packages, they can't be ruled out.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callGeneric">callGeneric</a></code> to call the generic function with the
current dispatch rules (typically for a group generic function);
<a href="#topic+Methods_Details">Methods_Details</a> for the general behavior of method dispatch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## callNextMethod() used for the Math, Math2 group generic functions

## A class to automatically round numeric results to "d" digits

rnum &lt;- setClass("rnum", slots = c(d = "integer"), contains = "numeric")

## Math functions operate on the rounded numbers, return a plain
## vector.  The next method will always be the default, usually a primitive.
setMethod("Math", "rnum",
          function(x)
              callNextMethod(round(as.numeric(x), x@d)))
setMethod("Math2", "rnum",
          function(x, digits)
              callNextMethod(round(as.numeric(x), x@d), digits))

## Examples of callNextMethod with two arguments in the signature.

## For arithmetic and one rnum with anything, callNextMethod with no arguments
## round the full accuracy result, and return as plain vector
setMethod("Arith", c(e1 ="rnum"),
          function(e1, e2)
              as.numeric(round(callNextMethod(), e1@d)))
setMethod("Arith", c(e2 ="rnum"),
          function(e1, e2)
              as.numeric(round(callNextMethod(), e2@d)))

## A method for BOTH arguments from "rnum" would be ambiguous
## for callNextMethod(): the two methods above are equally valid.
## The method chooses the smaller number of digits,
## and then calls the generic function, postponing the method selection
## until it's not ambiguous.
setMethod("Arith", c(e1 ="rnum", e2 = "rnum"),
          function(e1, e2) {
              if(e1@d &lt;= e2@d)
                  callGeneric(e1, as.numeric(e2))
              else
                  callGeneric(as.numeric(e1), e2)
          })

## For comparisons, callNextMethod with the rounded arguments
setMethod("Compare", c(e1 = "rnum"),
          function(e1, e2)
              callNextMethod(round(e1, e1@d), round(e2, e1@d)))
setMethod("Compare", c(e2 = "rnum"),
          function(e1, e2)
              callNextMethod(round(e1, e2@d), round(e2, e2@d)))

## similarly to the Arith case, the method for two "rnum" objects
## can not unambiguously use callNextMethod().  Instead, we rely on
## The rnum() method inhertited from Math2 to return plain vectors.
setMethod("Compare", c(e1 ="rnum", e2 = "rnum"),
          function(e1, e2) {
              d &lt;- min(e1@d, e2@d)
              callGeneric(round(e1, d), round(e2, d))
          })




set.seed(867)

x1 &lt;- rnum(10*runif(5), d=1L)
x2 &lt;- rnum(10*runif(5), d=2L)

x1+1
x2*2
x1-x2

## Simple examples to illustrate callNextMethod with and without arguments
B0 &lt;- setClass("B0", slots = c(s0 = "numeric"))

## and a function to illustrate callNextMethod

f &lt;- function(x, text = "default") {
    str(x) # print a summary
    paste(text, ":", class(x))
}

setGeneric("f")
setMethod("f", "B0", function(x, text = "B0") {
    cat("B0 method called with s0 =", x@s0, "\n")
    callNextMethod()
})

b0 &lt;- B0(s0 = 1)

## call f() with 2 arguments: callNextMethod passes both to the default method
f(b0, "first test")

## call f() with 1 argument:  the default "B0" is not passed by callNextMethod
f(b0)

## Now, a class that extends B0, with no methods for f()
B1 &lt;- setClass("B1", slots = c(s1 = "character"), contains = "B0")
b1 &lt;- B1(s0 = 2, s1 = "Testing B1")

## the two cases work as before, by inheriting the "B0" method

f(b1, b1@s1)

f(b1)

B2 &lt;- setClass("B2", contains = "B1")

## And, a method for "B2" that calls with explicit arguments.
## Note that the method selection in callNextMethod
## uses the class of the *argument* to consistently select the "B0" method

setMethod("f", "B2", function(x, text = "B1 method") {
    y &lt;- B1(s0 = -x@s0, s1 ="Modified x")
    callNextMethod(y, text)
})

b2 &lt;- B2(s1 = "Testing B2", s0 = 10)

f(b2, b2@s1)

f(b2)


## Be careful:  the argument passed must be legal for the method selected
## Although the argument here is numeric, it's still the "B0" method that's called
setMethod("f", "B2", function(x, text = "B1 method") {
    callNextMethod(x@s0, text)
})

##  Now the call will cause an error:

tryCatch(f(b2), error = function(e) cat(e$message,"\n"))




</code></pre>

<hr>
<h2 id='canCoerce'>Can an Object be Coerced to a Certain S4 Class?</h2><span id='topic+canCoerce'></span>

<h3>Description</h3>

<p>Test if an object can be coerced to a given S4 class.
Maybe useful inside <code>if()</code> to ensure that calling
<code>as(object, Class)</code> will find a method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canCoerce(object, Class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canCoerce_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object, typically of a formal S4 class.</p>
</td></tr>
<tr><td><code id="canCoerce_+3A_class">Class</code></td>
<td>
<p>an S4 class (see <code><a href="#topic+isClass">isClass</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar logical, <code>TRUE</code> if there is a <code>coerce</code> method
(as defined by e.g. <code><a href="#topic+setAs">setAs</a></code>) for the signature
<code>(from = class(object), to = Class)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as">as</a></code>, <code><a href="#topic+setAs">setAs</a></code>,
<code><a href="#topic+selectMethod">selectMethod</a></code>, <code><a href="#topic+setClass">setClass</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(pi, 2,3)
canCoerce(m, "numeric") # TRUE
canCoerce(m, "array")   # TRUE
</code></pre>

<hr>
<h2 id='cbind2'>Combine two Objects by Columns or Rows</h2><span id='topic+cbind2'></span><span id='topic+rbind2'></span><span id='topic+cbind2-methods'></span><span id='topic+cbind2+2CANY+2CANY-method'></span><span id='topic+cbind2+2CANY+2Cmissing-method'></span><span id='topic+rbind2-methods'></span><span id='topic+rbind2+2CANY+2CANY-method'></span><span id='topic+rbind2+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Combine two matrix-like <span class="rlang"><b>R</b></span> objects by columns (<code>cbind2</code>)
or rows (<code>rbind2</code>).  These are (S4) generic functions with default
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind2(x, y, ...)
rbind2(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind2_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object, typically matrix-like.</p>
</td></tr>
<tr><td><code id="cbind2_+3A_y">y</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object, typically similar to <code>x</code>, or missing
completely.</p>
</td></tr>
<tr><td><code id="cbind2_+3A_...">...</code></td>
<td>
<p>optional arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main use of <code>cbind2</code> (<code>rbind2</code>) is to be called
recursively by <code><a href="base.html#topic+cbind">cbind</a>()</code> (<code>rbind()</code>) when both of
these requirements are met:
</p>

<ul>
<li><p> There is at least one argument that is an S4 object, and
</p>
</li>
<li><p> S3 dispatch fails (see the Dispatch section under <a href="base.html#topic+cbind">cbind</a>).
</p>
</li></ul>

<p>The methods on <code>cbind2</code> and <code>rbind2</code> effectively define the
type promotion policy when combining a heterogeneous set of
arguments.  The homogeneous case, where all objects derive from some S4
class, can be handled via S4 dispatch on the <code>...</code> argument via
an externally defined S4 <code>cbind</code> (<code>rbind</code>) generic.
</p>
<p>Since (for legacy reasons) S3 dispatch is attempted first, it is
generally a good idea to additionally define an S3 method on
<code>cbind</code> (<code>rbind</code>) for the S4 class.  The S3 method will be
invoked when the arguments include objects of the S4 class, along with
arguments of classes for which no S3 method exists.  Also, in case there
is an argument that selects a different S3 method (like the one for
<code>data.frame</code>), this S3 method serves to introduce an ambiguity in
dispatch that triggers the recursive fallback to <code>cbind2</code>
(<code>rbind2</code>). Otherwise, the other S3 method would be called, which
may not be appropriate.
</p>


<h3>Value</h3>

<p>A matrix (or matrix like object) combining the columns (or rows) of
<code>x</code> and <code>y</code>.  Note that methods must construct
<code><a href="base.html#topic+colnames">colnames</a></code> and <code><a href="base.html#topic+rownames">rownames</a></code> from the
corresponding column and row names of <code>x</code> and <code>y</code> (but not
from deparsing argument names such as in <code><a href="base.html#topic+cbind">cbind</a>(...,
    deparse.level = d)</code> for <code class="reqn">d \ge 1</code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", y = "ANY")</code></dt><dd><p>the default method
using <span class="rlang"><b>R</b></span>'s internal code.</p>
</dd>
<dt><code>signature(x = "ANY", y = "missing")</code></dt><dd><p>the default method
for one argument using <span class="rlang"><b>R</b></span>'s internal code.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="base.html#topic+rbind">rbind</a></code>;
further, <code><a href="Matrix.html#topic+cBind">cBind</a></code>, <code><a href="Matrix.html#topic+cBind">rBind</a></code> in
the <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cbind2(1:3, 4)
m &lt;- matrix(3:8, 2,3, dimnames=list(c("a","b"), LETTERS[1:3]))
cbind2(1:2, m) # keeps dimnames from m

## rbind() and cbind() now make use of rbind2()/cbind2() methods
setClass("Num", contains="numeric")
setMethod("cbind2", c("Num", "missing"),
          function(x,y, ...) { cat("Num-miss--meth\n"); as.matrix(x)})
setMethod("cbind2", c("Num","ANY"), function(x,y, ...) {
    cat("Num-A.--method\n") ; cbind(getDataPart(x), y, ...) })
setMethod("cbind2", c("ANY","Num"), function(x,y, ...) {
    cat("A.-Num--method\n") ; cbind(x, getDataPart(y), ...) })

a &lt;- new("Num", 1:3)
trace("cbind2")
cbind(a)
cbind(a, four=4, 7:9)# calling cbind2() twice

cbind(m,a, ch=c("D","E"), a*3)
cbind(1,a, m) # ok with a warning
untrace("cbind2")
</code></pre>

<hr>
<h2 id='Classes'>S4 Class Documentation</h2><span id='topic+Classes'></span>

<h3>Description</h3>

<p>You have navigated to an old link to documentation of S4 classes.
</p>
<p>For basic use of classes and methods, see <a href="#topic+Introduction">Introduction</a>; to
create new class definitions, see <code><a href="#topic+setClass">setClass</a></code>; for
technical details on S4 classes, see <a href="#topic+Classes_Details">Classes_Details</a>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>

<hr>
<h2 id='Classes_Details'>Class Definitions</h2><span id='topic+Classes_Details'></span><span id='topic+__ClassMetaData'></span><span id='topic+.environment-class'></span><span id='topic+.externalptr-class'></span><span id='topic+.name-class'></span><span id='topic+.NULL-class'></span>

<h3>Description</h3>

<p>Class definitions are objects that contain the formal definition of a
class of <span class="rlang"><b>R</b></span> objects, usually referred to as an S4 class, to
distinguish them from the informal S3 classes.
This document gives an overview of S4 classes; for
details of the class representation objects, see help for the class
<code><a href="#topic+classRepresentation-class">classRepresentation</a></code>.
</p>


<h3>Metadata Information</h3>

<p>When a class is defined, an object is stored that contains the
information about that class.  The object, known as the
<em>metadata</em> defining the class, is not stored under the name of
the class (to allow programmers to write generating functions of
that name), but under a specially constructed name.
To examine the class definition, call <code><a href="#topic+getClass">getClass</a></code>.  The
information in the metadata object includes:
</p>

<dl>
<dt>Slots:</dt><dd>
<p>The data contained in an object from an S4 class is defined by
the <em>slots</em> in the class definition.
</p>
<p>Each slot in an object is a component of the object;
like components (that is, elements) of a
list, these may be extracted and set, using the
function <code><a href="#topic+slot">slot</a>()</code> or more often the operator
<code>"<a href="base.html#topic++40">@</a>"</code>.  However, they
differ from list components in important ways.
First, slots can only be referred to by name, not by position,
and there is no partial matching of names as with list elements.
</p>
<p>All the objects from a particular class have the same set of slot
names; specifically, the slot names that are contained in the
class definition.  Each slot in each object always is an object
of  the
class specified for this slot in the definition of the current class.
The word &ldquo;is&rdquo; corresponds to the <span class="rlang"><b>R</b></span> function of the same
name (<code><a href="#topic+is">is</a></code>), meaning that the class of the object in
the slot must be the same as the class specified in the
definition, or some class that extends the one in the
definition (a <em>subclass</em>).
</p>
<p>A special slot name, <code>.Data</code>, stands for the
&lsquo;data part&rsquo; of the object.  An object from a class with a
data part is defined by specifying that the class contains one
of the <span class="rlang"><b>R</b></span> object types or one of the special pseudo-classes,
<code>matrix</code> or <code>array</code>, usually because the definition of
the class, or of one of its superclasses, has included the type
or pseudo-class in its <code>contains</code> argument.  A second
special slot name, <code>.xData</code>, is used to enable inheritance
from abnormal types such as <code>"environment"</code>
See the section on inheriting from non-S4 classes
for details on the representation and
for the behavior of S3 methods with objects from these classes.
</p>
<p>Some slot names correspond to attributes used in old-style S3
objects and in <span class="rlang"><b>R</b></span> objects without an explicit class, for
example, the <code>names</code> attribute.  If you define a class for
which that attribute will be set, such as a subclass of named
vectors, you should include <code>"names"</code> as a slot.  See the
definition of class <code>"namedList"</code> for an example.  Using the
<code>names()</code> assignment to set such names will generate a
warning if there is no names slot and an error if the object in
question is not a vector type.  A slot called <code>"names"</code> can
be used anywhere, but only if it is assigned as a slot, not via
the default <code>names()</code> assignment.
</p>
</dd>
<dt>Superclasses:</dt><dd>
<p>The definition of a class includes the <em>superclasses</em> &mdash;the
classes that this class extends.  A
class <code>Fancy</code>, say, extends a class <code>Simple</code> if an
object from the <code>Fancy</code> class has all the capabilities of
the <code>Simple</code> class (and probably some more as well).  In
particular, and very usefully, any method defined to work for a
<code>Simple</code> object can be applied to a <code>Fancy</code> object as
well.
</p>
<p>This relationship is expressed equivalently by saying that
<code>Simple</code> is a superclass of <code>Fancy</code>, or that
<code>Fancy</code> is a subclass of <code>Simple</code>.
</p>
<p>The direct superclasses of a class are those superclasses
explicitly defined.   Direct superclasses can be defined in
three ways.  Most commonly, the superclasses are listed in the
<code>contains=</code> argument in the call to <code><a href="#topic+setClass">setClass</a></code>
that creates the subclass.   In this case the subclass will
contain all the slots of the superclass, and the relation
between the class is called <em>simple</em>, as it in fact is.
Superclasses can also be defined
explicitly by a call to <code><a href="#topic+setIs">setIs</a></code>; in this case, the
relation requires methods to be specified to go from subclass to
superclass.   Thirdly, a class union is a superclass of all the
members of the union.  In this case too the relation is simple,
but notice that the relation is defined when the superclass is
created, not when the subclass is created as with the
<code>contains=</code> mechanism.
</p>
<p>The definition of a superclass will also potentially contain
its own direct superclasses.  These are considered (and shown) as
superclasses at distance 2 from the original class; their direct
superclasses are at distance 3, and so on.  All these are
legitimate superclasses for purposes such as method selection.
</p>
<p>When superclasses are defined  by including the names of
superclasses in the <code>contains=</code> argument to
<code><a href="#topic+setClass">setClass</a></code>, an object from the class will have all the
slots defined for its own class <em>and</em> all the slots defined
for all its superclasses as well.
</p>
<p>The information about the relation between a class and a
particular superclass is encoded as an object of class
<code><a href="#topic+SClassExtension-class">SClassExtension</a></code>.  A list of such objects for
the superclasses (and sometimes for the subclasses) is included in
the metadata object defining the class.  If you need to compute
with these objects (for example, to compare the distances), call
the function <code><a href="#topic+extends">extends</a></code> with argument <code>fullInfo=TRUE</code>.
</p>
</dd>
<dt>Prototype:</dt><dd>
<p>The objects from a class created by a call to
<code><a href="#topic+new">new</a></code>
are defined by the <em>prototype</em> object for the class and by
additional arguments in the call to <code><a href="#topic+new">new</a></code>, which are
passed to a method for that class for the function
<code><a href="#topic+initialize">initialize</a></code>.
</p>
<p>Each class representation object contains a prototype object
for the class (although for a virtual class the prototype may be
<code>NULL</code>). The prototype object must have values for all the
slots of the class.
By default, these are the prototypes of the corresponding slot
classes.  However, the definition of the class can specify any
valid object for any of the slots.
</p>
</dd>
</dl>



<h3>Basic classes</h3>

<p>There are a number of &lsquo;basic&rsquo; classes, corresponding to the
ordinary kinds of data occurring in <span class="rlang"><b>R</b></span>.  For example,
<code>"numeric"</code> is a class corresponding to numeric vectors.
The other vector basic classes are <code>"logical"</code>, <code>"integer"</code>,
<code>"complex"</code>, <code>"character"</code>,  <code>"raw"</code>, <code>"list"</code>
and <code>"expression"</code>.
The prototypes for
the vector classes are vectors of length 0 of the corresponding
type.  Notice that basic classes are unusual in that the
prototype object is from the class itself.
</p>
<p>In addition to the vector classes there are also basic classes
corresponding to objects in the
language, such as <code>"function"</code> and <code>"call"</code>.
These classes are subclasses of the virtual class <code>"language"</code>.
Finally, there are object types and corresponding basic classes for
&ldquo;abnormal&rdquo; objects, such as <code>"environment"</code> and
<code>"externalptr"</code>.
These objects do not follow the
functional behavior of the language; in particular, they are not
copied and so cannot have attributes or slots defined locally.
</p>
<p>All these classes can be used as slots or as
superclasses for any other class definitions, although they do
not themselves come with an explicit class.  For the abnormal
object types, a special mechanism is used to enable inheritance
as described below.
</p>


<h3>Inheriting from non-S4 Classes</h3>

<p>A class definition can extend classes other than
regular S4 classes, usually by specifying them in the
<code>contains=</code> argument to <code><a href="#topic+setClass">setClass</a></code>.  Three groups
of such classes behave distinctly:
</p>

<ol>
<li>
<p>S3 classes, which must have been registered by a previous call to
<code><a href="#topic+setOldClass">setOldClass</a></code> (you can check that this has been done
by calling <code><a href="#topic+getClass">getClass</a></code>, which should return a class that
extends <a href="#topic+oldClass-class">oldClass</a>);
</p>
</li>
<li>
<p>One of the <span class="rlang"><b>R</b></span> object types, typically a vector type, which then
defines the type of the S4 objects, but also a type such as
<code><a href="base.html#topic+environment">environment</a></code> that can not be used directly as a type
for an S4 object.  See
below.
</p>
</li>
<li>
<p>One of the pseudo-classes <code><a href="#topic+matrix-class">matrix</a></code>
and <code><a href="#topic+array-class">array</a></code>, implying objects with
arbitrary vector types plus the <code>dim</code> and <code>dimnames</code>
attributes.
</p>
</li></ol>

<p>This section describes the approach to combining S4 computations
with older S3 computations by using such classes as superclasses. The
design goal is to allow the S4 class to inherit S3 methods and
default computations in as consistent a form as possible.
</p>
<p>As part of a general effort to make the S4 and S3 code in R more
consistent, when objects from an S4 class are used as the first
argument to a non-default S3 method, either for an S3 generic function
(one that calls <code><a href="base.html#topic+UseMethod">UseMethod</a></code>) or for one of the primitive
functions that dispatches S3 methods, an effort is made to provide a
valid object for that method.  In particular, if the S4 class extends
an S3 class or <code>matrix</code> or <code>array</code>, and there is an S3
method matching one of these classes, the S4 object will be coerced to
a valid S3 object, to the extent that is possible given that there is
no formal definition of an S3 class.
</p>
<p>For example, suppose <code>"myFrame"</code> is an S4 class that includes the
S3 class <code>"data.frame"</code> in the <code>contains=</code> argument to
<code><a href="#topic+setClass">setClass</a></code>.  If an object from this S4 class is passed to
a function, say <code><a href="base.html#topic+as.matrix">as.matrix</a></code>, that has an S3 method for
<code>"data.frame"</code>, the internal code for <code><a href="base.html#topic+UseMethod">UseMethod</a></code>
will convert the object to a data frame; in particular, to an S3
object whose class attribute will be the vector corresponding to the
S3 class (possibly containing multiple class names). Similarly for an
S4 object inheriting from <code>"matrix"</code> or <code>"array"</code>, the S4
object will be converted to a valid S3 matrix or array.
</p>
<p>Note that the conversion is <em>not</em> applied when an S4 object is
passed to the default S3 method.  Some S3 generics attempt to deal
with general objects, including S4 objects.  Also, no transformation
is applied to S4 objects that do not correspond to a selected S3
method; in particular, to objects from a class that does not contain
either an S3 class or one of the basic types.  See <code><a href="base.html#topic+asS4">asS4</a></code>
for the transformation details.
</p>
<p>In addition to explicit S3 generic functions, S3 methods are
defined for a variety of operators and functions implemented as
primitives.  These methods are dispatched by some internal C
code that operates partly through the same code as real S3
generic functions and partly via special considerations (for
example, both arguments to a binary operator are examined when
looking for methods).  The same mechanism for adapting S4
objects to S3 methods has been applied to these computations as
well, with a few exceptions such as generating an error if an S4
object that does not extend an appropriate S3 class or type is
passed to a binary operator.
</p>
<p>The remainder of this section discusses the mechanisms for
inheriting from  basic object types. See <code><a href="#topic+matrix-class">matrix</a></code>
or <code><a href="#topic+array-class">array</a></code>
for inhering from the matrix and array
pseudo-classes, or from time-series.  For the
corresponding details for inheritance
from S3 classes, see <code><a href="#topic+setOldClass">setOldClass</a></code>.
</p>
<p>An object from a class that directly and simply contains one
of the basic object types in <span class="rlang"><b>R</b></span>, has implicitly a corresponding
<code>.Data</code> slot of that type, allowing computations to extract
or replace the data part while leaving other slots
unchanged. If the type is one that can accept attributes and is
duplicated normally, the inheritance also determines the type of the
object; if the class definition has a <code>.Data</code> slot
corresponding to a normal type, the class of the
slot determines the type of the object (that is, the value of
<code><a href="base.html#topic+typeof">typeof</a>(x)</code>).
For such classes,  <code>.Data</code> is a pseudo-slot; that
is, extracting or setting it modifies the non-slot data in the
object.  The functions <code><a href="#topic+getDataPart">getDataPart</a></code> and
<code><a href="#topic+setDataPart">setDataPart</a></code> are a cleaner, but essentially
equivalent way to deal with the data part.
</p>
<p>Extending a basic type this way allows objects to
use old-style code for the corresponding type as well as S4
methods.  Any basic type can be used for <code>.Data</code>, but
a few types are treated differently because they do not behave like ordinary objects;
for example, <code>"NULL"</code>, environments, and external pointers.
Classes extend these types by having a slot, <code>.xData</code>,
itself inherited from an internally defined S4 class.  This
slot actually contains an object of the inherited type, to
protect computations from the reference semantics of the type.
Coercing to the nonstandard object type then requires an
actual computation, rather than the <code>"simple"</code> inclusion
for other types and classes.  The intent is that programmers
will not need to take account of the mechanism, but one
implication is that you should <em>not</em> explicitly use the
type of an S4 object to detect inheritance from an arbitrary
object type.  Use
<code><a href="#topic+is">is</a></code> and similar functions instead.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Methods_Details">Methods_Details</a></code> for analogous discussion of methods,
<code><a href="#topic+setClass">setClass</a></code> for details of specifying class definitions,
<code><a href="#topic+is">is</a></code>,
<code><a href="#topic+as">as</a></code>,
<code><a href="#topic+new">new</a></code>,
<code><a href="#topic+slot">slot</a></code>
</p>

<hr>
<h2 id='classesToAM'>
Compute an Adjacency Matrix for Superclasses of Class Definitions
</h2><span id='topic+classesToAM'></span>

<h3>Description</h3>

<p>Given a vector of class names or a list of class definitions, the
function returns an adjacency matrix of the superclasses of these
classes; that is, a matrix with class names as the row and column
names and with element [i, j] being 1 if the class in column j is a
direct superclass of the class in row i, and 0 otherwise.
</p>
<p>The matrix has the information implied by the <code>contains</code> slot of
the class definitions, but in a form that is often more convenient for
further analysis; for example, an adjacency matrix is used in packages
and other software to construct graph representations of relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classesToAM(classes, includeSubclasses = FALSE,
       abbreviate = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classesToAM_+3A_classes">classes</code></td>
<td>

<p>Either a character vector of class names or a list, whose
elements can be either class names or class definitions.  The
list is convenient, for example, to include the package slot for
the class name. See the examples.
</p>
</td></tr>
<tr><td><code id="classesToAM_+3A_includesubclasses">includeSubclasses</code></td>
<td>

<p>A logical flag; if <code>TRUE</code>, then the matrix will include all
the known subclasses of the specified classes as well as the
superclasses.  The argument can also be a logical vector of the
same length as <code>classes</code>, to include subclasses for some
but not all the classes.
</p>
</td></tr>
<tr><td><code id="classesToAM_+3A_abbreviate">abbreviate</code></td>
<td>

<p>Control of the abbreviation of the row and/or  column labels of
the matrix returned: values 0, 1, 2, or 3 abbreviate neither,
rows, columns or both.  The default, 2, is useful for printing
the matrix, since class names tend to be more than one
character long, making for spread-out printing.  Values of 0
or 3 would be appropriate for making a graph (3 avoids the
tendency of some graph plotting software to produce labels in
minuscule font size).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the classes, the calculation gets all the superclass
names from the class definition, and finds the edges in those classes'
definitions; that is, all the superclasses at distance 1.  The
corresponding elements of the adjacency matrix are set to 1.
</p>
<p>The adjacency matrices for the individual class definitions are
merged.  Note two possible kinds of inconsistency, neither of which
should cause problems except possibly with identically named classes from
different packages.  Edges are computed from each superclass
definition, so that information overrides a possible inference from
extension elements with distance &gt; 1 (and it should).  When
matrices from successive classes in the argument are merged, the
computations do not currently check for inconsistencies&mdash;this is
the area where possible multiple classes with the same name could
cause confusion.  A later revision may include consistency checks.
</p>


<h3>Value</h3>

<p>As described, a matrix with entries 0 or 1, non-zero values
indicating that the class corresponding to the column is a direct
superclass of the class corresponding to the row.  The row and
column names are the class names (without package slot).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extends">extends</a></code> and <a href="#topic+classRepresentation-class">classRepresentation</a> for the underlying information from the class
definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the super- and subclasses of "standardGeneric"
## and "derivedDefaultMethod"
am &lt;- classesToAM(list(class(show), class(getMethod(show))), TRUE)
am

## Not run: 
## the following function depends on the Bioconductor package Rgraphviz
plotInheritance &lt;- function(classes, subclasses = FALSE, ...) {
    if(!require("Rgraphviz", quietly=TRUE))
      stop("Only implemented if Rgraphviz is available")
    mm &lt;- classesToAM(classes, subclasses)
    classes &lt;- rownames(mm); rownames(mm) &lt;- colnames(mm)
    graph &lt;-  new("graphAM", mm, "directed", ...)
    plot(graph)
    cat("Key:\n", paste(abbreviate(classes), " = ", classes, ", ",
        sep = ""),  sep = "", fill = TRUE)
    invisible(graph)
}

## The plot of the class inheritance of the package "graph"
require(graph)
plotInheritance(getClasses("package:graph"))


## End(Not run)
</code></pre>

<hr>
<h2 id='className'>
Class names including the corresponding package
</h2><span id='topic+className'></span><span id='topic+multipleClasses'></span><span id='topic+className-class'></span>

<h3>Description</h3>

<p>The function <code>className()</code> generates a
valid references to a class, including the name of the package
containing the class definition.  The object returned, from class <code>"className"</code>, is the
unambiguous way to refer to a class, for example when calling
<code><a href="#topic+setMethod">setMethod</a></code>, just in case multiple definitions of the
class exist.
</p>
<p>Function
<code>"multipleClasses"</code> returns information about multiple
definitions of classes with the
same name from different packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
className(class, package)

multipleClasses(details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="className_+3A_class">class</code>, <code id="className_+3A_package">package</code></td>
<td>

<p>The character string name of a class and, optionally, of the package
to which it belongs.  If argument <code>package</code> is missing and the
<code>class</code> argument has a package slot, that is used  (in
particular, passing in an object from class <code>"className"</code> returns
itself in this case, but changes the package slot if the second
argument is supplied).
</p>
<p>If there is no package argument or slot, a
definition for the class must exist and will be used to define the
package.  If there are multiple definitions, one will be chosen and a
warning printed giving the other possibilities.
</p>
</td></tr>
<tr><td><code id="className_+3A_details">details</code></td>
<td>

<p>If <code>FALSE</code>, the default, <code>multipleClasses()</code> returns a
character vector of those classes currently known with multiple
definitions.
</p>
<p>If <code>TRUE</code>, a named list of those class definitions is returned.
Each element of the list is itself a list of the corresponding class
definitions, with the package names as the names of the list.  Note
that identical class definitions will not be considered
&ldquo;multiple&rdquo; definitions (see the discussion of the details below).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The table of class definitions used internally can maintain multiple
definitions for classes with the same name but coming from different
packages.
If identical class definitions are encountered, only one class
definition is kept; this occurs most often with S3 classes that have
been specified in calls to <code><a href="#topic+setOldClass">setOldClass</a></code>.  For true
classes, multiple class definitions are unavoidable in general if two
packages happen to have used the same name, independently.
</p>
<p>Overriding a class definition in another package with the same name deliberately is usually a bad
idea.
Although <span class="rlang"><b>R</b></span> attempts to keep and use the two definitions (as of
version 2.14.0), ambiguities are always possible.  It is more
sensible to define a new class that extends an existing class but has
a different name.
</p>


<h3>Value</h3>

<p>A call to <code>className()</code> returns an object from class
<code>"className"</code>.
</p>
<p>A call to <code>multipleClasses()</code> returns either a character
vector or a named list of class definitions.  In either case, testing
the length of the returned value for being greater than <code>0</code> is a
check for the existence of multiply defined classes.
</p>


<h3>Objects from the Class</h3>

<p>The class <code>"className"</code> extends <code>"character"</code> and has a slot
<code>"package"</code>, also of class <code>"character"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
className("vector") # will be found, from package "methods"
className("vector", "magic") # OK, even though the class doesn't exist


className("An unknown class") # Will cause an error

## End(Not run)
</code></pre>

<hr>
<h2 id='classRepresentation-class'>Class Objects </h2><span id='topic+classRepresentation-class'></span>

<h3>Description</h3>

<p>  These are the objects that hold the definition of
classes of objects.  They are constructed and stored as meta-data by
calls to the function <code><a href="#topic+setClass">setClass</a></code>.  Don't manipulate them
directly, except perhaps to look at individual slots. </p>


<h3>Details</h3>

<p>Class definitions are stored as metadata in various packages.
Additional metadata supplies information on inheritance (the result of
calls to <code><a href="#topic+setIs">setIs</a></code>).  Inheritance information implied by the
class definition itself (because the class contains one or more other
classes) is also constructed automatically.
</p>
<p>When a class is to be used in an R session, this information is
assembled to complete the class definition.  The completion is a
second object of class <code>"classRepresentation"</code>, cached for the
session or until something happens to change the information.  A call
to <code><a href="#topic+getClass">getClass</a></code> returns the completed definition of a class;
a call to <code><a href="#topic+getClassDef">getClassDef</a></code> returns the stored definition
(uncompleted).
</p>
<p>In particular, completion fills in the upward- and downward-pointing
inheritance information for the class, in slots <code>contains</code> and
<code>subclasses</code> respectively.  It's in principle important to note
that this information can depend on which packages are installed,
since these may define additional subclasses or superclasses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>slots</code>:</dt><dd><p>A named list of the slots in this class; the
elements of the list are the classes to which the slots must
belong (or extend), and the names of the list gives the
corresponding slot names.</p>
</dd>
<dt><code>contains</code>:</dt><dd><p>A named list of the classes this class
&lsquo;contains&rsquo;; the elements of the list are objects of
<code><a href="#topic+SClassExtension-class">SClassExtension</a></code>. The list may be only the
direct extensions or all the currently known extensions (see the
details).</p>
</dd>
<dt><code>virtual</code>:</dt><dd><p>Logical flag, set to <code>TRUE</code> if this is
a virtual class.</p>
</dd>
<dt><code>prototype</code>:</dt><dd><p>The object that represents the standard
prototype for this class; i.e., the data and slots returned by a
call to <code><a href="#topic+new">new</a></code> for this class with no special
arguments.  Don't mess with the prototype object directly.</p>
</dd>
<dt><code>validity</code>:</dt><dd><p>Optionally, a function to be used to test
the validity of objects from this class.
See <code><a href="#topic+validObject">validObject</a></code>.</p>
</dd>
<dt><code>access</code>:</dt><dd><p>Access control information.  Not currently used.</p>
</dd>
<dt><code>className</code>:</dt><dd><p>The character string name of the class.</p>
</dd>
<dt><code>package</code>:</dt><dd><p>The character string name of the package to
which the class belongs.  Nearly always the package on which the
metadata for the class is stored, but in operations such as
constructing inheritance information, the internal package name
rules.</p>
</dd>
<dt><code>subclasses</code>:</dt><dd><p>A named list of the classes known to
extend this class'; the elements of the list are objects of class
<code><a href="#topic+SClassExtension-class">SClassExtension</a></code>.  The list is currently only
filled in when completing the class definition (see the details).</p>
</dd>
<dt><code>versionKey</code>:</dt><dd><p>Object of class <code>"externalptr"</code>;
eventually will perhaps hold some versioning information, but not
currently used. </p>
</dd>
<dt><code>sealed</code>:</dt><dd><p>Object of class <code>"logical"</code>; is this
class sealed?  If so, no modifications are allowed. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>See function <code><a href="#topic+setClass">setClass</a></code> to supply the information in the
class definition.
See <a href="#topic+Classes_Details">Classes_Details</a> for a more basic discussion of class information.
</p>

<hr>
<h2 id='Documentation'>Using and Creating On-line Documentation for Classes and
Methods</h2><span id='topic+Documentation'></span><span id='topic+Documentation-class'></span><span id='topic+Documentation-methods'></span>

<h3>Description</h3>

<p>Special documentation can be supplied to describe the
classes and methods that are created by the software in the methods
package.  Techniques to access this documentation and to create it
in R help files are described here.</p>


<h3>Getting documentation on classes and methods</h3>

<p>You can ask for on-line help for class definitions, for specific
methods for a generic function, and for general discussion of
methods for a generic function.  These requests use the <code>?</code>
operator (see <code><a href="utils.html#topic+help">help</a></code> for a general description of
the operator).  Of course, you are at the mercy of the implementer
as to whether there <em>is</em> any documentation on the corresponding
topics.
</p>
<p>Documentation on a class uses the argument <code>class</code> on the left
of the <code>?</code>, and the name of the class on the right; for
example,
</p>
<p><code>class ? genericFunction</code>
</p>
<p>to ask for documentation on the class <code>"genericFunction"</code>.
</p>
<p>When you want documentation for the methods defined for a particular
function, you can ask either for a general discussion of the methods
or for documentation of a particular method (that is, the method that
would be selected for a particular set of actual arguments).
</p>
<p>Overall methods documentation is requested by
calling the <code>?</code> operator with <code>methods</code> as the left-side
argument and the name of the function as the right-side argument. For
example,
</p>
<p><code>methods ? initialize</code>
</p>
<p>asks for documentation on the methods for the <code><a href="#topic+initialize">initialize</a></code>
function.
</p>
<p>Asking for documentation on a particular method is done by giving a
function call expression as the right-hand argument to the <code>"?"</code>
operator.  There are two forms, depending on whether you prefer to
give the class names for the arguments or expressions that you intend
to use in the actual call.
</p>
<p>If you planned to evaluate a function call, say <code>myFun(x, sqrt(wt))</code>
and wanted to find out something about the method that would be used
for this call, put the call on the right of the <code>"?"</code> operator:
</p>
<p><code>?myFun(x, sqrt(wt))</code>
</p>
<p>A method will be selected, as it would be for the call itself, and
documentation for that method will be requested.  If <code>myFun</code> is
not a generic function, ordinary documentation for the function will
be requested.
</p>
<p>If you know the actual classes for which you would like method
documentation, you can supply these explicitly in place of the
argument expressions.  In the example above, if you want method
documentation for the first argument having class <code>"maybeNumber"</code>
and the second <code>"logical"</code>, call the <code>"?"</code> operator, this
time with a left-side argument <code>method</code>, and with a function call
on the right using the class names as arguments:
</p>
<p><code>method ? myFun("maybeNumber", "logical")</code>
</p>
<p>Once again, a method will be selected, this time corresponding to the
specified classes, and method documentation will be requested.  This
version only works with generic functions.
</p>
<p>The two forms each have advantages.  The version with actual arguments
doesn't require you to figure out (or guess at) the classes of the
arguments.
On the other hand, evaluating the arguments may take some time,
depending on the example.
The version with class names does require you to pick classes, but
it's otherwise unambiguous.  It has a subtler advantage, in that the
classes supplied may be virtual classes, in which case no actual
argument will have specifically this class.  The class
<code>"maybeNumber"</code>, for example, might be a class union (see the
example for <code><a href="#topic+setClassUnion">setClassUnion</a></code>).
</p>
<p>In either form, methods will be selected as they would be in actual
computation, including use of inheritance and group generic
functions.  See <code><a href="#topic+selectMethod">selectMethod</a></code> for the details, since it is
the function used to find the appropriate method.
</p>


<h3>Writing Documentation for Methods</h3>

<p>The on-line documentation for methods and classes uses some extensions
to the R documentation format to implement the requests for class and
method documentation described above.  See the document <em>Writing
R Extensions</em> for the available markup commands (you should
have consulted this document already if you are at the stage of
documenting your software).
</p>
<p>In addition to the specific markup commands to be described, you can
create an initial, overall file with a skeleton of documentation for
the methods defined for a particular generic function:
</p>
<p><code>promptMethods("myFun")</code>
</p>
<p>will create a file, &lsquo;<span class="file">myFun-methods.Rd</span>&rsquo; with a skeleton of
documentation for the methods defined for function <code>myFun</code>.
The output from <code>promptMethods</code> is suitable if you want to
describe all or most of the methods for the function in one file,
separate from the documentation of the generic function itself.
Once the file has been filled in and moved to the &lsquo;<span class="file">man</span>&rsquo;
subdirectory of your source package, requests for methods
documentation will use that file, both for specific methods
documentation as described above, and for overall documentation
requested by
</p>
<p><code>methods ? myFun</code>
</p>
<p>You are not required to use <code>promptMethods</code>, and if you do, you
may not want to use the entire file created:
</p>

<ul>
<li><p> If you want to document the methods in the file containing the
documentation for the generic function itself, you can
cut-and-paste to move the <code style="white-space: pre;">&#8288;\alias&#8288;</code> lines and the
<code>Methods</code> section from the file created by
<code>promptMethods</code> to the existing file.
</p>
</li>
<li><p> On the other hand, if these are auxiliary methods, and you only
want to document the added or modified software, you should strip
out all but the relevant <code style="white-space: pre;">&#8288;\alias&#8288;</code> lines for the methods of
interest, and remove all but the corresponding <code style="white-space: pre;">&#8288;\item&#8288;</code>
entries in the <code>Methods</code> section. Note that in this case you
will usually remove the first  <code style="white-space: pre;">&#8288;\alias&#8288;</code> line as well, since
that is the marker for general methods documentation on this
function (in the example, &lsquo;<span class="samp">&#8288;\alias{myfun-methods}&#8288;</span>&rsquo;).
</p>
</li></ul>

<p>If you simply want to direct documentation for one or more methods to
a particular R documentation file, insert the appropriate alias.
</p>

<hr>
<h2 id='dotsMethods'>The Use of <code>...</code> in Method Signatures</h2><span id='topic+dotsMethods'></span>

<h3>Description</h3>

<p>The &ldquo;...&rdquo; argument in <span class="rlang"><b>R</b></span> functions is treated specially, in that it
matches zero, one or more actual arguments (and so, objects).  A
mechanism has been added to <span class="rlang"><b>R</b></span> to allow &ldquo;...&rdquo; as the signature of a
generic function.  Methods defined for such functions will be
selected and called when <em>all</em>  the arguments matching &ldquo;...&rdquo;
are from the specified class or from some subclass of that class.
</p>


<h3>Using &quot;...&quot; in a Signature</h3>

<p>Beginning with version 2.8.0 of <span class="rlang"><b>R</b></span>, S4 methods can be dispatched
(selected and called) corresponding to the special argument &ldquo;...&rdquo;.
Currently, &ldquo;...&rdquo; cannot be mixed with other formal arguments:
either the signature of the generic function is &ldquo;...&rdquo; only, or it
does not contain &ldquo;...&rdquo;.  (This restriction may be lifted in a future
version.)
</p>
<p>Given a suitable generic function, methods are specified in the
usual way by a call to <code><a href="#topic+setMethod">setMethod</a></code>.  The method
definition must be written expecting all the arguments corresponding
to &ldquo;...&rdquo; to be from the class specified in the method's signature,
or from a class that extends that class (i.e., a subclass of that
class).
</p>
<p>Typically the methods will pass &ldquo;...&rdquo; down to another function or
will create a list of the arguments and iterate over that.  See the
examples below.
</p>
<p>When you have a computation that is suitable for more than one existing
class, a convenient approach may be to define a union of these
classes by a call to <code><a href="#topic+setClassUnion">setClassUnion</a></code>. See the example
below.
</p>


<h3>Method Selection and Dispatch for &quot;...&quot;</h3>

<p>See <a href="#topic+Methods_Details">Methods_Details</a> for a general discussion.  The following assumes
you have read the &ldquo;Method Selection and Dispatch&rdquo; section of
that documentation.
</p>
<p>A method selecting on &ldquo;...&rdquo; is specified by a single class in the
call to <code><a href="#topic+setMethod">setMethod</a></code>.  If all the actual arguments
corresponding to &ldquo;...&rdquo; have this class, the corresponding method is
selected directly.
</p>
<p>Otherwise, the class of each argument and that class' superclasses are
computed, beginning with the first &ldquo;...&rdquo; argument.  For the first
argument, eligible methods are those for any of the classes.   For
each succeeding argument that introduces a class not considered previously, the eligible methods are further
restricted to those matching the argument's class or
superclasses. If no further eligible classes exist, the iteration
breaks out and the default method, if any, is selected.
</p>
<p>At the end of the iteration, one or more methods may be eligible.
If more than one, the selection looks for the method with the least
distance to the actual arguments.  For each argument, any inherited
method corresponds to a distance, available from the <code>contains</code>
slot of the class definition.  Since the same class can arise for
more than one argument, there may be several distances associated
with it.  Combining them is inevitably arbitrary:  the current
computation uses the minimum distance.  Thus, for example, if a
method matched one argument directly, one as  first generation
superclass and another as a second generation superclass, the
distances are 0, 1 and 2.  The current selection computation would
use distance 0 for this
method.  In particular, this selection criterion tends to use a method that
matches exactly one or more of the arguments' class.
</p>
<p>As with ordinary method selection, there may be multiple methods
with the same distance.  A warning  message is issued and one of the
methods is chosen (the first encountered, which in this case is
rather arbitrary).
</p>
<p>Notice that, while the computation examines all arguments, the
essential cost of dispatch goes up with the number of
<em>distinct</em> classes among the arguments, likely to be much
smaller than the number of arguments when the latter is large.
</p>


<h3>Implementation Details</h3>

<p>Methods dispatching on &ldquo;...&rdquo; were introduced in version 2.8.0 of
<span class="rlang"><b>R</b></span>.  The initial implementation of the corresponding selection and
dispatch is in an R function, for flexibility while the new
mechanism is being studied.  In this implementation, a local version
of <code>standardGeneric</code> is inserted in the generic function's
environment.  The local version selects a method according to the
criteria above and calls that method, from the environment of the
generic function.  This is slightly different from the action taken
by the C implementation when &ldquo;...&rdquo; is not involved.  Aside from the
extra computing time required, the method is evaluated in a true
function call, as opposed to the special context constructed by the
C version (which cannot be exactly replicated in R code.)  However,
situations in which different computational results would
be obtained have not been encountered so far, and seem very
unlikely.
</p>
<p>Methods dispatching on arguments other than &ldquo;...&rdquo; are <em>cached</em> by storing
the inherited method in the table of all methods, where it will be
found on the next selection with the same combination of classes
in the actual arguments (but not used for inheritance searches).
Methods based on &ldquo;...&rdquo; are also cached, but not found quite
as immediately.  As noted, the selected method depends only on the
set of classes that occur in the &ldquo;...&rdquo; arguments.  Each of
these classes can appear one or more times, so many combinations of
actual argument classes will give rise to the same effective
signature.  The selection computation first computes and sorts the
distinct classes encountered.  This gives a label that will be
cached in the table of all methods, avoiding any further search for
inherited classes after the first occurrence.  A call to
<code><a href="#topic+showMethods">showMethods</a></code> will expose such inherited methods.
</p>
<p>The intention is that the &ldquo;...&rdquo; features will be added to the
standard C code when enough experience with them has been obtained.
It is possible that at the same time, combinations of &ldquo;...&rdquo; with
other arguments in signatures may be supported.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

<p>For the general discussion of methods, see  <a href="#topic+Methods_Details">Methods_Details</a> and links
from there.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc &lt;- function(...)c(...)

setGeneric("cc")

setMethod("cc", "character", function(...)paste(...))

setClassUnion("Number", c("numeric", "complex"))

setMethod("cc", "Number", function(...) sum(...))

setClass("cdate", contains = "character", slots = c(date = "Date"))

setClass("vdate", contains = "vector", slots = c(date = "Date"))

cd1 &lt;- new("cdate", "abcdef", date = Sys.Date())

cd2 &lt;- new("vdate", "abcdef", date = Sys.Date())

stopifnot(identical(cc(letters, character(), cd1),
           paste(letters, character(), cd1))) # the "character" method

stopifnot(identical(cc(letters, character(), cd2),
                    c(letters, character(), cd2)))
# the default, because "vdate" doesn't extend "character"

stopifnot(identical(cc(1:10, 1+1i), sum(1:10, 1+1i))) # the "Number" method

stopifnot(identical(cc(1:10, 1+1i, TRUE), c(1:10, 1+1i, TRUE))) # the default

stopifnot(identical(cc(), c())) # no arguments implies the default method

setGeneric("numMax", function(...)standardGeneric("numMax"))

setMethod("numMax", "numeric", function(...)max(...))
# won't work for complex data
setMethod("numMax", "Number", function(...) paste(...))
# should not be selected w/o complex args

stopifnot(identical(numMax(1:10, pi, 1+1i), paste(1:10, pi, 1+1i)))
stopifnot(identical(numMax(1:10, pi, 1), max(1:10, pi, 1)))

try(numMax(1:10, pi, TRUE)) # should be an error:  no default method

## A generic version of paste(), dispatching on the "..." argument:
setGeneric("paste", signature = "...")

setMethod("paste", "Number", function(..., sep, collapse) c(...))

stopifnot(identical(paste(1:10, pi, 1), c(1:10, pi, 1)))


</code></pre>

<hr>
<h2 id='EmptyMethodsList-class'>Internal Class representing Empty Methods List </h2><span id='topic+EmptyMethodsList-class'></span>

<h3>Description</h3>

<p>Objects from class <code>"EmptyMethodsList"</code> are generated during
method selection to indicate failed search (forcing backtracking).
Other classes described here are used internally in method dispatch.
All these are for internal use.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## class described below
"EmptyMethodsList"

### Other, virtual classes used in method dispatch
"OptionalMethods"
"PossibleMethod"
</code></pre>


<h3>Slots</h3>


<dl>
<dt><code>argument</code>:</dt><dd><p>Object of class <code>"name"</code> the argument
names being selected on.</p>
</dd>
<dt><code>sublist</code>:</dt><dd><p>Object of class <code>"list"</code> (unused, and
perhaps to be dropped in a later version.) </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class <code>"EmptyMethodsList"</code> in the
signature.
</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+MethodsListSelect">MethodsListSelect</a></code> (deprecated since <span class="rlang"><b>R</b></span> version
3.2.0) uses the objects;
class <code><a href="#topic+MethodsList-class">MethodsList</a></code> is formally defunct since <span class="rlang"><b>R</b></span> 3.2.0.
</p>

<hr>
<h2 id='environment-class'>Class <code>"environment"</code></h2><span id='topic+environment-class'></span>

<h3>Description</h3>

<p> A formal class for R environments.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("environment", ...)</code>.
The arguments in ..., if any, should be named and will be assigned to
the newly created environment.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "ANY", to = "environment")</code>:
calls <code><a href="base.html#topic+as.environment">as.environment</a></code>. </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(object = "environment")</code>:
Implements the assignments in the new environment.  Note that the
<code>object</code> argument is ignored; a new environment is
<em>always</em> created, since environments are not protected by copying. </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="base.html#topic+new.env">new.env</a></code> </p>

<hr>
<h2 id='envRefClass-class'>Class <code>"envRefClass"</code></h2><span id='topic+envRefClass-class'></span><span id='topic++24+2CenvRefClass-method'></span><span id='topic++24+3C-+2CenvRefClass-method'></span><span id='topic+initialize+2CenvRefClass-method'></span>

<h3>Description</h3>

<p>Support Class to Implement R Objects using Reference Semantics
</p>


<h3>NOTE:</h3>

<p>The software described here is an initial version.  The eventual goal
is to support reference-style classes with software in <span class="rlang"><b>R</b></span> itself
or using inter-system interfaces.  The current implementation (<span class="rlang"><b>R</b></span>
version 2.12.0) is preliminary and subject to change, and currently
includes only the <span class="rlang"><b>R</b></span>-only implementation.  Developers are encouraged
to experiment with the software, but the description here is more than
usually subject to change.
</p>


<h3>Purpose of the Class</h3>

<p>This class implements basic reference-style semantics for <span class="rlang"><b>R</b></span>
objects.  Objects normally do not come directly from this class, but
from subclasses defined by a call to <code><a href="#topic+setRefClass">setRefClass</a></code>.
The documentation below is technical background describing the implementation, but applications
should use the interface documented under <code><a href="#topic+setRefClass">setRefClass</a></code>,
in particular the <code>$</code> operator and field accessor functions as
described there.
</p>


<h3>A Basic Reference Class</h3>

<p>The design of reference classes for <span class="rlang"><b>R</b></span> divides those classes up
according to the mechanism used for implementing references, fields,
and class methods.
Each version of this mechanism is defined by a <em>basic reference
class</em>, which must implement a set of methods and provide some
further information used by <code><a href="#topic+setRefClass">setRefClass</a></code>.
</p>
<p>The required methods are for operators <code>$</code> and <code>$&lt;-</code> to
get and set a field in an object, and for <code><a href="#topic+initialize">initialize</a></code> to
initialize objects.
</p>
<p>To support these methods, the basic reference class needs to have some
implementation mechanism to store and retrieve data from fields in the
object.
The mechanism needs to be consistent with reference semantics; that
is, changes made to the contents of an object are global, seen by any
code accessing that object, rather than only local to the function
call where the change takes place.
As described below, class <code>envRefClass</code> implements reference
semantics through specialized use of <a href="#topic+environment-class">environment</a>
objects.
Other basic reference classes may use an interface to a language such
as Java or C++ using reference semantics for classes.
</p>
<p>Usually, the <span class="rlang"><b>R</b></span>  user will be able to invoke class methods on the
class, using the <code>$</code> operator.  The basic reference class
method for <code>$</code> needs to make this possible.  Essentially, the
operator must return an <span class="rlang"><b>R</b></span> function corresponding to the object and
the class method name.
</p>
<p>Class methods may include an implementation of data abstraction, in
the sense that fields are accessed by &ldquo;get&rdquo; and &ldquo;set&rdquo;
methods.  The basic reference class provides this facility by setting
the <code>"fieldAccessorGenerator"</code> slot in its definition to a
function of one variable.
This function will be called by <code><a href="#topic+setRefClass">setRefClass</a></code> with the
vector of field names as arguments.
The generator function must return a list of defined accessor
functions.
An element corresponding to a get operation is invoked with no
arguments and should extract the corresponding field; an element for a
set operation will be invoked with a single argument, the value to be
assigned to the field.
The implementation needs to supply the object, since that is not an
argument in the method invocation.
The mechanism used currently by <code>envRefClass</code> is described below.
</p>


<h3>Support Classes</h3>

<p>Two virtual classes are supplied to test for reference objects:
<code>is(x, "refClass")</code> tests whether <code>x</code> comes from a class
defined using the reference class mechanism described here;
<code>is(x, "refObject")</code> tests whether the object has reference
semantics generally, including the previous classes and also classes
inheriting from the <span class="rlang"><b>R</b></span> types with reference semantics, such as
<code>"environment"</code>.
</p>
<p>Installed class methods are <code>"classMethodDefinition"</code> objects,
with slots that identify the name of the function as a class method
and the other class methods called from this method.
The latter information is determined heuristically when the class is
defined by using the <code>codetools</code> recommended package.  This
package must be installed when reference classes are defined, but is
not needed in order to use existing reference classes.
</p>


<h3>Author(s)</h3>

<p>John Chambers
</p>

<hr>
<h2 id='evalSource'>
Use Function Definitions from a Source File without Reinstalling a Package
</h2><span id='topic+evalSource'></span><span id='topic+insertSource'></span><span id='topic+sourceEnvironment-class'></span>

<h3>Description</h3>

<p>Definitions of functions and/or methods from a source file are
inserted into a package, using the <code><a href="base.html#topic+trace">trace</a></code> mechanism.
Typically, this allows testing or debugging modified versions of a few
functions without reinstalling a large package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalSource(source, package = "", lock = TRUE, cache = FALSE)

insertSource(source, package = "", functions = , methods = ,
           force = )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalSource_+3A_source">source</code></td>
<td>

<p>A file to be parsed and evaluated by <code>evalSource</code> to find the new
function and method definitions.
</p>
<p>The argument to <code>insertSource</code> can be an object of class <code>"sourceEnvironment"</code>
returned from a previous call
to <code>evalSource</code>   If a file name is passed to <code>insertSource</code>
it calls <code>evalSource</code> to obtain the corresponding object.  See
the section on the class for details.
</p>
</td></tr>
<tr><td><code id="evalSource_+3A_package">package</code></td>
<td>

<p>Optionally, the name of the package to which the new code corresponds
and into which it will be
inserted.  Although the computations will attempt to infer the package
if it is omitted, the safe approach is to supply it.  In the case of a
package that is not attached to the search list, the package name must
be supplied.
</p>
</td></tr>
<tr><td><code id="evalSource_+3A_functions">functions</code>, <code id="evalSource_+3A_methods">methods</code></td>
<td>

<p>Optionally, the character-string names of the functions to be
used in the insertion.  Names supplied in the <code>functions</code>
argument are expected to be defined as functions in the source.
For names supplied in the <code>methods</code> argument, a table of methods
is expected (as generated by calls to <code><a href="#topic+setMethod">setMethod</a></code>, see the
details section); methods from this table will be inserted by
<code>insertSource</code>.  In both cases, the revised function or method is
inserted only if it differs from the version in the corresponding
package as loaded.
</p>
<p>If <code>what</code> is omitted, the results of evaluating the source file
will be compared to the contents of the package (see the details section).
</p>
</td></tr>
<tr><td><code id="evalSource_+3A_lock">lock</code>, <code id="evalSource_+3A_cache">cache</code></td>
<td>

<p>Optional arguments to control the actions taken by <code>evalSource</code>.
If <code>lock</code> is <code>TRUE</code>, the environment in the object returned
will be locked, and so will all its bindings.
If <code>cache</code> is <code>FALSE</code>, the normal caching of method and
class definitions will be suppressed during evaluation of the
<code>source</code> file.
</p>
<p>The default settings are generally recommended, the <code>lock</code> to
support the credibility of the object returned as a snapshot of the
source file, and the second so that method definitions can be inserted
later by <code>insertSource</code> using the trace mechanism.
</p>
</td></tr>
<tr><td><code id="evalSource_+3A_force">force</code></td>
<td>

<p>If <code>FALSE</code>, only functions currently in the environment will be
redefined, using <code><a href="base.html#topic+trace">trace</a></code>.  If <code>TRUE</code>, other
objects/functions will be simply assigned.  By default, <code>TRUE</code> if
neither the <code>functions</code> nor the <code>methods</code> argument is supplied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>source</code> file is parsed and evaluated, suppressing by default
the actual caching of method and class definitions contained in it, so
that functions and methods can be tested out in a reversible way.
The result, if all goes well, is an environment containing the
assigned objects and metadata corresponding to method and class definitions
in the source file.
</p>
<p>From this environment, the objects are inserted into the package, into
its namespace if it has one, for use during the current session or
until reverting to the original version by a call to
<code><a href="base.html#topic+untrace">untrace</a></code>.
The insertion is done by calls to the internal version of
<code><a href="base.html#topic+trace">trace</a></code>, to make reversion possible.
</p>
<p>Because the trace mechanism is used, only function-type objects will
be inserted, functions themselves or S4 methods.
</p>
<p>When the <code>functions</code> and <code>methods</code> arguments are both
omitted, <code>insertSource</code> selects all suitable objects from the
result of evaluating the <code>source</code> file.
</p>
<p>In all cases,
only objects in the source file that differ from
the corresponding objects in the package are inserted.
The definition of &ldquo;differ&rdquo; is that either the argument list
(including default expressions) or the body of the function is not
identical.
Note that in the case of a method, there need be no specific method
for the corresponding signature in the package: the comparison is made
to the method that would be selected for that signature.
</p>
<p>Nothing in the computation requires that the source file supplied be
the same file as in the original package source, although that case is
both likely and sensible if one is revising the package.  Nothing in
the computations compares source files:  the objects generated by
evaluating <code>source</code> are compared as objects to the content of the package.
</p>


<h3>Value</h3>

<p>An object from class <code>"sourceEnvironment"</code>, a subclass of
<code>"environment"</code> (see the section on the class)
The environment contains the versions
of <em>all</em>  object resulting from evaluation of the source file.
The class also has slots for the time of creation, the source file
and the package name.
Future extensions may use these objects for versioning or other code tools.
</p>
<p>The object returned can be used in debugging (see the section on that
topic) or as the <code>source</code>
argument in a future call to <code>insertSource</code>.  If only some of the
revised functions were inserted in the first call, others can be
inserted in a later call without re-evaluating the source file, by
supplying the environment and optionally suitable <code>functions</code>
and/or <code>methods</code> argument.
</p>


<h3>Debugging</h3>

<p>Once a function or method has been inserted into a package by
<code>insertSource</code>, it can be studied by the standard debugging tools;
for example, <code><a href="base.html#topic+debug">debug</a></code> or the various versions of
<code><a href="base.html#topic+trace">trace</a></code>.
</p>
<p>Calls to <code><a href="base.html#topic+trace">trace</a></code> should take the extra argument <code>edit
= env</code>, where <code>env</code> is the value returned by the call to
<code>evalSource</code>.
The trace mechanism has been used to install the revised version from
the source file, and supplying the argument ensures that it is this
version, not the original, that will be traced.  See the example
below.
</p>
<p>To turn tracing off, but retain the source version, use <code>trace(x,
edit = env)</code> as in the example.  To return to the original version
from the package, use <code>untrace(x)</code>.
</p>


<h3>Class <code>"sourceEnvironment"</code></h3>

<p>Objects from this class can be treated as environments, to extract the
version of functions and methods generated by <code>evalSource</code>.
The objects also have the following slots:
</p>

<dl>
<dt><code>packageName</code>:</dt><dd><p> The character-string name of the package
to which the source code corresponds.
</p>
</dd>
<dt><code>dateCreated</code>:</dt><dd><p> The date and time that the source file was
evaluated (usually from a call to <code><a href="base.html#topic+Sys.time">Sys.time</a></code>).
</p>
</dd>
<dt><code>sourceFile</code>:</dt><dd><p> The character-string name of the source file
used.
</p>
</dd>
</dl>
<p>Note that using the environment does not change the <code>dateCreated</code>.

</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+trace">trace</a></code> for the underlying mechanism, and also for the
<code>edit=</code> argument that can be used for somewhat similar purposes;
that function and also <code><a href="base.html#topic+debug">debug</a></code> and
<code><a href="utils.html#topic+setBreakpoint">setBreakpoint</a></code>, for techniques more oriented to
traditional debugging styles.
The present function is directly intended for the case that one is
modifying some of the source for an existing package, although it can
be used as well by inserting debugging code in the source (more useful
if the debugging involved is non-trivial).  As noted in the details
section, the source
file need not be the same one in the original package source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Suppose package P0 has a source file "all.R"
## First, evaluate the source, and from it
## insert the revised version of methods for summary()
  env &lt;- insertSource("./P0/R/all.R", package = "P0",
     methods = "summary")
## now test one of the methods, tracing  the version from the source
  trace("summary", signature = "myMat", browser, edit = env)
## After testing, remove the browser() call but keep the source
  trace("summary", signature = "myMat", edit = env)
## Now insert all the (other) revised functions and methods
## without re-evaluating the source file.
## The package name is included in the object env.
  insertSource(env)

## End(Not run)
</code></pre>

<hr>
<h2 id='findClass'>Find Class Definitions</h2><span id='topic+removeClass'></span><span id='topic+resetClass'></span><span id='topic+isClass'></span><span id='topic+getClasses'></span><span id='topic+findClass'></span><span id='topic+sealClass'></span>

<h3>Description</h3>

<p>Functions to find classes:  <code>isClass</code> tests for a class;
<code>findClass</code> returns the name(s) of packages containing the
class; <code>getClasses</code> returns the names of all the classes in an
environment, typically a namespace.  To examine the definition of a class, use <code><a href="#topic+getClass">getClass</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isClass(Class, formal=TRUE, where)

getClasses(where, inherits = missing(where))

findClass(Class, where, unique = "")

## The remaining functions are retained for compatibility
## but not generally recommended

removeClass(Class, where)

resetClass(Class, classDef, where)

sealClass(Class, where)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findClass_+3A_class">Class</code></td>
<td>
<p>character string name for the class.  The functions will
usually take a class definition instead of the string.  To restrict
the class to those defined in a particular package, set the
<code><a href="#topic+packageSlot">packageSlot</a></code> of the character string.</p>
</td></tr>
<tr><td><code id="findClass_+3A_where">where</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> in which to search for
the class definition.  Defaults to the top-level environment of the
calling function.  When called from the command line, this has the
effect of using all the package environments in the search list.
</p>
<p>To restrict the search to classes in a particular package, use <code>where =
      asNamespace(pkg)</code> with <code>pkg</code> the package name;  to restrict
it to
the <em>exported</em> classes, use <code>where = "package:pkg"</code> after the
package is attached to the search list.
</p>
</td></tr>
<tr><td><code id="findClass_+3A_formal">formal</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> is a formal definition
required? For S compatibility, and always treated as <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="findClass_+3A_unique">unique</code></td>
<td>
<p>if <code>findClass</code> expects a unique location for the
class, <code>unique</code> is a character string explaining the purpose
of the search (and is used in warning and error messages).  By
default, multiple locations are possible and the function always
returns a list.
</p>
</td></tr>
<tr><td><code id="findClass_+3A_inherits">inherits</code></td>
<td>
<p>in a call to <code>getClasses</code>, should the value
returned include all parent environments of <code>where</code>, or that
environment only?  Defaults to <code>TRUE</code> if <code>where</code> is
omitted, and to <code>FALSE</code> otherwise.
</p>
</td></tr>
<tr><td><code id="findClass_+3A_classdef">classDef</code></td>
<td>
<p> For <code>resetClass</code>, the optional class
definition.
</p>
</td></tr>
</table>


<h3>Functions</h3>


<dl>
<dt><code>isClass</code>:</dt><dd>
<p>Is this the name of a formally defined class?
</p>
</dd>
<dt><code>getClasses</code>:</dt><dd>
<p>The names of all the classes formally defined on <code>where</code>.  If
called with no argument, all the classes visible from the
calling function (if called from the top-level, all the classes
in any of the environments on the search list).  The
<code>where</code> argument is used to search only in a particular package.
</p>
</dd>
<dt><code>findClass</code>:</dt><dd>
<p>The list of environments in
which a class definition of <code>Class</code> is found.  If
<code>where</code> is supplied, a list is still returned, either empty
or containing the environment corresponding to <code>where</code>.
By default when called from the <span class="rlang"><b>R</b></span> session, the global
environment and all the currently
attached packages are searched.
</p>
<p>If <code>unique</code> is supplied as a character string,
<code>findClass</code> will warn if there is more than one definition
visible (using the string to identify the purpose of the call),
and will generate an error if no definition can be found.
</p>
<p><em>The remaining functions are retained for
back-compatibility and internal use, but not generally recommended.</em>
</p>
</dd>
<dt><code>removeClass</code>:</dt><dd>
<p>Remove the definition of this class.  This can't be used if the
class is in another package, and would rarely be needed in
source code defining classes in a package.
</p>
</dd>
<dt><code>resetClass</code>:</dt><dd>
<p>Reset the internal definition of a class.  Not legitimate for a
class definition not in this package and rarely needed otherwise.
</p>
</dd>
<dt><code>sealClass</code>:</dt><dd><p> Seal the current definition of the specified
class, to prevent further changes, by setting the corresponding
slot in the class definition.  This is rarely used, since
classes in loaded packages are sealed by locking their namespace.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer. (Chapter 9 has some details not in the later reference.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getClass">getClass</a></code>,
<code><a href="#topic+Classes_Details">Classes_Details</a></code>,
<code><a href="#topic+Methods_Details">Methods_Details</a></code>,
<code><a href="#topic+makeClassRepresentation">makeClassRepresentation</a></code>
</p>

<hr>
<h2 id='findMethods'>Description of the Methods Defined for a Generic Function</h2><span id='topic+findMethods'></span><span id='topic+findMethodSignatures'></span><span id='topic+hasMethods'></span><span id='topic+getMethods'></span><span id='topic+listOfMethods-class'></span>

<h3>Description</h3>

<p>The function <code>findMethods</code> converts the methods defined in a table for a generic
function (as used for selection of methods) into a list, for study or
display.  The list is actually from the class <code>listOfMethods</code>
(see the section describing the class, below).
</p>
<p>The list will be limited
to the methods defined in environment <code>where</code> if that argument is
supplied and limited to those including one or more of the
specified <code>classes</code> in the method signature if that argument is
supplied.
</p>
<p>To see the actual table (an <code><a href="base.html#topic+environment">environment</a></code>) used
for methods dispatch, call <code><a href="#topic+getMethodsForDispatch">getMethodsForDispatch</a></code>.
The names of the list returned by <code>findMethods</code> are the names of
the objects in the table.
</p>
<p>The function <code>findMethodSignatures</code> returns a character matrix
whose rows are the class names from the signature of the corresponding
methods; it operates either from a list returned by
<code>findMethods</code>, or by computing such a list itself, given the same
arguments as <code>findMethods</code> .
</p>
<p>The function <code>hasMethods</code> returns <code>TRUE</code> or <code>FALSE</code>
according to whether there is a non-empty table of methods for
function <code>f</code> in the environment or search position <code>where</code>
(or for the generic function generally if <code>where</code> is missing).
</p>
<p>The defunct function <code>getMethods</code> is an older alternative to
<code>findMethods</code> , returning information in the form of an object of
class <code>MethodsList</code>, previously used for method dispatch.  This
class of objects is deprecated generally and will disappear in a
future version of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMethods(f, where, classes = character(), inherited = FALSE,
      package = "")

findMethodSignatures(..., target = TRUE, methods = )

hasMethods(f, where, package)

## Deprecated in 2010 and defunct in 2015 for 'table = FALSE':
getMethods(f, where, table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMethods_+3A_f">f</code></td>
<td>
<p>A generic function or the character-string name of one.</p>
</td></tr>
<tr><td><code id="findMethods_+3A_where">where</code></td>
<td>
<p>Optionally, an environment or position on the search list
to look for methods metadata.
</p>
<p>If <code>where</code> is missing,  <code>findMethods</code> uses the current
table of methods in the generic function itself, and
<code>hasMethods</code> looks for metadata anywhere in the search list.
</p>
</td></tr>
<tr><td><code id="findMethods_+3A_table">table</code></td>
<td>
<p> If <code>TRUE</code> in a call to <code>getMethods</code> the
returned value is the table used for dispatch, including
inherited methods discovered to date.  Used internally, but
since the default result is the now unused <code>mlist</code> object,
the default will likely be changed at some point.
</p>
</td></tr>
<tr><td><code id="findMethods_+3A_classes">classes</code></td>
<td>
<p>If supplied, only methods whose signatures contain at
least one of the supplied classes will be included in the value
returned.</p>
</td></tr>
<tr><td><code id="findMethods_+3A_inherited">inherited</code></td>
<td>
<p>Logical flag; if <code>TRUE</code>, the table of all
methods, inherited or defined directly, will be used; otherwise,
only the methods explicitly defined.  Option <code>TRUE</code> is
meaningful only if <code>where</code> is missing.</p>
</td></tr>
<tr><td><code id="findMethods_+3A_...">...</code></td>
<td>
<p>In the call to <code>findMethodSignatures</code>, any arguments
that might be given to <code>findMethods</code>.</p>
</td></tr>
<tr><td><code id="findMethods_+3A_target">target</code></td>
<td>
<p>Optional flag to <code>findMethodSignatures</code>; if
<code>TRUE</code>, the signatures used are the target signatures (the
classes for which the method will be selected); if <code>FALSE</code>,
they will be the signatures are defined.  The difference is only
meaningful if <code>inherited</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="findMethods_+3A_methods">methods</code></td>
<td>
<p>In the call to <code>findMethodSignatures</code>, an optional
list of methods, presumably returned by a previous call to
<code>findMethods</code>.  If missing, that function will be call with the
... arguments.</p>
</td></tr>
<tr><td><code id="findMethods_+3A_package">package</code></td>
<td>
<p>In a call to <code>hasMethods</code>, the package name for
the generic function (e.g., <code>"base"</code> for primitives).  If
missing this will be inferred either from the <code>"package"</code>
attribute of the function name, if any, or from the package slot of
the generic function.  See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions obtain a table of the defined methods, either from the
generic function or from the stored metadata object in the environment
specified by <code>where</code>.  In a call to <code>getMethods</code>, the information in the table is converted
as described above to produce the returned value, except with the
<code>table</code> argument.
</p>
<p>Note that <code>hasMethods</code>, but not the other functions, can be used
even if no generic function of this name is currently found.  In this
case <code>package</code> must either be supplied as an argument or included
as an attribute of <code>f</code>, since the package name is part of the
identification of the methods tables.
</p>


<h3>The Class for lists of methods</h3>

<p>The class <code>"listOfMethods"</code> returns the methods as a named list
of method definitions (or a primitive function, see the slot
documentation below).  The names
are the strings used to store the corresponding objects in the
environment from which method dispatch is computed.
The current implementation uses the names of the corresponding classes
in the method signature, separated by <code>"#"</code> if more than one
argument is involved in the signature.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code> The method
definitions.
</p>
<p>Note that these may include the primitive function
itself as  default method,
when the generic corresponds to a primitive. (Basically, because
primitive functions are abnormal R objects, which cannot currently be
extended as method definitions.) Computations that use the returned
list to derive other information need to take account of this
possibility. See the implementation of <code>findMethodSignatures</code>
for an example.
</p>
</dd>
<dt><code>arguments</code>:</dt><dd><p>Object of class <code>"character"</code>.  The
names of the formal arguments in the signature of the generic function. </p>
</dd>
<dt><code>signatures</code>:</dt><dd><p>Object of class <code>"list"</code>. A list of
the signatures of the individual methods.  This is currently the
result of splitting the <code>names</code> according to the <code>"#"</code>
separator.
</p>
<p>If the object has been constructed from a table, as when returned by
<code>findMethods</code>, the signatures will all have the same length.
However, a list rather than a character matrix is used for
generality.  Calling <code>findMethodSignatures</code> as in the example
below will always convert to the matrix form.</p>
</dd>
<dt><code>generic</code>:</dt><dd><p>Object of class <code>"genericFunction"</code>.
The generic function corresponding to these methods.  There
are plans to generalize this slot to allow reference to the function.</p>
</dd>
<dt><code>names</code>:</dt><dd><p>Object of class <code>"character"</code>.  The
names as noted are the class names separated by <code>"#"</code> .</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+namedList-class">namedList</a>"</code>, directly.
</p>
<p>Class <code>"<a href="#topic+list-class">list</a>"</code>, by class <code>"namedList"</code>, distance 2.
</p>
<p>Class <code>"<a href="#topic+vector-class">vector</a>"</code>, by class <code>"namedList"</code>, distance 3.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+showMethods">showMethods</a></code>, <code><a href="#topic+selectMethod">selectMethod</a></code>, <a href="#topic+Methods_Details">Methods_Details</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mm &lt;-  findMethods("Ops")
findMethodSignatures(methods = mm)
</code></pre>

<hr>
<h2 id='fixPre1.8'>Fix Objects Saved from R Versions Previous to 1.8</h2><span id='topic+fixPre1.8'></span>

<h3>Description</h3>

<p>Beginning with R version 1.8.0, the class of an object contains the
identification of the package in which the class is defined.  The
function <code>fixPre1.8</code> fixes and re-assigns objects missing that information
(typically because they were loaded from a file saved with a previous
version of R.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixPre1.8(names, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixPre1.8_+3A_names">names</code></td>
<td>
<p> Character vector of the names of all the objects to be
fixed and re-assigned.</p>
</td></tr>
<tr><td><code id="fixPre1.8_+3A_where">where</code></td>
<td>
<p>The environment from which to look for the objects, and
for class definitions.  Defaults to the top environment of the
call to <code>fixPre1.8</code>, the global environment if the function
is used interactively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The named object will be saved where it was found.  Its class
attribute will be changed to the full form required by R 1.8;
otherwise, the contents of the object should be unchanged.
</p>
<p>Objects will be fixed and re-assigned only if all the following
conditions hold:
</p>

<ol>
<li><p> The named object exists.
</p>
</li>
<li><p> It is from a defined class (not a basic datatype which
has no actual class attribute).
</p>
</li>
<li><p> The object appears to be from an earlier version of R.
</p>
</li>
<li><p> The class is currently defined.
</p>
</li>
<li><p> The object is consistent with the current class definition.
</p>
</li></ol>

<p>If any condition except the second fails, a warning message is
generated.
</p>
<p>Note that <code>fixPre1.8</code> currently fixes <em>only</em> the change in
class attributes.  In particular, it will not fix binary versions of
packages installed with earlier versions of R if these use
incompatible features.  Such packages must be re-installed from
source, which is the wise approach always when major version changes
occur in R.
</p>


<h3>Value</h3>

<p>The names of all the objects that were in fact re-assigned.
</p>

<hr>
<h2 id='genericFunction-class'>Generic Function Objects </h2><span id='topic+genericFunction-class'></span><span id='topic+groupGenericFunction-class'></span>

<h3>Description</h3>

<p>Generic functions (objects from or extending class
<code>genericFunction</code>) are extended function objects,
containing information used in creating and dispatching methods for
this function.  They also identify the package associated with the
function and its methods.
</p>


<h3>Objects from the Class</h3>

<p>Generic functions are created and assigned by
<code><a href="#topic+setGeneric">setGeneric</a></code> or <code><a href="#topic+setGroupGeneric">setGroupGeneric</a></code> and, indirectly, by
<code><a href="#topic+setMethod">setMethod</a></code>.
</p>
<p>As you might expect <code><a href="#topic+setGeneric">setGeneric</a></code> and
<code><a href="#topic+setGroupGeneric">setGroupGeneric</a></code> create objects of class
<code>"genericFunction"</code> and <code>"groupGenericFunction"</code> respectively.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code>, the
function definition of the generic, usually created
automatically as a call to <code><a href="base.html#topic+standardGeneric">standardGeneric</a></code>. </p>
</dd>
<dt><code>generic</code>:</dt><dd><p>Object of class <code>"character"</code>, the
name of the generic function. </p>
</dd>
<dt><code>package</code>:</dt><dd><p>Object of class <code>"character"</code>, the
name of the package to which the function definition belongs
(and <em>not</em> necessarily where the generic function is
stored). If the package is not specified explicitly in the
call to <code>setGeneric</code>, it is usually the package on which
the corresponding non-generic function exists. </p>
</dd>
<dt><code>group</code>:</dt><dd><p>Object of class <code>"list"</code>, the group or
groups to which this generic function belongs.  Empty by default. </p>
</dd>
<dt><code>valueClass</code>:</dt><dd><p>Object of class <code>"character"</code>; if
not an empty character vector, identifies one or more classes.  It is
asserted that all methods for this function return objects
from these class (or from classes that extend them). </p>
</dd>
<dt><code>signature</code>:</dt><dd><p>Object of class <code>"character"</code>, the
vector of formal argument names that can appear in the
signature of methods for this generic function.  By default,
it is all the formal arguments, except for ....  Order
matters for efficiency:  the most commonly used arguments in
specifying methods should come first. </p>
</dd>
<dt><code>default</code>:</dt><dd><p>Object of class <code>"optionalMethod"</code>
(a union of classes <code>"function"</code> and <code>"NULL"</code>), containing
the default method for this function if any.  Generated
automatically and used to initialize method dispatch. </p>
</dd>
<dt><code>skeleton</code>:</dt><dd><p>Object of class <code>"call"</code>, a slot used
internally in method dispatch.  Don't expect to use it
directly.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"function"</code>, from data part.<br />
Class <code>"OptionalMethods"</code>, by class <code>"function"</code>.<br />
Class <code>"PossibleMethod"</code>, by class <code>"function"</code>.
</p>


<h3>Methods</h3>

<p>Generic function objects are used in the creation and dispatch of
formal methods; information from the object is used to create methods
list objects and to merge or update the existing methods for this
generic.
</p>

<hr>
<h2 id='GenericFunctions'>Tools for Managing Generic Functions</h2><span id='topic+GenericFunctions'></span><span id='topic+isGeneric'></span><span id='topic+isGroup'></span><span id='topic+removeGeneric'></span><span id='topic+getGenerics'></span><span id='topic+dumpMethod'></span><span id='topic+findFunction'></span><span id='topic+dumpMethods'></span><span id='topic+removeMethods'></span><span id='topic+signature'></span><span id='topic+setReplaceMethod'></span>

<h3>Description</h3>

<p>The functions documented here manage collections of methods associated
with a generic function, as well as providing information about the
generic functions themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isGeneric(f, where, fdef, getName = FALSE)
isGroup(f, where, fdef)
removeGeneric(f, where)

dumpMethod(f, signature, file, where, def)
findFunction(f, generic = TRUE, where = topenv(parent.frame()))
dumpMethods(f, file, signature, methods, where)
signature(...)

removeMethods(f, where = topenv(parent.frame()), all = missing(where))

setReplaceMethod(f, ..., where = topenv(parent.frame()))

getGenerics(where, searchForm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenericFunctions_+3A_f">f</code></td>
<td>
<p> The character string naming the function. </p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_where">where</code></td>
<td>
<p> The environment, namespace, or search-list position
from which to search for objects.  By default, start at the
top-level environment of the calling function, typically the global
environment (i.e., use the search list), or the namespace of a
package from which the call came.  It is important to supply this
argument when calling any of these functions indirectly.  With
package namespaces, the default is likely to be wrong in such calls.</p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_signature">signature</code></td>
<td>
<p> The class signature of the relevant method.  A
signature is a named or unnamed vector of character strings.  If
named, the names must be formal argument names for the generic
function.  Signatures are matched to the arguments specified in
the signature slot of the generic function (see the Details
section of the <code><a href="#topic+setMethod">setMethod</a></code> documentation).
</p>
<p>The <code>signature</code> argument to <code>dumpMethods</code> is ignored (it
was used internally in previous implementations).</p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_file">file</code></td>
<td>
<p> The file or connection on which to dump method definitions. </p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_def">def</code></td>
<td>
<p> The function object defining the method; if omitted, the
current method definition corresponding to the signature. </p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_...">...</code></td>
<td>
<p>Named or unnamed arguments to form a signature.</p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_generic">generic</code></td>
<td>
<p>In testing or finding functions, should generic
functions be included.  Supply as <code>FALSE</code> to get only
non-generic functions.</p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_fdef">fdef</code></td>
<td>
<p>Optional, the generic function definition.
</p>
<p>Usually omitted in calls to <code>isGeneric</code></p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_getname">getName</code></td>
<td>
<p>If <code>TRUE</code>, <code>isGeneric</code> returns the name of
the generic.  By default, it returns <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_methods">methods</code></td>
<td>

<p>The methods object containing the methods to be dumped.  By default,
the methods defined for this generic (optionally on the specified
<code>where</code> location).
</p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_all">all</code></td>
<td>
<p>in <code>removeMethods</code>, logical indicating if all
(default) or only the first method found should be removed.</p>
</td></tr>
<tr><td><code id="GenericFunctions_+3A_searchform">searchForm</code></td>
<td>
<p>In <code>getGenerics</code>, if <code>TRUE</code>, the
<code>package</code> slot of the returned result is in the form used
by <code>search()</code>, otherwise as the simple package name (e.g,
<code>"package:base"</code> vs <code>"base"</code>).
</p>
</td></tr>
</table>


<h3>Summary of Functions</h3>


<dl>
<dt><code>isGeneric</code>:</dt><dd>
<p>Is there a function named <code>f</code>, and if so, is it a generic?
</p>
<p>The <code>getName</code> argument allows a function to find the name
from a function definition.  If it is <code>TRUE</code> then the name of
the generic is returned, or <code>FALSE</code> if this is not a generic
function definition.
</p>
<p>The behavior of <code>isGeneric</code> and <code><a href="#topic+getGeneric">getGeneric</a></code> for
primitive functions is slightly different.  These functions don't
exist as formal function objects (for efficiency and historical
reasons), regardless of whether methods have been defined for
them.  A call to <code>isGeneric</code> tells you whether methods have
been defined for this primitive function, anywhere in the current
search list, or in the specified position <code>where</code>.  In
contrast, a call to <code><a href="#topic+getGeneric">getGeneric</a></code> will return what the
generic for that function would be, even if no methods have been
currently defined for it.
</p>
</dd>
<dt><code>removeGeneric</code>, <code>removeMethods</code>:</dt><dd>
<p>Remove all the methods for the generic function of this
name.  In addition, <code>removeGeneric</code> removes the function
itself; <code>removeMethods</code> restores the non-generic function
which was the default method.   If there was no default method,
<code>removeMethods</code> leaves a generic function with no methods.
</p>
</dd>
<dt><code>standardGeneric</code>:</dt><dd>
<p>Dispatches a method from the current function call for the generic
function <code>f</code>.  It is an error to call
<code>standardGeneric</code> anywhere except in the body of the
corresponding generic function.
</p>
<p>Note that <code><a href="base.html#topic+standardGeneric">standardGeneric</a></code> is a primitive function in
the <span class="pkg">base</span> package
for efficiency 
reasons, but rather documented here where it belongs naturally.
</p>
</dd>
<dt><code>dumpMethod</code>:</dt><dd>
<p>Dump the method for this generic function and signature.
</p>
</dd>
<dt><code>findFunction</code>:</dt><dd>
<p>return a list of either the positions on the search list, or the
current top-level environment, on which a function object
for <code>name</code> exists.  The returned value is <em>always</em> a
list, use the first element to access the first visible version
of the function.  See the example.
</p>
<p><em>NOTE:</em> Use this rather than <code><a href="utils.html#topic+find">find</a></code> with
<code>mode="function"</code>, which is not as meaningful, and has a few
subtle bugs from its use of regular expressions.  Also,
<code>findFunction</code> works correctly in the code for a package
when attaching the package via a call to <code><a href="base.html#topic+library">library</a></code>.
</p>
</dd>
<dt><code>dumpMethods</code>:</dt><dd>
<p>Dump all the methods for this generic.
</p>
</dd>
<dt><code>signature</code>:</dt><dd>
<p>Returns a named list of classes to be matched to arguments of a
generic function.
</p>
</dd>
<dt><code>getGenerics</code>:</dt><dd><p>returns the names of the generic
functions that have methods defined on <code>where</code>; this
argument can be an environment or an index into the search
list.  By default, the whole search list is used.
</p>
<p>The methods definitions are stored with
package qualifiers; for example, methods for function
<code>"initialize"</code> might refer to two different functions
of that name, on different packages.  The package names
corresponding to the method list object are contained in the
slot <code>package</code> of the returned object.  The form of
the returned name can be plain (e.g., <code>"base"</code>), or in
the form used in the search list (<code>"package:base"</code>)
according to the value of <code>searchForm</code></p>
</dd>
</dl>



<h3>Details</h3>


<dl>
<dt><code>isGeneric</code>:</dt><dd>
<p>If the <code>fdef</code> argument is supplied, take this as the
definition of the generic, and test whether it is really a
generic, with <code>f</code> as the name of the generic.  (This argument
is not available in S-Plus.)
</p>
</dd>
<dt><code>removeGeneric</code>:</dt><dd>
<p>If <code>where</code> supplied, just remove the version on this element
of the search list; otherwise, removes the first version
encountered.
</p>
</dd>
<dt><code>standardGeneric</code>:</dt><dd>
<p>Generic functions should usually have a call to
<code>standardGeneric</code> as their entire body.  They can, however,
do any other computations as well.
</p>
<p>The usual <code>setGeneric</code> (directly or through calling
<code>setMethod</code>) creates a function with a call to
<code>standardGeneric</code>.
</p>
</dd>
<dt><code>dumpMethod</code>:</dt><dd>
<p>The resulting source file will recreate the method.
</p>
</dd>
<dt><code>findFunction</code>:</dt><dd>
<p>If <code>generic</code> is <code>FALSE</code>, ignore generic functions.
</p>
</dd>
<dt><code>dumpMethods</code>:</dt><dd>
<p>If <code>signature</code> is supplied only the methods matching this
initial signature are dumped.  (This feature is not found in
S-Plus:  don't use it if you want compatibility.)
</p>
</dd>
<dt><code>signature</code>:</dt><dd>
<p>The advantage of using <code>signature</code> is to provide a check on
which arguments you meant, as well as clearer documentation in
your method specification.  In addition, <code>signature</code> checks
that each of the elements is a single character string.
</p>
</dd>
<dt><code>removeMethods</code>:</dt><dd>
<p>Returns <code>TRUE</code> if <code>f</code> was a generic function,
<code>FALSE</code> (silently) otherwise.
</p>
<p>If there is a default method, the function will be re-assigned as
a simple function with this definition.
Otherwise, the generic function remains but with no methods (so
any call to it will generate an error).  In either case, a
following call to <code>setMethod</code> will consistently
re-establish the same generic function as before.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMethod">getMethod</a></code> (also for <code>selectMethod</code>),
<code><a href="#topic+setGeneric">setGeneric</a></code>,
<code><a href="#topic+setClass">setClass</a></code>,
<code><a href="#topic+showMethods">showMethods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats) # for lm

## get the function "myFun" -- throw an error if 0 or &gt; 1 versions visible:
findFuncStrict &lt;- function(fName) {
  allF &lt;- findFunction(fName)
  if(length(allF) == 0)
    stop("No versions of ",fName," visible")
  else if(length(allF) &gt; 1)
    stop(fName," is ambiguous: ", length(allF), " versions")
  else
    get(fName, allF[[1]])
}

try(findFuncStrict("myFun"))# Error: no version
lm &lt;- function(x) x+1
try(findFuncStrict("lm"))#    Error: 2 versions
findFuncStrict("findFuncStrict")# just 1 version
rm(lm)



## method dumping ------------------------------------

setClass("A", slots = c(a="numeric"))
setMethod("plot", "A", function(x,y,...){ cat("A meth\n") })
dumpMethod("plot","A", file="")
## Not run: 
setMethod("plot", "A",
function (x, y, ...)
{
    cat("AAAAA\n")
}
)

## End(Not run)
tmp &lt;- tempfile()
dumpMethod("plot","A", file=tmp)
## now remove, and see if we can parse the dump
stopifnot(removeMethod("plot", "A"))
source(tmp)
stopifnot(is(getMethod("plot", "A"), "MethodDefinition"))

## same with dumpMethods() :
setClass("B", contains="A")
setMethod("plot", "B", function(x,y,...){ cat("B ...\n") })
dumpMethods("plot", file=tmp)
stopifnot(removeMethod("plot", "A"),
          removeMethod("plot", "B"))
source(tmp)
stopifnot(is(getMethod("plot", "A"), "MethodDefinition"),
          is(getMethod("plot", "B"), "MethodDefinition"))
</code></pre>

<hr>
<h2 id='getClass'>Get Class Definition </h2><span id='topic+getClass'></span><span id='topic+getClassDef'></span>

<h3>Description</h3>

<p>Get the definition of a class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClass   (Class, .Force = FALSE, where)
getClassDef(Class, where, package, inherits = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClass_+3A_class">Class</code></td>
<td>
<p> the character-string name of the class, often with a
<code>"package"</code> attribute as noted below under <code>package</code>.</p>
</td></tr>
<tr><td><code id="getClass_+3A_.force">.Force</code></td>
<td>
<p> if <code>TRUE</code>, return <code>NULL</code> if the class is
undefined; otherwise, an undefined class results in an error.</p>
</td></tr>
<tr><td><code id="getClass_+3A_where">where</code></td>
<td>
<p> environment from which to begin the search for the definition; by default,
start at the top-level (global) environment and proceed through
the search list.</p>
</td></tr>
<tr><td><code id="getClass_+3A_package">package</code></td>
<td>
<p> the name or environment of the package asserted to hold the
definition.  If it is a non-empty string it is used instead of
<code>where</code>, as the first place to look for the class.
Note that the package must be loaded but need not be attached.  By
default, the package attribute of the <code>Class</code> argument is
used, if any.  There will usually be a package attribute if
<code>Class</code> comes from <code>class(x)</code> for some object.
</p>
</td></tr>
<tr><td><code id="getClass_+3A_inherits">inherits</code></td>
<td>
<p>logical; should the class definition be retrieved from
any enclosing environment and also from the cache?  If <code>FALSE</code>
only a definition in the environment <code>where</code> will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Class definitions are stored in metadata objects in a package
namespace or other environment where they are defined.  When
packages are loaded, the class definitions in the package are cached in an internal
table.  Therefore, most calls to <code>getClassDef</code> will find the
class in the cache or fail to find it at all, unless <code>inherits</code>
is <code>FALSE</code>, in which case only the environment(s) defined by
<code>package</code> or <code>where</code> are searched.
</p>
<p>The class cache allows for multiple definitions of the
same class name in separate environments, with of course the
limitation that the package attribute or package name must be
provided in the call to
</p>


<h3>Value</h3>

<p>The object defining the class. If the class definition is not found,
<code>getClassDef</code> returns <code>NULL</code>, while <code>getClass</code>, which
calls <code>getClassDef</code>, either generates an error or, if
<code>.Force</code> is <code>TRUE</code>, returns a simple definition for the
class.  The latter case is used internally, but is not typically
sensible in user code.
</p>
<p>The non-null returned value is an object of class
<code><a href="#topic+classRepresentation-class">classRepresentation</a></code>.
</p>
<p>Use functions such as <code><a href="#topic+setClass">setClass</a></code> and
<code><a href="#topic+setClassUnion">setClassUnion</a></code> to create class definitions.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><a href="#topic+classRepresentation-class">classRepresentation</a>,
<code><a href="#topic+setClass">setClass</a></code>,
<code><a href="#topic+isClass">isClass</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getClass("numeric") ## a built in class

cld &lt;- getClass("thisIsAnUndefinedClass", .Force = TRUE)
cld ## a NULL prototype
## If you are really curious:
utils::str(cld)
## Whereas these generate errors:
try(getClass("thisIsAnUndefinedClass"))
try(getClassDef("thisIsAnUndefinedClass"))
</code></pre>

<hr>
<h2 id='getMethod'>Get or Test for the Definition of a Method</h2><span id='topic+getMethod'></span><span id='topic+findMethod'></span><span id='topic+existsMethod'></span><span id='topic+selectMethod'></span><span id='topic+hasMethod'></span>

<h3>Description</h3>

<p>The function <code>selectMethod()</code> returns the method that
would be selected for a call to function <code>f</code> if the arguments had
classes as specified by <code>signature</code>.  Failing to find a method
is an error, unless argument <code>optional = TRUE</code>, in which case
<code>NULL</code> is returned.
</p>
<p>The function <code>findMethod()</code> returns a list of
environments that contain a method for the specified function and signature; by
default, these are a subset of the packages in the current search
list.  See section &ldquo;Using <code>findMethod()</code>&rdquo; for details.
</p>
<p>The function <code>getMethod()</code> returns the method corresponding to the
function and signature supplied similarly to <code>selectMethod</code>, but
without using inheritance or group generics.
</p>
<p>The functions  <code>hasMethod()</code>  and
<code>existsMethod()</code> test whether <code>selectMethod()</code> or
<code>getMethod()</code>, respectively, finds a matching method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  selectMethod(f, signature, optional = FALSE, useInherited =,
             mlist = , fdef = , verbose = , doCache = )

  findMethod(f, signature, where)

  getMethod(f, signature = character(), where, optional = FALSE,
             mlist, fdef)

  existsMethod(f, signature = character(), where)

  hasMethod(f, signature = character(), where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMethod_+3A_f">f</code></td>
<td>
<p>a generic function or the character-string name of one.</p>
</td></tr>
<tr><td><code id="getMethod_+3A_signature">signature</code></td>
<td>
<p>the signature of classes to match to the arguments
of <code>f</code>.  See the details below.</p>
</td></tr>
<tr><td><code id="getMethod_+3A_where">where</code></td>
<td>
<p>the environment in which to look for the
method(s).  By default, if the call comes from the command line, the table of methods defined in the generic
function itself is used, except for <code>findMethod</code> (see the
section below).</p>
</td></tr>
<tr><td><code id="getMethod_+3A_optional">optional</code></td>
<td>
<p>if the selection in <code>selectMethod</code> does not find
a valid method an error is generated, unless <code>optional</code> is
<code>TRUE</code>,  in which case the value returned is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getMethod_+3A_mlist">mlist</code>, <code id="getMethod_+3A_fdef">fdef</code>, <code id="getMethod_+3A_useinherited">useInherited</code>, <code id="getMethod_+3A_verbose">verbose</code>, <code id="getMethod_+3A_docache">doCache</code></td>
<td>
<p>optional arguments
to  <code>getMethod</code> and <code>selectMethod</code> for internal use.  Avoid
these: some will work as expected and others will not, and none of
them is required for normal use of the functions.  But see the
section &ldquo;Methods for <code>as()</code>&rdquo; for nonstandard inheritance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>signature</code> argument specifies classes, corresponding to
formal arguments of the generic function; to be precise, to the
<code>signature</code> slot of the generic function object.  The argument
may be a vector of strings identifying classes, and may be named or
not.  Names, if supplied, match the names of those formal arguments
included in the signature of the generic.  That signature is normally
all the arguments except ....  However, generic functions can be
specified with only a subset of the arguments permitted, or with the
signature taking the arguments in a different order.
</p>
<p>It's a good idea to name the arguments in the signature to avoid
confusion, if you're dealing with a generic that does something
special with its signature.  In any case, the elements of the
signature are matched to the formal signature by the same rules used
in matching arguments in function calls (see
<code><a href="base.html#topic+match.call">match.call</a></code>).
</p>
<p>The strings in the signature may be class names, <code>"missing"</code> or
<code>"ANY"</code>.  See <a href="#topic+Methods_Details">Methods_Details</a> for the meaning of these in method
selection.  Arguments not supplied in the signature implicitly
correspond to class <code>"ANY"</code>; in particular, giving an empty
signature means to look for the default method.
</p>
<p>A call to <code>getMethod</code> returns the method for a particular
function and signature.   The search for the method makes no use of
inheritance.
</p>
<p>The function <code>selectMethod</code> also looks for a method given the
function and signature, but makes full use of the method dispatch
mechanism; i.e., inherited methods and group generics are taken into
account just as they would be in dispatching a method for the
corresponding signature, with the one exception that conditional
inheritance is not used.  Like <code>getMethod</code>, <code>selectMethod</code>
returns <code>NULL</code> or generates an error if
the method is not found, depending on the argument <code>optional</code>.
</p>
<p>Both <code>selectMethod</code> and <code>getMethod</code> will normally use the
current version of the generic function in the R session, which has a
table of the methods obtained from all the packages loaded in the
session. Optional arguments can cause a search for the generic function from a
specified environment, but this is rarely a useful idea.  In contrast,
<code>findMethod</code> has a different default and the optional
<code>where=</code> argument may be needed.  See the  section &ldquo;Using
<code>findMethod()</code>&rdquo;.
</p>
<p>The functions <code>existsMethod</code> and <code>hasMethod</code> return
<code>TRUE</code> or <code>FALSE</code> according to whether a method is found,
the first corresponding to <code>getMethod</code> (no inheritance) and the
second to <code>selectMethod</code>.
</p>


<h3>Value</h3>

<p>The call to <code>selectMethod</code> or <code>getMethod</code> returns  the selected method, if
one is found.
(This class extends <code>function</code>, so you can use the result
directly as a function if that is what you want.)
Otherwise an error is thrown if <code>optional</code> is <code>FALSE</code>  and  <code>NULL</code> is returned if
<code>optional</code> is <code>TRUE</code>.
</p>
<p>The returned method object is a
<code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code> object, <em>except</em> that the default method for a primitive function is required to be the primitive itself.
Note therefore that the only reliable test that the search failed is
<code>is.null()</code>.
</p>
<p>The returned value of <code>findMethod</code> is a list of
environments in which a corresponding method was found; that is, a
table of methods including the one specified.
</p>


<h3>Using <code>findMethod()</code></h3>

<p>As its name suggests, this function is intended to behave like
<code><a href="utils.html#topic+find">find</a></code>, which produces a list of the packages on the
current search list which have, and have exported, the object named.
That's what <code>findMethod</code> does also, by default.  The
&ldquo;exported&rdquo; part in this case means that the package's namespace
has an <code>exportMethods</code> directive for this generic function.
</p>
<p>An important distinction is that the absence of such a directive does
not prevent methods from the package from being called once the
package is loaded.  Otherwise, the code in the package could not use
un-exported methods.
</p>
<p>So, if your question is whether loading package <code>thisPkg</code> will define a
method for this function and signature, you need to ask that question
about the namespace of the package:
</p>
<p><code>findMethod(f, signature, where = asNamespace("thisPkg"))</code>
</p>
<p>If the package did not export the method, attaching it and calling
<code>findMethod</code> with no <code>where</code> argument will not find the
method.
</p>
<p>Notice also that the length of the signature must be what the
corresponding package used.  If <code>thisPkg</code> had only methods for
one argument, only length-1 signatures will match (no trailing
<code>"ANY"</code>), even if another currently loaded package had signatures
with more arguments.
</p>


<h3>Methods for <code>as()</code></h3>

<p>The function <code><a href="#topic+setAs">setAs</a></code> allows packages to define methods for
coercing one class of objects to another class.  This works internally
by defining methods for the generic function <code><a href="#topic+coerce">coerce</a>(from,
to)</code>,
which can not be called directly.
</p>
<p>The <span class="rlang"><b>R</b></span> evaluator selects
methods for this purpose using a different form of inheritance.  While
methods can be inherited for the object being coerced, they cannot
inherit for the target class, since the result would not be a valid
object from that class.
If you want to
examine the selection procedure, you must supply the optional argument
<code>useInherited = c(TRUE, FALSE)</code> to <code>selectMethod</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer. (Section 10.6 for some details of method selection.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Methods_Details">Methods_Details</a></code> for the details of method
selection; <code><a href="#topic+GenericFunctions">GenericFunctions</a></code> for other functions
manipulating methods and generic function objects;
<code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code> for the class that represents
method definitions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>testFun &lt;-  function(x)x
setGeneric("testFun")
setMethod("testFun", "numeric", function(x)x+1)

hasMethod("testFun", "numeric") # TRUE

hasMethod("testFun", "integer") #TRUE, inherited

existsMethod("testFun", "integer") #FALSE

hasMethod("testFun") # TRUE, default method

hasMethod("testFun", "ANY")


</code></pre>

<hr>
<h2 id='getPackageName'>The Name associated with a Given Package</h2><span id='topic+getPackageName'></span><span id='topic+setPackageName'></span><span id='topic+packageSlot'></span><span id='topic+packageSlot+3C-'></span>

<h3>Description</h3>

<p>The functions below produce the package associated with a particular
environment or position on the search list, or of the package
containing a particular function.  They are primarily used to support
computations that need to differentiate objects on multiple packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPackageName(where, create = TRUE)
setPackageName(pkg, env)

packageSlot(object)
packageSlot(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPackageName_+3A_where">where</code></td>
<td>
<p>the environment or position on the search list
associated with the desired package.</p>
</td></tr>
<tr><td><code id="getPackageName_+3A_object">object</code></td>
<td>
<p>object providing a character string name, plus the
package in which this object is to be found.</p>
</td></tr>
<tr><td><code id="getPackageName_+3A_value">value</code></td>
<td>
<p>the name of the package.</p>
</td></tr>
<tr><td><code id="getPackageName_+3A_create">create</code></td>
<td>
<p>flag, should a package name be created if none can be
inferred?  If <code>TRUE</code> and no non-empty package name is found,
the current date and time are used as a package name, and a
warning is issued. The created name is stored in the environment
if that environment is not locked.</p>
</td></tr>
<tr><td><code id="getPackageName_+3A_pkg">pkg</code>, <code id="getPackageName_+3A_env">env</code></td>
<td>
<p>make the string in <code>pkg</code> the internal
package name for all computations that set class and method
definitions in environment <code>env</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package names are normally installed during loading of the package,
by the <a href="utils.html#topic+INSTALL">INSTALL</a> script or by the <code><a href="base.html#topic+library">library</a></code>
function.  (Currently, the name is stored as the object
<code>.packageName</code> but don't trust this for the future.)
</p>


<h3>Value</h3>

<p><code>getPackageName</code> returns the character-string name of the package
(without the extraneous <code>"package:"</code> found in the search list).
</p>
<p><code>packageSlot</code> returns or sets the package name slot (currently
an attribute, not a formal slot, but this may change someday).
</p>
<p><code>setPackageName</code> can be used to establish a package name in an
environment that would otherwise not have one.  This
allows you to create classes and/or methods in an arbitrary
environment, but it is usually preferable to create packages by the
standard <span class="rlang"><b>R</b></span> programming tools (<code><a href="utils.html#topic+package.skeleton">package.skeleton</a></code>, etc.)
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+search">search</a></code>, <code><a href="utils.html#topic+packageName">packageName</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## all the following usually return "base"
getPackageName(length(search()))
getPackageName(baseenv())
getPackageName(asNamespace("base"))
getPackageName("package:base")

</code></pre>

<hr>
<h2 id='hasArg'>Look for an Argument in the Call</h2><span id='topic+hasArg'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if <code>name</code> corresponds to an argument in the
call, either a formal argument to the function, or a component of
<code>...</code>, and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasArg(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasArg_+3A_name">name</code></td>
<td>
<p>The name of a potential argument, as an unquoted name or
character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression <code>hasArg(x)</code>, for example, is similar to
<code>!missing(x)</code>, with two exceptions.  First,  <code>hasArg</code> will look for
an argument named <code>x</code> in the call if <code>x</code> is not a formal
argument to the calling function, but <code>...</code> is.  Second,
<code>hasArg</code> never generates an error if given a name as an argument,
whereas <code>missing(x)</code> generates an error if <code>x</code> is not a
formal argument.
</p>


<h3>Value</h3>

<p>Always <code>TRUE</code> or <code>FALSE</code> as described above.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+missing">missing</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ftest &lt;- function(x1, ...) c(hasArg(x1), hasArg("y2"))

ftest(1) ## c(TRUE, FALSE)
ftest(1, 2)  ## c(TRUE, FALSE)
ftest(y2 = 2)   ## c(FALSE, TRUE)
ftest(y = 2)    ## c(FALSE, FALSE) (no partial matching)
ftest(y2 = 2, x = 1)  ## c(TRUE, TRUE) partial match x1
</code></pre>

<hr>
<h2 id='implicitGeneric'>Manage Implicit Versions of Generic Functions</h2><span id='topic+implicitGeneric'></span><span id='topic+setGenericImplicit'></span><span id='topic+prohibitGeneric'></span><span id='topic+registerImplicitGenerics'></span><span id='topic+implicit+20generic'></span>

<h3>Description</h3>

<p>The implicit generic mechanism stores generic versions of
functions
in a table in a package. The package does not want the current
version of the function to be a generic, however, and retains the
non-generic version.
</p>
<p>When a call to <code><a href="#topic+setMethod">setMethod</a></code> or
<code><a href="#topic+setGeneric">setGeneric</a></code> creates a generic version for one of these
functions, the object in the table is used.
This mechanism is only needed if special arguments were used to
create the generic; e.g., the <code>signature</code> or the <code>valueClass</code>
options.
</p>
<p>Function <code>implicitGeneric()</code> returns the implicit
generic version, <code>setGenericImplicit()</code> turns a generic implicit,
<code>prohibitGeneric()</code> prevents your function from being made
generic, and <code>registerImplicitGenerics()</code> saves a set of implicit
generic definitions in the cached table of the current session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implicitGeneric(name, where, generic)
setGenericImplicit(name, where, restore = TRUE)
prohibitGeneric(name, where)
registerImplicitGenerics(what, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="implicitGeneric_+3A_name">name</code></td>
<td>
<p> Character string name of the function.</p>
</td></tr>
<tr><td><code id="implicitGeneric_+3A_where">where</code></td>
<td>
<p> Package or environment in which to register the implicit
generics.  When using the functions from the top level of your own
package source, this argument should be omitted.</p>
</td></tr>
<tr><td><code id="implicitGeneric_+3A_generic">generic</code></td>
<td>
<p> Obsolete, and likely to be deprecated.</p>
</td></tr>
<tr><td><code id="implicitGeneric_+3A_restore">restore</code></td>
<td>
<p>Should the non-generic version of the function be
restored?.</p>
</td></tr>
<tr><td><code id="implicitGeneric_+3A_what">what</code></td>
<td>
<p>Optional table of
the implicit generics to register, but nearly always omitted, when
it defaults to a standard metadata name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple packages may define methods for the same function, to apply
to classes defined in that package.  Arithmetic and other operators,
<code>plot()</code> and many other basic computations are typical
examples. It's essential that all such packages write methods for
the <em>same</em> definition of the generic function.  So long as that
generic uses the default choice for signature and other parameters,
nothing needs to be done.
</p>
<p>If the generic has special properties, these need to be ensured for
all packages creating methods for it.  The simplest solution is just
to make the function generic in the package that originally owned
it.  If for some reason the owner(s) of that package are unwilling
to do this, the alternative is to define the correct generic,
save it in a special table and restore the non-generic version by
calling <code>setGenericImplicit</code>.
</p>
<p>Note that the package containing the function can define methods for the implicit generic as
well; when the implicit generic is made a real generic, those methods
will be included.
</p>
<p>The usual reason for having a
non-default implicit generic is to provide a non-default signature,
and the usual reason for <em>that</em> is to allow lazy evaluation of
some arguments.  All arguments in the signature of a
generic function must be evaluated at the time the function needs to
select a method.
In the base function <code>with()</code> in the example below, evaluation of the argument
<code>expr</code> must be delayed; therefore, it is excluded from the signature.
</p>
<p>If you want to completely prohibit anyone from turning your function
into a generic, call <code>prohibitGeneric()</code>.
</p>
<p>Function <code>implicitGeneric()</code> returns the implicit generic
version of the named function.  If there is no table of these or if
this function is not in the table, the result of a simple call
<code>setGeneric(name)</code> is returned.
</p>


<h3>Value</h3>

<p>Function <code>implicitGeneric()</code> returns the implicit generic
definition (and caches that definition the first time if it has to
construct it).
</p>
<p>The other functions exist for their side effect and return nothing
useful.
</p>


<h3>Implicit Generics for Base Functions</h3>

<p>Implicit generic versions exist for some functions in the packages
supplied in the distribution of <span class="rlang"><b>R</b></span> itself.  These are stored in the
&lsquo;methods&rsquo; package itself and will always be available.
</p>
<p>As emphasized repeatedly in the documentation,
<code><a href="#topic+setGeneric">setGeneric</a>()</code> calls for a function in  another package
should never have non-default settings for arguments such as
<code>signature</code>.
The reasoning applies specially to functions in supplied packages,
since methods for these are likely to exist in multiple packages.
A call to <code>implicitGeneric()</code> will show the generic version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setGeneric">setGeneric</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
### How we would make the function with() into a generic:

## Since the second argument, 'expr' is used literally, we want
## with() to only have "data" in the signature.

## Not run: 
setGeneric("with", signature = "data")
## Now we could predefine methods for "with" if we wanted to.

## When ready, we store the generic as implicit, and restore the
original

setGenericImplicit("with")

## End(Not run)

implicitGeneric("with")

# (This implicit generic is stored in the 'methods' package.)
</code></pre>

<hr>
<h2 id='inheritedSlotNames'>Names of Slots Inherited From a Super Class</h2><span id='topic+inheritedSlotNames'></span>

<h3>Description</h3>

<p>For a class (or class definition, see <code><a href="#topic+getClass">getClass</a></code> and
the description of class <code><a href="#topic+classRepresentation-class">classRepresentation</a></code>),
give the names which are inherited from &ldquo;above&rdquo;, i.e., super
classes, rather than by this class' definition itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inheritedSlotNames(Class, where = topenv(parent.frame()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inheritedSlotNames_+3A_class">Class</code></td>
<td>
<p>character string or
<code><a href="#topic+classRepresentation-class">classRepresentation</a></code>, i.e., resulting from
<code><a href="#topic+getClass">getClass</a></code>.</p>
</td></tr>
<tr><td><code id="inheritedSlotNames_+3A_where">where</code></td>
<td>
<p>environment, to be passed further to
<code><a href="#topic+isClass">isClass</a></code> and <code><a href="#topic+getClass">getClass</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of slot names, or <code><a href="base.html#topic+NULL">NULL</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slotNames">slotNames</a></code>, <code><a href="#topic+slot">slot</a></code>, <code><a href="#topic+setClass">setClass</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.srch &lt;- search()
library(stats4)
inheritedSlotNames("mle")

if(require("Matrix", quietly = TRUE)) withAutoprint({
  inheritedSlotNames("Matrix")       # NULL
  ## whereas
  inheritedSlotNames("sparseMatrix") # --&gt; Dim &amp; Dimnames
  ##  i.e. inherited from "Matrix" class
  cl &lt;- getClass("dgCMatrix")        # six slots, etc
  inheritedSlotNames(cl) # *all* six slots are inherited
})
## Not run: 


## detach package we've attached above:
for(n in rev(which(is.na(match(search(), .srch)))))
   try( detach(pos = n) )

## End(Not run)
</code></pre>

<hr>
<h2 id='initialize-methods'>Methods to Initialize New Objects from a Class</h2><span id='topic+initialize-methods'></span><span id='topic+initialize+2CANY-method'></span><span id='topic+initialize+2Ctraceable-method'></span><span id='topic+initialize+2Csignature-method'></span><span id='topic+initialize+2Cenvironment-method'></span><span id='topic+initialize+2C.environment-method'></span>

<h3>Description</h3>

<p>The arguments to function <code><a href="#topic+new">new</a></code> to create an object from a
particular class can be interpreted specially for that class, by the
definition of a method for function <code>initialize</code> for the class.
This documentation describes some existing methods, and also outlines
how to write new ones.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(.Object = "ANY")</code></dt><dd>
<p>The default method for <code>initialize</code> takes either named or
unnamed arguments.  Argument names must be the names of slots in
this class definition, and the corresponding arguments must be
valid objects for the slot (that is, have the same class as
specified for the slot, or some superclass of that class).  If the
object comes from a superclass, it is not coerced strictly, so
normally it will retain its current class (specifically,
<code><a href="#topic+as">as</a>(object, Class, strict = FALSE)</code>).
</p>
<p>Unnamed arguments must be objects of this class, of one of its
superclasses, or one of its subclasses (from the class, from a
class this class extends, or from a class that extends this
class). If the object is from a superclass, this normally defines
some of the slots in the object.  If the object is from a
subclass, the new object is that argument, coerced to the current
class.
</p>
<p>Unnamed arguments are processed first, in the order they appear.
Then named arguments are processed.  Therefore, explicit values
for slots always override any values inferred from superclass or
subclass arguments.
</p>
</dd>
<dt><code>signature(.Object = "traceable")</code></dt><dd>
<p>Objects of a class that extends <code>traceable</code> are used to
implement debug tracing (see class <a href="#topic+traceable-class">traceable</a> and
<code><a href="base.html#topic+trace">trace</a></code>).
</p>
<p>The <code>initialize</code> method for these classes takes special
arguments <code>def, tracer, exit, at, print</code>.  The first of these
is the object to use as the original definition (e.g., a
function).  The others correspond to the arguments to
<code><a href="base.html#topic+trace">trace</a></code>.
</p>
</dd>
<dt><code>signature(.Object = "environment")</code>, <code>signature(.Object = ".environment")</code></dt><dd>
<p>The <code>initialize</code> method for environments takes a named list
of objects to be used to initialize the environment.  Subclasses
of <code>"environment"</code> inherit an initialize method through
<code>".environment"</code>, which has the additional effect of
allocating a new environment.  If you define your own method for
such a subclass, be sure either to call the existing method via
<code><a href="#topic+callNextMethod">callNextMethod</a></code> or allocate an environment in your
method, since environments are references and are not duplicated
automatically.
</p>
</dd>
<dt><code>signature(.Object = "signature")</code></dt><dd>
<p>This is a method for internal use only.
It takes an optional <code>functionDef</code> argument to provide a
generic function with a <code>signature</code> slot to define the
argument names.  See <a href="#topic+Methods_Details">Methods_Details</a> for details.
</p>
</dd>
</dl>



<h3>Writing Initialization Methods</h3>

<p>Initialization methods provide a general mechanism corresponding to
generator functions in other languages.
</p>
<p>The arguments to <code><a href="#topic+initialize">initialize</a></code> are <code>.Object</code> and
.... Nearly always, <code>initialize</code> is called from <code>new</code>,
not directly.  The <code>.Object</code> argument is then the
prototype object from the class.
</p>
<p>Two techniques are often appropriate for <code>initialize</code> methods:
special argument names and <code>callNextMethod</code>.
</p>
<p>You may want argument names that are more natural to your users than
the (default) slot names.  These will be the formal arguments to
your method definition, in addition to <code>.Object</code> (always) and
... (optionally).  For example, the method for class
<code>"traceable"</code> documented above would be created by a call to
<code><a href="#topic+setMethod">setMethod</a></code> of the form:
</p>
<pre>    setMethod("initialize", "traceable",
      function(.Object, def, tracer, exit, at, print) { .... }
    )
</pre>
<p>In this example, no other arguments are meaningful, and the resulting
method will throw an error if other names are supplied.
</p>
<p>When your new class extends another class, you may want to call the
initialize method for this superclass (either a special method or the
default).  For example, suppose you want to define a method for your
class, with special argument <code>x</code>, but you also want users to be
able to set slots specifically.  If you want <code>x</code> to override the
slot information, the beginning of your method definition might look
something like this:
</p>
<pre>    function(.Object, x, ...) {
      Object &lt;- callNextMethod(.Object, ...)
      if(!missing(x)) { # do something with x
</pre>
<p>You could also choose to have the inherited method override, by first
interpreting <code>x</code>, and then calling the next method.
</p>

<hr>
<h2 id='Introduction'>Basic use of S4 Methods and Classes</h2><span id='topic+Introduction'></span>

<h3>Description</h3>

<p>The majority of applications using methods and classes will be in <span class="rlang"><b>R</b></span>
packages implementing new computations for an application, using new <em>classes</em>
of objects that represent the data and results.
Computations will be implemented using <em>methods</em> that implement
functional computations when one or more of the arguments is an object
from these classes.
</p>
<p>Calls to the functions <code><a href="#topic+setClass">setClass</a>()</code> define the new classes;
calls to <code><a href="#topic+setMethod">setMethod</a></code> define the methods.
These, along with ordinary <span class="rlang"><b>R</b></span> computations, are sufficient to get
started for most applications.
</p>
<p>Classes are defined in terms of the data in them and what other
classes of data they inherit from.
Section &lsquo;Defining Classes&rsquo; outlines the basic design of new classes.
</p>
<p>Methods are <span class="rlang"><b>R</b></span> functions, often implementing basic computations as
they apply to the new classes of objects.
Section &lsquo;Defining Methods&rsquo; discusses basic requirements and
special tools for defining methods.
</p>
<p>The classes discussed here are the original functional classes.
<span class="rlang"><b>R</b></span> also supports formal classes and methods similar to those in other
languages such as Python, in which methods are part of class
definitions and invoked on an object.
These are more appropriate when computations expect references to
objects that are persistent, making changes to the object over time.
See <a href="#topic+ReferenceClasses">ReferenceClasses</a> and Chapter 9 of the reference for the
choice between these and S4 classes.
</p>


<h3>Defining Classes</h3>

<p>All objects in <span class="rlang"><b>R</b></span> belong to a class; ordinary vectors and other basic
objects are built-in (<a href="#topic+builtin-class">builtin-class</a>).
A new class is defined in terms of the named <em>slots</em> that is has
and/or in terms of existing classes that it inherits from, or
<em>contains</em> (discussed in &lsquo;Class Inheritance&rsquo; below).
A call to <code><a href="#topic+setClass">setClass</a>()</code> names a new class and uses the corresponding arguments to
define it.
</p>
<p>For example, suppose we want a class of objects to represent a
collection of positions, perhaps from GPS readings.
A natural way to think of these in <span class="rlang"><b>R</b></span> would have vectors of numeric values for
latitude, longitude and altitude.
A class with three corresponding slots could be defined by:
</p>
<p><code>
Pos &lt;- setClass("Pos", slots = c(latitude = "numeric",
            longitude = "numeric", altitude = "numeric"))
</code>
</p>
<p>The value returned is a function, typically assigned as here with the
name of the class.  Calling this function returns an object from the
class; its arguments are named with the slot names.
If a function in the class had read the corresponding data, perhaps
from a CSV file or from a data base, it could return an object from
the class by:
</p>
<p><code>Pos(latitude = x, longitude = y, altitude = z)</code>
</p>
<p>The slots are accessed by the
<code><a href="base.html#topic++40">@</a></code> operator; for example, if <code>g</code> is an object from
the class, <code>g@latitude</code>.
</p>
<p>In addition to returning a generator function the call to
<code><a href="#topic+setClass">setClass</a>()</code> assigns a definition of the class in a
special metadata object in the package's namespace.
When the package is loaded into an <span class="rlang"><b>R</b></span> session, the class definition is
added to a table of known classes.
</p>
<p>To make the class and the generating function publicly available, the
package should include <code>POS</code> in <code>exportClasses()</code> and
<code>export()</code> directives in its <code>NAMESPACE</code> file:
</p>
<p><code>exportClasses(Pos); export(Pos)</code>
</p>


<h3>Defining Methods</h3>

<p>Defining methods for an <span class="rlang"><b>R</b></span> function makes that function
<em>generic</em>.
Instead of a call to the function always being carried out by the same
method, there will be several alternatives.
These are selected by matching the classes of the arguments in the call to a
table  in the generic function, indexed by classes for one or more formal arguments to the
function, known as the <em>signatures</em> for the methods.
</p>
<p>A method definition then specifies three things:  the name of the
function, the signature and the method definition itself.
The definition must be a function with the same formal arguments as
the generic.
</p>
<p>For example, a method to make a plot of an object from class
<code>"Pos"</code> could be defined by:
</p>
<p><code>setMethod("plot", c("Pos", "missing"), function(x, y, ...) {
  plotPos(x, y) })</code>
</p>
<p>This method will match a call to <code><a href="graphics.html#topic+plot">plot</a>()</code> if the first
argument is from class <code>"Pos"</code> or a subclass of that.
The second argument must be missing; only a missing argument matches
that class in the signature.
Any object will match class <code>"ANY"</code> in the corresponding position
of the signature.
</p>


<h3>Class Inheritance</h3>

<p>A class may inherit all the slots and methods of one or more existing
classes by specifying the names of the inherited classes in the <code>contains =</code> argument to
<code><a href="#topic+setClass">setClass</a>()</code>.
</p>
<p>To define a class that extends class <code>"Pos"</code> to a class
<code>"GPS"</code> with a slot for the observation times:
</p>
<p><code>GPS &lt;- setClass("GPS", slots = c(time = "POSIXt"), contains = "Pos")</code>
</p>
<p>The inherited classes may be S4 classes, S3
classes or basic data types.
S3 classes need to be identified as such by a call to
<code><a href="#topic+setOldClass">setOldClass</a>()</code>; most S3 classes in the base package and
many in the other built-in packages are already declared, as is
<code>"POSIXt"</code>.
If it had not been, the application package should contain:
</p>
<p><code>setOldClass("POSIXt")</code>
</p>
<p>Inheriting from one of the <span class="rlang"><b>R</b></span> types is special.  Objects from the new
class will have the same type.  A class
<code>Currency</code> that contains numeric data plus a slot <code>"unit"</code>
would be created by
</p>
<p><code>Currency &lt;- setClass("Currency", slots = c(unit = "character"),
  contains = "numeric")</code>
</p>
<p>Objects created from this class will have type <code>"numeric"</code> and
inherit all the builtin arithmetic and other computations for that
type.
Classes can only inherit from at most one such type; if the class does
not inherit from a type, objects from the class will have type
<code>"S4"</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>

<hr>
<h2 id='is'>Is an Object from a Class?</h2><span id='topic+is'></span><span id='topic+extends'></span>

<h3>Description</h3>

<p>Functions to test inheritance relationships between an object and a
class or between two classes (<code>extends</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is(object, class2)

extends(class1, class2, maybe = TRUE, fullInfo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="is_+3A_class1">class1</code>, <code id="is_+3A_class2">class2</code></td>
<td>

<p>character strings giving the names of each of the two classes
between which <code>is</code> relations are to be examined, or (more
efficiently) the class definition objects for the classes.</p>
</td></tr>
<tr><td><code id="is_+3A_fullinfo">fullInfo</code></td>
<td>

<p>In a call to <code>extends</code>, with <code>class2</code> missing,
<code>fullInfo</code> is a flag, which if <code>TRUE</code> causes a list of
objects of class <code><a href="#topic+SClassExtension-class">SClassExtension</a></code> to be returned, rather than
just the names of the classes.  Only the distance slot is likely to
be useful in practice; see the &lsquo;Selecting Superclasses&rsquo; section;
</p>
</td></tr>
<tr><td><code id="is_+3A_maybe">maybe</code></td>
<td>

<p>What to return for conditional inheritance.  But such
relationships are rarely used and not recommended, so this
argument should not be needed.
</p>
</td></tr>
</table>


<h3>Selecting Superclasses</h3>

<p>A call to  <code><a href="#topic+selectSuperClasses">selectSuperClasses</a>(cl)</code> returns a list of
superclasses, similarly to
<code>extends(cl)</code>.  Additional arguments restrict the class names
returned to direct superclasses and/or to non-virtual classes.
</p>
<p>Either way, programming with the result, particularly using
<code><a href="base.html#topic+sapply">sapply</a></code>, can be useful.
</p>
<p>To find superclasses with more generally defined properties, one can program
with the result returned by <code>extends</code> when called with one
class as argument.
By default, the call returns a character vector including the name of the class
itself and of all its superclasses.
Alternatively,
if <code>extends</code> is called with <code>fullInfo =
    TRUE</code>, the return value is a named list, its names being the previous
character vector.  The elements of the list corresponding to
superclasses are objects of class
<code><a href="#topic+SClassExtension-class">SClassExtension</a></code>. Of the information in these objects, one piece can be useful:
the number of generations between the classes, given by the
<code>"distance"</code> slot.
</p>
<p>Programming with the result of the call to <code>extends</code>, particularly using
<code><a href="base.html#topic+sapply">sapply</a></code>, can select superclasses.
The programming technique is to define a test function that returns
<code>TRUE</code> for superclasses or relationships obeying some
requirement. For example, to find only next-to-direct superclasses,
use this function with the list of extension objects:
</p>
<p><code>function(what) is(what, "SClassExtension") &amp;&amp; what@distance == 2</code>
</p>
<p>or, to find only superclasses from <code>"myPkg"</code>, use this function
with the simple vector of names:
</p>
<p><code>function(what) getClassDef(what)@package == "myPkg"</code>
</p>
<p>Giving such functions as an argument to <code><a href="base.html#topic+sapply">sapply</a></code> called on the output of
<code>extends</code> allows you to find
superclasses with desired properties.  See the examples below.
</p>
<p>Note that the function using extension objects must test the class of its argument since,
unfortunately for this purpose, the list returned by <code>extends</code> includes
<code>class1</code> itself, as the object <code>TRUE</code>.
</p>


<h3>Note</h3>

<p>Prior to <span class="rlang"><b>R</b></span> 4.2.0 the code used the first elements of <code>class1</code>
and <code>class2</code>, silently,  These are now required to be length-one
character vectors.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p>Although <code><a href="base.html#topic+inherits">inherits</a></code> is defined for S3 classes, it has
been modified so that the result returned is nearly always equivalent to
<code>is</code>, both for S4 and non-S4 objects. Since it is implemented
in C, it is somewhat faster.
The only non-equivalences arise from use of <code><a href="#topic+setIs">setIs</a></code>,
which should rarely be encountered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## this example can be run if package XRPython from CRAN is installed.
supers &lt;- extends("PythonInterface")
## find all the superclasses from package XR
fromXR &lt;- sapply(supers,
    function(what) getClassDef(what)@package == "XR")
## print them
supers[fromXR]

## find all the superclasses at distance 2
superRelations &lt;- extends("PythonInterface", fullInfo = TRUE)
dist2 &lt;- sapply(superRelations,
    function(what) is(what, "SClassExtension") &amp;&amp; what@distance == 2)
## print them
names(superRelations)[dist2]


## End(Not run)
</code></pre>

<hr>
<h2 id='isSealedMethod'> Check for a Sealed Method or Class </h2><span id='topic+isSealedMethod'></span><span id='topic+isSealedClass'></span>

<h3>Description</h3>

<p>These functions check for either a method or a class that has been
<em>sealed</em> when it was defined, and which therefore cannot be
re-defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSealedMethod(f, signature, fdef, where)
isSealedClass(Class, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSealedMethod_+3A_f">f</code></td>
<td>
<p> The quoted name of the generic function. </p>
</td></tr>
<tr><td><code id="isSealedMethod_+3A_signature">signature</code></td>
<td>
<p> The class names in the method's signature, as
they would be supplied to <code><a href="#topic+setMethod">setMethod</a></code>. </p>
</td></tr>
<tr><td><code id="isSealedMethod_+3A_fdef">fdef</code></td>
<td>
<p> Optional, and usually omitted:  the generic function
definition for <code>f</code>. </p>
</td></tr>
<tr><td><code id="isSealedMethod_+3A_class">Class</code></td>
<td>
<p>The quoted name of the class.</p>
</td></tr>
<tr><td><code id="isSealedMethod_+3A_where">where</code></td>
<td>
<p>where to search for the method or class definition.  By
default, searches from the top environment of the call to
<code>isSealedMethod</code> or <code>isSealedClass</code>, typically the
global environment or the namespace of a package containing a call
to one of the functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <span class="rlang"><b>R</b></span> implementation of classes and methods, it is possible to
seal the definition of either a class or a method.  The basic
classes (numeric and other types of vectors, matrix and array data)
are sealed.  So also are the methods for the primitive functions on
those data types.  The effect is that programmers cannot re-define
the meaning of these basic data types and computations.  More
precisely, for primitive functions that depend on only one data
argument, methods cannot be specified for basic classes.  For
functions (such as the arithmetic operators) that depend on two
arguments, methods can be specified if <em>one</em> of those arguments
is a basic class, but not if both are.
</p>
<p>Programmers can seal other class and method definitions by using the
<code>sealed</code> argument to <code><a href="#topic+setClass">setClass</a></code> or <code><a href="#topic+setMethod">setMethod</a></code>.
</p>


<h3>Value</h3>

<p>The functions return <code>FALSE</code> if the method or class is not
sealed (including the case that it is not defined); <code>TRUE</code> if
it is.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## these are both TRUE
isSealedMethod("+", c("numeric", "character"))
isSealedClass("matrix")

setClass("track", slots = c(x="numeric", y="numeric"))
## but this is FALSE
isSealedClass("track")
## and so is this
isSealedClass("A Name for an undefined Class")
## and so are these, because only one of the two arguments is basic
isSealedMethod("+", c("track", "numeric"))
isSealedMethod("+", c("numeric", "track"))


</code></pre>

<hr>
<h2 id='language-class'>Classes to Represent Unevaluated Language Objects</h2><span id='topic+language-class'></span><span id='topic++28-class'></span><span id='topic++3C--class'></span><span id='topic+call-class'></span><span id='topic+for-class'></span><span id='topic+if-class'></span><span id='topic+repeat-class'></span><span id='topic+while-class'></span><span id='topic+name-class'></span><span id='topic++7B-class'></span>

<h3>Description</h3>

<p>  The virtual class <code>"language"</code> and the specific
classes that extend it represent unevaluated objects, as produced for
example by the parser or by functions such as <code><a href="base.html#topic+quote">quote</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>### each of these classes corresponds to an unevaluated object
### in the S language.
### The class name can appear in method signatures,
### and in a few other contexts (such as some calls to as()).

"("
"&lt;-"
"call"
"for"
"if"
"repeat"
"while"
"name"
"{"

### Each of the classes above extends the virtual class
"language"
</code></pre>


<h3>Objects from the Class</h3>

<p><code>"language"</code> is a virtual class; no objects may be created from
it.
</p>
<p>Objects from the other classes can be generated by a call to
<code>new(Class, ...)</code>, where <code>Class</code> is the quoted class name, and
the ... arguments are either empty or a <em>single</em> object that is
from this class (or an extension).
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "ANY", to = "call")</code>.  A method
exists for <code>as(object, "call")</code>, calling <code>as.call()</code>. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("language")

is( quote(sin(x)) ) # "call"  "language"

(ff &lt;- new("if"))  ; is(ff) # "if" "language"
(ff &lt;- new("for")) ; is(ff) # "for" "language"
</code></pre>

<hr>
<h2 id='languageEl'>Elements of Language Objects</h2><span id='topic+languageEl'></span><span id='topic+languageEl+3C-'></span><span id='topic+isGrammarSymbol'></span>

<h3>Description</h3>

<p>Internal routines to support some operations on language objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>languageEl(object, which)
languageEl(object, which) &lt;- value

isGrammarSymbol(symbol)
</code></pre>


<h3>Summary of Functions</h3>


<dl>
<dt><code>languageEl</code>:</dt><dd>
<p>extract an element of a language object, consistently for
different kinds of objects.
</p>
<p>The 1st., etc. elements of a function are the corresponding formal
arguments, with the default expression if any as value.
</p>
<p>The first element of a call is the name or the function object
being called.
</p>
<p>The 2nd, 3rd, etc. elements are the 1st, 2nd, etc. arguments
expressions.  Note that the form of the extracted name is
different for R and S-Plus.  When the name (the first element) of
a call is replaced, the <code>languageEl</code> replacement function coerces a
character string to the internal form for each system.
</p>
<p>The 1st, 2nd, 3rd elements of an <code>if</code> expression are the
test, first, and second branch.
</p>
<p>The 1st element of a <code>for</code> object is the name (symbol) being
used in the loop, the second is the expression for the range of
the loop, the third is the body of the loop.
</p>
<p>The first element of a <code>while</code> object is the loop test, and
the second the body of the loop.
</p>
</dd>
<dt><code>isGrammarSymbol</code>:</dt><dd>
<p>Checks whether the symbol is part of the grammar.
Don't use this function directly.
</p>
</dd>
</dl>


<hr>
<h2 id='LinearMethodsList-class'>Class <code>"LinearMethodsList"</code></h2><span id='topic+LinearMethodsList-class'></span>

<h3>Description</h3>

<p>A version of methods lists that has been &lsquo;linearized&rsquo;
for producing summary information.  The actual objects from class
<code>"MethodsList"</code> used for method dispatch are defined recursively
over the arguments involved.
</p>


<h3>Objects from the Class</h3>

<p>The function <code><a href="#topic+linearizeMlist">linearizeMlist</a></code> converts an ordinary methods
list object into the linearized form.
</p>


<h3>Slots</h3>


<dl>
<dt><code>methods</code>:</dt><dd><p>Object of class <code>"list"</code>, the method
definitions.</p>
</dd>
<dt><code>arguments</code>:</dt><dd><p>Object of class <code>"list"</code>, the
corresponding formal arguments, namely as many of the arguments
in the signature of the generic function as are active in the
relevant method table. </p>
</dd>
<dt><code>classes</code>:</dt><dd><p>Object of class <code>"list"</code>, the
corresponding classes in the signatures. </p>
</dd>
<dt><code>generic</code>:</dt><dd><p>Object of class <code>"genericFunction"</code>;
the generic function to which the methods correspond. </p>
</dd>
</dl>



<h3>Future Note</h3>

<p>The current version of <code>linearizeMlist</code> does not take advantage of
the <code>MethodDefinition</code> class, and therefore does more work for less
effect than it could.  In particular, we may move to redefine both the
function and the class to take advantage of the stored signatures.
Don't write code depending precisely on the present form, although all
the current information will be obtainable in the future.
</p>


<h3>See Also</h3>

<p> Function <code><a href="#topic+linearizeMlist">linearizeMlist</a></code> for the computation,
and class <code><a href="#topic+MethodsList-class">MethodsList</a></code> for the original, recursive
form.
</p>

<hr>
<h2 id='LocalReferenceClasses'>Localized Objects based on Reference Classes</h2><span id='topic+LocalReferenceClasses'></span><span id='topic+localRefClass-class'></span><span id='topic++24+3C-+2ClocalRefClass-method'></span>

<h3>Description</h3>

<p>Local reference classes are modified <a href="#topic+ReferenceClasses">ReferenceClasses</a> that
isolate the objects to the local frame.  Therefore, they do <em>not</em>
propagate changes back to the calling environment.   At the same time,
they use the reference field semantics locally, avoiding the automatic
duplication applied to standard <span class="rlang"><b>R</b></span> objects.
</p>
<p>The current implementation has no special construction.  To create a
local reference class, call <code><a href="#topic+setRefClass">setRefClass</a>()</code> with a
<code>contains=</code> argument that includes <code>"localRefClass"</code>.  See
the example below.
</p>
<p>Local reference classes operate essentially as do regular, functional
classes in <span class="rlang"><b>R</b></span>; that is, changes are made by assignment and take place
in the local frame.
The essential difference is that replacement operations (like the
change to the <code>twiddle</code> field in the example) do not cause
duplication of the entire object, as would be the case for a formal
class or for data with attributes or in a named list.
The purpose is to allow large objects in some fields that are not
changed along with potentially frequent changes to other fields, but
without copying the large fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRefClass(Class, fields = , contains = c("localRefClass",....),
     methods =, where =, ...)
</code></pre>


<h3>Details</h3>

<p>Localization of objects is only partially automated in the current implementation.
Replacement expressions using the <code>$&lt;-</code> operator are safe. 
</p>
<p>However, if reference methods for the class themselves modify fields,
using <code>&lt;&lt;-</code>, for example, then 
one must ensure that the object is local to the relevant frame before
any such method is called.
Otherwise, standard reference class behavior still prevails.
</p>
<p>There are two ways to ensure locality.  The direct way is to invoke
the special
method <code>x$ensureLocal()</code> on the object.
The other way is to modify a field explicitly by <code>x$field &lt;- ...</code>
It's
only necessary that  one or the other of these happens
once for each object, in order to trigger the shallow copy that
provides locality for the references.  In the example below, we show
both mechanisms.
</p>
<p>However it's done, localization must occur
<em>before</em> any methods make changes.  (Eventually, some use of code
tools should at least largely automate this process, although it may
be difficult to guarantee success under arbitrary circumstances.)
</p>


<h3>Author(s)</h3>

<p>John Chambers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## class "myIter" has a BigData field for the real (big) data
## and a "twiddle" field for some parameters that it twiddles
## ( for some reason)

myIter &lt;- setRefClass("myIter", contains = "localRefClass",
  fields = list(BigData = "numeric", twiddle = "numeric"))

tw &lt;- rnorm(3)
x1 &lt;- myIter(BigData = rnorm(1000), twiddle = tw) # OK, not REALLY big

twiddler &lt;- function(x, n) {
  x$ensureLocal() # see the Details.  Not really needed in this example
  for(i in seq_len(n)) {
      x$twiddle &lt;- x$twiddle + rnorm(length(x$twiddle))
      ## then do something ....
      ## Snooping in gdb, etc will show that x$BigData is not copied
  }
  return(x)
}

x2 &lt;- twiddler(x1, 10)

stopifnot(identical(x1$twiddle, tw), !identical(x1$twiddle, x2$twiddle))

</code></pre>

<hr>
<h2 id='makeClassRepresentation'>Create a Class Definition</h2><span id='topic+makeClassRepresentation'></span>

<h3>Description</h3>

<p>Constructs an object of class <code><a href="#topic+classRepresentation-class">classRepresentation</a></code>
to describe a particular class.  Mostly a utility function, but you can
call it to create a class definition without assigning it, as
<code><a href="#topic+setClass">setClass</a></code> would do.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClassRepresentation(name, slots=list(), superClasses=character(),
                        prototype=NULL, package, validity, access,
                        version, sealed, virtual=NA, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClassRepresentation_+3A_name">name</code></td>
<td>
<p>character string name for the class</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_slots">slots</code></td>
<td>
<p>named list of slot classes as would be supplied to
<code>setClass</code>, but <em>without</em> the unnamed arguments for
<code>superClasses</code> if any.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_superclasses">superClasses</code></td>
<td>
<p>what classes does this class extend</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_prototype">prototype</code></td>
<td>
<p>an object providing the default data for the class,
e.g., the result of a call to <code><a href="#topic+prototype">prototype</a></code>.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_package">package</code></td>
<td>
<p>The character string name for the package in which
the class will be stored; see <code><a href="#topic+getPackageName">getPackageName</a></code>.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_validity">validity</code></td>
<td>
<p>Optional validity method.  See
<code><a href="#topic+validObject">validObject</a></code>, and the discussion of validity methods in
the reference.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_access">access</code></td>
<td>
<p>Access information.  Not currently used.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_version">version</code></td>
<td>
<p>Optional version key for version control.  Currently
generated, but not used.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_sealed">sealed</code></td>
<td>
<p>Is the class sealed? See <code><a href="#topic+setClass">setClass</a></code>.</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_virtual">virtual</code></td>
<td>
<p>Is this known to be a virtual class?</p>
</td></tr>
<tr><td><code id="makeClassRepresentation_+3A_where">where</code></td>
<td>
<p>The environment from which to look for class
definitions needed (e.g., for slots or superclasses). See the
discussion of this argument under <a href="#topic+GenericFunctions">GenericFunctions</a>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setClass">setClass</a></code>
</p>

<hr>
<h2 id='method.skeleton'>Create a Skeleton File for a New Method</h2><span id='topic+method.skeleton'></span>

<h3>Description</h3>

<p>This function writes a source file containing a call to
<code><a href="#topic+setMethod">setMethod</a></code> to define a method for the generic function
and signature supplied.  By default the method definition is in line
in the call, but can be made an external (previously assigned) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method.skeleton(generic, signature, file, external = FALSE, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method.skeleton_+3A_generic">generic</code></td>
<td>
<p>the character string name of the generic function, or
the generic function itself.  In the first case, the function
need not currently be a generic, as it would not for the
resulting call to <code><a href="#topic+setMethod">setMethod</a></code>.</p>
</td></tr>
<tr><td><code id="method.skeleton_+3A_signature">signature</code></td>
<td>
<p>the method signature, as it would be given to <code><a href="#topic+setMethod">setMethod</a></code></p>
</td></tr>
<tr><td><code id="method.skeleton_+3A_file">file</code></td>
<td>
<p>a character string name for the output file, or a
writable connection.  By default the generic function name and
the classes in the signature are concatenated, with separating
underscore characters.  The file name should normally end in <code>".R"</code>.
</p>
<p>To write multiple method skeletons to one file, open the file
connection first and then pass it to <code>method.skeleton()</code> in
multiple calls.</p>
</td></tr>
<tr><td><code id="method.skeleton_+3A_external">external</code></td>
<td>
<p>flag to control whether the function definition for
the method should be a separate external object assigned in the
source file, or included in line in the call to
<code><a href="#topic+setMethod">setMethod</a></code>.
If supplied as a character string, this will be used as the name
for the external function; by default the name concatenates the
generic and signature names, with separating underscores.</p>
</td></tr>
<tr><td><code id="method.skeleton_+3A_where">where</code></td>
<td>
<p>The environment in which to look for the function; by default,
the top-level environment of the call to <code>method.skeleton</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>file</code> argument, invisibly, but the function is used for its side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setMethod">setMethod</a></code>, <code><a href="utils.html#topic+package.skeleton">package.skeleton</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
setClass("track", slots = c(x ="numeric", y="numeric"))
method.skeleton("show", "track")            ## writes show_track.R
method.skeleton("Ops", c("track", "track")) ## writes "Ops_track_track.R"

## write multiple method skeletons to one file
con &lt;- file("./Math_track.R", "w")
method.skeleton("Math", "track", con)
method.skeleton("exp", "track", con)
method.skeleton("log", "track", con)
close(con)

</code></pre>

<hr>
<h2 id='MethodDefinition-class'>Classes to Represent Method Definitions</h2><span id='topic+MethodDefinition-class'></span><span id='topic+SealedMethodDefinition-class'></span>

<h3>Description</h3>

<p>These classes extend the basic class <code>"function"</code> when
functions are to be stored and used as method definitions.
</p>


<h3>Details</h3>

<p>Method definition objects are functions with additional information
defining how the function is being used as a method.  The
<code>target</code> slot is the class signature for which the method will
be dispatched, and the <code>defined</code> slot the signature for which
the method was originally specified (that is, the one that appeared
in some call to <code><a href="#topic+setMethod">setMethod</a></code>).
</p>


<h3>Objects from the Class</h3>

<p>The action of setting a method by a call to <code><a href="#topic+setMethod">setMethod</a></code> creates an object of this class.  It's
unwise to create them directly.
</p>
<p>The class <code>"SealedMethodDefinition"</code> is created by a call to
<code><a href="#topic+setMethod">setMethod</a></code> with argument <code>sealed = TRUE</code>.  It has
the same representation as <code>"MethodDefinition"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code>; the data
part of the definition. </p>
</dd>
<dt><code>target</code>:</dt><dd><p>Object of class <code>"signature"</code>; the
signature for which the method was wanted. </p>
</dd>
<dt><code>defined</code>:</dt><dd><p>Object of class <code>"signature"</code>; the
signature for which a method was found.  If the method was
inherited, this will not be identical to <code>target</code>. </p>
</dd>
<dt><code>generic</code>:</dt><dd><p>Object of class <code>"character"</code>; the function
for which the method was created. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"function"</code>, from data part.<br />
Class <code>"PossibleMethod"</code>, directly.<br />
Class <code>"OptionalMethods"</code>, by class <code>"function"</code>.
</p>


<h3>See Also</h3>

<p>class <code><a href="#topic+MethodsList-class">MethodsList</a></code> for the objects
defining sets of methods associated with a particular generic
function.  The individual method definitions stored in these objects
are from class <code>MethodDefinition</code>, or an extension.
Class <code><a href="#topic+MethodWithNext-class">MethodWithNext</a></code> for an extension used by
<code><a href="#topic+callNextMethod">callNextMethod</a></code>.
</p>

<hr>
<h2 id='Methods'>S4 Class Documentation</h2><span id='topic+Methods'></span>

<h3>Description</h3>

<p>You have navigated to an old link to documentation of S4 methods.
</p>
<p>For basic use of classes and methods, see <a href="#topic+Introduction">Introduction</a>; to
create new method definitions, see <code><a href="#topic+setMethod">setMethod</a></code>; for
technical details on S4 methods, see <a href="#topic+Methods_Details">Methods_Details</a>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>

<hr>
<h2 id='Methods_Details'>General Information on Methods</h2><span id='topic+Methods_Details'></span>

<h3>Description</h3>

<p>This documentation covers some general topics on how methods
work and how the <span class="pkg">methods</span> package interacts with the rest of <span class="rlang"><b>R</b></span>.  The
information is usually not needed to get started with methods and
classes, but may be helpful for moderately ambitious projects, or when
something doesn't work as expected.
</p>
<p>For additional information  see documentation for
the important steps: (<code><a href="#topic+setMethod">setMethod</a>()</code>,
<code><a href="#topic+setClass">setClass</a>()</code> and <code><a href="#topic+setGeneric">setGeneric</a>()</code>). Also
<code><a href="#topic+Methods_for_Nongenerics">Methods_for_Nongenerics</a></code> on defining formal methods for
functions  that are not currently generic functions;
<a href="#topic+Methods_for_S3">Methods_for_S3</a> for the relation to S3 classes and methods;
<code><a href="#topic+Classes_Details">Classes_Details</a></code> for class definitions and
Chapters 9 and 10 of the reference.
</p>


<h3>How Methods Work</h3>

<p>A call to a generic function selects a method matching the actual
arguments in the call. The body of the method is evaluated in the
frame of the call to the generic function.
A generic function is identified by its name and by the package to
which it correspond.  Unlike ordinary functions, the generic has a
slot that specifies its package.
</p>
<p>In an <span class="rlang"><b>R</b></span> session, there is one version of each such generic,
regardless of where the call to that generic originated, and
the generic function has a table of all the methods currently
available for it; that is, all the methods
in packages currently loaded into the session.
</p>
<p>Methods are frequently defined for functions that are non-generic in
their original package,.
for example, for function <code>plot()</code> in
package <span class="pkg">graphics</span>.
An identical version of the corresponding generic function may exist
in several packages.  All methods will be dispatched consistently
from the <span class="rlang"><b>R</b></span> session.
</p>
<p>Each <span class="rlang"><b>R</b></span> package with a call to <code><a href="#topic+setMethod">setMethod</a></code> in its source code
will include  a methods metadata object for that generic.
When the package is loaded into an <span class="rlang"><b>R</b></span> session, the methods for each
generic function are <em>cached</em>, that is, added to the
environment of the generic function.  This merged table of methods is used to
dispatch or select methods from the generic, using class inheritance
and possibly group generic functions (see
<code><a href="#topic+GroupGenericFunctions">GroupGenericFunctions</a></code>) to find an applicable method.
See the &ldquo;Method Selection and Dispatch&rdquo; section below.
The caching computations ensure that only one version of each
generic function is visible globally; although different attached
packages may contain a copy of the generic function, these behave
identically with respect to method selection.
</p>
<p>In contrast, it is possible for the same function name to refer to
more than one generic function, when these have different
<code>package</code> slots.  In the latter case, <span class="rlang"><b>R</b></span> considers the
functions unrelated:  A generic function is defined by the
combination of name and package.  See the &ldquo;Generic Functions&rdquo;
section below.
</p>
<p>The methods for a generic are stored according to the
corresponding <code>signature</code> in the call to <code><a href="#topic+setMethod">setMethod</a></code>
that defined  the method.  The signature associates one
class name with each of a subset of the formal arguments to the
generic function.  Which formal arguments are available, and the
order in which they appear, are determined by the <code>"signature"</code>
slot of the generic function itself.  By default, the signature of the
generic consists of all the formal arguments except ..., in the
order they appear in the function definition.
</p>
<p>Trailing arguments in the signature of the generic will be <em>inactive</em>  if no
method has yet been specified that included those arguments in its signature.
Inactive arguments are not needed or used in labeling the cached
methods.  (The distinction does not change which methods are
dispatched, but ignoring inactive arguments improves the
efficiency of dispatch.)
</p>
<p>All arguments in the signature of the generic function will be evaluated when the
function is called, rather than using lazy
evaluation.  Therefore, it's important to <em>exclude</em>
from the signature any arguments that need to be dealt with
symbolically (such as the <code>expr</code> argument to function
<code><a href="base.html#topic+with">with</a></code>).  Note that only actual arguments are
evaluated, not default expressions.
A missing argument enters into the method selection as class
<code>"missing"</code>.
</p>
<p>The cached methods are stored in an
environment object.  The names used for assignment are a
concatenation of the class names for the active arguments in the method signature.
</p>


<h3>Method Selection: Details</h3>

<p>When a call to a generic function is evaluated, a method is selected corresponding
to the classes of the actual arguments in the signature.
First, the cached methods table is searched for an  exact match;
that is, a method stored under the signature defined by
the string value of <code>class(x)</code> for each non-missing
argument, and <code>"missing"</code> for each missing argument.
If no method is found directly for the actual arguments in a call to a
generic function, an attempt is made to match the available methods to
the arguments by using the superclass information about the actual
classes.
A method found by this search is cached
in the generic function so that future calls with the same argument classes will
not require repeating the search.  In any likely application, the
search for inherited methods will be a negligible overhead.
</p>
<p>Each class definition may include a list of  one or more direct
<em>superclasses</em> of the new class.
The simplest and most common specification is by the <code>contains=</code> argument in
the  call to <code><a href="#topic+setClass">setClass</a></code>.
Each class named in this argument is a superclass of the new class.
A class will also have as a direct superclass any class union to which
it is a member.
Class unions are created by
a call to <code><a href="#topic+setClassUnion">setClassUnion</a></code>.
Additional members can be added to the union by a simple call to
<code><a href="#topic+setIs">setIs</a></code>.
Superclasses specified by either mechanism are the <em>direct</em> superclasses.
</p>
<p>Inheritance specified in either of these forms is <em>simple</em> in the
sense that all the information needed for the superclass is asserted
to be directly available from the object.
<span class="rlang"><b>R</b></span> inherited from S a more general form of inheritance in which
inheritance may require some transformation or be conditional on a
test.
This more general form has not proved to be useful in general
practical situations.   Since it also adds some computational costs
non-simple inheritance is not recommended.  See <code><a href="#topic+setIs">setIs</a></code>
for the general version.
</p>
<p>The direct superclasses themselves may
have  direct superclasses and
similarly through further generations.  Putting all this information together produces
the full list of superclasses for this class.
The superclass list is included in the definition of the class that is
cached during the <span class="rlang"><b>R</b></span> session.
The <em>distance</em> between the two classes is defined to be the
number of generations:
<code>1</code> for direct superclasses (regardless of which mechanism
defined them), then <code>2</code> for the direct superclasses of those
classes, and so on.
To see all the superclasses, with their distance, print the class
definition by calling <code><a href="#topic+getClass">getClass</a></code>.
In addition, any class implicitly has class <code>"ANY"</code> as a superclass.  The
distance to <code>"ANY"</code> is treated as larger than the distance to any
actual class.
The special class <code>"missing"</code> corresponding to missing arguments
has only <code>"ANY"</code> as a superclass, while <code>"ANY"</code> has no
superclasses.
</p>
<p>When a method is to be selected by inheritance, a search is made in
the table for all methods corresponding to a combination of
either the direct class or one of its superclasses, for each argument
in the active signature.
For an example, suppose there is only one argument in the signature and that the class of
the corresponding object was <code>"dgeMatrix"</code> (from the recommended package
<code>Matrix</code>).
This class has (currently) three direct superclasses and through these
additional superclasses at distances 2 through 4.
A method that had been defined for any of these classes or for class
<code>"ANY"</code> (the default method) would be eligible.
Methods for the shortest difference are preferred.
If there is only one best method in this sense, method selection is unambiguous.
</p>
<p>When there are multiple arguments in the signature, each argument will
generate a similar  list of inherited classes.
The possible matches are now all the combinations of classes from each
argument (think of the function <code>outer</code> generating an array of
all possible combinations).
The search now finds all the methods matching any of this combination
of classes.
For each argument, the distance to the superclass defines which
method(s) are preferred for that argument.
A method is considered best for selection if it is among the best
(i.e., has the least distance) for
each argument.
</p>
<p>The end result is that zero, one or more methods may be &ldquo;best&rdquo;.
If one, this method is selected and cached in the table of methods.
If there is more than one best match, the selection is ambiguous and a message is
printed noting which method was selected (the first method
lexicographically in the ordering) and what other methods could have
been selected.
Since the ambiguity is usually nothing the end user could control,
this is not a warning.
Package authors should examine their package for possible ambiguous
inheritance by calling <code><a href="#topic+testInheritedMethods">testInheritedMethods</a></code>.
</p>
<p>Cached inherited selections are
not themselves used in future inheritance searches, since that could result
in invalid selections.
If you want inheritance computations to be done again (for example,
because a newly loaded package has a more direct method than one
that has already been used in this session), call
<code><a href="#topic+resetGeneric">resetGeneric</a></code>.  Because classes and methods involving
them tend to come from the same package, the current implementation
does not reset all generics every time a new package is loaded.
</p>
<p>Besides being initiated through calls to the generic function, method
selection can be done explicitly by calling the function
<code><a href="#topic+selectMethod">selectMethod</a></code>.
Note that some computations may use this function directly, with
optional arguments.
The prime example is the use of <code><a href="#topic+coerce">coerce</a>()</code> methods by
function <code><a href="#topic+as">as</a>()</code>.
There has been some confusion from comparing coerce methods to a call
to <code><a href="#topic+selectMethod">selectMethod</a></code> with other options.
</p>


<h3>Method Evaluation: Details</h3>

<p>Once a method has been selected, the evaluator creates a new context
in which a call to the method is evaluated.
The context is initialized with the arguments from the call to the
generic function.
These arguments are not rematched.  All the arguments in the signature
of the generic will have been evaluated (including any that are
currently inactive); arguments that are not in the signature will obey
the usual lazy evaluation rules of the language.
If an argument was missing in the call, its default expression if any
will <em>not</em> have been evaluated, since method dispatch always uses
class <code>missing</code> for such arguments.
</p>
<p>A call to a generic function therefore has two contexts:  one for the
function and a second for the method.
The argument objects will be copied to the second context, but not any
local objects created in a nonstandard generic function.
The other important distinction is that the parent
(&ldquo;enclosing&rdquo;) environment of the second context is the environment
of the method as a function, so that all <span class="rlang"><b>R</b></span> programming techniques
using such environments apply to method definitions as ordinary functions.
</p>
<p>For further discussion of method selection and dispatch,  see the
references in the sections indicated.
</p>


<h3>Generic Functions</h3>

<p>In principle, a generic function could be any function that evaluates
a call to <code>standardGeneric()</code>, the internal function that selects
a method and evaluates a call to  the selected method.  In practice,
generic functions are special objects that in addition to being from a
subclass of class <code>"function"</code> also extend the class
<code><a href="#topic+genericFunction-class">genericFunction</a></code>.  Such objects have slots to define
information needed to deal with their methods.  They also have
specialized environments, containing the tables used in method
selection.
</p>
<p>The slots <code>"generic"</code> and  <code>"package"</code> in the object are the
character string names of the generic function itself and of the
package from which the  function is defined.
As with classes, generic functions are uniquely defined in <span class="rlang"><b>R</b></span> by the
combination of the two names.
There can be generic functions of the same name associated with
different packages (although inevitably keeping such functions cleanly
distinguished is not always easy).
On the other hand, <span class="rlang"><b>R</b></span> will enforce that only one definition of a
generic function can be associated with a particular combination of
function and package name, in the current session or other active
version of <span class="rlang"><b>R</b></span>.
</p>
<p>Tables of methods for a particular generic function, in this sense,
will often be spread over several other packages.
The total set of methods for a given generic function may change
during a session, as additional packages are loaded.
Each table must be consistent in the signature assumed for the generic
function.
</p>
<p><span class="rlang"><b>R</b></span> distinguishes <em>standard</em> and <em>nonstandard</em> generic
functions, with the former having a function body that does nothing
but dispatch a method.
For the most part, the distinction is just one of simplicity:  knowing
that a generic function only dispatches a method call allows some
efficiencies and also removes some uncertainties.
</p>
<p>In most cases, the generic function is the visible function
corresponding to that name, in the corresponding package.
There are two exceptions, <em>implicit</em> generic
functions and the special computations required to deal with <span class="rlang"><b>R</b></span>'s
<em>primitive</em> functions.
Packages can contain a table of implicit generic versions of functions
in the package, if the package wishes to leave a function non-generic
but to constrain what the function would be like if it were generic.
Such implicit generic functions are created during the installation of
the package, essentially by defining the generic function and
possibly methods for it, and then reverting the function to its
non-generic form. (See <a href="#topic+implicitGeneric">implicitGeneric</a> for how this is done.)
The mechanism is mainly used for functions in the older packages in
<span class="rlang"><b>R</b></span>, which may prefer to ignore S4 methods.
Even in this case, the actual mechanism is only needed if something
special has to be specified.
All functions have a corresponding implicit generic version defined
automatically (an implicit, implicit generic function one might say).
This function is a standard generic with the same arguments as the
non-generic function, with the non-generic version as the default (and only)
method, and with the generic signature being all the formal arguments
except ....
</p>
<p>The implicit generic mechanism is needed only to override some aspect
of the default definition.
One reason to do so would be to remove some arguments from the
signature.
Arguments that may need to be interpreted literally, or for which the
lazy evaluation mechanism of the language is needed, must <em>not</em>
be included in the signature of the generic function, since all
arguments in the signature will be evaluated in order to select a
method.
For example, the argument <code>expr</code> to the function
<code><a href="base.html#topic+with">with</a></code> is treated literally and must therefore be excluded
from the signature.
</p>
<p>One would also need to define an implicit generic if the existing
non-generic function were not suitable as the default method.
Perhaps the function only applies to some classes of objects, and the
package designer prefers to have no general default method.
In the other direction, the package designer might have some ideas
about suitable methods for some classes, if the function were generic.
With reasonably modern packages, the simple approach in all these
cases is just to define the function as a generic.
The implicit generic mechanism is mainly attractive for older packages
that do not want to require the methods package to be available.
</p>
<p>Generic functions will also be defined but not obviously visible for
functions implemented as <em>primitive</em> functions in the base
package.
Primitive functions look like ordinary functions when printed but are
in fact not function objects but objects of two types interpreted by
the <span class="rlang"><b>R</b></span> evaluator to call underlying C code directly.
Since their entire justification is efficiency, <span class="rlang"><b>R</b></span> refuses to hide
primitives behind a generic function object.
Methods may be defined for most primitives, and corresponding metadata
objects will be created to store them.
Calls to the primitive still go directly to the C code, which will
sometimes check for applicable methods.
The definition of &ldquo;sometimes&rdquo; is that methods must have been
detected for the function in some package loaded in the session and
<code>isS4(x)</code> is <code>TRUE</code> for  the first argument (or for the
second argument, in the case of binary operators).
You can test whether methods have been detected by calling
<code><a href="#topic+isGeneric">isGeneric</a></code> for the relevant function and you can examine
the generic function by calling <code><a href="#topic+getGeneric">getGeneric</a></code>, whether or
not methods have been detected.
For more on generic functions, see the references and also section 2
of the <em>R Internals</em> document supplied with <span class="rlang"><b>R</b></span>.
</p>


<h3>Method Definitions</h3>

<p>All method definitions are stored as objects from the
<code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code> class.
Like the class of generic functions, this class extends ordinary <span class="rlang"><b>R</b></span>
functions with some additional slots: <code>"generic"</code>, containing the
name and package of the generic function, and two signature slots,
<code>"defined"</code> and <code>"target"</code>, the first being the signature supplied when
the method was defined by a call to <code><a href="#topic+setMethod">setMethod</a></code>.
The  <code>"target"</code> slot starts off equal to the <code>"defined"</code>
slot.  When an inherited method is cached after being selected, as
described above, a copy is made with the  appropriate <code>"target"</code>  signature.
Output from <code><a href="#topic+showMethods">showMethods</a></code>, for example, includes both
signatures.
</p>
<p>Method definitions are required to have the same formal arguments as
the generic function, since the method dispatch mechanism does not
rematch arguments, for reasons of both efficiency and consistency.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer. (Section 10.5 for some details.)
</p>


<h3>See Also</h3>

<p>For more specific information, see
<code><a href="#topic+setGeneric">setGeneric</a></code>, <code><a href="#topic+setMethod">setMethod</a></code>, and
<code><a href="#topic+setClass">setClass</a></code>.
</p>
<p>For the use of ... in methods, see  <a href="#topic+dotsMethods">dotsMethods</a>.
</p>

<hr>
<h2 id='Methods_for_Nongenerics'>Methods for Non-Generic Functions in Other Packages</h2><span id='topic+Methods_for_Nongenerics'></span>

<h3>Description</h3>

<p>In writing methods for an <span class="rlang"><b>R</b></span> package, it's common for these methods to
apply to a function (in another package) that is not  generic in that
package; that is, there are no formal methods for the function in its
own package, although it may have S3 methods.
The programming in this case involves one extra step, to call
<code><a href="#topic+setGeneric">setGeneric</a>()</code> to declare that the function <em>is</em>
generic in your package.
</p>
<p>Calls to the function in your package will then use all methods
defined there or in any other loaded package that creates the same
generic function. Similarly, calls to the function in those packages
will use your methods.
</p>
<p>The original version, however, remains non-generic.  Calls
in that package or in other packages that use that version will  not dispatch your methods
except for special circumstances:
</p>

<ol>
<li><p> If the function is one of the primitive functions that accept
methods, the internal C implementation will dispatch methods if one
of the arguments is an S4 object, as should be the case.
</p>
</li>
<li><p> If the other version of the function dispatches S3 methods
<em>and</em> your methods are also registered as S3 methods, the
method will usually be dispatched as that S3 method.
</p>
</li>
<li><p> Otherwise, you will need to ensure that all calls to the
function come from a package in which the function is generic,
perhaps by copying code to your package.
</p>
</li></ol>

<p>Details and the underlying reasons are discussed in the following sections.
</p>


<h3>Generic and Non-Generic Calls</h3>

<p>Creating methods for a function (any function) in a package means that
calls to the function in that package will select methods according to
the actual arguments.
However, if the function was originally a non-generic in another
package, calls to the function from that package will <em>not</em>
dispatch methods.
In addition, calls from any third package that imports the non-generic version
will also not dispatch methods.
This section considers the reason and how one might deal with the
consequences.
</p>
<p>The reason is simply the <span class="rlang"><b>R</b></span> namespace mechanism and its role in
evaluating function calls.
When a name (such as the name of a function) needs to be evaluated in
a call to a function from some package, the evaluator looks first in the frame of the call,
then in the namespace of the package and then in the imports to that
package.
</p>
<p>Defining methods for a function in a package ensures that calls to the
function in that package will select the methods, because a generic
version of the function is created in the namespace.
Similarly, calls from another package that has or imports the generic
version will select methods.
Because the generic versions are identical, all methods will be
available in all these packages.
</p>
<p>However, calls from any package that imports the old version or just
selects it from the search list will usually <em>not</em> select methods.
</p>
<p>A an example, consider the function
<code><a href="base.html#topic+data.frame">data.frame</a>()</code> in the base package.
This function takes any number of objects as arguments and attempts to combine
them as variables into a data frame object.
It does this by calling <code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>, also in the
base package, for each of the objects.
</p>
<p>A reasonable goal would be to extend the classes of objects that can
be included in a data frame by defining methods for
<code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>.
But calls to <code><a href="base.html#topic+data.frame">data.frame</a>()</code>,
will still use the version of that function in the base package, which
continues to call the non-generic <code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code> in
that package.
</p>
<p>The details of what happens and options for dealing with it depend on
the form of the function:  a primitive function; a function that
dispatches S3 methods; or an ordinary <span class="rlang"><b>R</b></span> function.
</p>
<p>Primitive functions are not actual <span class="rlang"><b>R</b></span> function objects.
They go directly to internal C code.
Some of them, however, have been implemented to recognize methods.
These functions dispatch both S4 and S3 methods from
the internal C code.
There is no explicit generic function, either S3 or S4.
The internal code looks for S4 methods if the first
argument, or either of the arguments in the case of a binary operator,
is an S4 object.
If no S4 method is found, a search is made for an S3 method.
So defining methods for these functions works as long as the relevant
classes have been defined, which should always be the case.
</p>
<p>A function dispatches S3 methods by calling
<code><a href="base.html#topic+UseMethod">UseMethod</a>()</code>, which does <em>not</em> look for
formal methods regardless of whether the first argument is an S4
object or not.
This applies to the <code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code> example above.
To have methods called in this situation, your package must also define the
method as an S3 method, if possible. See section &lsquo;S3
&ldquo;Generic&rdquo; Functions&rsquo;.
</p>
<p>In the third possibility, the function is defined with no expectation
of methods.
For example, the base package has a number of functions that compute
numerical decompositions of matrix arguments.
Some, such as <code><a href="Matrix.html#topic+chol">chol</a>()</code> and <code><a href="Matrix.html#topic+qr">qr</a>()</code>
are implemented to dispatch S3 methods; others, such as
<code><a href="base.html#topic+svd">svd</a>()</code> are implemented directly as a specific
computation.
A generic version of the latter functions can be written and called
directly to define formal methods, but no code in another package that
does not import this generic version will dispatch such methods.
</p>
<p>In this case, you need to have the generic version used in all the indirect calls to the
function supplying arguments that should dispatch methods.
This may require supplying new functions that dispatch methods and
then call the function they replace.
For example, if S3 methods did not work for
<code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>, one could call a function that
applied the generic version to all its arguments and then called
<code><a href="base.html#topic+data.frame">data.frame</a>()</code> as a replacement for that function.
If all else fails, it might be necessary to copy over the relevant
functions so that they would find the generic versions.
</p>


<h3>S3 &ldquo;Generic&rdquo; Functions</h3>

<p>S3 method dispatch looks at the class of the first
argument.
S3 methods are ordinary functions with the same arguments as the
generic function.
The &ldquo;signature&rdquo; of an S3 method is identified  by the name to
which the method is assigned, composed of the name of the
generic function, followed by <code>"."</code>, followed by the name of the class.
For details, see <code><a href="base.html#topic+UseMethod">UseMethod</a></code>.
</p>
<p>To implement a method for one of these functions corresponding to S4
classes, there are two possibilities: either an S4 method or an S3 method with the
S4 class name.
The S3 method is only possible if the intended signature has the
first argument and nothing else.
In this case,
the recommended approach is to define the S3 method and also supply the
identical function as the definition of the S4 method.
If the S3 generic function was <code>f3(x, ...)</code> and the S4 class for
the new method was
<code>"myClass"</code>:
</p>
<p><code>f3.myClass &lt;- function(x, ...) { ..... }</code>
</p>
<p><code>setMethod("f3", "myClass", f3.myClass)</code>
</p>
<p>Defining both methods usually ensures that all calls to the original
function will dispatch the intended method.
The S4 method alone would not be called from other packages using the
original version of the function.
On the other hand,
an S3 method alone will not be called if there is <em>any</em>
eligible non-default S4 method.
</p>
<p>S4 and S3 method selection are designed to follow compatible rules of
inheritance, as far as possible.
S3 classes can be used for any S4 method selection, provided that the
S3 classes have been registered by a call to
<code><a href="#topic+setOldClass">setOldClass</a></code>, with that call specifying the correct S3
inheritance pattern.
S4 classes can be used for any S3 method selection; when an S4 object
is detected, S3 method selection uses the contents of
<code><a href="#topic+extends">extends</a>(class(x))</code> as the equivalent of the S3
inheritance (the inheritance is cached after the first call).
</p>
<p>An existing S3 method may not behave as desired for an S4 subclass, in
which case utilities such as <code><a href="base.html#topic+asS3">asS3</a></code> and
<code><a href="#topic+S3Part">S3Part</a></code> may be useful.  If the S3 method fails on the S4
object, <code>asS3(x)</code> may be passed instead; if the object returned
by the S3 method needs to be incorporated in the S4 object, the
replacement function for <code>S3Part</code> may be useful.</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><a href="#topic+Methods_for_S3">Methods_for_S3</a> for suggested implementation of methods
that work for both S3 and S4 dispatch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A class that extends a registered S3 class inherits that class' S3
## methods.

setClass("myFrame", contains = "data.frame",
         slots = c(timestamps = "POSIXt"))
df1 &lt;- data.frame(x = 1:10, y = rnorm(10), z = sample(letters,10))
mydf1 &lt;- new("myFrame", df1, timestamps = Sys.time())

## "myFrame" objects inherit "data.frame" S3 methods; e.g., for `[`

mydf1[1:2, ] # a data frame object (with extra attributes)


## a method explicitly for "myFrame" class

setMethod("[",
    signature(x = "myFrame"),
    function (x, i, j, ..., drop = TRUE)
    {
        S3Part(x) &lt;- callNextMethod()
        x@timestamps &lt;- c(Sys.time(), as.POSIXct(x@timestamps))
        x
    }
)

mydf1[1:2, ]


setClass("myDateTime", contains = "POSIXt")

now &lt;- Sys.time() # class(now) is c("POSIXct", "POSIXt")
nowLt &lt;- as.POSIXlt(now)# class(nowLt) is c("POSIXlt", "POSIXt")

mCt &lt;- new("myDateTime", now)
mLt &lt;- new("myDateTime", nowLt)

## S3 methods for an S4 object will be selected using S4 inheritance
## Objects mCt and mLt have different S3Class() values, but this is
## not used.
f3 &lt;- function(x)UseMethod("f3") # an S3 generic to illustrate inheritance

f3.POSIXct &lt;- function(x) "The POSIXct result"
f3.POSIXlt &lt;- function(x) "The POSIXlt result"
f3.POSIXt &lt;- function(x) "The POSIXt result"

stopifnot(identical(f3(mCt), f3.POSIXt(mCt)))
stopifnot(identical(f3(mLt), f3.POSIXt(mLt)))



## An S4 object selects S3 methods according to its S4 "inheritance"

setClass("classA", contains = "numeric",
         slots = c(realData = "numeric"))

Math.classA &lt;- function(x) { (getFunction(.Generic))(x@realData) }
setMethod("Math", "classA", Math.classA)


x &lt;- new("classA", log(1:10), realData = 1:10)

stopifnot(identical(abs(x), 1:10))

setClass("classB", contains = "classA")

y &lt;- new("classB", x)

stopifnot(identical(abs(y), abs(x))) # (version 2.9.0 or earlier fails here)

## an S3 generic: just for demonstration purposes
f3 &lt;- function(x, ...) UseMethod("f3")

f3.default &lt;- function(x, ...) "Default f3"

## S3 method (only) for classA
f3.classA &lt;- function(x, ...) "Class classA for f3"

## S3 and S4 method for numeric
f3.numeric &lt;- function(x, ...) "Class numeric for f3"
setMethod("f3", "numeric", f3.numeric)

## The S3 method for classA and the closest inherited S3 method for classB
## are not found.

f3(x); f3(y) # both choose "numeric" method

## to obtain the natural inheritance, set identical S3 and S4 methods
setMethod("f3", "classA", f3.classA)

f3(x); f3(y) # now both choose "classA" method

## Need to define an S3 as well as S4 method to use on an S3 object
## or if called from a package without the S4 generic

MathFun &lt;- function(x) { # a smarter "data.frame" method for Math group
  for (i in seq_len(ncol(x))[sapply(x, is.numeric)])
    x[, i] &lt;- (getFunction(.Generic))(x[, i])
  x
}
setMethod("Math", "data.frame", MathFun)

## S4 method works for an S4 class containing data.frame,
## but not for data.frame objects (not S4 objects)

try(logIris &lt;- log(iris)) #gets an error from the old method

## Define an S3 method with the same computation

Math.data.frame &lt;- MathFun

logIris &lt;- log(iris)






</code></pre>

<hr>
<h2 id='Methods_for_S3'>Methods For S3 and S4 Dispatch</h2><span id='topic+Methods_for_S3'></span>

<h3>Description</h3>

<p>The S3 and S4 software in <span class="rlang"><b>R</b></span> are two generations implementing
functional object-oriented programming.
S3 is the original, simpler for initial programming but less general,
less formal and less open to validation.
The S4 formal methods and classes provide these features but require
more programming.
</p>
<p>In modern <span class="rlang"><b>R</b></span>, the two versions attempt to work together.  This
documentation outlines how to write methods for both systems by
defining an S4 method for a function that dispatches S3 methods.
</p>
<p>The systems can also be combined by using an S3 class with S4 method
dispatch or in S4 class definitions.  See <code><a href="#topic+setOldClass">setOldClass</a></code>.
</p>


<h3>S3 Method Dispatch</h3>

<p>The <span class="rlang"><b>R</b></span> evaluator will &lsquo;dispatch&rsquo; a method from a function call
either when the body of the function calls the special primitive
<code><a href="base.html#topic+UseMethod">UseMethod</a></code> or when the call is to one of the builtin
primitives such as the <code>math</code> functions or the binary operators.
</p>
<p>S3 method dispatch looks at the class of the first
argument or the class of either
argument in a call to one of the primitive binary operators.
In pure S3 situations, &lsquo;class&rsquo; in this context means the class
attribute or the implied class for a basic data type such as
<code>"numeric"</code>.
The first S3 method that matches a name in the class is called and the
value of that call is the value of the original function call.
For details, see <a href="base.html#topic+S3Methods">S3Methods</a>.
</p>
<p>In modern <span class="rlang"><b>R</b></span>, a function <code>meth</code> in a package is registered as an S3 method
for function <code>fun</code> and class <code>Class</code> by
including in the package's <code>NAMESPACE</code> file the directive
</p>
<p><code>S3method(fun, Class, meth)</code>
</p>
<p>By default (and traditionally), the third argument is taken to be the
function <code>fun.Class</code>; that is,
the name of the
generic function, followed by <code>"."</code>, followed by the name of the
class.
</p>
<p>As with S4 methods, a method that has been registered will be added to
a table of methods for this function when the corresponding package is
loaded into the session.
Older versions of <span class="rlang"><b>R</b></span>, copying the mechanism in S, looked for the
method in the current search list, but packages should now always
register S3 methods rather than requiring the package to be attached.
</p>


<h3>Methods for S4 Classes</h3>

<p>Two possible mechanisms for implementing a method  corresponding to an
S4 class, there are two possibilities are to register it as an S3 method with the
S4 class name or to define and set an S4 method, which will have the
side effect of creating an S4 generic version of this function.
</p>
<p>For most situations either works, but
the recommended approach is to do both: register the S3 method and supply the
identical function as the definition of the S4 method.
This ensures that the proposed method will be dispatched for any
applicable call to the function.
</p>
<p>As an example, suppose an S4 class <code>"uncased"</code> is defined,
extending <code>"character"</code> and intending to ignore upper- and
lower-case.
The base function <code><a href="base.html#topic+unique">unique</a></code> dispatches S3 methods.
To define the class and a method for this function:
</p>
<p><code>setClass("uncased", contains = "character")</code>
</p>
<p><code>unique.uncased &lt;- function(x, incomparables = FALSE, ...)
  nextMethod(tolower(x))</code>
</p>
<p><code>setMethod("unique", "uncased", unique.uncased)</code>
</p>
<p>In addition, the <code>NAMESPACE</code> for the package should contain:
</p>
<p><code>S3method(unique, uncased)</code>
</p>
<p><code>exportMethods(unique)</code>
</p>
<p>The result is to define identical S3 and S4 methods and ensure that all
calls to <code>unique</code> will dispatch that method when appropriate.
</p>


<h3>Details</h3>

<p>The reasons for defining both S3 and S4 methods are as follows:
</p>

<ol>
<li><p> An S4 method alone will not be seen if the S3 generic function
is called directly. This will be the case, for example, if some
function calls <code>unique()</code> from a package that does not make
that function  an S4 generic.
</p>
<p>However, primitive functions and operators
are exceptions:  The internal C code will look for S4 methods
if and only if the object is an S4 object.  S4 method dispatch
would be used to dispatch any binary operator calls where either
of the operands was an S4 object, for example.
</p>
</li>
<li><p> An S3 method alone will not be called if there is <em>any</em>
eligible non-default S4 method.
</p>
<p>So if a package defined an S3
method for <code>unique</code> for an S4 class but another package
defined an S4 method for a superclass of that class, the
superclass method would be chosen, probably not what was
intended.
</p>
</li></ol>

<p>S4 and S3 method selection are designed to follow compatible rules of
inheritance, as far as possible.
S3 classes can be used for any S4 method selection, provided that the
S3 classes have been registered by a call to
<code><a href="#topic+setOldClass">setOldClass</a></code>, with that call specifying the correct S3
inheritance pattern.
S4 classes can be used for any S3 method selection; when an S4 object
is detected, S3 method selection uses the contents of
<code><a href="#topic+extends">extends</a>(class(x))</code> as the equivalent of the S3
inheritance (the inheritance is cached after the first call).
</p>
<p>For the details of S4 and S3
dispatch see <a href="#topic+Methods_Details">Methods_Details</a> and <a href="base.html#topic+S3Methods">S3Methods</a>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>

<hr>
<h2 id='methods-defunct'>Defunct Functions in Package <span class="pkg">methods</span></h2><span id='topic+methods-defunct'></span><span id='topic+getAllMethods'></span><span id='topic+mlistMetaName'></span><span id='topic+removeMethodsObject'></span><span id='topic+getAccess'></span><span id='topic+getClassName'></span><span id='topic+getClassPackage'></span><span id='topic+getExtends'></span><span id='topic+getProperties'></span><span id='topic+getPrototype'></span><span id='topic+getSubclasses'></span><span id='topic+getVirtual'></span><span id='topic+seemsS4Object'></span><span id='topic+allGenerics'></span><span id='topic+trySilent'></span><span id='topic+traceOn'></span><span id='topic+traceOff'></span>

<h3>Description</h3>

<p>Defunct functions in package <span class="pkg">methods</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
getAccess(ClassDef)
getClassName(ClassDef)
getClassPackage(ClassDef)
getExtends(ClassDef)
getProperties(ClassDef)
getPrototype(ClassDef)
getSubclasses(ClassDef)
getVirtual(ClassDef)

getAllMethods(f, fdef, where)
mlistMetaName (name, package)
removeMethodsObject(f, where)

seemsS4Object(object)


allGenerics()


trySilent(expr)


traceOn(what, tracer=browseAll, exit=NULL)
traceOff(what)
</code></pre>


<h3>Details</h3>

<p>The first block of functions should be replaced by direct access to
the slots, or by use of higher-level alternatives.
</p>
<p>The functions and corresponding slots are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>getAccess</code> </td><td style="text-align: left;"> <code>"access"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getClassName</code> </td><td style="text-align: left;"> <code>"className"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getClassPackage</code> </td><td style="text-align: left;"> <code>"package"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getExtends</code> </td><td style="text-align: left;"> <code>"contains"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getProperties</code> </td><td style="text-align: left;"> <code>"slots"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getPrototype</code> </td><td style="text-align: left;"> <code>"prototype"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getSubclasses</code> </td><td style="text-align: left;"> <code>"subclasses"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getVirtual</code> </td><td style="text-align: left;"> <code>"virtual"</code>
  </td>
</tr>

</table>

<p><code>getAllMethods</code> replicated the behavior of
<code><a href="#topic+getMethods">getMethods</a></code>, which should be called instead to obtain
approximately the old behavior of <code>getAllMethods</code>.  However, a
better substitution is to use <code><a href="#topic+findMethods">findMethods</a></code>, which
returns a simpler structure.
</p>
<p><code>mlistMetaName</code> was a utility to  return the mangled
name for the object that stored the <code>MethodsList</code>
representation of the methods for a particular generic function,
typically in the environment of a package.  These objects are no
longer used.
</p>
<p><code>removeMethodsObject</code> removed the metadata object containing
methods for <code>f</code>.
</p>
<p><code>seemsS4Object</code> was similar to <code><a href="base.html#topic+isS4">isS4</a></code> and superseded
by the introduction of the S4 bit in <span class="rlang"><b>R</b></span> 2.4.0.
</p>
<p><code>allGenerics</code> is superseded by <code><a href="#topic+getGenerics">getGenerics</a></code>.
</p>
<p><code>trySilent(ex)</code> was a deprecated equivalent of <code><a href="base.html#topic+try">try</a>(e,
    silent=TRUE)</code>; in <span class="rlang"><b>R</b></span> programming it is typically more efficient and
flexible to work with something like <code><a href="base.html#topic+tryCatch">tryCatch</a>(ex,
    error = function(e) e)</code> instead.
</p>
<p>The functions <code>traceOn</code> and <code>traceOff</code> have been replaced by
extended versions of the functions <code><a href="base.html#topic+trace">trace</a></code> and
<code><a href="base.html#topic+untrace">untrace</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='methods-deprecated'>Deprecated Functions in Package <span class="pkg">methods</span></h2><span id='topic+methods-deprecated'></span>

<h3>Description</h3>

<p>(Currently none)
</p>
<p>These functions are provided for compatibility with older versions of
<span class="rlang"><b>R</b></span> only, and may be defunct as soon as the next release.
</p>


<h3>Details</h3>

<p>The original help page for these functions is often
available at <code>help("oldName-deprecated")</code> (note the quotes).
Functions in packages other than the methods package are listed in
<code>help("pkg-deprecated")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>, <code><a href="#topic+methods-defunct">methods-defunct</a></code>
</p>

<hr>
<h2 id='methods-package'>
Formal Methods and Classes
</h2><span id='topic+methods-package'></span>

<h3>Description</h3>

<p>Formally defined methods and classes for R objects, plus
other programming tools, as described in the references.
</p>


<h3>Details</h3>

<p>This package provides the &ldquo;S4&rdquo; or &ldquo;S version 4&rdquo;
approach to methods and classes in a functional language.
</p>
<p>For basic use of the techniques, start with <a href="#topic+Introduction">Introduction</a> and
follow the links there to the key functions for programming, notably
<code><a href="#topic+setClass">setClass</a></code> and <code><a href="#topic+setMethod">setMethod</a></code>.
</p>
<p>Some specific topics:
</p>

<dl>
<dt>Classes:</dt><dd><p> Creating one, see <code><a href="#topic+setClass">setClass</a></code>;
examining definitions, see <code><a href="#topic+getClassDef">getClassDef</a></code> and
<a href="#topic+classRepresentation-class">classRepresentation</a>; inheritance and coercing,
see <code><a href="#topic+is">is</a></code> and <code><a href="#topic+as">as</a></code>
</p>
</dd>
<dt>Generic functions:</dt><dd><p>  Basic programming, see
<code><a href="#topic+setGeneric">setGeneric</a></code>; the class of objects, see
<a href="#topic+genericFunction-class">genericFunction</a>; other functions to examine or
manipulate them, see <a href="#topic+GenericFunctions">GenericFunctions</a>.
</p>
</dd>
<dt>S3:</dt><dd><p>Using classes, see <code><a href="#topic+setOldClass">setOldClass</a></code>; methods,
see <a href="#topic+Methods_for_S3">Methods_for_S3</a>.
</p>
</dd>
<dt>Reference classes:</dt><dd><p>See <a href="#topic+ReferenceClasses">ReferenceClasses</a>.
</p>
</dd>
<dt>Class unions; virtual classes</dt><dd><p>See <code><a href="#topic+setClassUnion">setClassUnion</a></code>.
</p>
</dd>
</dl>

<p>These pages will have additional links to related topics.
</p>
<p>For a complete
list of functions and classes, use <code>library(help="methods")</code>.
</p>


<h3>Author(s)</h3>

<p>R Core Team
</p>
<p>Maintainer: R Core Team <a href="mailto:R-core@r-project.org">R-core@r-project.org</a>
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (Chapter 10 has some additional details.)
</p>

<hr>
<h2 id='MethodsList'><code>MethodsList</code> Objects</h2><span id='topic+listFromMlist'></span><span id='topic+linearizeMlist'></span><span id='topic+finalDefaultMethod'></span><span id='topic+loadMethod'></span><span id='topic+loadMethod-methods'></span><span id='topic+loadMethod+2CANY-method'></span><span id='topic+loadMethod+2CMethodDefinition-method'></span><span id='topic+loadMethod+2CMethodWithNext-method'></span><span id='topic+MethodsList'></span><span id='topic+makeMethodsList'></span><span id='topic+SignatureMethod'></span><span id='topic+insertMethod'></span><span id='topic+inheritedSubMethodLists'></span><span id='topic+showMlist'></span><span id='topic+print.MethodsList'></span><span id='topic+emptyMethodsList'></span><span id='topic+insertMethodInEmptyList'></span><span id='topic+mergeMethods'></span><span id='topic+MethodsListSelect'></span>

<h3>Description</h3>

<p>These functions create and manipulate <code>MethodsList</code> objects, the
objects formerly used in <span class="rlang"><b>R</b></span> to store methods for dispatch.  Use of
these objects is deprecated since <span class="rlang"><b>R</b></span> 3.2.0, as it will rarely be a
good idea.  Where methods dispatch is
to be studied, see <code><a href="#topic+selectMethod">selectMethod</a></code>.  For computations
that iterate over methods or over method signatures, see
<code><a href="#topic+findMethods">findMethods</a></code>, which returns a linearized methods list
to hold method definitions, usually more convenient for iteration
than the recursive <code>MethodsList</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listFromMlist(mlist, prefix = list(), sigs. = TRUE, methods. = TRUE)

linearizeMlist(mlist, inherited = TRUE)

finalDefaultMethod(method)

loadMethod(method, fname, envir)

##--------- These are all deprecated, since R 3.2.0 ----------

MethodsList(.ArgName, ...)
makeMethodsList(object, level=1)
SignatureMethod(names, signature, definition)
insertMethod(mlist, signature, args, def, cacheOnly)
inheritedSubMethodLists(object, thisClass, mlist, ev)

showMlist(mlist, includeDefs = TRUE, inherited = TRUE,
   classes, useArgNames, printTo = stdout() )
## S3 method for class 'MethodsList'
print(x, ...)

mergeMethods(m1, m2, genericLabel)

emptyMethodsList(mlist, thisClass = "ANY", sublist = list()) 
</code></pre>


<h3>Details</h3>












































<dl>
<dt><code>listFromMlist</code>:</dt><dd>
<p>Undo the recursive nature of the methods list, making a list of
<code>list(sigs,methods)</code> of function definitions, i.e. of
matching signatures and methods.
<code>prefix</code> is the partial signature (a named list of classes)
to be prepended to the signatures in this object.  If <code>sigs.</code>
or <code>methods.</code> are <code>FALSE</code>, the resulting part of the
return value will be empty.
</p>
<p>A utility function used to iterate over all the individual methods
in the object, it calls itself recursively.
</p>
</dd>
<dt><code>linearizeMlist</code>:</dt><dd>
<p>Undo the recursive nature of the methods list, making a list of
function definitions, with the names of the list being the
corresponding signatures.
</p>
<p>Designed for printing; for looping over the methods, use the above
<code>listFromMlist</code> instead.
</p>
</dd>
<dt><code>finalDefaultMethod</code>:</dt><dd>
<p>The default method or NULL.  With the demise of
<code>"MethodsList"</code> objects, this function only checks that the
value given it is a method definition, primitive or NULL.
</p>
</dd>






<dt><code>loadMethod</code>:</dt><dd>
<p>Called, if necessary, just before a call to <code>method</code> is
dispatched in the frame <code>envir</code>.  The function exists so that
methods can be defined for special classes of objects.  Usually
the point is to assign or modify information in the frame
environment to be used evaluation.  For example, the standard
class <code>MethodDefinition</code> has a method that stores the target
and defined signatures in the environment.  Class
<code>MethodWithNext</code> has a method taking account of the
mechanism for storing the method to be used in a call to
<code><a href="#topic+callNextMethod">callNextMethod</a></code>.
</p>
<p>Any methods defined for <code>loadMethod</code> must return the function
definition to be used for this call; typically, this is just the
<code>method</code> argument.
</p>
</dd>









</dl>



<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>

<hr>
<h2 id='MethodsList-class'>Class <code>"MethodsList"</code>, Defunct Representation of Methods </h2><span id='topic+MethodsList-class'></span><span id='topic+body+3C-+2CMethodDefinition-method'></span>

<h3>Description</h3>

<p> This class of objects was used in the original
implementation of the package to control method dispatch.  Its use
is now defunct, but object appear as the default method slot in
generic functions.  This and any other remaining uses will be
removed in the future.
</p>
<p>For the modern alternative, see <a href="#topic+listOfMethods-class">listOfMethods</a>.
</p>
<p>The details in this documentation are retained to allow analysis of
old-style objects. </p>


<h3>Details</h3>

<p>Suppose a function <code>f</code> has
formal arguments <code>x</code> and <code>y</code>.  The methods list object for
that function has the object <code>as.name("x")</code> as its
<code>argument</code> slot.  An element of the methods named <code>"track"</code>
is selected if the actual argument corresponding to <code>x</code> is an
object of class <code>"track"</code>.  If there is such an element, it can
generally be either a function or another methods list object.
</p>
<p>In the first case, the function defines the method to use for any call
in which <code>x</code> is of class <code>"track"</code>.  In the second case, the
new methods list object defines the available methods depending on
the remaining formal arguments, in this example, <code>y</code>.
</p>
<p>Each method  corresponds conceptually to a <em>signature</em>;
that is a named list of classes, with names corresponding to some or
all of the formal arguments.  In the previous example, if selecting
class <code>"track"</code> for <code>x</code>, finding that the selection was
another methods list and then selecting class <code>"numeric"</code> for
<code>y</code> would produce a method associated with the signature
<code>x = "track", y = "numeric"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>argument</code>:</dt><dd><p>Object of class <code>"name"</code>.  The name of the
argument being used for dispatch at this level. </p>
</dd>
<dt><code>methods</code>:</dt><dd><p>A named list of the methods (and method lists)
defined <em>explicitly</em> for this argument.
The names are the names of classes, and the corresponding
element defines the method or methods to be used if the corresponding
argument has that class.  See the details below.</p>
</dd>
<dt><code>allMethods</code>:</dt><dd><p>A named list,  contains
all the directly defined methods from the <code>methods</code> slot, plus
any inherited methods.  Ignored when methods tables are used for dispatch (see <a href="#topic+Methods_Details">Methods_Details</a>). </p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"OptionalMethods"</code>, directly.
</p>

<hr>
<h2 id='MethodSupport'>Additional (Support) Functions for Methods</h2><span id='topic+getMethodsForDispatch'></span><span id='topic+cacheMethod'></span><span id='topic+resetGeneric'></span><span id='topic+listFromMethods'></span>

<h3>Description</h3>

<p>These are <em>internal</em> support routines for computations on formal methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listFromMethods(generic, where, table)

getMethodsForDispatch(fdef, inherited = FALSE)

cacheMethod(f, sig, def, args, fdef, inherited = FALSE)

resetGeneric(f, fdef, mlist, where, deflt)
</code></pre>


<h3>Summary of Functions</h3>


<dl>
<dt><code>listFromMethods</code>:</dt><dd>
<p>A list object describing the methods for the function <code>generic</code>, supplied either as the function or the name of the function.   For user code, the function <code><a href="#topic+findMethods">findMethods</a></code> or <code><a href="#topic+findMethodSignatures">findMethodSignatures</a></code> is recommended instead,  returning a simple list of methods or a character matrix of the signatures.
</p>
<p>If <code>where</code> is supplied, this should be an environment or search list position from which a table of methods for the generic will be taken.  If <code>table</code> is supplied, this is itself assumed to be such a table.  If neither argument is supplied, the table is taken directly from the generic function (that is, the current set of methods defined for this generic).
</p>
<p>Returns an object of class <code>"LinearMethodsList"</code> (see
<a href="#topic+LinearMethodsList-class">LinearMethodsList</a>) describing all the methods in the
relevant table.
</p>
</dd>
<dt><code>resetGeneric</code>:</dt><dd>
<p>reset the currently defined methods for the generic function named
<code>f</code>, found in environment <code>where</code> or explicitly supplied
as an argument.  Other arguments are obsolete and ignored.
</p>
<p>Called for its side effect of resetting all inherited methods in
the generic function's internal table.
Normally not called directly, since changes to methods and the
loading and detaching  of packages all generate a call automatically.
</p>
</dd>
<dt><code>cacheMethod</code>:</dt><dd>
<p>Store the definition for this function and signature in the method
metadata for the function.  Used to store extensions of coerce
methods found through inheritance, and to cache methods with
<code><a href="#topic+callNextMethod">callNextMethod</a></code> information.
</p>
<p>No persistent effect, since the method metadata is session-scope
only.
</p>
</dd>
<dt><code>getMethodsForDispatch</code>:</dt><dd>
<p>Get the table of methods (an <code><a href="base.html#topic+environment">environment</a></code> since R
version 2.6.0) representing the methods for function <code>f</code>.
</p>
<p>For user code, the function <code><a href="#topic+findMethods">findMethods</a></code> or
<code><a href="#topic+findMethodSignatures">findMethodSignatures</a></code> is recommended instead, returning
a simple list of methods or a character matrix of the signatures.
</p>
</dd>
</dl>


<hr>
<h2 id='methodUtilities'>Utility Functions for Methods and S-Plus Compatibility</h2><span id='topic+functionBody'></span><span id='topic+functionBody+3C-'></span><span id='topic+allNames'></span><span id='topic+getFunction'></span><span id='topic+existsFunction'></span><span id='topic+el'></span><span id='topic+elNamed'></span><span id='topic+el+3C-'></span><span id='topic+elNamed+3C-'></span><span id='topic+formalArgs'></span><span id='topic+Quote'></span><span id='topic+showDefault'></span><span id='topic+initMethodDispatch'></span><span id='topic+methodSignatureMatrix'></span>

<h3>Description</h3>

<p>These are <em>internal</em> utilities, currently in the <span class="pkg">methods</span>
package, that either provide some functionality needed by the package
(e.g., element matching by name), or add compatibility with S-Plus, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functionBody(fun = sys.function(sys.parent()))
functionBody(fun, envir = environment(fun)) &lt;- value

allNames(x)

existsFunction(f, generic = TRUE, where = topenv(parent.frame()))
getFunction(name, generic = TRUE, mustFind = TRUE, where)

el(object, where)

elNamed(x, name, mustFind = FALSE)
elNamed(x, name) &lt;- value

formalArgs(def)

Quote(expr)

showDefault(object, oldMethods = TRUE)

initMethodDispatch(where = topenv(parent.frame()))

methodSignatureMatrix(object, sigSlots = c("target", "defined"))
</code></pre>


<h3>Summary of Functions</h3>


<dl>
<dt><code>allNames</code>:</dt><dd>
<p>the character vector of names (unlike <code>names()</code>, never
returns <code>NULL</code>).
</p>
</dd>
<dt><code>getFunction</code>:</dt><dd>
<p>find the object as a function.
</p>
</dd>
<dt><code>el</code>:</dt><dd><p><code>el(object, i)</code> is equivalent to
<code>object[i][[1]]</code> (and should typically be replaceable by object[[i]]).
</p>
</dd>
<dt><code>elNamed</code>:</dt><dd>
<p>get the element of the vector corresponding to name.  Unlike the
<code><a href="Matrix.html#topic++5B">[</a></code>, <code><a href="base.html#topic++5B+5B">[[</a></code>, and <code><a href="base.html#topic++24">$</a></code> operators, this function
requires <code>name</code> to match the element name exactly (no partial
matching).
</p>
</dd>
<dt><code>formalArgs</code>:</dt><dd>
<p>Returns the names of the formal arguments of this function.
</p>
</dd>
<dt><code>existsFunction</code>:</dt><dd>
<p>Is there a function of this name?  If <code>generic</code> is
<code>FALSE</code>, generic functions are not counted.
</p>
</dd>
<dt><code>findFunction</code>:</dt><dd>
<p>return all the indices of the search list on which a function
definition for <code>name</code> exists.
</p>
<p>If <code>generic</code> is <code>FALSE</code>, ignore generic functions.
</p>
</dd>
<dt><code>showDefault</code>:</dt><dd>
<p>Utility, used to enable <code>show</code> methods to be called by the
automatic printing (via <code>print.default</code>).
</p>
<p>Argument <code>oldMethods</code> is deprecated as it has been unused since
<span class="rlang"><b>R</b></span> &gt;= 1.7.0.
</p>
</dd>
<dt><code>initMethodDispatch</code>:</dt><dd>
<p>Turn on the internal method dispatch code.  Called on loading
the namespace.  Also, if dispatch has been turned off (by calling
<code>.isMethodsDispatchOn(FALSE)</code>&mdash;a very gutsy thing to do),
calling this function should turn dispatch back on again.
</p>
</dd>
<dt><code>methodSignatureMatrix</code>:</dt><dd>
<p>Returns a matrix with the contents of the specified slots as
rows.  The slots should be named character strings of the same
length.  Basically used to turn the signatures of a
<code>"MethodDefinition"</code> object into a matrix for printing.
</p>
</dd>
<dt><code>Quote</code>:</dt><dd><p>is a synonym of <code><a href="base.html#topic+quote">quote</a>()</code> and
considered deprecated.
</p>
</dd>
</dl>


<hr>
<h2 id='MethodWithNext-class'>Class <code>"MethodWithNext"</code> </h2><span id='topic+MethodWithNext-class'></span>

<h3>Description</h3>

<p> Class of method definitions set up for <code>callNextMethod</code> </p>


<h3>Objects from the Class</h3>

<p>Objects from this class are generated as a side-effect of calls to
<code><a href="#topic+callNextMethod">callNextMethod</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"function"</code>; the actual
function definition.</p>
</dd>
<dt><code>nextMethod</code>:</dt><dd><p>Object of class <code>"PossibleMethod"</code>
the method to use in response to a <code><a href="#topic+callNextMethod">callNextMethod</a>()</code>
call.</p>
</dd>
<dt><code>excluded</code>:</dt><dd><p>Object of class <code>"list"</code>; one or more
signatures excluded in finding the next method. </p>
</dd>
<dt><code>target</code>:</dt><dd><p>Object of class <code>"signature"</code>, from class
<code>"MethodDefinition"</code></p>
</dd>
<dt><code>defined</code>:</dt><dd><p>Object of class <code>"signature"</code>, from
class <code>"MethodDefinition"</code></p>
</dd>
<dt><code>generic</code>:</dt><dd><p>Object of class <code>"character"</code>; the function
for which the method was created. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"MethodDefinition"</code>, directly.<br />
Class <code>"function"</code>, from data part.<br />
Class <code>"PossibleMethod"</code>, by class <code>"MethodDefinition"</code>.<br />
Class <code>"OptionalMethods"</code>, by class <code>"MethodDefinition"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>findNextMethod</dt><dd><p><code>signature(method = "MethodWithNext")</code>:
used internally by method dispatch. </p>
</dd>
<dt>loadMethod</dt><dd><p><code>signature(method = "MethodWithNext")</code>: used
internally by method dispatch. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MethodWithNext")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

  <p><code><a href="#topic+callNextMethod">callNextMethod</a></code>, and
class <code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code>.
</p>

<hr>
<h2 id='new'> Generate an Object from a Class </h2><span id='topic+new'></span><span id='topic+initialize'></span>

<h3>Description</h3>

<p>A call to  <code>new</code> returns a newly allocated object from the
class identified by the first argument.  This call in turn calls the
method for the generic function <code>initialize</code> corresponding to
the specified class, passing the <code>...</code> arguments to this
method.
In the default method for <code>initialize()</code>, named arguments provide
values for the corresponding slots and unnamed arguments must be
objects from superclasses of this class.
</p>
<p>A call to a generating function for a class (see
<code><a href="#topic+setClass">setClass</a></code>) will pass its ... arguments to a corresponding call to <code>new()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new(Class, ...)

initialize(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_+3A_class">Class</code></td>
<td>
<p>either the name of a class, a <code><a href="base.html#topic+character">character</a></code>
string, (the usual case) or the object describing the class (e.g.,
the value returned by <code>getClass</code>). Note that the character
string passed from a generating function includes the package name
as an attribute, avoiding ambiguity if two packages have identically
named classes.</p>
</td></tr>
<tr><td><code id="new_+3A_...">...</code></td>
<td>
<p>arguments to specify properties of the new object, to
be passed to <code>initialize()</code>.</p>
</td></tr>
<tr><td><code id="new_+3A_.object">.Object</code></td>
<td>
<p> An object:  see the &ldquo;Initialize Methods&rdquo; section.</p>
</td></tr>
</table>


<h3>Initialize Methods</h3>

<p>The generic function <code>initialize</code> is not called directly.
A call to <code>new</code> begins by copying the prototype object from
the class definition, and then calls <code>intialize()</code> with this
object as the first argument, followed by the ... arguments. 
</p>
<p>The interpretation of the <code>...</code> arguments in a call to a
generator function or to <code>new()</code> can be specialized to
particular classes, by defining an appropriate method for <code>"initialize"</code>. 
</p>
<p>In the default method, unnamed arguments in the <code>...</code> are interpreted as
objects from a superclass, and named arguments are interpreted as
objects to be assigned into the correspondingly named slots.
Explicitly specified slots override inherited information for the same slot,
regardless of the order in which the arguments appear.
</p>
<p>The <code>initialize</code> methods do not have to have <code>...</code> as
their second argument (see the examples).  Initialize methods are
often written when the natural parameters describing the new object
are not the names of the slots.  If you do define such a method,
you should include  <code>...</code> as a formal argument, and your method should pass such
arguments along via <code><a href="#topic+callNextMethod">callNextMethod</a></code>. 
This helps the definition of future subclasses of your class.  If these
have additional slots and your method
does <em>not</em> have this argument, it will be difficult for these
slots to be included in an initializing call.
</p>
<p>See
<code><a href="#topic+initialize-methods">initialize-methods</a></code> for a discussion of some classes with existing
methods. 
</p>
<p>Methods for <code>initialize</code> can be inherited only by simple
inheritance, since it is a requirement that the method return an
object from the target class.  See the
<code>simpleInheritanceOnly</code> argument to <code><a href="#topic+setGeneric">setGeneric</a></code> and
the discussion in <code><a href="#topic+setIs">setIs</a></code> for the general concept.
</p>
<p>Note that the basic vector classes, <code>"numeric"</code>, etc. are
implicitly defined, so one can use <code>new</code> for these classes.
The ... arguments are interpreted as objects of this type and are
concatenated into the resulting vector.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

 <p><a href="#topic+Classes_Details">Classes_Details</a> for details of class definitions, and
<code><a href="#topic+setOldClass">setOldClass</a></code> for the relation to S3 classes. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## using the definition of class "track" from \link{setClass}



## a new object with two slots specified
t1 &lt;- new("track", x = seq_along(ydata), y = ydata)

# a new object including an object from a superclass, plus a slot
t2 &lt;- new("trackCurve", t1, smooth = ysmooth)

### define a method for initialize, to ensure that new objects have
### equal-length x and y slots.  In this version, the slots must still be
### supplied by name.

setMethod("initialize", "track", 
    function(.Object, ...) {
      .Object &lt;- callNextMethod()
      if(length(.Object@x) != length(.Object@y))
      stop("specified x and y of different lengths")
      .Object
    })

### An alternative version that allows x and y to be supplied
### unnamed.  A still more friendly version would make the default x
### a vector of the same length as y, and vice versa.

setMethod("initialize", "track",
          function(.Object, x = numeric(0), y = numeric(0), ...) {
              .Object &lt;- callNextMethod(.Object, ...)
              if(length(x) != length(y))
                  stop("specified x and y of different lengths")
              .Object@x &lt;- x
              .Object@y &lt;- y
              .Object
          })


</code></pre>

<hr>
<h2 id='nonStructure-class'>A non-structure S4 Class for basic types </h2><span id='topic+nonStructure-class'></span><span id='topic+Math+2CnonStructure-method'></span><span id='topic+Math2+2CnonStructure-method'></span><span id='topic+Ops+2Cvector+2CnonStructure-method'></span><span id='topic+Ops+2CnonStructure+2Cvector-method'></span><span id='topic+Ops+2CnonStructure+2CnonStructure-method'></span>

<h3>Description</h3>

<p> S4 classes that are defined to extend one of the basic
vector classes should contain the class
<code><a href="#topic+structure-class">structure</a></code> if they behave like structures; that
is, if they should retain their class behavior under math functions
or operators, so long as their length is unchanged.
On the other hand, if their class depends on the values in the
object, not just its structure, then they should lose that class
under any such transformations.  In the latter case, they should be
defined to contain <code>nonStructure</code>.
</p>
<p>If neither of these strategies applies, the class likely needs some
methods of its own for <code><a href="#topic+Ops">Ops</a></code>, <code><a href="#topic+Math">Math</a></code>, and/or
other generic functions. What is not usually a good idea is to allow
such computations to drop down to the default, base code.  This is
inconsistent with most definitions of such classes.</p>


<h3>Methods</h3>

<p>Methods are defined for operators and math functions (groups
<code><a href="#topic+Ops">Ops</a></code>, <code><a href="#topic+Math">Math</a></code> and  <code><a href="#topic+Math2">Math2</a></code>).  In
all cases the result is an ordinary vector of the appropriate type.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+structure-class">structure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setClass("NumericNotStructure", contains = c("numeric","nonStructure"))
xx &lt;- new("NumericNotStructure", 1:10)
xx + 1 # vector
log(xx) # vector
sample(xx) # vector

</code></pre>

<hr>
<h2 id='ObjectsWithPackage-class'>A Vector of Object Names, with associated Package Names </h2><span id='topic+ObjectsWithPackage-class'></span>

<h3>Description</h3>

<p>This class of objects is used to represent ordinary character string
object names, extended with a <code>package</code> slot naming the package
associated with each object.
</p>


<h3>Objects from the Class</h3>

<p>The function <code><a href="#topic+getGenerics">getGenerics</a></code> returns an object of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"character"</code>: the
object names.</p>
</dd>
<dt><code>package</code>:</dt><dd><p>Object of class <code>"character"</code> the
package names.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"character"</code>, from data part.<br />
Class <code>"vector"</code>, by class <code>"character"</code>.
</p>


<h3>See Also</h3>

 <p><code>Methods</code> for general background. </p>

<hr>
<h2 id='promptClass'>Generate a Shell for Documentation of a Formal Class</h2><span id='topic+promptClass'></span>

<h3>Description</h3>

<p>Assembles all relevant slot and method information for a class, with
minimal markup for Rd processing; no QC facilities at present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promptClass(clName, filename = NULL, type = "class",
            keywords = "classes", where = topenv(parent.frame()),
            generatorName = clName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promptClass_+3A_clname">clName</code></td>
<td>
<p>a character string naming the class to be documented.</p>
</td></tr>
<tr><td><code id="promptClass_+3A_filename">filename</code></td>
<td>
<p>usually, a connection or a character string giving the
name of the file to which the documentation shell should be written.
The default corresponds to a file whose name is the topic name for
the class documentation, followed by <code>".Rd"</code>.  Can also be
<code>NA</code> (see below).</p>
</td></tr>
<tr><td><code id="promptClass_+3A_type">type</code></td>
<td>
<p>the documentation type to be declared in the output file.</p>
</td></tr>
<tr><td><code id="promptClass_+3A_keywords">keywords</code></td>
<td>
<p>the keywords to include in the shell of the
documentation.  The keyword <code>"classes"</code> should be one of
them.</p>
</td></tr>
<tr><td><code id="promptClass_+3A_where">where</code></td>
<td>
<p>where to look for the definition of the class and of
methods that use it.

</p>
</td></tr>
<tr><td><code id="promptClass_+3A_generatorname">generatorName</code></td>
<td>
<p>the name for a generator function for this
class; only required if a generator function was created
<em>and</em> saved under a name different from the class name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class definition is found on the search list.  Using that
definition, information about classes extended and slots is
determined.
</p>
<p>In addition, the currently available generics with methods for this
class are found (using <code><a href="#topic+getGenerics">getGenerics</a></code>).  Note that these
methods need not be in the same environment as the class definition; in
particular, this part of the output may depend on which packages are
currently in the search list.
</p>
<p>As with other prompt-style functions, unless <code>filename</code> is
<code>NA</code>, the documentation shell is written to a file, and a message
about this is given.  The file will need editing to give information
about the <em>meaning</em> of the class.  The output of
<code>promptClass</code> can only contain information from the metadata
about the formal definition and how it is used.
</p>
<p>If <code>filename</code> is <code>NA</code>, a list-style representation of the
documentation shell is created and returned.  Writing the shell to a
file amounts to <code>cat(unlist(x), file = filename, sep = "\n")</code>,
where <code>x</code> is the list-style representation.
</p>
<p>If a generator function is found assigned under the class name or
the optional <code>generatorName</code>, skeleton documentation for that
function is added to the file.
</p>


<h3>Value</h3>

<p>If <code>filename</code> is <code>NA</code>, a list-style representation of the
documentation shell.  Otherwise, the name of the file written to is
returned invisibly.
</p>


<h3>Author(s)</h3>

<p>VJ Carey <a href="mailto:stvjc@channing.harvard.edu">stvjc@channing.harvard.edu</a> and John Chambers
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+prompt">prompt</a></code> for documentation of functions,
<code><a href="#topic+promptMethods">promptMethods</a></code> for documentation of method definitions.
</p>
<p>For processing of the edited documentation, either use
<code>R CMD <a href="base.html#topic+Rdconv">Rdconv</a></code>,
or include the edited file in the &lsquo;<span class="file">man</span>&rsquo; subdirectory of a
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: &gt; promptClass("track")
A shell of class documentation has been written to the
file "track-class.Rd".

## End(Not run)
</code></pre>

<hr>
<h2 id='promptMethods'> Generate a Shell for Documentation of Formal Methods </h2><span id='topic+promptMethods'></span>

<h3>Description</h3>

<p>Generates a shell of documentation for the methods of a generic
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promptMethods(f, filename = NULL, methods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promptMethods_+3A_f">f</code></td>
<td>
<p>a character string naming the generic function whose methods
are to be documented.</p>
</td></tr>
<tr><td><code id="promptMethods_+3A_filename">filename</code></td>
<td>
<p>usually, a connection or a character string giving the
name of the file to which the documentation shell should be written.
The default corresponds to the coded topic name for these methods
(currently, <code>f</code> followed by <code>"-methods.Rd"</code>).  Can also be
<code>FALSE</code> or <code>NA</code> (see below).</p>
</td></tr>
<tr><td><code id="promptMethods_+3A_methods">methods</code></td>
<td>
<p>optional <code>"<a href="#topic+listOfMethods-class">listOfMethods</a>"</code> object giving the methods to be
documented.  By default, the first methods object for this generic
is used (for example, if the current global environment has some
methods for <code>f</code>, these would be documented).
</p>
<p>If this argument is supplied, it is likely to be
<code><a href="#topic+findMethods">findMethods</a>(f, where)</code>, with <code>where</code> some package
containing methods for <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>filename</code> is <code>FALSE</code>, the text created is returned,
presumably to be inserted some other documentation file, such as the
documentation of the generic function itself (see
<code><a href="utils.html#topic+prompt">prompt</a></code>).
</p>
<p>If <code>filename</code> is <code>NA</code>, a list-style representation of the
documentation shell is created and returned.  Writing the shell to a
file amounts to <code>cat(unlist(x), file = filename, sep = "\n")</code>,
where <code>x</code> is the list-style representation.
</p>
<p>Otherwise, the documentation shell is written to the file specified by
<code>filename</code>.
</p>


<h3>Value</h3>

<p>If <code>filename</code> is <code>FALSE</code>, the text generated;
if <code>filename</code> is <code>NA</code>, a list-style representation of the
documentation shell.
Otherwise, the name of the file written to is returned invisibly.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+prompt">prompt</a></code> and
<code><a href="#topic+promptClass">promptClass</a></code>
</p>

<hr>
<h2 id='RClassUtils'>Utilities for Managing Class Definitions</h2><span id='topic+completeSubclasses'></span><span id='topic+newClassRepresentation'></span><span id='topic+print.classRepresentation'></span><span id='topic+setExtendsMetaData'></span><span id='topic+setSubclassMetaData'></span><span id='topic+subclassesMetaName'></span><span id='topic+extendsMetaName'></span><span id='topic+classPrototypeDef-class'></span><span id='topic+.classEnv'></span><span id='topic+classLabel'></span><span id='topic+testVirtual'></span><span id='topic+makePrototypeFromClassDef'></span><span id='topic+newEmptyObject'></span><span id='topic+completeClassDefinition'></span><span id='topic+getAllSuperClasses'></span><span id='topic+superClassDepth'></span><span id='topic+isVirtualClass'></span><span id='topic+assignClassDef'></span><span id='topic+newBasic'></span><span id='topic+makeExtends'></span><span id='topic+reconcilePropertiesAndPrototype'></span><span id='topic+tryNew'></span><span id='topic+empty.dump'></span><span id='topic+showClass'></span><span id='topic+showExtends'></span><span id='topic+possibleExtends'></span><span id='topic+completeExtends'></span><span id='topic+classMetaName'></span><span id='topic+methodsPackageMetaName'></span><span id='topic+metaNameUndo'></span><span id='topic+requireMethods'></span><span id='topic+checkAtAssignment'></span><span id='topic+checkSlotAssignment'></span><span id='topic+defaultPrototype'></span><span id='topic+isClassDef'></span><span id='topic+validSlotNames'></span><span id='topic+getDataPart'></span><span id='topic+setDataPart'></span><span id='topic+.BasicClasses'></span><span id='topic+.BasicVectorClasses'></span><span id='topic+.InitBasicClasses'></span><span id='topic+.InitMethodsListClass'></span><span id='topic+.setCoerceGeneric'></span><span id='topic+conditionalExtension-class'></span>

<h3>Description</h3>

<p>These are various functions to support the definition and use of
formal classes.  Most of them are rarely suitable to be called
directly.
</p>
<p>Others are somewhat experimental and/or partially implemented only. Do
refer to <code><a href="#topic+setClass">setClass</a></code> for normal code development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classLabel(Class)
.classEnv(Class, default = .requirePackage("methods"), mustFind = TRUE)

testVirtual(properties, extends, prototype, where)

makePrototypeFromClassDef(slots, ClassDef, extends, where)

newEmptyObject()

completeClassDefinition(Class, ClassDef, where, doExtends)

getAllSuperClasses(ClassDef, simpleOnly = TRUE)

superClassDepth(ClassDef, soFar, simpleOnly = TRUE)

isVirtualClass(Class, where)

newBasic(Class, ...)

makeExtends(Class, coerce, test, replace, by, package, slots,
            classDef1, classDef2)

reconcilePropertiesAndPrototype(name, properties, prototype,
                                superClasses, where)
tryNew(Class, where)

empty.dump()

showClass(Class, complete=TRUE, propertiesAreCalled="Slots")

showExtends(ext, printTo = stdout())

possibleExtends(class1, class2,
                ClassDef1 = getClassDef(class1),
                ClassDef2 = getClassDef(class2, where = .classEnv(ClassDef1)))

completeExtends(ClassDef, class2, extensionDef, where)

classMetaName(name)

methodsPackageMetaName(prefix, name, package = "")

metaNameUndo(strings, prefix, searchForm = FALSE)

requireMethods(functions, signature, message, where)

checkAtAssignment(cl, name, valueClass)
checkSlotAssignment(obj, name, value)

defaultPrototype()

isClassDef(object)

validSlotNames(names)

getDataPart(object, NULL.for.none = FALSE)
setDataPart(object, value, check = TRUE)

assignClassDef(Class, def, where = .GlobalEnv, force = FALSE,
               doSubclasses = is(def, "ClassUnionRepresentation"))

completeSubclasses(classDef, class2, extensionDef, where,
                   classDef2 = getClassDef(class2, where))

newClassRepresentation(...)
</code></pre>


<h3>Summary of Functions</h3>


<dl>
<dt><code>testVirtual</code>:</dt><dd>
<p>Test for a Virtual Class.
Figures out, as well as possible, whether the class with these
properties, extension, and prototype is a virtual class.
Can be forced to be virtual by extending <code>"VIRTUAL"</code>.
</p>
<p>Otherwise, a class is virtual only if it has no slots, extends no
non-virtual classes, and has a <code>NULL</code> Prototype.
</p>
</dd>
<dt><code>makePrototypeFromClassDef</code>:</dt><dd>
<p>Makes the prototype implied by the class definition.
</p>
<p>The following three rules are applied in this order.
</p>

<ol>
<li><p> If the class has slots, then the prototype for each slot
is used by default, but a corresponding element in the
explicitly supplied prototype in <code>ClassDef</code>, if there is
one, is used instead (but it must be coercible to the class of
the slot). This includes the data part (<code>".Data"</code> slot) if
there is one.
</p>
</li>
<li><p> If there are no slots but a non-null prototype was
specified, this is returned.
</p>
</li>
<li><p> If there is a non-virtual superclass (a class in the
extends list), then its prototype is used.  The data part is
extracted if needed (it is allowed to have two superclasses
with a data part; the first is used and a warning issued on
any others).
</p>
</li></ol>

<p>If all three of the above fail, the prototype is <code>NULL</code>.
</p>
</dd>
<dt><code>newEmptyObject</code>:</dt><dd>
<p>Utility function to create an empty object into which slots can be
set.
</p>
<p>Currently just creates an empty list with class <code>"NULL"</code>.
</p>
<p>Later version should create a special object reference that marks
an object currently with no slots and no data.
</p>
</dd>
<dt><code>completeClassDefinition</code>:</dt><dd>
<p>Completes the definition of <code>Class</code>, relative to the class
definitions visible from environment <code>where</code>.  If
<code>doExtends</code> is <code>TRUE</code>, complete the super- and
sub-class information.
</p>
<p>This function is called when a class is defined or re-defined.
</p>
</dd>
<dt><code>getFromClassDef</code>:</dt><dd>
<p>Extracts one of the intrinsically defined class definition
properties (&quot;.Properties&quot;, etc.)  Strictly a utility function.
</p>
</dd>

<dt><code>getSlots</code>:</dt><dd>
<p>Returns a named character vector.  The names are the names of the
slots, the values are the classes of the corresponding slots.
The argument <code>x</code> can either be the name of
a class or the class definition object.
</p>
</dd>
<dt><code>getAllSuperClasses</code>, <code>superClassDepth</code>:</dt><dd>
<p>Get the names of all the classes that this class definition
extends.
</p>
<p><code>getAllSuperClasses</code> is a utility function used to complete a
class definition.  It returns all the superclasses reachable from
this class, in breadth-first order (which is the order used for
matching methods); that is, the first direct superclass followed
by all its superclasses, then the next, etc.  (The order is
relevant only in the case that some of the superclasses have
multiple inheritance.)
</p>
<p><code>superClassDepth</code>, which is called from
<code>getAllSuperClasses</code>, returns the same information, but as a
list with components <code>label</code> and <code>depth</code>, the latter for
the number of generations back each class is in the inheritance
tree.  The argument <code>soFar</code> is used to avoid loops in the
network of class relationships.
</p>
</dd>
<dt><code>isVirtualClass</code>:</dt><dd>
<p>Is the named class a virtual class?
</p>
<p>A class is virtual if explicitly declared to be, and also if the
class is not formally defined.
</p>
</dd>

<dt><code>assignClassDef</code>:</dt><dd>
<p>assign the definition of the class to the specially named object
</p>
</dd>
<dt><code>newBasic</code>:</dt><dd>
<p>the implementation of the function <code>new</code> for basic classes
that don't have a formal definition.
</p>
<p>Any of these could have a formal definition, except for
<code>Class="NULL"</code> (disallowed because <code>NULL</code> can't have
attributes).  For all cases except <code>"NULL"</code>, the class of the
result will be set to <code>Class</code>.
</p>
<p>See <code>new</code> for the interpretation of the arguments.
</p>
</dd>
<dt><code>makeExtends</code>:</dt><dd>
<p>Construct an <code>"SClassExtension"</code> object representing the relationship
from <code>Class</code> to the class defined by <code>classDef2</code>. 
</p>
</dd>
<dt><code>reconcilePropertiesAndPrototype</code>:</dt><dd>
<p>makes a list or a structure look like a prototype for the given
class.
</p>
<p>Specifically, returns a structure with attributes corresponding to
the slot names in properties and values taken from prototype if
they exist there, from <code>new(classi)</code> for the class,
<code>classi</code> of the slot if that succeeds, and <code>NULL</code>
otherwise.
</p>
<p>The prototype may imply slots not in the properties list, since
properties does not include inherited slots (these are left
unresolved until the class is used in a session).
</p>
</dd>
<dt><code>tryNew</code>:</dt><dd>
<p>Tries to generate a new element from this class, but if the attempt
fails (as, e.g., when the class is undefined or virtual) just
returns <code>NULL</code>.
</p>
<p>This is inefficient and also not a good idea when actually
generating objects, but is useful in the initial definition of
classes.
</p>
</dd>
<dt><code>showClass</code>:</dt><dd>
<p>Print the information about a class definition.
</p>
<p>If <code>complete</code> is <code>TRUE</code>, include the indirect
information about extensions.
</p>
<p>It is the utility called from <code><a href="#topic+show">show</a>(<a href="#topic+getClass">getClass</a>(.))</code>,
and the user should typically use <code>getClass(.)</code> for looking
at class definitions.
</p>
</dd>
<dt><code>showExtends</code>:</dt><dd>
<p>Print the elements of the list of extensions; for <code>printTo = FALSE</code>,
returns a list with components <code>what</code> and <code>how</code>; this is
used e.g., by <code><a href="#topic+promptClass">promptClass</a>()</code>.
</p>
</dd>
<dt><code>possibleExtends</code>:</dt><dd>
<p>Find the information that says whether class1 extends class2,
directly or indirectly.
</p>
<p>This can be either a logical value or an object of class
<code><a href="#topic+SClassExtension-class">SClassExtension</a></code> containing various
functions to test and/or coerce the relationship.
</p>
</dd>
<dt><code>classLabel</code>: </dt><dd>
<p>Returns an informative character string identifying the class
and, if appropriate, the package from which the class came.
</p>
</dd>
<dt><code>.classEnv</code>: </dt><dd>
<p>Returns the environment, typically a namespace, in which the
<code>Class</code> has been defined.  <code>Class</code> should typically be
the result of <code><a href="base.html#topic+class">class</a>()</code> (and hence contain a
<code>"package"</code> attribute) or <code><a href="#topic+getClass">getClass</a></code> (or
<code><a href="#topic+getClassDef">getClassDef</a></code>).
</p>
</dd>
<dt><code>completeExtends</code>:</dt><dd>
<p>complete the extends information in the class definition, by
following transitive chains.
</p>
<p>If <code>class2</code> and <code>extensionDef</code> are included, this
class relation is to be added.  Otherwise just use the current
<code>ClassDef</code>.
</p>
<p>Both the <code>contains</code> and <code>subclasses</code> slots are
completed with any indirect relations visible.
</p>
</dd>
<dt><code>classMetaName</code>:</dt><dd>
<p>a name for the object storing this class's definition
</p>
</dd>
<dt><code>methodsPackageMetaName</code>:</dt><dd>
<p>a name mangling device to hide metadata defining method and
class information.
</p>
</dd>
<dt><code>metaNameUndo</code></dt><dd>
<p>As its name implies, this function undoes the
name-mangling used to produce meta-data object names, and
returns a object of class <code><a href="#topic+ObjectsWithPackage-class">ObjectsWithPackage</a></code>.
</p>
</dd>
<dt><code>requireMethods</code>:</dt><dd>
<p>Require a subclass to implement methods for the generic functions,
for this signature.
</p>
<p>For each generic, <code>setMethod</code> will be called to define a
method that throws an error, with the supplied message.
</p>
<p>The <code>requireMethods</code> function allows virtual classes to
require actual classes that extend them to implement methods for
certain functions, in effect creating an API for the virtual class.
</p>
<p>Otherwise, default methods for the corresponding function would be
called, resulting in less helpful error messages or (worse still)
silently incorrect results.
</p>
</dd>
<dt><code>checkSlotAssignment</code>, <code>checkAtAssignment</code>:</dt><dd>
<p>Check that the value provided is allowed for this slot, by
consulting the definition of the class.  Called from the C code
that assigns slots.
</p>
<p>For privileged slots (those that can only be set by accessor
functions defined along with the class itself), the class designer
may choose to improve efficiency by validating the value to be
assigned in the accessor function and then calling <code>slot&lt;-</code>
with the argument <code>check=FALSE</code>, to prevent the call to
<code>checkSlotAssignment</code>.
</p>
</dd>
<dt><code>defaultPrototype</code>:</dt><dd>
<p>The prototype for a class which will have slots, is not a virtual
class, and does not extend one of the basic classes. Both its
<code><a href="base.html#topic+class">class</a></code> and its (<span class="rlang"><b>R</b></span> internal) type,
<code><a href="base.html#topic+typeof">typeof</a>()</code>, are <code>"S4"</code>.
</p>
</dd>
<dt><code>.InitBasicClasses</code>, <code>.InitMethodsListClass</code>, <code>.setCoerceGeneric</code>:</dt><dd>
<p>These functions perform part of the initialization of classes and
methods, and are called (only!) from <code>.onLoad</code>.
</p>
</dd>
<dt><code>isClassDef</code>:</dt><dd>
<p>Is <code>object</code> a representation of a class?
</p>
</dd>
<dt><code>validSlotNames</code>:</dt><dd>
<p>Returns <code>names</code> unless one of the names is reserved, in which
case there is an error.  (As of writing, <code>"class"</code> is the
only reserved slot name.)
</p>
</dd>
<dt><code>getDataPart</code>, <code>setDataPart</code>:</dt><dd>
<p>Utilities called to implement
<code>object@.Data</code>.  Calls to <code>setDataPart</code> are also used
to merge the data part of a superclass prototype.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>typeof(defaultPrototype()) #-&gt; "S4"

## .classEnv()
meth.ns &lt;- asNamespace("methods")
if(get4 &lt;- !any("package:stats4" == search()))
   require("stats4")
stopifnot(TRUE
 , identical(.classEnv("data.frame"), meth.ns)
 , identical(.classEnv(class(new("data.frame"))), meth.ns)
 , identical(.classEnv(     "mle"       ), meth.ns) # &lt;- *not* 'stats4'
 , identical(.classEnv(class(new("mle"))), asNamespace("stats4"))
 , identical(.classEnv(getClass ("mle") ), asNamespace("stats4"))
 )
if(get4) detach("package:stats4")
</code></pre>

<hr>
<h2 id='ReferenceClasses'>Objects With Fields Treated by Reference (<abbr>OOP</abbr>-style)</h2><span id='topic+ReferenceClasses'></span><span id='topic+setRefClass'></span><span id='topic+getRefClass'></span><span id='topic+initFieldArgs'></span><span id='topic+initRefFields'></span><span id='topic+activeBindingFunction-class'></span><span id='topic+defaultBindingFunction-class'></span><span id='topic+uninitializedField-class'></span><span id='topic+refClassRepresentation-class'></span><span id='topic+refObjectGenerator-class'></span><span id='topic+refGeneratorSlot-class'></span><span id='topic+refClass-class'></span><span id='topic+refObject-class'></span><span id='topic+refMethodDef-class'></span><span id='topic+refMethodDefWithTrace-class'></span><span id='topic+SuperClassMethod-class'></span><span id='topic+show+2CenvRefClass-method'></span><span id='topic+show+2CrefMethodDef-method'></span><span id='topic+show+2CexternalRefMethod-method'></span><span id='topic+show+2CrefClassRepresentation-method'></span><span id='topic+externalRefMethod'></span><span id='topic+externalRefMethod-class'></span>

<h3>Description</h3>

<p>The software described here allows packages to define <em>reference
classes</em> that behave in the style of &ldquo;<abbr>OOP</abbr>&rdquo; languages such as Java and
C++.
This model for <abbr>OOP</abbr> differs from the functional model implemented by S4
(and S3) classes and methods, in which methods are defined for generic
functions.
Methods for reference classes are &ldquo;encapsulated&rdquo; in the class definition.
</p>
<p>Computations with objects from reference classes invoke methods on them and
extract or set their fields, using  the <code>`$`</code> operator in <span class="rlang"><b>R</b></span>.
The field and method computations potentially modify the object.
All computations referring to the objects see the modifications, in contrast to
the usual functional programming model in <span class="rlang"><b>R</b></span>.
</p>
<p>A call to
<code>setRefClass</code> in the source code for a package defines the class and returns a generator object.
Subsequent calls to the <code>$methods()</code> 
method of the generator will define methods for the class.
As with functional classes, if the class is exported from the package,
it will be available when the package is loaded.
</p>
<p>Methods are <span class="rlang"><b>R</b></span> functions.  In their usual implementation, they refer to fields
and other methods of the class directly by name. See the section on
&ldquo;Writing Reference Methods&rdquo;.
</p>
<p>As with functional classes, reference classes can inherit from other
reference classes via a <code>contains=</code> argument to
<code>setRefClass</code>.  Fields and methods will be inherited, except where the
new class overrides method definitions.  See the section on &ldquo;Inheritance&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRefClass(Class, fields = , contains = , methods =,
     where =, inheritPackage =, ...)

getRefClass(Class, where =)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReferenceClasses_+3A_class">Class</code></td>
<td>

<p>character string name for the class.
</p>
<p>In the call to <code>getRefClass()</code> this argument can also be any
object from the relevant class.
</p>
</td></tr>
<tr><td><code id="ReferenceClasses_+3A_fields">fields</code></td>
<td>

<p>either a character vector of field names or
a named list of the fields.  The resulting fields will be accessed with reference semantics (see
the  section on &ldquo;Reference Objects&rdquo;).  If the argument is a list, each
element of the list should usually be the character string name of a class, in
which case the object in the field must be from that class or a
subclass.  An alternative, but not generally recommended, is to supply an  <em>accessor
function</em>; see the section on &ldquo;Implementation&rdquo; for accessor
functions and the related internal mechanism.
</p>
<p>Note that fields are distinct from
slots.  Reference classes should not define class-specific slots. See
the note on slots in the
&ldquo;Implementation&rdquo; section.
</p>
</td></tr>
<tr><td><code id="ReferenceClasses_+3A_contains">contains</code></td>
<td>

<p>optional vector of superclasses for this class.  If a superclass is
also a reference class, the fields and class-based methods will be inherited.
</p>
</td></tr>
<tr><td><code id="ReferenceClasses_+3A_methods">methods</code></td>
<td>

<p>a named list of function definitions that can be invoked on objects
from this class.  These can also be created by invoking the
<code>$methods</code> method on the generator object returned. 
See the section on &ldquo;Writing Reference Methods&rdquo; for details.
</p>
</td></tr>
<tr><td><code id="ReferenceClasses_+3A_where">where</code></td>
<td>

<p>for <code>setRefClass</code>, the environment in which to store the class definition.  Should be
omitted in calls from a package's source code.
</p>
<p>For <code>getRefClass</code>, the environment from which to search for the definition.  If the
package is not loaded or you need to be specific, use
<code><a href="base.html#topic+asNamespace">asNamespace</a></code> with the package name.
</p>
</td></tr>
<tr><td><code id="ReferenceClasses_+3A_inheritpackage">inheritPackage</code></td>
<td>

<p>Should objects from the new class inherit the package environment of a
contained superclass?  Default <code>FALSE</code>.  See the Section &ldquo;Inter-Package Superclasses
and External Methods&rdquo;.
</p>
</td></tr> 
<tr><td><code id="ReferenceClasses_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to <code><a href="#topic+setClass">setClass</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setRefClass()</code> returns a generator function suitable for
creating objects from the class, invisibly.  A call to this function
takes any number of arguments,
which will be passed on to the initialize method.  If no
<code>initialize</code> method is defined for the class or one of its
superclasses, the default method expects named arguments with the
name of one of the fields and unnamed arguments, if any, that are
objects from one of the superclasses of this class (but only
superclasses that are themselves reference classes have any effect).
</p>
<p>The generator function is similar to the S4 generator function
returned by <code><a href="#topic+setClass">setClass</a></code>. In addition to being a generator
function, however, it is also a reference class generator object,
with reference class methods for various utilities.  See the section
on reference class generator objects below.
</p>
<p><code>getRefClass()</code> also returns the generator function for the
class.  Note that the package slot in the value is the correct package
from the class definition, regardless of  the <code>where</code> argument,
which is used only to
find the class if necessary.
</p>


<h3>Reference Objects</h3>

<p>Normal objects in <span class="rlang"><b>R</b></span> are passed as arguments in function calls consistently with
functional programming semantics; that is, changes made to an object
passed as an argument are local to the function call.  The object that
supplied the argument is unchanged.
</p>
<p>The functional model (sometimes called pass-by-value, although this is
inaccurate for <span class="rlang"><b>R</b></span>) is
suitable for many statistical computations and is implicit, for
example, in the basic <span class="rlang"><b>R</b></span> software for fitting statistical models.
In some other situations, one would like all the code dealing with an
object to see the exact same content, so that changes made in any
computation would be reflected everywhere.
This is often suitable if the object has some &ldquo;objective&rdquo;
reality, such as a window in a user interface.
</p>
<p>In addition, commonly used languages, including Java, C++ and many
others, support a version of classes and methods assuming reference
semantics.
The corresponding programming mechanism
is to invoke a method on an object.
In the <span class="rlang"><b>R</b></span> syntax we use <code>"$"</code> 
for this operation; one invokes a method,
<code>m1</code> say, on an object <code>x</code> by the expression
<code>x$m1(...)</code>. 
</p>
<p>Methods in this paradigm are associated with the object, or more
precisely with the class of the object, as opposed to methods in a
function-based class/method system, which are fundamentally associated
with the function (in <span class="rlang"><b>R</b></span>, for example, a generic function in an <span class="rlang"><b>R</b></span>
session has a table of all its currently known methods).
In this document &ldquo;methods for a class&rdquo; as opposed to
&ldquo;methods for a function&rdquo; will make the distinction.
</p>
<p>Objects in this paradigm usually have named fields on which
the methods operate.
In the <span class="rlang"><b>R</b></span> implementation, the fields are defined when the class is
created.
The field itself can optionally have a specified class, meaning that only objects
from this class or one of its subclasses can be assigned to the field.
By default, fields have class <code>"ANY"</code>.
</p>
<p>Fields are accessed by reference.
In particular, invoking a method may modify the content of
the fields.
</p>
<p>Programming for such classes involves writing new methods for a
particular class.
In the <span class="rlang"><b>R</b></span> implementation, these methods are <span class="rlang"><b>R</b></span> functions, with zero or
more formal arguments.
For standard reference methods, the object itself is not an explicit
argument to the method.
Instead, fields and methods for the class can be referred to by name
in the method definition.
The implementation uses <span class="rlang"><b>R</b></span> environments to make fields and other methods
available by name within the method.
Specifically, the parent environment of the method is the object itself.
See the section on &ldquo;Writing
Reference Methods&rdquo;.
This special use of environments is optional.  If a method is defined
with an initial formal argument <code>.self</code>, that will be passed in
as the whole object, and the method follows the standard rules for any
function in a package.  See the section on &ldquo;External Methods&rdquo;
</p>
<p>The goal of the software described here is to provide a uniform
programming style in <span class="rlang"><b>R</b></span> for software dealing with reference classes, whether
implemented directly in <span class="rlang"><b>R</b></span> or through an interface to one of the <abbr>OOP</abbr>
languages.
</p>


<h3>Writing Reference Methods</h3>

<p>Reference methods are functions supplied as elements of a named list,
either
when invoking <code>$methods()</code> 
on a generator object <code>g</code> or as
the argument <code>methods</code> in a call to <code>setRefClass</code>.
The two mechanisms have the same effect, but the first makes the code more readable.
</p>
<p>Methods are written as ordinary <span class="rlang"><b>R</b></span> functions but have some special
features and restrictions in their usual form.
In contrast to some other languages (e.g., Python), the object itself
does not need to be an argument in the method definition.
The body of the function can contain calls to any other reference method,
including those inherited from other reference classes and may refer
to methods and to fields in the object by name.
</p>
<p>Alternatively, a method may be an <em>external</em> method.
This is signalled by <code>.self</code> being the first formal argument to the method.
The body of the method then works like any ordinary function.
The methods are called like other methods (without the <code>.self</code>
argument, which is supplied internally and always refers to the object
itself).
Inside the method, fields and other methods are accessed in the form
<code>.self$x</code>. 
External methods exist so that reference classes can inherit the
package environment of superclasses
in other packages; see the section on &ldquo;External Methods&rdquo;.
</p>
<p>Fields may be modified in a method by using the
non-local assignment operator, <code>&lt;&lt;-</code>, as in the <code>$edit</code> and <code>$undo</code>
methods in the example below.
Note that non-local assignment is required:  a local assignment with
the <code>&lt;-</code> operator just creates a local object in the function
call, as it would in any <span class="rlang"><b>R</b></span> function.
When methods are installed, a heuristic check is made for local
assignments to field names and a warning issued if any are detected.
</p>
<p>Reference methods should be kept simple; if they need to do some
specialized <span class="rlang"><b>R</b></span> computation, that computation should use a separate <span class="rlang"><b>R</b></span>
function that is called from the reference method.
Specifically, methods can not use special features of the
enclosing environment mechanism, since the method's environment is
used to access fields and other methods.
In particular, methods should not use non-exported entries in the
package's namespace, because the methods may be inherited by a
reference class in another package.
</p>
<p>Two method names are interpreted specially, <code>initialize</code>
and <code>finalize</code>. If an <code>initialize</code> method is defined, it
will be invoked when an object is generated from the class.  See the
discussion of method <code>$new(...)</code> 
in the section &ldquo;Initialization Methods&rdquo;.
</p>
<p>If a <code>finalize</code> method is defined, a function will be
<a href="base.html#topic+reg.finalizer">registered</a> to invoke it before the environment in
the object is discarded by the garbage collector; finalizers are
registered with <code>atexit=TRUE</code>, and so are also run at the end of
<span class="rlang"><b>R</b></span> sessions. See the matrix viewer example for both initialize and
finalize methods.
</p>
<p>Reference methods can not themselves be generic functions; if you want
additional function-based method dispatch, write a separate generic
function and call that from the method.
</p>
<p>Two special object names are available.
The entire object can be referred to in a method by the reserved
name <code>.self</code>.
The object <code>.refClassDef</code> contains the definition of the
class of the object.
These are accessed as fields but are read-only, with one exception.
In principal, the <code>.self</code> field can be modified in the <code>$initialize</code> 
method, because the object is still being created at this stage.
This is not recommended, as it can invalidate the object with respect
to its class.
</p>
<p>The methods available include methods inherited from superclasses, as
discussed in the section &ldquo;Inheritance&rdquo;.
</p>
<p>Only methods actually used will be included in the environment
corresponding to an individual object.  To declare that a method requires a
particular other method, the first method should include a call
to <code>$usingMethods()</code> 
with the name of the other method as an argument.
Declaring the methods this way is essential if the other method is used indirectly (e.g., via <code><a href="base.html#topic+sapply">sapply</a>()</code>
or <code><a href="base.html#topic+do.call">do.call</a>()</code>).
If it is called directly, code analysis will find it.
Declaring the method is harmless in any case, however, and may aid
readability of the source code.
</p>
<p>Documentation for the methods can be obtained by the <code>$help</code> 
method for the generator object.
Methods for classes are not documented in the <code>Rd</code> format used
for <span class="rlang"><b>R</b></span> functions.
Instead, the <code>$help</code> 
method prints the calling sequence of the method, followed by
self-documentation from the method definition, in the style of Python.
If the first element of the body of the method is a literal character
string (possibly multi-line), that string is interpreted as documentation.
See the method definitions in the example.
</p>


<h3>Initialization Methods</h3>

<p>If the class has a method defined for <code>$initialize()</code>, 
this method will be called once the reference object has been
created.  You should write such a method for a class that needs to do
some special initialization.
In particular, a reference method is recommended rather than a method
for the S4 generic function <code>initialize()</code>, because some special initialization is
required for reference objects <em>before</em> the initialization of
fields.
As with S4 classes, methods are written for <code>$initialize()</code> 
and not for <code>$new()</code>, 
both for the previous reason and also because <code>$new()</code> 
is invoked on the generator object and would be a method for that class.
</p>
<p>The default method for <code>$initialize()</code> 
is equivalent to invoking the method <code>$initFields(...)</code>. 
Named arguments assign initial values to the corresponding fields.
Unnamed arguments must be objects from this class or a reference
superclass of this class.
Fields will be initialized to the contents of the fields in such
objects, but named arguments override the corresponding inherited
fields.
Note that fields are simply assigned.  If the field is itself a
reference object, that object is not copied.
The new and previous object will share the reference.
Also, a field assigned from an unnamed argument counts as an
assignment for locked fields.
To override an inherited value for a locked field, the new value must
be one of the named arguments in the initializing call.
A later assignment of the field will result in an error.
</p>
<p>Initialization methods need some care in design.
The generator
for a reference class will be called with no arguments, for example
when copying the object.
To ensure that these calls do not fail, the method must have defaults
for all arguments or check for <code>missing()</code>.
The method
should include <code>...</code> as an argument and
pass this on via <code>$callSuper()</code> (or <code>$initFields()</code> if
you know that your superclasses have no initialization methods).
This allows future class definitions that subclass this class, with
additional fields.
</p>


<h3>Inheritance</h3>

<p>Reference classes inherit from other reference classes by using the
standard <span class="rlang"><b>R</b></span> inheritance; that is, by including the superclasses in the
<code>contains=</code> argument when creating the new class.
The names of the reference superclasses are in slot
<code>refSuperClasses</code> of the class definition.
Reference classes can inherit from ordinary S4 classes also, but this
is usually a bad idea if it mixes reference fields and non-reference slots.
See the comments in the section on &ldquo;Implementation&rdquo;.
</p>
<p>Class fields are inherited.  A class definition can override a field
of the same name in a superclass only if the overriding class is a
subclass of the class of the inherited field.  This ensures that a
valid object in the field remains valid for the superclass as well.
</p>
<p>Inherited methods are installed in the same way as directly
specified methods.
The code in a method can refer to  inherited methods in the same
way as directly specified methods.
</p>
<p>A method may override a method of the same name in a superclass.
The overriding method can call the superclass method by
<code>callSuper(...)</code> as described below.
</p>


<h3>Methods Provided for all Objects</h3>

<p>All reference classes inherit from the class <code>"envRefClass"</code>.
All reference objects can use the following methods.
</p>

<dl>
<dt><code>$callSuper(...)</code></dt><dd> 
<p>Calls the method inherited from a reference superclass.
The call is meaningful only from within another method, and will be
resolved to call the inherited method of the same name.
The arguments to <code>$callSuper</code> 
are passed to the superclass version.
See the matrix viewer class in the example.
</p>
<p>Note that the intended arguments for the superclass method must be
supplied explicitly; there is no convention for supplying the
arguments automatically, in contrast to the similar mechanism for
functional methods.
</p>
</dd>
<dt><code>$copy(shallow = FALSE)</code></dt><dd> 
<p>Creates a copy of the object.  With reference classes, unlike ordinary
<span class="rlang"><b>R</b></span> objects, merely assigning the object with a different name does not
create an independent copy.  If <code>shallow</code> is <code>FALSE</code>, any
field that is itself a reference object will also be copied, and
similarly recursively for its fields.  Otherwise, while reassigning a
field to a new reference object will have no side effect, modifying
such a field will still be reflected in both copies of the object.
The argument has no effect on non-reference objects in fields.  When
there are reference objects in some fields but it is asserted that
they will not be modified, using <code>shallow = TRUE</code> will save some
memory and time.
</p>
</dd>
<dt><code>$field(name, value)</code></dt><dd> 
<p>With one argument, returns the field of the object with character
string <code>name</code>.  With two arguments, the corresponding field is
assigned <code>value</code>.  Assignment checks that <code>name</code> specifies a
valid field, but the single-argument version will attempt to get
anything of that name from the object's environment.
</p>
<p>The <code>$field()</code> 
method replaces the direct use of a field name, when the name of the
field must be calculated, or for looping over several fields.
</p>
</dd>
<dt><code>$export(Class)</code></dt><dd> 
<p>Returns the result of coercing the object to <code>Class</code> (typically
one of the superclasses of the object's class).  Calling the method
has no side effect on the object itself.
</p>
</dd>
<dt><code>$getRefClass()</code>; <code>$getClass()</code></dt><dd>
<p>These return respectively the generator object and the formal class
definition for the reference class of this object, efficiently.
</p>
</dd>
<dt><code>$import(value, Class = class(value))</code></dt><dd> 
<p>Import the object <code>value</code> into the current object, replacing the
corresponding fields in the current object.
Object <code>value</code> must come from one of the superclasses of the
current object's class.
If argument <code>Class</code> is supplied, <code>value</code> is first coerced to
that class.
</p>
</dd>
<dt><code>$initFields(...)</code></dt><dd> 
<p>Initialize the fields of the object from the supplied arguments.  This
method is usually only called from a class with a <code>$initialize()</code>
method.  It corresponds to the default initialization for reference
classes.  If there are slots and non-reference superclasses, these may
be supplied in the ... argument as well.
</p>
<p>Typically, a specialized <code>$initialize()</code>
method carries out its own computations, then invokes <code>$initFields()</code>
to perform standard initialization, as shown in the
<code>matrixViewer</code> class in the example below.
</p>
</dd>
<dt><code>$show()</code></dt><dd> 
<p>This method is called when the object is printed automatically,
analogously to the <code><a href="#topic+show">show</a></code> function.  A general method is
defined for class <code>"envRefClass"</code>.  User-defined reference
classes will often define their own method: see the Example below.
</p>
<p>Note two points in the example.  As with any <code>show()</code> method, it
is a good idea to print the class explicitly to allow for subclasses
using the method.  Second, to call the <em>function</em> <code>show()</code>
from the method, as opposed to the <code>$show()</code> 
method itself, refer to <code>methods::show()</code> explicitly.
</p>
</dd>
<dt><code>$trace(what, ...)</code>, <code>$untrace(what)</code> </dt><dd>
<p>Apply the tracing and debugging facilities of the <code><a href="base.html#topic+trace">trace</a></code>
function to the reference method <code>what</code>.
</p>
<p>All the arguments of the <code><a href="base.html#topic+trace">trace</a></code>
function can be supplied, except for <code>signature</code>, which is not
meaningful.
</p>
<p>The reference method can be invoked on either an object or the
generator for the class.  See the section on Debugging below for details.
</p>
</dd>
<dt><code>$usingMethods(...)</code></dt><dd> 
<p>Reference methods used by this method are named as the arguments
either quoted or unquoted.  In the code analysis phase of installing
the present method, the declared methods will be included.  It is essential
to declare any methods used in a nonstandard way (e.g., via an apply function).
Methods called directly do not need to be declared, but it is harmless to do so.
<code>$usingMethods()</code> does nothing at run time. 
</p>
</dd>
</dl>
 
<p>Objects also inherit two reserved fields:
</p>

<dl>
<dt><code>.self</code></dt><dd>
<p>a reference to the entire object;
</p>
</dd>
<dt><code>.refClassDef</code></dt><dd>
<p>the class definition.
</p>
</dd>
</dl>
 
<p>The defined fields should not override these, and in general it is
unwise to define a field whose name begins with <code>"."</code>, since the
implementation may use such names for special purposes.
</p>


<h3>External Methods; Inter-Package Superclasses </h3>

<p>The environment of a method in a reference class is the object itself,
as an environment.
This allows the method to refer directly to fields and other methods,
without using the whole object and the <code>"$"</code> 
operator.
The parent of that environment is the namespace of the package in
which the reference class is defined.
Computations in the method have access to all the objects in the
package's namespace, exported or not.
</p>
<p>When defining a class that contains a reference superclass in another
package, there is an ambiguity about which package namespace should
have that role.
The argument <code>inheritPackage</code> to <code>setRefClass()</code> controls
whether the environment of new objects should inherit from an
inherited class in another package or continue to inherit from the
current package's namespace.
</p>
<p>If the superclass is &ldquo;lean&rdquo;, with few methods, or exists
primarily to support a family of subclasses, then it may be better to
continue to use the new package's environment.
On the other hand, if the superclass was originally written as a
standalone, this choice may invalidate existing superclass methods.
For the superclass methods to continue to work, they must use only
exported functions in their package and the new package must import
these.
</p>
<p>Either way, some methods may need to be written that do <em>not</em>
assume the standard model for reference class methods, but behave
essentially as ordinary functions would in dealing with reference
class objects.
</p>
<p>The mechanism is to recognize <em>external methods</em>.
An external method  is
written as a function in which the first argument, named <code>.self</code>,
stands for the reference class object.
This function is supplied as the definition for a reference class method.
The method will be called, automatically, with the first argument
being the current object and the other arguments, if any, passed along
from the actual call.
</p>
<p>Since an external method is an ordinary function in the source code
for its package, it has access to all the objects in the namespace.
Fields and methods in the reference class must be referred to in the
form <code>.self$name</code>.
</p>
<p>If for some reason you do not want to use <code>.self</code> as the first
argument, a function <code>f()</code> can be converted explicitly as
<code>externalRefMethod(f)</code>, which returns an object of class
<code>"externalRefMethod"</code> that can be supplied as a method for the
class.
The first argument will still correspond to the whole object.
</p>
<p>External methods can be supplied for any reference class, but there is no
obvious advantage unless they are needed.
They are more work to write, harder to read and (slightly) slower to
execute.
</p>
<p><em>NOTE:</em> If you are the author of a package whose reference
classes are likely to be subclassed in other packages, you can avoid
these questions entirely by writing methods that <em>only</em> use
exported functions from your package, so that all the methods will
work from another package that imports yours.
</p>


<h3>Reference Class Generators</h3>

<p>The call to <code>setRefClass</code> defines the specified class and
returns a &ldquo;generator function&rdquo; object for that class.
This object has class <code>"refObjectGenerator"</code>; it inherits
from <code>"function"</code> via <code>"classGeneratorFunction"</code> and can be
called to generate new objects from the reference class.
</p>
<p>The returned object is also a reference class object, although not of
the standard construction.
It can be used to invoke reference methods and access fields in the usual way, but
instead of being implemented directly as an environment it has a
subsidiary generator object as a slot, a
standard reference object (of class
<code>"refGeneratorSlot"</code>).
Note that if one wanted to extend the reference class generator
capability with a subclass, this should be done by subclassing
<code>"refGeneratorSlot"</code>, not <code>"refObjectGenerator"</code>.
</p>
<p>The fields are <code>def</code>, the class definition, and <code>className</code>,
the character string name of the class.
Methods generate objects
from the class, to access help on reference methods, and to
define new reference methods for the class.
The currently available methods are:
</p>

<dl>
<dt><code>$new(...)</code></dt><dd> 
<p>This method is equivalent to calling the generator function returned
by <code>setRefClass</code>.
</p>
</dd>
<dt><code>$help(topic)</code></dt><dd> 
<p>Prints brief help on the topic.  The topics recognized
are reference method names, quoted or not.
</p>
<p>The information printed is the calling sequence for the method, plus
self-documentation if any.
Reference methods can have an initial character string or vector as
the first element in the body of the function defining the method.
If so, this string is taken as self-documentation for the method (see
the section on &ldquo;Writing Reference Methods&rdquo; for details).
</p>
<p>If no topic is given or if the topic is not a method name, the
definition of the class is printed.
</p>
</dd>
<dt><code>$methods(...)</code></dt><dd> 
<p>With no arguments, returns the names of the reference methods for this
class.
With one character string argument, returns the method of that name.
</p>
<p>Named arguments
are method definitions, which will be
installed in the class, as if they had been supplied in the
<code>methods</code> argument to <code>setRefClass()</code>.
Supplying methods in this way, rather than in the call to
<code>setRefClass()</code>, is recommended for the sake of clearer source
code.
See the section on &ldquo;Writing Reference Methods&rdquo; for details.
</p>
<p>All methods for a class should be defined in the source code that
defines the class, typically as part of a package.
In particular, methods can not be redefined in a class in an attached
package with a namespace: The class method checks for a locked
binding of the class definition.
</p>
<p>The new methods can refer to any currently defined method by name
(including other methods supplied in this call to
<code>$methods()</code>). 
Note though that previously defined methods are not re-analyzed
meaning that they will not call the new method (unless it redefines an
existing method of the same name).
</p>
<p>To remove a method, supply <code>NULL</code> as its new definition.
</p>
</dd>
<dt><code>$fields()</code></dt><dd> 
<p>Returns a list of the fields, each with its corresponding class.
Fields for which an accessor function was supplied in the definition
have class <code>"activeBindingFunction"</code>.
</p>
</dd>
<dt><code>$lock(...)</code></dt><dd> 
<p>The fields named in the arguments are locked; specifically, after the
lock method is called, the field may be set once.  Any further attempt
to set it will generate an error.
</p>
<p>If called with no arguments, the method returns the names of the
locked fields.
</p>
<p>Fields that are defined by an explicit accessor function can not be
locked (on the other hand, the accessor function can be defined to
generate an error if called with an argument).
</p>
<p>All code to lock fields should normally be part of the definition of a
class; that is, the read-only nature of the fields is meant to be part
of the class definition, not a dynamic property added later.
In particular, fields can not be locked in a class in an attached
package with a namespace:  The class method checks for a locked
binding of the class definition.  Locked fields can not be
subsequently unlocked.
</p>
</dd>
<dt><code>$trace(what, ..., classMethod = FALSE)</code></dt><dd> 
<p>Establish a traced version of method <code>what</code> for objects generated
from this class.  The generator object tracing works like the
<code>$trace()</code>
method for objects from the class, with two differences.
Since it changes the method definition in the class object itself,
tracing applies to all objects, not just the one on which the trace
method is invoked.
</p>
<p>Second, the optional argument <code>classMethod = TRUE</code> allows tracing
on the methods of the generator object itself.
By default, <code>what</code> is interpreted as the name of a method in the
class for which this object is the generator.
</p>
</dd>
<dt><code>$accessors(...)</code></dt><dd> 
<p>A number of
systems using the <abbr>OOP</abbr> programming paradigm recommend or enforce
<em>getter and setter methods</em>
corresponding to each field, rather than direct access by name.
If you like this style and want to  extract a field named <code>abc</code>
by <code>x$getAbc()</code> and assign it by
<code>x$setAbc(value)</code>,
the <code>$accessors</code> 
method is a convenience function that creates such getter and setter methods for the
specified fields.
Otherwise there is no reason to use this mechanism.  In particular, it
has nothing to do with the general ability to define fields by
functions as described in the section on &ldquo;Reference Objects&rdquo;.
</p>
</dd>
</dl>
 


<h3>Implementation; Reference Classes as S4 Classes</h3>

<p>Reference classes are implemented as S4 classes with a data part of
type <code>"environment"</code>.
Fields correspond to named objects in the environment.
A field associated with a function is implemented as an
<a href="base.html#topic+bindenv">active binding</a>.
In particular, fields with a specified class are implemented as a
special form of active binding to enforce valid assignment to the
field.
</p>
<p>As a related feature,  the element in the <code>fields=</code> list supplied
to <code>setRefClass</code> can be an <em>accessor
function</em>, a function of one argument that returns
the field if called with no argument or sets it to the value of the
argument otherwise.
Accessor functions are used internally and for inter-system interface
applications, but not generally recommended as they blur the concept
of fields as data within the object.
</p>
<p>A field, say <code>data</code>, can be accessed generally by an expression
of the form <code>x$data</code> 
for any object from the relevant class.
In an internal method for this class, the field can be accessed by the name
<code>data</code>.
A field that is not locked can be set by an expression of the form
<code>x$data &lt;- value</code>.
Inside an internal method, a field can be assigned by an expression of the form
<code>x &lt;&lt;- value</code>.
Note the <a href="base.html#topic+assignOps">non-local assignment</a> operator.
The standard <span class="rlang"><b>R</b></span> interpretation of this operator works to assign it in
the environment of the object.
If the field has an accessor function defined, getting and setting
will call that function.
</p>
<p>When a method is invoked on an object, the function defining the method is
installed in the object's environment, with the same environment as the
environment of the function.
</p>
<p>Reference classes can have validity methods in the same sense as any
S4 class (see <code><a href="#topic+setValidity">setValidity</a></code>).
Such methods are often a good idea; they will be called by calling
<code><a href="#topic+validObject">validObject</a></code> and a validity method, if one is defined,
will be called when a reference object is created (from version 3.4 of
<span class="rlang"><b>R</b></span> on).
Just remember that these are S4 methods.  The function will be called
with the <code>object</code> as its argument.  Fields and methods must be
accessed using <code>$</code>.
</p>
<p><em>Note: Slots.</em> Because of the implementation, new reference classes can inherit from
non-reference S4 classes as well as reference classes, and can include
class-specific slots in the definition.
This is usually a bad idea, if the slots from the non-reference
class are thought of as alternatives to fields.
Slots will as always be treated functionally.
Therefore, changes to the slots and the fields will behave inconsistently,
mixing the functional
and reference paradigms for properties of the same object,
conceptually unclear and prone to errors.
In addition, the initialization method for the class will have to sort
out fields from slots, with a good chance of creating anomalous
behavior for subclasses of this class.
</p>
<p>Inheriting from a <a href="#topic+setClassUnion">class union</a>, however, is a reasonable strategy (with
all members of the union likely to be reference classes).
</p>


<h3>Debugging</h3>

<p>The standard <span class="rlang"><b>R</b></span> debugging and tracing facilities can be applied to
reference methods.
Reference methods can be passed to <code><a href="base.html#topic+debug">debug</a></code> and its
relatives from an object to debug further method invocations on that
object; for example, <code>debug(xx$edit)</code>. 
</p>
<p>Somewhat more flexible use is available for a reference method version
of the <code><a href="base.html#topic+trace">trace</a></code> function.
A corresponding <code>$trace()</code> 
reference method is available for
either an object or for the reference class generator
(<code>xx$trace()</code> or <code>mEdit$trace()</code> in the example below).
Using <code>$trace()</code> on an object sets up a tracing
version for future invocations of the specified method for that
object.
Using <code>$trace()</code> on the generator for the class sets up a
tracing version for all future objects from that class (and sometimes for
existing objects from the class if the method is not declared or
previously invoked).
</p>
<p>In either case, all the arguments to the standard  <code><a href="base.html#topic+trace">trace</a></code>
function are available, except for <code>signature=</code> which is
meaningless since reference methods can not be S4 generic functions.
This includes the typical style <code>trace(what, browser)</code> for
interactive debugging and  <code>trace(what, edit = TRUE)</code> to edit the
reference method interactively.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 11.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a simple editor for matrix objects.  Method  $edit() changes some
## range of values; method $undo() undoes the last edit.
mEdit &lt;- setRefClass("mEdit",
      fields = list( data = "matrix",
        edits = "list"))

## The basic edit, undo methods
mEdit$methods(
     edit = function(i, j, value) {
       ## the following string documents the edit method
       'Replaces the range [i, j] of the
        object by value.
        '
         backup &lt;-
             list(i, j, data[i,j])
         data[i,j] &lt;&lt;- value
         edits &lt;&lt;- c(edits, list(backup))
         invisible(value)
     },
     undo = function() {
       'Undoes the last edit() operation
        and update the edits field accordingly.
        '
         prev &lt;- edits
         if(length(prev)) prev &lt;- prev[[length(prev)]]
         else stop("No more edits to undo")
         edit(prev[[1]], prev[[2]], prev[[3]])
         ## trim the edits list
         length(edits) &lt;&lt;- length(edits) - 2
         invisible(prev)
     })

## A method to automatically print objects
mEdit$methods(
     show = function() {
       'Method for automatically printing matrix editors'
       cat("Reference matrix editor object of class",
          classLabel(class(.self)), "\n")
       cat("Data: \n")
       methods::show(data)
       cat("Undo list is of length", length(edits), "\n")
     }
     )

xMat &lt;- matrix(1:12,4,3)
xx &lt;- mEdit(data = xMat)
xx$edit(2, 2, 0)
xx
xx$undo()
mEdit$help("undo")
stopifnot(all.equal(xx$data, xMat))

utils::str(xx) # show fields and names of methods

## A method to save the object
mEdit$methods(
     save = function(file) {
       'Save the current object on the file
        in R external object format.
       '
         base::save(.self, file = file)
     }
)

tf &lt;- tempfile()
xx$save(tf)


## Not run: 
## Inheriting a reference class:  a matrix viewer
mv &lt;- setRefClass("matrixViewer",
    fields = c("viewerDevice", "viewerFile"),
    contains = "mEdit",
    methods = list( view = function() {
        dd &lt;- dev.cur(); dev.set(viewerDevice)
        devAskNewPage(FALSE)
        matplot(data, main = paste("After",length(edits),"edits"))
        dev.set(dd)},
        edit = # invoke previous method, then replot
          function(i, j, value) {
            callSuper(i, j, value)
            view()
          }))

## initialize and finalize methods
mv$methods( initialize =
  function(file = "./matrixView.pdf", ...) {
    viewerFile &lt;&lt;- file
    pdf(viewerFile)
    viewerDevice &lt;&lt;- dev.cur()
    dev.set(dev.prev())
    callSuper(...)
  },
  finalize = function() {
    dev.off(viewerDevice)
  })

## debugging an object: call browser() in method $edit()
xx$trace(edit, browser)

## debugging all objects from class mEdit in method $undo()
mEdit$trace(undo, browser)

## End(Not run)
 
</code></pre>

<hr>
<h2 id='removeMethod'> Remove a Method </h2><span id='topic+removeMethod'></span>

<h3>Description</h3>

<p>Remove the method for a given function and signature.  Obsolete for
ordinary applications: Method definitions in a package should never
need to remove methods and it's very bad practice to remove methods
that were defined in other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeMethod(f, signature, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeMethod_+3A_f">f</code>, <code id="removeMethod_+3A_signature">signature</code>, <code id="removeMethod_+3A_where">where</code></td>
<td>
<p>  As for <code><a href="#topic+setMethod">setMethod</a>()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if a method
was found to be removed.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>

<hr>
<h2 id='representation'> Construct a Representation or a Prototype for a Class Definition</h2><span id='topic+representation'></span><span id='topic+prototype'></span>

<h3>Description</h3>

<p>These are old utility functions  to construct, respectively
a list designed to represent the slots and superclasses and
a list of prototype specifications.  The <code>representation()</code>
function is no longer useful, since the arguments <code>slots</code> and
<code>contains</code> to <code><a href="#topic+setClass">setClass</a></code> are now recommended.
</p>
<p>The <code>prototype()</code> function may still be used for the
corresponding argument, but a
simple list of the same arguments works as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>representation(...)
prototype(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="representation_+3A_...">...</code></td>
<td>

<p>The call to representation takes arguments that are single character
strings.  Unnamed arguments are classes that a newly defined class
extends; named arguments name the explicit slots in the new class,
and specify what class each slot should have.
</p>
<p>In the call to <code>prototype</code>, if an unnamed argument is
supplied, it unconditionally forms the basis for the prototype
object.  Remaining arguments are taken to correspond to slots of
this object.  It is an error to supply more than one unnamed argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>representation</code> function applies tests for the validity of
the arguments.  Each must specify the name of a class.
</p>
<p>The classes named don't have to exist when <code>representation</code> is
called, but if they do, then the function will check for any duplicate
slot names introduced by each of the inherited classes.
</p>
<p>The arguments to <code>prototype</code> are usually named initial values
for slots, plus an optional first argument that gives the object
itself.  The unnamed argument is typically useful if there is a data
part to the definition (see the examples below).
</p>


<h3>Value</h3>

<p>The value of <code>representation</code>  is just the list of arguments, after these have been checked
for validity.
</p>
<p>The value of <code>prototype</code> is the object to be used as the
prototype.  Slots will have been set consistently with the
arguments, but the construction does <em>not</em> use the class
definition to test validity of the contents (it hardly can, since
the prototype object is usually supplied to create the definition).
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+setClass">setClass</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## representation for a new class with a directly define slot "smooth"
## which should be a "numeric" object, and extending class "track"
representation("track", smooth ="numeric")


###  &gt;&gt;&gt; This *is* old syntax -- use 'contains=*, slots=*' instead &lt;&lt;&lt;
###                ==========         ----------  ------   ======



setClass("Character",representation("character"))
setClass("TypedCharacter",representation("Character",type="character"),
          prototype(character(0),type="plain"))
ttt &lt;- new("TypedCharacter", "foo", type = "character")


setClass("num1", representation(comment = "character"),
         contains = "numeric",
         prototype = prototype(pi, comment = "Start with pi"))



</code></pre>

<hr>
<h2 id='RMethodUtils'>Method Utilities</h2><span id='topic+asMethodDefinition'></span><span id='topic+standardGeneric-class'></span><span id='topic+standardGenericWithTrace-class'></span><span id='topic+nonstandardGeneric-class'></span><span id='topic+nonstandardGenericFunction-class'></span><span id='topic+nonstandardGroupGenericFunction-class'></span><span id='topic+OptionalFunction-class'></span><span id='topic+PossibleMethod-class'></span><span id='topic+optionalMethod-class'></span><span id='topic+derivedDefaultMethod-class'></span><span id='topic+internalDispatchMethod-class'></span><span id='topic+substituteFunctionArgs'></span><span id='topic+makeGeneric'></span><span id='topic+makeStandardGeneric'></span><span id='topic+generic.skeleton'></span><span id='topic+defaultDumpName'></span><span id='topic+doPrimitiveMethod'></span><span id='topic+conformMethod'></span><span id='topic+getGeneric'></span><span id='topic+getGroup'></span><span id='topic+getGroupMembers'></span><span id='topic+getMethodsMetaData'></span><span id='topic+assignMethodsMetaData'></span><span id='topic+matchSignature'></span><span id='topic+findUnique'></span><span id='topic+MethodAddCoerce'></span><span id='topic+.saveImage'></span><span id='topic+cacheMetaData'></span><span id='topic+cacheGenericsMetaData'></span><span id='topic+setPrimitiveMethods'></span><span id='topic+missingArg'></span><span id='topic+balanceMethodsList'></span><span id='topic+sigToEnv'></span><span id='topic+rematchDefinition'></span><span id='topic+isRematched'></span><span id='topic+unRematchDefinition'></span><span id='topic+addNextMethod+2CMethodDefinition-method'></span><span id='topic+addNextMethod+2CMethodWithNext-method'></span><span id='topic+addNextMethod'></span><span id='topic+.valueClassTest'></span><span id='topic+insertClassMethods'></span><span id='topic+.ShortPrimitiveSkeletons'></span><span id='topic+.EmptyPrimitiveSkeletons'></span>

<h3>Description</h3>

<p>Utility functions to support the definition and use of formal
methods.  Most of these functions will not normally be called directly
by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGeneric(f, mustFind=FALSE, where, package)

getGroup(fdef, recursive, where)
getGroupMembers(group, recursive = FALSE, character = TRUE)

getMethodsMetaData(f, where)
assignMethodsMetaData (f, value, fdef, where)

makeGeneric(f, fdef, fdefault =, group=list(), valueClass=character(),
            package =, signature = NULL, genericFunction = NULL,
            simpleInheritanceOnly = NULL)

makeStandardGeneric(f, fdef)

generic.skeleton(name, fdef, fdefault)

defaultDumpName(generic, signature)

doPrimitiveMethod(name, def, call= sys.call(sys.parent()),
                  ev = sys.frame(sys.parent(2)))

conformMethod(signature, mnames, fnames, f= , fdef, method)

matchSignature(signature, fun, where)

findUnique(what, message, where)

MethodAddCoerce(method, argName, thisClass, methodClass)

cacheMetaData(where, attach = TRUE, searchWhere = as.environment(where),
              doCheck = TRUE)

cacheGenericsMetaData(f, fdef, attach = TRUE, where, package, methods)

setPrimitiveMethods(f, fdef, code, generic, mlist)

missingArg(symbol, envir = parent.frame(), eval)

sigToEnv(signature, generic)

rematchDefinition(definition, generic, mnames, fnames, signature)
unRematchDefinition(definition)
isRematched(definition)

asMethodDefinition(def, signature, sealed = FALSE, fdef)

addNextMethod(method, f, mlist, optional, envir)

insertClassMethods(methods, Class, value, fieldNames, returnAll)

balanceMethodsList(mlist, args, check = TRUE) # &lt;- deprecated since R 3.2.0

substituteFunctionArgs(def, newArgs, args = formalArgs(def),
                       silent = FALSE, functionName = "a function") 

.valueClassTest(object, classes, fname)
</code></pre>


<h3>Summary of Functions</h3>


<dl>
<dt><code>getGeneric</code>:</dt><dd>
<p>returns the definition of the function named <code>f</code> as a generic.
</p>
<p>If no definition is found, throws an
error or returns <code>NULL</code> according to the value of
<code>mustFind</code>.  By default, searches in the top-level
environment (normally the global environment, but adjusted to
work correctly when package code is evaluated from the function
<code><a href="base.html#topic+library">library</a></code>).
</p>
<p>Primitive functions are dealt with specially, since there is never
a formal generic definition for them.  The value returned is the
formal definition used for assigning methods to this primitive.
Not all primitives can have methods; if this one can't, then
<code>getGeneric</code> returns <code>NULL</code> or throws an error.
</p>
</dd>
<dt><code>getGroup</code>:</dt><dd>
<p>returns the groups to which this generic belongs, searching from
environment <code>where</code> (the global environment normally by default).
</p>
<p>If <code>recursive=TRUE</code>, also all the group(s) of these groups.
</p>
</dd>
<dt><code>getGroupMembers</code>:</dt><dd>
<p>Return all the members of the group generic function named
<code>group</code>.
If <code>recursive</code> is <code>TRUE</code>, and some members are group
generics, includes their members as well.
If <code>character</code> is <code>TRUE</code>, returns just a character
vector of the names; otherwise returns a list, whose elements may
(or may not) include either names with a package attribute or
actual generic functions.
</p>
<p>Note that members that are not defined as generic functions will
<em>not</em> be included in the returned value.  To see the raw data,
use <code>getGeneric(group)@groupMembers</code>.
</p>
</dd>
<dt><code>getMethodsMetaData</code>,
<code>assignMethodsMetaData</code>,
<code>mlistMetaName</code>:</dt><dd><p>Utilities to get
(<code>getMethodsMetaData</code>) and assign
(<code>assignMethodsMetaData</code>) the metadata object recording the
methods defined in a particular package, or to return the mangled
name for that object  (<code>mlistMetaName</code>).
</p>
<p>The assign function should not be used directly.  The get
function may be useful if you want explicitly only the outcome of
the methods assigned in this package.  Otherwise, use
<code><a href="#topic+getMethods">getMethods</a></code>.
</p>
</dd>
<dt><code>matchSignature</code>:</dt><dd>
<p>Matches the signature object (a partially or completely named
subset of the signature arguments of the generic function object
<code>fun</code>), and return a vector of all the classes in the order
specified by <code>fun@signature</code>.  The classes not specified by
<code>signature</code> will be <code>"ANY"</code> in the value, but extra
trailing <code>"ANY"</code>'s are removed.  When the input signature is
empty, the returned signature is a single <code>"ANY"</code> matching
the first formal argument (so the returned value is always
non-empty).
</p>
<p>Generates an error if any of the supplied signature names are
not legal; that is, not in the signature slot of the generic
function.
</p>
<p>If argument <code>where</code> is supplied, a warning will be issued
if any of the classes does not have a formal definition visible
from <code>where</code>.
</p>
</dd>
<dt><code>MethodAddCoerce</code>:</dt><dd>
<p>Possibly modify one or more methods to explicitly coerce this
argument to <code>methodClass</code>, the class for which the method is
explicitly defined.  Only modifies the method if an explicit
coerce is required to coerce from <code>thisClass</code> to
<code>methodClass</code>.
</p>
</dd>
<dt><code>findUnique</code>:</dt><dd>
<p>Return the list of environments (or equivalent) having an object named
<code>what</code>, using environment <code>where</code> and its parent
environments.  If more than one is found, a warning message is
generated, using <code>message</code> to identify what was being
searched for, unless <code>message</code> is the empty string.
</p>
</dd>
<dt><code>cacheMetaData</code>,
<code>cacheGenericsMetaData</code>,
<code>setPrimitiveMethods</code>:</dt><dd>
<p>Utilities for ensuring that the internal information about
class and method definitions is up to date.  Should normally be
called automatically whenever needed (for example, when a method
or class definition changes, or when a package is attached or
detached).  Required primarily because primitive functions are
dispatched in C code, rather than by the official model.
</p>
<p>The <code>setPrimitiveMethods</code> function resets the caching
information for a particular primitive function.  Don't call it
directly.
</p>
</dd>
<dt><code>missingArg</code>:</dt><dd>
<p>Returns <code>TRUE</code> if the symbol supplied is missing <em>from
the call</em> corresponding to the environment supplied (by default,
environment of the call to <code>missingArg</code>).  If <code>eval</code> is
true, the argument is evaluated to get the name of the symbol to
test.  Note that <code>missingArg</code> is closer to the
&lsquo;Blue Book&rsquo; sense of the <code><a href="base.html#topic+missing">missing</a></code> function,
not that of the current R base package implementation.  But beware
that it works reliably only if no assignment has yet been made to
the argument.  (For method dispatch this is fine, because
computations are done at the beginning of the call.)
</p>
</dd>
<dt><code>balanceMethodsList</code>:</dt><dd>
<p>Used to be called from <code>setMethod()</code> and is <em>deprecated</em>
since <span class="rlang"><b>R</b></span> version 3.2.0.







</p>



</dd>
<dt><code>sigToEnv</code>:</dt><dd>
<p>Turn the signature (a named vector of classes) into an environment
with the classes assigned to the names.  The environment is then
suitable for calling <code><a href="#topic+MethodsListSelect">MethodsListSelect</a></code>, with
<code>evalArgs=FALSE</code>, to select a method corresponding to the
signature.  Usually not called directly: see
<code><a href="#topic+selectMethod">selectMethod</a></code>.
</p>
</dd>
<dt><code>.saveImage</code>:</dt><dd>
<p>Flag, used in dynamically initializing the methods package from
<code>.onLoad</code>.
</p>
</dd>
<dt><code>rematchDefinition</code>,
<code>unRematchDefinition</code>,
<code>isRematched</code>:</dt><dd>
<p>If the specified method in a call to <code><a href="#topic+setMethod">setMethod</a></code>
specializes the argument list (by replacing ...), then
<code>rematchDefinition</code> constructs the actual method stored.
Using knowledge of how <code>rematchDefinition</code> works,
<code>unRematchDefinition</code> reverses the procedure; if given a
function or method definition that does not correspond to this
form, it just returns its argument. <code>isRematched</code> returns a
logical value indicating whether rematching was used when
constructing a given method.
</p>
</dd>
<dt><code>asMethodDefinition</code>:</dt><dd>
<p>Turn a function definition into an object of class
<code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code>, corresponding to the
given <code>signature</code> (by default generates a default method
with empty signature).  The definition is sealed according to
the <code>sealed</code> argument.
</p>
</dd>
<dt><code>addNextMethod</code>:</dt><dd>
<p>A generic function that finds the next method for
the signature of the method definition <code>method</code>  and caches
that method in the method definition (promoting the class to
<code>"MethodWithNext"</code>).  Note that argument <code>mlist</code> is
obsolete and not used.
</p>
</dd>
<dt><code>makeGeneric</code>:</dt><dd>
<p>Makes a generic function object corresponding to the given
function name, optional definition and optional default method.
Other arguments supply optional elements for the slots of class
<code><a href="#topic+genericFunction-class">genericFunction</a></code>.
</p>
</dd>
<dt><code>makeStandardGeneric</code>:</dt><dd>
<p>a utility function that makes a valid function calling
<code>standardGeneric</code> for name <code>f</code>.  Works (more or less)
even if the actual definition, <code>fdef</code>, is not a proper
function, that is, it's a primitive or internal.
</p>
</dd>
<dt><code>conformMethod</code>:</dt><dd>
<p>If the formal arguments, <code>mnames</code>, are not identical to the
formal arguments to the function, <code>fnames</code>,
<code>conformMethod</code> determines whether the signature and the two
sets of arguments conform, and returns the signature, possibly
extended.  The function name, <code>f</code> is supplied for error
messages. The generic function, <code>fdef</code>, supplies the
generic signature  for matching purposes.
</p>
<p>The method assignment conforms if method and generic function have
identical formal argument lists.  It can also conform if the
method omits some of the formal arguments of the function but: (1)
the non-omitted arguments are a subset of the function arguments,
appearing in the same order; (2) there are no arguments to the
method that are not arguments to the function; and (3) the omitted
formal arguments do not appear as explicit classes in the
signature.  A future extension hopes to test also that the
omitted arguments are not assumed by being used as locally assigned
names or function names in the body of the method.
</p>
</dd>
<dt><code>defaultDumpName</code>:</dt><dd>
<p>the default name to be used for dumping a method.
</p>
</dd>
<dt><code>doPrimitiveMethod</code>:</dt><dd>
<p>do a primitive call to builtin function <code>name</code> the definition
and call provided, and carried out in the environment <code>ev</code>.
</p>
<p>A call to <code>doPrimitiveMethod</code> is used when the actual method
is a .Primitive.  (Because primitives don't behave correctly as
ordinary functions, not having either formal arguments nor a
function body).
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+setGeneric">setGeneric</a></code>, <code><a href="#topic+setClass">setClass</a></code>,
<code><a href="#topic+showMethods">showMethods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getGroup("exp")
getGroup("==", recursive = TRUE)

getGroupMembers("Arith")
getGroupMembers("Math")
getGroupMembers("Ops") # -&gt; its sub groups
</code></pre>

<hr>
<h2 id='S3Part'> S4 Classes that Contain S3 Classes</h2><span id='topic+S3Part'></span><span id='topic+S3Part+3C-'></span><span id='topic+S3Class'></span><span id='topic+S3Class+3C-'></span><span id='topic+isXS3Class'></span><span id='topic+slotsFromS3'></span><span id='topic+S4'></span><span id='topic+S3'></span><span id='topic+coerce+2CANY+2CS3-method'></span><span id='topic+coerce+2ColdClass+2CS3-method'></span><span id='topic+coerce+2CANY+2CS4-method'></span><span id='topic+S3-class'></span>

<h3>Description</h3>

<p>A regular (S4) class may contain an S3 class, if that class has been registered (by calling
<code><a href="#topic+setOldClass">setOldClass</a></code>).  The functions described here provide
information about contained S3 classes.  See the section &lsquo;Functions&rsquo;.
</p>
<p>In modern <span class="rlang"><b>R</b></span>, these functions are not
usually needed to program with objects from the S4 class.  Standard computations work as expected, including method selection
for both S4 and S3.  To coerce an object to its contained S3 class,
use either of the expressions:
</p>
<p><code>as(object, S3Class); as(object, "S3")</code> 
</p>
<p>where
<code>S3Class</code> evaluates to the name of the contained class.  These
return slightly different objects, which in rare cases may need to
be distinguished.  See the section &ldquo;Contained S3 Objects&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S3Part(object, strictS3 = FALSE, S3Class)

S3Class(object)

isXS3Class(classDef)

slotsFromS3(object)

## the replacement versions of the functions are not recommended
## Create a new object from the class or use the replacement version of as().


S3Part(object, strictS3 = FALSE, needClass = ) &lt;- value

S3Class(object) &lt;-  value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S3Part_+3A_object">object</code></td>
<td>
<p>an object from some class that extends a registered
S3 class, or a basic
vector, matrix or array object type.
</p>
<p>For most of the functions, an S3 object can also be supplied,
with the interpretation that it is its own S3 part.
</p>
</td></tr>
<tr><td><code id="S3Part_+3A_stricts3">strictS3</code></td>
<td>
<p>If <code>TRUE</code>, the value returned by
<code>S3Part</code> will be an S3 object, with all the S4 slots
removed.  Otherwise, an S4 object will always
be returned; for example, from the S4 class created by
<code><a href="#topic+setOldClass">setOldClass</a></code> as a proxy for an S3 class, rather than
the underlying S3 object.
</p>
</td></tr>
<tr><td><code id="S3Part_+3A_s3class">S3Class</code></td>
<td>
<p>the <code><a href="base.html#topic+character">character</a></code> vector to be stored as the
S3 class slot in the object.  Usually, and by default, retains
the slot from <code>object</code>, but an S3 superclass is allowed.
</p>
</td></tr>
<tr><td><code id="S3Part_+3A_classdef">classDef</code></td>
<td>
<p>a class definition object, as returned by
<code><a href="#topic+getClass">getClass</a></code>.
</p>
<p><em>The remaining arguments apply only to the replacement versions,
which are not recommended.</em>
</p>
</td></tr>
<tr><td><code id="S3Part_+3A_needclass">needClass</code></td>
<td>
<p>Require that the replacement value be this class or a
subclass of it.</p>
</td></tr>
<tr><td><code id="S3Part_+3A_value">value</code></td>
<td>
<p>For <code>S3Part&lt;-</code>, the replacement value for the
S3 part of the object.
</p>
<p>For <code>S3Class&lt;-</code>, the character vector that will be used as
a proxy for <code>class(x)</code> in S3 method dispatch.
</p>
</td></tr>
</table>


<h3>Functions</h3>

<p><code>S3Part</code>:  Returns an object from the S3 class that appeared
in the <code>contains=</code> argument to <code><a href="#topic+setClass">setClass</a></code>.
</p>
<p>If called with <code>strictS3 = TRUE</code>, <code>S3Part()</code> constructs the underlying
S3 object by eliminating
all the formally defined slots and turning off the S4 bit of the
object.  With <code>strictS3 = FALSE</code> the object returned is from
the corresponding S4 class.  For consistency and generality,
<code>S3Part()</code> works also for classes that extend the basic vector,
matrix and array classes.
</p>
<p>A call to is equivalent coercing the object to class <code>"S3"</code> for
the strict case, or to whatever the specific S3 class was, for the
non-strict case.  The <code>as()</code> calls are usually easier for
readers to understand.
</p>
<p><code>S3Class</code>:  Returns the character vector of S3 class(es) stored in
the object, if the class has the corresponding <code>.S3Class</code> slot.
Currently, the function defaults to <code><a href="base.html#topic+class">class</a></code> otherwise.
</p>
<p><code>isXS3Class</code>: Returns <code>TRUE</code> or <code>FALSE</code> according
to whether the class defined by <code>ClassDef</code>
extends S3 classes (specifically, whether it has the slot for
holding the S3 class).
</p>
<p><code>slotsFromS3</code>: returns a list of the relevant slot classes, or an
empty list for any other object.
</p>
<p>The function <code>slotsFromS3()</code> is a generic function used
internally to access the slots associated with the S3 part of the
object.  Methods for this function are created automatically when
<code><a href="#topic+setOldClass">setOldClass</a></code> is called with the <code>S4Class</code>
argument.  Usually, there is only one S3 slot, containing the S3
class, but the <code>S4Class</code> argument may provide additional slots,
in the case that the S3 class has some guaranteed attributes that
can be used as formal S4 slots.  See the corresponding section in
the documentation of <code><a href="#topic+setOldClass">setOldClass</a></code>.
</p>


<h3>Contained S3 Objects</h3>

<p>Registering an S3 class defines an S4 class.  Objects from this
class are essentially identical in content to an object from the S3
class, except for two differences.  The value returned by
<code><a href="base.html#topic+class">class</a>()</code> will always be a single string for the S4
object, and <code><a href="base.html#topic+isS4">isS4</a>()</code> will return <code>TRUE</code> or
<code>FALSE</code> in the two cases.  See the example below.  It is barely
possible that some S3 code will not work with the S4 object; if so,
use <code>as(x, "S3")</code>.
</p>
<p>Objects from a class that extends an S3 class will have some basic type and
possibly some attributes.  For an S3 class that has an equivalent S4
definition (e.g., <code>"data.frame"</code>), an extending S4 class will
have a data part and slots.  For other S3 classes (e.g., <code>"lm"</code>) an
object from the extending S4 class will be some sort of basic type,
nearly always a vector type (e.g., <code>"list"</code> for <code>"lm"</code>),
but the data part will not have a formal definition.
</p>
<p>Registering an S3 class by a call to
<code><a href="#topic+setOldClass">setOldClass</a></code> creates a class of the same name with a slot <code>".S3Class"</code> to hold
the corresponding S3 vector of class strings.
New S4 classes that extend such
classes also have the same slot, set to the S3 class of the
contained S3 <em>object</em>,
which may be  an
(S3) subclass of the registered class.
For example, an S4 class might contain the S3 class <code>"lm"</code>, but
an object from the class might contain an object from class
<code>"mlm"</code>, as in the <code>"xlm"</code>example below.
</p>
<p><span class="rlang"><b>R</b></span> is somewhat arbitrary about what
it treats as an S3 class: <code>"ts"</code> is, but <code>"matrix"</code> and <code>"array"</code>
are not.
For classes that extend
those, assuming they contain an S3 class is incorrect and will cause some
confusion&mdash;not usually disastrous, but the better strategy
is to stick to the explicit &ldquo;class&rdquo;.
Thus <code>as(x, "matrix")</code> rather than <code>as(x, "S3")</code> or <code>S3Part(x)</code>.
</p>


<h3>S3 and S4 Objects: Conversion Mechanisms</h3>

<p>Objects in <span class="rlang"><b>R</b></span> have an internal bit that indicates whether or not to
treat the object as coming from an S4 class.  This bit is tested by
<code><a href="base.html#topic+isS4">isS4</a></code> and can be set on or off by <code><a href="base.html#topic+asS4">asS4</a></code>.
The latter function, however, does no checking or interpretation;
you should only use it if you are very certain every detail has been
handled correctly.
</p>
<p>As a friendlier alternative, methods have been defined for coercing
to the virtual classes <code>"S3"</code> and <code>"S4"</code>.  The expressions
<code>as(object, "S3")</code>  and <code>as(object, "S4")</code>  return S3
and S4 objects, respectively.  In addition, they attempt
to do conversions in a valid way, and also check validity when
coercing to S4.
</p>
<p>The expression <code>as(object, "S3")</code> can be used in two ways.  For
objects from one of the registered S3 classes, the expression will
ensure that the class attribute is the full multi-string S3 class
implied by <code>class(object)</code>.  If the registered class has known
attribute/slots, these will also be provided.
</p>
<p>Another use of  <code>as(object, "S3")</code>  is to take an S4 object and
turn it into an S3 object with corresponding attributes.  This is
only meaningful with S4 classes that have a data part.  If you want
to operate on the object without invoking S4 methods, this
conversion is usually the safest way.
</p>
<p>The expression  <code>as(object, "S4")</code> will use the attributes in
the object to create an object from the S4 definition of
<code>class(object)</code>. This is a general mechanism to create
partially defined version of S4 objects via S3 computations  (not
much different from invoking <code><a href="#topic+new">new</a></code> with corresponding
arguments, but usable in this form even if the S4 object has an
initialize method with different arguments).
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10, particularly Section 10.8)
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+setOldClass">setOldClass</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## an "mlm" object, regressing two variables on two others

sepal &lt;- as.matrix(datasets::iris[,c("Sepal.Width", "Sepal.Length")])
fit &lt;- lm(sepal ~ Petal.Length + Petal.Width + Species, data = datasets::iris)
class(fit) # S3 class: "mlm", "lm"

## a class that contains "mlm"
myReg &lt;- setClass("myReg", slots = c(title = "character"), contains = "mlm")

fit2 &lt;- myReg(fit, title = "Sepal Regression for iris data")

fit2 # shows the inherited "mlm" object and the title

identical(S3Part(fit2), as(fit2, "mlm"))

class(as(fit2, "mlm")) # the S4 class, "mlm"

class(as(fit2, "S3")) # the S3 class, c("mlm", "lm")

## An object may contain an S3 class from a subclass of that declared:
xlm &lt;- setClass("xlm", slots = c(eps = "numeric"), contains = "lm")

xfit &lt;- xlm(fit, eps = .Machine$double.eps)

xfit@.S3Class # c("mlm", lm")


</code></pre>

<hr>
<h2 id='S4groupGeneric'>S4 Group Generic Functions</h2><span id='topic+S4groupGeneric'></span><span id='topic+GroupGenericFunctions'></span><span id='topic+Math'></span><span id='topic+Ops'></span><span id='topic+Summary'></span><span id='topic+Arith'></span><span id='topic+Logic'></span><span id='topic+Compare'></span><span id='topic+Complex'></span><span id='topic+Math2'></span>

<h3>Description</h3>

<p>Methods can be defined for <em>group generic functions</em>.  Each group
generic function has a number of <em>member</em> generic functions
associated with it.
</p>
<p>Methods  defined for a group generic function cause the same
method to be defined for each member of the group, but a method explicitly
defined for a  member of the group takes precedence over a
method defined, with the same signature, for the group generic.
</p>
<p>The functions shown in this documentation page all reside in the
<span class="pkg">methods</span> package, but the mechanism is available to any
programmer, by calling <code><a href="#topic+setGroupGeneric">setGroupGeneric</a></code> (provided package
<span class="pkg">methods</span> is attached).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 group generics:
Arith(e1, e2)
Compare(e1, e2)
Ops(e1, e2)
Logic(e1, e2)
Math(x)
Math2(x, digits)
Summary(x, ..., na.rm = FALSE)
Complex(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S4groupGeneric_+3A_x">x</code>, <code id="S4groupGeneric_+3A_z">z</code>, <code id="S4groupGeneric_+3A_e1">e1</code>, <code id="S4groupGeneric_+3A_e2">e2</code></td>
<td>
<p>objects.</p>
</td></tr>
<tr><td><code id="S4groupGeneric_+3A_digits">digits</code></td>
<td>
<p>number of digits to be used in <code>round</code> or <code>signif</code>.</p>
</td></tr>
<tr><td><code id="S4groupGeneric_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="S4groupGeneric_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods can be defined for the group generic functions by calls to
<code><a href="#topic+setMethod">setMethod</a></code> in the usual way.
Note that the group generic functions
should never be called directly
&ndash; a suitable error message will result if they are.  When metadata
for a group generic is loaded, the methods defined become methods
for the members of the group, but only if no method has been
specified directly for the member function for the same signature.
The effect is that group generic definitions are selected before
inherited methods but after directly specified methods.  For more on
method selection, see <code><a href="#topic+Methods_Details">Methods_Details</a></code>.
</p>
<p>There are also
S3 groups <code>Math</code>, <code>Ops</code>, <code>Summary</code> and
<code>Complex</code>, see <code>?<a href="base.html#topic+S3groupGeneric">S3groupGeneric</a></code>,
with no corresponding <span class="rlang"><b>R</b></span> objects, but these are irrelevant for S4
group generic functions.
</p>
<p>The members of the group defined by a particular generic can be
obtained by calling <code><a href="#topic+getGroupMembers">getGroupMembers</a></code>. For the group
generic functions currently defined in this package the members are
as follows:
</p>

<dl>
<dt><code>Arith</code></dt><dd><p><code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"^"</code>,
<code>"%%"</code>, <code>"%/%"</code>, <code>"/"</code></p>
</dd>
<dt><code>Compare</code></dt><dd><p><code>"=="</code>, <code>"&gt;"</code>, <code>"&lt;"</code>,
<code>"!="</code>, <code>"&lt;="</code>, <code>"&gt;="</code></p>
</dd>
<dt><code>Logic</code></dt><dd><p><code>"&amp;"</code>, <code>"|"</code>.
</p>
</dd>
<dt><code>Ops</code></dt><dd><p><code>"Arith"</code>, <code>"Compare"</code>, <code>"Logic"</code></p>
</dd>
<dt><code>Math</code></dt><dd><p><code>"abs"</code>, <code>"sign"</code>, <code>"sqrt"</code>,
<code>"ceiling"</code>, <code>"floor"</code>, <code>"trunc"</code>,
<code>"cummax"</code>, <code>"cummin"</code>, <code>"cumprod"</code>, <code>"cumsum"</code>,
<code>"log"</code>, <code>"log10"</code>, <code>"log2"</code>, <code>"log1p"</code>,
<code>"acos"</code>, <code>"acosh"</code>,
<code>"asin"</code>, <code>"asinh"</code>, <code>"atan"</code>, <code>"atanh"</code>,
<code>"exp"</code>, <code>"expm1"</code>,
<code>"cos"</code>, <code>"cosh"</code>, <code>"cospi"</code>,
<code>"sin"</code>, <code>"sinh"</code>, <code>"sinpi"</code>,
<code>"tan"</code>, <code>"tanh"</code>, <code>"tanpi"</code>,
<code>"gamma"</code>, <code>"lgamma"</code>, <code>"digamma"</code>,
<code>"trigamma"</code>
</p>
</dd>
<dt><code>Math2</code></dt><dd><p><code>"round"</code>, <code>"signif"</code></p>
</dd>
<dt><code>Summary</code></dt><dd><p><code>"max"</code>, <code>"min"</code>, <code>"range"</code>,
<code>"prod"</code>, <code>"sum"</code>, <code>"any"</code>, <code>"all"</code></p>
</dd>
<dt><code>Complex</code></dt><dd><p><code>"Arg"</code>, <code>"Conj"</code>, <code>"Im"</code>,
<code>"Mod"</code>, <code>"Re"</code></p>
</dd>
</dl>

<p>Note that <code>Ops</code> merely consists of three sub groups.
</p>
<p>All the functions in these groups (other than the group generics
themselves) are basic functions in <span class="rlang"><b>R</b></span>.  They are not by default S4 generic
functions, and many of them are defined as primitives.  However, you can still define
formal methods for them, both individually and via the group generics.  It all works more or less as you
might expect, admittedly via a bit of trickery in the background.
See <a href="#topic+Methods_Details">Methods_Details</a> for details.
</p>
<p>Note that two members of the <code>Math</code> group, <code><a href="base.html#topic+log">log</a></code> and
<code><a href="base.html#topic+trunc">trunc</a></code>, have ... as an extra formal argument.
Since methods for <code>Math</code> will have only one formal argument,
you must set a specific method for these functions in order to call
them with the extra argument(s).
</p>
<p>For further details about group generic functions see section 10.5 of
the second reference.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer. (Section 10.5)
</p>


<h3>See Also</h3>

<p> The function <code><a href="#topic+callGeneric">callGeneric</a></code> is nearly always
relevant when writing a method for a group generic.  See the
examples below and in section 10.5 of <em>Software for Data Analysis</em>.
</p>
<p>See <a href="base.html#topic+S3groupGeneric">S3groupGeneric</a> for S3 group generics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setClass("testComplex", slots = c(zz = "complex"))
## method for whole group "Complex"
setMethod("Complex", "testComplex",
          function(z) c("groupMethod", callGeneric(z@zz)))
## exception for Arg() :
setMethod("Arg", "testComplex",
          function(z) c("ArgMethod", Arg(z@zz)))
z1 &lt;- 1+2i
z2 &lt;- new("testComplex", zz = z1)
stopifnot(identical(Mod(z2), c("groupMethod", Mod(z1))))
stopifnot(identical(Arg(z2), c("ArgMethod", Arg(z1))))
</code></pre>

<hr>
<h2 id='SClassExtension-class'>Class to Represent Inheritance (Extension) Relations </h2><span id='topic+SClassExtension-class'></span>

<h3>Description</h3>

<p>  An object from this class represents a single &lsquo;is&rsquo;
relationship; lists of these objects are used to represent all the
extensions (superclasses) and subclasses for a given class.  The
object contains information about how the relation is defined and
methods to coerce, test, and replace correspondingly. </p>


<h3>Objects from the Class</h3>

<p>Objects from this class are generated by <code><a href="#topic+setIs">setIs</a></code>,
from direct calls and from the <code>contains=</code> information in a call to <code><a href="#topic+setClass">setClass</a></code>, and from class unions created by <code><a href="#topic+setClassUnion">setClassUnion</a></code>.
In the last case, the information is stored in defining the <em>subclasses</em> of the union class (allowing unions to contain sealed classes).
</p>


<h3>Slots</h3>


<dl>
<dt><code>subClass</code>, <code>superClass</code>:</dt><dd><p>The classes being
extended: corresponding to the <code>from</code>, and <code>to</code>
arguments to <code><a href="#topic+setIs">setIs</a></code>. </p>
</dd>
<dt><code>package</code>:</dt><dd><p>The package to which that class belongs. </p>
</dd>
<dt><code>coerce</code>:</dt><dd><p>A function to carry out the as() computation
implied by the relation.  Note that these functions should
<em>not</em> be used directly.  They only deal with the
<code>strict=TRUE</code> calls to the <code><a href="#topic+as">as</a></code> function, with
the full method constructed from this mechanically. </p>
</dd>
<dt><code>test</code>:</dt><dd><p>The function that would test whether the
relation holds.  Except for explicitly specified <code>test</code>
arguments to <code><a href="#topic+setIs">setIs</a></code>, this function is trivial. </p>
</dd>
<dt><code>replace</code>:</dt><dd><p>The method used to implement <code>as(x,
    Class) &lt;- value</code>.</p>
</dd>
<dt><code>simple</code>:</dt><dd><p>A <code>"logical"</code> flag, <code>TRUE</code> if this
is a simple relation, either because one class is contained in the
definition of another, or because a class has been explicitly
stated to extend a virtual class.  For simple extensions, the
three methods are generated automatically.</p>
</dd>
<dt><code>by</code>:</dt><dd><p>If this relation has been constructed
transitively, the first intermediate class from the subclass. </p>
</dd>
<dt><code>dataPart</code>:</dt><dd><p>A <code>"logical"</code> flag, <code>TRUE</code> if
the extended class is in fact the data part of the subclass.  In
this case the extended class is a basic class (i.e., a type). </p>
</dd>
<dt><code>distance</code>:</dt><dd><p>The distance between the two classes,
1 for directly contained classes, plus the number of generations between otherwise. </p>
</dd>  </dl>



<h3>Methods</h3>

<p>No methods defined with class <code>"SClassExtension"</code> in the
signature.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is">is</a></code>,
<code><a href="#topic+as">as</a></code>, and the
<code><a href="#topic+classRepresentation-class">classRepresentation</a></code> class.
</p>

<hr>
<h2 id='selectSuperClasses'>Super Classes (of Specific Kinds) of a Class</h2><span id='topic+selectSuperClasses'></span><span id='topic+.selectSuperClasses'></span>

<h3>Description</h3>

<p>Return superclasses of <code>ClassDef</code>, possibly only non-virtual or
direct or simple ones.
</p>
<p>These functions are designed to be fast, and consequently only work
with the <code>contains</code> slot of the corresponding class definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSuperClasses(Class, dropVirtual = FALSE, namesOnly = TRUE,
                   directOnly = TRUE, simpleOnly = directOnly,
                   where = topenv(parent.frame()))

.selectSuperClasses(ext, dropVirtual = FALSE, namesOnly = TRUE,
                    directOnly = TRUE, simpleOnly = directOnly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSuperClasses_+3A_class">Class</code></td>
<td>
<p>name of the class or (more efficiently) the class
definition object (see <code><a href="#topic+getClass">getClass</a></code>).</p>
</td></tr>
<tr><td><code id="selectSuperClasses_+3A_dropvirtual">dropVirtual</code></td>
<td>
<p>logical indicating if only non-virtual superclasses
should be returned.</p>
</td></tr>
<tr><td><code id="selectSuperClasses_+3A_namesonly">namesOnly</code></td>
<td>
<p>logical indicating if only a vector names instead of
a named list class-extensions should be returned.</p>
</td></tr>
<tr><td><code id="selectSuperClasses_+3A_directonly">directOnly</code></td>
<td>
<p>logical indicating if only a <em>direct</em> super
classes should be returned.</p>
</td></tr>
<tr><td><code id="selectSuperClasses_+3A_simpleonly">simpleOnly</code></td>
<td>
<p>logical indicating if only simple class extensions
should be returned.</p>
</td></tr>
<tr><td><code id="selectSuperClasses_+3A_where">where</code></td>
<td>
<p>(only used when <code>Class</code> is not a class definition)
environment where the class definition of <code>Class</code> is found.</p>
</td></tr>
<tr><td><code id="selectSuperClasses_+3A_ext">ext</code></td>
<td>
<p>for <code>.selectSuperClasses()</code> only, a <code><a href="base.html#topic+list">list</a></code>
of class extensions, typically <code><a href="#topic+getClassDef">getClassDef</a>(..)@contains</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+character">character</a></code> vector (if <code>namesOnly</code> is true, as per
default) or a list of class extensions (as the <code>contains</code> slot in
the result of <code><a href="#topic+getClass">getClass</a></code>).
</p>


<h3>Note</h3>

<p>The typical user level function is <code>selectSuperClasses()</code>
which calls <code>.selectSuperClasses()</code>; i.e., the latter should only
be used for efficiency reasons by experienced useRs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is">is</a></code>, <code><a href="#topic+getClass">getClass</a></code>; further, the more technical
class <code><a href="#topic+classRepresentation-class">classRepresentation</a></code> documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setClass("Root")
setClass("Base", contains = "Root", slots = c(length = "integer"))
setClass("A", contains = "Base", slots = c(x = "numeric"))
setClass("B", contains = "Base", slots = c(y = "character"))
setClass("C", contains = c("A", "B"))

extends("C")   #--&gt;  "C"  "A" "B"  "Base" "Root"
selectSuperClasses("C") # "A" "B"
selectSuperClasses("C", directOnly=FALSE) # "A" "B"  "Base"  "Root"
selectSuperClasses("C", dropVirtual=TRUE, directOnly=FALSE)# ditto w/o "Root"
</code></pre>

<hr>
<h2 id='setAs'>Methods for Coercing an Object to a Class</h2><span id='topic+coerce'></span><span id='topic+coerce+3C-'></span><span id='topic+setAs'></span><span id='topic+coerce-methods'></span><span id='topic+coerce+2CANY+2Carray-method'></span><span id='topic+coerce+2CANY+2Ccall-method'></span><span id='topic+coerce+2CANY+2Ccharacter-method'></span><span id='topic+coerce+2CANY+2Ccomplex-method'></span><span id='topic+coerce+2CANY+2Cenvironment-method'></span><span id='topic+coerce+2CANY+2Cexpression-method'></span><span id='topic+coerce+2CANY+2Cfunction-method'></span><span id='topic+coerce+2CANY+2Cinteger-method'></span><span id='topic+coerce+2CANY+2Clist-method'></span><span id='topic+coerce+2CANY+2Clogical-method'></span><span id='topic+coerce+2CANY+2Cmatrix-method'></span><span id='topic+coerce+2CANY+2Cname-method'></span><span id='topic+coerce+2CANY+2Cnumeric-method'></span><span id='topic+coerce+2CANY+2Csingle-method'></span><span id='topic+coerce+2CANY+2Cts-method'></span><span id='topic+coerce+2CANY+2Cvector-method'></span><span id='topic+coerce+2CANY+2CNULL-method'></span>

<h3>Description</h3>

<p>A call to <code>setAs</code> defines a method for coercing an object of
class <code>from</code> to class <code>to</code>.  The methods will then be used
by calls to <code><a href="#topic+as">as</a></code> for objects with class <code>from</code>,
including calls that replace part of the object.
</p>
<p>Methods for this purpose work indirectly, by defining methods for
function <code>coerce</code>.  The <code>coerce</code> function is <em>not</em> to
be called directly, and method selection uses class inheritance only
on the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAs(from, to, def, replace, where = topenv(parent.frame()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setAs_+3A_from">from</code>, <code id="setAs_+3A_to">to</code></td>
<td>
<p>The classes between which the coerce methods
<code>def</code> and <code>replace</code> perform coercion.
</p>
</td></tr>
<tr><td><code id="setAs_+3A_def">def</code></td>
<td>
<p>function of one argument.  It will get an object from
class <code>from</code> and had better return an object of class
<code>to</code>.  The convention is that
the name of the argument is <code>from</code>; if another argument name
is used, <code>setAs</code> will attempt to substitute <code>from</code>. </p>
</td></tr>
<tr><td><code id="setAs_+3A_replace">replace</code></td>
<td>
<p>if supplied, the function to use as a replacement
method, when <code>as</code> is used on the left of an assignment.
Should be a function of two arguments, <code>from, value</code>,
although <code>setAs</code> will attempt to substitute if the arguments
differ.
</p>
<p><em>The remaining argument will not be used in standard applications.</em>
</p>
</td></tr>
<tr><td><code id="setAs_+3A_where">where</code></td>
<td>
<p>the position or environment in which to store the
resulting methods. Do not use this argument when defining a method
in a package.  Only the default, the namespace of the package,
should be used in normal situations.
</p>
</td></tr>
</table>


<h3>Inheritance and Coercion</h3>

<p>Objects from one class can turn into objects from another class
either automatically or by an explicit call to the <code>as</code>
function.  Automatic conversion is special, and comes from the
designer of one class of objects asserting that this class extends
another class.  The most common case is that one or more class names
are supplied in the <code>contains=</code> argument to <code>setClass</code>, in
which case the new class extends each of the earlier classes (in the
usual terminology, the earlier classes are <em>superclasses</em> of
the new class and it is a <em>subclass</em> of each of them).
</p>
<p>This form of inheritance is called <em>simple</em> inheritance in <span class="rlang"><b>R</b></span>.
See <code><a href="#topic+setClass">setClass</a></code> for details.
Inheritance can also be defined explicitly by a call to
<code><a href="#topic+setIs">setIs</a></code>.
The two versions have slightly different implications for coerce methods.
Simple inheritance implies that inherited slots behave identically in the subclass and the superclass.
Whenever two classes are related by simple inheritance, corresponding coerce methods
are defined for both direct and replacement use of <code>as</code>.
In the case of simple inheritance, these methods do the obvious
computation:  they extract or replace the slots in the object that
correspond to those in the superclass definition.
</p>
<p>The implicitly defined coerce methods may be overridden by a call
to <code>setAs</code>; note, however, that the implicit methods are defined for each
subclass-superclass pair, so that you must override each of these
explicitly, not rely on inheritance.
</p>
<p>When inheritance is defined by a call to <code>setIs</code>, the coerce methods are provided explicitly, not generated automatically.
Inheritance will apply (to the <code>from</code> argument, as described in  the section below).
You could also supply methods via <code>setAs</code> for non-inherited relationships, and now these also can be inherited.
</p>
<p>For further on the distinction between simple and explicit inheritance, see <code><a href="#topic+setIs">setIs</a></code>.
</p>


<h3>How Functions <code>as</code> and <code>setAs</code> Work</h3>

<p>The function <code>as</code>  turns <code>object</code> into an object
of class <code>Class</code>.  In doing so, it applies a &ldquo;coerce
method&rdquo;, using S4
classes and methods, but in a somewhat special way.
Coerce methods are methods for the function <code>coerce</code> or, in the
replacement case the function <code>`coerce&lt;-`</code>.
These functions have two arguments in method signatures, <code>from</code>
and <code>to</code>, corresponding to the class of the object and the
desired coerce class.
These functions must not be called directly, but are used to store
tables of methods for the use of <code>as</code>, directly and for
replacements.
In this section we will describe the direct case, but except where
noted the replacement case works the same way, using <code>`coerce&lt;-`</code>
and the <code>replace</code> argument to <code>setAs</code>, rather than
<code>coerce</code> and the <code>def</code> argument.
</p>
<p>Assuming the <code>object</code> is not already of the desired class,
<code>as</code> first looks for a method in the table of methods
for the function
<code>coerce</code> for the signature <code>c(from = class(object), to =
    Class)</code>, in the same way method selection would do its initial lookup.
To be precise, this means the table of both direct and inherited
methods, but inheritance is used specially in this case (see below).
</p>
<p>If no method is found, <code>as</code> looks for one.
First, if either <code>Class</code> or <code>class(object)</code> is a superclass
of the other, the class definition will contain the information needed
to construct a coerce method.
In the usual case that the subclass contains the superclass (i.e., has
all its slots), the method is constructed either by extracting or
replacing the inherited slots.
Non-simple extensions (the result of a call to <code><a href="#topic+setIs">setIs</a></code>)
will usually contain explicit methods, though possibly not for replacement.
</p>
<p>If no subclass/superclass relationship provides a method, <code>as</code>
looks for an inherited method, but applying, inheritance for the argument <code>from</code> only, not for
the argument <code>to</code> (if you think about it, you'll probably agree
that you wouldn't want the result to be from some class other than the
<code>Class</code> specified). Thus,
<code>selectMethod("coerce", sig, useInherited= c(from=TRUE, to= FALSE))</code>
replicates the method selection used by <code>as()</code>.
</p>
<p>In nearly all cases the method found in this way will be cached in the
table of coerce methods (the exception being subclass relationships with a test, which
are legal but discouraged).
So the detailed calculations should be done only on the first
occurrence of a coerce from <code>class(object)</code> to <code>Class</code>.
</p>
<p>Note that  <code>coerce</code> is not a standard generic function.  It is
not intended to be called directly.  To prevent accidentally caching
an invalid inherited method, calls are routed to an equivalent call to
<code>as</code>, and a warning is issued.  Also, calls to
<code><a href="#topic+selectMethod">selectMethod</a></code> for this function may not represent the
method that <code>as</code> will choose.  You can only trust the result if
the corresponding call to <code>as</code> has occurred previously in this
session.
</p>
<p>With this explanation as background, the function <code>setAs</code> does a
fairly obvious computation:  It constructs and sets a method for the function
<code>coerce</code> with signature <code>c(from, to)</code>, using the <code>def</code>
argument to define the body of the method.  The function supplied as
<code>def</code> can have one argument (interpreted as an object to be
coerced) or two arguments (the <code>from</code> object and the <code>to</code>
class).  Either way, <code>setAs</code> constructs a function of two
arguments, with the second defaulting to the name of the <code>to</code>
class.  The method will be called from <code>as</code> with the object
as the <code>from</code> argument and no <code>to</code> argument, with the default for this argument being the name of the intended
<code>to</code> class, so the method can use this information in messages.
</p>
<p>The direct version of the <code>as</code> function also has a <code>strict=</code> argument that defaults to <code>TRUE</code>.
Calls during the evaluation of methods for other functions will set this argument to <code>FALSE</code>.
The distinction is relevant when the object being coerced is from a simple subclass of the <code>to</code> class; if <code>strict=FALSE</code> in this case, nothing need be done.
For most user-written coerce methods, when the two classes have no subclass/superclass, the <code>strict=</code> argument is irrelevant.
</p>
<p>The <code>replace</code> argument to <code>setAs</code> provides a method for
<code>`coerce&lt;-`</code>.
As with all replacement methods, the last argument of the method must
have the name <code>value</code> for the object on the right of the
assignment.
As with the <code>coerce</code> method, the first two arguments are
<code>from, to</code>; there is no <code>strict=</code> option for the replace case.
</p>
<p>The function <code>coerce</code> exists as a repository for
such methods, to be selected as described above by the <code>as</code>
function.  Actually dispatching the methods using
<code>standardGeneric</code> could produce incorrect inherited methods, by using
inheritance on the
<code>to</code> argument; as mentioned, this is not the logic used for
<code>as</code>.
To prevent selecting and caching invalid methods, calls to
<code>coerce</code> are
currently mapped into calls to <code>as</code>, with a warning message.
</p>


<h3>Basic Coercion Methods</h3>

<p>Methods are pre-defined for coercing any object to one of the basic
datatypes.  For example, <code>as(x, "numeric")</code> uses the existing
<code>as.numeric</code> function.  These built-in methods can be listed by
<code>showMethods("coerce")</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p>If you think of using <code>try(as(x, cl))</code>, consider
<code><a href="#topic+canCoerce">canCoerce</a>(x, cl)</code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## using the definition of class "track" from \link{setClass}



setAs("track", "numeric", function(from) from@y)

t1 &lt;- new("track", x=1:20, y=(1:20)^2)

as(t1, "numeric")

## The next example shows:
##  1. A virtual class to define setAs for several classes at once.
##  2. as() using inherited information

setClass("ca", slots = c(a = "character", id = "numeric"))

setClass("cb", slots = c(b = "character", id = "numeric"))

setClass("id")
setIs("ca", "id")
setIs("cb", "id")


setAs("id", "numeric", function(from) from@id)

CA &lt;- new("ca", a = "A", id = 1)
CB &lt;- new("cb", b = "B", id = 2)

setAs("cb", "ca", function(from, to )new(to, a=from@b, id = from@id))

as(CB, "numeric")


</code></pre>

<hr>
<h2 id='setClass'>Create a Class Definition</h2><span id='topic+setClass'></span><span id='topic+classGeneratorFunction-class'></span>

<h3>Description</h3>

<p>Create  a class definition and return a generator function to create
objects from the class.  Typical usage will be
of the style:
</p>
<p><code>myClass &lt;- setClass("myClass", slots= ...., contains =....)</code>
</p>
<p>where the first argument is the name of the new class and, if supplied, the arguments    
<code>slots=</code> and <code>contains=</code> specify the slots
in the new class and existing classes from which the new class
should inherit.  Calls to <code>setClass()</code> are normally found in the
source of a package; when the package is loaded the class will be
defined in the package's namespace.  Assigning the generator
function with the name of the class is  convenient for users, but
not a requirement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setClass(Class, representation, prototype, contains=character(),
         validity, access, where, version, sealed, package,
         S3methods = FALSE, slots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setClass_+3A_class">Class</code></td>
<td>
<p>character string name for the class.</p>
</td></tr>
<tr><td><code id="setClass_+3A_slots">slots</code></td>
<td>
<p>  The names and classes for the slots in the new class.  This argument
must be supplied by name, <code>slots=</code>, in the call, for back compatibility
with other arguments no longer recommended.
</p>
<p>The argument must be  vector with a names attribute, the names being those of the slots in
the new class.  Each element of the vector specifies an
existing class; the corresponding slot must be from this class
or a subclass of it.  Usually, this is a character vector
naming the classes.  It's also legal for the elements of the
vector to be class representation objects, as returned by <code><a href="#topic+getClass">getClass</a></code>.
</p>
<p>As a limiting
case,  the argument may be an unnamed character
vector;  the elements are  taken as slot names and all slots have
the unrestricted class <code>"ANY"</code>. 
</p>
</td></tr>
<tr><td><code id="setClass_+3A_contains">contains</code></td>
<td>
<p> A vector specifying existing classes from which
this class should inherit. The new class will have all the slots
of the superclasses, with the same requirements on the classes
of these slots.  This argument
must be supplied by name, <code>contains=</code>, in the call, for back compatibility
with other arguments no longer recommended.
</p>
<p>See the section &lsquo;Virtual Classes&rsquo; for the special
superclass  <code>"VIRTUAL"</code>.
</p>
</td></tr>
<tr><td><code id="setClass_+3A_prototype">prototype</code>, <code id="setClass_+3A_where">where</code>, <code id="setClass_+3A_validity">validity</code>, <code id="setClass_+3A_sealed">sealed</code>, <code id="setClass_+3A_package">package</code></td>
<td>

<p><em>These arguments are currently allowed, but either they are unlikely to be
useful or there are modern alternatives that are preferred.</em>
</p>
<p><code>prototype</code>: supplies an object with the default
data for the slots in this class.  A more flexible approach is to
write a method for <code><a href="#topic+initialize">initialize</a>()</code>.
</p>
<p><code>where</code>: supplies an environment in which to store the definition.
Should not be used:  For calls to
<code>setClass()</code> appearing in the source code for a package the
definition will be stored in the namespace of the package.
</p>
<p><code>validity</code>: supplied a validity-checking method
for objects from this class.  For clearer code, use a separate
call to <code><a href="#topic+setValidity">setValidity</a>()</code>.
</p>
<p><code>sealed</code>: if <code>TRUE</code>, the class definition will be sealed,
so that another call to <code>setClass</code> will fail on this class
name.  But the definition is automatically sealed after the
namespace is loaded, so explicit sealing it is not needed.
</p>
<p><code>package</code>: supplies an optional package name for the class, but
the class attribute should be  the package in which the class
definition is assigned, as it is by default.
</p>
</td></tr>
<tr><td><code id="setClass_+3A_representation">representation</code>, <code id="setClass_+3A_access">access</code>, <code id="setClass_+3A_version">version</code>, <code id="setClass_+3A_s3methods">S3methods</code></td>
<td>
<p><em>All these
arguments are deprecated from version 3.0.0 of <span class="rlang"><b>R</b></span> and should be
avoided</em>.
</p>
<p><code>representation</code> is an argument inherited from S that
included both <code>slots</code> and <code>contains</code>, but the use of
the latter two arguments is clearer and recommended.
</p>
<p><code>access</code> and <code>version</code> are included for
historical compatibility with S-Plus, but ignored.
</p>
<p><code>S3methods</code> is a flag indicating that old-style methods
will be written involving this class; ignored now.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A generator function suitable for creating objects from the class is
returned, invisibly.  A call to this function generates a call to
<code><a href="#topic+new">new</a></code> for the class.  The call takes any number of arguments,
which will be passed on to the initialize method.  If no
<code>initialize</code> method is defined for the class or one of its
superclasses, the default method expects named arguments with the
name of one of the slots and unnamed arguments that are objects from
one of the contained classes.
</p>
<p>Typically the generator function is assigned the name of the class,
for programming clarity.  This is not a requirement and objects
from the class can also be generated directly from
<code><a href="#topic+new">new</a></code>.  The advantages of the generator function are a
slightly simpler and clearer call, and that the call will contain
the package name of the class (eliminating any ambiguity if two
classes from different packages have the same name).
</p>
<p>If the class is virtual, an attempt to generate an object  from
either the generator or <code>new()</code>
will result in an error.
</p>


<h3>Basic Use: Slots and Inheritance</h3>

<p>The two essential arguments other than the class name are
<code>slots</code> and <code>contains</code>, defining the explicit slots
and the inheritance (superclasses). Together, these arguments define
all the information in an object from this class; that is, the names
of all the slots and the classes required for each of them.
</p>
<p>The name of the class determines
which methods apply directly to objects from this class.  The
superclass information specifies which methods apply indirectly,
through inheritance.  See <a href="#topic+Methods_Details">Methods_Details</a> for inheritance in method
selection.
</p>
<p>The slots in a class definition will be the union of all the slots
specified directly by <code>slots</code> and all the slots in all
the contained classes.
There can only be one slot with a given name.
A class may override the definition of a slot with a given name, but
<em>only</em> if the newly specified class is a subclass of the
inherited one.
For example, if the contained class had a slot <code>a</code> with class
<code>"ANY"</code>, then a subclass could specify <code>a</code> with class
<code>"numeric"</code>,
but if the original specification for the slot was class
<code>"character"</code>, the new call to <code>setClass</code> would generate an error.
</p>
<p>Slot names <code>"class"</code> and <code>"Class"</code> are not allowed.
There are other slot names with a special meaning; these names start with
the <code>"."</code> character.  To be safe, you should define all of
your own slots with names starting with an alphabetic character.
</p>
<p>Some inherited classes will be treated specially&mdash;object types, S3
classes and a few special cases&mdash;whether inherited
directly or indirectly.  See the next three sections.
</p>


<h3>Virtual Classes</h3>

<p>Classes exist for which no actual objects can be created, the
<em>virtual</em> classes.
</p>
<p>The most common and useful form of virtual class is the <em>class
union</em>, a virtual class that is defined in a call to
<code><a href="#topic+setClassUnion">setClassUnion</a>()</code> rather than a call to
<code>setClass()</code>.
This call lists the <em>members</em> of the union&mdash;subclasses
that extend the new class.
Methods that are written with the class union in the signature
are eligible for use with objects from any of the member classes.
Class
unions can include as members classes whose
definition is otherwise sealed, including basic <span class="rlang"><b>R</b></span> data types.
</p>
<p>Calls to <code>setClass()</code> will also create a virtual class,
either when only the <code>Class</code> argument is supplied (no slots
or superclasses) or when the <code>contains=</code> argument includes
the special class name <code>"VIRTUAL"</code>.
</p>
<p>In the latter case, a
virtual class may include
slots to provide some common behavior without fully defining
the object&mdash;see the class <code><a href="#topic+traceable-class">traceable</a></code> for an
example.
Note that  <code>"VIRTUAL"</code> does not carry over to subclasses; a
class that contains a virtual class is not itself automatically virtual.
</p>


<h3>Inheriting from Object Types</h3>

<p>In addition to containing other S4 classes, a class definition can
contain either an S3 class (see the next section) or a built-in R pseudo-class&mdash;one
of the <span class="rlang"><b>R</b></span>
object types or one of the special <span class="rlang"><b>R</b></span> pseudo-classes <code>"matrix"</code> and
<code>"array"</code>.
A class can contain at most one of the object types, directly or indirectly.
When it does, that contained class determines the &ldquo;data part&rdquo;
of the class.
This appears as a pseudo-slot, <code>".Data"</code> and can be treated as a
slot but actually determines
the type of objects from this slot.
</p>
<p>Objects from the new class try to inherit the built in
behavior of the contained type.
In the case of normal <span class="rlang"><b>R</b></span> data types, including vectors, functions and
expressions, the implementation is relatively straightforward.
For any object <code>x</code> from the class,
<code>typeof(x)</code> will be the contained basic type; and a special
pseudo-slot, <code>.Data</code>, will be shown with the corresponding class.
See the <code>"numWithId"</code> example below.
</p>
<p>Classes may also inherit from <code>"vector"</code>, <code>"matrix"</code> or
<code>"array"</code>.
The data part of these objects can be any vector data type.
</p>
<p>For an object from any class that does <em>not</em> contain one of these
types or classes,
<code>typeof(x)</code> will be <code>"S4"</code>.
</p>
<p>Some <span class="rlang"><b>R</b></span> data types do not behave normally, in the sense that they are
non-local references or other objects that are not duplicated.
Examples include those corresponding to classes <code>"environment"</code>, <code>"externalptr"</code>, and <code>"name"</code>.
These can not be the types for objects with user-defined
classes (either S4 or S3) because setting an attribute overwrites the
object in all contexts.
It is possible to define a class that inherits from such types,
through an indirect mechanism that stores the inherited object in a
reserved slot, <code>".xData"</code>.
See the
example for class <code>"stampedEnv"</code> below.
An object from such a class does <em>not</em> have a <code>".Data"</code> pseudo-slot.
</p>
<p>For most computations, these classes behave transparently as if they
inherited directly from the anomalous type.
S3 method dispatch and the relevant <code>as.</code><em>type</em><code>()</code>
functions should behave correctly, but code that uses the type of the
object directly will not.
For example, <code>as.environment(e1)</code> would work as expected with the
<code>"stampedEnv"</code> class, but <code>typeof(e1)</code> is <code>"S4"</code>.
</p>


<h3>Inheriting from S3 Classes</h3>

<p>Old-style S3 classes have no formal definition.  Objects are
&ldquo;from&rdquo; the class when their class attribute contains the
character string considered to be the class name.
</p>
<p>Using such classes with formal classes and methods is necessarily a
risky business, since there are no guarantees about the content of the
objects or about consistency of inherited methods.
Given that, it is still possible to define a class that inherits from
an S3 class, providing that class has been registered as an old class
(see <code><a href="#topic+setOldClass">setOldClass</a></code>).
</p>
<p>Broadly speaking, both S3 and S4 method dispatch try to behave
sensibly with respect to inheritance in either system.
Given an S4 object, S3 method dispatch and the <code><a href="base.html#topic+inherits">inherits</a></code>
function should use the S4 inheritance information.
Given an S3 object, an S4 generic function will dispatch S4 methods
using the S3 inheritance, provided that inheritance has been declared via
<code><a href="#topic+setOldClass">setOldClass</a></code>.  For details, see <code><a href="#topic+setOldClass">setOldClass</a></code>
and Section 10.8 of the reference.
</p>


<h3>Classes and Packages</h3>

<p>Class definitions normally belong to packages (but can be defined in
the  global environment as well, by evaluating the expression on the
command line or in a file sourced from the command line).
The corresponding package name is part of the class definition; that
is, part of the <code><a href="#topic+classRepresentation-class">classRepresentation</a></code> object holding that
definition.  Thus, two classes with the same name can exist in
different packages, for most purposes.
</p>
<p>When a class name is supplied for a slot or a superclass in a call to
<code>setClass</code>, a
corresponding class definition will be found, looking from the
namespace of the current package, assuming the call in question appears directly in the source for the
package, as it should to avoid ambiguity.
The  class definition
must be already defined in this package, in the imports directives of
the package's <code>DESCRIPTION</code> and
<code>NAMESPACE</code> files or in the basic classes defined by the methods package.
(The &lsquo;methods&rsquo; package must be included in the imports directives
for any package that uses
S4 methods and classes, to satisfy the
<code>"CMD check"</code> utility.)
</p>
<p>If a package imports two classes of the same name from separate packages, the <code><a href="#topic+packageSlot">packageSlot</a></code>
of the <code>name</code> argument needs to be set to the package name of the
particular class.
This should be a rare occurrence.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Classes_Details">Classes_Details</a></code> for a general discussion of classes,
<code><a href="#topic+Methods_Details">Methods_Details</a></code> for an analogous discussion of methods,
<code><a href="#topic+makeClassRepresentation">makeClassRepresentation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A simple class with two slots
track &lt;- setClass("track", slots = c(x="numeric", y="numeric"))
## an object from the class
t1 &lt;- track(x = 1:10, y = 1:10 + rnorm(10))

## A class extending the previous, adding one more slot
trackCurve &lt;- setClass("trackCurve",
		slots = c(smooth = "numeric"),
		contains = "track")

## an object containing a superclass object
t1s &lt;- trackCurve(t1, smooth = 1:10)

## A class similar to "trackCurve", but with different structure
## allowing matrices for the "y" and "smooth" slots
setClass("trackMultiCurve",
         slots = c(x="numeric", y="matrix", smooth="matrix"),
         prototype = list(x=numeric(), y=matrix(0,0,0),
                          smooth= matrix(0,0,0)))

## A class that extends the built-in data type "numeric"

numWithId &lt;- setClass("numWithId", slots = c(id = "character"),
         contains = "numeric")

numWithId(1:3, id = "An Example")

## inherit from reference object of type "environment"
stampedEnv &lt;- setClass("stampedEnv", contains = "environment",
                       slots = c(update = "POSIXct"))
setMethod("[[&lt;-", c("stampedEnv", "character", "missing"),
   function(x, i, j, ..., value) {
       ev &lt;- as(x, "environment")
       ev[[i]] &lt;- value  #update the object in the environment
       x@update &lt;- Sys.time() # and the update time
       x})


e1 &lt;- stampedEnv(update = Sys.time())

e1[["noise"]] &lt;- rnorm(10)


</code></pre>

<hr>
<h2 id='setClassUnion'>Classes Defined as the Union of Other Classes</h2><span id='topic+setClassUnion'></span><span id='topic+isClassUnion'></span><span id='topic+ClassUnionRepresentation-class'></span>

<h3>Description</h3>

<p>A class may be defined as the <em>union</em> of other classes; that
is, as a virtual class defined as a superclass of several other
classes. Class unions are useful in method signatures or as slots in
other classes, when we want to allow one of several classes to be supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setClassUnion(name, members, where)
isClassUnion(Class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setClassUnion_+3A_name">name</code></td>
<td>
<p> the name for the new union class. </p>
</td></tr>
<tr><td><code id="setClassUnion_+3A_members">members</code></td>
<td>
<p> the names of the classes that should be members of this union.</p>
</td></tr>
<tr><td><code id="setClassUnion_+3A_where">where</code></td>
<td>
<p> where to save the new class definition.  In calls from
a package's source code, should be omitted to save the definition
in the package's namespace.</p>
</td></tr>
<tr><td><code id="setClassUnion_+3A_class">Class</code></td>
<td>
<p> the name or definition of a class.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classes in <code>members</code> must be defined before creating the
union.  However, members can be added later on to an existing
union, as shown in the example below. Class unions can be
members of other class unions.
</p>
<p>Class unions are the only way to create a new superclass of
a class whose definition is sealed.  The namespace of all
packages is sealed when the package is loaded, protecting the
class and other definitions from being overwritten from another
class or from the global environment.  A call to
<code><a href="#topic+setIs">setIs</a></code> that tried to define a new superclass for
class <code>"numeric"</code>, for example, would cause an error.
</p>
<p>Class unions are the exception; the class union
<code>"maybeNumber"</code> in the examples defines itself as a new
superclass of <code>"numeric"</code>.  Technically, it does not alter the
metadata object in the other package's namespace and, of course,
the effect of the class union depends on loading the package it
belongs to.  But, basically, class unions are sufficiently useful
to justify the exemption.
</p>
<p>The different behavior for class unions is made possible because the
class definition object for class unions has itself a special class,
<code>"ClassUnionRepresentation"</code>, an extension of class
<code><a href="#topic+classRepresentation-class">classRepresentation</a></code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a class for either numeric or logical data
setClassUnion("maybeNumber", c("numeric", "logical"))

## use the union as the data part of another class
setClass("withId", contains = "maybeNumber", slots = c(id = "character"))

w1 &lt;- new("withId", 1:10, id = "test 1")
w2 &lt;- new("withId", sqrt(w1)%%1 &lt; .01, id = "Perfect squares")

## add class "complex" to the union "maybeNumber"
setIs("complex", "maybeNumber")

w3 &lt;- new("withId", complex(real = 1:10, imaginary = sqrt(1:10)))

## a class union containing the existing class  union "OptionalFunction"
setClassUnion("maybeCode",
    c("expression", "language", "OptionalFunction"))

is(quote(sqrt(1:10)), "maybeCode")  ## TRUE


</code></pre>

<hr>
<h2 id='setGeneric'>Create a Generic Version of a Function</h2><span id='topic+setGeneric'></span>

<h3>Description</h3>

<p>Create a generic version of the named function so that methods may
be defined for it.  A call to <code><a href="#topic+setMethod">setMethod</a></code> will call
<code>setGeneric</code> automatically if applied to a non-generic
function.
</p>
<p>An explicit call to <code>setGeneric</code> is usually not required, but
doesn't hurt and makes explicit that methods are being defined for a
non-generic function.
</p>
<p>Standard calls will be of the form:
</p>
<p><code>setGeneric(name)</code>
</p>
<p>where <code>name</code> specifies an existing function, possibly in another
package.  An alternative when creating a new generic function in this package is:
</p>
<p><code>setGeneric(name, def)</code>
</p>
<p>where the function definition <code>def</code> specifies the formal
arguments and becomes the default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGeneric(name, def= , group=list(), valueClass=character(),
           where= , package= , signature= , useAsDefault= ,
           genericFunction= , simpleInheritanceOnly = )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGeneric_+3A_name">name</code></td>
<td>
<p> The character string name of the generic function.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_def">def</code></td>
<td>
<p>An optional function object, defining the non-generic
version, to become the default method.  This is equivalent in
effect to assigning <code>def</code> as the function and then using
the one-argument call to <code>setGeneric</code>.
</p>
<p><em>The following arguments are specialized, optionally used
when creating a new generic function with non-standard
features. They should not be used when the non-generic is in
another package.</em>
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_group">group</code></td>
<td>
<p> The name of the group
generic function to which this function belongs.  See
<a href="#topic+Methods_Details">Methods_Details</a> for details of group generic functions in method
selection and <a href="#topic+S4groupGeneric">S4groupGeneric</a> for existing groups.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_valueclass">valueClass</code></td>
<td>
<p> A character vector specifying one or more class
names.  The value returned by the generic function must
have (or extend) this class, or one of the classes; otherwise,
an error is generated.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_signature">signature</code></td>
<td>

<p>The vector of names from among the formal arguments to
the function, that will be allowed in the signature of methods for this
function, in calls to <code><a href="#topic+setMethod">setMethod</a></code>.  By default and
usually, this will be all formal arguments except <code>...</code>.
</p>
<p>A non-standard signature for the generic function may be
used to exclude arguments that take advantage of lazy evaluation;
in particular, if the argument may <em>not</em> be evaluated then it
cannot be part of the signature.
</p>
<p>While <code>...</code> cannot be used as part of a general signature,
it is possible to have this as the <em>only</em> element of the
signature.
Methods will then be selected if their signature matches
all the <code>...</code> arguments.  See the documentation for topic
<a href="#topic+dotsMethods">dotsMethods</a> for details.  It is not
possible to mix <code>...</code> and other arguments in the signature.
</p>
<p>It's usually a mistake to omit arguments from the signature in the
belief that this improves efficiency.  For method selection, the
arguments that are used in the signatures for the <em>methods</em>
are what counts, and then only seriously on the first call to the
function with that combination of classes.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_simpleinheritanceonly">simpleInheritanceOnly</code></td>
<td>

<p>Supply this argument as <code>TRUE</code> to require that methods selected
be inherited through simple inheritance only; that is, from
superclasses specified in the <code>contains=</code> argument to
<code><a href="#topic+setClass">setClass</a></code>, or by simple inheritance to a class union or
other virtual class.  Generic functions should require simple
inheritance if they need to be assured that they get the complete
original object, not one that has been transformed.  Examples of
functions requiring simple inheritance are <code><a href="#topic+initialize">initialize</a></code>,
because by definition it must return an object from the same class
as its argument, and <code><a href="#topic+show">show</a></code>, because it claims to give a
full description of the object provided as its argument.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_useasdefault">useAsDefault</code></td>
<td>

<p>Override the usual default method mechanism.  Only relevant when
defining a nonstandard generic function.
See the section &lsquo;Specialized Local Generics&rsquo;.
</p>
<p><em>The remaining arguments are obsolete for normal applications.</em>
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_package">package</code></td>
<td>
<p> The name of the package with which this function is
associated.  Should be determined automatically from the
non-generic version.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_where">where</code></td>
<td>
<p> Where to store the resulting objects as side effects.
The default, to store in the package's namespace, is the only
safe choice.
</p>
</td></tr>
<tr><td><code id="setGeneric_+3A_genericfunction">genericFunction</code></td>
<td>
<p>Obsolete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>setGeneric</code> function exists for its side effect: saving the
generic function to allow methods to be specified later.  It returns
<code>name</code>.
</p>


<h3>Basic Use</h3>

<p>The <code>setGeneric</code> function is called to initialize a generic
function as preparation for defining some methods for that function.
</p>
<p>The simplest and most common situation is that <code>name</code> specifies
an existing function, usually in another package. You now want to
define methods for this function.  In this case you should
supply only <code>name</code>, for example:
</p>
<p><code>setGeneric("colSums")</code>
</p>
<p>There must be an existing function of this name (in this case in
package <code>"base"</code>).  The non-generic function can be in the same
package as the call, typically the case when you are creating a new
function plus methods for it. When the function is in
another package, it must be available by name, for
example through an <code>importFrom()</code> directive in this package's
<code>NAMESPACE</code> file. Not required for functions in <code>"base"</code>,
which are implicitly imported.
</p>
<p>A generic version of
the function will be created in the current package.  The existing function
becomes the default method, and the package slot of the new generic
function is set to the location of the original function
(<code>"base"</code> in the example).  
</p>
<p>Two special types of non-generic should be noted.
Functions that dispatch S3 methods by calling
<code><a href="base.html#topic+UseMethod">UseMethod</a></code> are ordinary functions, not objects from the
<code>"genericFunction"</code> class.  They are made generic like any
other function, but some special considerations apply to ensure that
S4 and S3 method dispatch is consistent (see <a href="#topic+Methods_for_S3">Methods_for_S3</a>).
</p>
<p>Primitive functions are handled in C code and don't exist as normal
functions.
A call to <code>setGeneric</code> is allowed in the simple form, but no
actual generic function object is created.  Method dispatch will
take place in the C code. See the section on Primitive Functions for
more details.
</p>
<p>It's an important feature that the
identical generic function definition is created in every package that
uses the same <code>setGeneric()</code> call.
When any of these packages is loaded into an <span class="rlang"><b>R</b></span> session, this
function will be added to a table of generic functions, and will
contain a methods table of all the available methods for the
function.
</p>
<p>Calling <code>setGeneric()</code> is not strictly
necessary before calling <code>setMethod()</code>.  If
the function specified in the call to <code>setMethod</code> is not generic,
<code>setMethod</code> will execute the call to <code>setGeneric</code> itself.
In the case that the non-generic is in another package, does not
dispatch S3 methods and is not a primitive, a message is printed noting the
creation of the generic function the first time <code>setMethod</code> is called.
</p>
<p>The second common use of <code>setGeneric()</code> is to create a new
generic function, unrelated to any existing function.  See the
<code>asRObject()</code> example below.
This case can be handled just like the previous examples, with only
the difference that the non-generic function exists in the
current package.
Again, the non-generic version becomes the default method.
For clarity it's best for the assignment to immediately precede the
call to <code>setGeneric()</code> in the source code.
</p>
<p>Exactly the same result can be obtained by supplying the default as
the <code>def</code> argument instead of assigning it.
In some applications, there will be no completely general default
method. While there is a special mechanism for this (see the
&lsquo;Specialized Local Generics&rsquo; section), the recommendation is to provide a
default method that signals an error, but with a message that
explains as clearly as you can why a non-default method is needed.
</p>


<h3>Specialized Local Generics</h3>

<p>The great majority of calls to <code>setGeneric()</code> should either
have one argument to ensure that an existing function can have
methods, or arguments <code>name</code> and <code>def</code> to create a new
generic function and optionally a default method.
</p>
<p>It is possible to create generic functions with nonstandard
signatures, or functions that do additional computations besides
method dispatch or that belong to a group of generic functions.
</p>
<p>None of these mechanisms should be used with a non-generic function
from a <em>different</em> package, because the result is to create a
generic function that may not be consistent from one package to another.
When any such options are used,
the new generic function will be assigned with a
package slot set to the <em>current</em> package, not the one in which
the non-generic version of the function is found.
</p>
<p>There is a mechanism to define a specialized generic version of a
non-generic function, the <code><a href="#topic+implicitGeneric">implicitGeneric</a></code>
construction.
This defines the generic version, but then reverts the function to
it non-generic form, saving the implicit generic in a table to be
activated when methods are defined.
However, the mechanism can only legitimately be used either for a non-generic
in the same package or by the <code>"methods"</code> package itself.
And in the first case, there is no compelling reason not to simply
make the function generic, with the non-generic as the default
method.
See <code><a href="#topic+implicitGeneric">implicitGeneric</a></code> for details.
</p>
<p>The body of a generic function usually does nothing except for
dispatching methods by a call to <code>standardGeneric</code>.  Under some
circumstances you might just want to do some additional computation in
the generic function itself.  As long as your function eventually
calls <code>standardGeneric</code> that is permissible.
See the example <code>"authorNames"</code> below.
</p>
<p>In this case, the <code>def</code> argument will define the nonstandard
generic, not the default method.
An existing non-generic of the same name and calling sequence should
be pre-assigned.  It will become the default method, as usual.
(An alternative is the <code>useAsDefault</code> argument.)
</p>
<p>By default, the generic function can return any object.  If
<code>valueClass</code> is supplied, it should be a vector of class names;
the value returned by a method is then required to satisfy
<code>is(object, Class)</code> for one of the specified classes.  An empty
(i.e., zero length) vector of classes means anything is allowed.  Note
that more complicated requirements on the result can be specified
explicitly, by defining a non-standard generic function.
</p>
<p>If the <code>def</code> argument calls <code>standardGeneric()</code> (with or
without additional computations) and there is no existing
non-generic version of the function, the generic is created without
a default method.  This is not usually a good idea:  better to have a
default method that signals an error with a message explaining why
the default case is not defined.
</p>
<p>A new generic function can be created belonging to an existing group
by including the <code>group</code> argument.  The argument list of the
new generic must agree with that of the group. See
<code><a href="#topic+setGroupGeneric">setGroupGeneric</a></code> for defining a new group generic.
For the role of group generics in
dispatching methods, see <a href="#topic+GroupGenericFunctions">GroupGenericFunctions</a> and section
10.5 of the second reference.
</p>


<h3>Generic Functions and Primitive Functions</h3>

<p>A number of the basic <span class="rlang"><b>R</b></span> functions are specially implemented as
primitive functions, to be evaluated directly in the underlying C code
rather than by evaluating an <span class="rlang"><b>R</b></span> language definition.  Most have
implicit generics (see <code><a href="#topic+implicitGeneric">implicitGeneric</a></code>), and become
generic as soon as methods (including group methods) are defined on
them.  Others cannot be made generic.
</p>
<p>Calling <code>setGeneric()</code> for
the primitive functions in the base package differs in that it does not, in fact,
generate an explicit generic function.
Methods for primitives are selected and dispatched from
the internal C code, to satisfy concerns for efficiency.
The same is true for a few
non-primitive functions that dispatch internally. These include
<code>unlist</code> and <code>as.vector</code>.
</p>
<p>Note, that the implementation restrict methods for
primitive functions to signatures in which at least one of the classes
in the signature is a formal S4 class.
Otherwise the internal C code will not look for methods.
This is a desirable restriction in principle, since optional
packages should not be allowed to change the behavior of basic R
computations on existing data types.
</p>
<p>To see the generic version of a primitive function, use
<code><a href="#topic+getGeneric">getGeneric</a>(name)</code>.  The function
<code><a href="#topic+isGeneric">isGeneric</a></code> will tell you whether methods are defined
for the function in the current session.
</p>
<p>Note that S4 methods can only be set on those primitives which are
&lsquo;<a href="base.html#topic+internal+20generic">internal generic</a>&rsquo;, plus <code>%*%</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>
<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer. (Section 10.5 for some details.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Methods_Details">Methods_Details</a></code> and the links there for a general discussion,
<code><a href="#topic+dotsMethods">dotsMethods</a></code> for methods that dispatch on
<code>...</code>, and <code><a href="#topic+setMethod">setMethod</a></code> for method definitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Specify that this package will define methods for plot()
setGeneric("plot")

## create a new generic function, with a default method
setGeneric("props", function(object) attributes(object))

###   A non-standard generic function.  It insists that the methods
###   return a non-empty character vector (a stronger requirement than
###    valueClass = "character" in the call to setGeneric)

setGeneric("authorNames",
    function(text) {
      value &lt;- standardGeneric("authorNames")
      if(!(is(value, "character") &amp;&amp; any(nchar(value)&gt;0)))
        stop("authorNames methods must return non-empty strings")
      value
      })

## the asRObject generic function, from package XR
## Its default method just returns object
## See the reference, Chapter 12 for methods

setGeneric("asRObject", function(object, evaluator) {
        object
})




</code></pre>

<hr>
<h2 id='setGroupGeneric'>Create a Group Generic Version of a Function</h2><span id='topic+setGroupGeneric'></span>

<h3>Description</h3>

<p>The <code>setGroupGeneric</code> function behaves like <code><a href="#topic+setGeneric">setGeneric</a></code>
except that it constructs a group generic function, differing in two
ways from an ordinary generic function.  First, this function cannot
be called directly, and the body of the function created will contain
a stop call with this information.  Second, the group generic function
contains information about the known members of the group, used to
keep the members up to date when the group definition changes, through
changes in the search list or direct specification of methods, etc.
</p>
<p>All members of the group must have the identical argument list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGroupGeneric(name, def= , group=list(), valueClass=character(),
                knownMembers=list(), package= , where= )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGroupGeneric_+3A_name">name</code></td>
<td>
<p>the character string name of the generic function.
</p>
</td></tr>
<tr><td><code id="setGroupGeneric_+3A_def">def</code></td>
<td>
<p>A function object.  There isn't likely to be an existing
nongeneric of this name, so some function needs to be supplied.  Any
known member or other function with the same argument list will do,
because the group generic cannot be called directly.
</p>
</td></tr>
<tr><td><code id="setGroupGeneric_+3A_group">group</code>, <code id="setGroupGeneric_+3A_valueclass">valueClass</code></td>
<td>
<p>arguments to pass to
<code><a href="#topic+setGeneric">setGeneric</a></code>.
</p>
</td></tr>
<tr><td><code id="setGroupGeneric_+3A_knownmembers">knownMembers</code></td>
<td>
<p>the names of functions that are
known to be members of this group.  This information is used to
reset cached definitions of the member generics when information
about the group generic is changed.
</p>
</td></tr>
<tr><td><code id="setGroupGeneric_+3A_package">package</code>, <code id="setGroupGeneric_+3A_where">where</code></td>
<td>
<p>passed to <code><a href="#topic+setGeneric">setGeneric</a></code>, but
obsolete and to be avoided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>setGroupGeneric</code> function exists for its side effect: saving the
generic function to allow methods to be specified later.  It returns
<code>name</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>
Chapman &amp; Hall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Methods_Details">Methods_Details</a></code> and the links there for a general discussion,
<code><a href="#topic+dotsMethods">dotsMethods</a></code> for methods that dispatch on
<code>...</code>, and <code><a href="#topic+setMethod">setMethod</a></code> for method definitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## the definition of the "Logic" group generic in the methods package
setGroupGeneric("Logic", function(e1, e2) NULL,
    knownMembers = c("&amp;", "|"))

## End(Not run)
</code></pre>

<hr>
<h2 id='setIs'>Specify a Superclass Explicitly</h2><span id='topic+setIs'></span>

<h3>Description</h3>

<p><code>setIs</code> is an explicit alternative
to the <code>contains=</code> argument to <code><a href="#topic+setClass">setClass</a></code>.  It is
only needed to create relations with explicit test or coercion.
These have not proved to be of much practical value, so this
function should not likely be needed in applications.
</p>
<p>Where the programming goal is to define methods for transforming one
class of objects to another, it is usually better practice to call
<code><a href="#topic+setAs">setAs</a>()</code>, which requires the transformations to be done explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setIs(class1, class2, test=NULL, coerce=NULL, replace=NULL,
      by = character(), where = topenv(parent.frame()), classDef =,
      extensionObject = NULL, doComplete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setIs_+3A_class1">class1</code>, <code id="setIs_+3A_class2">class2</code></td>
<td>

<p>the names of the classes between which <code>is</code> relations are to be
examined defined, or (more efficiently) the class definition
objects for the classes.</p>
</td></tr>
<tr><td><code id="setIs_+3A_coerce">coerce</code>, <code id="setIs_+3A_replace">replace</code></td>
<td>

<p>functions optionally supplied to coerce the object to
<code>class2</code>, and to alter the object so that <code>is(object, class2)</code>
is identical to <code>value</code>.  See the details section below.</p>
</td></tr>
<tr><td><code id="setIs_+3A_test">test</code></td>
<td>

<p>a <em>conditional</em> relationship is
defined by supplying this function.  Conditional relations are
discouraged and are not included in selecting methods.  See the details section below.
</p>
<p>The remaining arguments are for internal use and/or usually omitted.</p>
</td></tr>
<tr><td><code id="setIs_+3A_extensionobject">extensionObject</code></td>
<td>
<p> alternative to the <code>test, coerce,
    replace, by</code> arguments; an object from class
<code>SClassExtension</code> describing the relation.  (Used in internal calls.)</p>
</td></tr>
<tr><td><code id="setIs_+3A_docomplete">doComplete</code></td>
<td>
<p>when <code>TRUE</code>, the class definitions will be
augmented with indirect relations as well.  (Used in internal calls.)</p>
</td></tr>
<tr><td><code id="setIs_+3A_by">by</code></td>
<td>

<p>In a call to <code>setIs</code>, the name of an intermediary class.
Coercion will proceed by first coercing to this class and from there
to the target class.  (The intermediate coercions have to be valid.)</p>
</td></tr>
<tr><td><code id="setIs_+3A_where">where</code></td>
<td>

<p>In a call to <code>setIs</code>, where to store the metadata defining the
relationship.  Default is the global environment for calls from the
top level of the session or a source file evaluated there.  When the
call occurs in the top level of a file in the source of a package,
the default will be the namespace or environment of the package.
Other uses are tricky and not usually a good idea, unless you really
know what you are doing.</p>
</td></tr>
<tr><td><code id="setIs_+3A_classdef">classDef</code></td>
<td>

<p>Optional class definition for <code>class</code> , required internally
when <code>setIs</code> is called during the initial definition of the
class by a call to <code><a href="#topic+setClass">setClass</a></code>. <em>Don't</em> use this
argument, unless you really know why you're doing so.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arranging for a class to inherit from another class is a key tool in
programming.  In <span class="rlang"><b>R</b></span>, there are three basic techniques, the first two
providing what is called  &ldquo;simple&rdquo; inheritance, the preferred form:

</p>

<ol>
<li>
<p>By the <code>contains=</code> argument in a call to <code><a href="#topic+setClass">setClass</a></code>.  This
is and should be the most common mechanism.  It arranges that the new
class contains all the structure of the existing class, and in
particular all the slots with the same class specified.  The
resulting class extension is defined to be <code>simple</code>, with
important implications for method definition (see the section on
this topic below).
</p>
</li>
<li>
<p>Making <code>class1</code> a subclass of a virtual class
either by a call to <code><a href="#topic+setClassUnion">setClassUnion</a></code> to make the
subclass a member of a new class union, or by a call to
<code>setIs</code> to add a class to an existing class union or as a new
subclass of an existing virtual class.  In either case, the
implication should be that methods defined for the class union or
other superclass all work correctly for the subclass.  This may
depend on some similarity in the structure of the subclasses or
simply indicate that the superclass methods are defined in terms
of generic functions that apply to all the subclasses.  These
relationships are also generally simple.
</p>
</li>
<li>
<p>Supplying <code>coerce</code>  and <code>replace</code> arguments to <code>setAs</code>.
<span class="rlang"><b>R</b></span> allows arbitrary inheritance relationships, using the same
mechanism for defining coerce methods by a call to
<code><a href="#topic+setAs">setAs</a></code>.  The difference between the  two is simply
that <code><a href="#topic+setAs">setAs</a></code> will require a call to <code><a href="#topic+as">as</a></code>
for a conversion to take place, whereas after the call to
<code><a href="#topic+setIs">setIs</a></code>, objects will be automatically converted to
the superclass.
</p>
<p>The automatic feature is the dangerous part, mainly because it
results in the subclass potentially inheriting methods that do
not work.  See the section on inheritance below.  If the two
classes involved do not actually inherit a large collection of
methods, as in the first example below, the danger may be
relatively slight.
</p>
<p>If the superclass inherits methods where the subclass has only a
default or remotely inherited method, problems are more likely.
In this case, a general
recommendation is to use the <code><a href="#topic+setAs">setAs</a></code> mechanism
instead, unless there is a strong counter reason. Otherwise, be prepared to
override some of  the methods inherited.
</p>
</li></ol>

<p>With this caution given, the rest of this section describes what
happens when <code>coerce=</code> and <code>replace=</code> arguments are supplied
to <code>setIs</code>.
</p>
<p>The <code>coerce</code> and <code>replace</code> arguments are functions that
define how to coerce a <code>class1</code> object to <code>class2</code>, and
how to replace the part of the subclass object that corresponds to
<code>class2</code>.  The first of these is a function of one argument
which should be <code>from</code>, and the second of two arguments
(<code>from</code>, <code>value</code>).  For details, see the section on coerce
functions below .
</p>
<p>When <code>by</code> is specified, the coerce process first coerces to
this class and then to <code>class2</code>.  It's unlikely you
would use the <code>by</code> argument directly, but it is used in defining
cached information about classes.
</p>
<p>The value returned (invisibly) by
<code>setIs</code> is the revised class definition of <code>class1</code>.
</p>


<h3>Coerce, replace, and test functions</h3>

<p>The  <code>coerce</code> argument is a function that turns a
<code>class1</code> object into a <code>class2</code> object.  The
<code>replace</code> argument is a function of two arguments that modifies a <code>class1</code>
object (the first argument) to replace the part of it that
corresponds to <code>class2</code> (supplied as <code>value</code>, the second
argument).  It then returns the modified object as the value of the
call.  In other words, it acts as a replacement method to
implement the expression <code>as(object, class2) &lt;- value</code>.
</p>
<p>The easiest way to think of the  <code>coerce</code> and <code>replace</code>
functions is by thinking of the case that  <code>class1</code>
contains <code>class2</code> in the usual sense, by including the slots of
the second class.  (To repeat, in this situation you would not call
<code>setIs</code>, but the analogy shows what happens when you do.)
</p>
<p>The <code>coerce</code> function in this case would just make a
<code>class2</code> object by extracting the corresponding slots from the
<code>class1</code> object. The <code>replace</code> function would replace in
the <code>class1</code> object the slots corresponding to <code>class2</code>,
and return the modified object as its value.
</p>
<p>For additional discussion of these functions, see
the documentation of the
<code><a href="#topic+setAs">setAs</a></code> function.  (Unfortunately, argument
<code>def</code> to that function corresponds to argument <code>coerce</code> here.)
</p>
<p>The inheritance relationship can also be conditional, if a function is supplied as the
<code>test</code> argument.  This should be a function of one argument
that returns <code>TRUE</code> or <code>FALSE</code> according to whether the
object supplied satisfies the relation <code>is(object, class2)</code>.
Conditional relations between
classes are discouraged in general because they require a per-object
calculation to determine their validity. They cannot be applied
as efficiently as ordinary relations and tend to make the code that
uses them harder to interpret.  <em>NOTE:  conditional inheritance
is not used to dispatch methods.</em>  Methods for conditional
superclasses will not be inherited.  Instead, a method for the
subclass should be defined that tests the conditional relationship.
</p>


<h3>Inherited methods</h3>

<p>A method written for a particular signature (classes matched to one
or more formal arguments to the function) naturally assumes that the
objects corresponding to the arguments can be treated as coming from
the corresponding classes.  The objects will have all the slots and
available methods for the classes.
</p>
<p>The code that selects and dispatches the methods ensures that this
assumption is correct.  If the inheritance was &ldquo;simple&rdquo;, that
is, defined by one or more uses of the <code>contains=</code> argument in
a call to <code><a href="#topic+setClass">setClass</a></code>, no extra work is generally
needed.  Classes are inherited from the superclass, with the same
definition.
</p>
<p>When inheritance is defined by a general call to
<code>setIs</code>, extra computations are required.  This form of
inheritance implies that the subclass does <em>not</em> just contain
the slots of the superclass, but instead requires the explicit call
to the coerce and/or replace method.  To ensure correct computation,
the inherited method is supplemented by calls to <code><a href="#topic+as">as</a></code>
before the body of the method is evaluated.
</p>
<p>The calls to <code><a href="#topic+as">as</a></code> generated in this case have the
argument <code>strict = FALSE</code>, meaning that extra information can
be left in the converted object, so long as it has all the
appropriate slots.  (It's this option that allows simple subclass
objects to be used without any change.)  When you are writing your
coerce method, you may want to take advantage of that option.
</p>
<p>Methods inherited through non-simple extensions can result in ambiguities
or unexpected selections.  If <code>class2</code> is a specialized class
with just a few applicable methods, creating the inheritance
relation may have little effect on the behavior of <code>class1</code>.
But if <code>class2</code> is a class with many methods, you may
find that you now inherit some undesirable methods for
<code>class1</code>, in some cases, fail to inherit expected methods.
In the second example below, the non-simple inheritance from class
<code>"factor"</code> might be assumed to inherit S3 methods via that
class.  But the S3 class is ambiguous, and in fact is
<code>"character"</code> rather than <code>"factor"</code>.
</p>
<p>For some generic functions, methods inherited by non-simple
extensions are either known to be invalid or sufficiently likely to
be so that the generic function has been defined to exclude such
inheritance.  For example <code><a href="#topic+initialize">initialize</a></code> methods must
return an object of the target class; this is straightforward if the
extension is simple, because no change is made to the argument
object, but is essentially impossible.  For this reason, the generic
function insists on only simple extensions for inheritance.  See the
<code>simpleInheritanceOnly</code> argument to <code><a href="#topic+setGeneric">setGeneric</a></code>
for the mechanism.  You can use this mechanism when defining new
generic functions.
</p>
<p>If you get into problems with functions that do allow non-simple
inheritance, there are two basic choices.  Either
back off from the <code>setIs</code> call and settle for explicit coercing
defined by a call to <code><a href="#topic+setAs">setAs</a></code>; or, define explicit
methods involving <code>class1</code> to override the bad inherited
methods.  The first choice is the safer, when there are serious
problems.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two examples of setIs() with coerce= and replace= arguments
## The first one works fairly well, because neither class has many
## inherited methods do be disturbed by the new inheritance

## The second example does NOT work well, because the new superclass,
## "factor", causes methods to be inherited that should not be.

## First example:
## a class definition (see \link{setClass} for class "track")
setClass("trackCurve", contains = "track",
         slots = c( smooth = "numeric"))
## A class similar to "trackCurve", but with different structure
## allowing matrices for the "y" and "smooth" slots
setClass("trackMultiCurve",
         slots = c(x="numeric", y="matrix", smooth="matrix"),
         prototype = structure(list(), x=numeric(), y=matrix(0,0,0),

                               smooth= matrix(0,0,0)))
## Automatically convert an object from class "trackCurve" into
## "trackMultiCurve", by making the y, smooth slots into 1-column matrices
setIs("trackCurve",
      "trackMultiCurve",
      coerce = function(obj) {
        new("trackMultiCurve",
            x = obj@x,
            y = as.matrix(obj@y),
            smooth = as.matrix(obj@smooth))
      },
      replace = function(obj, value) {
        obj@y &lt;- as.matrix(value@y)
        obj@x &lt;- value@x
        obj@smooth &lt;- as.matrix(value@smooth)
        obj})




## Second Example:
## A class that adds a slot to "character"
setClass("stringsDated", contains = "character",
         slots = c(stamp="POSIXt"))

## Convert automatically to a factor by explicit coerce
setIs("stringsDated", "factor",
      coerce = function(from) factor(from@.Data),
      replace= function(from, value) {
                  from@.Data &lt;- as.character(value); from })

ll &lt;- sample(letters, 10, replace = TRUE)
ld &lt;- new("stringsDated", ll, stamp = Sys.time())

levels(as(ld, "factor"))
levels(ld) # will be NULL--see comment in section on inheritance above.

## In contrast, a class that simply extends "factor"
## has no such ambiguities
setClass("factorDated", contains = "factor",
         slots = c(stamp="POSIXt"))
fd &lt;- new("factorDated", factor(ll), stamp = Sys.time())
identical(levels(fd), levels(as(fd, "factor")))
</code></pre>

<hr>
<h2 id='setLoadActions'>
Set Actions For Package Loading
</h2><span id='topic+setLoadAction'></span><span id='topic+setLoadActions'></span><span id='topic+getLoadActions'></span><span id='topic+hasLoadAction'></span><span id='topic+evalOnLoad'></span><span id='topic+evalqOnLoad'></span>

<h3>Description</h3>

<p>These functions provide a mechanism for packages to specify
computations to be done during the loading of a package namespace.
Such actions are a flexible way to provide information only available at
load time (such as locations in a dynamically linked library).
</p>
<p>A call to <code>setLoadAction()</code> or <code>setLoadActions()</code> specifies
one or more functions to be called when the corresponding namespace is
loaded, with the ... argument names being used as identifying
names for the actions.
</p>
<p><code>getLoadActions</code> reports the currently defined load actions,
given a package's namespace as its argument.
</p>
<p><code>hasLoadAction</code> returns <code>TRUE</code> if a load action
corresponding to the given name has previously been set for the
<code>where</code> namespace.
</p>
<p><code>evalOnLoad()</code> and <code>evalqOnLoad()</code> schedule a specific
expression for evaluation at load time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLoadAction(action, aname=, where=)

setLoadActions(..., .where=)

getLoadActions(where=)

hasLoadAction(aname, where=)

evalOnLoad(expr, where=, aname=)

evalqOnLoad(expr, where=, aname=)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLoadActions_+3A_action">action</code>, <code id="setLoadActions_+3A_...">...</code></td>
<td>

<p>functions of one or more arguments, to be called when this package is
loaded. The functions will be called with one argument (the package
namespace) so all following arguments must have default values.
</p>
<p>If the elements of ... are named, these names will be used for the
corresponding load metadata.
</p>
</td></tr>
<tr><td><code id="setLoadActions_+3A_where">where</code>, <code id="setLoadActions_+3A_.where">.where</code></td>
<td>

<p>the namespace of the package for which the list of load actions are
defined. This argument is normally omitted if the call comes from the
source code for the package itself, but will be needed if a package
supplies load actions for another package.
</p>
</td></tr>
<tr><td><code id="setLoadActions_+3A_aname">aname</code></td>
<td>
<p>the name for the action.  If an action is set without
supplying a name,  the default uses the position in the sequence of
actions specified (<code>".1"</code>, etc.).
</p>
</td></tr>
<tr><td><code id="setLoadActions_+3A_expr">expr</code></td>
<td>
<p>an expression to be evaluated in a load action in
environment <code>where</code>.  In the case of <code>evalqOnLoad()</code>,
the expression is interpreted literally, in that of
<code>evalOnLoad()</code> it must be precomputed, typically as an object
of type <code>"language"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>evalOnLoad()</code> and <code>evalqOnLoad()</code> functions are for
convenience.  They construct a function to evaluate the expression and
call <code>setLoadAction()</code> to schedule a call to that function.
</p>
<p>Each of the functions supplied as an argument to <code>setLoadAction()</code>
or <code>setLoadActions()</code> is saved as metadata in the namespace,
typically that of the package containing the call to
<code>setLoadActions()</code>.  When this package's namespace is loaded, each
of these functions will be called.  Action functions are called in the
order they are supplied to <code>setLoadActions()</code>.  The objects
assigned have metadata names constructed from the names supplied in the
call; unnamed arguments are taken to be named by their position in the
list of actions (<code>".1"</code>, etc.).
</p>
<p>Multiple calls to <code>setLoadAction()</code> or <code>setLoadActions()</code>
can be used in a package's code; the actions will be scheduled after any
previously specified, except if the name given to <code>setLoadAction()</code>
is that of an existing action.  In typical applications,
<code>setLoadActions()</code> is more convenient when calling from the
package's own code to set several actions.  Calls to
<code>setLoadAction()</code> are more convenient if the action name is to be
constructed, which is more typical when one package constructs load
actions for another package.
</p>
<p>Actions can be revised by assigning with the same name, actual or
constructed, in a subsequent call.  The replacement must still be a
valid function, but can of course do nothing if the intention was to
remove a previously specified action.
</p>
<p>The functions must have at least one argument.  They will be called with
one argument, the namespace of the package.  The functions will be
called at the end of processing of S4 metadata, after dynamically
linking any compiled code, the call to <code>.onLoad()</code>, if any, and
caching method and class definitions, but before the namespace is
sealed.  (Load actions are only called if methods dispatch is on.)
</p>
<p>Functions may therefore assign or modify objects in the namespace
supplied as the argument in the call.  The mechanism allows packages
to save information not available until load time, such as values
obtained from a dynamically linked library.
</p>
<p>Load actions should be contrasted with user load hooks supplied by
<code><a href="base.html#topic+setHook">setHook</a>()</code>.  User hooks are generally provided from
outside the package and are run after the namespace has been sealed.
Load actions are normally part of the package code, and the list of
actions is normally established when the package is installed.
</p>
<p>Load actions can be supplied directly in the source code for a
package.  It is also possible and useful to provide facilities in one
package to create load actions in another package.  The software needs
to be careful to assign the action functions in the correct
environment, namely the namespace of the target package.
</p>


<h3>Value</h3>

  
<p><code>setLoadAction()</code> and <code>setLoadActions()</code> are called for
their side effect and return no useful value.
</p>
<p><code>getLoadActions()</code> returns a named list of the actions in the
supplied namespace.
</p>
<p><code>hasLoadAction()</code> returns <code>TRUE</code> if the specified action
name appears in the actions for this package.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+setHook">setHook</a></code> for safer (since they are run after the
namespace is sealed) and more comprehensive versions in the
base package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## in the code for some package

## ... somewhere else
setLoadActions(function(ns)
   cat("Loaded package", sQuote(getNamespaceName(ns)),
       "at", format(Sys.time()), "\n"),
  setCount = function(ns) assign("myCount", 1, envir = ns),
  function(ns) assign("myPointer", getMyExternalPointer(), envir = ns))
  ... somewhere later
if(countShouldBe0)
  setLoadAction(function(ns) assign("myCount", 0, envir = ns), "setCount")

## End(Not run)
</code></pre>

<hr>
<h2 id='setMethod'> Create and Save a Method </h2><span id='topic+setMethod'></span>

<h3>Description</h3>

<p>Create a method for a generic function, corresponding to a signature of classes for the arguments. Standard usage will be of the form:
</p>
<p><code>setMethod(f, signature, definition)</code>
</p>
<p>where <code>f</code> is the name of the function, <code>signature</code> specifies the argument classes for which the method applies and <code>definition</code> is the function definition for the method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMethod(f, signature=character(), definition,
          where = topenv(parent.frame()),
          valueClass = NULL, sealed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMethod_+3A_f">f</code></td>
<td>
<p> The character-string name of the generic function. The unquoted name usually works as well (evaluating to the generic function), except for a few functions in the base package.</p>
</td></tr>
<tr><td><code id="setMethod_+3A_signature">signature</code></td>
<td>
<p> The classes required for some of the arguments. Most applications just require one or two character strings matching the first argument(s) in the signature. More complicated cases follow R's rule for argument matching. See the details below; however, if the signature is not trivial, you should use <code><a href="#topic+method.skeleton">method.skeleton</a></code> to generate a valid call to <code>setMethod</code>.</p>
</td></tr>
<tr><td><code id="setMethod_+3A_definition">definition</code></td>
<td>
<p> A function definition, which will become the method
called when the arguments in a call to <code>f</code> match the
classes in <code>signature</code>, directly or through inheritance.
The definition must be a function with the same formal arguments
as the generic; however, <code>setMethod()</code> will handle methods
that add arguments, if <code>...</code> is a formal argument to the generic.
See the Details section.
</p>
</td></tr>
<tr><td><code id="setMethod_+3A_where">where</code>, <code id="setMethod_+3A_valueclass">valueClass</code>, <code id="setMethod_+3A_sealed">sealed</code></td>
<td>
<p><em>These arguments are allowed
but either obsolete or rarely appropriate.</em>
</p>
<p><code>where</code>: where to store the definition; should be the
default, the namespace for the package.
</p>
<p><code>valueClass</code>: obsolete.
</p>
<p><code>sealed</code>: prevents the method being redefined, but should never
be needed when the method is defined in the source code of a
package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function exists for its side-effect. The definition will be stored in a special metadata object and incorporated in the generic function when the corresponding package is loaded into an R session. 
</p>


<h3>Method Selection: Avoiding Ambiguity</h3>

<p>When defining methods, it's important to ensure that methods are
selected correctly; in particular, packages should be designed to
avoid ambiguous method selection.
</p>
<p>To describe method selection, consider first the case where only one
formal argument is in the active signature; that is, there is only one
argument, <code>x</code> say, for which methods have been defined.
The generic function has a table of methods, indexed by the class for
the argument in the calls to <code>setMethod</code>.
If there is a method in the table for the class of <code>x</code> in the
call, this method is selected.
</p>
<p>If not, the next best methods would correspond to the direct
superclasses of <code>class(x)</code>&mdash;those appearing in the
<code>contains=</code> argument when that class was defined.
If there is no method for any of these, the next best would correspond
to the direct superclasses of the first set of superclasses, and so
on.
</p>
<p>The first possible source of ambiguity arises if the class has several
direct superclasses and methods have been defined for more than one of
those;
<span class="rlang"><b>R</b></span> will consider these equally valid and report an ambiguous choice.
If your package has the class definition for <code>class(x)</code>, then you
need to define a method explicitly for this combination of generic
function and class.
</p>
<p>When more than one formal argument appears in the method signature, <span class="rlang"><b>R</b></span>
requires the &ldquo;best&rdquo; method to be chosen  unambiguously for each
argument.
Ambiguities arise when one method is specific about one argument while
another is specific about a different argument.
A call that satisfies both requirements is then ambiguous:  The two
methods look equally valid, which should be chosen?
In such cases the package needs to add a third method requiring both
arguments to match.
</p>
<p>The most common examples arise with binary operators.  Methods may be
defined for individual operators, for special groups of operators such as
<code><a href="#topic+Arith">Arith</a></code> or for group <code><a href="#topic+Ops">Ops</a></code>.
</p>


<h3>Exporting Methods</h3>

<p>If a package defines methods for generic functions, those methods
should be exported if any of the classes involved are exported; in
other words, if someone using the package might expect these methods
to be called.
Methods are exported by including an <code>exportMethods()</code> directive
in the <code>NAMESPACE</code> file for the package, with the arguments to
the directive being the names of the generic functions for which
methods have been defined.
</p>
<p>Exporting methods is always desirable in the sense of declaring what
you want to happen, in that you do expect users to find such methods.
It can be essential in the case that the method was defined for a
function that is not originally a generic function in its own package
(for example, <code>plot()</code> in the <code>graphics</code> package).  In this
case it may be that the version of the function in the <span class="rlang"><b>R</b></span> session is
not generic, and your methods will not be called.
</p>
<p>Exporting methods for a function also exports the generic version of
the function.
Keep in mind that this does <em>not</em> conflict with the function as
it was originally defined in another package; on the contrary, it's
designed to ensure that the function in the <span class="rlang"><b>R</b></span> session dispatches
methods correctly for your classes and continues to behave as expected
when no specific methods apply.  See <a href="#topic+Methods_Details">Methods_Details</a> for the actual mechanism.
</p>


<h3>Details</h3>

<p>The call to <code>setMethod</code> stores the supplied method definition  in
the metadata table for this generic function in the environment,
typically the global environment or the namespace of a package.
In the case of a package, the table object becomes part of the namespace or environment of the
package.
When the package is loaded into a later session, the
methods will be merged into the table of methods in the corresponding
generic function object.
</p>
<p>Generic functions are referenced by the combination of the function name and
the package name;
for example, the function <code>"show"</code> from the package
<code>"methods"</code>.
Metadata for methods is identified by the two strings; in particular, the
generic function object itself has slots containing its name and its
package name.
The package name of a generic is set according to the package
from which it originally comes; in particular, and frequently, the
package where a non-generic version of the function originated.
For example, generic functions for all the functions in package <span class="pkg">base</span> will
have <code>"base"</code> as the package name, although none of them is an
S4 generic on that package.
These include most of the base functions that are primitives, rather than
true functions; see the section on primitive functions in the
documentation for <code><a href="#topic+setGeneric">setGeneric</a></code> for details.
</p>
<p>Multiple packages can have methods for the same generic function; that
is, for the same combination of generic function name and package
name.
Even though the methods are stored in separate tables in separate
environments, loading the corresponding packages adds the methods to
the table in the generic function itself, for the duration of the session.
</p>
<p>The class
names in the signature can be any formal class, including basic
classes such as <code>"numeric"</code>, <code>"character"</code>, and
<code>"matrix"</code>.  Two additional special class names can appear:
<code>"ANY"</code>, meaning that this argument can have any class at all;
and <code>"missing"</code>, meaning that this argument <em>must not</em>
appear in the call in order to match this signature.  Don't confuse
these two:  if an argument isn't mentioned in a signature, it
corresponds implicitly to class <code>"ANY"</code>, not to
<code>"missing"</code>.  See the example below.  Old-style (&lsquo;S3&rsquo;)
classes can also be used, if you need compatibility with these, but
you should definitely declare these classes by calling
<code><a href="#topic+setOldClass">setOldClass</a></code> if you want S3-style inheritance to work.
</p>
<p>Method definitions can
have default expressions for arguments, but only if
the generic function must have <em>some</em> default expression for the
same argument. (This restriction is imposed by the way <span class="rlang"><b>R</b></span> manages
formal arguments.)
If so, and if the corresponding argument is
missing in the call to the generic function, the default expression
in the method is used.  If the method definition has no default for
the argument, then the expression supplied in the definition of the
generic function itself is used, but note that this expression will
be evaluated using the enclosing environment of the method, not of
the generic function.
Method selection does
not evaluate default expressions.
All actual (non-missing) arguments in the signature of the
generic function will be evaluated when a method is selected&mdash;when
the call to <code>standardGeneric(f)</code> occurs.
Note that specifying class <code>"missing"</code> in the signature
does not require any default expressions.
</p>
<p>It is possible to have some differences between the
formal arguments to a method supplied to <code>setMethod</code> and those
of the generic. Roughly, if the generic has ... as one of its
arguments, then the method may have extra formal arguments, which
will be matched from the arguments matching ... in the call to
<code>f</code>.  (What actually happens is that a local function is
created inside the method, with the modified formal arguments, and the method
is re-defined to call that local function.)
</p>
<p>Method dispatch tries to match the class of the actual arguments in a
call to the available methods collected for <code>f</code>.  If there is a
method defined for the exact same classes as in this call, that
method is used.  Otherwise, all possible signatures are considered
corresponding to the actual classes or to superclasses of the actual
classes (including <code>"ANY"</code>).
The method having the least distance from the actual classes is
chosen; if more than one method has minimal distance, one is chosen
(the lexicographically first in terms of superclasses) but a warning
is issued.
All inherited methods chosen are stored in another table, so that
the inheritance calculations only need to be done once per session
per sequence of actual classes.
See
<a href="#topic+Methods_Details">Methods_Details</a> and Section 10.7 of the reference for more details.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><a href="#topic+Methods_for_Nongenerics">Methods_for_Nongenerics</a> discusses method definition for
functions that are not generic functions in their original package;
<a href="#topic+Methods_for_S3">Methods_for_S3</a> discusses the integration of formal methods with the
older S3 methods.
</p>
<p><code><a href="#topic+method.skeleton">method.skeleton</a></code>, which is the recommended way to generate a skeleton of the call to <code>setMethod</code>, with the correct formal arguments and other details.
</p>
<p><a href="#topic+Methods_Details">Methods_Details</a> and the links there for a general discussion, <code><a href="#topic+dotsMethods">dotsMethods</a></code> for methods that dispatch on
&ldquo;...&rdquo;, and <code><a href="#topic+setGeneric">setGeneric</a></code> for generic functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## examples for a simple class with two numeric slots.
## (Run example(setMethod) to see the class and function definitions)


## methods for plotting track objects 
##
## First, with only one object as argument, plot the two slots
##  y must be included in the signature, it would default to "ANY"
setMethod("plot", signature(x="track", y="missing"),
  function(x,  y, ...) plot(x@x, x@y, ...)
)

## plot numeric data on either axis against a track object
## (reducing the track object to the cumulative distance along the track)
## Using a short form for the signature, which matches like formal arguments
setMethod("plot", c("track", "numeric"),
 function(x, y, ...) plot(cumdist(x@x, x@y), y,  xlab = "Distance",...)
)

## and similarly for the other axis
setMethod("plot", c("numeric", "track"),
 function(x, y, ...) plot(x, cumdist(y@x, y@y),  ylab = "Distance",...)
)

t1 &lt;- new("track", x=1:20, y=(1:20)^2)
plot(t1)
plot(qnorm(ppoints(20)), t1)

## Now a class that inherits from "track", with a vector for data at
## the points 
  setClass("trackData", contains = c("numeric", "track"))


tc1 &lt;- new("trackData", t1, rnorm(20))


## a method for plotting the object
## This method has an extra argument, allowed because ... is an
## argument to the generic function.
setMethod("plot", c("trackData", "missing"),
function(x, y, maxRadius = max(par("cin")), ...) {
  plot(x@x, x@y, type = "n", ...)
  symbols(x@x, x@y, circles = abs(x), inches = maxRadius)
  }
)
plot(tc1)

## Without other methods for "trackData", methods for "track"
## will be selected by inheritance

plot(qnorm(ppoints(20)), tc1)

## defining methods for primitive function.
## Although "[" and "length" are not ordinary functions
## methods can be defined for them.
setMethod("[", "track",
  function(x, i, j, ..., drop) {
    x@x &lt;- x@x[i]; x@y &lt;- x@y[i]
    x
  })
plot(t1[1:15])

setMethod("length", "track", function(x)length(x@y))
length(t1)

## Methods for binary operators
## A method for the group generic "Ops" will apply to all operators
## unless a method for a more specific operator has been defined.

## For one trackData argument, go on with just the data part
setMethod("Ops", signature(e1 = "trackData"),
    function(e1, e2) callGeneric(e1@.Data, e2))

setMethod("Ops", signature(e2 = "trackData"),
    function(e1, e2) callGeneric(e1, e2@.Data))

## At this point, the choice of a method for a call with BOTH
## arguments from "trackData" is ambiguous.  We must define a method.

setMethod("Ops", signature(e1 = "trackData", e2 = "trackData"),
    function(e1, e2) callGeneric(e1@.Data, e2@.Data))
## (well, really we should only do this if the "track" part
## of the two arguments matched)

tc1 +1

1/tc1

all(tc1 == tc1)


</code></pre>

<hr>
<h2 id='setOldClass'>Register Old-Style (S3) Classes and Inheritance</h2><span id='topic+setOldClass'></span><span id='topic+.setOldIs'></span><span id='topic+POSIXct-class'></span><span id='topic+POSIXlt-class'></span><span id='topic+POSIXt-class'></span><span id='topic+aov-class'></span><span id='topic+maov-class'></span><span id='topic+anova-class'></span><span id='topic+anova.glm-class'></span><span id='topic+anova.glm.null-class'></span><span id='topic+Date-class'></span><span id='topic+data.frame-class'></span><span id='topic+data.frameRowLabels-class'></span><span id='topic+density-class'></span><span id='topic+dump.frames-class'></span><span id='topic+factor-class'></span><span id='topic+formula-class'></span><span id='topic+glm-class'></span><span id='topic+glm.null-class'></span><span id='topic+hsearch-class'></span><span id='topic+integrate-class'></span><span id='topic+libraryIQR-class'></span><span id='topic+lm-class'></span><span id='topic+logLik-class'></span><span id='topic+mlm-class'></span><span id='topic+mtable-class'></span><span id='topic+mts-class'></span><span id='topic+ordered-class'></span><span id='topic+packageIQR-class'></span><span id='topic+packageInfo-class'></span><span id='topic+recordedplot-class'></span><span id='topic+rle-class'></span><span id='topic+socket-class'></span><span id='topic+summaryDefault-class'></span><span id='topic+summary.table-class'></span><span id='topic+oldClass-class'></span><span id='topic+.OldClassesList'></span><span id='topic+table-class'></span><span id='topic+initialize+2Cdata.frame-method'></span><span id='topic+initialize+2Cfactor-method'></span><span id='topic+initialize+2Cordered-method'></span><span id='topic+initialize+2Ctable-method'></span><span id='topic+initialize+2Csummary.table-method'></span>

<h3>Description</h3>

<p>Register an old-style (a.k.a. &lsquo;S3&rsquo;) class as a formally defined
class. Simple usage will be of the form:
</p>
<p><code>setOldClass(Classes)</code>
</p>
<p>where <code>Classes</code> is the character vector that would be the
<code>class</code> attribute of the S3 object. Calls to
<code>setOldClass()</code> in the code for a package
allow the class to be used as a slot in formal (S4) classes and in
signatures for methods (see <a href="#topic+Methods_for_S3">Methods_for_S3</a>).
Formal classes can also contain a registered S3 class (see
<a href="#topic+S3Part">S3Part</a> for details).
</p>
<p>If the S3 class has a known set of attributes, an
equivalent S4 class can be specified by <code>S4Class=</code> in the call to
<code>setOldClass()</code>; see the section  &ldquo;Known Attributes&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setOldClass(Classes, prototype, where, test = FALSE, S4Class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setOldClass_+3A_classes">Classes</code></td>
<td>

<p>A character vector, giving the names for S3
classes, as they would appear on the right side of an assignment of
the <code>class</code> attribute in S3 computations.
</p>
<p>In addition to S3 classes, an object type or other valid data part
can be specified, if the S3 class is known to require its data to
be of that form.
</p>
</td></tr>
<tr><td><code id="setOldClass_+3A_s4class">S4Class</code></td>
<td>
<p> optionally, the class definition or the class name
of an S4 class.  The new class will have all the slots and other
properties of this class, plus any S3 inheritance implied by
multiple names in the <code>Classes</code> argument.  See the section
on &ldquo;S3 classes with known attributes&rdquo; below.
</p>
</td></tr>
<tr><td><code id="setOldClass_+3A_prototype">prototype</code>, <code id="setOldClass_+3A_where">where</code>, <code id="setOldClass_+3A_test">test</code></td>
<td>
<p><em>These arguments are currently
allowed, but not recommended in typical applications.</em>
</p>
<p><code>prototype</code>:
An optional object to use as the prototype.  If the S3 class is
not to be <code>VIRTUAL</code> (the default), the use of <code>S4Class=</code> is
preferred. 
</p>
<p><code>where</code>:
Where to store the class definitions. Should be the default (the
package namespace) for normal use in an application package.
</p>
<p><code>test</code>: flag, if <code>TRUE</code>, arrange to test inheritance
explicitly for each object, needed if the S3 class can have a
different set of class strings, with the same first string.
Such classes are inherently malformed, are rare, and should be avoided.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name (or each of the names) in <code>Classes</code> will be defined as an S4 class, extending class <code>oldClass</code>,
which is the &lsquo;root&rsquo; of all old-style classes.  S3 classes
with multiple names in their class attribute will have a
corresponding inheritance as formal classes.  See the <code>"mlm"</code> example.
</p>
<p>S3 classes have
no formal definition, and therefore no formally defined slots.
If no S4 class is supplied as a model, the class created will be a
virtual class.
If a virtual class (any virtual class) is used for a slot in another class, then the
initializing method for the class needs to put something legal in
that slot; otherwise it will be set to <code>NULL</code>.
</p>
<p>See <a href="#topic+Methods_for_S3">Methods_for_S3</a> for the details of method dispatch and
inheritance with mixed S3 and S4 methods.
</p>
<p>Some S3 classes cannot be represented as an ordinary combination of S4
classes and superclasses, because objects with the same initial
string in the class attribute can have different strings following.
Such  classes are fortunately rare.  They violate the basic idea of
object-oriented programming and should be avoided.  
If you must deal with them, it is still possible to register
such classes as S4 classes, but now the inheritance has to be verified
for each object, and you must call <code>setOldClass</code> with argument
<code>test=TRUE</code>.
</p>


<h3>Pre-Defined Old Classes</h3>

<p>Many of the widely used S3 classes in the standard R distribution
come pre-defined for use with S4.  These don't need to be explicitly
declared in your package (although it does no harm to do so).
</p>
<p>The list <code>.OldClassesList</code> contains the old-style classes that
are defined by the methods package.  Each element of the list is a
character vector, with multiple strings if inheritance is included.
Each element of the list was passed to <code>setOldClass</code> when
creating the <span class="pkg">methods</span> package; therefore, these classes can be used
in <code><a href="#topic+setMethod">setMethod</a></code> calls, with the inheritance as implied by
the list.
</p>


<h3>S3 Classes with known attributes</h3>

<p>A further specification of an S3 class can be made <em>if</em> the
class is guaranteed to have some attributes of known class (where as
with slots, &ldquo;known&rdquo; means that the attribute is an object of
a specified class, or a subclass of that class).
</p>
<p>In this case, the call to <code>setOldClass()</code> can supply an S4 class
definition representing the known structure.  Since S4 slots are
implemented as attributes (largely for just this reason), the known
attributes can be specified in the representation of the S4 class.
The usual technique will be to create an S4 class with the desired
structure, and then supply the class name or definition as the
argument <code>S4Class=</code> to <code>setOldClass()</code>.
</p>
<p>See the definition of class <code>"ts"</code> in the examples below and
the <code>data.frame</code> example in Section 10.2 of the reference.
The call to <code><a href="#topic+setClass">setClass</a></code> to create the S4 class can use the same
class name, as here, so long as the call to <code>setOldClass</code>
follows in the same package.  For clarity it should be the next
expression in the same file.
</p>
<p>In the example, we define <code>"ts"</code> as a vector structure with a
numeric slot for <code>"tsp"</code>.  The validity of this definition relies
on an assertion that all the S3 code for this class is consistent with
that definition; specifically, that all <code>"ts"</code> objects will
behave as vector structures and will have a numeric <code>"tsp"</code>
attribute. We believe this to be true of all the base code in <span class="rlang"><b>R</b></span>, but
as always with S3 classes, no guarantee is possible.
</p>
<p>The S4 class definition can  have virtual superclasses (as in
the <code>"ts"</code> case) if the S3 class is asserted to behave
consistently with these (in the example, time-series objects are
asserted to be consistent with the <a href="#topic+structure-class">structure</a> class).
</p>
<p>Failures of the S3 class to live up to its asserted
behavior will usually go uncorrected, since S3 classes inherently
have no definition, and the resulting invalid S4 objects can cause
all sorts of grief.  Many S3 classes are not candidates for known
slots, either because the presence or class of the attributes are
not guaranteed  (e.g., <code>dimnames</code> in arrays, although these are
not even S3 classes), or because the class uses named components of
a list rather than attributes (e.g., <code>"lm"</code>).  An attribute
that is sometimes missing cannot be represented as a slot, not even
by pretending that it is present with class <code>"NULL"</code>, because
attributes, unlike slots, can not have value <code>NULL</code>.
</p>
<p>One irregularity that is usually tolerated, however, is to optionally
add other attributes to those guaranteed to exist (for example,
<code>"terms"</code> in <code>"data.frame"</code> objects returned by
<code><a href="stats.html#topic+model.frame">model.frame</a></code>).  Validity checks by
<code><a href="#topic+validObject">validObject</a></code> ignore extra attributes; even if this check
is tightened in the future, classes extending S3 classes would likely
be exempted because extra attributes are so common.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10, particularly Section 10.8)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setClass">setClass</a></code>, <code><a href="#topic+setMethod">setMethod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(stats)

## "lm" and "mlm" are predefined; if they were not this would do it:
## Not run: 
setOldClass(c("mlm", "lm"))
## End(Not run)

## Define a new generic function to compute the residual degrees of freedom
setGeneric("dfResidual",
  function(model) stop(gettextf(
    "This function only works for fitted model objects, not class %s",
                                class(model))))

setMethod("dfResidual", "lm", function(model)model$df.residual)

## dfResidual will work on mlm objects as well as lm objects
myData &lt;- data.frame(time = 1:10, y = (1:10)^.5)
myLm &lt;- lm(cbind(y, y^3)  ~ time, myData)



## two examples extending S3 class "lm": class "xlm" directly
## and "ylm" indirectly
setClass("xlm", slots = c(eps = "numeric"), contains = "lm")
setClass("ylm", slots = c(header = "character"), contains = "xlm")
ym1 = new("ylm", myLm, header = "Example", eps = 0.)
## for more examples, see ?\link{S3Class}.




## Not run: 
## The code in R that defines "ts" as an S4 class
setClass("ts", contains = "structure", slots = c(tsp = "numeric"),
         prototype(NA, tsp = rep(1,3)))
       # prototype to be a legal S3 time-series
## and now registers it as an S3 class
setOldClass("ts", S4Class = "ts", where = envir)

## End(Not run)

</code></pre>

<hr>
<h2 id='show'>Show an Object</h2><span id='topic+show'></span><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Ctraceable-method'></span><span id='topic+show+2CObjectsWithPackage-method'></span><span id='topic+show+2CMethodDefinition-method'></span><span id='topic+show+2CMethodWithNext-method'></span><span id='topic+show+2CgenericFunction-method'></span><span id='topic+show+2CclassRepresentation-method'></span>

<h3>Description</h3>

<p>Display the object, by printing, plotting or whatever suits its
class.  This function exists to be specialized by methods.  The
default method calls <code><a href="#topic+showDefault">showDefault</a></code>.
</p>
<p>Formal methods for <code>show</code> will
usually be invoked for automatic printing (see the details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects from an S4 class (a class defined by a call to
<code><a href="#topic+setClass">setClass</a></code>) will be displayed automatically is if by a
call to <code>show</code>.  S4 objects that occur as attributes of S3
objects will also be displayed in this form; conversely, S3 objects
encountered as slots in S4 objects will be printed using the S3
convention, as if by a call to <code><a href="base.html#topic+print">print</a></code>.
</p>
<p>Methods defined for <code>show</code> will only be inherited  by simple
inheritance, since otherwise the method would not receive the
complete, original object, with misleading results.  See the
<code>simpleInheritanceOnly</code> argument to <code><a href="#topic+setGeneric">setGeneric</a></code> and
the discussion in <code><a href="#topic+setIs">setIs</a></code> for the general concept.
</p>


<h3>Value</h3>

<p><code>show</code> returns an invisible <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showMethods">showMethods</a></code> prints all the methods for one or more
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## following the example shown in the setMethod documentation ...
setClass("track", slots = c(x="numeric", y="numeric"))
setClass("trackCurve", contains = "track", slots = c(smooth = "numeric"))

t1 &lt;- new("track", x=1:20, y=(1:20)^2)

tc1 &lt;- new("trackCurve", t1)

setMethod("show", "track",
  function(object)print(rbind(x = object@x, y=object@y))
)
## The method will now be used for automatic printing of t1

t1

## Not run:   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    2    3    4    5    6    7    8    9    10    11    12
y    1    4    9   16   25   36   49   64   81   100   121   144
  [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
x    13    14    15    16    17    18    19    20
y   169   196   225   256   289   324   361   400

## End(Not run)
## and also for tc1, an object of a class that extends "track"
tc1

## Not run:   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    2    3    4    5    6    7    8    9    10    11    12
y    1    4    9   16   25   36   49   64   81   100   121   144
  [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
x    13    14    15    16    17    18    19    20
y   169   196   225   256   289   324   361   400

## End(Not run)
</code></pre>

<hr>
<h2 id='showMethods'>Show all the methods for the specified function(s) or class</h2><span id='topic+showMethods'></span><span id='topic+.S4methods'></span>

<h3>Description</h3>

<p>Show a summary of the methods for one or more generic functions,
possibly restricted to those involving specified classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showMethods(f = character(), where = topenv(parent.frame()),
            classes = NULL, includeDefs = FALSE,
            inherited = !includeDefs,
            showEmpty, printTo = stdout(), fdef)
.S4methods(generic.function, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showMethods_+3A_f">f</code></td>
<td>
<p>one or more function names.  If omitted, all functions
will be shown that match the other arguments.
</p>
<p>The argument can also be an expression that evaluates to a single
generic function, in which
case argument <code>fdef</code> is ignored.  Providing an expression for
the function allows examination of hidden or anonymous functions;
see the example for <code>isDiagonal()</code>.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_where">where</code></td>
<td>
<p>Where to find the generic function, if not supplied as an
argument. When <code>f</code> is missing, or length 0, this also
determines which generic functions to examine.  If <code>where</code> is
supplied, only the generic functions returned by
<code>getGenerics(where)</code> are eligible for printing.  If
<code>where</code> is also missing, all the cached generic functions are
considered.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_classes">classes</code></td>
<td>
<p>If argument <code>classes</code> is supplied, it is a vector
of class names that restricts the displayed results to those methods
whose signatures include one or more of those classes.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_includedefs">includeDefs</code></td>
<td>
<p>If <code>includeDefs</code> is <code>TRUE</code>, include the
definitions of the individual methods in the printout.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_inherited">inherited</code></td>
<td>
<p>logical indicating if methods that have been found by
inheritance, so far in the session, will be included and marked as
inherited.  Note that an inherited method will not usually appear
until it has been used in this session.  See
<code><a href="#topic+selectMethod">selectMethod</a></code> if you want to know what method would be
dispatched for particular classes of arguments.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_showempty">showEmpty</code></td>
<td>
<p>logical indicating whether methods with no defined
methods matching the other criteria should be shown at all.  By
default, <code>TRUE</code> if and only if argument <code>f</code> is not
missing.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_printto">printTo</code></td>
<td>
<p>The connection on which the information will be
shown; by default, on standard output.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_fdef">fdef</code></td>
<td>
<p>Optionally, the generic function definition to use; if
missing, one is found, looking in <code>where</code> if that is specified.
See also comment in &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="showMethods_+3A_generic.function">generic.function</code>, <code id="showMethods_+3A_class">class</code></td>
<td>
<p>See <code>methods</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>methods</code> for a description of <code>.S4methods</code>.
</p>
<p>The name and package of the generic are followed by the list of
signatures for which methods are currently defined, according to the
criteria determined by the various arguments.  Note that the package
refers to the source of the generic function.  Individual methods
for that generic can come from other packages as well.
</p>
<p>When more than one generic function is involved, either as specified or
because <code>f</code> was missing, the functions are found and
<code>showMethods</code> is recalled for each, including the generic as the
argument <code>fdef</code>.  In complicated situations, this can avoid some
anomalous results.
</p>


<h3>Value</h3>

<p>If <code>printTo</code> is <code>FALSE</code>, the character vector that would
have been printed is returned; otherwise the value is the connection
or filename, via <code><a href="base.html#topic+invisible">invisible</a></code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setMethod">setMethod</a></code>, and <code><a href="#topic+GenericFunctions">GenericFunctions</a></code>
for other tools involving methods;
<code><a href="#topic+selectMethod">selectMethod</a></code> will show you the method dispatched for a
particular function and signature of classes for the arguments.
</p>
<p><code><a href="utils.html#topic+methods">methods</a></code> provides method discovery tools for light-weight
interactive use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

## Assuming the methods for plot
## are set up as in the example of help(setMethod),
## print (without definitions) the methods that involve class "track":
showMethods("plot", classes = "track")
## Not run: 
# Function "plot":
# x = ANY, y = track
# x = track, y = missing
# x = track, y = ANY

require("Matrix")
showMethods("%*%")# many!
    methods(class = "Matrix")# nothing
showMethods(class = "Matrix")# everything
showMethods(Matrix:::isDiagonal) # a non-exported generic

## End(Not run)



if(no4 &lt;- is.na(match("stats4", loadedNamespaces())))
   loadNamespace("stats4")
showMethods(classes = "mle") # -&gt; a method for show()
if(no4) unloadNamespace("stats4")
</code></pre>

<hr>
<h2 id='signature-class'>Class <code>"signature"</code> For Method Definitions</h2><span id='topic+signature-class'></span><span id='topic+show+2Csignature-method'></span>

<h3>Description</h3>

<p>This class represents the mapping of some of the formal
arguments of a function onto the corresponding classes.  It is used for
two slots in the <code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("signature",
    functionDef, ...)</code>.  The <code>functionDef</code> argument, if it is
supplied as a function object, defines the formal names.  The other
arguments define the classes.  More typically, the objects are
created as side effects of defining methods.  Either way, note that
the classes are expected to be well defined, usually because the
corresponding class definitions exist.  See the comment on the
<code>package</code> slot.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"character"</code> the class names. </p>
</dd>
<dt><code>names</code>:</dt><dd><p>Object of class <code>"character"</code> the
corresponding argument names. </p>
</dd>
<dt><code>package</code>:</dt><dd><p>Object of class <code>"character"</code> the
names of the packages corresponding to the class names. The
combination of class name and package uniquely defines the
class.  In principle, the same class name could appear in more
than one package, in which case the <code>package</code> information
is required for the signature to be well defined.</p>
</dd>  </dl>



<h3>Extends</h3>

<p>Class <code>"character"</code>, from data part.
Class <code>"vector"</code>, by class &quot;character&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(object = "signature")</code>: see the
discussion of objects from the class, above. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>class <code><a href="#topic+MethodDefinition-class">MethodDefinition</a></code> for the use of this class.
</p>

<hr>
<h2 id='slot'>The Slots in an Object from a Formal Class</h2><span id='topic+slot'></span><span id='topic+.hasSlot'></span><span id='topic+slot+3C-'></span><span id='topic+slotNames'></span><span id='topic+.slotNames'></span><span id='topic+getSlots'></span>

<h3>Description</h3>

<p>These functions return or set information about the individual slots
in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object@name
object@name &lt;- value

slot(object, name)
slot(object, name, check = TRUE) &lt;- value
.hasSlot(object, name)

slotNames(x)
.slotNames(x)
getSlots(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slot_+3A_object">object</code></td>
<td>
<p>An object from a formally defined class.</p>
</td></tr>
<tr><td><code id="slot_+3A_name">name</code></td>
<td>
<p>The name of the slot. The operator
takes a fixed name, which can be unquoted if it is syntactically a
name in the language.  A slot name can be any non-empty string, but
if the name is not made up of letters, numbers, and <code>.</code>, it
needs to be quoted (by backticks or single or double quotes).
</p>
<p>In the case of the <code>slot</code> function, <code>name</code> can be any
expression that evaluates to a valid slot in the class definition.
Generally, the only reason to use the functional form rather than
the simpler operator is <em>because</em> the slot name has to be computed.
</p>
</td></tr>
<tr><td><code id="slot_+3A_value">value</code></td>
<td>
<p>A new value for the named slot.  The value must be
valid for this slot in this object's class.</p>
</td></tr>
<tr><td><code id="slot_+3A_check">check</code></td>
<td>
<p>In the replacement version of <code>slot</code>, a flag.  If
<code>TRUE</code>, check the assigned value for validity
as the value of this slot.  User's code should not set this to
<code>FALSE</code> in normal use, since the resulting object can be invalid.
</p>
</td></tr>
<tr><td><code id="slot_+3A_x">x</code></td>
<td>
<p>either the name of a class (as character string), or a class
definition.  If given an argument that is neither a character string
nor a class definition, <code>slotNames</code> (only) uses <code>class(x)</code>
instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the class specifies all slots directly and
indirectly defined for that class.  Each slot has a name and an
associated class.  Extracting a slot returns an object from that
class.  Setting a slot first coerces the value to the specified slot
and then stores it.
</p>
<p>Unlike general attributes, slots are not partially matched, and asking
for (or trying to set) a slot with an invalid name for that class
generates an error.
</p>
<p>The <code><a href="base.html#topic++40">@</a></code> extraction operator and <code>slot</code>
function themselves do no checking against the class definition,
simply matching the name in the object itself.
The replacement forms do check (except for <code>slot</code> in the case
<code>check=FALSE</code>).  So long as slots are set without cheating, the
extracted slots will be valid.
</p>
<p>Be aware that there are two ways to cheat, both to be avoided but
with no guarantees.  The obvious way is to assign a slot with
<code>check=FALSE</code>.  Also, slots in <span class="rlang"><b>R</b></span> are implemented as
attributes, for the sake of some back compatibility.  The current
implementation does not prevent attributes being assigned, via
<code><a href="base.html#topic+attr+3C-">attr&lt;-</a></code>, and such assignments are not checked for
legitimate slot names.
</p>
<p>Note that the <code>"@"</code> operators for extraction and replacement are
primitive and actually reside in the <span class="pkg">base</span> package.
</p>
<p>The replacement versions of  <code>"@"</code> and <code>slot()</code> differ in
the computations done to coerce the right side of the assignment to
the declared class of the slot.  Both verify that the value provided
is from a subclass of the declared slot class.  The  <code>slot()</code>
version will go on to call the coerce method if there is one, in
effect doing the computation <code>as(value, slotClass, strict =
    FALSE)</code>. The  <code>"@"</code> version just verifies the relation,
leaving any coerce to be done later (e.g., when a relevant method is
dispatched).
</p>
<p>In most uses the result is equivalent, and the  <code>"@"</code> version
saves an extra function call, but if empirical evidence shows that a
conversion is needed, either call <code>as()</code> before the replacement
or use the replacement version of <code>slot()</code>.
</p>


<h3>Value</h3>

<p>The <code>"@"</code> operator and the <code>slot</code> function extract or
replace the formally defined slots for the object.
</p>
<p>Functions <code>slotNames</code> and <code>getSlots</code> return respectively the
names of the slots and the classes associated with the slots in the
specified class definition.  Except for its extended interpretation of
<code>x</code> (above), <code>slotNames(x)</code> is just <code>names(getSlots(x))</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++40">@</a></code>,
<code><a href="#topic+Classes_Details">Classes_Details</a></code>,
<code><a href="#topic+Methods_Details">Methods_Details</a></code>,
<code><a href="#topic+getClass">getClass</a></code>,
<code><a href="base.html#topic+names">names</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

setClass("track", slots = c(x="numeric", y="numeric"))
myTrack &lt;- new("track", x = -4:4, y = exp(-4:4))
slot(myTrack, "x")
slot(myTrack, "y") &lt;- log(slot(myTrack, "y"))
utils::str(myTrack)

getSlots("track") # or
getSlots(getClass("track"))
slotNames(class(myTrack)) # is the same as
slotNames(myTrack)

## Transform such an S4 object to a list, e.g. to "export" it:
S4toList &lt;- function(obj) {
   sn &lt;- slotNames(obj)
   structure(lapply(sn, slot, object = obj), names = sn)
}
S4toList(myTrack)


</code></pre>

<hr>
<h2 id='StructureClasses'>Classes Corresponding to Basic Structures</h2><span id='topic+structure-class'></span><span id='topic+matrix-class'></span><span id='topic+array-class'></span><span id='topic+ts-class'></span><span id='topic+Math+2Cstructure-method'></span><span id='topic+Ops+2Cstructure+2Cvector-method'></span><span id='topic+Ops+2Cstructure+2Cstructure-method'></span><span id='topic+Ops+2Cstructure+2Carray-method'></span><span id='topic+Ops+2Cvector+2Cstructure-method'></span><span id='topic+Ops+2Carray+2Cstructure-method'></span><span id='topic+Ops+2Carray+2Carray-method'></span><span id='topic+initialize+2Carray-method'></span><span id='topic+initialize+2Cmatrix-method'></span><span id='topic+initialize+2Cts-method'></span><span id='topic+initialize+2Cmts-method'></span><span id='topic+show+2Cts-method'></span>

<h3>Description</h3>

<p>The virtual class <code>structure</code> and classes that
extend it are formal classes analogous to S language structures such
as arrays and time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## The following class names can appear in method signatures,
## as the class in as() and is() expressions, and, except for
## the classes commented as VIRTUAL, in calls to new()

"matrix"
"array"
"ts"

"structure" ## VIRTUAL
</code></pre>


<h3>Objects from the Classes</h3>

<p>Objects can be created by calls of the form <code>new(Class, ...)</code>,
where <code>Class</code> is the quoted name of the specific class (e.g.,
<code>"matrix"</code>), and the other arguments, if any, are interpreted as
arguments to the corresponding function, e.g., to function
<code>matrix()</code>.  There is no particular advantage over calling those
functions directly, unless you are writing software designed to work
for multiple classes, perhaps with the class name and the arguments
passed in.
</p>
<p>Objects created from the classes <code>"matrix"</code> and <code>"array"</code>
are unusual, to put it mildly, and have been for some time.  Although
they may appear to be objects from these classes, they do not have the
internal structure of either an S3 or S4 class object.  In particular,
they have no <code>"class"</code> attribute and are not recognized as
objects with classes (that is, both <code><a href="base.html#topic+is.object">is.object</a></code> and
<code><a href="base.html#topic+isS4">isS4</a></code> will return <code>FALSE</code> for such objects).
However, methods (both S4 and S3) can be defined for these
pseudo-classes and new classes (both S4 and S3) can inherit from them.
</p>
<p>That the objects still behave as if they came from the corresponding
class (most of the time, anyway) results from special code
recognizing such objects being built into the base code of <span class="rlang"><b>R</b></span>.
For most purposes, treating the classes in the usual way will work,
fortunately.  One consequence of the special treatment is that these
two classes<em>may</em> be used as the data part of an S4 class; for
example, you can get away with <code>contains = "matrix"</code> in a call
to <code><a href="#topic+setGeneric">setGeneric</a></code> to create an S4 class that is a subclass
of <code>"matrix"</code>.  There is no guarantee that everything will work
perfectly, but a number of classes have been written in this form
successfully.
</p>
<p>Note that a class containing <code>"matrix"</code> or <code>"array"</code> will
have a  <code>.Data</code> slot with that class.  This is the only use of
<code>.Data</code> other than as a pseudo-class indicating the type of the
object.  In this case the type of the object will be the type of the
contained matrix or array. See <code><a href="#topic+Classes_Details">Classes_Details</a></code> for a general
discussion.
</p>
<p>The class <code>"ts"</code>  is basically an S3 class
that has been registered with S4, using the
<code><a href="#topic+setOldClass">setOldClass</a></code> mechanism.  Versions of <span class="rlang"><b>R</b></span> through 2.7.0
treated this class as a pure S4 class, which was in principal a good
idea, but in practice did not allow subclasses to be defined and had
other intrinsic problems.  (For example, setting the
<code>"tsp"</code> parameters as a slot often fails because the built-in
implementation does not allow the slot to be temporarily
inconsistent with the length of the data. Also, the S4 class
prevented the correct specification of the S3 inheritance for class
<code>"mts"</code>.)
</p>
<p>Time-series objects, in contrast to matrices and arrays, have a valid
S3 class, <code>"ts"</code>, registered  using an S4-style definition (see the
documentation for <code><a href="#topic+setOldClass">setOldClass</a></code> in the examples section
for an abbreviated listing of how this is done).  The S3
inheritance of <code>"mts"</code> in package <span class="pkg">stats</span> is also
registered.
These classes, as well as <code>"matrix"</code> and <code>"array"</code> should
be valid in most examples as superclasses for new S4 class
definitions.
</p>
<p>All of these classes have special S4 methods for
<code><a href="#topic+initialize">initialize</a></code> that accept the same arguments as the basic
generator functions, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="base.html#topic+array">array</a></code>, and <code><a href="stats.html#topic+ts">ts</a></code>, in so far as possible.
The limitation is that a class that has more than one non-virtual
superclass must accept objects from that superclass in the call to
<code><a href="#topic+new">new</a></code>; therefore, a such a class (what is called a
&ldquo;mixin&rdquo; in some languages) uses the default method for
<code><a href="#topic+initialize">initialize</a></code>, with no special arguments.
</p>


<h3>Extends</h3>

<p>The specific classes all extend class <code>"structure"</code>, directly, and
class <code>"vector"</code>, by class <code>"structure"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p>Methods are defined to coerce arbitrary objects to
these classes, by calling the corresponding basic function, for
example, <code>as(x, "matrix")</code> calls <code>as.matrix(x)</code>.
If <code>strict = TRUE</code> in the call to <code>as()</code>, the method
goes on to delete all other slots and attributes other than the
<code>dim</code> and <code>dimnames</code>.
</p>
</dd>
<dt>Ops</dt><dd><p>Group methods (see, e.g., <code><a href="#topic+S4groupGeneric">S4groupGeneric</a></code>)
are defined for combinations of structures and vectors (including
special cases for array and matrix), implementing the concept of
vector structures as in the reference.  Essentially, structures
combined with vectors retain the structure as long as the
resulting object has the same length.  Structures combined with
other structures remove the structure, since there is no
automatic way to determine what should happen to the slots
defining the structure.
</p>
<p>Note that these methods will be activated when a package is loaded
containing a class that inherits from any of the structure
classes or class <code>"vector"</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (For the R version.)
</p>
<p>Chambers, John M. (1998)
<em>Programming with Data</em>
Springer (For the original S4 version.)
</p>
<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole (for the original vector structures).
</p>


<h3>See Also</h3>

<p>Class <a href="#topic+nonStructure-class">nonStructure</a>, which enforces the
alternative model, in which all slots are dropped if any math
transformation or operation is applied to an object from a class
extending one of the basic classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("structure")

## explore a bit :
showClass("ts")
(ts0 &lt;- new("ts"))
str(ts0)

showMethods("Ops") # six methods from these classes, but maybe many more
</code></pre>

<hr>
<h2 id='substituteDirect'><code>SubstituteDirect</code></h2><span id='topic+substituteDirect'></span>

<h3>Description</h3>

<p>Substitute for the variables named in the second argument the
corresponding objects, substituting into <code>object</code>.  The argument
<code>frame</code> is a named list; if omitted, the environment of the
caller is used.
</p>
<p>This function differs from the ordinary <code>substitute</code> in that it
treats its first argument in the standard S way, by evaluating it.  In
contrast, <code>substitute</code> does not evaluate its first argument.
</p>
<p>The goal is to replace this with an <code>eval=</code> argument to
<code><a href="base.html#topic+substitute">substitute</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substituteDirect(object, frame, cleanFunction=TRUE)
</code></pre>

<hr>
<h2 id='testInheritedMethods'>
Test for and Report about  Selection of Inherited Methods
</h2><span id='topic+testInheritedMethods'></span><span id='topic+MethodSelectionReport-class'></span><span id='topic+.Other-class'></span>

<h3>Description</h3>

<p>A set of distinct inherited signatures is generated to test
inheritance for all the methods of a specified generic function.  If
method selection is ambiguous for some of these, a summary of the
ambiguities is attached to the returned object.  This test should be
performed by package authors <em>before</em> releasing a package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testInheritedMethods(f, signatures, test = TRUE, virtual = FALSE,
                     groupMethods = TRUE, where = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testInheritedMethods_+3A_f">f</code></td>
<td>
<p>a generic function or the character string name of one.  By default,
all currently defined subclasses of all the method signatures for this
generic will be examined.  The other arguments are mainly options to
modify which inheritance patterns will be examined.
</p>
</td></tr>
<tr><td><code id="testInheritedMethods_+3A_signatures">signatures</code></td>
<td>

<p>An optional set of subclass signatures to use instead of the relevant
subclasses computed by <code>testInheritedMethods</code>.  See the Details
for how this is done.  This argument might be supplied after a call
with <code>test = FALSE</code>, to test selection in batches.
</p>
</td></tr>
<tr><td><code id="testInheritedMethods_+3A_test">test</code></td>
<td>

<p>optional flag to control whether method selection is actually tested.
If <code>FALSE</code>, returns just the list of relevant signatures for
subclasses, without calling <code><a href="#topic+selectMethod">selectMethod</a></code> for each signature.
If there are a very large number of signatures, you may want to collect the full list  and then test them in batches.
</p>
</td></tr>
<tr><td><code id="testInheritedMethods_+3A_virtual">virtual</code></td>
<td>

<p>should virtual classes be included in the relevant subclasses.
Normally not, since only the classes of actual arguments will trigger
the inheritance calculation in a call to the generic function.
Including virtual classes may be useful if the class has no current
non-virtual subclasses but you anticipate your users may define such
classes in the future.
</p>
</td></tr>
<tr><td><code id="testInheritedMethods_+3A_groupmethods">groupMethods</code></td>
<td>

<p>should methods for the group generic function be included?
</p>
</td></tr>
<tr><td><code id="testInheritedMethods_+3A_where">where</code></td>
<td>

<p>the environment in which to look for class definitions.  Nearly
always, use the default global environment after attaching all the
packages with relevant methods and/or class definitions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following description applies when the optional arguments are
omitted, the usual case.
First, the defining signatures for all methods are computed by calls
to <code><a href="#topic+findMethodSignatures">findMethodSignatures</a></code>.
From these all the known non-virtual subclasses are found for each
class that appears in the signature of some method.
These subclasses are split into groups according to which class they
inherit from, and only one subclass from each group is retained (for
each argument in the generic signature).
So if a method was defined with class <code>"vector"</code> for some
argument, one actual vector class is chosen arbitrarily.
The case of <code>"ANY"</code> is dealt with specially, since all classes
extend it.  A dummy, nonvirtual class, <code>".Other"</code>, is used to
correspond to all classes that have no superclasses among those being
tested.
</p>
<p>All combinations of retained subclasses for the
arguments in the generic signature are then computed.
Each row of the resulting matrix is a signature to be tested by a call
to <code><a href="#topic+selectMethod">selectMethod</a></code>.
To collect information on ambiguous selections,
<code>testInheritedMethods</code> establishes a calling handler for the
special signal <code>"ambiguousMethodSelection"</code>, by setting the
corresponding option.
</p>


<h3>Value</h3>

<p>An object of class <code>"methodSelectionReport"</code>.  The details of
this class are currently subject to change.  It has slots
<code>"target"</code>, <code>"selected"</code>, <code>"candidates"</code>, and
<code>"note"</code>, all referring to the ambiguous cases (and so of length
0 if there were none).  These slots are intended to be examined by the
programmer to detect and preferably fix ambiguous method selections.
The object contains in addition slots <code>"generic"</code>, the name of
the generic function, and
<code>"allSelections"</code>,  giving the vector of labels for all
the signatures tested.
</p>


<h3>References</h3>

<p>Chambers, John M. (2008)
<em>Software for Data Analysis: Programming with R</em>
Springer.  (Section 10.6 for basics of method selection.)
</p>
<p>Chambers, John M. (2009)
<em>Class Inheritance in R</em>
<a href="https://johnmchambers.su.domains/classInheritance.pdf">https://johnmchambers.su.domains/classInheritance.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## if no other attached packages have methods for `+` or its group
## generic functions, this returns a 16 by 2 matrix of selection
## patterns (in R 2.9.0)
testInheritedMethods("+")
</code></pre>

<hr>
<h2 id='TraceClasses'>Classes Used Internally to Control Tracing </h2><span id='topic+traceable-class'></span><span id='topic+functionWithTrace-class'></span><span id='topic+MethodDefinitionWithTrace-class'></span><span id='topic+MethodWithNextWithTrace-class'></span><span id='topic+genericFunctionWithTrace-class'></span><span id='topic+groupGenericFunctionWithTrace-class'></span><span id='topic+derivedDefaultMethodWithTrace-class'></span><span id='topic+nonstandardGenericWithTrace-class'></span><span id='topic+show+2CMethodDefinitionWithTrace-method'></span><span id='topic+show+2CMethodWithNextWithTrace-method'></span><span id='topic+show+2CgenericFunctionWithTrace-method'></span><span id='topic+show+2CsourceEnvironment-method'></span><span id='topic+.untracedFunction'></span><span id='topic+.makeTracedFunction'></span><span id='topic+.doTracePrint'></span><span id='topic+.InitTraceFunctions'></span>

<h3>Description</h3>

<p> The classes described  here are used by the R function
<code><a href="base.html#topic+trace">trace</a></code> to create versions of functions and methods
including browser calls, etc., and also to <code><a href="base.html#topic+untrace">untrace</a></code> the
same objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>### Objects from the following classes are generated
### by calling trace() on an object from the corresponding
### class without the "WithTrace" in the name.

"functionWithTrace"
"MethodDefinitionWithTrace"
"MethodWithNextWithTrace"
"genericFunctionWithTrace"
"groupGenericFunctionWithTrace"

### the following is a virtual class extended by each of the
### classes above

"traceable"
</code></pre>


<h3>Objects from the Class</h3>

<p>Objects will be created from these classes by calls to <code>trace</code>.
(There is an <code><a href="#topic+initialize">initialize</a></code> method for class
<code>"traceable"</code>, but you are unlikely to need it directly.)
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>The data part, which will be <code>"function"</code>
for class <code>"functionWithTrace"</code>, and similarly for the other
classes.</p>
</dd>
<dt><code>original</code>:</dt><dd><p>Object of the original class; e.g.,
<code>"function"</code> for class <code>"functionWithTrace"</code>. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Each of the classes extends the corresponding untraced class, from the
data part; e.g., <code>"functionWithTrace"</code> extends <code>"function"</code>.
Each of the specific classes extends <code>"traceable"</code>, directly,
and class <code>"VIRTUAL"</code>, by class <code>"traceable"</code>.
</p>


<h3>Methods</h3>

<p>The point of the specific classes is that objects generated from them,
by function <code>trace()</code>, remain callable or dispatchable, in
addition to their new trace information.
</p>


<h3>See Also</h3>

<p> function <code><a href="base.html#topic+trace">trace</a></code> </p>

<hr>
<h2 id='validObject'> Test the Validity of an Object </h2><span id='topic+validObject'></span><span id='topic+getValidity'></span><span id='topic+setValidity'></span>

<h3>Description</h3>

<p><code>validObject()</code> tests the validity of <code>object</code> related to
its class definition; specifically, it checks that all slots
specified in the class definition are present and that the object in
the slot is from the required class or a subclass of that class.
</p>
<p>If the object is valid, <code>TRUE</code> is returned; otherwise, an error
is generated, reporting all the validity failures encountered.
If argument <code>test</code> is
<code>TRUE</code>, the errors are returned as a character vector rather
than generating an error.
</p>
<p>When an object from a class is initialized, the default method for
<code><a href="#topic+initialize">initialize</a>()</code> calls <code>validObject</code>.
</p>
<p>A class definition may have a validity method, set by a call to
the function <code>setValidity</code>, in the package or environment that
defines the class (or via the <code>validity</code> argument to <code><a href="#topic+setClass">setClass</a></code>).  The method
should be a function of one object that returns <code>TRUE</code> or a character-string
description of the non-validity.
If such a method exists, it will be called from <code>validObject</code>
and any strings from failure will be included in the result or the
error message.
Any validity methods defined for superclasses (from the <code>contains=</code>
argument to <code><a href="#topic+setClass">setClass</a></code>), will also be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validObject(object, test = FALSE, complete = FALSE)

setValidity(Class, method, where = topenv(parent.frame()) )

getValidity(ClassDef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validObject_+3A_object">object</code></td>
<td>
<p> any object, but not much will happen unless the
object's class has a formal definition.</p>
</td></tr>
<tr><td><code id="validObject_+3A_test">test</code></td>
<td>
<p>logical; if <code>TRUE</code> and validity fails, the
function returns a vector of strings describing the problems.  If
<code>test</code> is <code>FALSE</code> (the default) validity failure generates
an error.</p>
</td></tr>
<tr><td><code id="validObject_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>validObject</code> is
called recursively for each of the slots.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="validObject_+3A_class">Class</code></td>
<td>
<p>the name or class definition of the class whose validity
method is to be set.</p>
</td></tr>
<tr><td><code id="validObject_+3A_classdef">ClassDef</code></td>
<td>
<p>a class definition object, as from
<code><a href="#topic+getClassDef">getClassDef</a></code>.</p>
</td></tr>
<tr><td><code id="validObject_+3A_method">method</code></td>
<td>
<p>a validity method;  that is, either <code>NULL</code> or a
function of one argument (<code>object</code>).  Like
<code>validObject</code>, the function should return <code>TRUE</code> if the
object is valid, and one or more descriptive strings if any problems
are found.  Unlike <code>validObject</code>, it should never generate an
error.
</p>
</td></tr>
<tr><td><code id="validObject_+3A_where">where</code></td>
<td>
<p>an environment to store the modified class
definition. Should be omitted, specifically  for calls from a package that defines the class.
The definition will be stored in the
namespace of the package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Validity testing takes place &lsquo;bottom up&rsquo;, checking the slots,
then the superclasses, then the object's own validity method, if
there is one.
</p>
<p>For each slot and superclass, the existence of the specified class is
checked.
For each slot, the object in the slot is tested for inheritance from
the corresponding class.
If  <code>complete</code> is <code>TRUE</code>,   <code>validObject</code> is called
recursively for the object in the slot.
</p>
<p>Then, for each of the classes that this class
extends (the &lsquo;superclasses&rsquo;), the explicit validity method of
that class is called, if one exists.  Finally, the validity method of
<code>object</code>'s class is called, if there is one.
</p>


<h3>Value</h3>

<p><code>validObject</code> returns <code>TRUE</code> if the object is valid.
Otherwise a vector of strings describing problems found, except that
if <code>test</code> is <code>FALSE</code>, validity failure generates an error,
with the corresponding strings in the error message.
</p>


<h3>Validity methods</h3>

<p>A validity method must be a function of one argument; formally, that
argument should be named <code>object</code>.
If the argument has a different name, <code>setValidity</code> makes the
substitution but in obscure cases that might fail, so it's wiser to
name the
argument <code>object</code>.
</p>
<p>A good method checks all the possible errors and returns a character
vector citing all the exceptions found, rather than returning after
the first one.
<code>validObject</code> will accumulate these errors in its error message
or its return value.
</p>
<p>Note that validity methods do not have to check validity of
superclasses: <code>validObject</code> calls such methods explicitly.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall.
(Chapters 9 and 10.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setClass">setClass</a></code>;
class <code><a href="#topic+classRepresentation-class">classRepresentation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setClass("track",
          slots = c(x="numeric", y = "numeric"))
t1 &lt;- new("track", x=1:10, y=sort(stats::rnorm(10)))
## A valid "track" object has the same number of x, y values
validTrackObject &lt;- function(object) {
    if(length(object@x) == length(object@y)) TRUE
    else paste("Unequal x,y lengths: ", length(object@x), ", ",
               length(object@y), sep="")
}
## assign the function as the validity method for the class
setValidity("track", validTrackObject)
## t1 should be a valid "track" object
validObject(t1)
## Now we do something bad
t2 &lt;- t1
t2@x &lt;- 1:20
## This should generate an error
## Not run: try(validObject(t2))


setClass("trackCurve", contains = "track",
         slots = c(smooth = "numeric"))

## all superclass validity methods are used when validObject
## is called from initialize() with arguments, so this fails
## Not run: trynew("trackCurve", t2)


setClass("twoTrack", slots = c(tr1 = "track", tr2 ="track"))

## validity tests are not applied recursively by default,
## so this object is created (invalidly)
tT  &lt;- new("twoTrack", tr2 = t2)

## A stricter test detects the problem
## Not run: try(validObject(tT, complete = TRUE))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
