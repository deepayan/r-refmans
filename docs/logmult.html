<!DOCTYPE html><html><head><title>Help for package logmult</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {logmult}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anoas'><p>Analysis of Association Functions</p></a></li>
<li><a href='#assoc'><p>Identifying Scores from Association Models</p></a></li>
<li><a href='#color'>
<p>Two Cross-Classifications of Eye Color by Hair Color</p></a></li>
<li><a href='#criminal'>
<p>Dropped Criminal Charges, Denmark, 1955-1958</p></a></li>
<li><a href='#gss7590'>
<p>Education and Occupational Attainment Among White Men and Women in the United States, 1975-1990</p></a></li>
<li><a href='#gss8590'>
<p>Education and Occupational Attainment Among Women in the United States, 1985-1990</p></a></li>
<li><a href='#gss88'>
<p>Major Occupation by Years of Schooling in the United States, 1988</p></a></li>
<li><a href='#hg16'>
<p>Son's occupation by father's occupation for 16 countries in the 1960s and 1970s</p></a></li>
<li><a href='#hmskew'><p>Fitting van der Heijden &amp; Mooijaart Skew-Symmetric Association Model</p></a></li>
<li><a href='#HMSkew'><p>Specify a Skew-Symmetric Association in a gnm Model Formula</p></a></li>
<li><a href='#hmskewL'><p>Fitting van der Heijen &amp; Mooijaart Skew-Symmetric Association Model With Layer Effect</p></a></li>
<li><a href='#iac'>
<p>Intrinsic Association Coefficient</p></a></li>
<li><a href='#maor'>
<p>Mean Absolute Odds Ratio or Intrinsic Association Coefficient</p></a></li>
<li><a href='#ocg1973'><p>Intergenerational Mobility in the United States, 1973</p></a></li>
<li><a href='#plot.assoc'><p>Plotting Scores from Association Models</p></a></li>
<li><a href='#plot.unidiff'>
<p>Plot Layer Coefficients From a UNIDIFF Model</p></a></li>
<li><a href='#ras'>
<p>RAS/Deming-Stephan Algorithm for Raking Tables</p></a></li>
<li><a href='#rc'><p>Fitting Row-Column Association Models</p></a></li>
<li><a href='#rcL'><p>Fitting Row-Column Association Models With Layer Effect</p></a></li>
<li><a href='#rcL.trans'><p>Fitting Row-Column Association Models With Transitional Layer Effect</p></a></li>
<li><a href='#RCTrans'><p>Specify a Row-Column Association With Transitional Layer Effect in a gnm Model Formula</p></a></li>
<li><a href='#se.assoc'><p>Standard Errors for Association Models</p></a></li>
<li><a href='#summary.anoas'><p>Summary and Print Methods for ANOAS objects</p></a></li>
<li><a href='#summary.assoc'>
<p>Summarize Association Model Fits</p></a></li>
<li><a href='#summary.unidiff'>
<p>Summarize UNIDIFF Model Fits</p></a></li>
<li><a href='#svyassocmod'><p>Fitting Association Models With Complex Survey Data</p></a></li>
<li><a href='#svygnm'><p>Fitting Generalized Nonlinear Models With Complex Survey Data</p></a></li>
<li><a href='#unidiff'>
<p>Fitting Log-Multiplicative Uniform Difference/Layer Effect Model</p></a></li>
<li><a href='#yrcskew'><p>Fitting Yamaguchi RC_SK Skew-Symmetric Association Model</p></a></li>
<li><a href='#YRCSkew'><p>Specify a Skew-Symmetric Association in a gnm Model Formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Log-Multiplicative Models, Including Association Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-22</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, grDevices, qvcalc</td>
</tr>
<tr>
<td>Depends:</td>
<td>gnm (&ge; 1.0-5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survey (&ge; 3.34), boot, ellipse, parallel, knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to fit log-multiplicative models using 'gnm', with
  support for convenient printing, plots, and jackknife/bootstrap
  standard errors. For complex survey data, models can be fitted from
  design objects from the 'survey' package. Currently supported models
  include UNIDIFF (Erikson &amp; Goldthorpe, 1992),
  a.k.a. log-multiplicative layer effect model (Xie, 1992)
  &lt;<a href="https://doi.org/10.2307%2F2096242">doi:10.2307/2096242</a>&gt;, and several association models:
  Goodman (1979) &lt;<a href="https://doi.org/10.2307%2F2286971">doi:10.2307/2286971</a>&gt;
  row-column association models of the RC(M) and RC(M)-L families
  with one or several dimensions; two skew-symmetric association
  models proposed by Yamaguchi (1990) &lt;<a href="https://doi.org/10.2307%2F271086">doi:10.2307/271086</a>&gt;
  and by van der Heijden &amp; Mooijaart (1995) &lt;<a href="https://doi.org/10.1177%2F0049124195024001002">doi:10.1177/0049124195024001002</a>&gt;
  Functions allow computing the intrinsic association coefficient
  (see Bouchet-Valat (2022) &lt;<a href="https://doi.org/10.1177%2F0049124119852389">doi:10.1177/0049124119852389</a>&gt;)
  and the Altham (1970) index &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1970.tb00816.x">doi:10.1111/j.2517-6161.1970.tb00816.x</a>&gt;,
  including via the Bayes shrinkage estimator proposed
  by Zhou (2015) &lt;<a href="https://doi.org/10.1177%2F0081175015570097">doi:10.1177/0081175015570097</a>&gt;;
  and the RAS/IPF/Deming-Stephan algorithm.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nalimilan/logmult">https://github.com/nalimilan/logmult</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nalimilan/logmult/issues">https://github.com/nalimilan/logmult/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-22 17:08:32 UTC; milan</td>
</tr>
<tr>
<td>Author:</td>
<td>Milan Bouchet-Valat [aut, cre],
  Heather Turner [ctb],
  Michael Friendly [ctb],
  Jim Lemon [cph],
  Gabor Csardi [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Milan Bouchet-Valat &lt;nalimilan@club.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-23 13:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='anoas'>Analysis of Association Functions</h2><span id='topic+anoas'></span><span id='topic+anoasL'></span>

<h3>Description</h3>

<p>These functions allow performing in a straightforward and efficient way an analysis of association (ANOAS)
consisting of successive RC(M) or RC(M)-L models from 1 to N dimensions. They fit the models efficiently by
using scores from the previous model as starting values for the next one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anoas(tab, nd = 3, symmetric = FALSE, diagonal = FALSE, ...)

anoasL(tab, nd = 3,
       layer.effect = c("homogeneous.scores", "heterogeneous", "none"),
       symmetric = FALSE,
       diagonal = c("none", "heterogeneous", "homogeneous"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anoas_+3A_tab">tab</code></td>
<td>
<p> a two-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above two will be collapsed as appropriate.</p>
</td></tr>
<tr><td><code id="anoas_+3A_nd">nd</code></td>
<td>
<p> the number of dimensions to include in the most complex model. Cannot exceed
<code>min(nrow(tab) - 1, ncol(tab) - 1)</code> if <code>symmetric</code> is <code>FALSE</code> (saturated model),
and twice this threshold otherwise (quasi-symmetry model).</p>
</td></tr>
<tr><td><code id="anoas_+3A_symmetric">symmetric</code></td>
<td>
<p> See <code><a href="#topic+rc">rc</a></code> or <code><a href="#topic+rcL">rcL</a></code></p>
</td></tr>
<tr><td><code id="anoas_+3A_layer.effect">layer.effect</code></td>
<td>
<p> See <code><a href="#topic+rcL">rcL</a></code>.</p>
</td></tr>
<tr><td><code id="anoas_+3A_diagonal">diagonal</code></td>
<td>
<p> See <code><a href="#topic+rc">rc</a></code> or <code><a href="#topic+rcL">rcL</a></code>.</p>
</td></tr>
<tr><td><code id="anoas_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="#topic+rc">rc</a></code> or <code><a href="#topic+rcL">rcL</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to most analyses of association in the literature, this function currently does not fit uniform association model
(&ldquo;U&rdquo;), nor separate models with only row and column association (&ldquo;R&rdquo; and &ldquo;C&rdquo; models), nor log-linear
row and column association models.
</p>
<p>Currently, no significance test is performed on the models. Please note that it is not correct to test the one-dimension
association model against the independence model.
</p>


<h3>Value</h3>

<p>A <code>list</code> of <code><a href="igraph.html#topic+gnm">gnm</a></code> objects. The first element is the independence model, the remaining ones are <code><a href="#topic+rc">rc</a></code>
(for <code>anoas</code>) or <code><a href="#topic+rcL">rcL</a></code> (for <code>anoasL</code>) objects with dimensions from 1 to <code>nd</code>.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Wong, R.S-K. (2010). Association models. SAGE: Quantitative Applications in the Social Sciences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+rcL">rcL</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Wong (2010), Table 2.6
  data(gss8590)

  # The table used in Wong (2010) is not perfectly consistent
  # with that of Wong (2001)
  tab &lt;- margin.table(gss8590[,,c(2,4)], 1:2)
  tab[2,4] &lt;- 49

  # Results correspond to lines 1, 6 and 11
  results &lt;- anoas(tab, nd=2)
  results

  
</code></pre>

<hr>
<h2 id='assoc'>Identifying Scores from Association Models</h2><span id='topic+assoc'></span><span id='topic+assoc.rc'></span><span id='topic+assoc.rc.symm'></span><span id='topic+assoc.hmskew'></span><span id='topic+assoc.yrcskew'></span><span id='topic+assoc.yrcskew.symm'></span><span id='topic+assoc.rcL'></span><span id='topic+assoc.rcL.symm'></span><span id='topic+assoc.hmskewL'></span><span id='topic+assoc.rcL.trans'></span><span id='topic+assoc.rcL.trans.symm'></span>

<h3>Description</h3>

<p>Identify log-multiplicative association scores from over-parameterized gnm models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rc'
assoc(model, weighting = c("marginal", "uniform", "none"),
                   rowsup = NULL, colsup = NULL, ...)

## S3 method for class 'rc.symm'
assoc(model, weighting = c("marginal", "uniform", "none"),
                        rowsup = NULL, colsup = NULL, ...)

## S3 method for class 'hmskew'
assoc(model, weighting = c("marginal", "uniform", "none"),
                       rowsup = NULL, colsup = NULL, ...)

## S3 method for class 'yrcskew'
assoc(model, weighting = c("marginal", "uniform", "none"), ...)

## S3 method for class 'rcL'
assoc(model, weighting = c("marginal", "uniform", "none"), ...)

## S3 method for class 'rcL.symm'
assoc(model, weighting = c("marginal", "uniform", "none"), ...)

## S3 method for class 'rcL.trans'
assoc(model, weighting = c("marginal", "uniform", "none"), ...)

## S3 method for class 'hmskewL'
assoc(model, weighting = c("marginal", "uniform", "none"), ...)

## S3 method for class 'rcL.trans.symm'
assoc(model, weighting = c("marginal", "uniform", "none"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assoc_+3A_model">model</code></td>
<td>
<p>a <code><a href="igraph.html#topic+gnm">gnm</a></code> object, usually obtained using <code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>,
<code><a href="#topic+yrcskew">yrcskew</a></code>, <code><a href="#topic+rcL">rcL</a></code>, or <code><a href="#topic+rcL.trans">rcL.trans</a></code>, but not necessarily.</p>
</td></tr>
<tr><td><code id="assoc_+3A_weighting">weighting</code></td>
<td>
<p>the weights to be used when normalizing scores (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="assoc_+3A_rowsup">rowsup</code></td>
<td>
<p>a matrix with the same columns as the model data giving supplementary (passive) rows
to include in the result.</p>
</td></tr>
<tr><td><code id="assoc_+3A_colsup">colsup</code></td>
<td>
<p>a matrix with the same rows as the model data giving supplementary (passive) columns
to include in the result.</p>
</td></tr>
<tr><td><code id="assoc_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract parameters from <code><a href="igraph.html#topic+gnm">gnm</a></code> log-multiplicative models
and make them identifiable by imposing the required constraints on them. The general pattern
is that row and column scores are separately centered around 0 and scaled so that they sum to 1,
and so that their cross-dimensional correlation is null. From this operation result two series of
scores (rows and columns) plus an intrinsic association coefficient (phi) for each dimension.
</p>
<p>Most users do not need to call these directly, but they are still made public since they may be
useful for advanced uses, notably when combining log-multiplicative association components with
other model specifications. <code>assoc</code> can be used to identify the scores, the rest of the
coefficients being extracted manually by the caller.
</p>


<h3>Value</h3>

<p>An <code>assoc</code> object with the following components:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>The name of the weighting method used, reflected by <code>row.weights</code>
and <code>col.weights</code>.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="#topic+yrcskew">yrcskew</a></code>, <code><a href="#topic+rcL">rcL</a></code>,
<code><a href="#topic+rcL.trans">rcL.trans</a></code> </p>

<hr>
<h2 id='color'>
Two Cross-Classifications of Eye Color by Hair Color
</h2><span id='topic+color'></span>

<h3>Description</h3>

<p>Three-way table crossing eye color and hair color in two places, Caithness and Aberdeen.
This table is used by Becker and Clogg (1989) to illustrate several log-multiplicative
row-column association models, with and without layer effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(color)
</code></pre>


<h3>References</h3>

<p>Becker, M.P., and Clogg, C.C. (1989). Analysis of Sets of Two-Way Contingency Tables Using
Association Models. <em>J. of the Am. Stat. Association</em> 84(405), 142-151.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?rc
</code></pre>

<hr>
<h2 id='criminal'>
Dropped Criminal Charges, Denmark, 1955-1958
</h2><span id='topic+criminal'></span>

<h3>Description</h3>

<p>Number of men aged 15-19 charged with a criminal case for whom charges
were dropped: Denmark, 1955-1958. This two-way table is used by
Goodman (1991) to illustrate a log-multiplicative row-column model
with one dimension. It was used before by Rasch (1966), Christiansen
and Stene (1969), and Andersen (1986, 1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(criminal)</code></pre>


<h3>References</h3>

<p>Goodman, L.A. (1991). Measures, Models, and Graphical Displays in the Analysis of
Cross-Classified Data. <em>J. of the Am. Stat. Association</em> 86(416), 1086,
Table 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?rc
</code></pre>

<hr>
<h2 id='gss7590'>
Education and Occupational Attainment Among White Men and Women in the United States, 1975-1990
</h2><span id='topic+gss7590'></span>

<h3>Description</h3>

<p>Three-way table crossing education and occupational attainment by sex and period among white
men and women from the General Social Survey: United States, 1975-1980 and 1985-1990. This
table is used by Wong (2010) to illustrate log-multiplicative row-column models with three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gss7590)</code></pre>


<h3>References</h3>

<p>Wong, R.S-K. (2010). Association models. SAGE. 32, Table 4.3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?rcL and ?plot.rcL
</code></pre>

<hr>
<h2 id='gss8590'>
Education and Occupational Attainment Among Women in the United States, 1985-1990
</h2><span id='topic+gss8590'></span>

<h3>Description</h3>

<p>Two-way table crossing education and occupational attainment among women
from the General Social Survey: United States, 1985-1990. This table is used
by Wong (2001, 2010) to illustrate a log-multiplicative row-column model with two dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gss8590)
</code></pre>


<h3>References</h3>

<p>Wong, R.S-K. (2001). Multidimensional Association Models : A Multilinear Approach.
<em>Sociol. Methods &amp; Research</em> 30, 197-240, Table 2.
</p>
<p>Wong, R.S-K. (2010). <em>Association models</em>. SAGE. 32, Table 2.3 B.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?rc and ?plot.rc
  # The table reported in Wong (2010) has a cell inconsistent with
  # what was reported in Wong (2001). To fix this:
  data(gss8590)
  tab &lt;- margin.table(gss8590[,,c(2,4)], 1:2)
  tab[2,4] &lt;- 49
</code></pre>

<hr>
<h2 id='gss88'>
Major Occupation by Years of Schooling in the United States, 1988
</h2><span id='topic+gss88'></span>

<h3>Description</h3>

<p>Two-way table crossing occupational attainment and years of education among persons aged
20 through 64 from the General Social Survey: United States, 1988. This table is used
by Clogg and Shihadeh (1994) to illustrate a log-multiplicative row-column model with one
dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gss88)</code></pre>


<h3>References</h3>

<p>Clogg, C.C., and Shihadeh, E.S. (1994). Statistical Models for Ordinal Variables. Sage: Advanced
Quantitative Techniques in the Social Sciences (4), Table 3.1, p. 40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?rc
</code></pre>

<hr>
<h2 id='hg16'>
Son's occupation by father's occupation for 16 countries in the 1960s and 1970s
</h2><span id='topic+hg16'></span>

<h3>Description</h3>

<p>Three-way mobility table assembled by Hazelrigg and Garnier (1976), and used by Zhou (2015)
to illustrate the shrinkage estimation of the log-odds ratios and of the Altham index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hg16)</code></pre>


<h3>References</h3>

<p>Hazelrigg, L.E., Garnier, M.A (1976). Occupational Mobility in Industrial Societies:
A Comparative Analysis of Differential Access to Occupational Ranks in Seventeen Countries.
<em>American Sociological Review</em> 41: 498-511.
</p>
<p>Zhou, X. (2015). Shrinkage Estimation of Log-Odds Ratios for Comparing Mobility Tables.
<em>Sociological Methodology</em> 45(1):33-63.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?iac
</code></pre>

<hr>
<h2 id='hmskew'>Fitting van der Heijden &amp; Mooijaart Skew-Symmetric Association Model</h2><span id='topic+hmskew'></span><span id='topic+print.hmskew'></span>

<h3>Description</h3>

<p>Fits a skew-symmetric association model proposed in van der Heijden &amp; Mooijaart (1995)
to describe asymmetry of square tables. Skew-symmetric association can be combined with
quasi-symmetry (the default), quasi-independence, or symmetric (homogeneous) RC(M) associations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmskew(tab, nd.symm = NA, diagonal = FALSE,
       weighting = c("marginal", "uniform", "none"),
       rowsup = NULL, colsup = NULL,
       se = c("none", "jackknife", "bootstrap"),
       nreplicates = 100, ncpus = getOption("boot.ncpus"),
       family = poisson, weights = NULL,
       start = NULL, etastart = NULL, tolerance = 1e-8,
       iterMax = 5000, trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmskew_+3A_tab">tab</code></td>
<td>
<p> a square two-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above two will be collapsed.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_nd.symm">nd.symm</code></td>
<td>
<p> the number of dimensions to include in the <em>symmetric</em> RC(M) association. Cannot exceed
<code>2 * min(nrow(tab) - 1, ncol(tab) - 1)</code> (quasi-symmetry model).
If <code>NA</code> (the default), a full quasi-symmetric association is used instead of a RC(M) model; if <code>0</code>,
quasi-independence is used.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_diagonal">diagonal</code></td>
<td>
<p> should the model include parameters specific to each diagonal cell? This amounts to
taking quasi-independence, rather than independence, as the baseline model.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_rowsup">rowsup</code></td>
<td>
<p> if present, a matrix with the same columns as <code>tab</code> and rows corresponding to the columns
of <code>colsup</code>, giving supplementary (passive) rows.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_colsup">colsup</code></td>
<td>
<p> if present, a matrix with the same rows as <code>tab</code> and columns corresponding to the rows of
<code>colsup</code>, giving supplementary (passive) columns.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_se">se</code></td>
<td>
<p> which method to use to compute standard errors for parameters.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_nreplicates">nreplicates</code></td>
<td>
<p> the number of bootstrap replicates, if enabled.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> to use optimal starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="hmskew_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="hmskew_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="hmskew_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original model presented by van der Heijden &amp; Mooijaart (1995), called &ldquo;quasi-symmetry plus
skew-symmetry&rdquo;, combines a skew-symmetric association with a quasi-symmetry baseline; it is the variant
fitted by default by this function. If <code>nd.symm</code> is set to a positive integer value, though, variants
using a RC(M) model to describe the <em>symmetric association</em> are used, with our without
diagonal-specific parameters (depending on the value of the <code>diagonal</code> argument).
</p>
<p>These models follow the equation:
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ij} = q_{ij} + \phi (\nu_i \mu_j - \mu_i \nu_j) </code>
</p>

<p>where <code class="reqn">F_{ij}</code> is the expected frequency for the cell at the intersection of row i and column j of
<code>tab</code>, and <code class="reqn">q_{ij}</code> a quasi-symmetric specification, with either full interaction parameters, or
a RC(M) association. See reference for detailed information about the degrees of freedom and the identification
constraints applied to the scores.
</p>
<p>Another model presented in the paper, the &ldquo;symmetry plus skew-symmetry model&rdquo; is not currently supported
out of the box, but should be relatively straightforward to implement using the underlying <code><a href="#topic+assoc.hmskew">assoc.hmskew</a></code>
function combined with a symmetric association model.
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply ensures correct start values are used, in addition to allowing for identification
of scores even with several dimensions, computation of their jackknife or bootstrap standard errors, and plotting.
The default starting values for skew association parameters are computed using an eigen value decomposition from the
results of the model without skew association component (&ldquo;base model&rdquo;); if <code>nd.symm</code> is not <code>NA</code> and
strictly positive, random starting values are used. In some complex cases, using <code>start = NULL</code> to start with
random values can be more efficient, but it is also less stable and can converge to non-optimal solutions.
</p>


<h3>Value</h3>

<p>A <code>hmskew</code> object, which is a subclass of an <code>rc.symm</code> object (see <code><a href="#topic+rc">rc</a></code>) if
<code>nd.symm</code> is strictly positive. In addition to this class, it contains a <code>assoc.hmskew</code> component
holding information about the <em>skew-symmetric</em> association:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The variance-covariance matrix for phi coefficients and normalized row and column
scores. Only present if <code>se</code> was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>adj.covmats</code></td>
<td>
<p>An array stacking on its third dimension one variance-covariance matrix for
the adjusted scores of each layer in the model (used for plotting). Only present if <code>se</code>
was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>
<p>The method used to compute the variance-covariance matrix (corresponding to the
<code>se</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>van der Heijden, P.G.M., and Mooijaart, A. (1995). Some new log bilinear models for the analysis
of asymmetry in a square contingency table. <em>Sociol. Methods and Research</em> 24, 7-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.hmskew">plot.hmskew</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## van der Heijden &amp; Mooijaart (1995), Table 2c, p. 23
  data(ocg1973)

  # 5:1 is here to take "Farmers" as reference category (angle 0)
  model &lt;- hmskew(ocg1973[5:1, 5:1], weighting="uniform")
  model
  ass &lt;- model$assoc.hmskew

  # First column of the table
  round(ass$row[,,1] * sqrt(ass$phi[1,1]), d=2)[5:1,]

  # Right part of the table
  round(ass$phi[1] * (ass$row[,2,1] %o% ass$row[,1,1] -
                      ass$row[,1,1] %o% ass$row[,2,1]), d=3)[5:1, 5:1]

  # Plot
  plot(model, coords="cartesian")
</code></pre>

<hr>
<h2 id='HMSkew'>Specify a Skew-Symmetric Association in a gnm Model Formula</h2><span id='topic+HMSkew'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify a van der Heijden &amp; Mooijaart (1995) skew-symmetric
association in the formula argument to <code><a href="igraph.html#topic+gnm">gnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMSkew(row, col, inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMSkew_+3A_row">row</code></td>
<td>
<p>the levels of the row variable</p>
</td></tr>
<tr><td><code id="HMSkew_+3A_col">col</code></td>
<td>
<p>the levels of the column variable</p>
</td></tr>
<tr><td><code id="HMSkew_+3A_inst">inst</code></td>
<td>
<p>a positive integer specifying the instance number of the term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+hmskew">hmskew</a></code> to fit skew-symmetric models proposed by
van der Heijden &amp; Mooijaart (1995) and their variants. It can be used directly to fit custom
variants of the model not supported by <code>hmskew</code>.
</p>
<p>This function combines its arguments in the following way:
</p>
<p style="text-align: center;"><code class="reqn"> HMSkew(i, j) = \nu_i \mu_j - \mu_i \nu_j </code>
</p>

<p>where <code class="reqn">HMSkew(i, j)</code> is the skew association for the cell at the intersection of row i and column j of
the table. See reference for mathematical details.
</p>


<h3>Value</h3>

<p>A list with the required components of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> the expressions passed to <code>Mult</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical expression
of the term, given labels for the predictors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the call to use as a prefix for parameter labels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>van der Heijden, P.G.M., and Mooijaart, A. (1995). Some new log bilinear models for the analysis
of asymmetry in a square contingency table. <em>Sociol. Methods and Research</em> 24, 7-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmskew">hmskew</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See ?hmskew.
</code></pre>

<hr>
<h2 id='hmskewL'>Fitting van der Heijen &amp; Mooijaart Skew-Symmetric Association Model With Layer Effect</h2><span id='topic+hmskewL'></span><span id='topic+print.hmskewL'></span>

<h3>Description</h3>

<p>Fits an extension of the skew-symmetric association model proposed in van der Heijden &amp; Mooijaart (1995)
to describe asymmetry of square tables. This model introduces a layer effect by which the strength of
skew-symmetric association, and optionnally scores, can vary over the levels of the third dimension of the table.
Skew-symmetric association can be combined with quasi-symmetry (the default), quasi-independence, or
symmetric (homogeneous) RC(M) associations, with or without layer effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmskewL(tab, nd.symm = NA,
        layer.effect.skew = c("homogeneous.scores", "heterogeneous",
                              "none"),
        layer.effect.symm = c("heterogeneous", "uniform",
                              "regression.type",
                              "homogeneous.scores", "none"),
        diagonal = c("none", "heterogeneous", "homogeneous"),
        weighting = c("marginal", "uniform", "none"),
        se = c("none", "jackknife", "bootstrap"),
        nreplicates = 100, ncpus = getOption("boot.ncpus"),
        family = poisson, weights = NULL,
        start = NULL, etastart = NULL, tolerance = 1e-8,
        iterMax = 5000, trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmskewL_+3A_tab">tab</code></td>
<td>
<p> a three-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above three will be collapsed. First two dimensions must be symmetric
(i.e. of the same length).</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_nd.symm">nd.symm</code></td>
<td>
<p> the number of dimensions to include in the <em>symmetric</em> RC(M) association. Cannot exceed
<code>2 * min(nrow(tab) - 1, ncol(tab) - 1)</code> (quasi-symmetry model).
If <code>NA</code> (the default), a full quasi-symmetric association is used instead of a RC(M) model; if <code>0</code>,
quasi-independence is used.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_layer.effect.skew">layer.effect.skew</code></td>
<td>
<p> determines the form of the interaction between skew-symmetric association and layers.
See &ldquo;Details&rdquo; below.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_layer.effect.symm">layer.effect.symm</code></td>
<td>
<p> determines the form of the interaction between symmetric row-column association,
or quasi-symmetric association (if <code>nd.symm = NA</code>) and layers. See &ldquo;Details&rdquo; below.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_diagonal">diagonal</code></td>
<td>
<p> what type of diagonal-specific parameters to include in the model, if any. Only makes sense
when <code>nd.symm</code> is not <code>NA</code> (else, diagonal parameters are already included).</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_se">se</code></td>
<td>
<p> which method to use to compute standard errors for parameters.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_nreplicates">nreplicates</code></td>
<td>
<p> the number of bootstrap replicates, if enabled.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> to use optimal starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="hmskewL_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model follows an equation inspired from that presented by van der Heijden &amp; Mooijaart (1995) for two-way tables
(see <code><a href="#topic+hmskew">hmskew</a></code>):
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ijk} = q_{ijk} + \phi_k (\nu_{ik} \mu_{jk} - \mu_{ik} \nu_{jk}) </code>
</p>

<p>where <code class="reqn">F_{ijk}</code> is the expected frequency for the cell at the intersection of row i, column j and layer k of
<code>tab</code>, and <code class="reqn">q_{ij}</code> a quasi-symmetric specification, with either full interaction parameters, or
a RC(M) association. See reference for detailed information about the degrees of freedom and the identification
constraints applied to the scores.
</p>
<p>If <code>layer.effect.skew</code> is set to &lsquo;heterogeneous&rsquo;, different scores will be computed for each level,
which is equivalent to fitting separate models using <code><a href="#topic+hmskew">hmskew</a></code> on the k two-way tables.
If it is set to &lsquo;homogeneous.scores&rsquo;, then <code class="reqn">\mu_{ik} = \mu_i</code> and <code class="reqn">\nu_{ik} = \nu_i</code> for all
layers k: only the <code class="reqn">\phi_k</code> are allowed to vary across layers. If it is set to &lsquo;none&rsquo;, then in addition
to the previous conditions all <code class="reqn">\phi_{mk}</code> are forced to be equal for all layers k, which amounts to a stability
of the association across layers.
</p>
<p>When <code>nd.symm</code> is different from <code>NA</code>, the symmetric association works exactly like a call to <code>rcL</code>,
with parameters <code>nd.symm</code> and <code>layer.effect.symm</code> translated respectively to <code>nd</code> and
<code>layer.effect</code>. When <code>nd.symm == NA</code>, symmetric association parameters are either stable across layers,
are multiplied by a layer coefficient (UNIDIFF model, see <code><a href="#topic+unidiff">unidiff</a></code>), follow a regression-type
(Goodman-Hout) specification, or are different for each layer, when <code>layer.effect.symm</code> is respectively
<code>none</code>, <code>uniform</code>, <code>regression.type</code> and <code>heterogeneous</code>.
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply ensures correct start values are used, in addition to allowing for identification
of scores even with several dimensions, computation of their jackknife or bootstrap standard errors, and plotting.
The default starting values for skew association parameters are computed using an eigen value decomposition from the
results of the model without skew association component (&ldquo;base model&rdquo;); if <code>nd.symm</code> is not <code>NA</code> and
strictly positive, random starting values are used. In some complex cases, using <code>start = NULL</code> to start with
random values can be more efficient, but it is also less stable and can converge to non-optimal solutions.
</p>


<h3>Value</h3>

<p>A <code>hmskewL</code> object, which is a subclass of an <code>rcL.symm</code> object (see <code><a href="#topic+rcL">rcL</a></code>) if
<code>nd.symm</code> is strictly positive. In addition to this class, it contains a <code>assoc.hmskew</code> component
holding information about the <em>skew-symmetric</em> association:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension and per layer.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>The name of the weighting method used, reflected by <code>row.weights</code>
and <code>col.weights</code>.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The variance-covariance matrix for phi coefficients and normalized row and column
scores. Only present if <code>se</code> was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>adj.covmats</code></td>
<td>
<p>An array stacking on its third dimension one variance-covariance matrix for
the adjusted scores of each layer in the model (used for plotting). Only present if <code>se</code>
was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>
<p>The method used to compute the variance-covariance matrix (corresponding to the
<code>se</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>van der Heijden, P.G.M., and Mooijaart, A. (1995). Some new log bilinear models for the analysis
of asymmetry in a square contingency table. <em>Sociol. Methods and Research</em> 24, 7-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.hmskewL">plot.hmskewL</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>

<hr>
<h2 id='iac'>
Intrinsic Association Coefficient
</h2><span id='topic+iac'></span>

<h3>Description</h3>

<p>Compute the intrisic association coefficient of a table.
This coefficient was first devised by Goodman (1996) as the
&ldquo;generalized contingency&rdquo; when a logarithm link is used, and it is equal
to the standard deviation of the log-linear two-way interaction parameters
<code class="reqn">\lambda_{ij}</code>.
To obtain the Altham index, multiply the result by
<code>sqrt(nrow(tab) * ncol(tab)) * 2</code> (see &ldquo;Examples&rdquo; below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iac(tab, cell = FALSE,
    weighting = c("marginal", "uniform", "none"),
    component = c("total", "symmetric", "antisymmetric"),
    shrink = FALSE,
    normalize = FALSE,
    row.weights = NULL, col.weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iac_+3A_tab">tab</code></td>
<td>
<p>a two- or three-way table without zero cells; for three-way tables,
average marginal weighting is used when &ldquo;weighting = &quot;marginal&quot;&rdquo;, and
the MAOR is computed for each layer (third dimension).</p>
</td></tr>
<tr><td><code id="iac_+3A_cell">cell</code></td>
<td>
<p>if &ldquo;TRUE&rdquo;, return the per-cell contributions
(affected by the value of <code>phi</code>, see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="iac_+3A_weighting">weighting</code></td>
<td>
<p>what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="iac_+3A_component">component</code></td>
<td>
<p>whether to compute the total association, or from symmetric
or antisymmetric interaction coefficients only.</p>
</td></tr>
<tr><td><code id="iac_+3A_shrink">shrink</code></td>
<td>
<p>whether to use the empirical Bayes shrinkage estimator proposed by Zhou (2015)
rather than the direct estimator.</p>
</td></tr>
<tr><td><code id="iac_+3A_normalize">normalize</code></td>
<td>
<p>whether to return the normalized version of the index varying
between 0 and 1 proposed by Bouchet-Valat (2022) rather than the
classic index varying between 0 and positive infinity.</p>
</td></tr>
<tr><td><code id="iac_+3A_row.weights">row.weights</code></td>
<td>
<p>optional custom weights to be used for rows, e.g. to compute
the phi coefficient for several tables using their overall marginal
distribution. If specified, <code>weighting</code> is ignored.</p>
</td></tr>
<tr><td><code id="iac_+3A_col.weights">col.weights</code></td>
<td>
<p>see <code>row.weights</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Goodman (1996), Equation 52 for the (marginal or other) weighted version of
the intrinsic association coefficient (<code class="reqn">\tilde \lambda</code>); the unweighted version can be
computed with unit weights. The coefficient should not be confused with Goodman and Kruskal's lambda coefficient.
The uniform-weighted version is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\lambda^\dagger = \sqrt{ \frac{1}{IJ} \sum_{i = 1}^I \sum_{j = 1}^J \lambda_{ij}^2 }</code>
</p>

<p>The (marginal or other) weighted version is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\tilde \lambda = \sqrt{ \sum_{i = 1}^I \sum_{j = 1}^J \tilde \lambda_{ij}^2 P_{i+} P_{+j} }</code>
</p>

<p>with <code class="reqn">\sum_{i = 1}^I \lambda_{ij} = \sum_{j = 1}^J \lambda_{ij} = 0</code> and
<code class="reqn">\sum_{i = 1}^I P_{i+} \tilde \lambda_{ij} = \sum_{j = 1}^J P_{+j} \tilde \lambda_{ij} = 0</code>.
</p>
<p>The normalized version of the index is defined from <code class="reqn">\lambda^\dagger</code> and
<code class="reqn">\tilde \lambda</code> as:
</p>
<p style="text-align: center;"><code class="reqn">\tau = \sqrt{1 + 1/(2 \lambda)^2} - 1/(2 \lambda)</code>
</p>

<p>Per-cell contributions <code class="reqn">c_{ij}</code> are defined so that:
<code class="reqn">\tilde \phi = \sqrt{ \sum_{i = 1}^I \sum_{j = 1}^J c_{ij} }</code>. For the unweighted case,
<code class="reqn">c_{ij} = \lambda_{ij}^2 / IJ</code>; for the weighted case,
<code class="reqn">\tilde c_{ij} = \tilde \lambda_{ij}^2 P_{i+} P_{+j}</code>.
</p>
<p>This index cannot be computed in the presence of zero cells since it is based
on the logarithm of proportions. In these cases, 0.5 is added to all cells of the table
(Agresti 2002, sec. 9.8.7, p. 397; Berkson 1955), and a warning is printed.
Make sure this correction does not affect too much the results (especially
with small samples) by manually adding different values before calling this function.
</p>


<h3>Value</h3>

<p>The numeric value of the intrinsic association coefficient (if <code>cell = FALSE</code>),
or the corresponding per-cell contributions (if <code>cell = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Agresti, A. 2002. Categorical Data Analysis. New York: Wiley.
</p>
<p>Altham, P. M. E., Ferrie J. P., 2007. Comparing Contingency Tables Tools for Analyzing Data
from Two Groups Cross-Classified by Two Characteristics. <em>Historical Methods</em> 40(1):3-16.
</p>
<p>Bouchet-Valat, M. (2022). General Marginal-free Association Indices for Contingency Tables:
From the Altham Index to the Intrinsic Association Coefficient. <em>Sociological Methods &amp; Research</em> 51(1): 203-236.
</p>
<p>Berkson, J. (1955). Maximum Likelihood and Minimum chi2 Estimates of the Logistic Function.
<em>J. of the Am. Stat. Ass.</em> 50(269):130-162.
</p>
<p>Goodman, L. A. (1996). A Single General Method for the Analysis of Cross-Classified Data: Reconciliation
and Synthesis of Some Methods of Pearson, Yule, and Fisher, and Also Some Methods of Correspondence
Analysis and Association Analysis. <em>J. of the Am. Stat. Ass.</em> 91(433):408-428.
</p>
<p>Zhou, X. (2015). Shrinkage Estimation of Log-Odds Ratios for Comparing Mobility Tables.
<em>Sociological Methodology</em> 45(1):33-63.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unidiff">unidiff</a></code>, <code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+maor">maor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Altham index (Altham and Ferrie, 2007, Table 1, p. 3 and commentary p. 8)
  tab1 &lt;- matrix(c(260, 195, 158, 70,
                   715, 3245, 874, 664,
                   424, 454, 751, 246,
                   142, 247, 327, 228), 4, 4)
  iac(tab1, weighting="n") * sqrt(nrow(tab1) * ncol(tab1)) * 2

  # Zhou (2015)
  data(hg16)
  # Add 0.5 due to the presence of zero cells
  hg16 &lt;- hg16 + 0.5
  # Figure 3, p. 343: left column then right column
  # (reported values are actually twice the Altham index)
  iac(hg16, weighting="n") * sqrt(nrow(hg16) * ncol(hg16)) * 2 * 2
  iac(hg16, weighting="n", shrink=TRUE) * sqrt(nrow(hg16) * ncol(hg16)) * 2 * 2
  # Table 4, p. 347: values are not exactly the same
  u &lt;- unidiff(hg16)
  # First row
  cor(u$unidiff$layer$qvframe$estimate, iac(hg16, weighting="n"))
  cor(u$unidiff$layer$qvframe$estimate, iac(hg16, weighting="n"), method="spearman")
  # Second row
  cor(u$unidiff$layer$qvframe$estimate, iac(hg16, shrink=TRUE, weighting="n"))
  cor(u$unidiff$layer$qvframe$estimate, iac(hg16, shrink=TRUE, weighting="n"), method="spearman")
</code></pre>

<hr>
<h2 id='maor'>
Mean Absolute Odds Ratio or Intrinsic Association Coefficient
</h2><span id='topic+maor'></span>

<h3>Description</h3>

<p>Compute the mean absolute odds ratio of a table, i.e. the (possibly weighted)
geometric mean of the odds ratios or of their inverse when they are above one,
which is also closely related to the the intrinsic association coefficient.
The latter coefficient was first devised by Goodman (1996) as the
&ldquo;generalized contingency&rdquo; when a logarithm link is used, and it is equal
to the mean of the absolute value of log-linear two-way interaction parameters
<code class="reqn">\lambda_{ij}</code> (in its original version it consists in the square root of
the sum of squared parameters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maor(tab, phi = FALSE, cell = FALSE,
     weighting = c("marginal", "uniform", "none"),
     norm = 2, component=c("total", "symmetric", "antisymmetric"),
     row.weights = NULL, col.weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maor_+3A_tab">tab</code></td>
<td>
<p>a two- or three-way table without zero cells; for three-way tables,
average marginal weighting is used when &ldquo;weighting = &quot;marginal&quot;&rdquo;, and
the MAOR is computed for each layer (third dimension).</p>
</td></tr>
<tr><td><code id="maor_+3A_phi">phi</code></td>
<td>
<p>if &ldquo;TRUE&rdquo;, return the intrinsic association coefficient
rather than the Mean absolute odds ratio.</p>
</td></tr>
<tr><td><code id="maor_+3A_cell">cell</code></td>
<td>
<p>if &ldquo;TRUE&rdquo;, return the per-cell contributions
(affected by the value of <code>phi</code>, see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="maor_+3A_weighting">weighting</code></td>
<td>
<p>what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="maor_+3A_norm">norm</code></td>
<td>
<p>the norm to use to compute the mean of <code class="reqn">\lambda_{ij}</code> parameters,
1 for the mean of absolute values, or 2 for the square root
of the sum of squared parameters (as in the original version).</p>
</td></tr>
<tr><td><code id="maor_+3A_component">component</code></td>
<td>
<p>whether to compute the total association, or from symmetric
or antisymmetric interaction coefficients only.</p>
</td></tr>
<tr><td><code id="maor_+3A_row.weights">row.weights</code></td>
<td>
<p>optional custom weights to be used for rows, e.g. to compute
the phi coefficient for several tables using their overall marginal
distribution. If specified, <code>weighting</code> is ignored.</p>
</td></tr>
<tr><td><code id="maor_+3A_col.weights">col.weights</code></td>
<td>
<p>see <code>row.weights</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Goodman (1996), Equation 52 for the (marginal or other) weighted version of
the intrinsic association coefficient (<code class="reqn">\tilde \phi</code>); the unweighted version can be
computed with unit weights. The coefficient is called <code class="reqn">\tilde \lambda^2</code> in the original
article, but to avoid the confusion with Goodman and Kruskal's lambda coefficient,
it is here denoted as <code class="reqn">\phi</code>, as usual in row-column association models.
The uniform-weighted version is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\phi = \sqrt{ \frac{1}{IJ} \sum_{i = 1}^I \sum_{j = 1}^J \lambda_{ij}^2 }</code>
</p>

<p>The (marginal or other) weighted version is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\tilde \phi = \sqrt{ \sum_{i = 1}^I \sum_{j = 1}^J \tilde \lambda_{ij}^2 P_{i+} P_{+j} }</code>
</p>

<p>with <code class="reqn">\sum_{i = 1}^I \lambda_{ij} = \sum_{j = 1}^J \lambda_{ij} = 0</code> and
<code class="reqn">\sum_{i = 1}^I P_{i+} \tilde \lambda_{ij} = \sum_{j = 1}^J P_{+j} \tilde \lambda_{ij} = 0</code>.
</p>
<p>The uniform-weighted version of the mean absolute odds ratio (MAOR) is defined as:
</p>
<p style="text-align: center;"><code class="reqn">MAOR = \exp \left[ \sqrt{ \frac{4}{ IJ (I-1) (J-1)} } \phi \right]</code>
</p>

<p>The (marginal or other) weighted version is defined as:
</p>
<p style="text-align: center;"><code class="reqn">MAOR = \exp \left[ \sqrt{ \frac{4}{\sum_{i = 1}^I \sum_{j = 1}^J P_{i+}
      (1 -  P_{i+}) P_{+j} (1 - P_{+j})} } \tilde \phi \right]</code>
</p>

<p>Per-cell contributions <code class="reqn">c_{ij}</code> are defined so that <code class="reqn">\tilde \phi = \sqrt{ \sum_{i = 1}^I \sum_{j = 1}^J c_{ij} }</code> <br />
and <code class="reqn">MAOR = exp \left[ \sqrt{ \sum_{i = 1}^I \sum_{j = 1}^J c_{ij} } \right]</code>.
</p>
<p>This index cannot be computed in the presence of zero cells since it is based
on the logarithm of proportions. In these cases, 0.5 is added to all cells of the table
(Agresti 2002, sec. 9.8.7, p. 397; Berkson 1955), and a warning is printed.
Make sure this correction does not affect too much the results (especially
with small samples) by manually adding different values before calling this function.
</p>


<h3>Value</h3>

<p>The numeric value of the mean absolute odds ratio, or of the intrinsic association
coefficient (if <code>phi = TRUE</code>), or the corresponding per-cell contributions
(if <code>cell = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Agresti, A. 2002. Categorical Data Analysis. New York: Wiley.
</p>
<p>Goodman, L. A. (1996). A Single General Method for the Analysis of Cross-Classified Data: Reconciliation
and Synthesis of Some Methods of Pearson, Yule, and Fisher, and Also Some Methods of Correspondence
Analysis and Association Analysis. <em>J. of the Am. Stat. Ass.</em> 91(433):408-428.
</p>
<p>Berkson, J. (1955). Maximum Likelihood and Minimum chi2 Estimates of the Logistic Function.
<em>J. of the Am. Stat. Ass.</em> 50(269):130-162.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iac">iac</a></code>, <code><a href="#topic+unidiff">unidiff</a></code>, <code><a href="#topic+rc">rc</a></code>
</p>

<hr>
<h2 id='ocg1973'>Intergenerational Mobility in the United States, 1973</h2><span id='topic+ocg1973'></span>

<h3>Description</h3>

<p>Mobility table for the United States from the 1973 Occupational Changes in a Generation (OCG-II)
survey. This table has been used by Yamaguchi (1987, 1990), Xie (1992) and van der Heijden &amp;
Mooijaart (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ocg1973)</code></pre>


<h3>References</h3>

<p>Yamaguchi, K. (1990). Some Models for the Analysis of Asymmetric Association in Square
Contingency Tables with Ordered Categories. <em>Sociological Methodology</em> 20, 181-212.
</p>
<p>van der Heijden, P.G.M., and Mooijaart, A. (1995). Some new log bilinear models for the analysis
of asymmetry in a square contingency table. <em>Sociol. Methods and Research</em> 24, 7-29.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see ?yrcskew, ?hmskew and ?plot.hmskew
</code></pre>

<hr>
<h2 id='plot.assoc'>Plotting Scores from Association Models</h2><span id='topic+plot.assoc'></span><span id='topic+plot.rc'></span><span id='topic+plot.rc.symm'></span><span id='topic+plot.hmskew'></span><span id='topic+plot.yrcskew'></span><span id='topic+plot.rcL'></span><span id='topic+plot.rcL.symm'></span><span id='topic+plot.hmskewL'></span>

<h3>Description</h3>

<p>Graphical display of category scores from association models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rc'
plot(x, dim = c(1, 2),
     what = c("both", "rows", "columns"), which = NULL,
     mass = TRUE, luminosity = length(x$assoc$diagonal &gt; 0),
     conf.int = NA, replicates = FALSE,
     coords = c("cartesian", "polar"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = c("blue", "red"), col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'rc.symm'
plot(x, dim = c(1, 2), which = NULL,
     mass = TRUE, luminosity = length(x$assoc$diagonal &gt; 0),
     conf.int = NA, replicates = FALSE,
     coords = c("cartesian", "polar"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = "blue", col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'hmskew'
plot(x, dim = c(1, 2),
     what = c("skew-symmetric", "symmetric"), which = NULL,
     mass = TRUE, luminosity = length(x$assoc.hmskew$diagonal &gt; 0),
     arrow = 45, conf.int = NA, replicates = FALSE,
     coords = c("polar", "cartesian"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = "blue", col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'yrcskew'
plot(x, dim = c(1, 2),
     what = c("skew-symmetric", "symmetric"), which = NULL,
     mass = TRUE, luminosity = length(x$assoc.yrcskew$diagonal &gt; 0),
     arrow = 45, conf.int = NA, replicates = FALSE,
     coords = c("polar", "cartesian"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = "blue", col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'rcL'
plot(x, dim = c(1, 2), layer = "average",
     what = c("both", "rows", "columns"), which = NULL,
     mass = TRUE, luminosity = length(x$assoc$diagonal &gt; 0),
     conf.int = NA, replicates = FALSE,
     coords = c("cartesian", "polar"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = c("blue", "red"), col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'rcL.symm'
plot(x, dim = c(1, 2), layer = "average",
     which = NULL,
     mass = TRUE, luminosity = length(x$assoc$diagonal &gt; 0),
     conf.int = NA, replicates = FALSE,
     coords = c("cartesian", "polar"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = "blue", col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'hmskewL'
plot(x, dim = c(1, 2), layer = "average",
     what = c("skew-symmetric", "symmetric"), which = NULL,
     mass = TRUE, luminosity = length(x$assoc.hmskew$diagonal &gt; 0),
     arrow=45, conf.int = NA, replicates = FALSE,
     coords = c("polar", "cartesian"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = "blue", col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)

## S3 method for class 'assoc'
plot(x, dim = c(1, 2), layer = 1,
     what = c("both", "rows", "columns"), which = NULL,
     mass = TRUE, luminosity = length(x$diagonal &gt; 0),
     arrow = NULL, conf.int = NA, replicates = FALSE,
     coords = c("cartesian", "polar"), rev.axes = c(FALSE, FALSE),
     cex = par("cex"), col = c("blue", "red"), col.conf.int = col, groups = NULL,
     add = FALSE, type, xlim, ylim, asp, xlab, ylab, main, pch, font, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.assoc_+3A_x">x</code></td>
<td>
<p>an association model, or an object inheriting from class <code>assoc</code>.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_dim">dim</code></td>
<td>
<p>numerical vector of length 2 indicating the dimensions to plot on horizontal
and vertical axes respectively; default is first dimension horizontal and second
dimension vertical.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_layer">layer</code></td>
<td>
<p>integer indicating which layer should be represented, or &ldquo;average&rdquo; or
&ldquo;average.rotate&rdquo; when scores are homogeneous (see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_what">what</code></td>
<td>
<p>for <code>rc</code> and <code>assoc</code> objects, whether points corresponding to rows, columns
or both should be plotted; for <code>hmskew</code> and <code>yrcskew</code> objects, what association
should be plotted.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_which">which</code></td>
<td>
<p>an optional subset of points to be plotted, specified via a logical, integer or character
vector indexing the row or column component of the association object; if <code>what = both</code>,
a list of two such vectors, resp. for rows and columns.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_mass">mass</code></td>
<td>
<p>whether the size of the point symbols should reflect on the mass of the categories;
this only makes sense when marginal weights were used when fitting the model. The precise
formula is that the <code>pch</code> of a symbol is equal to the <code>pch</code> argument, times the
weight of the category divided by average weight.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_luminosity">luminosity</code></td>
<td>
<p>whether the luminosity of the symbols should vary according to the diagonal-specific
parameters (if <code>diagonal = TRUE</code> was passed when fitting the model); if <code>TRUE</code>,
hue and saturation of <code>col</code> are taken as a base, and value varies from 0 to 0.8
as a linear function of the diagonal parameter values.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_arrow">arrow</code></td>
<td>
<p>Numeric value indicating the angle at which the polar coordinates system arrow should be plotted;
use NULL for no arrow.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_conf.int">conf.int</code></td>
<td>
<p>an integer between 0 and 1 giving the confidence level to use when drawing error bars/ellipses
around the points (see &ldquo;Details&rdquo; below); by default nothing is plotted. Only possible
if jackknife or bootstrap was enabled when fitting the model.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_replicates">replicates</code></td>
<td>
<p>whether to plot points representing the values of the scores obtained for all of the
jackknife of bootrap replicates, when applicable (see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_coords">coords</code></td>
<td>
<p>whether to use a Cartesian or a polar coordinate system; the former makes sense when axes
offer an interpretation (like in RC(M) models), while the latter are more appropriate when
only the angle and distance to origin are of interest (like in <code>hmskew</code> models).</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_rev.axes">rev.axes</code></td>
<td>
<p>a numeric of length 1 or 2 indicating whether the sign of scores on the axes should be changed;
as this sign is arbitrary in RC(M) models, changing it has no incidence on the results and may
be more intuitive or consistent with other presentations.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_cex">cex</code></td>
<td>
<p>a numeric vector indicating the size of the point symbols, recycled as necessary; the most common
choice is probably to pass only one value and use <code>mass</code> to make the size vary.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_col">col</code></td>
<td>
<p>a vector indicating the color of the point symbols, recycled as necessary; as a special case, a
vector of length 2 can be passed, to indicate the color of row and column points, respectively.
See also <code>luminosity</code>.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_col.conf.int">col.conf.int</code></td>
<td>
<p>a vector indicating the color of the confidence bars/ellipses, when these are plotted; see
<code>col</code> the format.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_groups">groups</code></td>
<td>
<p>a vector indicating what symbol should be used for each point, recycled as necessary; groups will
use <code>pch</code> values 21, 24, 22, 23 and 25, in this order, cycling if needed. If not an integer,
the number of the factor level will be used.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_add">add</code></td>
<td>
<p>whether to draw over an existing plot instead of creating a new one.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_type">type</code></td>
<td>
<p>set to &quot;n&quot; to avoid actually plotting the points and labels;
useful for customization based on the returned coordinates, see &ldquo;Value&rdquo; below.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_xlim">xlim</code></td>
<td>
<p>numeric vector of length 2, giving the x coordinates range.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2, giving the y coordinates range.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio, see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>. For RC(M) axes and Cartesian coordinates,
the default is &ldquo;Dimension N (phi)&rdquo;; it is empty in other cases where axes have no meaning.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>. For RC(M) axes and Cartesian coordinates,
the default is &ldquo;Dimension N (phi)&rdquo;; it is empty in other cases where axes have no meaning.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_main">main</code></td>
<td>
<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>. If missing for RC(M)-L models, the name of
the plotted layer will be used.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_pch">pch</code></td>
<td>
<p>a vector of plotting &lsquo;character&rsquo;, i.e., symbol to use for each point, recycled as necessary;
see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_font">font</code></td>
<td>
<p>an integer vector indicating the font to use for each label, recycled as necessary;
see <code>link{par}</code>.</p>
</td></tr>
<tr><td><code id="plot.assoc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions documented here represent in a one- or two-dimensional space the category scores obtained from a
log-multiplicative association model. They produce <em>symmetric biplots</em> in which the coordinates of points
on both axes are the product of normalized scores and of the square root of the intrinsic association
coefficient corresponding to each dimension: thus, row and column points share the same &ldquo;unit&rdquo;
on all axes (Goodman, 1991, Appendix 2; Wong, 2010, eq. 2.38; Clogg &amp; Shihadeh, 1994, p. 91-92).
As a special case, models with only one dimension are presented as a dotchart of the scores.
</p>
<p>Various convenience options are provided, with reasonable defaults for each model family. In particular,
you may find it necessary to adapt the <code>cex</code>, <code>mass</code>, <code>luminosity</code> and <code>groups</code> arguments
depending on the number of categories to be plotted and to their respective weights. When plotting a RC(2) model,
a polar coordinate system can be of substantive interest, allowing to interpret at a glance the distance to
origin as the general strength of the association for a category on both axes (a property that is lost for
higher-dimensional models).
</p>
<p>Confidence bars/ellipses are computed from the scores' variances and covariances, based on the assumption that they are
follow a normal distribution, even if standard errors are computed using jackknife or bootstrap. When bootstrap (not
jackknife) was used, this normality assumption can be assessed visually using the <code>replicates</code> argument to check 
whether points globally follow the shape of the ellipses. See <code><a href="#topic+se.assoc">se.assoc</a></code> for details about checking the
validity of jackknife or bootstrap results.
</p>
<p>When <code>layer</code> is set to &ldquo;average&rdquo; for models with layer effect and homogeneous scores, intrinsic association
coefficients are weighted across all layers. In addition, if <code>layer</code> is set to &ldquo;average.rotate&rdquo;, scores are
rotated so that axes of the plot are those with the highest variance; oblique axes represent the original dimensions
in the new space.
</p>
<p>The <code>plot.assoc</code> function is called internally by all others, and may be leveraged for advanced use cases,
like plotting custom models that do not correspond stricly to the supported types.
</p>


<h3>Value</h3>

<p>An invisible list with components <code>row</code> and <code>col</code>, two matrices containing the coordinates of the
plotted points (<code>NULL</code> when not plotted).
</p>


<h3>References</h3>

<p>For RC(M) models:
</p>
<p>Goodman, L.A. (1991). Measures, Models, and Graphical Displays in the Analysis of
Cross-Classified Data. <em>J. of the Am. Stat. Association</em> 86(416), 1085-1111.
</p>
<p>Clogg, C.C., and Shihadeh, E.S. (1994). Statistical Models for Ordinal Variables. Sage: Advanced
Quantitative Techniques in the Social Sciences (4).
</p>
<p>Wong, R.S-K. (2010). Association models. Sage: Quantitative Applications in the Social Sciences (164).
</p>
<p>For van der Heijden &amp; Mooijaart models:
</p>
<p>van der Heijden, P.G.M., and Mooijaart, A. (1995). Some new log bilinear models for the analysis
of asymmetry in a square contingency table. <em>Sociol. Methods and Research</em> 24, 7-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+rcL">rcL</a></code>, <code><a href="#topic+rcL.trans">rcL.trans</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>,
<code><a href="#topic+hmskewL">hmskewL</a></code>, <code><a href="#topic+yrcskew">yrcskew</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Wong (2010), Figures 2.2 and 2.3 (p. 50-51)
  data(gss8590)

  ## Not run: 
  model &lt;- rc(margin.table(gss8590[,,c(2,4)], 1:2),
              nd=2, weighting="none", se="jackknife")
  plot(model, what="row", rev.axes=c(TRUE, FALSE), conf.int=0.95)
  plot(model, what="col", rev.axes=c(TRUE, FALSE), conf.int=0.95)
  
## End(Not run)

  ## Wong (2010), Figures 4.1 and 4.2 (p. 108-109)
  data(gss7590)
  model &lt;- rcL(gss7590, nd=2, weighting="none")

  opar &lt;- par(mfrow=c(2, 2))
  for(i in 1:4)
      plot(model, layer=i, what="rows", rev.axes=c(TRUE, FALSE),
           main=rownames(model$assoc$phi)[i],
           xlim=c(-1.2, 1.2), ylim=c(-1.2, 1.2))

  par(mfrow=c(2, 2))
  for(i in 1:4)
      plot(model, layer=i, what="col", rev.axes=c(TRUE, FALSE),
           main=rownames(model$assoc$phi)[i],
           xlim=c(-1.4, 1.4), ylim=c(-1.2, 1.2))

  par(opar)


  ## van der Heijden &amp; Mooijaart (1995), Figure 1c (p. 23)
  data(ocg1973)
  # 5:1 is here to take "Farmers" as reference category (angle 0)
  model &lt;- hmskew(ocg1973[5:1, 5:1], weighting="uniform")
  # Reproduce the plot from the original article
  plot(model, coords="cartesian")
  # Use a polar coordinates system, which makes more sense in this setting
  plot(model)
</code></pre>

<hr>
<h2 id='plot.unidiff'>
Plot Layer Coefficients From a UNIDIFF Model
</h2><span id='topic+plot.unidiff'></span>

<h3>Description</h3>

<p>Plots the layer coefficient estimates from a UNIDIFF model, together with confidence bars
based on quasi-standard errors or &ldquo;traditional&rdquo; standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unidiff'
plot(x, what = c("layer.coef", "phi", "maor"),
     se.type = c("quasi.se", "se"),
     conf.int = 0.95, numeric.auto = TRUE, type = "p",
     xlab = names(dimnames(x$data))[3], ylab = NULL,
     add = FALSE, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.unidiff_+3A_x">x</code></td>
<td>
<p>an object resulting from a call to <code><a href="#topic+unidiff">unidiff</a></code></p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_what">what</code></td>
<td>
<p>&ldquo;layer.coefficient&rdquo; to plot the layer coefficients in the log odds ratio
scale, with a reference of 1 for the first layer; &ldquo;phi&rdquo; to plot the intrinsic
association coefficient (on the log odds ratio scale); &ldquo;maor&rdquo; to plot the
mean absolute odds ratio (see <code><a href="#topic+maor">maor</a></code>).</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_se.type">se.type</code></td>
<td>
<p>whether to use quasi-standard errors or &ldquo;traditional&rdquo; standard errors
to compute confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_conf.int">conf.int</code></td>
<td>
<p>the confidence level to retain for confidence bars.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_numeric.auto">numeric.auto</code></td>
<td>
<p>whether layer names should be converted to numeric values when possible
(see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_type">type</code></td>
<td>
<p>what type of plot should be drawn: see <code><a href="graphics.html#topic+plot">plot</a></code>. Set to &ldquo;o&rdquo; or
&ldquo;b&rdquo; join points with lines.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis: see see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis: see see <code><a href="graphics.html#topic+title">title</a></code>; if <code>NULL</code>, an
appropriate default is used.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_add">add</code></td>
<td>
<p>whether to create a new plot using <code><a href="graphics.html#topic+plot">plot</a></code>, or draw over the existing
plot by calling <code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+segments">segments</a></code> directly.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.unidiff_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>numeric.auto = TRUE</code> and layer names (issued from the <code><a href="base.html#topic+dimnames">dimnames</a></code> of the third
dimension of the original table) can be converted to numeric (i.e. they consist of figures),
the position of points on the x axis will be determined by the value of the name. This makes most
sense when layers represent years, especially when they are not regularly spaced. If this behaviour
is disabled, layers will be placed regularly on the x axis, disregarding their possible interpretation
as numeric values.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unidiff">unidiff</a></code>, <code><a href="#topic+summary.unidiff">summary.unidiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See ?unidiff
</code></pre>

<hr>
<h2 id='ras'>
RAS/Deming-Stephan Algorithm for Raking Tables
</h2><span id='topic+ras'></span>

<h3>Description</h3>

<p>Adjust a table by multiplying rows and columns in order to reproduce the provided margins,
preserving all the odds ratios. This procedure is know as the RAS or Deming-Stephan algorithm,
as iterative proportional fitting (IPF) or as biproportional fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras(tab, row, col, tolerance = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ras_+3A_tab">tab</code></td>
<td>
<p>a two-way table with only positive or zero entries</p>
</td></tr>
<tr><td><code id="ras_+3A_row">row</code></td>
<td>
<p>a vector of strictly positive elements containing the wanted row margins (sums).</p>
</td></tr>
<tr><td><code id="ras_+3A_col">col</code></td>
<td>
<p>a vector of strictly positive elements containing the wanted column margins (sums).</p>
</td></tr>
<tr><td><code id="ras_+3A_tolerance">tolerance</code></td>
<td>
<p>the convergence criterion to stop iterating.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>sum(row)</code> must be equal to <code>sum(col)</code> for the algorithm to make sense.
</p>


<h3>Value</h3>

<p>The adjusted table with row sums equal to <code>row</code> and column sums equal to <code>col</code>.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>

<hr>
<h2 id='rc'>Fitting Row-Column Association Models</h2><span id='topic+rc'></span><span id='topic+print.rc'></span><span id='topic+print.rc.symm'></span>

<h3>Description</h3>

<p>Fit log-multiplicative row-column association models, also called RC(M) models or Goodman's (1979) Model II,
with one or several dimensions. Supported variants (for square tables) include symmetric (homogeneous)
row and column scores, possibly combined with separate diagonal parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc(tab, nd = 1, symmetric = FALSE, diagonal = FALSE,
   weighting = c("marginal", "uniform", "none"),
   rowsup = NULL, colsup = NULL,
   se = c("none", "jackknife", "bootstrap"),
   nreplicates = 100, ncpus = getOption("boot.ncpus"),
   family = poisson, weights = NULL,
   start = NULL, etastart = NULL, tolerance = 1e-8,
   iterMax = 5000, trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc_+3A_tab">tab</code></td>
<td>
<p> a two-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above two will be collapsed.</p>
</td></tr>
<tr><td><code id="rc_+3A_nd">nd</code></td>
<td>
<p> the number of dimensions to include in the model. Cannot exceed
<code>min(nrow(tab) - 1, ncol(tab) - 1)</code> if <code>symmetric</code> is <code>FALSE</code> (saturated model),
and twice this threshold otherwise (quasi-symmetry model).</p>
</td></tr>
<tr><td><code id="rc_+3A_symmetric">symmetric</code></td>
<td>
<p> should row and column scores be constrained to be equal? Valid only for square tables.</p>
</td></tr>
<tr><td><code id="rc_+3A_diagonal">diagonal</code></td>
<td>
<p> should the model include parameters specific to each diagonal cell? This amounts to
taking quasi-independence, rather than independence, as the baseline model. Valid only for square tables.</p>
</td></tr>
<tr><td><code id="rc_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="rc_+3A_rowsup">rowsup</code></td>
<td>
<p> if present, a matrix with the same columns as <code>tab</code> giving supplementary (passive) rows.
If <code>symmetric = TRUE</code>, <code>rowsup</code> and <code>colsup</code> must be specified together and
rows of <code>rowsup</code> must correspond to columns of <code>colsup</code>.</p>
</td></tr>
<tr><td><code id="rc_+3A_colsup">colsup</code></td>
<td>
<p> if present, a matrix with the same rows as <code>tab</code> giving supplementary (passive) columns.
See <code>rowsup</code>.</p>
</td></tr>
<tr><td><code id="rc_+3A_se">se</code></td>
<td>
<p> which method to use to compute standard errors for parameters (see <code><a href="#topic+se.assoc">se.assoc</a></code>).</p>
</td></tr>
<tr><td><code id="rc_+3A_nreplicates">nreplicates</code></td>
<td>
<p> the number of bootstrap replicates, if enabled.</p>
</td></tr>
<tr><td><code id="rc_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="rc_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="rc_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="rc_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> to use optimal starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="rc_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="rc_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="rc_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="rc_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="rc_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="rc_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits log-multiplicative row-column association models, usually called (after
Goodman) RC(M) models, typically following the equation:
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ij} = \lambda + \lambda^I_i + \lambda^J_j + \sum_{m=1}^M { \phi_{m} \mu_{im} \nu_{jm} } </code>
</p>

<p>where <code class="reqn">F_{ij}</code> is the expected frequency for the cell at the intersection of row i and column j of
<code>tab</code>, and M the number of dimensions. See references for detailed information about the
variants of the model, the degrees of freedom and the identification constraints applied to the scores.
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply ensures correct start values are used, in addition to allowing for identification
of scores even with several dimensions, computation of their jackknife or bootstrap standard errors, and plotting.
The default starting values for association parameters are computed using a singular/eigen value decomposition
from the results of the model without association component (&ldquo;base model&rdquo;). In some complex cases, using
<code>start = NULL</code> to start with random values can be more efficient, but it is also less stable and can converge
to non-optimal solutions.
</p>


<h3>Value</h3>

<p>A <code>rc</code> object, with all the components of a <code><a href="igraph.html#topic+gnm">gnm</a></code> object, plus an
<code>assoc.rc</code> component holding the most relevant association information:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>The name of the weighting method used, reflected by <code>row.weights</code>
and <code>col.weights</code>.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The variance-covariance matrix for phi coefficients and normalized row and column
scores. Only present if <code>se</code> was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>adj.covmats</code></td>
<td>
<p>An array stacking on its third dimension one variance-covariance matrix for
the adjusted scores of each layer in the model (used for plotting). Only present if <code>se</code>
was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>
<p>The method used to compute the variance-covariance matrix (corresponding to the
<code>se</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Goodman, L.A. (1979). Simple Models for the Analysis of Association in Cross-Classifications
having Ordered Categories. <em>J. of the Am. Stat. Association</em> 74(367), 537-552.
</p>
<p>Becker, M.P., and Clogg, C.C. (1989). Analysis of Sets of Two-Way Contingency Tables Using
Association Models. <em>Journal of the American Statistical Association</em> 84(405), 142-151.
</p>
<p>Goodman, L.A. (1985). The Analysis of Cross-Classified Data Having Ordered and/or Unordered
Categories: Association Models, Correlation Models, and Asymmetry Models for Contingency
Tables With or Without Missing Entries. <em>The Annals of Statistics</em> 13(1), 10-69.
</p>
<p>Goodman, L.A. (1991). Measures, Models, and Graphical Displays in the Analysis of
Cross-Classified Data. <em>J. of the Am. Stat. Association</em> 86(416), 1085-1111.
</p>
<p>Clogg, C.C., and Shihadeh, E.S. (1994). Statistical Models for Ordinal Variables. Sage: Advanced
Quantitative Techniques in the Social Sciences (4).
</p>
<p>Wong, R.S-K. (2010). Association models. SAGE: Quantitative Applications in the Social Sciences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rc">plot.rc</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Goodman (1991), Table 17.1 (p. 1097)
  data(criminal)
  model &lt;- rc(criminal)

  model$assoc # These are the phi (.07), mu and nu
  model$assoc$row[,1,1] * model$assoc$phi[1,1] # These are the mu'
  model$assoc$col[,1,1] * model$assoc$phi[1,1] # These are the nu'

  ## Becker &amp; Clogg (1989), Table 5 (p. 145)
  # See also ?rcL to run all models in one call
  ## Not run: 
  data(color)

  # "Uniform weights" in the authors' terms mean "no weighting" for us
  # See ?rcL for average marginals
  caithness.unweighted &lt;- rc(color[,,1], nd=2, weighting="none",
                             se="jackknife")
  caithness.marginal &lt;- rc(color[,,1], nd=2, weighting="marginal",
                           se="jackknife")
  aberdeen.unweighted &lt;- rc(color[,,2], nd=2, weighting="none",
                            se="jackknife")
  aberdeen.marginal &lt;- rc(color[,,2], nd=2, weighting="marginal",
                          se="jackknife")

  caithness.unweighted
  caithness.marginal
  aberdeen.unweighted
  aberdeen.marginal

  # To see standard errors, either:
  se(caithness.unweighted)

  # and so on...
  # (ours are much smaller for the marginal-weighted case)
  # Or:
  summary(caithness.unweighted)
  
## End(Not run)


  ## Clogg &amp; Shihadeh (1994), Tables 3.5a and b (p. 55-61)
  data(gss88)
  model &lt;- rc(gss88)

  # Unweighted scores
  summary(model, weighting="none")
  # Marginally weighted scores
  summary(model, weighting="marginal")
  # Uniformly weighted scores
  summary(model, weighting="uniform")


  ## Wong (2010), Table 2.7 (p. 48-49)
  ## Not run: 
  data(gss8590)

  # The table used in Wong (2001) is not perfectly consistent
  # with that of Wong (2010)
  tab &lt;- margin.table(gss8590[,,c(2,4)], 1:2)
  tab[2,4] &lt;- 49

  model &lt;- rc(tab, nd=2, weighting="none", se="jackknife")

  model
  summary(model) # Jackknife standard errors are slightly different
                 # from their asymptotic counterparts

  # Compare with bootstrap standard errors
  model2 &lt;- rc(tab, nd=2, weighting="none", se="bootstrap")
  plot(model, conf.int=0.95)
  summary(model2)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='rcL'>Fitting Row-Column Association Models With Layer Effect</h2><span id='topic+rcL'></span><span id='topic+print.rcL'></span><span id='topic+print.rcL.symm'></span>

<h3>Description</h3>

<p>Fit log-multiplicative row-column association models with layer effect, also called RC(M)-L models,
with one or several dimensions. Supported variants include homogeneous or heterogeneous scores over
the layer variable, and (for square tables) symmetric (homogeneous) row and column scores, possibly
combined with separate diagonal parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcL(tab, nd = 1,
    layer.effect = c("homogeneous.scores", "heterogeneous", "none"),
    symmetric = FALSE,
    diagonal = c("none", "heterogeneous", "homogeneous"),
    weighting = c("marginal", "uniform", "none"),
    se = c("none", "jackknife", "bootstrap"),
    nreplicates = 100, ncpus = getOption("boot.ncpus"),
    family = poisson, weights = NULL,
    start = NULL, etastart = NULL, tolerance = 1e-8,
    iterMax = 5000, eliminate=NULL,
    trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcL_+3A_tab">tab</code></td>
<td>
<p> a three-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above three will be collapsed.</p>
</td></tr>
<tr><td><code id="rcL_+3A_nd">nd</code></td>
<td>
<p> the number of dimensions to include in the model. Cannot exceed
<code>min(nrow(tab) - 1, ncol(tab) - 1)</code> if <code>symmetric</code> is <code>FALSE</code> (saturated model),
and twice this threshold otherwise (quasi-symmetry model).</p>
</td></tr>
<tr><td><code id="rcL_+3A_layer.effect">layer.effect</code></td>
<td>
<p> determines the form of the interaction between row-column association and layers.
See &ldquo;Details&rdquo; below.</p>
</td></tr>
<tr><td><code id="rcL_+3A_symmetric">symmetric</code></td>
<td>
<p> should row and column scores be constrained to be equal? Valid only for square tables.</p>
</td></tr>
<tr><td><code id="rcL_+3A_diagonal">diagonal</code></td>
<td>
<p> what type of diagonal-specific parameters to include in the model, if any. This amounts to
taking quasi-conditional independence, rather than conditional independence, as the baseline model.
Valid only for square tables.</p>
</td></tr>
<tr><td><code id="rcL_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="rcL_+3A_se">se</code></td>
<td>
<p> which method to use to compute standard errors for parameters.</p>
</td></tr>
<tr><td><code id="rcL_+3A_nreplicates">nreplicates</code></td>
<td>
<p> the number of bootstrap replicates, if enabled.</p>
</td></tr>
<tr><td><code id="rcL_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="rcL_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="rcL_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="rcL_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> to use optimal starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="rcL_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="rcL_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="rcL_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="rcL_+3A_eliminate">eliminate</code></td>
<td>
<p> either <code>NULL</code> (the default) to estimate all parameters, <code>NA</code>
to skip the estimation of some parameters for increased efficiency, or the name of a
factor to be passed as <code><a href="igraph.html#topic+gnm">gnm</a></code>'s corresponding argument.</p>
</td></tr>
<tr><td><code id="rcL_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="rcL_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="rcL_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits log-multiplicative row-column association models with layer effect, usually called (after
Wong) RC(M)-L models, typically following the equation:
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ijk} = \lambda + \lambda^I_i + \lambda^J_j + \lambda^K_k
                       + \lambda^{IK}_{ik} + \lambda^{JK}_{jk}
                       + \sum_{m=1}^M { \phi_{mk} \mu_{imk} \nu_{jmk} } </code>
</p>

<p>where <code class="reqn">F_{ijk}</code> is the expected frequency for the cell at the intersection of row i, column j and layer k of
<code>tab</code>, and M the number of dimensions. If <code>layer.effect</code> is set to &lsquo;heterogeneous&rsquo;, different scores
will be computed for each level, which is equivalent to fitting separate RC(M) models on the k two-way tables.
If it is set to &lsquo;homogeneous.scores&rsquo;, then <code class="reqn">\mu_{imk} = \mu_{mk}</code> and <code class="reqn">\nu_{imk} = \nu_{im}</code> for all
layers k: only the <code class="reqn">\phi_{mk}</code> are allowed to vary across layers. If it is set to &lsquo;none&rsquo;, then in addition
to the previous conditions all <code class="reqn">\phi_{mk}</code> are forced to be equal for all layers k, which amounts to a stability
of the association across layers. See references for detailed information about the variants of the model, the degrees
of freedom and the identification constraints applied to the scores.
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply ensures correct start values are used, in addition to allowing for identification
of scores even with several dimensions, computation of their jackknife or bootstrap standard errors, and plotting.
The default starting values for association parameters are computed using a singular/eigen value decomposition
from the results of the model without association component (&ldquo;base model&rdquo;). In some complex cases, using
<code>start = NULL</code> to start with random values can be more efficient, but it is also less stable and can converge
to non-optimal solutions.
</p>


<h3>Value</h3>

<p>A <code>rcL</code> object, with all the components of a <code><a href="igraph.html#topic+gnm">gnm</a></code> object, plus an
<code>assoc</code> component holding the most relevant association information:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension and per layer.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>The name of the weighting method used, reflected by <code>row.weights</code>
and <code>col.weights</code>.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The variance-covariance matrix for phi coefficients and normalized row and column
scores. Only present if <code>se</code> was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>adj.covmats</code></td>
<td>
<p>An array stacking on its third dimension one variance-covariance matrix for
the adjusted scores of each layer in the model (used for plotting). Only present if <code>se</code>
was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>
<p>The method used to compute the variance-covariance matrix (corresponding to the
<code>se</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Wong, R.S-K. (2010). Association models. SAGE: Quantitative Applications in the Social Sciences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rcL">plot.rcL</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Becker &amp; Clogg (1989), Table 5 (p. 145)
  # See also ?rc for more details
  ## Not run: 
  data(color)

  # "Uniform weights" in the authors' terms mean "no weighting" for us,
  # and "average marginals" means "marginal" with rcL
  # See ?rc for "marginals"
  unweighted &lt;- rcL(color, nd=2, weighting="none",
                    layer.effect="heterogeneous", se="jackknife")
  marginal &lt;- rcL(color, nd=2, weighting="marginal",
                  layer.effect="heterogeneous", se="jackknife")
  unweighted
  marginal

  # (our standard errors are much smaller for the marginal-weighted case)
  summary(unweighted)
  summary(marginal)

  opar &lt;- par(mfrow=c(1, 2))
  plot(marginal, layer="Caithness", conf.int=0.95)
  plot(marginal, layer="Aberdeen", conf.int=0.95)
  par(opar)
  
## End(Not run)


  ## Wong (2010), Table 4.6 (p. 103), model 9
  ## Not run: 
  data(gss7590)

  model &lt;- rcL(gss7590, nd=2, weighting="none", se="jackknife")

  model
  summary(model) # Jackknife standard errors are slightly different
                 # from their asymptotic counterparts

  # See ?plot.rcL for plotting
  
## End(Not run)
</code></pre>

<hr>
<h2 id='rcL.trans'>Fitting Row-Column Association Models With Transitional Layer Effect</h2><span id='topic+rcL.trans'></span>

<h3>Description</h3>

<p>Fit log-multiplicative row-column association models with transitional layer effect,
which are related to the RC(M)-L model, with one or several dimensions. Supported
variants include (for square tables) symmetric (homogeneous) row and column scores,
possibly combined with separate diagonal parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcL.trans(tab, nd = 1,
          symmetric = FALSE,
          diagonal = c("none", "heterogeneous", "homogeneous"),
          weighting = c("marginal", "uniform", "none"),
          se = c("none", "jackknife", "bootstrap"),
          nreplicates = 100, ncpus = getOption("boot.ncpus"),
          family = poisson, weights = NULL,
          start = NULL, etastart = NULL, tolerance = 1e-8,
          iterMax = 5000, trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcL.trans_+3A_tab">tab</code></td>
<td>
<p> a three-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above three will be collapsed.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_nd">nd</code></td>
<td>
<p> the number of dimensions to include in the model. Cannot exceed
<code>min(nrow(tab) - 1, ncol(tab) - 1)</code> if <code>symmetric</code> is <code>FALSE</code> (saturated model),
and twice this threshold otherwise (quasi-symmetry model).</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_symmetric">symmetric</code></td>
<td>
<p> should row and column scores be constrained to be equal? Valid only for square tables.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_diagonal">diagonal</code></td>
<td>
<p> what type of diagonal-specific parameters to include in the model, if any. This amounts to
taking quasi-conditional independence, rather than conditional independence, as the baseline model.
Valid only for square tables.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_se">se</code></td>
<td>
<p> which method to use to compute standard errors for parameters.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_nreplicates">nreplicates</code></td>
<td>
<p> the number of bootstrap replicates, if enabled.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> to use optimal starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="rcL.trans_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits log-multiplicative row-column association models with regression-type layer effect which are
<strong>experimental</strong> models combining the principles behind RC(M)-L (Wong, 2010; see <code><a href="#topic+rcL">rcL</a></code>) and regression-type
models (Goodman &amp; Hout, 1998). More specifically, like RC(M)-L models, row and column scores are allowed to vary across
a layer variable, and the pattern of this variation follows the regression-type inspiration: for each dimension, a set of
scores describes the first layer, another set describes the total variation of these scores need to describe the
association observed for the last layer, and one parameter per layer describes the position of the layer between the
first and the last layer. Compared with the RC(M)-L model with homogeneous scores across layers, this models allows
for a finer description of changes since the ordering and distances of categories on a dimension are allowed to vary,
and not only the general strength of the association. It is designed to describe transitions from one state to another,
and is best suited for ordered layer variables like time (though the model is not sensitive to reordering of the layers).
</p>
<p>The general equation of the model is:
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ijk} = \lambda + \lambda^I_i + \lambda^J_j + \lambda^K_k
               + \lambda^{IK}_{ik} + \lambda^{JK}_{jk}
               + \sum_{m=1}^M { \phi_{mk} (\mu^S_{im} + \psi_{mk} \mu^V_{im}) (\nu^S_{jm} + \psi_{mk} \nu^V_{jm}) }</code>
</p>

<p>where <code class="reqn">F_{ijk}</code> is the expected frequency for the cell at the intersection of row i, column j and layer k of
<code>tab</code>, and M the number of dimensions. The <code class="reqn">\psi_{mk}</code> parameter is constrained to be positive, equal to 0
for the first layer (<code class="reqn">m = 1</code>), and equal to 1 for the last layer.
</p>
<p>This model should not be confused with another combination of RC(M) models with the regression-type approach,
presented by Goodman &amp; Hout (1998:180), in which two separate RC(M) associations are used to describe respectively
the stable and the varying components. In the present model, row and column scores for both components are summed
<em>before</em> entering the multiplicative interaction, which means only one RC(M) association exists.
</p>
<p>The returned object is a generic <code>rcL</code> association model describing the fitted scores for each layer. To analyze
more specifically the variation of each (normalized) score from the first to the last layer, use:
<code>model$assoc$row[,,dim(model$assoc$row)[3]] - model$assoc$row[,,1]</code>
(and similarly for column scores).
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply ensures correct start values are used, in addition to allowing for identification
of scores even with several dimensions, computation of their jackknife or bootstrap standard errors, and plotting.
The default starting values are taken from a model with a stable RC(M) association (&ldquo;base model&rdquo;). In some
complex cases, using <code>start = NULL</code> to get random starting values can be more efficient, but it is also
less stable and can converge to non-optimal solutions.
</p>


<h3>Value</h3>

<p>A <code>rcL</code> object, with all the components of a <code><a href="igraph.html#topic+gnm">gnm</a></code> object, plus an
<code>assoc</code> component holding the most relevant association information:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension and per layer.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>The name of the weighting method used, reflected by <code>row.weights</code>
and <code>col.weights</code>.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The variance-covariance matrix for phi coefficients and normalized row and column
scores. Only present if <code>se</code> was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>adj.covmats</code></td>
<td>
<p>An array stacking on its third dimension one variance-covariance matrix for
the adjusted scores of each layer in the model (used for plotting). Only present if <code>se</code>
was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>
<p>The method used to compute the variance-covariance matrix (corresponding to the
<code>se</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Goodman, L.A., and Hout, M. (1998). Statistical Methods and Graphical Displays for Analyzing How the Association
Between Two Qualitative Variables Differs Among Countries, Among Groups, Or Over Time: A Modified Regression-Type
Approach. <em>Sociological Methodology</em> 28(1), 175-230.
Wong, R.S-K. (2010). Association models. SAGE: Quantitative Applications in the Social Sciences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rcL">plot.rcL</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>

<hr>
<h2 id='RCTrans'>Specify a Row-Column Association With Transitional Layer Effect in a gnm Model Formula</h2><span id='topic+RCTrans'></span><span id='topic+RCTransSymm'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify a log-multiplicative row-column association models with transitional
layer effect with one or several dimensions in the formula argument to <code><a href="igraph.html#topic+gnm">gnm</a></code>. <code>RCTransSymm</code>
allows specifying a variant with symmetric (homogeneous) row and column scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RCTrans(row, col, layer, inst = NULL)
  RCTransSymm(row, col, layer, inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RCTrans_+3A_row">row</code></td>
<td>
<p>the levels of the row variable</p>
</td></tr>
<tr><td><code id="RCTrans_+3A_col">col</code></td>
<td>
<p>the levels of the column variable</p>
</td></tr>
<tr><td><code id="RCTrans_+3A_layer">layer</code></td>
<td>
<p>the levels of the layer variable</p>
</td></tr>
<tr><td><code id="RCTrans_+3A_inst">inst</code></td>
<td>
<p>a positive integer specifying the instance number of the term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+rcL.trans">rcL.trans</a></code> to fit an experimental model.
</p>
<p><code>RCTrans</code> combines its arguments in the following way:
</p>
<p style="text-align: center;"><code class="reqn"> RCTrans(i, j, k) = (\mu^S_i + \psi_k \mu^V_i) (\nu^S_j + \psi_k \nu^V_j)</code>
</p>

<p>where <code class="reqn">RCTrans(i, j, k)</code> is the skew association for the cell at the intersection of row i, column j
and layer k of the table.
</p>
<p><code>RCTransSymm</code> is similar, but forces <code class="reqn">\mu^S_i</code> and <code class="reqn">\nu^S_i</code> (respectively <code class="reqn">\mu^V_i</code> and
<code class="reqn">\nu^V_i</code>) to be equal for identical values of i (diagonal cells).
</p>


<h3>Value</h3>

<p>A list with the required components of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> the expressions passed to <code>Mult</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical expression
of the term, given labels for the predictors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the call to use as a prefix for parameter labels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcL.trans">rcL.trans</a></code>
</p>

<hr>
<h2 id='se.assoc'>Standard Errors for Association Models</h2><span id='topic+se'></span><span id='topic+se.assoc'></span><span id='topic+se.rc'></span><span id='topic+se.hmskew'></span><span id='topic+se.yrcskew'></span><span id='topic+se.rcL'></span><span id='topic+se.hmskewL'></span>

<h3>Description</h3>

<p>Get standard errors for log-multiplicative association scores and intrinsic
association coefficients.</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x, ...)

## S3 method for class 'assoc'
se(x, type = c("se", "quasi.se"), ...)

## S3 method for class 'rc'
se(x, type = c("se", "quasi.se"), ...)

## S3 method for class 'hmskew'
se(x, type = c("se", "quasi.se"), ...)

## S3 method for class 'yrcskew'
se(x, type = c("se", "quasi.se"), ...)

## S3 method for class 'rcL'
se(x, type = c("se", "quasi.se"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.assoc_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+assoc">assoc</a></code> object with a non-null <code>covmat</code> component (for <code>se.assoc</code>);.
or a <code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="#topic+hmskewL">hmskewL</a></code>, <code><a href="#topic+yrcskew">yrcskew</a></code>,
<code><a href="#topic+rcL">rcL</a></code> or <code><a href="#topic+rcL.trans">rcL.trans</a></code> object fitted with the <code>se</code> argument different
from &ldquo;none&rdquo; (for other functions).</p>
</td></tr>
<tr><td><code id="se.assoc_+3A_type">type</code></td>
<td>
<p>the type of standard errors to be computed (see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="se.assoc_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only jackknife or bootstrap standard errors are supported, depending on the <code>se</code> argument
passed when fitting the model. <strong>Some care is needed before using such standard errors and confidence
intervals</strong>. First one must ensure all model replicates converged to a correct solution, especially for bootstrap;
second, when relying on normal confidence intervals computed from these standard errors, one must ensure that the
coefficients estimators follow a normal distribution. Both checks can be performed by calling
<code><a href="boot.html#topic+plot.boot">plot.boot</a></code> on the <code>boot.results</code> component of the <code>assoc</code> object of the models (not
supported for jackknife), with the <code>index</code> argument identifying the coefficient of interest (call <code>colnames</code>
on the <code>t</code> member of the <code>boot.results</code> object to find out the index you need).
</p>
<p>If outliers are present, standard errors and confidence intervals will be artificially large; to fix this, the
<code>tolerance</code> argument must be set to a smaller value when fitting the models (which may in turn require
increasing the value of the <code>iterMax</code> argument if convergence is too slow). Once outliers are removed, if
coefficient estimates are still not normally distributed, robust bootstrap confidence intervals can be computed
using <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> on the same object, provided a large number of replicates (&gt; 1000) were computed.
</p>
<p>For each replicate, stable scores and intrinsic association coefficients are identified using an orthogonal
Procrustes analysis to suppress meaningless variations due to random reflections, permutations and rotations of
dimensions (Milan &amp; Whittaker, 1995). For <code><a href="#topic+hmskew">hmskew</a></code> and <code><a href="#topic+hmskewL">hmskewL</a></code> models, a rotation within
each pair of dimensions and a permutation of pairs of dimensions is performed, but no reflection as it would change
the sign of intrinsic association coefficients.
</p>
<p>Quasi-standard errors are computed using <code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code>. See the help page for this function for
details and references about them.
</p>


<h3>Value</h3>

<p>An object of the same form as the <code>assoc</code> component of the model, but with standard errors rather than
the corresponding coefficients.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Milan, L., and J. Whittaker (1995). Application of the Parametric Bootstrap to Models that Incorporate a Singular
Value Decomposition. <em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em> 44(1), 31-49.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>, <code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="#topic+hmskewL">hmskewL</a></code>, <code><a href="#topic+yrcskew">yrcskew</a></code>,
<code><a href="#topic+rcL">rcL</a></code>, <code><a href="#topic+rcL.trans">rcL.trans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See ?rc about Wong (2010)
</code></pre>

<hr>
<h2 id='summary.anoas'>Summary and Print Methods for ANOAS objects</h2><span id='topic+summary.anoas'></span><span id='topic+print.anoas'></span><span id='topic+print.summary.anoas'></span>

<h3>Description</h3>

<p>These functions print the summary of a list of models fitted using the <code><a href="#topic+anoas">anoas</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anoas'
summary(object, ...)

## S3 method for class 'anoas'
print(x, ...)

## S3 method for class 'summary.anoas'
print(x, digits = 1, nsmall = 2, scientific = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.anoas_+3A_object">object</code></td>
<td>
<p> an <code>anoas</code> object.</p>
</td></tr>
<tr><td><code id="summary.anoas_+3A_x">x</code></td>
<td>
<p> an <code>anoas</code> object.</p>
</td></tr>
<tr><td><code id="summary.anoas_+3A_digits">digits</code></td>
<td>
<p> See ?format.</p>
</td></tr>
<tr><td><code id="summary.anoas_+3A_nsmall">nsmall</code></td>
<td>
<p> See ?format.</p>
</td></tr>
<tr><td><code id="summary.anoas_+3A_scientific">scientific</code></td>
<td>
<p> See ?format.</p>
</td></tr>
<tr><td><code id="summary.anoas_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to further methods (ignored by <code>summary.anoas</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to most analyses of association in the literature, this function currently does not fit uniform association model
(&ldquo;U&rdquo;), nor separate models with only row and column association (&ldquo;R&rdquo; and &ldquo;C&rdquo; models), nor log-linear
row and column association models.
</p>
<p>Currently, no significance test is performed on the models. Please note that it is not correct to test the one-dimension
association model against the independence model.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns:
</p>
<table>
<tr><td><code>Res. Df</code></td>
<td>
<p> the residual number of degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>Res. Dev</code></td>
<td>
<p> the residual deviance of the model (likelihood ratio Chi-squared statistic, or L-squared).</p>
</td></tr>
<tr><td><code>Dev. Indep. (%)</code></td>
<td>
<p> the ratio of the residual deviance of the model over that of the independence model,
times 100. This measures the share of departure from independence that cannot be explained using the
number of dimensions of the model.</p>
</td></tr>
<tr><td><code>Dissim. (%)</code></td>
<td>
<p> the dissimilarity index of the model's fitted values with regard to the observed data.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p> the Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p> Akaike's An Information Criterion for the model.</p>
</td></tr>
<tr><td><code>Deviance</code></td>
<td>
<p> the reduction in deviance of the model compared to the previous one</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p> the reduction in the number of degrees of freedom of the model compared to the previous one.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anoas">anoas</a></code>, <code><a href="#topic+anoasL">anoasL</a></code>
</p>

<hr>
<h2 id='summary.assoc'>
Summarize Association Model Fits
</h2><span id='topic+summary.assocmod'></span><span id='topic+print.summary.assocmod'></span>

<h3>Description</h3>

<p><code>summary</code> method for objects of class <code>assocmod</code>, including <code><a href="#topic+rc">rc</a></code>,
<code><a href="#topic+rcL">rcL</a></code>, <code><a href="#topic+rcL.trans">rcL.trans</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="#topic+hmskewL">hmskewL</a></code>
and <code><a href="#topic+yrcskew">yrcskew</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assocmod'
summary(object, weighting, ...)

## S3 method for class 'summary.assocmod'
print(x, digits = max(3, getOption("digits") - 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.assoc_+3A_object">object</code></td>
<td>
<p>an association model of class <code>assocmod</code>.</p>
</td></tr>
<tr><td><code id="summary.assoc_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.gnm</code>.</p>
</td></tr>
<tr><td><code id="summary.assoc_+3A_weighting">weighting</code></td>
<td>
<p>what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="summary.assoc_+3A_digits">digits</code></td>
<td>
<p>the number of siginificant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.assoc_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> by
<code>print.summary.assocmod</code>, and currently ignored by <code>summary.assocmod</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.assocmod</code> prints the original call to <code>assoc</code>; a
summary of the deviance residuals from the model fit; the coefficients of
interest of the model; the residual deviance; the residual degrees of freedom; 
the Schwartz's Bayesian Information Criterion value; the Akaike's An Information
Criterion value.
</p>
<p>Association coefficients are printed with their standard errors, p-values and significance
stars. The &ldquo;Normalized&rdquo; columns contains <em>normalized scores</em>, i.e. their (weighted)
sum is 0, their (weighted) sum of squares is 1, and their (weighted) cross-dimensional
correlation is null. For models with only one layer (<code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>,
<code><a href="#topic+yrcskew">yrcskew</a></code>), <em>adjusted</em> scores are printed in the &ldquo;Adjusted&rdquo; column:
these correspond to normalized scores times the square root of the corresponding intrinsic
association parameter (phi).
</p>
<p>p-values correspond to normalized scores, and are computed under the assumption that estimators
of coefficients are normally distributed, even if jackknife of bootstrap are used. See
<code><a href="#topic+se.assoc">se.assoc</a></code> for details about checking this assumption and the validity of jackknife
or bootstrap results.
</p>
<p>Note that setting the <code>weighting</code> argument to a value different from that used at the
time of the fit discards the computed standard errors, if any.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.assoc</code>, with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code>call</code> component from object.</p>
</td></tr>
<tr><td><code>diagonal</code></td>
<td>
<p>the <code>diagonal</code> component from the object's <code>assoc</code> component.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals, see <code><a href="stats.html#topic+residuals.glm">residuals.glm</a>.</code></p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix holding the association coefficients estimates, standard
errors and p-values.</p>
</td></tr>
<tr><td><code>diagonal</code></td>
<td>
<p>a matrix holding the diagonal coefficients, if any.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>the weigthing method used when normalizing the scores.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the <code>deviance</code> component from object.</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>the Pearson Chi-squared statistic for the model fit.</p>
</td></tr>
<tr><td><code>dissim</code></td>
<td>
<p>the dissimilarity index for the model fit.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the <code>df.residual</code> component from object.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the value of the BIC for the model fit (contrary to the value reported by
<code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>, the reference is 0 for the
saturated model).</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the value of the AIC for the model fit (contrary to the value reported by
<code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>, the reference is 0 for the
saturated model).</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code>family</code> component from object.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated dispersion</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a 3-vector of the rank of the model; the number of residual
degrees of freedom; and number of unconstrained coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>, <code><a href="#topic+plot.assoc">plot.assoc</a></code>, <code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+rcL">rcL</a></code>,
<code><a href="#topic+rcL.trans">rcL.trans</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="#topic+hmskewL">hmskewL</a></code>, <code><a href="#topic+yrcskew">yrcskew</a></code>
</p>

<hr>
<h2 id='summary.unidiff'>
Summarize UNIDIFF Model Fits
</h2><span id='topic+summary.unidiff'></span><span id='topic+print.summary.unidiff'></span>

<h3>Description</h3>

<p><code>summary</code> method for objects of class <code>unidiff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unidiff'
summary(object, ...)

## S3 method for class 'summary.unidiff'
print(x, digits = max(3, getOption("digits") - 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.unidiff_+3A_object">object</code></td>
<td>
<p>an object resulting from a call to <code><a href="#topic+unidiff">unidiff</a></code></p>
</td></tr>
<tr><td><code id="summary.unidiff_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.gnm</code>.</p>
</td></tr>
<tr><td><code id="summary.unidiff_+3A_digits">digits</code></td>
<td>
<p>the number of siginificant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.unidiff_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> by
<code>print.summary.unidiff</code>, and currently ignored by <code>summary.unidiff</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.unidiff</code> prints the original call to <code>unidiff</code>; a
summary of the deviance residuals from the model fit; the coefficients of
interest of the model; the residual deviance; the residual degrees of freedom; 
the Schwartz's Bayesian Information Criterion value; the Akaike's An Information
Criterion value.
</p>
<p>Layer and two-way interaction coefficients are printed with their standard errors,
quasi-standard errors (see <code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code>), p-values (based on standard
errors) and significance stars. Constrained coefficients have a value of 0 (by default),
and 0 standard errors, but still have quasi-standard errors.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.unidiff</code>, with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code>call</code> component from object.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals, see <code><a href="stats.html#topic+residuals.glm">residuals.glm</a>.</code></p>
</td></tr>
<tr><td><code>layer</code></td>
<td>
<p>a <code>data.frame</code> holding the layer coefficients estimates, standard
errors, quasi-standard errors (see <code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code>) and p-values.</p>
</td></tr>
<tr><td><code>phi.layer</code></td>
<td>
<p>a <code>data.frame</code> holding the layer coefficients estimates,
standard errors, and quasi-standard errors (see <code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code>)
multiplied by the intrinsic association coefficient (see <code><a href="#topic+maor">maor</a></code>)
for the first layer; p-values are the same as those for the &ldquo;layer&rdquo; component.</p>
</td></tr>
<tr><td><code>interaction</code></td>
<td>
<p>a <code>data.frame</code> holding the two-way interaction coefficients
estimates, standard errors and p-values.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the <code>deviance</code> component from object.</p>
</td></tr>
<tr><td><code>diagonal</code></td>
<td>
<p>the <code>diagonal</code> component from the object's <code>unidiff</code> component.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>the <code>weighting</code> component from the object's <code>unidiff</code> component.</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>the Pearson Chi-squared statistic for the model fit.</p>
</td></tr>
<tr><td><code>dissim</code></td>
<td>
<p>the dissimilarity index for the model fit.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the <code>df.residual</code> component from object.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the value of the BIC for the model fit (contrary to the value reported by
<code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>, the reference is 0 for the
saturated model).</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the value of the AIC for the model fit (contrary to the value reported by
<code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>, the reference is 0 for the
saturated model).</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code>family</code> component from object.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated dispersion</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a 3-vector of the rank of the model; the number of residual
degrees of freedom; and number of unconstrained coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unidiff">unidiff</a></code>, <code><a href="#topic+plot.unidiff">plot.unidiff</a></code>
</p>

<hr>
<h2 id='svyassocmod'>Fitting Association Models With Complex Survey Data</h2><span id='topic+svyrc'></span><span id='topic+svyhmskew'></span><span id='topic+svyyrcskew'></span><span id='topic+svyrcL'></span><span id='topic+svyrcL.trans'></span><span id='topic+svyhmskewL'></span>

<h3>Description</h3>

<p>Fit association models to data from a complex survey
design, with inverse-probability weighting and (optionally)
standard errors based on replicate weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svyrc(formula, design, nd = 1,
      symmetric = FALSE, diagonal = FALSE,
      weighting = c("marginal", "uniform", "none"),
      rowsup = NULL, colsup = NULL,
      Ntotal = nrow(design), exclude = c(NA, NaN),
      se = c("none", "replicate"),
      ncpus = getOption("boot.ncpus"),
      family = quasipoisson, weights = NULL,
      start = NULL, etastart = NULL, tolerance = 1e-8,
      iterMax = 5000, trace = FALSE, verbose = TRUE, ...)

svyhmskew(formula, design, nd.symm = NA, diagonal = FALSE,
          weighting = c("marginal", "uniform", "none"),
          rowsup = NULL, colsup = NULL,
          Ntotal = nrow(design), exclude = c(NA, NaN),
          se = c("none", "replicate"),
          ncpus = getOption("boot.ncpus"),
          family = quasipoisson, weights = NULL,
          start = NULL, etastart = NULL, tolerance = 1e-8,
          iterMax = 5000, trace = FALSE, verbose = TRUE, ...)

svyyrcskew(formula, design, nd.symm = NA, nd.skew = 1, diagonal = FALSE,
           weighting = c("marginal", "uniform", "none"),
           rowsup = NULL, colsup = NULL,
           Ntotal = nrow(design), exclude = c(NA, NaN),
           se = c("none", "replicate"),
           ncpus = getOption("boot.ncpus"),
           family = quasipoisson, weights = NULL,
           start = NA, etastart = NULL, tolerance = 1e-8,
           iterMax = 15000, trace = FALSE, verbose = TRUE, ...)

svyrcL(formula, design, nd = 1,
       layer.effect = c("homogeneous.scores",
                        "heterogeneous", "none"),
       symmetric = FALSE,
       diagonal = c("none", "heterogeneous", "homogeneous"),
       weighting = c("marginal", "uniform", "none"),
       Ntotal = nrow(design), exclude = c(NA, NaN),
       se = c("none", "replicate"),
       ncpus = getOption("boot.ncpus"),
       family = quasipoisson, weights = NULL,
       start = NULL, etastart = NULL, tolerance = 1e-8,
       iterMax = 5000, trace = FALSE, verbose = TRUE, ...)

svyrcL.trans(formula, design, nd = 1,
             symmetric = FALSE,
             diagonal = c("none", "heterogeneous", "homogeneous"),
             weighting = c("marginal", "uniform", "none"),
             Ntotal = nrow(design), exclude = c(NA, NaN),
             se = c("none", "replicate"),
             ncpus = getOption("boot.ncpus"),
             family = quasipoisson, weights = NULL,
             start = NULL, etastart = NULL, tolerance = 1e-8,
             iterMax = 5000, trace = FALSE, verbose = TRUE, ...)

svyhmskewL(formula, design, nd.symm = NA,
           layer.effect.skew = c("homogeneous.scores", "heterogeneous",
                                 "none"),
           layer.effect.symm = c("heterogeneous", "uniform",
                                 "homogeneous.scores", "none"),
           diagonal = c("none", "heterogeneous", "homogeneous"),
           weighting = c("marginal", "uniform", "none"),
           Ntotal = nrow(design), exclude = c(NA, NaN),
           se = c("none", "replicate"),
           ncpus = getOption("boot.ncpus"),
           family = quasipoisson, weights = NULL,
           start = NULL, etastart = NULL, tolerance = 1e-8,
           iterMax = 5000, trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svyassocmod_+3A_formula">formula</code></td>
<td>
<p> a formula specifying margins for the table (using &lsquo;+&rsquo; only)
on which the model will be fitted (passed to
<code><a href="survey.html#topic+svytable">svytable</a></code>); dimensions of the
resulting table must match the models expectations.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_design">design</code></td>
<td>
<p> a survey object; if <code>se == "replicate"</code>, must be of class
<code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> (see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_nd">nd</code></td>
<td>
<p> the number of dimensions to include in the model. Cannot exceed
<code>min(nrow(tab) - 1, ncol(tab) - 1)</code> if <code>symmetric</code> is <code>FALSE</code> (saturated model),
and twice this threshold otherwise (quasi-symmetry model).</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_nd.symm">nd.symm</code></td>
<td>
<p> the number of dimensions to include in the <em>symmetric</em> RC(M) association. Cannot exceed
<code>2 * min(nrow(tab) - 1, ncol(tab) - 1)</code> (quasi-symmetry model).
If <code>NA</code> (the default), a full quasi-symmetric association is used instead of a RC(M) model; if <code>0</code>,
quasi-independence is used.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_nd.skew">nd.skew</code></td>
<td>
<p> the number of dimensions to include in the <em>skew-symmetric</em> RC(M) association.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_layer.effect">layer.effect</code></td>
<td>
<p> determines the form of the interaction between row-column association and layers.
See &ldquo;Details&rdquo; below.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_layer.effect.skew">layer.effect.skew</code></td>
<td>
<p> determines the form of the interaction between skew-symmetric association and layers.
See &ldquo;Details&rdquo; below.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_layer.effect.symm">layer.effect.symm</code></td>
<td>
<p> determines the form of the interaction between symmetric row-column association,
or quasi-symmetric association (if <code>nd.symm = NA</code>) and layers. See &ldquo;Details&rdquo; below.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_symmetric">symmetric</code></td>
<td>
<p> should row and column scores be constrained to be equal? Valid only for square tables.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_diagonal">diagonal</code></td>
<td>
<p> what type of diagonal-specific parameters to include in the model, if any. Only makes sense
when <code>nd.symm</code> is not <code>NA</code> (else, diagonal parameters are already included).</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_ntotal">Ntotal</code></td>
<td>
<p> sum of counts to normalize the table to (passed to <code><a href="survey.html#topic+svytable">svytable</a></code>).
See &ldquo;Details&rdquo; below..</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_exclude">exclude</code></td>
<td>
<p> a vector of values to be exclude when building the table, passed to <code><a href="stats.html#topic+xtabs">xtabs</a></code>.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_rowsup">rowsup</code></td>
<td>
<p> if present, a matrix with the same columns as <code>tab</code> and rows corresponding to the columns
of <code>colsup</code>, giving supplementary (passive) rows.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_colsup">colsup</code></td>
<td>
<p> if present, a matrix with the same rows as <code>tab</code> and columns corresponding to the rows of
<code>colsup</code>, giving supplementary (passive) columns.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_se">se</code></td>
<td>
<p>whether to compute replicate standard errors or not (only supported for <code>svrepdesign</code> objects).</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> to use optimal starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="svyassocmod_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted to a table with probabilities estimated by
<code><a href="survey.html#topic+svytable">svytable</a></code> and (when <code>Ntotal = nrow(design)</code>)
with the sample size equal to the observed sample size, treating the
resulting table as if it came from iid multinomial sampling, as described
by Rao and Scott. This assumption affects the fit statistics but not parameter
point estimates.
</p>
<p>Standard errors that do not rely on this assumption can be computed
by fitting the model using each series of replicate weights. If your
data does not come with replicate weights, use
<code><a href="survey.html#topic+as.svrepdesign">as.svrepdesign</a></code> to create them first, and pass
the resulting <code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> object via the
<code>design</code> argument.
</p>


<h3>Value</h3>

<p>An <code>assocmod</code> object whose exact class depends on the function called.
</p>


<h3>Note</h3>

<p>Note that printed fit statistics and degrees of freedom rely on the
iid assumption. This is also the case of the variance-covariance matrix
returned by the <code><a href="gnm.html#topic+vcov.gnm">vcov.gnm</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Rao, J.N.K., Scott, A.J. (1984). On Chi-squared Tests For Multiway
Contingency Tables with Proportions Estimated From Survey Data.
<em>Annals of Statistics</em> 12, 46-60.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rc">rc</a></code>, <code><a href="#topic+hmskew">hmskew</a></code>, <code><a href="#topic+yrcskew">yrcskew</a></code>, <code><a href="#topic+rcL">rcL</a></code>,
<code><a href="#topic+rcL.trans">rcL.trans</a></code>, <code><a href="#topic+hmskewL">hmskewL</a></code>
</p>
<p><code><a href="survey.html#topic+svytable">svytable</a></code>, <code><a href="survey.html#topic+svyloglin">svyloglin</a></code>,
<code><a href="survey.html#topic+svyglm">svyglm</a></code>, <code><a href="survey.html#topic+as.svrepdesign">as.svrepdesign</a></code>
</p>

<hr>
<h2 id='svygnm'>Fitting Generalized Nonlinear Models With Complex Survey Data</h2><span id='topic+svygnm'></span><span id='topic+svygnm.svyrep.design'></span>

<h3>Description</h3>

<p>Fit association models to data from a complex survey
design, with inverse-probability weighting and (optionally)
standard errors based on replicate weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svygnm(formula, design, ...) 
## S3 method for class 'svyrep.design'
svygnm(formula, design,
    subset = NULL, data.fun = NULL, rescale = NULL, rho = NULL,
    return.replicates = FALSE, keep.weights = FALSE, na.action, 
    eliminate, ncpus = getOption("boot.ncpus"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svygnm_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the nonlinear predictor.</p>
</td></tr>
<tr><td><code id="svygnm_+3A_design">design</code></td>
<td>
<p>a survey object; if <code>se == "replicate"</code>, must be of class
<code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> (see &ldquo;Details&rdquo; below).
Must contain all variables in the formula</p>
</td></tr>
<tr><td><code id="svygnm_+3A_subset">subset</code></td>
<td>
<p>expression to select a subpopulation</p>
</td></tr>
<tr><td><code id="svygnm_+3A_data.fun">data.fun</code></td>
<td>
<p>function called on each replicate to generate the <code>data</code> argument
passed to <code><a href="gnm.html#topic+gnm">gnm</a></code>. If not <code>NULL</code>,
it will be passed <code>design</code> and <code>...</code> as arguments, and must
return a <code>data.frame</code> object. This is primarily useful to compute a
frequency table and fit log-linear models.</p>
</td></tr>
<tr><td><code id="svygnm_+3A_rescale">rescale</code></td>
<td>
<p>Rescaling of weights, to improve numerical stability. The default rescales                       weights to sum to the sample size. Use <code>FALSE</code> to not rescale weights.
For replicate-weight designs, use <code>TRUE</code> to rescale weights to sum to 1, as
was the case before version 0.7.0.</p>
</td></tr>
<tr><td><code id="svygnm_+3A_rho">rho</code></td>
<td>
<p>For replicate BRR designs, to specify the parameter for
Fay's variance method, giving weights of <code>rho</code> and <code>2-rho</code></p>
</td></tr>
<tr><td><code id="svygnm_+3A_return.replicates">return.replicates</code></td>
<td>
<p>return the replicates as a component of the result?</p>
</td></tr>
<tr><td><code id="svygnm_+3A_keep.weights">keep.weights</code></td>
<td>
<p>whether to save the weights in the <code>survey.design$pweights</code>
component of the result; note this typically uses a lot of memory.</p>
</td></tr>
<tr><td><code id="svygnm_+3A_na.action">na.action</code></td>
<td>
<p>handling of NAs</p>
</td></tr>
<tr><td><code id="svygnm_+3A_eliminate">eliminate</code></td>
<td>
<p>a factor to be included as the first term in the model.
<code><a href="gnm.html#topic+gnm">gnm</a></code> will exploit the structure of this factor to improve
computational efficiency. See details.</p>
</td></tr>
<tr><td><code id="svygnm_+3A_ncpus">ncpus</code></td>
<td>
<p>the number of CPU cores to use to run replicates. Pass <code>NULL</code> to use the actual
number of cores with an upper limit of 5.</p>
</td></tr>
<tr><td><code id="svygnm_+3A_...">...</code></td>
<td>
<p>more arguments to be passed to <code><a href="gnm.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in a similar way as <code><a href="survey.html#topic+svyglm">svyglm</a></code>,
but for generalized nonlinear models. It computes standard errors
using replicates only (i.e. no asymptotic standard errors). If your
data does not come with replicate weights, use
<code><a href="survey.html#topic+as.svrepdesign">as.svrepdesign</a></code> to create them first, and pass
the resulting <code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> object via the
<code>design</code> argument.
</p>


<h3>Value</h3>

<p>An <code>svygnm</code> object.
</p>


<h3>Note</h3>

<p>Note that printed fit statistics and degrees of freedom rely on the
iid assumption. This is also the case of the variance-covariance matrix
returned by the <code><a href="gnm.html#topic+vcov.gnm">vcov.gnm</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat, based on the <code><a href="survey.html#topic+svyglm">svyglm</a></code> function by Thomas Lumley
</p>


<h3>References</h3>

<p>Rao, J.N.K., Scott, A.J. (1984). On Chi-squared Tests For Multiway
Contingency Tables with Proportions Estimated From Survey Data.
<em>Annals of Statistics</em> 12, 46-60.
</p>


<h3>See Also</h3>

<p><code><a href="gnm.html#topic+gnm">gnm</a></code>, <code><a href="survey.html#topic+svyglm">svyglm</a></code>, <code><a href="survey.html#topic+as.svrepdesign">as.svrepdesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(survey)
  data(api)
  dstrat&lt;-svydesign(id=~1,strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)
  rstrat&lt;-as.svrepdesign(dstrat)
  glm.mod &lt;- svyglm(api00~ell+meals+mobility, design=rstrat)
  gnm.mod &lt;- svygnm(api00~ell+meals+mobility, design=rstrat, ncpus=1)
  # Both functions give the same result for GLMs
  summary(glm.mod)
  summary(gnm.mod)
  

  # GNM, can only be fitted with svygnm()
  summary(svygnm(api00~ell+meals+mobility, design=rstrat, family=poisson, ncpus=1))
</code></pre>

<hr>
<h2 id='unidiff'>
Fitting Log-Multiplicative Uniform Difference/Layer Effect Model
</h2><span id='topic+unidiff'></span>

<h3>Description</h3>

<p>Fit the log-multiplicative uniform difference model (UNIDIFF, see Erikson &amp; Goldthorpe, 1992),
also called the log-multiplicative layer effect model (Xie, 1992). For square tables, diagonal
cells can be handled separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unidiff(tab, diagonal = c("included", "excluded", "only"),
        constrain = "auto",
        weighting = c("marginal", "uniform", "none"), norm = 2,
        family = poisson,
        tolerance = 1e-8, iterMax = 5000, eliminate=NULL,
        trace = FALSE, verbose = TRUE,
        checkEstimability = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unidiff_+3A_tab">tab</code></td>
<td>
<p>a three-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above three will be collapsed as appropriate.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_diagonal">diagonal</code></td>
<td>
<p><code>included</code> fits the standard model with full two-way interaction;
<code>excluded</code> adds to this model diagonal-specific parameters for each years, effectively
removing the influence of diagonal cells on the layer coefficients; <code>only</code> fits a model
without the full two-way interaction, where only diagonal parameters are affected by the layer
effect (see &ldquo;Details&rdquo; below).</p>
</td></tr>
<tr><td><code id="unidiff_+3A_constrain">constrain</code></td>
<td>
<p>(non-eliminated) coefficients to constrain, specified by a regular expression,
a numeric vector of indices, a logical vector, a character vector of names, or &quot;[?]&quot; to
select from a Tk dialog. The default constrains to 0 the first layer parameter and
interaction coefficients for the first row and column of the table.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_weighting">weighting</code></td>
<td>
<p>what weights should be used when normalizing coefficients. This does not affect
layer coefficients, which are set to 1 for the first layer, but only two-way interaction
coefficients and layer association levels, which are layer coefficients times the intrinsic
association coefficient (see <code><a href="#topic+maor">maor</a></code>) for the first layer.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_norm">norm</code></td>
<td>
<p>the norm to use to compute the mean absolute odds ratio (see <code><a href="#topic+maor">maor</a></code>).</p>
</td></tr>
<tr><td><code id="unidiff_+3A_family">family</code></td>
<td>
<p>a specification of the error distribution and link function to be used in the model.
This can be a character string naming a family function; a family function, or the result of
a call to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="unidiff_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_eliminate">eliminate</code></td>
<td>
<p> either <code>NULL</code> (the default) to estimate all parameters, <code>NA</code>
to skip the estimation of some parameters for increased efficiency, or the name of a
factor to be passed as <code><a href="igraph.html#topic+gnm">gnm</a></code>'s corresponding argument.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_checkestimability">checkEstimability</code></td>
<td>
<p> a logical value indicating whether the estimability of the contrasts should
be checked via <code>checkEstimable</code>. Disabling this check can improve performance for large models.</p>
</td></tr>
<tr><td><code id="unidiff_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation of the fitted model is:
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ijk} = \lambda + \lambda^I_i + \lambda^J_j + \lambda^K_k
                      + \lambda^{IK}_{ik} + \lambda^{JK}_{jk}
                      + \phi_k \psi^{IJ}_{ij} </code>
</p>

<p>where <code class="reqn">F_{ijk}</code> is the expected frequency for the cell at the intersection of row i, column j and
layer k of <code>tab</code>. When <code>diagonal = "excluded"</code>, <code class="reqn">\lambda^{IJK}_{ijk}</code> parameters are added
but set to 0 when <code class="reqn">i \neq j</code> (off-diagonal). When <code>diagonal = "only"</code>, <code class="reqn">\psi^{IJ}_{ij}</code> is set
to 0 when <code class="reqn">i \neq j</code>.
</p>
<p>Note that by default <code>weighting="marginal"</code>, meaning that reported
interaction coefficients do <em>not</em> correspond to what is usually expected
in log-linear modeling. Use <code>weighting="none"</code> or <code>weighting="uniform"</code> 
to use more classic identification constraints (effects coding).
</p>
<p>Layer coefficients <code class="reqn">\phi_k</code> are internally exponentiated in the gnm formula, which means the reported
values are in log scale, with reference 0 for the first year. Interaction coefficients use the
&ldquo;sum&rdquo; contrast, also known as &ldquo;effect&rdquo; coding, except when <code>diagonal</code> is different from
<code>included</code>, in which case &ldquo;treatment&rdquo; constrast (a.k.a &ldquo;reference&rdquo; or &ldquo;dummy&rdquo;
coding) is used.
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply allows for direct identification of the log-multiplicative parameters by setting the
appropriate constraints, and improves performance by eliminating less interesting coefficients.
</p>


<h3>Value</h3>

<p>A <code>unidiff</code> object, with all the components of a <code><a href="igraph.html#topic+gnm">gnm</a></code> object, plus an
<code>unidiff</code> component holding the most relevant information:
</p>
<table>
<tr><td><code>layer</code></td>
<td>
<p>a <code>qvcalc</code> object holding the (log) layer coefficients, their standard
errors and quasi-standard errors.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the value of the intrinsic association coefficient (see <code><a href="#topic+maor">maor</a></code>) for
each layer.</p>
</td></tr>
<tr><td><code>maor</code></td>
<td>
<p>the value of the Mean absolute odds ratio (see <code><a href="#topic+maor">maor</a></code>) for
each layer.</p>
</td></tr>
<tr><td><code>interaction</code></td>
<td>
<p>a data frame object holding the two-way interaction coefficients, and their
standard errors.</p>
</td></tr>
<tr><td><code>diagonal</code></td>
<td>
<p>the value of the <code>diagonal</code> argument above.</p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p>the value of the <code>weighting</code> argument above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Erikson, R., and Goldthorpe, J.H. (1992). The Constant Flux: A Study of Class Mobility in Industrial Societies.
Oxford: Clarendon Press. Ch. 3.
</p>
<p>Xie, Yu (1992). The Log-Multiplicative Layer Effect Model for Comparing Mobility Tables. <em>Am. Sociol. Rev.</em>
57(3):380-395.
</p>
<p>Yaish, M. (1998). Opportunities, Little Change. Class Mobility in Israeli Society, 1974-1991. Ph.D. thesis,
Nuffield College, University of Oxford.
</p>
<p>Yaish, M. (2004). Class Mobility Trends in Israeli Society, 1974-1991. Lewiston: Edwin Mellen Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.unidiff">plot.unidiff</a></code>, <code><a href="#topic+summary.unidiff">summary.unidiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Yaish (1998, 2004)
  data(yaish)

  # Last layer omitted because of low frequencies
  yaish &lt;- yaish[,,-7]

  # Layer (education) must be the third dimension
  yaish &lt;- aperm(yaish, 3:1)

  model &lt;- unidiff(yaish)

  model
  summary(model)
  plot(model)

  
</code></pre>

<hr>
<h2 id='yrcskew'>Fitting Yamaguchi RC_SK Skew-Symmetric Association Model</h2><span id='topic+yrcskew'></span><span id='topic+print.yrcskew'></span>

<h3>Description</h3>

<p>Fit a skew-symmetric association model proposed in Yamaguchi (1990) to describe asymmetry of square
tables. This model can be combined with symmetric association models like a quasi-symmetry (the default)
or symmetric (homogeneous) RC(M) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yrcskew(tab, nd.symm = NA, nd.skew = 1, diagonal = FALSE,
        weighting = c("marginal", "uniform", "none"),
        se = c("none", "jackknife", "bootstrap"),
        nreplicates = 100, ncpus = getOption("boot.ncpus"),
        family = poisson, weights = NULL,
        start = NA, etastart = NULL, tolerance = 1e-8,
        iterMax = 15000, trace = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yrcskew_+3A_tab">tab</code></td>
<td>
<p> a two-way table, or an object (such as a matrix) that can be coerced into a table;
if present, dimensions above two will be collapsed.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_nd.symm">nd.symm</code></td>
<td>
<p> the number of dimensions to include in the <em>symmetric</em> RC(M) association. Cannot exceed
<code>2 * min(nrow(tab) - 1, ncol(tab) - 1)</code>.
If <code>NA</code>, a quasi-symmetric association is used instead of a RC(M) model.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_nd.skew">nd.skew</code></td>
<td>
<p> the number of dimensions to include in the <em>skew-symmetric</em> RC(M) association.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_diagonal">diagonal</code></td>
<td>
<p> should the model include parameters specific to each diagonal cell? This amounts to
taking quasi-independence, rather than independence, as the baseline model.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_weighting">weighting</code></td>
<td>
<p> what weights should be used when normalizing the scores.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_se">se</code></td>
<td>
<p> which method to use to compute standard errors for parameters.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_nreplicates">nreplicates</code></td>
<td>
<p> the number of bootstrap replicates, if enabled.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_ncpus">ncpus</code></td>
<td>
<p> the number of processes to use for jackknife or bootstrap parallel computing. Defaults to
the number of cores (see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>), with a maximum of 5, but falls back to 1
(no parallelization) if package <code>parallel</code> is not available.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> details of family functions.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_start">start</code></td>
<td>
<p>either <code>NA</code> (the default) to use reasonable starting values, <code>NULL</code> to use
random starting values, or a vector of starting values for the parameters in the model.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor; set to <code>NULL</code> to use either default
starting values (if <code>start = NA</code>), or random starting values (in all other cases).</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence; higher values will speed up the fitting process, but beware of numerical
instability of estimated scores!</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main iterations to perform;
consider raising this value if your model does not converge.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_verbose">verbose</code></td>
<td>
<p> a logical value indicating whether progress indicators should be printed,
including a diagnostic error message if the algorithm restarts.</p>
</td></tr>
<tr><td><code id="yrcskew_+3A_...">...</code></td>
<td>
<p> more arguments to be passed to <code><a href="igraph.html#topic+gnm">gnm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original presented by Yamaguchi (1990), called &ldquo;row-column-effect skew-symmetric
association (logbilinear) model with full quasi-symmetry (QS+RC_SK)&rdquo;, combines a skew-symmetric association
with a quasi-symmetry baseline; it is the variant fitted by default by this function. If <code>nd.symm</code> is
set to a positive integer value, though, variants using a RC(M) model to describe the <em>symmetric association</em>
are used, with our without diagonal-specific parameters (depending on the value of the <code>diagonal</code> argument);
among them is the HM_RC+RC_SK variant, when <code>nd.symm</code> is 1.
</p>
<p>These models follow the equation:
</p>
<p style="text-align: center;"><code class="reqn"> log F_{ij} = q_{ij} + \delta_{i&lt;j} \nu_i (\nu_j - \nu_i) - \delta_{i&gt;j} \nu_j (\nu_i - \nu_j) </code>
</p>

<p>where <code class="reqn">F_{ij}</code> is the expected frequency for the cell at the intersection of row i and column j of
<code>tab</code>, and <code class="reqn">q_{ij}</code> a quasi-symmetric or a RC(M) association. See reference for detailed information
about the degrees of freedom and the identification constraints applied to the scores.
</p>
<p>Please note that contrary to other association models, this model is sensitive to reorderings of rows and columns.
You have to take care of passing a table whose categories follow a hierarchical order with a substantive meaning.
</p>
<p>Another model presented in the paper, the homogeneous symmetric and skew-symmetric associations models (HM_(S+SK))
is not currently supported.
</p>
<p>Actual model fitting is performed using <code><a href="igraph.html#topic+gnm">gnm</a></code>, which implements the Newton-Raphson algorithm.
This function simply ensures correct start values are used, in addition to allowing for identification
of scores even with several dimensions, computation of their jackknife or bootstrap standard errors, and plotting.
The default starting values for main parameters are taken from the model without association parameters
(&ldquo;base model&rdquo;); association parameters start with random starting values. In some complex
cases, using <code>start = NULL</code> to get completely random starting values can be more efficient, but it is also
less stable and can converge to non-optimal solutions.
</p>


<h3>Value</h3>

<p>A <code>yrcskew</code> object, which is a subclass of an <code>rc.symm</code> object (see<code><a href="#topic+rc">rc</a></code>) unless
<code>nd.symm</code> is <code>NA</code>. In addition to this class, it contains a <code>assoc.yrcskew</code> component
holding information about the <em>skew-symmetric</em> association:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>The intrisic association parameters, one per dimension.</p>
</td></tr>
<tr><td><code>row</code></td>
<td>
<p>Row scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Column scores, normalized so that their (weighted) sum is 0, their (weighted)
sum of squares is 1, and their (weighted) cross-dimensional correlation is null.</p>
</td></tr>
<tr><td><code>row.weights</code></td>
<td>
<p>The row weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>col.weights</code></td>
<td>
<p>The column weights used for the identification of scores, as specified by the
<code>weighting</code> argument.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>The variance-covariance matrix for phi coefficients and normalized row and column
scores. Only present if <code>se</code> was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>adj.covmats</code></td>
<td>
<p>An array stacking on its third dimension one variance-covariance matrix for
the adjusted scores of each layer in the model (used for plotting). Only present if <code>se</code>
was not &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code>covtype</code></td>
<td>
<p>The method used to compute the variance-covariance matrix (corresponding to the
<code>se</code> argument.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This family of model sometimes converges to a non-optimal solution, in which case the reported scores
are wrong. To protect yourself from this problem, you are advised to run the models several times to find out which
convergence point is the true one. Furthermore, when model converges slowly, restarting the fitting procedure may produce
much better random starting values.
</p>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Yamaguchi, K. (1990). Some Models for the Analysis of Asymmetric Association in Square Contingency Tables with
Ordered Categories. <em>Sociol. Methodology</em> 20, 181-212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.yrcskew">plot.yrcskew</a></code>, <code><a href="igraph.html#topic+gnm">gnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Yamaguchi (1990), Table 5, p. 202, and Table 6B, p. 205
  data(ocg1973)

  # Simple symmetric RC(1) model ("Null skew-symmetry")
  rc.model &lt;- rc(ocg1973, diagonal=TRUE, symmetric=TRUE, weighting="none")
  # Reported phi is slightly different, coefficients agree
  rc.model

  # Note model does not always converge, several attempts may be needed
  # Here we set known starting values to be sure it works
  set.seed(5)
  model &lt;- yrcskew(ocg1973, nd.symm=1, nd.skew=1, diagonal=TRUE, weighting="none")

  # We do not get the same results as the author, but the smaller deviance
  # indicates a better fit in our version (!)
  model
</code></pre>

<hr>
<h2 id='YRCSkew'>Specify a Skew-Symmetric Association in a gnm Model Formula</h2><span id='topic+YRCSkew'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify a Yamaguchi (1990) skew-symmetric association in
the formula argument to <code><a href="igraph.html#topic+gnm">gnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YRCSkew(row, col, rowinf, rowsup, inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YRCSkew_+3A_row">row</code></td>
<td>
<p>for each cell in the table, the row category.</p>
</td></tr>
<tr><td><code id="YRCSkew_+3A_col">col</code></td>
<td>
<p>for each cell in the table, the column category.</p>
</td></tr>
<tr><td><code id="YRCSkew_+3A_rowinf">rowinf</code></td>
<td>
<p>must be 1 for cells above the diagonal, 0 for cells below and on the diagonal.</p>
</td></tr>
<tr><td><code id="YRCSkew_+3A_rowsup">rowsup</code></td>
<td>
<p>must be 1 for cells below the diagonal, 0 for cells above and on the diagonal.</p>
</td></tr>
<tr><td><code id="YRCSkew_+3A_inst">inst</code></td>
<td>
<p>a positive integer specifying the instance number of the term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+yrcskew">yrcskew</a></code> to fit the &ldquo;row-column-effect skew-symmetric
association (logbilinear) model with full quasi-symmetry (QS+RC_SK)&rdquo; proposed by Yamaguchi (1990).
It can be used directly to fit custom variants of the model not supported by <code>yrcskew</code>.
</p>
<p>This function combines its arguments in the following way:
</p>
<p style="text-align: center;"><code class="reqn"> YRCSkew(row, col, rowinf, rowsup) = \delta_{rowinf} * \mu_{row} * (\mu_{col} - \mu_{row})
                                           + \delta_{rowsup} * \nu_{col} * (\nu_{row} - \nu_{col}) </code>
</p>

<p>When arguments are set according to what is suggested above, and the skew <code class="reqn">\delta</code> parameter is
constrained to 1, this amounts to the equation:
</p>
<p style="text-align: center;"><code class="reqn"> YRCSkew_{ij} = \delta_{i&lt;j} \nu_i (\nu_j - \nu_i) - \delta_{i&gt;j} \nu_j (\nu_i - \nu_j)
              = (\delta_{i&lt;j} - \delta_{i&gt;j}) \nu_{min(i,j)} (\nu_{max(i,j)} - \nu_{min(i,j)})</code>
</p>

<p>where <code class="reqn">YRCSkew_{ij}</code> is the skew association for the cell at the intersection of row i and column j of
the table. See reference for mathematical details, and the code of <code><a href="#topic+yrcskew">yrcskew</a></code> for real-world usage.
</p>


<h3>Value</h3>

<p>A list with the required components of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> the expressions passed to <code>Mult</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical expression
of the term, given labels for the predictors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the call to use as a prefix for parameter labels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Milan Bouchet-Valat
</p>


<h3>References</h3>

<p>Yamaguchi, K. (1990). Some Models for the Analysis of Asymmetric Association in Square Contingency Tables with
Ordered Categories. <em>Sociol. Methodology</em> 20, 181-212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yrcskew">yrcskew</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See ?yrcskew.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
