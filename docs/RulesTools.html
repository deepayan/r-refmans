<!DOCTYPE html><html lang="en"><head><title>Help for package RulesTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RulesTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BrookTrout'><p>Brook Trout eDNA and Environmental Data</p></a></li>
<li><a href='#compare_rules'><p>Compare Association Rule Sets and Find Their Intersections</p></a></li>
<li><a href='#dtize_col'><p>Discretize a Numeric Column</p></a></li>
<li><a href='#dtize_df'><p>Discretize Dataframe Columns</p></a></li>
<li><a href='#rule_euler'><p>Create an Euler Diagram for Association Rules</p></a></li>
<li><a href='#rule_heatmap'><p>Create a Heatmap for Association Rules</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Preparing, Analyzing, and Visualizing Association Rules</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Streamlines data preprocessing, analysis, and visualization for association rule mining. Designed to work with the 'arules' package, features include discretizing data frames, generating rule set intersections, and visualizing rules with heatmaps and Euler diagrams. 'RulesTools' also includes a dataset on Brook trout detection from Nolan et al. (2022) &lt;<a href="https://doi.org/10.1007%2Fs13412-022-00800-x">doi:10.1007/s13412-022-00800-x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>mice, arules, ggplot2, tidyr, eulerr, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, roxygen2 (&ge; 7.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nikolett0203/RulesTools">https://github.com/nikolett0203/RulesTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nikolett0203/RulesTools/issues">https://github.com/nikolett0203/RulesTools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-23 19:56:54 UTC; niki</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolett Toth [aut, cre],
  Jarrett Phillips [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolett Toth &lt;rules.tools.pkg@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-28 15:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BrookTrout'>Brook Trout eDNA and Environmental Data</h2><span id='topic+BrookTrout'></span>

<h3>Description</h3>

<p>This dataset contains information on brook trout detections using
environmental DNA (eDNA) and environmental parameters collected from various
sites in Ontario, Canada. The data was sourced from a scientific study
comparing eDNA sampling methods with electrofishing to detect Brook trout
populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrookTrout
</code></pre>


<h3>Format</h3>

<p>A dataframe with 10 variables and multiple rows (one row per sample):
</p>

<dl>
<dt>Backpack</dt><dd><p>Character. The type of eDNA sampler: &quot;OSMOS&quot; or &quot;ANDe&quot;.</p>
</dd>
<dt>Site</dt><dd><p>Integer. The site number where the sample was taken.</p>
</dd>
<dt>eFishCatch</dt><dd><p>Integer. The number of fish caught via electrofishing.</p>
</dd>
<dt>AirTemp</dt><dd><p>Numeric. Air temperature in degrees Celsius.</p>
</dd>
<dt>WaterTemp</dt><dd><p>Numeric. Water temperature in degrees Celsius.</p>
</dd>
<dt>pH</dt><dd><p>Numeric. pH level of the water sample.</p>
</dd>
<dt>DissolvedOxygen</dt><dd><p>Numeric. Dissolved oxygen concentration in mg/L.</p>
</dd>
<dt>Conductivity</dt><dd><p>Numeric. Conductivity in uS/cm.</p>
</dd>
<dt>VolumeFiltered</dt><dd><p>Numeric. Volume of water filtered in litres.</p>
</dd>
<dt>eDNAConc</dt><dd><p>Numeric. eDNA concentration in copies per microlitre.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Adapted from Nolan, K. P., Loeza-Quintana, T., Little, H. A., et al.
(2022). Detection of brook trout in spatiotemporally separate locations
using validated eDNA technology. <em>Journal of Environmental Studies and
Sciences</em>, 13, 66-82. <a href="doi:10.1007/s13412-022-00800-x">doi:10.1007/s13412-022-00800-x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BrookTrout)
summary(BrookTrout)
plot(eDNAConc ~ Site, data = BrookTrout)
</code></pre>

<hr>
<h2 id='compare_rules'>Compare Association Rule Sets and Find Their Intersections</h2><span id='topic+compare_rules'></span>

<h3>Description</h3>

<p>Compares multiple sets of association rules, identifies intersections,
and optionally displays the results or writes them to a CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_rules(..., display = TRUE, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_rules_+3A_...">...</code></td>
<td>
<p>Named association rule sets (objects of class <code>rules</code>).</p>
</td></tr>
<tr><td><code id="compare_rules_+3A_display">display</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints the intersection results. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compare_rules_+3A_filename">filename</code></td>
<td>
<p>Character string. If provided, writes the results to a CSV file. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the intersections of the provided rule sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(arules)
data(BrookTrout)

# Discretize the BrookTrout dataset
discrete_bt &lt;- dtize_df(BrookTrout, cutoff = "mean")

# Generate the first set of rules with a confidence threshold of 0.5
rules1 &lt;- apriori(
  discrete_bt,
  parameter = list(supp = 0.01, conf = 0.5, target = "rules")
)

# Generate the second set of rules with a higher confidence threshold of 0.6
rules2 &lt;- apriori(
  discrete_bt,
  parameter = list(supp = 0.01, conf = 0.6, target = "rules")
)

# Compare the two sets of rules and display the intersections
compare_rules(
  r1 = rules1,
  r2 = rules2,
  display = TRUE
)

# If `filename = "intersections.csv"`, the data is saved in a .csv file

</code></pre>

<hr>
<h2 id='dtize_col'>Discretize a Numeric Column</h2><span id='topic+dtize_col'></span>

<h3>Description</h3>

<p>Discretizes a numeric vector into categories based on specified cutoff points.
The function handles missing values, allows for infinite bounds, and supports
predefined cutoffs such as the mean or median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtize_col(
  column,
  cutoff = "median",
  labels = c("low", "high"),
  include_right = TRUE,
  infinity = TRUE,
  include_lowest = TRUE,
  na_fill = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtize_col_+3A_column">column</code></td>
<td>
<p>A numeric vector to discretize.</p>
</td></tr>
<tr><td><code id="dtize_col_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric vector specifying cutoff points, or a string (&quot;mean&quot; or &quot;median&quot;).</p>
</td></tr>
<tr><td><code id="dtize_col_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying labels for the resulting categories.</p>
</td></tr>
<tr><td><code id="dtize_col_+3A_include_right">include_right</code></td>
<td>
<p>Logical. If <code>TRUE</code>, intervals are closed on the right (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dtize_col_+3A_infinity">infinity</code></td>
<td>
<p>Logical. If <code>TRUE</code>, extends cutoffs to <code>-Inf</code> and <code>Inf</code> (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dtize_col_+3A_include_lowest">include_lowest</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the lowest interval is closed on the left (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dtize_col_+3A_na_fill">na_fill</code></td>
<td>
<p>A string specifying the method to impute missing values: &quot;none&quot;, &quot;mean&quot;, or &quot;median&quot; (default &quot;none&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor with the same length as <code>column</code>, where each value is categorized based on the cutoffs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BrookTrout)

# Example with predefined cutoffs
discrete_water_temp &lt;- dtize_col(
  BrookTrout$eDNAConc, cutoff=13.3,
  labels=c("low", "high"),
  infinity=TRUE
)

# Example with median as cutoff
discrete_pH &lt;- dtize_col(BrookTrout$pH, cutoff="median")

# Example with missing value imputation
filled_col &lt;- dtize_col(
  c(1, 2, NA, 4, 5),
  cutoff = "mean",
  include_right=FALSE,
  na_fill = "mean"
)

</code></pre>

<hr>
<h2 id='dtize_df'>Discretize Dataframe Columns</h2><span id='topic+dtize_df'></span>

<h3>Description</h3>

<p>Discretizes numeric columns of a dataframe based on specified splitting criteria,
and handles missing values using specified imputation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtize_df(
  data,
  cutoff = "median",
  labels = c("low", "high"),
  include_right = TRUE,
  infinity = TRUE,
  include_lowest = TRUE,
  na_fill = "none",
  m = 5,
  maxit = 5,
  seed = NULL,
  printFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtize_df_+3A_data">data</code></td>
<td>
<p>A dataframe containing the data to be discretized.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_cutoff">cutoff</code></td>
<td>
<p>A character string specifying the splitting method for numeric columns.
Options are <code>"median"</code> (default), <code>"mean"</code> or a custom numeric vector of split points.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels for the discretized categories. Default is <code>c("low", "high")</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_include_right">include_right</code></td>
<td>
<p>A logical value indicating if the intervals should be closed on the right. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_infinity">infinity</code></td>
<td>
<p>A logical value indicating if the split intervals should extend to infinity. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_include_lowest">include_lowest</code></td>
<td>
<p>A logical value indicating if the lowest value should be included in the first interval. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_na_fill">na_fill</code></td>
<td>
<p>A character string specifying the imputation method for handling missing values.
Options are <code>"none"</code> (default), <code>"mean"</code>, <code>"median"</code>, or <code>"pmm"</code> (predictive mean matching).</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_m">m</code></td>
<td>
<p>An integer specifying the number of multiple imputations if <code>na_fill = "pmm"</code>. Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_maxit">maxit</code></td>
<td>
<p>An integer specifying the maximum number of iterations for the <code>mice</code> algorithm. Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_seed">seed</code></td>
<td>
<p>An integer seed for reproducibility of the imputation process. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dtize_df_+3A_printflag">printFlag</code></td>
<td>
<p>A logical value indicating if <code>mice</code> should print logs during imputation. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with numeric columns discretized and missing values handled based on the specified imputation method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BrookTrout)

# Example with median as cutoff
med_df &lt;- dtize_df(
  BrookTrout,
  cutoff="median",
  labels=c("below median", "above median")
)

# Example with mean as cutoff
mean_df &lt;- dtize_df(
  BrookTrout,
  cutoff="mean",
  include_right=FALSE
)

# Example with missing value imputation
air &lt;- dtize_df(
  airquality,
  cutoff="mean",
  na_fill="pmm",
  m=10,
  maxit=10,
  seed=42
)


</code></pre>

<hr>
<h2 id='rule_euler'>Create an Euler Diagram for Association Rules</h2><span id='topic+rule_euler'></span>

<h3>Description</h3>

<p>Generates an Euler diagram visualization for up to 4 sets of association rules.
The function displays the relationships between rule sets with customizable colors, transparency, and labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule_euler(
  rules,
  fill_color = NULL,
  fill_alpha = 0.5,
  stroke_color = "black",
  stroke_size = 1,
  title = NULL,
  name_color = "black",
  name_size = 12,
  text_color = "black",
  text_size = 11,
  show_legend = FALSE,
  legend_position = "bottom",
  nrow = NULL,
  ncol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule_euler_+3A_rules">rules</code></td>
<td>
<p>A list of <code>rules</code> objects from the <code>arules</code> package.
The list must contain between 2 and 4 <code>rules</code> objects.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_fill_color">fill_color</code></td>
<td>
<p>A character vector of valid R color names or hex color codes for filling the sets.
If <code>NULL</code>, default colors <code>c("red", "blue", "green", "purple")</code> will be used. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_fill_alpha">fill_alpha</code></td>
<td>
<p>A numeric value between 0 and 1 specifying the transparency of the fill colors. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_stroke_color">stroke_color</code></td>
<td>
<p>A character string specifying the color of the set borders. Defaults to <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_stroke_size">stroke_size</code></td>
<td>
<p>A positive numeric value specifying the size of the set borders. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_title">title</code></td>
<td>
<p>A character string specifying the title of the Euler diagram. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_name_color">name_color</code></td>
<td>
<p>A character string specifying the color of the set names. Defaults to <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_name_size">name_size</code></td>
<td>
<p>A positive numeric value specifying the font size of the set names. Defaults to <code>12</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_text_color">text_color</code></td>
<td>
<p>A character string specifying the color of the quantity labels (counts) in the diagram. Defaults to <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_text_size">text_size</code></td>
<td>
<p>A positive numeric value specifying the font size of the quantities (counts). Defaults to <code>11</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_show_legend">show_legend</code></td>
<td>
<p>A logical value indicating whether to display a legend for the sets rather than labels. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_legend_position">legend_position</code></td>
<td>
<p>A character string specifying the position of the legend. Must be one of <code>"top"</code>, <code>"bottom"</code>, <code>"left"</code>, or <code>"right"</code>. Defaults to <code>"bottom"</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_nrow">nrow</code></td>
<td>
<p>An optional numeric value specifying the number of rows in the legend layout. If <code>NULL</code>, the number of rows is calculated automatically. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rule_euler_+3A_ncol">ncol</code></td>
<td>
<p>An optional numeric value specifying the number of columns in the legend layout. If <code>NULL</code>, the number of columns is calculated automatically. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>plot</code> object displaying the Euler diagram visualization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(arules)
data(BrookTrout)

# Discretize the BrookTrout dataset
discrete_bt &lt;- dtize_df(BrookTrout, cutoff = "median")

# Generate the first set of rules with a confidence threshold of 0.5
rules1 &lt;- apriori(
  discrete_bt,
  parameter = list(supp = 0.01, conf = 0.5, target = "rules")
)

# Generate the second set of rules with a higher confidence threshold of 0.6
rules2 &lt;- apriori(
  discrete_bt,
  parameter = list(supp = 0.01, conf = 0.6, target = "rules")
)

# Create an Euler diagram to visualize the intersections between the rule sets
rule_euler(
  rules = list(conf0.5 = rules1, conf0.6 = rules2),
  title = "Euler Diagram of BrookTrout Rule Sets",
  fill_color = c("#7832ff", "lightgreen"),
  stroke_color = "darkblue"
)

</code></pre>

<hr>
<h2 id='rule_heatmap'>Create a Heatmap for Association Rules</h2><span id='topic+rule_heatmap'></span>

<h3>Description</h3>

<p>Generates a heatmap visualization of association rules,
showing relationships between antecedents and consequents based on a specified metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule_heatmap(
  rules,
  metric = "confidence",
  graph_title = "",
  graph_title_size = 14,
  x_axis_title = "Antecedents",
  x_axis_title_size = 12,
  x_axis_text_size = 11,
  x_axis_text_angle = 45,
  y_axis_title = "Consequents",
  y_axis_title_size = 12,
  y_axis_text_size = 11,
  y_axis_text_angle = 0,
  legend_title = metric,
  legend_text_size = 8,
  legend_position = "right",
  low_color = "lightblue",
  high_color = "navy",
  include_zero = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule_heatmap_+3A_rules">rules</code></td>
<td>
<p>An object of class <code>rules</code> from the <code>arules</code> package.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_metric">metric</code></td>
<td>
<p>A character string specifying the metric to use for coloring the heatmap.
Must be one of <code>"confidence"</code>, <code>"support"</code>, or <code>"lift"</code>. Defaults to <code>"confidence"</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_graph_title">graph_title</code></td>
<td>
<p>A character string specifying the title of the graph.
Defaults to an empty string (<code>""</code>).</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_graph_title_size">graph_title_size</code></td>
<td>
<p>A numeric value specifying the size of the graph title text.
Defaults to <code>14</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_x_axis_title">x_axis_title</code></td>
<td>
<p>A character string specifying the title for the x-axis.
Defaults to <code>"Antecedents"</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_x_axis_title_size">x_axis_title_size</code></td>
<td>
<p>A numeric value specifying the size of the x-axis title text.
Defaults to <code>12</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_x_axis_text_size">x_axis_text_size</code></td>
<td>
<p>A numeric value specifying the size of the x-axis text.
Defaults to <code>11</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_x_axis_text_angle">x_axis_text_angle</code></td>
<td>
<p>A numeric value specifying the angle of the x-axis text.
Defaults to <code>45</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_y_axis_title">y_axis_title</code></td>
<td>
<p>A character string specifying the title for the y-axis.
Defaults to <code>"Consequents"</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_y_axis_title_size">y_axis_title_size</code></td>
<td>
<p>A numeric value specifying the size of the y-axis title text.
Defaults to <code>12</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_y_axis_text_size">y_axis_text_size</code></td>
<td>
<p>A numeric value specifying the size of the y-axis text.
Defaults to <code>11</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_y_axis_text_angle">y_axis_text_angle</code></td>
<td>
<p>A numeric value specifying the angle of the y-axis text.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_legend_title">legend_title</code></td>
<td>
<p>A character string specifying the title of the legend. Defaults to the value of <code>metric</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_legend_text_size">legend_text_size</code></td>
<td>
<p>A numeric value specifying the size of the legend text. Defaults to <code>8</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_legend_position">legend_position</code></td>
<td>
<p>A character string specifying the position of the legend.
Possible values are <code>"right"</code> (default), <code>"left"</code>, <code>"top"</code>, <code>"bottom"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_low_color">low_color</code></td>
<td>
<p>A valid R color or hex color code for the lower bound of the gradient.
Defaults to <code>"lightblue"</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_high_color">high_color</code></td>
<td>
<p>A valid R color or hex color code for the upper bound of the gradient.
Defaults to <code>"navy"</code>.</p>
</td></tr>
<tr><td><code id="rule_heatmap_+3A_include_zero">include_zero</code></td>
<td>
<p>A logical value indicating whether to include zero values for missing antecedent-consequent combinations.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object representing the heatmap visualization of the association rules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(arules)
library(tidyr)
data(BrookTrout)

# Discretise data
discrete_bt &lt;- dtize_df(BrookTrout, cutoff="median")

# Generate rules
rules &lt;- apriori(
  discrete_bt,
  parameter = list(supp = 0.01, conf = 0.5, target = "rules"),
  appearance = list(rhs="eDNAConc=high")
)

# Subset ruleset (too many rules won't fit on the heatmap)
rules &lt;- rules %&gt;%
  subset(!is.redundant(., measure = "confidence")) %&gt;%
  subset(is.significant(., alpha = 0.05)) %&gt;%
  sort(by = c("confidence", "lift", "support"))

# Create a heatmap of the rules using confidence as the metric
rule_heatmap(
  rules,
  metric = "confidence",
  graph_title = "Confidence Heatmap"
)

# Create a heatmap of the rules using lift as the metric
rule_heatmap(
  rules,
  metric = "lift",
  graph_title = "Lift Heatmap",
  low_color = "#D4A221",
  high_color = "darkgreen"
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
