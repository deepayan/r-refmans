<!DOCTYPE html><html><head><title>Help for package Seurat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Seurat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddAzimuthResults'><p>Add Azimuth Results</p></a></li>
<li><a href='#AddAzimuthScores'><p>Add Azimuth Scores</p></a></li>
<li><a href='#AddModuleScore'><p>Calculate module scores for feature expression programs in single cells</p></a></li>
<li><a href='#AggregateExpression'><p>Aggregated feature expression by identity class</p></a></li>
<li><a href='#AnchorSet-class'><p>The AnchorSet Class</p></a></li>
<li><a href='#AnnotateAnchors'><p>Add info to anchor matrix</p></a></li>
<li><a href='#as.CellDataSet'><p>Convert objects to CellDataSet objects</p></a></li>
<li><a href='#as.Seurat.CellDataSet'><p>Convert objects to <code>Seurat</code> objects</p></a></li>
<li><a href='#as.SingleCellExperiment'><p>Convert objects to SingleCellExperiment objects</p></a></li>
<li><a href='#as.sparse.H5Group'><p>Cast to Sparse</p></a></li>
<li><a href='#Assay-class'><p>The Assay Class</p></a></li>
<li><a href='#AugmentPlot'><p>Augments ggplot2-based plot with a PNG image.</p></a></li>
<li><a href='#AutoPointSize'><p>Automagically calculate a point size for ggplot2-based scatter plots</p></a></li>
<li><a href='#AverageExpression'><p>Averaged feature expression by identity class</p></a></li>
<li><a href='#BarcodeInflectionsPlot'><p>Plot the Barcode Distribution and Calculated Inflection Points</p></a></li>
<li><a href='#BGTextColor'><p>Determine text color based on background color</p></a></li>
<li><a href='#BlackAndWhite'><p>Create a custom color palette</p></a></li>
<li><a href='#BridgeCellsRepresentation'><p>Construct a dictionary representation for each unimodal dataset</p></a></li>
<li><a href='#BridgeReferenceSet-class'><p>The BridgeReferenceSet Class</p>
The BridgeReferenceSet is an output from PrepareBridgeReference</a></li>
<li><a href='#BuildClusterTree'><p>Phylogenetic Analysis of Identity Classes</p></a></li>
<li><a href='#BuildNicheAssay'><p>Construct an assay for spatial niche analysis</p></a></li>
<li><a href='#CalcDispersion'><p>Calculate dispersion of features</p></a></li>
<li><a href='#CalcPerturbSig'><p>Calculate a perturbation Signature</p></a></li>
<li><a href='#CalculateBarcodeInflections'><p>Calculate the Barcode Distribution Inflection</p></a></li>
<li><a href='#CaseMatch'><p>Match the case of character vectors</p></a></li>
<li><a href='#cc.genes'><p>Cell cycle genes</p></a></li>
<li><a href='#cc.genes.updated.2019'><p>Cell cycle genes: 2019 update</p></a></li>
<li><a href='#CCAIntegration'><p>Seurat-CCA Integration</p></a></li>
<li><a href='#CellCycleScoring'><p>Score cell cycle phases</p></a></li>
<li><a href='#Cells.SCTModel'><p>Get Cell Names</p></a></li>
<li><a href='#CellsByImage'><p>Get a vector of cell names associated with an image (or set of images)</p></a></li>
<li><a href='#CellScatter'><p>Cell-cell scatter plot</p></a></li>
<li><a href='#CellSelector'><p>Cell Selector</p></a></li>
<li><a href='#CollapseEmbeddingOutliers'><p>Move outliers towards center on dimension reduction plot</p></a></li>
<li><a href='#CollapseSpeciesExpressionMatrix'><p>Slim down a multi-species expression matrix, when only one species is primarily of interenst.</p></a></li>
<li><a href='#ColorDimSplit'><p>Color dimensional reduction plot by tree split</p></a></li>
<li><a href='#CombinePlots'><p>Combine ggplot2-based plots into a single plot</p></a></li>
<li><a href='#components'><p>Objects exported from other packages</p></a></li>
<li><a href='#contrast-theory'><p>Get the intensity and/or luminance of a color</p></a></li>
<li><a href='#CountSketch'><p>Generate CountSketch random matrix</p></a></li>
<li><a href='#CreateCategoryMatrix'><p>Create one hot matrix for a given label</p></a></li>
<li><a href='#CreateSCTAssayObject'><p>Create a SCT Assay object</p></a></li>
<li><a href='#CustomDistance'><p>Run a custom distance function on an input data matrix</p></a></li>
<li><a href='#DEenrichRPlot'><p>DE and EnrichR pathway visualization barplot</p></a></li>
<li><a href='#DietSeurat'><p>Slim down a Seurat object</p></a></li>
<li><a href='#DimHeatmap'><p>Dimensional reduction heatmap</p></a></li>
<li><a href='#DimPlot'><p>Dimensional reduction plot</p></a></li>
<li><a href='#DimReduc-class'><p>The DimReduc Class</p></a></li>
<li><a href='#DiscretePalette'><p>Discrete colour palettes from pals</p></a></li>
<li><a href='#DISP'><p>Find variable features based on dispersion</p></a></li>
<li><a href='#DoHeatmap'><p>Feature expression heatmap</p></a></li>
<li><a href='#DotPlot'><p>Dot plot visualization</p></a></li>
<li><a href='#ElbowPlot'><p>Quickly Pick Relevant Dimensions</p></a></li>
<li><a href='#ExpMean'><p>Calculate the mean of logged values</p></a></li>
<li><a href='#ExpSD'><p>Calculate the standard deviation of logged values</p></a></li>
<li><a href='#ExpVar'><p>Calculate the variance of logged values</p></a></li>
<li><a href='#FastRowScale'><p>Scale and/or center matrix rowwise</p></a></li>
<li><a href='#FastRPCAIntegration'><p>Perform integration on the joint PCA cell embeddings.</p></a></li>
<li><a href='#FeaturePlot'><p>Visualize 'features' on a dimensional reduction plot</p></a></li>
<li><a href='#FeatureScatter'><p>Scatter plot of single cell data</p></a></li>
<li><a href='#FetchResiduals'><p>Calculate pearson residuals of features not in the scale.data</p></a></li>
<li><a href='#FetchResiduals_reference'><p>temporal function to get residuals from reference</p></a></li>
<li><a href='#FetchResidualSCTModel'><p>Calculate pearson residuals of features not in the scale.data</p>
This function is the secondary function under FetchResiduals</a></li>
<li><a href='#FilterSlideSeq'><p>Filter stray beads from Slide-seq puck</p></a></li>
<li><a href='#FindAllMarkers'><p>Gene expression markers for all identity classes</p></a></li>
<li><a href='#FindBridgeAnchor'><p>Find bridge anchors between two unimodal datasets</p></a></li>
<li><a href='#FindBridgeIntegrationAnchors'><p>Find integration bridge anchors between query and extended bridge-reference</p></a></li>
<li><a href='#FindBridgeTransferAnchors'><p>Find bridge anchors between query and extended bridge-reference</p></a></li>
<li><a href='#FindClusters'><p>Cluster Determination</p></a></li>
<li><a href='#FindConservedMarkers'><p>Finds markers that are conserved between the groups</p></a></li>
<li><a href='#FindIntegrationAnchors'><p>Find integration anchors</p></a></li>
<li><a href='#FindMarkers'><p>Gene expression markers of identity classes</p></a></li>
<li><a href='#FindMultiModalNeighbors'><p>Construct weighted nearest neighbor graph</p></a></li>
<li><a href='#FindNeighbors'><p>(Shared) Nearest-neighbor graph construction</p></a></li>
<li><a href='#FindSpatiallyVariableFeatures'><p>Find spatially variable features</p></a></li>
<li><a href='#FindSubCluster'><p>Find subclusters under one cluster</p></a></li>
<li><a href='#FindTransferAnchors'><p>Find transfer anchors</p></a></li>
<li><a href='#FindVariableFeatures'><p>Find variable features</p></a></li>
<li><a href='#FoldChange'><p>Fold Change</p></a></li>
<li><a href='#fortify-Spatial'><p>Prepare Coordinates for Spatial Plots</p></a></li>
<li><a href='#GaussianSketch'><p>Gaussian sketching</p></a></li>
<li><a href='#GetAssay'><p>Get an Assay object from a given Seurat object.</p></a></li>
<li><a href='#GetImage.SlideSeq'><p>Get Image Data</p></a></li>
<li><a href='#GetIntegrationData'><p>Get integration data</p></a></li>
<li><a href='#GetResidual'><p>Calculate pearson residuals of features not in the scale.data</p></a></li>
<li><a href='#GetTissueCoordinates.SlideSeq'><p>Get Tissue Coordinates</p></a></li>
<li><a href='#GetTransferPredictions'><p>Get the predicted identity</p></a></li>
<li><a href='#Graph-class'><p>The Graph Class</p></a></li>
<li><a href='#GroupCorrelation'><p>Compute the correlation of features broken down by groups with another</p>
covariate</a></li>
<li><a href='#GroupCorrelationPlot'><p>Boxplot of correlation of a variable (e.g. number of UMIs) with expression</p>
data</a></li>
<li><a href='#HarmonyIntegration'><p>Harmony Integration</p></a></li>
<li><a href='#HoverLocator'><p>Hover Locator</p></a></li>
<li><a href='#HTODemux'><p>Demultiplex samples based on data from cell 'hashing'</p></a></li>
<li><a href='#HTOHeatmap'><p>Hashtag oligo heatmap</p></a></li>
<li><a href='#HVFInfo.SCTAssay'><p>Get Variable Feature Information</p></a></li>
<li><a href='#IFeaturePlot'><p>Visualize features in dimensional reduction space interactively</p></a></li>
<li><a href='#ImageDimPlot'><p>Spatial Cluster Plots</p></a></li>
<li><a href='#ImageFeaturePlot'><p>Spatial Feature Plots</p></a></li>
<li><a href='#IntegrateData'><p>Integrate data</p></a></li>
<li><a href='#IntegrateEmbeddings'><p>Integrate low dimensional embeddings</p></a></li>
<li><a href='#IntegrateLayers'><p>Integrate Layers</p></a></li>
<li><a href='#IntegrationAnchorSet-class'><p>The IntegrationAnchorSet Class</p></a></li>
<li><a href='#IntegrationData-class'><p>The IntegrationData Class</p></a></li>
<li><a href='#ISpatialDimPlot'><p>Visualize clusters spatially and interactively</p></a></li>
<li><a href='#ISpatialFeaturePlot'><p>Visualize features spatially and interactively</p></a></li>
<li><a href='#JackStraw'><p>Determine statistical significance of PCA scores.</p></a></li>
<li><a href='#JackStrawData-class'><p>The JackStrawData Class</p></a></li>
<li><a href='#JackStrawPlot'><p>JackStraw Plot</p></a></li>
<li><a href='#JointPCAIntegration'><p>Seurat-Joint PCA Integration</p></a></li>
<li><a href='#L2CCA'><p>L2-Normalize CCA</p></a></li>
<li><a href='#L2Dim'><p>L2-normalization</p></a></li>
<li><a href='#LabelClusters'><p>Label clusters on a ggplot2-based scatter plot</p></a></li>
<li><a href='#LabelPoints'><p>Add text labels to a ggplot2 plot</p></a></li>
<li><a href='#LeverageScore'><p>Leverage Score Calculation</p></a></li>
<li><a href='#LinkedPlots'><p>Visualize spatial and clustering (dimensional reduction) data in a linked,</p>
interactive framework</a></li>
<li><a href='#Load10X_Spatial'><p>Load a 10x Genomics Visium Spatial Experiment into a <code>Seurat</code> object</p></a></li>
<li><a href='#LoadAnnoyIndex'><p>Load the Annoy index file</p></a></li>
<li><a href='#LoadCurioSeeker'><p>Load Curio Seeker data</p></a></li>
<li><a href='#LoadSTARmap'><p>Load STARmap data</p></a></li>
<li><a href='#LoadXenium'><p>Read and Load 10x Genomics Xenium in-situ data</p></a></li>
<li><a href='#LocalStruct'><p>Calculate the local structure preservation metric</p></a></li>
<li><a href='#LogNormalize'><p>Normalize Raw Data</p></a></li>
<li><a href='#LogVMR'><p>Calculate the variance to mean ratio of logged values</p></a></li>
<li><a href='#MappingScore'><p>Metric for evaluating mapping success</p></a></li>
<li><a href='#MapQuery'><p>Map query cells to a reference</p></a></li>
<li><a href='#merge.SCTAssay'><p>Merge SCTAssay objects</p></a></li>
<li><a href='#MetaFeature'><p>Aggregate expression of multiple features into a single feature</p></a></li>
<li><a href='#MinMax'><p>Apply a ceiling and floor to all values in a matrix</p></a></li>
<li><a href='#MixingMetric'><p>Calculates a mixing metric</p></a></li>
<li><a href='#MixscapeHeatmap'><p>Differential expression heatmap for mixscape</p></a></li>
<li><a href='#MixscapeLDA'><p>Linear discriminant analysis on pooled CRISPR screen data.</p></a></li>
<li><a href='#ModalityWeights-class'><p>The ModalityWeights Class</p></a></li>
<li><a href='#MULTIseqDemux'><p>Demultiplex samples based on classification method from MULTI-seq (McGinnis et al., bioRxiv 2018)</p></a></li>
<li><a href='#MVP'><p>Find variable features based on mean.var.plot</p></a></li>
<li><a href='#Neighbor-class'><p>The Neighbor Class</p></a></li>
<li><a href='#NNPlot'><p>Highlight Neighbors in DimPlot</p></a></li>
<li><a href='#NNtoGraph'><p>Convert Neighbor class to an asymmetrical Graph class</p></a></li>
<li><a href='#NormalizeData'><p>Normalize Data</p></a></li>
<li><a href='#PCASigGenes'><p>Significant genes from a PCA</p></a></li>
<li><a href='#PercentAbove'><p>Calculate the percentage of a vector above some threshold</p></a></li>
<li><a href='#PercentageFeatureSet'><p>Calculate the percentage of all counts that belong to a given set of features</p></a></li>
<li><a href='#PlotClusterTree'><p>Plot clusters as a tree</p></a></li>
<li><a href='#PlotPerturbScore'><p>Function to plot perturbation score distributions.</p></a></li>
<li><a href='#PolyDimPlot'><p>Polygon DimPlot</p></a></li>
<li><a href='#PolyFeaturePlot'><p>Polygon FeaturePlot</p></a></li>
<li><a href='#PredictAssay'><p>Predict value from nearest neighbors</p></a></li>
<li><a href='#PrepareBridgeReference'><p>Prepare the bridge and reference datasets</p></a></li>
<li><a href='#PrepLDA'><p>Function to prepare data for Linear Discriminant Analysis.</p></a></li>
<li><a href='#PrepSCTFindMarkers'><p>Prepare object to run differential expression on SCT assay with multiple models</p></a></li>
<li><a href='#PrepSCTIntegration'><p>Prepare an object list normalized with sctransform for integration.</p></a></li>
<li><a href='#ProjectCellEmbeddings'><p>Project query data to the reference dimensional reduction</p></a></li>
<li><a href='#ProjectData'><p>Project full data to the sketch assay</p></a></li>
<li><a href='#ProjectDim'><p>Project Dimensional reduction onto full dataset</p></a></li>
<li><a href='#ProjectDimReduc'><p>Project query data to reference dimensional reduction</p></a></li>
<li><a href='#ProjectIntegration'><p>Integrate embeddings from the integrated sketched.assay</p></a></li>
<li><a href='#ProjectUMAP'><p>Project query into UMAP coordinates of a reference</p></a></li>
<li><a href='#PseudobulkExpression'><p>Pseudobulk Expression</p></a></li>
<li><a href='#Radius.SlideSeq'><p>Get Spot Radius</p></a></li>
<li><a href='#Read10X'><p>Load in data from 10X</p></a></li>
<li><a href='#Read10X_h5'><p>Read 10X hdf5 file</p></a></li>
<li><a href='#Read10X_Image'><p>Load a 10X Genomics Visium Image</p></a></li>
<li><a href='#Read10X_probe_metadata'><p>Read10x Probe Metadata</p></a></li>
<li><a href='#ReadAkoya'><p>Read and Load Akoya CODEX data</p></a></li>
<li><a href='#ReadMtx'><p>Load in data from remote or local mtx files</p></a></li>
<li><a href='#ReadNanostring'><p>Read and Load Nanostring SMI data</p></a></li>
<li><a href='#ReadParseBio'><p>Read output from Parse Biosciences</p></a></li>
<li><a href='#ReadSlideSeq'><p>Load Slide-seq spatial data</p></a></li>
<li><a href='#ReadSTARsolo'><p>Read output from STARsolo</p></a></li>
<li><a href='#ReadVitessce'><p>Read Data From Vitessce</p></a></li>
<li><a href='#ReadVizgen'><p>Read and Load MERFISH Input from Vizgen</p></a></li>
<li><a href='#RegroupIdents'><p>Regroup idents based on meta.data info</p></a></li>
<li><a href='#RelativeCounts'><p>Normalize raw data to fractions</p></a></li>
<li><a href='#RenameCells.SCTAssay'><p>Rename Cells in an Object</p></a></li>
<li><a href='#RidgePlot'><p>Single cell ridge plot</p></a></li>
<li><a href='#RPCAIntegration'><p>Seurat-RPCA Integration</p></a></li>
<li><a href='#RunCCA'><p>Perform Canonical Correlation Analysis</p></a></li>
<li><a href='#RunGraphLaplacian'><p>Run Graph Laplacian Eigendecomposition</p></a></li>
<li><a href='#RunICA'><p>Run Independent Component Analysis on gene expression</p></a></li>
<li><a href='#RunLDA'><p>Run Linear Discriminant Analysis</p></a></li>
<li><a href='#RunMarkVario'><p>Run the mark variogram computation on a given position matrix and expression</p>
matrix.</a></li>
<li><a href='#RunMixscape'><p>Run Mixscape</p></a></li>
<li><a href='#RunMoransI'><p>Compute Moran's I value.</p></a></li>
<li><a href='#RunPCA'><p>Run Principal Component Analysis</p></a></li>
<li><a href='#RunSLSI'><p>Run Supervised Latent Semantic Indexing</p></a></li>
<li><a href='#RunSPCA'><p>Run Supervised Principal Component Analysis</p></a></li>
<li><a href='#RunTSNE'><p>Run t-distributed Stochastic Neighbor Embedding</p></a></li>
<li><a href='#RunUMAP'><p>Run UMAP</p></a></li>
<li><a href='#SampleUMI'><p>Sample UMI</p></a></li>
<li><a href='#SaveAnnoyIndex'><p>Save the Annoy index</p></a></li>
<li><a href='#ScaleData'><p>Scale and center the data.</p></a></li>
<li><a href='#ScaleFactors'><p>Get image scale factors</p></a></li>
<li><a href='#ScoreJackStraw'><p>Compute Jackstraw scores significance.</p></a></li>
<li><a href='#SCTAssay-class'><p>The SCTModel Class</p></a></li>
<li><a href='#SCTransform'><p>Perform sctransform-based normalization</p></a></li>
<li><a href='#SCTResults'><p>Get SCT results from an Assay</p></a></li>
<li><a href='#SelectIntegrationFeatures'><p>Select integration features</p></a></li>
<li><a href='#SelectIntegrationFeatures5'><p>Select integration features</p></a></li>
<li><a href='#SelectSCTIntegrationFeatures'><p>Select SCT integration features</p></a></li>
<li><a href='#SetIntegrationData'><p>Set integration data</p></a></li>
<li><a href='#SetQuantile'><p>Find the Quantile of Data</p></a></li>
<li><a href='#Seurat-class'><p>The Seurat Class</p></a></li>
<li><a href='#Seurat-package'><p>Seurat: Tools for Single Cell Genomics</p></a></li>
<li><a href='#SeuratCommand-class'><p>The SeuratCommand Class</p></a></li>
<li><a href='#SeuratTheme'><p>Seurat Themes</p></a></li>
<li><a href='#SingleCorPlot'><p>A single correlation plot</p></a></li>
<li><a href='#SingleDimPlot'><p>Plot a single dimension</p></a></li>
<li><a href='#SingleExIPlot'><p>Plot a single expression by identity on a plot</p></a></li>
<li><a href='#SingleImageMap'><p>A single heatmap from base R using <code>image</code></p></a></li>
<li><a href='#SingleImagePlot'><p>Single Spatial Plot</p></a></li>
<li><a href='#SingleRasterMap'><p>A single heatmap from ggplot2 using geom_raster</p></a></li>
<li><a href='#SingleSpatialPlot'><p>Base plotting function for all Spatial plots</p></a></li>
<li><a href='#SketchData'><p>Sketch Data</p></a></li>
<li><a href='#SlideSeq-class'><p>The SlideSeq class</p></a></li>
<li><a href='#SpatialImage-class'><p>The SpatialImage Class</p></a></li>
<li><a href='#SpatialPlot'><p>Visualize spatial clustering and expression data.</p></a></li>
<li><a href='#SplitObject'><p>Splits object into a list of subsetted objects.</p></a></li>
<li><a href='#STARmap-class'><p>The STARmap class</p></a></li>
<li><a href='#subset.AnchorSet'><p>Subset an AnchorSet object</p></a></li>
<li><a href='#SubsetByBarcodeInflections'><p>Subset a Seurat Object based on the Barcode Distribution Inflection Points</p></a></li>
<li><a href='#TopCells'><p>Find cells with highest scores for a given dimensional reduction technique</p></a></li>
<li><a href='#TopFeatures'><p>Find features with highest scores for a given dimensional reduction technique</p></a></li>
<li><a href='#TopNeighbors'><p>Get nearest neighbors for given cell</p></a></li>
<li><a href='#TransferAnchorSet-class'><p>The TransferAnchorSet Class</p></a></li>
<li><a href='#TransferData'><p>Transfer data</p></a></li>
<li><a href='#TransferSketchLabels'><p>Transfer data from sketch data to full data</p></a></li>
<li><a href='#UnSketchEmbeddings'><p>Transfer embeddings from sketched cells to the full data</p></a></li>
<li><a href='#UpdateSCTAssays'><p>Update pre-V4 Assays generated with SCTransform in the Seurat to the new</p>
SCTAssay class</a></li>
<li><a href='#UpdateSymbolList'><p>Get updated synonyms for gene symbols</p></a></li>
<li><a href='#VariableFeaturePlot'><p>View variable features</p></a></li>
<li><a href='#VisiumV1-class'><p>The VisiumV1 class</p></a></li>
<li><a href='#VizDimLoadings'><p>Visualize Dimensional Reduction genes</p></a></li>
<li><a href='#VlnPlot'><p>Single cell violin plot</p></a></li>
<li><a href='#VST'><p>Variance Stabilizing Transformation</p></a></li>
<li><a href='#writing-integration'><p>Writing Integration Method Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>5.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Single Cell Genomics</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for quality control, analysis, and exploration of single cell RNA sequencing data. 'Seurat' aims to enable users to identify and interpret sources of heterogeneity from single cell transcriptomic measurements, and to integrate diverse types of single cell data. See Satija R, Farrell J, Gennert D, et al (2015) &lt;<a href="https://doi.org/10.1038%2Fnbt.3192">doi:10.1038/nbt.3192</a>&gt;, Macosko E, Basu A, Satija R, et al (2015) &lt;<a href="https://doi.org/10.1016%2Fj.cell.2015.05.002">doi:10.1016/j.cell.2015.05.002</a>&gt;, Stuart T, Butler A, et al (2019) &lt;<a href="https://doi.org/10.1016%2Fj.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>&gt;, and Hao, Hao, et al (2020) &lt;<a href="https://doi.org/10.1101%2F2020.10.12.335331">doi:10.1101/2020.10.12.335331</a>&gt; for more details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://satijalab.org/seurat">https://satijalab.org/seurat</a>, <a href="https://github.com/satijalab/seurat">https://github.com/satijalab/seurat</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/satijalab/seurat/issues">https://github.com/satijalab/seurat/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://satijalab.r-universe.dev">https://satijalab.r-universe.dev</a>,
<a href="https://bnprks.r-universe.dev">https://bnprks.r-universe.dev</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods, SeuratObject (&ge; 5.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, cowplot, fastDummies, fitdistrplus, future,
future.apply, generics (&ge; 0.1.3), ggplot2 (&ge; 3.3.0), ggrepel,
ggridges, graphics, grDevices, grid, httr, ica, igraph, irlba,
jsonlite, KernSmooth, leiden (&ge; 0.3.1), lifecycle, lmtest,
MASS, Matrix (&ge; 1.5-0), matrixStats, miniUI, patchwork,
pbapply, plotly (&ge; 4.9.0), png, progressr, purrr, RANN,
RColorBrewer, Rcpp (&ge; 1.0.7), RcppAnnoy (&ge; 0.0.18), RcppHNSW,
reticulate, rlang, ROCR, RSpectra, Rtsne, scales, scattermore
(&ge; 1.2), sctransform (&ge; 0.4.1), shiny, spatstat.explore,
spatstat.geom, stats, tibble, tools, utils, uwot (&ge; 0.1.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0), RcppEigen, RcppProgress</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'reexports.R' 'generics.R' 'clustering.R'
'visualization.R' 'convenience.R' 'data.R'
'differential_expression.R' 'dimensional_reduction.R'
'integration.R' 'zzz.R' 'integration5.R' 'mixscape.R'
'objects.R' 'preprocessing.R' 'preprocessing5.R' 'roxygen.R'
'sketching.R' 'tree.R' 'utilities.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, BPCells, rsvd, testthat, hdf5r, S4Vectors,
SummarizedExperiment, SingleCellExperiment, MAST, DESeq2,
BiocGenerics, GenomicRanges, GenomeInfoDb, IRanges,
rtracklayer, Rfast2, monocle, Biobase, VGAM, limma, metap,
enrichR, mixtools, ggrastr, data.table, R.utils, presto,
DelayedArray, harmony</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 21:12:54 UTC; collinsd</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Butler <a href="https://orcid.org/0000-0003-3608-0463"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Saket Choudhary <a href="https://orcid.org/0000-0001-5202-7633"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Charlotte Darby <a href="https://orcid.org/0000-0003-2195-5300"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jeff Farrell [ctb],
  Isabella Grabski <a href="https://orcid.org/0000-0002-0616-5469"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Christoph Hafemeister
    <a href="https://orcid.org/0000-0001-6365-8254"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Yuhan Hao <a href="https://orcid.org/0000-0002-1810-0822"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Austin Hartman <a href="https://orcid.org/0000-0001-7278-1852"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Paul Hoffman <a href="https://orcid.org/0000-0002-7693-8957"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jaison Jain <a href="https://orcid.org/0000-0002-9478-5018"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Longda Jiang <a href="https://orcid.org/0000-0003-4964-6497"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Madeline Kowalski <a href="https://orcid.org/0000-0002-5655-7620"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Skylar Li [ctb],
  Gesmira Molla <a href="https://orcid.org/0000-0002-8628-5056"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Efthymia Papalexi <a href="https://orcid.org/0000-0001-5898-694X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Patrick Roelli [ctb],
  Rahul Satija <a href="https://orcid.org/0000-0001-9448-8833"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Karthik Shekhar [ctb],
  Avi Srivastava <a href="https://orcid.org/0000-0001-9798-2079"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Tim Stuart <a href="https://orcid.org/0000-0002-3044-0897"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Kristof Torkenczy <a href="https://orcid.org/0000-0002-4869-7957"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Shiwei Zheng <a href="https://orcid.org/0000-0001-6682-6743"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Satija Lab and Collaborators [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rahul Satija &lt;seurat@nygenome.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddAzimuthResults'>Add Azimuth Results</h2><span id='topic+AddAzimuthResults'></span>

<h3>Description</h3>

<p>Add mapping and prediction scores, UMAP embeddings, and imputed assay (if
available)
from Azimuth to an existing or new <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAzimuthResults(object = NULL, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddAzimuthResults_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="AddAzimuthResults_+3A_filename">filename</code></td>
<td>
<p>Path to Azimuth mapping scores file</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with Azimuth results added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
object &lt;- AddAzimuthResults(object, filename = "azimuth_results.Rds")

## End(Not run)

</code></pre>

<hr>
<h2 id='AddAzimuthScores'>Add Azimuth Scores</h2><span id='topic+AddAzimuthScores'></span>

<h3>Description</h3>

<p>Add mapping and prediction scores from Azimuth to a
<code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAzimuthScores(object, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddAzimuthScores_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="AddAzimuthScores_+3A_filename">filename</code></td>
<td>
<p>Path to Azimuth mapping scores file</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with the mapping scores added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
object &lt;- AddAzimuthScores(object, filename = "azimuth_pred.tsv")

## End(Not run)

</code></pre>

<hr>
<h2 id='AddModuleScore'>Calculate module scores for feature expression programs in single cells</h2><span id='topic+AddModuleScore'></span>

<h3>Description</h3>

<p>Calculate the average expression levels of each program (cluster) on single
cell level, subtracted by the aggregated expression of control feature sets.
All analyzed features are binned based on averaged expression, and the
control features are randomly selected from each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddModuleScore(
  object,
  features,
  pool = NULL,
  nbin = 24,
  ctrl = 100,
  k = FALSE,
  assay = NULL,
  name = "Cluster",
  seed = 1,
  search = FALSE,
  slot = "data",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddModuleScore_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_features">features</code></td>
<td>
<p>A list of vectors of features for expression programs; each
entry should be a vector of feature names</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_pool">pool</code></td>
<td>
<p>List of features to check expression levels against, defaults to
<code>rownames(x = object)</code></p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_nbin">nbin</code></td>
<td>
<p>Number of bins of aggregate expression levels for all
analyzed features</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_ctrl">ctrl</code></td>
<td>
<p>Number of control features selected from the same bin per
analyzed feature</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_k">k</code></td>
<td>
<p>Use feature clusters returned from DoKMeans</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_name">name</code></td>
<td>
<p>Name for the expression programs; will append a number to the
end for each entry in <code>features</code> (eg. if <code>features</code> has three
programs, the results will be stored as <code>name1</code>, <code>name2</code>,
<code>name3</code>, respectively)</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_seed">seed</code></td>
<td>
<p>Set a random seed. If NULL, seed is not set.</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_search">search</code></td>
<td>
<p>Search for symbol synonyms for features in <code>features</code> that
don't match features in <code>object</code>? Searches the HGNC's gene names
database; see <code><a href="#topic+UpdateSymbolList">UpdateSymbolList</a></code> for more details</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_slot">slot</code></td>
<td>
<p>Slot to calculate score values off of. Defaults to data slot (i.e log-normalized counts)</p>
</td></tr>
<tr><td><code id="AddModuleScore_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+UpdateSymbolList">UpdateSymbolList</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with module scores added to object meta data;
each module is stored as <code>name#</code> for each module program present in
<code>features</code>
</p>


<h3>References</h3>

<p>Tirosh et al, Science (2016)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
cd_features &lt;- list(c(
  'CD79B',
  'CD79A',
  'CD19',
  'CD180',
  'CD200',
  'CD3D',
  'CD2',
  'CD3E',
  'CD7',
  'CD8A',
  'CD14',
  'CD1C',
  'CD68',
  'CD9',
  'CD247'
))
pbmc_small &lt;- AddModuleScore(
  object = pbmc_small,
  features = cd_features,
  ctrl = 5,
  name = 'CD_Features'
)
head(x = pbmc_small[])

## End(Not run)

</code></pre>

<hr>
<h2 id='AggregateExpression'>Aggregated feature expression by identity class</h2><span id='topic+AggregateExpression'></span>

<h3>Description</h3>

<p>Returns summed counts (&quot;pseudobulk&quot;) for each identity class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AggregateExpression(
  object,
  assays = NULL,
  features = NULL,
  return.seurat = FALSE,
  group.by = "ident",
  add.ident = NULL,
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  margin = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AggregateExpression_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_assays">assays</code></td>
<td>
<p>Which assays to use. Default is all assays</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_features">features</code></td>
<td>
<p>Features to analyze. Default is all features in the assay</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_return.seurat">return.seurat</code></td>
<td>
<p>Whether to return the data as a Seurat object. Default is FALSE</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_group.by">group.by</code></td>
<td>
<p>Category (or vector of categories) for grouping (e.g, ident, replicate, celltype); 'ident' by default
To use multiple categories, specify a vector, such as c('ident', 'replicate', 'celltype')</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_add.ident">add.ident</code></td>
<td>
<p>(Deprecated). Place an additional label on each cell prior to pseudobulking</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Method for normalization, see <code><a href="#topic+NormalizeData">NormalizeData</a></code></p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Scale factor for normalization, see <code><a href="#topic+NormalizeData">NormalizeData</a></code></p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_margin">margin</code></td>
<td>
<p>Margin to perform CLR normalization, see <code><a href="#topic+NormalizeData">NormalizeData</a></code></p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and show progress bar</p>
</td></tr>
<tr><td><code id="AggregateExpression_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods such as <code><a href="#topic+CreateSeuratObject">CreateSeuratObject</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>return.seurat = TRUE</code>, aggregated values are placed in the 'counts'
layer of the returned object. The data is then normalized by running <code><a href="#topic+NormalizeData">NormalizeData</a></code>
on the aggregated counts. <code><a href="#topic+ScaleData">ScaleData</a></code> is then run on the default assay
before returning the object.
</p>


<h3>Value</h3>

<p>Returns a matrix with genes as rows, identity classes as columns.
If return.seurat is TRUE, returns an object of class <code><a href="#topic+Seurat">Seurat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
head(AggregateExpression(object = pbmc_small)$RNA)
head(AggregateExpression(object = pbmc_small, group.by = c('ident', 'groups'))$RNA)

## End(Not run)

</code></pre>

<hr>
<h2 id='AnchorSet-class'>The AnchorSet Class</h2><span id='topic+AnchorSet-class'></span><span id='topic+AnchorSet'></span>

<h3>Description</h3>

<p>The AnchorSet class is an intermediate data storage class that stores the anchors and other
related information needed for performing downstream analyses - namely data integration
(<code><a href="#topic+IntegrateData">IntegrateData</a></code>) and data transfer (<code><a href="#topic+TransferData">TransferData</a></code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>object.list</code></dt><dd><p>List of objects used to create anchors</p>
</dd>
<dt><code>reference.cells</code></dt><dd><p>List of cell names in the reference dataset - needed when performing data
transfer.</p>
</dd>
<dt><code>reference.objects</code></dt><dd><p>Position of reference object/s in object.list</p>
</dd>
<dt><code>query.cells</code></dt><dd><p>List of cell names in the query dataset - needed when performing data transfer</p>
</dd>
<dt><code>anchors</code></dt><dd><p>The anchor matrix. This contains the cell indices of both anchor pair cells, the
anchor score, and the index of the original dataset in the object.list for cell1 and cell2 of
the anchor.</p>
</dd>
<dt><code>offsets</code></dt><dd><p>The offsets used to enable cell look up in downstream functions</p>
</dd>
<dt><code>weight.reduction</code></dt><dd><p>The weight dimensional reduction used to calculate weight matrix</p>
</dd>
<dt><code>anchor.features</code></dt><dd><p>The features used when performing anchor finding.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>List containing Neighbor objects for reuse later (e.g. mapping)</p>
</dd>
<dt><code>command</code></dt><dd><p>Store log of parameters that were used</p>
</dd>
</dl>

<hr>
<h2 id='AnnotateAnchors'>Add info to anchor matrix</h2><span id='topic+AnnotateAnchors'></span><span id='topic+AnnotateAnchors.default'></span><span id='topic+AnnotateAnchors.IntegrationAnchorSet'></span><span id='topic+AnnotateAnchors.TransferAnchorSet'></span>

<h3>Description</h3>

<p>Add info to anchor matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnnotateAnchors(anchors, vars, slot, ...)

## Default S3 method:
AnnotateAnchors(
  anchors,
  vars = NULL,
  slot = NULL,
  object.list,
  assay = NULL,
  ...
)

## S3 method for class 'IntegrationAnchorSet'
AnnotateAnchors(
  anchors,
  vars = NULL,
  slot = NULL,
  object.list = NULL,
  assay = NULL,
  ...
)

## S3 method for class 'TransferAnchorSet'
AnnotateAnchors(
  anchors,
  vars = NULL,
  slot = NULL,
  reference = NULL,
  query = NULL,
  assay = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnnotateAnchors_+3A_anchors">anchors</code></td>
<td>
<p>An <code><a href="#topic+AnchorSet">AnchorSet</a></code> object</p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_vars">vars</code></td>
<td>
<p>Variables to pull for each object via FetchData</p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_slot">slot</code></td>
<td>
<p>Slot to pull feature data for</p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_object.list">object.list</code></td>
<td>
<p>List of Seurat objects</p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_assay">assay</code></td>
<td>
<p>Specify the Assay per object if annotating with expression data</p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_reference">reference</code></td>
<td>
<p>Reference object used in <code><a href="#topic+FindTransferAnchors">FindTransferAnchors</a></code></p>
</td></tr>
<tr><td><code id="AnnotateAnchors_+3A_query">query</code></td>
<td>
<p>Query object used in <code><a href="#topic+FindTransferAnchors">FindTransferAnchors</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the anchor dataframe with additional columns for annotation
metadata
</p>

<hr>
<h2 id='as.CellDataSet'>Convert objects to CellDataSet objects</h2><span id='topic+as.CellDataSet'></span><span id='topic+as.CellDataSet.Seurat'></span>

<h3>Description</h3>

<p>Convert objects to CellDataSet objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.CellDataSet(x, ...)

## S3 method for class 'Seurat'
as.CellDataSet(x, assay = NULL, reduction = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.CellDataSet_+3A_x">x</code></td>
<td>
<p>An object to convert to class <code>CellDataSet</code></p>
</td></tr>
<tr><td><code id="as.CellDataSet_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="as.CellDataSet_+3A_assay">assay</code></td>
<td>
<p>Assay to convert</p>
</td></tr>
<tr><td><code id="as.CellDataSet_+3A_reduction">reduction</code></td>
<td>
<p>Name of DimReduc to set to main reducedDim in cds</p>
</td></tr>
</table>

<hr>
<h2 id='as.Seurat.CellDataSet'>Convert objects to <code>Seurat</code> objects</h2><span id='topic+as.Seurat.CellDataSet'></span><span id='topic+as.Seurat.SingleCellExperiment'></span>

<h3>Description</h3>

<p>Convert objects to <code>Seurat</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CellDataSet'
as.Seurat(x, slot = "counts", assay = "RNA", verbose = TRUE, ...)

## S3 method for class 'SingleCellExperiment'
as.Seurat(
  x,
  counts = "counts",
  data = "logcounts",
  assay = NULL,
  project = "SingleCellExperiment",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Seurat.CellDataSet_+3A_x">x</code></td>
<td>
<p>An object to convert to class <code>Seurat</code></p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_slot">slot</code></td>
<td>
<p>Slot to store expression data as</p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_assay">assay</code></td>
<td>
<p>Name of assays to convert; set to <code>NULL</code> for all assays to be converted</p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_verbose">verbose</code></td>
<td>
<p>Show progress updates</p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_counts">counts</code></td>
<td>
<p>name of the SingleCellExperiment assay to store as <code>counts</code>;
set to <code>NULL</code> if only normalized data are present</p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_data">data</code></td>
<td>
<p>name of the SingleCellExperiment assay to slot as <code>data</code>.
Set to NULL if only counts are present</p>
</td></tr>
<tr><td><code id="as.Seurat.CellDataSet_+3A_project">project</code></td>
<td>
<p>Project name for new Seurat object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Seurat</code> object generated from <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+as.Seurat">SeuratObject::as.Seurat</a></code>
</p>

<hr>
<h2 id='as.SingleCellExperiment'>Convert objects to SingleCellExperiment objects</h2><span id='topic+as.SingleCellExperiment'></span><span id='topic+as.SingleCellExperiment.Seurat'></span>

<h3>Description</h3>

<p>Convert objects to SingleCellExperiment objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SingleCellExperiment(x, ...)

## S3 method for class 'Seurat'
as.SingleCellExperiment(x, assay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SingleCellExperiment_+3A_x">x</code></td>
<td>
<p>An object to convert to class <code>SingleCellExperiment</code></p>
</td></tr>
<tr><td><code id="as.SingleCellExperiment_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="as.SingleCellExperiment_+3A_assay">assay</code></td>
<td>
<p>Assays to convert</p>
</td></tr>
</table>

<hr>
<h2 id='as.sparse.H5Group'>Cast to Sparse</h2><span id='topic+as.sparse.H5Group'></span><span id='topic+as.data.frame.Matrix'></span>

<h3>Description</h3>

<p>Cast to Sparse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'H5Group'
as.sparse(x, ...)

## S3 method for class 'Matrix'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  stringsAsFactors = getOption(x = "stringsAsFactors", default = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sparse.H5Group_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="as.sparse.H5Group_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="as.sparse.H5Group_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row names for
the data; missing values are not allowed</p>
</td></tr>
<tr><td><code id="as.sparse.H5Group_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code><a href="base.html#topic+make.names">make.names</a></code>) is optional.  Note that all of <span class="rlang"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code><a href="base.html#topic+data.frame">data.frame</a>(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td></tr>
<tr><td><code id="as.sparse.H5Group_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should the character vector be converted
to a factor?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.data.frame.Matrix</code>: A data frame representation of the S4 Matrix
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+as.sparse">SeuratObject::as.sparse</a></code>
</p>

<hr>
<h2 id='Assay-class'>The Assay Class</h2><span id='topic+Assay-class'></span>

<h3>Description</h3>

<p>The <code>Assay</code> object is the basic unit of Seurat; for more details, please
see the documentation in <code><a href="SeuratObject.html#topic+Assay">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+Assay">SeuratObject::Assay-class</a></code>
</p>

<hr>
<h2 id='AugmentPlot'>Augments ggplot2-based plot with a PNG image.</h2><span id='topic+AugmentPlot'></span>

<h3>Description</h3>

<p>Creates &quot;vector-friendly&quot; plots. Does this by saving a copy of the plot as a PNG file,
then adding the PNG image with <code><a href="ggplot2.html#topic+annotation_raster">annotation_raster</a></code> to a blank plot
of the same dimensions as <code>plot</code>. Please note: original legends and axes will be lost
during augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AugmentPlot(plot, width = 10, height = 10, dpi = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AugmentPlot_+3A_plot">plot</code></td>
<td>
<p>A ggplot object</p>
</td></tr>
<tr><td><code id="AugmentPlot_+3A_width">width</code>, <code id="AugmentPlot_+3A_height">height</code></td>
<td>
<p>Width and height of PNG version of plot</p>
</td></tr>
<tr><td><code id="AugmentPlot_+3A_dpi">dpi</code></td>
<td>
<p>Plot resolution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
plot &lt;- DimPlot(object = pbmc_small)
AugmentPlot(plot = plot)

## End(Not run)

</code></pre>

<hr>
<h2 id='AutoPointSize'>Automagically calculate a point size for ggplot2-based scatter plots</h2><span id='topic+AutoPointSize'></span>

<h3>Description</h3>

<p>It happens to look good
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoPointSize(data, raster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoPointSize_+3A_data">data</code></td>
<td>
<p>A data frame being passed to ggplot2</p>
</td></tr>
<tr><td><code id="AutoPointSize_+3A_raster">raster</code></td>
<td>
<p>If TRUE, point size is set to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The &quot;optimal&quot; point size for visualizing these data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = rnorm(n = 10000), y = runif(n = 10000))
AutoPointSize(data = df)

</code></pre>

<hr>
<h2 id='AverageExpression'>Averaged feature expression by identity class</h2><span id='topic+AverageExpression'></span>

<h3>Description</h3>

<p>Returns averaged expression values for each identity class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AverageExpression(
  object,
  assays = NULL,
  features = NULL,
  return.seurat = FALSE,
  group.by = "ident",
  add.ident = NULL,
  layer = "data",
  slot = deprecated(),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AverageExpression_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_assays">assays</code></td>
<td>
<p>Which assays to use. Default is all assays</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_features">features</code></td>
<td>
<p>Features to analyze. Default is all features in the assay</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_return.seurat">return.seurat</code></td>
<td>
<p>Whether to return the data as a Seurat object. Default is FALSE</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_group.by">group.by</code></td>
<td>
<p>Category (or vector of categories) for grouping (e.g, ident, replicate, celltype); 'ident' by default
To use multiple categories, specify a vector, such as c('ident', 'replicate', 'celltype')</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_add.ident">add.ident</code></td>
<td>
<p>(Deprecated). Place an additional label on each cell prior to pseudobulking</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_layer">layer</code></td>
<td>
<p>Layer(s) to use; if multiple layers are given, assumed to follow
the order of 'assays' (if specified) or object's assays</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_slot">slot</code></td>
<td>
<p>(Deprecated). Slots(s) to use</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and show progress bar</p>
</td></tr>
<tr><td><code id="AverageExpression_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods such as <code><a href="#topic+CreateSeuratObject">CreateSeuratObject</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If layer is set to 'data', this function assumes that the data has been log
normalized and therefore feature values are exponentiated prior to averaging
so that averaging is done in non-log space. Otherwise, if layer is set to
either 'counts' or 'scale.data', no exponentiation is performed prior to  averaging.
If <code>return.seurat = TRUE</code> and layer is not 'scale.data', averaged values
are placed in the 'counts' layer of the returned object and 'log1p'
is run on the averaged counts and placed in the 'data' layer <code><a href="#topic+ScaleData">ScaleData</a></code>
is then run on the default assay before returning the object.
If <code>return.seurat = TRUE</code> and layer is 'scale.data', the 'counts' layer contains
average counts and 'scale.data' is set to the averaged values of 'scale.data'.
</p>


<h3>Value</h3>

<p>Returns a matrix with genes as rows, identity classes as columns.
If return.seurat is TRUE, returns an object of class <code><a href="#topic+Seurat">Seurat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
head(AverageExpression(object = pbmc_small)$RNA)
head(AverageExpression(object = pbmc_small, group.by = c('ident', 'groups'))$RNA)

</code></pre>

<hr>
<h2 id='BarcodeInflectionsPlot'>Plot the Barcode Distribution and Calculated Inflection Points</h2><span id='topic+BarcodeInflectionsPlot'></span>

<h3>Description</h3>

<p>This function plots the calculated inflection points derived from the barcode-rank
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BarcodeInflectionsPlot(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BarcodeInflectionsPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See [CalculateBarcodeInflections()] to calculate inflection points and
[SubsetByBarcodeInflections()] to subsequently subset the Seurat object.
</p>


<h3>Value</h3>

<p>Returns a 'ggplot2' object showing the by-group inflection points and provided
(or default) rank threshold values in grey.
</p>


<h3>Author(s)</h3>

<p>Robert A. Amezquita, <a href="mailto:robert.amezquita@fredhutch.org">robert.amezquita@fredhutch.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateBarcodeInflections">CalculateBarcodeInflections</a></code> <code><a href="#topic+SubsetByBarcodeInflections">SubsetByBarcodeInflections</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small &lt;- CalculateBarcodeInflections(pbmc_small, group.column = 'groups')
BarcodeInflectionsPlot(pbmc_small)

</code></pre>

<hr>
<h2 id='BGTextColor'>Determine text color based on background color</h2><span id='topic+BGTextColor'></span>

<h3>Description</h3>

<p>Determine text color based on background color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGTextColor(
  background,
  threshold = 186,
  w3c = FALSE,
  dark = "black",
  light = "white"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGTextColor_+3A_background">background</code></td>
<td>
<p>A vector of background colors; supports R color names and
hexadecimal codes</p>
</td></tr>
<tr><td><code id="BGTextColor_+3A_threshold">threshold</code></td>
<td>
<p>Intensity threshold for light/dark cutoff; intensities
greater than <code>theshold</code> yield <code>dark</code>, others yield <code>light</code></p>
</td></tr>
<tr><td><code id="BGTextColor_+3A_w3c">w3c</code></td>
<td>
<p>Use <a href="https://www.w3.org/TR/WCAG20/">W3C</a> formula for calculating
background text color; ignores <code>threshold</code></p>
</td></tr>
<tr><td><code id="BGTextColor_+3A_dark">dark</code></td>
<td>
<p>Color for dark text</p>
</td></tr>
<tr><td><code id="BGTextColor_+3A_light">light</code></td>
<td>
<p>Color for light text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of either <code>dark</code> or <code>light</code>, depending on
<code>background</code>; names of vector are <code>background</code>
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color">https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BGTextColor(background = c('black', 'white', '#E76BF3'))

</code></pre>

<hr>
<h2 id='BlackAndWhite'>Create a custom color palette</h2><span id='topic+BlackAndWhite'></span><span id='topic+BlueAndRed'></span><span id='topic+CustomPalette'></span><span id='topic+PurpleAndYellow'></span>

<h3>Description</h3>

<p>Creates a custom color palette based on low, middle, and high color values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlackAndWhite(mid = NULL, k = 50)

BlueAndRed(k = 50)

CustomPalette(low = "white", high = "red", mid = NULL, k = 50)

PurpleAndYellow(k = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BlackAndWhite_+3A_mid">mid</code></td>
<td>
<p>middle color. Optional.</p>
</td></tr>
<tr><td><code id="BlackAndWhite_+3A_k">k</code></td>
<td>
<p>number of steps (colors levels) to include between low and high values</p>
</td></tr>
<tr><td><code id="BlackAndWhite_+3A_low">low</code></td>
<td>
<p>low color</p>
</td></tr>
<tr><td><code id="BlackAndWhite_+3A_high">high</code></td>
<td>
<p>high color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color palette for plotting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
plot(df, col = BlackAndWhite())

df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
plot(df, col = BlueAndRed())

myPalette &lt;- CustomPalette()
myPalette

df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
plot(df, col = PurpleAndYellow())

</code></pre>

<hr>
<h2 id='BridgeCellsRepresentation'>Construct a dictionary representation for each unimodal dataset</h2><span id='topic+BridgeCellsRepresentation'></span>

<h3>Description</h3>

<p>Construct a dictionary representation for each unimodal dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BridgeCellsRepresentation(
  object.list,
  bridge.object,
  object.reduction,
  bridge.reduction,
  laplacian.reduction = "lap",
  laplacian.dims = 1:50,
  bridge.assay.name = "Bridge",
  return.all.assays = FALSE,
  l2.norm = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BridgeCellsRepresentation_+3A_object.list">object.list</code></td>
<td>
<p>A list of Seurat objects</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_bridge.object">bridge.object</code></td>
<td>
<p>A multi-omic bridge Seurat which is used as the basis to
represent unimodal datasets</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_object.reduction">object.reduction</code></td>
<td>
<p>A list of dimensional reductions from object.list used
to be reconstructed by bridge.object</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_bridge.reduction">bridge.reduction</code></td>
<td>
<p>A list of dimensional reductions from bridge.object used
to reconstruct object.reduction</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_laplacian.reduction">laplacian.reduction</code></td>
<td>
<p>Name of bridge graph laplacian dimensional reduction</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_laplacian.dims">laplacian.dims</code></td>
<td>
<p>Dimensions used for bridge graph laplacian dimensional reduction</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_bridge.assay.name">bridge.assay.name</code></td>
<td>
<p>Assay name used for bridge object reconstruction value (default is 'Bridge')</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_return.all.assays">return.all.assays</code></td>
<td>
<p>Whether to return all assays in the object.list.
Only bridge assay is returned by default.</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Whether to l2 normalize the dictionary representation</p>
</td></tr>
<tr><td><code id="BridgeCellsRepresentation_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a object list in which each object has a bridge cell derived assay
</p>

<hr>
<h2 id='BridgeReferenceSet-class'>The BridgeReferenceSet Class
The BridgeReferenceSet is an output from PrepareBridgeReference</h2><span id='topic+BridgeReferenceSet-class'></span><span id='topic+BridgeReferenceSet'></span>

<h3>Description</h3>

<p>The BridgeReferenceSet Class
The BridgeReferenceSet is an output from PrepareBridgeReference
</p>


<h3>Slots</h3>


<dl>
<dt><code>bridge</code></dt><dd><p>The multi-omic object</p>
</dd>
<dt><code>reference</code></dt><dd><p>The Reference object only containing bridge representation assay</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of parameters used in the PrepareBridgeReference</p>
</dd>
<dt><code>command</code></dt><dd><p>Store log of parameters that were used</p>
</dd>
</dl>

<hr>
<h2 id='BuildClusterTree'>Phylogenetic Analysis of Identity Classes</h2><span id='topic+BuildClusterTree'></span>

<h3>Description</h3>

<p>Constructs a phylogenetic tree relating the 'average' cell from each
identity class. Tree is estimated based on a distance matrix constructed in
either gene expression space or PCA space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildClusterTree(
  object,
  assay = NULL,
  features = NULL,
  dims = NULL,
  reduction = "pca",
  graph = NULL,
  slot = "data",
  reorder = FALSE,
  reorder.numeric = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildClusterTree_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_assay">assay</code></td>
<td>
<p>Assay to use for the analysis.</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_features">features</code></td>
<td>
<p>Genes to use for the analysis. Default is the set of
variable genes (<code>VariableFeatures(object = object)</code>)</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_dims">dims</code></td>
<td>
<p>If set, tree is calculated in dimension reduction space;
overrides <code>features</code></p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_reduction">reduction</code></td>
<td>
<p>Name of dimension reduction to use. Only used if <code>dims</code>
is not NULL.</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_graph">graph</code></td>
<td>
<p>If graph is passed, build tree based on graph connectivity between
clusters; overrides <code>dims</code> and <code>features</code></p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_slot">slot</code></td>
<td>
<p>(Deprecated). Slots(s) to use</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_reorder">reorder</code></td>
<td>
<p>Re-order identity classes (factor ordering), according to
position on the tree. This groups similar classes together which can be
helpful, for example, when drawing violin plots.</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_reorder.numeric">reorder.numeric</code></td>
<td>
<p>Re-order identity classes according to position on
the tree, assigning a numeric value ('1' is the leftmost node)</p>
</td></tr>
<tr><td><code id="BuildClusterTree_+3A_verbose">verbose</code></td>
<td>
<p>Show progress updates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the tree is calculated for an 'average' cell, so gene expression
or PC scores are averaged across all cells in an identity class before the
tree is constructed.
</p>


<h3>Value</h3>

<p>A Seurat object where the cluster tree can be accessed with <code><a href="#topic+Tool">Tool</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("ape", quietly = TRUE)) {
  data("pbmc_small")
  pbmc_small
  pbmc_small &lt;- BuildClusterTree(object = pbmc_small)
  Tool(object = pbmc_small, slot = 'BuildClusterTree')
}

## End(Not run)

</code></pre>

<hr>
<h2 id='BuildNicheAssay'>Construct an assay for spatial niche analysis</h2><span id='topic+BuildNicheAssay'></span>

<h3>Description</h3>

<p>This function will construct a new assay where each feature is a
cell label The values represents the sum of a particular cell label
neighboring a given cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildNicheAssay(
  object,
  fov,
  group.by,
  assay = "niche",
  neighbors.k = 20,
  niches.k = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildNicheAssay_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="BuildNicheAssay_+3A_fov">fov</code></td>
<td>
<p>FOV object to gather cell positions from</p>
</td></tr>
<tr><td><code id="BuildNicheAssay_+3A_group.by">group.by</code></td>
<td>
<p>Cell classifications to count in spatial neighborhood</p>
</td></tr>
<tr><td><code id="BuildNicheAssay_+3A_assay">assay</code></td>
<td>
<p>Name for spatial neighborhoods assay</p>
</td></tr>
<tr><td><code id="BuildNicheAssay_+3A_neighbors.k">neighbors.k</code></td>
<td>
<p>Number of neighbors to consider for each cell</p>
</td></tr>
<tr><td><code id="BuildNicheAssay_+3A_niches.k">niches.k</code></td>
<td>
<p>Number of clusters to return based on the niche assay</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Seurat object containing a new assay
</p>

<hr>
<h2 id='CalcDispersion'>Calculate dispersion of features</h2><span id='topic+CalcDispersion'></span>

<h3>Description</h3>

<p>Calculate dispersion of features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcDispersion(
  object,
  mean.function = FastExpMean,
  dispersion.function = FastLogVMR,
  num.bin = 20,
  binning.method = "equal_width",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcDispersion_+3A_object">object</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="CalcDispersion_+3A_mean.function">mean.function</code></td>
<td>
<p>Function to calculate mean</p>
</td></tr>
<tr><td><code id="CalcDispersion_+3A_dispersion.function">dispersion.function</code></td>
<td>
<p>Function to calculate dispersion</p>
</td></tr>
<tr><td><code id="CalcDispersion_+3A_num.bin">num.bin</code></td>
<td>
<p>Number of bins to use</p>
</td></tr>
<tr><td><code id="CalcDispersion_+3A_binning.method">binning.method</code></td>
<td>
<p>Method to use for binning. Options are 'equal_width' or 'equal_frequency'</p>
</td></tr>
<tr><td><code id="CalcDispersion_+3A_verbose">verbose</code></td>
<td>
<p>Display progress</p>
</td></tr>
</table>

<hr>
<h2 id='CalcPerturbSig'>Calculate a perturbation Signature</h2><span id='topic+CalcPerturbSig'></span>

<h3>Description</h3>

<p>Function to calculate perturbation signature for pooled CRISPR screen datasets.
For each target cell (expressing one target gRNA), we identified 20 cells
from the control pool (non-targeting cells) with the most similar mRNA
expression profiles. The perturbation signature is calculated by subtracting the
averaged mRNA expression profile of the non-targeting neighbors from the mRNA
expression profile of the target cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcPerturbSig(
  object,
  assay = NULL,
  features = NULL,
  slot = "data",
  gd.class = "guide_ID",
  nt.cell.class = "NT",
  split.by = NULL,
  num.neighbors = NULL,
  reduction = "pca",
  ndims = 15,
  new.assay.name = "PRTB",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcPerturbSig_+3A_object">object</code></td>
<td>
<p>An object of class Seurat.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_assay">assay</code></td>
<td>
<p>Name of Assay PRTB  signature is being calculated on.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_features">features</code></td>
<td>
<p>Features to compute PRTB signature for. Defaults to the
variable features set in the assay specified.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_slot">slot</code></td>
<td>
<p>Data slot to use for PRTB signature calculation.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_gd.class">gd.class</code></td>
<td>
<p>Metadata column containing target gene classification.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_nt.cell.class">nt.cell.class</code></td>
<td>
<p>Non-targeting gRNA cell classification identity.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_split.by">split.by</code></td>
<td>
<p>Provide metadata column if multiple biological replicates
exist to calculate PRTB signature for every replicate separately.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_num.neighbors">num.neighbors</code></td>
<td>
<p>Number of nearest neighbors to consider.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_reduction">reduction</code></td>
<td>
<p>Reduction method used to calculate nearest neighbors.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_ndims">ndims</code></td>
<td>
<p>Number of dimensions to use from dimensionality reduction method.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_new.assay.name">new.assay.name</code></td>
<td>
<p>Name for the new assay.</p>
</td></tr>
<tr><td><code id="CalcPerturbSig_+3A_verbose">verbose</code></td>
<td>
<p>Display progress + messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with a new assay added containing the
perturbation signature for all cells in the data slot.
</p>

<hr>
<h2 id='CalculateBarcodeInflections'>Calculate the Barcode Distribution Inflection</h2><span id='topic+CalculateBarcodeInflections'></span>

<h3>Description</h3>

<p>This function calculates an adaptive inflection point (&quot;knee&quot;) of the barcode distribution
for each sample group. This is useful for determining a threshold for removing
low-quality samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateBarcodeInflections(
  object,
  barcode.column = "nCount_RNA",
  group.column = "orig.ident",
  threshold.low = NULL,
  threshold.high = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateBarcodeInflections_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="CalculateBarcodeInflections_+3A_barcode.column">barcode.column</code></td>
<td>
<p>Column to use as proxy for barcodes (&quot;nCount_RNA&quot; by default)</p>
</td></tr>
<tr><td><code id="CalculateBarcodeInflections_+3A_group.column">group.column</code></td>
<td>
<p>Column to group by (&quot;orig.ident&quot; by default)</p>
</td></tr>
<tr><td><code id="CalculateBarcodeInflections_+3A_threshold.low">threshold.low</code></td>
<td>
<p>Ignore barcodes of rank below this threshold in inflection calculation</p>
</td></tr>
<tr><td><code id="CalculateBarcodeInflections_+3A_threshold.high">threshold.high</code></td>
<td>
<p>Ignore barcodes of rank above thisf threshold in inflection calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function operates by calculating the slope of the barcode number vs. rank
distribution, and then finding the point at which the distribution changes most
steeply (the &quot;knee&quot;). Of note, this calculation often must be restricted as to the
range at which it performs, so 'threshold' parameters are provided to restrict the
range of the calculation based on the rank of the barcodes. [BarcodeInflectionsPlot()]
is provided as a convenience function to visualize and test different thresholds and
thus provide more sensical end results.
</p>
<p>See [BarcodeInflectionsPlot()] to visualize the calculated inflection points and
[SubsetByBarcodeInflections()] to subsequently subset the Seurat object.
</p>


<h3>Value</h3>

<p>Returns Seurat object with a new list in the 'tools' slot, 'CalculateBarcodeInflections' with values:
</p>
<p>* 'barcode_distribution' - contains the full barcode distribution across the entire dataset
* 'inflection_points' - the calculated inflection points within the thresholds
* 'threshold_values' - the provided (or default) threshold values to search within for inflections
* 'cells_pass' - the cells that pass the inflection point calculation
</p>


<h3>Author(s)</h3>

<p>Robert A. Amezquita, <a href="mailto:robert.amezquita@fredhutch.org">robert.amezquita@fredhutch.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BarcodeInflectionsPlot">BarcodeInflectionsPlot</a></code> <code><a href="#topic+SubsetByBarcodeInflections">SubsetByBarcodeInflections</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
CalculateBarcodeInflections(pbmc_small, group.column = 'groups')

</code></pre>

<hr>
<h2 id='CaseMatch'>Match the case of character vectors</h2><span id='topic+CaseMatch'></span>

<h3>Description</h3>

<p>Match the case of character vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CaseMatch(search, match)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CaseMatch_+3A_search">search</code></td>
<td>
<p>A vector of search terms</p>
</td></tr>
<tr><td><code id="CaseMatch_+3A_match">match</code></td>
<td>
<p>A vector of characters whose case should be matched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Values from search present in match with the case of match
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
cd_genes &lt;- c('Cd79b', 'Cd19', 'Cd200')
CaseMatch(search = cd_genes, match = rownames(x = pbmc_small))

</code></pre>

<hr>
<h2 id='cc.genes'>Cell cycle genes</h2><span id='topic+cc.genes'></span>

<h3>Description</h3>

<p>A list of genes used in cell-cycle regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc.genes
</code></pre>


<h3>Format</h3>

<p>A list of two vectors
</p>

<dl>
<dt>s.genes</dt><dd><p>Genes associated with S-phase</p>
</dd>
<dt>g2m.genes</dt><dd><p>Genes associated with G2M-phase</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.science.org/doi/abs/10.1126/science.aad0501">https://www.science.org/doi/abs/10.1126/science.aad0501</a>
</p>

<hr>
<h2 id='cc.genes.updated.2019'>Cell cycle genes: 2019 update</h2><span id='topic+cc.genes.updated.2019'></span>

<h3>Description</h3>

<p>A list of genes used in cell-cycle regression, updated with 2019 symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc.genes.updated.2019
</code></pre>


<h3>Format</h3>

<p>A list of two vectors
</p>

<dl>
<dt>s.genes</dt><dd><p>Genes associated with S-phase</p>
</dd>
<dt>g2m.genes</dt><dd><p>Genes associated with G2M-phase</p>
</dd>
</dl>



<h3>Updated symbols</h3>

<p>The following symbols were updated from <code><a href="#topic+cc.genes">cc.genes</a></code>
</p>

<dl>
<dt>s.genes</dt><dd>

<ul>
<li> <p><em>MCM2</em>: <em>MCM7</em>
</p>
</li>
<li> <p><em>MLF1IP</em>: <em>CENPU</em>
</p>
</li>
<li> <p><em>RPA2</em>: <em>POLR1B</em>
</p>
</li>
<li> <p><em>BRIP1</em>: <em>MRPL36</em>
</p>
</li></ul>

</dd>
<dt>g2m.genes</dt><dd>

<ul>
<li> <p><em>FAM64A</em>: <em>PIMREG</em>
</p>
</li>
<li> <p><em>HN1</em>: <em>JPT1</em>
</p>
</li></ul>

</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.science.org/doi/abs/10.1126/science.aad0501">https://www.science.org/doi/abs/10.1126/science.aad0501</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc.genes">cc.genes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cc.genes.updated.2019 &lt;- cc.genes
cc.genes.updated.2019$s.genes &lt;- UpdateSymbolList(symbols = cc.genes.updated.2019$s.genes)
cc.genes.updated.2019$g2m.genes &lt;- UpdateSymbolList(symbols = cc.genes.updated.2019$g2m.genes)

## End(Not run)

</code></pre>

<hr>
<h2 id='CCAIntegration'>Seurat-CCA Integration</h2><span id='topic+CCAIntegration'></span>

<h3>Description</h3>

<p>Seurat-CCA Integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCAIntegration(
  object = NULL,
  assay = NULL,
  layers = NULL,
  orig = NULL,
  new.reduction = "integrated.dr",
  reference = NULL,
  features = NULL,
  normalization.method = c("LogNormalize", "SCT"),
  dims = 1:30,
  k.filter = NA,
  scale.layer = "scale.data",
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCAIntegration_+3A_object">object</code></td>
<td>
<p>A <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_assay">assay</code></td>
<td>
<p>Name of <code>Assay</code> in the <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_layers">layers</code></td>
<td>
<p>Names of layers in <code>assay</code></p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_orig">orig</code></td>
<td>
<p>A <a href="SeuratObject.html#topic+DimReduc">dimensional reduction</a> to correct</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_new.reduction">new.reduction</code></td>
<td>
<p>Name of new integrated dimensional reduction</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_reference">reference</code></td>
<td>
<p>A reference <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_features">features</code></td>
<td>
<p>A vector of features to use for integration</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_dims">dims</code></td>
<td>
<p>Dimensions of dimensional reduction to use for integration</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_k.filter">k.filter</code></td>
<td>
<p>Number of anchors to filter</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_scale.layer">scale.layer</code></td>
<td>
<p>Name of scaled layer in <code>Assay</code></p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_dims.to.integrate">dims.to.integrate</code></td>
<td>
<p>Number of dimensions to return integrated values for</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_weight.reduction">weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li><p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li><p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li><p>A vector of <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li><p>NULL, in which case the full corrected space is used for computing
anchor weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_sd.weight">sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_sample.tree">sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code><a href="stats.html#topic+hclust">hclust</a></code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_preserve.order">preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
<tr><td><code id="CCAIntegration_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>FindIntegrationAnchors</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Preprocessing
obj &lt;- SeuratData::LoadData("pbmcsca")
obj[["RNA"]] &lt;- split(obj[["RNA"]], f = obj$Method)
obj &lt;- NormalizeData(obj)
obj &lt;- FindVariableFeatures(obj)
obj &lt;- ScaleData(obj)
obj &lt;- RunPCA(obj)

# After preprocessing, we integrate layers.
obj &lt;- IntegrateLayers(object = obj, method = CCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.cca",
  verbose = FALSE)

# Modifying parameters
# We can also specify parameters such as `k.anchor` to increase the strength of integration
obj &lt;- IntegrateLayers(object = obj, method = CCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.cca",
  k.anchor = 20, verbose = FALSE)

# Integrating SCTransformed data
obj &lt;- SCTransform(object = obj)
obj &lt;- IntegrateLayers(object = obj, method = CCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.cca",
  assay = "SCT", verbose = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='CellCycleScoring'>Score cell cycle phases</h2><span id='topic+CellCycleScoring'></span>

<h3>Description</h3>

<p>Score cell cycle phases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CellCycleScoring(
  object,
  s.features,
  g2m.features,
  ctrl = NULL,
  set.ident = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CellCycleScoring_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="CellCycleScoring_+3A_s.features">s.features</code></td>
<td>
<p>A vector of features associated with S phase</p>
</td></tr>
<tr><td><code id="CellCycleScoring_+3A_g2m.features">g2m.features</code></td>
<td>
<p>A vector of features associated with G2M phase</p>
</td></tr>
<tr><td><code id="CellCycleScoring_+3A_ctrl">ctrl</code></td>
<td>
<p>Number of control features selected from the same bin per
analyzed feature supplied to <code><a href="#topic+AddModuleScore">AddModuleScore</a></code>.
Defaults to value equivalent to minimum number of features
present in 's.features' and 'g2m.features'.</p>
</td></tr>
<tr><td><code id="CellCycleScoring_+3A_set.ident">set.ident</code></td>
<td>
<p>If true, sets identity to phase assignments
Stashes old identities in 'old.ident'</p>
</td></tr>
<tr><td><code id="CellCycleScoring_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+AddModuleScore">AddModuleScore</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with the following columns added to object meta data: S.Score, G2M.Score, and Phase
</p>


<h3>See Also</h3>

<p><code>AddModuleScore</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
# pbmc_small doesn't have any cell-cycle genes
# To run CellCycleScoring, please use a dataset with cell-cycle genes
# An example is available at http://satijalab.org/seurat/cell_cycle_vignette.html
pbmc_small &lt;- CellCycleScoring(
  object = pbmc_small,
  g2m.features = cc.genes$g2m.genes,
  s.features = cc.genes$s.genes
)
head(x = pbmc_small@meta.data)

## End(Not run)

</code></pre>

<hr>
<h2 id='Cells.SCTModel'>Get Cell Names</h2><span id='topic+Cells.SCTModel'></span><span id='topic+Cells.SlideSeq'></span><span id='topic+Cells.STARmap'></span><span id='topic+Cells.VisiumV1'></span>

<h3>Description</h3>

<p>Get Cell Names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCTModel'
Cells(x, ...)

## S3 method for class 'SlideSeq'
Cells(x, ...)

## S3 method for class 'STARmap'
Cells(x, ...)

## S3 method for class 'VisiumV1'
Cells(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cells.SCTModel_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="Cells.SCTModel_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+Cells">SeuratObject::Cells</a></code>
</p>

<hr>
<h2 id='CellsByImage'>Get a vector of cell names associated with an image (or set of images)</h2><span id='topic+CellsByImage'></span>

<h3>Description</h3>

<p>Get a vector of cell names associated with an image (or set of images)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CellsByImage(object, images = NULL, unlist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CellsByImage_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="CellsByImage_+3A_images">images</code></td>
<td>
<p>Vector of image names</p>
</td></tr>
<tr><td><code id="CellsByImage_+3A_unlist">unlist</code></td>
<td>
<p>Return as a single vector of cell names as opposed to a list,
named by image name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of cell names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
CellsByImage(object = object, images = "slice1")

## End(Not run)

</code></pre>

<hr>
<h2 id='CellScatter'>Cell-cell scatter plot</h2><span id='topic+CellScatter'></span><span id='topic+CellPlot'></span>

<h3>Description</h3>

<p>Creates a plot of scatter plot of features across two single cells. Pearson
correlation between the two cells is displayed above the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CellScatter(
  object,
  cell1,
  cell2,
  features = NULL,
  highlight = NULL,
  cols = NULL,
  pt.size = 1,
  smooth = FALSE,
  raster = NULL,
  raster.dpi = c(512, 512)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CellScatter_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_cell1">cell1</code></td>
<td>
<p>Cell 1 name</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_cell2">cell2</code></td>
<td>
<p>Cell 2 name</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_features">features</code></td>
<td>
<p>Features to plot (default, all features)</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_highlight">highlight</code></td>
<td>
<p>Features to highlight</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_cols">cols</code></td>
<td>
<p>Colors to use for identity class plotting.</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_pt.size">pt.size</code></td>
<td>
<p>Size of the points on the plot</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_smooth">smooth</code></td>
<td>
<p>Smooth the graph (similar to smoothScatter)</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code>
which will automatically use raster if the number of points plotted is greater than
100,000</p>
</td></tr>
<tr><td><code id="CellScatter_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Pixel resolution for rasterized plots, passed to geom_scattermore().
Default is c(512, 512).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
CellScatter(object = pbmc_small, cell1 = 'ATAGGAGAAACAGA', cell2 = 'CATCAGGATGCACA')

</code></pre>

<hr>
<h2 id='CellSelector'>Cell Selector</h2><span id='topic+CellSelector'></span><span id='topic+FeatureLocator'></span>

<h3>Description</h3>

<p>Select points on a scatterplot and get information about them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CellSelector(plot, object = NULL, ident = "SelectedCells", ...)

FeatureLocator(plot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CellSelector_+3A_plot">plot</code></td>
<td>
<p>A ggplot2 plot</p>
</td></tr>
<tr><td><code id="CellSelector_+3A_object">object</code></td>
<td>
<p>An optional Seurat object; if passes, will return an object
with the identities of selected cells set to <code>ident</code></p>
</td></tr>
<tr><td><code id="CellSelector_+3A_ident">ident</code></td>
<td>
<p>An optional new identity class to assign the selected cells</p>
</td></tr>
<tr><td><code id="CellSelector_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>object</code> is <code>NULL</code>, the names of the points selected;
otherwise, a Seurat object with the selected cells identity classes set to
<code>ident</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimPlot">DimPlot</a></code> <code><a href="#topic+FeaturePlot">FeaturePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
plot &lt;- DimPlot(object = pbmc_small)
# Follow instructions in the terminal to select points
cells.located &lt;- CellSelector(plot = plot)
cells.located
# Automatically set the identity class of selected cells and return a new Seurat object
pbmc_small &lt;- CellSelector(plot = plot, object = pbmc_small, ident = 'SelectedCells')

## End(Not run)

</code></pre>

<hr>
<h2 id='CollapseEmbeddingOutliers'>Move outliers towards center on dimension reduction plot</h2><span id='topic+CollapseEmbeddingOutliers'></span>

<h3>Description</h3>

<p>Move outliers towards center on dimension reduction plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CollapseEmbeddingOutliers(
  object,
  reduction = "umap",
  dims = 1:2,
  group.by = "ident",
  outlier.sd = 2,
  reduction.key = "UMAP_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CollapseEmbeddingOutliers_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="CollapseEmbeddingOutliers_+3A_reduction">reduction</code></td>
<td>
<p>Name of DimReduc to adjust</p>
</td></tr>
<tr><td><code id="CollapseEmbeddingOutliers_+3A_dims">dims</code></td>
<td>
<p>Dimensions to visualize</p>
</td></tr>
<tr><td><code id="CollapseEmbeddingOutliers_+3A_group.by">group.by</code></td>
<td>
<p>Group (color) cells in different ways (for example, orig.ident)</p>
</td></tr>
<tr><td><code id="CollapseEmbeddingOutliers_+3A_outlier.sd">outlier.sd</code></td>
<td>
<p>Controls the outlier distance</p>
</td></tr>
<tr><td><code id="CollapseEmbeddingOutliers_+3A_reduction.key">reduction.key</code></td>
<td>
<p>Key for DimReduc that is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a DimReduc object with the modified embeddings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small &lt;- FindClusters(pbmc_small, resolution = 1.1)
pbmc_small &lt;- RunUMAP(pbmc_small, dims = 1:5)
DimPlot(pbmc_small, reduction = "umap")
pbmc_small[["umap_new"]] &lt;- CollapseEmbeddingOutliers(pbmc_small,
    reduction = "umap", reduction.key = 'umap_', outlier.sd = 0.5)
DimPlot(pbmc_small, reduction = "umap_new")

## End(Not run)

</code></pre>

<hr>
<h2 id='CollapseSpeciesExpressionMatrix'>Slim down a multi-species expression matrix, when only one species is primarily of interenst.</h2><span id='topic+CollapseSpeciesExpressionMatrix'></span>

<h3>Description</h3>

<p>Valuable for CITE-seq analyses, where we typically spike in rare populations of 'negative control' cells from a different species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CollapseSpeciesExpressionMatrix(
  object,
  prefix = "HUMAN_",
  controls = "MOUSE_",
  ncontrols = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CollapseSpeciesExpressionMatrix_+3A_object">object</code></td>
<td>
<p>A UMI count matrix. Should contain rownames that start with
the ensuing arguments prefix.1 or prefix.2</p>
</td></tr>
<tr><td><code id="CollapseSpeciesExpressionMatrix_+3A_prefix">prefix</code></td>
<td>
<p>The prefix denoting rownames for the species of interest.
Default is &quot;HUMAN_&quot;. These rownames will have this prefix removed in the returned matrix.</p>
</td></tr>
<tr><td><code id="CollapseSpeciesExpressionMatrix_+3A_controls">controls</code></td>
<td>
<p>The prefix denoting rownames for the species of 'negative
control' cells. Default is &quot;MOUSE_&quot;.</p>
</td></tr>
<tr><td><code id="CollapseSpeciesExpressionMatrix_+3A_ncontrols">ncontrols</code></td>
<td>
<p>How many of the most highly expressed (average) negative
control features (by default, 100 mouse genes), should be kept? All other
rownames starting with prefix.2 are discarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A UMI count matrix. Rownames that started with <code>prefix</code> have this
prefix discarded. For rownames starting with <code>controls</code>, only the
<code>ncontrols</code> most highly expressed features are kept, and the
prefix is kept. All other rows are retained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cbmc.rna.collapsed &lt;- CollapseSpeciesExpressionMatrix(cbmc.rna)

## End(Not run)

</code></pre>

<hr>
<h2 id='ColorDimSplit'>Color dimensional reduction plot by tree split</h2><span id='topic+ColorDimSplit'></span>

<h3>Description</h3>

<p>Returns a DimPlot colored based on whether the cells fall in clusters
to the left or to the right of a node split in the cluster tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColorDimSplit(
  object,
  node,
  left.color = "red",
  right.color = "blue",
  other.color = "grey50",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ColorDimSplit_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="ColorDimSplit_+3A_node">node</code></td>
<td>
<p>Node in cluster tree on which to base the split</p>
</td></tr>
<tr><td><code id="ColorDimSplit_+3A_left.color">left.color</code></td>
<td>
<p>Color for the left side of the split</p>
</td></tr>
<tr><td><code id="ColorDimSplit_+3A_right.color">right.color</code></td>
<td>
<p>Color for the right side of the split</p>
</td></tr>
<tr><td><code id="ColorDimSplit_+3A_other.color">other.color</code></td>
<td>
<p>Color for all other cells</p>
</td></tr>
<tr><td><code id="ColorDimSplit_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+DimPlot">DimPlot</a></code>
</p>

<dl>
<dt><code>dims</code></dt><dd><p>Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions</p>
</dd>
<dt><code>cells</code></dt><dd><p>Vector of cells to plot (default is all cells)</p>
</dd>
<dt><code>cols</code></dt><dd><p>Vector of colors, each color corresponds to an identity class. This may also be a single character
or numeric value corresponding to a palette as specified by <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>.
By default, ggplot2 assigns colors. We also include a number of palettes from the pals package.
See <code><a href="#topic+DiscretePalette">DiscretePalette</a></code> for details.</p>
</dd>
<dt><code>pt.size</code></dt><dd><p>Adjust point size for plotting</p>
</dd>
<dt><code>reduction</code></dt><dd><p>Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca</p>
</dd>
<dt><code>group.by</code></dt><dd><p>Name of one or more metadata columns to group (color) cells by
(for example, orig.ident); pass 'ident' to group by identity class</p>
</dd>
<dt><code>split.by</code></dt><dd><p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'</p>
</dd>
<dt><code>shape.by</code></dt><dd><p>If NULL, all points are circles (default). You can specify any
cell attribute (that can be pulled with FetchData) allowing for both
different colors and different shapes on cells.  Only applicable if <code>raster = FALSE</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>Specify the order of plotting for the idents. This can be
useful for crowded plots if points of interest are being buried. Provide
either a full list of valid idents or a subset to be plotted last (on top)</p>
</dd>
<dt><code>shuffle</code></dt><dd><p>Whether to randomly shuffle the order of points. This can be
useful for crowded plots if points of interest are being buried. (default is FALSE)</p>
</dd>
<dt><code>seed</code></dt><dd><p>Sets the seed if randomly shuffling the order of points.</p>
</dd>
<dt><code>label</code></dt><dd><p>Whether to label the clusters</p>
</dd>
<dt><code>label.size</code></dt><dd><p>Sets size of labels</p>
</dd>
<dt><code>label.color</code></dt><dd><p>Sets the color of the label text</p>
</dd>
<dt><code>label.box</code></dt><dd><p>Whether to put a box around the label text (geom_text vs
geom_label)</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Alpha value for plotting (default is 1)</p>
</dd>
<dt><code>repel</code></dt><dd><p>Repel labels</p>
</dd>
<dt><code>cells.highlight</code></dt><dd><p>A list of character or numeric vectors of cells to
highlight. If only one group of cells desired, can simply
pass a vector instead of a list. If set, colors selected cells to the color(s)
in <code>cols.highlight</code> and other cells black (white if dark.theme = TRUE);
will also resize to the size(s) passed to <code>sizes.highlight</code></p>
</dd>
<dt><code>cols.highlight</code></dt><dd><p>A vector of colors to highlight the cells as; will
repeat to the length groups in cells.highlight</p>
</dd>
<dt><code>sizes.highlight</code></dt><dd><p>Size of highlighted cells; will repeat to the length
groups in cells.highlight.  If <code>sizes.highlight = TRUE</code> size of all
points will be this value.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>Color value for NA points when using custom scale</p>
</dd>
<dt><code>ncol</code></dt><dd><p>Number of columns for display when combining plots</p>
</dd>
<dt><code>combine</code></dt><dd><p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</dd>
<dt><code>raster</code></dt><dd><p>Convert points to raster format, default is <code>NULL</code> which
automatically rasterizes if plotting more than 100,000 cells</p>
</dd>
<dt><code>raster.dpi</code></dt><dd><p>Pixel resolution for rasterized plots, passed to geom_scattermore().
Default is c(512, 512).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a DimPlot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimPlot">DimPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("ape", quietly = TRUE)) {
  data("pbmc_small")
  pbmc_small &lt;- BuildClusterTree(object = pbmc_small, verbose = FALSE)
  PlotClusterTree(pbmc_small)
  ColorDimSplit(pbmc_small, node = 5)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='CombinePlots'>Combine ggplot2-based plots into a single plot</h2><span id='topic+CombinePlots'></span>

<h3>Description</h3>

<p>Combine ggplot2-based plots into a single plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombinePlots(plots, ncol = NULL, legend = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CombinePlots_+3A_plots">plots</code></td>
<td>
<p>A list of gg objects</p>
</td></tr>
<tr><td><code id="CombinePlots_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns</p>
</td></tr>
<tr><td><code id="CombinePlots_+3A_legend">legend</code></td>
<td>
<p>Combine legends into a single legend
choose from 'right' or 'bottom'; pass 'none' to remove legends, or <code>NULL</code>
to leave legends as they are</p>
</td></tr>
<tr><td><code id="CombinePlots_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to plot_grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small[['group']] &lt;- sample(
  x = c('g1', 'g2'),
  size = ncol(x = pbmc_small),
  replace = TRUE
)
plot1 &lt;- FeaturePlot(
  object = pbmc_small,
  features = 'MS4A1',
  split.by = 'group'
)
plot2 &lt;- FeaturePlot(
  object = pbmc_small,
  features = 'FCN1',
  split.by = 'group'
)
CombinePlots(
  plots = list(plot1, plot2),
  legend = 'none',
  nrow = length(x = unique(x = pbmc_small[['group', drop = TRUE]]))
)

</code></pre>

<hr>
<h2 id='components'>Objects exported from other packages</h2><span id='topic+components'></span><span id='topic++25+7C+7C+25'></span><span id='topic++25iff+25'></span><span id='topic+reexports'></span><span id='topic+AddMetaData'></span><span id='topic+as.Graph'></span><span id='topic+as.Neighbor'></span><span id='topic+as.Seurat'></span><span id='topic+as.sparse'></span><span id='topic+Assays'></span><span id='topic+Cells'></span><span id='topic+CellsByIdentities'></span><span id='topic+Command'></span><span id='topic+CreateAssayObject'></span><span id='topic+CreateDimReducObject'></span><span id='topic+CreateSeuratObject'></span><span id='topic+DefaultAssay'></span><span id='topic+DefaultAssay+3C-'></span><span id='topic+Distances'></span><span id='topic+Embeddings'></span><span id='topic+FetchData'></span><span id='topic+GetAssayData'></span><span id='topic+GetImage'></span><span id='topic+GetTissueCoordinates'></span><span id='topic+HVFInfo'></span><span id='topic+Idents'></span><span id='topic+Idents+3C-'></span><span id='topic+Images'></span><span id='topic+Index'></span><span id='topic+Index+3C-'></span><span id='topic+Indices'></span><span id='topic+IsGlobal'></span><span id='topic+JS'></span><span id='topic+JS+3C-'></span><span id='topic+Key'></span><span id='topic+Key+3C-'></span><span id='topic+Loadings'></span><span id='topic+Loadings+3C-'></span><span id='topic+LogSeuratCommand'></span><span id='topic+Misc'></span><span id='topic+Misc+3C-'></span><span id='topic+Neighbors'></span><span id='topic+Project'></span><span id='topic+Project+3C-'></span><span id='topic+Radius'></span><span id='topic+Reductions'></span><span id='topic+RenameCells'></span><span id='topic+RenameIdents'></span><span id='topic+ReorderIdent'></span><span id='topic+RowMergeSparseMatrices'></span><span id='topic+SetAssayData'></span><span id='topic+SetIdent'></span><span id='topic+SpatiallyVariableFeatures'></span><span id='topic+StashIdent'></span><span id='topic+Stdev'></span><span id='topic+SVFInfo'></span><span id='topic+Tool'></span><span id='topic+Tool+3C-'></span><span id='topic+UpdateSeuratObject'></span><span id='topic+VariableFeatures'></span><span id='topic+VariableFeatures+3C-'></span><span id='topic+WhichCells'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>SeuratObject</dt><dd><p><code><a href="SeuratObject.html#topic+AddMetaData">AddMetaData</a></code>, <code><a href="SeuratObject.html#topic+as.Graph">as.Graph</a></code>, <code><a href="SeuratObject.html#topic+as.Neighbor">as.Neighbor</a></code>, <code><a href="SeuratObject.html#topic+as.Seurat">as.Seurat</a></code>, <code><a href="SeuratObject.html#topic+as.sparse">as.sparse</a></code>, <code><a href="SeuratObject.html#topic+ObjectAccess">Assays</a></code>, <code><a href="SeuratObject.html#topic+Cells">Cells</a></code>, <code><a href="SeuratObject.html#topic+CellsByIdentities">CellsByIdentities</a></code>, <code><a href="SeuratObject.html#topic+Command">Command</a></code>, <code><a href="SeuratObject.html#topic+CreateAssayObject">CreateAssayObject</a></code>, <code><a href="SeuratObject.html#topic+CreateDimReducObject">CreateDimReducObject</a></code>, <code><a href="SeuratObject.html#topic+CreateSeuratObject">CreateSeuratObject</a></code>, <code><a href="SeuratObject.html#topic+DefaultAssay">DefaultAssay</a></code>, <code><a href="SeuratObject.html#topic+DefaultAssay">DefaultAssay&lt;-</a></code>, <code><a href="SeuratObject.html#topic+Distances">Distances</a></code>, <code><a href="SeuratObject.html#topic+Embeddings">Embeddings</a></code>, <code><a href="SeuratObject.html#topic+FetchData">FetchData</a></code>, <code><a href="SeuratObject.html#topic+AssayData">GetAssayData</a></code>, <code><a href="SeuratObject.html#topic+GetImage">GetImage</a></code>, <code><a href="SeuratObject.html#topic+GetTissueCoordinates">GetTissueCoordinates</a></code>, <code><a href="SeuratObject.html#topic+VariableFeatures">HVFInfo</a></code>, <code><a href="SeuratObject.html#topic+Idents">Idents</a></code>, <code><a href="SeuratObject.html#topic+Idents">Idents&lt;-</a></code>, <code><a href="SeuratObject.html#topic+Images">Images</a></code>, <code><a href="SeuratObject.html#topic+NNIndex">Index</a></code>, <code><a href="SeuratObject.html#topic+NNIndex">Index&lt;-</a></code>, <code><a href="SeuratObject.html#topic+Indices">Indices</a></code>, <code><a href="SeuratObject.html#topic+IsGlobal">IsGlobal</a></code>, <code><a href="SeuratObject.html#topic+JS">JS</a></code>, <code><a href="SeuratObject.html#topic+JS">JS&lt;-</a></code>, <code><a href="SeuratObject.html#topic+Key">Key</a></code>, <code><a href="SeuratObject.html#topic+Key">Key&lt;-</a></code>, <code><a href="SeuratObject.html#topic+Loadings">Loadings</a></code>, <code><a href="SeuratObject.html#topic+Loadings">Loadings&lt;-</a></code>, <code><a href="SeuratObject.html#topic+LogSeuratCommand">LogSeuratCommand</a></code>, <code><a href="SeuratObject.html#topic+Misc">Misc</a></code>, <code><a href="SeuratObject.html#topic+Misc">Misc&lt;-</a></code>, <code><a href="SeuratObject.html#topic+ObjectAccess">Neighbors</a></code>, <code><a href="SeuratObject.html#topic+Project">Project</a></code>, <code><a href="SeuratObject.html#topic+Project">Project&lt;-</a></code>, <code><a href="SeuratObject.html#topic+Radius">Radius</a></code>, <code><a href="SeuratObject.html#topic+ObjectAccess">Reductions</a></code>, <code><a href="SeuratObject.html#topic+RenameCells">RenameCells</a></code>, <code><a href="SeuratObject.html#topic+Idents">RenameIdents</a></code>, <code><a href="SeuratObject.html#topic+Idents">ReorderIdent</a></code>, <code><a href="SeuratObject.html#topic+RowMergeSparseMatrices">RowMergeSparseMatrices</a></code>, <code><a href="SeuratObject.html#topic+AssayData">SetAssayData</a></code>, <code><a href="SeuratObject.html#topic+Idents">SetIdent</a></code>, <code><a href="SeuratObject.html#topic+VariableFeatures">SpatiallyVariableFeatures</a></code>, <code><a href="SeuratObject.html#topic+Idents">StashIdent</a></code>, <code><a href="SeuratObject.html#topic+Stdev">Stdev</a></code>, <code><a href="SeuratObject.html#topic+VariableFeatures">SVFInfo</a></code>, <code><a href="SeuratObject.html#topic+Tool">Tool</a></code>, <code><a href="SeuratObject.html#topic+Tool">Tool&lt;-</a></code>, <code><a href="SeuratObject.html#topic+UpdateSeuratObject">UpdateSeuratObject</a></code>, <code><a href="SeuratObject.html#topic+VariableFeatures">VariableFeatures</a></code>, <code><a href="SeuratObject.html#topic+VariableFeatures">VariableFeatures&lt;-</a></code>, <code><a href="SeuratObject.html#topic+WhichCells">WhichCells</a></code></p>
</dd>
</dl>


<h3>Usage</h3>

<pre><code class='language-R'>components(object, ...)

x %||% y

x %iff% y
</code></pre>

<hr>
<h2 id='contrast-theory'>Get the intensity and/or luminance of a color</h2><span id='topic+contrast-theory'></span><span id='topic+Intensity'></span><span id='topic+Luminance'></span>

<h3>Description</h3>

<p>Get the intensity and/or luminance of a color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Intensity(color)

Luminance(color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrast-theory_+3A_color">color</code></td>
<td>
<p>A vector of colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of intensities/luminances for each color
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color">https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Intensity(color = c('black', 'white', '#E76BF3'))

Luminance(color = c('black', 'white', '#E76BF3'))

</code></pre>

<hr>
<h2 id='CountSketch'>Generate CountSketch random matrix</h2><span id='topic+CountSketch'></span>

<h3>Description</h3>

<p>Generate CountSketch random matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountSketch(nsketch, ncells, seed = NA_integer_, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountSketch_+3A_nsketch">nsketch</code></td>
<td>
<p>Number of sketching random cells</p>
</td></tr>
<tr><td><code id="CountSketch_+3A_ncells">ncells</code></td>
<td>
<p>Number of cells in the original data</p>
</td></tr>
<tr><td><code id="CountSketch_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or <code>NULL</code>
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="CountSketch_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>


<h3>References</h3>

<p>Clarkson, KL. &amp; Woodruff, DP.
Low-rank approximation and regression in input sparsity time.
Journal of the ACM (JACM). 2017 Jan 30;63(6):1-45.
<a href="https://dl.acm.org/doi/abs/10.1145/3019134">https://dl.acm.org/doi/abs/10.1145/3019134</a>;
</p>

<hr>
<h2 id='CreateCategoryMatrix'>Create one hot matrix for a given label</h2><span id='topic+CreateCategoryMatrix'></span>

<h3>Description</h3>

<p>Create one hot matrix for a given label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateCategoryMatrix(
  labels,
  method = c("aggregate", "average"),
  cells.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateCategoryMatrix_+3A_labels">labels</code></td>
<td>
<p>A vector of labels</p>
</td></tr>
<tr><td><code id="CreateCategoryMatrix_+3A_method">method</code></td>
<td>
<p>Method to aggregate cells with the same label. Either 'aggregate' or 'average'</p>
</td></tr>
<tr><td><code id="CreateCategoryMatrix_+3A_cells.name">cells.name</code></td>
<td>
<p>A vector of cell names</p>
</td></tr>
</table>

<hr>
<h2 id='CreateSCTAssayObject'>Create a SCT Assay object</h2><span id='topic+CreateSCTAssayObject'></span>

<h3>Description</h3>

<p>Create a SCT object from a feature (e.g. gene) expression matrix and a list of SCTModels.
The expected format of the input matrix is features x cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateSCTAssayObject(
  counts,
  data,
  scale.data = NULL,
  umi.assay = "RNA",
  min.cells = 0,
  min.features = 0,
  SCTModel.list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateSCTAssayObject_+3A_counts">counts</code></td>
<td>
<p>Unnormalized data such as raw counts or TPMs</p>
</td></tr>
<tr><td><code id="CreateSCTAssayObject_+3A_data">data</code></td>
<td>
<p>Prenormalized data; if provided, do not pass <code>counts</code></p>
</td></tr>
<tr><td><code id="CreateSCTAssayObject_+3A_scale.data">scale.data</code></td>
<td>
<p>a residual matrix</p>
</td></tr>
<tr><td><code id="CreateSCTAssayObject_+3A_umi.assay">umi.assay</code></td>
<td>
<p>The UMI assay name. Default is RNA</p>
</td></tr>
<tr><td><code id="CreateSCTAssayObject_+3A_min.cells">min.cells</code></td>
<td>
<p>Include features detected in at least this many cells. Will
subset the counts matrix as well. To reintroduce excluded features, create a
new object with a lower cutoff</p>
</td></tr>
<tr><td><code id="CreateSCTAssayObject_+3A_min.features">min.features</code></td>
<td>
<p>Include cells where at least this many features are
detected</p>
</td></tr>
<tr><td><code id="CreateSCTAssayObject_+3A_sctmodel.list">SCTModel.list</code></td>
<td>
<p>list of SCTModels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-unique cell or feature names are not allowed. Please make unique before
calling this function.
</p>

<hr>
<h2 id='CustomDistance'>Run a custom distance function on an input data matrix</h2><span id='topic+CustomDistance'></span>

<h3>Description</h3>

<p>Run a custom distance function on an input data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CustomDistance(my.mat, my.function, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CustomDistance_+3A_my.mat">my.mat</code></td>
<td>
<p>A matrix to calculate distance on</p>
</td></tr>
<tr><td><code id="CustomDistance_+3A_my.function">my.function</code></td>
<td>
<p>A function to calculate distance</p>
</td></tr>
<tr><td><code id="CustomDistance_+3A_...">...</code></td>
<td>
<p>Extra parameters to my.function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix
</p>


<h3>Author(s)</h3>

<p>Jean Fan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
# Define custom distance matrix
manhattan.distance &lt;- function(x, y) return(sum(abs(x-y)))

input.data &lt;- GetAssayData(pbmc_small, assay.type = "RNA", slot = "scale.data")
cell.manhattan.dist &lt;- CustomDistance(input.data, manhattan.distance)

</code></pre>

<hr>
<h2 id='DEenrichRPlot'>DE and EnrichR pathway visualization barplot</h2><span id='topic+DEenrichRPlot'></span>

<h3>Description</h3>

<p>DE and EnrichR pathway visualization barplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEenrichRPlot(
  object,
  ident.1 = NULL,
  ident.2 = NULL,
  balanced = TRUE,
  logfc.threshold = 0.25,
  assay = NULL,
  max.genes,
  test.use = "wilcox",
  p.val.cutoff = 0.05,
  cols = NULL,
  enrich.database = NULL,
  num.pathway = 10,
  return.gene.list = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEenrichRPlot_+3A_object">object</code></td>
<td>
<p>Name of object class Seurat.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_ident.1">ident.1</code></td>
<td>
<p>Cell class identity 1.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_ident.2">ident.2</code></td>
<td>
<p>Cell class identity 2.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_balanced">balanced</code></td>
<td>
<p>Option to display pathway enrichments for both negative and
positive DE genes.If false, only positive DE gene will be displayed.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average, at least
X-fold difference (log-scale) between the two groups of cells. Default is 0.25. 
Increasing logfc.threshold speeds up the function, but can miss weaker signals.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_assay">assay</code></td>
<td>
<p>Assay to use in differential expression testing</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_max.genes">max.genes</code></td>
<td>
<p>Maximum number of genes to use as input to enrichR.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_test.use">test.use</code></td>
<td>
<p>Denotes which test to use. Available options are:
</p>

<ul>
<li><p>&quot;wilcox&quot; : Identifies differentially expressed genes between two
groups of cells using a Wilcoxon Rank Sum test (default); will use a fast
implementation by Presto if installed
</p>
</li>
<li><p>&quot;wilcox_limma&quot; : Identifies differentially expressed genes between two
groups of cells using the limma implementation of the Wilcoxon Rank Sum test;
set this option to reproduce results from Seurat v4
</p>
</li>
<li><p>&quot;bimod&quot; : Likelihood-ratio test for single cell gene expression,
(McDavid et al., Bioinformatics, 2013)
</p>
</li>
<li><p>&quot;roc&quot; : Identifies 'markers' of gene expression using ROC analysis.
For each gene, evaluates (using AUC) a classifier built on that gene alone,
to classify between two groups of cells. An AUC value of 1 means that
expression values for this gene alone can perfectly classify the two
groupings (i.e. Each of the cells in cells.1 exhibit a higher level than
each of the cells in cells.2). An AUC value of 0 also means there is perfect
classification, but in the other direction. A value of 0.5 implies that
the gene has no predictive power to classify the two groups. Returns a
'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially
expressed genes.
</p>
</li>
<li><p>&quot;t&quot; : Identify differentially expressed genes between two groups of
cells using the Student's t-test.
</p>
</li>
<li><p>&quot;negbinom&quot; : Identifies differentially expressed genes between two
groups of cells using a negative binomial generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;poisson&quot; : Identifies differentially expressed genes between two
groups of cells using a poisson generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;LR&quot; : Uses a logistic regression framework to determine differentially
expressed genes. Constructs a logistic regression model predicting group
membership based on each feature individually and compares this to a null
model with a likelihood ratio test.
</p>
</li>
<li><p>&quot;MAST&quot; : Identifies differentially expressed genes between two groups
of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST
package to run the DE testing.
</p>
</li>
<li><p>&quot;DESeq2&quot; : Identifies differentially expressed genes between two groups
of cells based on a model using DESeq2 which uses a negative binomial
distribution (Love et al, Genome Biology, 2014).This test does not support
pre-filtering of genes based on average difference (or percent detection rate)
between cell groups. However, genes may be pre-filtered based on their
minimum detection rate (min.pct) across both cell groups. To use this method,
please install DESeq2, using the instructions at
https://bioconductor.org/packages/release/bioc/html/DESeq2.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_p.val.cutoff">p.val.cutoff</code></td>
<td>
<p>Cutoff to select DE genes.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_cols">cols</code></td>
<td>
<p>A list of colors to use for barplots.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_enrich.database">enrich.database</code></td>
<td>
<p>Database to use from enrichR.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_num.pathway">num.pathway</code></td>
<td>
<p>Number of pathways to display in barplot.</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_return.gene.list">return.gene.list</code></td>
<td>
<p>Return list of DE genes</p>
</td></tr>
<tr><td><code id="DEenrichRPlot_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and to specific DE methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one (only enriched) or two (both enriched and depleted)
barplots with the top enriched/depleted GO terms from EnrichR.
</p>

<hr>
<h2 id='DietSeurat'>Slim down a Seurat object</h2><span id='topic+DietSeurat'></span>

<h3>Description</h3>

<p>Keep only certain aspects of the Seurat object. Can be useful in functions
that utilize merge as it reduces the amount of data in the merge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DietSeurat(
  object,
  layers = NULL,
  features = NULL,
  assays = NULL,
  dimreducs = NULL,
  graphs = NULL,
  misc = TRUE,
  counts = deprecated(),
  data = deprecated(),
  scale.data = deprecated(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DietSeurat_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_layers">layers</code></td>
<td>
<p>A vector or named list of layers to keep</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_features">features</code></td>
<td>
<p>Only keep a subset of features, defaults to all features</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_assays">assays</code></td>
<td>
<p>Only keep a subset of assays specified here</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_dimreducs">dimreducs</code></td>
<td>
<p>Only keep a subset of DimReducs specified here (if
<code>NULL</code>, remove all DimReducs)</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_graphs">graphs</code></td>
<td>
<p>Only keep a subset of Graphs specified here (if <code>NULL</code>,
remove all Graphs)</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_misc">misc</code></td>
<td>
<p>Preserve the <code>misc</code> slot; default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_counts">counts</code></td>
<td>
<p>Preserve the count matrices for the assays specified</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_data">data</code></td>
<td>
<p>Preserve the data matrices for the assays specified</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_scale.data">scale.data</code></td>
<td>
<p>Preserve the scale data matrices for the assays specified</p>
</td></tr>
<tr><td><code id="DietSeurat_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with only the sub-object specified retained
</p>

<hr>
<h2 id='DimHeatmap'>Dimensional reduction heatmap</h2><span id='topic+DimHeatmap'></span><span id='topic+PCHeatmap'></span>

<h3>Description</h3>

<p>Draws a heatmap focusing on a principal component. Both cells and genes are sorted by their
principal component scores. Allows for nice visualization of sources of heterogeneity in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DimHeatmap(
  object,
  dims = 1,
  nfeatures = 30,
  cells = NULL,
  reduction = "pca",
  disp.min = -2.5,
  disp.max = NULL,
  balanced = TRUE,
  projected = FALSE,
  ncol = NULL,
  fast = TRUE,
  raster = TRUE,
  slot = "scale.data",
  assays = NULL,
  combine = TRUE
)

PCHeatmap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DimHeatmap_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_dims">dims</code></td>
<td>
<p>Dimensions to plot</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of genes to plot</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_cells">cells</code></td>
<td>
<p>A list of cells to plot. If numeric, just plots the top cells.</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensional reduction to use</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_disp.min">disp.min</code></td>
<td>
<p>Minimum display value (all values below are clipped)</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_disp.max">disp.max</code></td>
<td>
<p>Maximum display value (all values above are clipped); defaults to 2.5
if <code>slot</code> is 'scale.data', 6 otherwise</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_balanced">balanced</code></td>
<td>
<p>Plot an equal number of genes with both + and - scores.</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_projected">projected</code></td>
<td>
<p>Use the full projected dimensional reduction</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns to plot</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_fast">fast</code></td>
<td>
<p>If true, use <code>image</code> to generate plots; faster than using ggplot2, but not customizable</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_raster">raster</code></td>
<td>
<p>If true, plot with geom_raster, else use geom_tile. geom_raster may look blurry on
some viewing applications such as Preview due to how the raster is interpolated. Set this to FALSE
if you are encountering that issue (note that plots may take longer to produce/render).</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_slot">slot</code></td>
<td>
<p>Data slot to use, choose from 'raw.data', 'data', or 'scale.data'</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_assays">assays</code></td>
<td>
<p>A vector of assays to pull data from</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</td></tr>
<tr><td><code id="DimHeatmap_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>DimHeatmap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value by default. If using fast = FALSE, will return a
<code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if combine = TRUE, otherwise
returns a list of ggplot objects
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code> <code><a href="ggplot2.html#topic+geom_raster">geom_raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
DimHeatmap(object = pbmc_small)

</code></pre>

<hr>
<h2 id='DimPlot'>Dimensional reduction plot</h2><span id='topic+DimPlot'></span><span id='topic+TSNEPlot'></span><span id='topic+PCAPlot'></span><span id='topic+ICAPlot'></span><span id='topic+UMAPPlot'></span>

<h3>Description</h3>

<p>Graphs the output of a dimensional reduction technique on a 2D scatter plot where each point is a
cell and it's positioned based on the cell embeddings determined by the reduction technique. By
default, cells are colored by their identity class (can be changed with the group.by parameter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DimPlot(
  object,
  dims = c(1, 2),
  cells = NULL,
  cols = NULL,
  pt.size = NULL,
  reduction = NULL,
  group.by = NULL,
  split.by = NULL,
  shape.by = NULL,
  order = NULL,
  shuffle = FALSE,
  seed = 1,
  label = FALSE,
  label.size = 4,
  label.color = "black",
  label.box = FALSE,
  repel = FALSE,
  alpha = 1,
  cells.highlight = NULL,
  cols.highlight = "#DE2D26",
  sizes.highlight = 1,
  na.value = "grey50",
  ncol = NULL,
  combine = TRUE,
  raster = NULL,
  raster.dpi = c(512, 512)
)

PCAPlot(object, ...)

TSNEPlot(object, ...)

UMAPPlot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DimPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_dims">dims</code></td>
<td>
<p>Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to plot (default is all cells)</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_cols">cols</code></td>
<td>
<p>Vector of colors, each color corresponds to an identity class. This may also be a single character
or numeric value corresponding to a palette as specified by <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>.
By default, ggplot2 assigns colors. We also include a number of palettes from the pals package.
See <code><a href="#topic+DiscretePalette">DiscretePalette</a></code> for details.</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Adjust point size for plotting</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of one or more metadata columns to group (color) cells by
(for example, orig.ident); pass 'ident' to group by identity class</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_shape.by">shape.by</code></td>
<td>
<p>If NULL, all points are circles (default). You can specify any
cell attribute (that can be pulled with FetchData) allowing for both
different colors and different shapes on cells.  Only applicable if <code>raster = FALSE</code>.</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_order">order</code></td>
<td>
<p>Specify the order of plotting for the idents. This can be
useful for crowded plots if points of interest are being buried. Provide
either a full list of valid idents or a subset to be plotted last (on top)</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to randomly shuffle the order of points. This can be
useful for crowded plots if points of interest are being buried. (default is FALSE)</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_seed">seed</code></td>
<td>
<p>Sets the seed if randomly shuffling the order of points.</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_label">label</code></td>
<td>
<p>Whether to label the clusters</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_label.size">label.size</code></td>
<td>
<p>Sets size of labels</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_label.color">label.color</code></td>
<td>
<p>Sets the color of the label text</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_label.box">label.box</code></td>
<td>
<p>Whether to put a box around the label text (geom_text vs
geom_label)</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_repel">repel</code></td>
<td>
<p>Repel labels</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for plotting (default is 1)</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_cells.highlight">cells.highlight</code></td>
<td>
<p>A list of character or numeric vectors of cells to
highlight. If only one group of cells desired, can simply
pass a vector instead of a list. If set, colors selected cells to the color(s)
in <code>cols.highlight</code> and other cells black (white if dark.theme = TRUE);
will also resize to the size(s) passed to <code>sizes.highlight</code></p>
</td></tr>
<tr><td><code id="DimPlot_+3A_cols.highlight">cols.highlight</code></td>
<td>
<p>A vector of colors to highlight the cells as; will
repeat to the length groups in cells.highlight</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_sizes.highlight">sizes.highlight</code></td>
<td>
<p>Size of highlighted cells; will repeat to the length
groups in cells.highlight.  If <code>sizes.highlight = TRUE</code> size of all
points will be this value.</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_na.value">na.value</code></td>
<td>
<p>Color value for NA points when using custom scale</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns for display when combining plots</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code> which
automatically rasterizes if plotting more than 100,000 cells</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Pixel resolution for rasterized plots, passed to geom_scattermore().
Default is c(512, 512).</p>
</td></tr>
<tr><td><code id="DimPlot_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>DimPlot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>


<h3>Note</h3>

<p>For the old <code>do.hover</code> and <code>do.identify</code> functionality, please see
<code>HoverLocator</code> and <code>CellSelector</code>, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FeaturePlot">FeaturePlot</a></code> <code><a href="#topic+HoverLocator">HoverLocator</a></code>
<code><a href="#topic+CellSelector">CellSelector</a></code> <code><a href="#topic+FetchData">FetchData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
DimPlot(object = pbmc_small)
DimPlot(object = pbmc_small, split.by = 'letter.idents')

</code></pre>

<hr>
<h2 id='DimReduc-class'>The DimReduc Class</h2><span id='topic+DimReduc-class'></span>

<h3>Description</h3>

<p>The <code>DimReduc</code> object stores a dimensionality reduction taken out in
Seurat; for more details, please see the documentation in
<code><a href="SeuratObject.html#topic+DimReduc">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+DimReduc">SeuratObject::DimReduc-class</a></code>
</p>

<hr>
<h2 id='DiscretePalette'>Discrete colour palettes from pals</h2><span id='topic+DiscretePalette'></span>

<h3>Description</h3>

<p>These are included here because pals depends on a number of compiled
packages, and this can lead to increases in run time for Travis,
and generally should be avoided when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscretePalette(n, palette = NULL, shuffle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscretePalette_+3A_n">n</code></td>
<td>
<p>Number of colours to be generated.</p>
</td></tr>
<tr><td><code id="DiscretePalette_+3A_palette">palette</code></td>
<td>
<p>Options are
&quot;alphabet&quot;, &quot;alphabet2&quot;, &quot;glasbey&quot;, &quot;polychrome&quot;, &quot;stepped&quot;, and &quot;parade&quot;.
Can be omitted and the function will use the one based on the requested n.</p>
</td></tr>
<tr><td><code id="DiscretePalette_+3A_shuffle">shuffle</code></td>
<td>
<p>Shuffle the colors in the selected palette.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These palettes are a much better default for data with many classes
than the default ggplot2 palette.
</p>
<p>Many thanks to Kevin Wright for writing the pals package.
</p>
<p>Taken from the pals package (Licence: GPL-3).
<a href="https://cran.r-project.org/package=pals">https://cran.r-project.org/package=pals</a>
Credit: Kevin Wright
</p>


<h3>Value</h3>

<p>A vector of colors
</p>

<hr>
<h2 id='DISP'>Find variable features based on dispersion</h2><span id='topic+DISP'></span>

<h3>Description</h3>

<p>Find variable features based on dispersion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DISP(data, nselect = 2000L, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DISP_+3A_data">data</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="DISP_+3A_nselect">nselect</code></td>
<td>
<p>Number of top features to select based on dispersion values</p>
</td></tr>
<tr><td><code id="DISP_+3A_verbose">verbose</code></td>
<td>
<p>Display progress</p>
</td></tr>
</table>

<hr>
<h2 id='DoHeatmap'>Feature expression heatmap</h2><span id='topic+DoHeatmap'></span>

<h3>Description</h3>

<p>Draws a heatmap of single cell feature expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoHeatmap(
  object,
  features = NULL,
  cells = NULL,
  group.by = "ident",
  group.bar = TRUE,
  group.colors = NULL,
  disp.min = -2.5,
  disp.max = NULL,
  slot = "scale.data",
  assay = NULL,
  label = TRUE,
  size = 5.5,
  hjust = 0,
  vjust = 0,
  angle = 45,
  raster = TRUE,
  draw.lines = TRUE,
  lines.width = NULL,
  group.bar.height = 0.02,
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoHeatmap_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_features">features</code></td>
<td>
<p>A vector of features to plot, defaults to <code>VariableFeatures(object = object)</code></p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_cells">cells</code></td>
<td>
<p>A vector of cells to plot</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_group.by">group.by</code></td>
<td>
<p>A vector of variables to group cells by; pass 'ident' to group by cell identity classes</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_group.bar">group.bar</code></td>
<td>
<p>Add a color bar showing group status for cells</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_group.colors">group.colors</code></td>
<td>
<p>Colors to use for the color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_disp.min">disp.min</code></td>
<td>
<p>Minimum display value (all values below are clipped)</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_disp.max">disp.max</code></td>
<td>
<p>Maximum display value (all values above are clipped); defaults to 2.5
if <code>slot</code> is 'scale.data', 6 otherwise</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_slot">slot</code></td>
<td>
<p>Data slot to use, choose from 'raw.data', 'data', or 'scale.data'</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_assay">assay</code></td>
<td>
<p>Assay to pull from</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_label">label</code></td>
<td>
<p>Label the cell identies above the color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_size">size</code></td>
<td>
<p>Size of text above color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_hjust">hjust</code></td>
<td>
<p>Horizontal justification of text above color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_vjust">vjust</code></td>
<td>
<p>Vertical justification of text above color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_angle">angle</code></td>
<td>
<p>Angle of text above color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_raster">raster</code></td>
<td>
<p>If true, plot with geom_raster, else use geom_tile. geom_raster may look blurry on
some viewing applications such as Preview due to how the raster is interpolated. Set this to FALSE
if you are encountering that issue (note that plots may take longer to produce/render).</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_draw.lines">draw.lines</code></td>
<td>
<p>Include white lines to separate the groups</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_lines.width">lines.width</code></td>
<td>
<p>Integer number to adjust the width of the separating white lines.
Corresponds to the number of &quot;cells&quot; between each group.</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_group.bar.height">group.bar.height</code></td>
<td>
<p>Scale the height of the color bar</p>
</td></tr>
<tr><td><code id="DoHeatmap_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
DoHeatmap(object = pbmc_small)

</code></pre>

<hr>
<h2 id='DotPlot'>Dot plot visualization</h2><span id='topic+DotPlot'></span><span id='topic+SplitDotPlotGG'></span>

<h3>Description</h3>

<p>Intuitive way of visualizing how feature expression changes across different
identity classes (clusters). The size of the dot encodes the percentage of
cells within a class, while the color encodes the AverageExpression level
across all cells within a class (blue is high).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DotPlot(
  object,
  features,
  assay = NULL,
  cols = c("lightgrey", "blue"),
  col.min = -2.5,
  col.max = 2.5,
  dot.min = 0,
  dot.scale = 6,
  idents = NULL,
  group.by = NULL,
  split.by = NULL,
  cluster.idents = FALSE,
  scale = TRUE,
  scale.by = "radius",
  scale.min = NA,
  scale.max = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DotPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_features">features</code></td>
<td>
<p>Input vector of features, or named list of feature vectors
if feature-grouped panels are desired (replicates the functionality of the
old SplitDotPlotGG)</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use, defaults to the active assay</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_cols">cols</code></td>
<td>
<p>Colors to plot: the name of a palette from
<code>RColorBrewer::brewer.pal.info</code>, a pair of colors defining a gradient,
or 3+ colors defining multiple gradients (if split.by is set)</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_col.min">col.min</code></td>
<td>
<p>Minimum scaled average expression threshold (everything
smaller will be set to this)</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_col.max">col.max</code></td>
<td>
<p>Maximum scaled average expression threshold (everything larger
will be set to this)</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_dot.min">dot.min</code></td>
<td>
<p>The fraction of cells at which to draw the smallest dot
(default is 0). All cell groups with less than this expressing the given
gene will have no dot drawn.</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_dot.scale">dot.scale</code></td>
<td>
<p>Scale the size of the points, similar to cex</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_idents">idents</code></td>
<td>
<p>Identity classes to include in plot (default is all)</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_group.by">group.by</code></td>
<td>
<p>Factor to group the cells by</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'
see <code><a href="#topic+FetchData">FetchData</a></code> for more details</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_cluster.idents">cluster.idents</code></td>
<td>
<p>Whether to order identities by hierarchical clusters
based on given features, default is FALSE</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_scale">scale</code></td>
<td>
<p>Determine whether the data is scaled, TRUE for default</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_scale.by">scale.by</code></td>
<td>
<p>Scale the size of the points by 'size' or by 'radius'</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_scale.min">scale.min</code></td>
<td>
<p>Set lower limit for scaling, use NA for default</p>
</td></tr>
<tr><td><code id="DotPlot_+3A_scale.max">scale.max</code></td>
<td>
<p>Set upper limit for scaling, use NA for default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>See Also</h3>

<p><code>RColorBrewer::brewer.pal.info</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
cd_genes &lt;- c("CD247", "CD3E", "CD9")
DotPlot(object = pbmc_small, features = cd_genes)
pbmc_small[['groups']] &lt;- sample(x = c('g1', 'g2'), size = ncol(x = pbmc_small), replace = TRUE)
DotPlot(object = pbmc_small, features = cd_genes, split.by = 'groups')

</code></pre>

<hr>
<h2 id='ElbowPlot'>Quickly Pick Relevant Dimensions</h2><span id='topic+ElbowPlot'></span>

<h3>Description</h3>

<p>Plots the standard deviations (or approximate singular values if running PCAFast)
of the principle components for easy identification of an elbow in the graph.
This elbow often corresponds well with the significant dims and is much faster to run than
Jackstraw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElbowPlot(object, ndims = 20, reduction = "pca")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElbowPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="ElbowPlot_+3A_ndims">ndims</code></td>
<td>
<p>Number of dimensions to plot standard deviation for</p>
</td></tr>
<tr><td><code id="ElbowPlot_+3A_reduction">reduction</code></td>
<td>
<p>Reduction technique to plot standard deviation for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
ElbowPlot(object = pbmc_small)

</code></pre>

<hr>
<h2 id='ExpMean'>Calculate the mean of logged values</h2><span id='topic+ExpMean'></span>

<h3>Description</h3>

<p>Calculate mean of logged values in non-log space (return answer in log-space)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpMean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpMean_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="ExpMean_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mean in log-space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ExpMean(x = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='ExpSD'>Calculate the standard deviation of logged values</h2><span id='topic+ExpSD'></span>

<h3>Description</h3>

<p>Calculate SD of logged values in non-log space (return answer in log-space)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpSD(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpSD_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the standard deviation in log-space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ExpSD(x = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='ExpVar'>Calculate the variance of logged values</h2><span id='topic+ExpVar'></span>

<h3>Description</h3>

<p>Calculate variance of logged values in non-log space (return answer in
log-space)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpVar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpVar_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the variance in log-space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ExpVar(x = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='FastRowScale'>Scale and/or center matrix rowwise</h2><span id='topic+FastRowScale'></span>

<h3>Description</h3>

<p>Performs row scaling and/or centering. Equivalent to using t(scale(t(mat)))
in R except in the case of NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FastRowScale(mat, center = TRUE, scale = TRUE, scale_max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FastRowScale_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="FastRowScale_+3A_center">center</code></td>
<td>
<p>a logical value indicating whether to center the rows</p>
</td></tr>
<tr><td><code id="FastRowScale_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether to scale the rows</p>
</td></tr>
<tr><td><code id="FastRowScale_+3A_scale_max">scale_max</code></td>
<td>
<p>clip all values greater than scale_max to scale_max. Don't
clip if Inf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the center/scaled matrix
</p>

<hr>
<h2 id='FastRPCAIntegration'>Perform integration on the joint PCA cell embeddings.</h2><span id='topic+FastRPCAIntegration'></span>

<h3>Description</h3>

<p>This is a convenience wrapper function around the following three functions
that are often run together when perform integration.
#' <code><a href="#topic+FindIntegrationAnchors">FindIntegrationAnchors</a></code>, <code><a href="#topic+RunPCA">RunPCA</a></code>,
<code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FastRPCAIntegration(
  object.list,
  reference = NULL,
  anchor.features = 2000,
  k.anchor = 20,
  dims = 1:30,
  scale = TRUE,
  normalization.method = c("LogNormalize", "SCT"),
  new.reduction.name = "integrated_dr",
  npcs = 50,
  findintegrationanchors.args = list(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FastRPCAIntegration_+3A_object.list">object.list</code></td>
<td>
<p>A list of <code><a href="#topic+Seurat">Seurat</a></code> objects between which to
find anchors for downstream integration.</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_reference">reference</code></td>
<td>
<p>A vector specifying the object/s to be used as a reference
during integration. If NULL (default), all pairwise anchors are found (no
reference/s). If not NULL, the corresponding objects in <code>object.list</code>
will be used as references. When using a set of specified references, anchors
are first found between each query and each reference. The references are
then integrated through pairwise integration. Each query is then mapped to
the integrated reference.</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_anchor.features">anchor.features</code></td>
<td>
<p>Can be either:
</p>

<ul>
<li><p>A numeric value. This will call <code><a href="#topic+SelectIntegrationFeatures">SelectIntegrationFeatures</a></code>
to select the provided number of features to be used in anchor finding
</p>
</li>
<li><p>A vector of features to be used as input to the anchor finding process
</p>
</li></ul>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_k.anchor">k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to use from the CCA to specify the neighbor
search space</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_scale">scale</code></td>
<td>
<p>Whether or not to scale the features provided. Only set to FALSE
if you have previously scaled the features you want to use for each object in
the object.list</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_new.reduction.name">new.reduction.name</code></td>
<td>
<p>Name of integrated dimensional reduction</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_npcs">npcs</code></td>
<td>
<p>Total Number of PCs to compute and store (50 by default)</p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_findintegrationanchors.args">findintegrationanchors.args</code></td>
<td>
<p>A named list of additional arguments to
<code><a href="#topic+FindIntegrationAnchors">FindIntegrationAnchors</a></code></p>
</td></tr>
<tr><td><code id="FastRPCAIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with integrated dimensional reduction
</p>

<hr>
<h2 id='FeaturePlot'>Visualize 'features' on a dimensional reduction plot</h2><span id='topic+FeaturePlot'></span><span id='topic+FeatureHeatmap'></span>

<h3>Description</h3>

<p>Colors single cells on a dimensional reduction plot according to a 'feature'
(i.e. gene expression, PC scores, number of genes detected, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FeaturePlot(
  object,
  features,
  dims = c(1, 2),
  cells = NULL,
  cols = if (blend) {
     c("lightgrey", "#ff0000", "#00ff00")
 } else {
    
    c("lightgrey", "blue")
 },
  pt.size = NULL,
  alpha = 1,
  order = FALSE,
  min.cutoff = NA,
  max.cutoff = NA,
  reduction = NULL,
  split.by = NULL,
  keep.scale = "feature",
  shape.by = NULL,
  slot = "data",
  blend = FALSE,
  blend.threshold = 0.5,
  label = FALSE,
  label.size = 4,
  label.color = "black",
  repel = FALSE,
  ncol = NULL,
  coord.fixed = FALSE,
  by.col = TRUE,
  sort.cell = deprecated(),
  interactive = FALSE,
  combine = TRUE,
  raster = NULL,
  raster.dpi = c(512, 512)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FeaturePlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_features">features</code></td>
<td>
<p>Vector of features to plot. Features can come from:
</p>

<ul>
<li><p> An <code>Assay</code> feature (e.g. a gene name - &quot;MS4A1&quot;)
</p>
</li>
<li><p> A column name from meta.data (e.g. mitochondrial percentage -
&quot;percent.mito&quot;)
</p>
</li>
<li><p> A column name from a <code>DimReduc</code> object corresponding to the
cell embedding values (e.g. the PC 1 scores - &quot;PC_1&quot;)
</p>
</li></ul>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_dims">dims</code></td>
<td>
<p>Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to plot (default is all cells)</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_cols">cols</code></td>
<td>
<p>The two colors to form the gradient over. Provide as string vector with
the first color corresponding to low values, the second to high. Also accepts a Brewer
color scale or vector of colors. Note: this will bin the data into number of colors provided.
When blend is <code>TRUE</code>, takes anywhere from 1-3 colors:
</p>

<dl>
<dt>1 color:</dt><dd><p>Treated as color for double-negatives, will use default colors 2 and 3 for per-feature expression</p>
</dd>
<dt>2 colors:</dt><dd><p>Treated as colors for per-feature expression, will use default color 1 for double-negatives</p>
</dd>
<dt>3+ colors:</dt><dd><p>First color used for double-negatives, colors 2 and 3 used for per-feature expression, all others ignored</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Adjust point size for plotting</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for plotting (default is 1)</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_order">order</code></td>
<td>
<p>Boolean determining whether to plot cells in order of expression. Can be useful if
cells expressing given feature are getting buried.</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_min.cutoff">min.cutoff</code>, <code id="FeaturePlot_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Vector of minimum and maximum cutoff values for each feature,
may specify quantile in the form of 'q##' where '##' is the quantile (eg, 'q1', 'q10')</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_keep.scale">keep.scale</code></td>
<td>
<p>How to handle the color scale across multiple plots. Options are:
</p>

<ul>
<li> <p>&ldquo;feature&rdquo; (default; by row/feature scaling): The plots for
each individual feature are scaled to the maximum expression of the
feature across the conditions provided to <code>split.by</code>
</p>
</li>
<li> <p>&ldquo;all&rdquo; (universal scaling): The plots for all features and
conditions are scaled to the maximum expression value for the feature
with the highest overall expression
</p>
</li>
<li> <p><code>all</code> (no scaling): Each individual plot is scaled to the
maximum expression value of the feature in the condition provided to
<code>split.by</code>. Be aware setting <code>NULL</code> will result in color
scales that are not comparable between plots
</p>
</li></ul>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_shape.by">shape.by</code></td>
<td>
<p>If NULL, all points are circles (default). You can specify any
cell attribute (that can be pulled with FetchData) allowing for both
different colors and different shapes on cells.  Only applicable if <code>raster = FALSE</code>.</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_slot">slot</code></td>
<td>
<p>Which slot to pull expression data from?</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_blend">blend</code></td>
<td>
<p>Scale and blend expression values to visualize coexpression of two features</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_blend.threshold">blend.threshold</code></td>
<td>
<p>The color cutoff from weak signal to strong signal; ranges from 0 to 1.</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_label">label</code></td>
<td>
<p>Whether to label the clusters</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_label.size">label.size</code></td>
<td>
<p>Sets size of labels</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_label.color">label.color</code></td>
<td>
<p>Sets the color of the label text</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_repel">repel</code></td>
<td>
<p>Repel labels</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns to combine multiple feature plots to, ignored if <code>split.by</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_coord.fixed">coord.fixed</code></td>
<td>
<p>Plot cartesian coordinates with fixed aspect ratio</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_by.col">by.col</code></td>
<td>
<p>If splitting by a factor, plot the splits per column with the features as rows; ignored if <code>blend = TRUE</code></p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_sort.cell">sort.cell</code></td>
<td>
<p>Redundant with <code>order</code>. This argument is being
deprecated. Please use <code>order</code> instead.</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_interactive">interactive</code></td>
<td>
<p>Launch an interactive <code><a href="#topic+IFeaturePlot">FeaturePlot</a></code></p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code> which
automatically rasterizes if plotting more than 100,000 cells</p>
</td></tr>
<tr><td><code id="FeaturePlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Pixel resolution for rasterized plots, passed to geom_scattermore().
Default is c(512, 512).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>


<h3>Note</h3>

<p>For the old <code>do.hover</code> and <code>do.identify</code> functionality, please see
<code>HoverLocator</code> and <code>CellSelector</code>, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimPlot">DimPlot</a></code> <code><a href="#topic+HoverLocator">HoverLocator</a></code>
<code><a href="#topic+CellSelector">CellSelector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
FeaturePlot(object = pbmc_small, features = 'PC_1')

</code></pre>

<hr>
<h2 id='FeatureScatter'>Scatter plot of single cell data</h2><span id='topic+FeatureScatter'></span><span id='topic+GenePlot'></span>

<h3>Description</h3>

<p>Creates a scatter plot of two features (typically feature expression), across a
set of single cells. Cells are colored by their identity class. Pearson
correlation between the two features is displayed above the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FeatureScatter(
  object,
  feature1,
  feature2,
  cells = NULL,
  shuffle = FALSE,
  seed = 1,
  group.by = NULL,
  split.by = NULL,
  cols = NULL,
  pt.size = 1,
  shape.by = NULL,
  span = NULL,
  smooth = FALSE,
  combine = TRUE,
  slot = "data",
  plot.cor = TRUE,
  ncol = NULL,
  raster = NULL,
  raster.dpi = c(512, 512),
  jitter = FALSE,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FeatureScatter_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_feature1">feature1</code></td>
<td>
<p>First feature to plot. Typically feature expression but can also
be metrics, PC scores, etc. - anything that can be retreived with FetchData</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_feature2">feature2</code></td>
<td>
<p>Second feature to plot.</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_cells">cells</code></td>
<td>
<p>Cells to include on the scatter plot.</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to randomly shuffle the order of points. This can be
useful for crowded plots if points of interest are being buried. (default is FALSE)</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_seed">seed</code></td>
<td>
<p>Sets the seed if randomly shuffling the order of points.</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_group.by">group.by</code></td>
<td>
<p>Name of one or more metadata columns to group (color) cells by
(for example, orig.ident); pass 'ident' to group by identity class</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the feature plot by, pass 'ident'
to split by cell identity'</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_cols">cols</code></td>
<td>
<p>Colors to use for identity class plotting.</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_pt.size">pt.size</code></td>
<td>
<p>Size of the points on the plot</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_shape.by">shape.by</code></td>
<td>
<p>Ignored for now</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_span">span</code></td>
<td>
<p>Spline span in loess function call, if <code>NULL</code>, no spline added</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_smooth">smooth</code></td>
<td>
<p>Smooth the graph (similar to smoothScatter)</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code></p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_slot">slot</code></td>
<td>
<p>Slot to pull data from, should be one of 'counts', 'data', or 'scale.data'</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_plot.cor">plot.cor</code></td>
<td>
<p>Display correlation in plot title</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if plotting multiple plots</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code>
which will automatically use raster if the number of points plotted is greater than
100,000</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Pixel resolution for rasterized plots, passed to geom_scattermore().
Default is c(512, 512).</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_jitter">jitter</code></td>
<td>
<p>Jitter for easier visualization of crowded points (default is FALSE)</p>
</td></tr>
<tr><td><code id="FeatureScatter_+3A_log">log</code></td>
<td>
<p>Plot features on the log scale (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
FeatureScatter(object = pbmc_small, feature1 = 'CD9', feature2 = 'CD3E')

</code></pre>

<hr>
<h2 id='FetchResiduals'>Calculate pearson residuals of features not in the scale.data</h2><span id='topic+FetchResiduals'></span>

<h3>Description</h3>

<p>This function calls sctransform::get_residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FetchResiduals(
  object,
  features,
  assay = NULL,
  umi.assay = "RNA",
  layer = "counts",
  clip.range = NULL,
  reference.SCT.model = NULL,
  replace.value = FALSE,
  na.rm = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FetchResiduals_+3A_object">object</code></td>
<td>
<p>A seurat object</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_features">features</code></td>
<td>
<p>Name of features to add into the scale.data</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_assay">assay</code></td>
<td>
<p>Name of the assay of the seurat object generated by SCTransform</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_umi.assay">umi.assay</code></td>
<td>
<p>Name of the assay of the seurat object containing UMI matrix
and the default is RNA</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_layer">layer</code></td>
<td>
<p>Name (prefix) of the layer to pull counts from</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_clip.range">clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the
Pearson residual will be clipped to</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_reference.sct.model">reference.SCT.model</code></td>
<td>
<p>reference.SCT.model If a reference SCT model should be used
for calculating the residuals. When set to not NULL, ignores the 'SCTModel'
paramater.</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_replace.value">replace.value</code></td>
<td>
<p>Recalculate residuals for all features, even if they are
already present. Useful if you want to change the clip.range.</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_na.rm">na.rm</code></td>
<td>
<p>For features where there is no feature model stored, return NA
for residual value in scale.data when na.rm = FALSE. When na.rm is TRUE, only
return residuals for features with a model stored for all cells.</p>
</td></tr>
<tr><td><code id="FetchResiduals_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages and progress bars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object containing Pearson residuals of added
features in its scale.data
</p>


<h3>See Also</h3>

<p><code><a href="sctransform.html#topic+get_residuals">get_residuals</a></code>
</p>

<hr>
<h2 id='FetchResiduals_reference'>temporal function to get residuals from reference</h2><span id='topic+FetchResiduals_reference'></span>

<h3>Description</h3>

<p>temporal function to get residuals from reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FetchResiduals_reference(
  object,
  reference.SCT.model = NULL,
  features = NULL,
  nCount_UMI = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FetchResiduals_reference_+3A_object">object</code></td>
<td>
<p>A seurat object</p>
</td></tr>
<tr><td><code id="FetchResiduals_reference_+3A_reference.sct.model">reference.SCT.model</code></td>
<td>
<p>a reference SCT model that should be used
for calculating the residuals</p>
</td></tr>
<tr><td><code id="FetchResiduals_reference_+3A_features">features</code></td>
<td>
<p>Names of features to compute</p>
</td></tr>
<tr><td><code id="FetchResiduals_reference_+3A_ncount_umi">nCount_UMI</code></td>
<td>
<p>UMI counts. If not specified, defaults to
column sums of object</p>
</td></tr>
<tr><td><code id="FetchResiduals_reference_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages and progress bars</p>
</td></tr>
</table>

<hr>
<h2 id='FetchResidualSCTModel'>Calculate pearson residuals of features not in the scale.data
This function is the secondary function under FetchResiduals</h2><span id='topic+FetchResidualSCTModel'></span>

<h3>Description</h3>

<p>Calculate pearson residuals of features not in the scale.data
This function is the secondary function under FetchResiduals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FetchResidualSCTModel(
  object,
  assay = "SCT",
  umi.assay = "RNA",
  layer = "counts",
  chunk_size = 2000,
  layer.cells = NULL,
  SCTModel = NULL,
  reference.SCT.model = NULL,
  new_features = NULL,
  clip.range = NULL,
  replace.value = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FetchResidualSCTModel_+3A_object">object</code></td>
<td>
<p>A seurat object</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_assay">assay</code></td>
<td>
<p>Name of the assay of the seurat object generated by
SCTransform. Default is &quot;SCT&quot;</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_umi.assay">umi.assay</code></td>
<td>
<p>Name of the assay of the seurat object to fetch
UMIs from. Default is &quot;RNA&quot;</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_layer">layer</code></td>
<td>
<p>Name of the layer under 'umi.assay' to fetch UMIs from.
Default is &quot;counts&quot;</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of cells to load in memory for calculating
residuals</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_layer.cells">layer.cells</code></td>
<td>
<p>Vector of cells to calculate the residual for.
Default is NULL which uses all cells in the layer</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_sctmodel">SCTModel</code></td>
<td>
<p>Which SCTmodel to use from the object for calculating
the residual. Will be ignored if reference.SCT.model is set</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_reference.sct.model">reference.SCT.model</code></td>
<td>
<p>If a reference SCT model should be used
for calculating the residuals. When set to not NULL, ignores the 'SCTModel'
paramater.</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_new_features">new_features</code></td>
<td>
<p>A vector of features to calculate the residuals for</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_clip.range">clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values
the Pearson residual will be clipped to. Useful if you want to change the
clip.range.</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_replace.value">replace.value</code></td>
<td>
<p>Whether to replace the value of residuals if it
already exists</p>
</td></tr>
<tr><td><code id="FetchResidualSCTModel_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages and progress bars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix containing centered pearson residuals of
added features
</p>

<hr>
<h2 id='FilterSlideSeq'>Filter stray beads from Slide-seq puck</h2><span id='topic+FilterSlideSeq'></span>

<h3>Description</h3>

<p>This function is useful for removing stray beads that fall outside the main
Slide-seq puck area. Essentially, it's a circular filter where you set a
center and radius defining a circle of beads to keep. If the center is not
set, it will be estimated from the bead coordinates (removing the 1st and
99th quantile to avoid skewing the center by the stray beads). By default,
this function will display a <code><a href="#topic+SpatialDimPlot">SpatialDimPlot</a></code> showing which cells
were removed for easy adjustment of the center and/or radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterSlideSeq(
  object,
  image = "image",
  center = NULL,
  radius = NULL,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterSlideSeq_+3A_object">object</code></td>
<td>
<p>Seurat object with slide-seq data</p>
</td></tr>
<tr><td><code id="FilterSlideSeq_+3A_image">image</code></td>
<td>
<p>Name of the image where the coordinates are stored</p>
</td></tr>
<tr><td><code id="FilterSlideSeq_+3A_center">center</code></td>
<td>
<p>Vector specifying the x and y coordinates for the center of the
inclusion circle</p>
</td></tr>
<tr><td><code id="FilterSlideSeq_+3A_radius">radius</code></td>
<td>
<p>Radius of the circle of inclusion</p>
</td></tr>
<tr><td><code id="FilterSlideSeq_+3A_do.plot">do.plot</code></td>
<td>
<p>Display a <code><a href="#topic+SpatialDimPlot">SpatialDimPlot</a></code> with the cells being
removed labeled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with only the subset of cells that pass the
circular filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example uses the ssHippo dataset which you can download
# using the SeuratData package.
library(SeuratData)
data('ssHippo')
# perform filtering of beads
ssHippo.filtered &lt;- FilterSlideSeq(ssHippo, radius = 2300)
# This radius looks to small so increase and repeat until satisfied

## End(Not run)
</code></pre>

<hr>
<h2 id='FindAllMarkers'>Gene expression markers for all identity classes</h2><span id='topic+FindAllMarkers'></span><span id='topic+FindAllMarkersNode'></span>

<h3>Description</h3>

<p>Finds markers (differentially expressed genes) for each of the identity classes in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindAllMarkers(
  object,
  assay = NULL,
  features = NULL,
  logfc.threshold = 0.1,
  test.use = "wilcox",
  slot = "data",
  min.pct = 0.01,
  min.diff.pct = -Inf,
  node = NULL,
  verbose = TRUE,
  only.pos = FALSE,
  max.cells.per.ident = Inf,
  random.seed = 1,
  latent.vars = NULL,
  min.cells.feature = 3,
  min.cells.group = 3,
  mean.fxn = NULL,
  fc.name = NULL,
  base = 2,
  return.thresh = 0.01,
  densify = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindAllMarkers_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_assay">assay</code></td>
<td>
<p>Assay to use in differential expression testing</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_features">features</code></td>
<td>
<p>Genes to test. Default is to use all genes</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average, at least
X-fold difference (log-scale) between the two groups of cells. Default is 0.1
Increasing logfc.threshold speeds up the function, but can miss weaker signals.
If the <code>slot</code> parameter is &quot;scale.data&quot; no filtering is performed.</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_test.use">test.use</code></td>
<td>
<p>Denotes which test to use. Available options are:
</p>

<ul>
<li><p>&quot;wilcox&quot; : Identifies differentially expressed genes between two
groups of cells using a Wilcoxon Rank Sum test (default); will use a fast
implementation by Presto if installed
</p>
</li>
<li><p>&quot;wilcox_limma&quot; : Identifies differentially expressed genes between two
groups of cells using the limma implementation of the Wilcoxon Rank Sum test;
set this option to reproduce results from Seurat v4
</p>
</li>
<li><p>&quot;bimod&quot; : Likelihood-ratio test for single cell gene expression,
(McDavid et al., Bioinformatics, 2013)
</p>
</li>
<li><p>&quot;roc&quot; : Identifies 'markers' of gene expression using ROC analysis.
For each gene, evaluates (using AUC) a classifier built on that gene alone,
to classify between two groups of cells. An AUC value of 1 means that
expression values for this gene alone can perfectly classify the two
groupings (i.e. Each of the cells in cells.1 exhibit a higher level than
each of the cells in cells.2). An AUC value of 0 also means there is perfect
classification, but in the other direction. A value of 0.5 implies that
the gene has no predictive power to classify the two groups. Returns a
'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially
expressed genes.
</p>
</li>
<li><p>&quot;t&quot; : Identify differentially expressed genes between two groups of
cells using the Student's t-test.
</p>
</li>
<li><p>&quot;negbinom&quot; : Identifies differentially expressed genes between two
groups of cells using a negative binomial generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;poisson&quot; : Identifies differentially expressed genes between two
groups of cells using a poisson generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;LR&quot; : Uses a logistic regression framework to determine differentially
expressed genes. Constructs a logistic regression model predicting group
membership based on each feature individually and compares this to a null
model with a likelihood ratio test.
</p>
</li>
<li><p>&quot;MAST&quot; : Identifies differentially expressed genes between two groups
of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST
package to run the DE testing.
</p>
</li>
<li><p>&quot;DESeq2&quot; : Identifies differentially expressed genes between two groups
of cells based on a model using DESeq2 which uses a negative binomial
distribution (Love et al, Genome Biology, 2014).This test does not support
pre-filtering of genes based on average difference (or percent detection rate)
between cell groups. However, genes may be pre-filtered based on their
minimum detection rate (min.pct) across both cell groups. To use this method,
please install DESeq2, using the instructions at
https://bioconductor.org/packages/release/bioc/html/DESeq2.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_slot">slot</code></td>
<td>
<p>Slot to pull data from; note that if <code>test.use</code> is
&quot;negbinom&quot;, &quot;poisson&quot;, or &quot;DESeq2&quot;, <code>slot</code> will be set to &quot;counts&quot;</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_min.pct">min.pct</code></td>
<td>
<p>only test genes that are detected in a minimum fraction of
min.pct cells in either of the two populations. Meant to speed up the function
by not testing genes that are very infrequently expressed. Default is 0.01</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_min.diff.pct">min.diff.pct</code></td>
<td>
<p>only test genes that show a minimum difference in the
fraction of detection between the two groups. Set to -Inf by default</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_node">node</code></td>
<td>
<p>A node to find markers for and all its children; requires
<code><a href="#topic+BuildClusterTree">BuildClusterTree</a></code> to have been run previously; replaces <code>FindAllMarkersNode</code></p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_verbose">verbose</code></td>
<td>
<p>Print a progress bar once expression testing begins</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_only.pos">only.pos</code></td>
<td>
<p>Only return positive markers (FALSE by default)</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_max.cells.per.ident">max.cells.per.ident</code></td>
<td>
<p>Down sample each identity class to a max number.
Default is no downsampling. Not activated by default (set to Inf)</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_random.seed">random.seed</code></td>
<td>
<p>Random seed for downsampling</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_latent.vars">latent.vars</code></td>
<td>
<p>Variables to test, used only when <code>test.use</code> is one of
'LR', 'negbinom', 'poisson', or 'MAST'</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_min.cells.feature">min.cells.feature</code></td>
<td>
<p>Minimum number of cells expressing the feature in at least one
of the two groups, currently only used for poisson and negative binomial tests</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_min.cells.group">min.cells.group</code></td>
<td>
<p>Minimum number of cells in one of the groups</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_mean.fxn">mean.fxn</code></td>
<td>
<p>Function to use for fold change or average difference calculation.
The default depends on the the value of <code>fc.slot</code>:
</p>

<ul>
<li><p>&quot;counts&quot; : difference in the log of the mean counts, with pseudocount.
</p>
</li>
<li><p>&quot;data&quot; : difference in the log of the average exponentiated data, with pseudocount.
This adjusts for differences in sequencing depth between cells, and assumes that &quot;data&quot;
has been log-normalized.
</p>
</li>
<li><p>&quot;scale.data&quot; : difference in the means of scale.data.
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_fc.name">fc.name</code></td>
<td>
<p>Name of the fold change, average difference, or custom function column
in the output data.frame. If NULL, the fold change column will be named
according to the logarithm base (eg, &quot;avg_log2FC&quot;), or if using the scale.data
slot &quot;avg_diff&quot;.</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_base">base</code></td>
<td>
<p>The base with respect to which logarithms are computed.</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_return.thresh">return.thresh</code></td>
<td>
<p>Only return markers that have a p-value &lt; return.thresh, or a power &gt; return.thresh (if the test is ROC)</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_densify">densify</code></td>
<td>
<p>Convert the sparse matrix to a dense form before running the 
DE test. This can provide speedups but might require higher memory; default is FALSE</p>
</td></tr>
<tr><td><code id="FindAllMarkers_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and to specific DE methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing a ranked list of putative markers, and associated
statistics (p-values, ROC score, etc.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
# Find markers for all clusters
all.markers &lt;- FindAllMarkers(object = pbmc_small)
head(x = all.markers)
## Not run: 
# Pass a value to node as a replacement for FindAllMarkersNode
pbmc_small &lt;- BuildClusterTree(object = pbmc_small)
all.markers &lt;- FindAllMarkers(object = pbmc_small, node = 4)
head(x = all.markers)

## End(Not run)

</code></pre>

<hr>
<h2 id='FindBridgeAnchor'>Find bridge anchors between two unimodal datasets</h2><span id='topic+FindBridgeAnchor'></span>

<h3>Description</h3>

<p>First, bridge object is used to reconstruct two single-modality profiles and
then project those cells into bridage graph laplacian space.
Next, find a set of anchors between two single-modality objects. These
anchors can later be used to integrate embeddings or transfer data from the reference to
query object using the <code><a href="#topic+MapQuery">MapQuery</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBridgeAnchor(
  object.list,
  bridge.object,
  object.reduction,
  bridge.reduction,
  anchor.type = c("Transfer", "Integration"),
  reference = NULL,
  laplacian.reduction = "lap",
  laplacian.dims = 1:50,
  reduction = c("direct", "cca"),
  bridge.assay.name = "Bridge",
  reference.bridge.stored = FALSE,
  k.anchor = 20,
  k.score = 50,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindBridgeAnchor_+3A_object.list">object.list</code></td>
<td>
<p>A list of Seurat objects</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_bridge.object">bridge.object</code></td>
<td>
<p>A multi-omic bridge Seurat which is used as the basis to
represent unimodal datasets</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_object.reduction">object.reduction</code></td>
<td>
<p>A list of dimensional reductions from object.list used
to be reconstructed by bridge.object</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_bridge.reduction">bridge.reduction</code></td>
<td>
<p>A list of dimensional reductions from bridge.object used
to reconstruct object.reduction</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_anchor.type">anchor.type</code></td>
<td>
<p>The type of anchors. Can
be one of:
</p>

<ul>
<li><p>Integration: Generate IntegrationAnchors for integration
</p>
</li>
<li><p>Transfer: Generate TransferAnchors for transfering data
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_reference">reference</code></td>
<td>
<p>A vector specifying the object/s to be used as a reference
during integration or transfer data.</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_laplacian.reduction">laplacian.reduction</code></td>
<td>
<p>Name of bridge graph laplacian dimensional reduction</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_laplacian.dims">laplacian.dims</code></td>
<td>
<p>Dimensions used for bridge graph laplacian dimensional reduction</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors. Can
be one of:
</p>

<ul>
<li><p>cca: Canonical correlation analysis
</p>
</li>
<li><p>direct: Use assay data as a dimensional reduction
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_bridge.assay.name">bridge.assay.name</code></td>
<td>
<p>Assay name used for bridge object reconstruction value (default is 'Bridge')</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_reference.bridge.stored">reference.bridge.stored</code></td>
<td>
<p>If refernece has stored the bridge dictionary representation</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_k.anchor">k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_k.score">k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
<tr><td><code id="FindBridgeAnchor_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>FindIntegrationAnchors</code> or
<code>FindTransferAnchors</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Bridge cells reconstruction

</p>
</li>
<li><p> Find anchors between objects. It can be either IntegrationAnchors or TransferAnchor.

</p>
</li></ul>



<h3>Value</h3>

<p>Returns an <code><a href="#topic+AnchorSet">AnchorSet</a></code> object that can be used as input to
<code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code>.or <code><a href="#topic+MapQuery">MapQuery</a></code>
</p>

<hr>
<h2 id='FindBridgeIntegrationAnchors'>Find integration bridge anchors between query and extended bridge-reference</h2><span id='topic+FindBridgeIntegrationAnchors'></span>

<h3>Description</h3>

<p>Find a set of anchors between unimodal query and the other unimodal reference
using a pre-computed <code><a href="#topic+BridgeReferenceSet">BridgeReferenceSet</a></code>.
These integration anchors can later be used to integrate query and reference
using the <code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBridgeIntegrationAnchors(
  extended.reference,
  query,
  query.assay = NULL,
  dims = 1:30,
  scale = FALSE,
  reduction = c("lsiproject", "pcaproject"),
  integration.reduction = c("direct", "cca"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_extended.reference">extended.reference</code></td>
<td>
<p>BridgeReferenceSet object generated from
<code><a href="#topic+PrepareBridgeReference">PrepareBridgeReference</a></code></p>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_query">query</code></td>
<td>
<p>A query Seurat object</p>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_query.assay">query.assay</code></td>
<td>
<p>Assay name for query-bridge integration</p>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_dims">dims</code></td>
<td>
<p>Number of dimensions for query-bridge integration</p>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_scale">scale</code></td>
<td>
<p>Determine if scale the query data for projection</p>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors.
Options are:
</p>

<ul>
<li><p>pcaproject: Project the PCA from the bridge onto the query. We
recommend using PCA when bridge and query datasets are from scRNA-seq
</p>
</li>
<li><p>lsiproject: Project the LSI from the bridge onto the query. We
recommend using LSI when bridge and query datasets are from scATAC-seq or scCUT&amp;TAG data.
This requires that LSI or supervised LSI has been computed for the bridge dataset, and the
same features (eg, peaks or genome bins) are present in both the bridge
and query.

</p>
</li></ul>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_integration.reduction">integration.reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors
between query and reference.
Options are:
</p>

<ul>
<li><p>direct: find anchors directly on the bridge representation space
</p>
</li>
<li><p>cca: perform cca on the on the bridge representation space and then find anchors

</p>
</li></ul>
</td></tr>
<tr><td><code id="FindBridgeIntegrationAnchors_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>AnchorSet</code> object that can be used as input to
<code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code>.
</p>

<hr>
<h2 id='FindBridgeTransferAnchors'>Find bridge anchors between query and extended bridge-reference</h2><span id='topic+FindBridgeTransferAnchors'></span>

<h3>Description</h3>

<p>Find a set of anchors between unimodal query and the other unimodal reference
using a pre-computed <code><a href="#topic+BridgeReferenceSet">BridgeReferenceSet</a></code>.
This function performs three steps:
1. Harmonize the bridge and query cells in the bridge query reduction space
2. Construct the bridge dictionary representations for query cells
3. Find a set of anchors between query and reference in the bridge graph laplacian eigenspace
These anchors can later be used to integrate embeddings or transfer data from the reference to
query object using the <code><a href="#topic+MapQuery">MapQuery</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBridgeTransferAnchors(
  extended.reference,
  query,
  query.assay = NULL,
  dims = 1:30,
  scale = FALSE,
  reduction = c("lsiproject", "pcaproject"),
  bridge.reduction = c("direct", "cca"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindBridgeTransferAnchors_+3A_extended.reference">extended.reference</code></td>
<td>
<p>BridgeReferenceSet object generated from
<code><a href="#topic+PrepareBridgeReference">PrepareBridgeReference</a></code></p>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_query">query</code></td>
<td>
<p>A query Seurat object</p>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_query.assay">query.assay</code></td>
<td>
<p>Assay name for query-bridge integration</p>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_dims">dims</code></td>
<td>
<p>Number of dimensions for query-bridge integration</p>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_scale">scale</code></td>
<td>
<p>Determine if scale the query data for projection</p>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors.
Options are:
</p>

<ul>
<li><p>pcaproject: Project the PCA from the bridge onto the query. We
recommend using PCA when bridge and query datasets are from scRNA-seq
</p>
</li>
<li><p>lsiproject: Project the LSI from the bridge onto the query. We
recommend using LSI when bridge and query datasets are from scATAC-seq or scCUT&amp;TAG data.
This requires that LSI or supervised LSI has been computed for the bridge dataset, and the
same features (eg, peaks or genome bins) are present in both the bridge
and query.

</p>
</li></ul>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_bridge.reduction">bridge.reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors. Can
be one of:
</p>

<ul>
<li><p>cca: Canonical correlation analysis
</p>
</li>
<li><p>direct: Use assay data as a dimensional reduction
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindBridgeTransferAnchors_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>AnchorSet</code> object that can be used as input to
<code><a href="#topic+TransferData">TransferData</a></code>, <code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code> and
<code><a href="#topic+MapQuery">MapQuery</a></code>.
</p>

<hr>
<h2 id='FindClusters'>Cluster Determination</h2><span id='topic+FindClusters'></span><span id='topic+FindClusters.default'></span><span id='topic+FindClusters.Seurat'></span>

<h3>Description</h3>

<p>Identify clusters of cells by a shared nearest neighbor (SNN) modularity
optimization based clustering algorithm. First calculate k-nearest neighbors
and construct the SNN graph. Then optimize the modularity function to
determine clusters. For a full description of the algorithms, see Waltman and
van Eck (2013) <em>The European Physical Journal B</em>. Thanks to Nigel
Delaney (evolvedmicrobe@github) for the rewrite of the Java modularity
optimizer code in Rcpp!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindClusters(object, ...)

## Default S3 method:
FindClusters(
  object,
  modularity.fxn = 1,
  initial.membership = NULL,
  node.sizes = NULL,
  resolution = 0.8,
  method = "matrix",
  algorithm = 1,
  n.start = 10,
  n.iter = 10,
  random.seed = 0,
  group.singletons = TRUE,
  temp.file.location = NULL,
  edge.file.name = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
FindClusters(
  object,
  graph.name = NULL,
  cluster.name = NULL,
  modularity.fxn = 1,
  initial.membership = NULL,
  node.sizes = NULL,
  resolution = 0.8,
  method = "matrix",
  algorithm = 1,
  n.start = 10,
  n.iter = 10,
  random.seed = 0,
  group.singletons = TRUE,
  temp.file.location = NULL,
  edge.file.name = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindClusters_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_modularity.fxn">modularity.fxn</code></td>
<td>
<p>Modularity function (1 = standard; 2 = alternative).</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_initial.membership">initial.membership</code>, <code id="FindClusters_+3A_node.sizes">node.sizes</code></td>
<td>
<p>Parameters to pass to the Python leidenalg function.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_resolution">resolution</code></td>
<td>
<p>Value of the resolution parameter, use a value above
(below) 1.0 if you want to obtain a larger (smaller) number of communities.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_method">method</code></td>
<td>
<p>Method for running leiden (defaults to matrix which is fast for small datasets).
Enable method = &quot;igraph&quot; to avoid casting large data to a dense matrix.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for modularity optimization (1 = original Louvain
algorithm; 2 = Louvain algorithm with multilevel refinement; 3 = SLM
algorithm; 4 = Leiden algorithm). Leiden requires the leidenalg python.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_n.start">n.start</code></td>
<td>
<p>Number of random starts.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_n.iter">n.iter</code></td>
<td>
<p>Maximal number of iterations per random start.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_random.seed">random.seed</code></td>
<td>
<p>Seed of the random number generator.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_group.singletons">group.singletons</code></td>
<td>
<p>Group singletons into nearest cluster. If FALSE, assign all singletons to
a &quot;singleton&quot; group</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_temp.file.location">temp.file.location</code></td>
<td>
<p>Directory where intermediate files will be written.
Specify the ABSOLUTE path.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_edge.file.name">edge.file.name</code></td>
<td>
<p>Edge file to use as input for modularity optimizer jar.</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_verbose">verbose</code></td>
<td>
<p>Print output</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_graph.name">graph.name</code></td>
<td>
<p>Name of graph to use for the clustering algorithm</p>
</td></tr>
<tr><td><code id="FindClusters_+3A_cluster.name">cluster.name</code></td>
<td>
<p>Name of output clusters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To run Leiden algorithm, you must first install the leidenalg python
package (e.g. via pip install leidenalg), see Traag et al (2018).
</p>


<h3>Value</h3>

<p>Returns a Seurat object where the idents have been updated with new cluster info;
latest clustering results will be stored in object metadata under 'seurat_clusters'.
Note that 'seurat_clusters' will be overwritten everytime FindClusters is run
</p>

<hr>
<h2 id='FindConservedMarkers'>Finds markers that are conserved between the groups</h2><span id='topic+FindConservedMarkers'></span>

<h3>Description</h3>

<p>Finds markers that are conserved between the groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindConservedMarkers(
  object,
  ident.1,
  ident.2 = NULL,
  grouping.var,
  assay = "RNA",
  slot = "data",
  min.cells.group = 3,
  meta.method = metap::minimump,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindConservedMarkers_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_ident.1">ident.1</code></td>
<td>
<p>Identity class to define markers for</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_ident.2">ident.2</code></td>
<td>
<p>A second identity class for comparison. If NULL (default) -
use all other cells for comparison.</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_grouping.var">grouping.var</code></td>
<td>
<p>grouping variable</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_assay">assay</code></td>
<td>
<p>of assay to fetch data for (default is RNA)</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_slot">slot</code></td>
<td>
<p>Slot to pull data from; note that if <code>test.use</code> is
&quot;negbinom&quot;, &quot;poisson&quot;, or &quot;DESeq2&quot;, <code>slot</code> will be set to &quot;counts&quot;</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_min.cells.group">min.cells.group</code></td>
<td>
<p>Minimum number of cells in one of the groups</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_meta.method">meta.method</code></td>
<td>
<p>method for combining p-values. Should be a function from
the metap package (NOTE: pass the function, not a string)</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_verbose">verbose</code></td>
<td>
<p>Print a progress bar once expression testing begins</p>
</td></tr>
<tr><td><code id="FindConservedMarkers_+3A_...">...</code></td>
<td>
<p>parameters to pass to FindMarkers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing a ranked list of putative conserved markers, and
associated statistics (p-values within each group and a combined p-value
(such as Fishers combined p-value or others from the metap package),
percentage of cells expressing the marker, average differences). Name of group is appended to each
associated output column (e.g. CTRL_p_val). If only one group is tested in the grouping.var, max
and combined p-values are not returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small
# Create a simulated grouping variable
pbmc_small[['groups']] &lt;- sample(x = c('g1', 'g2'), size = ncol(x = pbmc_small), replace = TRUE)
FindConservedMarkers(pbmc_small, ident.1 = 0, ident.2 = 1, grouping.var = "groups")

## End(Not run)

</code></pre>

<hr>
<h2 id='FindIntegrationAnchors'>Find integration anchors</h2><span id='topic+FindIntegrationAnchors'></span>

<h3>Description</h3>

<p>Find a set of anchors between a list of <code><a href="#topic+Seurat">Seurat</a></code> objects.
These  anchors can later be used to integrate the objects using the
<code><a href="#topic+IntegrateData">IntegrateData</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindIntegrationAnchors(
  object.list = NULL,
  assay = NULL,
  reference = NULL,
  anchor.features = 2000,
  scale = TRUE,
  normalization.method = c("LogNormalize", "SCT"),
  sct.clip.range = NULL,
  reduction = c("cca", "rpca", "jpca", "rlsi"),
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = 200,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindIntegrationAnchors_+3A_object.list">object.list</code></td>
<td>
<p>A list of <code><a href="#topic+Seurat">Seurat</a></code> objects between which to
find anchors for downstream integration.</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_assay">assay</code></td>
<td>
<p>A vector of assay names specifying which assay to use when
constructing anchors. If NULL, the current default assay for each object is
used.</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_reference">reference</code></td>
<td>
<p>A vector specifying the object/s to be used as a reference
during integration. If NULL (default), all pairwise anchors are found (no
reference/s). If not NULL, the corresponding objects in <code>object.list</code>
will be used as references. When using a set of specified references, anchors
are first found between each query and each reference. The references are
then integrated through pairwise integration. Each query is then mapped to
the integrated reference.</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_anchor.features">anchor.features</code></td>
<td>
<p>Can be either:
</p>

<ul>
<li><p>A numeric value. This will call <code><a href="#topic+SelectIntegrationFeatures">SelectIntegrationFeatures</a></code>
to select the provided number of features to be used in anchor finding
</p>
</li>
<li><p>A vector of features to be used as input to the anchor finding process
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_scale">scale</code></td>
<td>
<p>Whether or not to scale the features provided. Only set to FALSE
if you have previously scaled the features you want to use for each object in
the object.list</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_sct.clip.range">sct.clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values
the Pearson residual will be clipped to</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors. Can
be one of:
</p>

<ul>
<li><p>cca: Canonical correlation analysis
</p>
</li>
<li><p>rpca: Reciprocal PCA
</p>
</li>
<li><p>jpca: Joint PCA
</p>
</li>
<li><p>rlsi: Reciprocal LSI
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Perform L2 normalization on the CCA cell embeddings after
dimensional reduction</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to use from the CCA to specify the neighbor
search space</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_k.anchor">k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_k.filter">k.filter</code></td>
<td>
<p>How many neighbors (k) to use when filtering anchors</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_k.score">k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_max.features">max.features</code></td>
<td>
<p>The maximum number of features to use when specifying the
neighborhood search space in the anchor filtering</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_nn.method">nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann,
annoy</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_n.trees">n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_eps">eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from RANN/Annoy)</p>
</td></tr>
<tr><td><code id="FindIntegrationAnchors_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019:
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>
<p>First, determine anchor.features if not explicitly specified using
<code><a href="#topic+SelectIntegrationFeatures">SelectIntegrationFeatures</a></code>. Then for all pairwise combinations
of reference and query datasets:
</p>

<ul>
<li><p>Perform dimensional reduction on the dataset pair as specified via
the <code>reduction</code> parameter. If <code>l2.norm</code> is set to <code>TRUE</code>,
perform L2 normalization of the embedding vectors.
</p>
</li>
<li><p>Identify anchors - pairs of cells from each dataset
that are contained within each other's neighborhoods (also known as mutual
nearest neighbors).
</p>
</li>
<li><p>Filter low confidence anchors to ensure anchors in the low dimension
space are in broad agreement with the high dimensional measurements. This
is done by looking at the neighbors of each query cell in the reference
dataset using <code>max.features</code> to define this space. If the reference
cell isn't found within the first <code>k.filter</code> neighbors, remove the
anchor.
</p>
</li>
<li><p>Assign each remaining anchor a score. For each anchor cell, determine
the nearest <code>k.score</code> anchors within its own dataset and within its
pair's dataset. Based on these neighborhoods, construct an overall neighbor
graph and then compute the shared neighbor overlap between anchor and query
cells (analogous to an SNN graph). We use the 0.01 and 0.90 quantiles on
these scores to dampen outlier effects and rescale to range between 0-1.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an <code><a href="#topic+AnchorSet">AnchorSet</a></code> object that can be used as input to
<code><a href="#topic+IntegrateData">IntegrateData</a></code>.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("panc8")

# panc8 is a merged Seurat object containing 8 separate pancreas datasets
# split the object by dataset
pancreas.list &lt;- SplitObject(panc8, split.by = "tech")

# perform standard preprocessing on each object
for (i in 1:length(pancreas.list)) {
  pancreas.list[[i]] &lt;- NormalizeData(pancreas.list[[i]], verbose = FALSE)
  pancreas.list[[i]] &lt;- FindVariableFeatures(
    pancreas.list[[i]], selection.method = "vst",
    nfeatures = 2000, verbose = FALSE
  )
}

# find anchors
anchors &lt;- FindIntegrationAnchors(object.list = pancreas.list)

# integrate data
integrated &lt;- IntegrateData(anchorset = anchors)

## End(Not run)

</code></pre>

<hr>
<h2 id='FindMarkers'>Gene expression markers of identity classes</h2><span id='topic+FindMarkers'></span><span id='topic+FindMarkersNode'></span><span id='topic+FindMarkers.default'></span><span id='topic+FindMarkers.Assay'></span><span id='topic+FindMarkers.SCTAssay'></span><span id='topic+FindMarkers.DimReduc'></span><span id='topic+FindMarkers.Seurat'></span>

<h3>Description</h3>

<p>Finds markers (differentially expressed genes) for identity classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMarkers(object, ...)

## Default S3 method:
FindMarkers(
  object,
  slot = "data",
  cells.1 = NULL,
  cells.2 = NULL,
  features = NULL,
  logfc.threshold = 0.1,
  test.use = "wilcox",
  min.pct = 0.01,
  min.diff.pct = -Inf,
  verbose = TRUE,
  only.pos = FALSE,
  max.cells.per.ident = Inf,
  random.seed = 1,
  latent.vars = NULL,
  min.cells.feature = 3,
  min.cells.group = 3,
  fc.results = NULL,
  densify = FALSE,
  ...
)

## S3 method for class 'Assay'
FindMarkers(
  object,
  slot = "data",
  cells.1 = NULL,
  cells.2 = NULL,
  features = NULL,
  test.use = "wilcox",
  fc.slot = "data",
  pseudocount.use = 1,
  norm.method = NULL,
  mean.fxn = NULL,
  fc.name = NULL,
  base = 2,
  ...
)

## S3 method for class 'SCTAssay'
FindMarkers(
  object,
  cells.1 = NULL,
  cells.2 = NULL,
  features = NULL,
  test.use = "wilcox",
  pseudocount.use = 1,
  slot = "data",
  fc.slot = "data",
  mean.fxn = NULL,
  fc.name = NULL,
  base = 2,
  recorrect_umi = TRUE,
  ...
)

## S3 method for class 'DimReduc'
FindMarkers(
  object,
  cells.1 = NULL,
  cells.2 = NULL,
  features = NULL,
  logfc.threshold = 0.1,
  test.use = "wilcox",
  min.pct = 0.01,
  min.diff.pct = -Inf,
  verbose = TRUE,
  only.pos = FALSE,
  max.cells.per.ident = Inf,
  random.seed = 1,
  latent.vars = NULL,
  min.cells.feature = 3,
  min.cells.group = 3,
  densify = FALSE,
  mean.fxn = rowMeans,
  fc.name = NULL,
  ...
)

## S3 method for class 'Seurat'
FindMarkers(
  object,
  latent.vars = NULL,
  ident.1 = NULL,
  ident.2 = NULL,
  group.by = NULL,
  subset.ident = NULL,
  assay = NULL,
  reduction = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindMarkers_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and to specific DE methods</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_slot">slot</code></td>
<td>
<p>Slot to pull data from; note that if <code>test.use</code> is
&quot;negbinom&quot;, &quot;poisson&quot;, or &quot;DESeq2&quot;, <code>slot</code> will be set to &quot;counts&quot;</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_cells.1">cells.1</code></td>
<td>
<p>Vector of cell names belonging to group 1</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_cells.2">cells.2</code></td>
<td>
<p>Vector of cell names belonging to group 2</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_features">features</code></td>
<td>
<p>Genes to test. Default is to use all genes</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average, at least
X-fold difference (log-scale) between the two groups of cells. Default is 0.1
Increasing logfc.threshold speeds up the function, but can miss weaker signals.
If the <code>slot</code> parameter is &quot;scale.data&quot; no filtering is performed.</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_test.use">test.use</code></td>
<td>
<p>Denotes which test to use. Available options are:
</p>

<ul>
<li><p>&quot;wilcox&quot; : Identifies differentially expressed genes between two
groups of cells using a Wilcoxon Rank Sum test (default); will use a fast
implementation by Presto if installed
</p>
</li>
<li><p>&quot;wilcox_limma&quot; : Identifies differentially expressed genes between two
groups of cells using the limma implementation of the Wilcoxon Rank Sum test;
set this option to reproduce results from Seurat v4
</p>
</li>
<li><p>&quot;bimod&quot; : Likelihood-ratio test for single cell gene expression,
(McDavid et al., Bioinformatics, 2013)
</p>
</li>
<li><p>&quot;roc&quot; : Identifies 'markers' of gene expression using ROC analysis.
For each gene, evaluates (using AUC) a classifier built on that gene alone,
to classify between two groups of cells. An AUC value of 1 means that
expression values for this gene alone can perfectly classify the two
groupings (i.e. Each of the cells in cells.1 exhibit a higher level than
each of the cells in cells.2). An AUC value of 0 also means there is perfect
classification, but in the other direction. A value of 0.5 implies that
the gene has no predictive power to classify the two groups. Returns a
'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially
expressed genes.
</p>
</li>
<li><p>&quot;t&quot; : Identify differentially expressed genes between two groups of
cells using the Student's t-test.
</p>
</li>
<li><p>&quot;negbinom&quot; : Identifies differentially expressed genes between two
groups of cells using a negative binomial generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;poisson&quot; : Identifies differentially expressed genes between two
groups of cells using a poisson generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;LR&quot; : Uses a logistic regression framework to determine differentially
expressed genes. Constructs a logistic regression model predicting group
membership based on each feature individually and compares this to a null
model with a likelihood ratio test.
</p>
</li>
<li><p>&quot;MAST&quot; : Identifies differentially expressed genes between two groups
of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST
package to run the DE testing.
</p>
</li>
<li><p>&quot;DESeq2&quot; : Identifies differentially expressed genes between two groups
of cells based on a model using DESeq2 which uses a negative binomial
distribution (Love et al, Genome Biology, 2014).This test does not support
pre-filtering of genes based on average difference (or percent detection rate)
between cell groups. However, genes may be pre-filtered based on their
minimum detection rate (min.pct) across both cell groups. To use this method,
please install DESeq2, using the instructions at
https://bioconductor.org/packages/release/bioc/html/DESeq2.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindMarkers_+3A_min.pct">min.pct</code></td>
<td>
<p>only test genes that are detected in a minimum fraction of
min.pct cells in either of the two populations. Meant to speed up the function
by not testing genes that are very infrequently expressed. Default is 0.01</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_min.diff.pct">min.diff.pct</code></td>
<td>
<p>only test genes that show a minimum difference in the
fraction of detection between the two groups. Set to -Inf by default</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_verbose">verbose</code></td>
<td>
<p>Print a progress bar once expression testing begins</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_only.pos">only.pos</code></td>
<td>
<p>Only return positive markers (FALSE by default)</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_max.cells.per.ident">max.cells.per.ident</code></td>
<td>
<p>Down sample each identity class to a max number.
Default is no downsampling. Not activated by default (set to Inf)</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_random.seed">random.seed</code></td>
<td>
<p>Random seed for downsampling</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_latent.vars">latent.vars</code></td>
<td>
<p>Variables to test, used only when <code>test.use</code> is one of
'LR', 'negbinom', 'poisson', or 'MAST'</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_min.cells.feature">min.cells.feature</code></td>
<td>
<p>Minimum number of cells expressing the feature in at least one
of the two groups, currently only used for poisson and negative binomial tests</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_min.cells.group">min.cells.group</code></td>
<td>
<p>Minimum number of cells in one of the groups</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_fc.results">fc.results</code></td>
<td>
<p>data.frame from FoldChange</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_densify">densify</code></td>
<td>
<p>Convert the sparse matrix to a dense form before running the 
DE test. This can provide speedups but might require higher memory; default is FALSE</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_fc.slot">fc.slot</code></td>
<td>
<p>Slot used to calculate fold-change - will also affect the 
default for <code>mean.fxn</code>, see below for more details.</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_pseudocount.use">pseudocount.use</code></td>
<td>
<p>Pseudocount to add to averaged expression values when
calculating logFC. 1 by default.</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_norm.method">norm.method</code></td>
<td>
<p>Normalization method for fold change calculation when
<code>slot</code> is &ldquo;<code>data</code>&rdquo;</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_mean.fxn">mean.fxn</code></td>
<td>
<p>Function to use for fold change or average difference calculation.
The default depends on the the value of <code>fc.slot</code>:
</p>

<ul>
<li><p>&quot;counts&quot; : difference in the log of the mean counts, with pseudocount.
</p>
</li>
<li><p>&quot;data&quot; : difference in the log of the average exponentiated data, with pseudocount.
This adjusts for differences in sequencing depth between cells, and assumes that &quot;data&quot;
has been log-normalized.
</p>
</li>
<li><p>&quot;scale.data&quot; : difference in the means of scale.data.
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindMarkers_+3A_fc.name">fc.name</code></td>
<td>
<p>Name of the fold change, average difference, or custom function column
in the output data.frame. If NULL, the fold change column will be named
according to the logarithm base (eg, &quot;avg_log2FC&quot;), or if using the scale.data
slot &quot;avg_diff&quot;.</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_base">base</code></td>
<td>
<p>The base with respect to which logarithms are computed.</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_recorrect_umi">recorrect_umi</code></td>
<td>
<p>Recalculate corrected UMI counts using minimum of the 
median UMIs when performing DE using multiple SCT objects; default is TRUE</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_ident.1">ident.1</code></td>
<td>
<p>Identity class to define markers for; pass an object of class
<code>phylo</code> or 'clustertree' to find markers for a node in a cluster tree;
passing 'clustertree' requires <code><a href="#topic+BuildClusterTree">BuildClusterTree</a></code> to have been run</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_ident.2">ident.2</code></td>
<td>
<p>A second identity class for comparison; if <code>NULL</code>,
use all other cells for comparison; if an object of class <code>phylo</code> or
'clustertree' is passed to <code>ident.1</code>, must pass a node to find markers for</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_group.by">group.by</code></td>
<td>
<p>Regroup cells into a different identity class prior to 
performing differential expression (see example)</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_subset.ident">subset.ident</code></td>
<td>
<p>Subset a particular identity class prior to regrouping. 
Only relevant if group.by is set (see example)</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_assay">assay</code></td>
<td>
<p>Assay to use in differential expression testing</p>
</td></tr>
<tr><td><code id="FindMarkers_+3A_reduction">reduction</code></td>
<td>
<p>Reduction to use in differential expression testing - will 
test for DE on cell embeddings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>p-value adjustment is performed using bonferroni correction based on
the total number of genes in the dataset. Other correction methods are not
recommended, as Seurat pre-filters genes using the arguments above, reducing
the number of tests performed. Lastly, as Aaron Lun has pointed out, p-values
should be interpreted cautiously, as the genes used for clustering are the
same genes tested for differential expression.
</p>


<h3>Value</h3>

<p>data.frame with a ranked list of putative markers as rows, and associated
statistics as columns (p-values, ROC score, etc., depending on the test used (<code>test.use</code>)). The following columns are always present:
</p>

<ul>
<li> <p><code>avg_logFC</code>: log fold-chage of the average expression between the two groups. Positive values indicate that the gene is more highly expressed in the first group
</p>
</li>
<li> <p><code>pct.1</code>: The percentage of cells where the gene is detected in the first group
</p>
</li>
<li> <p><code>pct.2</code>: The percentage of cells where the gene is detected in the second group
</p>
</li>
<li> <p><code>p_val_adj</code>: Adjusted p-value, based on bonferroni correction using all genes in the dataset
</p>
</li></ul>



<h3>References</h3>

<p>McDavid A, Finak G, Chattopadyay PK, et al. Data exploration,
quality control and testing in single-cell qPCR-based gene expression experiments.
Bioinformatics. 2013;29(4):461-467. doi:10.1093/bioinformatics/bts714
</p>
<p>Trapnell C, et al. The dynamics and regulators of cell fate
decisions are revealed by pseudotemporal ordering of single cells. Nature
Biotechnology volume 32, pages 381-386 (2014)
</p>
<p>Andrew McDavid, Greg Finak and Masanao Yajima (2017). MAST: Model-based
Analysis of Single Cell Transcriptomics. R package version 1.2.1.
https://github.com/RGLab/MAST/
</p>
<p>Love MI, Huber W and Anders S (2014). &quot;Moderated estimation of
fold change and dispersion for RNA-seq data with DESeq2.&quot; Genome Biology.
https://bioconductor.org/packages/release/bioc/html/DESeq2.html
</p>


<h3>See Also</h3>

<p><code>FoldChange</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
# Find markers for cluster 2
markers &lt;- FindMarkers(object = pbmc_small, ident.1 = 2)
head(x = markers)

# Take all cells in cluster 2, and find markers that separate cells in the 'g1' group (metadata
# variable 'group')
markers &lt;- FindMarkers(pbmc_small, ident.1 = "g1", group.by = 'groups', subset.ident = "2")
head(x = markers)

# Pass 'clustertree' or an object of class phylo to ident.1 and
# a node to ident.2 as a replacement for FindMarkersNode
if (requireNamespace("ape", quietly = TRUE)) {
  pbmc_small &lt;- BuildClusterTree(object = pbmc_small)
  markers &lt;- FindMarkers(object = pbmc_small, ident.1 = 'clustertree', ident.2 = 5)
  head(x = markers)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='FindMultiModalNeighbors'>Construct weighted nearest neighbor graph</h2><span id='topic+FindMultiModalNeighbors'></span>

<h3>Description</h3>

<p>This function will construct a weighted nearest neighbor (WNN) graph. For
each cell, we identify the nearest neighbors based on a weighted combination
of two modalities. Takes as input two dimensional reductions, one computed
for each modality.Other parameters are listed for debugging, but can be left
as default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMultiModalNeighbors(
  object,
  reduction.list,
  dims.list,
  k.nn = 20,
  l2.norm = TRUE,
  knn.graph.name = "wknn",
  snn.graph.name = "wsnn",
  weighted.nn.name = "weighted.nn",
  modality.weight.name = NULL,
  knn.range = 200,
  prune.SNN = 1/15,
  sd.scale = 1,
  cross.contant.list = NULL,
  smooth = FALSE,
  return.intermediate = FALSE,
  modality.weight = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindMultiModalNeighbors_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_reduction.list">reduction.list</code></td>
<td>
<p>A list of two dimensional reductions, one for each of
the modalities to be integrated</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_dims.list">dims.list</code></td>
<td>
<p>A list containing the dimensions for each reduction to use</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_k.nn">k.nn</code></td>
<td>
<p>the number of multimodal neighbors to compute. 20 by default</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Perform L2 normalization on the cell embeddings after
dimensional reduction. TRUE by default.</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_knn.graph.name">knn.graph.name</code></td>
<td>
<p>Multimodal knn graph name</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_snn.graph.name">snn.graph.name</code></td>
<td>
<p>Multimodal snn graph name</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_weighted.nn.name">weighted.nn.name</code></td>
<td>
<p>Multimodal neighbor object name</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_modality.weight.name">modality.weight.name</code></td>
<td>
<p>Variable name to store modality weight in object
meta data</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_knn.range">knn.range</code></td>
<td>
<p>The number of approximate neighbors to compute</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_prune.snn">prune.SNN</code></td>
<td>
<p>Cutoff not to discard edge in SNN graph</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_sd.scale">sd.scale</code></td>
<td>
<p>The scaling factor for kernel width. 1 by default</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_cross.contant.list">cross.contant.list</code></td>
<td>
<p>Constant used to avoid divide-by-zero errors. 1e-4
by default</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_smooth">smooth</code></td>
<td>
<p>Smoothing modality score across each individual modality
neighbors. FALSE by default</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_return.intermediate">return.intermediate</code></td>
<td>
<p>Store intermediate results in misc</p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_modality.weight">modality.weight</code></td>
<td>
<p>A <code><a href="#topic+ModalityWeights">ModalityWeights</a></code> object generated by
<code>FindModalityWeights</code></p>
</td></tr>
<tr><td><code id="FindMultiModalNeighbors_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Seurat object containing a nearest-neighbor object, KNN graph, and
SNN graph - each based on a weighted combination of modalities.
</p>

<hr>
<h2 id='FindNeighbors'>(Shared) Nearest-neighbor graph construction</h2><span id='topic+FindNeighbors'></span><span id='topic+FindNeighbors.default'></span><span id='topic+FindNeighbors.Assay'></span><span id='topic+FindNeighbors.dist'></span><span id='topic+FindNeighbors.Seurat'></span>

<h3>Description</h3>

<p>Computes the <code>k.param</code> nearest neighbors for a given dataset. Can also
optionally (via <code>compute.SNN</code>), construct a shared nearest neighbor
graph by calculating the neighborhood overlap (Jaccard index) between every
cell and its <code>k.param</code> nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindNeighbors(object, ...)

## Default S3 method:
FindNeighbors(
  object,
  query = NULL,
  distance.matrix = FALSE,
  k.param = 20,
  return.neighbor = FALSE,
  compute.SNN = !return.neighbor,
  prune.SNN = 1/15,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "euclidean",
  nn.eps = 0,
  verbose = TRUE,
  l2.norm = FALSE,
  cache.index = FALSE,
  index = NULL,
  ...
)

## S3 method for class 'Assay'
FindNeighbors(
  object,
  features = NULL,
  k.param = 20,
  return.neighbor = FALSE,
  compute.SNN = !return.neighbor,
  prune.SNN = 1/15,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "euclidean",
  nn.eps = 0,
  verbose = TRUE,
  l2.norm = FALSE,
  cache.index = FALSE,
  ...
)

## S3 method for class 'dist'
FindNeighbors(
  object,
  k.param = 20,
  return.neighbor = FALSE,
  compute.SNN = !return.neighbor,
  prune.SNN = 1/15,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "euclidean",
  nn.eps = 0,
  verbose = TRUE,
  l2.norm = FALSE,
  cache.index = FALSE,
  ...
)

## S3 method for class 'Seurat'
FindNeighbors(
  object,
  reduction = "pca",
  dims = 1:10,
  assay = NULL,
  features = NULL,
  k.param = 20,
  return.neighbor = FALSE,
  compute.SNN = !return.neighbor,
  prune.SNN = 1/15,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "euclidean",
  nn.eps = 0,
  verbose = TRUE,
  do.plot = FALSE,
  graph.name = NULL,
  l2.norm = FALSE,
  cache.index = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindNeighbors_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_query">query</code></td>
<td>
<p>Matrix of data to query against object. If missing, defaults to
object.</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>Boolean value of whether the provided matrix is a
distance matrix; note, for objects of class <code>dist</code>, this parameter will
be set automatically</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_k.param">k.param</code></td>
<td>
<p>Defines k for the k-nearest neighbor algorithm</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_return.neighbor">return.neighbor</code></td>
<td>
<p>Return result as <code><a href="SeuratObject.html#topic+Neighbor">Neighbor</a></code> object. Not
used with distance matrix input.</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_compute.snn">compute.SNN</code></td>
<td>
<p>also compute the shared nearest neighbor graph</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_prune.snn">prune.SNN</code></td>
<td>
<p>Sets the cutoff for acceptable Jaccard index when
computing the neighborhood overlap for the SNN construction. Any edges with
values less than or equal to this will be set to 0 and removed from the SNN
graph. Essentially sets the stringency of pruning (0 &mdash; no pruning, 1 &mdash;
prune everything).</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_nn.method">nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann,
annoy</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_n.trees">n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_annoy.metric">annoy.metric</code></td>
<td>
<p>Distance metric for annoy. Options include: euclidean,
cosine, manhattan, and hamming</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_nn.eps">nn.eps</code></td>
<td>
<p>Error bound when performing nearest neighbor seach using RANN;
default of 0.0 implies exact nearest neighbor search</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print output to the console</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Take L2Norm of the data</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_cache.index">cache.index</code></td>
<td>
<p>Include cached index in returned Neighbor object
(only relevant if return.neighbor = TRUE)</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_index">index</code></td>
<td>
<p>Precomputed index. Useful if querying new data against existing
index to avoid recomputing.</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_features">features</code></td>
<td>
<p>Features to use as input for building the (S)NN; used only when
<code>dims</code> is <code>NULL</code></p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_reduction">reduction</code></td>
<td>
<p>Reduction to use as input for building the (S)NN</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_dims">dims</code></td>
<td>
<p>Dimensions of reduction to use as input</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_assay">assay</code></td>
<td>
<p>Assay to use in construction of (S)NN; used only when <code>dims</code>
is <code>NULL</code></p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_do.plot">do.plot</code></td>
<td>
<p>Plot SNN graph on tSNE coordinates</p>
</td></tr>
<tr><td><code id="FindNeighbors_+3A_graph.name">graph.name</code></td>
<td>
<p>Optional naming parameter for stored (S)NN graph
(or Neighbor object, if return.neighbor = TRUE). Default is assay.name_(s)nn.
To store both the neighbor graph and the shared nearest neighbor (SNN) graph,
you must supply a vector containing two names to the <code>graph.name</code>
parameter. The first element in the vector will be used to store the nearest
neighbor (NN) graph, and the second element used to store the SNN graph. If
only one name is supplied, only the NN graph is stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function can either return a <code><a href="SeuratObject.html#topic+Neighbor">Neighbor</a></code> object
with the KNN information or a list of <code><a href="SeuratObject.html#topic+Graph">Graph</a></code> objects with
the KNN and SNN depending on the settings of <code>return.neighbor</code> and
<code>compute.SNN</code>. When running on a <code><a href="#topic+Seurat">Seurat</a></code> object, this
returns the <code><a href="#topic+Seurat">Seurat</a></code> object with the Graphs or Neighbor objects
stored in their respective slots. Names of the Graph or Neighbor object can
be found with <code><a href="SeuratObject.html#topic+Graphs">Graphs</a></code> or <code><a href="#topic+Neighbors">Neighbors</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small
# Compute an SNN on the gene expression level
pbmc_small &lt;- FindNeighbors(pbmc_small, features = VariableFeatures(object = pbmc_small))

# More commonly, we build the SNN on a dimensionally reduced form of the data
# such as the first 10 principle components.

pbmc_small &lt;- FindNeighbors(pbmc_small, reduction = "pca", dims = 1:10)

</code></pre>

<hr>
<h2 id='FindSpatiallyVariableFeatures'>Find spatially variable features</h2><span id='topic+FindSpatiallyVariableFeatures'></span><span id='topic+FindSpatiallyVariableFeatures.default'></span><span id='topic+FindSpatiallyVariableFeatures.Assay'></span><span id='topic+FindSpatiallyVariableFeatures.Seurat'></span><span id='topic+FindSpatiallyVariableFeatures.StdAssay'></span>

<h3>Description</h3>

<p>Identify features whose variability in expression can be explained to some
degree by spatial location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindSpatiallyVariableFeatures(object, ...)

## Default S3 method:
FindSpatiallyVariableFeatures(
  object,
  spatial.location,
  selection.method = c("markvariogram", "moransi"),
  r.metric = 5,
  x.cuts = NULL,
  y.cuts = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
FindSpatiallyVariableFeatures(
  object,
  slot = "scale.data",
  spatial.location,
  selection.method = c("markvariogram", "moransi"),
  features = NULL,
  r.metric = 5,
  x.cuts = NULL,
  y.cuts = NULL,
  nfeatures = nfeatures,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
FindSpatiallyVariableFeatures(
  object,
  assay = NULL,
  slot = "scale.data",
  features = NULL,
  image = NULL,
  selection.method = c("markvariogram", "moransi"),
  r.metric = 5,
  x.cuts = NULL,
  y.cuts = NULL,
  nfeatures = 2000,
  verbose = TRUE,
  ...
)

## S3 method for class 'StdAssay'
FindSpatiallyVariableFeatures(
  object,
  layer = "scale.data",
  spatial.location,
  selection.method = c("markvariogram", "moransi"),
  features = NULL,
  r.metric = 5,
  x.cuts = NULL,
  y.cuts = NULL,
  nfeatures = nfeatures,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_object">object</code></td>
<td>
<p>A Seurat object, assay, or expression matrix</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_spatial.location">spatial.location</code></td>
<td>
<p>Coordinates for each cell/spot/bead</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_selection.method">selection.method</code></td>
<td>
<p>Method for selecting spatially variable features.
</p>

<ul>
<li> <p><code>markvariogram</code>: See <code><a href="#topic+RunMarkVario">RunMarkVario</a></code> for details
</p>
</li>
<li> <p><code>moransi</code>: See <code><a href="#topic+RunMoransI">RunMoransI</a></code> for details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_r.metric">r.metric</code></td>
<td>
<p>r value at which to report the &quot;trans&quot; value of the mark
variogram</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_x.cuts">x.cuts</code></td>
<td>
<p>Number of divisions to make in the x direction, helps define
the grid over which binning is performed</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_y.cuts">y.cuts</code></td>
<td>
<p>Number of divisions to make in the y direction, helps define
the grid over which binning is performed</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_slot">slot</code></td>
<td>
<p>Slot in the Assay to pull data from</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_features">features</code></td>
<td>
<p>If provided, only compute on given features. Otherwise,
compute for all features.</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to mark as the top spatially variable.</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_assay">assay</code></td>
<td>
<p>Assay to pull the features (marks) from</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_image">image</code></td>
<td>
<p>Name of image to pull the coordinates from</p>
</td></tr>
<tr><td><code id="FindSpatiallyVariableFeatures_+3A_layer">layer</code></td>
<td>
<p>Layer in the Assay5 to pull data from</p>
</td></tr>
</table>

<hr>
<h2 id='FindSubCluster'>Find subclusters under one cluster</h2><span id='topic+FindSubCluster'></span>

<h3>Description</h3>

<p>Find subclusters under one cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindSubCluster(
  object,
  cluster,
  graph.name,
  subcluster.name = "sub.cluster",
  resolution = 0.5,
  algorithm = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindSubCluster_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindSubCluster_+3A_cluster">cluster</code></td>
<td>
<p>the cluster to be sub-clustered</p>
</td></tr>
<tr><td><code id="FindSubCluster_+3A_graph.name">graph.name</code></td>
<td>
<p>Name of graph to use for the clustering algorithm</p>
</td></tr>
<tr><td><code id="FindSubCluster_+3A_subcluster.name">subcluster.name</code></td>
<td>
<p>the name of sub cluster added in the meta.data</p>
</td></tr>
<tr><td><code id="FindSubCluster_+3A_resolution">resolution</code></td>
<td>
<p>Value of the resolution parameter, use a value above
(below) 1.0 if you want to obtain a larger (smaller) number of communities.</p>
</td></tr>
<tr><td><code id="FindSubCluster_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for modularity optimization (1 = original Louvain
algorithm; 2 = Louvain algorithm with multilevel refinement; 3 = SLM
algorithm; 4 = Leiden algorithm). Leiden requires the leidenalg python.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a object with sub cluster labels in the sub-cluster.name variable
</p>

<hr>
<h2 id='FindTransferAnchors'>Find transfer anchors</h2><span id='topic+FindTransferAnchors'></span>

<h3>Description</h3>

<p>Find a set of anchors between a reference and query object. These
anchors can later be used to transfer data from the reference to
query object using the <code><a href="#topic+TransferData">TransferData</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindTransferAnchors(
  reference,
  query,
  normalization.method = "LogNormalize",
  recompute.residuals = TRUE,
  reference.assay = NULL,
  reference.neighbors = NULL,
  query.assay = NULL,
  reduction = "pcaproject",
  reference.reduction = NULL,
  project.query = FALSE,
  features = NULL,
  scale = TRUE,
  npcs = 30,
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = NA,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0,
  approx.pca = TRUE,
  mapping.score.k = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindTransferAnchors_+3A_reference">reference</code></td>
<td>
<p><code><a href="#topic+Seurat">Seurat</a></code> object to use as the reference</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_query">query</code></td>
<td>
<p><code><a href="#topic+Seurat">Seurat</a></code> object to use as the query</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_recompute.residuals">recompute.residuals</code></td>
<td>
<p>If using SCT as a normalization method, compute
query Pearson residuals using the reference SCT model parameters.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_reference.assay">reference.assay</code></td>
<td>
<p>Name of the Assay to use from reference</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_reference.neighbors">reference.neighbors</code></td>
<td>
<p>Name of the Neighbor to use from the reference.
Optionally enables reuse of precomputed neighbors.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_query.assay">query.assay</code></td>
<td>
<p>Name of the Assay to use from query</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to perform when finding anchors.
Options are:
</p>

<ul>
<li><p>pcaproject: Project the PCA from the reference onto the query. We
recommend using PCA when reference and query datasets are from scRNA-seq
</p>
</li>
<li><p>lsiproject: Project the LSI from the reference onto the query. We
recommend using LSI when reference and query datasets are from scATAC-seq.
This requires that LSI has been computed for the reference dataset, and the
same features (eg, peaks or genome bins) are present in both the reference
and query. See <code><a href="Signac.html#topic+RunTFIDF">RunTFIDF</a></code> and
<code><a href="Signac.html#topic+RunSVD">RunSVD</a></code>
</p>
</li>
<li><p>rpca: Project the PCA from the reference onto the query, and the PCA
from the query onto the reference (reciprocal PCA projection).
</p>
</li>
<li><p>cca: Run a CCA on the reference and query 
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_reference.reduction">reference.reduction</code></td>
<td>
<p>Name of dimensional reduction to use from the
reference if running the pcaproject workflow. Optionally enables reuse of
precomputed reference dimensional reduction. If NULL (default), use a PCA
computed on the reference object.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_project.query">project.query</code></td>
<td>
<p>Project the PCA from the query dataset onto the
reference. Use only in rare cases where the query dataset has a much larger
cell number, but the reference dataset has a unique assay for transfer. In
this case, the default features will be set to the variable features of the
query object that are alos present in the reference.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_features">features</code></td>
<td>
<p>Features to use for dimensional reduction. If not specified,
set as variable features of the reference object which are also present in
the query.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_scale">scale</code></td>
<td>
<p>Scale query data.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_npcs">npcs</code></td>
<td>
<p>Number of PCs to compute on reference if reference.reduction is
not provided.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Perform L2 normalization on the cell embeddings after
dimensional reduction</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to use from the reduction to specify the
neighbor search space</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_k.anchor">k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when finding anchors</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_k.filter">k.filter</code></td>
<td>
<p>How many neighbors (k) to use when filtering anchors. Set to
NA to turn off filtering.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_k.score">k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_max.features">max.features</code></td>
<td>
<p>The maximum number of features to use when specifying the
neighborhood search space in the anchor filtering</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_nn.method">nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann,
annoy</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_n.trees">n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_eps">eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from
<code><a href="RANN.html#topic+RANN">RANN</a></code> or <code><a href="RcppAnnoy.html#topic+RcppAnnoy">RcppAnnoy</a></code>)</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_approx.pca">approx.pca</code></td>
<td>
<p>Use truncated singular value decomposition to approximate
PCA</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_mapping.score.k">mapping.score.k</code></td>
<td>
<p>Compute and store nearest k query neighbors in the
AnchorSet object that is returned. You can optionally set this if you plan
on computing the mapping score and want to enable reuse of some downstream
neighbor calculations to make the mapping score function more efficient.</p>
</td></tr>
<tr><td><code id="FindTransferAnchors_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>

<ul>
<li><p>Perform dimensional reduction. Exactly what is done here depends on
the values set for the <code>reduction</code> and <code>project.query</code>
parameters. If <code>reduction = "pcaproject"</code>, a PCA is performed on
either the reference (if <code>project.query = FALSE</code>) or the query (if
<code>project.query = TRUE</code>), using the <code>features</code> specified. The data
from the other dataset is then projected onto this learned PCA structure.
If <code>reduction = "cca"</code>, then CCA is performed on the reference and
query for this dimensional reduction step. If
<code>reduction = "lsiproject"</code>, the stored LSI dimension reduction in the
reference object is used to project the query dataset onto the reference.
If <code>l2.norm</code> is set to <code>TRUE</code>, perform L2 normalization of the
embedding vectors.
</p>
</li>
<li><p>Identify anchors between the reference and query - pairs of cells
from each dataset that are contained within each other's neighborhoods
(also known as mutual nearest neighbors).
</p>
</li>
<li><p>Filter low confidence anchors to ensure anchors in the low dimension
space are in broad agreement with the high dimensional measurements. This
is done by looking at the neighbors of each query cell in the reference
dataset using <code>max.features</code> to define this space. If the reference
cell isn't found within the first <code>k.filter</code> neighbors, remove the
anchor.
</p>
</li>
<li><p>Assign each remaining anchor a score. For each anchor cell, determine
the nearest <code>k.score</code> anchors within its own dataset and within its
pair's dataset. Based on these neighborhoods, construct an overall neighbor
graph and then compute the shared neighbor overlap between anchor and query
cells (analogous to an SNN graph). We use the 0.01 and 0.90 quantiles on
these scores to dampen outlier effects and rescale to range between 0-1.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an <code>AnchorSet</code> object that can be used as input to
<code><a href="#topic+TransferData">TransferData</a></code>, <code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code> and
<code><a href="#topic+MapQuery">MapQuery</a></code>. The dimension reduction used for finding anchors is
stored in the <code>AnchorSet</code> object and can be used for computing anchor
weights in downstream functions. Note that only the requested dimensions are
stored in the dimension reduction object in the <code>AnchorSet</code>. This means
that if <code>dims=2:20</code> is used, for example, the dimension of the stored
reduction is <code>1:19</code>.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("pbmc3k")

# for demonstration, split the object into reference and query
pbmc.reference &lt;- pbmc3k[, 1:1350]
pbmc.query &lt;- pbmc3k[, 1351:2700]

# perform standard preprocessing on each object
pbmc.reference &lt;- NormalizeData(pbmc.reference)
pbmc.reference &lt;- FindVariableFeatures(pbmc.reference)
pbmc.reference &lt;- ScaleData(pbmc.reference)

pbmc.query &lt;- NormalizeData(pbmc.query)
pbmc.query &lt;- FindVariableFeatures(pbmc.query)
pbmc.query &lt;- ScaleData(pbmc.query)

# find anchors
anchors &lt;- FindTransferAnchors(reference = pbmc.reference, query = pbmc.query)

# transfer labels
predictions &lt;- TransferData(
  anchorset = anchors,
  refdata = pbmc.reference$seurat_annotations
)
pbmc.query &lt;- AddMetaData(object = pbmc.query, metadata = predictions)

## End(Not run)

</code></pre>

<hr>
<h2 id='FindVariableFeatures'>Find variable features</h2><span id='topic+FindVariableFeatures'></span><span id='topic+FindVariableGenes'></span><span id='topic+FindVariableFeatures.V3Matrix'></span><span id='topic+FindVariableFeatures.Assay'></span><span id='topic+FindVariableFeatures.SCTAssay'></span><span id='topic+FindVariableFeatures.Seurat'></span>

<h3>Description</h3>

<p>Identifies features that are outliers on a 'mean variability plot'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindVariableFeatures(object, ...)

## S3 method for class 'V3Matrix'
FindVariableFeatures(
  object,
  selection.method = "vst",
  loess.span = 0.3,
  clip.max = "auto",
  mean.function = FastExpMean,
  dispersion.function = FastLogVMR,
  num.bin = 20,
  binning.method = "equal_width",
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
FindVariableFeatures(
  object,
  selection.method = "vst",
  loess.span = 0.3,
  clip.max = "auto",
  mean.function = FastExpMean,
  dispersion.function = FastLogVMR,
  num.bin = 20,
  binning.method = "equal_width",
  nfeatures = 2000,
  mean.cutoff = c(0.1, 8),
  dispersion.cutoff = c(1, Inf),
  verbose = TRUE,
  ...
)

## S3 method for class 'SCTAssay'
FindVariableFeatures(object, nfeatures = 2000, ...)

## S3 method for class 'Seurat'
FindVariableFeatures(
  object,
  assay = NULL,
  selection.method = "vst",
  loess.span = 0.3,
  clip.max = "auto",
  mean.function = FastExpMean,
  dispersion.function = FastLogVMR,
  num.bin = 20,
  binning.method = "equal_width",
  nfeatures = 2000,
  mean.cutoff = c(0.1, 8),
  dispersion.cutoff = c(1, Inf),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindVariableFeatures_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_selection.method">selection.method</code></td>
<td>
<p>How to choose top variable features. Choose one of :
</p>

<ul>
<li> <p>&ldquo;<code>vst</code>&rdquo;:  First, fits a line to the relationship of
log(variance) and log(mean) using local polynomial regression (loess).
Then standardizes the feature values using the observed mean and
expected variance (given by the fitted line). Feature variance is then
calculated on the standardized values
after clipping to a maximum (see clip.max parameter).
</p>
</li>
<li> <p>&ldquo;<code>mean.var.plot</code>&rdquo; (mvp): First, uses a function to
calculate average expression (mean.function) and dispersion
(dispersion.function) for each feature. Next, divides features into
<code>num.bin</code> (deafult 20) bins based on their average expression,
and calculates z-scores for dispersion within each bin. The purpose of
this is to identify variable features while controlling for the
strong relationship between variability and average expression
</p>
</li>
<li> <p>&ldquo;<code>dispersion</code>&rdquo; (disp): selects the genes with the
highest dispersion values
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_loess.span">loess.span</code></td>
<td>
<p>(vst method) Loess span parameter used when fitting the
variance-mean relationship</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_clip.max">clip.max</code></td>
<td>
<p>(vst method) After standardization values larger than
clip.max will be set to clip.max; default is 'auto' which sets this value to
the square root of the number of cells</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_mean.function">mean.function</code></td>
<td>
<p>Function to compute x-axis value (average expression).
Default is to take the mean of the detected (i.e. non-zero) values</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_dispersion.function">dispersion.function</code></td>
<td>
<p>Function to compute y-axis value (dispersion).
Default is to take the standard deviation of all values</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_num.bin">num.bin</code></td>
<td>
<p>Total number of bins to use in the scaled analysis (default
is 20)</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_binning.method">binning.method</code></td>
<td>
<p>Specifies how the bins should be computed. Available
methods are:
</p>

<ul>
<li> <p>&ldquo;<code>equal_width</code>&rdquo;: each bin is of equal width along the
x-axis (default)
</p>
</li>
<li> <p>&ldquo;<code>equal_frequency</code>&rdquo;: each bin contains an equal number
of features (can increase statistical power to detect overdispersed
eatures at high expression values, at the cost of reduced resolution
along the x-axis)
</p>
</li></ul>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_verbose">verbose</code></td>
<td>
<p>show progress bar for calculations</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to select as top variable features;
only used when <code>selection.method</code> is set to <code>'dispersion'</code> or
<code>'vst'</code></p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_mean.cutoff">mean.cutoff</code></td>
<td>
<p>A two-length numeric vector with low- and high-cutoffs for
feature means</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_dispersion.cutoff">dispersion.cutoff</code></td>
<td>
<p>A two-length numeric vector with low- and high-cutoffs for
feature dispersions</p>
</td></tr>
<tr><td><code id="FindVariableFeatures_+3A_assay">assay</code></td>
<td>
<p>Assay to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the mean.var.plot method:
Exact parameter settings may vary empirically from dataset to dataset, and
based on visual inspection of the plot. Setting the y.cutoff parameter to 2
identifies features that are more than two standard deviations away from the
average dispersion within a bin. The default X-axis function is the mean
expression level, and for Y-axis it is the log(Variance/mean). All mean/variance
calculations are not performed in log-space, but the results are reported in
log-space - see relevant functions for exact details.
</p>

<hr>
<h2 id='FoldChange'>Fold Change</h2><span id='topic+FoldChange'></span><span id='topic+FoldChange.default'></span><span id='topic+FoldChange.Assay'></span><span id='topic+FoldChange.SCTAssay'></span><span id='topic+FoldChange.DimReduc'></span><span id='topic+FoldChange.Seurat'></span>

<h3>Description</h3>

<p>Calculate log fold change and percentage of cells expressing each feature
for different identity classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FoldChange(object, ...)

## Default S3 method:
FoldChange(object, cells.1, cells.2, mean.fxn, fc.name, features = NULL, ...)

## S3 method for class 'Assay'
FoldChange(
  object,
  cells.1,
  cells.2,
  features = NULL,
  slot = "data",
  pseudocount.use = 1,
  fc.name = NULL,
  mean.fxn = NULL,
  base = 2,
  norm.method = NULL,
  ...
)

## S3 method for class 'SCTAssay'
FoldChange(
  object,
  cells.1,
  cells.2,
  features = NULL,
  slot = "data",
  pseudocount.use = 1,
  fc.name = NULL,
  mean.fxn = NULL,
  base = 2,
  ...
)

## S3 method for class 'DimReduc'
FoldChange(
  object,
  cells.1,
  cells.2,
  features = NULL,
  slot = NULL,
  pseudocount.use = 1,
  fc.name = NULL,
  mean.fxn = NULL,
  ...
)

## S3 method for class 'Seurat'
FoldChange(
  object,
  ident.1 = NULL,
  ident.2 = NULL,
  group.by = NULL,
  subset.ident = NULL,
  assay = NULL,
  slot = "data",
  reduction = NULL,
  features = NULL,
  pseudocount.use = 1,
  mean.fxn = NULL,
  base = 2,
  fc.name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FoldChange_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_cells.1">cells.1</code></td>
<td>
<p>Vector of cell names belonging to group 1</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_cells.2">cells.2</code></td>
<td>
<p>Vector of cell names belonging to group 2</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_mean.fxn">mean.fxn</code></td>
<td>
<p>Function to use for fold change or average difference calculation</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_fc.name">fc.name</code></td>
<td>
<p>Name of the fold change, average difference, or custom function column
in the output data.frame</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_features">features</code></td>
<td>
<p>Features to calculate fold change for.
If NULL, use all features</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_slot">slot</code></td>
<td>
<p>Slot to pull data from</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_pseudocount.use">pseudocount.use</code></td>
<td>
<p>Pseudocount to add to averaged expression values when
calculating logFC.</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_base">base</code></td>
<td>
<p>The base with respect to which logarithms are computed.</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_norm.method">norm.method</code></td>
<td>
<p>Normalization method for mean function selection
when <code>slot</code> is &ldquo;<code>data</code>&rdquo;</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_ident.1">ident.1</code></td>
<td>
<p>Identity class to calculate fold change for; pass an object of class
<code>phylo</code> or 'clustertree' to calculate fold change for a node in a cluster tree;
passing 'clustertree' requires <code><a href="#topic+BuildClusterTree">BuildClusterTree</a></code> to have been run</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_ident.2">ident.2</code></td>
<td>
<p>A second identity class for comparison; if <code>NULL</code>,
use all other cells for comparison; if an object of class <code>phylo</code> or
'clustertree' is passed to <code>ident.1</code>, must pass a node to calculate fold change for</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_group.by">group.by</code></td>
<td>
<p>Regroup cells into a different identity class prior to
calculating fold change (see example in <code><a href="#topic+FindMarkers">FindMarkers</a></code>)</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_subset.ident">subset.ident</code></td>
<td>
<p>Subset a particular identity class prior to regrouping.
Only relevant if group.by is set (see example in <code><a href="#topic+FindMarkers">FindMarkers</a></code>)</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_assay">assay</code></td>
<td>
<p>Assay to use in fold change calculation</p>
</td></tr>
<tr><td><code id="FoldChange_+3A_reduction">reduction</code></td>
<td>
<p>Reduction to use - will calculate average difference on cell embeddings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the slot is <code>scale.data</code> or a reduction is specified, average difference
is returned instead of log fold change and the column is named &quot;avg_diff&quot;.
Otherwise, log2 fold change is returned with column named &quot;avg_log2_FC&quot;.
</p>


<h3>Value</h3>

<p>Returns a data.frame
</p>


<h3>See Also</h3>

<p><code>FindMarkers</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
FoldChange(pbmc_small, ident.1 = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='fortify-Spatial'>Prepare Coordinates for Spatial Plots</h2><span id='topic+fortify-Spatial'></span><span id='topic+fortify.Centroids'></span><span id='topic+fortify'></span><span id='topic+fortify.Molecules'></span><span id='topic+fortify.Segmentation'></span>

<h3>Description</h3>

<p>Prepare Coordinates for Spatial Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Centroids'
fortify(model, data, ...)

## S3 method for class 'Molecules'
fortify(model, data, nmols = NULL, seed = NA_integer_, ...)

## S3 method for class 'Segmentation'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify-Spatial_+3A_model">model</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Segmentation-class">Segmentation</a></code>,
<code><a href="SeuratObject.html#topic+Centroids-class">Centroids</a></code>,
or <code><a href="SeuratObject.html#topic+Molecules-class">Molecules</a></code> object</p>
</td></tr>
<tr><td><code id="fortify-Spatial_+3A_data">data</code></td>
<td>
<p>Extra data to be used for annotating the cell segmentations; the
easiest way to pass data is a one-column
<code><a href="base.html#topic+data.frame">data frame</a></code> with the values to color by and
the cell names are rownames</p>
</td></tr>
<tr><td><code id="fortify-Spatial_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='GaussianSketch'>Gaussian sketching</h2><span id='topic+GaussianSketch'></span>

<h3>Description</h3>

<p>Gaussian sketching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianSketch(nsketch, ncells, seed = NA_integer_, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianSketch_+3A_nsketch">nsketch</code></td>
<td>
<p>Number of sketching random cells</p>
</td></tr>
<tr><td><code id="GaussianSketch_+3A_ncells">ncells</code></td>
<td>
<p>Number of cells in the original data</p>
</td></tr>
<tr><td><code id="GaussianSketch_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or <code>NULL</code>
(see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="GaussianSketch_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='GetAssay'>Get an Assay object from a given Seurat object.</h2><span id='topic+GetAssay'></span><span id='topic+GetAssay.Seurat'></span>

<h3>Description</h3>

<p>Get an Assay object from a given Seurat object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAssay(object, ...)

## S3 method for class 'Seurat'
GetAssay(object, assay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetAssay_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="GetAssay_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="GetAssay_+3A_assay">assay</code></td>
<td>
<p>Assay to get</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an Assay object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
GetAssay(object = pbmc_small, assay = "RNA")

</code></pre>

<hr>
<h2 id='GetImage.SlideSeq'>Get Image Data</h2><span id='topic+GetImage.SlideSeq'></span><span id='topic+GetImage.STARmap'></span><span id='topic+GetImage.VisiumV1'></span>

<h3>Description</h3>

<p>Get Image Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SlideSeq'
GetImage(object, mode = c("grob", "raster", "plotly", "raw"), ...)

## S3 method for class 'STARmap'
GetImage(object, mode = c("grob", "raster", "plotly", "raw"), ...)

## S3 method for class 'VisiumV1'
GetImage(object, mode = c("grob", "raster", "plotly", "raw"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetImage.SlideSeq_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="GetImage.SlideSeq_+3A_mode">mode</code></td>
<td>
<p>How to return the image; should accept one of &ldquo;grob&rdquo;,
&ldquo;raster&rdquo;, &ldquo;plotly&rdquo;, or &ldquo;raw&rdquo;</p>
</td></tr>
<tr><td><code id="GetImage.SlideSeq_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+GetImage">SeuratObject::GetImage</a></code>
</p>

<hr>
<h2 id='GetIntegrationData'>Get integration data</h2><span id='topic+GetIntegrationData'></span>

<h3>Description</h3>

<p>Get integration data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetIntegrationData(object, integration.name, slot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetIntegrationData_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="GetIntegrationData_+3A_integration.name">integration.name</code></td>
<td>
<p>Name of integration object</p>
</td></tr>
<tr><td><code id="GetIntegrationData_+3A_slot">slot</code></td>
<td>
<p>Which slot in integration object to get</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data from the requested slot within the integrated object
</p>

<hr>
<h2 id='GetResidual'>Calculate pearson residuals of features not in the scale.data</h2><span id='topic+GetResidual'></span>

<h3>Description</h3>

<p>This function calls sctransform::get_residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetResidual(
  object,
  features,
  assay = NULL,
  umi.assay = "RNA",
  clip.range = NULL,
  replace.value = FALSE,
  na.rm = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetResidual_+3A_object">object</code></td>
<td>
<p>A seurat object</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_features">features</code></td>
<td>
<p>Name of features to add into the scale.data</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_assay">assay</code></td>
<td>
<p>Name of the assay of the seurat object generated by SCTransform</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_umi.assay">umi.assay</code></td>
<td>
<p>Name of the assay of the seurat object containing UMI matrix
and the default is RNA</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_clip.range">clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the
Pearson residual will be clipped to</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_replace.value">replace.value</code></td>
<td>
<p>Recalculate residuals for all features, even if they are
already present. Useful if you want to change the clip.range.</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_na.rm">na.rm</code></td>
<td>
<p>For features where there is no feature model stored, return NA
for residual value in scale.data when na.rm = FALSE. When na.rm is TRUE, only
return residuals for features with a model stored for all cells.</p>
</td></tr>
<tr><td><code id="GetResidual_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages and progress bars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object containing Pearson residuals of added
features in its scale.data
</p>


<h3>See Also</h3>

<p><code><a href="sctransform.html#topic+get_residuals">get_residuals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small &lt;- SCTransform(object = pbmc_small, variable.features.n = 20)
pbmc_small &lt;- GetResidual(object = pbmc_small, features = c('MS4A1', 'TCL1A'))

## End(Not run)

</code></pre>

<hr>
<h2 id='GetTissueCoordinates.SlideSeq'>Get Tissue Coordinates</h2><span id='topic+GetTissueCoordinates.SlideSeq'></span><span id='topic+GetTissueCoordinates.STARmap'></span><span id='topic+GetTissueCoordinates.VisiumV1'></span>

<h3>Description</h3>

<p>Get Tissue Coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SlideSeq'
GetTissueCoordinates(object, ...)

## S3 method for class 'STARmap'
GetTissueCoordinates(object, qhulls = FALSE, ...)

## S3 method for class 'VisiumV1'
GetTissueCoordinates(
  object,
  scale = "lowres",
  cols = c("imagerow", "imagecol"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTissueCoordinates.SlideSeq_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="GetTissueCoordinates.SlideSeq_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="GetTissueCoordinates.SlideSeq_+3A_qhulls">qhulls</code></td>
<td>
<p>return qhulls instead of centroids</p>
</td></tr>
<tr><td><code id="GetTissueCoordinates.SlideSeq_+3A_scale">scale</code></td>
<td>
<p>A factor to scale the coordinates by; choose from: 'tissue',
'fiducial', 'hires', 'lowres', or <code>NULL</code> for no scaling</p>
</td></tr>
<tr><td><code id="GetTissueCoordinates.SlideSeq_+3A_cols">cols</code></td>
<td>
<p>Columns of tissue coordinates data.frame to pull</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+GetTissueCoordinates">SeuratObject::GetTissueCoordinates</a></code>
</p>

<hr>
<h2 id='GetTransferPredictions'>Get the predicted identity</h2><span id='topic+GetTransferPredictions'></span>

<h3>Description</h3>

<p>Utility function to easily pull out the name of the class with the maximum
prediction. This is useful if you've set <code>prediction.assay = TRUE</code> in
<code><a href="#topic+TransferData">TransferData</a></code> and want to have a vector with the predicted class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTransferPredictions(
  object,
  assay = "predictions",
  slot = "data",
  score.filter = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTransferPredictions_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="GetTransferPredictions_+3A_assay">assay</code></td>
<td>
<p>Name of the assay holding the predictions</p>
</td></tr>
<tr><td><code id="GetTransferPredictions_+3A_slot">slot</code></td>
<td>
<p>Slot of the assay in which the prediction scores are stored</p>
</td></tr>
<tr><td><code id="GetTransferPredictions_+3A_score.filter">score.filter</code></td>
<td>
<p>Return &quot;Unassigned&quot; for any cell with a score less than
this value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of predicted class names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  prediction.assay &lt;- TransferData(anchorset = anchors, refdata = reference$class)
  query[["predictions"]] &lt;- prediction.assay
  query$predicted.id &lt;- GetTransferPredictions(query)

## End(Not run)
</code></pre>

<hr>
<h2 id='Graph-class'>The Graph Class</h2><span id='topic+Graph-class'></span>

<h3>Description</h3>

<p>For more details, please see the documentation in
<code><a href="SeuratObject.html#topic+Graph">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+Graph">SeuratObject::Graph-class</a></code>
</p>

<hr>
<h2 id='GroupCorrelation'>Compute the correlation of features broken down by groups with another
covariate</h2><span id='topic+GroupCorrelation'></span>

<h3>Description</h3>

<p>Compute the correlation of features broken down by groups with another
covariate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupCorrelation(
  object,
  assay = NULL,
  slot = "scale.data",
  var = NULL,
  group.assay = NULL,
  min.cells = 5,
  ngroups = 6,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GroupCorrelation_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_assay">assay</code></td>
<td>
<p>Assay to pull the data from</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_slot">slot</code></td>
<td>
<p>Slot in the assay to pull feature expression data from (counts,
data, or scale.data)</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_var">var</code></td>
<td>
<p>Variable with which to correlate the features</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_group.assay">group.assay</code></td>
<td>
<p>Compute the gene groups based off the data in this assay.</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_min.cells">min.cells</code></td>
<td>
<p>Only compute for genes in at least this many cells</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_ngroups">ngroups</code></td>
<td>
<p>Number of groups to split into</p>
</td></tr>
<tr><td><code id="GroupCorrelation_+3A_do.plot">do.plot</code></td>
<td>
<p>Display the group correlation boxplot (via
<code>GroupCorrelationPlot</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with the correlation stored in metafeatures
</p>

<hr>
<h2 id='GroupCorrelationPlot'>Boxplot of correlation of a variable (e.g. number of UMIs) with expression
data</h2><span id='topic+GroupCorrelationPlot'></span>

<h3>Description</h3>

<p>Boxplot of correlation of a variable (e.g. number of UMIs) with expression
data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupCorrelationPlot(
  object,
  assay = NULL,
  feature.group = "feature.grp",
  cor = "nCount_RNA_cor"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GroupCorrelationPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="GroupCorrelationPlot_+3A_assay">assay</code></td>
<td>
<p>Assay where the feature grouping info and correlations are
stored</p>
</td></tr>
<tr><td><code id="GroupCorrelationPlot_+3A_feature.group">feature.group</code></td>
<td>
<p>Name of the column in meta.features where the feature
grouping info is stored</p>
</td></tr>
<tr><td><code id="GroupCorrelationPlot_+3A_cor">cor</code></td>
<td>
<p>Name of the column in meta.features where correlation info is
stored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot boxplot of correlations split by group
</p>

<hr>
<h2 id='HarmonyIntegration'>Harmony Integration</h2><span id='topic+HarmonyIntegration'></span>

<h3>Description</h3>

<p>Harmony Integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HarmonyIntegration(
  object,
  orig,
  features = NULL,
  scale.layer = "scale.data",
  new.reduction = "harmony",
  layers = NULL,
  npcs = 50L,
  key = "harmony_",
  theta = NULL,
  lambda = NULL,
  sigma = 0.1,
  nclust = NULL,
  tau = 0,
  block.size = 0.05,
  max.iter.harmony = 10L,
  max.iter.cluster = 20L,
  epsilon.cluster = 1e-05,
  epsilon.harmony = 1e-04,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HarmonyIntegration_+3A_object">object</code></td>
<td>
<p>An <code><a href="SeuratObject.html#topic+Assay5">Assay5</a></code> object</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_orig">orig</code></td>
<td>
<p>A <a href="SeuratObject.html#topic+DimReduc">dimensional reduction</a> to correct</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_features">features</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_scale.layer">scale.layer</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_new.reduction">new.reduction</code></td>
<td>
<p>Name of new integrated dimensional reduction</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_layers">layers</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_npcs">npcs</code></td>
<td>
<p>If doing PCA on input matrix, number of PCs to compute</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_key">key</code></td>
<td>
<p>Key for Harmony dimensional reduction</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_theta">theta</code></td>
<td>
<p>Diversity clustering penalty parameter</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_lambda">lambda</code></td>
<td>
<p>Ridge regression penalty parameter</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_sigma">sigma</code></td>
<td>
<p>Width of soft kmeans clusters</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_nclust">nclust</code></td>
<td>
<p>Number of clusters in model</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_tau">tau</code></td>
<td>
<p>Protection against overclustering small datasets with large ones</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_block.size">block.size</code></td>
<td>
<p>What proportion of cells to update during clustering</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_max.iter.harmony">max.iter.harmony</code></td>
<td>
<p>Maximum number of rounds to run Harmony</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_max.iter.cluster">max.iter.cluster</code></td>
<td>
<p>Maximum number of rounds to run clustering at each round of Harmony</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_epsilon.cluster">epsilon.cluster</code></td>
<td>
<p>Convergence tolerance for clustering round of Harmony</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_epsilon.harmony">epsilon.harmony</code></td>
<td>
<p>Convergence tolerance for Harmony</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress messages. TRUE to print, FALSE to suppress</p>
</td></tr>
<tr><td><code id="HarmonyIntegration_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>


<h3>Note</h3>

<p>This function requires the
<a href="https://cran.r-project.org/package=harmony"><span class="pkg">harmony</span></a> package
to be installed
</p>


<h3>See Also</h3>

<p><code><a href="harmony.html#topic+HarmonyMatrix">harmony::HarmonyMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Preprocessing
obj &lt;- SeuratData::LoadData("pbmcsca")
obj[["RNA"]] &lt;- split(obj[["RNA"]], f = obj$Method)
obj &lt;- NormalizeData(obj)
obj &lt;- FindVariableFeatures(obj)
obj &lt;- ScaleData(obj)
obj &lt;- RunPCA(obj)

# After preprocessing, we integrate layers with added parameters specific to Harmony:
obj &lt;- IntegrateLayers(object = obj, method = HarmonyIntegration, orig.reduction = "pca",
  new.reduction = 'harmony', verbose = FALSE)

# Modifying Parameters
# We can also add arguments specific to Harmony such as theta, to give more diverse clusters
obj &lt;- IntegrateLayers(object = obj, method = HarmonyIntegration, orig.reduction = "pca",
  new.reduction = 'harmony', verbose = FALSE, theta = 3)
# Integrating SCTransformed data
obj &lt;- SCTransform(object = obj)
obj &lt;- IntegrateLayers(object = obj, method = HarmonyIntegration,
  orig.reduction = "pca", new.reduction = 'harmony',
  assay = "SCT", verbose = FALSE)

## End(Not run)


</code></pre>

<hr>
<h2 id='HoverLocator'>Hover Locator</h2><span id='topic+HoverLocator'></span>

<h3>Description</h3>

<p>Get quick information from a scatterplot by hovering over points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HoverLocator(plot, information = NULL, axes = TRUE, dark.theme = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HoverLocator_+3A_plot">plot</code></td>
<td>
<p>A ggplot2 plot</p>
</td></tr>
<tr><td><code id="HoverLocator_+3A_information">information</code></td>
<td>
<p>An optional dataframe or matrix of extra information to be displayed on hover</p>
</td></tr>
<tr><td><code id="HoverLocator_+3A_axes">axes</code></td>
<td>
<p>Display or hide x- and y-axes</p>
</td></tr>
<tr><td><code id="HoverLocator_+3A_dark.theme">dark.theme</code></td>
<td>
<p>Plot using a dark theme?</p>
</td></tr>
<tr><td><code id="HoverLocator_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to <code><a href="plotly.html#topic+layout">layout</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="plotly.html#topic+layout">layout</a></code> <code><a href="ggplot2.html#topic+ggplot_build">ggplot_build</a></code>
<code><a href="#topic+DimPlot">DimPlot</a></code> <code><a href="#topic+FeaturePlot">FeaturePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
plot &lt;- DimPlot(object = pbmc_small)
HoverLocator(plot = plot, information = FetchData(object = pbmc_small, vars = 'percent.mito'))

## End(Not run)

</code></pre>

<hr>
<h2 id='HTODemux'>Demultiplex samples based on data from cell 'hashing'</h2><span id='topic+HTODemux'></span>

<h3>Description</h3>

<p>Assign sample-of-origin for each cell, annotate doublets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTODemux(
  object,
  assay = "HTO",
  positive.quantile = 0.99,
  init = NULL,
  nstarts = 100,
  kfunc = "clara",
  nsamples = 100,
  seed = 42,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTODemux_+3A_object">object</code></td>
<td>
<p>Seurat object. Assumes that the hash tag oligo (HTO) data has been added and normalized.</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_assay">assay</code></td>
<td>
<p>Name of the Hashtag assay (HTO by default)</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_positive.quantile">positive.quantile</code></td>
<td>
<p>The quantile of inferred 'negative' distribution for each hashtag - over which the cell is considered 'positive'. Default is 0.99</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_init">init</code></td>
<td>
<p>Initial number of clusters for hashtags. Default is the # of hashtag oligo names + 1 (to account for negatives)</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_nstarts">nstarts</code></td>
<td>
<p>nstarts value for k-means clustering (for kfunc = &quot;kmeans&quot;). 100 by default</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_kfunc">kfunc</code></td>
<td>
<p>Clustering function for initial hashtag grouping. Default is &quot;clara&quot; for fast k-medoids clustering on large applications, also support &quot;kmeans&quot; for kmeans clustering</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of samples to be drawn from the dataset used for clustering, for kfunc = &quot;clara&quot;</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_seed">seed</code></td>
<td>
<p>Sets the random seed. If NULL, seed is not set</p>
</td></tr>
<tr><td><code id="HTODemux_+3A_verbose">verbose</code></td>
<td>
<p>Prints the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Seurat object with the following demultiplexed information stored in the meta data:
</p>

<dl>
<dt>hash.maxID</dt><dd><p>Name of hashtag with the highest signal</p>
</dd>
<dt>hash.secondID</dt><dd><p>Name of hashtag with the second highest signal</p>
</dd>
<dt>hash.margin</dt><dd><p>The difference between signals for hash.maxID and hash.secondID</p>
</dd>
<dt>classification</dt><dd><p>Classification result, with doublets/multiplets named by the top two highest hashtags</p>
</dd>
<dt>classification.global</dt><dd><p>Global classification result (singlet, doublet or negative)</p>
</dd>
<dt>hash.ID</dt><dd><p>Classification result where doublet IDs are collapsed</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+HTOHeatmap">HTOHeatmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
object &lt;- HTODemux(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='HTOHeatmap'>Hashtag oligo heatmap</h2><span id='topic+HTOHeatmap'></span>

<h3>Description</h3>

<p>Draws a heatmap of hashtag oligo signals across singlets/doublets/negative cells. Allows for the visualization of HTO demultiplexing results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTOHeatmap(
  object,
  assay = "HTO",
  classification = paste0(assay, "_classification"),
  global.classification = paste0(assay, "_classification.global"),
  ncells = 5000,
  singlet.names = NULL,
  raster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTOHeatmap_+3A_object">object</code></td>
<td>
<p>Seurat object. Assumes that the hash tag oligo (HTO) data has been added and normalized, and demultiplexing has been run with HTODemux().</p>
</td></tr>
<tr><td><code id="HTOHeatmap_+3A_assay">assay</code></td>
<td>
<p>Hashtag assay name.</p>
</td></tr>
<tr><td><code id="HTOHeatmap_+3A_classification">classification</code></td>
<td>
<p>The naming for metadata column with classification result from HTODemux().</p>
</td></tr>
<tr><td><code id="HTOHeatmap_+3A_global.classification">global.classification</code></td>
<td>
<p>The slot for metadata column specifying a cell as singlet/doublet/negative.</p>
</td></tr>
<tr><td><code id="HTOHeatmap_+3A_ncells">ncells</code></td>
<td>
<p>Number of cells to plot. Default is to choose 5000 cells by random subsampling, to avoid having to draw exceptionally large heatmaps.</p>
</td></tr>
<tr><td><code id="HTOHeatmap_+3A_singlet.names">singlet.names</code></td>
<td>
<p>Namings for the singlets. Default is to use the same names as HTOs.</p>
</td></tr>
<tr><td><code id="HTOHeatmap_+3A_raster">raster</code></td>
<td>
<p>If true, plot with geom_raster, else use geom_tile. geom_raster may look blurry on
some viewing applications such as Preview due to how the raster is interpolated. Set this to FALSE
if you are encountering that issue (note that plots may take longer to produce/render).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HTODemux">HTODemux</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
object &lt;- HTODemux(object)
HTOHeatmap(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='HVFInfo.SCTAssay'>Get Variable Feature Information</h2><span id='topic+HVFInfo.SCTAssay'></span>

<h3>Description</h3>

<p>Get variable feature information from <code><a href="#topic+SCTAssay">SCTAssay</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCTAssay'
HVFInfo(object, method, status = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HVFInfo.SCTAssay_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="HVFInfo.SCTAssay_+3A_method">method</code></td>
<td>
<p>method to determine variable features</p>
</td></tr>
<tr><td><code id="HVFInfo.SCTAssay_+3A_status">status</code></td>
<td>
<p>Add variable status to the resulting data frame</p>
</td></tr>
<tr><td><code id="HVFInfo.SCTAssay_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+HVFInfo">HVFInfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get the HVF info directly from an SCTAssay object
pbmc_small &lt;- SCTransform(pbmc_small)
HVFInfo(pbmc_small[["SCT"]], method = 'sct')[1:5, ]

## End(Not run)

</code></pre>

<hr>
<h2 id='IFeaturePlot'>Visualize features in dimensional reduction space interactively</h2><span id='topic+IFeaturePlot'></span>

<h3>Description</h3>

<p>Visualize features in dimensional reduction space interactively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IFeaturePlot(object, feature, dims = c(1, 2), reduction = NULL, slot = "data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IFeaturePlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="IFeaturePlot_+3A_feature">feature</code></td>
<td>
<p>Feature to plot</p>
</td></tr>
<tr><td><code id="IFeaturePlot_+3A_dims">dims</code></td>
<td>
<p>Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions</p>
</td></tr>
<tr><td><code id="IFeaturePlot_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca</p>
</td></tr>
<tr><td><code id="IFeaturePlot_+3A_slot">slot</code></td>
<td>
<p>Which slot to pull expression data from?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the final plot as a ggplot object
</p>

<hr>
<h2 id='ImageDimPlot'>Spatial Cluster Plots</h2><span id='topic+ImageDimPlot'></span>

<h3>Description</h3>

<p>Visualize clusters or other categorical groupings in a spatial context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImageDimPlot(
  object,
  fov = NULL,
  boundaries = NULL,
  group.by = NULL,
  split.by = NULL,
  cols = NULL,
  shuffle.cols = FALSE,
  size = 0.5,
  molecules = NULL,
  mols.size = 0.1,
  mols.cols = NULL,
  mols.alpha = 1,
  nmols = 1000,
  alpha = 1,
  border.color = "white",
  border.size = NULL,
  na.value = "grey50",
  dark.background = TRUE,
  crop = FALSE,
  cells = NULL,
  overlap = FALSE,
  axes = FALSE,
  combine = TRUE,
  coord.fixed = TRUE,
  flip_xy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImageDimPlot_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_fov">fov</code></td>
<td>
<p>Name of FOV to plot</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_boundaries">boundaries</code></td>
<td>
<p>A vector of segmentation boundaries per image to plot;
can be a character vector, a named character vector, or a named list.
Names should be the names of FOVs and values should be the names of
segmentation boundaries</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of one or more metadata columns to group (color) cells by
(for example, orig.ident); pass 'ident' to group by identity class</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_cols">cols</code></td>
<td>
<p>Vector of colors, each color corresponds to an identity class. This may also be a single character
or numeric value corresponding to a palette as specified by <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>.
By default, ggplot2 assigns colors. We also include a number of palettes from the pals package.
See <code><a href="#topic+DiscretePalette">DiscretePalette</a></code> for details.</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_shuffle.cols">shuffle.cols</code></td>
<td>
<p>Randomly shuffle colors when a palette or
vector of colors is provided to <code>cols</code></p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_size">size</code></td>
<td>
<p>Point size for cells when plotting centroids</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_molecules">molecules</code></td>
<td>
<p>A vector of molecules to plot</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_mols.size">mols.size</code></td>
<td>
<p>Point size for molecules</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_mols.cols">mols.cols</code></td>
<td>
<p>A vector of color for molecules. The &quot;Set1&quot; palette from
RColorBrewer is used by default.</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_mols.alpha">mols.alpha</code></td>
<td>
<p>Alpha value for molecules, should be between 0 and 1</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_nmols">nmols</code></td>
<td>
<p>Max number of each molecule specified in 'molecules' to plot</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for plotting (default is 1)</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_border.color">border.color</code></td>
<td>
<p>Color of cell segmentation border; pass <code>NA</code>
to suppress borders for segmentation-based plots</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_border.size">border.size</code></td>
<td>
<p>Thickness of cell segmentation borders; pass <code>NA</code>
to suppress borders for centroid-based plots</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_na.value">na.value</code></td>
<td>
<p>Color value for NA points when using custom scale</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_dark.background">dark.background</code></td>
<td>
<p>Set plot background to black</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_crop">crop</code></td>
<td>
<p>Crop the plots to area with cells only</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to plot (default is all cells)</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_overlap">overlap</code></td>
<td>
<p>Overlay boundaries from a single image to create a single
plot; if <code>TRUE</code>, then boundaries are stacked in the order they're
given (first is lowest)</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_axes">axes</code></td>
<td>
<p>Keep axes and panel background</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single
<code>patchwork</code> ggplot object.If <code>FALSE</code>,
return a list of ggplot objects</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_coord.fixed">coord.fixed</code></td>
<td>
<p>Plot cartesian coordinates with fixed aspect ratio</p>
</td></tr>
<tr><td><code id="ImageDimPlot_+3A_flip_xy">flip_xy</code></td>
<td>
<p>Flag to flip X and Y axes. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>combine = TRUE</code>, a <code>patchwork</code>
ggplot object; otherwise, a list of ggplot objects
</p>

<hr>
<h2 id='ImageFeaturePlot'>Spatial Feature Plots</h2><span id='topic+ImageFeaturePlot'></span>

<h3>Description</h3>

<p>Visualize expression in a spatial context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImageFeaturePlot(
  object,
  features,
  fov = NULL,
  boundaries = NULL,
  cols = if (isTRUE(x = blend)) {
     c("lightgrey", "#ff0000", "#00ff00")
 } else {
   
     c("lightgrey", "firebrick1")
 },
  size = 0.5,
  min.cutoff = NA,
  max.cutoff = NA,
  split.by = NULL,
  molecules = NULL,
  mols.size = 0.1,
  mols.cols = NULL,
  nmols = 1000,
  alpha = 1,
  border.color = "white",
  border.size = NULL,
  dark.background = TRUE,
  blend = FALSE,
  blend.threshold = 0.5,
  crop = FALSE,
  cells = NULL,
  scale = c("feature", "all", "none"),
  overlap = FALSE,
  axes = FALSE,
  combine = TRUE,
  coord.fixed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImageFeaturePlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_features">features</code></td>
<td>
<p>Vector of features to plot. Features can come from:
</p>

<ul>
<li><p> An <code>Assay</code> feature (e.g. a gene name - &quot;MS4A1&quot;)
</p>
</li>
<li><p> A column name from meta.data (e.g. mitochondrial percentage -
&quot;percent.mito&quot;)
</p>
</li>
<li><p> A column name from a <code>DimReduc</code> object corresponding to the
cell embedding values (e.g. the PC 1 scores - &quot;PC_1&quot;)
</p>
</li></ul>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_fov">fov</code></td>
<td>
<p>Name of FOV to plot</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_boundaries">boundaries</code></td>
<td>
<p>A vector of segmentation boundaries per image to plot;
can be a character vector, a named character vector, or a named list.
Names should be the names of FOVs and values should be the names of
segmentation boundaries</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_cols">cols</code></td>
<td>
<p>The two colors to form the gradient over. Provide as string vector with
the first color corresponding to low values, the second to high. Also accepts a Brewer
color scale or vector of colors. Note: this will bin the data into number of colors provided.
When blend is <code>TRUE</code>, takes anywhere from 1-3 colors:
</p>

<dl>
<dt>1 color:</dt><dd><p>Treated as color for double-negatives, will use default colors 2 and 3 for per-feature expression</p>
</dd>
<dt>2 colors:</dt><dd><p>Treated as colors for per-feature expression, will use default color 1 for double-negatives</p>
</dd>
<dt>3+ colors:</dt><dd><p>First color used for double-negatives, colors 2 and 3 used for per-feature expression, all others ignored</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_size">size</code></td>
<td>
<p>Point size for cells when plotting centroids</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_min.cutoff">min.cutoff</code>, <code id="ImageFeaturePlot_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Vector of minimum and maximum cutoff values for each feature,
may specify quantile in the form of 'q##' where '##' is the quantile (eg, 'q1', 'q10')</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_molecules">molecules</code></td>
<td>
<p>A vector of molecules to plot</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_mols.size">mols.size</code></td>
<td>
<p>Point size for molecules</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_mols.cols">mols.cols</code></td>
<td>
<p>A vector of color for molecules. The &quot;Set1&quot; palette from
RColorBrewer is used by default.</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_nmols">nmols</code></td>
<td>
<p>Max number of each molecule specified in 'molecules' to plot</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for plotting (default is 1)</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_border.color">border.color</code></td>
<td>
<p>Color of cell segmentation border; pass <code>NA</code>
to suppress borders for segmentation-based plots</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_border.size">border.size</code></td>
<td>
<p>Thickness of cell segmentation borders; pass <code>NA</code>
to suppress borders for centroid-based plots</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_dark.background">dark.background</code></td>
<td>
<p>Set plot background to black</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_blend">blend</code></td>
<td>
<p>Scale and blend expression values to visualize coexpression of two features</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_blend.threshold">blend.threshold</code></td>
<td>
<p>The color cutoff from weak signal to strong signal; ranges from 0 to 1.</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_crop">crop</code></td>
<td>
<p>Crop the plots to area with cells only</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to plot (default is all cells)</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_scale">scale</code></td>
<td>
<p>Set color scaling across multiple plots; choose from:
</p>

<ul>
<li> <p>&ldquo;<code>feature</code>&rdquo;: Plots per-feature are scaled across splits
</p>
</li>
<li> <p>&ldquo;<code>all</code>&rdquo;: Plots per-feature are scaled across all features
</p>
</li>
<li> <p>&ldquo;<code>none</code>&rdquo;: Plots are not scaled; <strong>note</strong>: setting
<code>scale</code> to &ldquo;<code>none</code>&rdquo; will result in color scales that are
<em>not</em> comparable between plots
</p>
</li></ul>

<p>Ignored if <code>blend = TRUE</code></p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_overlap">overlap</code></td>
<td>
<p>Overlay boundaries from a single image to create a single
plot; if <code>TRUE</code>, then boundaries are stacked in the order they're
given (first is lowest)</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_axes">axes</code></td>
<td>
<p>Keep axes and panel background</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</td></tr>
<tr><td><code id="ImageFeaturePlot_+3A_coord.fixed">coord.fixed</code></td>
<td>
<p>Plot cartesian coordinates with fixed aspect ratio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>combine = TRUE</code>, a <code>patchwork</code>
ggplot object; otherwise, a list of ggplot objects
</p>

<hr>
<h2 id='IntegrateData'>Integrate data</h2><span id='topic+IntegrateData'></span>

<h3>Description</h3>

<p>Perform dataset integration using a pre-computed <code><a href="#topic+AnchorSet">AnchorSet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntegrateData(
  anchorset,
  new.assay.name = "integrated",
  normalization.method = c("LogNormalize", "SCT"),
  features = NULL,
  features.to.integrate = NULL,
  dims = 1:30,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  eps = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntegrateData_+3A_anchorset">anchorset</code></td>
<td>
<p>An <code><a href="#topic+AnchorSet">AnchorSet</a></code> object generated by
<code><a href="#topic+FindIntegrationAnchors">FindIntegrationAnchors</a></code></p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_new.assay.name">new.assay.name</code></td>
<td>
<p>Name for the new assay containing the integrated data</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_features">features</code></td>
<td>
<p>Vector of features to use when computing the PCA to determine
the weights. Only set if you want a different set from those used in the
anchor finding process</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_features.to.integrate">features.to.integrate</code></td>
<td>
<p>Vector of features to integrate. By default,
will use the features used in anchor finding.</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_dims">dims</code></td>
<td>
<p>Number of dimensions to use in the anchor weighting procedure</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_weight.reduction">weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li><p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li><p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li><p>A vector of <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li><p>NULL, in which case a new PCA will be calculated and used to
calculate anchor weights
</p>
</li></ul>

<p>Note that, if specified, the requested dimension reduction will only be used
for calculating anchor weights in the first merge between reference and
query, as the merged object will subsequently contain more cells than was in
query, and weights will need to be calculated for all cells in the object.</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_sd.weight">sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_sample.tree">sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code><a href="stats.html#topic+hclust">hclust</a></code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_preserve.order">preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_eps">eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from
<code><a href="RANN.html#topic+RANN">RANN</a></code>)</p>
</td></tr>
<tr><td><code id="IntegrateData_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>
<p>For pairwise integration:
</p>

<ul>
<li><p>Construct a weights matrix that defines the association between each
query cell and each anchor. These weights are computed as 1 - the distance
between the query cell and the anchor divided by the distance of the query
cell to the <code>k.weight</code>th anchor multiplied by the anchor score
computed in <code><a href="#topic+FindIntegrationAnchors">FindIntegrationAnchors</a></code>. We then apply a Gaussian
kernel width a bandwidth defined by <code>sd.weight</code> and normalize across
all <code>k.weight</code> anchors.
</p>
</li>
<li><p>Compute the anchor integration matrix as the difference between the
two expression matrices for every pair of anchor cells
</p>
</li>
<li><p>Compute the transformation matrix as the product of the integration
matrix and the weights matrix.
</p>
</li>
<li><p>Subtract the transformation matrix from the original expression
matrix.
</p>
</li></ul>

<p>For multiple dataset integration, we perform iterative pairwise integration.
To determine the order of integration (if not specified via
<code>sample.tree</code>), we
</p>

<ul>
<li><p>Define a distance between datasets as the total number of cells in
the smaller dataset divided by the total number of anchors between the two
datasets.
</p>
</li>
<li><p>Compute all pairwise distances between datasets
</p>
</li>
<li><p>Cluster this distance matrix to determine a guide tree
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code><a href="#topic+Seurat">Seurat</a></code> object with a new integrated
<code><a href="nlme.html#topic+Assay">Assay</a></code>. If <code>normalization.method = "LogNormalize"</code>, the
integrated data is returned to the <code>data</code> slot and can be treated as
log-normalized, corrected data. If <code>normalization.method = "SCT"</code>, the
integrated data is returned to the <code>scale.data</code> slot and can be treated
as centered, corrected Pearson residuals.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("panc8")

# panc8 is a merged Seurat object containing 8 separate pancreas datasets
# split the object by dataset
pancreas.list &lt;- SplitObject(panc8, split.by = "tech")

# perform standard preprocessing on each object
for (i in 1:length(pancreas.list)) {
  pancreas.list[[i]] &lt;- NormalizeData(pancreas.list[[i]], verbose = FALSE)
  pancreas.list[[i]] &lt;- FindVariableFeatures(
    pancreas.list[[i]], selection.method = "vst",
    nfeatures = 2000, verbose = FALSE
  )
}

# find anchors
anchors &lt;- FindIntegrationAnchors(object.list = pancreas.list)

# integrate data
integrated &lt;- IntegrateData(anchorset = anchors)

## End(Not run)

</code></pre>

<hr>
<h2 id='IntegrateEmbeddings'>Integrate low dimensional embeddings</h2><span id='topic+IntegrateEmbeddings'></span><span id='topic+IntegrateEmbeddings.IntegrationAnchorSet'></span><span id='topic+IntegrateEmbeddings.TransferAnchorSet'></span>

<h3>Description</h3>

<p>Perform dataset integration using a pre-computed Anchorset of specified low
dimensional representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntegrateEmbeddings(anchorset, ...)

## S3 method for class 'IntegrationAnchorSet'
IntegrateEmbeddings(
  anchorset,
  new.reduction.name = "integrated_dr",
  reductions = NULL,
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'TransferAnchorSet'
IntegrateEmbeddings(
  anchorset,
  reference,
  query,
  query.assay = NULL,
  new.reduction.name = "integrated_dr",
  reductions = "pcaproject",
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  reuse.weights.matrix = TRUE,
  sd.weight = 1,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntegrateEmbeddings_+3A_anchorset">anchorset</code></td>
<td>
<p>An AnchorSet object</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_...">...</code></td>
<td>
<p>Reserved for internal use</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_new.reduction.name">new.reduction.name</code></td>
<td>
<p>Name for new integrated dimensional reduction.</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_reductions">reductions</code></td>
<td>
<p>Name of reductions to be integrated. For a
TransferAnchorSet, this should be the name of a reduction present in the
anchorset object (for example, &quot;pcaproject&quot;). For an IntegrationAnchorSet,
this should be a <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> object containing all cells present
in the anchorset object.</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_dims.to.integrate">dims.to.integrate</code></td>
<td>
<p>Number of dimensions to return integrated values for</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_weight.reduction">weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li><p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li><p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li><p>A vector of <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li><p>NULL, in which case the full corrected space is used for computing
anchor weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_sd.weight">sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_sample.tree">sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code><a href="stats.html#topic+hclust">hclust</a></code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_preserve.order">preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_reference">reference</code></td>
<td>
<p>Reference object used in anchorset construction</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_query">query</code></td>
<td>
<p>Query object used in anchorset construction</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_query.assay">query.assay</code></td>
<td>
<p>Name of the Assay to use from query</p>
</td></tr>
<tr><td><code id="IntegrateEmbeddings_+3A_reuse.weights.matrix">reuse.weights.matrix</code></td>
<td>
<p>Can be used in conjunction with the store.weights
parameter in TransferData to reuse a precomputed weights matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps of this procedure are identical to <code><a href="#topic+IntegrateData">IntegrateData</a></code>
with one key distinction. When computing the weights matrix, the distance
calculations are performed in the full space of integrated embeddings when
integrating more than two datasets, as opposed to a reduced PCA space which
is the default behavior in <code><a href="#topic+IntegrateData">IntegrateData</a></code>.
</p>


<h3>Value</h3>

<p>When called on a TransferAnchorSet (from FindTransferAnchors), this
will return the query object with the integrated embeddings stored in a new
reduction. When called on an IntegrationAnchorSet (from IntegrateData), this
will return a merged object with the integrated reduction stored.
</p>

<hr>
<h2 id='IntegrateLayers'>Integrate Layers</h2><span id='topic+IntegrateLayers'></span>

<h3>Description</h3>

<p>Integrate Layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntegrateLayers(
  object,
  method,
  orig.reduction = "pca",
  assay = NULL,
  features = NULL,
  layers = NULL,
  scale.layer = "scale.data",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntegrateLayers_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_method">method</code></td>
<td>
<p>Integration method function</p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_orig.reduction">orig.reduction</code></td>
<td>
<p>Name of dimensional reduction for correction</p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_assay">assay</code></td>
<td>
<p>Name of assay for integration</p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_features">features</code></td>
<td>
<p>A vector of features to use for integration</p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_layers">layers</code></td>
<td>
<p>Names of normalized layers in <code>assay</code></p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_scale.layer">scale.layer</code></td>
<td>
<p>Name(s) of scaled layer(s) in <code>assay</code></p>
</td></tr>
<tr><td><code id="IntegrateLayers_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>method</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with integration data added to it
</p>


<h3>Integration Method Functions</h3>

<p>The following integration method functions are available:

</p>


<h3>See Also</h3>

<p><a href="#topic+writing-integration">Writing integration method functions</a>
</p>

<hr>
<h2 id='IntegrationAnchorSet-class'>The IntegrationAnchorSet Class</h2><span id='topic+IntegrationAnchorSet-class'></span><span id='topic+IntegrationAnchorSet'></span>

<h3>Description</h3>

<p>Inherits from the Anchorset class. Implemented mainly for method dispatch
purposes.  See <code><a href="#topic+AnchorSet">AnchorSet</a></code> for slot details.
</p>

<hr>
<h2 id='IntegrationData-class'>The IntegrationData Class</h2><span id='topic+IntegrationData-class'></span><span id='topic+IntegrationData'></span>

<h3>Description</h3>

<p>The IntegrationData object is an intermediate storage container used internally throughout the
integration procedure to hold bits of data that are useful downstream.
</p>


<h3>Slots</h3>


<dl>
<dt><code>neighbors</code></dt><dd><p>List of neighborhood information for cells (outputs of <code>RANN::nn2</code>)</p>
</dd>
<dt><code>weights</code></dt><dd><p>Anchor weight matrix</p>
</dd>
<dt><code>integration.matrix</code></dt><dd><p>Integration matrix</p>
</dd>
<dt><code>anchors</code></dt><dd><p>Anchor matrix</p>
</dd>
<dt><code>offsets</code></dt><dd><p>The offsets used to enable cell look up in downstream functions</p>
</dd>
<dt><code>objects.ncell</code></dt><dd><p>Number of cells in each object in the object.list</p>
</dd>
<dt><code>sample.tree</code></dt><dd><p>Sample tree used for ordering multi-dataset integration</p>
</dd>
</dl>

<hr>
<h2 id='ISpatialDimPlot'>Visualize clusters spatially and interactively</h2><span id='topic+ISpatialDimPlot'></span>

<h3>Description</h3>

<p>Visualize clusters spatially and interactively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISpatialDimPlot(object, image = NULL, group.by = NULL, alpha = c(0.3, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ISpatialDimPlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="ISpatialDimPlot_+3A_image">image</code></td>
<td>
<p>Name of the image to use in the plot</p>
</td></tr>
<tr><td><code id="ISpatialDimPlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of meta.data column to group the data by</p>
</td></tr>
<tr><td><code id="ISpatialDimPlot_+3A_alpha">alpha</code></td>
<td>
<p>Controls opacity of spots. Provide as a vector specifying the
min and max for SpatialFeaturePlot. For SpatialDimPlot, provide a single
alpha value for each plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns final plot as a ggplot object
</p>

<hr>
<h2 id='ISpatialFeaturePlot'>Visualize features spatially and interactively</h2><span id='topic+ISpatialFeaturePlot'></span>

<h3>Description</h3>

<p>Visualize features spatially and interactively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISpatialFeaturePlot(
  object,
  feature,
  image = NULL,
  slot = "data",
  alpha = c(0.1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ISpatialFeaturePlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="ISpatialFeaturePlot_+3A_feature">feature</code></td>
<td>
<p>Feature to visualize</p>
</td></tr>
<tr><td><code id="ISpatialFeaturePlot_+3A_image">image</code></td>
<td>
<p>Name of the image to use in the plot</p>
</td></tr>
<tr><td><code id="ISpatialFeaturePlot_+3A_slot">slot</code></td>
<td>
<p>If plotting a feature, which data slot to pull from (counts,
data, or scale.data)</p>
</td></tr>
<tr><td><code id="ISpatialFeaturePlot_+3A_alpha">alpha</code></td>
<td>
<p>Controls opacity of spots. Provide as a vector specifying the
min and max for SpatialFeaturePlot. For SpatialDimPlot, provide a single
alpha value for each plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns final plot as a ggplot object
</p>

<hr>
<h2 id='JackStraw'>Determine statistical significance of PCA scores.</h2><span id='topic+JackStraw'></span>

<h3>Description</h3>

<p>Randomly permutes a subset of data, and calculates projected PCA scores for
these 'random' genes. Then compares the PCA scores for the 'random' genes
with the observed PCA scores to determine statistical signifance. End result
is a p-value for each gene's association with each principal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackStraw(
  object,
  reduction = "pca",
  assay = NULL,
  dims = 20,
  num.replicate = 100,
  prop.freq = 0.01,
  verbose = TRUE,
  maxit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackStraw_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_reduction">reduction</code></td>
<td>
<p>DimReduc to use. ONLY PCA CURRENTLY SUPPORTED.</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_assay">assay</code></td>
<td>
<p>Assay used to calculate reduction.</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_dims">dims</code></td>
<td>
<p>Number of PCs to compute significance for</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_num.replicate">num.replicate</code></td>
<td>
<p>Number of replicate samplings to perform</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_prop.freq">prop.freq</code></td>
<td>
<p>Proportion of the data to randomly permute for each
replicate</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bar showing the number of replicates
that have been processed.</p>
</td></tr>
<tr><td><code id="JackStraw_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations to be performed by the irlba function of RunPCA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object where JS(object = object[['pca']], slot = 'empirical')
represents p-values for each gene in the PCA analysis. If ProjectPCA is
subsequently run, JS(object = object[['pca']], slot = 'full') then
represents p-values for all genes.
</p>


<h3>References</h3>

<p>Inspired by Chung et al, Bioinformatics (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small = suppressWarnings(JackStraw(pbmc_small))
head(JS(object = pbmc_small[['pca']], slot = 'empirical'))

## End(Not run)

</code></pre>

<hr>
<h2 id='JackStrawData-class'>The JackStrawData Class</h2><span id='topic+JackStrawData-class'></span>

<h3>Description</h3>

<p>For more details, please see the documentation in
<code><a href="SeuratObject.html#topic+JackStrawData">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+JackStrawData">SeuratObject::JackStrawData-class</a></code>
</p>

<hr>
<h2 id='JackStrawPlot'>JackStraw Plot</h2><span id='topic+JackStrawPlot'></span>

<h3>Description</h3>

<p>Plots the results of the JackStraw analysis for PCA significance. For each
PC, plots a QQ-plot comparing the distribution of p-values for all genes
across each PC, compared with a uniform distribution. Also determines a
p-value for the overall significance of each PC (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JackStrawPlot(
  object,
  dims = 1:5,
  cols = NULL,
  reduction = "pca",
  xmax = 0.1,
  ymax = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JackStrawPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="JackStrawPlot_+3A_dims">dims</code></td>
<td>
<p>Dims to plot</p>
</td></tr>
<tr><td><code id="JackStrawPlot_+3A_cols">cols</code></td>
<td>
<p>Vector of colors, each color corresponds to an individual PC. This may also be a single character
or numeric value corresponding to a palette as specified by <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>.
By default, ggplot2 assigns colors. We also include a number of palettes from the pals package.
See <code><a href="#topic+DiscretePalette">DiscretePalette</a></code> for details.</p>
</td></tr>
<tr><td><code id="JackStrawPlot_+3A_reduction">reduction</code></td>
<td>
<p>reduction to pull jackstraw info from</p>
</td></tr>
<tr><td><code id="JackStrawPlot_+3A_xmax">xmax</code></td>
<td>
<p>X-axis maximum on each QQ plot.</p>
</td></tr>
<tr><td><code id="JackStrawPlot_+3A_ymax">ymax</code></td>
<td>
<p>Y-axis maximum on each QQ plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Significant PCs should show a p-value distribution (black curve) that is
strongly skewed to the left compared to the null distribution (dashed line)
The p-value for each PC is based on a proportion test comparing the number
of genes with a p-value below a particular threshold (score.thresh), compared with the
proportion of genes expected under a uniform distribution of p-values.
</p>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Author(s)</h3>

<p>Omri Wurtzel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreJackStraw">ScoreJackStraw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
JackStrawPlot(object = pbmc_small)

</code></pre>

<hr>
<h2 id='JointPCAIntegration'>Seurat-Joint PCA Integration</h2><span id='topic+JointPCAIntegration'></span>

<h3>Description</h3>

<p>Seurat-Joint PCA Integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JointPCAIntegration(
  object = NULL,
  assay = NULL,
  layers = NULL,
  orig = NULL,
  new.reduction = "integrated.dr",
  reference = NULL,
  features = NULL,
  normalization.method = c("LogNormalize", "SCT"),
  dims = 1:30,
  k.anchor = 20,
  scale.layer = "scale.data",
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JointPCAIntegration_+3A_object">object</code></td>
<td>
<p>A <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_assay">assay</code></td>
<td>
<p>Name of <code>Assay</code> in the <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_layers">layers</code></td>
<td>
<p>Names of layers in <code>assay</code></p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_orig">orig</code></td>
<td>
<p>A <a href="SeuratObject.html#topic+DimReduc">dimensional reduction</a> to correct</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_new.reduction">new.reduction</code></td>
<td>
<p>Name of new integrated dimensional reduction</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_reference">reference</code></td>
<td>
<p>A reference <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_features">features</code></td>
<td>
<p>A vector of features to use for integration</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_dims">dims</code></td>
<td>
<p>Dimensions of dimensional reduction to use for integration</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_k.anchor">k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_scale.layer">scale.layer</code></td>
<td>
<p>Name of scaled layer in <code>Assay</code></p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_dims.to.integrate">dims.to.integrate</code></td>
<td>
<p>Number of dimensions to return integrated values for</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_weight.reduction">weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li><p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li><p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li><p>A vector of <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li><p>NULL, in which case the full corrected space is used for computing
anchor weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_sd.weight">sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_sample.tree">sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code><a href="stats.html#topic+hclust">hclust</a></code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_preserve.order">preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
<tr><td><code id="JointPCAIntegration_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>FindIntegrationAnchors</code></p>
</td></tr>
</table>

<hr>
<h2 id='L2CCA'>L2-Normalize CCA</h2><span id='topic+L2CCA'></span>

<h3>Description</h3>

<p>Perform l2 normalization on CCs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2CCA(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L2CCA_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="L2CCA_+3A_...">...</code></td>
<td>
<p>Additional parameters to L2Dim.</p>
</td></tr>
</table>

<hr>
<h2 id='L2Dim'>L2-normalization</h2><span id='topic+L2Dim'></span>

<h3>Description</h3>

<p>Perform l2 normalization on given dimensional reduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2Dim(object, reduction, new.dr = NULL, new.key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L2Dim_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="L2Dim_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to normalize</p>
</td></tr>
<tr><td><code id="L2Dim_+3A_new.dr">new.dr</code></td>
<td>
<p>name of new dimensional reduction to store
(default is olddr.l2)</p>
</td></tr>
<tr><td><code id="L2Dim_+3A_new.key">new.key</code></td>
<td>
<p>name of key for new dimensional reduction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+Seurat">Seurat</a></code> object
</p>

<hr>
<h2 id='LabelClusters'>Label clusters on a ggplot2-based scatter plot</h2><span id='topic+LabelClusters'></span>

<h3>Description</h3>

<p>Label clusters on a ggplot2-based scatter plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LabelClusters(
  plot,
  id,
  clusters = NULL,
  labels = NULL,
  split.by = NULL,
  repel = TRUE,
  box = FALSE,
  geom = "GeomPoint",
  position = "median",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LabelClusters_+3A_plot">plot</code></td>
<td>
<p>A ggplot2-based scatter plot</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_id">id</code></td>
<td>
<p>Name of variable used for coloring scatter plot</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_clusters">clusters</code></td>
<td>
<p>Vector of cluster ids to label</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_labels">labels</code></td>
<td>
<p>Custom labels for the clusters</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_split.by">split.by</code></td>
<td>
<p>Split labels by some grouping label, useful when using
<code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> or <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code></p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_repel">repel</code></td>
<td>
<p>Use <code>geom_text_repel</code> to create nicely-repelled labels</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_box">box</code></td>
<td>
<p>Use geom_label/geom_label_repel (includes a box around the text
labels)</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_geom">geom</code></td>
<td>
<p>Name of geom to get X/Y aesthetic names for</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_position">position</code></td>
<td>
<p>How to place the label if repel = FALSE. If &quot;median&quot;, place
the label at the median position. If &quot;nearest&quot; place the label at the
position of the nearest data point to the median.</p>
</td></tr>
<tr><td><code id="LabelClusters_+3A_...">...</code></td>
<td>
<p>Extra parameters to <code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code>, such as <code>size</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2-based scatter plot with cluster labels
</p>


<h3>See Also</h3>

<p><code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code> <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
plot &lt;- DimPlot(object = pbmc_small)
LabelClusters(plot = plot, id = 'ident')

</code></pre>

<hr>
<h2 id='LabelPoints'>Add text labels to a ggplot2 plot</h2><span id='topic+LabelPoints'></span><span id='topic+Labeler'></span>

<h3>Description</h3>

<p>Add text labels to a ggplot2 plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LabelPoints(
  plot,
  points,
  labels = NULL,
  repel = FALSE,
  xnudge = 0.3,
  ynudge = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LabelPoints_+3A_plot">plot</code></td>
<td>
<p>A ggplot2 plot with a GeomPoint layer</p>
</td></tr>
<tr><td><code id="LabelPoints_+3A_points">points</code></td>
<td>
<p>A vector of points to label; if <code>NULL</code>, will use all points in the plot</p>
</td></tr>
<tr><td><code id="LabelPoints_+3A_labels">labels</code></td>
<td>
<p>A vector of labels for the points; if <code>NULL</code>, will use
rownames of the data provided to the plot at the points selected</p>
</td></tr>
<tr><td><code id="LabelPoints_+3A_repel">repel</code></td>
<td>
<p>Use <code>geom_text_repel</code> to create a nicely-repelled labels; this
is slow when a lot of points are being plotted. If using <code>repel</code>, set <code>xnudge</code>
and <code>ynudge</code> to 0</p>
</td></tr>
<tr><td><code id="LabelPoints_+3A_xnudge">xnudge</code>, <code id="LabelPoints_+3A_ynudge">ynudge</code></td>
<td>
<p>Amount to nudge X and Y coordinates of labels by</p>
</td></tr>
<tr><td><code id="LabelPoints_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>geom_text</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
ff &lt;- TopFeatures(object = pbmc_small[['pca']])
cc &lt;- TopCells(object = pbmc_small[['pca']])
plot &lt;- FeatureScatter(object = pbmc_small, feature1 = ff[1], feature2 = ff[2])
LabelPoints(plot = plot, points = cc)

</code></pre>

<hr>
<h2 id='LeverageScore'>Leverage Score Calculation</h2><span id='topic+LeverageScore'></span><span id='topic+LeverageScore.default'></span><span id='topic+LeverageScore.StdAssay'></span><span id='topic+LeverageScore.Assay'></span><span id='topic+LeverageScore.Seurat'></span>

<h3>Description</h3>

<p>This function computes the leverage scores for a given object
It uses the concept of sketching and random projections. The function provides an approximation 
to the leverage scores using a scalable method suitable for large matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LeverageScore(object, ...)

## Default S3 method:
LeverageScore(
  object,
  nsketch = 5000L,
  ndims = NULL,
  method = CountSketch,
  eps = 0.5,
  seed = 123L,
  verbose = TRUE,
  ...
)

## S3 method for class 'StdAssay'
LeverageScore(
  object,
  nsketch = 5000L,
  ndims = NULL,
  method = CountSketch,
  vf.method = NULL,
  layer = "data",
  eps = 0.5,
  seed = 123L,
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
LeverageScore(
  object,
  nsketch = 5000L,
  ndims = NULL,
  method = CountSketch,
  vf.method = NULL,
  layer = "data",
  eps = 0.5,
  seed = 123L,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
LeverageScore(
  object,
  assay = NULL,
  nsketch = 5000L,
  ndims = NULL,
  var.name = "leverage.score",
  over.write = FALSE,
  method = CountSketch,
  vf.method = NULL,
  layer = "data",
  eps = 0.5,
  seed = 123L,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LeverageScore_+3A_object">object</code></td>
<td>
<p>A matrix-like object</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_nsketch">nsketch</code></td>
<td>
<p>A positive integer. The number of sketches to be used in the approximation.
Default is 5000.</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_ndims">ndims</code></td>
<td>
<p>A positive integer or NULL. The number of dimensions to use. If NULL, the number
of dimensions will default to the number of columns in the object.</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_method">method</code></td>
<td>
<p>The sketching method to use, defaults to CountSketch.</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_eps">eps</code></td>
<td>
<p>A numeric. The error tolerance for the approximation in Johnson–Lindenstrauss embeddings,
defaults to 0.5.</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_seed">seed</code></td>
<td>
<p>A positive integer. The seed for the random number generator, defaults to 123.</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and diagnostic messages</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_vf.method">vf.method</code></td>
<td>
<p>VariableFeatures method</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_layer">layer</code></td>
<td>
<p>layer to use</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_assay">assay</code></td>
<td>
<p>assay to use</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_var.name">var.name</code></td>
<td>
<p>name of slot to store leverage scores</p>
</td></tr>
<tr><td><code id="LeverageScore_+3A_over.write">over.write</code></td>
<td>
<p>whether to overwrite slot that currently stores leverage scores. Defaults
to FALSE, in which case the 'var.name' is modified if it already exists in the object</p>
</td></tr>
</table>


<h3>References</h3>

<p>Clarkson, K. L. &amp; Woodruff, D. P.
Low-rank approximation and regression in input sparsity time.
JACM 63, 1–45 (2017). <a href="https://dl.acm.org/doi/10.1145/3019134">https://dl.acm.org/doi/10.1145/3019134</a>;
</p>

<hr>
<h2 id='LinkedPlots'>Visualize spatial and clustering (dimensional reduction) data in a linked,
interactive framework</h2><span id='topic+LinkedPlots'></span><span id='topic+LinkedDimPlot'></span><span id='topic+LinkedPlot'></span><span id='topic+LinkedFeaturePlot'></span>

<h3>Description</h3>

<p>Visualize spatial and clustering (dimensional reduction) data in a linked,
interactive framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinkedDimPlot(
  object,
  dims = 1:2,
  reduction = NULL,
  image = NULL,
  group.by = NULL,
  alpha = c(0.1, 1),
  combine = TRUE
)

LinkedFeaturePlot(
  object,
  feature,
  dims = 1:2,
  reduction = NULL,
  image = NULL,
  slot = "data",
  alpha = c(0.1, 1),
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinkedPlots_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_dims">dims</code></td>
<td>
<p>Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_image">image</code></td>
<td>
<p>Name of the image to use in the plot</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_group.by">group.by</code></td>
<td>
<p>Name of meta.data column to group the data by</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_alpha">alpha</code></td>
<td>
<p>Controls opacity of spots. Provide as a vector specifying the
min and max for SpatialFeaturePlot. For SpatialDimPlot, provide a single
alpha value for each plot.</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single gg object; note that if TRUE;
themeing will not work when plotting multiple features/groupings</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_feature">feature</code></td>
<td>
<p>Feature to visualize</p>
</td></tr>
<tr><td><code id="LinkedPlots_+3A_slot">slot</code></td>
<td>
<p>If plotting a feature, which data slot to pull from (counts,
data, or scale.data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns final plots. If <code>combine</code>, plots are stiched together
using <code><a href="#topic+CombinePlots">CombinePlots</a></code>; otherwise, returns a list of ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LinkedDimPlot(seurat.object)
LinkedFeaturePlot(seurat.object, feature = 'Hpca')

## End(Not run)

</code></pre>

<hr>
<h2 id='Load10X_Spatial'>Load a 10x Genomics Visium Spatial Experiment into a <code>Seurat</code> object</h2><span id='topic+Load10X_Spatial'></span>

<h3>Description</h3>

<p>Load a 10x Genomics Visium Spatial Experiment into a <code>Seurat</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Load10X_Spatial(
  data.dir,
  filename = "filtered_feature_bc_matrix.h5",
  assay = "Spatial",
  slice = "slice1",
  filter.matrix = TRUE,
  to.upper = FALSE,
  image = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Load10X_Spatial_+3A_data.dir">data.dir</code></td>
<td>
<p>Directory containing the H5 file specified by <code>filename</code>
and the image data in a subdirectory called <code>spatial</code></p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_filename">filename</code></td>
<td>
<p>Name of H5 file containing the feature barcode matrix</p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_assay">assay</code></td>
<td>
<p>Name of the initial assay</p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_slice">slice</code></td>
<td>
<p>Name for the stored image of the tissue slice</p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_filter.matrix">filter.matrix</code></td>
<td>
<p>Only keep spots that have been determined to be over
tissue</p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_to.upper">to.upper</code></td>
<td>
<p>Converts all feature names to upper case. Can be useful when
analyses require comparisons between human and mouse gene names for example.</p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_image">image</code></td>
<td>
<p>Name of image to pull the coordinates from</p>
</td></tr>
<tr><td><code id="Load10X_Spatial_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+Read10X_h5">Read10X_h5</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Seurat</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data_dir &lt;- 'path/to/data/directory'
list.files(data_dir) # Should show filtered_feature_bc_matrix.h5
Load10X_Spatial(data.dir = data_dir)

## End(Not run)

</code></pre>

<hr>
<h2 id='LoadAnnoyIndex'>Load the Annoy index file</h2><span id='topic+LoadAnnoyIndex'></span>

<h3>Description</h3>

<p>Load the Annoy index file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadAnnoyIndex(object, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadAnnoyIndex_+3A_object">object</code></td>
<td>
<p>Neighbor object</p>
</td></tr>
<tr><td><code id="LoadAnnoyIndex_+3A_file">file</code></td>
<td>
<p>Path to file with annoy index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the Neighbor object with the index stored
</p>

<hr>
<h2 id='LoadCurioSeeker'>Load Curio Seeker data</h2><span id='topic+LoadCurioSeeker'></span>

<h3>Description</h3>

<p>Load Curio Seeker data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadCurioSeeker(data.dir, assay = "Spatial")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadCurioSeeker_+3A_data.dir">data.dir</code></td>
<td>
<p>location of data directory that contains the counts matrix,
gene names, barcodes/beads, and barcodes/bead location files.</p>
</td></tr>
<tr><td><code id="LoadCurioSeeker_+3A_assay">assay</code></td>
<td>
<p>Name of assay to associate spatial data to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Seurat">Seurat</a></code> object
</p>

<hr>
<h2 id='LoadSTARmap'>Load STARmap data</h2><span id='topic+LoadSTARmap'></span>

<h3>Description</h3>

<p>Load STARmap data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadSTARmap(
  data.dir,
  counts.file = "cell_barcode_count.csv",
  gene.file = "genes.csv",
  qhull.file = "qhulls.tsv",
  centroid.file = "centroids.tsv",
  assay = "Spatial",
  image = "image"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadSTARmap_+3A_data.dir">data.dir</code></td>
<td>
<p>location of data directory that contains the counts matrix,
gene name, qhull, and centroid files.</p>
</td></tr>
<tr><td><code id="LoadSTARmap_+3A_counts.file">counts.file</code></td>
<td>
<p>name of file containing the counts matrix (csv)</p>
</td></tr>
<tr><td><code id="LoadSTARmap_+3A_gene.file">gene.file</code></td>
<td>
<p>name of file containing the gene names (csv)</p>
</td></tr>
<tr><td><code id="LoadSTARmap_+3A_qhull.file">qhull.file</code></td>
<td>
<p>name of file containing the hull coordinates (tsv)</p>
</td></tr>
<tr><td><code id="LoadSTARmap_+3A_centroid.file">centroid.file</code></td>
<td>
<p>name of file containing the centroid positions (tsv)</p>
</td></tr>
<tr><td><code id="LoadSTARmap_+3A_assay">assay</code></td>
<td>
<p>Name of assay to associate spatial data to</p>
</td></tr>
<tr><td><code id="LoadSTARmap_+3A_image">image</code></td>
<td>
<p>Name of &quot;image&quot; object storing spatial coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Seurat">Seurat</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STARmap">STARmap</a></code>
</p>

<hr>
<h2 id='LoadXenium'>Read and Load 10x Genomics Xenium in-situ data</h2><span id='topic+LoadXenium'></span><span id='topic+ReadXenium'></span>

<h3>Description</h3>

<p>Read and Load 10x Genomics Xenium in-situ data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadXenium(data.dir, fov = "fov", assay = "Xenium")

ReadXenium(
  data.dir,
  outs = c("matrix", "microns"),
  type = "centroids",
  mols.qv.threshold = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadXenium_+3A_data.dir">data.dir</code></td>
<td>
<p>Directory containing all Xenium output files with
default filenames</p>
</td></tr>
<tr><td><code id="LoadXenium_+3A_fov">fov</code></td>
<td>
<p>FOV name</p>
</td></tr>
<tr><td><code id="LoadXenium_+3A_assay">assay</code></td>
<td>
<p>Assay name</p>
</td></tr>
<tr><td><code id="LoadXenium_+3A_outs">outs</code></td>
<td>
<p>Types of molecular outputs to read; choose one or more of:
</p>

<ul>
<li> <p>&ldquo;matrix&rdquo;: the counts matrix
</p>
</li>
<li> <p>&ldquo;microns&rdquo;: molecule coordinates
</p>
</li></ul>
</td></tr>
<tr><td><code id="LoadXenium_+3A_type">type</code></td>
<td>
<p>Type of cell spatial coordinate matrices to read; choose one
or more of:
</p>

<ul>
<li> <p>&ldquo;centroids&rdquo;: cell centroids in pixel coordinate space
</p>
</li>
<li> <p>&ldquo;segmentations&rdquo;: cell segmentations in pixel coordinate space
</p>
</li></ul>
</td></tr>
<tr><td><code id="LoadXenium_+3A_mols.qv.threshold">mols.qv.threshold</code></td>
<td>
<p>Remove transcript molecules with
a QV less than this threshold. QV &gt;= 20 is the standard threshold
used to construct the cell x gene count matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>LoadXenium</code>: A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>
<p><code>ReadXenium</code>: A list with some combination of the
following values:
</p>

<ul>
<li> <p>&ldquo;<code>matrix</code>&rdquo;: a
<a href="Matrix.html#topic+dgCMatrix-class">sparse matrix</a> with expression data; cells
are columns and features are rows
</p>
</li>
<li> <p>&ldquo;<code>centroids</code>&rdquo;: a data frame with cell centroid
coordinates in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>pixels</code>&rdquo;: a data frame with molecule pixel coordinates
in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;gene&rdquo;
</p>
</li></ul>


<hr>
<h2 id='LocalStruct'>Calculate the local structure preservation metric</h2><span id='topic+LocalStruct'></span>

<h3>Description</h3>

<p>Calculates a metric that describes how well the local structure of each group
prior to integration is preserved after integration. This procedure works as
follows: For each group, compute a PCA, compute the top num.neighbors in pca
space, compute the top num.neighbors in corrected pca space, compute the
size of the intersection of those two sets of neighbors.
Return the average over all groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalStruct(
  object,
  grouping.var,
  idents = NULL,
  neighbors = 100,
  reduction = "pca",
  reduced.dims = 1:10,
  orig.dims = 1:10,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocalStruct_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_grouping.var">grouping.var</code></td>
<td>
<p>Grouping variable</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_idents">idents</code></td>
<td>
<p>Optionally specify a set of idents to compute metric for</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_neighbors">neighbors</code></td>
<td>
<p>Number of neighbors to compute in pca/corrected pca space</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction to use for corrected space</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_reduced.dims">reduced.dims</code></td>
<td>
<p>Number of reduced dimensions to use</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_orig.dims">orig.dims</code></td>
<td>
<p>Number of PCs to use in original space</p>
</td></tr>
<tr><td><code id="LocalStruct_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the average preservation metric
</p>

<hr>
<h2 id='LogNormalize'>Normalize Raw Data</h2><span id='topic+LogNormalize'></span><span id='topic+LogNormalize.data.frame'></span><span id='topic+LogNormalize.V3Matrix'></span><span id='topic+LogNormalize.default'></span>

<h3>Description</h3>

<p>Normalize Raw Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogNormalize(data, scale.factor = 10000, margin = 2L, verbose = TRUE, ...)

## S3 method for class 'data.frame'
LogNormalize(data, scale.factor = 10000, margin = 2L, verbose = TRUE, ...)

## S3 method for class 'V3Matrix'
LogNormalize(data, scale.factor = 10000, margin = 2L, verbose = TRUE, ...)

## Default S3 method:
LogNormalize(data, scale.factor = 10000, margin = 2L, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogNormalize_+3A_data">data</code></td>
<td>
<p>Matrix with the raw count data</p>
</td></tr>
<tr><td><code id="LogNormalize_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Scale the data; default is <code>1e4</code></p>
</td></tr>
<tr><td><code id="LogNormalize_+3A_margin">margin</code></td>
<td>
<p>Margin to normalize over</p>
</td></tr>
<tr><td><code id="LogNormalize_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
<tr><td><code id="LogNormalize_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the normalized and log-transformed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(data = rbinom(n = 25, size = 5, prob = 0.2), nrow = 5)
mat
mat_norm &lt;- LogNormalize(data = mat)
mat_norm

</code></pre>

<hr>
<h2 id='LogVMR'>Calculate the variance to mean ratio of logged values</h2><span id='topic+LogVMR'></span>

<h3>Description</h3>

<p>Calculate the variance to mean ratio (VMR) in non-logspace (return answer in
log-space)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogVMR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogVMR_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="LogVMR_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the VMR in log-space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LogVMR(x = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='MappingScore'>Metric for evaluating mapping success</h2><span id='topic+MappingScore'></span><span id='topic+MappingScore.default'></span><span id='topic+MappingScore.AnchorSet'></span>

<h3>Description</h3>

<p>This metric was designed to help identify query cells that aren't well
represented in the reference dataset. The intuition for the score is that we
are going to project the query cells into a reference-defined space and then
project them back onto the query. By comparing the neighborhoods before and
after projection, we identify cells who's local neighborhoods are the most
affected by this transformation. This could be because there is a population
of query cells that aren't present in the reference or the state of the cells
in the query is significantly different from the equivalent cell type in the
reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MappingScore(anchors, ...)

## Default S3 method:
MappingScore(
  anchors,
  combined.object,
  query.neighbors,
  ref.embeddings,
  query.embeddings,
  kanchors = 50,
  ndim = 50,
  ksmooth = 100,
  ksnn = 20,
  snn.prune = 0,
  subtract.first.nn = TRUE,
  nn.method = "annoy",
  n.trees = 50,
  query.weights = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'AnchorSet'
MappingScore(
  anchors,
  kanchors = 50,
  ndim = 50,
  ksmooth = 100,
  ksnn = 20,
  snn.prune = 0,
  subtract.first.nn = TRUE,
  nn.method = "annoy",
  n.trees = 50,
  query.weights = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MappingScore_+3A_anchors">anchors</code></td>
<td>
<p>AnchorSet object or just anchor matrix from the
Anchorset object returned from FindTransferAnchors</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_...">...</code></td>
<td>
<p>Reserved for internal use</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_combined.object">combined.object</code></td>
<td>
<p>Combined object (ref + query) from the
Anchorset object returned</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_query.neighbors">query.neighbors</code></td>
<td>
<p>Neighbors object computed on query cells</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_ref.embeddings">ref.embeddings</code></td>
<td>
<p>Reference embeddings matrix</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_query.embeddings">query.embeddings</code></td>
<td>
<p>Query embeddings matrix</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_kanchors">kanchors</code></td>
<td>
<p>Number of anchors to use in projection steps when computing
weights</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_ndim">ndim</code></td>
<td>
<p>Number of dimensions to use when working with low dimensional
projections of the data</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_ksmooth">ksmooth</code></td>
<td>
<p>Number of cells to average over when computing transition
probabilities</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_ksnn">ksnn</code></td>
<td>
<p>Number of cells to average over when determining the kernel
bandwidth from the SNN graph</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_snn.prune">snn.prune</code></td>
<td>
<p>Amount of pruning to apply to edges in SNN graph</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_subtract.first.nn">subtract.first.nn</code></td>
<td>
<p>Option to the scoring function when computing
distances to subtract the distance to the first nearest neighbor</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_nn.method">nn.method</code></td>
<td>
<p>Nearest neighbor method to use (annoy or RANN)</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_n.trees">n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_query.weights">query.weights</code></td>
<td>
<p>Query weights matrix for reuse</p>
</td></tr>
<tr><td><code id="MappingScore_+3A_verbose">verbose</code></td>
<td>
<p>Display messages/progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of cell scores
</p>

<hr>
<h2 id='MapQuery'>Map query cells to a reference</h2><span id='topic+MapQuery'></span>

<h3>Description</h3>

<p>This is a convenience wrapper function around the following three functions
that are often run together when mapping query data to a reference:
<code><a href="#topic+TransferData">TransferData</a></code>, <code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code>,
<code><a href="#topic+ProjectUMAP">ProjectUMAP</a></code>. Note that by default, the <code>weight.reduction</code>
parameter for all functions will be set to the dimension reduction method
used in the <code><a href="#topic+FindTransferAnchors">FindTransferAnchors</a></code> function call used to construct
the anchor object, and the <code>dims</code> parameter will be the same dimensions
used to find anchors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MapQuery(
  anchorset,
  query,
  reference,
  refdata = NULL,
  new.reduction.name = NULL,
  reference.reduction = NULL,
  reference.dims = NULL,
  query.dims = NULL,
  store.weights = FALSE,
  reduction.model = NULL,
  transferdata.args = list(),
  integrateembeddings.args = list(),
  projectumap.args = list(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MapQuery_+3A_anchorset">anchorset</code></td>
<td>
<p>An AnchorSet object</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_query">query</code></td>
<td>
<p>Query object used in anchorset construction</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_reference">reference</code></td>
<td>
<p>Reference object used in anchorset construction</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_refdata">refdata</code></td>
<td>
<p>Data to transfer. This can be specified in one of two ways:
</p>

<ul>
<li><p>The reference data itself as either a vector where the names
correspond to the reference cells, or a matrix, where the column names
correspond to the reference cells.
</p>
</li>
<li><p>The name of the metadata field or assay from the reference object
provided. This requires the reference parameter to be specified. If pulling
assay data in this manner, it will pull the data from the data slot. To
transfer data from other slots, please pull the data explicitly with
<code><a href="#topic+GetAssayData">GetAssayData</a></code> and provide that matrix here.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MapQuery_+3A_new.reduction.name">new.reduction.name</code></td>
<td>
<p>Name for new integrated dimensional reduction.</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_reference.reduction">reference.reduction</code></td>
<td>
<p>Name of reduction to use from the reference for
neighbor finding</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_reference.dims">reference.dims</code></td>
<td>
<p>Dimensions (columns) to use from reference</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_query.dims">query.dims</code></td>
<td>
<p>Dimensions (columns) to use from query</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_store.weights">store.weights</code></td>
<td>
<p>Determine if the weight and anchor matrices are stored.</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_reduction.model">reduction.model</code></td>
<td>
<p><code>DimReduc</code> object that contains the umap model</p>
</td></tr>
<tr><td><code id="MapQuery_+3A_transferdata.args">transferdata.args</code></td>
<td>
<p>A named list of additional arguments to
<code><a href="#topic+TransferData">TransferData</a></code></p>
</td></tr>
<tr><td><code id="MapQuery_+3A_integrateembeddings.args">integrateembeddings.args</code></td>
<td>
<p>A named list of additional arguments to
<code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code></p>
</td></tr>
<tr><td><code id="MapQuery_+3A_projectumap.args">projectumap.args</code></td>
<td>
<p>A named list of additional arguments to
<code><a href="#topic+ProjectUMAP">ProjectUMAP</a></code></p>
</td></tr>
<tr><td><code id="MapQuery_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a modified query Seurat object containing:#'
</p>

<ul>
<li><p>New Assays corresponding to the features transferred and/or their
corresponding prediction scores from <code><a href="#topic+TransferData">TransferData</a></code>
</p>
</li>
<li><p>An integrated reduction from <code><a href="#topic+IntegrateEmbeddings">IntegrateEmbeddings</a></code>
</p>
</li>
<li><p>A projected UMAP reduction of the query cells projected into the
reference UMAP using <code><a href="#topic+ProjectUMAP">ProjectUMAP</a></code>
</p>
</li></ul>


<hr>
<h2 id='merge.SCTAssay'>Merge SCTAssay objects</h2><span id='topic+merge.SCTAssay'></span>

<h3>Description</h3>

<p>Merge SCTAssay objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCTAssay'
merge(
  x = NULL,
  y = NULL,
  add.cell.ids = NULL,
  merge.data = TRUE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.SCTAssay_+3A_x">x</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="merge.SCTAssay_+3A_y">y</code></td>
<td>
<p>A single <code>Seurat</code> object or a list of <code>Seurat</code> objects</p>
</td></tr>
<tr><td><code id="merge.SCTAssay_+3A_add.cell.ids">add.cell.ids</code></td>
<td>
<p>A character vector of <code>length(x = c(x, y))</code>;
appends the corresponding values to the start of each objects' cell names</p>
</td></tr>
<tr><td><code id="merge.SCTAssay_+3A_merge.data">merge.data</code></td>
<td>
<p>Merge the data slots instead of just merging the counts
(which requires renormalization); this is recommended if the same
normalization approach was applied to all objects</p>
</td></tr>
<tr><td><code id="merge.SCTAssay_+3A_na.rm">na.rm</code></td>
<td>
<p>If na.rm = TRUE, this will only preserve residuals that are
present in all SCTAssays being merged. Otherwise, missing residuals will be
populated with NAs.</p>
</td></tr>
<tr><td><code id="merge.SCTAssay_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='MetaFeature'>Aggregate expression of multiple features into a single feature</h2><span id='topic+MetaFeature'></span>

<h3>Description</h3>

<p>Calculates relative contribution of each feature to each cell
for given set of features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetaFeature(
  object,
  features,
  meta.name = "metafeature",
  cells = NULL,
  assay = NULL,
  slot = "data"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetaFeature_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="MetaFeature_+3A_features">features</code></td>
<td>
<p>List of features to aggregate</p>
</td></tr>
<tr><td><code id="MetaFeature_+3A_meta.name">meta.name</code></td>
<td>
<p>Name of column in metadata to store metafeature</p>
</td></tr>
<tr><td><code id="MetaFeature_+3A_cells">cells</code></td>
<td>
<p>List of cells to use (default all cells)</p>
</td></tr>
<tr><td><code id="MetaFeature_+3A_assay">assay</code></td>
<td>
<p>Which assay to use</p>
</td></tr>
<tr><td><code id="MetaFeature_+3A_slot">slot</code></td>
<td>
<p>Which slot to take data from (default data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>Seurat</code> object with metafeature stored in objct metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small &lt;- MetaFeature(
  object = pbmc_small,
  features = c("LTB", "EAF2"),
  meta.name = 'var.aggregate'
)
head(pbmc_small[[]])

</code></pre>

<hr>
<h2 id='MinMax'>Apply a ceiling and floor to all values in a matrix</h2><span id='topic+MinMax'></span>

<h3>Description</h3>

<p>Apply a ceiling and floor to all values in a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinMax(data, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinMax_+3A_data">data</code></td>
<td>
<p>Matrix or data frame</p>
</td></tr>
<tr><td><code id="MinMax_+3A_min">min</code></td>
<td>
<p>all values below this min value will be replaced with min</p>
</td></tr>
<tr><td><code id="MinMax_+3A_max">max</code></td>
<td>
<p>all values above this max value will be replaced with max</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns matrix after performing these floor and ceil operations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(data = rbinom(n = 25, size = 20, prob = 0.2 ), nrow = 5)
mat
MinMax(data = mat, min = 4, max = 5)

</code></pre>

<hr>
<h2 id='MixingMetric'>Calculates a mixing metric</h2><span id='topic+MixingMetric'></span>

<h3>Description</h3>

<p>Here we compute a measure of how well mixed a composite dataset is. To
compute, we first examine the local neighborhood for each cell (looking at
max.k neighbors) and determine for each group (could be the dataset after
integration) the k nearest neighbor and what rank that neighbor was in the
overall neighborhood. We then take the median across all groups as the mixing
metric per cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixingMetric(
  object,
  grouping.var,
  reduction = "pca",
  dims = 1:2,
  k = 5,
  max.k = 300,
  eps = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixingMetric_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_grouping.var">grouping.var</code></td>
<td>
<p>Grouping variable for dataset</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensionally reduced space to use</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_dims">dims</code></td>
<td>
<p>Dimensions to use</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_k">k</code></td>
<td>
<p>Neighbor number to examine per group</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_max.k">max.k</code></td>
<td>
<p>Maximum size of local neighborhood to compute</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_eps">eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from RANN)</p>
</td></tr>
<tr><td><code id="MixingMetric_+3A_verbose">verbose</code></td>
<td>
<p>Displays progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of values of the mixing metric for each cell
</p>

<hr>
<h2 id='MixscapeHeatmap'>Differential expression heatmap for mixscape</h2><span id='topic+MixscapeHeatmap'></span>

<h3>Description</h3>

<p>Draws a heatmap of single cell feature expression with cells ordered by their
mixscape ko probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixscapeHeatmap(
  object,
  ident.1 = NULL,
  ident.2 = NULL,
  balanced = TRUE,
  logfc.threshold = 0.25,
  assay = "RNA",
  max.genes = 100,
  test.use = "wilcox",
  max.cells.group = NULL,
  order.by.prob = TRUE,
  group.by = NULL,
  mixscape.class = "mixscape_class",
  prtb.type = "KO",
  fc.name = "avg_log2FC",
  pval.cutoff = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixscapeHeatmap_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_ident.1">ident.1</code></td>
<td>
<p>Identity class to define markers for; pass an object of class
<code>phylo</code> or 'clustertree' to find markers for a node in a cluster tree;
passing 'clustertree' requires <code><a href="#topic+BuildClusterTree">BuildClusterTree</a></code> to have been run</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_ident.2">ident.2</code></td>
<td>
<p>A second identity class for comparison; if <code>NULL</code>,
use all other cells for comparison; if an object of class <code>phylo</code> or
'clustertree' is passed to <code>ident.1</code>, must pass a node to find markers for</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_balanced">balanced</code></td>
<td>
<p>Plot an equal number of genes with both groups of cells.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average, at least
X-fold difference (log-scale) between the two groups of cells. Default is 0.25. 
Increasing logfc.threshold speeds up the function, but can miss weaker signals.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_assay">assay</code></td>
<td>
<p>Assay to use in differential expression testing</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_max.genes">max.genes</code></td>
<td>
<p>Total number of DE genes to plot.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_test.use">test.use</code></td>
<td>
<p>Denotes which test to use. Available options are:
</p>

<ul>
<li><p>&quot;wilcox&quot; : Identifies differentially expressed genes between two
groups of cells using a Wilcoxon Rank Sum test (default); will use a fast
implementation by Presto if installed
</p>
</li>
<li><p>&quot;wilcox_limma&quot; : Identifies differentially expressed genes between two
groups of cells using the limma implementation of the Wilcoxon Rank Sum test;
set this option to reproduce results from Seurat v4
</p>
</li>
<li><p>&quot;bimod&quot; : Likelihood-ratio test for single cell gene expression,
(McDavid et al., Bioinformatics, 2013)
</p>
</li>
<li><p>&quot;roc&quot; : Identifies 'markers' of gene expression using ROC analysis.
For each gene, evaluates (using AUC) a classifier built on that gene alone,
to classify between two groups of cells. An AUC value of 1 means that
expression values for this gene alone can perfectly classify the two
groupings (i.e. Each of the cells in cells.1 exhibit a higher level than
each of the cells in cells.2). An AUC value of 0 also means there is perfect
classification, but in the other direction. A value of 0.5 implies that
the gene has no predictive power to classify the two groups. Returns a
'predictive power' (abs(AUC-0.5) * 2) ranked matrix of putative differentially
expressed genes.
</p>
</li>
<li><p>&quot;t&quot; : Identify differentially expressed genes between two groups of
cells using the Student's t-test.
</p>
</li>
<li><p>&quot;negbinom&quot; : Identifies differentially expressed genes between two
groups of cells using a negative binomial generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;poisson&quot; : Identifies differentially expressed genes between two
groups of cells using a poisson generalized linear model.
Use only for UMI-based datasets
</p>
</li>
<li><p>&quot;LR&quot; : Uses a logistic regression framework to determine differentially
expressed genes. Constructs a logistic regression model predicting group
membership based on each feature individually and compares this to a null
model with a likelihood ratio test.
</p>
</li>
<li><p>&quot;MAST&quot; : Identifies differentially expressed genes between two groups
of cells using a hurdle model tailored to scRNA-seq data. Utilizes the MAST
package to run the DE testing.
</p>
</li>
<li><p>&quot;DESeq2&quot; : Identifies differentially expressed genes between two groups
of cells based on a model using DESeq2 which uses a negative binomial
distribution (Love et al, Genome Biology, 2014).This test does not support
pre-filtering of genes based on average difference (or percent detection rate)
between cell groups. However, genes may be pre-filtered based on their
minimum detection rate (min.pct) across both cell groups. To use this method,
please install DESeq2, using the instructions at
https://bioconductor.org/packages/release/bioc/html/DESeq2.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_max.cells.group">max.cells.group</code></td>
<td>
<p>Number of cells per identity to plot.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_order.by.prob">order.by.prob</code></td>
<td>
<p>Order cells on heatmap based on their mixscape knockout
probability from highest to lowest score.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_group.by">group.by</code></td>
<td>
<p>(Deprecated) Option to split densities based on mixscape
classification. Please use mixscape.class instead</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_mixscape.class">mixscape.class</code></td>
<td>
<p>metadata column with mixscape classifications.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_prtb.type">prtb.type</code></td>
<td>
<p>specify type of CRISPR perturbation expected for labeling
mixscape classifications. Default is KO.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_fc.name">fc.name</code></td>
<td>
<p>Name of the fold change, average difference, or custom
function column in the output data.frame. Default is avg_log2FC</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_pval.cutoff">pval.cutoff</code></td>
<td>
<p>P-value cut-off for selection of significantly DE genes.</p>
</td></tr>
<tr><td><code id="MixscapeHeatmap_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and to specific DE methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>

<hr>
<h2 id='MixscapeLDA'>Linear discriminant analysis on pooled CRISPR screen data.</h2><span id='topic+MixscapeLDA'></span>

<h3>Description</h3>

<p>This function performs unsupervised PCA on each mixscape class separately and projects each subspace onto all
cells in the data. Finally, it uses the first 10 principle components from each projection as input to lda in MASS package together with mixscape class labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MixscapeLDA(
  object,
  assay = NULL,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.key = "LDA_",
  seed = 42,
  pc.assay = "PRTB",
  labels = "gene",
  nt.label = "NT",
  npcs = 10,
  verbose = TRUE,
  logfc.threshold = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixscapeLDA_+3A_object">object</code></td>
<td>
<p>An object of class Seurat.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_assay">assay</code></td>
<td>
<p>Assay to use for performing Linear Discriminant Analysis (LDA).</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_ndims.print">ndims.print</code></td>
<td>
<p>Number of LDA dimensions to print.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_nfeatures.print">nfeatures.print</code></td>
<td>
<p>Number of features to print for each LDA component.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_reduction.key">reduction.key</code></td>
<td>
<p>Reduction key name.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_seed">seed</code></td>
<td>
<p>Value for random seed</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_pc.assay">pc.assay</code></td>
<td>
<p>Assay to use for running Principle components analysis.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_labels">labels</code></td>
<td>
<p>Meta data column with target gene class labels.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_nt.label">nt.label</code></td>
<td>
<p>Name of non-targeting cell class.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_npcs">npcs</code></td>
<td>
<p>Number of principle components to use.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bar.</p>
</td></tr>
<tr><td><code id="MixscapeLDA_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average, at least
X-fold difference (log-scale) between the two groups of cells. Default is 0.25. 
Increasing logfc.threshold speeds up the function, but can miss weaker signals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with LDA added in the reduction slot.
</p>

<hr>
<h2 id='ModalityWeights-class'>The ModalityWeights Class</h2><span id='topic+ModalityWeights-class'></span><span id='topic+ModalityWeights'></span>

<h3>Description</h3>

<p>The ModalityWeights class is an intermediate data storage class that stores the modality weight and other
related information needed for performing downstream analyses - namely data integration
(<code>FindModalityWeights</code>) and data transfer (<code><a href="#topic+FindMultiModalNeighbors">FindMultiModalNeighbors</a></code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>modality.weight.list</code></dt><dd><p>A list of modality weights value from all modalities</p>
</dd>
<dt><code>modality.assay</code></dt><dd><p>Names of assays for the list of dimensional reductions</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of parameters used in the FindModalityWeights</p>
</dd>
<dt><code>score.matrix</code></dt><dd><p>a list of score matrices representing cross and within-modality prediction
score, and kernel value</p>
</dd>
<dt><code>command</code></dt><dd><p>Store log of parameters that were used</p>
</dd>
</dl>

<hr>
<h2 id='MULTIseqDemux'>Demultiplex samples based on classification method from MULTI-seq (McGinnis et al., bioRxiv 2018)</h2><span id='topic+MULTIseqDemux'></span>

<h3>Description</h3>

<p>Identify singlets, doublets and negative cells from multiplexing experiments. Annotate singlets by tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MULTIseqDemux(
  object,
  assay = "HTO",
  quantile = 0.7,
  autoThresh = FALSE,
  maxiter = 5,
  qrange = seq(from = 0.1, to = 0.9, by = 0.05),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MULTIseqDemux_+3A_object">object</code></td>
<td>
<p>Seurat object. Assumes that the specified assay data has been added</p>
</td></tr>
<tr><td><code id="MULTIseqDemux_+3A_assay">assay</code></td>
<td>
<p>Name of the multiplexing assay (HTO by default)</p>
</td></tr>
<tr><td><code id="MULTIseqDemux_+3A_quantile">quantile</code></td>
<td>
<p>The quantile to use for classification</p>
</td></tr>
<tr><td><code id="MULTIseqDemux_+3A_autothresh">autoThresh</code></td>
<td>
<p>Whether to perform automated threshold finding to define the best quantile. Default is FALSE</p>
</td></tr>
<tr><td><code id="MULTIseqDemux_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations if autoThresh = TRUE. Default is 5</p>
</td></tr>
<tr><td><code id="MULTIseqDemux_+3A_qrange">qrange</code></td>
<td>
<p>A range of possible quantile values to try if autoThresh = TRUE</p>
</td></tr>
<tr><td><code id="MULTIseqDemux_+3A_verbose">verbose</code></td>
<td>
<p>Prints the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with demultiplexing results stored at <code>object$MULTI_ID</code>
</p>


<h3>References</h3>

<p><a href="https://www.biorxiv.org/content/10.1101/387241v1">https://www.biorxiv.org/content/10.1101/387241v1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
object &lt;- MULTIseqDemux(object)

## End(Not run)

</code></pre>

<hr>
<h2 id='MVP'>Find variable features based on mean.var.plot</h2><span id='topic+MVP'></span>

<h3>Description</h3>

<p>Find variable features based on mean.var.plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVP(
  data,
  verbose = TRUE,
  nselect = 2000L,
  mean.cutoff = c(0.1, 8),
  dispersion.cutoff = c(1, Inf),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVP_+3A_data">data</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="MVP_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages and progress bars</p>
</td></tr>
<tr><td><code id="MVP_+3A_nselect">nselect</code></td>
<td>
<p>Number of features to select based on dispersion values</p>
</td></tr>
<tr><td><code id="MVP_+3A_mean.cutoff">mean.cutoff</code></td>
<td>
<p>Numeric of length two specifying the min and max values</p>
</td></tr>
<tr><td><code id="MVP_+3A_dispersion.cutoff">dispersion.cutoff</code></td>
<td>
<p>Numeric of length two specifying the min and max values</p>
</td></tr>
</table>

<hr>
<h2 id='Neighbor-class'>The Neighbor Class</h2><span id='topic+Neighbor-class'></span>

<h3>Description</h3>

<p>For more details, please see the documentation in
<code><a href="SeuratObject.html#topic+Neighbor">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+Neighbor">SeuratObject::Neighbor-class</a></code>
</p>

<hr>
<h2 id='NNPlot'>Highlight Neighbors in DimPlot</h2><span id='topic+NNPlot'></span>

<h3>Description</h3>

<p>It will color the query cells and the neighbors of the query cells in the
DimPlot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNPlot(
  object,
  reduction,
  nn.idx,
  query.cells,
  dims = 1:2,
  label = FALSE,
  label.size = 4,
  repel = FALSE,
  sizes.highlight = 2,
  pt.size = 1,
  cols.highlight = c("#377eb8", "#e41a1c"),
  na.value = "#bdbdbd",
  order = c("self", "neighbors", "other"),
  show.all.cells = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensionality reduction to use. If not specified, first searches for umap, then tsne, then pca</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_nn.idx">nn.idx</code></td>
<td>
<p>the neighbor index of all cells</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_query.cells">query.cells</code></td>
<td>
<p>cells used to find their neighbors</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_dims">dims</code></td>
<td>
<p>Dimensions to plot, must be a two-length numeric vector specifying x- and y-dimensions</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_label">label</code></td>
<td>
<p>Whether to label the clusters</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_label.size">label.size</code></td>
<td>
<p>Sets size of labels</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_repel">repel</code></td>
<td>
<p>Repel labels</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_sizes.highlight">sizes.highlight</code></td>
<td>
<p>Size of highlighted cells; will repeat to the length
groups in cells.highlight.  If <code>sizes.highlight = TRUE</code> size of all
points will be this value.</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Adjust point size for plotting</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_cols.highlight">cols.highlight</code></td>
<td>
<p>A vector of colors to highlight the cells as; will
repeat to the length groups in cells.highlight</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_na.value">na.value</code></td>
<td>
<p>Color value for NA points when using custom scale</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_order">order</code></td>
<td>
<p>Specify the order of plotting for the idents. This can be
useful for crowded plots if points of interest are being buried. Provide
either a full list of valid idents or a subset to be plotted last (on top)</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_show.all.cells">show.all.cells</code></td>
<td>
<p>Show all cells or only query and neighbor cells</p>
</td></tr>
<tr><td><code id="NNPlot_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>DimPlot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>

<hr>
<h2 id='NNtoGraph'>Convert Neighbor class to an asymmetrical Graph class</h2><span id='topic+NNtoGraph'></span>

<h3>Description</h3>

<p>Convert Neighbor class to an asymmetrical Graph class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNtoGraph(nn.object, col.cells = NULL, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNtoGraph_+3A_nn.object">nn.object</code></td>
<td>
<p>A neighbor class object</p>
</td></tr>
<tr><td><code id="NNtoGraph_+3A_col.cells">col.cells</code></td>
<td>
<p>Cells names of the neighbors, cell names in nn.object is used by default</p>
</td></tr>
<tr><td><code id="NNtoGraph_+3A_weighted">weighted</code></td>
<td>
<p>Determine if use distance in the Graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Graph object
</p>

<hr>
<h2 id='NormalizeData'>Normalize Data</h2><span id='topic+NormalizeData'></span><span id='topic+NormalizeData.V3Matrix'></span><span id='topic+NormalizeData.Assay'></span><span id='topic+NormalizeData.Seurat'></span>

<h3>Description</h3>

<p>Normalize the count data present in a given assay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeData(object, ...)

## S3 method for class 'V3Matrix'
NormalizeData(
  object,
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  margin = 1,
  block.size = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
NormalizeData(
  object,
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  margin = 1,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
NormalizeData(
  object,
  assay = NULL,
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  margin = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalizeData_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="NormalizeData_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="NormalizeData_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Method for normalization.
</p>

<ul>
<li> <p>&ldquo;<code>LogNormalize</code>&rdquo;: Feature counts for each cell are
divided by the total counts for that cell and multiplied by the
<code>scale.factor</code>. This is then natural-log transformed using <code>log1p</code>
</p>
</li>
<li> <p>&ldquo;<code>CLR</code>&rdquo;: Applies a centered log ratio transformation
</p>
</li>
<li> <p>&ldquo;<code>RC</code>&rdquo;: Relative counts. Feature counts for each cell
are divided by the total counts for that cell and multiplied by the
<code>scale.factor</code>. No log-transformation is applied. For counts per
million (CPM) set <code>scale.factor = 1e6</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="NormalizeData_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Sets the scale factor for cell-level normalization</p>
</td></tr>
<tr><td><code id="NormalizeData_+3A_margin">margin</code></td>
<td>
<p>If performing CLR normalization, normalize across features (1) or cells (2)</p>
</td></tr>
<tr><td><code id="NormalizeData_+3A_block.size">block.size</code></td>
<td>
<p>How many cells should be run in each chunk, will try to split evenly across threads</p>
</td></tr>
<tr><td><code id="NormalizeData_+3A_verbose">verbose</code></td>
<td>
<p>display progress bar for normalization procedure</p>
</td></tr>
<tr><td><code id="NormalizeData_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object after normalization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small
pmbc_small &lt;- NormalizeData(object = pbmc_small)

## End(Not run)

</code></pre>

<hr>
<h2 id='PCASigGenes'>Significant genes from a PCA</h2><span id='topic+PCASigGenes'></span>

<h3>Description</h3>

<p>Returns a set of genes, based on the JackStraw analysis, that have
statistically significant associations with a set of PCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCASigGenes(
  object,
  pcs.use,
  pval.cut = 0.1,
  use.full = FALSE,
  max.per.pc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCASigGenes_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="PCASigGenes_+3A_pcs.use">pcs.use</code></td>
<td>
<p>PCS to use.</p>
</td></tr>
<tr><td><code id="PCASigGenes_+3A_pval.cut">pval.cut</code></td>
<td>
<p>P-value cutoff</p>
</td></tr>
<tr><td><code id="PCASigGenes_+3A_use.full">use.full</code></td>
<td>
<p>Use the full list of genes (from the projected PCA). Assumes
that <code>ProjectDim</code> has been run. Currently, must be set to FALSE.</p>
</td></tr>
<tr><td><code id="PCASigGenes_+3A_max.per.pc">max.per.pc</code></td>
<td>
<p>Maximum number of genes to return per PC. Used to avoid genes from one PC dominating the entire analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of genes whose p-values are statistically significant for
at least one of the given PCs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjectDim">ProjectDim</a></code> <code><a href="#topic+JackStraw">JackStraw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
PCASigGenes(pbmc_small, pcs.use = 1:2)

</code></pre>

<hr>
<h2 id='PercentAbove'>Calculate the percentage of a vector above some threshold</h2><span id='topic+PercentAbove'></span>

<h3>Description</h3>

<p>Calculate the percentage of a vector above some threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PercentAbove(x, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PercentAbove_+3A_x">x</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="PercentAbove_+3A_threshold">threshold</code></td>
<td>
<p>Threshold to use when calculating percentage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the percentage of <code>x</code> values above the given threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
PercentAbove(sample(1:100, 10), 75)

</code></pre>

<hr>
<h2 id='PercentageFeatureSet'>Calculate the percentage of all counts that belong to a given set of features</h2><span id='topic+PercentageFeatureSet'></span>

<h3>Description</h3>

<p>This function enables you to easily calculate the percentage of all the counts belonging to a
subset of the possible features for each cell. This is useful when trying to compute the percentage
of transcripts that map to mitochondrial genes for example. The calculation here is simply the
column sum of the matrix present in the counts slot for features belonging to the set divided by
the column sum for all features times 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PercentageFeatureSet(
  object,
  pattern = NULL,
  features = NULL,
  col.name = NULL,
  assay = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PercentageFeatureSet_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="PercentageFeatureSet_+3A_pattern">pattern</code></td>
<td>
<p>A regex pattern to match features against</p>
</td></tr>
<tr><td><code id="PercentageFeatureSet_+3A_features">features</code></td>
<td>
<p>A defined feature set. If features provided, will ignore the pattern matching</p>
</td></tr>
<tr><td><code id="PercentageFeatureSet_+3A_col.name">col.name</code></td>
<td>
<p>Name in meta.data column to assign. If this is not null, returns a Seurat object
with the proportion of the feature set stored in metadata.</p>
</td></tr>
<tr><td><code id="PercentageFeatureSet_+3A_assay">assay</code></td>
<td>
<p>Assay to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with the proportion of the feature set or if md.name is set, returns a
Seurat object with the proportion of the feature set stored in metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
# Calculate the proportion of transcripts mapping to mitochondrial genes
# NOTE: The pattern provided works for human gene names. You may need to adjust depending on your
# system of interest
pbmc_small[["percent.mt"]] &lt;- PercentageFeatureSet(object = pbmc_small, pattern = "^MT-")

</code></pre>

<hr>
<h2 id='PlotClusterTree'>Plot clusters as a tree</h2><span id='topic+PlotClusterTree'></span>

<h3>Description</h3>

<p>Plots previously computed tree (from BuildClusterTree)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotClusterTree(object, direction = "downwards", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotClusterTree_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="PlotClusterTree_+3A_direction">direction</code></td>
<td>
<p>A character string specifying the direction of the tree (default is downwards)
Possible options: &quot;rightwards&quot;, &quot;leftwards&quot;, &quot;upwards&quot;, and &quot;downwards&quot;.</p>
</td></tr>
<tr><td><code id="PlotClusterTree_+3A_...">...</code></td>
<td>
<p>Additional arguments to
<code><a href="ape.html#topic+plot.phylo">ape::plot.phylo</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots dendogram (must be precomputed using BuildClusterTree), returns no value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("ape", quietly = TRUE)) {
  data("pbmc_small")
  pbmc_small &lt;- BuildClusterTree(object = pbmc_small)
  PlotClusterTree(object = pbmc_small)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotPerturbScore'>Function to plot perturbation score distributions.</h2><span id='topic+PlotPerturbScore'></span>

<h3>Description</h3>

<p>Density plots to visualize perturbation scores calculated from RunMixscape
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPerturbScore(
  object,
  target.gene.class = "gene",
  target.gene.ident = NULL,
  mixscape.class = "mixscape_class",
  col = "orange2",
  split.by = NULL,
  before.mixscape = FALSE,
  prtb.type = "KO"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPerturbScore_+3A_object">object</code></td>
<td>
<p>An object of class Seurat.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_target.gene.class">target.gene.class</code></td>
<td>
<p>meta data column specifying all target gene names in the experiment.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_target.gene.ident">target.gene.ident</code></td>
<td>
<p>Target gene name to visualize perturbation scores for.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_mixscape.class">mixscape.class</code></td>
<td>
<p>meta data column specifying mixscape classifications.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_col">col</code></td>
<td>
<p>Specify color of target gene class or knockout cell class. For
control non-targeting and non-perturbed cells, colors are set to different
shades of grey.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_split.by">split.by</code></td>
<td>
<p>For datasets with more than one cell type. Set equal TRUE to visualize perturbation scores for each cell type separately.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_before.mixscape">before.mixscape</code></td>
<td>
<p>Option to split densities based on mixscape classification (default) or original target gene classification.
Default is set to NULL and plots cells by original class ID.</p>
</td></tr>
<tr><td><code id="PlotPerturbScore_+3A_prtb.type">prtb.type</code></td>
<td>
<p>specify type of CRISPR perturbation expected for labeling mixscape classifications. Default is KO.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>

<hr>
<h2 id='PolyDimPlot'>Polygon DimPlot</h2><span id='topic+PolyDimPlot'></span>

<h3>Description</h3>

<p>Plot cells as polygons, rather than single points. Color cells by identity, or a categorical variable
in metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolyDimPlot(
  object,
  group.by = NULL,
  cells = NULL,
  poly.data = "spatial",
  flip.coords = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolyDimPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="PolyDimPlot_+3A_group.by">group.by</code></td>
<td>
<p>A grouping variable present in the metadata. Default is to use the groupings present
in the current cell identities (<code>Idents(object = object)</code>)</p>
</td></tr>
<tr><td><code id="PolyDimPlot_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to plot (default is all cells)</p>
</td></tr>
<tr><td><code id="PolyDimPlot_+3A_poly.data">poly.data</code></td>
<td>
<p>Name of the polygon dataframe in the misc slot</p>
</td></tr>
<tr><td><code id="PolyDimPlot_+3A_flip.coords">flip.coords</code></td>
<td>
<p>Flip x and y coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object
</p>

<hr>
<h2 id='PolyFeaturePlot'>Polygon FeaturePlot</h2><span id='topic+PolyFeaturePlot'></span>

<h3>Description</h3>

<p>Plot cells as polygons, rather than single points. Color cells by any value
accessible by <code><a href="#topic+FetchData">FetchData</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolyFeaturePlot(
  object,
  features,
  cells = NULL,
  poly.data = "spatial",
  ncol = ceiling(x = length(x = features)/2),
  min.cutoff = 0,
  max.cutoff = NA,
  common.scale = TRUE,
  flip.coords = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolyFeaturePlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_features">features</code></td>
<td>
<p>Vector of features to plot. Features can come from:
</p>

<ul>
<li><p> An <code>Assay</code> feature (e.g. a gene name - &quot;MS4A1&quot;)
</p>
</li>
<li><p> A column name from meta.data (e.g. mitochondrial percentage -
&quot;percent.mito&quot;)
</p>
</li>
<li><p> A column name from a <code>DimReduc</code> object corresponding to the
cell embedding values (e.g. the PC 1 scores - &quot;PC_1&quot;)
</p>
</li></ul>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to plot (default is all cells)</p>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_poly.data">poly.data</code></td>
<td>
<p>Name of the polygon dataframe in the misc slot</p>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns to split the plot into</p>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_min.cutoff">min.cutoff</code>, <code id="PolyFeaturePlot_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Vector of minimum and maximum cutoff values for each feature,
may specify quantile in the form of 'q##' where '##' is the quantile (eg, 'q1', 'q10')</p>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_common.scale">common.scale</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="PolyFeaturePlot_+3A_flip.coords">flip.coords</code></td>
<td>
<p>Flip x and y coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object
</p>

<hr>
<h2 id='PredictAssay'>Predict value from nearest neighbors</h2><span id='topic+PredictAssay'></span>

<h3>Description</h3>

<p>This function will predict expression or cell embeddings from its k nearest
neighbors index. For each cell, it will average its k neighbors value to get
its new imputed value. It can average expression value in assays and cell
embeddings from dimensional reductions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictAssay(
  object,
  nn.idx,
  assay,
  reduction = NULL,
  dims = NULL,
  return.assay = TRUE,
  slot = "scale.data",
  features = NULL,
  mean.function = rowMeans,
  seed = 4273,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredictAssay_+3A_object">object</code></td>
<td>
<p>The object used to calculate knn</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_nn.idx">nn.idx</code></td>
<td>
<p>k near neighbour indices. A cells x k matrix.</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_assay">assay</code></td>
<td>
<p>Assay used for prediction</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_reduction">reduction</code></td>
<td>
<p>Cell embedding of the reduction used for prediction</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_dims">dims</code></td>
<td>
<p>Number of dimensions of cell embedding</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_return.assay">return.assay</code></td>
<td>
<p>Return an assay or a predicted matrix</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_slot">slot</code></td>
<td>
<p>slot used for prediction</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_features">features</code></td>
<td>
<p>features used for prediction</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_mean.function">mean.function</code></td>
<td>
<p>the function used to calculate row mean</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_seed">seed</code></td>
<td>
<p>Sets the random seed to check if the nearest neighbor is query
cell</p>
</td></tr>
<tr><td><code id="PredictAssay_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return an assay containing predicted expression value in the data
slot
</p>

<hr>
<h2 id='PrepareBridgeReference'>Prepare the bridge and reference datasets</h2><span id='topic+PrepareBridgeReference'></span>

<h3>Description</h3>

<p>Preprocess the multi-omic bridge and unimodal reference datasets into
an extended reference.
This function performs the following three steps:
1. Performs within-modality harmonization between bridge and reference
2. Performs dimensional reduction on the SNN graph of bridge datasets via
Laplacian Eigendecomposition
3. Constructs a bridge dictionary representation for unimodal reference cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrepareBridgeReference(
  reference,
  bridge,
  reference.reduction = "pca",
  reference.dims = 1:50,
  normalization.method = c("SCT", "LogNormalize"),
  reference.assay = NULL,
  bridge.ref.assay = "RNA",
  bridge.query.assay = "ATAC",
  supervised.reduction = c("slsi", "spca", NULL),
  bridge.query.reduction = NULL,
  bridge.query.features = NULL,
  laplacian.reduction.name = "lap",
  laplacian.reduction.key = "lap_",
  laplacian.reduction.dims = 1:50,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrepareBridgeReference_+3A_reference">reference</code></td>
<td>
<p>A reference Seurat object</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_bridge">bridge</code></td>
<td>
<p>A multi-omic bridge Seurat object</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_reference.reduction">reference.reduction</code></td>
<td>
<p>Name of dimensional reduction of the reference object (default is 'pca')</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_reference.dims">reference.dims</code></td>
<td>
<p>Number of dimensions used for the reference.reduction (default is 50)</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_reference.assay">reference.assay</code></td>
<td>
<p>Assay name for reference (default is <code><a href="#topic+DefaultAssay">DefaultAssay</a></code>)</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_bridge.ref.assay">bridge.ref.assay</code></td>
<td>
<p>Assay name for bridge used for reference mapping. RNA by default</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_bridge.query.assay">bridge.query.assay</code></td>
<td>
<p>Assay name for bridge used for query mapping. ATAC by default</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_supervised.reduction">supervised.reduction</code></td>
<td>
<p>Type of supervised dimensional reduction to be performed
for integrating the bridge and query.
#' Options are:
</p>

<ul>
<li><p>slsi: Perform supervised LSI as the dimensional reduction for
the bridge-query integration
</p>
</li>
<li><p>spca: Perform supervised PCA as the dimensional reduction for
the bridge-query integration
</p>
</li>
<li><p>NULL: no supervised dimensional reduction will be calculated.
bridge.query.reduction is used for the bridge-query integration
</p>
</li></ul>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_bridge.query.reduction">bridge.query.reduction</code></td>
<td>
<p>Name of dimensions used for the bridge-query harmonization.
'bridge.query.reduction' and 'supervised.reduction' cannot be NULL together.</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_bridge.query.features">bridge.query.features</code></td>
<td>
<p>Features used for bridge query dimensional reduction
(default is NULL which uses VariableFeatures from the bridge object)</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_laplacian.reduction.name">laplacian.reduction.name</code></td>
<td>
<p>Name of dimensional reduction name of graph laplacian eigenspace (default is 'lap')</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_laplacian.reduction.key">laplacian.reduction.key</code></td>
<td>
<p>Dimensional reduction key (default is 'lap_')</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_laplacian.reduction.dims">laplacian.reduction.dims</code></td>
<td>
<p>Number of dimensions used for graph laplacian eigenspace (default is 50)</p>
</td></tr>
<tr><td><code id="PrepareBridgeReference_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and message (default is TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>BridgeReferenceSet</code> that can be used as input to
<code><a href="#topic+FindBridgeTransferAnchors">FindBridgeTransferAnchors</a></code>.
The parameters used are stored in the <code>BridgeReferenceSet</code> as well
</p>

<hr>
<h2 id='PrepLDA'>Function to prepare data for Linear Discriminant Analysis.</h2><span id='topic+PrepLDA'></span>

<h3>Description</h3>

<p>This function performs unsupervised PCA on each mixscape class separately and projects each subspace onto all
cells in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrepLDA(
  object,
  de.assay = "RNA",
  pc.assay = "PRTB",
  labels = "gene",
  nt.label = "NT",
  npcs = 10,
  verbose = TRUE,
  logfc.threshold = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrepLDA_+3A_object">object</code></td>
<td>
<p>An object of class Seurat.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_de.assay">de.assay</code></td>
<td>
<p>Assay to use for selection of DE genes.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_pc.assay">pc.assay</code></td>
<td>
<p>Assay to use for running Principle components analysis.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_labels">labels</code></td>
<td>
<p>Meta data column with target gene class labels.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_nt.label">nt.label</code></td>
<td>
<p>Name of non-targeting cell class.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_npcs">npcs</code></td>
<td>
<p>Number of principle components to use.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bar.</p>
</td></tr>
<tr><td><code id="PrepLDA_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average, at least
X-fold difference (log-scale) between the two groups of cells. Default is 0.25. 
Increasing logfc.threshold speeds up the function, but can miss weaker signals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the first 10 PCs from each projection.
</p>

<hr>
<h2 id='PrepSCTFindMarkers'>Prepare object to run differential expression on SCT assay with multiple models</h2><span id='topic+PrepSCTFindMarkers'></span>

<h3>Description</h3>

<p>Given a merged object with multiple SCT models, this function uses minimum
of the median UMI (calculated using the raw UMI counts) of individual objects
to reverse the individual SCT regression model using minimum of median UMI
as the sequencing depth covariate.
The counts slot of the SCT assay is replaced with recorrected counts and
the data slot is replaced with log1p of recorrected counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrepSCTFindMarkers(object, assay = "SCT", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrepSCTFindMarkers_+3A_object">object</code></td>
<td>
<p>Seurat object with SCT assays</p>
</td></tr>
<tr><td><code id="PrepSCTFindMarkers_+3A_assay">assay</code></td>
<td>
<p>Assay name where for SCT objects are stored; Default is 'SCT'</p>
</td></tr>
<tr><td><code id="PrepSCTFindMarkers_+3A_verbose">verbose</code></td>
<td>
<p>Print messages and progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with recorrected counts and data in the SCT assay.
</p>


<h3>Progress Updates with <span class="pkg">progressr</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=progressr"><span class="pkg">progressr</span></a> to
render status updates and progress bars. To enable progress updates, wrap
the function call in <code><a href="progressr.html#topic+with_progress">with_progress</a></code> or run
<code><a href="progressr.html#topic+handlers">handlers(global = TRUE)</a></code> before running
this function. For more details about <span class="pkg">progressr</span>, please read
<a href="https://progressr.futureverse.org/articles/progressr-intro.html"><code>vignette("progressr-intro")</code></a>
</p>


<h3>Parallelization with <span class="pkg">future</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=future"><span class="pkg">future</span></a> to enable
parallelization. Parallelization strategies can be set using
<code><a href="future.html#topic+plan">plan</a></code>. Common plans include &ldquo;<code>sequential</code>&rdquo;
for non-parallelized processing or &ldquo;<code>multisession</code>&rdquo; for parallel
evaluation using multiple <span class="rlang"><b>R</b></span> sessions; for other plans, see the
&ldquo;Implemented evaluation strategies&rdquo; section of
<code><a href="future.html#topic+plan">?future::plan</a></code>. For a more thorough introduction
to <span class="pkg">future</span>, see
<a href="https://future.futureverse.org/articles/future-1-overview.html"><code>vignette("future-1-overview")</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small1 &lt;- SCTransform(object = pbmc_small, variable.features.n = 20, vst.flavor="v1")
pbmc_small2 &lt;- SCTransform(object = pbmc_small, variable.features.n = 20, vst.flavor="v1")
pbmc_merged &lt;- merge(x = pbmc_small1, y = pbmc_small2)
pbmc_merged &lt;- PrepSCTFindMarkers(object = pbmc_merged)
markers &lt;- FindMarkers(
  object = pbmc_merged,
  ident.1 = "0",
  ident.2 = "1",
  assay = "SCT"
)
pbmc_subset &lt;- subset(pbmc_merged, idents = c("0", "1"))
markers_subset &lt;- FindMarkers(
  object = pbmc_subset,
  ident.1 = "0",
  ident.2 = "1",
  assay = "SCT",
  recorrect_umi = FALSE
)

</code></pre>

<hr>
<h2 id='PrepSCTIntegration'>Prepare an object list normalized with sctransform for integration.</h2><span id='topic+PrepSCTIntegration'></span>

<h3>Description</h3>

<p>This function takes in a list of objects that have been normalized with the
<code><a href="#topic+SCTransform">SCTransform</a></code> method and performs the following steps:
</p>

<ul>
<li><p>If anchor.features is a numeric value, calls <code><a href="#topic+SelectIntegrationFeatures">SelectIntegrationFeatures</a></code>
to determine the features to use in the downstream integration procedure.
</p>
</li>
<li><p>Ensures that the sctransform residuals for the features specified
to anchor.features are present in each object in the list. This is
necessary because the default behavior of <code><a href="#topic+SCTransform">SCTransform</a></code> is to
only store the residuals for the features determined to be variable.
Residuals are recomputed for missing features using the stored model
parameters via the <code><a href="#topic+GetResidual">GetResidual</a></code> function.
</p>
</li>
<li><p>Subsets the <code>scale.data</code> slot to only contain the residuals for
anchor.features for efficiency in downstream processing. 
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>PrepSCTIntegration(
  object.list,
  assay = NULL,
  anchor.features = 2000,
  sct.clip.range = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrepSCTIntegration_+3A_object.list">object.list</code></td>
<td>
<p>A list of <code><a href="#topic+Seurat">Seurat</a></code> objects to prepare for integration</p>
</td></tr>
<tr><td><code id="PrepSCTIntegration_+3A_assay">assay</code></td>
<td>
<p>The name of the <code><a href="nlme.html#topic+Assay">Assay</a></code> to use for integration. This can be a
single name if all the assays to be integrated have the same name, or a character vector
containing the name of each <code><a href="nlme.html#topic+Assay">Assay</a></code> in each object to be integrated. The
specified assays must have been normalized using <code><a href="#topic+SCTransform">SCTransform</a></code>.
If NULL (default), the current default assay for each object is used.</p>
</td></tr>
<tr><td><code id="PrepSCTIntegration_+3A_anchor.features">anchor.features</code></td>
<td>
<p>Can be either:
</p>

<ul>
<li><p>A numeric value. This will call <code><a href="#topic+SelectIntegrationFeatures">SelectIntegrationFeatures</a></code>
to select the provided number of features to be used in anchor finding
</p>
</li>
<li><p>A vector of features to be used as input to the anchor finding
process
</p>
</li></ul>
</td></tr>
<tr><td><code id="PrepSCTIntegration_+3A_sct.clip.range">sct.clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values
the Pearson residual will be clipped to</p>
</td></tr>
<tr><td><code id="PrepSCTIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Display output/messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+Seurat">Seurat</a></code> objects with the appropriate <code>scale.data</code> slots
containing only the required <code>anchor.features</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("panc8")

# panc8 is a merged Seurat object containing 8 separate pancreas datasets
# split the object by dataset and take the first 2 to integrate
pancreas.list &lt;- SplitObject(panc8, split.by = "tech")[1:2]

# perform SCTransform normalization
pancreas.list &lt;- lapply(X = pancreas.list, FUN = SCTransform)

# select integration features and prep step
features &lt;- SelectIntegrationFeatures(pancreas.list)
pancreas.list &lt;- PrepSCTIntegration(
  pancreas.list,
  anchor.features = features
)

# downstream integration steps
anchors &lt;- FindIntegrationAnchors(
  pancreas.list,
  normalization.method = "SCT",
  anchor.features = features
)
pancreas.integrated &lt;- IntegrateData(anchors, normalization.method = "SCT")

## End(Not run)

</code></pre>

<hr>
<h2 id='ProjectCellEmbeddings'>Project query data to the reference dimensional reduction</h2><span id='topic+ProjectCellEmbeddings'></span><span id='topic+ProjectCellEmbeddings.Seurat'></span><span id='topic+ProjectCellEmbeddings.Assay'></span><span id='topic+ProjectCellEmbeddings.SCTAssay'></span><span id='topic+ProjectCellEmbeddings.StdAssay'></span><span id='topic+ProjectCellEmbeddings.default'></span><span id='topic+ProjectCellEmbeddings.IterableMatrix'></span>

<h3>Description</h3>

<p>Project query data to the reference dimensional reduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectCellEmbeddings(query, ...)

## S3 method for class 'Seurat'
ProjectCellEmbeddings(
  query,
  reference,
  query.assay = NULL,
  reference.assay = NULL,
  reduction = "pca",
  dims = 1:50,
  normalization.method = c("LogNormalize", "SCT"),
  scale = TRUE,
  verbose = TRUE,
  nCount_UMI = NULL,
  feature.mean = NULL,
  feature.sd = NULL,
  ...
)

## S3 method for class 'Assay'
ProjectCellEmbeddings(
  query,
  reference,
  reference.assay = NULL,
  reduction = "pca",
  dims = 1:50,
  scale = TRUE,
  normalization.method = NULL,
  verbose = TRUE,
  nCount_UMI = NULL,
  feature.mean = NULL,
  feature.sd = NULL,
  ...
)

## S3 method for class 'SCTAssay'
ProjectCellEmbeddings(
  query,
  reference,
  reference.assay = NULL,
  reduction = "pca",
  dims = 1:50,
  scale = TRUE,
  normalization.method = NULL,
  verbose = TRUE,
  nCount_UMI = NULL,
  feature.mean = NULL,
  feature.sd = NULL,
  ...
)

## S3 method for class 'StdAssay'
ProjectCellEmbeddings(
  query,
  reference,
  reference.assay = NULL,
  reduction = "pca",
  dims = 1:50,
  scale = TRUE,
  normalization.method = NULL,
  verbose = TRUE,
  nCount_UMI = NULL,
  feature.mean = NULL,
  feature.sd = NULL,
  ...
)

## Default S3 method:
ProjectCellEmbeddings(
  query,
  reference,
  reference.assay = NULL,
  reduction = "pca",
  dims = 1:50,
  scale = TRUE,
  normalization.method = NULL,
  verbose = TRUE,
  features = NULL,
  nCount_UMI = NULL,
  feature.mean = NULL,
  feature.sd = NULL,
  ...
)

## S3 method for class 'IterableMatrix'
ProjectCellEmbeddings(
  query,
  reference,
  reference.assay = NULL,
  reduction = "pca",
  dims = 1:50,
  scale = TRUE,
  normalization.method = NULL,
  verbose = TRUE,
  features = features,
  nCount_UMI = NULL,
  feature.mean = NULL,
  feature.sd = NULL,
  block.size = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectCellEmbeddings_+3A_query">query</code></td>
<td>
<p>An object for query cells</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_reference">reference</code></td>
<td>
<p>An object for reference cells</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_query.assay">query.assay</code></td>
<td>
<p>Assay name for query object</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_reference.assay">reference.assay</code></td>
<td>
<p>Assay name for reference object</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_reduction">reduction</code></td>
<td>
<p>Name of dimensional reduction from reference object</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_dims">dims</code></td>
<td>
<p>Dimensions used for reference dimensional reduction</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_scale">scale</code></td>
<td>
<p>Determine if scale query data based on reference data variance</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_feature.mean">feature.mean</code></td>
<td>
<p>Mean of features in reference</p>
</td></tr>
<tr><td><code id="ProjectCellEmbeddings_+3A_feature.sd">feature.sd</code></td>
<td>
<p>Standard variance of features in reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with projected cell embeddings
</p>

<hr>
<h2 id='ProjectData'>Project full data to the sketch assay</h2><span id='topic+ProjectData'></span>

<h3>Description</h3>

<p>This function allows projection of high-dimensional single-cell RNA expression data from a full dataset
onto the lower-dimensional embedding of the sketch of the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectData(
  object,
  assay = "RNA",
  sketched.assay = "sketch",
  sketched.reduction,
  full.reduction,
  dims,
  normalization.method = c("LogNormalize", "SCT"),
  refdata = NULL,
  k.weight = 50,
  umap.model = NULL,
  recompute.neighbors = FALSE,
  recompute.weights = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectData_+3A_object">object</code></td>
<td>
<p>A Seurat object.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_assay">assay</code></td>
<td>
<p>Assay name for the full data. Default is 'RNA'.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_sketched.assay">sketched.assay</code></td>
<td>
<p>Sketched assay name to project onto. Default is 'sketch'.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_sketched.reduction">sketched.reduction</code></td>
<td>
<p>Dimensional reduction results of the sketched assay to project onto.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_full.reduction">full.reduction</code></td>
<td>
<p>Dimensional reduction name for the projected full dataset.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_dims">dims</code></td>
<td>
<p>Dimensions to include in the projection.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Normalization method to use. Can be 'LogNormalize' or 'SCT'.
Default is 'LogNormalize'.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_refdata">refdata</code></td>
<td>
<p>An optional list for label transfer from sketch to full data. Default is NULL.
Similar to refdata in 'MapQuery'</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting labels for transfer. Default is 50.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_umap.model">umap.model</code></td>
<td>
<p>An optional pre-computed UMAP model. Default is NULL.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_recompute.neighbors">recompute.neighbors</code></td>
<td>
<p>Whether to recompute the neighbors for label transfer. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_recompute.weights">recompute.weights</code></td>
<td>
<p>Whether to recompute the weights for label transfer. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ProjectData_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and diagnostic messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with the full data projected onto the sketched dimensional reduction results.
The projected data are stored in the specified full reduction.
</p>

<hr>
<h2 id='ProjectDim'>Project Dimensional reduction onto full dataset</h2><span id='topic+ProjectDim'></span>

<h3>Description</h3>

<p>Takes a pre-computed dimensional reduction (typically calculated on a subset
of genes) and projects this onto the entire dataset (all genes). Note that
the cell loadings will remain unchanged, but now there are gene loadings for
all genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectDim(
  object,
  reduction = "pca",
  assay = NULL,
  dims.print = 1:5,
  nfeatures.print = 20,
  overwrite = FALSE,
  do.center = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectDim_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_reduction">reduction</code></td>
<td>
<p>Reduction to use</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_assay">assay</code></td>
<td>
<p>Assay to use</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_dims.print">dims.print</code></td>
<td>
<p>Number of dims to print features for</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_nfeatures.print">nfeatures.print</code></td>
<td>
<p>Number of features with highest/lowest loadings to print for
each dimension</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_overwrite">overwrite</code></td>
<td>
<p>Replace the existing data in feature.loadings</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_do.center">do.center</code></td>
<td>
<p>Center the dataset prior to projection (should be set to TRUE)</p>
</td></tr>
<tr><td><code id="ProjectDim_+3A_verbose">verbose</code></td>
<td>
<p>Print top genes associated with the projected dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Seurat object with the projected values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small
pbmc_small &lt;- ProjectDim(object = pbmc_small, reduction = "pca")
# Vizualize top projected genes in heatmap
DimHeatmap(object = pbmc_small, reduction = "pca", dims = 1, balanced = TRUE)

</code></pre>

<hr>
<h2 id='ProjectDimReduc'>Project query data to reference dimensional reduction</h2><span id='topic+ProjectDimReduc'></span>

<h3>Description</h3>

<p>Project query data to reference dimensional reduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectDimReduc(
  query,
  reference,
  mode = c("pcaproject", "lsiproject"),
  reference.reduction,
  combine = FALSE,
  query.assay = NULL,
  reference.assay = NULL,
  features = NULL,
  do.scale = TRUE,
  reduction.name = NULL,
  reduction.key = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectDimReduc_+3A_query">query</code></td>
<td>
<p>Query object</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_reference">reference</code></td>
<td>
<p>Reference object</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_mode">mode</code></td>
<td>
<p>Projection mode name for projection
</p>

<ul>
<li><p>pcaproject: PCA projection
</p>
</li>
<li><p>lsiproject: LSI projection
</p>
</li></ul>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_reference.reduction">reference.reduction</code></td>
<td>
<p>Name of dimensional reduction in the reference object</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_combine">combine</code></td>
<td>
<p>Determine if query and reference objects are combined</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_query.assay">query.assay</code></td>
<td>
<p>Assay used for query object</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_reference.assay">reference.assay</code></td>
<td>
<p>Assay used for reference object</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_features">features</code></td>
<td>
<p>Features used for projection</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_do.scale">do.scale</code></td>
<td>
<p>Determine if scale expression matrix in the pcaproject mode</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name, reference.reduction is used by default</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, the key in reference.reduction
is used by default</p>
</td></tr>
<tr><td><code id="ProjectDimReduc_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a query-only or query-reference combined seurat object
</p>

<hr>
<h2 id='ProjectIntegration'>Integrate embeddings from the integrated sketched.assay</h2><span id='topic+ProjectIntegration'></span>

<h3>Description</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Hao,  et al Biorxiv 2022:
<a href="https://doi.org/10.1101/2022.02.24.481684">doi:10.1101/2022.02.24.481684</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjectIntegration(
  object,
  sketched.assay = "sketch",
  assay = "RNA",
  reduction = "integrated_dr",
  features = NULL,
  layers = "data",
  reduction.name = NULL,
  reduction.key = NULL,
  method = c("sketch", "data"),
  ratio = 0.8,
  sketched.layers = NULL,
  seed = 123,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectIntegration_+3A_object">object</code></td>
<td>
<p>A Seurat object with all cells for one dataset</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_sketched.assay">sketched.assay</code></td>
<td>
<p>Assay name for sketched-cell expression (default is 'sketch')</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_assay">assay</code></td>
<td>
<p>Assay name for original expression (default is 'RNA')</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction name for batch-corrected embeddings
in the sketched object (default is 'integrated_dr')</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_features">features</code></td>
<td>
<p>Features used for atomic sketch integration</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_layers">layers</code></td>
<td>
<p>Names of layers for correction.</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_reduction.name">reduction.name</code></td>
<td>
<p>Name to save new reduction as; defaults to
<code>paste0(reduction, '.orig')</code></p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_reduction.key">reduction.key</code></td>
<td>
<p>Key for new dimensional reduction; defaults to creating
one from <code>reduction.name</code></p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_method">method</code></td>
<td>
<p>Methods to construct sketch-cell representation
for all cells (default is 'sketch'). Can be one of:
</p>

<ul>
<li> <p>&ldquo;<code>sketch</code>&rdquo;: Use random sketched data slot
</p>
</li>
<li> <p>&ldquo;<code>data</code>&rdquo;: Use data slot
</p>
</li></ul>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_ratio">ratio</code></td>
<td>
<p>Sketch ratio of data slot when <code>dictionary.method</code> is set
to &ldquo;<code>sketch</code>&rdquo;; defaults to 0.8</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_sketched.layers">sketched.layers</code></td>
<td>
<p>Names of sketched layers, defaults to all
layers of &ldquo;<code>object[[assay]]</code>&rdquo;</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_seed">seed</code></td>
<td>
<p>A positive integer. The seed for the random number generator, defaults to 123.</p>
</td></tr>
<tr><td><code id="ProjectIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First learn a atom dictionary representation to reconstruct each cell.
Then, using this dictionary representation,
reconstruct the embeddings of each cell from the integrated atoms.
</p>


<h3>Value</h3>

<p>Returns a Seurat object with an integrated dimensional reduction
</p>

<hr>
<h2 id='ProjectUMAP'>Project query into UMAP coordinates of a reference</h2><span id='topic+ProjectUMAP'></span><span id='topic+ProjectUMAP.default'></span><span id='topic+ProjectUMAP.DimReduc'></span><span id='topic+ProjectUMAP.Seurat'></span>

<h3>Description</h3>

<p>This function will take a query dataset and project it into the coordinates
of a provided reference UMAP. This is essentially a wrapper around two steps:
</p>

<ul>
<li><p>FindNeighbors - Find the nearest reference cell neighbors and their
distances for each query cell.
</p>
</li>
<li><p>RunUMAP - Perform umap projection by providing the neighbor set
calculated above and the umap model previously computed in the reference.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ProjectUMAP(query, ...)

## Default S3 method:
ProjectUMAP(
  query,
  query.dims = NULL,
  reference,
  reference.dims = NULL,
  k.param = 30,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "cosine",
  l2.norm = FALSE,
  cache.index = TRUE,
  index = NULL,
  neighbor.name = "query_ref.nn",
  reduction.model,
  ...
)

## S3 method for class 'DimReduc'
ProjectUMAP(
  query,
  query.dims = NULL,
  reference,
  reference.dims = NULL,
  k.param = 30,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "cosine",
  l2.norm = FALSE,
  cache.index = TRUE,
  index = NULL,
  neighbor.name = "query_ref.nn",
  reduction.model,
  ...
)

## S3 method for class 'Seurat'
ProjectUMAP(
  query,
  query.reduction,
  query.dims = NULL,
  reference,
  reference.reduction,
  reference.dims = NULL,
  k.param = 30,
  nn.method = "annoy",
  n.trees = 50,
  annoy.metric = "cosine",
  l2.norm = FALSE,
  cache.index = TRUE,
  index = NULL,
  neighbor.name = "query_ref.nn",
  reduction.model,
  reduction.name = "ref.umap",
  reduction.key = "refUMAP_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjectUMAP_+3A_query">query</code></td>
<td>
<p>Query dataset</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="#topic+RunUMAP">RunUMAP</a></code></p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_query.dims">query.dims</code></td>
<td>
<p>Dimensions (columns) to use from query</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_reference">reference</code></td>
<td>
<p>Reference dataset</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_reference.dims">reference.dims</code></td>
<td>
<p>Dimensions (columns) to use from reference</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_k.param">k.param</code></td>
<td>
<p>Defines k for the k-nearest neighbor algorithm</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_nn.method">nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann,
annoy</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_n.trees">n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_annoy.metric">annoy.metric</code></td>
<td>
<p>Distance metric for annoy. Options include: euclidean,
cosine, manhattan, and hamming</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Take L2Norm of the data</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_cache.index">cache.index</code></td>
<td>
<p>Include cached index in returned Neighbor object
(only relevant if return.neighbor = TRUE)</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_index">index</code></td>
<td>
<p>Precomputed index. Useful if querying new data against existing
index to avoid recomputing.</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_neighbor.name">neighbor.name</code></td>
<td>
<p>Name to store neighbor information in the query</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_reduction.model">reduction.model</code></td>
<td>
<p><code>DimReduc</code> object that contains the umap model</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_query.reduction">query.reduction</code></td>
<td>
<p>Name of reduction to use from the query for neighbor
finding</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_reference.reduction">reference.reduction</code></td>
<td>
<p>Name of reduction to use from the reference for
neighbor finding</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_reduction.name">reduction.name</code></td>
<td>
<p>Name of projected UMAP to store in the query</p>
</td></tr>
<tr><td><code id="ProjectUMAP_+3A_reduction.key">reduction.key</code></td>
<td>
<p>Value for the projected UMAP key</p>
</td></tr>
</table>

<hr>
<h2 id='PseudobulkExpression'>Pseudobulk Expression</h2><span id='topic+PseudobulkExpression'></span>

<h3>Description</h3>

<p>Normalize the count data present in a given assay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PseudobulkExpression(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PseudobulkExpression_+3A_object">object</code></td>
<td>
<p>An assay</p>
</td></tr>
<tr><td><code id="PseudobulkExpression_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object after normalization
</p>

<hr>
<h2 id='Radius.SlideSeq'>Get Spot Radius</h2><span id='topic+Radius.SlideSeq'></span><span id='topic+Radius.STARmap'></span><span id='topic+Radius.VisiumV1'></span>

<h3>Description</h3>

<p>Get Spot Radius
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SlideSeq'
Radius(object)

## S3 method for class 'STARmap'
Radius(object)

## S3 method for class 'VisiumV1'
Radius(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Radius.SlideSeq_+3A_object">object</code></td>
<td>
<p>An image object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+Radius">SeuratObject::Radius</a></code>
</p>

<hr>
<h2 id='Read10X'>Load in data from 10X</h2><span id='topic+Read10X'></span>

<h3>Description</h3>

<p>Enables easy loading of sparse data matrices provided by 10X genomics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read10X(
  data.dir,
  gene.column = 2,
  cell.column = 1,
  unique.features = TRUE,
  strip.suffix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read10X_+3A_data.dir">data.dir</code></td>
<td>
<p>Directory containing the matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv
files provided by 10X. A vector or named vector can be given in order to load
several data directories. If a named vector is given, the cell barcode names
will be prefixed with the name.</p>
</td></tr>
<tr><td><code id="Read10X_+3A_gene.column">gene.column</code></td>
<td>
<p>Specify which column of genes.tsv or features.tsv to use for gene names; default is 2</p>
</td></tr>
<tr><td><code id="Read10X_+3A_cell.column">cell.column</code></td>
<td>
<p>Specify which column of barcodes.tsv to use for cell names; default is 1</p>
</td></tr>
<tr><td><code id="Read10X_+3A_unique.features">unique.features</code></td>
<td>
<p>Make feature names unique (default TRUE)</p>
</td></tr>
<tr><td><code id="Read10X_+3A_strip.suffix">strip.suffix</code></td>
<td>
<p>Remove trailing &quot;-1&quot; if present in all cell barcodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If features.csv indicates the data has multiple data types, a list
containing a sparse matrix of the data from each type will be returned.
Otherwise a sparse matrix containing the expression data will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For output from CellRanger &lt; 3.0
data_dir &lt;- 'path/to/data/directory'
list.files(data_dir) # Should show barcodes.tsv, genes.tsv, and matrix.mtx
expression_matrix &lt;- Read10X(data.dir = data_dir)
seurat_object = CreateSeuratObject(counts = expression_matrix)

# For output from CellRanger &gt;= 3.0 with multiple data types
data_dir &lt;- 'path/to/data/directory'
list.files(data_dir) # Should show barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz
data &lt;- Read10X(data.dir = data_dir)
seurat_object = CreateSeuratObject(counts = data$`Gene Expression`)
seurat_object[['Protein']] = CreateAssayObject(counts = data$`Antibody Capture`)

## End(Not run)

</code></pre>

<hr>
<h2 id='Read10X_h5'>Read 10X hdf5 file</h2><span id='topic+Read10X_h5'></span>

<h3>Description</h3>

<p>Read count matrix from 10X CellRanger hdf5 file.
This can be used to read both scATAC-seq and scRNA-seq matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read10X_h5(filename, use.names = TRUE, unique.features = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read10X_h5_+3A_filename">filename</code></td>
<td>
<p>Path to h5 file</p>
</td></tr>
<tr><td><code id="Read10X_h5_+3A_use.names">use.names</code></td>
<td>
<p>Label row names with feature names rather than ID numbers.</p>
</td></tr>
<tr><td><code id="Read10X_h5_+3A_unique.features">unique.features</code></td>
<td>
<p>Make feature names unique (default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sparse matrix with rows and columns labeled. If multiple
genomes are present, returns a list of sparse matrices (one per genome).
</p>

<hr>
<h2 id='Read10X_Image'>Load a 10X Genomics Visium Image</h2><span id='topic+Read10X_Image'></span>

<h3>Description</h3>

<p>Load a 10X Genomics Visium Image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read10X_Image(image.dir, filter.matrix = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read10X_Image_+3A_image.dir">image.dir</code></td>
<td>
<p>Path to directory with 10X Genomics visium image data;
should include files <code>tissue_lowres_iamge.png</code>,
<code>scalefactors_json.json</code> and <code>tissue_positions_list.csv</code></p>
</td></tr>
<tr><td><code id="Read10X_Image_+3A_filter.matrix">filter.matrix</code></td>
<td>
<p>Filter spot/feature matrix to only include spots that
have been determined to be over tissue.</p>
</td></tr>
<tr><td><code id="Read10X_Image_+3A_...">...</code></td>
<td>
<p>Ignored for now</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+VisiumV1">VisiumV1</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VisiumV1">VisiumV1</a></code> <code><a href="#topic+Load10X_Spatial">Load10X_Spatial</a></code>
</p>

<hr>
<h2 id='Read10X_probe_metadata'>Read10x Probe Metadata</h2><span id='topic+Read10X_probe_metadata'></span>

<h3>Description</h3>

<p>This function reads the probe metadata from a 10x Genomics probe barcode matrix file in HDF5 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read10X_probe_metadata(data.dir, filename = "raw_probe_bc_matrix.h5")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read10X_probe_metadata_+3A_data.dir">data.dir</code></td>
<td>
<p>The directory where the file is located.</p>
</td></tr>
<tr><td><code id="Read10X_probe_metadata_+3A_filename">filename</code></td>
<td>
<p>The name of the file containing the raw probe barcode matrix in HDF5 format. The default filename is 'raw_probe_bc_matrix.h5'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame containing the probe metadata.
</p>

<hr>
<h2 id='ReadAkoya'>Read and Load Akoya CODEX data</h2><span id='topic+ReadAkoya'></span><span id='topic+LoadAkoya'></span>

<h3>Description</h3>

<p>Read and Load Akoya CODEX data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadAkoya(
  filename,
  type = c("inform", "processor", "qupath"),
  filter = "DAPI|Blank|Empty",
  inform.quant = c("mean", "total", "min", "max", "std")
)

LoadAkoya(
  filename,
  type = c("inform", "processor", "qupath"),
  fov,
  assay = "Akoya",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadAkoya_+3A_filename">filename</code></td>
<td>
<p>Path to matrix generated by upstream processing.</p>
</td></tr>
<tr><td><code id="ReadAkoya_+3A_type">type</code></td>
<td>
<p>Specify which type matrix is being provided.
</p>

<ul>
<li> <p>&ldquo;<code>processor</code>&rdquo;: matrix generated by CODEX Processor
</p>
</li>
<li> <p>&ldquo;<code>inform</code>&rdquo;: matrix generated by inForm
</p>
</li>
<li> <p>&ldquo;<code>qupath</code>&rdquo;: matrix generated by QuPath
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadAkoya_+3A_filter">filter</code></td>
<td>
<p>A pattern to filter features by; pass <code>NA</code> to
skip feature filtering</p>
</td></tr>
<tr><td><code id="ReadAkoya_+3A_inform.quant">inform.quant</code></td>
<td>
<p>When <code>type</code> is &ldquo;<code>inform</code>&rdquo;, the
quantification level to read in</p>
</td></tr>
<tr><td><code id="ReadAkoya_+3A_fov">fov</code></td>
<td>
<p>Name to store FOV as</p>
</td></tr>
<tr><td><code id="ReadAkoya_+3A_assay">assay</code></td>
<td>
<p>Name to store expression matrix as</p>
</td></tr>
<tr><td><code id="ReadAkoya_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ReadAkoya</code>: A list with some combination of the following values
</p>

<ul>
<li> <p>&ldquo;<code>matrix</code>&rdquo;: a
<a href="Matrix.html#topic+dgCMatrix-class">sparse matrix</a> with expression data; cells
are columns and features are rows
</p>
</li>
<li> <p>&ldquo;<code>centroids</code>&rdquo;: a data frame with cell centroid
coordinates in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>metadata</code>&rdquo;: a data frame with cell-level meta data;
includes all columns in <code>filename</code> that aren't in
&ldquo;<code>matrix</code>&rdquo; or &ldquo;<code>centroids</code>&rdquo;
</p>
</li></ul>

<p>When <code>type</code> is &ldquo;<code>inform</code>&rdquo;, additional expression matrices
are returned and named using their segmentation type (eg.
&ldquo;nucleus&rdquo;, &ldquo;membrane&rdquo;). The &ldquo;Entire Cell&rdquo; segmentation
type is returned in the &ldquo;<code>matrix</code>&rdquo; entry of the list
</p>
<p><code>LoadAkoya</code>: A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Progress Updates with <span class="pkg">progressr</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=progressr"><span class="pkg">progressr</span></a> to
render status updates and progress bars. To enable progress updates, wrap
the function call in <code><a href="progressr.html#topic+with_progress">with_progress</a></code> or run
<code><a href="progressr.html#topic+handlers">handlers(global = TRUE)</a></code> before running
this function. For more details about <span class="pkg">progressr</span>, please read
<a href="https://progressr.futureverse.org/articles/progressr-intro.html"><code>vignette("progressr-intro")</code></a>
</p>


<h3>Note</h3>

<p>This function requires the
<a href="https://cran.r-project.org/package=data.table"><span class="pkg">data.table</span></a> package
to be installed
</p>

<hr>
<h2 id='ReadMtx'>Load in data from remote or local mtx files</h2><span id='topic+ReadMtx'></span>

<h3>Description</h3>

<p>Enables easy loading of sparse data matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadMtx(
  mtx,
  cells,
  features,
  cell.column = 1,
  feature.column = 2,
  cell.sep = "\t",
  feature.sep = "\t",
  skip.cell = 0,
  skip.feature = 0,
  mtx.transpose = FALSE,
  unique.features = TRUE,
  strip.suffix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadMtx_+3A_mtx">mtx</code></td>
<td>
<p>Name or remote URL of the mtx file</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_cells">cells</code></td>
<td>
<p>Name or remote URL of the cells/barcodes file</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_features">features</code></td>
<td>
<p>Name or remote URL of the features/genes file</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_cell.column">cell.column</code></td>
<td>
<p>Specify which column of cells file to use for cell names; default is 1</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_feature.column">feature.column</code></td>
<td>
<p>Specify which column of features files to use for feature/gene names; default is 2</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_cell.sep">cell.sep</code></td>
<td>
<p>Specify the delimiter in the cell name file</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_feature.sep">feature.sep</code></td>
<td>
<p>Specify the delimiter in the feature name file</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_skip.cell">skip.cell</code></td>
<td>
<p>Number of lines to skip in the cells file before beginning to read cell names</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_skip.feature">skip.feature</code></td>
<td>
<p>Number of lines to skip in the features file before beginning to gene names</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_mtx.transpose">mtx.transpose</code></td>
<td>
<p>Transpose the matrix after reading in</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_unique.features">unique.features</code></td>
<td>
<p>Make feature names unique (default TRUE)</p>
</td></tr>
<tr><td><code id="ReadMtx_+3A_strip.suffix">strip.suffix</code></td>
<td>
<p>Remove trailing &quot;-1&quot; if present in all cell barcodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix containing the expression data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For local files:

expression_matrix &lt;- ReadMtx(
  mtx = "count_matrix.mtx.gz", features = "features.tsv.gz",
  cells = "barcodes.tsv.gz"
)
seurat_object &lt;- CreateSeuratObject(counts = expression_matrix)

# For remote files:

expression_matrix &lt;- ReadMtx(mtx = "http://localhost/matrix.mtx",
cells = "http://localhost/barcodes.tsv",
features = "http://localhost/genes.tsv")
seurat_object &lt;- CreateSeuratObject(counts = data)

## End(Not run)

</code></pre>

<hr>
<h2 id='ReadNanostring'>Read and Load Nanostring SMI data</h2><span id='topic+ReadNanostring'></span><span id='topic+LoadNanostring'></span>

<h3>Description</h3>

<p>Read and Load Nanostring SMI data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadNanostring(
  data.dir,
  mtx.file = NULL,
  metadata.file = NULL,
  molecules.file = NULL,
  segmentations.file = NULL,
  type = "centroids",
  mol.type = "pixels",
  metadata = NULL,
  mols.filter = NA_character_,
  genes.filter = NA_character_,
  fov.filter = NULL,
  subset.counts.matrix = NULL,
  cell.mols.only = TRUE
)

LoadNanostring(data.dir, fov, assay = "Nanostring")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadNanostring_+3A_data.dir">data.dir</code></td>
<td>
<p>Path to folder containing Nanostring SMI outputs</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_mtx.file">mtx.file</code></td>
<td>
<p>Path to Nanostring cell x gene matrix CSV</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_metadata.file">metadata.file</code></td>
<td>
<p>Contains metadata including cell center, area,
and stain intensities</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_molecules.file">molecules.file</code></td>
<td>
<p>Path to molecules file</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_segmentations.file">segmentations.file</code></td>
<td>
<p>Path to segmentations CSV</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_type">type</code></td>
<td>
<p>Type of cell spatial coordinate matrices to read; choose one
or more of:
</p>

<ul>
<li> <p>&ldquo;centroids&rdquo;: cell centroids in pixel coordinate space
</p>
</li>
<li> <p>&ldquo;segmentations&rdquo;: cell segmentations in pixel coordinate space
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_mol.type">mol.type</code></td>
<td>
<p>Type of molecule spatial coordinate matrices to read;
choose one or more of:
</p>

<ul>
<li> <p>&ldquo;pixels&rdquo;: molecule coordinates in pixel space
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_metadata">metadata</code></td>
<td>
<p>Type of available metadata to read;
choose zero or more of:
</p>

<ul>
<li> <p>&ldquo;Area&rdquo;: number of pixels in cell segmentation
</p>
</li>
<li> <p>&ldquo;fov&rdquo;: cell's fov
</p>
</li>
<li> <p>&ldquo;Mean.MembraneStain&rdquo;: mean membrane stain intensity
</p>
</li>
<li> <p>&ldquo;Mean.DAPI&rdquo;: mean DAPI stain intensity
</p>
</li>
<li> <p>&ldquo;Mean.G&rdquo;: mean green channel stain intensity
</p>
</li>
<li> <p>&ldquo;Mean.Y&rdquo;: mean yellow channel stain intensity
</p>
</li>
<li> <p>&ldquo;Mean.R&rdquo;: mean red channel stain intensity
</p>
</li>
<li> <p>&ldquo;Max.MembraneStain&rdquo;: max membrane stain intensity
</p>
</li>
<li> <p>&ldquo;Max.DAPI&rdquo;: max DAPI stain intensity
</p>
</li>
<li> <p>&ldquo;Max.G&rdquo;: max green channel stain intensity
</p>
</li>
<li> <p>&ldquo;Max.Y&rdquo;: max yellow stain intensity
</p>
</li>
<li> <p>&ldquo;Max.R&rdquo;: max red stain intensity
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_mols.filter">mols.filter</code></td>
<td>
<p>Filter molecules that match provided string</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_genes.filter">genes.filter</code></td>
<td>
<p>Filter genes from cell x gene matrix that match
provided string</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_fov.filter">fov.filter</code></td>
<td>
<p>Only load in select FOVs. Nanostring SMI data contains
30 total FOVs.</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_subset.counts.matrix">subset.counts.matrix</code></td>
<td>
<p>If the counts matrix should be built from
molecule coordinates for a specific segmentation; One of:
</p>

<ul>
<li> <p>&ldquo;Nuclear&rdquo;: nuclear segmentations
</p>
</li>
<li> <p>&ldquo;Cytoplasm&rdquo;: cell cytoplasm segmentations
</p>
</li>
<li> <p>&ldquo;Membrane&rdquo;: cell membrane segmentations
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_cell.mols.only">cell.mols.only</code></td>
<td>
<p>If TRUE, only load molecules within a cell</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_fov">fov</code></td>
<td>
<p>Name to store FOV as</p>
</td></tr>
<tr><td><code id="ReadNanostring_+3A_assay">assay</code></td>
<td>
<p>Name to store expression matrix as</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ReadNanostring</code>: A list with some combination of the
following values:
</p>

<ul>
<li> <p>&ldquo;<code>matrix</code>&rdquo;: a
<a href="Matrix.html#topic+dgCMatrix-class">sparse matrix</a> with expression data; cells
are columns and features are rows
</p>
</li>
<li> <p>&ldquo;<code>centroids</code>&rdquo;: a data frame with cell centroid
coordinates in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>pixels</code>&rdquo;: a data frame with molecule pixel coordinates
in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;gene&rdquo;
</p>
</li></ul>

<p><code>LoadNanostring</code>: A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Progress Updates with <span class="pkg">progressr</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=progressr"><span class="pkg">progressr</span></a> to
render status updates and progress bars. To enable progress updates, wrap
the function call in <code><a href="progressr.html#topic+with_progress">with_progress</a></code> or run
<code><a href="progressr.html#topic+handlers">handlers(global = TRUE)</a></code> before running
this function. For more details about <span class="pkg">progressr</span>, please read
<a href="https://progressr.futureverse.org/articles/progressr-intro.html"><code>vignette("progressr-intro")</code></a>
</p>


<h3>Parallelization with <span class="pkg">future</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=future"><span class="pkg">future</span></a> to enable
parallelization. Parallelization strategies can be set using
<code><a href="future.html#topic+plan">plan</a></code>. Common plans include &ldquo;<code>sequential</code>&rdquo;
for non-parallelized processing or &ldquo;<code>multisession</code>&rdquo; for parallel
evaluation using multiple <span class="rlang"><b>R</b></span> sessions; for other plans, see the
&ldquo;Implemented evaluation strategies&rdquo; section of
<code><a href="future.html#topic+plan">?future::plan</a></code>. For a more thorough introduction
to <span class="pkg">future</span>, see
<a href="https://future.futureverse.org/articles/future-1-overview.html"><code>vignette("future-1-overview")</code></a>
</p>


<h3>Note</h3>

<p>This function requires the
<a href="https://cran.r-project.org/package=data.table"><span class="pkg">data.table</span></a> package
to be installed
</p>

<hr>
<h2 id='ReadParseBio'>Read output from Parse Biosciences</h2><span id='topic+ReadParseBio'></span>

<h3>Description</h3>

<p>Read output from Parse Biosciences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadParseBio(data.dir, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadParseBio_+3A_data.dir">data.dir</code></td>
<td>
<p>Directory containing the data files</p>
</td></tr>
<tr><td><code id="ReadParseBio_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+ReadMtx">ReadMtx</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='ReadSlideSeq'>Load Slide-seq spatial data</h2><span id='topic+ReadSlideSeq'></span>

<h3>Description</h3>

<p>Load Slide-seq spatial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadSlideSeq(coord.file, assay = "Spatial")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadSlideSeq_+3A_coord.file">coord.file</code></td>
<td>
<p>Path to csv file containing bead coordinate positions</p>
</td></tr>
<tr><td><code id="ReadSlideSeq_+3A_assay">assay</code></td>
<td>
<p>Name of assay to associate image to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+SlideSeq">SlideSeq</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SlideSeq">SlideSeq</a></code>
</p>

<hr>
<h2 id='ReadSTARsolo'>Read output from STARsolo</h2><span id='topic+ReadSTARsolo'></span>

<h3>Description</h3>

<p>Read output from STARsolo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadSTARsolo(data.dir, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadSTARsolo_+3A_data.dir">data.dir</code></td>
<td>
<p>Directory containing the data files</p>
</td></tr>
<tr><td><code id="ReadSTARsolo_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+ReadMtx">ReadMtx</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='ReadVitessce'>Read Data From Vitessce</h2><span id='topic+ReadVitessce'></span><span id='topic+LoadHuBMAPCODEX'></span>

<h3>Description</h3>

<p>Read in data from Vitessce-formatted JSON files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadVitessce(
  counts = NULL,
  coords = NULL,
  molecules = NULL,
  type = c("segmentations", "centroids"),
  filter = NA_character_
)

LoadHuBMAPCODEX(data.dir, fov, assay = "CODEX")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadVitessce_+3A_counts">counts</code></td>
<td>
<p>Path or URL to a Vitessce-formatted JSON file with
expression data; should end in &ldquo;<code>.genes.json</code>&rdquo; or
&ldquo;<code>.clusters.json</code>&rdquo;; pass <code>NULL</code> to skip</p>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_coords">coords</code></td>
<td>
<p>Path or URL to a Vitessce-formatted JSON file with cell/spot
spatial coordinates; should end in &ldquo;<code>.cells.json</code>&rdquo;;
pass <code>NULL</code> to skip</p>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_molecules">molecules</code></td>
<td>
<p>Path or URL to a Vitessce-formatted JSON file with molecule
spatial coordinates; should end in &ldquo;<code>.molecules.json</code>&rdquo;;
pass <code>NULL</code> to skip</p>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_type">type</code></td>
<td>
<p>Type of cell/spot spatial coordinates to return,
choose one or more from:
</p>

<ul>
<li> <p>&ldquo;segmentations&rdquo; cell/spot segmentations
</p>
</li>
<li> <p>&ldquo;centroids&rdquo; cell/spot centroids
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_filter">filter</code></td>
<td>
<p>A character to filter molecules by, pass <code>NA</code> to skip
molecule filtering</p>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_data.dir">data.dir</code></td>
<td>
<p>Path to a directory containing Vitessce cells
and clusters JSONs</p>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_fov">fov</code></td>
<td>
<p>Name to store FOV as</p>
</td></tr>
<tr><td><code id="ReadVitessce_+3A_assay">assay</code></td>
<td>
<p>Name to store expression matrix as</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ReadVitessce</code>: A list with some combination of the
following values:
</p>

<ul>
<li> <p>&ldquo;<code>counts</code>&rdquo;: if <code>counts</code> is not <code>NULL</code>, an
expression matrix with cells as columns and features as rows
</p>
</li>
<li> <p>&ldquo;<code>centroids</code>&rdquo;: if <code>coords</code> is not <code>NULL</code> and
<code>type</code> is contains&ldquo;centroids&rdquo;, a data frame with cell centroids
in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>segmentations</code>&rdquo;: if <code>coords</code> is not <code>NULL</code> and
<code>type</code> contains &ldquo;centroids&rdquo;, a data frame with cell
segmentations in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo; and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>molecules</code>&rdquo;: if <code>molecules</code> is not <code>NULL</code>, a
data frame with molecule spatial coordinates in three columns: &ldquo;x&rdquo;,
&ldquo;y&rdquo;, and &ldquo;gene&rdquo;
</p>
</li></ul>

<p><code>LoadHuBMAPCODEX</code>: A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Progress Updates with <span class="pkg">progressr</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=progressr"><span class="pkg">progressr</span></a> to
render status updates and progress bars. To enable progress updates, wrap
the function call in <code><a href="progressr.html#topic+with_progress">with_progress</a></code> or run
<code><a href="progressr.html#topic+handlers">handlers(global = TRUE)</a></code> before running
this function. For more details about <span class="pkg">progressr</span>, please read
<a href="https://progressr.futureverse.org/articles/progressr-intro.html"><code>vignette("progressr-intro")</code></a>
</p>


<h3>Note</h3>

<p>This function requires the
<a href="https://cran.r-project.org/package=jsonlite"><span class="pkg">jsonlite</span></a> package
to be installed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
coords &lt;- ReadVitessce(
  counts =
     "https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/wang/wang.genes.json",
  coords =
     "https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/wang/wang.cells.json",
  molecules =
     "https://s3.amazonaws.com/vitessce-data/0.0.31/master_release/wang/wang.molecules.json"
)
names(coords)
coords$counts[1:10, 1:10]
head(coords$centroids)
head(coords$segmentations)
head(coords$molecules)

## End(Not run)

</code></pre>

<hr>
<h2 id='ReadVizgen'>Read and Load MERFISH Input from Vizgen</h2><span id='topic+ReadVizgen'></span><span id='topic+LoadVizgen'></span>

<h3>Description</h3>

<p>Read and load in MERFISH data from Vizgen-formatted files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadVizgen(
  data.dir,
  transcripts = NULL,
  spatial = NULL,
  molecules = NULL,
  type = "segmentations",
  mol.type = "microns",
  metadata = NULL,
  filter = NA_character_,
  z = 3L
)

LoadVizgen(data.dir, fov, assay = "Vizgen", z = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadVizgen_+3A_data.dir">data.dir</code></td>
<td>
<p>Path to the directory with Vizgen MERFISH files; requires at
least one of the following files present:
</p>

<ul>
<li> <p>&ldquo;<code>cell_by_gene.csv</code>&rdquo;: used for reading count matrix
</p>
</li>
<li> <p>&ldquo;<code>cell_metadata.csv</code>&rdquo;: used for reading cell spatial
coordinate matrices
</p>
</li>
<li> <p>&ldquo;<code>detected_transcripts.csv</code>&rdquo;: used for reading molecule
spatial coordinate matrices
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_transcripts">transcripts</code></td>
<td>
<p>Optional file path for counts matrix; pass <code>NA</code> to
suppress reading counts matrix</p>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_spatial">spatial</code></td>
<td>
<p>Optional file path for spatial metadata; pass <code>NA</code> to
suppress reading spatial coordinates. If <code>spatial</code> is provided and
<code>type</code> is &ldquo;segmentations&rdquo;, uses <code>dirname(spatial)</code> instead of
<code>data.dir</code> to find HDF5 files</p>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_molecules">molecules</code></td>
<td>
<p>Optional file path for molecule coordinates file; pass
<code>NA</code> to suppress reading spatial molecule information</p>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_type">type</code></td>
<td>
<p>Type of cell spatial coordinate matrices to read; choose one
or more of:
</p>

<ul>
<li> <p>&ldquo;segmentations&rdquo;: cell segmentation vertices; requires
<a href="https://cran.r-project.org/package=hdf5r"><span class="pkg">hdf5r</span></a> to be
installed and requires a directory &ldquo;<code>cell_boundaries</code>&rdquo; within
<code>data.dir</code>. Within &ldquo;<code>cell_boundaries</code>&rdquo;, there must be
one or more HDF5 file named &ldquo;<code>feature_data_##.hdf5</code>&rdquo;
</p>
</li>
<li> <p>&ldquo;centroids&rdquo;: cell centroids in micron coordinate space
</p>
</li>
<li> <p>&ldquo;boxes&rdquo;: cell box outlines in micron coordinate space
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_mol.type">mol.type</code></td>
<td>
<p>Type of molecule spatial coordinate matrices to read;
choose one or more of:
</p>

<ul>
<li> <p>&ldquo;pixels&rdquo;: molecule coordinates in pixel space
</p>
</li>
<li> <p>&ldquo;microns&rdquo;: molecule coordinates in micron space
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_metadata">metadata</code></td>
<td>
<p>Type of available metadata to read;
choose zero or more of:
</p>

<ul>
<li> <p>&ldquo;volume&rdquo;: estimated cell volume
</p>
</li>
<li> <p>&ldquo;fov&rdquo;: cell's fov
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_filter">filter</code></td>
<td>
<p>A character to filter molecules by, pass <code>NA</code> to skip
molecule filtering</p>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_z">z</code></td>
<td>
<p>Z-index to load; must be between 0 and 6, inclusive</p>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_fov">fov</code></td>
<td>
<p>Name to store FOV as</p>
</td></tr>
<tr><td><code id="ReadVizgen_+3A_assay">assay</code></td>
<td>
<p>Name to store expression matrix as</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ReadVizgen</code>: A list with some combination of the
following values:
</p>

<ul>
<li> <p>&ldquo;<code>transcripts</code>&rdquo;: a
<a href="Matrix.html#topic+dgCMatrix-class">sparse matrix</a> with expression data; cells
are columns and features are rows
</p>
</li>
<li> <p>&ldquo;<code>segmentations</code>&rdquo;: a data frame with cell polygon outlines in
three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>centroids</code>&rdquo;: a data frame with cell centroid
coordinates in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>boxes</code>&rdquo;: a data frame with cell box outlines in three
columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;cell&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>microns</code>&rdquo;: a data frame with molecule micron
coordinates in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;gene&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>pixels</code>&rdquo;: a data frame with molecule pixel coordinates
in three columns: &ldquo;x&rdquo;, &ldquo;y&rdquo;, and &ldquo;gene&rdquo;
</p>
</li>
<li> <p>&ldquo;<code>metadata</code>&rdquo;: a data frame with the cell-level metadata
requested by <code>metadata</code>
</p>
</li></ul>

<p><code>LoadVizgen</code>: A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Progress Updates with <span class="pkg">progressr</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=progressr"><span class="pkg">progressr</span></a> to
render status updates and progress bars. To enable progress updates, wrap
the function call in <code><a href="progressr.html#topic+with_progress">with_progress</a></code> or run
<code><a href="progressr.html#topic+handlers">handlers(global = TRUE)</a></code> before running
this function. For more details about <span class="pkg">progressr</span>, please read
<a href="https://progressr.futureverse.org/articles/progressr-intro.html"><code>vignette("progressr-intro")</code></a>
</p>


<h3>Parallelization with <span class="pkg">future</span></h3>

<p>This function uses
<a href="https://cran.r-project.org/package=future"><span class="pkg">future</span></a> to enable
parallelization. Parallelization strategies can be set using
<code><a href="future.html#topic+plan">plan</a></code>. Common plans include &ldquo;<code>sequential</code>&rdquo;
for non-parallelized processing or &ldquo;<code>multisession</code>&rdquo; for parallel
evaluation using multiple <span class="rlang"><b>R</b></span> sessions; for other plans, see the
&ldquo;Implemented evaluation strategies&rdquo; section of
<code><a href="future.html#topic+plan">?future::plan</a></code>. For a more thorough introduction
to <span class="pkg">future</span>, see
<a href="https://future.futureverse.org/articles/future-1-overview.html"><code>vignette("future-1-overview")</code></a>
</p>


<h3>Note</h3>

<p>This function requires the
<a href="https://cran.r-project.org/package=data.table"><span class="pkg">data.table</span></a> package
to be installed
</p>

<hr>
<h2 id='RegroupIdents'>Regroup idents based on meta.data info</h2><span id='topic+RegroupIdents'></span>

<h3>Description</h3>

<p>For cells in each ident, set a new identity based on the most common value
of a specified metadata column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegroupIdents(object, metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegroupIdents_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="RegroupIdents_+3A_metadata">metadata</code></td>
<td>
<p>Name of metadata column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with the active idents regrouped
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small &lt;- RegroupIdents(pbmc_small, metadata = "groups")

</code></pre>

<hr>
<h2 id='RelativeCounts'>Normalize raw data to fractions</h2><span id='topic+RelativeCounts'></span>

<h3>Description</h3>

<p>Normalize count data to relative counts per cell by dividing by the total
per cell. Optionally use a scale factor, e.g. for counts per million (CPM)
use <code>scale.factor = 1e6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RelativeCounts(data, scale.factor = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RelativeCounts_+3A_data">data</code></td>
<td>
<p>Matrix with the raw count data</p>
</td></tr>
<tr><td><code id="RelativeCounts_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Scale the result. Default is 1</p>
</td></tr>
<tr><td><code id="RelativeCounts_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with the relative counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(data = rbinom(n = 25, size = 5, prob = 0.2), nrow = 5)
mat
mat_norm &lt;- RelativeCounts(data = mat)
mat_norm

</code></pre>

<hr>
<h2 id='RenameCells.SCTAssay'>Rename Cells in an Object</h2><span id='topic+RenameCells.SCTAssay'></span><span id='topic+RenameCells.SlideSeq'></span><span id='topic+RenameCells.STARmap'></span><span id='topic+RenameCells.VisiumV1'></span>

<h3>Description</h3>

<p>Rename Cells in an Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCTAssay'
RenameCells(object, new.names = NULL, ...)

## S3 method for class 'SlideSeq'
RenameCells(object, new.names = NULL, ...)

## S3 method for class 'STARmap'
RenameCells(object, new.names = NULL, ...)

## S3 method for class 'VisiumV1'
RenameCells(object, new.names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RenameCells.SCTAssay_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="RenameCells.SCTAssay_+3A_new.names">new.names</code></td>
<td>
<p>vector of new cell names</p>
</td></tr>
<tr><td><code id="RenameCells.SCTAssay_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+RenameCells">SeuratObject::RenameCells</a></code>
</p>

<hr>
<h2 id='RidgePlot'>Single cell ridge plot</h2><span id='topic+RidgePlot'></span>

<h3>Description</h3>

<p>Draws a ridge plot of single cell data (gene expression, metrics, PC
scores, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RidgePlot(
  object,
  features,
  cols = NULL,
  idents = NULL,
  sort = FALSE,
  assay = NULL,
  group.by = NULL,
  y.max = NULL,
  same.y.lims = FALSE,
  log = FALSE,
  ncol = NULL,
  slot = deprecated(),
  layer = "data",
  stack = FALSE,
  combine = TRUE,
  fill.by = "feature"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RidgePlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_features">features</code></td>
<td>
<p>Features to plot (gene expression, metrics, PC scores,
anything that can be retreived by FetchData)</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_cols">cols</code></td>
<td>
<p>Colors to use for plotting</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_idents">idents</code></td>
<td>
<p>Which classes to include in the plot (default is all)</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_sort">sort</code></td>
<td>
<p>Sort identity classes (on the x-axis) by the average
expression of the attribute being potted, can also pass 'increasing' or 'decreasing' to change sort direction</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use, defaults to the active assay</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_group.by">group.by</code></td>
<td>
<p>Group (color) cells in different ways (for example, orig.ident)</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_y.max">y.max</code></td>
<td>
<p>Maximum y axis value</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_same.y.lims">same.y.lims</code></td>
<td>
<p>Set all the y-axis limits to the same values</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_log">log</code></td>
<td>
<p>plot the feature axis on log scale</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if multiple plots are displayed</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_slot">slot</code></td>
<td>
<p>Slot to pull expression data from (e.g. &quot;counts&quot; or &quot;data&quot;)</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_layer">layer</code></td>
<td>
<p>Layer to pull expression data from (e.g. &quot;counts&quot; or &quot;data&quot;)</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_stack">stack</code></td>
<td>
<p>Horizontally stack plots for each feature</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot</p>
</td></tr>
<tr><td><code id="RidgePlot_+3A_fill.by">fill.by</code></td>
<td>
<p>Color violins/ridges based on either 'feature' or 'ident'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
RidgePlot(object = pbmc_small, features = 'PC_1')

</code></pre>

<hr>
<h2 id='RPCAIntegration'>Seurat-RPCA Integration</h2><span id='topic+RPCAIntegration'></span>

<h3>Description</h3>

<p>Seurat-RPCA Integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RPCAIntegration(
  object = NULL,
  assay = NULL,
  layers = NULL,
  orig = NULL,
  new.reduction = "integrated.dr",
  reference = NULL,
  features = NULL,
  normalization.method = c("LogNormalize", "SCT"),
  dims = 1:30,
  k.filter = NA,
  scale.layer = "scale.data",
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RPCAIntegration_+3A_object">object</code></td>
<td>
<p>A <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_assay">assay</code></td>
<td>
<p>Name of <code>Assay</code> in the <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_layers">layers</code></td>
<td>
<p>Names of layers in <code>assay</code></p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_orig">orig</code></td>
<td>
<p>A <a href="SeuratObject.html#topic+DimReduc">dimensional reduction</a> to correct</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_new.reduction">new.reduction</code></td>
<td>
<p>Name of new integrated dimensional reduction</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_reference">reference</code></td>
<td>
<p>A reference <code>Seurat</code> object</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_features">features</code></td>
<td>
<p>A vector of features to use for integration</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_normalization.method">normalization.method</code></td>
<td>
<p>Name of normalization method used: LogNormalize
or SCT</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_dims">dims</code></td>
<td>
<p>Dimensions of dimensional reduction to use for integration</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_k.filter">k.filter</code></td>
<td>
<p>Number of anchors to filter</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_scale.layer">scale.layer</code></td>
<td>
<p>Name of scaled layer in <code>Assay</code></p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_dims.to.integrate">dims.to.integrate</code></td>
<td>
<p>Number of dimensions to return integrated values for</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_weight.reduction">weight.reduction</code></td>
<td>
<p>Dimension reduction to use when calculating anchor
weights. This can be one of:
</p>

<ul>
<li><p>A string, specifying the name of a dimension reduction present in
all objects to be integrated
</p>
</li>
<li><p>A vector of strings, specifying the name of a dimension reduction to
use for each object to be integrated
</p>
</li>
<li><p>A vector of <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> objects, specifying the object to
use for each object in the integration
</p>
</li>
<li><p>NULL, in which case the full corrected space is used for computing
anchor weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_sd.weight">sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_sample.tree">sample.tree</code></td>
<td>
<p>Specify the order of integration. Order of integration
should be encoded in a matrix, where each row represents one of the pairwise
integration steps. Negative numbers specify a dataset, positive numbers
specify the integration results from a given row (the format of the merge
matrix included in the <code><a href="stats.html#topic+hclust">hclust</a></code> function output). For example:
<code>matrix(c(-2, 1, -3, -1), ncol = 2)</code> gives:
</p>
<div class="sourceCode"><pre>            [,1]  [,2]
       [1,]   -2   -3
       [2,]    1   -1
</pre></div>
<p>Which would cause dataset 2 and 3 to be integrated first, then the resulting
object integrated with dataset 1.
</p>
<p>If NULL, the sample tree will be computed automatically.</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_preserve.order">preserve.order</code></td>
<td>
<p>Do not reorder objects based on size for each pairwise
integration.</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
<tr><td><code id="RPCAIntegration_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>FindIntegrationAnchors</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Preprocessing
obj &lt;- SeuratData::LoadData("pbmcsca")
obj[["RNA"]] &lt;- split(obj[["RNA"]], f = obj$Method)
obj &lt;- NormalizeData(obj)
obj &lt;- FindVariableFeatures(obj)
obj &lt;- ScaleData(obj)
obj &lt;- RunPCA(obj)

# After preprocessing, we run integration
obj &lt;- IntegrateLayers(object = obj, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = 'integrated.rpca',
  verbose = FALSE)

# Reference-based Integration
# Here, we use the first layer as a reference for integraion
# Thus, we only identify anchors between the reference and the rest of the datasets,
# saving computational resources
obj &lt;- IntegrateLayers(object = obj, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = 'integrated.rpca',
  reference = 1, verbose = FALSE)

# Modifying parameters
# We can also specify parameters such as `k.anchor` to increase the strength of
# integration
obj &lt;- IntegrateLayers(object = obj, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = 'integrated.rpca',
  k.anchor = 20, verbose = FALSE)

# Integrating SCTransformed data
obj &lt;- SCTransform(object = obj)
obj &lt;- IntegrateLayers(object = obj, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = 'integrated.rpca',
  assay = "SCT", verbose = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='RunCCA'>Perform Canonical Correlation Analysis</h2><span id='topic+RunCCA'></span><span id='topic+RunCCA.default'></span><span id='topic+RunCCA.Seurat'></span>

<h3>Description</h3>

<p>Runs a canonical correlation analysis using a diagonal implementation of CCA.
For details about stored CCA calculation parameters, see
<code>PrintCCAParams</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunCCA(object1, object2, ...)

## Default S3 method:
RunCCA(
  object1,
  object2,
  standardize = TRUE,
  num.cc = 20,
  seed.use = 42,
  verbose = FALSE,
  ...
)

## S3 method for class 'Seurat'
RunCCA(
  object1,
  object2,
  assay1 = NULL,
  assay2 = NULL,
  num.cc = 20,
  features = NULL,
  renormalize = FALSE,
  rescale = FALSE,
  compute.gene.loadings = TRUE,
  add.cell.id1 = NULL,
  add.cell.id2 = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunCCA_+3A_object1">object1</code></td>
<td>
<p>First Seurat object</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_object2">object2</code></td>
<td>
<p>Second Seurat object.</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_...">...</code></td>
<td>
<p>Extra parameters (passed onto MergeSeurat in case with two objects
passed, passed onto ScaleData in case with single object and rescale.groups
set to TRUE)</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_standardize">standardize</code></td>
<td>
<p>Standardize matrices - scales columns to have unit variance
and mean 0</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_num.cc">num.cc</code></td>
<td>
<p>Number of canonical vectors to calculate</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_seed.use">seed.use</code></td>
<td>
<p>Random seed to set. If NULL, does not set a seed</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_verbose">verbose</code></td>
<td>
<p>Show progress messages</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_assay1">assay1</code>, <code id="RunCCA_+3A_assay2">assay2</code></td>
<td>
<p>Assays to pull from in the first and second objects, respectively</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_features">features</code></td>
<td>
<p>Set of genes to use in CCA. Default is the union of both
the variable features sets present in both objects.</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_renormalize">renormalize</code></td>
<td>
<p>Renormalize raw data after merging the objects. If FALSE,
merge the data matrices also.</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the datasets prior to CCA. If FALSE, uses existing data in the scale data slots.</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_compute.gene.loadings">compute.gene.loadings</code></td>
<td>
<p>Also compute the gene loadings. NOTE - this will
scale every gene in the dataset which may impose a high memory cost.</p>
</td></tr>
<tr><td><code id="RunCCA_+3A_add.cell.id1">add.cell.id1</code>, <code id="RunCCA_+3A_add.cell.id2">add.cell.id2</code></td>
<td>
<p>Add ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a combined Seurat object with the CCA results stored.
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+merge.Seurat">merge.Seurat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small
# As CCA requires two datasets, we will split our test object into two just for this example
pbmc1 &lt;- subset(pbmc_small, cells = colnames(pbmc_small)[1:40])
pbmc2 &lt;- subset(pbmc_small, cells = colnames(x = pbmc_small)[41:80])
pbmc1[["group"]] &lt;- "group1"
pbmc2[["group"]] &lt;- "group2"
pbmc_cca &lt;- RunCCA(object1 = pbmc1, object2 = pbmc2)
# Print results
print(x = pbmc_cca[["cca"]])

## End(Not run)

</code></pre>

<hr>
<h2 id='RunGraphLaplacian'>Run Graph Laplacian Eigendecomposition</h2><span id='topic+RunGraphLaplacian'></span><span id='topic+RunGraphLaplacian.Seurat'></span><span id='topic+RunGraphLaplacian.default'></span>

<h3>Description</h3>

<p>Run a graph laplacian dimensionality reduction. It is used as a low
dimensional representation for a cell-cell graph. The input graph
should be symmetric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunGraphLaplacian(object, ...)

## S3 method for class 'Seurat'
RunGraphLaplacian(
  object,
  graph,
  reduction.name = "lap",
  reduction.key = "LAP_",
  n = 50,
  verbose = TRUE,
  ...
)

## Default S3 method:
RunGraphLaplacian(object, n = 50, reduction.key = "LAP_", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunGraphLaplacian_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="RunGraphLaplacian_+3A_...">...</code></td>
<td>
<p>Arguments passed to eigs_sym</p>
</td></tr>
<tr><td><code id="RunGraphLaplacian_+3A_graph">graph</code></td>
<td>
<p>The name of graph</p>
</td></tr>
<tr><td><code id="RunGraphLaplacian_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name, lap by default</p>
</td></tr>
<tr><td><code id="RunGraphLaplacian_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names. LAP by default</p>
</td></tr>
<tr><td><code id="RunGraphLaplacian_+3A_n">n</code></td>
<td>
<p>Total Number of Eigenvectors to compute and store (50 by default)</p>
</td></tr>
<tr><td><code id="RunGraphLaplacian_+3A_verbose">verbose</code></td>
<td>
<p>Print message and process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Seurat object with the Graph laplacian eigenvector
calculation stored in the reductions slot
</p>

<hr>
<h2 id='RunICA'>Run Independent Component Analysis on gene expression</h2><span id='topic+RunICA'></span><span id='topic+RunICA.default'></span><span id='topic+RunICA.Assay'></span><span id='topic+RunICA.Seurat'></span>

<h3>Description</h3>

<p>Run fastica algorithm from the ica package for ICA dimensionality reduction.
For details about stored ICA calculation parameters, see
<code>PrintICAParams</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunICA(object, ...)

## Default S3 method:
RunICA(
  object,
  assay = NULL,
  nics = 50,
  rev.ica = FALSE,
  ica.function = "icafast",
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.name = "ica",
  reduction.key = "ica_",
  seed.use = 42,
  ...
)

## S3 method for class 'Assay'
RunICA(
  object,
  assay = NULL,
  features = NULL,
  nics = 50,
  rev.ica = FALSE,
  ica.function = "icafast",
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.name = "ica",
  reduction.key = "ica_",
  seed.use = 42,
  ...
)

## S3 method for class 'Seurat'
RunICA(
  object,
  assay = NULL,
  features = NULL,
  nics = 50,
  rev.ica = FALSE,
  ica.function = "icafast",
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.name = "ica",
  reduction.key = "IC_",
  seed.use = 42,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunICA_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="RunICA_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to fastica</p>
</td></tr>
<tr><td><code id="RunICA_+3A_assay">assay</code></td>
<td>
<p>Name of Assay ICA is being run on</p>
</td></tr>
<tr><td><code id="RunICA_+3A_nics">nics</code></td>
<td>
<p>Number of ICs to compute</p>
</td></tr>
<tr><td><code id="RunICA_+3A_rev.ica">rev.ica</code></td>
<td>
<p>By default, computes the dimensional reduction on the cell x
feature matrix. Setting to true will compute it on the transpose (feature x cell
matrix).</p>
</td></tr>
<tr><td><code id="RunICA_+3A_ica.function">ica.function</code></td>
<td>
<p>ICA function from ica package to run (options: icafast,
icaimax, icajade)</p>
</td></tr>
<tr><td><code id="RunICA_+3A_verbose">verbose</code></td>
<td>
<p>Print the top genes associated with high/low loadings for
the ICs</p>
</td></tr>
<tr><td><code id="RunICA_+3A_ndims.print">ndims.print</code></td>
<td>
<p>ICs to print genes for</p>
</td></tr>
<tr><td><code id="RunICA_+3A_nfeatures.print">nfeatures.print</code></td>
<td>
<p>Number of genes to print for each IC</p>
</td></tr>
<tr><td><code id="RunICA_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name</p>
</td></tr>
<tr><td><code id="RunICA_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names.</p>
</td></tr>
<tr><td><code id="RunICA_+3A_seed.use">seed.use</code></td>
<td>
<p>Set a random seed.  Setting NULL will not set a seed.</p>
</td></tr>
<tr><td><code id="RunICA_+3A_features">features</code></td>
<td>
<p>Features to compute ICA on</p>
</td></tr>
</table>

<hr>
<h2 id='RunLDA'>Run Linear Discriminant Analysis</h2><span id='topic+RunLDA'></span><span id='topic+RunLDA.default'></span><span id='topic+RunLDA.Assay'></span><span id='topic+RunLDA.Seurat'></span>

<h3>Description</h3>

<p>Run Linear Discriminant Analysis
</p>
<p>Function to perform Linear Discriminant Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunLDA(object, ...)

## Default S3 method:
RunLDA(
  object,
  labels,
  assay = NULL,
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.key = "LDA_",
  seed = 42,
  ...
)

## S3 method for class 'Assay'
RunLDA(
  object,
  assay = NULL,
  labels,
  features = NULL,
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.key = "LDA_",
  seed = 42,
  ...
)

## S3 method for class 'Seurat'
RunLDA(
  object,
  assay = NULL,
  labels,
  features = NULL,
  reduction.name = "lda",
  reduction.key = "LDA_",
  seed = 42,
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunLDA_+3A_object">object</code></td>
<td>
<p>An object of class Seurat.</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_labels">labels</code></td>
<td>
<p>Meta data column with target gene class labels.</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_assay">assay</code></td>
<td>
<p>Assay to use for performing Linear Discriminant Analysis (LDA).</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_verbose">verbose</code></td>
<td>
<p>Print the top genes associated with high/low loadings for
the PCs</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_ndims.print">ndims.print</code></td>
<td>
<p>Number of LDA dimensions to print.</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_nfeatures.print">nfeatures.print</code></td>
<td>
<p>Number of features to print for each LDA component.</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_reduction.key">reduction.key</code></td>
<td>
<p>Reduction key name.</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_seed">seed</code></td>
<td>
<p>Value for random seed</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_features">features</code></td>
<td>
<p>Features to compute LDA on</p>
</td></tr>
<tr><td><code id="RunLDA_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name, lda by default</p>
</td></tr>
</table>

<hr>
<h2 id='RunMarkVario'>Run the mark variogram computation on a given position matrix and expression
matrix.</h2><span id='topic+RunMarkVario'></span>

<h3>Description</h3>

<p>Wraps the functionality of markvario from the spatstat package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunMarkVario(spatial.location, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunMarkVario_+3A_spatial.location">spatial.location</code></td>
<td>
<p>A 2 column matrix giving the spatial locations of
each of the data points also in data</p>
</td></tr>
<tr><td><code id="RunMarkVario_+3A_data">data</code></td>
<td>
<p>Matrix containing the data used as &quot;marks&quot; (e.g. gene expression)</p>
</td></tr>
<tr><td><code id="RunMarkVario_+3A_...">...</code></td>
<td>
<p>Arguments passed to markvario</p>
</td></tr>
</table>

<hr>
<h2 id='RunMixscape'>Run Mixscape</h2><span id='topic+RunMixscape'></span>

<h3>Description</h3>

<p>Function to identify perturbed and non-perturbed gRNA expressing cells that
accounts for multiple treatments/conditions/chemical perturbations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunMixscape(
  object,
  assay = "PRTB",
  slot = "scale.data",
  labels = "gene",
  nt.class.name = "NT",
  new.class.name = "mixscape_class",
  min.de.genes = 5,
  min.cells = 5,
  de.assay = "RNA",
  logfc.threshold = 0.25,
  iter.num = 10,
  verbose = FALSE,
  split.by = NULL,
  fine.mode = FALSE,
  fine.mode.labels = "guide_ID",
  prtb.type = "KO"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunMixscape_+3A_object">object</code></td>
<td>
<p>An object of class Seurat.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_assay">assay</code></td>
<td>
<p>Assay to use for mixscape classification.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_slot">slot</code></td>
<td>
<p>Assay data slot to use.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_labels">labels</code></td>
<td>
<p>metadata column with target gene labels.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_nt.class.name">nt.class.name</code></td>
<td>
<p>Classification name of non-targeting gRNA cells.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_new.class.name">new.class.name</code></td>
<td>
<p>Name of mixscape classification to be stored in
metadata.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_min.de.genes">min.de.genes</code></td>
<td>
<p>Required number of genes that are differentially
expressed for method to separate perturbed and non-perturbed cells.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_min.cells">min.cells</code></td>
<td>
<p>Minimum number of cells in target gene class. If fewer than
this many cells are assigned to a target gene class during classification,
all are assigned NP.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_de.assay">de.assay</code></td>
<td>
<p>Assay to use when performing differential expression analysis.
Usually RNA.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Limit testing to genes which show, on average,
at least X-fold difference (log-scale) between the two groups of cells.
Default is 0.25 Increasing logfc.threshold speeds up the function, but can miss
weaker signals.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_iter.num">iter.num</code></td>
<td>
<p>Number of normalmixEM iterations to run if convergence does
not occur.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_split.by">split.by</code></td>
<td>
<p>metadata column with experimental condition/cell type
classification information. This is meant to be used to account for cases a
perturbation is condition/cell type -specific.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_fine.mode">fine.mode</code></td>
<td>
<p>When this is equal to TRUE, DE genes for each target gene
class will be calculated for each gRNA separately and pooled into one DE list
for calculating the perturbation score of every cell and their subsequent
classification.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_fine.mode.labels">fine.mode.labels</code></td>
<td>
<p>metadata column with gRNA ID labels.</p>
</td></tr>
<tr><td><code id="RunMixscape_+3A_prtb.type">prtb.type</code></td>
<td>
<p>specify type of CRISPR perturbation expected for labeling mixscape classifications. Default is KO.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Seurat object with with the following information in the
meta data and tools slots:
</p>

<dl>
<dt>mixscape_class</dt><dd><p>Classification result with cells being either
classified as perturbed (KO, by default) or non-perturbed (NP) based on their target
gene class.</p>
</dd>
<dt>mixscape_class.global</dt><dd><p>Global classification result (perturbed, NP or NT)</p>
</dd>
<dt>p_ko</dt><dd><p>Posterior probabilities used to determine if a cell is KO (default). Name of this item will change to match prtb.type parameter setting.
(&gt;0.5) or NP</p>
</dd>
<dt>perturbation score</dt><dd><p>Perturbation scores for every cell calculated in
the first iteration of the function.</p>
</dd>
</dl>


<hr>
<h2 id='RunMoransI'>Compute Moran's I value.</h2><span id='topic+RunMoransI'></span>

<h3>Description</h3>

<p>Wraps the functionality of the Moran.I function from the ape package.
Weights are computed as 1/distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunMoransI(data, pos, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunMoransI_+3A_data">data</code></td>
<td>
<p>Expression matrix</p>
</td></tr>
<tr><td><code id="RunMoransI_+3A_pos">pos</code></td>
<td>
<p>Position matrix</p>
</td></tr>
<tr><td><code id="RunMoransI_+3A_verbose">verbose</code></td>
<td>
<p>Display messages/progress</p>
</td></tr>
</table>

<hr>
<h2 id='RunPCA'>Run Principal Component Analysis</h2><span id='topic+RunPCA'></span><span id='topic+RunPCA.default'></span><span id='topic+RunPCA.Assay'></span><span id='topic+RunPCA.Seurat'></span>

<h3>Description</h3>

<p>Run a PCA dimensionality reduction. For details about stored PCA calculation
parameters, see <code>PrintPCAParams</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunPCA(object, ...)

## Default S3 method:
RunPCA(
  object,
  assay = NULL,
  npcs = 50,
  rev.pca = FALSE,
  weight.by.var = TRUE,
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.key = "PC_",
  seed.use = 42,
  approx = TRUE,
  ...
)

## S3 method for class 'Assay'
RunPCA(
  object,
  assay = NULL,
  features = NULL,
  npcs = 50,
  rev.pca = FALSE,
  weight.by.var = TRUE,
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.key = "PC_",
  seed.use = 42,
  ...
)

## S3 method for class 'Seurat'
RunPCA(
  object,
  assay = NULL,
  features = NULL,
  npcs = 50,
  rev.pca = FALSE,
  weight.by.var = TRUE,
  verbose = TRUE,
  ndims.print = 1:5,
  nfeatures.print = 30,
  reduction.name = "pca",
  reduction.key = "PC_",
  seed.use = 42,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunPCA_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and IRLBA</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_assay">assay</code></td>
<td>
<p>Name of Assay PCA is being run on</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_npcs">npcs</code></td>
<td>
<p>Total Number of PCs to compute and store (50 by default)</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_rev.pca">rev.pca</code></td>
<td>
<p>By default computes the PCA on the cell x gene matrix. Setting
to true will compute it on gene x cell matrix.</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_weight.by.var">weight.by.var</code></td>
<td>
<p>Weight the cell embeddings by the variance of each PC
(weights the gene loadings if rev.pca is TRUE)</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_verbose">verbose</code></td>
<td>
<p>Print the top genes associated with high/low loadings for
the PCs</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_ndims.print">ndims.print</code></td>
<td>
<p>PCs to print genes for</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_nfeatures.print">nfeatures.print</code></td>
<td>
<p>Number of genes to print for each PC</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names. PC by default</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_seed.use">seed.use</code></td>
<td>
<p>Set a random seed. By default, sets the seed to 42. Setting
NULL will not set a seed.</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_approx">approx</code></td>
<td>
<p>Use truncated singular value decomposition to approximate PCA</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_features">features</code></td>
<td>
<p>Features to compute PCA on. If features=NULL, PCA will be run
using the variable features for the Assay. Note that the features must be present
in the scaled data. Any requested features that are not scaled or have 0 variance
will be dropped, and the PCA will be run using the remaining features.</p>
</td></tr>
<tr><td><code id="RunPCA_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name,  pca by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Seurat object with the PCA calculation stored in the reductions slot
</p>

<hr>
<h2 id='RunSLSI'>Run Supervised Latent Semantic Indexing</h2><span id='topic+RunSLSI'></span><span id='topic+RunSLSI.default'></span><span id='topic+RunSLSI.Assay'></span><span id='topic+RunSLSI.Seurat'></span>

<h3>Description</h3>

<p>Run a supervised LSI (SLSI) dimensionality reduction supervised by a
cell-cell kernel. SLSI is used to capture a linear transformation of peaks
that maximizes its dependency to the given cell-cell kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunSLSI(object, ...)

## Default S3 method:
RunSLSI(
  object,
  assay = NULL,
  n = 50,
  reduction.key = "SLSI_",
  graph = NULL,
  verbose = TRUE,
  seed.use = 42,
  ...
)

## S3 method for class 'Assay'
RunSLSI(
  object,
  assay = NULL,
  features = NULL,
  n = 50,
  reduction.key = "SLSI_",
  graph = NULL,
  verbose = TRUE,
  seed.use = 42,
  ...
)

## S3 method for class 'Seurat'
RunSLSI(
  object,
  assay = NULL,
  features = NULL,
  n = 50,
  reduction.name = "slsi",
  reduction.key = "SLSI_",
  graph = NULL,
  verbose = TRUE,
  seed.use = 42,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunSLSI_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_...">...</code></td>
<td>
<p>Arguments passed to IRLBA irlba</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_assay">assay</code></td>
<td>
<p>Name of Assay SLSI is being run on</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_n">n</code></td>
<td>
<p>Total Number of SLSI components to compute and store</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_graph">graph</code></td>
<td>
<p>Graph used supervised by SLSI</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_seed.use">seed.use</code></td>
<td>
<p>Set a random seed. Setting NULL will not set a seed.</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_features">features</code></td>
<td>
<p>Features to compute SLSI on. If NULL, SLSI will be run
using the variable features for the Assay.</p>
</td></tr>
<tr><td><code id="RunSLSI_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Seurat object with the SLSI calculation stored in the
reductions slot
</p>

<hr>
<h2 id='RunSPCA'>Run Supervised Principal Component Analysis</h2><span id='topic+RunSPCA'></span><span id='topic+RunSPCA.default'></span><span id='topic+RunSPCA.Assay'></span><span id='topic+RunSPCA.Assay5'></span><span id='topic+RunSPCA.Seurat'></span>

<h3>Description</h3>

<p>Run a supervised PCA (SPCA) dimensionality reduction supervised by a cell-cell kernel.
SPCA is used to capture a linear transformation which maximizes its dependency to
the given cell-cell kernel. We use SNN graph as the kernel to supervise the linear
matrix factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunSPCA(object, ...)

## Default S3 method:
RunSPCA(
  object,
  assay = NULL,
  npcs = 50,
  reduction.key = "SPC_",
  graph = NULL,
  verbose = FALSE,
  seed.use = 42,
  ...
)

## S3 method for class 'Assay'
RunSPCA(
  object,
  assay = NULL,
  features = NULL,
  npcs = 50,
  reduction.key = "SPC_",
  graph = NULL,
  verbose = TRUE,
  seed.use = 42,
  ...
)

## S3 method for class 'Assay5'
RunSPCA(
  object,
  assay = NULL,
  features = NULL,
  npcs = 50,
  reduction.key = "SPC_",
  graph = NULL,
  verbose = TRUE,
  seed.use = 42,
  layer = "scale.data",
  ...
)

## S3 method for class 'Seurat'
RunSPCA(
  object,
  assay = NULL,
  features = NULL,
  npcs = 50,
  reduction.name = "spca",
  reduction.key = "SPC_",
  graph = NULL,
  verbose = TRUE,
  seed.use = 42,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunSPCA_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and IRLBA</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_assay">assay</code></td>
<td>
<p>Name of Assay SPCA is being run on</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_npcs">npcs</code></td>
<td>
<p>Total Number of SPCs to compute and store (50 by default)</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names. SPC by default</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_graph">graph</code></td>
<td>
<p>Graph used supervised by SPCA</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_verbose">verbose</code></td>
<td>
<p>Print the top genes associated with high/low loadings for
the SPCs</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_seed.use">seed.use</code></td>
<td>
<p>Set a random seed. By default, sets the seed to 42. Setting
NULL will not set a seed.</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_features">features</code></td>
<td>
<p>Features to compute SPCA on. If features=NULL, SPCA will be run
using the variable features for the Assay.</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_layer">layer</code></td>
<td>
<p>Layer to run SPCA on</p>
</td></tr>
<tr><td><code id="RunSPCA_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name, spca by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Seurat object with the SPCA calculation stored in the reductions slot
</p>


<h3>References</h3>

<p>Barshan E, Ghodsi A, Azimifar Z, Jahromi MZ.
Supervised principal component analysis: Visualization, classification and
regression on subspaces and submanifolds.
Pattern Recognition. 2011 Jul 1;44(7):1357-71. <a href="https://www.sciencedirect.com/science/article/pii/S0031320310005819?casa_token=AZMFg5OtPnAAAAAA:_Udu7GJ7G2ed1-XSmr-3IGSISUwcHfMpNtCj-qacXH5SBC4nwzVid36GXI3r8XG8dK5WOQui">https://www.sciencedirect.com/science/article/pii/S0031320310005819?casa_token=AZMFg5OtPnAAAAAA:_Udu7GJ7G2ed1-XSmr-3IGSISUwcHfMpNtCj-qacXH5SBC4nwzVid36GXI3r8XG8dK5WOQui</a>;
</p>

<hr>
<h2 id='RunTSNE'>Run t-distributed Stochastic Neighbor Embedding</h2><span id='topic+RunTSNE'></span><span id='topic+RunTSNE.matrix'></span><span id='topic+RunTSNE.DimReduc'></span><span id='topic+RunTSNE.dist'></span><span id='topic+RunTSNE.Seurat'></span>

<h3>Description</h3>

<p>Run t-SNE dimensionality reduction on selected features. Has the option of
running in a reduced dimensional space (i.e. spectral tSNE, recommended),
or running based on a set of genes. For details about stored TSNE calculation
parameters, see <code>PrintTSNEParams</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunTSNE(object, ...)

## S3 method for class 'matrix'
RunTSNE(
  object,
  assay = NULL,
  seed.use = 1,
  tsne.method = "Rtsne",
  dim.embed = 2,
  reduction.key = "tSNE_",
  ...
)

## S3 method for class 'DimReduc'
RunTSNE(
  object,
  cells = NULL,
  dims = 1:5,
  seed.use = 1,
  tsne.method = "Rtsne",
  dim.embed = 2,
  reduction.key = "tSNE_",
  ...
)

## S3 method for class 'dist'
RunTSNE(
  object,
  assay = NULL,
  seed.use = 1,
  tsne.method = "Rtsne",
  dim.embed = 2,
  reduction.key = "tSNE_",
  ...
)

## S3 method for class 'Seurat'
RunTSNE(
  object,
  reduction = "pca",
  cells = NULL,
  dims = 1:5,
  features = NULL,
  seed.use = 1,
  tsne.method = "Rtsne",
  dim.embed = 2,
  distance.matrix = NULL,
  reduction.name = "tsne",
  reduction.key = "tSNE_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunTSNE_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and to t-SNE call (most commonly used is perplexity)</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_assay">assay</code></td>
<td>
<p>Name of assay that that t-SNE is being run on</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_seed.use">seed.use</code></td>
<td>
<p>Random seed for the t-SNE. If NULL, does not set the seed</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_tsne.method">tsne.method</code></td>
<td>
<p>Select the method to use to compute the tSNE. Available
methods are:
</p>

<ul>
<li> <p>&ldquo;<code>Rtsne</code>&rdquo;: Use the Rtsne package Barnes-Hut
implementation of tSNE (default)
</p>
</li>
<li> <p>&ldquo;<code>FIt-SNE</code>&rdquo;: Use the FFT-accelerated Interpolation-based
t-SNE. Based on Kluger Lab code found here:
<a href="https://github.com/KlugerLab/FIt-SNE">https://github.com/KlugerLab/FIt-SNE</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="RunTSNE_+3A_dim.embed">dim.embed</code></td>
<td>
<p>The dimensional space of the resulting tSNE embedding
(default is 2). For example, set to 3 for a 3d tSNE</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names. &ldquo;<code>tSNE_</code>&rdquo; by default</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_cells">cells</code></td>
<td>
<p>Which cells to analyze (default, all cells)</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to use as input features</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensional reduction (e.g. PCA, ICA) to use for
the tSNE. Default is PCA</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_features">features</code></td>
<td>
<p>If set, run the tSNE on this subset of features
(instead of running on a set of reduced dimensions). Not set (NULL) by default;
<code>dims</code> must be NULL to run on features</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_distance.matrix">distance.matrix</code></td>
<td>
<p>If set, runs tSNE on the given distance matrix
instead of data matrix (experimental)</p>
</td></tr>
<tr><td><code id="RunTSNE_+3A_reduction.name">reduction.name</code></td>
<td>
<p>dimensional reduction name, specifies the position in the object$dr list. tsne by default</p>
</td></tr>
</table>

<hr>
<h2 id='RunUMAP'>Run UMAP</h2><span id='topic+RunUMAP'></span><span id='topic+RunUMAP.default'></span><span id='topic+RunUMAP.Graph'></span><span id='topic+RunUMAP.Neighbor'></span><span id='topic+RunUMAP.Seurat'></span>

<h3>Description</h3>

<p>Runs the Uniform Manifold Approximation and Projection (UMAP) dimensional
reduction technique. To run using <code>umap.method="umap-learn"</code>, you must
first install the umap-learn python package (e.g. via
<code>pip install umap-learn</code>). Details on this package can be
found here: <a href="https://github.com/lmcinnes/umap">https://github.com/lmcinnes/umap</a>. For a more in depth
discussion of the mathematics underlying UMAP, see the ArXiv paper here:
<a href="https://arxiv.org/abs/1802.03426">https://arxiv.org/abs/1802.03426</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunUMAP(object, ...)

## Default S3 method:
RunUMAP(
  object,
  reduction.key = "UMAP_",
  assay = NULL,
  reduction.model = NULL,
  return.model = FALSE,
  umap.method = "uwot",
  n.neighbors = 30L,
  n.components = 2L,
  metric = "cosine",
  n.epochs = NULL,
  learning.rate = 1,
  min.dist = 0.3,
  spread = 1,
  set.op.mix.ratio = 1,
  local.connectivity = 1L,
  repulsion.strength = 1,
  negative.sample.rate = 5,
  a = NULL,
  b = NULL,
  uwot.sgd = FALSE,
  seed.use = 42,
  metric.kwds = NULL,
  angular.rp.forest = FALSE,
  densmap = FALSE,
  dens.lambda = 2,
  dens.frac = 0.3,
  dens.var.shift = 0.1,
  verbose = TRUE,
  ...
)

## S3 method for class 'Graph'
RunUMAP(
  object,
  assay = NULL,
  umap.method = "umap-learn",
  n.components = 2L,
  metric = "correlation",
  n.epochs = 0L,
  learning.rate = 1,
  min.dist = 0.3,
  spread = 1,
  repulsion.strength = 1,
  negative.sample.rate = 5L,
  a = NULL,
  b = NULL,
  uwot.sgd = FALSE,
  seed.use = 42L,
  metric.kwds = NULL,
  densmap = FALSE,
  densmap.kwds = NULL,
  verbose = TRUE,
  reduction.key = "UMAP_",
  ...
)

## S3 method for class 'Neighbor'
RunUMAP(object, reduction.model, ...)

## S3 method for class 'Seurat'
RunUMAP(
  object,
  dims = NULL,
  reduction = "pca",
  features = NULL,
  graph = NULL,
  assay = DefaultAssay(object = object),
  nn.name = NULL,
  slot = "data",
  umap.method = "uwot",
  reduction.model = NULL,
  return.model = FALSE,
  n.neighbors = 30L,
  n.components = 2L,
  metric = "cosine",
  n.epochs = NULL,
  learning.rate = 1,
  min.dist = 0.3,
  spread = 1,
  set.op.mix.ratio = 1,
  local.connectivity = 1L,
  repulsion.strength = 1,
  negative.sample.rate = 5L,
  a = NULL,
  b = NULL,
  uwot.sgd = FALSE,
  seed.use = 42L,
  metric.kwds = NULL,
  angular.rp.forest = FALSE,
  densmap = FALSE,
  dens.lambda = 2,
  dens.frac = 0.3,
  dens.var.shift = 0.1,
  verbose = TRUE,
  reduction.name = "umap",
  reduction.key = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunUMAP_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and UMAP</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_reduction.key">reduction.key</code></td>
<td>
<p>dimensional reduction key, specifies the string before
the number for the dimension names. UMAP by default</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_assay">assay</code></td>
<td>
<p>Assay to pull data for when using <code>features</code>, or assay used to construct Graph
if running UMAP on a Graph</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_reduction.model">reduction.model</code></td>
<td>
<p><code>DimReduc</code> object that contains the umap model</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_return.model">return.model</code></td>
<td>
<p>whether UMAP will return the uwot model</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_umap.method">umap.method</code></td>
<td>
<p>UMAP implementation to run. Can be
</p>

<dl>
<dt><code>uwot</code>:</dt><dd><p>Runs umap via the uwot R package</p>
</dd>
<dt><code>uwot-learn</code>:</dt><dd><p>Runs umap via the uwot R package and return the learned umap model</p>
</dd>
<dt><code>umap-learn</code>:</dt><dd><p>Run the Seurat wrapper of the python umap-learn package</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RunUMAP_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>This determines the number of neighboring points used in
local approximations of manifold structure. Larger values will result in more
global structure being preserved at the loss of detailed local structure. In
general this parameter should often be in the range 5 to 50.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_n.components">n.components</code></td>
<td>
<p>The dimension of the space to embed into.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_metric">metric</code></td>
<td>
<p>metric: This determines the choice of metric used to measure
distance in the input space. A wide variety of metrics are already coded, and
a user defined function can be passed as long as it has been JITd by numba.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_n.epochs">n.epochs</code></td>
<td>
<p>he number of training epochs to be used in optimizing the low dimensional
embedding. Larger values result in more accurate embeddings. If NULL is specified, a value will
be selected based on the size of the input dataset (200 for large datasets, 500 for small).</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_learning.rate">learning.rate</code></td>
<td>
<p>The initial learning rate for the embedding optimization.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_min.dist">min.dist</code></td>
<td>
<p>This controls how tightly the embedding is allowed compress points together.
Larger values ensure embedded points are moreevenly distributed, while smaller values allow the
algorithm to optimise more accurately with regard to local structure. Sensible values are in
the range 0.001 to 0.5.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_spread">spread</code></td>
<td>
<p>The effective scale of embedded points. In combination with min.dist this
determines how clustered/clumped the embedded points are.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_set.op.mix.ratio">set.op.mix.ratio</code></td>
<td>
<p>Interpolate between (fuzzy) union and intersection as the set operation
used to combine local fuzzy simplicial sets to obtain a global fuzzy simplicial sets. Both fuzzy
set operations use the product t-norm. The value of this parameter should be between 0.0 and
1.0; a value of 1.0 will use a pure fuzzy union, while 0.0 will use a pure fuzzy intersection.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_local.connectivity">local.connectivity</code></td>
<td>
<p>The local connectivity required - i.e. the number of nearest neighbors
that should be assumed to be connected at a local level. The higher this value the more connected
the manifold becomes locally. In practice this should be not more than the local intrinsic
dimension of the manifold.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_repulsion.strength">repulsion.strength</code></td>
<td>
<p>Weighting applied to negative samples in low dimensional embedding
optimization. Values higher than one will result in greater weight being given to negative
samples.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_negative.sample.rate">negative.sample.rate</code></td>
<td>
<p>The number of negative samples to select per positive sample in the
optimization process. Increasing this value will result in greater repulsive force being applied,
greater optimization cost, but slightly more accuracy.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_a">a</code></td>
<td>
<p>More specific parameters controlling the embedding. If NULL, these values are set
automatically as determined by min. dist and spread. Parameter of differentiable approximation of
right adjoint functor.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_b">b</code></td>
<td>
<p>More specific parameters controlling the embedding. If NULL, these values are set
automatically as determined by min. dist and spread. Parameter of differentiable approximation of
right adjoint functor.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_uwot.sgd">uwot.sgd</code></td>
<td>
<p>Set <code>uwot::umap(fast_sgd = TRUE)</code>; see <code><a href="uwot.html#topic+umap">umap</a></code> for more details</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_seed.use">seed.use</code></td>
<td>
<p>Set a random seed. By default, sets the seed to 42. Setting
NULL will not set a seed</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_metric.kwds">metric.kwds</code></td>
<td>
<p>A dictionary of arguments to pass on to the metric, such as the p value for
Minkowski distance. If NULL then no arguments are passed on.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_angular.rp.forest">angular.rp.forest</code></td>
<td>
<p>Whether to use an angular random projection forest to initialise the
approximate nearest neighbor search. This can be faster, but is mostly on useful for metric that
use an angular style distance such as cosine, correlation etc. In the case of those metrics
angular forests will be chosen automatically.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_densmap">densmap</code></td>
<td>
<p>Whether to use the density-augmented objective of densMAP.
Turning on this option generates an embedding where the local densities
are encouraged to be correlated with those in the original space.
Parameters below with the prefix ‘dens’ further control the behavior
of this extension. Default is FALSE. Only compatible with 'umap-learn' method
and version of umap-learn &gt;= 0.5.0</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_dens.lambda">dens.lambda</code></td>
<td>
<p>Specific parameter which controls the regularization weight
of the density correlation term in densMAP. Higher values prioritize density
preservation over the UMAP objective, and vice versa for values closer to zero.
Setting this parameter to zero is equivalent to running the original UMAP algorithm.
Default value is 2.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_dens.frac">dens.frac</code></td>
<td>
<p>Specific parameter which controls the fraction of epochs
(between 0 and 1) where the density-augmented objective is used in densMAP.
The first (1 - dens_frac) fraction of epochs optimize the original UMAP
objective before introducing the density correlation term. Default is 0.3.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_dens.var.shift">dens.var.shift</code></td>
<td>
<p>Specific parameter which specifies a small constant
added to the variance of local radii in the embedding when calculating
the density correlation objective to prevent numerical instability from
dividing by a small number. Default is 0.1.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_densmap.kwds">densmap.kwds</code></td>
<td>
<p>A dictionary of arguments to pass on to the densMAP optimization.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to use as input features, used only if
<code>features</code> is NULL</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_reduction">reduction</code></td>
<td>
<p>Which dimensional reduction (PCA or ICA) to use for the
UMAP input. Default is PCA</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_features">features</code></td>
<td>
<p>If set, run UMAP on this subset of features (instead of running on a
set of reduced dimensions). Not set (NULL) by default; <code>dims</code> must be NULL to run
on features</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_graph">graph</code></td>
<td>
<p>Name of graph on which to run UMAP</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_nn.name">nn.name</code></td>
<td>
<p>Name of knn output on which to run UMAP</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_slot">slot</code></td>
<td>
<p>The slot used to pull data for when using <code>features</code>. data slot is by default.</p>
</td></tr>
<tr><td><code id="RunUMAP_+3A_reduction.name">reduction.name</code></td>
<td>
<p>Name to store dimensional reduction under in the Seurat object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object containing a UMAP representation
</p>


<h3>References</h3>

<p>McInnes, L, Healy, J, UMAP: Uniform Manifold Approximation and
Projection for Dimension Reduction, ArXiv e-prints 1802.03426, 2018
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("pbmc_small")
pbmc_small
# Run UMAP map on first 5 PCs
pbmc_small &lt;- RunUMAP(object = pbmc_small, dims = 1:5)
# Plot results
DimPlot(object = pbmc_small, reduction = 'umap')

## End(Not run)

</code></pre>

<hr>
<h2 id='SampleUMI'>Sample UMI</h2><span id='topic+SampleUMI'></span>

<h3>Description</h3>

<p>Downsample each cell to a specified number of UMIs. Includes
an option to upsample cells below specified UMI as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SampleUMI(data, max.umi = 1000, upsample = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SampleUMI_+3A_data">data</code></td>
<td>
<p>Matrix with the raw count data</p>
</td></tr>
<tr><td><code id="SampleUMI_+3A_max.umi">max.umi</code></td>
<td>
<p>Number of UMIs to sample to</p>
</td></tr>
<tr><td><code id="SampleUMI_+3A_upsample">upsample</code></td>
<td>
<p>Upsamples all cells with fewer than max.umi</p>
</td></tr>
<tr><td><code id="SampleUMI_+3A_verbose">verbose</code></td>
<td>
<p>Display the progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with downsampled data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
counts = as.matrix(x = GetAssayData(object = pbmc_small, assay = "RNA", slot = "counts"))
downsampled = SampleUMI(data = counts)
head(x = downsampled)

</code></pre>

<hr>
<h2 id='SaveAnnoyIndex'>Save the Annoy index</h2><span id='topic+SaveAnnoyIndex'></span>

<h3>Description</h3>

<p>Save the Annoy index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SaveAnnoyIndex(object, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SaveAnnoyIndex_+3A_object">object</code></td>
<td>
<p>A Neighbor object with the annoy index stored</p>
</td></tr>
<tr><td><code id="SaveAnnoyIndex_+3A_file">file</code></td>
<td>
<p>Path to file to write index to</p>
</td></tr>
</table>

<hr>
<h2 id='ScaleData'>Scale and center the data.</h2><span id='topic+ScaleData'></span><span id='topic+ScaleData.default'></span><span id='topic+ScaleData.IterableMatrix'></span><span id='topic+ScaleData.Assay'></span><span id='topic+ScaleData.Seurat'></span>

<h3>Description</h3>

<p>Scales and centers features in the dataset. If variables are provided in vars.to.regress,
they are individually regressed against each feature, and the resulting residuals are
then scaled and centered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScaleData(object, ...)

## Default S3 method:
ScaleData(
  object,
  features = NULL,
  vars.to.regress = NULL,
  latent.data = NULL,
  split.by = NULL,
  model.use = "linear",
  use.umi = FALSE,
  do.scale = TRUE,
  do.center = TRUE,
  scale.max = 10,
  block.size = 1000,
  min.cells.to.block = 3000,
  verbose = TRUE,
  ...
)

## S3 method for class 'IterableMatrix'
ScaleData(
  object,
  features = NULL,
  do.scale = TRUE,
  do.center = TRUE,
  scale.max = 10,
  ...
)

## S3 method for class 'Assay'
ScaleData(
  object,
  features = NULL,
  vars.to.regress = NULL,
  latent.data = NULL,
  split.by = NULL,
  model.use = "linear",
  use.umi = FALSE,
  do.scale = TRUE,
  do.center = TRUE,
  scale.max = 10,
  block.size = 1000,
  min.cells.to.block = 3000,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
ScaleData(
  object,
  features = NULL,
  assay = NULL,
  vars.to.regress = NULL,
  split.by = NULL,
  model.use = "linear",
  use.umi = FALSE,
  do.scale = TRUE,
  do.center = TRUE,
  scale.max = 10,
  block.size = 1000,
  min.cells.to.block = 3000,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScaleData_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_features">features</code></td>
<td>
<p>Vector of features names to scale/center. Default is variable features.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_vars.to.regress">vars.to.regress</code></td>
<td>
<p>Variables to regress out (previously latent.vars in
RegressOut). For example, nUMI, or percent.mito.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_latent.data">latent.data</code></td>
<td>
<p>Extra data to regress out, should be cells x latent data</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_split.by">split.by</code></td>
<td>
<p>Name of variable in object metadata or a vector or factor defining
grouping of cells. See argument <code>f</code> in <code><a href="base.html#topic+split">split</a></code> for more details</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_model.use">model.use</code></td>
<td>
<p>Use a linear model or generalized linear model
(poisson, negative binomial) for the regression. Options are 'linear'
(default), 'poisson', and 'negbinom'</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_use.umi">use.umi</code></td>
<td>
<p>Regress on UMI count data. Default is FALSE for linear
modeling, but automatically set to TRUE if model.use is 'negbinom' or 'poisson'</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_do.scale">do.scale</code></td>
<td>
<p>Whether to scale the data.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_do.center">do.center</code></td>
<td>
<p>Whether to center the data.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_scale.max">scale.max</code></td>
<td>
<p>Max value to return for scaled data. The default is 10.
Setting this can help reduce the effects of features that are only expressed in
a very small number of cells. If regressing out latent variables and using a
non-linear model, the default is 50.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_block.size">block.size</code></td>
<td>
<p>Default size for number of features to scale at in a single
computation. Increasing block.size may speed up calculations but at an
additional memory cost.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_min.cells.to.block">min.cells.to.block</code></td>
<td>
<p>If object contains fewer than this number of cells,
don't block for scaling calculations.</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_verbose">verbose</code></td>
<td>
<p>Displays a progress bar for scaling procedure</p>
</td></tr>
<tr><td><code id="ScaleData_+3A_assay">assay</code></td>
<td>
<p>Name of Assay to scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ScaleData now incorporates the functionality of the function formerly known
as RegressOut (which regressed out given the effects of provided variables
and then scaled the residuals). To make use of the regression functionality,
simply pass the variables you want to remove to the vars.to.regress parameter.
</p>
<p>Setting center to TRUE will center the expression for each feature by subtracting
the average expression for that feature. Setting scale to TRUE will scale the
expression level for each feature by dividing the centered feature expression
levels by their standard deviations if center is TRUE and by their root mean
square otherwise.
</p>

<hr>
<h2 id='ScaleFactors'>Get image scale factors</h2><span id='topic+ScaleFactors'></span><span id='topic+scalefactors'></span><span id='topic+ScaleFactors.VisiumV1'></span>

<h3>Description</h3>

<p>Get image scale factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScaleFactors(object, ...)

scalefactors(spot, fiducial, hires, lowres)

## S3 method for class 'VisiumV1'
ScaleFactors(object, ...)

## S3 method for class 'VisiumV1'
ScaleFactors(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScaleFactors_+3A_object">object</code></td>
<td>
<p>An object to get scale factors from</p>
</td></tr>
<tr><td><code id="ScaleFactors_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="ScaleFactors_+3A_spot">spot</code></td>
<td>
<p>Spot full resolution scale factor</p>
</td></tr>
<tr><td><code id="ScaleFactors_+3A_fiducial">fiducial</code></td>
<td>
<p>Fiducial full resolution scale factor</p>
</td></tr>
<tr><td><code id="ScaleFactors_+3A_hires">hires</code></td>
<td>
<p>High resolutoin scale factor</p>
</td></tr>
<tr><td><code id="ScaleFactors_+3A_lowres">lowres</code></td>
<td>
<p>Low resolution scale factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalefactors</code>
</p>


<h3>Note</h3>

<p><code>scalefactors</code> objects can be created with <code>scalefactors()</code>
</p>

<hr>
<h2 id='ScoreJackStraw'>Compute Jackstraw scores significance.</h2><span id='topic+ScoreJackStraw'></span><span id='topic+ScoreJackStraw.JackStrawData'></span><span id='topic+ScoreJackStraw.DimReduc'></span><span id='topic+ScoreJackStraw.Seurat'></span>

<h3>Description</h3>

<p>Significant PCs should show a p-value distribution that is
strongly skewed to the left compared to the null distribution.
The p-value for each PC is based on a proportion test comparing the number
of features with a p-value below a particular threshold (score.thresh), compared with the
proportion of features expected under a uniform distribution of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreJackStraw(object, ...)

## S3 method for class 'JackStrawData'
ScoreJackStraw(object, dims = 1:5, score.thresh = 1e-05, ...)

## S3 method for class 'DimReduc'
ScoreJackStraw(object, dims = 1:5, score.thresh = 1e-05, ...)

## S3 method for class 'Seurat'
ScoreJackStraw(
  object,
  reduction = "pca",
  dims = 1:5,
  score.thresh = 1e-05,
  do.plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScoreJackStraw_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="ScoreJackStraw_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="ScoreJackStraw_+3A_dims">dims</code></td>
<td>
<p>Which dimensions to examine</p>
</td></tr>
<tr><td><code id="ScoreJackStraw_+3A_score.thresh">score.thresh</code></td>
<td>
<p>Threshold to use for the proportion test of PC
significance (see Details)</p>
</td></tr>
<tr><td><code id="ScoreJackStraw_+3A_reduction">reduction</code></td>
<td>
<p>Reduction associated with JackStraw to score</p>
</td></tr>
<tr><td><code id="ScoreJackStraw_+3A_do.plot">do.plot</code></td>
<td>
<p>Show plot. To return ggplot object, use <code>JackStrawPlot</code> after
running ScoreJackStraw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object
</p>


<h3>Author(s)</h3>

<p>Omri Wurtzel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JackStrawPlot">JackStrawPlot</a></code>
</p>
<p><code><a href="#topic+JackStrawPlot">JackStrawPlot</a></code>
</p>

<hr>
<h2 id='SCTAssay-class'>The SCTModel Class</h2><span id='topic+SCTAssay-class'></span><span id='topic+SCTModel'></span><span id='topic+SCTAssay'></span><span id='topic+levels.SCTAssay'></span><span id='topic+levels+3C-.SCTAssay'></span>

<h3>Description</h3>

<p>The SCTModel object is a model and parameters storage from SCTransform.
It can be used to calculate Pearson residuals for new genes.
</p>
<p>The SCTAssay object contains all the information found in an <code><a href="nlme.html#topic+Assay">Assay</a></code>
object, with extra information from the results of <code><a href="#topic+SCTransform">SCTransform</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCTAssay'
levels(x)

## S3 replacement method for class 'SCTAssay'
levels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCTAssay-class_+3A_x">x</code></td>
<td>
<p>An <code>SCTAssay</code> object</p>
</td></tr>
<tr><td><code id="SCTAssay-class_+3A_value">value</code></td>
<td>
<p>New levels, must be in the same order as the levels present</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>levels</code>: SCT model names
</p>
<p><code>levels&lt;-</code>: <code>x</code> with updated SCT model names
</p>


<h3>Slots</h3>


<dl>
<dt><code>feature.attributes</code></dt><dd><p>A data.frame with feature attributes in SCTransform</p>
</dd>
<dt><code>cell.attributes</code></dt><dd><p>A data.frame with cell attributes in SCTransform</p>
</dd>
<dt><code>clips</code></dt><dd><p>A list of two numeric of length two specifying the min and max
values the Pearson residual will be clipped to. One for vst and one for
SCTransform</p>
</dd>
<dt><code>umi.assay</code></dt><dd><p>Name of the assay of the seurat object containing UMI matrix
and the default is RNA</p>
</dd>
<dt><code>model</code></dt><dd><p>A formula used in SCTransform</p>
</dd>
<dt><code>arguments</code></dt><dd><p>other information used in SCTransform</p>
</dd>
<dt><code>median_umi</code></dt><dd><p>Median UMI (or scale factor) used to calculate corrected counts</p>
</dd>
<dt><code>SCTModel.list</code></dt><dd><p>A list containing SCT models</p>
</dd>
</dl>


<h3>Get and set SCT model names</h3>

<p>SCT results are named by initial run of <code><a href="#topic+SCTransform">SCTransform</a></code> in order
to keep SCT parameters straight between runs. When working with merged
<code>SCTAssay</code> objects, these model names are important. <code>levels</code>
allows querying the models present. <code>levels&lt;-</code> allows the changing of
the names of the models present, useful when merging <code>SCTAssay</code> objects.
Note: unlike normal <code><a href="base.html#topic+levels+3C-">levels&lt;-</a></code>, <code>levels&lt;-.SCTAssay</code>
allows complete changing of model names, not reordering.
</p>


<h3>Creating an <code>SCTAssay</code> from an <code>Assay</code></h3>

<p>Conversion from an <code>Assay</code> object to an <code>SCTAssay</code> object by
is done by adding the additional slots to the object. If <code>from</code> has
results generated by <code><a href="#topic+SCTransform">SCTransform</a></code> from Seurat v3.0.0 to v3.1.1,
the conversion will automagically fill the new slots with the data
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+Assay">Assay</a></code>
</p>
<p><code><a href="nlme.html#topic+Assay">Assay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# SCTAssay objects are generated from SCTransform
pbmc_small &lt;- SCTransform(pbmc_small)

## End(Not run)

## Not run: 
# SCTAssay objects are generated from SCTransform
pbmc_small &lt;- SCTransform(pbmc_small)
pbmc_small[["SCT"]]

## End(Not run)

## Not run: 
# Query and change SCT model names
levels(pbmc_small[['SCT']])
levels(pbmc_small[['SCT']]) &lt;- '3'
levels(pbmc_small[['SCT']])

## End(Not run)

</code></pre>

<hr>
<h2 id='SCTransform'>Perform sctransform-based normalization</h2><span id='topic+SCTransform'></span><span id='topic+SCTransform.default'></span><span id='topic+SCTransform.Assay'></span><span id='topic+SCTransform.Seurat'></span><span id='topic+SCTransform.IterableMatrix'></span>

<h3>Description</h3>

<p>This function calls sctransform::vst. The sctransform package is available at
https://github.com/satijalab/sctransform.
Use this function as an alternative to the NormalizeData,
FindVariableFeatures, ScaleData workflow. Results are saved in a new assay
(named SCT by default) with counts being (corrected) counts, data being log1p(counts),
scale.data being pearson residuals; sctransform::vst intermediate results are saved
in misc slot of new assay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCTransform(object, ...)

## Default S3 method:
SCTransform(
  object,
  cell.attr,
  reference.SCT.model = NULL,
  do.correct.umi = TRUE,
  ncells = 5000,
  residual.features = NULL,
  variable.features.n = 3000,
  variable.features.rv.th = 1.3,
  vars.to.regress = NULL,
  latent.data = NULL,
  do.scale = FALSE,
  do.center = TRUE,
  clip.range = c(-sqrt(x = ncol(x = umi)/30), sqrt(x = ncol(x = umi)/30)),
  vst.flavor = "v2",
  conserve.memory = FALSE,
  return.only.var.genes = TRUE,
  seed.use = 1448145,
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
SCTransform(
  object,
  cell.attr,
  reference.SCT.model = NULL,
  do.correct.umi = TRUE,
  ncells = 5000,
  residual.features = NULL,
  variable.features.n = 3000,
  variable.features.rv.th = 1.3,
  vars.to.regress = NULL,
  latent.data = NULL,
  do.scale = FALSE,
  do.center = TRUE,
  clip.range = c(-sqrt(x = ncol(x = object)/30), sqrt(x = ncol(x = object)/30)),
  vst.flavor = "v2",
  conserve.memory = FALSE,
  return.only.var.genes = TRUE,
  seed.use = 1448145,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
SCTransform(
  object,
  assay = "RNA",
  new.assay.name = "SCT",
  reference.SCT.model = NULL,
  do.correct.umi = TRUE,
  ncells = 5000,
  residual.features = NULL,
  variable.features.n = 3000,
  variable.features.rv.th = 1.3,
  vars.to.regress = NULL,
  do.scale = FALSE,
  do.center = TRUE,
  clip.range = c(-sqrt(x = ncol(x = object[[assay]])/30), sqrt(x = ncol(x =
    object[[assay]])/30)),
  vst.flavor = "v2",
  conserve.memory = FALSE,
  return.only.var.genes = TRUE,
  seed.use = 1448145,
  verbose = TRUE,
  ...
)

## S3 method for class 'IterableMatrix'
SCTransform(
  object,
  cell.attr,
  reference.SCT.model = NULL,
  do.correct.umi = TRUE,
  ncells = 5000,
  residual.features = NULL,
  variable.features.n = 3000,
  variable.features.rv.th = 1.3,
  vars.to.regress = NULL,
  latent.data = NULL,
  do.scale = FALSE,
  do.center = TRUE,
  clip.range = c(-sqrt(x = ncol(x = object)/30), sqrt(x = ncol(x = object)/30)),
  vst.flavor = "v2",
  conserve.memory = FALSE,
  return.only.var.genes = TRUE,
  seed.use = 1448145,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCTransform_+3A_object">object</code></td>
<td>
<p>UMI counts matrix</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>sctransform::vst</code></p>
</td></tr>
<tr><td><code id="SCTransform_+3A_cell.attr">cell.attr</code></td>
<td>
<p>A metadata with cell attributes</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_reference.sct.model">reference.SCT.model</code></td>
<td>
<p>If not NULL, compute residuals for the object
using the provided SCT model; supports only log_umi as the latent variable.
If residual.features are not specified, compute for the top variable.features.n
specified in the model which are also present in the object. If
residual.features are specified, the variable features of the resulting SCT
assay are set to the top variable.features.n in the model.</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_do.correct.umi">do.correct.umi</code></td>
<td>
<p>Place corrected UMI matrix in assay counts slot; default is TRUE</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_ncells">ncells</code></td>
<td>
<p>Number of subsampling cells used to build NB regression; default is 5000</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_residual.features">residual.features</code></td>
<td>
<p>Genes to calculate residual features for; default is NULL (all genes).
If specified, will be set to VariableFeatures of the returned object.</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_variable.features.n">variable.features.n</code></td>
<td>
<p>Use this many features as variable features after
ranking by residual variance; default is 3000. Only applied if residual.features is not set.</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_variable.features.rv.th">variable.features.rv.th</code></td>
<td>
<p>Instead of setting a fixed number of variable features,
use this residual variance cutoff; this is only used when <code>variable.features.n</code>
is set to NULL; default is 1.3. Only applied if residual.features is not set.</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_vars.to.regress">vars.to.regress</code></td>
<td>
<p>Variables to regress out in a second non-regularized linear</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_latent.data">latent.data</code></td>
<td>
<p>Extra data to regress out, should be cells x latent data
regression. For example, percent.mito. Default is NULL</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_do.scale">do.scale</code></td>
<td>
<p>Whether to scale residuals to have unit variance; default is FALSE</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_do.center">do.center</code></td>
<td>
<p>Whether to center residuals to have mean zero; default is TRUE</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_clip.range">clip.range</code></td>
<td>
<p>Range to clip the residuals to; default is <code>c(-sqrt(n/30), sqrt(n/30))</code>,
where n is the number of cells</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_vst.flavor">vst.flavor</code></td>
<td>
<p>When set to 'v2' sets method = glmGamPoi_offset, n_cells=2000,
and exclude_poisson = TRUE which causes the model to learn theta and intercept
only besides excluding poisson genes from learning and regularization</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_conserve.memory">conserve.memory</code></td>
<td>
<p>If set to TRUE the residual matrix for all genes is never
created in full; useful for large data sets, but will take longer to run;
this will also set return.only.var.genes to TRUE; default is FALSE</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_return.only.var.genes">return.only.var.genes</code></td>
<td>
<p>If set to TRUE the scale.data matrices in output assay are
subset to contain only the variable genes; default is TRUE</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_seed.use">seed.use</code></td>
<td>
<p>Set a random seed. By default, sets the seed to 1448145. Setting
NULL will not set a seed.</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages and progress bars</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_assay">assay</code></td>
<td>
<p>Name of assay to pull the count data from; default is 'RNA'</p>
</td></tr>
<tr><td><code id="SCTransform_+3A_new.assay.name">new.assay.name</code></td>
<td>
<p>Name for the new assay containing the normalized data; default is 'SCT'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object with a new assay (named SCT by default) with
counts being (corrected) counts, data being log1p(counts), scale.data being
pearson residuals; sctransform::vst intermediate results are saved in misc
slot of the new assay.
</p>


<h3>See Also</h3>

<p><code><a href="sctransform.html#topic+correct_counts">correct_counts</a></code> <code><a href="sctransform.html#topic+get_residuals">get_residuals</a></code>
</p>

<hr>
<h2 id='SCTResults'>Get SCT results from an Assay</h2><span id='topic+SCTResults'></span><span id='topic+SCTResults+3C-'></span><span id='topic+SCTResults.SCTModel'></span><span id='topic+SCTResults+3C-.SCTModel'></span><span id='topic+SCTResults.SCTAssay'></span><span id='topic+SCTResults+3C-.SCTAssay'></span><span id='topic+SCTResults.Seurat'></span>

<h3>Description</h3>

<p>Pull the <code><a href="#topic+SCTResults">SCTResults</a></code> information from an <code><a href="#topic+SCTAssay">SCTAssay</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCTResults(object, ...)

SCTResults(object, ...) &lt;- value

## S3 method for class 'SCTModel'
SCTResults(object, slot, ...)

## S3 replacement method for class 'SCTModel'
SCTResults(object, slot, ...) &lt;- value

## S3 method for class 'SCTAssay'
SCTResults(object, slot, model = NULL, ...)

## S3 replacement method for class 'SCTAssay'
SCTResults(object, slot, model = NULL, ...) &lt;- value

## S3 method for class 'Seurat'
SCTResults(object, assay = "SCT", slot, model = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCTResults_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="SCTResults_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods (not used)</p>
</td></tr>
<tr><td><code id="SCTResults_+3A_value">value</code></td>
<td>
<p>new data to set</p>
</td></tr>
<tr><td><code id="SCTResults_+3A_slot">slot</code></td>
<td>
<p>Which slot to pull the SCT results from</p>
</td></tr>
<tr><td><code id="SCTResults_+3A_model">model</code></td>
<td>
<p>Name of SCModel to pull result from. Available names can be
retrieved with <code>levels</code>.</p>
</td></tr>
<tr><td><code id="SCTResults_+3A_assay">assay</code></td>
<td>
<p>Assay in the Seurat object to pull from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value present in the requested slot for the requested
group. If group is not specified, returns a list of slot results for each
group unless there is only one group present (in which case it just returns
the slot directly).
</p>

<hr>
<h2 id='SelectIntegrationFeatures'>Select integration features</h2><span id='topic+SelectIntegrationFeatures'></span>

<h3>Description</h3>

<p>Choose the features to use when integrating multiple datasets. This function
ranks features by the number of datasets they are deemed variable in,
breaking ties by the median variable feature rank across datasets. It returns
the top scoring features by this ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectIntegrationFeatures(
  object.list,
  nfeatures = 2000,
  assay = NULL,
  verbose = TRUE,
  fvf.nfeatures = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectIntegrationFeatures_+3A_object.list">object.list</code></td>
<td>
<p>List of seurat objects</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to return</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures_+3A_assay">assay</code></td>
<td>
<p>Name or vector of assay names (one for each object) from which
to pull the variable features.</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Print messages</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures_+3A_fvf.nfeatures">fvf.nfeatures</code></td>
<td>
<p>nfeatures for <code><a href="#topic+FindVariableFeatures">FindVariableFeatures</a></code>. Used
if <code>VariableFeatures</code> have not been set for any object in
<code>object.list</code>.</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="#topic+FindVariableFeatures">FindVariableFeatures</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If for any assay in the list, <code><a href="#topic+FindVariableFeatures">FindVariableFeatures</a></code> hasn't been
run, this method will try to run it using the <code>fvf.nfeatures</code> parameter
and any additional ones specified through the ....
</p>


<h3>Value</h3>

<p>A vector of selected features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("panc8")

# panc8 is a merged Seurat object containing 8 separate pancreas datasets
# split the object by dataset and take the first 2
pancreas.list &lt;- SplitObject(panc8, split.by = "tech")[1:2]

# perform SCTransform normalization
pancreas.list &lt;- lapply(X = pancreas.list, FUN = SCTransform)

# select integration features
features &lt;- SelectIntegrationFeatures(pancreas.list)

## End(Not run)

</code></pre>

<hr>
<h2 id='SelectIntegrationFeatures5'>Select integration features</h2><span id='topic+SelectIntegrationFeatures5'></span>

<h3>Description</h3>

<p>Select integration features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectIntegrationFeatures5(
  object,
  nfeatures = 2000,
  assay = NULL,
  method = NULL,
  layers = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectIntegrationFeatures5_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures5_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to return for integration</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures5_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use for integration feature selection</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures5_+3A_method">method</code></td>
<td>
<p>Which method to pull. For <code>HVFInfo</code> and
<code>VariableFeatures</code>, choose one from one of the
following:
</p>

<ul>
<li> <p>&ldquo;vst&rdquo;
</p>
</li>
<li> <p>&ldquo;sctransform&rdquo; or &ldquo;sct&rdquo;
</p>
</li>
<li> <p>&ldquo;mean.var.plot&rdquo;, &ldquo;dispersion&rdquo;, &ldquo;mvp&rdquo;, or
&ldquo;disp&rdquo;
</p>
</li></ul>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures5_+3A_layers">layers</code></td>
<td>
<p>Name of layers to use for integration feature selection</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures5_+3A_verbose">verbose</code></td>
<td>
<p>Print messages</p>
</td></tr>
<tr><td><code id="SelectIntegrationFeatures5_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>method</code></p>
</td></tr>
</table>

<hr>
<h2 id='SelectSCTIntegrationFeatures'>Select SCT integration features</h2><span id='topic+SelectSCTIntegrationFeatures'></span>

<h3>Description</h3>

<p>Select SCT integration features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectSCTIntegrationFeatures(
  object,
  nfeatures = 3000,
  assay = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectSCTIntegrationFeatures_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="SelectSCTIntegrationFeatures_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to return for integration</p>
</td></tr>
<tr><td><code id="SelectSCTIntegrationFeatures_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use for integration feature selection</p>
</td></tr>
<tr><td><code id="SelectSCTIntegrationFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Print messages</p>
</td></tr>
<tr><td><code id="SelectSCTIntegrationFeatures_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>method</code></p>
</td></tr>
</table>

<hr>
<h2 id='SetIntegrationData'>Set integration data</h2><span id='topic+SetIntegrationData'></span>

<h3>Description</h3>

<p>Set integration data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetIntegrationData(object, integration.name, slot, new.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetIntegrationData_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="SetIntegrationData_+3A_integration.name">integration.name</code></td>
<td>
<p>Name of integration object</p>
</td></tr>
<tr><td><code id="SetIntegrationData_+3A_slot">slot</code></td>
<td>
<p>Which slot in integration object to set</p>
</td></tr>
<tr><td><code id="SetIntegrationData_+3A_new.data">new.data</code></td>
<td>
<p>New data to insert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+Seurat">Seurat</a></code> object
</p>

<hr>
<h2 id='SetQuantile'>Find the Quantile of Data</h2><span id='topic+SetQuantile'></span>

<h3>Description</h3>

<p>Converts a quantile in character form to a number regarding some data.
String form for a quantile is represented as a number prefixed with
&ldquo;q&rdquo;; for example, 10th quantile is &ldquo;q10&rdquo; while 2nd quantile is
&ldquo;q2&rdquo;. Will only take a quantile of non-zero data values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetQuantile(cutoff, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetQuantile_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff to turn into a quantile</p>
</td></tr>
<tr><td><code id="SetQuantile_+3A_data">data</code></td>
<td>
<p>The data to turn find the quantile of</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numerical representation of the quantile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
SetQuantile('q10', sample(1:100, 10))

</code></pre>

<hr>
<h2 id='Seurat-class'>The Seurat Class</h2><span id='topic+Seurat-class'></span>

<h3>Description</h3>

<p>The Seurat object is a representation of single-cell expression data for R;
for more details, please see the documentation in
<code><a href="SeuratObject.html#topic+Seurat">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+Seurat">SeuratObject::Seurat-class</a></code>
</p>

<hr>
<h2 id='Seurat-package'>Seurat: Tools for Single Cell Genomics</h2><span id='topic+Seurat'></span><span id='topic+Seurat-package'></span>

<h3>Description</h3>

<p>A toolkit for quality control, analysis, and exploration of single cell RNA sequencing data. 'Seurat' aims to enable users to identify and interpret sources of heterogeneity from single cell transcriptomic measurements, and to integrate diverse types of single cell data. See Satija R, Farrell J, Gennert D, et al (2015) <a href="https://doi.org/10.1038/nbt.3192">doi:10.1038/nbt.3192</a>, Macosko E, Basu A, Satija R, et al (2015) <a href="https://doi.org/10.1016/j.cell.2015.05.002">doi:10.1016/j.cell.2015.05.002</a>, Stuart T, Butler A, et al (2019) <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>, and Hao, Hao, et al (2020) <a href="https://doi.org/10.1101/2020.10.12.335331">doi:10.1101/2020.10.12.335331</a> for more details.
</p>


<h3>Package options</h3>

<p>Seurat uses the following [options()] to configure behaviour:
</p>

<dl>
<dt><code>Seurat.memsafe</code></dt><dd><p>global option to call gc() after many operations.
This can be helpful in cleaning up the memory status of the R session and
prevent use of swap space. However, it does add to the computational overhead
and setting to FALSE can speed things up if you're working in an environment
where RAM availability is not a concern.</p>
</dd>
<dt><code>Seurat.warn.umap.uwot</code></dt><dd><p>Show warning about the default backend
for <code><a href="#topic+RunUMAP">RunUMAP</a></code> changing from Python UMAP via reticulate to UWOT</p>
</dd>
<dt><code>Seurat.checkdots</code></dt><dd><p>For functions that have ... as a parameter,
this controls the behavior when an item isn't used. Can be one of warn,
stop, or silent.</p>
</dd>
<dt><code>Seurat.limma.wilcox.msg</code></dt><dd><p>Show message about more efficient
Wilcoxon Rank Sum test available via the limma package</p>
</dd>
<dt><code>Seurat.Rfast2.msg</code></dt><dd><p>Show message about more efficient
Moran's I function available via the Rfast2 package</p>
</dd>
<dt><code>Seurat.warn.vlnplot.split</code></dt><dd><p>Show message about changes to
default behavior of split/multi violin plots</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rahul Satija <a href="mailto:seurat@nygenome.org">seurat@nygenome.org</a> (<a href="https://orcid.org/0000-0001-9448-8833">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Andrew Butler <a href="mailto:abutler@nygenome.org">abutler@nygenome.org</a> (<a href="https://orcid.org/0000-0003-3608-0463">ORCID</a>) [contributor]
</p>
</li>
<li><p> Saket Choudhary <a href="mailto:schoudhary@nygenome.org">schoudhary@nygenome.org</a> (<a href="https://orcid.org/0000-0001-5202-7633">ORCID</a>) [contributor]
</p>
</li>
<li><p> Charlotte Darby <a href="mailto:cdarby@nygenome.org">cdarby@nygenome.org</a> (<a href="https://orcid.org/0000-0003-2195-5300">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jeff Farrell <a href="mailto:jfarrell@g.harvard.edu">jfarrell@g.harvard.edu</a> [contributor]
</p>
</li>
<li><p> Isabella Grabski <a href="mailto:igrabski@nygenome.org">igrabski@nygenome.org</a> (<a href="https://orcid.org/0000-0002-0616-5469">ORCID</a>) [contributor]
</p>
</li>
<li><p> Christoph Hafemeister <a href="mailto:chafemeister@nygenome.org">chafemeister@nygenome.org</a> (<a href="https://orcid.org/0000-0001-6365-8254">ORCID</a>) [contributor]
</p>
</li>
<li><p> Yuhan Hao <a href="mailto:yhao@nygenome.org">yhao@nygenome.org</a> (<a href="https://orcid.org/0000-0002-1810-0822">ORCID</a>) [contributor]
</p>
</li>
<li><p> Austin Hartman <a href="mailto:ahartman@nygenome.org">ahartman@nygenome.org</a> (<a href="https://orcid.org/0000-0001-7278-1852">ORCID</a>) [contributor]
</p>
</li>
<li><p> Paul Hoffman <a href="mailto:hoff0792@umn.edu">hoff0792@umn.edu</a> (<a href="https://orcid.org/0000-0002-7693-8957">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jaison Jain <a href="mailto:jjain@nygenome.org">jjain@nygenome.org</a> (<a href="https://orcid.org/0000-0002-9478-5018">ORCID</a>) [contributor]
</p>
</li>
<li><p> Longda Jiang <a href="mailto:ljiang@nygenome.org">ljiang@nygenome.org</a> (<a href="https://orcid.org/0000-0003-4964-6497">ORCID</a>) [contributor]
</p>
</li>
<li><p> Madeline Kowalski <a href="mailto:mkowalski@nygenome.org">mkowalski@nygenome.org</a> (<a href="https://orcid.org/0000-0002-5655-7620">ORCID</a>) [contributor]
</p>
</li>
<li><p> Skylar Li <a href="mailto:sli@nygenome.org">sli@nygenome.org</a> [contributor]
</p>
</li>
<li><p> Gesmira Molla <a href="mailto:gmolla@nygenome.org">gmolla@nygenome.org</a> (<a href="https://orcid.org/0000-0002-8628-5056">ORCID</a>) [contributor]
</p>
</li>
<li><p> Efthymia Papalexi <a href="mailto:epapalexi@nygenome.org">epapalexi@nygenome.org</a> (<a href="https://orcid.org/0000-0001-5898-694X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Patrick Roelli <a href="mailto:proelli@nygenome.org">proelli@nygenome.org</a> [contributor]
</p>
</li>
<li><p> Karthik Shekhar <a href="mailto:kshekhar@berkeley.edu">kshekhar@berkeley.edu</a> [contributor]
</p>
</li>
<li><p> Avi Srivastava <a href="mailto:asrivastava@nygenome.org">asrivastava@nygenome.org</a> (<a href="https://orcid.org/0000-0001-9798-2079">ORCID</a>) [contributor]
</p>
</li>
<li><p> Tim Stuart <a href="mailto:tstuart@nygenome.org">tstuart@nygenome.org</a> (<a href="https://orcid.org/0000-0002-3044-0897">ORCID</a>) [contributor]
</p>
</li>
<li><p> Kristof Torkenczy (<a href="https://orcid.org/0000-0002-4869-7957">ORCID</a>) [contributor]
</p>
</li>
<li><p> Shiwei Zheng <a href="mailto:szheng@nygenome.org">szheng@nygenome.org</a> (<a href="https://orcid.org/0000-0001-6682-6743">ORCID</a>) [contributor]
</p>
</li>
<li><p> Satija Lab and Collaborators [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://satijalab.org/seurat">https://satijalab.org/seurat</a>
</p>
</li>
<li> <p><a href="https://github.com/satijalab/seurat">https://github.com/satijalab/seurat</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/satijalab/seurat/issues">https://github.com/satijalab/seurat/issues</a>
</p>
</li></ul>


<hr>
<h2 id='SeuratCommand-class'>The SeuratCommand Class</h2><span id='topic+SeuratCommand-class'></span>

<h3>Description</h3>

<p>For more details, please see the documentation in
<code><a href="SeuratObject.html#topic+SeuratCommand">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+SeuratCommand">SeuratObject::SeuratCommand-class</a></code>
</p>

<hr>
<h2 id='SeuratTheme'>Seurat Themes</h2><span id='topic+SeuratTheme'></span><span id='topic+CenterTitle'></span><span id='topic+DarkTheme'></span><span id='topic+FontSize'></span><span id='topic+NoAxes'></span><span id='topic+NoLegend'></span><span id='topic+NoGrid'></span><span id='topic+SeuratAxes'></span><span id='topic+SpatialTheme'></span><span id='topic+RestoreLegend'></span><span id='topic+RotatedAxis'></span><span id='topic+BoldTitle'></span><span id='topic+WhiteBackground'></span>

<h3>Description</h3>

<p>Various themes to be applied to ggplot2-based plots
</p>

<dl>
<dt><code>SeuratTheme</code></dt><dd><p>The curated Seurat theme, consists of ...</p>
</dd>
<dt><code>DarkTheme</code></dt><dd><p>A dark theme, axes and text turn to white, the background becomes black</p>
</dd>
<dt><code>NoAxes</code></dt><dd><p>Removes axis lines, text, and ticks</p>
</dd>
<dt><code>NoLegend</code></dt><dd><p>Removes the legend</p>
</dd>
<dt><code>FontSize</code></dt><dd><p>Sets axis and title font sizes</p>
</dd>
<dt><code>NoGrid</code></dt><dd><p>Removes grid lines</p>
</dd>
<dt><code>SeuratAxes</code></dt><dd><p>Set Seurat-style axes</p>
</dd>
<dt><code>SpatialTheme</code></dt><dd><p>A theme designed for spatial visualizations (eg <code><a href="#topic+PolyFeaturePlot">PolyFeaturePlot</a></code>, <code><a href="#topic+PolyDimPlot">PolyDimPlot</a></code>)</p>
</dd>
<dt><code>RestoreLegend</code></dt><dd><p>Restore a legend after removal</p>
</dd>
<dt><code>RotatedAxis</code></dt><dd><p>Rotate X axis text 45 degrees</p>
</dd>
<dt><code>BoldTitle</code></dt><dd><p>Enlarges and emphasizes the title</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>SeuratTheme()

CenterTitle(...)

DarkTheme(...)

FontSize(
  x.text = NULL,
  y.text = NULL,
  x.title = NULL,
  y.title = NULL,
  main = NULL,
  ...
)

NoAxes(..., keep.text = FALSE, keep.ticks = FALSE)

NoLegend(...)

NoGrid(...)

SeuratAxes(...)

SpatialTheme(...)

RestoreLegend(..., position = "right")

RotatedAxis(...)

BoldTitle(...)

WhiteBackground(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeuratTheme_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to <code>theme</code></p>
</td></tr>
<tr><td><code id="SeuratTheme_+3A_x.text">x.text</code>, <code id="SeuratTheme_+3A_y.text">y.text</code></td>
<td>
<p>X and Y axis text sizes</p>
</td></tr>
<tr><td><code id="SeuratTheme_+3A_x.title">x.title</code>, <code id="SeuratTheme_+3A_y.title">y.title</code></td>
<td>
<p>X and Y axis title sizes</p>
</td></tr>
<tr><td><code id="SeuratTheme_+3A_main">main</code></td>
<td>
<p>Plot title size</p>
</td></tr>
<tr><td><code id="SeuratTheme_+3A_keep.text">keep.text</code></td>
<td>
<p>Keep axis text</p>
</td></tr>
<tr><td><code id="SeuratTheme_+3A_keep.ticks">keep.ticks</code></td>
<td>
<p>Keep axis ticks</p>
</td></tr>
<tr><td><code id="SeuratTheme_+3A_position">position</code></td>
<td>
<p>A position to restore the legend to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 theme object
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+theme">theme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a plot with a dark theme
library(ggplot2)
df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
p &lt;- ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(mapping = aes(color = 'red'))
p + DarkTheme(legend.position = 'none')

# Generate a plot with no axes
library(ggplot2)
df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
p &lt;- ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(mapping = aes(color = 'red'))
p + NoAxes()

# Generate a plot with no legend
library(ggplot2)
df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
p &lt;- ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(mapping = aes(color = 'red'))
p + NoLegend()

# Generate a plot with no grid lines
library(ggplot2)
df &lt;- data.frame(x = rnorm(n = 100, mean = 20, sd = 2), y = rbinom(n = 100, size = 100, prob = 0.2))
p &lt;- ggplot(data = df, mapping = aes(x = x, y = y)) + geom_point(mapping = aes(color = 'red'))
p + NoGrid()

</code></pre>

<hr>
<h2 id='SingleCorPlot'>A single correlation plot</h2><span id='topic+SingleCorPlot'></span>

<h3>Description</h3>

<p>A single correlation plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleCorPlot(
  data,
  col.by = NULL,
  cols = NULL,
  pt.size = NULL,
  smooth = FALSE,
  rows.highlight = NULL,
  legend.title = NULL,
  na.value = "grey50",
  span = NULL,
  raster = NULL,
  raster.dpi = NULL,
  plot.cor = TRUE,
  jitter = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleCorPlot_+3A_data">data</code></td>
<td>
<p>A data frame with two columns to be plotted</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_col.by">col.by</code></td>
<td>
<p>A vector or factor of values to color the plot by</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_cols">cols</code></td>
<td>
<p>An optional vector of colors to use</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Point size for the plot</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_smooth">smooth</code></td>
<td>
<p>Make a smoothed scatter plot</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_rows.highlight">rows.highlight</code></td>
<td>
<p>A vector of rows to highlight (like cells.highlight in
<code><a href="#topic+SingleDimPlot">SingleDimPlot</a></code>)</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>Optional legend title</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code>
which will automatically use raster if the number of points plotted is
greater than 100,000</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>the pixel resolution for rastered plots, passed to geom_scattermore().
Default is c(512, 512)</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_plot.cor">plot.cor</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="SingleCorPlot_+3A_jitter">jitter</code></td>
<td>
<p>Jitter for easier visualization of crowded points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='SingleDimPlot'>Plot a single dimension</h2><span id='topic+SingleDimPlot'></span>

<h3>Description</h3>

<p>Plot a single dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleDimPlot(
  data,
  dims,
  col.by = NULL,
  cols = NULL,
  pt.size = NULL,
  shape.by = NULL,
  alpha = 1,
  alpha.by = NULL,
  order = NULL,
  label = FALSE,
  repel = FALSE,
  label.size = 4,
  cells.highlight = NULL,
  cols.highlight = "#DE2D26",
  sizes.highlight = 1,
  na.value = "grey50",
  raster = NULL,
  raster.dpi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleDimPlot_+3A_data">data</code></td>
<td>
<p>Data to plot</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_dims">dims</code></td>
<td>
<p>A two-length numeric vector with dimensions to use</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_col.by">col.by</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_cols">cols</code></td>
<td>
<p>Vector of colors, each color corresponds to an identity class.
This may also be a single character or numeric value corresponding to a
palette as specified by <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>.By
default, ggplot2 assigns colors</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Adjust point size for plotting</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_shape.by">shape.by</code></td>
<td>
<p>If NULL, all points are circles (default). You can specify
any cell attribute (that can be pulled with <code><a href="#topic+FetchData">FetchData</a></code>)
allowing for both different colors and different shapes on cells.</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for plotting (default is 1)</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_alpha.by">alpha.by</code></td>
<td>
<p>Mapping variable for the point alpha value</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_order">order</code></td>
<td>
<p>Specify the order of plotting for the idents. This can be
useful for crowded plots if points of interest are being buried. Provide
either a full list of valid idents or a subset to be plotted last (on top).</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_label">label</code></td>
<td>
<p>Whether to label the clusters</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_repel">repel</code></td>
<td>
<p>Repel labels</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_label.size">label.size</code></td>
<td>
<p>Sets size of labels</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_cells.highlight">cells.highlight</code></td>
<td>
<p>A list of character or numeric vectors of cells to
highlight. If only one group of cells desired, can simply
pass a vector instead of a list. If set, colors selected cells to the color(s)
in <code>cols.highlight</code> and other cells black (white if dark.theme = TRUE);
will also resize to the size(s) passed to <code>sizes.highlight</code></p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_cols.highlight">cols.highlight</code></td>
<td>
<p>A vector of colors to highlight the cells as; will
repeat to the length groups in cells.highlight</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_sizes.highlight">sizes.highlight</code></td>
<td>
<p>Size of highlighted cells; will repeat to the length
groups in cells.highlight</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_na.value">na.value</code></td>
<td>
<p>Color value for NA points when using custom scale.</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code>
which will automatically use raster if the number of points plotted is
greater than 100,000</p>
</td></tr>
<tr><td><code id="SingleDimPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>the pixel resolution for rastered plots, passed to geom_scattermore().
Default is c(512, 512)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='SingleExIPlot'>Plot a single expression by identity on a plot</h2><span id='topic+SingleExIPlot'></span>

<h3>Description</h3>

<p>Plot a single expression by identity on a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleExIPlot(
  data,
  idents,
  split = NULL,
  type = "violin",
  sort = FALSE,
  y.max = NULL,
  adjust = 1,
  pt.size = 0,
  alpha = 1,
  cols = NULL,
  seed.use = 42,
  log = FALSE,
  add.noise = TRUE,
  raster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleExIPlot_+3A_data">data</code></td>
<td>
<p>Data to plot</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_idents">idents</code></td>
<td>
<p>Idents to use</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_split">split</code></td>
<td>
<p>Use a split violin plot</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_type">type</code></td>
<td>
<p>Make either a &ldquo;ridge&rdquo; or &ldquo;violin&rdquo; plot</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_sort">sort</code></td>
<td>
<p>Sort identity classes (on the x-axis) by the average
expression of the attribute being potted</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_y.max">y.max</code></td>
<td>
<p>Maximum Y value to plot</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_adjust">adjust</code></td>
<td>
<p>Adjust parameter for geom_violin</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Size of points for violin plots</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha vlaue for violin plots</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_cols">cols</code></td>
<td>
<p>Colors to use for plotting</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_seed.use">seed.use</code></td>
<td>
<p>Random seed to use. If NULL, don't set a seed</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_log">log</code></td>
<td>
<p>plot Y axis on log10 scale</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_add.noise">add.noise</code></td>
<td>
<p>determine if adding small noise for plotting</p>
</td></tr>
<tr><td><code id="SingleExIPlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format. Requires 'ggrastr' to be installed.
default is <code>NULL</code> which automatically rasterizes if ggrastr is installed and
number of points exceed 100,000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot-based Expression-by-Identity plot
</p>

<hr>
<h2 id='SingleImageMap'>A single heatmap from base R using <code><a href="graphics.html#topic+image">image</a></code></h2><span id='topic+SingleImageMap'></span>

<h3>Description</h3>

<p>A single heatmap from base R using <code><a href="graphics.html#topic+image">image</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleImageMap(data, order = NULL, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleImageMap_+3A_data">data</code></td>
<td>
<p>matrix of data to plot</p>
</td></tr>
<tr><td><code id="SingleImageMap_+3A_order">order</code></td>
<td>
<p>optional vector of cell names to specify order in plot</p>
</td></tr>
<tr><td><code id="SingleImageMap_+3A_title">title</code></td>
<td>
<p>Title for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return, generates a base-R heatmap using <code><a href="graphics.html#topic+image">image</a></code>
</p>

<hr>
<h2 id='SingleImagePlot'>Single Spatial Plot</h2><span id='topic+SingleImagePlot'></span>

<h3>Description</h3>

<p>Single Spatial Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleImagePlot(
  data,
  col.by = NA,
  col.factor = TRUE,
  cols = NULL,
  shuffle.cols = FALSE,
  size = 0.1,
  molecules = NULL,
  mols.size = 0.1,
  mols.cols = NULL,
  mols.alpha = 1,
  alpha = molecules %iff% 0.3 %||% 0.6,
  border.color = "white",
  border.size = NULL,
  na.value = "grey50",
  dark.background = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleImagePlot_+3A_data">data</code></td>
<td>
<p>A data frame with at least the following columns:
</p>

<ul>
<li> <p>&ldquo;<code>x</code>&rdquo;: Spatial-resolved <em>x</em> coordinates, will be
plotted on the <em>y</em>-axis
</p>
</li>
<li> <p>&ldquo;<code>y</code>&rdquo;: Spatially-resolved <em>y</em> coordinates, will be
plotted on the <em>x</em>-axis
</p>
</li>
<li> <p>&ldquo;<code>cell</code>&rdquo;: Cell name
</p>
</li>
<li> <p>&ldquo;<code>boundary</code>&rdquo;: Segmentation boundary label; when plotting
multiple segmentation layers, the order of boundary transparency is set by
factor levels for this column
</p>
</li></ul>

<p>Can pass <code>NA</code> to <code>data</code> suppress segmentation visualization</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_col.by">col.by</code></td>
<td>
<p>Name of column in <code>data</code> to color cell segmentations by;
pass <code>NA</code> to suppress coloring</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_col.factor">col.factor</code></td>
<td>
<p>Are the colors a factor or discrete?</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_cols">cols</code></td>
<td>
<p>Colors for cell segmentations; can be one of the
following:
</p>

<ul>
<li> <p><code>NULL</code> for default ggplot2 colors
</p>
</li>
<li><p> A numeric value or name of a
<a href="RColorBrewer.html#topic+RColorBrewer">color brewer palette</a>
</p>
</li>
<li><p> Name of a palette for <code><a href="#topic+DiscretePalette">DiscretePalette</a></code>
</p>
</li>
<li><p> A vector of colors equal to the length of unique levels of
<code>data$col.by</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_shuffle.cols">shuffle.cols</code></td>
<td>
<p>Randomly shuffle colors when a palette or
vector of colors is provided to <code>cols</code></p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_size">size</code></td>
<td>
<p>Point size for cells when plotting centroids</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_molecules">molecules</code></td>
<td>
<p>A data frame with spatially-resolved molecule coordinates;
should have the following columns:
</p>

<ul>
<li> <p>&ldquo;<code>x</code>&rdquo;: Spatial-resolved <em>x</em> coordinates, will be
plotted on the <em>y</em>-axis
</p>
</li>
<li> <p>&ldquo;<code>y</code>&rdquo;: Spatially-resolved <em>y</em> coordinates, will be
plotted on the <em>x</em>-axis
</p>
</li>
<li> <p>&ldquo;<code>molecule</code>&rdquo;: Molecule name
</p>
</li></ul>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_mols.size">mols.size</code></td>
<td>
<p>Point size for molecules</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_mols.cols">mols.cols</code></td>
<td>
<p>A vector of color for molecules. The &quot;Set1&quot; palette from
RColorBrewer is used by default.</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_mols.alpha">mols.alpha</code></td>
<td>
<p>Alpha value for molecules, should be between 0 and 1</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value, should be between 0 and 1; when plotting multiple
boundaries, <code>alpha</code> is equivalent to max alpha</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_border.color">border.color</code></td>
<td>
<p>Color of cell segmentation border; pass <code>NA</code>
to suppress borders for segmentation-based plots</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_border.size">border.size</code></td>
<td>
<p>Thickness of cell segmentation borders; pass <code>NA</code>
to suppress borders for centroid-based plots</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_na.value">na.value</code></td>
<td>
<p>Color value for <code>NA</code> segmentations when
using custom scale</p>
</td></tr>
<tr><td><code id="SingleImagePlot_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='SingleRasterMap'>A single heatmap from ggplot2 using geom_raster</h2><span id='topic+SingleRasterMap'></span>

<h3>Description</h3>

<p>A single heatmap from ggplot2 using geom_raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleRasterMap(
  data,
  raster = TRUE,
  cell.order = NULL,
  feature.order = NULL,
  colors = PurpleAndYellow(),
  disp.min = -2.5,
  disp.max = 2.5,
  limits = NULL,
  group.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleRasterMap_+3A_data">data</code></td>
<td>
<p>A matrix or data frame with data to plot</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_raster">raster</code></td>
<td>
<p>switch between geom_raster and geom_tile</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_cell.order">cell.order</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_feature.order">feature.order</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_colors">colors</code></td>
<td>
<p>A vector of colors to use</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_disp.min">disp.min</code></td>
<td>
<p>Minimum display value (all values below are clipped)</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_disp.max">disp.max</code></td>
<td>
<p>Maximum display value (all values above are clipped)</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_limits">limits</code></td>
<td>
<p>A two-length numeric vector with the limits for colors on the plot</p>
</td></tr>
<tr><td><code id="SingleRasterMap_+3A_group.by">group.by</code></td>
<td>
<p>A vector to group cells by, should be one grouping identity per cell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='SingleSpatialPlot'>Base plotting function for all Spatial plots</h2><span id='topic+SingleSpatialPlot'></span>

<h3>Description</h3>

<p>Base plotting function for all Spatial plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleSpatialPlot(
  data,
  image,
  cols = NULL,
  image.alpha = 1,
  pt.alpha = NULL,
  crop = TRUE,
  pt.size.factor = NULL,
  stroke = 0.25,
  col.by = NULL,
  alpha.by = NULL,
  cells.highlight = NULL,
  cols.highlight = c("#DE2D26", "grey50"),
  geom = c("spatial", "interactive", "poly"),
  na.value = "grey50"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleSpatialPlot_+3A_data">data</code></td>
<td>
<p>Data.frame with info to be plotted</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_image">image</code></td>
<td>
<p><code>SpatialImage</code> object to be plotted</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_cols">cols</code></td>
<td>
<p>Vector of colors, each color corresponds to an identity class.
This may also be a single character
or numeric value corresponding to a palette as specified by
<code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>. By default, ggplot2 assigns
colors</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_image.alpha">image.alpha</code></td>
<td>
<p>Adjust the opacity of the background images. Set to 0 to
remove.</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_pt.alpha">pt.alpha</code></td>
<td>
<p>Adjust the opacity of the points if plotting a
<code>SpatialDimPlot</code></p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_crop">crop</code></td>
<td>
<p>Crop the plot in to focus on points plotted. Set to <code>FALSE</code>
to show entire background image.</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_pt.size.factor">pt.size.factor</code></td>
<td>
<p>Sets the size of the points relative to spot.radius</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_stroke">stroke</code></td>
<td>
<p>Control the width of the border around the spots</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_col.by">col.by</code></td>
<td>
<p>Mapping variable for the point color</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_alpha.by">alpha.by</code></td>
<td>
<p>Mapping variable for the point alpha value</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_cells.highlight">cells.highlight</code></td>
<td>
<p>A list of character or numeric vectors of cells to
highlight. If only one group of cells desired, can simply pass a vector
instead of a list. If set, colors selected cells to the color(s) in
cols.highlight</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_cols.highlight">cols.highlight</code></td>
<td>
<p>A vector of colors to highlight the cells as; ordered
the same as the groups in cells.highlight; last color corresponds to
unselected cells.</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_geom">geom</code></td>
<td>
<p>Switch between normal spatial geom and geom to enable hover
functionality</p>
</td></tr>
<tr><td><code id="SingleSpatialPlot_+3A_na.value">na.value</code></td>
<td>
<p>Color for spots with NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='SketchData'>Sketch Data</h2><span id='topic+SketchData'></span>

<h3>Description</h3>

<p>This function uses sketching methods to downsample high-dimensional single-cell RNA expression data,
which can help with scalability for large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SketchData(
  object,
  assay = NULL,
  ncells = 5000L,
  sketched.assay = "sketch",
  method = c("LeverageScore", "Uniform"),
  var.name = "leverage.score",
  over.write = FALSE,
  seed = 123L,
  cast = "dgCMatrix",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SketchData_+3A_object">object</code></td>
<td>
<p>A Seurat object.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_assay">assay</code></td>
<td>
<p>Assay name. Default is NULL, in which case the default assay of the object is used.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_ncells">ncells</code></td>
<td>
<p>A positive integer indicating the number of cells to sample for the sketching. Default is 5000.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_sketched.assay">sketched.assay</code></td>
<td>
<p>Sketched assay name. A  sketch assay is created or overwrite with the sketch data. Default is 'sketch'.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_method">method</code></td>
<td>
<p>Sketching method to use. Can be 'LeverageScore' or 'Uniform'.
Default is 'LeverageScore'.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_var.name">var.name</code></td>
<td>
<p>A metadata column name to store the leverage scores. Default is 'leverage.score'.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_over.write">over.write</code></td>
<td>
<p>whether to overwrite existing column in the metadata. Default is FALSE.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_seed">seed</code></td>
<td>
<p>A positive integer for the seed of the random number generator. Default is 123.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_cast">cast</code></td>
<td>
<p>The type to cast the resulting assay to. Default is 'dgCMatrix'.</p>
</td></tr>
<tr><td><code id="SketchData_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and diagnostic messages</p>
</td></tr>
<tr><td><code id="SketchData_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with the sketched data added as a new assay.
</p>

<hr>
<h2 id='SlideSeq-class'>The SlideSeq class</h2><span id='topic+SlideSeq-class'></span><span id='topic+SlideSeq'></span>

<h3>Description</h3>

<p>The SlideSeq class represents spatial information from the Slide-seq platform
</p>


<h3>Slots</h3>


<dl>
<dt><code>coordinates</code></dt><dd><p>...</p>
</dd>
</dl>


<h3>Slots</h3>


<dl>
<dt><code>assay</code></dt><dd><p>Name of assay to associate image data with; will give this image
priority for visualization when the assay is set as the active/default assay
in a <code>Seurat</code> object</p>
</dd>
<dt><code>key</code></dt><dd><p>A one-length character vector with the object's key; keys must
be one or more alphanumeric characters followed by an underscore
&ldquo;<code>_</code>&rdquo; (regex pattern
&ldquo;<code>^[a-zA-Z][a-zA-Z0-9]*_$</code>&rdquo;)</p>
</dd>
</dl>


<hr>
<h2 id='SpatialImage-class'>The SpatialImage Class</h2><span id='topic+SpatialImage-class'></span>

<h3>Description</h3>

<p>For more details, please see the documentation in
<code><a href="SeuratObject.html#topic+SpatialImage">SeuratObject</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="SeuratObject.html#topic+SpatialImage">SeuratObject::SpatialImage-class</a></code>
</p>

<hr>
<h2 id='SpatialPlot'>Visualize spatial clustering and expression data.</h2><span id='topic+SpatialPlot'></span><span id='topic+SpatialDimPlot'></span><span id='topic+SpatialFeaturePlot'></span>

<h3>Description</h3>

<p>SpatialPlot plots a feature or discrete grouping (e.g. cluster assignments) as
spots over the image that was collected. We also provide SpatialFeaturePlot
and SpatialDimPlot as wrapper functions around SpatialPlot for a consistent
naming framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialPlot(
  object,
  group.by = NULL,
  features = NULL,
  images = NULL,
  cols = NULL,
  image.alpha = 1,
  crop = TRUE,
  slot = "data",
  keep.scale = "feature",
  min.cutoff = NA,
  max.cutoff = NA,
  cells.highlight = NULL,
  cols.highlight = c("#DE2D26", "grey50"),
  facet.highlight = FALSE,
  label = FALSE,
  label.size = 5,
  label.color = "white",
  label.box = TRUE,
  repel = FALSE,
  ncol = NULL,
  combine = TRUE,
  pt.size.factor = 1.6,
  alpha = c(1, 1),
  stroke = 0.25,
  interactive = FALSE,
  do.identify = FALSE,
  identify.ident = NULL,
  do.hover = FALSE,
  information = NULL
)

SpatialDimPlot(
  object,
  group.by = NULL,
  images = NULL,
  cols = NULL,
  crop = TRUE,
  cells.highlight = NULL,
  cols.highlight = c("#DE2D26", "grey50"),
  facet.highlight = FALSE,
  label = FALSE,
  label.size = 7,
  label.color = "white",
  repel = FALSE,
  ncol = NULL,
  combine = TRUE,
  pt.size.factor = 1.6,
  alpha = c(1, 1),
  image.alpha = 1,
  stroke = 0.25,
  label.box = TRUE,
  interactive = FALSE,
  information = NULL
)

SpatialFeaturePlot(
  object,
  features,
  images = NULL,
  crop = TRUE,
  slot = "data",
  keep.scale = "feature",
  min.cutoff = NA,
  max.cutoff = NA,
  ncol = NULL,
  combine = TRUE,
  pt.size.factor = 1.6,
  alpha = c(1, 1),
  image.alpha = 1,
  stroke = 0.25,
  interactive = FALSE,
  information = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of meta.data column to group the data by</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_features">features</code></td>
<td>
<p>Name of the feature to visualize. Provide either group.by OR
features, not both.</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_images">images</code></td>
<td>
<p>Name of the images to use in the plot(s)</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_cols">cols</code></td>
<td>
<p>Vector of colors, each color corresponds to an identity class.
This may also be a single character or numeric value corresponding to a
palette as specified by <code><a href="RColorBrewer.html#topic+brewer.pal.info">brewer.pal.info</a></code>. By
default, ggplot2 assigns colors</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_image.alpha">image.alpha</code></td>
<td>
<p>Adjust the opacity of the background images. Set to 0 to
remove.</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_crop">crop</code></td>
<td>
<p>Crop the plot in to focus on points plotted. Set to <code>FALSE</code> to show
entire background image.</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_slot">slot</code></td>
<td>
<p>If plotting a feature, which data slot to pull from (counts,
data, or scale.data)</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_keep.scale">keep.scale</code></td>
<td>
<p>How to handle the color scale across multiple plots. Options are:
</p>

<ul>
<li> <p>&ldquo;feature&rdquo; (default; by row/feature scaling): The plots for
each individual feature are scaled to the maximum expression of the
feature across the conditions provided to <code>split.by</code>
</p>
</li>
<li> <p>&ldquo;all&rdquo; (universal scaling): The plots for all features and
conditions are scaled to the maximum expression value for the feature
with the highest overall expression
</p>
</li>
<li> <p><code>NULL</code> (no scaling): Each individual plot is scaled to the
maximum expression value of the feature in the condition provided to
<code>split.by</code>; be aware setting <code>NULL</code> will result in color
scales that are not comparable between plots
</p>
</li></ul>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_min.cutoff">min.cutoff</code>, <code id="SpatialPlot_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Vector of minimum and maximum cutoff
values for each feature, may specify quantile in the form of 'q##' where '##'
is the quantile (eg, 'q1', 'q10')</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_cells.highlight">cells.highlight</code></td>
<td>
<p>A list of character or numeric vectors of cells to
highlight. If only one group of cells desired, can simply pass a vector
instead of a list. If set, colors selected cells to the color(s) in
cols.highlight</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_cols.highlight">cols.highlight</code></td>
<td>
<p>A vector of colors to highlight the cells as; ordered
the same as the groups in cells.highlight; last color corresponds to
unselected cells.</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_facet.highlight">facet.highlight</code></td>
<td>
<p>When highlighting certain groups of cells, split each
group into its own plot</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_label">label</code></td>
<td>
<p>Whether to label the clusters</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_label.size">label.size</code></td>
<td>
<p>Sets the size of the labels</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_label.color">label.color</code></td>
<td>
<p>Sets the color of the label text</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_label.box">label.box</code></td>
<td>
<p>Whether to put a box around the label text (geom_text vs
geom_label)</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_repel">repel</code></td>
<td>
<p>Repels the labels to prevent overlap</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if plotting multiple plots</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single gg object; note that if TRUE;
themeing will not work when plotting multiple features/groupings</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_pt.size.factor">pt.size.factor</code></td>
<td>
<p>Scale the size of the spots.</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_alpha">alpha</code></td>
<td>
<p>Controls opacity of spots. Provide as a vector specifying the
min and max for SpatialFeaturePlot. For SpatialDimPlot, provide a single
alpha value for each plot.</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_stroke">stroke</code></td>
<td>
<p>Control the width of the border around the spots</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_interactive">interactive</code></td>
<td>
<p>Launch an interactive SpatialDimPlot or SpatialFeaturePlot
session, see <code><a href="#topic+ISpatialDimPlot">ISpatialDimPlot</a></code> or
<code><a href="#topic+ISpatialFeaturePlot">ISpatialFeaturePlot</a></code> for more details</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_do.identify">do.identify</code>, <code id="SpatialPlot_+3A_do.hover">do.hover</code></td>
<td>
<p>DEPRECATED in favor of <code>interactive</code></p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_identify.ident">identify.ident</code></td>
<td>
<p>DEPRECATED</p>
</td></tr>
<tr><td><code id="SpatialPlot_+3A_information">information</code></td>
<td>
<p>An optional dataframe or matrix of extra information to be displayed on hover</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>do.identify</code>, either a vector of cells selected or the object
with selected cells set to the value of <code>identify.ident</code> (if set). Else,
if <code>do.hover</code>, a plotly object with interactive graphics. Else, a ggplot
object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For functionality analagous to FeaturePlot
SpatialPlot(seurat.object, features = "MS4A1")
SpatialFeaturePlot(seurat.object, features = "MS4A1")

# For functionality analagous to DimPlot
SpatialPlot(seurat.object, group.by = "clusters")
SpatialDimPlot(seurat.object, group.by = "clusters")

## End(Not run)

</code></pre>

<hr>
<h2 id='SplitObject'>Splits object into a list of subsetted objects.</h2><span id='topic+SplitObject'></span>

<h3>Description</h3>

<p>Splits object based on a single attribute into a list of subsetted objects,
one for each level of the attribute. For example, useful for taking an object
that contains cells from many patients, and subdividing it into
patient-specific objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitObject(object, split.by = "ident")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitObject_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="SplitObject_+3A_split.by">split.by</code></td>
<td>
<p>Attribute for splitting. Default is &quot;ident&quot;. Currently
only supported for class-level (i.e. non-quantitative) attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of Seurat objects, each containing a subset of cells
from the original object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
# Assign the test object a three level attribute
groups &lt;- sample(c("group1", "group2", "group3"), size = 80, replace = TRUE)
names(groups) &lt;- colnames(pbmc_small)
pbmc_small &lt;- AddMetaData(object = pbmc_small, metadata = groups, col.name = "group")
obj.list &lt;- SplitObject(pbmc_small, split.by = "group")

</code></pre>

<hr>
<h2 id='STARmap-class'>The STARmap class</h2><span id='topic+STARmap-class'></span><span id='topic+STARmap'></span>

<h3>Description</h3>

<p>The STARmap class
</p>


<h3>Slots</h3>


<dl>
<dt><code>assay</code></dt><dd><p>Name of assay to associate image data with; will give this image
priority for visualization when the assay is set as the active/default assay
in a <code>Seurat</code> object</p>
</dd>
<dt><code>key</code></dt><dd><p>A one-length character vector with the object's key; keys must
be one or more alphanumeric characters followed by an underscore
&ldquo;<code>_</code>&rdquo; (regex pattern
&ldquo;<code>^[a-zA-Z][a-zA-Z0-9]*_$</code>&rdquo;)</p>
</dd>
</dl>


<hr>
<h2 id='subset.AnchorSet'>Subset an AnchorSet object</h2><span id='topic+subset.AnchorSet'></span>

<h3>Description</h3>

<p>Subset an AnchorSet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnchorSet'
subset(
  x,
  score.threshold = NULL,
  disallowed.dataset.pairs = NULL,
  dataset.matrix = NULL,
  group.by = NULL,
  disallowed.ident.pairs = NULL,
  ident.matrix = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.AnchorSet_+3A_x">x</code></td>
<td>
<p>object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_score.threshold">score.threshold</code></td>
<td>
<p>Only anchor pairs with scores greater than this value
are retained.</p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_disallowed.dataset.pairs">disallowed.dataset.pairs</code></td>
<td>
<p>Remove any anchors formed between the
provided pairs. E.g. <code>list(c(1, 5), c(1, 2))</code> filters out any anchors between
datasets 1 and 5 and datasets 1 and 2.</p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_dataset.matrix">dataset.matrix</code></td>
<td>
<p>Provide a binary matrix specifying whether a dataset
pair is allowable (1) or not (0). Should be a dataset x dataset matrix.</p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_group.by">group.by</code></td>
<td>
<p>Grouping variable to determine allowable ident pairs</p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_disallowed.ident.pairs">disallowed.ident.pairs</code></td>
<td>
<p>Remove any anchors formed between provided
ident pairs. E.g. <code>list(c("CD4", "CD8"), c("B-cell", "T-cell"))</code></p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_ident.matrix">ident.matrix</code></td>
<td>
<p>Provide a binary matrix specifying whether an ident pair
is allowable (1) or not (0). Should be an ident x ident symmetric matrix</p>
</td></tr>
<tr><td><code id="subset.AnchorSet_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AnchorSet">AnchorSet</a></code> object with specified anchors
filtered out
</p>

<hr>
<h2 id='SubsetByBarcodeInflections'>Subset a Seurat Object based on the Barcode Distribution Inflection Points</h2><span id='topic+SubsetByBarcodeInflections'></span>

<h3>Description</h3>

<p>This convenience function subsets a Seurat object based on calculated inflection points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetByBarcodeInflections(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubsetByBarcodeInflections_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See [CalculateBarcodeInflections()] to calculate inflection points and
[BarcodeInflectionsPlot()] to visualize and test inflection point calculations.
</p>


<h3>Value</h3>

<p>Returns a subsetted Seurat object.
</p>


<h3>Author(s)</h3>

<p>Robert A. Amezquita, <a href="mailto:robert.amezquita@fredhutch.org">robert.amezquita@fredhutch.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateBarcodeInflections">CalculateBarcodeInflections</a></code> <code><a href="#topic+BarcodeInflectionsPlot">BarcodeInflectionsPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small &lt;- CalculateBarcodeInflections(
  object = pbmc_small,
  group.column = 'groups',
  threshold.low = 20,
  threshold.high = 30
)
SubsetByBarcodeInflections(object = pbmc_small)

</code></pre>

<hr>
<h2 id='TopCells'>Find cells with highest scores for a given dimensional reduction technique</h2><span id='topic+TopCells'></span>

<h3>Description</h3>

<p>Return a list of genes with the strongest contribution to a set of components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopCells(object, dim = 1, ncells = 20, balanced = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TopCells_+3A_object">object</code></td>
<td>
<p>DimReduc object</p>
</td></tr>
<tr><td><code id="TopCells_+3A_dim">dim</code></td>
<td>
<p>Dimension to use</p>
</td></tr>
<tr><td><code id="TopCells_+3A_ncells">ncells</code></td>
<td>
<p>Number of cells to return</p>
</td></tr>
<tr><td><code id="TopCells_+3A_balanced">balanced</code></td>
<td>
<p>Return an equal number of cells with both + and - scores.</p>
</td></tr>
<tr><td><code id="TopCells_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+Embeddings">Embeddings</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of cells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small
head(TopCells(object = pbmc_small[["pca"]]))
# Can specify which dimension and how many cells to return
TopCells(object = pbmc_small[["pca"]], dim = 2, ncells = 5)

</code></pre>

<hr>
<h2 id='TopFeatures'>Find features with highest scores for a given dimensional reduction technique</h2><span id='topic+TopFeatures'></span>

<h3>Description</h3>

<p>Return a list of features with the strongest contribution to a set of components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopFeatures(
  object,
  dim = 1,
  nfeatures = 20,
  projected = FALSE,
  balanced = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TopFeatures_+3A_object">object</code></td>
<td>
<p>DimReduc object</p>
</td></tr>
<tr><td><code id="TopFeatures_+3A_dim">dim</code></td>
<td>
<p>Dimension to use</p>
</td></tr>
<tr><td><code id="TopFeatures_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of features to return</p>
</td></tr>
<tr><td><code id="TopFeatures_+3A_projected">projected</code></td>
<td>
<p>Use the projected feature loadings</p>
</td></tr>
<tr><td><code id="TopFeatures_+3A_balanced">balanced</code></td>
<td>
<p>Return an equal number of features with both + and - scores.</p>
</td></tr>
<tr><td><code id="TopFeatures_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+Loadings">Loadings</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
pbmc_small
TopFeatures(object = pbmc_small[["pca"]], dim = 1)
# After projection:
TopFeatures(object = pbmc_small[["pca"]], dim = 1,  projected = TRUE)

</code></pre>

<hr>
<h2 id='TopNeighbors'>Get nearest neighbors for given cell</h2><span id='topic+TopNeighbors'></span>

<h3>Description</h3>

<p>Return a vector of cell names of the nearest n cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TopNeighbors(object, cell, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TopNeighbors_+3A_object">object</code></td>
<td>
<p><code><a href="SeuratObject.html#topic+Neighbor">Neighbor</a></code> object</p>
</td></tr>
<tr><td><code id="TopNeighbors_+3A_cell">cell</code></td>
<td>
<p>Cell of interest</p>
</td></tr>
<tr><td><code id="TopNeighbors_+3A_n">n</code></td>
<td>
<p>Number of neighbors to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of cell names
</p>

<hr>
<h2 id='TransferAnchorSet-class'>The TransferAnchorSet Class</h2><span id='topic+TransferAnchorSet-class'></span><span id='topic+TransferAnchorSet'></span>

<h3>Description</h3>

<p>Inherits from the Anchorset class. Implemented mainly for method dispatch
purposes.  See <code><a href="#topic+AnchorSet">AnchorSet</a></code> for slot details.
</p>

<hr>
<h2 id='TransferData'>Transfer data</h2><span id='topic+TransferData'></span>

<h3>Description</h3>

<p>Transfer categorical or continuous data across single-cell datasets. For
transferring categorical information, pass a vector from the reference
dataset (e.g. <code>refdata = reference$celltype</code>). For transferring
continuous information, pass a matrix from the reference dataset (e.g.
<code>refdata = GetAssayData(reference[['RNA']])</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransferData(
  anchorset,
  refdata,
  reference = NULL,
  query = NULL,
  query.assay = NULL,
  weight.reduction = "pcaproject",
  l2.norm = FALSE,
  dims = NULL,
  k.weight = 50,
  sd.weight = 1,
  eps = 0,
  n.trees = 50,
  verbose = TRUE,
  slot = "data",
  prediction.assay = FALSE,
  only.weights = FALSE,
  store.weights = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransferData_+3A_anchorset">anchorset</code></td>
<td>
<p>An <code><a href="#topic+AnchorSet">AnchorSet</a></code> object generated by
<code><a href="#topic+FindTransferAnchors">FindTransferAnchors</a></code></p>
</td></tr>
<tr><td><code id="TransferData_+3A_refdata">refdata</code></td>
<td>
<p>Data to transfer. This can be specified in one of two ways:
</p>

<ul>
<li><p>The reference data itself as either a vector where the names
correspond to the reference cells, or a matrix, where the column names
correspond to the reference cells.
</p>
</li>
<li><p>The name of the metadata field or assay from the reference object
provided. This requires the reference parameter to be specified. If pulling
assay data in this manner, it will pull the data from the data slot. To
transfer data from other slots, please pull the data explicitly with
<code><a href="#topic+GetAssayData">GetAssayData</a></code> and provide that matrix here.
</p>
</li></ul>
</td></tr>
<tr><td><code id="TransferData_+3A_reference">reference</code></td>
<td>
<p>Reference object from which to pull data to transfer</p>
</td></tr>
<tr><td><code id="TransferData_+3A_query">query</code></td>
<td>
<p>Query object into which the data will be transferred.</p>
</td></tr>
<tr><td><code id="TransferData_+3A_query.assay">query.assay</code></td>
<td>
<p>Name of the Assay to use from query</p>
</td></tr>
<tr><td><code id="TransferData_+3A_weight.reduction">weight.reduction</code></td>
<td>
<p>Dimensional reduction to use for the weighting
anchors. Options are:
</p>

<ul>
<li><p>pcaproject: Use the projected PCA used for anchor building
</p>
</li>
<li><p>lsiproject: Use the projected LSI used for anchor building
</p>
</li>
<li><p>pca: Use an internal PCA on the query only
</p>
</li>
<li><p>cca: Use the CCA used for anchor building
</p>
</li>
<li><p>custom DimReduc: User provided <code><a href="SeuratObject.html#topic+DimReduc">DimReduc</a></code> object
computed on the query cells
</p>
</li></ul>
</td></tr>
<tr><td><code id="TransferData_+3A_l2.norm">l2.norm</code></td>
<td>
<p>Perform L2 normalization on the cell embeddings after
dimensional reduction</p>
</td></tr>
<tr><td><code id="TransferData_+3A_dims">dims</code></td>
<td>
<p>Set of dimensions to use in the anchor weighting procedure. If
NULL, the same dimensions that were used to find anchors will be used for
weighting.</p>
</td></tr>
<tr><td><code id="TransferData_+3A_k.weight">k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting anchors</p>
</td></tr>
<tr><td><code id="TransferData_+3A_sd.weight">sd.weight</code></td>
<td>
<p>Controls the bandwidth of the Gaussian kernel for weighting</p>
</td></tr>
<tr><td><code id="TransferData_+3A_eps">eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from
<code><a href="RANN.html#topic+RANN">RANN</a></code>)</p>
</td></tr>
<tr><td><code id="TransferData_+3A_n.trees">n.trees</code></td>
<td>
<p>More trees gives higher precision when using annoy approximate
nearest neighbor search</p>
</td></tr>
<tr><td><code id="TransferData_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bars and output</p>
</td></tr>
<tr><td><code id="TransferData_+3A_slot">slot</code></td>
<td>
<p>Slot to store the imputed data. Must be either &quot;data&quot; (default)
or &quot;counts&quot;</p>
</td></tr>
<tr><td><code id="TransferData_+3A_prediction.assay">prediction.assay</code></td>
<td>
<p>Return an <code>Assay</code> object with the prediction
scores for each class stored in the <code>data</code> slot.</p>
</td></tr>
<tr><td><code id="TransferData_+3A_only.weights">only.weights</code></td>
<td>
<p>Only return weights matrix</p>
</td></tr>
<tr><td><code id="TransferData_+3A_store.weights">store.weights</code></td>
<td>
<p>Optionally store the weights matrix used for predictions
in the returned query object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main steps of this procedure are outlined below. For a more detailed
description of the methodology, please see Stuart, Butler, et al Cell 2019.
<a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>; <a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>
</p>
<p>For both transferring discrete labels and also feature imputation, we first
compute the weights matrix.
</p>

<ul>
<li><p>Construct a weights matrix that defines the association between each
query cell and each anchor. These weights are computed as 1 - the distance
between the query cell and the anchor divided by the distance of the query
cell to the <code>k.weight</code>th anchor multiplied by the anchor score
computed in <code><a href="#topic+FindIntegrationAnchors">FindIntegrationAnchors</a></code>. We then apply a Gaussian
kernel width a bandwidth defined by <code>sd.weight</code> and normalize across
all <code>k.weight</code> anchors.
</p>
</li></ul>

<p>The main difference between label transfer (classification) and feature
imputation is what gets multiplied by the weights matrix. For label transfer,
we perform the following steps:
</p>

<ul>
<li><p>Create a binary classification matrix, the rows corresponding to each
possible class and the columns corresponding to the anchors. If the
reference cell in the anchor pair is a member of a certain class, that
matrix entry is filled with a 1, otherwise 0.
</p>
</li>
<li><p>Multiply this classification matrix by the transpose of weights
matrix to compute a prediction score for each class for each cell in the
query dataset.
</p>
</li></ul>

<p>For feature imputation, we perform the following step:
</p>

<ul>
<li><p>Multiply the expression matrix for the reference anchor cells by the
weights matrix. This returns a predicted expression matrix for the
specified features for each cell in the query dataset.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>query</code> is not provided, for the categorical data in <code>refdata</code>,
returns a data.frame with label predictions. If <code>refdata</code> is a matrix,
returns an Assay object where the imputed data has been stored in the
provided slot.
</p>
<p>If <code>query</code> is provided, a modified query object is returned. For
the categorical data in refdata, prediction scores are stored as Assays
(prediction.score.NAME) and two additional metadata fields: predicted.NAME
and predicted.NAME.score which contain the class prediction and the score for
that predicted class. For continuous data, an Assay called NAME is returned.
NAME here corresponds to the name of the element in the refdata list.
</p>


<h3>References</h3>

<p>Stuart T, Butler A, et al. Comprehensive Integration of
Single-Cell Data. Cell. 2019;177:1888-1902 <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to install the SeuratData package see https://github.com/satijalab/seurat-data
library(SeuratData)
data("pbmc3k")

# for demonstration, split the object into reference and query
pbmc.reference &lt;- pbmc3k[, 1:1350]
pbmc.query &lt;- pbmc3k[, 1351:2700]

# perform standard preprocessing on each object
pbmc.reference &lt;- NormalizeData(pbmc.reference)
pbmc.reference &lt;- FindVariableFeatures(pbmc.reference)
pbmc.reference &lt;- ScaleData(pbmc.reference)

pbmc.query &lt;- NormalizeData(pbmc.query)
pbmc.query &lt;- FindVariableFeatures(pbmc.query)
pbmc.query &lt;- ScaleData(pbmc.query)

# find anchors
anchors &lt;- FindTransferAnchors(reference = pbmc.reference, query = pbmc.query)

# transfer labels
predictions &lt;- TransferData(anchorset = anchors, refdata = pbmc.reference$seurat_annotations)
pbmc.query &lt;- AddMetaData(object = pbmc.query, metadata = predictions)

## End(Not run)

</code></pre>

<hr>
<h2 id='TransferSketchLabels'>Transfer data from sketch data to full data</h2><span id='topic+TransferSketchLabels'></span>

<h3>Description</h3>

<p>This function transfers cell type labels from a sketched dataset to a full dataset
based on the similarities in the lower dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransferSketchLabels(
  object,
  sketched.assay = "sketch",
  reduction,
  dims,
  refdata = NULL,
  k = 50,
  reduction.model = NULL,
  neighbors = NULL,
  recompute.neighbors = FALSE,
  recompute.weights = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransferSketchLabels_+3A_object">object</code></td>
<td>
<p>A Seurat object.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_sketched.assay">sketched.assay</code></td>
<td>
<p>Sketched assay name. Default is 'sketch'.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_reduction">reduction</code></td>
<td>
<p>Dimensional reduction name to use for label transfer.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_dims">dims</code></td>
<td>
<p>An integer vector indicating which dimensions to use for label transfer.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_refdata">refdata</code></td>
<td>
<p>A list of character strings indicating the metadata columns containing labels to transfer. Default is NULL.
Similar to refdata in 'MapQuery'</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_k">k</code></td>
<td>
<p>Number of neighbors to use for label transfer. Default is 50.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_reduction.model">reduction.model</code></td>
<td>
<p>Dimensional reduction model to use for label transfer. Default is NULL.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_neighbors">neighbors</code></td>
<td>
<p>An object storing the neighbors found during the sketching process. Default is NULL.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_recompute.neighbors">recompute.neighbors</code></td>
<td>
<p>Whether to recompute the neighbors for label transfer. Default is FALSE.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_recompute.weights">recompute.weights</code></td>
<td>
<p>Whether to recompute the weights for label transfer. Default is FALSE.</p>
</td></tr>
<tr><td><code id="TransferSketchLabels_+3A_verbose">verbose</code></td>
<td>
<p>Print progress and diagnostic messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with transferred labels stored in the metadata. If a UMAP model is provided,
the full data are also projected onto the UMAP space, with the results stored in a new reduction, full.'reduction.model'
</p>

<hr>
<h2 id='UnSketchEmbeddings'>Transfer embeddings from sketched cells to the full data</h2><span id='topic+UnSketchEmbeddings'></span>

<h3>Description</h3>

<p>Transfer embeddings from sketched cells to the full data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnSketchEmbeddings(
  atom.data,
  atom.cells = NULL,
  orig.data,
  embeddings,
  sketch.matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnSketchEmbeddings_+3A_atom.data">atom.data</code></td>
<td>
<p>Atom data</p>
</td></tr>
<tr><td><code id="UnSketchEmbeddings_+3A_atom.cells">atom.cells</code></td>
<td>
<p>Atom cells</p>
</td></tr>
<tr><td><code id="UnSketchEmbeddings_+3A_orig.data">orig.data</code></td>
<td>
<p>Original data</p>
</td></tr>
<tr><td><code id="UnSketchEmbeddings_+3A_embeddings">embeddings</code></td>
<td>
<p>Embeddings of atom cells</p>
</td></tr>
<tr><td><code id="UnSketchEmbeddings_+3A_sketch.matrix">sketch.matrix</code></td>
<td>
<p>Sketch matrix</p>
</td></tr>
</table>

<hr>
<h2 id='UpdateSCTAssays'>Update pre-V4 Assays generated with SCTransform in the Seurat to the new
SCTAssay class</h2><span id='topic+UpdateSCTAssays'></span>

<h3>Description</h3>

<p>Update pre-V4 Assays generated with SCTransform in the Seurat to the new
SCTAssay class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdateSCTAssays(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateSCTAssays_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Seurat object with updated SCTAssays
</p>

<hr>
<h2 id='UpdateSymbolList'>Get updated synonyms for gene symbols</h2><span id='topic+UpdateSymbolList'></span><span id='topic+GeneSymbolThesarus'></span>

<h3>Description</h3>

<p>Find current gene symbols based on old or alias symbols using the gene
names database from the HUGO Gene Nomenclature Committee (HGNC)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneSymbolThesarus(
  symbols,
  timeout = 10,
  several.ok = FALSE,
  search.types = c("alias_symbol", "prev_symbol"),
  verbose = TRUE,
  ...
)

UpdateSymbolList(
  symbols,
  timeout = 10,
  several.ok = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdateSymbolList_+3A_symbols">symbols</code></td>
<td>
<p>A vector of gene symbols</p>
</td></tr>
<tr><td><code id="UpdateSymbolList_+3A_timeout">timeout</code></td>
<td>
<p>Time to wait before canceling query in seconds</p>
</td></tr>
<tr><td><code id="UpdateSymbolList_+3A_several.ok">several.ok</code></td>
<td>
<p>Allow several current gene symbols for each
provided symbol</p>
</td></tr>
<tr><td><code id="UpdateSymbolList_+3A_search.types">search.types</code></td>
<td>
<p>Type of query to perform:
</p>

<dl>
<dt>&ldquo;<code>alias_symbol</code>&rdquo;</dt><dd><p>Find alternate symbols for the genes
described by <code>symbols</code></p>
</dd>
<dt>&ldquo;<code>prev_symbol</code>&rdquo;</dt><dd><p>Find new new symbols for the genes
described by <code>symbols</code></p>
</dd>
</dl>

<p>This parameter accepts multiple options and short-hand options
(eg. &ldquo;<code>prev</code>&rdquo; for &ldquo;<code>prev_symbol</code>&rdquo;)</p>
</td></tr>
<tr><td><code id="UpdateSymbolList_+3A_verbose">verbose</code></td>
<td>
<p>Show a progress bar depicting search progress</p>
</td></tr>
<tr><td><code id="UpdateSymbolList_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="httr.html#topic+GET">GET</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each symbol passed, we query the HGNC gene names database for
current symbols that have the provided symbol as either an alias
(<code>alias_symbol</code>) or old (<code>prev_symbol</code>) symbol. All other queries
are <strong>not</strong> supported.
</p>


<h3>Value</h3>

<p><code>GeneSymbolThesarus</code>:, if <code>several.ok</code>, a named list
where each entry is the current symbol found for each symbol provided and
the names are the provided symbols. Otherwise, a named vector with the
same information.
</p>
<p><code>UpdateSymbolList</code>: <code>symbols</code> with updated symbols from
HGNC's gene names database
</p>


<h3>Note</h3>

<p>This function requires internet access
</p>


<h3>Source</h3>

<p><a href="https://www.genenames.org/">https://www.genenames.org/</a> <a href="https://www.genenames.org/help/rest/">https://www.genenames.org/help/rest/</a>
</p>


<h3>See Also</h3>

<p><code><a href="httr.html#topic+GET">GET</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GeneSybmolThesarus(symbols = c("FAM64A"))

## End(Not run)

## Not run: 
UpdateSymbolList(symbols = cc.genes$s.genes)

## End(Not run)

</code></pre>

<hr>
<h2 id='VariableFeaturePlot'>View variable features</h2><span id='topic+VariableFeaturePlot'></span><span id='topic+VariableGenePlot'></span><span id='topic+MeanVarPlot'></span>

<h3>Description</h3>

<p>View variable features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VariableFeaturePlot(
  object,
  cols = c("black", "red"),
  pt.size = 1,
  log = NULL,
  selection.method = NULL,
  assay = NULL,
  raster = NULL,
  raster.dpi = c(512, 512)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VariableFeaturePlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_cols">cols</code></td>
<td>
<p>Colors to specify non-variable/variable status</p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Size of the points on the plot</p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_log">log</code></td>
<td>
<p>Plot the x-axis in log scale</p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_selection.method">selection.method</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_assay">assay</code></td>
<td>
<p>Assay to pull variable features from</p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format, default is <code>NULL</code>
which will automatically use raster if the number of points plotted is greater than
100,000</p>
</td></tr>
<tr><td><code id="VariableFeaturePlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Pixel resolution for rasterized plots, passed to geom_scattermore().
Default is c(512, 512).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FindVariableFeatures">FindVariableFeatures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
VariableFeaturePlot(object = pbmc_small)

</code></pre>

<hr>
<h2 id='VisiumV1-class'>The VisiumV1 class</h2><span id='topic+VisiumV1-class'></span><span id='topic+VisiumV1'></span>

<h3>Description</h3>

<p>The VisiumV1 class represents spatial information from the 10X Genomics Visium
platform
</p>


<h3>Slots</h3>


<dl>
<dt><code>image</code></dt><dd><p>A three-dimensional array with PNG image data, see
<code><a href="png.html#topic+readPNG">readPNG</a></code> for more details</p>
</dd>
<dt><code>scale.factors</code></dt><dd><p>An object of class <code><a href="#topic+scalefactors">scalefactors</a></code>; see
<code><a href="#topic+scalefactors">scalefactors</a></code> for more information</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>A data frame with tissue coordinate information</p>
</dd>
<dt><code>spot.radius</code></dt><dd><p>Single numeric value giving the radius of the spots</p>
</dd>
</dl>

<hr>
<h2 id='VizDimLoadings'>Visualize Dimensional Reduction genes</h2><span id='topic+VizDimLoadings'></span>

<h3>Description</h3>

<p>Visualize top genes associated with reduction components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VizDimLoadings(
  object,
  dims = 1:5,
  nfeatures = 30,
  col = "blue",
  reduction = "pca",
  projected = FALSE,
  balanced = FALSE,
  ncol = NULL,
  combine = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VizDimLoadings_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_dims">dims</code></td>
<td>
<p>Number of dimensions to display</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_nfeatures">nfeatures</code></td>
<td>
<p>Number of genes to display</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_col">col</code></td>
<td>
<p>Color of points to use</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_reduction">reduction</code></td>
<td>
<p>Reduction technique to visualize results for</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_projected">projected</code></td>
<td>
<p>Use reduction values for full dataset (i.e. projected
dimensional reduction values)</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_balanced">balanced</code></td>
<td>
<p>Return an equal number of genes with + and - scores. If
FALSE (default), returns the top genes ranked by the scores absolute values</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns to display</p>
</td></tr>
<tr><td><code id="VizDimLoadings_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code>patchwork</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>patchwork</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
VizDimLoadings(object = pbmc_small)

</code></pre>

<hr>
<h2 id='VlnPlot'>Single cell violin plot</h2><span id='topic+VlnPlot'></span>

<h3>Description</h3>

<p>Draws a violin plot of single cell data (gene expression, metrics, PC
scores, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VlnPlot(
  object,
  features,
  cols = NULL,
  pt.size = NULL,
  alpha = 1,
  idents = NULL,
  sort = FALSE,
  assay = NULL,
  group.by = NULL,
  split.by = NULL,
  adjust = 1,
  y.max = NULL,
  same.y.lims = FALSE,
  log = FALSE,
  ncol = NULL,
  slot = deprecated(),
  layer = NULL,
  split.plot = FALSE,
  stack = FALSE,
  combine = TRUE,
  fill.by = "feature",
  flip = FALSE,
  add.noise = TRUE,
  raster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VlnPlot_+3A_object">object</code></td>
<td>
<p>Seurat object</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_features">features</code></td>
<td>
<p>Features to plot (gene expression, metrics, PC scores,
anything that can be retreived by FetchData)</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_cols">cols</code></td>
<td>
<p>Colors to use for plotting</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>Point size for points</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for points</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_idents">idents</code></td>
<td>
<p>Which classes to include in the plot (default is all)</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_sort">sort</code></td>
<td>
<p>Sort identity classes (on the x-axis) by the average
expression of the attribute being potted, can also pass 'increasing' or 'decreasing' to change sort direction</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use, defaults to the active assay</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_group.by">group.by</code></td>
<td>
<p>Group (color) cells in different ways (for example, orig.ident)</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_split.by">split.by</code></td>
<td>
<p>A factor in object metadata to split the plot by, pass 'ident'
to split by cell identity'</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_adjust">adjust</code></td>
<td>
<p>Adjust parameter for geom_violin</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_y.max">y.max</code></td>
<td>
<p>Maximum y axis value</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_same.y.lims">same.y.lims</code></td>
<td>
<p>Set all the y-axis limits to the same values</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_log">log</code></td>
<td>
<p>plot the feature axis on log scale</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if multiple plots are displayed</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_slot">slot</code></td>
<td>
<p>Slot to pull expression data from (e.g. &quot;counts&quot; or &quot;data&quot;)</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_layer">layer</code></td>
<td>
<p>Layer to pull expression data from (e.g. &quot;counts&quot; or &quot;data&quot;)</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_split.plot">split.plot</code></td>
<td>
<p>plot each group of the split violin plots by multiple or
single violin shapes.</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_stack">stack</code></td>
<td>
<p>Horizontally stack plots for each feature</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_combine">combine</code></td>
<td>
<p>Combine plots into a single <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code>
ggplot object. If <code>FALSE</code>, return a list of ggplot</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_fill.by">fill.by</code></td>
<td>
<p>Color violins/ridges based on either 'feature' or 'ident'</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_flip">flip</code></td>
<td>
<p>flip plot orientation (identities on x-axis)</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_add.noise">add.noise</code></td>
<td>
<p>determine if adding a small noise for plotting</p>
</td></tr>
<tr><td><code id="VlnPlot_+3A_raster">raster</code></td>
<td>
<p>Convert points to raster format. Requires 'ggrastr' to be installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="patchwork.html#topic+patchwork">patchwork</a>ed</code> ggplot object if
<code>combine = TRUE</code>; otherwise, a list of ggplot objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FetchData">FetchData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbmc_small")
VlnPlot(object = pbmc_small, features = 'PC_1')
VlnPlot(object = pbmc_small, features = 'LYZ', split.by = 'groups')

</code></pre>

<hr>
<h2 id='VST'>Variance Stabilizing Transformation</h2><span id='topic+VST'></span><span id='topic+VST.default'></span><span id='topic+VST.IterableMatrix'></span><span id='topic+VST.dgCMatrix'></span><span id='topic+VST.matrix'></span>

<h3>Description</h3>

<p>Apply variance stabilizing transformation for selection of variable features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VST(data, margin = 1L, nselect = 2000L, span = 0.3, clip = NULL, ...)

## Default S3 method:
VST(data, margin = 1L, nselect = 2000L, span = 0.3, clip = NULL, ...)

## S3 method for class 'IterableMatrix'
VST(
  data,
  margin = 1L,
  nselect = 2000L,
  span = 0.3,
  clip = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'dgCMatrix'
VST(
  data,
  margin = 1L,
  nselect = 2000L,
  span = 0.3,
  clip = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'matrix'
VST(data, margin = 1L, nselect = 2000L, span = 0.3, clip = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VST_+3A_data">data</code></td>
<td>
<p>A matrix-like object</p>
</td></tr>
<tr><td><code id="VST_+3A_margin">margin</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="VST_+3A_nselect">nselect</code></td>
<td>
<p>Number of of features to select</p>
</td></tr>
<tr><td><code id="VST_+3A_span">span</code></td>
<td>
<p>the parameter <code class="reqn">\alpha</code> which controls the degree of
smoothing.</p>
</td></tr>
<tr><td><code id="VST_+3A_clip">clip</code></td>
<td>
<p>Upper bound for values post-standardization; defaults to the
square root of the number of cells</p>
</td></tr>
<tr><td><code id="VST_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="VST_+3A_verbose">verbose</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>

<ul>
<li> <p>&ldquo;<code>mean</code>&rdquo;: ...
</p>
</li>
<li> <p>&ldquo;<code>variance</code>&rdquo;: ...
</p>
</li>
<li> <p>&ldquo;<code>variance.expected</code>&rdquo;: ...
</p>
</li>
<li> <p>&ldquo;<code>variance.standardized</code>&rdquo;: ...
</p>
</li>
<li> <p>&ldquo;<code>variable</code>&rdquo;: <code>TRUE</code> if the feature selected as
variable, otherwise <code>FALSE</code>
</p>
</li>
<li> <p>&ldquo;<code>rank</code>&rdquo;: If the feature is selected as variable, then how
it compares to other variable features with lower ranks as more variable;
otherwise, <code>NA</code>
</p>
</li></ul>


<hr>
<h2 id='writing-integration'>Writing Integration Method Functions</h2><span id='topic+writing-integration'></span>

<h3>Description</h3>

<p>Integration method functions can be written by anyone to implement any
integration method in Seurat. These methods should expect to take a
<a href="SeuratObject.html#topic+Assay5">v5 assay</a> as input and return a named list of
objects that can be added back to a <code>Seurat</code> object (eg. a
<a href="SeuratObject.html#topic+DimReduc">dimensional reduction</a> or cell-level meta data)
</p>


<h3>Provided Parameters</h3>

<p>Every integration method function should expect the following arguments:
</p>

<ul>
<li> <p>&ldquo;<code>object</code>&rdquo;: an <code><a href="SeuratObject.html#topic+Assay5">Assay5</a></code> object
</p>
</li>
<li> <p>&ldquo;<code>orig</code>&rdquo;: <a href="SeuratObject.html#topic+DimReduc">dimensional
reduction</a> to correct
</p>
</li>
<li> <p>&ldquo;<code>layers</code>&rdquo;: names of normalized layers in <code>object</code>
</p>
</li>
<li> <p>&ldquo;<code>scale.layer</code>&rdquo;: name(s) of scaled layer(s) in
<code>object</code>
</p>
</li>
<li> <p>&ldquo;<code>features</code>&rdquo;: a vector of features for integration
</p>
</li>
<li> <p>&ldquo;<code>groups</code>&rdquo;: a one-column data frame with the groups for
each cell in <code>object</code>; the column name will be &ldquo;group&rdquo;
</p>
</li></ul>



<h3>Method Discovery</h3>

<p>The documentation for <code><a href="#topic+IntegrateLayers">IntegrateLayers</a>()</code> will automatically
link to integration method functions provided by packages in the
<code><a href="base.html#topic+search">search</a>()</code> space. To make an integration method function
discoverable by the documentation, simply add an attribute named
&ldquo;<code>Seurat.method</code>&rdquo; to the function with a value of
&ldquo;<code>integration</code>&rdquo;
</p>
<pre>
attr(MyIntegrationFunction, which = "Seurat.method") &lt;- "integration"
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+IntegrateLayers">IntegrateLayers</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
