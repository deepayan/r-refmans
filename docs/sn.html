<!DOCTYPE html><html><head><title>Help for package sn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sn-package'><p>Package <span class="pkg">sn</span>: overview, background and history</p></a></li>
<li><a href='#affineTransSECdistr'><p>Affine transformations and marginals of a skew-elliptical distribution</p></a></li>
<li><a href='#ais'><p>Australian Institute of Sport data</p></a></li>
<li><a href='#barolo'><p>Price of Barolo wine</p></a></li>
<li><a href='#coef.selm'><p>Coefficients of objects created by <code>selm</code></p></a></li>
<li><a href='#conditionalSECdistr'><p>Skew-normal conditional distribution</p></a></li>
<li><a href='#confint.selm'><p>Confidence intervals for parameters of a selm-class object</p></a></li>
<li><a href='#convertCSN2SUNpar'><p>Conversion of <abbr><span class="acronym">CSN</span></abbr> parameters to <abbr><span class="acronym">SUN</span></abbr> parameters</p></a></li>
<li><a href='#convertSN2SUNdistr'><p>Convert a SN distribution into a SUN</p></a></li>
<li><a href='#dmsn'><p>Multivariate skew-normal distribution</p></a></li>
<li><a href='#dmst'><p>Multivariate skew-<code class="reqn">t</code> distribution and skew-Cauchy distribution</p></a></li>
<li><a href='#dp2cp'><p>Conversion between parametrizations of a skew-elliptical distribution</p></a></li>
<li><a href='#dsc'><p>Skew-Cauchy Distribution</p></a></li>
<li><a href='#dsn'><p>Skew-Normal Distribution</p></a></li>
<li><a href='#dst'><p>Skew-<code class="reqn">t</code> Distribution</p></a></li>
<li><a href='#extractSECdistr'><p>Extract the SEC error distribution from an object created by <code>selm</code></p></a></li>
<li><a href='#fitdistr.grouped'>
<p>Maximum-likelihood fitting of a univariate distribution from grouped data</p></a></li>
<li><a href='#fitdistr.grouped-class'><p>Methods for objects of class created by <code>fitdistr.grouped</code></p></a></li>
<li><a href='#fournum'><p>Four-number summary of a numeric vector</p></a></li>
<li><a href='#frontier'><p>Simulated sample from a skew-normal distribution</p></a></li>
<li><a href='#galton_moors2alpha_nu'><p>Mapping of the (Galton-Bowley, Moors)  measures to the</p>
(<code class="reqn">alpha</code>, <code class="reqn">nu</code>) parameters of a ST distribution</a></li>
<li><a href='#makeSECdistr'><p>Build a skew-elliptically contoured distribution</p></a></li>
<li><a href='#makeSUNdistr'><p>Build an object representing a SUN distribution</p></a></li>
<li><a href='#matrix-op'><p>vech, tr and other matrix operators</p></a></li>
<li><a href='#modeSECdistr'><p>The mode of a skew-elliptically contoured (<abbr><span class="acronym">SEC</span></abbr>) distribution</p></a></li>
<li><a href='#overview-sn'><p>Package <span class="pkg">sn</span>: overview of the structure and main commands</p></a></li>
<li><a href='#plot.fitdistr.grouped'><p>Plot an object generated by <code>fitdistr.grouped</code></p></a></li>
<li><a href='#plot.SECdistr'><p>Plotting methods for classes <code>SECdistrUv</code> and <code>SECdistrMv</code></p></a></li>
<li><a href='#plot.selm'><p>Diagnostic plots for <code>selm</code> fits</p></a></li>
<li><a href='#plot.SUNdistr-method'><p>Plotting method for class <code>SUNdistr</code></p></a></li>
<li><a href='#pprodt2'>
<p>The distribution of the product of two jointly normal or <em>t</em> variables</p></a></li>
<li><a href='#predict.selm'><p>Predict method for selm-class objects</p></a></li>
<li><a href='#profile.selm'><p>Profile log-likelihood function of selm-class objects</p></a></li>
<li><a href='#Qpenalty'><p>Penalty function for log-likelihood of <code>selm</code> models</p></a></li>
<li><a href='#residuals.selm'><p>Residuals and fitted values from <code>selm</code> fits</p></a></li>
<li><a href='#sd'><p>Standard deviation</p></a></li>
<li><a href='#SECdistrMv-class'><p>Class <code>"SECdistrMv"</code></p></a></li>
<li><a href='#SECdistrUv-class'><p>Class <code>"SECdistrUv"</code></p></a></li>
<li><a href='#selm'><p>Fitting linear models with skew-elliptical error term</p></a></li>
<li><a href='#selm-class'><p>Classes <code>selm</code> and <code>mselm</code> of objects created by</p>
function <code>selm</code></a></li>
<li><a href='#selm.fit'><p>Fitting functions for <code>selm</code> models</p></a></li>
<li><a href='#sn-st.cumulants'><p>Cumulants of univariate skew-normal and skew-<code class="reqn">t</code> distributions</p></a></li>
<li><a href='#sn-st.info'><p>Expected and observed Fisher information for <abbr><span class="acronym">SN</span></abbr></p>
and <abbr><span class="acronym">ST</span></abbr> distributions</a></li>
<li><a href='#spread.grouped'><p>Spreading grouped data over intervals</p></a></li>
<li><a href='#st.prelimFit'>
<p>Compute preliminary estimates for a linear model with ST-distributed error term</p></a></li>
<li><a href='#summary.SECdistr'><p>Summary of a <abbr><span class="acronym">SEC</span></abbr> distribution object</p></a></li>
<li><a href='#summary.SECdistrMv-class'><p>Classes <code>summary.SECdistrMv</code> and <code>summary.SECdistrUv</code></p></a></li>
<li><a href='#summary.selm'><p>Summarizing <code>selm</code> fits</p></a></li>
<li><a href='#summary.SUNdistr'><p>Summary of a <abbr><span class="acronym">SUN</span></abbr> distribution object</p></a></li>
<li><a href='#summary.SUNdistr-class'><p>Class <code>summary.SUNdistr</code></p></a></li>
<li><a href='#SUNdistr-base'><p>The Unified Skew-Normal (SUN) probability distribution</p></a></li>
<li><a href='#SUNdistr-class'><p>Class <code>"SUNdistr"</code> and its methods</p></a></li>
<li><a href='#SUNdistr-op'><p>Operations on SUNdistr-class objects</p></a></li>
<li><a href='#symm-modulated-distr'><p>Symmetry-modulated distributions</p></a></li>
<li><a href='#T.Owen'>
<p>Owen's function</p></a></li>
<li><a href='#wines'><p>Piedmont wines data</p></a></li>
<li><a href='#zeta'><p>Function <code class="reqn">\log(2\,\Phi(x))</code> and its derivatives</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-04</td>
</tr>
<tr>
<td>Title:</td>
<td>The Skew-Normal and Related Distributions Such as the Skew-t and
the SUN</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods, stats4</td>
</tr>
<tr>
<td>Imports:</td>
<td>mnormt (&ge; 2.0.0), numDeriv, utils, quantreg</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>Build and manipulate probability distributions of the skew-normal 
  family and some related ones, notably the skew-t and the SUN families. 
  For the skew-normal and the skew-t distributions, statistical methods are 
  provided for data fitting and model diagnostics, in the univariate and the 
  multivariate case.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://azzalini.stat.unipd.it/SN/">http://azzalini.stat.unipd.it/SN/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-04 17:13:55 UTC; aa</td>
</tr>
<tr>
<td>Author:</td>
<td>Adelchi Azzalini <a href="https://orcid.org/0000-0002-7583-1269"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-04 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sn-package'>Package <span class="pkg">sn</span>: overview, background and history</h2><span id='topic+sn-package'></span><span id='topic+SN'></span>

<h3>Description</h3>

<p>The <span class="pkg">sn</span> package  provides facilities to  define and manipulate 
probability distributions of the skew-normal (<abbr><span class="acronym">SN</span></abbr>) family and 
some related ones, notably the skew-<code class="reqn">t</code> (<abbr><span class="acronym">ST</span></abbr>) and 
the unified skew-normal (<abbr><span class="acronym">SUN</span></abbr>) families. 
For a number of these families, statistical methods are provided, 
to perform data fitting and model diagnostics, 
in the univariate and the multivariate case.
</p>


<h3>Overview of the package structure and commands</h3>

<p>A separatate document is entirely dedicated to the presentation of 
the package structure and its basic functions; 
see the <code><a href="#topic+overview-sn">package overview</a></code>. 
</p>


<h3>Background information and references</h3>

<p>The package adopts the terminology, notation and general framework of the
monograph by Azzalini and Capitanio (2014). 
This matching constitutes a reason for the numerous references to the book 
in the documentation of the package. 
</p>
<p>An additional reason for referring to that monograph instead of the original
research papers is that the book provides a relatively not-so-formal account 
of material which has been elaborated in a number of publications, sometimes
very technical, or re-elabotated over a few papers or possibly mixing 
the information of key interest with other  material. 
In other words, the motivation behind this policy is readability,
not indulgence in self-citation.
</p>
<p>When one or a few original sources appeared to deliver the required
information in a compact and accessible form, they have been cited directly. 
In any case, the cited sections of the book include bibliographic notes
which refer back to the original sources.
</p>


<h3>A bit of history</h3>


<p>The first version of the package was written in 1997, 
and it was uploaded on <abbr><span class="acronym">CRAN</span></abbr> in 1998.
Subsequent versions have evolved  gradually up to version 0.4-18 in May 2013. 
</p>
<p>In January 2014, version 1.0-0 has been uploaded to <abbr><span class="acronym">CRAN</span></abbr>.
This represented a substantial re-writing of the earlier &lsquo;version 0.x&rsquo;,
developed in broad connection with the book by Azzalini and Capitanio (2014). 
Differences between the &lsquo;version 0&rsquo; and the &lsquo;version 1&rsquo; series 
are radical; they concern the core computational and graphical part as well 
as the user interface. 
Since version 1.0-0, the S4 protocol for classes and methods has been adopted.
</p>
<p>After various versions 1.x-y, version 2.0.0 has appeared in March 2021,
providing support for the <abbr><span class="acronym">SUN</span></abbr> distribution.
</p>
<p>Additional information on the evolution of the package is provided in
<code>NEWS</code> file, accessible from the package documentation index page.
</p>


<h3>Backward compatibility versus &lsquo;version 0.4-18&rsquo;</h3>


<p>There is a partial backward compatibility of newer version versus
&lsquo;version 0-4.18&rsquo; of the package.
Some functions of the older version would work as before
with virtually no change; a wider set arguments is now allowed. Functions
<code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dst">dst</a></code>, <code><a href="#topic+dmsn">dmsn</a></code> and alike fall in
this category: in some cases, the names of the arguments have been altered, 
but they work as before if called with unnamed arguments; similar cases are
<code><a href="#topic+msn.mle">msn.mle</a></code>, <code><a href="#topic+sn.cumulants">sn.cumulants</a></code> and <code><a href="#topic+T.Owen">T.Owen</a></code>.
Notice, however, that <code><a href="#topic+msn.mle">msn.mle</a></code> and other fitting functions have
effectively been subsumed into the more comprehensive fitting function
<code><a href="#topic+selm">selm</a></code>.
</p>
<p>A second group of functions will work with little or even minimal changes.
Specific examples are functions <code>sn.mle</code> and <code>st.mle</code> which have
become <code><a href="#topic+sn.mple">sn.mple</a></code> and <code><a href="#topic+st.mple">st.mple</a></code>, with some additional
arguments (again, one can achieve the same result via <code><a href="#topic+selm">selm</a></code>). 
Another example is constitude by the group of functions <code>dp.to.cp</code>,
<code>cp.to.dp</code> and  <code>st.cumulants.inversion</code>, which have been replaced 
by the more general functions <code><a href="#topic+dp2cp">dp2cp</a></code> and <code><a href="#topic+cp2dp">cp2dp</a></code>; 
one only needs to pay attention to conversion from 3rd and 4th order 
cumulants  to their standardized form in connection with the replacement of 
<code>st.cumulants.inversion</code>.
</p>
<p>Finally, some functions are not there any longer, with no similarly-working
functions in the new version.  This is the case of <code>sn.mle.grouped</code>
and <code>st.mle.grouped</code> for maximum likelihood estimation from
grouped data, that is, data recorded as intervals and corresponding 
frequencies.
</p>


<h3>Requirements</h3>

<p><span class="rlang"><b>R</b></span> version 2.15-3 or higher, plus packages <span class="pkg">mnormt</span>, 
<span class="pkg">numDeriv</span> and <span class="pkg">quantreg</span>,   in addition to standard
packages (<span class="pkg">methods</span>, <span class="pkg">graphics</span>, <span class="pkg">stats4</span>,  etc.)
</p>


<h3>Version</h3>

<p>The command <code>citation("sn")</code> indicates, among other information,
the running version of the package.
The most recent version of the package can be obtained from
the web page: <a href="http://azzalini.stat.unipd.it/SN/">http://azzalini.stat.unipd.it/SN/</a>
which also provides related material.
</p>
<p>From the above-indicated web page, one can also obtain the package 
&lsquo;sn0&rsquo; which is essentially the last &lsquo;version 0&rsquo; 
(that is, 0.4-18) with suitable renaming of  certain  ingredients.
This allows to have both the current and the old package installed 
at the same time.
</p>


<h3>Author</h3>

<p>Adelchi Azzalini.
Please send comments, error reports <em>et cetera</em> to the author, 
whose web page is <a href="http://azzalini.stat.unipd.it/">http://azzalini.stat.unipd.it/</a>.
</p>


<h3>Licence</h3>

<p>This package and its documentation are usable under the terms of 
the &ldquo;GNU General Public License&rdquo; version 3 or version 2,
as you prefer; a copy of them is available from 
<a href="https://www.R-project.org/Licenses/">https://www.R-project.org/Licenses/</a>.
</p>
<p>While the software is freely usable, it would be appreciated
if a reference is inserted in publications or other work
which makes use of it. For the appropriate way of referencing it, 
see the command <code>citation("sn")</code>. 
</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overview-sn">package-overview</a></code> </p>

<hr>
<h2 id='affineTransSECdistr'>Affine transformations and marginals of a skew-elliptical distribution</h2><span id='topic+marginalSECdistr'></span><span id='topic+affineTransSECdistr'></span>

<h3>Description</h3>

<p>Given a multivariate random variable <code class="reqn">Y</code> with skew-elliptical
(<abbr><span class="acronym">SEC</span></abbr>) distribution, compute the distribution 
of a (possibly multivariate) marginal or the distribution
of an affine  transformation <code class="reqn">a + A^{\top}Y</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  affineTransSECdistr(object, a, A, name, compNames, drop=TRUE)
  marginalSECdistr(object, comp, name, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affineTransSECdistr_+3A_object">object</code></td>
<td>
<p>an object of class <code>SECdistrMv</code> which identifies the 
source random variable, as created by
<code><a href="#topic+makeSECdistr">makeSECdistr</a></code> or by <code><a href="#topic+extractSECdistr">extractSECdistr</a></code> or 
by a previous call to these functions</p>
</td></tr>
<tr><td><code id="affineTransSECdistr_+3A_a">a</code></td>
<td>
<p>a numeric vector with the length <code>ncol(A)</code>.</p>
</td></tr>
<tr><td><code id="affineTransSECdistr_+3A_a">A</code></td>
<td>
<p>a full-rank matrix with <code>nrow(A)</code> equal to the dimensionality
<kbd>d</kbd> of the random variable identified by <code>object</code>. </p>
</td></tr>
<tr><td><code id="affineTransSECdistr_+3A_name">name</code></td>
<td>
<p>an optional character string representing the name of the 
outcome distribution; if missing, one such string is constructed.</p>
</td></tr>
<tr><td><code id="affineTransSECdistr_+3A_compnames">compNames</code></td>
<td>
<p>an optional vector of length <code>ncol(A)</code> of character 
strings  with the names of the components of the outcome distribution; 
if missing, one such vector is constructed.</p>
</td></tr>
<tr><td><code id="affineTransSECdistr_+3A_drop">drop</code></td>
<td>
<p>a logical flag (default value: <code>TRUE</code>), operating only if
the returned object has dimension <code>d=1</code>, in which case it indicates
whether this object must be of class <code>SECdistrUv</code>.</p>
</td></tr>
<tr><td><code id="affineTransSECdistr_+3A_comp">comp</code></td>
<td>
<p>a vector formed by a subset of <code>1:d</code> which indicates which
components must be extracted from <code>object</code>, on denoting by <code>d</code> 
its dimensionality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>object</code> defines the distribution of a <abbr><span class="acronym">SEC</span></abbr> random
variable <code class="reqn">Y</code>, <code>affineTransSECdistr</code> computes  the 
distribution of <code class="reqn">a+A'Y</code> and <code>marginalSECdistr</code> computes the marginal
distribution of the <code>comp</code> components. In both cases the returned
object is of class <code>SECdistrMv</code>, except when <code>drop=TRUE</code>
operates, leading to an object of class <code>SECdistrUv</code>.</p>


<h3>Background</h3>

<p>These functions implement formulae given in Sections 
5.1.4, 5.1.6 and 6.2.2 of the reference below.</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, <code><a href="#topic+extractSECdistr">extractSECdistr</a></code>,
<code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dp3 &lt;- list(xi=1:3, Omega=toeplitz(1/(1:3)), alpha=c(3,-1,2), nu=5)
st3 &lt;- makeSECdistr(dp3, family="ST", name="ST3", compNames=c("U", "V", "W"))
A &lt;- matrix(c(1,-1,1, 3,0,-2), 3, 2)
new.st &lt;- affineTransSECdistr(st3, a=c(-3,0), A=A)
#
st2 &lt;- marginalSECdistr(st3, comp=c(3,1), name="2D marginal of ST3")
</code></pre>

<hr>
<h2 id='ais'>Australian Institute of Sport data</h2><span id='topic+ais'></span>

<h3>Description</h3>

<p>Data on 102 male and 100 female athletes collected at the 
Australian Institute of Sport, courtesy of Richard Telford and Ross Cunningham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ais)</code></pre>


<h3>Format</h3>

 
<p>A data frame with 202 observations on the following 13 variables.
</p>

<table>
<tr>
 <td style="text-align: right;">
   [,1]</td><td style="text-align: left;"> <code>sex</code></td><td style="text-align: left;"> categorical, levels: <code>female</code>, <code>male</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   [,2]</td><td style="text-align: left;"> <code>sport</code></td><td style="text-align: left;"> categorical, levels: <code>B_Ball</code>, <code>Field</code>,
      <code>Gym</code>, <code>Netball</code>, <code>Row</code>, <code>Swim</code>, <code>T_400m</code>, </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>Tennis</code>, <code>T_Sprnt</code>, <code>W_Polo</code></td>
</tr>
<tr>
 <td style="text-align: right;">            
   [,3]</td><td style="text-align: left;"> <code>RCC</code></td><td style="text-align: left;"> red cell count (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,4]</td><td style="text-align: left;"> <code>WCC</code></td><td style="text-align: left;"> white cell count (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,5]</td><td style="text-align: left;"> <code>Hc</code></td><td style="text-align: left;"> Hematocrit (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,6]</td><td style="text-align: left;"> <code>Hg</code></td><td style="text-align: left;"> Hemoglobin (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,7]</td><td style="text-align: left;"> <code>Fe</code></td><td style="text-align: left;">  plasma ferritin concentration (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,8]</td><td style="text-align: left;"> <code>BMI</code></td><td style="text-align: left;"> body mass index, weight/(height)<code class="reqn">^2</code> 
       (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,9]</td><td style="text-align: left;"> <code>SSF</code></td><td style="text-align: left;"> sum of skin folds (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,10]</td><td style="text-align: left;"> <code>Bfat</code></td><td style="text-align: left;"> body fat percentage (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,11]</td><td style="text-align: left;"> <code>LBM</code></td><td style="text-align: left;"> lean body mass  (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,12]</td><td style="text-align: left;"> <code>Ht</code></td><td style="text-align: left;"> height, cm (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
   [,13]</td><td style="text-align: left;"> <code>Wt</code></td><td style="text-align: left;"> weight, kg (numeric)</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>The data have been made publicly available in connection with the
book by  Cook and Weisberg (1994).</p>


<h3>References</h3>

<p>Cook and Weisberg (1994),
<em>An Introduction to Regression Graphics</em>.                   
John Wiley &amp; Sons, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais, package="sn")
pairs(ais[,c(3:4,10:13)], col=as.numeric(ais[,1]), main = "AIS data")
</code></pre>

<hr>
<h2 id='barolo'>Price of Barolo wine</h2><span id='topic+barolo'></span>

<h3>Description</h3>

<p>A data frame with prices of bottles of Barolo wine 
and some auxiliary variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(barolo)</code></pre>


<h3>Format</h3>

<p>A data frame with 307 observations on five variables, as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>reseller</code></td><td style="text-align: left;"> reseller code (factor with levels <code>A, B, C, D</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>vintage</code> </td><td style="text-align: left;"> vintage year (numeric) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>volume</code>  </td><td style="text-align: left;"> content volume in centilitres (numeric) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>price</code>   </td><td style="text-align: left;"> price in Euro (numeric) </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>age</code>     </td><td style="text-align: left;"> age in 2010 (numeric)
</td>
</tr>

</table>

<p>For six items, <code>vintage</code> is <code>NA</code>'s and so also <code>age</code>.
Three items have a non-standard volume of 50 cl.
</p>


<h3>Details</h3>

<p>The data have been obtained in July 2010 from the websites  
of four Italian wine resellers, selecting only quotations of Barolo 
wine, which is produced in the Piedmont region of Italy. 
The price does not include the delivery charge.
</p>
<p>The data have been presented in Section 4.3.2 of the reference below,
where a subset of them has been used for illustrative purposes.
This subset refers to reseller <code>"A"</code> and bottles of 75cl.
</p>


<h3>Source</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barolo)
attach(barolo)  
f &lt;- cut(age, c(0, 5,  6, 8, 11,  30))
table(volume, f)
plot(volume, price, col=as.numeric(f), pch=as.character(reseller))
legend(400, 990, col=1:5, lty=1, title="age class",
       legend=c("4-5", "6", "7-8", "9-11", "12-30"))
#
A75 &lt;- (reseller=="A" &amp; volume==75)
hist(log(price[A75],10), col="gray85")
# see Figure 4.7 of the source
</code></pre>

<hr>
<h2 id='coef.selm'>Coefficients of objects created by <code>selm</code></h2><span id='topic+coef.selm'></span><span id='topic+coef.mselm'></span><span id='topic+coef+2Cselm-method'></span><span id='topic+coef+2Cmselm-method'></span>

<h3>Description</h3>

<p><code>coef</code> method for classes <code>"selm"</code> and <code>"mselm"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'selm'
coef(object, param.type = "CP", ...)
## S4 method for signature 'mselm'
coef(object, param.type = "CP", vector=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.selm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"selm"</code> or <code>"mselm"</code> as created
by a call to function <code>selm</code>.</p>
</td></tr>
<tr><td><code id="coef.selm_+3A_param.type">param.type</code></td>
<td>
<p>a character string which indicates the required type of 
parameter type; possible values are <code>"CP"</code> (default), <code>"DP"</code>,
<code>"pseudo-CP"</code> and their equivalent lower-case  expressions.</p>
</td></tr>
<tr><td><code id="coef.selm_+3A_vector">vector</code></td>
<td>
<p>a logical value (default is <code>TRUE</code>) which selects a vector
or a list format of the retuned value</p>
</td></tr>
<tr><td><code id="coef.selm_+3A_...">...</code></td>
<td>
<p>not used, included for compatibility with the generic method</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>a numeric vector or a list
(the latter only for <code>mselm-class</code> objects if <code>vector=FALSE</code>) </p>


<h3>Note</h3>

<p>The possible options of <code>param.type</code> are described in the
documentation of <code><a href="#topic+dp2cp">dp2cp</a></code>; their corresponding outcomes 
differ by an additive constant only. With the <code>"CP"</code> option (that is,
the &lsquo;centred parametrization&rsquo;), the residuals are centred around 0, 
at least approximately; this is a reason for setting <code>"CP"</code> as the 
default option. For more information, see  the &lsquo;Note&rsquo; in the 
documentation of <code><a href="#topic+summary.selm">summary.selm</a></code>. </p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dp2cp">dp2cp</a></code>, <code><a href="#topic+summary.selm">summary.selm</a></code>, 
<code><a href="#topic+selm">selm</a></code> function, <code><a href="#topic+selm-class">selm</a>-class</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(wines, package="sn")
m5 &lt;- selm(acidity ~ phenols + wine, family="SN", data=wines)
coef(m5)
coef(m5, "dp")
#
m12 &lt;- selm(cbind(acidity, alcohol) ~ phenols + wine,  family="SN", data=wines)
coef(m12)
coef(m12, "DP", vector=FALSE)

</code></pre>

<hr>
<h2 id='conditionalSECdistr'>Skew-normal conditional distribution</h2><span id='topic+conditionalSECdistr'></span>

<h3>Description</h3>

<p>For a multivariate (extended) skew-normal distribution, compute 
its conditional distribution for given values of some of its components.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  conditionalSECdistr(object, fixed.comp, fixed.values, name, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditionalSECdistr_+3A_object">object</code></td>
<td>
<p>an object of class <code>SECdistrMv</code> with <code>family="SN"</code>
or <code>family="ESN"</code>. </p>
</td></tr>
<tr><td><code id="conditionalSECdistr_+3A_fixed.comp">fixed.comp</code></td>
<td>
<p>a vector containing a subset of <code>1:d</code> which selects
the components whose values are to be fixed, if <code>d</code> denotes the
dimensionality of the distribution.</p>
</td></tr>
<tr><td><code id="conditionalSECdistr_+3A_fixed.values">fixed.values</code></td>
<td>
<p>a numeric vector of values taken on by the components
<code>fixed.comp</code>; it must be of the same length of <code>fixed.comp</code>.</p>
</td></tr>
<tr><td><code id="conditionalSECdistr_+3A_name">name</code></td>
<td>
<p>an optional character string with the name of the outcome 
distribution; if missing, one such string is constructed.</p>
</td></tr>
<tr><td><code id="conditionalSECdistr_+3A_drop">drop</code></td>
<td>
<p>logical (default=<code>TRUE</code>), to indicate whether the
returned object must be of class <code>SECdistrUv</code> when
<code>length(fixed.comp)+1=d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For background information, see Section 5.3.2 of the reference below.</p>


<h3>Value</h3>

<p>an object of class <code>SECdistrMv</code>, except in the case when 
<code>drop=TRUE</code> operates, leading to an object of class 
<code>SECdistrUv-class</code>.</p>


<h3>References</h3>

<p>Azzalini, A. and Capitanio, A. (2014). <em>The Skew-normal and Related 
Families</em>. Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, <code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code>, 
<code><a href="#topic+affineTransSECdistr">affineTransSECdistr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>Omega &lt;- diag(3) + outer(1:3,1:3)
sn &lt;- makeSECdistr(dp=list(xi=rep(0,3), Omega=Omega, alpha=1:3), family="SN")
esn &lt;- conditionalSECdistr(sn, fixed.comp=2, fixed.values=1.5)
show(esn)
</code></pre>

<hr>
<h2 id='confint.selm'>Confidence intervals for parameters of a selm-class object</h2><span id='topic+confint.selm'></span><span id='topic+confint.selm-method'></span>

<h3>Description</h3>

<p>Computes confidence intervals for parameters in a selm-class object produces
by <code>selm</code> fit when the response variable is univariate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'selm'
confint(object, parm, level=0.95, param.type, tol=1e-3, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.selm_+3A_object">object</code></td>
<td>
<p>an object of class <code>selm</code> as produced by a call to
function <code>selm</code> with univariate response.</p>
</td></tr>
<tr><td><code id="confint.selm_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence 
intervals, either a vector of numbers or a vector of names. If missing, all 
parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.selm_+3A_level">level</code></td>
<td>
<p>the confidence level required (default value is <code>0.95</code>).</p>
</td></tr> 
<tr><td><code id="confint.selm_+3A_param.type">param.type</code></td>
<td>

<p>a character string with the required parameterization; it must be either
<code>"CP"</code> or <code>"DP"</code> or <code>"pseudo-CP"</code>, or possibly their 
equivalent lowercase.</p>
</td></tr>
<tr><td><code id="confint.selm_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance); this is a parameter 
passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code> for computing the roots of the
likelihood-based confidence interval for <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="confint.selm_+3A_...">...</code></td>
<td>
<p>not used, only there for compatibility reasons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A description of the methodology underlying <code>confint.selm</code> is provided 
in the technical note of Azzalini (2016).
That document also explains why in certain cases an interval is not 
constructed and <code>NA</code>'s are returned as endpoint.</p>


<h3>Value</h3>

<p>An invisible list whose components, described below, are partly 
different in the one- and the two-parameter cases.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the calling statement</p>
</td></tr>
<tr><td><code>&lt;param1&gt;</code></td>
<td>
<p>values of the first parameter</p>
</td></tr>
<tr><td><code>&lt;param2&gt;</code></td>
<td>
<p>values of the second parameter (in a two-parameter case)</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>numeric vector or matrix of the profile log-likelihood values</p>
</td></tr>
<tr><td><code>confint</code></td>
<td>
<p>in the one-parameter case, the confidence interval</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>in the one-parameter case, the confidence level</p>
</td></tr>
<tr><td><code>deviance.contour</code></td>
<td>
<p>in the two-parameter case, a list of lists whose
elements identify each curve of the contour plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. (2016). 
Derivation of various types of intervals from a <code>selm</code> object.
Technical note distributed with the documentation of the <span class="rlang"><b>R</b></span> package
<code>sn</code> in file 
<a href="../doc/selm-intervals.pdf"><code>selm-intervals.pdf</code></a>  within 
section &lsquo;User guide, package vignettes and other documentation&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code>, <code><a href="#topic+summary.selm">summary.selm</a></code>, <code><a href="#topic+profile.selm">profile.selm</a></code>,
</p>
<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for the <abbr><span class="acronym">CP</span></abbr>/<abbr><span class="acronym">DP</span></abbr> parameterizations,
</p>
<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for its <code>tol</code> argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
m1 &lt;-  selm(log(Fe) ~ BMI + LBM, family = "sn", data = ais)
intervCP &lt;- confint(m1)
intervDP &lt;- confint(m1, param.type="DP")
confint(m1, parm=2:3)    
confint(m1, parm=c("omega", "alpha"), param.type="DP")                                 
</code></pre>

<hr>
<h2 id='convertCSN2SUNpar'>Conversion of <abbr><span class="acronym">CSN</span></abbr> parameters to <abbr><span class="acronym">SUN</span></abbr> parameters</h2><span id='topic+convertCSN2SUNpar'></span>

<h3>Description</h3>

<p>The parameter set of a Closed Skew-Normal (<abbr><span class="acronym">CSN</span></abbr>)
distribution is  converted into the parameter set of the equivalent 
Unified Skew-Normal (<abbr><span class="acronym">SUN</span></abbr>) distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertCSN2SUNpar(mu, Sigma, D, nu, Delta)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertCSN2SUNpar_+3A_mu">mu</code></td>
<td>
<p>a numeric vector of length <code>p</code>, say.</p>
</td></tr>
<tr><td><code id="convertCSN2SUNpar_+3A_sigma">Sigma</code></td>
<td>
<p>a positive definite variance matrix of size <code>c(p,p)</code>.</p>
</td></tr>
<tr><td><code id="convertCSN2SUNpar_+3A_d">D</code></td>
<td>
<p>an arbitrary numeric matrix of size say <code>c(q, p)</code>, say.</p>
</td></tr>
<tr><td><code id="convertCSN2SUNpar_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length <code>q</code>.</p>
</td></tr>
<tr><td><code id="convertCSN2SUNpar_+3A_delta">Delta</code></td>
<td>
<p>a positive definite variance matrix of size <code>c(q,q)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of the function match the parameters 
<code class="reqn">(\mu, \Sigma, D, \nu, \Delta)</code> of the <abbr><span class="acronym">CSN</span></abbr> distribution
presented by González-Farías <em>et alii</em> (2004a, 2004b). 
These parameters are converted into those of the equivalent 
<abbr><span class="acronym">SUN</span></abbr> distribution, which is unique. The converse operation, that is,
mapping parameters from the <abbr><span class="acronym">SUN</span></abbr> to the <abbr><span class="acronym">CSN</span></abbr> family, 
is not handled here. Its solution  would be non-unique, 
because the <abbr><span class="acronym">CSN</span></abbr> family is over-parameterized.
</p>
<p>Note that, having retained the exact notation of the above-quoted papers,
there is a <code>Delta</code> argument which must not be confused with one of the
arguments for the <abbr><span class="acronym">SUN</span></abbr> distribution  in <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>. 
The coincidence of these names is entirely accidental.
</p>
<p>The <abbr><span class="acronym">CSN</span></abbr> parameters must only satisfy the requirements that 
<code class="reqn">\Sigma</code> and <code class="reqn">\Delta</code> are symmetric positive definite matrices. 
Since these conditions are somewhat simpler to check than those for the 
<abbr><span class="acronym">SUN</span></abbr> parameters, as indicated in <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>, 
this function may provide a simple option for the specification of a
<abbr><span class="acronym">CSN/SUN</span></abbr> distribution.
</p>
<p>The parameter list <code>dp</code> produced by this function can be used as an
input for the functions in <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code> or for
<code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code>.
</p>


<h3>Value</h3>

<p>a list representing the <code>dp</code> parameter set of the
corresponding <abbr><span class="acronym">SUN</span></abbr> distribution</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>González-Farías, G., Domínguez-Molina, J. A., &amp; Gupta, A. K. (2004a). 
Additive properties of skew normal random vectors.
<em>J. Statist. Plann. Inference</em> <b>126</b>, 521-534.
</p>
<p>González-Farías, G., Domínguez-Molina, J. A., &amp; Gupta, A. K. (2004b). 
The closed skew-normal distribution. 
In M. G. Genton (Ed.), <em>Skew-elliptical Distributions and Their 
Applications: a Journey Beyond Normality</em>, Chapter 2, (pp. 25–42). 
Chapman &amp; Hall/<abbr><span class="acronym">CRC</span></abbr>. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>, <code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 3
q &lt;- 2
mu &lt;- 1:p
Sigma &lt;- toeplitz(1/(1:p))
D &lt;- matrix(sqrt(1:(p*q)), q, p)
nu &lt;- 1/(1:q)
Delta &lt;- diag(q) + outer(rep(1,q), rep(1,q))
dp &lt;- convertCSN2SUNpar(mu, Sigma, D, nu, Delta)
</code></pre>

<hr>
<h2 id='convertSN2SUNdistr'>Convert a SN distribution into a SUN</h2><span id='topic+convertSN2SUNdistr'></span>

<h3>Description</h3>

<p>An object of <code>SECdistrMv-class</code> or <code>SECdistrUv-class</code> 
representing a <abbr><span class="acronym">SN</span></abbr> or <abbr><span class="acronym">ESN</span></abbr>  distribution is converted  
into a <code>SUNdistr-class</code> object representing the same distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertSN2SUNdistr(object, HcompNames = "h", silent = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertSN2SUNdistr_+3A_object">object</code></td>
<td>
<p>an object of <code>SECdistrMv-class</code> with <code>family</code> of type
<code>SN</code> or <code>ESN</code>.</p>
</td></tr>
<tr><td><code id="convertSN2SUNdistr_+3A_hcompnames">HcompNames</code></td>
<td>
<p>an optional character string for the hidden component</p>
</td></tr> 
<tr><td><code id="convertSN2SUNdistr_+3A_silent">silent</code></td>
<td>
<p>a logical value which controls the behaviour if the supplied
<code>object</code> is not suitable. If <code>silent = FALSE</code>  (detault value)
an error message is generated, otherwise a <code>NULL</code> is silently
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code>SUNdistr-class</code></p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

 <p><code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code>, <code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code>, 
<code><a href="#topic+SECdistrUv-class">SECdistrUv-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>esn &lt;- makeSECdistr(dp=c(0, 1, 2, 0.5), family="ESN")
sun &lt;- convertSN2SUNdistr(esn)
mean(sun) - mean(esn)
vcov(sun) - sd(esn)^2
#
dp0 &lt;- list(xi=1:2, Omega=diag(3:4), alpha=c(3, -5))
f10 &lt;- makeSECdistr(dp=dp0, family="SN", name="SN-2d", compNames=c("u1", "u2"))
sun10 &lt;- convertSN2SUNdistr(f10)
mean(sun10) - mean(f10)
vcov(sun10) - vcov(f10)
</code></pre>

<hr>
<h2 id='dmsn'>Multivariate skew-normal distribution</h2><span id='topic+dmsn'></span><span id='topic+pmsn'></span><span id='topic+rmsn'></span>

<h3>Description</h3>

<p>Probability density function, distribution function and random number 
generation for the multivariate skew-normal (<abbr><span class="acronym">SN</span></abbr>) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmsn(x, xi=rep(0,length(alpha)), Omega, alpha, tau=0, dp=NULL, log=FALSE)
pmsn(x, xi=rep(0,length(alpha)), Omega, alpha,  tau=0, dp=NULL, ...)
rmsn(n=1, xi=rep(0,length(alpha)), Omega, alpha,  tau=0, dp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmsn_+3A_x">x</code></td>
<td>
<p>either a vector of length <code>d</code>, 
where <code>d=length(alpha)</code>, or a matrix with <code>d</code> columns, 
giving the coordinates of the point(s) where the density or the
distribution function must be evaluated.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_xi">xi</code></td>
<td>
<p>a numeric vector of length <code>d</code> representing the 
location parameter of the distribution; see &lsquo;Background&rsquo;.
In a call to <code>dmsn</code> and <code>pmsn</code>, <code>xi</code> can be a matrix,
whose rows represent a set of location parameters;
in this case, its dimensions must match those of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_omega">Omega</code></td>
<td>
<p>a symmetric positive-definite matrix of dimension <code>(d,d)</code>;
see &lsquo;Background&rsquo;.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector which regulates the slant of the density; 
see &lsquo;Background&rsquo;. <code>Inf</code> values in <code>alpha</code> are not allowed.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_tau">tau</code></td>
<td>
<p>a single value representing the &lsquo;hidden mean&rsquo; parameter 
of the <abbr><span class="acronym">ESN</span></abbr> distribution; <code>tau=0</code> (default) corresponds to 
a <abbr><span class="acronym">SN</span></abbr> distribution.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_dp">dp</code></td>
<td>

<p>a list with three elements, corresponding to <code>xi</code>, <code>Omega</code> and 
<code>alpha</code> described above; default value <code>FALSE</code>. 
If <code>dp</code> is assigned, individual parameters must not be specified. </p>
</td></tr>
<tr><td><code id="dmsn_+3A_n">n</code></td>
<td>
<p>a numeric value which represents the number of random vectors
to be drawn.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_log">log</code></td>
<td>
<p>logical (default value: <code>FALSE</code>); 
if <code>TRUE</code>, log-densities are returned.</p>
</td></tr>
<tr><td><code id="dmsn_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="mnormt.html#topic+pmnorm">pmnorm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
dmsn(x, xi=rep(0,length(alpha)), Omega, alpha, log=FALSE)
dmsn(x, dp=, log=FALSE)
pmsn(x, xi=rep(0,length(alpha)), Omega, alpha, ...)
pmsn(x, dp=)
rmsn(n=1, xi=rep(0,length(alpha)), Omega, alpha)
rmsn(n=1, dp=)
</pre>
<p>For efficiency reasons, <code>rmsn</code> makes very limited checks on the 
validity of the arguments. For instance, failure to positive definiteness 
of <code>Omega</code> would not be detected, and an uncontrolled crash occurs. 
Function <code>pmsn</code> makes use of <code>pmnorm</code> from package <span class="pkg">mnormt</span>;
the accuracy of its computation can be controlled via <code>...</code>
</p>


<h3>Value</h3>

<p>A vector of density values (<code>dmsn</code>) or of probabilities
(<code>pmsn</code>) or a matrix of random  points (<code>rmsn</code>).
</p>


<h3>Background</h3>

<p>The multivariate skew-normal distribution is discussed by Azzalini and 
Dalla Valle (1996). The <code>(Omega,alpha)</code>
parametrization adopted here is the one of Azzalini and Capitanio (1999).
Chapter 5 of Azzalini and Capitanio (2014) provides an extensive account,
including subsequent developments.
</p>
<p>Notice that the location vector <code>xi</code> does not represent the mean vector 
of the distribution. Similarly, <code>Omega</code> is not <em>the</em> covariance 
matrix of the distribution, although it is <em>a</em> covariance matrix. 
Finally, the components of <code>alpha</code> are not equal to the slant parameters 
of the marginal  distributions; to fix the marginal parameters at prescribed 
values, it is convenient to start from the OP parameterization, as illustrated 
in the &lsquo;Examples&rsquo; below. Another option is to start from the <abbr><span class="acronym">CP</span></abbr>
parameterization, but notice that, at variance from the <abbr><span class="acronym">OP</span></abbr>, not all
<abbr><span class="acronym">CP</span></abbr> sets are invertible to lend a <abbr><span class="acronym">DP</span></abbr> set.</p>


<h3>References</h3>

<p>Azzalini, A. and Capitanio, A. (1999).
Statistical applications of the multivariate skew normal distribution.
<em>J.Roy.Statist.Soc. B</em> <b>61</b>, 579&ndash;602. Full-length version 
available at <a href="https://arXiv.org/abs/0911.2093">https://arXiv.org/abs/0911.2093</a>
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Azzalini, A. and Dalla Valle, A. (1996).
The multivariate skew-normal distribution.
<em>Biometrika</em> <b>83</b>, 715&ndash;726.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsn">dsn</a></code>,  <code><a href="#topic+dmst">dmst</a></code>,  <code><a href="mnormt.html#topic+pmnorm">pmnorm</a></code>,
<code><a href="#topic+op2dp">op2dp</a></code>,  <code><a href="#topic+cp2dp">cp2dp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-3,3,length=15)
xi &lt;- c(0.5, -1)
Omega &lt;- diag(2)
Omega[2,1] &lt;- Omega[1,2] &lt;- 0.5
alpha &lt;- c(2,-6)
pdf &lt;- dmsn(cbind(x, 2*x-1), xi, Omega, alpha)
cdf &lt;- pmsn(cbind(x, 2*x-1), xi, Omega, alpha)
p1 &lt;- pmsn(c(2,1), xi, Omega, alpha)
p2 &lt;- pmsn(c(2,1), xi, Omega, alpha, abseps=1e-12, maxpts=10000)
#
rnd &lt;- rmsn(10, xi, Omega, alpha)
#
# use OP parameters to fix marginal shapes at given lambda values:
op &lt;- list(xi=c(0,1), Psi=matrix(c(2,2,2,3), 2, 2), lambda=c(5, -2))
rnd &lt;- rmsn(10, dp=op2dp(op,"SN"))
# 
# use CP parameters to fix mean vector, variance matrix and marginal skewness:
cp &lt;- list(mean=c(0,0), var.cov=matrix(c(3,2,2,3)/3, 2, 2), gamma1=c(0.8, 0.4))
dp &lt;- cp2dp(cp, "SN")
rnd &lt;- rmsn(5, dp=dp)
</code></pre>

<hr>
<h2 id='dmst'>Multivariate skew-<code class="reqn">t</code> distribution and skew-Cauchy distribution</h2><span id='topic+dmst'></span><span id='topic+pmst'></span><span id='topic+rmst'></span><span id='topic+dmsc'></span><span id='topic+pmsc'></span><span id='topic+rmsc'></span>

<h3>Description</h3>

<p>Probability density function, distribution function and random 
number generation for the multivariate skew-<code class="reqn">t</code> (<abbr><span class="acronym">ST</span></abbr>) and
skew-Cauchy (<abbr><span class="acronym">SC</span></abbr>) distributions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmst(x, xi=rep(0,length(alpha)), Omega, alpha, nu=Inf, dp=NULL, log=FALSE)
pmst(x, xi=rep(0,length(alpha)), Omega, alpha, nu=Inf, dp=NULL, ...)
rmst(n=1, xi=rep(0,length(alpha)), Omega, alpha, nu=Inf, dp=NULL)
dmsc(x, xi=rep(0,length(alpha)), Omega, alpha, dp=NULL, log=FALSE)
pmsc(x, xi=rep(0,length(alpha)), Omega, alpha, dp=NULL, ...)
rmsc(n=1, xi=rep(0,length(alpha)), Omega, alpha, dp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmst_+3A_x">x</code></td>
<td>
<p>for <code>dmst</code> and <code>dmsc</code>, this is either a vector of length
<code>d</code>, where <code>d=length(alpha)</code>, or a matrix with <code>d</code> columns,
representing the coordinates of the point(s) where the density must be
avaluated; for <code>pmst</code> and <code>pmsc</code>, only a vector of length
<code>d</code> is allowed.</p>
</td></tr>
<tr><td><code id="dmst_+3A_xi">xi</code></td>
<td>
<p>a numeric vector of length <code>d</code> representing the 
location parameter of the distribution; see &lsquo;Background&rsquo;.
In a call to <code>dmst</code> or <code>dmsc</code>, <code>xi</code> can be a matrix,
whose rows represent a set of location parameters; 
in this case, its dimensions must match those of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dmst_+3A_omega">Omega</code></td>
<td>
<p>a symmetric positive-definite matrix of dimension <code>(d,d)</code>; 
see Section &lsquo;Background&rsquo;.</p>
</td></tr>
<tr><td><code id="dmst_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of length <code>d</code> which regulates the slant
of the density; see Section &lsquo;Background&rsquo;.
<code>Inf</code> values in <code>alpha</code> are not allowed.</p>
</td></tr>
<tr><td><code id="dmst_+3A_nu">nu</code></td>
<td>
<p>a positive value representing the degrees of freedom of
<abbr><span class="acronym">ST</span></abbr> distribution; does not need to be integer. 
Default value is <code>nu=Inf</code> which corresponds to the multivariate
skew-normal distribution.</p>
</td></tr>
<tr><td><code id="dmst_+3A_dp">dp</code></td>
<td>
<p>a list with three elements named <code>xi</code>, <code>Omega</code>,
<code>alpha</code> and <code>nu</code>, containing quantities as described above. If
<code>dp</code> is specified, this prevents specification of the individual
parameters.</p>
</td></tr>
<tr><td><code id="dmst_+3A_n">n</code></td>
<td>
<p>a numeric value which represents the number of random vectors to be
drawn; default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="dmst_+3A_log">log</code></td>
<td>
<p>logical (default value: <code>FALSE</code>); if <code>TRUE</code>,
log-densities are returned.</p>
</td></tr>
<tr><td><code id="dmst_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>pmt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
dmst(x, xi=rep(0,length(alpha)), Omega, alpha, nu=Inf, log=FALSE)
dmst(x, dp=, log=FALSE)
pmst(x, xi=rep(0,length(alpha)), Omega, alpha, nu=Inf, ...)
pmst(x, dp=, ...)
rmst(n=1, xi=rep(0,length(alpha)), Omega, alpha, nu=Inf)
rmst(n=1, dp=)
dmsc(x, xi=rep(0,length(alpha)), Omega, alpha, log=FALSE)
dmsc(x, dp=, log=FALSE)
pmsc(x, xi=rep(0,length(alpha)), Omega, alpha, ...)
pmsc(x, dp=, ...)
rmsc(n=1, xi=rep(0,length(alpha)), Omega, alpha)
rmsc(n=1, dp=)
</pre>
<p>For efficiency reasons, <code>rmst, rmsc</code> make very limited checks on the 
validity of the arguments. For instance, failure to positive definiteness 
of <code>Omega</code> would not be detected, and an uncontrolled crash occurs.
Function <code>pmst</code> requires <code><a href="mnormt.html#topic+dmt">dmt</a></code> from package 
<span class="pkg">mnormt</span>; the accuracy of its computation can be controlled via 
argument <code>...</code>.</p>


<h3>Value</h3>

<p>A vector of density values (<code>dmst</code> and <code>dmsc</code>) or a single
probability (<code>pmst</code> and <code>pmsc</code>) or a matrix of random points
(<code>rmst</code> and <code>rmsc</code>).</p>


<h3>Background</h3>

<p>The family of multivariate <abbr><span class="acronym">ST</span></abbr> distributions is an extension of the 
multivariate Student's <code class="reqn">t</code> family, via the introduction of a <code>alpha</code> 
parameter which regulates asymmetry; when <code>alpha=0</code>, the skew-<code class="reqn">t</code>
distribution reduces to the commonly used form of multivariate Student's 
<code class="reqn">t</code>.  Further,  location is regulated by <code>xi</code> and scale by 
<code>Omega</code>, when its diagonal terms are not all 1's.
When <code>nu=Inf</code> the distribution reduces to the multivariate skew-normal 
one; see <code>dmsn</code>. Notice that the location vector <code>xi</code>
does not represent the mean vector of the distribution (which in fact
may not even exist if <code>nu &lt;= 1</code>), and similarly <code>Omega</code> is not 
<em>the</em> covariance matrix of the distribution, although it is <em>a</em> 
covariance matrix. 
For additional information, see Section 6.2 of the reference below.
</p>
<p>The family of multivariate <abbr><span class="acronym">SC</span></abbr> distributions is the subset of the
<abbr><span class="acronym">ST</span></abbr> family, obtained when <code>nu=1</code>. While in the univariate case
there are specialized functions for the <abbr><span class="acronym">SC</span></abbr> distribution,
<code>dmsc</code>, <code>pmsc</code> and <code>rmsc</code> simply make a call to <code>dmst,
pmst, rmst</code> with argument <code>nu</code> set equal to 1.</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monograph series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dst">dst</a></code>,  <code><a href="#topic+dsc">dsc</a></code>, <code><a href="#topic+dmsn">dmsn</a></code>, 
<code><a href="mnormt.html#topic+dmt">dmt</a></code>, <code><a href="#topic+makeSECdistr">makeSECdistr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4,4,length=15)
xi &lt;- c(0.5, -1)
Omega &lt;- diag(2)
Omega[2,1] &lt;- Omega[1,2] &lt;- 0.5
alpha &lt;- c(2,2)
pdf &lt;- dmst(cbind(x,2*x-1), xi, Omega, alpha, 5)
rnd &lt;- rmst(10,  xi, Omega, alpha, 6)
p1 &lt;- pmst(c(2,1), xi, Omega, alpha, nu=5)
p2 &lt;- pmst(c(2,1), xi, Omega, alpha, nu=5, abseps=1e-12, maxpts=10000)
</code></pre>

<hr>
<h2 id='dp2cp'>Conversion between parametrizations of a skew-elliptical distribution</h2><span id='topic+dp2cp'></span><span id='topic+cp2dp'></span><span id='topic+dp2op'></span><span id='topic+op2dp'></span>

<h3>Description</h3>

<p>Convert direct parameters (<abbr><span class="acronym">DP</span></abbr>) to centred parameters 
(<abbr><span class="acronym">CP</span></abbr>) of a skew-elliptical distribution and <em>vice versa</em>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dp2cp(dp, family, object = NULL, cp.type = "proper", upto = NULL) 
cp2dp(cp, family)
dp2op(dp, family)
op2dp(op, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dp2cp_+3A_dp">dp</code></td>
<td>
<p>a vector (in the univariate case) or a list (in the multivariate
case) as described in <code><a href="#topic+makeSECdistr">makeSECdistr</a></code>; see &lsquo;Background 
and Details&rsquo; for an extented form of usage.</p>
</td></tr>
<tr><td><code id="dp2cp_+3A_cp">cp</code></td>
<td>
<p>a vector or a list, in agreement with <code>dp</code> as for type and
dimension.</p>
</td></tr>
<tr><td><code id="dp2cp_+3A_op">op</code></td>
<td>
<p>a vector or a list, in agreement with <code>dp</code> as for type and
dimension.</p>
</td></tr>
<tr><td><code id="dp2cp_+3A_family">family</code></td>
<td>
<p>a characther string with the family acronym, 
as described in <code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, except that family 
<code>"ESN"</code> is not implemented.</p>
</td></tr>
<tr><td><code id="dp2cp_+3A_object">object</code></td>
<td>
<p>optionally, an S4 object of class <code>SECdistrUv</code> or
<code>SECdistrMv</code>, as produced by <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> 
(default value: <code>NULL</code>). 
If this argument is not <code>NULL</code>, then <code>family</code> and <code>dp</code> 
must not be set.</p>
</td></tr>
<tr><td><code id="dp2cp_+3A_cp.type">cp.type</code></td>
<td>
<p>character string, which has effect only if <code>family="ST"</code> 
or <code>"SC"</code>, otherwise a warning message is generated.  Possible values 
are <kbd>"proper", "pseudo", "auto"</kbd>, which correspond to the <abbr><span class="acronym">CP</span></abbr> 
parameter set, their 'pseudo-<abbr><span class="acronym">CP</span></abbr>' version and an automatic
selection based on <code>nu&gt;4</code>, where <code>nu</code> represents the degrees of
freedom of the <abbr><span class="acronym">ST</span></abbr> distribution.</p>
</td></tr>
<tr><td><code id="dp2cp_+3A_upto">upto</code></td>
<td>
<p>numeric value (in <code>1:length(dp)</code>, default=<code>NULL</code>) to 
select how many <abbr><span class="acronym">CP</span></abbr> components are computed. 
Default value <code>upto=NULL</code> is equivalent to <code>length(dp)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>dp2cp</code>, a matching vector (in the univariate case) or a list 
(in the multivariate case) of <code>cp</code> parameters. 
For <code>cp2dp</code> and <code>op2dp</code>, a similar object of <code>dp</code> parameters,
provided the set of input parameters is in the admissible region.
For <code>dp2op</code>, a similar set of <code>op</code> parameters.</p>


<h3>Background</h3>

<p>For a description of the <abbr><span class="acronym">DP</span></abbr>
parameters, see Section &lsquo;Details&rsquo; of <code><a href="#topic+makeSECdistr">makeSECdistr</a></code>.  The
<abbr><span class="acronym">CP</span></abbr> form of parameterization is cumulant-based. For a univariate
distribution, the <abbr><span class="acronym">CP</span></abbr> components are the mean value (first cumulant), 
the standard deviation (square root of the 2nd cumulant), the coefficient of 
skewness (3rd standardized cumulant) and,  for the <abbr><span class="acronym">ST</span></abbr>, 
the coefficient of excess kurtosis (4th standardized cumulant). 
For a multivariate distribution, there exists an extension based on the 
same logic; its components represent the
vector mean value, the variance matrix, the vector of marginal coefficients of
skewness and, only for the <abbr><span class="acronym">ST</span></abbr>, the Mardia's coefficient of excess
kurtosis. The pseudo-<abbr><span class="acronym">CP</span></abbr> variant provides an &lsquo;approximate form&rsquo; of
<abbr><span class="acronym">CP</span></abbr> when not all required cumulants exist; however, this parameter set
is not uniquely invertible to <abbr><span class="acronym">DP</span></abbr>. The names of pseudo-<abbr><span class="acronym">CP</span></abbr>
components printed in summary output are composed by adding a <code>~</code> 
after the usual component name; for example, the first one is denoted
<code>mean~</code>.
</p>
<p>Additional information is provided by Azzalini and Capitanio (2014).
Specifically, their Section 3.1.4 presents <abbr><span class="acronym">CP</span></abbr> in the univariate 
<abbr><span class="acronym">SN</span></abbr> case, Section 4.3.4 <abbr><span class="acronym">CP</span></abbr> for the <abbr><span class="acronym">ST</span></abbr> case and 
the 'pseudo-<abbr><span class="acronym">CP</span></abbr>' version. Section 5.2.3 presents the multivariate
extension for the <abbr><span class="acronym">SN</span></abbr> distribution, Section 6.2.5 for the 
multivariate <abbr><span class="acronym">ST</span></abbr> case. 
For a more detailed discussion, see Arellano-Valle &amp; Azzalini (2013).
</p>
<p>The <abbr><span class="acronym">OP</span></abbr> parameterization is very similar to <abbr><span class="acronym">DP</span></abbr>, from which 
it differs only for the components which regulate dispersion (or scatter) 
and slant.  Its relevance lies essentially in the multivariate case, where 
the components of the slant parameter can be interpreted component-wise and
remain unaffected if marginalization with respect to some other components 
is performed. 
In the multivariate <abbr><span class="acronym">SN</span></abbr> case, the components of <abbr><span class="acronym">OP</span></abbr>, denoted
<code class="reqn">\xi, \Psi, \lambda</code>, are associated to the expression of the density
function (5.30) of Azzalini &amp; Capitanio (2014); see pp.128&ndash;131 for more
information. In the univariate case, the slant component of <abbr><span class="acronym">DP</span></abbr>
and the one of <abbr><span class="acronym">OP</span></abbr> coincide, that is, <code class="reqn">\alpha=\lambda</code>,
Parameter <code class="reqn">\xi</code> and other parameters which may exist with other families 
remain the same of the <abbr><span class="acronym">DP</span></abbr> set. The term <abbr><span class="acronym">OP</span></abbr> stands for
&lsquo;original parameterization&rsquo; since this is, up to a negligible difference, 
the parameterization adopted by Azzalini &amp; Dalla Valle (1996).
</p>


<h3>Details</h3>

<p>While any choice of the components of <abbr><span class="acronym">DP</span></abbr> or <abbr><span class="acronym">OP</span></abbr> is
admissible, this is not true for <abbr><span class="acronym">CP</span></abbr>. An implication is that a
call to <code>cp2dp</code> may fail with an error message <code>"non-admissible CP"</code>
for certain input values. The most extreme case is represented by the
<abbr><span class="acronym">SC</span></abbr> family, for which  <abbr><span class="acronym">CP</span></abbr> never exists; hence it makes
to sense to call <code>cp2dp</code> with <code>family="SC"</code>.
</p>
<p>It is possible to call the functions with <code>dp</code> or <code>cp</code> having more
components than those expected for a given family as described above and in
<code><a href="#topic+makeSECdistr">makeSECdistr</a></code>. In the univariate case, this means that <code>dp</code>
or <code>cp</code> can be vectors of longer length than indicated earlier. This
occurrence is interpreted in the sense that the additional components after
the first one are regarded as regression coefficients of a <code>selm</code> model,
and they are transferred unchanged to the matching components of the
transformed parameter set; the motivation is given in Section 3.1.4 of
Azzalini and Capitanio (2014). In the multivariate case, <code>dp[[1]]</code> and
<code>cp[[1]]</code> can be matrices instead of vectors; the rows beyond the first
one are transferred unchanged to <code>cp[[1]]</code> and <code>dp[[1]]</code>,
respectively. 
</p>


<h3>References</h3>

<p>Arellano-Valle, R. B. and Azzalini, A. (2013, available on-line 12 June 2011). 
The centred parameterization and related quantities of the skew-<em>t</em> 
distribution. <em>J. Multiv. Analysis</em> <b>113</b>, 73-90. 
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related  Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Azzalini, A. and Dalla Valle, A. (1996).
The multivariate skew-normal distribution.
<em>Biometrika</em> <b>83</b>, 715&ndash;726.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, <code><a href="#topic+summary.SECdistr">summary.SECdistr</a></code>, 
<code><a href="#topic+sn.cumulants">sn.cumulants</a></code>, 
</p>
<p>the &lsquo;Note&rsquo; at <code><a href="#topic+summary.selm">summary.selm</a></code> for the reason why
<abbr><span class="acronym">CP</span></abbr> is the default parameterization in that function and in 
related ones,
</p>
<p>the &lsquo;Examples&rsquo; at <code><a href="#topic+rmsn">rmsn</a></code> for use of the <abbr><span class="acronym">CP</span></abbr>
parameterization
</p>


<h3>Examples</h3>

<pre><code class='language-R'># univariate case
cp &lt;- dp2cp(c(1, 2222, 3333, 2, 3), "SN")
dp &lt;- cp2dp(cp, "SN")
# notice that the 2nd and the 3rd component remain unchanged
#
# multivariate case
dp3 &lt;- list(xi=1:3, Omega=toeplitz(1/(1:3)), alpha=c(-3, 8, 5), nu=6)
cp3 &lt;- dp2cp(dp3, "ST")
dp3.back &lt;- cp2dp(cp3, "ST")
#
op3 &lt;- dp2op(dp3, "ST")
dp3back &lt;- op2dp(op3,"ST")
</code></pre>

<hr>
<h2 id='dsc'>Skew-Cauchy Distribution</h2><span id='topic+dsc'></span><span id='topic+psc'></span><span id='topic+qsc'></span><span id='topic+rsc'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and random
number generation for the skew-Cauchy (SC) distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsc(x, xi = 0, omega = 1, alpha = 0, dp = NULL, log = FALSE)
psc(x, xi = 0, omega = 1, alpha = 0, dp = NULL)
qsc(p, xi = 0, omega = 1, alpha = 0, dp = NULL) 
rsc(n = 1, xi = 0, omega = 1, alpha = 0, dp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsc_+3A_x">x</code></td>
<td>
<p>vector of quantiles. Missing values (<code>NA</code>s) and <code>Inf</code>'s
are allowed.</p>
</td></tr>
<tr><td><code id="dsc_+3A_p">p</code></td>
<td>
<p>vector of probabilities. Missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr><td><code id="dsc_+3A_xi">xi</code></td>
<td>
<p> vector of location parameters.</p>
</td></tr>
<tr><td><code id="dsc_+3A_omega">omega</code></td>
<td>
<p>vector of (positive) scale parameters.</p>
</td></tr>
<tr><td><code id="dsc_+3A_alpha">alpha</code></td>
<td>
<p>vector of slant parameters.</p>
</td></tr>
<tr><td><code id="dsc_+3A_dp">dp</code></td>
<td>
<p>a vector of length 3 whose elements represent the parameters 
described above. If <code>dp</code> is specified, the individual parameters 
cannot be set.</p>
</td></tr>
<tr><td><code id="dsc_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="dsc_+3A_log">log</code></td>
<td>
<p>logical flag used in <code>dsc</code> (default <code>FALSE</code>).
When <code>TRUE</code>, the logarithm of the density values is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density (<code>dsc</code>), probability (<code>psc</code>), quantile (<code>qsc</code>)
or random sample (<code>rsc</code>) from the skew-Cauchy distribution with given
<code>xi</code>, <code>omega</code> and <code>alpha</code> parameters or from the extended
skew-normal if <code>tau!=0</code> </p>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
dsc(x, xi=0, omega=1, alpha=0, log=FALSE)
dsc(x, dp=, log=FALSE)
psc(x, xi=0, omega=1, alpha=0)
psc(x, dp= )
qsc(p, xi=0, omega=1, alpha=0)
qsc(x, dp=)
rsc(n=1, xi=0, omega=1, alpha=0)
rsc(x, dp=)
</pre>


<h3>Background</h3>

<p>The skew-Cauchy distribution can be thought as a skew-<code class="reqn">t</code> with tail-weight
parameter <code>nu=1</code>. In this case, closed-form expressions of the 
distribution function and the quantile function have been obtained by
Behboodian <em>et al.</em> (2006).
The key facts are summarized in Complement 4.2 of Azzalini and Capitanio (2014).
A multivariate version of the distribution exists.
</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Behboodian, J., Jamalizadeh, A., and Balakrishnan, N. (2006).
A new class of skew-Cauchy distributions.
<em>Statist. Probab. Lett.</em> <b>76</b>, 1488&ndash;1493.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dst">dst</a></code>,  <code><a href="#topic+dmsc">dmsc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dsc(seq(-5,5,by=0.1), alpha=3)
cdf &lt;- psc(seq(-5,5,by=0.1), alpha=3)
q &lt;- qsc(seq(0.1,0.9,by=0.1), alpha=-2)
p &lt;- psc(q, alpha=-2)  
rn &lt;- rsc(100, 5, 2, 5)
</code></pre>

<hr>
<h2 id='dsn'>Skew-Normal Distribution</h2><span id='topic+dsn'></span><span id='topic+psn'></span><span id='topic+qsn'></span><span id='topic+rsn'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and random
number generation for the skew-normal (<abbr><span class="acronym">SN</span></abbr>) and the extended 
skew-normal (<abbr><span class="acronym">ESN</span></abbr>) distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsn(x, xi=0, omega=1, alpha=0, tau=0, dp=NULL, log=FALSE)
psn(x, xi=0, omega=1, alpha=0, tau=0, dp=NULL, engine, ...)
qsn(p, xi=0, omega=1, alpha=0, tau=0, dp=NULL, tol=1e-8, solver="NR", ...) 
rsn(n=1, xi=0, omega=1, alpha=0, tau=0,  dp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsn_+3A_x">x</code></td>
<td>
<p>vector of quantiles. Missing values (<code>NA</code>'s) and <code>Inf</code>'s
are allowed.</p>
</td></tr>
<tr><td><code id="dsn_+3A_p">p</code></td>
<td>
<p>vector of probabilities. Missing values (<code>NA</code>'s) are allowed</p>
</td></tr>
<tr><td><code id="dsn_+3A_xi">xi</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="dsn_+3A_omega">omega</code></td>
<td>
<p>vector of  scale parameters;  must be positive.</p>
</td></tr>
<tr><td><code id="dsn_+3A_alpha">alpha</code></td>
<td>
<p>vector of slant parameter(s); <code>+/- Inf</code> is allowed.
For <code>psn</code>, it must be of length 1 if <code>engine="T.Owen"</code>. 
For <code>qsn</code>, it must be of length 1.</p>
</td></tr>
<tr><td><code id="dsn_+3A_tau">tau</code></td>
<td>
<p>a single value representing the &lsquo;hidden mean&rsquo; parameter 
of the <abbr><span class="acronym">ESN</span></abbr> distribution; <code>tau=0</code> (default) corresponds to 
a <abbr><span class="acronym">SN</span></abbr> distribution.</p>
</td></tr>
<tr><td><code id="dsn_+3A_dp">dp</code></td>
<td>
<p>a vector of length 3 (in the <abbr><span class="acronym">SN</span></abbr> case) or 
4 (in the <abbr><span class="acronym">ESN</span></abbr> case), whose components represent 
the individual parameters described above. If <code>dp</code>
is specified, the individual parameters cannot be set.</p>
</td></tr>
<tr><td><code id="dsn_+3A_n">n</code></td>
<td>
<p>a positive integer representing the sample size.</p>
</td></tr>
<tr><td><code id="dsn_+3A_tol">tol</code></td>
<td>
<p>a scalar value which regulates the accuracy of the result of 
<code>qsn</code>, measured on the probability scale.</p>
</td></tr>
<tr><td><code id="dsn_+3A_log">log</code></td>
<td>
<p>logical flag used in <code>dsn</code> (default <code>FALSE</code>).
When <code>TRUE</code>, the logarithm of the density values is returned.</p>
</td></tr>
<tr><td><code id="dsn_+3A_engine">engine</code></td>
<td>
<p>a character string  which selects the computing engine;
this is either <code>"T.Owen"</code> or <code>"biv.nt.prob"</code>, the latter from 
package <code>mnormt</code>. If <code>tau != 0</code> or <code>length(alpha)&gt;1</code>, 
<code>"biv.nt.prob"</code> must be used. If this argument is missing, a default 
selection rule is applied.</p>
</td></tr>
<tr><td><code id="dsn_+3A_solver">solver</code></td>
<td>
<p>a character string which selects the numerical method used for 
solving the quantile equation; possible options are <code>"NR"</code> (default)
and <code>"RFB"</code>, described in the &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="dsn_+3A_...">...</code></td>
<td>
<p> additional parameters passed to <code>T.Owen</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>density (<code>dsn</code>), probability (<code>psn</code>), quantile (<code>qsn</code>)
or random sample (<code>rsn</code>) from the skew-normal distribution with given
<code>xi</code>, <code>omega</code> and <code>alpha</code> parameters or from the extended
skew-normal if <code>tau!=0</code> </p>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
dsn(x, xi=0, omega=1, alpha=0, log=FALSE)
dsn(x, dp=, log=FALSE)
psn(x, xi=0, omega=1, alpha=0,  ...)
psn(x, dp=,  ...)
qsn(p, xi=0, omega=1, alpha=0, tol=1e-8, ...)
qsn(x, dp=, ...)
rsn(n=1, xi=0, omega=1, alpha=0)
rsn(x, dp=)
</pre>
<p><code>psn</code> and <code>qsn</code> make use  of function <code><a href="#topic+T.Owen">T.Owen</a></code>
or <code><a href="mnormt.html#topic+dmt">biv.nt.prob</a></code>
</p>
<p>In <code>qsn</code>, the choice <code>solver="NR"</code> selects the Newton-Raphson method 
for solving the quantile equation, while option <code>solver="RFB"</code>
alternates a step of <em>regula falsi</em> with one of bisection. 
The <code>"NR"</code> method is generally more efficient, but <code>"RFB"</code> is 
occasionally required in some problematic cases.
</p>
<p>In version 1.6-2, the random number generation method for <code>rsn</code> has
changed;  the so-called transformation method  (also referred to as the
&lsquo;additive representation&rsquo;) has been adopted for all values of <code>tau</code>.
Also, the code has been modified so that there is this form of consistency:
provided <code>set.seed()</code> is reset similarly before calls, code like
<code>rsn(5, dp=1:3)</code> and <code>rsn(10, dp=1:3)</code>, for instance, will start with 
the same initial values in the longer sequence as in the shorter sequence.
</p>


<h3>Background</h3>

<p>The family of skew-normal distributions is an extension of the normal
family, via the introdution of a <code>alpha</code> parameter which regulates
asymmetry; when <code>alpha=0</code>, the skew-normal distribution reduces to 
the normal one.  The density function of the <abbr><span class="acronym">SN</span></abbr> distribution 
in the &lsquo;normalized&rsquo;  case having <code>xi=0</code> and <code>omega=1</code> is 
<code class="reqn">2\phi(x)\Phi(\alpha x)</code>, if <code class="reqn">\phi</code> and <code class="reqn">\Phi</code> denote the
standard normal density and distribution function.
An early discussion of the skew-normal distribution is given by 
Azzalini (1985); see Section 3.3 for the <abbr><span class="acronym">ESN</span></abbr> variant, 
up to a slight difference in the parameterization.
</p>
<p>An updated exposition is provided in Chapter 2 of Azzalini and 
Capitanio (2014); the <abbr><span class="acronym">ESN</span></abbr> variant is presented Section 2.2. 
See Section 2.3 for an historical account.   
A multivariate version of the distribution is examined in Chapter 5.</p>


<h3>References</h3>

<p>Azzalini, A. (1985).
A class of distributions which includes the normal ones.
<em>Scand. J. Statist.</em> <b>12</b>, 171-178.
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p>Functions used by <code>psn</code>:
<code><a href="#topic+T.Owen">T.Owen</a></code>, <code><a href="mnormt.html#topic+dmt">biv.nt.prob</a></code>
</p>
<p>Related distributions: <code><a href="#topic+dmsn">dmsn</a></code>, <code><a href="#topic+dst">dst</a></code>, 
<code><a href="#topic+dmst">dmst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dsn(seq(-3, 3, by=0.1), alpha=3)
cdf &lt;- psn(seq(-3, 3, by=0.1), alpha=3)
q &lt;- qsn(seq(0.1, 0.9, by=0.1), alpha=-2)
r &lt;- rsn(100, 5, 2, 5)
qsn(1/10^(1:4), 0, 1, 5, 3, solver="RFB")  
</code></pre>

<hr>
<h2 id='dst'>Skew-<code class="reqn">t</code> Distribution</h2><span id='topic+dst'></span><span id='topic+pst'></span><span id='topic+qst'></span><span id='topic+rst'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantiles and 
random number generation for the skew-<code class="reqn">t</code> (<abbr><span class="acronym">ST</span></abbr>) distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dst(x, xi=0, omega=1, alpha=0, nu=Inf, dp=NULL, log=FALSE) 
pst(x, xi=0, omega=1, alpha=0, nu=Inf, dp=NULL, method=0, lower.tail=TRUE, 
    log.p=FALSE, ...)
qst(p, xi=0, omega=1, alpha=0, nu=Inf, tol=1e-08, dp=NULL, method=0, ...)
rst(n=1, xi=0, omega=1, alpha=0, nu=Inf, dp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dst_+3A_x">x</code></td>
<td>
<p>vector of quantiles. Missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr><td><code id="dst_+3A_p">p</code></td>
<td>
<p>vector of probabililities.</p>
</td></tr>
<tr><td><code id="dst_+3A_xi">xi</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="dst_+3A_omega">omega</code></td>
<td>
<p>vector of scale parameters; must be positive.</p>
</td></tr>
<tr><td><code id="dst_+3A_alpha">alpha</code></td>
<td>
<p>vector of slant parameters. With <code>pst</code> and <code>qst</code>, 
it must be of length 1.</p>
</td></tr>
<tr><td><code id="dst_+3A_nu">nu</code></td>
<td>
<p>a single positive value representing the degrees of freedom;
it can be non-integer. Default value is <code>nu=Inf</code> which corresponds 
to the skew-normal distribution.
</p>
</td></tr>
<tr><td><code id="dst_+3A_dp">dp</code></td>
<td>
<p>a vector of length 4, whose elements represent location, scale
(positive), slant and degrees of freedom, respectively.  If <code>dp</code> is
specified, the individual parameters cannot be set.</p>
</td></tr>
<tr><td><code id="dst_+3A_n">n</code></td>
<td>
<p>a positive integer representing the sample size.</p>
</td></tr>
<tr><td><code id="dst_+3A_log">log</code>, <code id="dst_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities  are given as log-densities
and probabilities <code>p</code> are given as <code>log(p)</code></p>
</td></tr>
<tr><td><code id="dst_+3A_tol">tol</code></td>
<td>

<p>a scalar value which regulates the accuracy of the result of
<code>qsn</code>, measured on the probability scale.
</p>
</td></tr>
<tr><td><code id="dst_+3A_method">method</code></td>
<td>
<p>an integer value between <code>0</code> and <code>5</code> which selects 
the computing method; see &lsquo;Details&rsquo; below for the meaning of these
values. If <code>method=0</code> (default value), an automatic choice is made
among the four actual computing methods, depending on the other
arguments.</p>
</td></tr>
<tr><td><code id="dst_+3A_lower.tail">lower.tail</code></td>
<td>

<p>logical; if <code>TRUE</code> (default), probabilities are <code class="reqn">P\{X\le x\}</code>,
otherwise  <code class="reqn">P\{X\ge x\}</code>
</p>
</td></tr>
<tr><td><code id="dst_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>integrate</code> or <code>pmst</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density (<code>dst</code>), probability (<code>pst</code>), quantiles (<code>qst</code>) 
and random sample (<code>rst</code>) from the skew-<code class="reqn">t</code> distribution with given 
<code>xi</code>, <code>omega</code>, <code>alpha</code> and <code>nu</code> parameters.</p>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
dst(x, xi=0, omega=1, alpha=0, nu=Inf, log=FALSE)
dst(x, dp=, log=FALSE)
pst(x, xi=0, omega=1, alpha=0, nu=Inf, method=0, ...)
pst(x, dp=, log=FALSE)
qst(p, xi=0, omega=1, alpha=0, nu=Inf, tol=1e-8,  method=0, ...)
qst(x, dp=, log=FALSE)
rst(n=1, xi=0, omega=1, alpha=0, nu=Inf)
rst(x, dp=, log=FALSE)
</pre>


<h3>Background</h3>

<p>The family of skew-<code class="reqn">t</code> distributions is an extension of the Student's
<code class="reqn">t</code> family, via the introduction of a <code>alpha</code> parameter which 
regulates skewness; when <code>alpha=0</code>, the skew-<code class="reqn">t</code> distribution 
reduces to the usual Student's <code class="reqn">t</code> distribution. 
When <code>nu=Inf</code>, it reduces to the skew-normal distribution. 
When <code>nu=1</code>, it reduces to a form of skew-Cauchy distribution.
See Chapter 4 of Azzalini &amp; Capitanio (2014) for additional information. 
A multivariate version of the distribution exists; see <code>dmst</code>.
</p>


<h3>Details</h3>

<p>For evaluation of <code>pst</code>, and so indirectly of
<code>qst</code>, four different methods are employed.
In all the cases, the actual computations are performed for the normalized 
values <code>z=(x-xi)/omega</code>).
Method 1 consists in using <code>pmst</code> with dimension <code>d=1</code>.
Method 2 applies <code>integrate</code> to the density function <code>dst</code>.
Method 3 again uses <code>integrate</code> too but with a different integrand,
as given in Section 4.2 of Azzalini &amp; Capitanio (2003, full version of
the paper).
Method 4 consists in the recursive procedure of Jamalizadeh, Khosravi and
Balakrishnan (2009), which is recalled in Complement 4.3 on 
Azzalini &amp; Capitanio (2014); the recursion over <code>nu</code> starts from 
the explicit expression for <code>nu=1</code> given by <code>psc</code>.
Method 5 is targeted to tail probabilities only, and it returns <code>NA</code>s
for non-extreme <code>x</code> values (those with <code>abs(z)&lt;=20</code>); 
it is based on expressions given in Complement 4.4 of Azzalini and Capitanio (2014).
Method 1 and 4 are only suitable for integer values of <code>nu</code>.
Method 4 becomes progressively less efficient as <code>nu</code> increases,
because the value of <code>nu</code> determines the number of nested calls, 
but the decay of efficiency is slower for larger values of <code>length(x)</code>.
If the default argument value <code>method=0</code> is retained, an automatic choice
among the above four methods is made, which depends on the values of 
<code>nu, alpha, z</code>. The numerical accuracy of methods 1, 2 and 3 can 
be regulated via the <code>...</code> argument, while method 4 is conceptually exact, 
up to machine precision.
</p>
<p>If <code>qst</code> is called with <code>nu&gt;1e4</code>, the computation is transferred to
<code>qsn</code>. 
</p>


<h3>References</h3>

<p>Azzalini, A. and Capitanio, A. (2003).
Distributions generated by perturbation of symmetry 
with emphasis on a multivariate skew-<em>t</em> distribution.
<em>J.Roy. Statist. Soc. B</em> <b>65</b>, 367&ndash;389.
Full version of the paper at <a href="https://arXiv.org/abs/0911.2342">https://arXiv.org/abs/0911.2342</a>.
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series. 
</p>
<p>Jamalizadeh, A., Khosravi, M., and Balakrishnan, N. (2009).
Recurrence relations for distributions of a skew-<em>t</em> and a linear
combination of order statistics from a bivariate-<em>t</em>.
<em>Comp. Statist. Data An.</em> <b>53</b>, 847&ndash;852.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmst">dmst</a></code>, <code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dsc">dsc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dst(seq(-4, 4, by=0.1), alpha=3, nu=5)
rnd &lt;- rst(100, 5, 2, -5, 8)
q &lt;- qst(c(0.25, 0.50, 0.75), alpha=3, nu=5)
pst(q, alpha=3, nu=5)  # must give back c(0.25, 0.50, 0.75)
#
p1 &lt;- pst(x=seq(-3,3, by=1), dp=c(0,1,pi, 3.5))
p2 &lt;- pst(x=seq(-3,3, by=1), dp=c(0,1,pi, 3.5), method=2, rel.tol=1e-9)
</code></pre>

<hr>
<h2 id='extractSECdistr'>Extract the SEC error distribution from an object created by <code>selm</code></h2><span id='topic+extractSECdistr'></span>

<h3>Description</h3>

<p>Given an object created by a call to <code>selm</code>, the function delivers
the <abbr><span class="acronym">SEC</span></abbr> distribution representing the stochastic term of the 
fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  extractSECdistr(object, name, compNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractSECdistr_+3A_object">object</code></td>
<td>
<p>an object of class <code>selm</code> or <code>mselm</code>, 
as created by <code><a href="#topic+selm">selm</a></code>.</p>
</td></tr>
<tr><td><code id="extractSECdistr_+3A_name">name</code></td>
<td>
<p>an optional character string representing the name of the 
outcome distribution; if missing, a string is constructed from the
<code>object</code> ingredients.</p>
</td></tr>
<tr><td><code id="extractSECdistr_+3A_compnames">compNames</code></td>
<td>
<p>in the multivariate case, an optional vector  of character 
strings  with the names of the components of the error distribution; 
if missing, one such vector is constructed from the <code>object</code>
ingredients.</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>An object of class <code>SECdistrMv</code> or <code>SECdistrUv</code>, 
depending of the class of <code>object</code>.</p>


<h3>Details</h3>

<p>When the formula of the fitted model includes only the constant <code>1</code>,
the returned object represents the fitted <abbr><span class="acronym">SEC</span></abbr> distribution.
If the formula includes additional terms, the linear predictor is eliminated
and the returned object corresponds to the error term of the model; 
hence the location parameter <code>xi</code> in the <abbr><span class="acronym">DP</span></abbr> parameterization
is set to zero.
</p>
<p>The returned object can be submitted to tools
available for objects created by <code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, 
such as <code><a href="#topic+summary.SECdistr">summary.SECdistr</a></code>, <code><a href="#topic+conditionalSECdistr">conditionalSECdistr</a></code> and
and so on.</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code>, <code><a href="#topic+makeSECdistr">makeSECdistr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
m2 &lt;- selm(log(Fe) ~ 1, family="ST", data=ais, fixed=list(nu=8))
f2 &lt;- extractSECdistr(m2)
show(f2)
#
m4 &lt;- selm(cbind(BMI, LBM) ~ 1, family="SN", data=ais)
f4 &lt;- extractSECdistr(m4)
mean(f4)
vcov(f4)
</code></pre>

<hr>
<h2 id='fitdistr.grouped'>
Maximum-likelihood fitting of a univariate distribution from grouped data
</h2><span id='topic+fitdistr.grouped'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting of a univariate distribution when the data are
represented by a set of frequencies pertaining to given set of contiguous 
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitdistr.grouped(breaks, counts, family, weights, trace = FALSE, wpar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitdistr.grouped_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of strictly increasing values which identify 
a set of contiguous intervals on the real line.
See &lsquo;Details&rsquo; for additional information.</p>
</td></tr>
<tr><td><code id="fitdistr.grouped_+3A_counts">counts</code></td>
<td>
<p>A vector of non-negative integers representing the number 
of observations falling in the intervals specified by <code>breaks</code>;
it is then required that <code>length(counts)+1=length(breaks)</code>. </p>
</td></tr>
<tr><td><code id="fitdistr.grouped_+3A_family">family</code></td>
<td>
<p>A character string specifying the parametric family of 
distributions to be used for fitted. 
Admissible names are: <code>"normal"</code>, <code>"logistic"</code>, <code>"t"</code>, 
<code>"Cauchy"</code>, <code>"SN"</code>, <code>"ST"</code>, <code>"SC"</code>, <code>"gamma"</code>, 
<code>"Weibull"</code>;
the names <code>"gaussian"</code> and <code>"Gaussian"</code> are also allowed, 
and are converted to <code>"normal"</code>.</p>
</td></tr>
<tr><td><code id="fitdistr.grouped_+3A_weights">weights</code></td>
<td>
<p>An alias for <code>counts</code>, allowed for analogy with the 
<code>selm</code> function.</p>
</td></tr>
<tr><td><code id="fitdistr.grouped_+3A_trace">trace</code></td>
<td>
<p>A logical value which indicates whether intermediate evaluations 
of the optimization process are printed (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fitdistr.grouped_+3A_wpar">wpar</code></td>
<td>

<p>An optional vector with initial values of the &lsquo;working parameters&rsquo;
for starting the maximization of the log-likelihood function; 
see &lsquo;Details&rsquo; for their description. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original motivation of this function was fitting a univariate <abbr><span class="acronym">SN</span></abbr>, 
<abbr><span class="acronym">ST</span></abbr> or <abbr><span class="acronym">SC</span></abbr> distribution from grouped data;
its scope was later extended to include some other continuous distributions. 
The adopted name of the function reflects the broad similarity of its purpose 
with the one of <code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>, but there are substantial 
differences in the actual working of the two functions.
</p>
<p>The parameter set of a given <code>family</code> is the same as appearing in the
corresponding <code>d&lt;basename&gt;</code> function, with the exception of the <code>"t"</code> 
distribution, for which a location and a scale parameter are included, 
besides <code>df</code>.
</p>
<p>The range of <code>breaks</code> does not need to span the whole support of the
chosen <code>family</code> of distributions, that is, 
<code>(0, Inf)</code> for <code>"Weibull"</code> and <code>"gamma"</code> families,
<code>(-Inf, Inf)</code> for the other families.
In fact, for the purpose of post-fitting plotting, an infinite 
<code>range(breaks)</code> represents a complication, requiring an <em>ad hoc</em> 
handling;  so it is sensible to avoid it.
However, at the maximum-likelihood fitting stage, the full support of
the  probability distribution is considered, with the following implications. 
If <code>max(breaks)=xR</code>, say, and <code>xR&lt;Inf</code>,  then an additional 
interval <code>(xR, Inf)</code> is introduced, with value <code>counts=0</code> assigned.
A similar action is taken at the lower end: if <code>min(breaks)=xL</code> is
larger than the infimum of the support of the distribution,
an extra  0-<code>counts</code> interval is introduced as <code>(0, xL)</code> 
or <code>(-Inf, xL)</code>, depending on the support of the <code>family</code>.
</p>
<p>Maximum likelihood fitting is obtained by maximizing the pertaining 
multinomial log-likelihood using the <code><a href="stats.html#topic+optim">optim</a></code> function 
with  <code>method="Nelder-Mead"</code>. For numerical convenience, the numerical 
search is performed using &lsquo;working parameters&rsquo; in place of the original
ones, with reverse conversion at the end. The working parameters coincide
with the original distribution parameters when they have unbounded range,
while they are log-transformed in case of intrinsically positive parameters.
This transformation applies to the parameters of the positive-valued
distributions (&quot;gamma&quot; and &quot;Weibull&quot;), all scale parameters and <code>df</code>
of the <code>"t"</code> distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>fitdistr.grouped</code>, whose components are described in 
<code><a href="#topic+fitdistr.grouped-class">fitdistr.grouped-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini </p>


<h3>See Also</h3>

<p>For methods pertaining to this class of objects, see
<code><a href="#topic+fitdistr.grouped-class">fitdistr.grouped-class</a></code> and
<code><a href="#topic+plot.fitdistr.grouped">plot.fitdistr.grouped</a></code>; see also 
<code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dst">dst</a></code>, <code><a href="#topic+dsc">dsc</a></code>,
<code><a href="stats.html#topic+Distributions">Distributions</a></code>, <code><a href="stats.html#topic+dmultinom">dmultinom</a></code>;
see also <code><a href="#topic+selm">selm</a></code> for ungrouped data fitting and an example
elaborated on below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barolo)
attach(barolo)
A75 &lt;- (reseller=="A" &amp; volume==75)
logPrice &lt;- log(price[A75], 10) # used in documentation of 'selm'; see its fitting
detach(barolo)
breaks&lt;- seq(1, 3, by=0.25)
f &lt;- cut(logPrice, breaks = breaks)
counts &lt;- tabulate(f, length(levels(f))) 
logPrice.grouped &lt;- fitdistr.grouped(breaks, counts, family='ST')
summary(logPrice.grouped) # compare this fit with the ungrouped data fitting 
</code></pre>

<hr>
<h2 id='fitdistr.grouped-class'>Methods for objects of class created by <code>fitdistr.grouped</code></h2><span id='topic+fitdistr.grouped-class'></span><span id='topic+logLik.fitdistr.grouped'></span><span id='topic+coef.fitdistr.grouped'></span><span id='topic+vcov.fitdistr.grouped'></span><span id='topic+print.fitdistr.grouped'></span><span id='topic+summary.fitdistr.grouped'></span><span id='topic+fitted.fitdistr.grouped'></span>

<h3>Description</h3>

<p>A successful call to function <code>fitdistr.grouped</code> creates 
an object of class, also named <code>fitdistr.grouped</code>, for which a set 
of methods exist.
The structure of an object of this class is described in section 
&lsquo;Object components&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fitdistr.grouped'
logLik(object, ...)
  ## S3 method for class 'fitdistr.grouped'
coef(object, ...)
  ## S3 method for class 'fitdistr.grouped'
vcov(object, ...)
  ## S3 method for class 'fitdistr.grouped'
print(x, ...)
  ## S3 method for class 'fitdistr.grouped'
summary(object, cor=FALSE, ...)
  ## S3 method for class 'fitdistr.grouped'
fitted(object, full=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitdistr.grouped-class_+3A_x">x</code>, <code id="fitdistr.grouped-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>fitdistr.grouped</code> as created 
by a call to the function with this name.</p>
</td></tr>
<tr><td><code id="fitdistr.grouped-class_+3A_cor">cor</code></td>
<td>
<p>logical (default=<code>FALSE</code>); is the correlation matrix required?</p>
</td></tr>   
<tr><td><code id="fitdistr.grouped-class_+3A_full">full</code></td>
<td>
<p>logical (default=<code>FALSE</code>); must the vector of fitted 
frequencies include the boundary classes, when they are added to 
cover the full support of the fitted distribution?</p>
</td></tr>
<tr><td><code id="fitdistr.grouped-class_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>     
</table>


<h3>Object components</h3>

<p>Components of an object of class <code>fitdistr.grouped</code>:
</p>

<dl>
<dt><code>call</code></dt><dd><p>the matched call</p>
</dd>
<dt><code>family</code></dt><dd><p>the selected <code>family</code> of distributions</p>
</dd>
<dt><code>logL</code></dt><dd><p>the achieved maximum log-likelihood</p>
</dd>
<dt><code>param</code></dt><dd><p>a vector of estimated parameters</p>
</dd>
<dt><code>vcov</code></dt><dd><p>the approximate variance-covariance matrix of the estimates</p>
</dd>
<dt><code>input</code></dt><dd><p>a list with the input quantities and some derived ones</p>
</dd>
<dt><code>opt</code></dt><dd><p>a list as returned by <code>optim</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Possolo, A., Merkatas, C. and Bodnar, O. (2019).
Asymmetrical uncertainties.
<em>Metrologia</em> 56, 045009.
</p>


<h3>See Also</h3>

<p>the function <code><a href="#topic+fitdistr.grouped">fitdistr.grouped</a></code>, 
the plotting method <code><a href="#topic+plot.fitdistr.grouped">plot.fitdistr.grouped</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barolo)
attach(barolo)
A75 &lt;- (reseller=="A" &amp; volume==75)
logPrice &lt;- log(price[A75], 10) # as used in selm documentation; see its fitting
detach(barolo)
breaks &lt;- seq(1, 3, by=0.25)
f &lt;- cut(logPrice, breaks = breaks)
counts &lt;- tabulate(f, length(levels(f))) 
fit.logPrice.gr &lt;- fitdistr.grouped(breaks, counts, family='ST')
summary(fit.logPrice.gr) # compare this fit with the ungrouped data fitting 
print(fit.logPrice.gr)
coef(fit.logPrice.gr)
vcov(fit.logPrice.gr)
data.frame(intervals=levels(f), counts, fitted=format(fitted(fit.logPrice.gr)))
full.intervals &lt;- c("(-Inf, 1]", levels(f), "(3, Inf)")
data.frame("full-range intervals" = full.intervals,
       "full-range counts" = c(0, counts, 0), 
      "full-range fit" = fitted(fit.logPrice.gr, full=TRUE))
sum(counts) - sum(fitted(fit.logPrice.gr))  
sum(counts) - sum(fitted(fit.logPrice.gr, full=TRUE))  # must be "nearly 0" 
#---
# Use first entry in Table 3 of Possolo et al. (2019) and do similar fitting
# to the *probability* values, not observation counts
afcrc59 &lt;- 1.141
breaks &lt;- c(-Inf, afcrc59 - 0.033, afcrc59, afcrc59 + 0.037, Inf)
prob &lt;-  c(0.16, 0.50, 0.84) 
cum.percent &lt;- c(0, prob, 1)*100 
fitSN &lt;- fitdistr.grouped(breaks, counts=diff(cum.percent), family="SN") 
print(coef(fitSN))
print(rbind(target=c(prob, 1)*100, fitted=cumsum(fitted(fitSN))), digits=5)
# Note: given the nature of these data (i.e. probabilities, not counts), 
#       there is no point to use vcov, logLik and summary on the fitted object.
</code></pre>

<hr>
<h2 id='fournum'>Four-number summary of a numeric vector</h2><span id='topic+fournum'></span>

<h3>Description</h3>

<p>Returns a quantile-based four-number summary of the input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fournum(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fournum_+3A_x">x</code></td>
<td>
<p>a numeric vector,  maybe including <code>NA</code>s and <code>+/-Inf</code>'s.
At least 8 not-<code>NA</code> values are required.
It works with objects which can be coerced to vector.</p>
</td></tr>
<tr><td><code id="fournum_+3A_na.rm">na.rm</code></td>
<td>
<p>	 logical; 
if <code>TRUE</code>, all <code>NA</code> and <code>NaN</code>s are dropped, 
before the statistics are computed.</p>
</td></tr>
<tr><td><code id="fournum_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>quantile</code> is used to compute 7 octiles of <code>x</code>, 
that is, quantiles of level <code>(1:7)/8</code>, denoted <code>oct[1:7]</code>, 
and derive four summary quantities: 
</p>

<ol>
<li><p> the median, which corresponds to <code>oct[4]</code>, 
</p>
</li>
<li><p> the &lsquo;(coefficient of) quartile deviation&rsquo; 
or semi-interquantile range: <code>(oct[6] - oct[2])/2</code>;
</p>
</li>
<li><p> the Galton-Bowley measure of asymmetry, that is, skewness:
<code>(oct[6] - 2 * oct[4] + oct[2])/(oct[6] - oct[2])</code>;
</p>
</li>
<li><p> the Moors measure of kurtosis: 
<code>(oct[7] - oct[5] + oct[3] - oct[1])/(oct[6] - oct[2])</code>
</p>
</li></ol>

<p>The term &lsquo;coefficient of quartile deviation&rsquo; is adopted from the
Encyclopedia of Statistical Sciences; see the references below.
What is called Galton-Bowley measure here is often named 
&lsquo;Bowley's measure&rsquo;, but some sources attribute it to Francis Galton. 
For the Moors measure, see Moors (1988).
</p>


<h3>Value</h3>

<p>a vector of length four containing the median, the quartile deviation, 
the Galton-Bowley measure and the Moors measure. However,
if <code>x</code> does not contain at least 8 values (after removing <code>NA</code>s),
<code>rep(NA,4)</code> is returned.</p>


<h3>Note</h3>

<p>Computation of octiles makes real sense only if <code>length(x)</code> is
substantially larger than 8. </p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>&lsquo;Quartile deviation, coefficient of&rsquo;, in:
<em>Encyclopedia of Statistical Sciences</em>, 2nd edition (2006). 
Editors: Samuel Kotz (Editor-in-Chief), Campbell B. Read, N. Balakrishnan, 
Brani Vidakovic. Volume 10, p.6743.
</p>
<p>&lsquo;Skewness, Bowleys's measures of&rsquo;, in:
<em>Encyclopedia of Statistical Sciences</em>, 2nd edition (2006). 
Editors: Samuel Kotz (Editor-in-Chief), Campbell B. Read, N. Balakrishnan, 
Brani Vidakovic.   Volume 12, p.7771-7773.
</p>
<p>Moors, J.J.A. (1988). 
A quantile alternative for kurtosis.
<em>Source: Journal of the Royal Statistical Society. 
Series D (The Statistician)</em>, Vol. 37, pp. 25-32
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+fivenum">fivenum</a></code>,
<code><a href="stats.html#topic+IQR">IQR</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>fournum(datasets::rivers)
</code></pre>

<hr>
<h2 id='frontier'>Simulated sample from a skew-normal distribution</h2><span id='topic+frontier'></span>

<h3>Description</h3>

<p>A sample simulated from the SN(0,1,5) distribution with sample
coefficient of skewness inside the admissible range 
(-0.9952719, 0.9952719) for the skew-normal family but
maximum likelihood estimate on the frontier of the parameter space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(frontier)</code></pre>


<h3>Format</h3>

<p>A numeric vector of length 50.</p>


<h3>Source</h3>

<p>Generated by a run of <code>rsn(50, 0, 1, 5)</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(frontier, package="sn")
fit &lt;- selm(frontier ~ 1)
plot(fit, which=2)
#
fit.p &lt;- selm(frontier ~ 1, method="MPLE")
plot(fit.p, which=2)
</code></pre>

<hr>
<h2 id='galton_moors2alpha_nu'>Mapping of the (Galton-Bowley, Moors)  measures to the 
(<code class="reqn">alpha</code>, <code class="reqn">nu</code>) parameters of a ST distribution</h2><span id='topic+galton_moors2alpha_nu'></span><span id='topic+galton2alpha'></span>

<h3>Description</h3>

<p>Given a pair of (Galton-Bowley, Moors) measures of skewness and 
kurtosis for a given sample, <code>galton_moors2alpha_nu</code> delivers values  
(<code class="reqn">alpha</code>, <code class="reqn">nu</code>)  such that a skew-<em>t</em> (<abbr><span class="acronym">ST</span></abbr>) distribution 
with these slant  and tail-weight  parameter has its (Galton-Bowley, Moors) 
measures equal to  the input values.
Its simplified version <code>galton2alpha</code> uses only a Galton-Bowley measure
to deliver a <code class="reqn">alpha</code> value, assuming a <abbr><span class="acronym">SN</span></abbr> distribution.
These functions are mainly intended for internal package usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galton_moors2alpha_nu(galton, moors, quick = TRUE, move.in = TRUE, verbose = 0, 
  abstol = 1e-04)
galton2alpha(galton, move.in = TRUE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galton_moors2alpha_nu_+3A_galton">galton</code></td>
<td>
<p>a numeric value, representing a Galton-Bowley measure</p>
</td></tr>
<tr><td><code id="galton_moors2alpha_nu_+3A_moors">moors</code></td>
<td>
<p>a numeric value, representing a Moors measure</p>
</td></tr>
<tr><td><code id="galton_moors2alpha_nu_+3A_quick">quick</code></td>
<td>
<p>a logical value; if <code>TRUE</code>, a quick mapping is performed</p>
</td></tr>
<tr><td><code id="galton_moors2alpha_nu_+3A_move.in">move.in</code></td>
<td>
<p>if the input values <code>(galton, moors)</code> are outside the 
feasible <abbr><span class="acronym">ST</span></abbr> region, a suitable point within the feasible area 
is returned</p>
</td></tr>
<tr><td><code id="galton_moors2alpha_nu_+3A_verbose">verbose</code></td>
<td>
<p>a numeric value which regulates the amount of printed detail</p>
</td></tr>
<tr><td><code id="galton_moors2alpha_nu_+3A_abstol">abstol</code></td>
<td>
<p>the tolerance value of the mapping, only relevant is
<code>quick=FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For background information about the Galton-Bowley's and 
the Moors measures, see the documentation of <code><a href="#topic+fournum">fournum</a></code>.
The working of the mapping by described in Azzalini and Salehi (2020).
</p>


<h3>Value</h3>

<p>for <code>galton_moors2alpha_nu</code>, named vector of length two, 
with one or more descriptive attributes; 
for <code>galton2alpha</code>, a single <code>alpha</code> value.</p>


<h3>Note</h3>

<p>These functions are mainly intended for internal package usage.
Specifically they are used by <code><a href="#topic+st.prelimFit">st.prelimFit</a></code>.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. and Salehi, M. (2020).
Some computational aspects of maximum likelihood estimation of the 
skew-<em>t</em> distribution.
In: <em>Computational and Methodological Statistics and Biostatistics</em>,
edited by  Andriëtte Bekker, Ding-Geng Chen and Johannes T. Ferreira.
Springer. DOI: 10.1007/978-3-030-42196-0
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fournum">fournum</a></code>, <code><a href="#topic+st.prelimFit">st.prelimFit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>galton_moors2alpha_nu(0.5, 3, quick=FALSE)  # input in the feasible area
galton_moors2alpha_nu(0.5, 3)    # very similar output, much more quickly
galton_moors2alpha_nu(0.5, 0.5)  # input outside the feasible area
</code></pre>

<hr>
<h2 id='makeSECdistr'>Build a skew-elliptically contoured distribution</h2><span id='topic+makeSECdistr'></span>

<h3>Description</h3>

<p>Build an object which identifies a skew-elliptically contoured 
distribution (<abbr><span class="acronym">SEC</span></abbr>), in the univariate and in the multivariate case.
The term &lsquo;skew-elliptical distribution&rsquo; is a synonym of <abbr><span class="acronym">SEC</span></abbr> 
distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSECdistr(dp, family, name, compNames)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSECdistr_+3A_dp">dp</code></td>
<td>
<p>a numeric vector (in the univariate case) or a list (in the
multivariate case) of parameters which identify the specific distribution
within the named <code>family</code>. See &lsquo;Details&rsquo; for their expected 
structure.</p>
</td></tr>
<tr><td><code id="makeSECdistr_+3A_family">family</code></td>
<td>
<p>a character string which identifies the parametric
family; currently, possible values are: <kbd>"SN"</kbd>, <kbd>"ESN"</kbd>, 
<kbd>"ST"</kbd>, <kbd>"SC"</kbd>. 
See &lsquo;Details&rsquo; for additional information.</p>
</td></tr>
<tr><td><code id="makeSECdistr_+3A_name">name</code></td>
<td>
<p>an optional character string with the name of the distribution.
If missing, one is created.</p>
</td></tr>
<tr><td><code id="makeSECdistr_+3A_compnames">compNames</code></td>
<td>
<p>in the multivariate case, an optional vector of character
strings with the names of the component variables; its length must be 
equal to the dimensionality of the distribution being generated. 
If missing and the first component of <code>dp</code> is a named vector,
its names are used as <code>compNames</code>; otherwise
the components are named <code>"V1"</code>, <code>"V2"</code>, ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>dp</code> is a numeric vector, a univariate distribution is built. 
Alternatively, if <code>dp</code> is a list, a multivariate distribution is 
built. In both cases, the required number of components of <code>dp</code> 
depends on <code>family</code>: it must be  <code>3</code> for <kbd>"SN"</kbd> and 
<kbd>"SC"</kbd>; it must be <code>4</code> for <kbd>"ESN"</kbd> and <kbd>"ST"</kbd>.
</p>
<p>In the univariate case, the first three components of <code>dp</code> represent 
what for the specific distributions are denoted <code>xi</code> (location), 
<code>omega</code> (scale, positive) and <code>alpha</code> (slant); see functions 
<code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dst">dst</a></code>, <code><a href="#topic+dsc">dsc</a></code> for their
description. 
The fourth component, when it exists, represents either <code>tau</code> 
(hidden variable mean) for <kbd>"ESN"</kbd> or <code>nu</code> (degrees of freedom) 
for <kbd>"ST"</kbd>. The names of the individual parameters are attached
to the components of <code>dp</code> in the returned object.
</p>
<p>In the multivariate case, <code>dp</code> is a list with components having 
similar role as in the univariate case, but <code>xi=dp[[1]]</code> and 
<code>alpha=dp[[3]]</code> are now vectors and the scale parameter
<code>Omega=dp[[2]]</code> is a symmetric positive-definite matrix. 
For a multivariate distribution of dimension 1 (which can be created, 
although a warning message is issued), <code>Omega</code> corresponds to the 
square of <code>omega</code> in the univariate case. 
Vectors <code>xi</code> and <code>alpha</code> must be of length <code>ncol(Omega)</code>.
See also functions <code><a href="#topic+dmsn">dmsn</a></code>, <code><a href="#topic+dmst">dmst</a></code> and 
<code><a href="#topic+dmsc">dmsc</a></code>.
The fourth component, when it exists, is a scalar with the same role as 
in the univariate case. 
</p>
<p>In the univariate case <code>alpha=Inf</code> is allowed, but in the multivariate
case all components of the vector <code>alpha</code> must be finite.
</p>
<p>An object built by this function operates according to the S4 protocol.
</p>


<h3>Value</h3>

<p>In the univariate case, an object of class <code>SECdistrUv</code>;
in the multivariate case, an object of class <code>SECdistrMv</code>.
See <code><a href="#topic+SECdistrUv-class">SECdistrUv-class</a></code> and <code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code>
for their description.
</p>


<h3>Background</h3>

<p>For background information, see Azzalini and Capitanio (2014), specifically
Chapters 2 and 4 for univariate cases, Chapters 5 and 6 for multivariate
cases; Section 6.1 provides a general formulation of <abbr><span class="acronym">SEC</span></abbr>
distributions.
</p>
<p>If the slant parameter <code>alpha</code> is <code>0</code> (or a vector of <code>0</code>'s,
in the multivariate case), the distribution is of classical elliptical 
type.
</p>
<p>The <abbr><span class="acronym">ESN</span></abbr> distribution is included here  as a members of the
<abbr><span class="acronym">SEC</span></abbr> class, with a very slight extension of the original definition
of this class, since the only difference is the non-zero truncation point
of the unobserved component of the <code>(d+1)</code>-dimensional <abbr><span class="acronym">EC</span></abbr> 
variable.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p>The description of classes  <code><a href="#topic+SECdistrUv-class">SECdistrUv-class</a></code> and
<code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code>
</p>
<p><code><a href="#topic+plot.SECdistr">plot.SECdistr</a></code> for plotting and 
<code><a href="#topic+summary.SECdistr">summary.SECdistr</a></code> for summaries
</p>
<p>Related functions <code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dst">dst</a></code>, <code><a href="#topic+dsc">dsc</a></code>, 
<code><a href="#topic+dmsn">dmsn</a></code>, <code><a href="#topic+dmst">dmst</a></code>,  <code><a href="#topic+dp2cp">dp2cp</a></code>
</p>
<p>Functions <code><a href="#topic+affineTransSECdistr">affineTransSECdistr</a></code> and
<code><a href="#topic+conditionalSECdistr">conditionalSECdistr</a></code> to manipulate objects of class    
<code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code> 
</p>
<p>Function <code><a href="#topic+extractSECdistr">extractSECdistr</a></code> to extract objects of class 
<code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code> and <code><a href="#topic+SECdistrUv-class">SECdistrUv-class</a></code> 
representing the <abbr><span class="acronym">SEC</span></abbr> distribution of a <code><a href="#topic+selm">selm</a></code> fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
f1 &lt;- makeSECdistr(dp=c(3,2,5), family="SN", name="First-SN")
show(f1)
summary(f1)
plot(f1)
plot(f1, probs=c(0.1, 0.9))
#
f2 &lt;- makeSECdistr(dp=c(3, 5, -4, 8), family="ST", name="First-ST")
f9 &lt;- makeSECdistr(dp=c(5, 1, Inf, 0.5), family="ESN", name="ESN,alpha=Inf")
#
dp0 &lt;- list(xi=1:2, Omega=diag(3:4), alpha=c(3, -5))
f10 &lt;- makeSECdistr(dp=dp0, family="SN", name="SN-2d", compNames=c("u1", "u2"))
#
dp1 &lt;- list(xi=1:2, Omega=diag(1:2)+outer(c(3,3),c(2,2)), alpha=c(-3, 5), nu=6)
f11 &lt;- makeSECdistr(dp=dp1, family="ST", name="ST-2d", compNames=c("t1", "t2"))
</code></pre>

<hr>
<h2 id='makeSUNdistr'>Build an object representing a SUN distribution</h2><span id='topic+makeSUNdistr'></span>

<h3>Description</h3>

<p>Build an object which identifies a Unified Skew-Normal distribution 
(<abbr><span class="acronym">SUN</span></abbr>) within this parametric family.
The <abbr><span class="acronym">SUN</span></abbr> family is essentially equivalent to some other 
parametric families examined in the literature, notably the Closed Skew-Normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSUNdistr(dp, name, compNames, HcompNames, drop = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSUNdistr_+3A_dp">dp</code></td>
<td>
<p>a list of parameters as described at <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>.</p>
</td></tr>
<tr><td><code id="makeSUNdistr_+3A_name">name</code></td>
<td>
<p>an optional character string with the name of the distribution. 
If missing, one is created.</p>
</td></tr>
<tr><td><code id="makeSUNdistr_+3A_compnames">compNames</code></td>
<td>
<p>an optional vector of character strings with the names of 
the component variables; its length must be equal to the dimensionality 
<code>d</code> of the distribution being generated.
If missing, the components are named  <code>"V1"</code>, <code>"V2"</code>, ...</p>
</td></tr>
<tr><td><code id="makeSUNdistr_+3A_hcompnames">HcompNames</code></td>
<td>
<p>an optional vector of character strings with the names of 
the hidden component variables; its length must be equal to the 
dimensionality component <code>m</code> described in the &lsquo;Details&rsquo;.
If missing, the components are named <code>"H1"</code>, <code>"H2"</code>, ...</p>
</td></tr>
<tr><td><code id="makeSUNdistr_+3A_drop">drop</code></td>
<td>
<p>a logical value (default: <code>TRUE</code>) relevant only in the
case <code>m=1</code>. When both <code>m=1</code> and <code>drop=TRUE</code>, the 
returned object is of class either <code>SECdistrUv</code> or <code>SECdistrMv</code>,
depending on the value of <code>d</code>, and family <code>"SN"</code> or 
<code>"ESN"</code>, depending on the <code>dp</code> ingredients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument  <code>dp</code> is a list, whose components are described at 
<code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>; see especially the &lsquo;Details&rsquo; there.
In this respect, there is no difference between the univariate and the
univariate case, differently from the similar command 
<code><a href="#topic+makeSECdistr">makeSECdistr</a></code>.
</p>
<p>If the arguments <code>name</code>, <code>compNames</code> and <code>HcompNames</code>
are missing, they are composed from the supplied arguments.
</p>
<p>A <code>SUNdistr-class</code> object operates according to the S4 protocol.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code></p>


<h3>Note</h3>

<p>The present structure and user interface of this function, and of other ones 
related to the <abbr><span class="acronym">SUN</span></abbr> distribution, must be considered experimental, 
and they might possibly change in the future.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p>Basic information on the SUN distribution <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>,
the description of the class <code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code>, 
</p>
<p>Related methods:
<code><a href="#topic+show.SUNdistr">show.SUNdistr</a></code> for displaying the object constituents,
<code><a href="#topic+plot.SUNdistr">plot.SUNdistr</a></code> for plotting,
<code><a href="#topic+mean.SUNdistr">mean.SUNdistr</a></code> for the mean value,
<code><a href="#topic+vcov.SUNdistr">vcov.SUNdistr</a></code> for the variance matrix,
<code><a href="#topic+summary.SUNdistr">summary.SUNdistr</a></code> for various summary quantities 
</p>
<p>Functions <code><a href="#topic+SUNdistr-op">SUNdistr-op</a></code>  manipulate objects created by this 
function, producing new <code>SUNdistr-class</code> objects  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- c(1, 0, -1)
Omega &lt;- matrix(c(2,1,1, 1,3,1, 1,1,4), 3, 3)
Delta &lt;- matrix(c(0.72,0.20, 0.51,0.42, 0.88, 0.94), 3, 2, byrow=TRUE)
Gamma &lt;- matrix(c(1, 0.8, 0.8, 1), 2, 2)
dp3 &lt;- list(xi=xi, Omega=Omega, Delta=Delta, tau=c(-0.5, 0), Gamma=Gamma)
sun3 &lt;- makeSUNdistr(dp=dp3, name="SUN3", compNames=c("x", "w", "z"))
show(sun3)
</code></pre>

<hr>
<h2 id='matrix-op'>vech, tr and other matrix operators</h2><span id='topic+vech'></span><span id='topic+vech2mat'></span><span id='topic+duplicationMatrix'></span><span id='topic+tr'></span><span id='topic+blockDiag'></span>

<h3>Description</h3>

<p>vech and other matrix operators</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(A)
vech2mat(v)
duplicationMatrix(n)
tr(x)
blockDiag(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix-op_+3A_a">A</code></td>
<td>
<p>a (symmetric) square numeric matrix.</p>
</td></tr>
<tr><td><code id="matrix-op_+3A_v">v</code></td>
<td>
<p>a numeric vector such that <code>length(v)=n*(n+1)/2</code> for some
positive integer <code>n</code>.</p>
</td></tr>
<tr><td><code id="matrix-op_+3A_n">n</code></td>
<td>
<p>a positive integer number; default is <code>n=1</code>.</p>
</td></tr>
<tr><td><code id="matrix-op_+3A_x">x</code></td>
<td>
<p>a square numeric matrix.</p>
</td></tr>
<tr><td><code id="matrix-op_+3A_...">...</code></td>
<td>
<p>an abitrary numer of matrices or objects coercible into matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector in case of <code>vech</code>, a scalar in case of <code>tr</code>, 
otherwise a matrix.</p>


<h3>Details</h3>


<p>For a  square matrix <code>A</code>, <code>vech(A)</code> returns the vector formed
by the lower triangular portion of the matrix, including the diagonal; 
usually, this only makes sense for a symmetric matrix of numeric values. 
If <code>v=vech(M)</code> where <code>M</code> is a symmetric numeric matrix, 
<code>vech2mat(v)</code> performs the inverse operation and returns the original 
matrix <code>M</code>; this explain the requirement on <code>length(v)</code>.
</p>
<p>For a positive integer <code>n</code>, <code>D=duplicationMatrix(n)</code> is a matrix 
of dimension <code>(n^2, n*(n+1)/2)</code> such that <code>D %*% vech(M)</code> returns 
the <code>vec</code>-form of a symmetric matrix <code>M</code> of 
order <code>n</code>, that is, the vector which stacks the columns of <code>M</code>;
for more information, see Section 3.8 of Magnus and Neudecker (1988). 
</p>
<p>For a square numeric matrix <code>x</code>, <code>tr(x)</code> returns its trace.
</p>
<p><code>blockDiag(...)</code> creates a block-diagonal matrix from a set of matrices 
or objects coercible into matrices. Generally, this is useful only for
numeric objects.
</p>


<h3>Author</h3>

<p>Adelchi Azzalini; 
the original Octave code of <code>duplicationMatrix</code> is by Kurt Hornik.</p>


<h3>References</h3>

<p>Magnus, Jan R. and Neudecker, Heinz (1988). <em>Matrix differential
calculus with application in statistics and econometrics</em>. 
Wiley series in probability and statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- toeplitz(1:4)
v &lt;- vech(M)
vech2mat(v) - M
D &lt;- duplicationMatrix(ncol(M))
# D %*% vech(M) - as.vector(M), must be a one-column matrix of 0s
tr(outer(1:4,2:5))
blockDiag(M[1:2,], 1:2, diag(5:6))
</code></pre>

<hr>
<h2 id='modeSECdistr'>The mode of a skew-elliptically contoured (<abbr><span class="acronym">SEC</span></abbr>) distribution</h2><span id='topic+modeSECdistr'></span>

<h3>Description</h3>

<p>Compute compute the mode of a univariate or multivariate <abbr><span class="acronym">SEC</span></abbr>
distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  modeSECdistr(dp, family, object=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeSECdistr_+3A_dp">dp</code></td>
<td>

<p>a numeric vector (in the univariate case, for class <code>SECdistrUv</code>) 
or a list (in the multivariate case, , for class <code>SECdistrUv</code>) 
of parameters which identify the specific distribution within the named
<code>family</code>.
</p>
</td></tr>
<tr><td><code id="modeSECdistr_+3A_family">family</code></td>
<td>
<p>a character string which identifies the parametric
family among those admissible for classes <code>SECdistrUv</code> or 
<code>SECdistrMv</code>.</p>
</td></tr>
<tr><td><code id="modeSECdistr_+3A_object">object</code></td>
<td>
<p>an object of class <code>SECdistrUv</code> or <code>SECdistrMv</code> as
created by <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> or <code><a href="#topic+extractSECdistr">extractSECdistr</a></code>;
if this argument is used, arguments <code>dp</code> and <code>family</code> must 
not be set, and <em>vice versa</em>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector</p>


<h3>Background</h3>

<p>The mode is obtained through numerical maximization.
In the multivariate case, the problem is reduced to a one-dimensional search 
using Propositions 5.14 and 6.2 of the reference below.</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code> and <code><a href="#topic+extractSECdistr">extractSECdistr</a></code>
for additional information and for constructing a suitable <code>object</code>,
</p>
<p><code><a href="#topic+SECdistrUv-class">SECdistrUv-class</a></code> and <code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code>
for methods <code>mean</code> and <code>vcov</code> which compute the mean (vector) 
and the variance (matrix) of the  <code>object</code> distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dp3 &lt;- list(xi=1:3, Omega=toeplitz(1/(1:3)), alpha=c(3,-1,2), nu=5)
st3 &lt;- makeSECdistr(dp3, family="ST", name="ST3", compNames=c("U", "V", "W"))
mode1 &lt;- modeSECdistr(dp3, "ST")
mode2 &lt;- modeSECdistr(object=st3) # the same of mode1
</code></pre>

<hr>
<h2 id='overview-sn'>Package <span class="pkg">sn</span>: overview of the structure and main commands</h2><span id='topic+overview-sn'></span>

<h3>Description</h3>

 
<p>The package provides facilities to build and manipulate probability 
distributions of the skew-normal (<abbr><span class="acronym">SN</span></abbr>)  and some related families, 
notably the skew-<code class="reqn">t</code> (<abbr><span class="acronym">ST</span></abbr>) and the &lsquo;unified skew-normal&rsquo; 
(<abbr><span class="acronym">SUN</span></abbr>) families. 
For the <abbr><span class="acronym">SN</span></abbr>, <abbr><span class="acronym">ST</span></abbr> and skew-Cauchy (<abbr><span class="acronym">SC</span></abbr>) families,
statistical methods are made available for data fitting and model diagnostics,  
in the univariate and  the multivariate case.
</p>


<h3>Two main sides</h3>

 
<p>The package comprises two main sides: one side provides  facilities for the 
pertaining probability distributions; the other one deals with related
statistical methods.
Underlying formulation, parameterizations of distributions and terminology 
are in agreement with the monograph of Azzalini and Capitanio (2014).
</p>


<h3>Probability side</h3>


<p>There are two layers of support for the probability distributions of interest.
At the basic level, there exist functions which follow the classical <span class="rlang"><b>R</b></span>  
scheme for distributions.
In addition, there exists facilities to build an object which incapsulates 
a probability distribution and then certain operations can be be performed 
on such an object;
these probability objects operate according to the S4 protocol. 
The two schemes are described next.
</p>

<dl>
<dt>Classical <span class="rlang"><b>R</b></span> scheme</dt><dd>
<p>The following functions work similary to <code>{d,p,q,r}norm</code> and other <span class="rlang"><b>R</b></span>
functions for probability distributions:
</p>

<ul>
<li><p> skew-normal (<abbr><span class="acronym">SN</span></abbr>): functions <code>{d,p,q,r}sn</code> for the 
univariate case, functions  <code>{d,p,r}msn</code> for the multivariate case, 
where in both cases the &lsquo;Extended skew-normal&rsquo; (<abbr><span class="acronym">ESN</span></abbr>) 
variant form is included;
</p>
</li>
<li><p> skew-<code class="reqn">t</code> (<abbr><span class="acronym">ST</span></abbr>): functions <code>{d,p,q,r}st</code> for the
univariate case,  functions  <code>{d,p,r}mst</code> for the multivariate case;
</p>
</li>
<li><p> skew-Cauchy (<abbr><span class="acronym">SC</span></abbr>): functions <code>{d,p,q,r}sc</code> for the 
univariate case, functions <code>{d,p,r}msc</code> for the multivariate case.
</p>
</li></ul>

<p>In addition to the usual specification of their parameters as a sequence of
individual components, a parameter set can be specified as a single <code>dp</code>
entity, namely a vector in the univariate case, a list in the multivariate
case; <code>dp</code> stands for &lsquo;Direct Parameters&rsquo; (<abbr><span class="acronym">DP</span></abbr>).
</p>
<p>Another set of parameters is in use, denoted Centred Parameters (<abbr><span class="acronym">CP</span></abbr>),
which are more convenient for interpretability, since they correspond to
familiar quantifies, such as the mean and the standard deviation. 
Conversion from the <code>dp</code> parameter set to the corresponding <abbr><span class="acronym">CP</span></abbr>
parameters can be accomplished using the function <code>dp2cp</code>,
while function <code>cp2dp</code> performs the inverse transformation.
</p>
<p>The <abbr><span class="acronym">SUN</span></abbr> family is mainly targeted to the multivariate context, 
and this is reflected in the organization of the pertaining functions, 
although univariate <abbr><span class="acronym">SUN</span></abbr> distributions are supported.
Density, distribution function and random numbers are handled by
<code>{d,p,r}sun</code>. Mean value, variance matrix and Mardia's measures
of multivariate skewness and kurtosis are computed by
<code>sun{Mean,Vcov,Mardia}</code>.
</p>
<p>In addition, one can introduce a user-specified density function using
<code>dSymmModulated</code> and <code>dmSymmModulated</code>, in the univariate and the
multivariate case, respectively. These densities are of the
&lsquo;symmetry-modulated&rsquo; type, also called &lsquo;skew-symmetric&rsquo;, where
one can specify the base density and the modulation factor with high degree of
flexibility.  Random numbers can be sampled using the corresponding functions
<code>rSymmModulated</code> and <code>rmSymmModulated</code>. In the bivariate case,
a dedicated plotting function exists.
</p>
</dd>
<dt>Probability distribution objects: <abbr><span class="acronym">SEC</span></abbr> families</dt><dd>
<p>Function <code>makeSECdistr</code> can be used to build a &lsquo;<abbr><span class="acronym">SEC</span></abbr>
distribution&rsquo; object representing a member of a specified parametric family
(among the types <abbr><span class="acronym">SN, ESN, ST, SC</span></abbr>) with a given <code>dp</code> parameter
set. This object can be used for various operations such as plotting  or
extraction of moments and other summary quantities.  
Another way of constructing a <abbr><span class="acronym">SEC</span></abbr> distribution object is via
<code>extractSECdistr</code> which extracts suitable components of an object 
produced by function <code>selm</code> to be described below.
</p>
<p>Additional operations on these objects are possible in the multivariate case,
namely <code>marginalSECdistr</code> and <code>affineTransSECdistr</code>
for marginalization and affine trasformations. 
For the multivariate <abbr><span class="acronym">SN</span></abbr> family only (but including <abbr><span class="acronym">ESN</span></abbr>), 
<code>conditionalSECdistr</code> performs a conditioning on the values taken 
on by some components of the multivariate variable.</p>
</dd>
<dt>Probability distribution objects: the <abbr><span class="acronym">SUN</span></abbr> family</dt><dd>
<p>Function <code>makeSUNdistr</code> can be used to build a <abbr><span class="acronym">SUN</span></abbr>
distribution object representing a member of the <abbr><span class="acronym">SUN</span></abbr> 
parametric family.
This object can be used for various operations such as plotting  or
extraction of moments and other summary quantities.
</p>
<p>Moreover there are several trasformation operations which can be performed
on a <abbr><span class="acronym">SUN</span></abbr> distribution object, or two such objects in some cases:
computing a (multivariate) marginal distribution,  a conditional distribution
(on given values of some components or on one-sided intervals), an affine
trasformation, a convolution (that is, the distribution of the sum of two
independent variables), and joining two distributions under assumption of
independence.
</p>
</dd></dl>



<h3>Statistics side</h3>


<p>The main function for data fitting is represented by <code>selm</code>, which allows
to specify a linear regression model for the location parameter, similarly 
to function <code>lm</code>, but assuming a <dfn>skew-elliptical</dfn> distribution
of the random component;
this explains the name <dfn>selm=(se+lm)</dfn>. Allowed types of distributions
are  <abbr><span class="acronym">SN</span></abbr> (but not <abbr><span class="acronym">ESN</span></abbr>), <abbr><span class="acronym">ST</span></abbr> and <abbr><span class="acronym">SC</span></abbr>.
The fitted distribution is univariate or multivariate, depending on the nature
of the response variable of the posited regression model. The model fitting
method is either maximum likelihood or maximum penalized likelihood; 
the latter option effectively allows the introduction of a prior distribution 
on the slant parameter of the error distribution, hence leading to a 
&lsquo;maximum a posteriori&rsquo; estimate.
</p>
<p>Once the fitting process has been accomplished, an object of class either
<dfn>selm</dfn> (for univariate response) or <dfn>mselm</dfn> (for multivariate 
response) is produced.
A number of &lsquo;methods&rsquo; are available for these objects: <code>show</code>, 
<code>plot</code>, <code>summary</code>, <code>coef</code>, <code>residuals</code>, <code>logLik</code> 
and others.
For univariate <dfn>selm</dfn>-class objects, univariate and bivariate profile
log-likelihood functions can be obtained; a <code>predict</code> method also exists.
These methods are built following the S4 protocol; however, the user must not
be concerned with the choice of the adopted protocol (unless this is wished).
</p>
<p>The actual fitting process invoked via <code>selm</code> is actually performed by a
set of lower-level procedures. These are accessible for direct call, 
if so wished, typically for improved efficiency, at the expense of a little 
additional programming effort. Similarly, functions to compute the Fisher 
information matrix are available, in the expected and the observed form 
(with some restrictions depending on the selected distribution).
</p>
<p>The <code>extractSECdistr</code> function extracts the fitted <abbr><span class="acronym">SEC</span></abbr> 
distribution from  <dfn>selm</dfn>-class and <dfn>mselm</dfn>-class objects, hence
providing a bridge with the probability side of the package.
</p>
<p>The facilities for statistical work do not support the <abbr><span class="acronym">SUN</span></abbr> family.
</p>


<h3>Additional material</h3>

<p>Additional material is available in the section 
&lsquo;User guides, package vignettes and other documentation&rsquo;
accessible from the front page of the documentation. 
See especially the document <code>pkg_sn-intro.pdf</code>
</p>


<h3>Author</h3>

<p>Adelchi Azzalini.
Please send comments, error reports <em>et cetera</em> to the author, 
whose web page is <a href="http://azzalini.stat.unipd.it/">http://azzalini.stat.unipd.it/</a>.
</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>

<hr>
<h2 id='plot.fitdistr.grouped'>Plot an object generated by <code>fitdistr.grouped</code></h2><span id='topic+plot.fitdistr.grouped'></span><span id='topic+plot+2Cfitdistr.grouped-method'></span>

<h3>Description</h3>

<p>The object produced by <code><a href="#topic+fitdistr.grouped">fitdistr.grouped</a></code> is plotted in the form
of an histogram of the input original observed frequencies with superimposed 
the fitted parametric density function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitdistr.grouped'
plot(x, freq = FALSE, col = "grey90", 
  border = "grey80",  pdfcol = "blue", main, sub = NULL, xlab, ylab, xlim, ylim, 
  axes = TRUE, labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitdistr.grouped_+3A_x">x</code></td>
<td>
<p>a <code>link{fitdistr.grouped}</code> object.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_freq">freq</code></td>
<td>
<p>logical;  if <code>TRUE</code>, the histogram graphic is to present 
a representation of frequencies; if <code>FALSE</code> (default value),
densities are plotted.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_col">col</code></td>
<td>
<p>a colour to be used to fill the bars. </p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_border">border</code></td>
<td>
<p>the colour of the border around the bars.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_pdfcol">pdfcol</code></td>
<td>
<p>the colour of the fitted parametric distribution.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_main">main</code>, <code id="plot.fitdistr.grouped_+3A_sub">sub</code>, <code id="plot.fitdistr.grouped_+3A_xlab">xlab</code>, <code id="plot.fitdistr.grouped_+3A_ylab">ylab</code></td>
<td>
<p>these arguments to <code>title</code> an be omitted,
in which case default values are constructed.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_xlim">xlim</code>, <code id="plot.fitdistr.grouped_+3A_ylim">ylim</code></td>
<td>
<p> the range of <code>x</code> and <code>y</code> values with 
sensible defaults.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_axes">axes</code></td>
<td>
<p>logical, indicating if axes should be drawn.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_labels">labels</code></td>
<td>
<p>logical or character. Additionally draw labels on top of bars, 
if not FALSE; if TRUE, draw the counts or rounded densities; 
if labels is a character, draw itself.</p>
</td></tr>
<tr><td><code id="plot.fitdistr.grouped_+3A_...">...</code></td>
<td>
<p>further graphical parameters to title and axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function builds on <code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code>, 
but some lesser features have been dropped.</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>hist</code></td>
<td>
<p>an object of class <code>histogram</code> which produces the histogram.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>the values used for plotting the fitted parametric distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitdistr.grouped">fitdistr.grouped</a></code> for generating a suitable object, 
<code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code> for the related more general function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barolo)
attach(barolo)
A75 &lt;- (reseller=="A" &amp; volume==75)
logPrice &lt;- log(price[A75],10) # as used in selm documentation; see its fitting
detach(barolo)
breaks&lt;- seq(1, 3, by=0.25)
f &lt;- cut(logPrice, breaks = breaks)
freq &lt;- tabulate(f, length(levels(f))) 
logPrice.grouped &lt;- fitdistr.grouped(breaks, freq, family='ST')
plot(logPrice.grouped)
</code></pre>

<hr>
<h2 id='plot.SECdistr'>Plotting methods for classes <code>SECdistrUv</code> and <code>SECdistrMv</code></h2><span id='topic+plot.SECdistr'></span><span id='topic+plot.SECdistrUv'></span><span id='topic+plot.SECdistrMv'></span><span id='topic+plot+2CSECdistrMv+2Cmissing-method'></span><span id='topic+plot+2CSECdistrUv+2Cmissing-method'></span><span id='topic+plot+2CSECdistrMv-method'></span><span id='topic+plot+2CSECdistrUv-method'></span>

<h3>Description</h3>

<p>Plotting methods for classes <code>SECdistrUv</code> and <code>SECdistrMv</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SECdistrUv'
plot(x, range, probs, main, npt = 251, ...)

## S4 method for signature 'SECdistrMv'
plot(x, range, probs, npt, landmarks = "auto",
   main, comp, compLabs, data = NULL, data.par = NULL, gap = 0.5, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SECdistr_+3A_x">x</code></td>
<td>
<p>an object of class <code>SECdistrUv</code> or <code>SECdistrMv</code>.</p>
</td></tr>

<tr><td><code id="plot.SECdistr_+3A_range">range</code></td>
<td>
<p>in the univariate case, a vector of length 2 which defines 
the plotting range; in the multivariate case, a matrix with two rows where 
each column defines the plotting range of the corresponding component 
variable. If missing, a sensible choice is made.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_probs">probs</code></td>
<td>
<p>a vector of probability values. In the univariate case, the
corresponding quantiles are plotted on the horizontal axis; it can be
skipped by setting <code>probs=NULL</code>. In the multivariate case, each 
probability value corresponds to a contour level in each bivariate plot; 
at least one probability value is required. See &lsquo;Details&rsquo; for
further information. Default value: <code>c(0.05, 0.25, 0.5, 0.75, 0.95)</code>
in the univariate case, <code>c(0.25, 0.5, 0.75, 0.95)</code> in the
multivariate case.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_npt">npt</code></td>
<td>
<p>a numeric value or vector (in the univariate and in the 
multivariate case, respectively) to assign the number of evaluation points
of the distribution, on an equally-spaced grid over the <code>range</code>
defined above.  Default value: 251 in the univariate case, a vector of
101's in the multivariate case.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_landmarks">landmarks</code></td>
<td>
<p>a character string which affects the placement of some
landmark values in the multivariate case, that is, the origin, the mode
and the mean (or its substitute pseudo-mean), which are all aligned.
Possible values: <code>"proper"</code>, <code>"pseudo"</code>, <code>"auto"</code>
(default), <code>""</code>. The option <code>""</code> prevents plotting of the
landmarks. With the other options, the landmarks are plotted, with some
variation in the last one: <code>"proper"</code> plots the proper mean value,
<code>"pseudo"</code> plots the pseudo-mean, useful when the proper mean does
not exists, <code>"auto"</code> plots the proper mean if it exists, otherwise it
switches automatically to the pseudo-mean. See <code><a href="#topic+dp2cp">dp2cp</a></code> for
more information on pseudo-<abbr><span class="acronym">CP</span></abbr> parameters, including pseudo-mean.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_main">main</code></td>
<td>
<p>a character string for main title; if missing, one is built
from the available ingredients.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_comp">comp</code></td>
<td>
<p>a subset of the vector <code>1:d</code>, if <code>d</code> denotes the
dimensionality of the multivariate distribution.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_complabs">compLabs</code></td>
<td>
<p>a vector of character strings or expressions used to denote
the variables in the plot; 
if missing, <code>slot(object,"compNames")</code> is used.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_data">data</code></td>
<td>
<p>an optional set of data of matching dimensionity of
<code>object</code> to be superimposed to the plot. 
The default value <code>data=NULL</code> produces no effect. 
In the univariate case, data are plotted using <code><a href="graphics.html#topic+rug">rug</a></code> 
at the top horizontal axis, unless if <code>probs=NULL</code>, in which case 
plotting is at the bottom axis. In the multivariate case, points are 
plotted in the form of a scatterplot or matrix of scatterplots; this
can be regulated by argument <code>data.par</code>.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_data.par">data.par</code></td>
<td>
<p>an optional list of graphical parameters used for plotting 
<code>data</code> in the multivariate case, when <code>data</code> is not <code>NULL</code>. 
Recognized parameters are: <code>col</code>, <code>pch</code>, <code>cex</code>.
If missing, the analogous components of <code>par()</code> are used. </p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_gap">gap</code></td>
<td>
<p>a numeric value which regulates the gap between panels of a
multivariate plot when <code>d&gt;2</code>.</p>
</td></tr>
<tr><td><code id="plot.SECdistr_+3A_...">...</code></td>
<td>
<p>additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible list. In the univariate case the list has three components:
the input object representing the distribution and two numeric vectors with 
the coordinates of the plotted density values. 
In the multivariate case, the first element of the list is the input object 
representing the distribution and all subsequent list elements are lists with 
components of the panels comprising the matrix plot; 
the elements of these sub-lists are: 
the vectors of <code>x</code> and <code>y</code> coordinates, the names of the variables, 
the density values at the <code>(x,y)</code> points, a vector of the density levels 
of the curves appearing in each panel plot, with the corresponding approximate
probability content as a vector attribute.</p>


<h3>Details</h3>

<p>For univariate density plots, <code>probs</code> are used to compute quantiles
from the appropriate distribution, and these are superimposed to the plot of
the density function, unless <code>probs=NULL</code>. In the multivariate case,
each bivariate plot  is constructed as a collection of contour curves,
one curve for each probability level; consequently, <code>probs</code> cannot be 
missing or <code>NULL</code>. The level of the density contour lines are chosen 
so that each curve circumscribes a region with the  quoted probability, 
to a good degree of approssimation; for additional information, see 
Azzalini and Capitanio (2014), specifically Complement 5.2 and p.179, 
and references therein.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "SECdistrUv")</code></dt><dd><p>Plot an object <code>x</code>
of class <code>SECdistrUv</code>.</p>
</dd>
<dt><code>signature(x = "SECdistrMv")</code></dt><dd><p>Plot an object <code>x</code>
of class <code>SECdistrMv</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.    
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, <code><a href="#topic+summary.SECdistr">summary.SECdistr</a></code>, 
<code><a href="#topic+dp2cp">dp2cp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># d=1
f1 &lt;- makeSECdistr(dp=c(3,2,5), family="SC", name="Univariate Skew-Cauchy")
plot(f1)
plot(f1, range=c(-3,40), probs=NULL, col=4)
#    
# d=2
Omega2 &lt;- matrix(c(3, -3, -3, 5), 2, 2)    
f2 &lt;-  makeSECdistr(dp=list(c(10,30), Omega=Omega2, alpha=c(-3, 5)),  
                family="sn", name="SN-2d", compNames=c("x1","x2"))
plot(f2)    
x2 &lt;- rmsn(100, dp=slot(f2,"dp"))
plot(f2, main="Distribution 'f2'", probs=c(0.5,0.9), cex.main=1.5, col=2,
  cex=0.8, compLabs=c(expression(x[1]), expression(log(z[2]-beta^{1/3}))), 
  data=x2, data.par=list(col=4, cex=0.6, pch=5))

</code></pre>

<hr>
<h2 id='plot.selm'>Diagnostic plots for <code>selm</code> fits</h2><span id='topic+plot.selm'></span><span id='topic+plot.mselm'></span><span id='topic+plot+2Cselm-method'></span><span id='topic+plot+2Cmselm-method'></span>

<h3>Description</h3>

<p>Diagnostic plots for objects of class <code>selm</code>
and <code>mselm</code> generated by a call to function <code>selm</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'selm'
plot(x, param.type="CP", which = c(1:4), caption, 
    panel = if (add.smooth) panel.smooth else points, main = "", 
    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), ..., 
    id.n = 3, labels.id = names(x@residuals.dp), 
    cex.id = 0.75, identline = TRUE, add.smooth = getOption("add.smooth"), 
    label.pos = c(4, 2), cex.caption = 1) 

 ## S4 method for signature 'mselm'
plot(x, param.type="CP",  which, caption, 
    panel = if (add.smooth) panel.smooth else points,  main = "", 
    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), ..., 
    id.n = 3, labels.id = names(x@residuals.dp), 
    cex.id = 0.75, identline = TRUE, add.smooth = getOption("add.smooth"), 
    label.pos = c(4, 2), cex.caption = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.selm_+3A_x">x</code></td>
<td>
<p>an object of class <code>selm</code> or <code>mselm</code>.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_param.type">param.type</code></td>
<td>
<p>a character string which selects the type of residuals
to be used for some of of the plots; 
possible values are: <code>"CP"</code> (default), <code>"DP"</code>, 
<code>"pseudo-CP"</code>. The various type of residuals only differ by an 
additive term; see &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of 
<code>1:4</code>; see &lsquo;Details&rsquo; for a description of the plots.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_caption">caption</code></td>
<td>
<p>a vector of character strings with captions to appear above 
the plots.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_panel">panel</code></td>
<td>
<p>panel function.  The useful alternative to <code>points</code>,
<code>panel.smooth</code> can be chosen by <code>add.smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_main">main</code></td>
<td>
<p>title to each plot, in addition to the above caption.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>

<tr><td><code id="plot.selm_+3A_id.n">id.n</code></td>
<td>
<p>number of points to be labelled in each plot, starting with the
most extreme.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_labels.id">labels.id</code></td>
<td>
<p>vector of labels, from which the labels for extreme points
will be chosen. <code>NULL</code> uses observation numbers..</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_cex.id">cex.id</code></td>
<td>
<p>magnification of point labels.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_identline">identline</code></td>
<td>
<p>logical indicating if an identity line should be added to
QQ-plot and PP-plot (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical indicating if a smoother should be added to most 
plots; see also <code>panel</code> above.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_label.pos">label.pos</code></td>
<td>
<p> positioning of labels, for the left half and right 
half of the graph respectively, for plots 1-3.</p>
</td></tr>
<tr><td><code id="plot.selm_+3A_cex.caption">cex.caption</code></td>
<td>
<p>controls the size of <code>caption</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The meaning of <code>param.type</code> is described in
<code><a href="#topic+dp2cp">dp2cp</a></code>. However, for these plot only the first parameter
component is relevant, which affects the location of the residuals; the other
components are not computed. Moreover, for <abbr><span class="acronym">QQ</span></abbr>-plot and
<abbr><span class="acronym">PP</span></abbr>-plot, <abbr><span class="acronym">DP</span></abbr>-residuals are used irrespectively of
<code>param.type</code>; see Section &lsquo;Background&rsquo;.
</p>
<p>Values <code>which=1</code> and <code>which=2</code> have a
different effect for object of class <code>"selm"</code> and class <code>"mselm"</code>.
In the univariate case, <code>which=1</code> plots the residual values versus the
fitted values if <code>p&gt;1</code>, where <code>p</code> denotes the number of covariates
including the constant; if <code>p=1</code>, a boxplot of the response is produced.
Value <code>which=2</code> produces an histogram of the residuals with superimposed
the fitted curve, when <code>p&gt;1</code>; if <code>p=1</code>, a similar plot is generated
using the response variable instead of the residuals. Default value for
<code>which</code> is <code>1:4</code>.
</p>
<p>In the multivariate case, <code>which=1</code> is feasible only if <code>p=1</code> and it
displays the data scatter with superimposed the fitted distribution. Value
<code>which=2</code> produces a similar plot but for residuals instead of
data. Default value for codewhich is <code>2:4</code> if <code>p&gt;1</code>, otherwise
<code>c(1,3,4)</code>. 
</p>
<p>Value <code>which=3</code> produces a QQ-plot, both in the univariate and in the
multivariate case; the difference is that the squares of normalized residuals
and suitably defined Mahalanobis distances, respectively, are used in the two
cases. Similarly, <code>which=4</code> produces a PP-plot, working in a similar
fashion.</p>


<h3>Background</h3>

<p>Healy-type graphical diagnostics, in the form of QQ- and PP-plots, for the 
multivariate normal distribution have been extended to the skew-normal
distribution by Azzalini and Capitanio (1999, section 6.1), and subsequently 
to the skew-<code class="reqn">t</code> distribution in Azzalini and Capitanio (2003). 
A brief explanation in the univariate <abbr><span class="acronym">SN</span></abbr> case is provided 
in Section 3.1.1 of Azzalini and Capitanio (2014); see also Section 3.1.6.
For the univariate <abbr><span class="acronym">ST</span></abbr> case, see p.102 and p.111 of the monograph.
The multivariate case is discussed in Section 5.2.1 as for the <abbr><span class="acronym">SN</span></abbr>
distribution, in Section 6.2.6 as for the <abbr><span class="acronym">ST</span></abbr> distribution.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. and Capitanio, A. (1999).
Statistical applications of the multivariate skew normal distribution.
<em>J.Roy.Statist.Soc. B</em> <b>61</b>, 579-602. 
Full-length version available at <a href="https://arXiv.org/abs/0911.2093">https://arXiv.org/abs/0911.2093</a>
</p>
<p>Azzalini, A. and Capitanio, A. (2003).
Distributions generated by perturbation of symmetry with emphasis on
a multivariate skew <em>t</em> distribution.
<em>J.Roy. Statist. Soc. B</em> <b>65</b>, 367-389.
Full-length version available at <a href="https://arXiv.org/abs/0911.2342">https://arXiv.org/abs/0911.2342</a>
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code>, <code><a href="#topic+dp2cp">dp2cp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
#
m10 &lt;- selm(flavanoids  ~ 1, family="SN", data=wines, subset=(wine=="Barolo"))
plot(m10)
plot(m10, which=c(1,3)) # fig 3.1 and 3.2(a) of Azzalini and Capitanio (2014)
#
m18 &lt;- selm(acidity ~ sugar + nonflavanoids + wine, family="SN", data=wines)
plot(m18)
plot(m18, param.type="DP")
#
m28 &lt;- selm(cbind(acidity, alcohol) ~ sugar + nonflavanoids + wine, 
            family="SN", data=wines)
plot(m28, col=4)            
# 
data(ais)
m30 &lt;-  selm(cbind(RCC, Hg, Fe) ~ 1, family="SN", data=ais)
plot(m30, col=2, which=2)

# multiple plots on the same sheet 
par(mfcol=c(2,2)) 
plot(m30, which=1:3)
par(mfcol=c(1,1)) 

</code></pre>

<hr>
<h2 id='plot.SUNdistr-method'>Plotting method for class <code>SUNdistr</code></h2><span id='topic+plot.SUNdistr'></span><span id='topic+plot+2CSUNdistr-method'></span><span id='topic+plot+2CSUNdistr+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plotting method for class <code>SUNdistr</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SUNdistr'
plot(x, range, nlevels = 8, levels, npt,  main, comp, compLabs, gap = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SUNdistr-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>SUNdistr</code></p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_range">range</code></td>
<td>
<p>in the univariate case, a vector of length 2 which defines 
the plotting range; in the multivariate case, a matrix with two rows where 
each column defines the plotting range of the corresponding component 
variable. If missing, a sensible choice is made.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_nlevels">nlevels</code></td>
<td>

<p>number of contour levels desired <b>iff</b> levels is not supplied.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_levels">levels</code></td>
<td>
<p>numeric vector of levels at which to draw contour lines.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_npt">npt</code></td>
<td>
<p>a numeric value or vector (in the univariate and in the 
multivariate case, respectively) to assign the number of evaluation points
of the distribution, on an equally-spaced grid over the <code>range</code>
defined above.  Default value: 251 in the univariate case, a vector of
101's in the multivariate case.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_main">main</code></td>
<td>
<p>a character string for main title; if missing, one is built
from the available ingredients.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_comp">comp</code></td>
<td>
<p>an optional integer vector representing the subset of the vector
<code>1:d</code>, if <code>d</code> denotes the dimensionality of the distribution.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_complabs">compLabs</code></td>
<td>
<p>a vector of character strings or expressions used to label
the variables in the plot; 
if missing, <code>slot(object,"compNames")[comp]</code> is used.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_gap">gap</code></td>
<td>
<p>a numeric value which regulates the gap between panels of a
multivariate plot when <code>d&gt;2</code>; default: <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="plot.SUNdistr-method_+3A_...">...</code></td>
<td>
<p>additional graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For univariate density plots, <code>probs</code> are used to compute quantiles
from the appropriate distribution, and these are superimposed to the plot of
the density function, unless <code>probs=NULL</code>. In the multivariate case,
each bivariate plot  is constructed as a collection of contour curves,
one curve for each probability level; consequently, <code>probs</code> cannot be 
missing or <code>NULL</code>. The level of the density contour lines are chosen 
so that each curve circumscribes a region with the  quoted probability, 
to a good degree of approssimation; for additional information, see 
Azzalini and Capitanio (2014), specifically Complement 5.2 and p.179, 
and references therein.</p>


<h3>Value</h3>

<p>an invisible list. In the univariate case the list has three components:
the input object representing the distribution and two numeric vectors with 
the coordinates of the plotted density values. 
In the multivariate case, the first element of the list is the input object 
representing the distribution and all subsequent list elements are lists with 
components of the panels comprising the matrix plot; 
the elements of these sub-lists are: 
the vectors of <code>x</code> and <code>y</code> coordinates, the names of the variables, 
the density values at the <code>(x,y)</code> points, a vector of the density levels 
of the curves appearing in each panel plot.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code>,  <code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- c(1, 0, -1)
Omega &lt;- matrix(c(2,1,1, 1,3,1, 1,1,4), 3, 3)
Delta &lt;- matrix(c(0.72,0.20, 0.51,0.42, 0.88, 0.94), 3, 2, byrow=TRUE)
Gamma &lt;- matrix(c(1, 0.8, 0.8, 1), 2, 2)
dp3 &lt;- list(xi=xi, Omega=Omega, Delta=Delta, tau=c(-0.5, 0), Gamma=Gamma)
sun3 &lt;- makeSUNdistr(dp=dp3, name="SUN3", compNames=c("x", "w", "z"))
plot(sun3, npt=rep(51,3))
p &lt;- plot(sun3, comp=2:3, compLabs=c(expression(x[2]), expression(x[3])))
# str(p)
</code></pre>

<hr>
<h2 id='pprodt2'>
The distribution of the product of two jointly normal or <em>t</em> variables
</h2><span id='topic+pprodt2'></span><span id='topic+qprodt2'></span><span id='topic+pprodn2'></span>

<h3>Description</h3>

<p>Consider the product <code class="reqn">W=X_1 X_2</code> from a bivariate random variable 
<code class="reqn">(X_1, X_2)</code> having joint normal or Student's <em>t</em> distribution, 
with 0 location and unit scale parameters. 
Functions are provided for the distribution function of <code class="reqn">W</code> in the 
normal and the <em>t</em> case, and the quantile function for the <em>t</em> case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pprodn2(x, rho)
pprodt2(x, rho, nu)
qprodt2(p, rho, nu, tol=1e-5, trace=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pprodt2_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="pprodt2_+3A_p">p</code></td>
<td>
<p>a numeric vector of probabilities</p>
</td></tr>
<tr><td><code id="pprodt2_+3A_rho">rho</code></td>
<td>
<p>a scalar value representing the correlation (or the matching
term in the <em>t</em> case when correlation does not exists)</p>
</td></tr>
<tr><td><code id="pprodt2_+3A_nu">nu</code></td>
<td>
<p>a positive scalar representing the degrees of freedom</p>
</td></tr>
<tr><td><code id="pprodt2_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance),
passed to function <code><a href="stats.html#topic+uniroot">uniroot</a></code> </p>
</td></tr>
<tr><td><code id="pprodt2_+3A_trace">trace</code></td>
<td>
<p>integer number for controlling tracing information, 
passed on to <code>uniroot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pprodt2</code> implements formulae in Theorem 1 of Wallgren (1980).
Corresponding quantiles are obtained by <code>qprodt2</code> by solving the 
pertaining non-linear equations with the aid of <code><a href="stats.html#topic+uniroot">uniroot</a></code>,
one such equation for each element of <code>p</code>. 
</p>
<p>Function <code>pprodn2</code> implements results for the central case in
Theorem 1 of Aroian et al. (1978).
</p>


<h3>Value</h3>

<p>a numeric vector</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Aroian, L.A., Taneja, V.S,  &amp;  Cornwell, L.W. (1978).
Mathematical forms of the distribution of the product of two normal variables.
<em>Communications in statistics. Theory and methods</em>, 7, 165-172
</p>
<p>Wallgren, C. M. (1980).
The distribution of the product of two correlated <em>t</em> variates.
<em>Journal of the American Statistical Association</em>, 75, 996-1000
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+uniroot">uniroot</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;-  pprodt2(-3:3, 0.5, 8)
qprodt2(p, 0.5, 8)
</code></pre>

<hr>
<h2 id='predict.selm'>Predict method for selm-class objects</h2><span id='topic+predict.selm'></span><span id='topic+predict.selm-method'></span>

<h3>Description</h3>

<p>Predicted values based on a model object produced by <code>selm</code> with 
univariate response. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'selm'
predict(object, newdata, param.type = "CP",
           interval = "none", level = 0.95, na.action = na.pass, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.selm_+3A_object">object</code></td>
<td>
<p>an object of class <code>selm</code> as produced by a call to
function <code>selm</code> with univariate response.</p>
</td></tr>
<tr><td><code id="predict.selm_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.selm_+3A_param.type">param.type</code></td>
<td>

<p>a character string with the required parameterization; it must be one of
<code>"CP"</code>, <code>"DP"</code>, <code>"pseudo-CP"</code>, or possibly their  
equivalent lowercase.</p>
</td></tr>
<tr><td><code id="predict.selm_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation among <code>"none", "confidence", 
    "prediction"</code>; it can be abbreviated.</p>
</td></tr> 
<tr><td><code id="predict.selm_+3A_level">level</code></td>
<td>
<p>tolerance/confidence level (default value is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="predict.selm_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing 
values in newdata. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.selm_+3A_...">...</code></td>
<td>
<p>not used, only there for compatibility reasons.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Predicted values are obtained by evaluating the regression function in the 
dataframe <code>newdata</code> (which defaults to <code>model.frame(object)</code>).
Setting <code>interval</code> other than <code>"none"</code> produces computation of
confidence or prediction (tolerance) intervals at the specified level.
</p>
<p>If <code>newdata</code> is omitted the predictions are based on the data used for 
the fit.
</p>
<p>The action taken in case of missing data is regulated by argument
<code>na.action</code>, along the lines of function <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.
</p>
<p>A detailed description of the methodology underlying <code>predict.selm</code>
is available in the technical note of Azzalini (2016). 
</p>


<h3>Value</h3>

<p>a vector of predictions  (if <code>interval="none"</code>) or a matrix of
predictions and bounds with column names <code>fit</code>, <code>lwr</code>, and 
<code>upr</code>, if <code>interval</code> is set.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. (2016). 
Derivation of various types of intervals from a <code>selm</code> object.
Technical note distributed with the documentation of the <span class="rlang"><b>R</b></span> package
<code>sn</code>, in file 
<a href="../doc/selm-intervals.pdf"><code>selm-intervals.pdf</code></a> within section 
&lsquo;User guide, package vignettes and other documentation&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code>, <code><a href="#topic+summary.selm">summary.selm</a></code>,
</p>
<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for the <abbr><span class="acronym">CP</span></abbr>/<abbr><span class="acronym">DP</span></abbr> parameterizations,
</p>
<p><code><a href="stats.html#topic+predict.lm">predict.lm</a></code> for usage of <code>na.action</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barolo)
attach(barolo)  
A75 &lt;- (reseller=="A" &amp; volume==75)
detach(barolo)
m3 &lt;- selm(log(price, 10) ~ age, data=barolo[A75,], family="ST")                
</code></pre>

<hr>
<h2 id='profile.selm'>Profile log-likelihood function of selm-class objects</h2><span id='topic+profile.selm'></span><span id='topic+profile.selm-method'></span>

<h3>Description</h3>

<p>One- or two-dimensional profile (penalized) log-likelihood function of a 
<code>selm</code> fit and corresponding confidence interval or regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'selm'
profile(fitted, param.type, param.name, param.values, npt, 
   opt.control = list(), plot.it = TRUE, log = TRUE, levels, 
   trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.selm_+3A_fitted">fitted</code></td>
<td>
<p>an object of class <code>selm</code> as produced by a call to
function <code>selm</code> with univariate response.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_param.type">param.type</code></td>
<td>

<p>a character string with the required parameterization; it must be either
<code>"CP"</code> or <code>"DP"</code>, or possibly their equivalent lowercase.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_param.name">param.name</code></td>
<td>

<p>either a single character string  or a vector of two such terms with the 
name(s) of the parameter(s) for which the profile log-likelihood is 
required; these names must match those appearing in 
<code><a href="#topic+summary.selm">summary.selm</a>(object, param.type)</code>.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_param.values">param.values</code></td>
<td>
<p>in the one-parameter case, a numeric vector with 
the values where the log-likelihood must be evaluated; in the two-parameter
case, a list of two such vectors used to build a  grid of coordinates 
of points. Their range must identify an interval or a rectangle which
includes the <abbr><span class="acronym">MLE</span></abbr> or <abbr><span class="acronym">MPLE</span></abbr> obtained by <code><a href="#topic+selm">selm</a></code>.
See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_npt">npt</code></td>
<td>

<p>in case the vector or any of the vectors of argument <code>param.values</code> 
has length 2, an equally spaced grid of values is build with length equal
to the corresponding component of <code>npt</code>.
If the above condition is met but this argument is missing,  
a default choice is made, namely 51 or (26,26) in the one- or two-parameter
case, respectively.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_opt.control">opt.control</code></td>
<td>

<p>an optional list passed as argument <code>control</code> to <code>optim</code> to
optimize the log-likelihood; see &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_plot.it">plot.it</code></td>
<td>
<p>a logical value; if <code>TRUE</code> (default value), a plot 
is produced representing the deviance, which is described in 
&lsquo;Details&rsquo; below.
In the one-parameter case, a confidence interval of prescribed <code>level</code>
is marked on the plot; in the two-parameter case, the contour curves are
labelled with approximate confidence levels. See however 
for more information.
</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_log">log</code></td>
<td>
<p>a logical value (default: <code>TRUE</code>)  indicating whether the
scale and tail-weight parameter (the latter only for the <abbr><span class="acronym">ST</span></abbr> 
family) must be log-transformed, if case any of them occurs in   
<code>param.name</code>. This applies to <code>omega</code> and 
<code>nu</code> in the <code>DP</code> parameter set and to <code>s.d.</code> and 
<code>gamma2</code> in the <code>CP</code> parameter set.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_levels">levels</code></td>
<td>
<p>a single probability value (in the one-parameter case) or a 
vector of such values (in the two-parameter case) for which the confidence
interval or region is requited; see &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_trace">trace</code></td>
<td>
<p>a logical value (default: <code>FALSE</code>) to activate printing
of intermediate outcome of the log-likelihood optimization process</p>
</td></tr>
<tr><td><code id="profile.selm_+3A_...">...</code></td>
<td>
<p>optional graphical parameters passed to the plotting functions.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>For each chosen point of the parameter(s) to be profiled, the 
log-likelihood is maximized with respect to the remaining parameters.
The optimization process is accomplished using the <code><a href="stats.html#topic+optim">optim</a></code>
optimization function, with <code>method="BFGS"</code>. This step can be regulated by
the user via <code>opt.control</code> which is  passed to <code><a href="stats.html#topic+optim">optim</a></code> 
as <code>control</code> argument, apart from element <code>fnscale</code> whose use is
reserved.
</p>
<p>If the original <code>fitted</code> object included a fixed parameter value, 
this is kept fixed here. If the estimation method was <code>"MPLE"</code>,
that choice carries on here; in case the penalty function was user-defined,
it must still be accessible.
</p>
<p>For plotting purposes and also in the numerical output, the deviance
function <code class="reqn">D</code> is used, namely
</p>
<p style="text-align: center;"><code class="reqn">D = 2\left[\max(\log L) - \log L\right]</code>
</p>

<p>where <code class="reqn">L</code> denotes the likelihood.  
</p>
<p>The range of <code>param.values</code> must enclose the maximum (penalized)
likelihood estimates (<abbr><span class="acronym">MLE</span></abbr> or <abbr><span class="acronym">MPLE</span></abbr>) by an adequate extent 
such that suitable confidence intervals or regions can be established from
standard asymptotic theory. If this condition does not hold, the function
still proceeds, but no confidence interval or region is delivered.
For the <abbr><span class="acronym">SN</span></abbr> family and <abbr><span class="acronym">DP</span></abbr> parameterization, the asymptotic
theory is actually non-standard near the important point <code class="reqn">\alpha=0</code>, 
but the correspondence with the regular case of the <abbr><span class="acronym">CP</span></abbr> 
parameterization, still allows to derive confidence regions using standard
procedures; for additional information, see Section 3.1.6 of
Azzalini and Capitanio (2014).
When the <abbr><span class="acronym">MLE</span></abbr> occurs on the frontier of the parameter space, 
a message is issued and no confidence interval is produced, while in the
two-parameter case the plot is not labelled with probability values, but only
with deviance levels.
</p>


<h3>Value</h3>

<p>An invisible list whose components, described below, are partly 
different in the one- and the two-parameter cases.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the calling statement</p>
</td></tr>
<tr><td><code>&lt;param1&gt;</code></td>
<td>
<p>values of the first parameter</p>
</td></tr>
<tr><td><code>&lt;param2&gt;</code></td>
<td>
<p>values of the second parameter (in the two-parameter case)</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>numeric vector or matrix of the profile log-likelihood values</p>
</td></tr>
<tr><td><code>confint</code></td>
<td>
<p>in the one-parameter case, the confidence interval</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>in the one-parameter case, the confidence level</p>
</td></tr>
<tr><td><code>deviance.contour</code></td>
<td>
<p>in the two-parameter case, a list of lists whose
elements identify each curve of the contour plot</p>
</td></tr>
</table>


<h3>Warnings</h3>


<ul>
<li><p> This function is experimental and changes in future versions
of the package may occur. Users should not rely on the persistence of the 
same user interface or the same name(s).
</p>
</li>
<li><p> It is a known fact that, in some critical situations, peculiar outcomes
are produced.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code>, <code><a href="#topic+summary.selm">summary.selm</a></code>,
</p>
<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for the <abbr><span class="acronym">CP</span></abbr>/<abbr><span class="acronym">DP</span></abbr> parameterizations,
</p>
<p><code><a href="stats.html#topic+optim">optim</a></code> for its <code>control</code> argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais, package="sn")
m1 &lt;-  selm(log(Fe) ~ BMI + LBM, family = "sn", data = ais)

pll &lt;- profile(m1, "dp", param.name="alpha", param.val=c(-3,2))

profile(m1, "cp", param.name="gamma1", param.val=seq(-0.7, 0.4, by=0.1))

# in the next example, we reduce the grid points to save execution time
pll &lt;- profile(m1, "cp", param.name=c("(Intercept.CP)", "gamma1"),
           param.val = list(c(1.5, 4), c(-0.8, 0.5)), npt=c(11,11) )
</code></pre>

<hr>
<h2 id='Qpenalty'>Penalty function for log-likelihood of <code>selm</code> models</h2><span id='topic+Qpenalty'></span><span id='topic+MPpenalty'></span>

<h3>Description</h3>

<p>Penalty function for the log-likelihood of <code>selm</code> models 
when <code>method="MPLE"</code>. <code>Qpenalty</code> is the default function;
<code>MPpenalty</code> is an example of a user-defined function effectively
corresponding to a prior distributio on <code>alpha</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>Qpenalty(alpha_etc, nu = NULL, der = 0)

MPpenalty(alpha, der = 0)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qpenalty_+3A_alpha_etc">alpha_etc</code>, <code id="Qpenalty_+3A_alpha">alpha</code></td>
<td>
<p>in the univariate case, a single value <code>alpha</code>; 
in the multivariate case, a two-component list whose first component is 
the vector <code>alpha</code>, the second one is matrix <code>cov2cor(Omega)</code>. </p>
</td></tr>
<tr><td><code id="Qpenalty_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom, only required if <code>selm</code> is called
with <code>family="ST"</code>. </p>
</td></tr>
<tr><td><code id="Qpenalty_+3A_der">der</code></td>
<td>
<p>a numeric value in the set <kbd>0,1,2</kbd> which indicates the
required numer of derivatives of the function. In the multivariate case
the function will only be called with <code>der</code> equal to 0 or 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The penalty is a function of <code>alpha</code>, but its expression may
depend on other ingredients, specifically <code>nu</code> and <code>cov2cor(Omega)</code>.
See &lsquo;Details&rsquo; of <code><a href="#topic+selm">selm</a></code> for additional information.
</p>
<p>The penalty mechanism allows to introduce a prior distribution <code class="reqn">\pi</code> 
for <code class="reqn">\alpha</code> by setting <code class="reqn">Q=-\log\pi</code>, 
leading to a maximum <em>a posteriori</em> estimate in the stated sense. 
</p>
<p>As a simple illustration of this mechanism, function <code>MPpenalty</code>
implements the &lsquo;matching prior&rsquo; distribution for the univariate <abbr><span class="acronym">SN</span></abbr>
distribution studied by Cabras <em>et al.</em> (2012); a brief summary of the
proposal is provided in Section 3.2 of Azzalini and Capitanio (2014). Note
that, besides <code>alpha=+/-Inf</code>, this choice also penalizes <code>alpha=0</code>
with <code>Q=Inf</code>, effectively removing <code>alpha=0</code> from the parameter
space.  
</p>
<p>Starting from the code of function <code>MPpenalty</code>, a user should be able 
to introduce an alternative prior distribution if so desired.
</p>


<h3>Value</h3>

<p>A positive number <code>Q</code> representing the penalty, possibly
with attributes <code>attr(Q, "der1")</code> and <code>attr(Q, "der2")</code>, 
depending onthe input value <code>der</code>.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Cabras, S., Racugno, W., Castellanos, M. E., and Ventura, L. (2012).
A matching prior for the shape parameter of the skew-normal distribution.
<em>Scand. J. Statist.</em> <b>39</b>, 236&ndash;247.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code> function</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(frontier)
m2 &lt;- selm(frontier ~ 1)  # no penalty
m2a &lt;- selm(frontier ~ 1, method="MPLE") # penalty="Qpenalty" is implied here
m2b &lt;- selm(frontier ~ 1, method="MPLE", penalty="MPpenalty")    
</code></pre>

<hr>
<h2 id='residuals.selm'>Residuals and fitted values from <code>selm</code> fits</h2><span id='topic+residuals.selm'></span><span id='topic+residuals.mselm'></span><span id='topic+residuals+2Cselm-method'></span><span id='topic+residuals+2Cmselm-method'></span><span id='topic+fitted.selm'></span><span id='topic+fitted.mselm'></span><span id='topic+fitted+2Cselm-method'></span><span id='topic+fitted+2Cmselm-method'></span>

<h3>Description</h3>

<p><code>residuals</code> and <code>fitted</code> methods for classes <code>"selm"</code> and 
<code>"mselm"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'selm'
residuals(object, param.type = "CP", ...)
## S4 method for signature 'mselm'
residuals(object, param.type = "CP", ...)
## S4 method for signature 'selm'
fitted(object, param.type = "CP", ...)
## S4 method for signature 'mselm'
fitted(object, param.type = "CP", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.selm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"selm"</code> or <code>"mselm"</code> as created
by a call to function <code>selm</code>.</p>
</td></tr>
<tr><td><code id="residuals.selm_+3A_param.type">param.type</code></td>
<td>
<p>a character string which indicates the required type of 
parameter type; possible values are <code>"CP"</code> (default), <code>"DP"</code>,
<code>"pseudo-CP"</code> and their equivalent lower-case  expressions.</p>
</td></tr>
<tr><td><code id="residuals.selm_+3A_...">...</code></td>
<td>
<p>not used, included for compatibility with the generic method.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>a numeric vector (for <code>selm-class</code> objects) or a matrix
(for <code>mselm-class</code> objects). </p>


<h3>Note</h3>

<p>The possible options of <code>param.type</code> are described in the
documentation of <code><a href="#topic+dp2cp">dp2cp</a></code>; their corresponding outcomes 
differ by an additive constant only. With the <code>"CP"</code> option (that is,
the &lsquo;centred parametrization&rsquo;), the residuals are centred around 0, 
at least approximately; this is a reason for setting <code>"CP"</code> as the 
default option. For more information, see  the &lsquo;Note&rsquo; in the 
documentation of <code><a href="#topic+summary.selm">summary.selm</a></code>. </p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dp2cp">dp2cp</a></code>, <code><a href="#topic+summary.selm">summary.selm</a></code>, 
<code><a href="#topic+selm">selm</a></code> function, <code><a href="#topic+selm-class">selm</a>-class</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(wines, package="sn")
m5 &lt;- selm(acidity ~ phenols + wine, family="SN", data=wines)
residuals(m5)
residuals(m5, "dp")
fitted(m5, "dp")
#
m12 &lt;- selm(cbind(acidity, alcohol) ~ phenols + wine,  family="SN", data=wines)
residuals(m12)
#
# see other examples at function selm
</code></pre>

<hr>
<h2 id='sd'>Standard deviation</h2><span id='topic+sd'></span><span id='topic+sd.default'></span>

<h3>Description</h3>

<p>The <code>sd</code> function from the <span class="pkg">stats</span> is replaced by a new <code>method</code> 
in order to introduce a separate method to deal with objects of class
<code>SECdistrUv</code>. The function <code>sd.default</code> is an alias of the original
function <code><a href="stats.html#topic+sd">sd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sd(x, ...)
  ## Default S3 method:
sd(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="sd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="sd_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="#topic+SECdistrUv-class">SECdistrUv</a></code> 
</p>

<hr>
<h2 id='SECdistrMv-class'>Class <code>"SECdistrMv"</code></h2><span id='topic+SECdistrMv-class'></span><span id='topic+show+2CSECdistrMv-method'></span><span id='topic+mean+2CSECdistrMv-method'></span><span id='topic+vcov+2CSECdistrMv-method'></span>

<h3>Description</h3>

<p>A class of objects representing multivariate skew-elliptically 
contoured (<abbr><span class="acronym">SEC</span></abbr>) distributions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by a call to function <code><a href="#topic+makeSECdistr">makeSECdistr</a></code>,
when its argument <code>dp</code> is a list, or by a suitable transformation of 
some object of this class. They can also obtained from an object generated
by  <code>selm</code> using the function <code>extractSEDdistr</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>family</code>:</dt><dd><p>a character string which identifies the parametric
family; currently, possible values are: <kbd>"SN"</kbd>, <kbd>"ESN"</kbd>, 
<kbd>"ST"</kbd>, <kbd>"SC"</kbd>.</p>
</dd>
<dt><code>dp</code>:</dt><dd><p>a list of parameters; its length depends on 
the selected  <code>family</code>.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>a character string with the name of the multivariate
variable; it can be an empty string.</p>
</dd>
<dt><code>compNames</code>:</dt><dd><p>a vector of character strings with the names of 
the component variables.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "SECdistrMv-class")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SECdistrMv-class")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SECdistrMv-class")</code>: ... </p>
</dd>
<dt>mean</dt><dd><p><code>signature(x = "SECdistrMv")</code>: ...</p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "SECdistrMv")</code>: ...</p>
</dd>
</dl>



<h3>Note</h3>

<p>See <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for a detailed description of 
<code>family</code> and <code>dp</code>.
</p>
<p>Note that  here methods <code>mean</code> and <code>vcov</code>  are not applied
to data or to a fitted model, but to a <em>probability
distribution</em> instead,  of which they provide the mean (vector) value
and the variance-covariance matrix.  If methods <code>mean</code> and <code>vcov</code> 
are applied to a distribution for which the mean or the variance do
not exist, a <code>NULL</code> value is returned and a warning message
is issued.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+SECdistrUv-class">SECdistrUv</a></code>,  
<code><a href="#topic+plot+2CSECdistrMv-method">plot,SECdistrMv-method</a></code>, 
<code><a href="#topic+summary+2CSECdistrMv-method">summary,SECdistrMv-method</a></code>,
<code><a href="#topic+affineTransSECdistr">affineTransSECdistr</a></code>,  <code><a href="#topic+marginalSECdistr">marginalSECdistr</a></code>,
<code><a href="#topic+extractSECdistr">extractSECdistr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dp0 &lt;- list(xi=1:2, Omega=diag(3:4), alpha=c(3, -5))
  f10 &lt;- makeSECdistr(dp=dp0, family="SN", name="SN-2D", compNames=c("x", "y"))
  show(f10)
  plot(f10)
  summary(f10)
  mean(f10)  # the mean value of the probability distribution
  vcov(f10)  # the variance-covariance matrix of the probability distribution
</code></pre>

<hr>
<h2 id='SECdistrUv-class'>Class <code>"SECdistrUv"</code></h2><span id='topic+SECdistrUv-class'></span><span id='topic+show+2CSECdistrUv-method'></span><span id='topic+mean+2CSECdistrUv-method'></span><span id='topic+sd+2CSECdistrUv-method'></span>

<h3>Description</h3>

<p>A class of objects representing univariate skew-elliptically
contoured (<abbr><span class="acronym">SEC</span></abbr>) distributions.</p>


<h3>Objects from the class</h3>

<p>Objects can be created by a call to function <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> 
when its argument <code>dp</code> is a vector. They can also obtained from
an object generated by <code>selm</code> using the function <code>extractSEDdistr</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>family</code>:</dt><dd><p>a character string which selects the parametric
family; currently, possible values are: <kbd>"SN"</kbd>, <kbd>"ESN"</kbd>, 
<kbd>"ST"</kbd>, <kbd>"SC"</kbd>. </p>
</dd>
<dt><code>dp</code>:</dt><dd><p>a numeric vector of parameters; its length depends 
on the selected <code>family</code>.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>a character string with name of the distribution.</p>
</dd>
</dl>



<h3>Methods</h3>

   
<dl>
<dt>show</dt><dd><p><code>signature(object = "SECdistrUv")</code>: ...</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SECdistrUv")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SECdistrUv")</code>: ...</p>
</dd>
<dt>mean</dt><dd><p><code>signature(x = "SECdistrUv")</code>: ...</p>
</dd>
<dt>sd</dt><dd><p><code>signature(object = "SECdistrUv")</code>: ...</p>
</dd>
</dl>



<h3>Note</h3>

<p>See <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for a detailed description of <code>family</code> 
and <code>dp</code>. 
</p>
<p>Unlike various other packages, methods <code>mean</code> and <code>sd</code> here are 
not targeted to data or to a fitted model, but to a <em>probability
distribution</em> instead, of which they provide the mean value
and the standard deviation.   If these methods  are applied
to a distribution of which the mean or the variance do not exist, 
a <code>NULL</code> value is returned and a warning message is issued.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+SECdistrMv-class">SECdistrMv</a></code>,
<code><a href="#topic+plot+2CSECdistrUv-method">plot,SECdistrUv-method</a></code>, 
<code><a href="#topic+summary+2CSECdistrUv-method">summary,SECdistrUv-method</a></code>,
<code><a href="#topic+extractSECdistr">extractSECdistr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f2 &lt;- makeSECdistr(dp=c(3, 5, -pi, 6), family="ST", name="My first ST")
show(f2)
plot(f2)
plot(f2, probs=c(1,5,9)/10)
plot(f2, range=c(-30,10), probs=NULL, col=2, main=NULL)
summary(f2)
mean(f2)  # the mean value of the probability distribution
sd(f2)  # the standard deviation of the distribution  
</code></pre>

<hr>
<h2 id='selm'>Fitting linear models with skew-elliptical error term</h2><span id='topic+selm'></span>

<h3>Description</h3>

<p>Function <code>selm</code> fits a <code>l</code>inear <code>m</code>odel
with <code>s</code>kew-<code>e</code>lliptical error term. 
The term &lsquo;skew-elliptical distribution&rsquo; is an abbreviated equivalent 
of skew-elliptically contoured (<abbr><span class="acronym">SEC</span></abbr>) distribution.
The function works for univariate and multivariate response variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>selm(formula, family = "SN", data, weights, subset, na.action, 
  start = NULL, fixed.param = list(), method = "MLE",  penalty=NULL, 
  model = TRUE, x = FALSE, y = FALSE, contrasts = NULL, offset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> 
(or one that can be coerced to that class): a symbolic description of the
model to be fitted, using the same syntax used for the similar parameter of
e.g. <code>"<a href="stats.html#topic+lm">lm</a>"</code>, with the restriction that the constant
term must not be removed from the linear predictor. 

</p>
</td></tr>
<tr><td><code id="selm_+3A_family">family</code></td>
<td>
<p>a character string which selects the parametric family
of <abbr><span class="acronym">SEC</span></abbr> type  assumed for the error term. It must be one of
<code>"SN"</code> (default), <code>"ST"</code> or <code>"SC"</code>, which correspond to the
skew-normal, the skew-<em>t</em> and the skew-Cauchy family, respectively.
See <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for more information on these families and
the set of <abbr><span class="acronym">SEC</span></abbr> distributions; notice that the family <code>"ESN"</code> 
listed there is not allowed here.</p>
</td></tr>
<tr><td><code id="selm_+3A_data">data</code></td>
<td>
<p>an optional data frame  containing the variables in
the model.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>selm</code> is called.</p>
</td></tr>
<tr><td><code id="selm_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights associated to  individual
observations. Weights are supposed to represent frequencies, hence must be
non-negative integers (not all 0) and <code>length(weights)</code> must equal the
number of observations. If not assigned, a vector of all 1's is generated.</p>
</td></tr>
<tr><td><code id="selm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process. It works like the same parameter
in <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="selm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by the
<code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>.  
The &lsquo;factory-fresh&rsquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  
Another possible value is <code>NULL</code>, no action.  

</p>
</td></tr>
<tr><td><code id="selm_+3A_start">start</code></td>
<td>
<p>a vector (in the univariate case) or a list (in the  
multivariate case) of initial <abbr><span class="acronym">DP</span></abbr> values for searching the 
parameter estimates. See &lsquo;Details&rsquo; about a choice of
<kbd>start</kbd> to be avoided.  If <code>start=NULL</code> (default), 
initial values are  selected by the procedure.
If <code>family="ST"</code>, an additional option exists; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="selm_+3A_fixed.param">fixed.param</code></td>
<td>
<p>a list of assignments of parameter values which must
be kept fixed in the estimation process. 
Currently, there only two types of admissible constraint: one is to
set <code>alpha=0</code> to impose a symmetry condition of the distribution; 
the other is to set <code>nu=&lt;value&gt;</code>, to fix the degrees of freedom  
at the named <code>&lt;value&gt;</code> when <code>family="ST"</code>, for instance
<code>list(nu=3)</code>.  See &lsquo;Details&rsquo; for additional information.
</p>
</td></tr>
<tr><td><code id="selm_+3A_method">method</code></td>
<td>
<p>a character string which selects the estimation method to be
used for fitting. Currently, two options exist: <code>"MLE"</code> (default) and
<code>"MPLE"</code>, corresponding to standard maximum likelihood and maximum
penalized likelihood estimation, respectively. See &lsquo;Details&rsquo; for
additional information.  </p>
</td></tr>
<tr><td><code id="selm_+3A_penalty">penalty</code></td>
<td>
<p>a character string which denotes the penalty function to be
subtracted to the log-likelihood function, when <code>method="MPLE"</code>; if
<code>penalty=NULL</code> (default), a pre-defined function is adopted. See
&lsquo;Details&rsquo; for a description of the default penalty function and for
the expected format of alternative specifications.  When
<code>method="MLE"</code>, no penalization is applied and this argument has no
effect.</p>
</td></tr>
<tr><td><code id="selm_+3A_model">model</code>, <code id="selm_+3A_x">x</code>, <code id="selm_+3A_y">y</code></td>
<td>
<p>logicals.  If <code>TRUE</code>, the corresponding components
of the fit are returned.</p>
</td></tr>
<tr><td><code id="selm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="selm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the number of
cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the
formula instead or as well, and if more than one are specified their sum 
is used. </p>
</td></tr>
<tr><td><code id="selm_+3A_...">...</code></td>
<td>
<p>optional control parameters, as follows.
</p>

<ul>
<li> <p><code>trace</code>: a logical value which indicates whether intermediate
evaluations of the optimization process are printed (default:
<code>FALSE</code>).
</p>
</li>
<li> <p><code>info.type</code>: a character string which indicates the type of
Fisher information matrix; possible values are <code>"observed"</code>
(default) and <code>"expected"</code>. Currently, <code>"expected"</code> is
implemented only for the <abbr><span class="acronym">SN</span></abbr> family.
</p>
</li>
<li> <p><code>opt.method</code>: a character string which selects the numerical
optimization method, among the possible values 
<code>"nlminb", "Nelder-Mead", "BFGS", "CG", "SANN"</code>. 
If <code>opt.method="nlminb"</code> (default),
function <code><a href="stats.html#topic+nlminb">nlminb</a></code> is called, 
otherwise function <code><a href="stats.html#topic+optim">optim</a></code> is called with 
<code>method</code> equal to <code>opt.method</code>.
</p>
</li>
<li> <p><code>opt.control</code>: a list of control parameters which is passed on
either to <code>nlminb</code> or to <code>optim</code>, depending on the chosen
<code>opt.method</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>selm</code> fits the selected model by maximum
likelihood estimation (<abbr><span class="acronym">MLE</span></abbr>), making use of some numerical
optimization method.  Maximization is performed in one
parameterization, usually <abbr><span class="acronym">DP</span></abbr>, and then the estimates are mapped to
other parameter sets, <abbr><span class="acronym">CP</span></abbr> and pseudo-<abbr><span class="acronym">CP</span></abbr>; 
see <code><a href="#topic+dp2cp">dp2cp</a></code> for more information on parameterizations. 
These parameter transformations are carried out trasparently to the user. 
The observed information matrix is used to obtain the estimated variance 
matrix of the <abbr><span class="acronym">MLE</span></abbr>'s and from this the standard errors.  
Background information on <abbr><span class="acronym">MLE</span></abbr> in the context of <abbr><span class="acronym">SEC</span></abbr> 
distributions is provided by Azzalini and Capitanio (2014); 
see specifically Chapter 3, Sections 4.3, 5.2,  6.2.5&ndash;6. For additional
information, see the original research work referenced therein as well as
the sources quoted below.
</p>
<p>Although the density functionof SEC distributions are expressed using
<abbr><span class="acronym">DP</span></abbr> parameter sets, the methods associated to the objects created
by this function communicate, by default, their outcomes in the <abbr><span class="acronym">CP</span></abbr>
parameter set, or its variant form pseudo-<abbr><span class="acronym">CP</span></abbr> when <abbr><span class="acronym">CP</span></abbr>
does not exist; the &lsquo;Note&rsquo; at <code><a href="#topic+summary.selm">summary.selm</a></code> explains why. 
A more detailed discussion  is provided by Azzalini and Capitanio 
(1999,  Section 5.2) and Arellano-Valle and  Azzalini (2008, Section 4), 
for the univariate and the multivariate SN case, respectively; 
an abriged account is available in Sections 3.1.4&ndash;6 and 5.2.3 of 
Azzalini and Capitanio (2014). For the ST case, see Arellano-Valle 
and  Azzalini (2013).
</p>
<p>There is a known open issue which affects computation of the information
matrix of the multivariate skew-normal distribution when the slant
parameter <code class="reqn">\alpha</code> approaches the null vector; see p.149 of
Azzalini and Capitanio (2014). Consequently, if a model with
multivariate response is fitted with <code>family="SN"</code> and the estimate
<code>alpha</code> of <code class="reqn">\alpha</code> is at the origin or neary so, the
information matrix and the standard errors are not computed and a
warning message is issued. In this unusual circumstance, a simple
work-around is to re-fit the model with <code>family="ST"</code>, which will
work except in remote cases when (i) the estimated degrees of freedom
<code>nu</code> diverge and (ii) still <code>alpha</code> remains at the origin.
</p>
<p>The optional argument <code>fixed.param=list(alpha=0)</code> imposes the
constraint <code class="reqn">\alpha=0</code> in the estimation process; in the multivariate 
case, the expression is interpreted in the sense that all the components  
of vector <code class="reqn">\alpha</code> are zero, which implies symmetry of the
error distribution, irrespectively of the parameterization 
subsequently adopted for summaries and diagnostics.
When this restriction is selected, the estimation method cannot be
set to <code>"MPLE"</code>. Under the constraint <code class="reqn">\alpha=0</code>,
if <code>family="SN"</code>, the model is  fitted similarly to <code>lm</code>, except
that here <abbr><span class="acronym">MLE</span></abbr> is used for estimation of the covariance matrix. 
If <code>family="ST"</code> or <code>family="SC"</code>, a symmetric Student's <code class="reqn">t</code> 
or Cauchy distribution is adopted. 
</p>
<p>Under the constraint <code class="reqn">\alpha=0</code>, the location parameter <code class="reqn">\xi</code>
coincides with the mode and the mean of the distribution, when the latter
exists. In addition, when the covariance matrix of a <abbr><span class="acronym">ST</span></abbr>
distribution exists, it differs from <code class="reqn">\Omega</code> only by a multiplicative
factor. Consequently, the summaries of a model of this sort automatically
adopt the <abbr><span class="acronym">DP</span></abbr> parametrization.
</p>
<p>The other possible form of constraint allows to fix the degrees of
freedom when <code>family="ST"</code>. The two constraints can be combined 
writing, for instance,  <code>fixed.param=list(alpha=0, nu=6)</code>.
The constraint <code>nu=1</code> is equivalent to select <code>family="SC"</code>.
In practice, an expression of type <code>fixed.param=list(..)</code> can be
abbreviated to <code>fixed=list(..)</code>.
</p>
<p>Argument <kbd>start</kbd> allows to set the initial values, with respect to the
<abbr><span class="acronym">DP</span></abbr> parameterization, of the numerical optimization. 
However, there is a specific choice of start to be avoided.
When <kbd>family="SN"</kbd>, do not set the shape parameter <kbd>alpha</kbd> 
exactly at 0, as this would blow-up computation of the log-likelihood 
gradient and the Hessian matrix. This is not due to a software bug, 
but to a known peculiar behaviour of the log-likelihood  function at 
that specific point. Therefore, in the univariate case for instance, 
do not set e.g. <kbd>start=c(12, 21, 0)</kbd>, but set instead something
like <kbd>start=c(12, 21, 0.01)</kbd>. 




Recall that, if one needs to fit a model forcing 0 asymmetry, typically to
compare two log-likelihood functions with/without asymmetry, then the option
to use is <kbd>fixed.param=list(alpha=0)</kbd>.
</p>
<p>Since version 1.6.0, a new initialization procedure has been introduced
for the case <kbd>family="ST"</kbd>, which adopts the method proposed by 
Azzalini &amp; Salehi (2020), implemented in functions <kbd>st.prelimFit</kbd> 
and <kbd>mst.prelimFit</kbd>.
Correspondingly, the <kbd>start</kbd> argument can now be of different type,
namely a character with possible values <kbd>"M0"</kbd>, <kbd>"M2"</kbd> (detault in 
the univariate case) and <kbd>"M3"</kbd> (detault in the multivariate case).
The choice <kbd>"M0"</kbd> selects the older method, in use prior to version
1.6.0. For more information, see Azzalini &amp;  Salehi (2020).
</p>
<p>In some cases, especially for small sample size, the <abbr><span class="acronym">MLE</span></abbr> occurs on
the frontier of the parameter space, leading to <abbr><span class="acronym">DP</span></abbr> estimates with
<code>abs(alpha)=Inf</code> or to a similar situation in the multivariate case 
or in an alternative parameterization. Such outcome is regared by many as
unsatisfactory; surely it prevents using the observed information matrix to
compute standard errors. This problem motivates the use of maximum penalized
likelihood estimation (<abbr><span class="acronym">MPLE</span></abbr>), where the regular log-likelihood
function <code class="reqn">\log~L</code> is penalized by subtracting an amount
<code class="reqn">Q</code>, say, increasingly large as <code class="reqn">|\alpha|</code> increases. 
Hence the function which is maximized at the optimization stage is now
<code class="reqn">\log\,L~-~Q</code>.  If <code>method="MPLE"</code> and
<code>penalty=NULL</code>, the default function <code>Qpenalty</code> is used,
which implements the penalization:
</p>
<p style="text-align: center;"><code class="reqn">Q(\alpha) = c_1 \log(1 + c_2 \alpha_*^2)</code>
</p>

<p>where <code class="reqn">c_1</code> and <code class="reqn">c_2</code> are positive constants, which
depend on the degrees of freedom <code>nu</code> in the <code>ST</code> case,
</p>
<p style="text-align: center;"><code class="reqn">\alpha_*^2 = \alpha^\top \bar\Omega \alpha</code>
</p>

<p>and <code class="reqn">\bar\Omega</code> denotes the correlation matrix 
associated to the scale matrix <code>Omega</code> described in connection with
<code><a href="#topic+makeSECdistr">makeSECdistr</a></code>. In the univariate case 
<code class="reqn">\bar\Omega=1</code>,
so that <code class="reqn">\alpha_*^2=\alpha^2</code>. Further information 
on <abbr><span class="acronym">MPLE</span></abbr> and this choice of the penalty function is given in 
Section 3.1.8 and p.111 of Azzalini and Capitanio (2014); for a more 
detailed account, see Azzalini and Arellano-Valle (2013) and references  
therein.
</p>
<p>It is possible to change the penalty function, to be declared via the 
argument <code>penalty</code>. For instance, if the calling statement includes 
<code>penalty="anotherQ"</code>, the user must have defined  
</p>
<p><code style="white-space: pre;">&#8288;    &#8288;</code><code>anotherQ &lt;- function(alpha_etc, nu = NULL, der = 0)</code>
</p>
<p>with the following arguments.
</p>

<ul>
<li> <p><code>alpha_etc</code>: in the univariate case, a single value <code>alpha</code>;
in the multivariate case, a two-component list whose first component is
the vector <code>alpha</code>, the second one is matrix equal to
<code>cov2cor(Omega)</code>.

</p>
</li>
<li> <p><code>nu</code>: degrees of freedom, only relevant if <code>family="ST"</code>.
</p>
</li>
<li> <p><code>der</code>: a numeric value which indicates the required order of
derivation; if <code>der=0</code> (default value), only the penalty <code>Q</code>
needs to be retuned by the function; 
if <code>der=1</code>, <code>attr(Q, "der1")</code> must represent the
first order derivative of <code>Q</code> with respect to <code>alpha</code>; if
<code>der=2</code>, also <code>attr(Q, "der2")</code> must be assigned, containing
the second derivative (only required in the univariate case).
</p>
</li></ul>

<p>This function must return a single numeric value, possibly with required
attributes when is called with <code>der&gt;1</code>.
Since <span class="pkg">sn</span> imports functions <code><a href="numDeriv.html#topic+grad">grad</a></code> and 
<code><a href="numDeriv.html#topic+hessian">hessian</a></code> from package <span class="pkg">numDeriv</span>, one can rely 
on them for numerical evaluation of the derivatives, if they are not 
available in an explicit form.
</p>
<p>This penalization scheme allows to introduce a prior distribution 
<code class="reqn">\pi</code> for <code class="reqn">\alpha</code> by setting <code class="reqn">Q=-\log\pi</code>, 
leading to a maximum <em>a posteriori</em> estimate in the stated sense. 
See <code><a href="#topic+Qpenalty">Qpenalty</a></code> for more information and an illustration.
</p>
<p>The actual computations are not performed within <code>selm</code> which only 
sets-up ingredients for work of <code><a href="#topic+selm.fit">selm.fit</a></code> and other functions
further below this one.  See <code><a href="#topic+selm.fit">selm.fit</a></code> for more information.
</p>


<h3>Value</h3>

<p>an S4 object of class <code>selm</code> or <code>mselm</code>, depending on whether
the response variable of the fitted model is univariate or multivariate;
these objects are described in the <code><a href="#topic+selm-class">selm</a> class</code>.
</p>


<h3>Cautionary notes</h3>

<p>The first of these notes applies to the stage <em>preceding</em> the
use of <kbd>selm</kbd> and related fitting procedures. Before fitting a model of
this sort, consider whether you have enough data for this task. 
In this respect, the passage below taken from p.63 of Azzalini 
and Capitanio (2014) is relevant.
</p>
<p>&ldquo;Before entering technical aspects, it is advisable to underline 
a qualitative effect of working with a parametric family which effectively 
is regulated by moments up to the third order. 
The implication is that the traditional rule of thumb by which a sample 
size is small up to ‘about <code class="reqn">n = 30</code>’, and then starts to become ‘large’,
while sensible for a normal population or other two-parameter distribution, 
is not really appropriate here. 
To give an indication of a new threshold is especially difficult, 
because the value of  <code class="reqn">\alpha</code> also has a role here. 
Under this <em>caveat</em>, numerical experience suggests that ‘about 
<code class="reqn">n = 50</code>’ may be a more appropriate guideline in this context.&rdquo;
</p>
<p>The above passage referred to the univariate SN context. 
In the multivariate case, increase the sample size appropriately, 
especially so with the <abbr><span class="acronym">ST</span></abbr> family.
This is not to say that one cannot attempt fitting these models 
with small or moderate sample size. However, one must be aware of the 
implications and not be surprised if problems appear.
</p>
<p>The second cautionary note refers instead to the outcome of a call to 
<kbd>selm</kbd> and related function, or the lack of it.
The estimates are obtained by numerical optimization methods and, as
usual in similar cases, there is no guarantee that the maximum of the
objective function is achieved. Consideration of model simplicity
and of numerical experience indicate that models with <abbr><span class="acronym">SN</span></abbr> error
terms generally produce more reliable results compared to those with 
the <abbr><span class="acronym">ST</span></abbr> family. Take into account that models involving a 
traditional Student's <code class="reqn">t</code> distribution with unknown degrees of freedom 
can already be problematic; the presence of the (multivariate) slant parameter
<code class="reqn">\alpha</code> in the <abbr><span class="acronym">ST</span></abbr> family cannot make things any simpler. 
Consequently, care must be exercised, especially so if one works with 
the (multivariate) <abbr><span class="acronym">ST</span></abbr> family. 
Consider re-fitting a model with different starting values and, 
in the <abbr><span class="acronym">ST</span></abbr> case, building the profile log-likelihood for a range 
of <code class="reqn">\nu</code> values; function <code><a href="#topic+profile.selm">profile.selm</a></code> can be useful here.
</p>
<p>Details on the numerical optimization which has produced object <code>obj</code> 
can be extracted with <code>slot(obj, "opt.method")</code>; inspection of this
component can be useful in problematic cases.
# Be aware that  occasionally <code>optim</code> and <code>nlminb</code> declare successful
# completion of a regular minimization problem at a point where the Hessian 
# matrix is not positive-definite. 
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B., and Azzalini, A. (2008).
The centred parametrization for the multivariate skew-normal distribution.
<em>J. Multiv. Anal.</em> <b>99</b>, 1362&ndash;1382.
Corrigendum: <b>100</b> (2009), 816.
</p>
<p>Arellano-Valle, R. B., and Azzalini, A. (2013, available online 12 June 2011).
The centred parametrization and related quantities for the  skew-<em>t</em> 
distribution.
<em>J. Multiv. Anal.</em> <b>113</b>, 73&ndash;90. 
</p>
<p>Azzalini, A. and Capitanio, A. (1999).
Statistical applications of the multivariate skew normal distribution.
<em>J.Roy.Statist.Soc. B</em> <b>61</b>, 579&ndash;602. 
Full-length version available at <a href="https://arXiv.org/abs/0911.2093">https://arXiv.org/abs/0911.2093</a>
</p>
<p>Azzalini, A. and Arellano-Valle, R. B. (2013, available online 30 June 2012). 
Maximum penalized likelihood estimation for skew-normal and skew-<em>t</em> 
distributions. <em>J. Stat. Planning &amp; Inference</em> <b>143</b>, 419&ndash;433. 
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Azzalini, A. and Salehi, M. (2020).
Some computational aspects of maximum likelihood estimation 
of the skew-<em>t</em> distribution. In <em>Computational and Methodological 
Statistics and Biostatistics</em>, edited by A. Bekker, Ding-Geng Chen and 
Johannes T. Ferreira, pp.3-28.  Springer Nature Switzerland.
</p>


<h3>See Also</h3>


<ul>
<li>
<p><code><a href="#topic+selm-class">selm</a>-class</code> for classes <code>"selm"</code> and <code>"mselm"</code>,
<code><a href="#topic+summary.selm">summary.selm</a></code> for summaries, <code><a href="#topic+plot.selm">plot.selm</a></code> for plots,
<code><a href="#topic+residuals.selm">residuals.selm</a></code> for residuals and fitted values
</p>
</li>
<li>
<p>the generic functions <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+profile">profile</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, 
<code><a href="stats.html#topic+predict">predict</a></code>
</p>
</li>
<li>
<p>the underlying function <code><a href="#topic+selm.fit">selm.fit</a></code> and those further down
</p>
</li>
<li>
<p>the selection of a penalty function of the log-likelihood, 
such as <code><a href="#topic+Qpenalty">Qpenalty</a></code>
</p>
</li>
<li>
<p>the function <code><a href="#topic+extractSECdistr">extractSECdistr</a></code> to extract the <abbr><span class="acronym">SEC</span></abbr>
error distribution from an object returned by <code>selm</code> 
</p>
</li>
<li><p> the broad underlying logic and a number of ingredients are like in 
function <code><a href="stats.html#topic+lm">lm</a></code>  
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
m1 &lt;- selm(log(Fe) ~ BMI + LBM, family="SN", data=ais)
print(m1)
summary(m1)
s &lt;- summary(m1, "DP", cov=TRUE, cor=TRUE)
plot(m1)
plot(m1, param.type="DP")
logLik(m1)
coef(m1)
coef(m1, "DP")
var &lt;- vcov(m1)
#
m1a &lt;- selm(log(Fe) ~ BMI + LBM, family="SN", method="MPLE", data=ais)
m1b &lt;- selm(log(Fe) ~ BMI + LBM, family="ST", fixed.param=list(nu=8), data=ais)
#
data(barolo)
attach(barolo)
A75 &lt;- (reseller=="A" &amp; volume==75)
logPrice &lt;- log(price[A75],10) 
m &lt;- selm(logPrice ~ 1, family="ST", opt.method="Nelder-Mead")
summary(m)
summary(m, "DP")
plot(m, which=2, col=4, main="Barolo log10(price)")
# cfr Figure 4.7 of Azzalini &amp; Capitanio (2014), p.107
detach(barolo)
#-----
# examples with multivariate response
#
m3 &lt;- selm(cbind(BMI, LBM) ~ WCC + RCC, family="SN", data=ais)
plot(m3, col=2, which=2)
summary(m3, "dp")
coef(m3)
coef(m3, vector=FALSE)
#
data(wines)
m28 &lt;- selm(cbind(chloride, glycerol, magnesium) ~ 1, family="ST", data=wines)
dp28 &lt;- coef(m28, "DP", vector=FALSE) 
pcp28 &lt;- coef(m28, "pseudo-CP", vector=FALSE) 
# the next statement takes a little more time than others
plot(m28)

#
m4 &lt;- selm(cbind(alcohol,sugar)~1, family="ST", data=wines)
m5 &lt;- selm(cbind(alcohol,sugar)~1, family="ST", data=wines, fixed=list(alpha=0))
print(1 - pchisq(2*as.numeric(logLik(m4)-logLik(m5)), 2)) # test for symmetry
</code></pre>

<hr>
<h2 id='selm-class'>Classes <code>selm</code> and <code>mselm</code> of objects created by 
function <code>selm</code></h2><span id='topic+selm-class'></span><span id='topic+logLik+2Cselm-method'></span><span id='topic+plot+2Cselm+2CANY-method'></span><span id='topic+plot+2Cselm+2Cmissing-method'></span><span id='topic+show+2Cselm-method'></span><span id='topic+vcov+2Cselm-method'></span><span id='topic+weights+2Cselm-method'></span><span id='topic+confint+2Cselm-method'></span><span id='topic+predict+2Cselm-method'></span><span id='topic+mselm-class'></span><span id='topic+logLik+2Cmselm-method'></span><span id='topic+plot+2Cmselm+2CANY-method'></span><span id='topic+plot+2Cmselm+2Cmissing-method'></span><span id='topic+show+2Cmselm-method'></span><span id='topic+vcov+2Cmselm-method'></span><span id='topic+weights+2Cmselm-method'></span>

<h3>Description</h3>

<p>A successful call to function <code>selm</code> creates an object of
either of these classes, having a structure described in section
&lsquo;Slots&rsquo;. A set of methods for these classes of objects exist, listed in
section &lsquo;Methods&rsquo;.</p>


<h3>Objects from the class</h3>

<p>An object can be created by a successful call to function <code>selm</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>the calling statement.</p>
</dd>
<dt><code>family</code>:</dt><dd><p>the parametric family of skew-ellitically 
contoured distributed (SEC) type.</p>
</dd>
<dt><code>logL</code>:</dt><dd><p>log-likelihood or penalized log-likelihood value
achieved at the end of the maximization process.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>estimation method (<code>"MLE"</code> or <code>"MPLE"</code>).</p>
</dd>
<dt><code>param</code>:</dt><dd><p>estimated parameters, for various parameterizations.</p>
</dd>
<dt><code>param.var</code>:</dt><dd><p>approximate variance matrices of the parameter 
estimates, for various parameterizations.</p>
</dd>
<dt><code>size</code>:</dt><dd><p>a numeric vector with size of various components.</p>
</dd>
<dt><code>fixed.param</code>:</dt><dd><p>a vector of parameters which have been kept
fixed in the fitting process, if any.</p>
</dd>
<dt><code>residuals.dp</code>:</dt><dd><p>residual values, for DP-type parameters.</p>
</dd>
<dt><code>fitted.values.dp</code>:</dt><dd><p>fitted values, for DP-type parameters.</p>
</dd>
<dt><code>control</code>:</dt><dd><p>a list with control parameters.</p>
</dd>
<dt><code>input</code>:</dt><dd><p>a list of selected input values.</p>
</dd>
<dt><code>opt.method</code>:</dt><dd><p>a list with details on the optimization method.</p>
</dd>
</dl>



<h3>Methods</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code>coef</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>logLik</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    
    
    <code>plot</code> </td><td style="text-align: left;"> <code>signature(x = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>show</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>summary</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>residuals</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fitted</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>vcov</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>weights</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>profile</code> </td><td style="text-align: left;"> <code>signature(fitted = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>confint</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>predict</code> </td><td style="text-align: left;"> <code>signature(object = "selm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coef</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>logLik</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plot</code> </td><td style="text-align: left;"> <code>signature(x = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>show</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>summary</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>residuals</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fitted</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>vcov</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>weights</code> </td><td style="text-align: left;"> <code>signature(object = "mselm")</code>: ... </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Note</h3>

<p>See <code><a href="#topic+dp2cp">dp2cp</a></code> for a description of possible parameter sets.
When <code>logLik</code> is used on an object obtained using the MPLE estimation
method, the value reported is actually the <em>penalized</em> log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p>See also  
<code><a href="#topic+selm">selm</a></code> function,  <code><a href="#topic+plot.selm">plot.selm</a></code>,
<code><a href="#topic+summary.selm-class">summary.selm</a></code>,  <code><a href="#topic+dp2cp">dp2cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
m1 &lt;- selm(log(Fe) ~ BMI + LBM, family="SN", data=ais)
summary(m1)
plot(m1)
logLik(m1)
res &lt;- residuals(m1)
fv &lt;- fitted(m1)
# 
data(wines, package="sn")
m2 &lt;- selm(alcohol ~ malic + phenols, data=wines)
#
m12 &lt;- selm(cbind(acidity, alcohol) ~ phenols + wine, family="SN", data=wines)
coef(m12)
cp &lt;- coef(m12, vector=FALSE)
dp &lt;- coef(m12, "DP", vector=FALSE)
plot(m12)
plot(m12, which=2, col="gray60", pch=20)
</code></pre>

<hr>
<h2 id='selm.fit'>Fitting functions for <code>selm</code> models</h2><span id='topic+selm.fit'></span><span id='topic+sn.mple'></span><span id='topic+st.mple'></span><span id='topic+msn.mle'></span><span id='topic+msn.mple'></span><span id='topic+mst.mple'></span>

<h3>Description</h3>

<p>A call to <code>selm</code> activates a call to <code>selm.fit</code> and
from here to some other function which actually performs the parameter
search, among those listed below. These lower-level functions can be 
called directly for increased efficiency, at the expense of some more 
programming effort and lack of methods for the returned object.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
selm.fit(x, y, family = "SN", start = NULL, w, fixed.param = list(), 
   offset = NULL, selm.control=list())

sn.mple(x, y, cp = NULL, w, penalty = NULL, trace = FALSE, opt.method =
   c("nlminb",  "Nelder-Mead", "BFGS", "CG", "SANN"), control = list()) 

st.mple(x, y, dp = NULL, w, fixed.nu = NULL, symmetr = FALSE, penalty = NULL, 
   trace = FALSE, opt.method = c("nlminb", "Nelder-Mead", "BFGS", "CG", "SANN"), 
   control = list()) 

msn.mle(x, y, start = NULL, w, trace = FALSE, opt.method = c("nlminb", 
   "Nelder-Mead", "BFGS", "CG", "SANN"), control = list())

msn.mple(x, y, start = NULL, w, trace = FALSE, penalty = NULL, 
   opt.method = c("nlminb", "Nelder-Mead", "BFGS", "CG", "SANN"), 
   control = list()) 

mst.mple(x, y, start = NULL, w, fixed.nu = NULL, symmetr=FALSE, 
   penalty = NULL, trace = FALSE, 
   opt.method = c("nlminb", "Nelder-Mead", "BFGS", "CG", "SANN"), 
   control = list()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selm.fit_+3A_x">x</code></td>
<td>
<p>a full-rank design matrix with the first column of all 1's.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_y">y</code></td>
<td>
<p>a vector or a matrix of response values such that
<code>NROW(y)=nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_family">family</code></td>
<td>
<p>a character string which selects the parametric family of
distributions assumed for the error term of the regression model. 
It must one of <code>"SN"</code> (default), <code>"ST"</code> or <code>"SC"</code>, which 
correspond to the skew-normal, the skew-<em>t</em> and the skew-Cauchy 
family, respectively.
See <code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for more information on these families and
the skew-elliptically contoured (<abbr><span class="acronym">SEC</span></abbr>) distributions; notice that
family <code>"ESN"</code> is not allowed here.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_start">start</code>, <code id="selm.fit_+3A_dp">dp</code>, <code id="selm.fit_+3A_cp">cp</code></td>
<td>
<p>a vector or a list of initial parameter values,
depeding whether <code>y</code> is a vector or a matrix. It is assumed that 
<code>cp</code> is given in the <abbr><span class="acronym">CP</span></abbr> parameterization, <code>dp</code> and
<code>start</code> in the <abbr><span class="acronym">DP</span></abbr> parameterization. 
For <code>st.mple</code> and <code>mst.mple</code>, see also the paragraph about  
<code>start</code> in the documentation &lsquo;Details&rsquo; of <code>selm</code>.
</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_w">w</code></td>
<td>
<p>a vector of non-negative integer weights of length equal to 
<code>NROW(y)</code>; if missing, a vector of all 1's is generated.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_fixed.param">fixed.param</code></td>
<td>
<p>a list of assignments of parameter values to be kept
fixed during the optimization process. Currently, there is only one such
option, namely <code>fixed.param=list(nu='value')</code>, to fix the degrees
of freedom at the named <code>'value'</code> when <code>family="ST"</code>, for instance
<code>list(nu=3)</code>. Setting <code>fixed.param=list(nu=1)</code> is equivalent to
select <code>family="SC"</code>.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_penalty">penalty</code></td>
<td>
<p>an optional character string with the name of the penalty
function of the log-likelihood; 
default value <code>NULL</code> corresponds to no penalty.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.  This
should be <code>NULL</code> or a numeric vector of length equal to the number of
cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the
formula instead or as well, and if more than one are specified their sum is
used.</p>
</td></tr>  
<tr><td><code id="selm.fit_+3A_trace">trace</code></td>
<td>
<p>a logical value which regulates printing of successive calls 
to the target function; default value is <code>FALSE</code> which suppresses 
printing.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_fixed.nu">fixed.nu</code></td>
<td>
<p>a positive value to keep fixed the parameter <code>nu</code> 
of the <abbr><span class="acronym">ST</span></abbr> distribution in the optimization process; with default
value <code>NULL</code>, <code>nu</code> is estimated like the other parameters.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_symmetr">symmetr</code></td>
<td>
<p>a logical flag indicating whether a contraint of symmetry is
imposed on the slant parameter; default is <code>symmetr=FALSE</code>.</p>
</td></tr>  
<tr><td><code id="selm.fit_+3A_opt.method">opt.method</code></td>
<td>
<p>a character string which selects the optimization method
within the set <code>c("nlminb", "Nelder-Mead", "BFGS", "CG", "SANN")</code>;
the last four of these are <code>"methods"</code> of function <code>optim</code>.</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_selm.control">selm.control</code></td>
<td>
<p>a list whose components regulate the working of 
<code>selm.fit</code>; see &lsquo;Details&rsquo; for their description;</p>
</td></tr>
<tr><td><code id="selm.fit_+3A_control">control</code></td>
<td>
<p>a list of control items passed to the optimization function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to <code>selm</code> produces a call to <code>selm.fit</code> which
selects the appropriate function among <code>sn.mple</code>, <code>st.mple</code>,
<code>msn.mle</code>, <code>msn.mple</code>, <code>mst.mple</code>, depending on the
arguments of the calling statement. In the adopted scheme for function names, 
<code>msn</code> refers to a  multivariate skew-normal distribution and  
<code>mst</code> refers to a multivariate skew-<code class="reqn">t</code> distribution, while
<code>mle</code> and <code>mple</code> refers to maximum likelihood and maximum
penalized likelihood estimation, respectively.
Of these functions, <code>sn.mple</code> works in <abbr><span class="acronym">CP</span></abbr> space; the others
in the <abbr><span class="acronym">DP</span></abbr> space. In all cases, a correspondig mapping to the 
alternative parameter space is performed before exiting <code>selm.fit</code>,
in addition to the selected parameter set.
</p>
<p>The components of <code>selm.control</code> are as follows:
</p>

<ul>
<li> <p><code>method</code>: the estimation method, <code>"MLE"</code> or <code>"MPLE"</code>.
</p>
</li>
<li> <p><code>penalty</code>: a string with the name of the penalty function.
</p>
</li>
<li> <p><code>info.type</code>: a string with the name of the information matrix,
<code>"observed"</code> or <code>"expected"</code>; currently fixed at &quot;observed&quot;.         
</p>
</li>
<li> <p><code>opt.method</code>: a character string which selects the optimization
method. 
</p>
</li>
<li> <p><code>opt.control</code>: a list of control parameters of <code>opt.method</code>.
</p>
</li></ul>

<p>Function <code>msn.mle</code>, for <abbr><span class="acronym">MLE</span></abbr> estimation of linear models with
<abbr><span class="acronym">SN</span></abbr> errors, is unchanged from version 0.4-x of the package. 
Function <code>msn.mple</code> is similar to <code>msn.mle</code> but allows to introduce
a penalization of the log-likelihood; when <code>penalty=NULL</code>, a call to 
<code>msn.mle</code> is more efficient.
Functions <code>sn.mple</code> and <code>mst.mple</code> work like <code>sn.mle</code> and
<code>mst.mle</code> in version 0.4-x if the argument <code>penalty</code> is not 
set or it is set to <code>NULL</code>, except that <code>mst.mple</code> does not
handle a univariate response (use <code>st.mple</code> for that).
</p>


<h3>Value</h3>

<p>A list whose specific components depend on the named function.
Typical components are:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the calling statement</p>
</td></tr>
<tr><td><code>dp</code></td>
<td>
<p>vector or list of estimated <abbr><span class="acronym">DP</span></abbr> parameters</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>vector or list of estimated <abbr><span class="acronym">CP</span></abbr> parameters</p>
</td></tr>
<tr><td><code>logL</code></td>
<td>
<p>the maximized (penalized) log-likelihood</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>a list with auxiliary output values, depending on the function</p>
</td></tr>
<tr><td><code>opt.method</code></td>
<td>
<p>a list produced by the numerical <code>opt.method</code></p>
</td></tr>
</table>


<h3>Background</h3>

<p>Computational aspects of maximum likelihood estimation for univariate 
<abbr><span class="acronym">SN</span></abbr> distributions are discussed in Section 3.1.7 of Azzalini and
Capitanio (2014). The working of <code>sn.mple</code> follows these lines; 
maximization is performed in the <abbr><span class="acronym">CP</span></abbr> space. All other functions
operate on the <abbr><span class="acronym">DP</span></abbr> space.
</p>
<p>The technique underlying <code>msn.mle</code> is based on a partial analytical 
maximization, leading  implicitly to a form of profile log-likelihood.
This scheme is formulated in detail in Section 6.1 of Azzalini and Capitanio 
(1999) and summarized in Section 5.2.1 of Azzalini and Capitanio (2014). 
The same procedure is not feasible when one adopts <abbr><span class="acronym">MPLE</span></abbr>; 
hence function <code>msn.mple</code> has to maximize over a larger parameter space.
</p>
<p>When the SN family is fitted with the constraint <kbd>alpha=0</kbd>, this amounts
to adopt a classical linear model with Gaussian distributional assumption.
The corresponding <abbr><span class="acronym">MLE</span></abbr>'s are the same as those produced by <code>lm</code>, 
except that the denominator the of the <abbr><span class="acronym">MLE</span></abbr> variance (matrix) has the 
&lsquo;uncorrected&rsquo; form.
In the multivariate case, the covariance matrix of <abbr><span class="acronym">MLE</span></abbr> is computed 
using expression (10) in Section 15.8 of Magnus and Neudecker (2007).
</p>
<p>Maximization of the univariate <abbr><span class="acronym">ST</span></abbr> log-likelihood is speeded-up 
by using the expressions of the gradient given by DiCiccio and Monti (2011),
reproduced with inessential variants in Section 4.3.3 of Azzalini and 
Capitanio (2014).
</p>
<p>The working of <code>mst.mple</code> is based on a re-parameterization described 
in Section 5.1 of Azzalini and Capitanio (2003). The expressions of the 
corresponding log-likelihood derivatives are given in Appendix B of the full 
version of the paper.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. and Capitanio, A. (1999).
Statistical applications of the multivariate skew normal distribution.
<em>J.Roy.Statist.Soc. B</em> <b>61</b>, 579&ndash;602. 
Full-length version available at <a href="https://arXiv.org/abs/0911.2093">https://arXiv.org/abs/0911.2093</a>
</p>
<p>Azzalini, A. and Capitanio, A. (2003).
Distributions generated by perturbation of symmetry with emphasis on
a multivariate skew <em>t</em> distribution.
<em>J.Roy. Statist. Soc. B</em> <b>65</b>, 367&ndash;389.
Full-length version available at <a href="https://arXiv.org/abs/0911.2342">https://arXiv.org/abs/0911.2342</a>
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>DiCiccio,  T. J. and Monti, A. C. (2011).  
Inferential aspects of the skew <code class="reqn">t</code>-distribution.
<em>Quaderni di Statistica</em> <b>13</b>, 1&ndash;21.
</p>
<p>Magnus, J. R. and Neudecker, H. (2007).
<em>Matrix Differential Calculus with Applications in Statistics and 
Econometrics</em>, third edition.  John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code> for a comprehensive higher level fitting function,   
<code><a href="#topic+Qpenalty">Qpenalty</a></code> for specification of a penalty function 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(wines, package="sn")
X &lt;- model.matrix(~ phenols + wine, data=wines)
fit &lt;- msn.mle(x=X, y=cbind(wines$acidity, wines$alcohol), opt.method="BFGS")
fit &lt;- st.mple(x=X, y = wines$acidity, fixed.nu=4, penalty="Qpenalty")
</code></pre>

<hr>
<h2 id='sn-st.cumulants'>Cumulants of univariate skew-normal and skew-<code class="reqn">t</code> distributions</h2><span id='topic+sn.cumulants'></span><span id='topic+st.cumulants'></span>

<h3>Description</h3>

<p>Compute cumulants of univariate (extended) skew-normal and 
skew-<code class="reqn">t</code> distributions up to a given order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sn.cumulants(xi=0, omega=1, alpha=0, tau=0, dp=NULL, n=4)
  st.cumulants(xi=0, omega=1, alpha=0, nu=Inf, dp=NULL, n=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sn-st.cumulants_+3A_xi">xi</code></td>
<td>
<p>location parameters (numeric vector).</p>
</td></tr>
<tr><td><code id="sn-st.cumulants_+3A_omega">omega</code></td>
<td>
<p>scale parameters (numeric vector, positive).</p>
</td></tr>
<tr><td><code id="sn-st.cumulants_+3A_alpha">alpha</code></td>
<td>
<p>slant parameters (numeric vector).</p>
</td></tr>
<tr><td><code id="sn-st.cumulants_+3A_tau">tau</code></td>
<td>
<p>hidden mean parameter (numeric scalar).</p>
</td></tr>
<tr><td><code id="sn-st.cumulants_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom (numeric scalar, positive); the default value
is <code>nu=Inf</code> which corresponds to the skew-normal distribution.</p>
</td></tr>
<tr><td><code id="sn-st.cumulants_+3A_dp">dp</code></td>
<td>
<p>a vector containing the appropriate set of parameters. 
If <code>dp</code> is not <code>NULL</code>, the individual parameters must 
not be supplied.</p>
</td></tr>
<tr><td><code id="sn-st.cumulants_+3A_n">n</code></td>
<td>
<p>maximal order of the cumulants. For <code>st.cumulants</code> and
for <code>sn.cumulants</code> with <code>tau!=0</code> (<abbr><span class="acronym">ESN</span></abbr> distribution), 
it cannot exceed 4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>n</code> or a matrix with <code>n</code> columns, 
in case the input values are vectors.</p>


<h3>Background</h3>

<p>See Sections 2.1.4, 2.2.3 and 4.3.1 of the reference below</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dsn">dsn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sn.cumulants(omega=2, alpha=c(0, 3, 5, 10), n=5)
sn.cumulants(dp=c(0, 3, -8), n=6)
st.cumulants(dp=c(0, 3, -8, 5), n=6) # only four of them are computed
st.cumulants(dp=c(0, 3, -8, 3))
</code></pre>

<hr>
<h2 id='sn-st.info'>Expected and observed Fisher information for <abbr><span class="acronym">SN</span></abbr> 
and <abbr><span class="acronym">ST</span></abbr> distributions</h2><span id='topic+sn.infoUv'></span><span id='topic+sn.infoMv'></span><span id='topic+st.infoUv'></span><span id='topic+st.infoMv'></span>

<h3>Description</h3>

<p>Computes Fisher information for parameters of simple sample having
skew-normal (<abbr><span class="acronym">SN</span></abbr>) or skew-<code class="reqn">t</code> (<abbr><span class="acronym">ST</span></abbr>) distribution or
for a regression model with errors term having such distributions, in the
<abbr><span class="acronym">DP</span></abbr> and <abbr><span class="acronym">CP</span></abbr> parametrizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sn.infoUv(dp=NULL, cp=NULL, x=NULL, y, w, penalty=NULL,  norm2.tol=1e-06) 
    
sn.infoMv(dp, x=NULL, y, w, penalty=NULL, norm2.tol=1e-06, at.MLE=TRUE)

st.infoUv(dp = NULL, cp = NULL, x = NULL, y, w, fixed.nu = NULL, 
    symmetr = FALSE, penalty = NULL, norm2.tol = 1e-06) 

st.infoMv(dp, x = NULL, y, w, fixed.nu = NULL, symmetr = FALSE, 
    penalty = NULL, norm2.tol = 1e-06) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sn-st.info_+3A_dp">dp</code>, <code id="sn-st.info_+3A_cp">cp</code></td>
<td>
<p>direct or centred parameters, respectively; one of them
can be a non-<code>NULL</code> argument. For the univariate <abbr><span class="acronym">SN</span></abbr>
distribution, <code>sn.infoUv</code> is to be used, and these arguments are
vectors. In the multivariate case, <code>sn.infoMv</code> is to be used and these
arguments are lists. See <code><a href="#topic+dp2cp">dp2cp</a></code> for their description.</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_x">x</code></td>
<td>
<p>an optional matrix which represents the design matrix of a 
regression model</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_y">y</code></td>
<td>
<p>a numeric vector (for <code>sn.infoUv</code> and <code>st.infoUv</code>)
or a matrix (for <code>sn.infoMv</code> and <code>st.infoMv</code>) representing the
response.  In the <abbr><span class="acronym">SN</span></abbr> case ( <code>sn.infoUv</code> and
<code>sn.infoMv</code>), <code>y</code> can be missing, and in this case the expected
information matrix is computed; otherwise the observed information is
computed. In the <abbr><span class="acronym">ST</span></abbr> case (<code>st.infoUv</code> and <code>st.infoMv</code>),
<code>y</code> is a required argument, since only the observed information matrix
for <abbr><span class="acronym">ST</span></abbr> distributions is implemented. See &lsquo;Details&rsquo; for
additional information.</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_w">w</code></td>
<td>
<p>an optional vector of weights (only meaningful for the observed 
information, hence if <code>y</code> is missing); if missing, a vector of 1's is
generated.</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_fixed.nu">fixed.nu</code></td>
<td>
<p>an optional numeric value which declares a fixed value of the
degrees of freedom, <code>nu</code>. If not <code>NULL</code>, the information matrix
has a dimension reduced by 1.</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_symmetr">symmetr</code></td>
<td>
<p>a logical flag which indicates whether a symmetry condition of 
the distribution is being imposed; default is <code>symmetr=FALSE</code>.</p>
</td></tr>   
<tr><td><code id="sn-st.info_+3A_penalty">penalty</code></td>
<td>
<p>a optional character string with the name of the penalty 
function used in the call to <code><a href="#topic+selm">selm</a></code>; see this function for its
description.</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_norm2.tol">norm2.tol</code></td>
<td>
<p>for the observed information case, the Mahalanobis squared
distance of the score function from 0 is evaluated; if it exceeds
<code>norm2.tol</code>, a warning message is issued, since the &lsquo;information
matrix&rsquo; so evaluated may be not positive-definite.  See &lsquo;Details&rsquo; for
additional information.</p>
</td></tr>
<tr><td><code id="sn-st.info_+3A_at.mle">at.MLE</code></td>
<td>
<p>a logical flag; if <code>at.MLE=TRUE</code> (default value), 
it generates  a warning if the information matrix is not positive 
definite or an error if the observed information matrix is not evaluated 
at a maximum of the log-likelihood function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>dp</code>, <code>cp</code></td>
<td>
<p>one of the two arguments is the one supplied on input; 
the other one matches the previous one in the alternative parametrization.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the type of information matrix: &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code>info.dp</code>, <code>info.cp</code></td>
<td>
<p>matrices of Fisher (observed or expected) 
information in the two parametrizations.</p>
</td></tr>
<tr><td><code>asyvar.dp</code>, <code>asyvar.cp</code></td>
<td>
<p>inverse matrices of Fisher information in the two
parametrizations, when available; See &lsquo;Details&rsquo; for additional
information. </p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>a list containing auxiliary elements, depending of the selected 
function and the type of computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the univariate <abbr><span class="acronym">SN</span></abbr> case, when <code>x</code> is not set, then a simple
random sample is assumed and a matrix <code>x</code> with a single column of all 
1's is constructed; in this case, the supplied vector <code>dp</code> or <code>cp</code>
must have length 3.  If <code>x</code> is set, then the supplied vector of parameters,
<code>dp</code> or <code>cp</code>, must have length <code>ncol(x)+2</code>.
In the multivariate case, a direct extension of this scheme applies.
</p>
<p>If the observed information matrix is required, <code>dp</code> or <code>cp</code> should
represent the maximum likelihood estimates (MLE) for the given <code>y</code>,
otherwise the information matrix may fail to be positive-definite and it
would be meaningless anyway. 
Therefore, the squared Mahalobis norm of the score vector is evaluated and compared with <code>norm2.tol</code>. 
If it exceeds this threshold, this is taken as an indication that the supplied
parameter list is not at the <abbr><span class="acronym">MLE</span></abbr> and a warning message is issued.
The returned list still includes <code>info.dp</code> and <code>info.cp</code>, but in 
this case these represent merely the matrices of second derivatives;
<code>asyvar.dp</code> and <code>asyvar.cp</code> are set to <code>NULL</code>.
</p>


<h3>Background</h3>

<p>The information matrix for the the univariate <abbr><span class="acronym">SN</span></abbr> distribution in
the two stated parameterizations in discussed in Sections 3.1.3&ndash;4 of 
Azzalini and Capitanio (2014). For the multivariate distribution,   
Section 5.2.2 of this monograph summarizes briefly the findings of 
Arellano-Valle and Azzalini (2008).
</p>
<p>For <abbr><span class="acronym">ST</span></abbr> distributions, only the observed information matrix is 
provided, at the moment. Computation for the univariate case is based on 
DiCiccio and Monti (2011). For the multivariate case, the score function is
computed using an expression of Arellano-Valle (2010) followed by numerical
differentiation.
</p>


<h3>References</h3>

<p>Arellano-Valle, R. B. (2010).
The information matrix of the multivariate skew-<em>t</em> distribution.
<em>Metron</em>, <b>LXVIII</b>, 371&ndash;386.
</p>
<p>Arellano-Valle, R. B., and Azzalini, A. (2008).
The centred parametrization for the multivariate skew-normal distribution.
<em>J. Multiv. Anal.</em> <b>99</b>, 1362&ndash;1382.
Corrigendum: <b>100</b> (2009), 816.
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>DiCiccio,  T. J. and Monti, A. C. (2011).  
Inferential aspects of the skew <code class="reqn">t</code>-distribution.
<em>Quaderni di Statistica</em> <b>13</b>, 1&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsn">dsn</a></code>, <code><a href="#topic+dmsn">dmsn</a></code>, <code><a href="#topic+dp2cp">dp2cp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>infoE &lt;- sn.infoUv(dp=c(0,1,5))           # expected information
set.seed(1); rnd &lt;- rsn(100, dp=c(0, 1, 3))
fit &lt;- selm(rnd~1, family="SN")
infoO &lt;- sn.infoUv(cp=coef(fit), y=rnd)   # observed information
#
data(wines)
X &lt;- model.matrix(~ pH + wine, data=wines)
fit &lt;- sn.mple(x=X, y=wines$alcohol)
infoE &lt;- sn.infoUv(cp=fit$cp, x=X)
infoO &lt;- sn.infoUv(cp=fit$cp, x=X, y=wines$alcohol)
</code></pre>

<hr>
<h2 id='spread.grouped'>Spreading grouped data over intervals</h2><span id='topic+spread.grouped'></span>

<h3>Description</h3>

<p>Assuming that <code>counts</code> represents the frequencies of observations
falling into intervals identified by <code>breaks</code>, the function returns
a vector of values obtained by uniformly spreading each group of data 
over the pertaining interval.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread.grouped(breaks, counts, shift = "centre")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread.grouped_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of strictly increasing finite values 
which identify a set of contiguous intervals on the real line.</p>
</td></tr>
<tr><td><code id="spread.grouped_+3A_counts">counts</code></td>
<td>
<p>A vector of non-negative integers representing the number 
of observations falling in the intervals specified by <code>breaks</code>;
it is then required that <code>length(counts)+1=length(breaks)</code>. </p>
</td></tr>
<tr><td><code id="spread.grouped_+3A_shift">shift</code></td>
<td>
<p>a character string which regulates the positioning of the 
constructed points within a given interval, with possible values
<code>"left"</code>, <code>"center"</code> (default choice) and <code>"right"</code>,
possibly abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>sum(counts)</code> of values 
within <code>range(breaks)</code>.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p>fitdistr.grouped</p>


<h3>Examples</h3>

<pre><code class='language-R'>breaks &lt;- c(10, 12, 15, 20)
counts &lt;- c(3, 2, 4)
spread.grouped(breaks, counts)
spread.grouped(breaks, counts, "l")
</code></pre>

<hr>
<h2 id='st.prelimFit'>
Compute preliminary estimates for a linear model with ST-distributed error term
</h2><span id='topic+st.prelimFit'></span><span id='topic+mst.prelimFit'></span>

<h3>Description</h3>

<p>For a univariate or multivariate linear model where the error term
is assumed to have skew-<em>t</em> (ST) distribution and the location parameter
is a linear function of a set of explanatory values, the functions compute
preliminary estimates to be used as initial values for a subsequent
maximization of the likelihood function.
These functions are mainly intended for internal package use.</p>


<h3>Usage</h3>

<pre><code class='language-R'>st.prelimFit(x, y, w, quick = TRUE, verbose = 0, max.nu = 30, SN=FALSE)
mst.prelimFit(x, y, w, quick = TRUE, verbose = 0, max.nu = 30, SN=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st.prelimFit_+3A_x">x</code></td>
<td>
<p>design matrix of numeric values. It may be missing;
if present, the first column must contain all 1's.</p>
</td></tr>
<tr><td><code id="st.prelimFit_+3A_y">y</code></td>
<td>
<p>vector of observations of length <code>n</code>,
or a matrix with <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="st.prelimFit_+3A_w">w</code></td>
<td>
<p>a vector of non-negative integer weights of length <code>n</code>; 
if missing, a vector of all 1's is generated.</p>
</td></tr>
<tr><td><code id="st.prelimFit_+3A_quick">quick</code></td>
<td>
<p>logical value which regulates whether a very quick estimate 
is produced (default value <code>TRUE</code>); 
see &lsquo;Details&rsquo; for additional information.</p>
</td></tr>
<tr><td><code id="st.prelimFit_+3A_verbose">verbose</code></td>
<td>
<p>an integer value which regulates the amount of messages
printed out; default value is 0.</p>
</td></tr>
<tr><td><code id="st.prelimFit_+3A_max.nu">max.nu</code></td>
<td>
<p>threshold for the estimated degrees of freedom</p>
</td></tr>
<tr><td><code id="st.prelimFit_+3A_sn">SN</code></td>
<td>
<p>logical value (default value: <code>FALSE</code>); 
if <code>TRUE</code>, a <abbr><span class="acronym">SN</span></abbr> distribution is assumed.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The underlying methodology is the one presented by Azzalini and Salehi (2020).
In its essence, it is based on the selection of parameter values achieving the 
best matching between certain quantile-based summaries of the ST distribution
and the corresponding empirical quantities for the sample or, in the presence 
of explanatory variables, the same quantities computed from the residuals 
after fitting a median regression.
</p>
<p>Argument <code>quick</code> selects whether the above-described matching is performed
in a quick or in an accurate way. Since the output values of this function are 
intended to be only initial values for subsequent likelihood maximization,
this explains the default option <code>quick=TRUE</code>. Other possible values
are <code>FALSE</code> and <code>NULL</code>; the latter simply sets <code>alpha=0</code>
and <code>nu=10</code>.
</p>
<p>Since the methodology hinges on some selected sample quantiles, 
it can occasionally be spoiled by poor behaviour of these basic quantiles,
especially for small or moderate sample sizes.
The more visible effect of such situation is a very large value of the
estimated degrees of freedom, which then hampers rather than help a
subsequent likelihood maximization. It is therefore appropriate to set
an upper limit <code>max.nu</code> to this component.
</p>
<p>Argument <code>x</code> may be missing. In this case, a one-column matrix with
all elements 1 is created.
</p>


<h3>Value</h3>

<p>A call to <code>st.prelimFit</code> returns a list with these components:
</p>
<table>
<tr><td><code>dp</code></td>
<td>
<p>a vector of estimates in the DP parameterization</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of residual values</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the corresponding log-likelihood value</p>
</td></tr>
</table>
<p>A call to <code>mst.prelimFit</code> returns a list with these components:
</p>
<table>
<tr><td><code>dp</code></td>
<td>
<p>a list with the estimates in the DP parameterization</p>
</td></tr>
<tr><td><code>shrink.steps</code></td>
<td>
<p>the number of shrinking steps applied to the original 
estimate of the scale matrix to obtain an admissible matrix</p>
</td></tr>
<tr><td><code>dp.matrix</code></td>
<td>
<p>a numeric matrix formed by the component-wise DP estimates</p>
</td></tr>     
<tr><td><code>logLik</code></td>
<td>
<p>the corresponding log-likelihood value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions are mainly intended to be called by <code><a href="#topic+selm">selm</a></code>,
but they could be of interest for people developing their own procedures.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. and Salehi, M. (2020).
Some computational aspects of maximum likelihood estimation of the 
skew-<em>t</em> distribution.
In: <em>Computational and Methodological Statistics and Biostatistics</em>,
edited by  Andriëtte Bekker, Ding-Geng Chen and Johannes T. Ferreira.
Springer. DOI: 10.1007/978-3-030-42196-0
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code> and  either <code><a href="#topic+dst">dst</a></code> or 
<code><a href="#topic+dmst">dmst</a></code> for explanation of the DP parameters</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barolo)
attach(barolo)  
A75 &lt;- (reseller=="A" &amp; volume==75)  
log.price &lt;- log(price[A75], 10)
prelimFit &lt;- st.prelimFit(y=log.price)
detach(barolo)
# 
data(ais)
attach(ais)
prelim32 &lt;- mst.prelimFit(y=cbind(BMI, LBM), x=cbind(1, Ht, Wt))
detach(ais)
</code></pre>

<hr>
<h2 id='summary.SECdistr'>Summary of a <abbr><span class="acronym">SEC</span></abbr> distribution object</h2><span id='topic+summary.SECdistr'></span><span id='topic+summary.SECdistrUv'></span><span id='topic+summary.SECdistrMv'></span><span id='topic+summary+2CSECdistrUv-method'></span><span id='topic+summary+2CSECdistrMv-method'></span>

<h3>Description</h3>

<p>Produce a summary of an object of class either
<code>"SECdistrUv"</code> or <code>"SECdistrMv"</code>, which refer to a univariate or a
multivariate <abbr><span class="acronym">SEC</span></abbr> distribution, respectively. Both types of
objects can be produced by <code>makeSECditr</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SECdistrUv'
summary(object, cp.type = "auto", probs)

## S4 method for signature 'SECdistrMv'
summary(object, cp.type = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SECdistr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"SECdistrUv"</code> or <code>"SECdistrMv"</code>.</p>
</td></tr>
<tr><td><code id="summary.SECdistr_+3A_cp.type">cp.type</code></td>
<td>
<p>a character string to select the required variance of
<abbr><span class="acronym">CP</span></abbr> parameterization; possible values are <code>"proper"</code>,
<code>"pseudo"</code>, <code>"auto"</code> (default). For a description of these
codes, see <code><a href="#topic+dp2cp">dp2cp</a></code>.</p>
</td></tr>
<tr><td><code id="summary.SECdistr_+3A_probs">probs</code></td>
<td>
<p>in the univariate case, a vector of probabilities for which 
the corresponding quantiles are required. If missing, the vector
<code>c(0.05, 0.25, 0.50, 0.75, 0.95)</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a description of  the <abbr><span class="acronym">DP</span></abbr>,  <abbr><span class="acronym">CP</span></abbr> and    
pseudo-<abbr><span class="acronym">CP</span></abbr>  parameter sets included in the returned object, 
see <code><a href="#topic+dp2cp">dp2cp</a></code>.
</p>
<p>The <code>aux</code> slot of the returned object includes other summary quantities,
as described next. 
In the univariate case, the reported quantile-based measures of skewness and
kurtosis refer to the  Bowley and Moors measures, respectively;
see Groeneveld (2006) and Moors (1988) for their specifications.
In the multivariate case, the Mardia's measures of skewness and kurtosis
are computed from the expressions given on p.153 and p.178 of
Azzalini and Capitanio (2014).
</p>
<p>In the univariate case, <code>delta</code> is a simple transformation of the 
slant parameter <code>alpha</code>; it takes values in <code class="reqn">(-1, 1)</code>. 
In the multivariate case, <code>delta</code> is a vector with components
of similar type; they correspond to the matching terms of the univariate 
components. The <code>alpha*</code> and <code>delta*</code> coefficients are univariate
comprehensive summary quantities of slant; see pp.132-3 of 
Azzalini and Capitanio (2014) for their expressions. These quantities
play an important role in <abbr><span class="acronym">SEC</span></abbr> distributions; for instance,
the Mardia's measures of multivariare skewness and kurtosis depend
on the vector of slant parameters only via <code>delta*</code> or, equivalently,
via <code>alpha*</code>.
</p>
<p>The mode, which is unique for all these distributions, is computed by a 
numerical line search between the <abbr><span class="acronym">DP</span></abbr> location and the <abbr><span class="acronym">CP</span></abbr>
location (or the pseudo-<abbr><span class="acronym">DP</span></abbr> location, when the latter does
exists). This line search is univariate also in the multivariate case, 
using Propositions 5.14 and 6.2 of Azzalini and Capitanio (2014);
see also Problem 5.14.
</p>
<p>The examples below illustrate how extract various components from <code>aux</code> 
and other slots of the returned object. 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>name of the family within the <abbr><span class="acronym">SEC</span></abbr> class, character</p>
</td></tr>
<tr><td><code>dp</code></td>
<td>
<p><abbr><span class="acronym">DP</span></abbr> parameters, a list or a vector</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>the name of the distribution, character string</p>
</td></tr>
<tr><td><code>compNames</code></td>
<td>
<p>in the multivariate case the names of the components,
a character vector</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p><abbr><span class="acronym">CP</span></abbr> parameters, a list or a vector</p>
</td></tr>
<tr><td><code>cp.type</code></td>
<td>
<p>the name of the selected variant of the <abbr><span class="acronym">CP</span></abbr> set</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>a list with auxiliary ingredients (mode, coefficients of 
skewness and kurtosis, in the parametric and non-parametric variants, 
and more); see Section &lsquo;Details&rsquo; for more information.</p>
</td></tr>
</table>
<p>The list items <code>dp</code> and <code>cp</code> are vectors if <code>class(object)</code> is  
<code>SECdistrUv</code> (univariate distribution); they are lists if 
<code>class(object)</code> is <code>SECdistrMv</code> (multivariate distribution). 
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>Moors, I. J. A. (1988). A quantile alternative for kurtosis. 
<em>The Statistician</em> <b>37</b>, 25-32.
</p>
<p>Groeneveld, R. A. (2006).  Skewness, Bowley's measures of. 
In volume <b>12</b>, 7771-3, of <em>Encyclopedia of Statistical Sciences</em>, 
2nd edition, edited by Kotz et al. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code> for building a <abbr><span class="acronym">SEC</span></abbr> distribution
</p>
<p><code><a href="#topic+extractSECdistr">extractSECdistr</a></code> for extracting a <abbr><span class="acronym">SEC</span></abbr>
distribution from a <code><a href="#topic+selm">selm</a></code> fit 
</p>
<p>methods <code><a href="base.html#topic+mean">mean</a></code> and <code><a href="#topic+sd">sd</a></code> 
for computing the mean  and the standard deviation of 
<code><a href="#topic+SECdistrUv-class">SECdistrUv-class</a></code> objects,
methods <code><a href="base.html#topic+mean">mean</a></code> and  <code><a href="stats.html#topic+vcov">vcov</a></code> 
for computing the mean vector and the variance matrix of 
<code><a href="#topic+SECdistrMv-class">SECdistrMv-class</a></code> objects
</p>
<p><code><a href="#topic+modeSECdistr">modeSECdistr</a></code> for computing the mode directly 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f3 &lt;- makeSECdistr(dp=c(3,2,5), family="SC")
summary(f3)
s &lt;- summary(f3, probs=(1:9)/10)
print(slotNames(s)) 
print(names(slot(s,"aux")))   # the components of the 'aux' slot
slot(s, "aux")$mode           # the same of modeSECdistr(object=f3)
slot(s, "aux")$q.measures     # quantile-based measures of skewness and kurtosis
#
dp3 &lt;- list(xi=1:3, Omega=toeplitz(1/(1:3)), alpha=c(-3, 8, 5), nu=6)
st3 &lt;- makeSECdistr(dp=dp3, family="ST", name="ST3", compNames=c("U", "V", "W"))
s &lt;- summary(st3)
dp &lt;- slot(s, "dp")           # the same of slot(st3, "dp")
slot(s, "cp")$var.cov         # the same of vcov(st3)
slot(s, "aux")$delta.star     # comprehensive coefficient of shape
slot(s, "aux")$mardia         # Mardia's measures of skewness and kurtosis
#
dp2 &lt;- list(xi=rep(0,2), Omega=matrix(c(2,2,2,4),2,2), alpha=c(3,-5), tau=-1)
esn2 &lt;- makeSECdistr(dp=dp2, family="ESN", name="ESN-2d")
summary(esn2)
</code></pre>

<hr>
<h2 id='summary.SECdistrMv-class'>Classes <code>summary.SECdistrMv</code> and <code>summary.SECdistrUv</code></h2><span id='topic+summary.SECdistrMv-class'></span><span id='topic+summary.SECdistrUv-class'></span><span id='topic+show+2Csummary.SECdistrMv-method'></span><span id='topic+show+2Csummary.SECdistrUv-method'></span>

<h3>Description</h3>

<p>Summaries of objects of classes <code>SECdistrMv</code> and 
<code>SECdistrUv</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of type <code>summary(object)</code> when 
<code>object</code> is  of class either <code>"SECdistrMv"</code> or <code>"SECdistrUv"</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>family</code>:</dt><dd><p>A character string which represents
the parametric family of <abbr><span class="acronym">SEC</span></abbr> type </p>
</dd>
<dt><code>dp</code>:</dt><dd><p>Object of class <code>"list"</code> or <code>"vector"</code> for
<code>"SECdistrMv"</code> and <code>"SECdistrUv"</code>, respectively</p>
</dd>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code> with the name of 
distribution </p>
</dd>
<dt><code>compNames</code>:</dt><dd><p>For <code>"SECdistrMv"</code> objects, a character 
vector with names of the components of the multivariate distribution</p>
</dd>
<dt><code>cp</code>:</dt><dd><p>Object of class <code>"list"</code> or <code>"vector"</code> for
<code>"SECdistrMv"</code> and <code>"SECdistrUv"</code>, respectively</p>
</dd>
<dt><code>cp.type</code>:</dt><dd><p>a character string of the <abbr><span class="acronym">CP</span></abbr> version</p>
</dd>
<dt><code>aux</code>:</dt><dd><p>A list of auxiliary quantities </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "summary.SECdistrMv")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "summary.SECdistrUv")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.SECdistrMv">summary.SECdistrMv</a></code>, <code><a href="#topic+summary.SECdistrUv">summary.SECdistrUv</a></code>,
</p>
<p><code><a href="#topic+makeSECdistr">makeSECdistr</a></code>, <code><a href="#topic+dp2cp">dp2cp</a></code> </p>

<hr>
<h2 id='summary.selm'>Summarizing <code>selm</code> fits</h2><span id='topic+summary.selm'></span><span id='topic+summary.mselm'></span><span id='topic+summary+2Cselm-method'></span><span id='topic+summary+2Cmselm-method'></span><span id='topic+summary.selm-class'></span><span id='topic+summary.mselm-class'></span><span id='topic+show+2Csummary.selm-method'></span><span id='topic+show+2Csummary.mselm-method'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"selm"</code> and <code>"mselm"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'selm'
summary(object, param.type = "CP", cov = FALSE, cor = FALSE)

## S4 method for signature 'mselm'
summary(object, param.type = "CP", cov = FALSE, cor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.selm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"selm"</code> or <code>"mselm"</code> as created
by a call to function <code>selm</code>.</p>
</td></tr>
<tr><td><code id="summary.selm_+3A_param.type">param.type</code></td>
<td>
<p>a character string which indicates the required type of 
parameter type; possible values are <code>"CP"</code> (default), <code>"DP"</code>,
<code>"pseudo-CP"</code> and their equivalent lower-case  expressions.</p>
</td></tr>
<tr><td><code id="summary.selm_+3A_cov">cov</code></td>
<td>
<p>a logical value, to indicate if an estimate of the variance and 
covariance matrix of the estimates is required (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="summary.selm_+3A_cor">cor</code></td>
<td>
<p>a logical value, to indicate if an estimate of the correlation 
matrix of the estimates is required (default: <code>FALSE</code>).</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An S4 object of class <code>summary.selm</code> with 12 slots.
</p>
<table>
<tr><td><code>call:</code></td>
<td>
<p>the calling statement.</p>
</td></tr>
<tr><td><code>family:</code></td>
<td>
<p>the parametric family of skew-ellitically 
contoured distributed (<abbr><span class="acronym">SEC</span></abbr>) type.</p>
</td></tr>
<tr><td><code>logL:</code></td>
<td>
<p>the maximized log-likelihood or penalized 
log-likelihood value</p>
</td></tr>
<tr><td><code>method:</code></td>
<td>
<p>estimation method (<code>"MLE"</code> or <code>"MPLE"</code>)</p>
</td></tr>
<tr><td><code>param.type:</code></td>
<td>
<p>a characer string with the chosen parameter set.</p>
</td></tr>
<tr><td><code>param.table:</code></td>
<td>
<p>table of parameters, std.errors and z-values</p>
</td></tr>
<tr><td><code>fixed.param:</code></td>
<td>
<p>a list of fixed parameter values</p>
</td></tr>
<tr><td><code>resid:</code></td>
<td>
<p>residual values</p>
</td></tr>
<tr><td><code>control:</code></td>
<td>
<p>a list with control parameters</p>
</td></tr>
<tr><td><code>aux:</code></td>
<td>
<p>a list of auxiliary quantities</p>
</td></tr>
<tr><td><code>size:</code></td>
<td>
<p>a numeric vector with various lengths and dimensions</p>
</td></tr>
<tr><td><code>boundary:</code></td>
<td>
<p>a logical value which indicates whether the 
estimates are on the boundary of the parameter space</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are two reasons why the default choice of <code>param.type</code> is
<code>CP</code>.  One is the the easier interpretation of cumulant-based quantities
such as mean value, standard deviation, coefficient of skewness. 
</p>
<p>The other reason is more technical and applies only to cases when the 
estimate of the slant parameter <code class="reqn">alpha</code> of the <abbr><span class="acronym">SN</span></abbr> distribution 
is close to the origin: standard asymptotic distribution theory of maximum 
likelihood estimates (MLE's) does not apply in this case and the
corresponding standard errors are not trustworthy. 
The problem is especialy severe at
<code class="reqn">\alpha=0</code> but to some extent propagates to its vicinity. 
If <code class="reqn">d=1</code>, adoption of <code>CP</code> leads to MLE's with regular asymptotic 
distribution across the parameter space, including <code class="reqn">\alpha=0</code>. 
For <code class="reqn">d&gt;1</code> and <code class="reqn">\alpha=0,</code> the problem is still unsolved at the 
present time,  which is the reason why <code>selm</code> issues a warning
message when the MLE is in the vicinity of <code class="reqn">\alpha=0</code>; 
see &lsquo;Details&rsquo; of <code><a href="#topic+selm">selm</a></code>.  
For background information, see Sections 3.1.4&ndash;6 and 5.2.3 of 
Azzalini and Capitanio (2014)  and references therein.  
</p>
<p>This problem does not occur with the the <abbr><span class="acronym">SC</span></abbr> and the <abbr><span class="acronym">ST</span></abbr>
distribution (unless its tail-weight parameter <code>nu</code> diverges, that is, 
when we are effectively approaching the <code>SN</code> case). </p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selm">selm</a></code> function,  
<code><a href="#topic+selm-class">selm</a></code> (and <code>mselm</code>) class, 
<code><a href="#topic+plot.selm">plot.selm</a></code>, <code><a href="#topic+dp2cp">dp2cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(wines, package="sn")
m5 &lt;- selm(acidity ~ phenols + wine, family="SN", data=wines)
summary(m5)
summary(m5, "dp")
s5 &lt;- summary(m5, "dp", cor=TRUE, cov=TRUE)
dp.cor &lt;- slot(s5, "aux")$param.cor
cov2cor(vcov(m5, "dp")) # the same
#
# m6 &lt;- selm(acidity ~ phenols + wine, family="ST", data=wines) # boundary!?
#
m12 &lt;- selm(cbind(acidity, alcohol) ~ phenols + wine,  family="SN", data=wines)
s12 &lt;- summary(m12)
coef(m12, 'dp')
coef(m12, "dp", vector=FALSE)
#
# see other examples at function selm
</code></pre>

<hr>
<h2 id='summary.SUNdistr'>Summary of a <abbr><span class="acronym">SUN</span></abbr> distribution object</h2><span id='topic+summary.SUNdistr'></span><span id='topic+summary+2CSUNdistr-method'></span>

<h3>Description</h3>

<p>Produce a summary of an object of class <code>"SUNdistr"</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SUNdistr'
summary(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SUNdistr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"SUNdistr"</code>.</p>
</td></tr>
<tr><td><code id="summary.SUNdistr_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>mom.mtruncnorm</code> for the
regulation of its working.qq</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4-object with the following slots:
</p>
<table>
<tr><td><code>dp</code></td>
<td>
<p>the parameters of the distrbution, a list</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>the name of the distribution, a character string</p>
</td></tr>
<tr><td><code>compNames</code></td>
<td>
<p>the names of the components, a character vector</p>
</td></tr>
<tr><td><code>HcompNames</code></td>
<td>
<p>the names of the hidden components, a character vector</p>
</td></tr>   
<tr><td><code>mean</code></td>
<td>
<p>the mean value, a vector</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>the variance-covariance matrix</p>
</td></tr>
<tr><td><code>gamma1</code></td>
<td>
<p>the marginal indices of asymmetry, a vector</p>
</td></tr>
<tr><td><code>cum3</code></td>
<td>
<p>the third order cumulants, a three-dimensional array</p>
</td></tr>
<tr><td><code>mardia</code></td>
<td>
<p>the Mardia's measures of multivariate asymmetry and
skewness, a vector of length two</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B. and Azzalini, A. (2021).
Some properties of the unified skew-normal distribution.
<em>Statistical Papers</em>, 
<a href="https://doi.org/10.1007/s00362-021-01235-2">doi:10.1007/s00362-021-01235-2</a>
and <a href="https://arxiv.org/abs/2011.06316">arXiv:2011.06316</a>    
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code> for building a <abbr><span class="acronym">SUN</span></abbr> distribution object
</p>
<p>methods <code><a href="base.html#topic+mean">mean</a></code> and  <code><a href="stats.html#topic+vcov">vcov</a></code> 
for computing the mean vector and the variance matrix of 
<code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Omega &lt;- matrix(c(5, 1, 1, 6), 2, 2)
Delta &lt;- matrix(c(0.30, 0.50, 0.50, 0.85), 2, 2, byrow=TRUE)
Gamma &lt;- matrix(c(1, 0.18, 0.18, 1), 2, 2)
tau &lt;- c(0.4, -0.8)
dp2 &lt;- list(x=c(1, 0), Omega=Omega, Delta=Delta, tau=tau, Gamma=Gamma)
sun2 &lt;-  makeSUNdistr(dp=dp2, name="SUN2", compNames=c("u", "v"))
s &lt;- summary(sun2)
</code></pre>

<hr>
<h2 id='summary.SUNdistr-class'>Class <code>summary.SUNdistr</code></h2><span id='topic+summary.SUNdistr-class'></span><span id='topic+show+2Csummary.SUNdistr-method'></span>

<h3>Description</h3>

<p>Summaries of objects of classes <code>SUNdistr</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of type <code>summary(object)</code> when 
<code>object</code> is  of class <code>"SUNdistr"</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>dp</code>:</dt><dd><p>a list of parameters</p>
</dd>
<dt>name</dt><dd><p>the name of the distribution, a character string</p>
</dd>
<dt>compNames</dt><dd><p>the names of the components, a character vector</p>
</dd>
<dt>HcompNames</dt><dd><p>the names of the hidden components, a character vector</p>
</dd>   
<dt>mean</dt><dd><p>the mean value, a vector</p>
</dd>
<dt>var.cov</dt><dd><p>the variance-covariance matrix</p>
</dd>
<dt>gamma1</dt><dd><p>the marginal indices of asymmetry, a vector</p>
</dd>
<dt>cum3</dt><dd><p>the third order cumulants, a three-dimensional array</p>
</dd>
<dt>mardia</dt><dd><p>the Mardia's measures of multivariate asymmetry and
skewness, a vector of length two</p>
</dd>
</dl>



<h3>Methods</h3>

 
<dl>
<dt>show</dt><dd><p><code>signature(object = "summary.SUNdistr")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.SUNdistr">summary.SUNdistr</a></code>, <code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code></p>

<hr>
<h2 id='SUNdistr-base'>The Unified Skew-Normal (SUN) probability distribution</h2><span id='topic+SUNdistr-base'></span><span id='topic+dsun'></span><span id='topic+psun'></span><span id='topic+rsun'></span><span id='topic+sunMean'></span><span id='topic+sunVcov'></span><span id='topic+sunMardia'></span>

<h3>Description</h3>

<p>Density, distribution function, random number generation, the mean value,
the variance-covariance matrix and the Mardia's measures  of multivariate
skewness and kurtosis of the <abbr><span class="acronym">SUN</span></abbr> probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsun(x, xi, Omega, Delta, tau, Gamma, dp = NULL, log = FALSE, silent=FALSE, ...)
psun(x, xi, Omega, Delta, tau, Gamma, dp = NULL, log = FALSE, silent=FALSE, ...)
rsun(n=1, xi, Omega, Delta, tau, Gamma, dp = NULL, silent=FALSE)
sunMean(xi, Omega, Delta, tau, Gamma, dp = NULL, silent=FALSE, ...)
sunVcov(xi, Omega, Delta, tau, Gamma, dp = NULL, silent=FALSE, ...)
sunMardia(xi, Omega, Delta, tau, Gamma, dp = NULL, silent=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SUNdistr-base_+3A_x">x</code></td>
<td>
<p>either a vector of length <code>d</code>, where <code>d=ncol(Omega)</code>,
with the coordinates of the point where the density or the
distribution function must be evaluated, or alternatively
a <code>d</code>-column matrix whose rows represent a set of points.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_xi">xi</code></td>
<td>
<p>a numeric vector of length <code>d</code> representing the 
location parameter of the distribution; see &lsquo;Background&rsquo;.
In a call to <code>dsun</code> and <code>psun</code>, <code>xi</code> can be a matrix,
whose rows represent a set of location parameters;
in this case, its dimensions must match those of <code>x</code>.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_omega">Omega</code></td>
<td>
<p>a symmetric positive definite matrix of dimension <code>(d,d)</code>;
see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_delta">Delta</code></td>
<td>
<p>a matrix of size <code>(d,m)</code>, where <code>m=length(tau)</code>;
see &lsquo;Details&rsquo; about its constraints.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_tau">tau</code></td>
<td>
<p>a vector of length <code>m</code>, say.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_gamma">Gamma</code></td>
<td>
<p>a symmetric positive definite matrix of dimension <code>(m,m)</code>
with 1's on its main diagonal, that is, a correlation matrix</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_dp">dp</code></td>
<td>
<p>a list with five elements, representing <code>xi</code> 
(which must be a vector in this case), 
<code>Omega</code>, <code>Delta</code>, <code>tau</code> and <code>Gamma</code>, 
with restrictions indicated in the &lsquo;Details&rsquo;.
Its default value is <code>NULL</code>;  if <code>dp</code> is assigned, 
the individual parameters must not be specified.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_n">n</code></td>
<td>
<p>a positive integer value.</p>
</td></tr> 
<tr><td><code id="SUNdistr-base_+3A_log">log</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>); 
if <code>TRUE</code>, log-densities and log-probabilities are returned.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_silent">silent</code></td>
<td>
<p>a logical value which indicates the action to take in the case
<code>m=1</code>, which could be more convenently handled by functions for the
<abbr><span class="acronym">SN/ESN</span></abbr> family. If <code>silent=FALSE</code> (default value), a warning
message is issued; otherwise this is suppressed.</p>
</td></tr>
<tr><td><code id="SUNdistr-base_+3A_...">...</code></td>
<td>
<p>additional tuning arguments passed either to 
<code><a href="mnormt.html#topic+pmnorm">pmnorm</a></code> (for <code>dsun</code>, 
<code>psun</code> and <code>sunMean</code>) or to <code><a href="mnormt.html#topic+mom.mtruncnorm">mom.mtruncnorm</a></code> 
(for <code>sunVcov</code> and <code>sunMardia</code>); see also &lsquo;Details&rsquo;. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A member of the <abbr><span class="acronym">SUN</span></abbr> family of distributions is identified by five 
parameters, which are described  in the &lsquo;Background&rsquo; section.  
The five parameters can be supplied by combining them in a list, denoted
<code>dp</code>, in which case the individual parameters must <em>not</em> be
supplied. The elements of <code>dp</code> must appear in the above-indicated order
and must be named.
</p>
<p>The optional arguments in <code>...</code> passed to <code><a href="mnormt.html#topic+pmnorm">pmnorm</a></code>,
which uses <code><a href="mnormt.html#topic+ptriv.nt">ptriv.nt</a></code> when <code>d=3</code>, 
<code><a href="mnormt.html#topic+biv.nt.prob">biv.nt.prob</a></code> when <code>d=2</code> and 
and <code><a href="mnormt.html#topic+sadmvn">sadmvn</a></code> when <code>d&gt;2</code>.
In practice these arguments are effective only if <code>d&gt;3</code>, 
since for lower dimensions the computations are made to full available 
precision anyway.
A similar fact applies to the <code>...</code> argument passed to 
<code><a href="mnormt.html#topic+mom.mtruncnorm">mom.mtruncnorm</a></code>. 
</p>
<p>Some numerical inaccuracy is inevitably involved in these computations.
In most cases,  they are of negligible extent, but they can possibly become
more relevant, especially in the computation of higher order moments
involved by <code>sunMardia</code>, depending on the dimension <code>d</code> and on 
the specific parameter values.
Consider the &lsquo;Warning&rsquo; section in <code><a href="mnormt.html#topic+recintab">recintab</a></code>
which is used by <code><a href="mnormt.html#topic+mom.mtruncnorm">mom.mtruncnorm</a></code>. 
</p>
<p>The above-described functions operate following the traditional <span class="rlang"><b>R</b></span> scheme for 
probability distributions. Another scheme, coexisting with the classical one, 
works with <code>SUNdistr-class</code> objects, which represent <abbr><span class="acronym">SUN</span></abbr> 
distributions, by encapsulating their parameters and other characteristics. 
These objects are created by <code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code>, and various methods 
exist for them; see <code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code>. 
Moreover these objects can be manipulated by a number of tools, described 
in <code><a href="#topic+SUNdistr-op">SUNdistr-op</a></code>, leading to new objects of the same class.
</p>


<h3>Value</h3>

<p>The structure of the returned value depends on the called function, as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code>dsun, psun</code>  </td><td style="text-align: left;"> a vector of length <code>nrow(x)</code> representing 
                          density or probability values, </td>
</tr>
<tr>
 <td style="text-align: right;">
             </td><td style="text-align: left;"> or their log-transformed values if <code>log=TRUE</code>,</td>
</tr>
<tr>
 <td style="text-align: right;">
 <code>rsun</code> </td><td style="text-align: left;"> a matrix of size <code>(n,d)</code>, 
                  where each row represents a <abbr><span class="acronym">SUN</span></abbr> random vectors,</td>
</tr>
<tr>
 <td style="text-align: right;">
 <code>sunMean</code> </td><td style="text-align: left;"> a vector of length <code>d</code> representing the mean value,</td>
</tr>
<tr>
 <td style="text-align: right;">
 <code>sunVcov</code> </td><td style="text-align: left;"> a matrix of size <code>(d,d)</code>  representing the 
   variance-covariance matrix,</td>
</tr>
<tr>
 <td style="text-align: right;">
 <code>sunMardia</code> </td><td style="text-align: left;"> a vector of length two with the Mardia's measures of
   multivariate skewness and kurtosis.
 </td>
</tr>

</table>



<h3>Background</h3>

<p>A member of the <abbr><span class="acronym">SUN</span></abbr> family is characterized by two
dimensionality indices, denoted <code class="reqn">d</code> and <code class="reqn">m</code>, and a set of five
parameters blocks (vector and matrices, as explained soon).  
The value <code class="reqn">d</code> represents the number of observable
components; the value <code class="reqn">m</code> represents the number of latent (or hidden)
variables notionally involved in the construction of the distribution.
The parameters and their corresponding <span class="rlang"><b>R</b></span> variables are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code class="reqn">\xi</code>    </td><td style="text-align: center;"> <code>xi</code>    </td><td style="text-align: left;"> a vector of length <code class="reqn">d</code>, </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code class="reqn">\Omega</code> </td><td style="text-align: center;"> <code>Omega</code> </td><td style="text-align: left;"> a matrix of size <code class="reqn">(d,d)</code>, </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code class="reqn">\Delta</code> </td><td style="text-align: center;"> <code>Delta</code> </td><td style="text-align: left;"> a matrix of size <code class="reqn">(d,m)</code>, </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code class="reqn">\tau</code>   </td><td style="text-align: center;"> <code>tau</code>   </td><td style="text-align: left;"> a vector of length <code class="reqn">m</code>, </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code class="reqn">\Gamma</code> </td><td style="text-align: center;"> <code>Gamma</code> </td><td style="text-align: left;"> a matrix of size <code class="reqn">(m,m)</code>,  
 </td>
</tr>

</table>

<p>and must satisfy the following  conditions:  
</p>

<ol>
<li> <p><code class="reqn">\Omega</code> is a symmetric positive definite matrix;
</p>
</li>
<li> <p><code class="reqn">\Gamma</code> is a symmetric positive definite matrix with 1's 
on the main diagonal, hence a correlation matrix;
</p>
</li>
<li><p> if <code class="reqn">\bar\Omega</code>  
denotes the correlation matrix associated to <code class="reqn">\Omega</code>,  
the matrix of size <code class="reqn">(d+m)\times(d+m)</code>
formed by the <code class="reqn">2 x 2</code> blocks
 
</p>

<table>
<tr>
 <td style="text-align: right;">
            </td><td style="text-align: right;">  </td><td style="text-align: center;"> <code class="reqn">\bar\Omega</code>  </td><td style="text-align: center;">  <code class="reqn">\Delta</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
            </td><td style="text-align: right;">  </td><td style="text-align: center;"> <code class="reqn">\Delta'</code>  </td><td style="text-align: center;">  <code class="reqn">\Gamma</code>  </td>
</tr>

</table>


<p>must be a positive definite correlation matrix.</p>
</li></ol>

<p>The formulation adopted here has arisen as the evolution of earlier 
constructions, which are recalled very briefly next.
A number of extensions of the multivariate skew-normal distributions, 
all involving a number <code>m</code> (with <code class="reqn">m\ge1</code>) of latent variables 
(instead of <code>m=1</code> like the skew-normal distribution), 
have been put-forward in close succession in the years 2003-2005. 
Special attention has been drawn by the &lsquo;closed skew-normal (CSN)&rsquo;
distribution  developed by González-Farías <em>et alii</em> (2004a, 2004b)
and the &lsquo;fundamental skew-normal  (FUSN)&rsquo; distribution
developed by Arellano-Valle and Genton (2005),
but other formulations have been considered too.
</p>
<p>Arellano Valle and Azzalini (2006) have shown the essential equivalence
of these apparently alternative constructions, after appropriate
reparameterizations, and underlined the necessity of removing 
over-parameterizations in some cases, to avoid lack of identifiability. 
This elaboration has led to the <abbr><span class="acronym">SUN</span></abbr> formulation. 
A relatively less technical account of their development is provided 
in Section 7.1 of Azzalini and Capitanio (2014), using very slightly 
modified notation and parameterization, which are the ones adopted here.  
</p>
<p>Additional results have been presented by Arellano-Valle 
and Azzalini (2021), such as expressions for the variance matrix
and higher order moments, the Mardia's measures of multivariate  skewness
and kurtosis, which are implemented here. Another result is the
conditional distribution when the conditioning event is represented
by an orthant.
</p>


<h3>Note</h3>

<p>The present structure and user interface of this function, and of other ones 
related to the <abbr><span class="acronym">SUN</span></abbr> distribution, must be considered experimental, 
and they might possibly change in the future.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B., and Azzalini, A. (2006).
On the unification of families of skew-normal distributions.
<em>Scand. J. Stat.</em> <b>33</b>, 561-574. 
Corrigendum in  <b>49</b> (2022), 1418-1419.
</p>
<p>Arellano-Valle, R. B. and Azzalini, A. (2021).
Some properties of the unified skew-normal distribution.
<em>Statistical Papers</em> <b>63</b>, 461-487,
<a href="https://doi.org/10.1007/s00362-021-01235-2">doi:10.1007/s00362-021-01235-2</a>;
see also <a href="https://arxiv.org/abs/2011.06316">arXiv:2011.06316</a>
</p>
<p>Arellano-Valle, R. B. and Genton, M. G. (2005). 
On fundamental skew distributions. 
<em>J. Multivariate Anal.</em> <b>96</b>, 93–1116.
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>
<p>González-Farías, G., Domínguez-Molina, J. A., &amp; Gupta, A. K. (2004a). 
Additive properties of skew normal random vectors.
<em>J. Statist. Plann. Inference</em> <b>126</b>, 521-534.
</p>
<p>González-Farías, G., Domínguez-Molina, J. A., &amp; Gupta, A. K. (2004b). 
The closed skew-normal distribution. 
In M. G. Genton (Ed.), <em>Skew-elliptical Distributions and Their 
Applications: a Journey Beyond Normality</em>, Chapter 2, (pp. 25–42). 
Chapman &amp; Hall/<abbr><span class="acronym">CRC</span></abbr>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code> to build a <abbr><span class="acronym">SUN</span></abbr> distribution object, 
with related methods in <code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code>,
and other facilities in <code><a href="#topic+SUNdistr-op">SUNdistr-op</a></code>
</p>
<p><code><a href="#topic+convertCSN2SUNpar">convertCSN2SUNpar</a></code> to convert a parameter set of the Closed 
Skew-Normal formulation to the equivalent <abbr><span class="acronym">SUN</span></abbr> parameter set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- c(1, 0, -1)
Omega &lt;- matrix(c(2,1,1, 1,3,1, 1,1,4), 3, 3)
Delta &lt;- matrix(c(0.72,0.20, 0.51,0.42, 0.88, 0.94), 3, 2, byrow=TRUE)
Gamma &lt;- matrix(c(1, 0.8, 0.8, 1), 2, 2)
dp3 &lt;- list(xi=xi, Omega=Omega, Delta=Delta, tau=c(-0.5, 0), Gamma=Gamma)
x &lt;- c(0.8, 0.5, -1.1)
f1 &lt;- dsun(x, xi, Omega, Delta, c(-0.5, 0), Gamma) # mode 1
f2 &lt;- dsun(x, dp=dp3)   # mode 2, equivalent to mode 1
set.seed(1)
xm &lt;- rsun(10, dp=dp3)
f3 &lt;- dsun(xm, dp=dp3) 
psun(xm, dp=dp3)
sunMean(dp=dp3)
sunVcov(dp=dp3)
sunMardia(dp=dp3)
</code></pre>

<hr>
<h2 id='SUNdistr-class'>Class <code>"SUNdistr"</code> and its methods</h2><span id='topic+SUNdistr-class'></span><span id='topic+show.SUNdistr'></span><span id='topic+show+2CSUNdistr-method'></span><span id='topic+mean.SUNdistr'></span><span id='topic+mean+2CSUNdistr-method'></span><span id='topic+vcov.SUNdistr'></span><span id='topic+vcov+2CSUNdistr-method'></span>

<h3>Description</h3>

<p>A class of objects representing Unified Skew-Normal (<abbr><span class="acronym">SUN</span></abbr>) 
distributions.</p>


<h3>Details</h3>

<p>See <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code> for a  description of the 
required structure of <code>dp</code>.
</p>
<p>Note that here the methods <code>mean</code> and <code>vcov</code>  are not applied
to data or to a fitted model, but to a <em>probability
distribution</em>,  of which they provide the mean (expected) value
and the variance-covariance matrix.
</p>
<p>The object of this class follow the S4 protocol.
</p>


<h3>Objects from the class</h3>

<p>Objects can be created by a call to the function <code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code> 
or by a suitable transformation of some object of this class.</p>


<h3>Slots</h3>


<dl>
<dt><code>dp</code>:</dt><dd><p>a list of parameters of length five, 
as described in <code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code> </p>
</dd>
<dt><code>name</code>:</dt><dd><p>a character string with the name of the multivariate
variable; it can be an empty string.</p>
</dd>
<dt><code>compNames</code>:</dt><dd><p>a vector of character strings with the names of 
the component variables.</p>
</dd>
<dt>HcompNames</dt><dd><p>a vector of character strings with the names of the 
hidden variables.</p>
</dd>    
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "SUNdistr-class")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "SUNdistr-class")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "SUNdistr-class")</code>: ... </p>
</dd>
<dt>mean</dt><dd><p><code>signature(x = "SUNdistr")</code>: ...</p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "SUNdistr")</code>: ...</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CSUNdistr-method">plot,SUNdistr-method</a></code>, <code class="reqn">\quad</code>
<code><a href="#topic+summary+2CSUNdistr-method">summary,SUNdistr-method</a></code>, <code class="reqn">\quad</code>
<code><a href="#topic+affineTransSUNdistr">affineTransSUNdistr</a></code>,  <code><a href="#topic+marginalSUNdistr">marginalSUNdistr</a></code>
</p>
<p><code><a href="#topic+convertSN2SUNdistr">convertSN2SUNdistr</a></code> to convert a <code>SECdistr</code> object with
family <code>"SN"</code> or <code>"ESN"</code> to the equivalent <code>SUNdistr-class</code>
object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  xi &lt;- c(1, 0, -1)
  Omega &lt;- matrix(c(2,1,1, 1,3,1, 1,1,4), 3, 3)
  Delta &lt;- matrix(c(0.72,0.20, 0.51,0.42, 0.88, 0.94), 3, 2, byrow=TRUE)
  Gamma &lt;- matrix(c(1, 0.8, 0.8, 1), 2, 2)
  dp3 &lt;- list(xi=xi, Omega=Omega, Delta=Delta, tau=c(-0.5, 0), Gamma=Gamma)
  sun3 &lt;- makeSUNdistr(dp=dp3, name="firstSUN", compNames=c("x", "w", "z"))
  show(sun3)
  plot(sun3)
  mean(sun3)  # the mean value of the probability distribution
  vcov(sun3)  # the variance-covariance matrix of the probability distribution
  summary(sun3)  # a more detailed summary
</code></pre>

<hr>
<h2 id='SUNdistr-op'>Operations on SUNdistr-class objects</h2><span id='topic+SUNdistr-op'></span><span id='topic+affineTransSUNdistr'></span><span id='topic+conditionalSUNdistr'></span><span id='topic+convolutionSUNdistr'></span><span id='topic+joinSUNdistr'></span><span id='topic+marginalSUNdistr'></span>

<h3>Description</h3>

<p>Given an object of <code>SUNdistr-class</code>, or possibly two such things
in some cases, the functions   perform various operations,
and produce a new object of the same class.</p>


<h3>Usage</h3>

<pre><code class='language-R'>affineTransSUNdistr(object, a, A, name, compNames, HcompNames, drop = TRUE)
conditionalSUNdistr(object, comp, values, eventType = "=", name, drop = TRUE) 
convolutionSUNdistr(object1, object2, name, compNames, HcompNames) 
joinSUNdistr(object1, object2, name, compNames, HcompNames) 
marginalSUNdistr(object, comp, name, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SUNdistr-op_+3A_object">object</code>, <code id="SUNdistr-op_+3A_object1">object1</code>, <code id="SUNdistr-op_+3A_object2">object2</code></td>
<td>
<p>objects of class <code>SUNdistr</code></p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_a">a</code></td>
<td>
<p>a numeric vector; see &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_a">A</code></td>
<td>
<p>a numeric matrix; see &lsquo;Details&rsquo;</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_name">name</code></td>
<td>
<p>an optional character string with the name of the returned
distribution</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_compnames">compNames</code></td>
<td>
<p>an optional vector of character strings with the names 
of the component variables of the returned distribution</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_hcompnames">HcompNames</code></td>
<td>
<p>an optional vector of character strings with the names 
of the hidden variables of the returned distribution</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_drop">drop</code></td>
<td>
<p>a logical value (default: <code>TRUE</code>)  relevant only in the
case <code>m=1</code>. When both <code>m=1</code> and <code>drop=TRUE</code>, the 
returned object is of class either <code>SECdistrUv</code> or <code>SECdistrMv</code>,
depending on the dimension of the returned object, and family 
<code>"SN"</code> or <code>"ESN"</code>, as appropriate.</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_comp">comp</code></td>
<td>
<p>a vector of integers representing the selected components</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_values">values</code></td>
<td>
<p>a numeric vector which identifies the conditioning event</p>
</td></tr>
<tr><td><code id="SUNdistr-op_+3A_eventtype">eventType</code></td>
<td>
<p>a single character value which indicates the type of the
conditioning event, as described in the &lsquo;Details&rsquo; section;
possible values are <code>"="</code> (default) and <code>"&gt;"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For  an <code>object</code> which represents the distribution of a multivariate 
<abbr><span class="acronym">SUN</span></abbr> random variable <code class="reqn">Y</code> of dimension <code>d</code>, say, a number of
operations are possible, producing a new object of the same class.
This <code>object</code> could have been created by <code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code> 
or it could be the outcome from some previous call to one of the functions
described here.
</p>
<p>The function <code>affineTransSUNdistr</code> computes  the distribution of
<code class="reqn">a+A'Y</code>,  provided <code>A</code> is a full-rank matrix with
<code>nrow(A)=d</code> and <code>length(a)=ncol(A)</code>.
See equation (7.6) of Azzalini &amp; Capitanio (2014).
</p>
<p>The function <code>marginalSUNdistr</code>  builds a <abbr><span class="acronym">SUN</span></abbr> distribution 
from the components selected by the <code>comp</code> vector.
</p>
<p>A conditional distribution can be computed using <code>conditionalSUNdistr</code> 
for two type of events, selected by <code>eventType</code>. 
The <code>"="</code> case corresponds to the event <code class="reqn">Y_1=y_1</code> where 
<code class="reqn">Y_1</code> is the subset of components identified
by  the <code>comp</code> argument, <code class="reqn">y_1</code> is vector specified by the 
<code>values</code> argument and the equality sign must hold for each component.
See equation (7.6) of Azzalini &amp; Capitanio (2014).
</p>
<p>If <code>conditionalSUNdistr</code> is used with <code>eventType="&gt;"</code>,
the conditiong refers to the event <code class="reqn">Y_1&gt;y_1</code>, 
where the inequality must be interpreted components-wise;
see Arellano-Valle &amp; Azzalini (2021) for the underlying mathematical result.
If the conditional distribution is required for the reverse inequality 
condition, <code>"&lt;"</code> say, 
this is equivalent to consideration of the event <code class="reqn">-Y_1&gt;-y_1</code>. 
The corresponding distribution can be obtained in two steps: 
first a new variable is constructed reversing the sign of the required
components using <code>affineTransSUNdistr</code>;
then <code>conditionalSUNdistr</code> is applied to this new variable with
the <code>"&gt;"</code> condition and values <code class="reqn">-y_1</code>. 
More complex conditions, where the <code>"&lt;"</code> and <code>"&gt;"</code> signs 
are mixed for different component varables, can be handled similarly, 
by introducing a square matrix <code>A</code> for <code>affineTransSUNdistr</code> 
having an appropriate combination of <code>1</code>s' and <code>-1</code>'s on its main
diagonal, and 0's elsewhere, and  matching changes of sign to the components  
of <code class="reqn">y_1</code>.
</p>
<p>Functions <code>convolutionSUNdistr</code> and <code>joinSUNdistr</code> operate under 
the assumptions that <code>object1</code> and <code>object2</code> refer to independent 
variables. 
Specifically, <code>convolutionSUNdistr</code> computes the convolution of the
two objects (i.e. the distribution of the sum of two independent variables),
which must have the same dimension <code>d</code>. 
Function <code>joinSUNdistr</code> combines two objects into a joint distribution.
</p>
<p>If the arguments <code>name</code>, <code>compNames</code> and <code>HcompNames</code>
are missing, they are composed from the supplied arguments.
</p>


<h3>Value</h3>

<p>an object of <code>SUNdistr-class</code></p>


<h3>Note</h3>

<p>The present structure and user interface of this function, and of other ones 
related to the <abbr><span class="acronym">SUN</span></abbr> distribution, must be considered experimental, 
and they might possibly change in the future.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B. and Azzalini, A. (2021).
Some properties of the unified skew-normal distribution.
<em>Statistical Papers</em>, 
<a href="https://doi.org/10.1007/s00362-021-01235-2">doi:10.1007/s00362-021-01235-2</a>
and <a href="https://arxiv.org/abs/2011.06316">arXiv:2011.06316</a>  
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SUNdistr-base">SUNdistr-base</a></code>, <code><a href="#topic+makeSUNdistr">makeSUNdistr</a></code>,
<code><a href="#topic+SUNdistr-class">SUNdistr-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xi &lt;- c(1, 0, -1)
Omega &lt;- matrix(c(2,1,1, 1,3,1, 1,1,4), 3, 3)
Delta &lt;- matrix(c(0.72,0.20, 0.51,0.42, 0.88, 0.94), 3, 2, byrow=TRUE)
Gamma &lt;- matrix(c(1, 0.8, 0.8, 1), 2, 2)
dp3 &lt;- list(xi=xi, Omega=Omega, Delta=Delta, tau=c(-0.5, 0), Gamma=Gamma)
sun3 &lt;- makeSUNdistr(dp=dp3, name="SUN3", compNames=c("x", "w", "z"))
#
a &lt;- c(1,-2)
A &lt;- matrix(1:6, 3, 2)
sun2at &lt;- affineTransSUNdistr(sun3, a, A, "SUN2at", compNames=c("at1", "at2"))
sun2m &lt;- marginalSUNdistr(sun3, comp=c(1,3), name="SUN2m")
sun1c &lt;- conditionalSUNdistr(sun3, comp=c(1,3), values=c(1.1, 0.8),
            eventType="&gt;", name="SUN1c", drop=FALSE)
#
Omega &lt;- matrix(c(5, 1, 1, 6), 2, 2)
Delta &lt;- matrix(c(0.30, 0.50, 0.50, 0.85), 2, 2, byrow=TRUE)
Gamma &lt;- matrix(c(1, 0.18, 0.18, 1), 2, 2)
tau &lt;- c(0.4, -0.8)
dp2 &lt;- list(x=c(1, 0), Omega=Omega, Delta=Delta, tau=tau, Gamma=Gamma)
sun2 &lt;-  makeSUNdistr(dp=dp2, name="SUN2", compNames=c("u", "v"))
#
sun2conv &lt;- convolutionSUNdistr(sun2, sun2m, name="SUN2sum")
sun5 &lt;- joinSUNdistr(sun3, sun2)
</code></pre>

<hr>
<h2 id='symm-modulated-distr'>Symmetry-modulated distributions</h2><span id='topic+SymmModulatedDistr'></span><span id='topic+dSymmModulated'></span><span id='topic+rSymmModulated'></span><span id='topic+dmSymmModulated'></span><span id='topic+rmSymmModulated'></span><span id='topic+plot2D.SymmModulated'></span>

<h3>Description</h3>

<p>Symmetry-modulated distributions, univariate and multivariate,
AKA skew-symmetric distributions</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSymmModulated(x, xi=0, omega=1, f0, G0, w, par.f0, par.G0, odd="check", 
  log=FALSE, ...)
rSymmModulated(n=1, xi=0, omega=1, f0, G0, w, par.f0, par.G0, odd="check", ...) 
dmSymmModulated(x, xi, Omega, f0, G0, w, par.f0, par.G0, odd="check", 
  log=FALSE, ...) 
rmSymmModulated(n=1, xi, Omega, f0, G0, w, par.f0, par.G0, odd="check", ...)
plot2D.SymmModulated(range, npt=rep(101,2), xi=c(0,0), Omega, f0, G0, w, 
  par.f0, par.G0, odd="check", ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm-modulated-distr_+3A_x">x</code></td>
<td>
<p>a vector of coordinates where the density must be evaluated; 
for multivariate densities, evaluated by <code>dmSymmModulated</code>, 
a matrix is also allowed, each row representing a point.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_xi">xi</code></td>
<td>
<p>a numeric vector representing the location parameter; 
if must have length 1 for <code>dSymmModulated</code> and <code>rSymmModulated</code>,
length 2 for <code>plot2D.SymmModulated</code>).</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_omega">omega</code></td>
<td>
<p>a positive value representing the scale parameter.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_f0">f0</code></td>
<td>
<p>a character string denoting the symmetric density to be modulated;
admissible values for <code>dSymmModulated</code> and <code>dSymmModulated</code> 
are <code>"beta"</code>, <code>"cauchy"</code>, <code>"logistic"</code> (or <code>"logis"</code>), 
<code>"normal"</code> (or <code>"norm"</code>), <code>"t"</code>, <code>"uniform"</code>;   
for the other functions the possible 
values are <code>"cauchy"</code>, <code>"normal"</code> (or <code>"norm"</code>), <code>"t"</code>; 
the meaning of the names is described in the &lsquo;Details&rsquo;  section.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_g0">G0</code></td>
<td>
<p>a character string denoting the symmetric distribution used in the
modulating factor; admissible values are <code>"beta"</code>, <code>"cauchy"</code>, 
<code>"logistic"</code> (or <code>"logis"</code>), <code>"normal"</code> (or <code>"norm"</code>), 
<code>"t"</code>, <code>"uniform"</code>,  with meaning  described in the
&lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_w">w</code></td>
<td>
<p>the name (<em>not</em> as a character string) of a user-defined 
function which satisfies the condition <code class="reqn">w(-z)=-w(z)</code> for all <code class="reqn">z</code>;
see the &lsquo;Details&rsquo; section for additional specifications.</p>
</td></tr>    
<tr><td><code id="symm-modulated-distr_+3A_par.f0">par.f0</code>, <code id="symm-modulated-distr_+3A_par.g0">par.G0</code></td>
<td>
<p>parameters required by <code>f0</code> and <code>G0</code>, 
when they are of type <code>"beta"</code> or <code>"t"</code>, otherwise ignored.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_odd">odd</code></td>
<td>
<p>a character string, with possible values <code>"check"</code> (default),
&quot;assume&quot;, &quot;force&quot;,  for regulation of the behaviour about the condition
that <code>w</code> is an odd function, as explained in the &lsquo;Details&rsquo;
section.</p>
</td></tr> 
<tr><td><code id="symm-modulated-distr_+3A_log">log</code></td>
<td>
<p>logical (default: <code>FALSE</code>); 
if <code>TRUE</code>, densities are given as log(densities).</p>
</td></tr> 
<tr><td><code id="symm-modulated-distr_+3A_n">n</code></td>
<td>
<p>an integer value (default: <code>n=1</code>) indicating the number of 
random numbers.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_omega">Omega</code></td>
<td>
<p>a symmetric positive-definite matrix which regulates the 
dependence structure of <code>f0</code> and so of the final density.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_range">range</code></td>
<td>
<p>a two-column matrix whose column-wise range is taken as the
plotting intervals  on the coordinated axes forming a bivariate grid of
points over which the density is plotted.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_npt">npt</code></td>
<td>
<p>a numeric vector with two elements representing the number of  
equally-spaced points on each axis spanning the <code>range</code> described 
above;  default value is <code>rep(101,2)</code>.</p>
</td></tr>
<tr><td><code id="symm-modulated-distr_+3A_...">...</code></td>
<td>
<p>optional parameters regulating the function <code>w</code> and, for 
<code>plot2D.SymmModulated</code> only, graphical parameters to be supplied to
function <code><a href="graphics.html#topic+contour">contour</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>dSymmModulated</code>, <code>rSymmModulated</code> and  <code>dmSymmModulated</code>, 
a numeric vector; for <code>dmSymmModulated</code> a matrix, unless <code>n=1</code>.
</p>
<p>For <code>plot2D.SymmModulated</code> an invisible list containing the <code>x</code>
and <code>y</code> coordinates forming the grid over which the density <code>pdf</code>
has been evaluated for plotting.
</p>


<h3>Background</h3>

<p>In the univariate case, start from symmetric density function <code class="reqn">f_0</code>, 
such that  <code class="reqn">f_0(z)=f_0(-z)</code> for all <code class="reqn">z</code>, and 
&lsquo;modulate&rsquo;  it in the form 
</p>
<p style="text-align: center;"><code class="reqn">f(z) = 2\, f_0(z)\, G_0\{w(z)\}</code>
</p>

<p>where <code class="reqn">G_0</code> is a univariate symmetric (about 0) distribution function 
and <code class="reqn">w(z)</code>is a real-valued odd function, hence satisfying the condition 
<code class="reqn">w(-z)=-w(z)</code>;
then $f(z)$ is a proper density function wich integrates to 1. 
A subsequent location and scale transformation applied to <code class="reqn">f(z)</code> 
delivers the final density. 
Specifically, if <code class="reqn">Z</code> denotes a univariate random variable with density 
<code class="reqn">f(z)</code>, then the computed density pertains to the transformed variable
</p>
<p style="text-align: center;"><code class="reqn">\xi + \omega Z.</code>
</p>

<p>In the multivariate case, the scheme is similar, with natural adaptation.
Density <code class="reqn">f_0</code> is  now <code class="reqn">d</code>-dimensional, while <code class="reqn">G_0</code> 
is still univariate. The conditions <code class="reqn">f_0(z)=f_0(-z)</code> 
and <code class="reqn">w(-z)=-w(z)</code> refer to a <code class="reqn">d</code>-dimensional vector <code class="reqn">z</code>.  
Given a <code class="reqn">d \times d</code> symmetric positive-definite matrix 
<code class="reqn">\Omega</code>, we extract the the square roots <code class="reqn">\omega</code> of the diagonal 
element of  <code class="reqn">\Omega</code> and correspondingly obtain the scale-free matrix
</p>
<p style="text-align: center;"><code class="reqn">\bar\Omega = \mathrm{diag}(\omega)^{-1}\, \Omega\,
                             \mathrm{diag}(\omega)^{-1}
     </code>
</p>

<p>which is used to regulate the dependence structure of <code class="reqn">f_0(z)</code> 
and so of <code class="reqn">f(z)</code>. 
If <code class="reqn">Z</code> is multivariate random variable with density <code class="reqn">f(z)</code>, 
then the final distribution refers to 
</p>
<p style="text-align: center;"><code class="reqn">\xi + \mathrm{diag}(\omega)\,Z </code>
</p>

<p>where <code class="reqn">\xi</code> is a <code class="reqn">d</code>-dimensional vector of location parametes.
</p>
<p>This construction was put forward by Azzalini and Capitanio (2003). 
An essentially equivalent formulation has been presented by Wang et al. (2004).
A summary account is available in Section 1.2 of Azzalini and Capitanio
(2014); this includes, inter alia, an explanation  of why the term
&lsquo;symmetry-modulated&rsquo; distributions is preferred to 
&lsquo;skew-symmetric&rsquo; distributions. 
</p>
<p>Random number generation is based on expression (1.11a) of
Azzalini and Capitanio (2014).
</p>


<h3>Details</h3>

<p>Functions <code>dSymmModulated</code> and <code>rSymmModulated</code> deal with univariate 
distributions, for computing densities and generating random rumbers, 
respectively; 
<code>dmSymmModulated</code> and <code>rmSymmModulated</code> act similarly 
for multivariate distributions. For the bivariate case only,
<code>plot2D.SymmModulated</code> computes a density over a grid of
coordinates and produces a <code>contour</code> plot. 
</p>
<p>The distribution names used in <code>f0</code> and <code>G0</code> have, in the univariate
case, the same meaning as described in the <code><a href="stats.html#topic+Distributions">Distributions</a></code>
page, with the following exceptions, to achive symmetry about 0: 
<code>"uniform"</code> denotes a  uniform distribution over the interval 
<code class="reqn">(-1, 1)</code>; <code>"beta"</code> denotes the a symmetric Beta distribution with
support  over the interval <code class="reqn">(-1, 1)</code> and a common value of the shape 
parameters.
</p>
<p>In the multivariate case, the available options <code>"normal"</code> and <code>"t"</code>
for <code>f0</code> refer to densities computed by  <code><a href="mnormt.html#topic+dmnorm">dmnorm</a></code> 
and <code><a href="mnormt.html#topic+dmt">dmt</a></code> with 0 location and correlation matrix   
<code class="reqn">\bar\Omega</code>, implied by <code class="reqn">\Omega</code>. 
Argument <code>G0</code> has the same meaning as in the univariate case.
</p>
<p>Options <code>"beta"</code> and <code>"t"</code> for <code>f0</code> and <code>G0</code> require the
specification of a shape parameter, via the arguments <code>par.f0</code> and
<code>par.G0</code>, respectively. For <code>"beta"</code> the parameter represents
the common value of the shape parameters of <code><a href="stats.html#topic+Beta">Beta</a></code>;
for <code>"t"</code>, it represents <code>df</code> of <code><a href="stats.html#topic+TDist">TDist</a></code> and
<code><a href="mnormt.html#topic+dmt">dmt</a></code>. 
</p>
<p>Function <code>w</code> most be  of the form <code>w &lt;- function(z, ...)</code> where
<code>...</code> are optional additional parameters and <code>z</code> represents valued
of the standardized form of the density; in the univariate case, <code>x</code> and
<code>z</code> are related by <code>z=(x-xi)/omega</code> and an analogous fact holds in
the multivariate setting. The function must satisfy the condition
<code class="reqn">w(-z)=-w(z)</code>. It is assumed that the function is vectorized and, in the
multivariate case, it will be called with <code>z</code> representing a matrix with
<code>d</code> columns, if <code>d</code> denotes the dimensionality of the random
variable.
</p>
<p>Argument <code>odd</code> regulates the behaviour with respect to the condition 
<code class="reqn">w(-z)=-w(z)</code>. If its value is <code>"assume"</code>, the condition is just
assumed to hold, and no action is taken. If the value is <code>"check"</code>
(deafult), a <em>limited</em> check is performed; namely, in case of densities,
the check is at 0 and the supplied <code>x</code> points, while for random numbers  
the check is at 0 and the generated points.
The value <code>"force"</code> ensures that the condition is satisfied by 
actually constructing a modified version of the user-supplied function 
<code>w</code>, such that the required condition is enforced. 
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Arellano-Valle, R. B., Gómez, H. W. and Quintana, F. A. (2004).
A new class of skew-normal distributions. <em>Comm. Stat., Theory &amp;
Methods</em>, <b>58</b>, 111-121. 
</p>
<p>Azzalini, A. and Capitanio, A. (2003).
Distributions generated by perturbation of symmetry 
with emphasis on a multivariate skew-<em>t</em> distribution.
<em>J.Roy. Statist. Soc. B</em> <b>65</b>, 367&ndash;389.
Full version of the paper at <a href="https://arXiv.org/abs/0911.2342">https://arXiv.org/abs/0911.2342</a>
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series.    
</p>
<p>Wang, J., Boyer, J. and Genton, M. G. (2004).
A skew-symmetric representation of multivariate distributions.
<em>Statistica Sinica</em>, <b>14</b>, 1259-1270.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Distributions">Distributions</a></code>, 
<code><a href="stats.html#topic+Beta">Beta</a></code>, <code><a href="stats.html#topic+TDist">TDist</a></code>,
<code><a href="mnormt.html#topic+dmnorm">dmnorm</a></code>, <code><a href="mnormt.html#topic+dmt">dmt</a></code>, 
<code><a href="graphics.html#topic+contour">contour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(2, 13, length=45)
wLinear &lt;- function(z, lambda) lambda*z
y &lt;- dSymmModulated(x, 5, 2, f0="normal", G0="normal", w=wLinear, lambda=3)
# the same of dsn(x, 5, 2, 3), up to negligible numerical differences
#
wSGN &lt;- function(z, lambda) z*lambda[1]/sqrt(1 + lambda[2]*z^2) 
y &lt;- dSymmModulated(x, 5, 2, f0="normal", G0="normal", w=wSGN, lambda=c(3,5))
# SGN distribution of Arellano-Valle et al. (2004)
#
wST &lt;- function(z, lambda, nu) lambda*z*sqrt((nu+1)/(nu+z^2))
y &lt;- rSymmModulated(n=100, 5, 2, f0="t", G0="t", w=wST, par.f0=8, par.G0=9, 
        lambda=3, nu=8)
# equivalent to rst(n=100, 5, 2, 3, 8) 
#
wTrigs &lt;- function(z, p, q) sin(z * p)/(1 + cos(z * q))
x &lt;- seq(-1, 1, length=51)
y &lt;- dSymmModulated(x, 0, 1, f0="beta", G0="logistic", w=wTrigs, par.f0=2,
        par.G0=NULL, p=5, q=0.5)   
plot(x, y, type="l")        
# univariate analogue of the bivariate distribution on pp.372-3 of
# Azzalini &amp; Capitanio (2003)           
#
range &lt;- cbind(c(-3,3), c(-3,3))
wMvTrigs &lt;- function(z, p, q) sin(z %*% p)/(1 + cos(z %*% q))
plot2D.SymmModulated(range, xi=c(0,0), Omega=diag(2), f0="normal", G0="normal",
    w=wMvTrigs, par.f0=NULL, par.G0=NULL, p=c(2,3), q=c(1,1), col=4)
# w(.) as in (1.6) of Azzalini &amp; Capitanio (2014, p.4) and plot as in 
# bottom-right panel of their Figure 1.1.      
</code></pre>

<hr>
<h2 id='T.Owen'>
Owen's function
</h2><span id='topic+T.Owen'></span>

<h3>Description</h3>

<p>Evaluates function <code class="reqn">T(h,a)</code> studied by D.B.Owen</p>


<h3>Usage</h3>

<pre><code class='language-R'>T.Owen(h, a, jmax=50, cut.point=8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T.Owen_+3A_h">h</code></td>
<td>
<p>a numeric vector. Missing values (<code>NA</code>s) and <code>Inf</code> are
allowed.</p>
</td></tr>
<tr><td><code id="T.Owen_+3A_a">a</code></td>
<td>
<p>a numeric value. <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="T.Owen_+3A_jmax">jmax</code></td>
<td>
<p>an integer scalar value which regulates the accuracy of the result.
See Section &lsquo;Details&rsquo; below for explanation.
</p>
</td></tr>
<tr><td><code id="T.Owen_+3A_cut.point">cut.point</code></td>
<td>
<p>a scalar value which regulates the behaviour of the algorithm,
as explained in Section &lsquo;Details&rsquo; below (default value: <code>8</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>a&gt;1</code> and <code>0&lt;h&lt;=cut.point</code>, a series expansion is used,
truncated after <code>jmax</code> terms.
If <code>a&gt;1</code> and <code>h&gt;cut.point</code>, an asymptotic approximation is used.
In the other cases, various reflection properties of the function
are exploited. See the reference below for more information.
</p>


<h3>Value</h3>

<p>a numeric vector.</p>


<h3>Background</h3>

<p>The function <em>T(h,a)</em> studied by Owen (1956) is useful for the computation 
of the bivariate normal distribution function and related quantities, 
including the distribution function of a skew-normal variate; see <code>psn</code>.
See the reference below for more information on function <code class="reqn">T(h,a)</code>.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini and Francesca Furlan</p>


<h3>References</h3>

<p>Owen, D. B. (1956).
Tables for computing bivariate normal probabilities.
<em>Ann. Math. Statist.</em> <b>27</b>, 1075-1090.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+psn">psn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> owen &lt;- T.Owen(1:10, 2)</code></pre>

<hr>
<h2 id='wines'>Piedmont wines data</h2><span id='topic+wines'></span>

<h3>Description</h3>

<p>Data refer to chemical properties of 178 specimens of three 
types of wine produced in the Piedmont region of Italy. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wines)</code></pre>


<h3>Format</h3>

<p>A data frame with 178 observations on the following 28 variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>wine</code></td><td style="text-align: left;"> wine name (categorical,  
         levels: <code>Barbera</code>, <code>Barolo</code>, <code>Grignolino</code>)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>alcohol</code></td><td style="text-align: left;"> alcohol percentage (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>sugar</code></td><td style="text-align: left;"> sugar-free extract (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>acidity</code></td><td style="text-align: left;"> fixed acidity (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>tartaric</code></td><td style="text-align: left;"> tartaric acid (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>malic</code></td><td style="text-align: left;"> malic acid (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>uronic</code></td><td style="text-align: left;"> uronic acids (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>pH</code></td><td style="text-align: left;"> pH (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ash</code></td><td style="text-align: left;"> ash (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>alcal_ash</code></td><td style="text-align: left;"> alcalinity of ash (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>potassium</code></td><td style="text-align: left;"> potassium (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>calcium</code></td><td style="text-align: left;"> calcium (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>magnesium</code></td><td style="text-align: left;"> magnesium (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>phosphate</code></td><td style="text-align: left;"> phosphate (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>cloride</code></td><td style="text-align: left;"> chloride (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>phenols</code></td><td style="text-align: left;"> total phenols (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>flavanoids</code></td><td style="text-align: left;"> flavanoids (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>nonflavanoids</code></td><td style="text-align: left;"> nonflavanoid phenols (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>proanthocyanins</code></td><td style="text-align: left;"> proanthocyanins (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>colour</code></td><td style="text-align: left;"> colour intensity (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>hue</code></td><td style="text-align: left;"> hue (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>OD_dw</code></td><td style="text-align: left;"> <code class="reqn">OD_{280}/OD_{315}</code> of diluted wines
          (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>OD_fl</code></td><td style="text-align: left;"> <code class="reqn">OD_{280}/OD_{315}</code> of flavanoids 
          (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">          
    <code>glycerol</code></td><td style="text-align: left;"> glycerol (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>butanediol</code></td><td style="text-align: left;"> 2,3-butanediol (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>nitrogen</code></td><td style="text-align: left;"> total nitrogen (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>proline</code></td><td style="text-align: left;"> proline (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>methanol</code></td><td style="text-align: left;"> methanol (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>The data represent 27 chemical measurements on each of 178 wine specimens 
belonging to three types of wine produced in the Piedmont region of Italy. 
The data have been presented and examined by Forina <em>et al.</em> (1986) and 
were freely accessible from the <abbr><span class="acronym">PARVUS</span></abbr> web-site until it was active.
These data or, more often, a subset of them are now available from various
places, including some <span class="rlang"><b>R</b></span> packages. The present dataset includes 
all variables available on the <abbr><span class="acronym">PARVUS</span></abbr> repository, which are
the variables listed by Forina <em>et al.</em> (1986) with the exception 
of &lsquo;Sulphate&rsquo;. Moreover, it reveals the undocumented fact that
the original dataset appears to include also the vintage year;
see the final portion of the &lsquo;Examples&rsquo; below.</p>


<h3>Source</h3>

<p>Forina, M., Lanteri, S. Armanino, C., Casolino, C., Casale, M. and Oliveri, P. 
<abbr><span class="acronym">V-PARVUS 2008</span></abbr>: an extendible package of programs for esplorative 
data analysis, classification and regression analysis. 
Dip. Chimica e Tecnologie Farmaceutiche ed Alimentari, 
Università di Genova, Italia. Web-site (not accessible as of 2014): 
&lsquo;<span class="samp">&#8288;http://www.parvus.unige.it&#8288;</span>&rsquo;
</p>


<h3>References</h3>

 
<p>Forina M., Armanino C., Castino M. and Ubigli M. (1986).  
Multivariate data analysis as a discriminating method of the origin of wines. 
<em>Vitis</em> <b>25</b>, 189&ndash;201.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wines)
pairs(wines[,c(2,3,16:18)], col=as.numeric(wines$wine))
#
code &lt;- substr(rownames(wines), 1, 3)
table(wines$wine, code)
#
year &lt;- as.numeric(substr(rownames(wines), 6, 7))
table(wines$wine, year)
# coincides with Table 1(a) of Forina et al. (1986)
</code></pre>

<hr>
<h2 id='zeta'>Function <code class="reqn">\log(2\,\Phi(x))</code> and its derivatives</h2><span id='topic+zeta'></span>

<h3>Description</h3>

<p>The function <code>log(2*pnorm(x))</code> and its derivatives, 
including inverse Mills ratio.</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeta(k, x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeta_+3A_k">k</code></td>
<td>
<p>an integer number between 0 and 5.</p>
</td></tr>
<tr><td><code id="zeta_+3A_x">x</code></td>
<td>
<p>a numeric vector. Missing values (<code>NA</code>s)  and <code>Inf</code>s are 
allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>k</code> between 0 and 5, the derivative of  order <code>k</code>  of
<code class="reqn">\log(2\,\Phi(x))</code> is  evaluated, where <code class="reqn">\Phi(x)</code> 
denotes the <code class="reqn">N(0,1)</code> cumulative distribution function.
The derivative of order <code>k=0</code> refers to the function itself.
If <code>k</code> is not an integer within <code>0,..., 5</code>, <code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p>a vector representing the <code>k</code>-th order derivative evaluated at 
<code>x</code>.</p>


<h3>Background</h3>

<p>The computation for <code>k&gt;1</code> is reduced to the case <code>k=1</code>, making use
of expressions given by Azzalini and Capitanio (1999); see especially 
Section 4 of the full-length version of the paper.   The main facts are 
summarized in Section 2.1.4 of Azzalini and Capitanio (2014).
</p>
<p>For numerical stability, the evaluation of <code>zeta(1,x)</code> when 
<code>x &lt; -50</code> makes use of the asymptotic expansion (26.2.13) of 
Abramowitz and Stegun (1964).
</p>
<p><code>zeta(1,-x)</code> equals <code>dnorm(x)/pnorm(-x)</code> (in principle, apart from
the above-mentioned asymptotic expansion), called the  
<em>inverse Mills ratio</em>.
</p>


<h3>References</h3>

<p>Abramowitz, M. and Stegun, I. A., editors (1964).
<em>Handbook of Mathematical Functions</em>. 
Dover Publications.
</p>
<p>Azzalini, A. and Capitanio, A. (1999).
Statistical applications of the multivariate skew normal distribution.
<em>J.Roy.Statist.Soc. B</em> <b>61</b>, 579&ndash;602. Full-length version 
available at <a href="https://arXiv.org/abs/0911.2093">https://arXiv.org/abs/0911.2093</a>
</p>
<p>Azzalini, A. with the collaboration of Capitanio, A. (2014). 
<em>The Skew-Normal and Related Families</em>. 
Cambridge University Press, IMS Monographs series. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- zeta(2,seq(-20,20,by=0.5))
#
for(k in 0:5) curve(zeta(k,x), from=-1.5, to=5, col = k+2, add = k &gt; 0)
legend(3.5, -0.5, legend=as.character(0:5), col=2:7, lty=1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
