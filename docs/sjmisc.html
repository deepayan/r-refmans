<!DOCTYPE html><html><head><title>Help for package sjmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sjmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sjmisc-package'><p>Data and Variable Transformation Functions</p></a></li>
<li><a href='#+25nin+25'><p>Value matching</p></a></li>
<li><a href='#add_columns'><p>Add or replace data frame columns</p></a></li>
<li><a href='#add_rows'><p>Merge labelled data frames</p></a></li>
<li><a href='#add_variables'><p>Add variables or cases to data frames</p></a></li>
<li><a href='#all_na'><p>Check if vector only has NA values</p></a></li>
<li><a href='#big_mark'><p>Format numbers</p></a></li>
<li><a href='#count_na'><p>Frequency table of tagged NA values</p></a></li>
<li><a href='#de_mean'><p>Compute group-meaned and de-meaned variables</p></a></li>
<li><a href='#descr'><p>Basic descriptive statistics</p></a></li>
<li><a href='#dicho'><p>Dichotomize variables</p></a></li>
<li><a href='#efc'><p>Sample dataset from the EUROFAMCARE project</p></a></li>
<li><a href='#empty_cols'><p>Return or remove variables or observations that are completely missing</p></a></li>
<li><a href='#find_var'><p>Find variable by name or label</p></a></li>
<li><a href='#flat_table'><p>Flat (proportional) tables</p></a></li>
<li><a href='#frq'><p>Frequency table of labelled variables</p></a></li>
<li><a href='#group_str'><p>Group near elements of string vectors</p></a></li>
<li><a href='#group_var'><p>Recode numeric variables into equal-ranged groups</p></a></li>
<li><a href='#has_na'><p>Check if variables or cases have missing / infinite values</p></a></li>
<li><a href='#is_crossed'><p>Check whether two factors are crossed or nested</p></a></li>
<li><a href='#is_empty'><p>Check whether string, list or vector is empty</p></a></li>
<li><a href='#is_even'><p>Check whether value is even or odd</p></a></li>
<li><a href='#is_float'><p>Check if a variable is of (non-integer) double type or a whole number</p></a></li>
<li><a href='#is_num_fac'><p>Check whether a factor has numeric levels only</p></a></li>
<li><a href='#merge_imputations'><p>Merges multiple imputed data frames into a single data frame</p></a></li>
<li><a href='#move_columns'><p>Move columns to other positions in a data frame</p></a></li>
<li><a href='#numeric_to_factor'><p>Convert numeric vectors into factors associated value labels</p></a></li>
<li><a href='#rec'><p>Recode variables</p></a></li>
<li><a href='#rec_pattern'><p>Create recode pattern for 'rec' function</p></a></li>
<li><a href='#recode_to'><p>Recode variable categories into new values</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#ref_lvl'><p>Change reference level of (numeric) factors</p></a></li>
<li><a href='#remove_var'><p>Remove variables from a data frame</p></a></li>
<li><a href='#replace_na'><p>Replace NA with specific values</p></a></li>
<li><a href='#reshape_longer'><p>Reshape data into long format</p></a></li>
<li><a href='#rotate_df'><p>Rotate a data frame</p></a></li>
<li><a href='#round_num'><p>Round numeric variables in a data frame</p></a></li>
<li><a href='#row_count'><p>Count row or column indices</p></a></li>
<li><a href='#row_sums'><p>Row sums and means for data frames</p></a></li>
<li><a href='#seq_col'><p>Sequence generation for column or row counts of data frames</p></a></li>
<li><a href='#set_na_if'><p>Replace specific values in vector with NA</p></a></li>
<li><a href='#shorten_string'><p>Shorten character strings</p></a></li>
<li><a href='#split_var'><p>Split numeric variables into smaller groups</p></a></li>
<li><a href='#spread_coef'><p>Spread model coefficients of list-variables into columns</p></a></li>
<li><a href='#std'><p>Standardize and center variables</p></a></li>
<li><a href='#str_contains'><p>Check if string contains pattern</p></a></li>
<li><a href='#str_find'><p>Find partial matching and close distance elements in strings</p></a></li>
<li><a href='#str_start'><p>Find start and end index of pattern in string</p></a></li>
<li><a href='#tidy_values'><p>Clean values of character vectors.</p></a></li>
<li><a href='#to_dummy'><p>Split (categorical) vectors into dummy variables</p></a></li>
<li><a href='#to_long'><p>Convert wide data to long format</p></a></li>
<li><a href='#to_value'><p>Convert factors to numeric variables</p></a></li>
<li><a href='#trim'><p>Trim leading and trailing whitespaces from strings</p></a></li>
<li><a href='#typical_value'><p>Return the typical value of a vector</p></a></li>
<li><a href='#var_rename'><p>Rename variables</p></a></li>
<li><a href='#var_type'><p>Determine variable type</p></a></li>
<li><a href='#word_wrap'><p>Insert line breaks in long labels</p></a></li>
<li><a href='#zap_inf'><p>Convert infiite or NaN values into regular NA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Data and Variable Transformation Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.8.10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Lüdecke &lt;d.luedecke@uke.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of miscellaneous utility functions, supporting data 
    transformation tasks like recoding, dichotomizing or grouping variables, 
    setting and replacing missing values. The data transformation functions 
    also support labelled data, and all integrate seamlessly into a 
    'tidyverse'-workflow.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, insight, datawizard, magrittr, methods, purrr, rlang,
sjlabelled (&ge; 1.1.1), stats, tidyselect, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, graphics, haven (&ge; 2.0.0), mice, nnet, sjPlot,
sjstats, knitr, rmarkdown, stringdist, testthat, tidyr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://strengejacke.github.io/sjmisc/">https://strengejacke.github.io/sjmisc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/strengejacke/sjmisc/issues">https://github.com/strengejacke/sjmisc/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 13:03:33 UTC; mail</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Lüdecke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Iago Giné-Vázquez [ctb],
  Alexander Bartel <a href="https://orcid.org/0000-0002-1280-6138"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sjmisc-package'>Data and Variable Transformation Functions</h2><span id='topic+sjmisc-package'></span><span id='topic+sjmisc'></span>

<h3>Description</h3>

<p><strong>Purpose of this package</strong>
</p>
<p>Collection of miscellaneous utility functions, supporting data transformation tasks like recoding, dichotomizing or grouping variables, setting and replacing missing values. The data transformation functions also support labelled data, and all integrate seamlessly into a 'tidyverse'-workflow.
</p>
<p><strong>Design philosophy - consistent api</strong>
</p>
<p>The design of this package follows, where appropriate, the <em>tidyverse-approach</em>, with the first argument of a function always being the data (either a data frame or vector), followed by variable names that should be processed by the function. If no variables are specified as argument, the function applies to the complete data that was indicated as first function argument.
</p>
<p>There are two types of function designs:
</p>

<dl>
<dt><em>transformation/recoding functions</em></dt><dd>
<p>Functions like <code>rec()</code> or <code>dicho()</code>, which transform or recode variables, typically return the complete data frame that was given as first argument, <em>additionally including</em> the transformed and recoded variables specified in the <code>...</code>-ellipses argument. The variables usually get a suffix, so original variables are preserved in the data.
</p>
</dd>
<dt><em>coercing/converting functions</em></dt><dd>
<p>Functions like <code>to_factor()</code> or <code>to_label()</code>, which convert variables into other types or add additional information like variable or value labels as attribute, also typically return the complete data frame that was given as first argument. However, the variables specified in the <code>...</code>-ellipses argument are converted (&quot;overwritten&quot;), all other variables remain unchanged. Hence, these functions do not return any new, additional variables.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Daniel Lüdecke <a href="mailto:d.luedecke@uke.de">d.luedecke@uke.de</a>
</p>

<hr>
<h2 id='+25nin+25'>Value matching</h2><span id='topic++25nin+25'></span>

<h3>Description</h3>

<p>%nin% is the complement to %in%. It looks which values
in <code>x</code> do <em>not</em> match (hence, are <em>not in</em>)
values in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %nin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25nin+2B25_+3A_x">x</code></td>
<td>
<p>Vector with values to be matched.</p>
</td></tr>
<tr><td><code id="+2B25nin+2B25_+3A_y">y</code></td>
<td>
<p>Vector with values to be matched against.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'Details' in <code><a href="base.html#topic+match">match</a></code>.
</p>


<h3>Value</h3>

<p>A logical vector, indicating if a match was <em>not</em> located for each element
of <code>x</code>, thus the values are <code>TRUE</code> or <code>FALSE</code> and
never <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c("a", "B", "c") %in% letters
c("a", "B", "c") %nin% letters

c(1, 2, 3, 4) %in% c(3, 4, 5, 6)
c(1, 2, 3, 4) %nin% c(3, 4, 5, 6)

</code></pre>

<hr>
<h2 id='add_columns'>Add or replace data frame columns</h2><span id='topic+add_columns'></span><span id='topic+replace_columns'></span><span id='topic+add_id'></span>

<h3>Description</h3>

<p><code>add_columns()</code> combines two or more data frames, but unlike
<code><a href="base.html#topic+cbind">cbind</a></code> or <code><a href="dplyr.html#topic+bind">dplyr::bind_cols()</a></code>, this function
binds <code>data</code> as last columns of a data frame (i.e., behind columns
specified in <code>...</code>). This can be useful in a &quot;pipe&quot;-workflow, where
a data frame returned by a previous function should be appended
<em>at the end</em> of another data frame that is processed in
<code>add_colums()</code>.
<br /> <br />
<code>replace_columns()</code> replaces all columns in <code>data</code> with
identically named columns in <code>...</code>, and adds remaining (non-duplicated)
columns from <code>...</code> to <code>data</code>.
<br /> <br />
<code>add_id()</code> simply adds an ID-column to the data frame, with values
from 1 to <code>nrow(data)</code>, respectively for grouped data frames, values
from 1 to group size. See 'Examples'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_columns(data, ..., replace = TRUE)

replace_columns(data, ..., add.unique = TRUE)

add_id(data, var = "ID")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_columns_+3A_data">data</code></td>
<td>
<p>A data frame. For <code>add_columns()</code>, will be bound after data
frames specified in <code>...</code>. For <code>replace_columns()</code>, duplicated
columns in <code>data</code> will be replaced by columns in <code>...</code>.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_...">...</code></td>
<td>
<p>More data frames to combine, resp. more data frames with columns
that should replace columns in <code>data</code>.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_replace">replace</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), columns in <code>...</code> with
identical names in <code>data</code> will replace the columns in <code>data</code>.
The order of columns after replacing is preserved.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_add.unique">add.unique</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), remaining columns in
<code>...</code> that did not replace any column in <code>data</code>, are appended
as new columns to <code>data</code>.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_var">var</code></td>
<td>
<p>Name of new the ID-variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>add_columns()</code>, a data frame, where columns of <code>data</code>
are appended after columns of <code>...</code>.
<br /> <br />
For <code>replace_columns()</code>, a data frame where columns in <code>data</code>
will be replaced by identically named columns in <code>...</code>, and remaining
columns from <code>...</code> will be appended to <code>data</code> (if
<code>add.unique = TRUE</code>).
<br /> <br />
For <code>add_id()</code>, a new column with ID numbers. This column is always
the first column in the returned data frame.
</p>


<h3>Note</h3>

<p>For <code>add_columns()</code>, by default, columns in <code>data</code> with
identical names like columns in one of the data frames in <code>...</code>
will be dropped (i.e. variables with identical names in <code>...</code> will
replace existing variables in <code>data</code>). Use <code>replace = FALSE</code> to
keep all columns. Identical column names will then be renamed, to ensure
unique column names (which happens by default when using
<code><a href="dplyr.html#topic+bind">dplyr::bind_cols()</a></code>). When replacing columns, replaced columns
are not added to the end of the data frame. Rather, the original order of
columns will be preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
d1 &lt;- efc[, 1:3]
d2 &lt;- efc[, 4:6]

if (require("dplyr") &amp;&amp; require("sjlabelled")) {
head(bind_cols(d1, d2))
add_columns(d1, d2) %&gt;% head()

d1 &lt;- efc[, 1:3]
d2 &lt;- efc[, 2:6]

add_columns(d1, d2, replace = TRUE) %&gt;% head()
add_columns(d1, d2, replace = FALSE) %&gt;% head()

# use case: we take the original data frame, select specific
# variables and do some transformations or recodings
# (standardization in this example) and add the new, transformed
# variables *to the end* of the original data frame
efc %&gt;%
  select(e17age, c160age) %&gt;%
  std() %&gt;%
  add_columns(efc) %&gt;%
  head()

# new variables with same name will overwrite old variables
# in "efc". order of columns is not changed.
efc %&gt;%
  select(e16sex, e42dep) %&gt;%
  to_factor() %&gt;%
  add_columns(efc) %&gt;%
  head()

# keep both old and new variables, automatically
# rename variables with identical name
efc %&gt;%
  select(e16sex, e42dep) %&gt;%
  to_factor() %&gt;%
  add_columns(efc, replace = FALSE) %&gt;%
  head()

# create sample data frames
d1 &lt;- efc[, 1:10]
d2 &lt;- efc[, 2:3]
d3 &lt;- efc[, 7:8]
d4 &lt;- efc[, 10:12]

# show original
head(d1)

library(sjlabelled)
# slightly change variables, to see effect
d2 &lt;- as_label(d2)
d3 &lt;- as_label(d3)

# replace duplicated columns, append remaining
replace_columns(d1, d2, d3, d4) %&gt;% head()

# replace duplicated columns, omit remaining
replace_columns(d1, d2, d3, d4, add.unique = FALSE) %&gt;% head()

# add ID to dataset
library(dplyr)
data(mtcars)
add_id(mtcars)

mtcars %&gt;%
  group_by(gear) %&gt;%
  add_id() %&gt;%
  arrange(gear, ID) %&gt;%
  print(n = 100)
}
</code></pre>

<hr>
<h2 id='add_rows'>Merge labelled data frames</h2><span id='topic+add_rows'></span><span id='topic+merge_df'></span>

<h3>Description</h3>

<p>Merges (full join) data frames and preserve value and variable labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_rows(..., id = NULL)

merge_df(..., id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_rows_+3A_...">...</code></td>
<td>
<p>Two or more data frames to be merged.</p>
</td></tr>
<tr><td><code id="add_rows_+3A_id">id</code></td>
<td>
<p>Optional name for ID column that will be created to indicate the
source data frames for appended rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works like <code><a href="dplyr.html#topic+bind">dplyr::bind_rows()</a></code>, but preserves
variable and value label attributes. <code>add_rows()</code> row-binds all data
frames in <code>...</code>, even if these have different numbers of columns.
Non-matching columns will be column-bound and filled with <code>NA</code>-values
for rows in those data frames that do not have this column.
<br /> <br />
Value and variable labels are preserved. If matching columns have
different value label attributes, attributes from first data frame
will be used.
<br /> <br />
<code>merge_df()</code> is an alias for <code>add_rows()</code>.
</p>


<h3>Value</h3>

<p>A full joined data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(efc)
x1 &lt;- efc %&gt;% select(1:5) %&gt;% slice(1:10)
x2 &lt;- efc %&gt;% select(3:7) %&gt;% slice(11:20)

mydf &lt;- add_rows(x1, x2)
mydf
str(mydf)

## Not run: 
library(sjPlot)
view_df(mydf)
## End(Not run)

x3 &lt;- efc %&gt;% select(5:9) %&gt;% slice(21:30)
x4 &lt;- efc %&gt;% select(11:14) %&gt;% slice(31:40)

mydf &lt;- add_rows(x1, x2, x3, x4, id = "subsets")
mydf
str(mydf)
</code></pre>

<hr>
<h2 id='add_variables'>Add variables or cases to data frames</h2><span id='topic+add_variables'></span><span id='topic+add_case'></span>

<h3>Description</h3>

<p><code>add_variables()</code> adds a new column to a data frame, while
<code>add_case()</code> adds a new row to a data frame. These are convenient
functions to add columns or rows not only at the end of a data frame,
but at any column or row position. Furthermore, they allow easy integration
into a pipe-workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_variables(data, ..., .after = Inf, .before = NULL)

add_case(data, ..., .after = Inf, .before = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_variables_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="add_variables_+3A_...">...</code></td>
<td>
<p>One or more named vectors that indicate the variables or values,
which will be added as new column or row to <code>data</code>. For <code>add_case()</code>,
non-matching columns in <code>data</code> will be filled with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="add_variables_+3A_.after">.after</code>, <code id="add_variables_+3A_.before">.before</code></td>
<td>
<p>Numerical index of row or column, where after or before
the new variable or case should be added. If <code>.after = -1</code>, variables
or cases are added at the beginning; if <code>.after = Inf</code>,
variables and cases are added at the end. In case of <code>add_variables()</code>,
<code>.after</code> and <code>.before</code> may also be a character name indicating
the column in <code>data</code>, after or infront of what <code>...</code> should be
inserted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code>, including the new variables or cases from <code>...</code>.
</p>


<h3>Note</h3>

<p>For <code>add_case()</code>, if variable does not exist, a new variable is
created and existing cases for this new variable get the value <code>NA</code>.
See 'Examples'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  a = c(1, 2, 3),
  b = c("a", "b", "c"),
  c = c(10, 20, 30),
  stringsAsFactors = FALSE
)

add_case(d, b = "d")
add_case(d, b = "d", a = 5, .before = 1)

# adding a new case for a new variable
add_case(d, e = "new case")

add_variables(d, new = 5)
add_variables(d, new = c(4, 4, 4), new2 = c(5, 5, 5), .after = "b")
</code></pre>

<hr>
<h2 id='all_na'>Check if vector only has NA values</h2><span id='topic+all_na'></span>

<h3>Description</h3>

<p>Check if all values in a vector are <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_na_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if <code>x</code> has only NA values, <code>FALSE</code> if
<code>x</code> has at least one non-missing value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, NA, NA)
y &lt;- c(1, NA, NA)

all_na(x)
all_na(y)
all_na(data.frame(x, y))
all_na(list(x, y))
</code></pre>

<hr>
<h2 id='big_mark'>Format numbers</h2><span id='topic+big_mark'></span><span id='topic+prcn'></span>

<h3>Description</h3>

<p><code>big_mark()</code> formats large numbers with big marks, while
<code>prcn()</code> converts a numeric scalar between 0 and 1 into a character
vector, representing the percentage-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>big_mark(x, big.mark = ",", ...)

prcn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="big_mark_+3A_x">x</code></td>
<td>
<p>A vector or data frame. All numeric inputs (including numeric character)
vectors) will be prettified. For <code>prcn()</code>, a number between
0 and 1, or a vector or data frame with such numbers.</p>
</td></tr>
<tr><td><code id="big_mark_+3A_big.mark">big.mark</code></td>
<td>
<p>Character, used as mark between every 3 decimals before the decimal point.</p>
</td></tr>
<tr><td><code id="big_mark_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to the <code><a href="base.html#topic+prettyNum">prettyNum</a></code>-function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>big_mark()</code>, a prettified <code>x</code> as character, with big marks.
For <code>prcn</code>, a character vector with a percentage number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple big mark
big_mark(1234567)

# big marks for several values at once, mixed numeric and character
big_mark(c(1234567, "55443322"))

# pre-defined width of character output
big_mark(c(1234567, 55443322), width = 15)

# convert numbers into percentage, as character
prcn(0.2389)
prcn(c(0.2143887, 0.55443, 0.12345))

dat &lt;- data.frame(
  a = c(.321, .121, .64543),
  b = c("a", "b", "c"),
  c = c(.435, .54352, .234432)
)
prcn(dat)
</code></pre>

<hr>
<h2 id='count_na'>Frequency table of tagged NA values</h2><span id='topic+count_na'></span>

<h3>Description</h3>

<p>This method counts tagged NA values (see <code><a href="haven.html#topic+tagged_na">tagged_na</a></code>)
in a vector and prints a frequency table of counted tagged NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_na(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_na_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="count_na_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with counted tagged NA values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("haven")) {
  x &lt;- labelled(
    x = c(1:3, tagged_na("a", "c", "z"),
          4:1, tagged_na("a", "a", "c"),
          1:3, tagged_na("z", "c", "c"),
          1:4, tagged_na("a", "c", "z")),
    labels = c("Agreement" = 1, "Disagreement" = 4,
               "First" = tagged_na("c"), "Refused" = tagged_na("a"),
               "Not home" = tagged_na("z"))
  )
  count_na(x)

  y &lt;- labelled(
    x = c(1:3, tagged_na("e", "d", "f"),
          4:1, tagged_na("f", "f", "d"),
          1:3, tagged_na("f", "d", "d"),
          1:4, tagged_na("f", "d", "f")),
    labels = c("Agreement" = 1, "Disagreement" = 4, "An E" = tagged_na("e"),
              "A D" = tagged_na("d"), "The eff" = tagged_na("f"))
  )

  # create data frame
  dat &lt;- data.frame(x, y)

  # possible count()-function calls
  count_na(dat)
  count_na(dat$x)
  count_na(dat, x)
  count_na(dat, x, y)
}
</code></pre>

<hr>
<h2 id='de_mean'>Compute group-meaned and de-meaned variables</h2><span id='topic+de_mean'></span>

<h3>Description</h3>

<p><code>de_mean()</code> computes group- and de-meaned versions of a
variable that can be used in regression analysis to model the between-
and within-subject effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>de_mean(x, ..., grp, append = TRUE, suffix.dm = "_dm", suffix.gm = "_gm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="de_mean_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="de_mean_+3A_...">...</code></td>
<td>
<p>Names of variables that should be group- and de-meaned.</p>
</td></tr>
<tr><td><code id="de_mean_+3A_grp">grp</code></td>
<td>
<p>Quoted or unquoted name of the variable that indicates the
group- or cluster-ID.</p>
</td></tr>
<tr><td><code id="de_mean_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="de_mean_+3A_suffix.dm">suffix.dm</code>, <code id="de_mean_+3A_suffix.gm">suffix.gm</code></td>
<td>
<p>String value, will be appended to the names of the
group-meaned and de-meaned variables of <code>x</code>. By default, de-meaned
variables will be suffixed with <code>"_dm"</code> and grouped-meaned variables
with <code>"_gm"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>de_mean()</code> is intended to create group- and de-meaned variables
for complex random-effect-within-between models (see <cite>Bell et al. 2018</cite>),
where group-effects (random effects) and fixed effects correlate (see
<cite>Bafumi and Gelman 2006)</cite>). This violation of one of the
<em>Gauss-Markov-assumptions</em> can happen, for instance, when analysing panel
data. To control for correlating predictors and group effects, it is
recommended to include the group-meaned and de-meaned version of
<em>time-varying covariates</em> in the model. By this, one can fit
complex multilevel models for panel data, including time-varying,
time-invariant predictors and random effects. This approach is superior to
simple fixed-effects models, which lack information of variation in the
group-effects or between-subject effects.
<br /> <br />
A description of how to translate the
formulas described in <em>Bell et al. 2018</em> into R using <code>lmer()</code>
from <span class="pkg">lme4</span> or <code>glmmTMB()</code> from <span class="pkg">glmmTMB</span> can be found here:
<a href="https://strengejacke.github.io/mixed-models-snippets/random-effects-within-between-effects-model.html">for lmer()</a>
and <a href="https://strengejacke.github.io/mixed-models-snippets/random-effects-within-between-effects-model-glmmtmb.html">for glmmTMB()</a>.
</p>


<h3>Value</h3>

<p>For <code>append = TRUE</code>, <code>x</code> including the group-/de-meaned
variables as new columns is returned; if <code>append = FALSE</code>, only the
group-/de-meaned variables will be returned.
</p>


<h3>References</h3>

<p>Bafumi J, Gelman A. 2006. Fitting Multilevel Models When Predictors and Group Effects Correlate. In. Philadelphia, PA: Annual meeting of the American Political Science Association.
<br /> <br />
Bell A, Fairbrother M, Jones K. 2018. Fixed and Random Effects Models: Making an Informed Choice. Quality &amp; Quantity. <a href="https://doi.org/10.1007/s11135-018-0802-x">doi:10.1007/s11135-018-0802-x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
efc$ID &lt;- sample(1:4, nrow(efc), replace = TRUE) # fake-ID
de_mean(efc, c12hour, barthtot, grp = ID, append = FALSE)
</code></pre>

<hr>
<h2 id='descr'>Basic descriptive statistics</h2><span id='topic+descr'></span>

<h3>Description</h3>

<p>This function prints a basic descriptive statistic, including
variable labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descr(
  x,
  ...,
  max.length = NULL,
  weights = NULL,
  show = "all",
  out = c("txt", "viewer", "browser"),
  encoding = "UTF-8",
  file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descr_+3A_x">x</code></td>
<td>
<p>A vector or a data frame. May also be a grouped data frame
(see 'Note' and 'Examples').</p>
</td></tr>
<tr><td><code id="descr_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="descr_+3A_max.length">max.length</code></td>
<td>
<p>Numeric, indicating the maximum length of variable labels
in the output. If variable names are longer than <code>max.length</code>,
they will be shortened to the last whole word within the first
<code>max.length</code> chars.</p>
</td></tr>
<tr><td><code id="descr_+3A_weights">weights</code></td>
<td>
<p>Bare name, or name as string, of a variable in <code>x</code>
that indicates the vector of weights, which will be applied to weight all
observations. Default is <code>NULL</code>, so no weights are used.</p>
</td></tr>
<tr><td><code id="descr_+3A_show">show</code></td>
<td>
<p>Character vector, indicating which information (columns) that describe
the data should be returned. May be one or more of <code>"type", "label", "n",
"NA.prc", "mean", "sd", "se", "md", "trimmed", "range", "iqr", "skew"</code>. There are
two shortcuts: <code>show = "all"</code> (default) shows all information,
<code>show = "short"</code> just shows n, missing percentage, mean and standard
deviation.</p>
</td></tr>
<tr><td><code id="descr_+3A_out">out</code></td>
<td>
<p>Character vector, indicating whether the results should be printed
to console (<code>out = "txt"</code>) or as HTML-table in the viewer-pane
(<code>out = "viewer"</code>) or browser (<code>out = "browser"</code>).</p>
</td></tr>
<tr><td><code id="descr_+3A_encoding">encoding</code></td>
<td>
<p>Character vector, indicating the charset encoding used
for variable and value labels. Default is <code>"UTF-8"</code>. Only used
when <code>out</code> is not <code>"txt"</code>.</p>
</td></tr>
<tr><td><code id="descr_+3A_file">file</code></td>
<td>
<p>Destination file, if the output should be saved as file.
Only used when <code>out</code> is not <code>"txt"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with basic descriptive statistics.
</p>


<h3>Note</h3>

<p><code>data</code> may also be a grouped data frame (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>)
with up to two grouping variables. Descriptive tables are created for each
subgroup then.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
descr(efc, e17age, c160age)

efc$weights &lt;- abs(rnorm(nrow(efc), 1, .3))
descr(efc, c12hour, barthtot, weights = weights)

library(dplyr)
efc %&gt;% select(e42dep, e15relat, c172code) %&gt;% descr()

# show just a few elements
efc %&gt;% select(e42dep, e15relat, c172code) %&gt;% descr(show = "short")

# with grouped data frames
efc %&gt;%
  group_by(e16sex) %&gt;%
  select(e16sex, e42dep, e15relat, c172code) %&gt;%
  descr()

# you can select variables also inside 'descr()'
efc %&gt;%
  group_by(e16sex, c172code) %&gt;%
  descr(e16sex, c172code, e17age, c160age)

# or even use select-helpers
descr(efc, contains("cop"), max.length = 20)
</code></pre>

<hr>
<h2 id='dicho'>Dichotomize variables</h2><span id='topic+dicho'></span><span id='topic+dicho_if'></span>

<h3>Description</h3>

<p>Dichotomizes variables into dummy variables (0/1). Dichotomization is
either done by median, mean or a specific value (see <code>dich.by</code>).
<code>dicho_if()</code> is a scoped variant of <code>dicho()</code>, where recoding
will be applied only to those variables that match the logical condition
of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicho(
  x,
  ...,
  dich.by = "median",
  as.num = FALSE,
  var.label = NULL,
  val.labels = NULL,
  append = TRUE,
  suffix = "_d"
)

dicho_if(
  x,
  predicate,
  dich.by = "median",
  as.num = FALSE,
  var.label = NULL,
  val.labels = NULL,
  append = TRUE,
  suffix = "_d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicho_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="dicho_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="dicho_+3A_dich.by">dich.by</code></td>
<td>
<p>Indicates the split criterion where a variable is dichotomized.
Must be one of the following values (may be abbreviated):
</p>

<dl>
<dt><code>"median"</code> or <code>"md"</code></dt><dd><p>by default, <code>x</code> is split into two groups at the median.</p>
</dd>
<dt><code>"mean"</code> or <code>"m"</code></dt><dd><p>splits <code>x</code> into two groups at the mean of <code>x</code>.</p>
</dd>
<dt>numeric value</dt><dd><p>splits <code>x</code> into two groups at the specific value. Note that the value is inclusive, i.e. <code>dich.by = 10</code> will split <code>x</code> into one group with values from lowest to 10 and another group with values greater than 10.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dicho_+3A_as.num">as.num</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return value will be numeric, not a factor.</p>
</td></tr>
<tr><td><code id="dicho_+3A_var.label">var.label</code></td>
<td>
<p>Optional string, to set variable label attribute for the
returned variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), variable label attribute of <code>x</code> will
be used (if present). If empty, variable label attributes will be removed.</p>
</td></tr>
<tr><td><code id="dicho_+3A_val.labels">val.labels</code></td>
<td>
<p>Optional character vector (of length two), to set value label
attributes of dichotomized variable (see <code><a href="sjlabelled.html#topic+set_labels">set_labels</a></code>).
If <code>NULL</code> (default), no value labels will be set.</p>
</td></tr>
<tr><td><code id="dicho_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="dicho_+3A_suffix">suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="dicho_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dicho()</code> also works on grouped data frames (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>).
In this case, dichotomization is applied to the subsets of variables
in <code>x</code>. See 'Examples'.
</p>


<h3>Value</h3>

<p><code>x</code>, dichotomized. If <code>x</code> is a data frame,
for <code>append = TRUE</code>, <code>x</code> including the dichotomized. variables
as new columns is returned; if <code>append = FALSE</code>, only
the dichotomized variables will be returned. If <code>append = TRUE</code> and
<code>suffix = ""</code>, recoded variables will replace (overwrite) existing
variables.
</p>


<h3>Note</h3>

<p>Variable label attributes are preserved (unless changed via
<code>var.label</code>-argument).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
summary(efc$c12hour)
# split at median
table(dicho(efc$c12hour))
# split at mean
table(dicho(efc$c12hour, dich.by = "mean"))
# split between value lowest to 30, and above 30
table(dicho(efc$c12hour, dich.by = 30))

# sample data frame, values from 1-4
head(efc[, 6:10])

# dichtomized values (1 to 2 = 0, 3 to 4 = 1)
library(dplyr)
efc %&gt;%
  select(6:10) %&gt;%
  dicho(dich.by = 2) %&gt;%
  head()

# dichtomize several variables in a data frame
dicho(efc, c12hour, e17age, c160age, append = FALSE)

# dichotomize and set labels
frq(dicho(
  efc, e42dep,
  var.label = "Dependency (dichotomized)",
  val.labels = c("lower", "higher"),
  append = FALSE
))

# works also with gouped data frames
mtcars %&gt;%
  dicho(disp, append = FALSE) %&gt;%
  table()

mtcars %&gt;%
  group_by(cyl) %&gt;%
  dicho(disp, append = FALSE) %&gt;%
  table()

# dichotomizing grouped data frames leads to different
# results for a dichotomized variable, because the split
# value is different for each group.
# compare:
mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarise(median = median(disp))

median(mtcars$disp)

# dichotomize only variables with more than 10 unique values
p &lt;- function(x) dplyr::n_distinct(x) &gt; 10
dicho_if(efc, predicate = p, append = FALSE)
</code></pre>

<hr>
<h2 id='efc'>Sample dataset from the EUROFAMCARE project</h2><span id='topic+efc'></span>

<h3>Description</h3>

<p>A SPSS sample data set, imported with the <code><a href="sjlabelled.html#topic+read_spss">read_spss</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach EFC-data
data(efc)

# Show structure
str(efc)

# show first rows
head(efc)
</code></pre>

<hr>
<h2 id='empty_cols'>Return or remove variables or observations that are completely missing</h2><span id='topic+empty_cols'></span><span id='topic+empty_rows'></span><span id='topic+remove_empty_cols'></span><span id='topic+remove_empty_rows'></span>

<h3>Description</h3>

<p>These functions check which rows or columns of a data frame completely
contain missing values, i.e. which observations or variables
completely have missing values, and either 1) returns their
indices; or 2) removes them from the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_cols(x)

empty_rows(x)

remove_empty_cols(x)

remove_empty_rows(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_cols_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>empty_cols</code> and <code>empty_rows</code>, a numeric (named) vector
with row or column indices of those variables that completely have
missing values.
<br /> <br />
For <code>remove_empty_cols</code> and <code>remove_empty_rows</code>, a
data frame with &quot;empty&quot; columns or rows removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(a = c(1, 2, 3, NA, 5),
                  b = c(1, NA, 3, NA , 5),
                  c = c(NA, NA, NA, NA, NA),
                  d = c(1, NA, 3, NA, 5))

tmp

empty_cols(tmp)
empty_rows(tmp)

remove_empty_cols(tmp)
remove_empty_rows(tmp)

</code></pre>

<hr>
<h2 id='find_var'>Find variable by name or label</h2><span id='topic+find_var'></span><span id='topic+find_in_data'></span>

<h3>Description</h3>

<p>This functions finds variables in a data frame, which variable
names or variable (and value) label attribute match a specific
pattern. Regular expression for the pattern is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_var(
  data,
  pattern,
  ignore.case = TRUE,
  search = c("name_label", "name_value", "label_value", "name", "label", "value", "all"),
  out = c("table", "df", "index"),
  fuzzy = FALSE,
  regex = FALSE
)

find_in_data(
  data,
  pattern,
  ignore.case = TRUE,
  search = c("name_label", "name_value", "label_value", "name", "label", "value", "all"),
  out = c("table", "df", "index"),
  fuzzy = FALSE,
  regex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_var_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="find_var_+3A_pattern">pattern</code></td>
<td>
<p>Character string to be matched in <code>data</code>. May also be a
character vector of length &gt; 1 (see 'Examples'). <code>pattern</code> is
searched for in column names and variable label attributes of
<code>data</code> (see <code><a href="sjlabelled.html#topic+get_label">get_label</a></code>). <code>pattern</code>
might also be a regular-expression object, as returned by <code>stringr::regex()</code>.
Alternatively, use <code>regex = TRUE</code> to treat <code>pattern</code> as a regular
expression rather than a fixed string.</p>
</td></tr>
<tr><td><code id="find_var_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical, whether matching should be case sensitive or not.
<code>ignore.case</code> is ignored when <code>pattern</code> is no regular expression or
<code>regex = FALSE</code>.</p>
</td></tr>
<tr><td><code id="find_var_+3A_search">search</code></td>
<td>
<p>Character string, indicating where <code>pattern</code> is sought.
Use one of following options:
</p>

<dl>
<dt><code>"name_label"</code></dt><dd><p>The default, searches for <code>pattern</code> in
variable names and variable labels.</p>
</dd>
<dt><code>"name_value"</code></dt><dd><p>Searches for <code>pattern</code> in
variable names and value labels.</p>
</dd>
<dt><code>"label_value"</code></dt><dd><p>Searches for <code>pattern</code> in
variable and value labels.</p>
</dd>
<dt><code>"name"</code></dt><dd><p>Searches for <code>pattern</code> in
variable names.</p>
</dd>
<dt><code>"label"</code></dt><dd><p>Searches for <code>pattern</code> in
variable labels</p>
</dd>
<dt><code>"value"</code></dt><dd><p>Searches for <code>pattern</code> in
value labels.</p>
</dd>
<dt><code>"all"</code></dt><dd><p>Searches for <code>pattern</code> in
variable names, variable and value labels.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="find_var_+3A_out">out</code></td>
<td>
<p>Output (return) format of the search results. May be abbreviated
and must be one of:
</p>

<dl>
<dt><code>"table"</code></dt><dd><p>A tabular overview (as data frame) with
column indices, variable names and labels of matching variables.
</p>
</dd>
<dt><code>"df"</code></dt><dd><p>A data frame with all matching variables.</p>
</dd>
<dt><code>"index"</code></dt><dd>
<p>A named vector with column indices of all matching variables.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="find_var_+3A_fuzzy">fuzzy</code></td>
<td>
<p>Logical, if <code>TRUE</code>, &quot;fuzzy matching&quot; (partial and
close distance matching) will be used to find <code>pattern</code>
in <code>data</code> if no exact match was found.</p>
</td></tr>
<tr><td><code id="find_var_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, <code>pattern</code> is treated as a regular
expression rather than a fixed string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function searches for <code>pattern</code> in <code>data</code>'s column names
and - for labelled data - in all variable and value labels of <code>data</code>'s
variables (see <code><a href="sjlabelled.html#topic+get_label">get_label</a></code> for details on variable labels and
labelled data). Regular expressions are supported as well, by simply using
<code>pattern = stringr::regex(...)</code> or <code>regex = TRUE</code>.
</p>


<h3>Value</h3>

<p>By default (i.e. <code>out = "table"</code>, returns a data frame with three
columns: column number, variable name and variable label. If
<code>out = "index"</code>, returns a named vector with column indices
of matching variables (variable names are used as names-attribute);
if <code>out = "df"</code>, returns the matching variables as data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)

# find variables with "cop" in variable name
find_var(efc, "cop")

# return data frame with matching variables
find_var(efc, "cop", out = "df")

# or return column numbers
find_var(efc, "cop", out = "index")

# find variables with "dependency" in names and variable labels
library(sjlabelled)
find_var(efc, "dependency")
get_label(efc$e42dep)

# find variables with "level" in names and value labels
res &lt;- find_var(efc, "level", search = "name_value", out = "df")
res
get_labels(res, attr.only = FALSE)

# use sjPlot::view_df() to view results
## Not run: 
library(sjPlot)
view_df(res)
## End(Not run)
</code></pre>

<hr>
<h2 id='flat_table'>Flat (proportional) tables</h2><span id='topic+flat_table'></span>

<h3>Description</h3>

<p>This function creates a labelled flat table or flat
proportional (marginal) table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_table(
  data,
  ...,
  margin = c("counts", "cell", "row", "col"),
  digits = 2,
  show.values = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat_table_+3A_data">data</code></td>
<td>
<p>A data frame. May also be a grouped data frame (see 'Note' and
'Examples').</p>
</td></tr>
<tr><td><code id="flat_table_+3A_...">...</code></td>
<td>
<p>One or more variables of <code>data</code> that should be printed as table.</p>
</td></tr>
<tr><td><code id="flat_table_+3A_margin">margin</code></td>
<td>
<p>Specify the table margin that should be computed for proportional
tables. By default, counts are printed. Use <code>margin = "cell"</code>,
<code>margin = "col"</code> or <code>margin = "row"</code> to print cell,
column or row percentages of the table margins.</p>
</td></tr>
<tr><td><code id="flat_table_+3A_digits">digits</code></td>
<td>
<p>Numeric; for proportional tables, <code>digits</code> indicates the
number of decimal places.</p>
</td></tr>
<tr><td><code id="flat_table_+3A_show.values">show.values</code></td>
<td>
<p>Logical, if <code>TRUE</code>, value labels are prefixed by the
associated value.</p>
</td></tr>
<tr><td><code id="flat_table_+3A_weights">weights</code></td>
<td>
<p>Bare name, or name as string, of a variable in <code>x</code>
that indicates the vector of weights, which will be applied to weight all
observations. Default is <code>NULL</code>, so no weights are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+ftable">ftable</a></code>.
</p>


<h3>Note</h3>

<p><code>data</code> may also be a grouped data frame (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>)
with up to two grouping variables. Cross tables are created for each subgroup then.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frq">frq</a></code> for simple frequency table of labelled vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)

# flat table with counts
flat_table(efc, e42dep, c172code, e16sex)

# flat table with proportions
flat_table(efc, e42dep, c172code, e16sex, margin = "row")

# flat table from grouped data frame. You need to select
# the grouping variables and at least two more variables for
# cross tabulation.
library(dplyr)
efc %&gt;%
  group_by(e16sex) %&gt;%
  select(e16sex, c172code, e42dep) %&gt;%
  flat_table()

efc %&gt;%
  group_by(e16sex, e42dep) %&gt;%
  select(e16sex, e42dep, c172code, n4pstu) %&gt;%
  flat_table()

# now it gets weird...
efc %&gt;%
  group_by(e16sex, e42dep) %&gt;%
  select(e16sex, e42dep, c172code, n4pstu, c161sex) %&gt;%
  flat_table()
</code></pre>

<hr>
<h2 id='frq'>Frequency table of labelled variables</h2><span id='topic+frq'></span>

<h3>Description</h3>

<p>This function returns a frequency table of labelled vectors, as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frq(
  x,
  ...,
  sort.frq = c("none", "asc", "desc"),
  weights = NULL,
  auto.grp = NULL,
  show.strings = TRUE,
  show.na = TRUE,
  grp.strings = NULL,
  min.frq = 0,
  out = c("txt", "viewer", "browser"),
  title = NULL,
  encoding = "UTF-8",
  file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frq_+3A_x">x</code></td>
<td>
<p>A vector or a data frame. May also be a grouped data frame
(see 'Note' and 'Examples').</p>
</td></tr>
<tr><td><code id="frq_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="frq_+3A_sort.frq">sort.frq</code></td>
<td>
<p>Determines whether categories should be sorted
according to their frequencies or not. Default is <code>"none"</code>, so
categories are not sorted by frequency. Use <code>"asc"</code> or
<code>"desc"</code> for sorting categories ascending or descending order.</p>
</td></tr>
<tr><td><code id="frq_+3A_weights">weights</code></td>
<td>
<p>Bare name, or name as string, of a variable in <code>x</code>
that indicates the vector of weights, which will be applied to weight all
observations. Default is <code>NULL</code>, so no weights are used.</p>
</td></tr>
<tr><td><code id="frq_+3A_auto.grp">auto.grp</code></td>
<td>
<p>Numeric value, indicating the minimum amount of unique
values in a variable, at which automatic grouping into smaller  units
is done (see <code><a href="#topic+group_var">group_var</a></code>). Default value for <code>auto.group</code>
is <code>NULL</code>, i.e. auto-grouping is off.</p>
</td></tr>
<tr><td><code id="frq_+3A_show.strings">show.strings</code></td>
<td>
<p>Logical, if <code>TRUE</code>, frequency tables for character
vectors will not be printed. This is useful when printing frequency tables
of all variables from a data frame, and due to computational reasons
character vectors should not be printed.</p>
</td></tr>
<tr><td><code id="frq_+3A_show.na">show.na</code></td>
<td>
<p>Logical, or <code>"auto"</code>. If <code>TRUE</code>, the output always
contains information on missing values, even if variables have no missing
values. If <code>FALSE</code>, information on missing values are removed from
the output. If <code>show.na = "auto"</code>, information on missing values
is only shown when variables actually have missing values, else it's not
shown.</p>
</td></tr>
<tr><td><code id="frq_+3A_grp.strings">grp.strings</code></td>
<td>
<p>Numeric, if not <code>NULL</code>, groups string values in
character vectors, based on their similarity. See <code><a href="#topic+group_str">group_str</a></code>
and <code><a href="#topic+str_find">str_find</a></code> for details on grouping, and their
<code>precision</code>-argument to get more details on the distance of strings
to be treated as equal.</p>
</td></tr>
<tr><td><code id="frq_+3A_min.frq">min.frq</code></td>
<td>
<p>Numeric, indicating the minimum frequency for which a
value will be shown in the output (except for the missing values, prevailing
<code>show.na</code>). Default value for <code>min.frq</code> is <code>0</code>, so all value
frequencies are shown. All values or categories that have less than
<code>min.frq</code> occurences in the data will be summarized in a <code>"n &lt; 100"</code>
category.</p>
</td></tr>
<tr><td><code id="frq_+3A_out">out</code></td>
<td>
<p>Character vector, indicating whether the results should be printed
to console (<code>out = "txt"</code>) or as HTML-table in the viewer-pane
(<code>out = "viewer"</code>) or browser (<code>out = "browser"</code>).</p>
</td></tr>
<tr><td><code id="frq_+3A_title">title</code></td>
<td>
<p>String, will be used as alternative title to the variable
label. If <code>x</code> is a grouped data frame, <code>title</code> must be a
vector of same length as groups.</p>
</td></tr>
<tr><td><code id="frq_+3A_encoding">encoding</code></td>
<td>
<p>Character vector, indicating the charset encoding used
for variable and value labels. Default is <code>"UTF-8"</code>. Only used
when <code>out</code> is not <code>"txt"</code>.</p>
</td></tr>
<tr><td><code id="frq_+3A_file">file</code></td>
<td>
<p>Destination file, if the output should be saved as file.
Only used when <code>out</code> is not <code>"txt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ...-argument not only accepts variable names or expressions
from select-helpers. You can also use logical
conditions, math operations, or combining variables to produce &quot;crosstables&quot;.
See 'Examples' for more details.
</p>


<h3>Value</h3>

<p>A list of data frames with values, value labels, frequencies, raw, valid and
cumulative percentages of <code>x</code>.
</p>


<h3>Note</h3>

<p><code>x</code> may also be a grouped data frame (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>)
with up to two grouping variables. Frequency tables are created for each
subgroup then.
<br /> <br />
The <code>print()</code>-method adds a table header with information on the
variable label, variable type, total and valid N, and mean and
standard deviations. Mean and SD are <em>always</em> printed, even for
categorical variables (factors) or character vectors. In this case,
values are coerced into numeric vector to calculate the summary
statistics.
<br /> <br />
To print tables in markdown or HTML format, use <code>print_md()</code> or
<code>print_html()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flat_table">flat_table</a></code> for labelled (proportional) tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple vector
data(efc)
frq(efc$e42dep)

# with grouped data frames, in a pipe
library(dplyr)
efc %&gt;%
  group_by(e16sex, c172code) %&gt;%
  frq(e42dep)

# show only categories with a minimal amount of frequencies
frq(mtcars$gear)

frq(mtcars$gear, min.frq = 10)

frq(mtcars$gear, min.frq = 15)

# with select-helpers: all variables from the COPE-Index
# (which all have a "cop" in their name)
frq(efc, contains("cop"))

# all variables from column "c161sex" to column "c175empl"
frq(efc, c161sex:c175empl)

# for non-labelled data, variable name is printed,
# and "label" column is removed from output
data(iris)
frq(iris, Species)

# also works on grouped data frames
efc %&gt;%
  group_by(c172code) %&gt;%
  frq(is.na(nur_pst))

# group variables with large range and with weights
efc$weights &lt;- abs(rnorm(n = nrow(efc), mean = 1, sd = .5))
frq(efc, c160age, auto.grp = 5, weights = weights)

# different weight options
frq(efc, c172code, weights = weights)
frq(efc, c172code, weights = "weights")
frq(efc, c172code, weights = efc$weights)
frq(efc$c172code, weights = efc$weights)

# group string values
dummy &lt;- efc[1:50, 3, drop = FALSE]
dummy$words &lt;- sample(
  c("Hello", "Helo", "Hole", "Apple", "Ape",
    "New", "Old", "System", "Systemic"),
  size = nrow(dummy),
  replace = TRUE
)

frq(dummy)
frq(dummy, grp.strings = 2)

#### other expressions than variables

# logical conditions
frq(mtcars, cyl ==6)

frq(efc, is.na(nur_pst), contains("cop"))

iris %&gt;%
  frq(starts_with("Petal"), Sepal.Length &gt; 5)

# computation of variables "on the fly"
frq(mtcars, (gear + carb) / cyl)

# crosstables
set.seed(123)
d &lt;- data.frame(
  var_x = sample(letters[1:3], size = 30, replace = TRUE),
  var_y = sample(1:2, size = 30, replace = TRUE),
  var_z = sample(LETTERS[8:10], size = 30, replace = TRUE)
)
table(d$var_x, d$var_z)
frq(d, paste0(var_x, var_z))
frq(d, paste0(var_x, var_y, var_z))
</code></pre>

<hr>
<h2 id='group_str'>Group near elements of string vectors</h2><span id='topic+group_str'></span>

<h3>Description</h3>

<p>This function groups elements of a string vector (character or string
variable) according to the element's distance ('similatiry'). The
more similar two string elements are, the higher is the
chance to be combined into a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_str(
  strings,
  precision = 2,
  strict = FALSE,
  trim.whitespace = TRUE,
  remove.empty = TRUE,
  verbose = FALSE,
  maxdist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_str_+3A_strings">strings</code></td>
<td>
<p>Character vector with string elements.</p>
</td></tr>
<tr><td><code id="group_str_+3A_precision">precision</code></td>
<td>
<p>Maximum distance (&quot;precision&quot;) between two string elements,
which is allowed to treat them as similar or equal. Smaller values mean
less tolerance in matching.</p>
</td></tr>
<tr><td><code id="group_str_+3A_strict">strict</code></td>
<td>
<p>Logical; if <code>TRUE</code>, value matching is more strictly. See 'Examples'.</p>
</td></tr>
<tr><td><code id="group_str_+3A_trim.whitespace">trim.whitespace</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), leading and trailing white spaces will
be removed from string values.</p>
</td></tr>
<tr><td><code id="group_str_+3A_remove.empty">remove.empty</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), empty string values will be removed from the
character vector <code>strings</code>.</p>
</td></tr>
<tr><td><code id="group_str_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the progress bar is displayed when computing the distance matrix.
Default in <code>FALSE</code>, hence the bar is hidden.</p>
</td></tr>
<tr><td><code id="group_str_+3A_maxdist">maxdist</code></td>
<td>
<p>Deprecated. Please use <code>precision</code> now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector where similar string elements (values) are recoded
into a new, single value. The return value is of same length as
<code>strings</code>, i.e. grouped elements appear multiple times, so
the count for each grouped string is still avaiable (see 'Examples').
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str_find">str_find</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldstring &lt;- c("Hello", "Helo", "Hole", "Apple",
               "Ape", "New", "Old", "System", "Systemic")
newstring &lt;- group_str(oldstring)

# see result
newstring

# count for each groups
table(newstring)

# print table to compare original and grouped string
frq(oldstring)
frq(newstring)

# larger groups
newstring &lt;- group_str(oldstring, precision = 3)
frq(oldstring)
frq(newstring)

# be more strict with matching pairs
newstring &lt;- group_str(oldstring, precision = 3, strict = TRUE)
frq(oldstring)
frq(newstring)
</code></pre>

<hr>
<h2 id='group_var'>Recode numeric variables into equal-ranged groups</h2><span id='topic+group_var'></span><span id='topic+group_var_if'></span><span id='topic+group_labels'></span><span id='topic+group_labels_if'></span>

<h3>Description</h3>

<p>Recode numeric variables into equal ranged, grouped factors,
i.e. a variable is cut into a smaller number of groups, where each group
has the same value range. <code>group_labels()</code> creates the related value
labels. <code>group_var_if()</code> and <code>group_labels_if()</code> are scoped
variants of <code>group_var()</code> and <code>group_labels()</code>, where grouping
will be applied only to those variables that match the logical condition
of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_var(
  x,
  ...,
  size = 5,
  as.num = TRUE,
  right.interval = FALSE,
  n = 30,
  append = TRUE,
  suffix = "_gr"
)

group_var_if(
  x,
  predicate,
  size = 5,
  as.num = TRUE,
  right.interval = FALSE,
  n = 30,
  append = TRUE,
  suffix = "_gr"
)

group_labels(x, ..., size = 5, right.interval = FALSE, n = 30)

group_labels_if(x, predicate, size = 5, right.interval = FALSE, n = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_var_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="group_var_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="group_var_+3A_size">size</code></td>
<td>
<p>Numeric; group-size, i.e. the range for grouping. By default,
for each 5 categories of <code>x</code> a new group is defined, i.e. <code>size = 5</code>.
Use <code>size = "auto"</code> to automatically resize a variable into a maximum
of 30 groups (which is the ggplot-default grouping when plotting
histograms). Use <code>n</code> to determine the amount of groups.</p>
</td></tr>
<tr><td><code id="group_var_+3A_as.num">as.num</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return value will be numeric, not a factor.</p>
</td></tr>
<tr><td><code id="group_var_+3A_right.interval">right.interval</code></td>
<td>
<p>Logical; if <code>TRUE</code>, grouping starts with the lower
bound of <code>size</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="group_var_+3A_n">n</code></td>
<td>
<p>Sets the maximum number of groups that are defined when auto-grouping is on
(<code>size = "auto"</code>). Default is 30. If <code>size</code> is not set to <code>"auto"</code>,
this argument will be ignored.</p>
</td></tr>
<tr><td><code id="group_var_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="group_var_+3A_suffix">suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="group_var_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>size</code> is set to a specific value, the variable is recoded
into several groups, where each group has a maximum range of <code>size</code>.
Hence, the amount of groups differ depending on the range of <code>x</code>.
<br /> <br />
If <code>size = "auto"</code>, the variable is recoded into a maximum of
<code>n</code> groups. Hence, independent from the range of
<code>x</code>, always the same amount of groups are created, so the range
within each group differs (depending on <code>x</code>'s range).
<br /> <br />
<code>right.interval</code> determins which boundary values to include when
grouping is done. If <code>TRUE</code>, grouping starts with the <strong>lower
bound</strong> of <code>size</code>. For example, having a variable ranging from
50 to 80, groups cover the ranges from  50-54, 55-59, 60-64 etc.
If <code>FALSE</code> (default), grouping starts with the <code>upper bound</code>
of <code>size</code>. In this case, groups cover the ranges from
46-50, 51-55, 56-60, 61-65 etc. <strong>Note:</strong> This will cover
a range from 46-50 as first group, even if values from 46 to 49
are not present. See 'Examples'.
<br /> <br />
If you want to split a variable into a certain amount of equal
sized groups (instead of having groups where values have all the same
range), use the <code><a href="#topic+split_var">split_var</a></code> function!
<br /> <br />
<code>group_var()</code> also works on grouped data frames (see <code><a href="dplyr.html#topic+group_by">group_by</a></code>).
In this case, grouping is applied to the subsets of variables
in <code>x</code>. See 'Examples'.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>group_var()</code>, a grouped variable, either as numeric or as factor (see paramter <code>as.num</code>). If <code>x</code> is a data frame, only the grouped variables will be returned.
</p>
</li>
<li><p> For <code>group_labels()</code>, a string vector or a list of string vectors containing labels based on the grouped categories of <code>x</code>, formatted as &quot;from lower bound to upper bound&quot;, e.g. <code>"10-19"  "20-29"  "30-39"</code> etc. See 'Examples'.
</p>
</li></ul>



<h3>Note</h3>

<p>Variable label attributes (see, for instance,
<code><a href="sjlabelled.html#topic+set_label">set_label</a></code>) are preserved. Usually you should use
the same values for <code>size</code> and <code>right.interval</code> in
<code>group_labels()</code> as used in the <code>group_var</code> function if you want
matching labels for the related recoded variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split_var">split_var</a></code> to split variables into equal sized groups,
<code><a href="#topic+group_str">group_str</a></code> for grouping string vectors or
<code><a href="#topic+rec_pattern">rec_pattern</a></code> and <code><a href="#topic+rec">rec</a></code> for another convenient
way of recoding variables into smaller groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age &lt;- abs(round(rnorm(100, 65, 20)))
age.grp &lt;- group_var(age, size = 10)
hist(age)
hist(age.grp)

age.grpvar &lt;- group_labels(age, size = 10)
table(age.grp)
print(age.grpvar)

# histogram with EUROFAMCARE sample dataset
# variable not grouped
library(sjlabelled)
data(efc)
hist(efc$e17age, main = get_label(efc$e17age))

# bar plot with EUROFAMCARE sample dataset
# grouped variable
ageGrp &lt;- group_var(efc$e17age)
ageGrpLab &lt;- group_labels(efc$e17age)
barplot(table(ageGrp), main = get_label(efc$e17age), names.arg = ageGrpLab)

# within a pipe-chain
library(dplyr)
efc %&gt;%
  select(e17age, c12hour, c160age) %&gt;%
  group_var(size = 20)

# create vector with values from 50 to 80
dummy &lt;- round(runif(200, 50, 80))
# labels with grouping starting at lower bound
group_labels(dummy)
# labels with grouping startint at upper bound
group_labels(dummy, right.interval = TRUE)

# works also with gouped data frames
mtcars %&gt;%
  group_var(disp, size = 4, append = FALSE) %&gt;%
  table()

mtcars %&gt;%
  group_by(cyl) %&gt;%
  group_var(disp, size = 4, append = FALSE) %&gt;%
  table()
</code></pre>

<hr>
<h2 id='has_na'>Check if variables or cases have missing / infinite values</h2><span id='topic+has_na'></span><span id='topic+incomplete_cases'></span><span id='topic+complete_cases'></span><span id='topic+complete_vars'></span><span id='topic+incomplete_vars'></span>

<h3>Description</h3>

<p>This functions checks if variables or observations in a data
frame have <code>NA</code>, <code>NaN</code> or <code>Inf</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_na(x, ..., by = c("col", "row"), out = c("table", "df", "index"))

incomplete_cases(x, ...)

complete_cases(x, ...)

complete_vars(x, ...)

incomplete_vars(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_na_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="has_na_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="has_na_+3A_by">by</code></td>
<td>
<p>Whether to check column- or row-wise for missing and infinite values.
If <code>by = "col"</code>, <code>has_na()</code> checks for <code>NA</code>/<code>NaN</code>/<code>Inf</code>
in <em>columns</em>; If <code>by = "row"</code>, <code>has_na()</code> checks each row for
these values.</p>
</td></tr>
<tr><td><code id="has_na_+3A_out">out</code></td>
<td>
<p>Output (return) format of the results. May be abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a vector, returns <code>TRUE</code> if <code>x</code> has any missing
or infinite values. If <code>x</code> is a data frame, returns <code>TRUE</code> for
each variable (if <code>by = "col"</code>) or observation (if <code>by = "row"</code>)
that has any missing or infinite values. If <code>out = "table"</code>, results
are returned as data frame, with column number, variable name and
label, and a logical vector indicating if a variable has missing values or
not. However, it's printed in colors, with green rows indicating that a
variable has no missings, while red rows indicate the presence of missings
or infinite values. If <code>out = "index"</code>, a named vector is returned.
</p>


<h3>Note</h3>

<p><code>complete_cases()</code> and <code>incomplete_cases()</code> are convenient
shortcuts for <code>has_na(by = "row", out = "index")</code>, where the first
only returns case-id's for all complete cases, and the latter only for
non-complete cases. <br /> <br />
<code>complete_vars()</code> and <code>incomplete_vars()</code> are convenient shortcuts
for <code>has_na(by = "col", out = "index")</code>, and again only return those
column-id's for variables which are (in-)complete.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
has_na(efc$e42dep)
has_na(efc, e42dep, tot_sc_e, c161sex)
has_na(efc)

has_na(efc, e42dep, tot_sc_e, c161sex, out = "index")
has_na(efc, out = "df")

has_na(efc, by = "row")
has_na(efc, e42dep, tot_sc_e, c161sex, by = "row", out = "index")
has_na(efc, by = "row", out = "df")

complete_cases(efc, e42dep, tot_sc_e, c161sex)
incomplete_cases(efc, e42dep, tot_sc_e, c161sex)
complete_vars(efc, e42dep, tot_sc_e, c161sex)
incomplete_vars(efc, e42dep, tot_sc_e, c161sex)
</code></pre>

<hr>
<h2 id='is_crossed'>Check whether two factors are crossed or nested</h2><span id='topic+is_crossed'></span><span id='topic+is_nested'></span><span id='topic+is_cross_classified'></span>

<h3>Description</h3>

<p>These functions checks whether two factors are (fully) crossed
or nested, i.e. if each level of one factor occurs in combination with
each level of the other factor (<code>is_crossed()</code>) resp. if each
category of the first factor co-occurs with only one category of the
other (<code>is_nested()</code>). <code>is_cross_classified()</code> checks if one
factor level occurs in some, but not all levels of another factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_crossed(f1, f2)

is_nested(f1, f2)

is_cross_classified(f1, f2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_crossed_+3A_f1">f1</code></td>
<td>
<p>Numeric vector or <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="is_crossed_+3A_f2">f2</code></td>
<td>
<p>Numeric vector or <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. For <code>is_crossed()</code>, <code>TRUE</code> if factors are (fully)
crossed, <code>FALSE</code> otherwise. For <code>is_nested()</code>, <code>TRUE</code> if
factors are nested, <code>FALSE</code> otherwise. For <code>is_cross_classified()</code>,
<code>TRUE</code>, if one factor level occurs in some, but not all levels of
another factor.
</p>


<h3>Note</h3>

<p>If factors are nested, a message is displayed to tell whether <code>f1</code>
is nested within <code>f2</code> or vice versa.
</p>


<h3>References</h3>

<p>Grace, K. The Difference Between Crossed and Nested Factors. <a href="https://www.theanalysisfactor.com/the-difference-between-crossed-and-nested-factors/">(web)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># crossed factors, each category of
# x appears in each category of y
x &lt;- c(1,4,3,2,3,2,1,4)
y &lt;- c(1,1,1,2,2,1,2,2)
# show distribution
table(x, y)
# check if crossed
is_crossed(x, y)

# not crossed factors
x &lt;- c(1,4,3,2,3,2,1,4)
y &lt;- c(1,1,1,2,1,1,2,2)
# show distribution
table(x, y)
# check if crossed
is_crossed(x, y)


# nested factors, each category of
# x appears in one category of y
x &lt;- c(1,2,3,4,5,6,7,8,9)
y &lt;- c(1,1,1,2,2,2,3,3,3)
# show distribution
table(x, y)
# check if nested
is_nested(x, y)
is_nested(y, x)

# not nested factors
x &lt;- c(1,2,3,4,5,6,7,8,9,1,2)
y &lt;- c(1,1,1,2,2,2,3,3,3,2,3)
# show distribution
table(x, y)
# check if nested
is_nested(x, y)
is_nested(y, x)

# also not fully crossed
is_crossed(x, y)

# but partially crossed
is_cross_classified(x, y)

</code></pre>

<hr>
<h2 id='is_empty'>Check whether string, list or vector is empty</h2><span id='topic+is_empty'></span>

<h3>Description</h3>

<p>This function checks whether a string or character vector (of
length 1), a list or any vector (numeric, atomic) is empty or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty(x, first.only = TRUE, all.na.empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_empty_+3A_x">x</code></td>
<td>
<p>String, character vector, list, data.frame or numeric vector or factor.</p>
</td></tr>
<tr><td><code id="is_empty_+3A_first.only">first.only</code></td>
<td>
<p>Logical, if <code>FALSE</code> and <code>x</code> is a character
vector, each element of <code>x</code> will be checked if empty. If
<code>TRUE</code>, only the first element of <code>x</code> will be checked.</p>
</td></tr>
<tr><td><code id="is_empty_+3A_all.na.empty">all.na.empty</code></td>
<td>
<p>Logical, if <code>x</code> is a vector with <code>NA</code>-values
only, <code>is_empty</code> will return <code>FALSE</code> if <code>all.na.empty = FALSE</code>,
and will return <code>TRUE</code> if <code>all.na.empty = TRUE</code> (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if <code>x</code> is a character vector or string and
is empty, <code>TRUE</code> if <code>x</code> is a vector or list and of length 0,
<code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p><code>NULL</code>- or <code>NA</code>-values are also considered as &quot;empty&quot; (see
'Examples') and will return <code>TRUE</code>, unless <code>all.na.empty==FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_empty("test")
is_empty("")
is_empty(NA)
is_empty(NULL)

# string is not empty
is_empty(" ")

# however, this trimmed string is
is_empty(trim(" "))

# numeric vector
x &lt;- 1
is_empty(x)
x &lt;- x[-1]
is_empty(x)

# check multiple elements of character vectors
is_empty(c("", "a"))
is_empty(c("", "a"), first.only = FALSE)

# empty data frame
d &lt;- data.frame()
is_empty(d)

# empty list
is_empty(list(NULL))

# NA vector
x &lt;- rep(NA,5)
is_empty(x)
is_empty(x, all.na.empty = FALSE)
</code></pre>

<hr>
<h2 id='is_even'>Check whether value is even or odd</h2><span id='topic+is_even'></span><span id='topic+is_odd'></span>

<h3>Description</h3>

<p>Checks whether <code>x</code> is an even or odd number. Only
accepts numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_even(x)

is_odd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_even_+3A_x">x</code></td>
<td>
<p>Numeric vector or single numeric value, or a data frame or list with
such vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_even()</code> returns <code>TRUE</code> for each even value of <code>x</code>, <code>FALSE</code> for
odd values. <code>is_odd()</code> returns <code>TRUE</code> for each odd value of <code>x</code>
and <code>FALSE</code> for even values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_even(4)
is_even(5)
is_even(1:4)

is_odd(4)
is_odd(5)
is_odd(1:4)

</code></pre>

<hr>
<h2 id='is_float'>Check if a variable is of (non-integer) double type or a whole number</h2><span id='topic+is_float'></span><span id='topic+is_whole'></span>

<h3>Description</h3>

<p><code>is_float()</code> checks whether an input vector or value is a
numeric non-integer (double), depending on fractional parts of the value(s).
<code>is_whole()</code> does the opposite and checks whether an input vector
is a whole number (without fractional parts).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_float(x)

is_whole(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_float_+3A_x">x</code></td>
<td>
<p>A value, vector or data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>is_float()</code>, <code>TRUE</code> if <code>x</code> is a floating value
(non-integer double), <code>FALSE</code> otherwise (also returns <code>FALSE</code>
for character vectors and factors). For <code>is_whole()</code>, <code>TRUE</code>
if <code>x</code> is a vector with whole numbers only, <code>FALSE</code> otherwise
(returns <code>TRUE</code> for character vectors and factors).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data(iris)

is.double(4)
is_float(4)
is_float(4.2)
is_float(iris)

is_whole(4)
is_whole(4.2)
is_whole(mtcars)


</code></pre>

<hr>
<h2 id='is_num_fac'>Check whether a factor has numeric levels only</h2><span id='topic+is_num_fac'></span><span id='topic+is_num_chr'></span>

<h3>Description</h3>

<p><code>is_num_fac()</code> checks whether a factor has only numeric or
any non-numeric factor levels, while <code>is_num_chr()</code> checks whether
a character vector has only numeric strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_num_fac(x)

is_num_chr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_num_fac_+3A_x">x</code></td>
<td>
<p>A factor for <code>is_num_fac()</code> and a character vector for
<code>is_num_chr()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if factor has numeric factor levels only, or
if character vector has numeric strings only, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># numeric factor levels
f1 &lt;- factor(c(NA, 1, 3, NA, 2, 4))
is_num_fac(f1)

# not completeley numeric factor levels
f2 &lt;- factor(c(NA, "C", 1, 3, "A", NA, 2, 4))
is_num_fac(f2)

# not completeley numeric factor levels
f3 &lt;- factor(c("Justus", "Bob", "Peter"))
is_num_fac(f3)

is_num_chr(c("a", "1"))
is_num_chr(c("2", "1"))

</code></pre>

<hr>
<h2 id='merge_imputations'>Merges multiple imputed data frames into a single data frame</h2><span id='topic+merge_imputations'></span>

<h3>Description</h3>

<p>This function merges multiple imputed data frames from
<code><a href="mice.html#topic+mids-class">mice::mids()</a></code>-objects into a single data frame
by computing the mean or selecting the most likely imputed value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_imputations(
  dat,
  imp,
  ori = NULL,
  summary = c("none", "dens", "hist", "sd"),
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_imputations_+3A_dat">dat</code></td>
<td>
<p>The data frame that was imputed and used as argument in the
<code><a href="mice.html#topic+mice">mice</a></code>-function call.</p>
</td></tr>
<tr><td><code id="merge_imputations_+3A_imp">imp</code></td>
<td>
<p>The <code><a href="mice.html#topic+mids-class">mice::mids()</a></code>-object with the imputed data frames
from <code>dat</code>.</p>
</td></tr>
<tr><td><code id="merge_imputations_+3A_ori">ori</code></td>
<td>
<p>Optional, if <code>ori</code> is specified, the imputed variables are
appended to this data frame; else, a new data frame with the imputed
variables is returned.</p>
</td></tr>
<tr><td><code id="merge_imputations_+3A_summary">summary</code></td>
<td>
<p>After merging multiple imputed data, <code>summary</code> displays
a graphical summary of the &quot;quality&quot; of the merged values, compared
to the original imputed values.
</p>

<dl>
<dt><code>"dens"</code></dt><dd>
<p>Creates a density plot, which shows the distribution of the mean
of the imputed values for each variable at each observation. The
larger the areas overlap, the better is the fit of the merged
value compared to the imputed value.
</p>
</dd>
<dt><code>"hist"</code></dt><dd>
<p>Similar to <code>summary = "dens"</code>, however, mean and merged
values are shown as histogram. Bins should have almost equal
height for both groups (mean and merged).
</p>
</dd>
<dt><code>"sd"</code></dt><dd>
<p>Creates a dot plot, where data points indicate the standard
deviation for all imputed values (y-axis) at each merged
value (x-axis) for all imputed variables. The higher the
standard deviation, the less precise is the imputation, and
hence the merged value.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="merge_imputations_+3A_filter">filter</code></td>
<td>
<p>A character vector with variable names that should be plotted.
All non-defined variables will not be shown in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method merges multiple imputations of variables into a single
variable by computing the (rounded) mean of all imputed values
of missing values. By this, each missing value is replaced by
those values that have been imputed the most times.
<br /> <br />
<code>imp</code> must be a <code>mids</code>-object, which is returned by the
<code>mice()</code>-function of the <span class="pkg">mice</span>-package. <code>merge_imputations()</code>
than creates a data frame for each imputed variable, by combining all
imputations (as returned by the <code><a href="mice.html#topic+complete">complete</a></code>-function)
of each variable, and computing the row means of this data frame.
The mean value is then rounded for integer values (and not for numerical
values with fractional part), which corresponds to the most frequent
imputed value (mode) for a missing value. Missings in the original variable
are replaced by the most frequent imputed value.
</p>


<h3>Value</h3>

<p>A data frame with (merged) imputed variables; or <code>ori</code> with
appended imputed variables, if <code>ori</code> was specified.
If <code>summary</code> is included, returns a list with the data frame
<code>data</code> with (merged) imputed variables and some other summary
information, including the <code>plot</code> as ggplot-object.
</p>


<h3>Note</h3>

<p>Typically, further analyses are conducted on pooled results of multiple
imputed data sets (see <code><a href="mice.html#topic+pool">pool</a></code>), however, sometimes
(in social sciences) it is also feasible to compute the mean or mode
of multiple imputed variables (see <cite>Burns et al. 2011</cite>).
</p>


<h3>References</h3>

<p>Burns RA, Butterworth P, Kiely KM, Bielak AAM, Luszcz MA, Mitchell P, et al. 2011. Multiple imputation was an efficient method for harmonizing the Mini-Mental State Examination with missing item-level data. Journal of Clinical Epidemiology;64:787-93 <a href="https://doi.org/10.1016/j.jclinepi.2010.10.011">doi:10.1016/j.jclinepi.2010.10.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("mice")) {
  imp &lt;- mice(nhanes)

  # return data frame with imputed variables
  merge_imputations(nhanes, imp)

  # append imputed variables to original data frame
  merge_imputations(nhanes, imp, nhanes)

  # show summary of quality of merging imputations
  merge_imputations(nhanes, imp, summary = "dens", filter = c("chl", "hyp"))
}
</code></pre>

<hr>
<h2 id='move_columns'>Move columns to other positions in a data frame</h2><span id='topic+move_columns'></span>

<h3>Description</h3>

<p><code>move_columns()</code> moves one or more columns in a data frame
to another position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_columns(data, ..., .before, .after)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_columns_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="move_columns_+3A_...">...</code></td>
<td>
<p>Unquoted names or character vector with names of variables that
should be move to another position. You may also use functions like
<code>:</code> or tidyselect's select-helpers.</p>
</td></tr>
<tr><td><code id="move_columns_+3A_.before">.before</code></td>
<td>
<p>Optional, column name or numeric index of the position where
<code>col</code> should be moved to. If not missing, <code>col</code> is moved to the
position <em>before</em> the column indicated by <code>.before</code>.</p>
</td></tr>
<tr><td><code id="move_columns_+3A_.after">.after</code></td>
<td>
<p>Optional, column name or numeric index of the position where
<code>col</code> should be moved to. If not missing, <code>col</code> is moved to the
position <em>after</em> the column indicated by <code>.after</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code>, with resorted columns.
</p>


<h3>Note</h3>

<p>If neither <code>.before</code> nor <code>.after</code> are specified, the
column is moved to the end of the data frame by default. <code>.before</code>
and <code>.after</code> are evaluated in a non-standard fashion, so you need
quasi-quotation when the value for <code>.before</code> or <code>.after</code> is
a vector with the target-column value. See 'Examples'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(iris)

iris %&gt;%
  move_columns(Sepal.Width, .after = "Species") %&gt;%
  head()

iris %&gt;%
  move_columns(Sepal.Width, .before = Sepal.Length) %&gt;%
  head()

iris %&gt;%
  move_columns(Species, .before = 1) %&gt;%
  head()

iris %&gt;%
  move_columns("Species", "Petal.Length", .after = 1) %&gt;%
  head()

library(dplyr)
iris %&gt;%
  move_columns(contains("Width"), .after = "Species") %&gt;%
  head()
## End(Not run)

# using quasi-quotation
target &lt;- "Petal.Width"
# does not work, column is moved to the end
iris %&gt;%
  move_columns(Sepal.Width, .after = target) %&gt;%
  head()

# using !! works
iris %&gt;%
  move_columns(Sepal.Width, .after = !!target) %&gt;%
  head()
</code></pre>

<hr>
<h2 id='numeric_to_factor'>Convert numeric vectors into factors associated value labels</h2><span id='topic+numeric_to_factor'></span>

<h3>Description</h3>

<p>This function converts numeric variables into factors,
and uses associated value labels as factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric_to_factor(x, n = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numeric_to_factor_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="numeric_to_factor_+3A_n">n</code></td>
<td>
<p>Numeric, indicating the maximum amount of unique values in <code>x</code>
to be considered as &quot;factor&quot;. Variables with more unique values than <code>n</code>
are not converted to factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a labelled vector, associated value labels will be used
as level. Else, the numeric vector is simply coerced using <code>as.factor()</code>.
</p>


<h3>Value</h3>

<p><code>x</code>, with numeric values with a maximum of <code>n</code> unique values
being converted to factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(efc)
efc %&gt;%
  select(e42dep, e16sex, c12hour, c160age, c172code) %&gt;%
  numeric_to_factor()
</code></pre>

<hr>
<h2 id='rec'>Recode variables</h2><span id='topic+rec'></span><span id='topic+rec_if'></span>

<h3>Description</h3>

<p><code>rec()</code> recodes values of variables, where variable
selection is based on variable names or column position, or on
select helpers (see documentation on <code>...</code>). <code>rec_if()</code> is a
scoped variant of <code>rec()</code>, where recoding will be applied only
to those variables that match the logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rec(
  x,
  ...,
  rec,
  as.num = TRUE,
  var.label = NULL,
  val.labels = NULL,
  append = TRUE,
  suffix = "_r",
  to.factor = !as.num
)

rec_if(
  x,
  predicate,
  rec,
  as.num = TRUE,
  var.label = NULL,
  val.labels = NULL,
  append = TRUE,
  suffix = "_r",
  to.factor = !as.num
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rec_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="rec_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="rec_+3A_rec">rec</code></td>
<td>
<p>String with recode pairs of old and new values. See 'Details'
for examples. <code><a href="#topic+rec_pattern">rec_pattern</a></code> is a convenient function to
create recode strings for grouping variables.</p>
</td></tr>
<tr><td><code id="rec_+3A_as.num">as.num</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return value will be numeric, not a factor.</p>
</td></tr>
<tr><td><code id="rec_+3A_var.label">var.label</code></td>
<td>
<p>Optional string, to set variable label attribute for the
returned variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), variable label attribute of <code>x</code> will
be used (if present). If empty, variable label attributes will be removed.</p>
</td></tr>
<tr><td><code id="rec_+3A_val.labels">val.labels</code></td>
<td>
<p>Optional character vector, to set value label attributes
of recoded variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), no value labels will be set. Value labels
can also be directly defined in the <code>rec</code>-syntax, see
'Details'.</p>
</td></tr>
<tr><td><code id="rec_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="rec_+3A_suffix">suffix</code></td>
<td>
<p>String value, will be appended to variable (column) names of
<code>x</code>, if <code>x</code> is a data frame. If <code>x</code> is not a data
frame, this argument will be ignored. The default value to suffix
column names in a data frame depends on the function call:
</p>

<ul>
<li><p> recoded variables (<code>rec()</code>) will be suffixed with <code>"_r"</code>
</p>
</li>
<li><p> recoded variables (<code>recode_to()</code>) will be suffixed with <code>"_r0"</code>
</p>
</li>
<li><p> dichotomized variables (<code>dicho()</code>) will be suffixed with <code>"_d"</code>
</p>
</li>
<li><p> grouped variables (<code>split_var()</code>) will be suffixed with <code>"_g"</code>
</p>
</li>
<li><p> grouped variables (<code>group_var()</code>) will be suffixed with <code>"_gr"</code>
</p>
</li>
<li><p> standardized variables (<code>std()</code>) will be suffixed with <code>"_z"</code>
</p>
</li>
<li><p> centered variables (<code>center()</code>) will be suffixed with <code>"_c"</code>
</p>
</li></ul>

<p>If <code>suffix = ""</code> and <code>append = TRUE</code>, existing variables that
have been recoded/transformed will be overwritten.</p>
</td></tr>
<tr><td><code id="rec_+3A_to.factor">to.factor</code></td>
<td>
<p>Logical, alias for <code>as.num</code>. If <code>TRUE</code>, return value
will be a factor, not numeric.</p>
</td></tr>
<tr><td><code id="rec_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rec</code> string has following syntax:
</p>

<dl>
<dt>recode pairs</dt><dd><p>each recode pair has to be separated by a <code>;</code>, e.g. <code>rec = "1=1; 2=4; 3=2; 4=3"</code></p>
</dd>
<dt>multiple values</dt><dd><p>multiple old values that should be recoded into a new single value may be separated with comma, e.g. <code>"1,2=1; 3,4=2"</code></p>
</dd>
<dt>value range</dt><dd><p>a value range is indicated by a colon, e.g. <code>"1:4=1; 5:8=2"</code> (recodes all values from 1 to 4 into 1, and from 5 to 8 into 2)</p>
</dd>
<dt>value range for doubles</dt><dd><p>for double vectors (with fractional part), all values within the specified range are recoded; e.g. <code>1:2.5=1;2.6:3=2</code> recodes 1 to 2.5 into 1 and 2.6 to 3 into 2, but 2.55 would not be recoded (since it's not included in any of the specified ranges)</p>
</dd>
<dt><code>"min"</code> and <code>"max"</code></dt><dd><p>minimum and maximum values are indicates by <em>min</em> (or <em>lo</em>) and <em>max</em> (or <em>hi</em>), e.g. <code>"min:4=1; 5:max=2"</code> (recodes all values from minimum values of <code>x</code> to 4 into 1, and from 5 to maximum values of <code>x</code> into 2)</p>
</dd>
<dt><code>"else"</code></dt><dd><p>all other values, which have not been specified yet, are indicated by <em>else</em>, e.g. <code>"3=1; 1=2; else=3"</code> (recodes 3 into 1, 1 into 2 and all other values into 3)</p>
</dd>
<dt><code>"copy"</code></dt><dd><p>the <code>"else"</code>-token can be combined with <em>copy</em>, indicating that all remaining, not yet recoded values should stay the same (are copied from the original value), e.g. <code>"3=1; 1=2; else=copy"</code> (recodes 3 into 1, 1 into 2 and all other values like 2, 4 or 5 etc. will not be recoded, but copied, see 'Examples')</p>
</dd>
<dt><code>NA</code>'s</dt><dd><p><code><a href="base.html#topic+NA">NA</a></code> values are allowed both as old and new value, e.g. <code>"NA=1; 3:5=NA"</code> (recodes all NA into 1, and all values from 3 to 5 into NA in the new variable)</p>
</dd>
<dt><code>"rev"</code></dt><dd><p><code>"rev"</code> is a special token that reverses the value order (see 'Examples')</p>
</dd>
<dt>direct value labelling</dt><dd><p>value labels for new values can be assigned inside the recode pattern by writing the value label in square brackets after defining the new value in a recode pair, e.g. <code>"15:30=1 [young aged]; 31:55=2 [middle aged]; 56:max=3 [old aged]"</code>. See 'Examples'.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>x</code> with recoded categories. If <code>x</code> is a data frame,
for <code>append = TRUE</code>, <code>x</code> including the recoded variables
as new columns is returned; if <code>append = FALSE</code>, only
the recoded variables will be returned. If <code>append = TRUE</code> and
<code>suffix = ""</code>, recoded variables will replace (overwrite) existing
variables.
</p>


<h3>Note</h3>

<p>Please note following behaviours of the function:
</p>

<ul>
<li><p> the <code>"else"</code>-token should always be the last argument in the <code>rec</code>-string.
</p>
</li>
<li><p> Non-matching values will be set to <code>NA</code>, unless captured by the <code>"else"</code>-token.
</p>
</li>
<li><p> Tagged NA values (see <code><a href="haven.html#topic+tagged_na">tagged_na</a></code>) and their value labels will be preserved when copying NA values to the recoded vector with <code>"else=copy"</code>.
</p>
</li>
<li><p> Variable label attributes (see, for instance, <code><a href="sjlabelled.html#topic+get_label">get_label</a></code>) are preserved (unless changed via <code>var.label</code>-argument), however, value label attributes are removed (except for <code>"rev"</code>, where present value labels will be automatically reversed as well). Use <code>val.labels</code>-argument to add labels for recoded values.
</p>
</li>
<li><p> If <code>x</code> is a data frame, all variables should have the same categories resp. value range (else, see second bullet, <code>NA</code>s are produced).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="sjlabelled.html#topic+set_na">set_na</a></code> for setting <code>NA</code> values, <code><a href="#topic+replace_na">replace_na</a></code>
to replace <code>NA</code>'s with specific value, <code><a href="#topic+recode_to">recode_to</a></code>
for re-shifting value ranges and <code><a href="#topic+ref_lvl">ref_lvl</a></code> to change the
reference level of (numeric) factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
table(efc$e42dep, useNA = "always")

# replace NA with 5
table(rec(efc$e42dep, rec = "1=1;2=2;3=3;4=4;NA=5"), useNA = "always")

# recode 1 to 2 into 1 and 3 to 4 into 2
table(rec(efc$e42dep, rec = "1,2=1; 3,4=2"), useNA = "always")

# keep value labels. variable label is automatically preserved
library(dplyr)
efc %&gt;%
  select(e42dep) %&gt;%
  rec(rec = "1,2=1; 3,4=2",
      val.labels = c("low dependency", "high dependency")) %&gt;%
  frq()

# works with mutate
efc %&gt;%
  select(e42dep, e17age) %&gt;%
  mutate(dependency_rev = rec(e42dep, rec = "rev")) %&gt;%
  head()

# recode 1 to 3 into 1 and 4 into 2
table(rec(efc$e42dep, rec = "min:3=1; 4=2"), useNA = "always")

# recode 2 to 1 and all others into 2
table(rec(efc$e42dep, rec = "2=1; else=2"), useNA = "always")

# reverse value order
table(rec(efc$e42dep, rec = "rev"), useNA = "always")

# recode only selected values, copy remaining
table(efc$e15relat)
table(rec(efc$e15relat, rec = "1,2,4=1; else=copy"))

# recode variables with same category in a data frame
head(efc[, 6:9])
head(rec(efc[, 6:9], rec = "1=10;2=20;3=30;4=40"))

# recode multiple variables and set value labels via recode-syntax
dummy &lt;- rec(
  efc, c160age, e17age,
  rec = "15:30=1 [young]; 31:55=2 [middle]; 56:max=3 [old]",
  append = FALSE
)
frq(dummy)

# recode variables with same value-range
lapply(
  rec(
    efc, c82cop1, c83cop2, c84cop3,
    rec = "1,2=1; NA=9; else=copy",
    append = FALSE
  ),
  table,
  useNA = "always"
)

# recode character vector
dummy &lt;- c("M", "F", "F", "X")
rec(dummy, rec = "M=Male; F=Female; X=Refused")

# recode numeric to character
rec(efc$e42dep, rec = "1=first;2=2nd;3=third;else=hi") %&gt;% head()

# recode non-numeric factors
data(iris)
table(rec(iris, Species, rec = "setosa=huhu; else=copy", append = FALSE))

# recode floating points
table(rec(
  iris, Sepal.Length, rec = "lo:5=1;5.01:6.5=2;6.501:max=3", append = FALSE
))

# preserve tagged NAs
if (require("haven")) {
  x &lt;- labelled(c(1:3, tagged_na("a", "c", "z"), 4:1),
                c("Agreement" = 1, "Disagreement" = 4, "First" = tagged_na("c"),
                  "Refused" = tagged_na("a"), "Not home" = tagged_na("z")))
  # get current value labels
  x
  # recode 2 into 5; Values of tagged NAs are preserved
  rec(x, rec = "2=5;else=copy")
}

# use select-helpers from dplyr-package
out &lt;- rec(
  efc, contains("cop"), c161sex:c175empl,
  rec = "0,1=0; else=1",
  append = FALSE
)
head(out)

# recode only variables that have a value range from 1-4
p &lt;- function(x) min(x, na.rm = TRUE) &gt; 0 &amp;&amp; max(x, na.rm = TRUE) &lt; 5
out &lt;- rec_if(efc, predicate = p, rec = "1:3=1;4=2;else=copy")
head(out)
</code></pre>

<hr>
<h2 id='rec_pattern'>Create recode pattern for 'rec' function</h2><span id='topic+rec_pattern'></span>

<h3>Description</h3>

<p>Convenient function to create a recode pattern for the
<code><a href="#topic+rec">rec</a></code> function, which recodes (numeric)
vectors into smaller groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rec_pattern(from, to, width = 5, other = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rec_pattern_+3A_from">from</code></td>
<td>
<p>Minimum value that should be recoded.</p>
</td></tr>
<tr><td><code id="rec_pattern_+3A_to">to</code></td>
<td>
<p>Maximum value that should be recoded.</p>
</td></tr>
<tr><td><code id="rec_pattern_+3A_width">width</code></td>
<td>
<p>Numeric, indicating the range of each group.</p>
</td></tr>
<tr><td><code id="rec_pattern_+3A_other">other</code></td>
<td>
<p>String token, indicating how to deal with all other values
that have not been captured by the recode pattern. See 'Details'
on the <code>else</code>-token in <code><a href="#topic+rec">rec</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two values:
</p>

<dl>
<dt><code>pattern</code></dt><dd><p>string pattern that can be used as <code>rec</code> argument for the <code><a href="#topic+rec">rec</a></code>-function.</p>
</dd>
<dt><code>labels</code></dt><dd><p>the associated values labels that can be used with <code><a href="sjlabelled.html#topic+set_labels">set_labels</a></code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+group_var">group_var</a></code> for recoding variables into smaller groups, and
<code><a href="#topic+group_labels">group_labels</a></code> to create the asssociated value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rp &lt;- rec_pattern(1, 100)
rp

# sample data, inspect age of carers
data(efc)
table(efc$c160age, exclude = NULL)
table(rec(efc$c160age, rec = rp$pattern), exclude = NULL)

# recode carers age into groups of width 5
x &lt;- rec(
  efc$c160age,
  rec = rp$pattern,
  val.labels = rp$labels
)
# watch result
frq(x)

</code></pre>

<hr>
<h2 id='recode_to'>Recode variable categories into new values</h2><span id='topic+recode_to'></span><span id='topic+recode_to_if'></span>

<h3>Description</h3>

<p>Recodes (or &quot;renumbers&quot;) the categories of variables into new
category values, beginning with the lowest value specified by <code>lowest</code>.
Useful when recoding dummy variables with 1/2 values to 0/1 values,  or
recoding scales from 1-4 to 0-3 etc.
<code>recode_to_if()</code> is a scoped variant of <code>recode_to()</code>, where
recoding will be applied only to those variables that match the
logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_to(x, ..., lowest = 0, highest = -1, append = TRUE, suffix = "_r0")

recode_to_if(
  x,
  predicate,
  lowest = 0,
  highest = -1,
  append = TRUE,
  suffix = "_r0"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_to_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="recode_to_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="recode_to_+3A_lowest">lowest</code></td>
<td>
<p>Indicating the lowest category value for recoding. Default is 0, so the new
variable starts with value 0.</p>
</td></tr>
<tr><td><code id="recode_to_+3A_highest">highest</code></td>
<td>
<p>If specified and greater than <code>lowest</code>, all category values larger than
<code>highest</code> will be set to <code>NA</code>. Default is <code>-1</code>, i.e. this argument is ignored
and no NA's will be produced.</p>
</td></tr>
<tr><td><code id="recode_to_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="recode_to_+3A_suffix">suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="recode_to_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with recoded category values, where <code>lowest</code> indicates
the lowest value;  If <code>x</code> is a data frame, for <code>append = TRUE</code>,
<code>x</code> including the recoded variables as new columns is returned; if
<code>append = FALSE</code>, only the recoded variables will be returned. If
<code>append = TRUE</code> and <code>suffix = ""</code>, recoded variables will replace
(overwrite) existing variables.
</p>


<h3>Note</h3>

<p>Value and variable label attributes are preserved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rec">rec</a></code> for general recoding of variables and <code><a href="sjlabelled.html#topic+set_na">set_na</a></code>
for setting <code><a href="base.html#topic+NA">NA</a></code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># recode 1-4 to 0-3
dummy &lt;- sample(1:4, 10, replace = TRUE)
recode_to(dummy)

# recode 3-6 to 0-3
# note that numeric type is returned
dummy &lt;- as.factor(3:6)
recode_to(dummy)

# lowest value starting with 1
dummy &lt;- sample(11:15, 10, replace = TRUE)
recode_to(dummy, lowest = 1)

# lowest value starting with 1, highest with 3
# all others set to NA
dummy &lt;- sample(11:15, 10, replace = TRUE)
recode_to(dummy, lowest = 1, highest = 3)

# recode multiple variables at once
data(efc)
recode_to(efc, c82cop1, c83cop2, c84cop3, append = FALSE)

library(dplyr)
efc %&gt;%
  select(c82cop1, c83cop2, c84cop3) %&gt;%
  mutate(
    c82new = recode_to(c83cop2, lowest = 5),
    c83new = recode_to(c84cop3, lowest = 3)
  ) %&gt;%
  head()


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+print_md'></span><span id='topic+print_html'></span><span id='topic+to_character'></span><span id='topic+to_label'></span><span id='topic+to_numeric'></span><span id='topic+to_factor'></span><span id='topic++25+3E+25'></span><span id='topic+set_na'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>insight</dt><dd><p><code><a href="insight.html#topic+display">print_html</a></code>, <code><a href="insight.html#topic+display">print_md</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>sjlabelled</dt><dd><p><code><a href="sjlabelled.html#topic+set_na">set_na</a></code>, <code><a href="sjlabelled.html#topic+as_label">to_character</a></code>, <code><a href="sjlabelled.html#topic+as_factor">to_factor</a></code>, <code><a href="sjlabelled.html#topic+as_label">to_label</a></code>, <code><a href="sjlabelled.html#topic+as_numeric">to_numeric</a></code></p>
</dd>
</dl>

<hr>
<h2 id='ref_lvl'>Change reference level of (numeric) factors</h2><span id='topic+ref_lvl'></span>

<h3>Description</h3>

<p>Changes the reference level of (numeric) factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref_lvl(x, ..., lvl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref_lvl_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="ref_lvl_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="ref_lvl_+3A_lvl">lvl</code></td>
<td>
<p>Either numeric, indicating the new reference level, or a string,
indicating the value label from the new reference level. If <code>x</code> is a
factor with non-numeric factor levels, <code>relevel(x, ref = lvl)</code> is
returned. See 'Examples'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="stats.html#topic+relevel">relevel</a></code>, this function behaves differently
for factor with numeric factor levels or for labelled data, i.e. factors
with value labels for the values. <code>ref_lvl()</code> changes the reference
level by recoding the factor's values using the <code><a href="#topic+rec">rec</a></code> function.
Hence, all values from lowest up to the reference level indicated by
<code>lvl</code> are recoded, with <code>lvl</code> starting as lowest factor value.
For factors with non-numeric factor levels, the function simply returns
<code>relevel(x, ref = lvl)</code>. See 'Examples'.
</p>


<h3>Value</h3>

<p><code>x</code> with new reference level. If <code>x</code>
is a data frame, the complete data frame <code>x</code> will be returned,
where variables specified in <code>...</code> will be re-leveled;
if <code>...</code> is not specified, applies to all variables in the
data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+to_factor">to_factor</a></code> to convert numeric vectors into factors;
<code><a href="#topic+rec">rec</a></code> to recode variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
x &lt;- to_factor(efc$e42dep)
str(x)
frq(x)

# see column "val" in frq()-output, which indicates
# how values/labels were recoded after using ref_lvl()
x &lt;- ref_lvl(x, lvl = 3)
str(x)
frq(x)

library(dplyr)
dat &lt;- efc %&gt;%
  select(c82cop1, c83cop2, c84cop3) %&gt;%
  to_factor()

frq(dat)
ref_lvl(dat, c82cop1, c83cop2, lvl = 2) %&gt;% frq()

# compare numeric and string value for "lvl"-argument
x &lt;- to_factor(efc$e42dep)
frq(x)
ref_lvl(x, lvl = 2) %&gt;% frq()
ref_lvl(x, lvl = "slightly dependent") %&gt;% frq()

# factors with non-numeric factor levels
data(iris)
levels(iris$Species)
levels(ref_lvl(iris$Species, lvl = 3))
levels(ref_lvl(iris$Species, lvl = "versicolor"))
</code></pre>

<hr>
<h2 id='remove_var'>Remove variables from a data frame</h2><span id='topic+remove_var'></span><span id='topic+remove_cols'></span>

<h3>Description</h3>

<p>This function removes variables from a data frame, and is
intended to use within a pipe-workflow. <code>remove_cols()</code> is an
alias for <code>remove_var()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_var(x, ...)

remove_cols(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_var_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="remove_var_+3A_...">...</code></td>
<td>
<p>Character vector with variable names, or unquoted names
of variables that should be removed from the data frame.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, with variables specified in <code>...</code> removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% remove_var("disp", "cyl")
mtcars %&gt;% remove_var(c("wt", "vs"))
mtcars %&gt;% remove_var(drat:am)
</code></pre>

<hr>
<h2 id='replace_na'>Replace NA with specific values</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>This function replaces (tagged) NA's of a variable, data frame
or list of variables with <code>value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(x, ..., value, na.label = NULL, tagged.na = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_value">value</code></td>
<td>
<p>Value that will replace the <code><a href="base.html#topic+NA">NA</a></code>'s.</p>
</td></tr>
<tr><td><code id="replace_na_+3A_na.label">na.label</code></td>
<td>
<p>Optional character vector, used to label the the former NA-value
(i.e. adding a <code>labels</code> attribute for <code>value</code> to <code>x</code>).</p>
</td></tr>
<tr><td><code id="replace_na_+3A_tagged.na">tagged.na</code></td>
<td>
<p>Optional single character, specifies a <code><a href="haven.html#topic+tagged_na">tagged_na</a></code> value
that will be replaced by <code>value</code>. Herewith it is possible
to replace only specific <code>NA</code> values of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While regular <code>NA</code> values can only be <em>completely</em> replaced with
a single value, <code><a href="haven.html#topic+tagged_na">tagged_na</a></code> allows to differentiate
between different qualitative values of <code>NA</code>s.
Tagged <code>NA</code>s work exactly like regular R missing values
except that they store one additional byte of information: a tag,
which is usually a letter (&quot;a&quot; to &quot;z&quot;) or character number (&quot;0&quot; to &quot;9&quot;).
Therewith it is possible to replace only specific NA values, while
other NA values are preserved.
</p>


<h3>Value</h3>

<p><code>x</code>, where <code>NA</code>'s are replaced with <code>value</code>. If <code>x</code>
is a data frame, the complete data frame <code>x</code> will be returned,
with replaced NA's for variables specified in <code>...</code>;
if <code>...</code> is not specified, applies to all variables in the
data frame.
</p>


<h3>Note</h3>

<p>Value and variable label attributes are preserved.
</p>


<h3>See Also</h3>

<p><code><a href="sjlabelled.html#topic+set_na">set_na</a></code> for setting <code>NA</code> values, <code><a href="#topic+rec">rec</a></code>
for general recoding of variables and <code><a href="#topic+recode_to">recode_to</a></code>
for re-shifting value ranges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sjlabelled)
data(efc)
table(efc$e42dep, useNA = "always")
table(replace_na(efc$e42dep, value = 99), useNA = "always")

# the original labels
get_labels(replace_na(efc$e42dep, value = 99))
# NA becomes "99", and is labelled as "former NA"
get_labels(
  replace_na(efc$e42dep, value = 99, na.label = "former NA"),
  values = "p"
)

dummy &lt;- data.frame(
  v1 = efc$c82cop1,
  v2 = efc$c83cop2,
  v3 = efc$c84cop3
)
# show original distribution
lapply(dummy, table, useNA = "always")
# show variables, NA's replaced with 99
lapply(replace_na(dummy, v2, v3, value = 99), table, useNA = "always")

if (require("haven")) {
  x &lt;- labelled(c(1:3, tagged_na("a", "c", "z"), 4:1),
                c("Agreement" = 1, "Disagreement" = 4, "First" = tagged_na("c"),
                  "Refused" = tagged_na("a"), "Not home" = tagged_na("z")))
  # get current NA values
  x
  get_na(x)

  # replace only the NA, which is tagged as NA(c)
  replace_na(x, value = 2, tagged.na = "c")
  get_na(replace_na(x, value = 2, tagged.na = "c"))

  table(x)
  table(replace_na(x, value = 2, tagged.na = "c"))

  # tagged NA also works for non-labelled class
  # init vector
  x &lt;- c(1, 2, 3, 4)
  # set values 2 and 3 as tagged NA
  x &lt;- set_na(x, na = c(2, 3), as.tag = TRUE)
  # see result
  x
  # now replace only NA tagged with 2 with value 5
  replace_na(x, value = 5, tagged.na = "2")
}
</code></pre>

<hr>
<h2 id='reshape_longer'>Reshape data into long format</h2><span id='topic+reshape_longer'></span>

<h3>Description</h3>

<p><code>reshape_longer()</code> reshapes one or more columns from
wide into long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_longer(
  x,
  columns = colnames(x),
  names.to = "key",
  values.to = "value",
  labels = NULL,
  numeric.timevar = FALSE,
  id = ".id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_longer_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="reshape_longer_+3A_columns">columns</code></td>
<td>
<p>Names of variables (as character vector), or column index of
variables, that should be reshaped. If multiple column groups should be
reshaped, use a list of vectors (see 'Examples').</p>
</td></tr>
<tr><td><code id="reshape_longer_+3A_names.to">names.to</code></td>
<td>
<p>Character vector with name(s) of key column(s) to create in output.
Either one name per column group that should be gathered, or a single string.
In the latter case, this name will be used as key column, and only one key
column is created.</p>
</td></tr>
<tr><td><code id="reshape_longer_+3A_values.to">values.to</code></td>
<td>
<p>Character vector with names of value columns (variable names)
to create in output. Must be of same length as number of column
groups that should be gathered. See 'Examples'.</p>
</td></tr>
<tr><td><code id="reshape_longer_+3A_labels">labels</code></td>
<td>
<p>Character vector of same length as <code>values.to</code> with variable
labels for the new variables created from gathered columns.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="reshape_longer_+3A_numeric.timevar">numeric.timevar</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values of the <code>names.to</code>
column will be recoded to numeric values, in sequential ascending order.</p>
</td></tr>
<tr><td><code id="reshape_longer_+3A_id">id</code></td>
<td>
<p>Name of ID-variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reshaped data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+to_long">to_long</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reshape one column group into long format
mydat &lt;- data.frame(
  age = c(20, 30, 40),
  sex = c("Female", "Male", "Male"),
  score_t1 = c(30, 35, 32),
  score_t2 = c(33, 34, 37),
  score_t3 = c(36, 35, 38)
)

reshape_longer(
  mydat,
  columns = c("score_t1", "score_t2", "score_t3"),
  names.to = "time",
  values.to = "score"
)


# Reshape multiple column groups into long format
mydat &lt;- data.frame(
  age = c(20, 30, 40),
  sex = c("Female", "Male", "Male"),
  score_t1 = c(30, 35, 32),
  score_t2 = c(33, 34, 37),
  score_t3 = c(36, 35, 38),
  speed_t1 = c(2, 3, 1),
  speed_t2 = c(3, 4, 5),
  speed_t3 = c(1, 8, 6)
)

reshape_longer(
  mydat,
  columns = list(
    c("score_t1", "score_t2", "score_t3"),
    c("speed_t1", "speed_t2", "speed_t3")
  ),
  names.to = "time",
  values.to = c("score", "speed")
)

# or ...
reshape_longer(
  mydat,
  list(3:5, 6:8),
  names.to = "time",
  values.to = c("score", "speed")
)

# gather multiple columns, label columns
x &lt;- reshape_longer(
  mydat,
  list(3:5, 6:8),
  names.to = "time",
  values.to = c("score", "speed"),
  labels = c("Test Score", "Time needed to finish")
)

library(sjlabelled)
str(x$score)
get_label(x$speed)
</code></pre>

<hr>
<h2 id='rotate_df'>Rotate a data frame</h2><span id='topic+rotate_df'></span>

<h3>Description</h3>

<p>This function rotates a data frame, i.e. columns become rows
and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_df(x, rn = NULL, cn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_df_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="rotate_df_+3A_rn">rn</code></td>
<td>
<p>Character vector (optional). If not <code>NULL</code>, the data frame's
rownames will be added as (first) column to the output, with
<code>rn</code> being the name of this column.</p>
</td></tr>
<tr><td><code id="rotate_df_+3A_cn">cn</code></td>
<td>
<p>Logical (optional), if <code>TRUE</code>, the values of the first column
in <code>x</code> will be used as column names in the rotated data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (rotated) data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- mtcars[1:3, 1:4]
rotate_df(x)
rotate_df(x, rn = "property")

# use values in 1. column as column name
rotate_df(x, cn = TRUE)
rotate_df(x, rn = "property", cn = TRUE)

# also works on list-results
library(purrr)

dat &lt;- mtcars[1:3, 1:4]
tmp &lt;- purrr::map(dat, function(x) {
  sdev &lt;- stats::sd(x, na.rm = TRUE)
  ulsdev &lt;- mean(x, na.rm = TRUE) + c(-sdev, sdev)
  names(ulsdev) &lt;- c("lower_sd", "upper_sd")
  ulsdev
})
tmp
as.data.frame(tmp)
rotate_df(tmp)

tmp &lt;- purrr::map_df(dat, function(x) {
  sdev &lt;- stats::sd(x, na.rm = TRUE)
  ulsdev &lt;- mean(x, na.rm = TRUE) + c(-sdev, sdev)
  names(ulsdev) &lt;- c("lower_sd", "upper_sd")
  ulsdev
})
tmp
rotate_df(tmp)
</code></pre>

<hr>
<h2 id='round_num'>Round numeric variables in a data frame</h2><span id='topic+round_num'></span>

<h3>Description</h3>

<p><code>round_num()</code> rounds numeric variables in a data frame
that also contains non-numeric variables. Non-numeric variables are
ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_num(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_num_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="round_num_+3A_digits">digits</code></td>
<td>
<p>Numeric, number of decimals to round to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with all numeric variables rounded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
round_num(iris)

</code></pre>

<hr>
<h2 id='row_count'>Count row or column indices</h2><span id='topic+row_count'></span><span id='topic+col_count'></span>

<h3>Description</h3>

<p><code>row_count()</code> mimics base R's <code>rowSums()</code>, with sums
for a specific value indicated by <code>count</code>. Hence, it is equivalent
to <code>rowSums(x == count, na.rm = TRUE)</code>. However, this function
is designed to work nicely within a pipe-workflow and allows select-helpers
for selecting variables and the return value is always a data frame
(with one variable).
<br /> <br />
<code>col_count()</code> does the same for columns. The return value is
a data frame with one row (the column counts) and the same number
of columns as <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_count(x, ..., count, var = "rowcount", append = TRUE)

col_count(x, ..., count, var = "colcount", append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_count_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="row_count_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="row_count_+3A_count">count</code></td>
<td>
<p>The value for which the row or column sum should be computed. May
be a numeric value, a character string (for factors or character vectors),
<code>NA</code>, <code>Inf</code> or <code>NULL</code> to count missing or infinite values,
or null-values.</p>
</td></tr>
<tr><td><code id="row_count_+3A_var">var</code></td>
<td>
<p>Name of new the variable with the row or column counts.</p>
</td></tr>
<tr><td><code id="row_count_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>row_count()</code>, a data frame with one variable: the sum of <code>count</code>
appearing in each row of <code>x</code>; for <code>col_count()</code>, a data frame with
one row and the same number of variables as in <code>x</code>: each variable
holds the sum of <code>count</code> appearing in each variable of <code>x</code>.
If <code>append = TRUE</code>, <code>x</code> including this variable will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
  c1 = c(1, 2, 3, 1, 3, NA),
  c2 = c(3, 2, 1, 2, NA, 3),
  c3 = c(1, 1, 2, 1, 3, NA),
  c4 = c(1, 1, 3, 2, 1, 2)
)

row_count(dat, count = 1, append = FALSE)
row_count(dat, count = NA, append = FALSE)
row_count(dat, c1:c3, count = 2, append = TRUE)

col_count(dat, count = 1, append = FALSE)
col_count(dat, count = NA, append = FALSE)
col_count(dat, c1:c3, count = 2, append = TRUE)

</code></pre>

<hr>
<h2 id='row_sums'>Row sums and means for data frames</h2><span id='topic+row_sums'></span><span id='topic+row_sums.default'></span><span id='topic+row_sums.mids'></span><span id='topic+row_means'></span><span id='topic+total_mean'></span><span id='topic+row_means.default'></span><span id='topic+row_means.mids'></span>

<h3>Description</h3>

<p><code>row_sums()</code> and <code>row_means()</code> compute row sums or means
for at least <code>n</code> valid values per row. The functions are designed
to work nicely within a pipe-workflow and allow select-helpers
for selecting variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_sums(x, ...)

## Default S3 method:
row_sums(x, ..., n, var = "rowsums", append = TRUE)

## S3 method for class 'mids'
row_sums(x, ..., var = "rowsums", append = TRUE)

row_means(x, ...)

total_mean(x, ...)

## Default S3 method:
row_means(x, ..., n, var = "rowmeans", append = TRUE)

## S3 method for class 'mids'
row_means(x, ..., var = "rowmeans", append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_sums_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="row_sums_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="row_sums_+3A_n">n</code></td>
<td>
<p>May either be
</p>

<ul>
<li><p> a numeric value that indicates the amount of valid values per row to calculate the row mean or sum;
</p>
</li>
<li><p> a value between 0 and 1, indicating a proportion of valid values per row to calculate the row mean or sum (see 'Details').
</p>
</li>
<li><p> or <code>Inf</code>. If <code>n = Inf</code>, all values per row must be non-missing to compute row mean or sum.
</p>
</li></ul>

<p>If a row's sum of valid (i.e. non-<code>NA</code>) values is less than <code>n</code>, <code>NA</code> will be returned as value for the row mean or sum.</p>
</td></tr>
<tr><td><code id="row_sums_+3A_var">var</code></td>
<td>
<p>Name of new the variable with the row sums or means.</p>
</td></tr>
<tr><td><code id="row_sums_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>n</code>, must be a numeric value from <code>0</code> to <code>ncol(x)</code>. If
a <em>row</em> in <code>x</code> has at least <code>n</code> non-missing values, the
row mean or sum is returned. If <code>n</code> is a non-integer value from 0 to 1,
<code>n</code> is considered to indicate the proportion of necessary non-missing
values per row. E.g., if <code>n = .75</code>, a row must have at least <code>ncol(x) * n</code>
non-missing values for the row mean or sum to be calculated. See 'Examples'.
</p>


<h3>Value</h3>

<p>For <code>row_sums()</code>, a data frame with a new variable: the row sums from
<code>x</code>; for <code>row_means()</code>, a data frame with a new variable: the row
means from <code>x</code>. If <code>append = FALSE</code>, only the new variable
with row sums resp. row means is returned. <code>total_mean()</code> returns
the mean of all values from all specified columns in a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
efc %&gt;% row_sums(c82cop1:c90cop9, n = 3, append = FALSE)

library(dplyr)
row_sums(efc, contains("cop"), n = 2, append = FALSE)

dat &lt;- data.frame(
  c1 = c(1,2,NA,4),
  c2 = c(NA,2,NA,5),
  c3 = c(NA,4,NA,NA),
  c4 = c(2,3,7,8),
  c5 = c(1,7,5,3)
)
dat

row_means(dat, n = 4)
row_sums(dat, n = 4)

row_means(dat, c1:c4, n = 4)
# at least 40% non-missing
row_means(dat, c1:c4, n = .4)
row_sums(dat, c1:c4, n = .4)

# total mean of all values in the data frame
total_mean(dat)

# create sum-score of COPE-Index, and append to data
efc %&gt;%
  select(c82cop1:c90cop9) %&gt;%
  row_sums(n = 1)

# if data frame has only one column, this column is returned
row_sums(dat[, 1, drop = FALSE], n = 0)

</code></pre>

<hr>
<h2 id='seq_col'>Sequence generation for column or row counts of data frames</h2><span id='topic+seq_col'></span><span id='topic+seq_row'></span>

<h3>Description</h3>

<p><code>seq_col(x)</code> is a convenient wrapper for <code>seq_len(ncol(x))</code>,
while <code>seq_row(x)</code> is a convenient wrapper for <code>seq_len(nrow(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_col(x)

seq_row(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_col_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric sequence from 1 to number of columns or rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
seq_col(iris)
seq_row(iris)

</code></pre>

<hr>
<h2 id='set_na_if'>Replace specific values in vector with NA</h2><span id='topic+set_na_if'></span>

<h3>Description</h3>

<p><code>set_na_if()</code> is a scoped variant of
<code><a href="sjlabelled.html#topic+set_na">set_na</a></code>, where values will be replaced only
with NA's for those variables that match the logical condition of
<code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_na_if(x, predicate, na, drop.levels = TRUE, as.tag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_na_if_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="set_na_if_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
<tr><td><code id="set_na_if_+3A_na">na</code></td>
<td>
<p>Numeric vector with values that should be replaced with NA values,
or a character vector if values of factors or character vectors should be
replaced. For labelled vectors, may also be the name of a value label. In
this case, the associated values for the value labels in each vector
will be replaced with <code>NA</code>. <code>na</code> can also be a named vector.
If <code>as.tag = FALSE</code>, values will be replaced only in those variables
that are indicated by the value names (see 'Examples').</p>
</td></tr>
<tr><td><code id="set_na_if_+3A_drop.levels">drop.levels</code></td>
<td>
<p>Logical, if <code>TRUE</code>, factor levels of values that have
been replaced with <code>NA</code> are dropped. See 'Examples'.</p>
</td></tr>
<tr><td><code id="set_na_if_+3A_as.tag">as.tag</code></td>
<td>
<p>Logical, if <code>TRUE</code>, values in <code>x</code> will be replaced
by <code>tagged_na</code>, else by usual <code>NA</code> values. Use a named
vector to assign the value label to the tagged NA value (see 'Examples').</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, with all values in <code>na</code> being replaced by <code>NA</code>.
If <code>x</code> is a data frame, the complete data frame <code>x</code> will
be returned, with NA's set for variables specified in <code>...</code>;
if <code>...</code> is not specified, applies to all variables in the
data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+replace_na">replace_na</a></code> to replace <code><a href="base.html#topic+NA">NA</a></code>'s with specific
values, <code><a href="#topic+rec">rec</a></code> for general recoding of variables and
<code><a href="#topic+recode_to">recode_to</a></code> for re-shifting value ranges. See
<code><a href="sjlabelled.html#topic+get_na">get_na</a></code> to get values of missing values in
labelled vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dummy &lt;- data.frame(var1 = sample(1:8, 100, replace = TRUE),
                    var2 = sample(1:10, 100, replace = TRUE),
                    var3 = sample(1:6, 100, replace = TRUE))

p &lt;- function(x) max(x, na.rm = TRUE) &gt; 7
tmp &lt;- set_na_if(dummy, predicate = p, na = 8:9)
head(tmp)
</code></pre>

<hr>
<h2 id='shorten_string'>Shorten character strings</h2><span id='topic+shorten_string'></span>

<h3>Description</h3>

<p>This function shortens strings that are longer than <code>max.length</code>
chars, without cropping words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shorten_string(s, max.length = NULL, abbr = "...")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shorten_string_+3A_s">s</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="shorten_string_+3A_max.length">max.length</code></td>
<td>
<p>Maximum length of chars for the string.</p>
</td></tr>
<tr><td><code id="shorten_string_+3A_abbr">abbr</code></td>
<td>
<p>String that will be used as suffix, if <code>s</code> was shortened.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the string length defined in <code>max.length</code> happens to be inside
a word, this word is removed from the returned string (see 'Examples'), so
the returned string has a <em>maximum length</em> of <code>max.length</code>, but
might be shorter.
</p>


<h3>Value</h3>

<p>A shortened string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- "This can be considered as very long string!"

# string is shorter than max.length, so returned as is
shorten_string(s, 60)

# string is shortened to as many words that result in
# a string of maximum 20 chars
shorten_string(s, 20)

# string including "considered" is exactly of length 22 chars
shorten_string(s, 22)

</code></pre>

<hr>
<h2 id='split_var'>Split numeric variables into smaller groups</h2><span id='topic+split_var'></span><span id='topic+split_var_if'></span>

<h3>Description</h3>

<p>Recode numeric variables into equal sized groups, i.e. a
variable is cut into a smaller number of groups at specific cut points.
<code>split_var_if()</code> is a scoped variant of <code>split_var()</code>, where
transformation will be applied only to those variables that match the
logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_var(
  x,
  ...,
  n,
  as.num = FALSE,
  val.labels = NULL,
  var.label = NULL,
  inclusive = FALSE,
  append = TRUE,
  suffix = "_g"
)

split_var_if(
  x,
  predicate,
  n,
  as.num = FALSE,
  val.labels = NULL,
  var.label = NULL,
  inclusive = FALSE,
  append = TRUE,
  suffix = "_g"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_var_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="split_var_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="split_var_+3A_n">n</code></td>
<td>
<p>The new number of groups that <code>x</code> should be split into.</p>
</td></tr>
<tr><td><code id="split_var_+3A_as.num">as.num</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return value will be numeric, not a factor.</p>
</td></tr>
<tr><td><code id="split_var_+3A_val.labels">val.labels</code></td>
<td>
<p>Optional character vector, to set value label attributes
of recoded variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), no value labels will be set. Value labels
can also be directly defined in the <code>rec</code>-syntax, see
'Details'.</p>
</td></tr>
<tr><td><code id="split_var_+3A_var.label">var.label</code></td>
<td>
<p>Optional string, to set variable label attribute for the
returned variable (see vignette <a href="https://cran.r-project.org/package=sjlabelled/vignettes/intro_sjlabelled.html">Labelled Data and the sjlabelled-Package</a>).
If <code>NULL</code> (default), variable label attribute of <code>x</code> will
be used (if present). If empty, variable label attributes will be removed.</p>
</td></tr>
<tr><td><code id="split_var_+3A_inclusive">inclusive</code></td>
<td>
<p>Logical; if <code>TRUE</code>, cut point value are included in
the preceding group. This may be necessary if cutting a vector into
groups does not define proper (&quot;equal sized&quot;) group sizes.
See 'Note' and 'Examples'.</p>
</td></tr>
<tr><td><code id="split_var_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="split_var_+3A_suffix">suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="split_var_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>split_var()</code> splits a variable into equal sized groups, where
the amount of groups depends on the <code>n</code>-argument. Thus, this
functions <code><a href="base.html#topic+cut">cut</a>s</code> a variable into groups at the specified
<code><a href="stats.html#topic+quantile">quantile</a>s</code>.
<br /> <br />
By contrast, <code><a href="#topic+group_var">group_var</a></code> recodes a variable into groups, where
groups have the same value range (e.g., from 1-5, 6-10, 11-15 etc.).
<br /> <br />
<code>split_var()</code> also works on grouped data frames
(see <code><a href="dplyr.html#topic+group_by">group_by</a></code>). In this case, splitting is applied to
the subsets of variables in <code>x</code>. See 'Examples'.
</p>


<h3>Value</h3>

<p>A grouped variable with equal sized groups. If <code>x</code> is a data frame,
for <code>append = TRUE</code>, <code>x</code> including the grouped variables as new
columns is returned; if <code>append = FALSE</code>, only the grouped variables
will be returned. If <code>append = TRUE</code> and <code>suffix = ""</code>,
recoded variables will replace (overwrite) existing variables.
</p>


<h3>Note</h3>

<p>In case a vector has only few number of unique values, splitting into
equal sized groups may fail. In this case, use the <code>inclusive</code>-argument
to shift a value at the cut point into the lower, preceeding group to
get equal sized groups. See 'Examples'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_var">group_var</a></code> to group variables into equal ranged groups,
or <code><a href="#topic+rec">rec</a></code> to recode variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
# non-grouped
table(efc$neg_c_7)

# split into 3 groups
table(split_var(efc$neg_c_7, n = 3))

# split multiple variables into 3 groups
split_var(efc, neg_c_7, pos_v_4, e17age, n = 3, append = FALSE)
frq(split_var(efc, neg_c_7, pos_v_4, e17age, n = 3, append = FALSE))

# original
table(efc$e42dep)

# two groups, non-inclusive cut-point
# vector split leads to unequal group sizes
table(split_var(efc$e42dep, n = 2))

# two groups, inclusive cut-point
# group sizes are equal
table(split_var(efc$e42dep, n = 2, inclusive = TRUE))

# Unlike dplyr's ntile(), split_var() never splits a value
# into two different categories, i.e. you always get a clean
# separation of original categories
library(dplyr)

x &lt;- dplyr::ntile(efc$neg_c_7, n = 3)
table(efc$neg_c_7, x)

x &lt;- split_var(efc$neg_c_7, n = 3)
table(efc$neg_c_7, x)

# works also with gouped data frames
mtcars %&gt;%
  split_var(disp, n = 3, append = FALSE) %&gt;%
  table()

mtcars %&gt;%
  group_by(cyl) %&gt;%
  split_var(disp, n = 3, append = FALSE) %&gt;%
  table()
</code></pre>

<hr>
<h2 id='spread_coef'>Spread model coefficients of list-variables into columns</h2><span id='topic+spread_coef'></span>

<h3>Description</h3>

<p>This function extracts coefficients (and standard error and
p-values) of fitted model objects from (nested) data frames,
which are saved in a list-variable, and spreads the coefficients
into new colummns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_coef(data, model.column, model.term, se, p.val, append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_coef_+3A_data">data</code></td>
<td>
<p>A (nested) data frame with a list-variable that contains fitted
model objects (see 'Details').</p>
</td></tr>
<tr><td><code id="spread_coef_+3A_model.column">model.column</code></td>
<td>
<p>Name or index of the list-variable that contains the
fitted model objects.</p>
</td></tr>
<tr><td><code id="spread_coef_+3A_model.term">model.term</code></td>
<td>
<p>Optional, name of a model term. If specified, only this model
term (including p-value) will be extracted from each model and
added as new column.</p>
</td></tr>
<tr><td><code id="spread_coef_+3A_se">se</code></td>
<td>
<p>Logical, if <code>TRUE</code>, standard errors for estimates will also be extracted.</p>
</td></tr>
<tr><td><code id="spread_coef_+3A_p.val">p.val</code></td>
<td>
<p>Logical, if <code>TRUE</code>, p-values for estimates will also be extracted.</p>
</td></tr>
<tr><td><code id="spread_coef_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), this function returns
<code>data</code> with new columns for the model coefficients; else,
a new data frame with model coefficients only are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a (nested) data frame (e.g. created by the
<code><a href="tidyr.html#topic+nest">nest</a></code>-function of the <span class="pkg">tidyr</span>-package),
where several fitted models are saved in a list-variable (see
'Examples'). Since nested data frames with fitted models stored as list-variable
are typically fit with an identical formula, all models have the same
dependent and independent variables and only differ in their
subsets of data. The function then extracts all coefficients from
each model and saves each estimate in a new column. The result
is a data frame, where each <em>row</em> is a model with each
model's coefficients in an own <em>column</em>.
</p>


<h3>Value</h3>

<p>A data frame with columns for each coefficient of the models
that are stored in the list-variable of <code>data</code>; or, if
<code>model.term</code> is given, a data frame with the term's estimate.
If <code>se = TRUE</code> or <code>p.val = TRUE</code>, the returned data frame
also contains columns for the coefficients' standard error and
p-value.
If <code>append = TRUE</code>, the columns are appended to <code>data</code>,
i.e. <code>data</code> is also returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("dplyr") &amp;&amp; require("tidyr") &amp;&amp; require("purrr")) {
  data(efc)

  # create nested data frame, grouped by dependency (e42dep)
  # and fit linear model for each group. These models are
  # stored in the list variable "models".
  model.data &lt;- efc %&gt;%
    filter(!is.na(e42dep)) %&gt;%
    group_by(e42dep) %&gt;%
    nest() %&gt;%
    mutate(
      models = map(data, ~lm(neg_c_7 ~ c12hour + c172code, data = .x))
    )

  # spread coefficients, so we can easily access and compare the
  # coefficients over all models. arguments `se` and `p.val` default
  # to `FALSE`, when `model.term` is not specified
  spread_coef(model.data, models)
  spread_coef(model.data, models, se = TRUE)

  # select only specific model term. `se` and `p.val` default to `TRUE`
  spread_coef(model.data, models, c12hour)

  # spread_coef can be used directly within a pipe-chain
  efc %&gt;%
    filter(!is.na(e42dep)) %&gt;%
    group_by(e42dep) %&gt;%
    nest() %&gt;%
    mutate(
      models = map(data, ~lm(neg_c_7 ~ c12hour + c172code, data = .x))
    ) %&gt;%
    spread_coef(models)
}
</code></pre>

<hr>
<h2 id='std'>Standardize and center variables</h2><span id='topic+std'></span><span id='topic+std_if'></span><span id='topic+center'></span><span id='topic+center_if'></span>

<h3>Description</h3>

<p><code>std()</code> computes a z-transformation (standardized and centered)
on the input. <code>center()</code> centers the input. <code>std_if()</code> and
<code>center_if()</code> are scoped variants of <code>std()</code> and <code>center()</code>,
where transformation will be applied only to those variables that match the
logical condition of <code>predicate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std(
  x,
  ...,
  robust = c("sd", "2sd", "gmd", "mad"),
  include.fac = FALSE,
  append = TRUE,
  suffix = "_z"
)

std_if(
  x,
  predicate,
  robust = c("sd", "2sd", "gmd", "mad"),
  include.fac = FALSE,
  append = TRUE,
  suffix = "_z"
)

center(x, ..., include.fac = FALSE, append = TRUE, suffix = "_c")

center_if(x, predicate, include.fac = FALSE, append = TRUE, suffix = "_c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="std_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="std_+3A_robust">robust</code></td>
<td>
<p>Character vector, indicating the method applied when
standardizing variables with <code>std()</code>. By default, standardization is
achieved by dividing the centered variables by their standard deviation
(<code>robust = "sd"</code>). However, for skewed distributions, the median
absolute deviation (MAD, <code>robust = "mad"</code>) or Gini's mean difference
(<code>robust = "gmd"</code>) might be more robust measures of dispersion. For
the latter option, <a href="https://CRAN.R-project.org/package=sjstats"><span class="pkg">sjstats</span></a> needs to be installed.
<code>robust = "2sd"</code> divides the centered variables by two standard
deviations, following a suggestion by <em>Gelman (2008)</em>, so the
rescaled input is comparable to binary variables.</p>
</td></tr>
<tr><td><code id="std_+3A_include.fac">include.fac</code></td>
<td>
<p>Logical, if <code>TRUE</code>, factors will be converted to numeric
vectors and also standardized or centered.</p>
</td></tr>
<tr><td><code id="std_+3A_append">append</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) and <code>x</code> is a data frame,
<code>x</code> including the new variables as additional columns is returned;
if <code>FALSE</code>, only the new variables are returned.</p>
</td></tr>
<tr><td><code id="std_+3A_suffix">suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td></tr>
<tr><td><code id="std_+3A_predicate">predicate</code></td>
<td>
<p>A predicate function to be applied to the columns. The
variables for which <code>predicate</code> returns <code>TRUE</code> are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>std()</code> and <code>center()</code> also work on grouped data frames
(see <code><a href="dplyr.html#topic+group_by">group_by</a></code>). In this case, standardization
or centering is applied to the subsets of variables in <code>x</code>.
See 'Examples'.
<br /> <br />
For more complicated models with many predictors, Gelman and Hill (2007)
suggest leaving binary inputs as is and only standardize continuous predictors
by dividing by two standard deviations. This ensures a rough comparability
in the coefficients.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a vector, returns a vector with standardized or
centered variables. If <code>x</code> is a data frame, for <code>append = TRUE</code>,
<code>x</code> including the transformed variables as new columns is returned;
if <code>append = FALSE</code>, only the transformed variables will be returned.
If <code>append = TRUE</code> and <code>suffix = ""</code>, recoded variables will
replace (overwrite) existing variables.
</p>


<h3>Note</h3>

<p><code>std()</code> and <code>center()</code> only return a vector, if <code>x</code> is
a vector. If <code>x</code> is a data frame and only one variable is specified
in the <code>...</code>-ellipses argument, both functions do return a
data frame (see 'Examples').
</p>


<h3>References</h3>

<p>Gelman A (2008) Scaling regression inputs by dividing by two
standard deviations. <em>Statistics in Medicine 27: 2865-2873.</em>
<a href="http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf">http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf</a>
<br /> <br />
Gelman A, Hill J (2007) Data Analysis Using Regression and Multilevel/Hierarchical
Models. Cambdridge, Cambdrige University Press: 55-57
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
std(efc$c160age) %&gt;% head()
std(efc, e17age, c160age, append = FALSE) %&gt;% head()

center(efc$c160age) %&gt;% head()
center(efc, e17age, c160age, append = FALSE) %&gt;% head()

# NOTE!
std(efc$e17age) # returns a vector
std(efc, e17age) # returns a data frame

# with quasi-quotation
x &lt;- "e17age"
center(efc, !!x, append = FALSE) %&gt;% head()

# works with mutate()
library(dplyr)
efc %&gt;%
  select(e17age, neg_c_7) %&gt;%
  mutate(age_std = std(e17age), burden = center(neg_c_7)) %&gt;%
  head()

# works also with grouped data frames
mtcars %&gt;% std(disp)

# compare new column "disp_z" w/ output above
mtcars %&gt;%
  group_by(cyl) %&gt;%
  std(disp)

data(iris)
# also standardize factors
std(iris, include.fac = TRUE, append = FALSE)
# don't standardize factors
std(iris, include.fac = FALSE, append = FALSE)

# standardize only variables with more than 10 unique values
p &lt;- function(x) dplyr::n_distinct(x) &gt; 10
std_if(efc, predicate = p, append = FALSE)

</code></pre>

<hr>
<h2 id='str_contains'>Check if string contains pattern</h2><span id='topic+str_contains'></span>

<h3>Description</h3>

<p>This functions checks whether a string or character vector
<code>x</code> contains the string <code>pattern</code>. By default,
this function is case sensitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_contains(x, pattern, ignore.case = FALSE, logic = NULL, switch = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_contains_+3A_x">x</code></td>
<td>
<p>Character string where matches are sought. May also be a
character vector of length &gt; 1 (see 'Examples').</p>
</td></tr>
<tr><td><code id="str_contains_+3A_pattern">pattern</code></td>
<td>
<p>Character string to be matched in <code>x</code>. May also be a
character vector of length &gt; 1 (see 'Examples').</p>
</td></tr>
<tr><td><code id="str_contains_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical, whether matching should be case sensitive or not.</p>
</td></tr>
<tr><td><code id="str_contains_+3A_logic">logic</code></td>
<td>
<p>Indicates whether a logical combination of multiple search pattern
should be made.
</p>

<ul>
<li><p> Use <code>"or"</code>, <code>"OR"</code> or <code>"|"</code> for a logical or-combination, i.e. at least one element of <code>pattern</code> is in <code>x</code>.
</p>
</li>
<li><p> Use <code>"and"</code>, <code>"AND"</code> or <code>"&amp;"</code> for a logical AND-combination, i.e. all elements of <code>pattern</code> are in <code>x</code>.
</p>
</li>
<li><p> Use <code>"not"</code>, <code>"NOT"</code> or <code>"!"</code> for a logical NOT-combination, i.e. no element of <code>pattern</code> is in <code>x</code>.
</p>
</li>
<li><p> By default, <code>logic = NULL</code>, which means that <code>TRUE</code> or <code>FALSE</code> is returned for each element of <code>pattern</code> separately.
</p>
</li></ul>
</td></tr>
<tr><td><code id="str_contains_+3A_switch">switch</code></td>
<td>
<p>Logical, if <code>TRUE</code>, <code>x</code> will be sought in each element
of <code>pattern</code>. If <code>switch = TRUE</code>, <code>x</code> needs to be of
length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function iterates all elements in <code>pattern</code> and
looks for each of these elements if it is found in
<em>any</em> element of <code>x</code>, i.e. which elements
of <code>pattern</code> are found in the vector <code>x</code>.
<br /> <br />
Technically, it iterates <code>pattern</code> and calls
<code>grep(x, pattern[i], fixed = TRUE)</code> for each element
of <code>pattern</code>. If <code>switch = TRUE</code>, it iterates
<code>pattern</code> and calls <code>grep(pattern[i], x, fixed = TRUE)</code>
for each element of <code>pattern</code>. Hence, in the latter case
(if <code>switch = TRUE</code>), <code>x</code> must be of length 1.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> contains <code>pattern</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_contains("hello", "hel")
str_contains("hello", "hal")

str_contains("hello", "Hel")
str_contains("hello", "Hel", ignore.case = TRUE)

# which patterns are in "abc"?
str_contains("abc", c("a", "b", "e"))

# is pattern in any element of 'x'?
str_contains(c("def", "abc", "xyz"), "abc")
# is "abcde" in any element of 'x'?
str_contains(c("def", "abc", "xyz"), "abcde") # no...
# is "abc" in any of pattern?
str_contains("abc", c("defg", "abcde", "xyz12"), switch = TRUE)

str_contains(c("def", "abcde", "xyz"), c("abc", "123"))

# any pattern in "abc"?
str_contains("abc", c("a", "b", "e"), logic = "or")

# all patterns in "abc"?
str_contains("abc", c("a", "b", "e"), logic = "and")
str_contains("abc", c("a", "b"), logic = "and")

# no patterns in "abc"?
str_contains("abc", c("a", "b", "e"), logic = "not")
str_contains("abc", c("d", "e", "f"), logic = "not")
</code></pre>

<hr>
<h2 id='str_find'>Find partial matching and close distance elements in strings</h2><span id='topic+str_find'></span>

<h3>Description</h3>

<p>This function finds the element indices of partial matching or
similar strings in a character vector. Can be used to find exact or
slightly mistyped elements in a string vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_find(string, pattern, precision = 2, partial = 0, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_find_+3A_string">string</code></td>
<td>
<p>Character vector with string elements.</p>
</td></tr>
<tr><td><code id="str_find_+3A_pattern">pattern</code></td>
<td>
<p>String that should be matched against the elements of <code>string</code>.</p>
</td></tr>
<tr><td><code id="str_find_+3A_precision">precision</code></td>
<td>
<p>Maximum distance (&quot;precision&quot;) between two string elements,
which is allowed to treat them as similar or equal. Smaller values mean
less tolerance in matching.</p>
</td></tr>
<tr><td><code id="str_find_+3A_partial">partial</code></td>
<td>
<p>Activates similar matching (close distance strings) for parts (substrings)
of the <code>string</code>. Following values are accepted:
</p>

<ul>
<li><p> 0 for no partial distance matching
</p>
</li>
<li><p> 1 for one-step matching, which means, only substrings of same length as <code>pattern</code> are extracted from <code>string</code> matching
</p>
</li>
<li><p> 2 for two-step matching, which means, substrings of same length as <code>pattern</code> as well as strings with a slightly wider range are extracted from <code>string</code> matching
</p>
</li></ul>

<p>Default value is 0. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="str_find_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the progress bar is displayed when computing the distance matrix.
Default in <code>FALSE</code>, hence the bar is hidden.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Computation Details</strong>
<br /> <br />
Fuzzy string matching is based on regular expressions, in particular
<code>grep(pattern = "(&lt;pattern&gt;){~&lt;precision&gt;}", x = string)</code>. This
means, <code>precision</code> indicates the number of chars inside <code>pattern</code>
that may differ in <code>string</code> to cosinder it as &quot;matching&quot;. The higher
<code>precision</code> is, the more tolerant is the search (i.e. yielding more
possible matches). Furthermore, the higher the value for <code>partial</code>
is, the more matches may be found.
<br /> <br />
<strong>Partial Distance Matching</strong>
<br /> <br />
For <code>partial = 1</code>, a substring of <code>length(pattern)</code> is extracted
from <code>string</code>, starting at position 0 in <code>string</code> until
the end of <code>string</code> is reached. Each substring is matched against
<code>pattern</code>, and results with a maximum distance of <code>precision</code>
are considered as &quot;matching&quot;. If <code>partial = 2</code>, the range
of the extracted substring is increased by 2, i.e. the extracted substring
is two chars longer and so on.
</p>


<h3>Value</h3>

<p>A numeric vector with index position of elements in <code>string</code> that
partially match or are similar to <code>pattern</code>. Returns <code>-1</code> if no
match was found.
</p>


<h3>Note</h3>

<p>This function does <em>not</em> return the position of a matching string <em>inside</em>
another string, but the element's index of the <code>string</code> vector, where
a (partial) match with <code>pattern</code> was found. Thus, searching for &quot;abc&quot; in
a string &quot;this is abc&quot; will not return 9 (the start position of the substring),
but 1 (the element index, which is always 1 if <code>string</code> only has one element).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_str">group_str</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c("Hello", "Helo", "Hole", "Apple", "Ape", "New", "Old", "System", "Systemic")
str_find(string, "hel")   # partial match
str_find(string, "stem")  # partial match
str_find(string, "R")     # no match
str_find(string, "saste") # similarity to "System"

# finds two indices, because partial matching now
# also applies to "Systemic"
str_find(string,
        "sytsme",
        partial = 1)

# finds partial matching of similarity
str_find("We are Sex Pistols!", "postils")
</code></pre>

<hr>
<h2 id='str_start'>Find start and end index of pattern in string</h2><span id='topic+str_start'></span><span id='topic+str_end'></span>

<h3>Description</h3>

<p><code>str_start()</code> finds the beginning position of <code>pattern</code>
in each element of <code>x</code>, while <code>str_end()</code> finds the stopping position
of <code>pattern</code> in each element of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_start(x, pattern, ignore.case = TRUE, regex = FALSE)

str_end(x, pattern, ignore.case = TRUE, regex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_start_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_start_+3A_pattern">pattern</code></td>
<td>
<p>Character string to be matched in <code>x</code>. <code>pattern</code> might also
be a regular-expression object, as returned by <code>stringr::regex()</code>.
Alternatively, use <code>regex = TRUE</code> to treat <code>pattern</code> as a regular
expression rather than a fixed string.</p>
</td></tr>
<tr><td><code id="str_start_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical, whether matching should be case sensitive or not.
<code>ignore.case</code> is ignored when <code>pattern</code> is no regular expression or
<code>regex = FALSE</code>.</p>
</td></tr>
<tr><td><code id="str_start_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, <code>pattern</code> is treated as a regular
expression rather than a fixed string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with index of start/end position(s) of <code>pattern</code>
found in <code>x</code>, or <code>-1</code>, if <code>pattern</code> was not found
in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- "this/is/my/fileofinterest.csv"
str_start(path, "/")

path &lt;- "this//is//my//fileofinterest.csv"
str_start(path, "//")
str_end(path, "//")

x &lt;- c("my_friend_likes me", "your_friend likes_you")
str_start(x, "_")

# pattern "likes" starts at position 11 in first, and
# position 13 in second string
str_start(x, "likes")

# pattern "likes" ends at position 15 in first, and
# position 17 in second string
str_end(x, "likes")

x &lt;- c("I like to move it, move it", "You like to move it")
str_start(x, "move")
str_end(x, "move")

x &lt;- c("test1234testagain")
str_start(x, "\\d+4")
str_start(x, "\\d+4", regex = TRUE)
str_end(x, "\\d+4", regex = TRUE)
</code></pre>

<hr>
<h2 id='tidy_values'>Clean values of character vectors.</h2><span id='topic+tidy_values'></span><span id='topic+clean_values'></span>

<h3>Description</h3>

<p>This function &quot;cleans&quot; values of a character vector or levels of
a factor by removing space and punctuation characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_values(x, ...)

clean_values(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_values_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="tidy_values_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, with &quot;cleaned&quot; values or levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- sprintf("Char %s", sample(LETTERS[1:5], size = 10, replace = TRUE))
f2 &lt;- as.factor(sprintf("F / %s", sample(letters[1:5], size = 10, replace = TRUE)))
f3 &lt;- sample(1:5, size = 10, replace = TRUE)

x &lt;- data.frame(f1, f2, f3, stringsAsFactors = FALSE)

clean_values(f1)
clean_values(f2)
clean_values(x)
</code></pre>

<hr>
<h2 id='to_dummy'>Split (categorical) vectors into dummy variables</h2><span id='topic+to_dummy'></span>

<h3>Description</h3>

<p>This function splits categorical or numeric vectors with
more than two categories into 0/1-coded dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_dummy(x, ..., var.name = "name", suffix = c("numeric", "label"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_dummy_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="to_dummy_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="to_dummy_+3A_var.name">var.name</code></td>
<td>
<p>Indicates how the new dummy variables are named. Use
<code>"name"</code> to use the variable name or any other string that will
be used as is. Only applies, if <code>x</code> is a vector. See 'Examples'.</p>
</td></tr>
<tr><td><code id="to_dummy_+3A_suffix">suffix</code></td>
<td>
<p>Indicates which suffix will be added to each dummy variable.
Use <code>"numeric"</code> to number dummy variables, e.g. <em>x_1</em>,
<em>x_2</em>, <em>x_3</em> etc. Use <code>"label"</code> to add value label,
e.g. <em>x_low</em>, <em>x_mid</em>, <em>x_high</em>. May be abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with dummy variables for each category of <code>x</code>.
The dummy coded variables are of type <code><a href="base.html#topic+atomic">atomic</a></code>.
</p>


<h3>Note</h3>

<p><code>NA</code> values will be copied from <code>x</code>, so each dummy variable
has the same amount of <code>NA</code>'s at the same position as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
head(to_dummy(efc$e42dep))

# add value label as suffix to new variable name
head(to_dummy(efc$e42dep, suffix = "label"))

# use "dummy" as new variable name
head(to_dummy(efc$e42dep, var.name = "dummy"))

# create multiple dummies, append to data frame
to_dummy(efc, c172code, e42dep)

# pipe-workflow
library(dplyr)
efc %&gt;%
  select(e42dep, e16sex, c172code) %&gt;%
  to_dummy()

</code></pre>

<hr>
<h2 id='to_long'>Convert wide data to long format</h2><span id='topic+to_long'></span>

<h3>Description</h3>

<p>This function converts wide data into long format. It allows
to transform multiple key-value pairs to be transformed
from wide to long format in one single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_long(data, keys, values, ..., labels = NULL, recode.key = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_long_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> that should be tansformed from wide to
long format.</p>
</td></tr>
<tr><td><code id="to_long_+3A_keys">keys</code></td>
<td>
<p>Character vector with name(s) of key column(s) to create in output.
Either one key value per column group that should be gathered, or
a single string. In the latter case, this name will be used as
key column, and only one key column is created. See 'Examples'.</p>
</td></tr>
<tr><td><code id="to_long_+3A_values">values</code></td>
<td>
<p>Character vector with names of value columns (variable names)
to create in output. Must be of same length as number of column
groups that should be gathered. See 'Examples'.</p>
</td></tr>
<tr><td><code id="to_long_+3A_...">...</code></td>
<td>
<p>Specification of columns that should be gathered. Must be one
character vector with variable names per column group, or a numeric
vector with column indices indicating those columns that should be
gathered. See 'Examples'.</p>
</td></tr>
<tr><td><code id="to_long_+3A_labels">labels</code></td>
<td>
<p>Character vector of same length as <code>values</code> with variable
labels for the new variables created from gathered columns.
See 'Examples' and 'Details'.</p>
</td></tr>
<tr><td><code id="to_long_+3A_recode.key">recode.key</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values of the <code>key</code>
column will be recoded to numeric values, in sequential ascending
order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reshapes data from wide to long format, however,
you can gather multiple column groups at once. Value and variable labels
for non-gathered variables are preserved. Attributes from gathered variables,
such as information about the variable labels, are lost during reshaping.
Hence, the new created variables from gathered columns don't have any
variable label attributes. In such cases, use <code>labels</code> argument to set
back variable label attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reshape_longer">reshape_longer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create sample
mydat &lt;- data.frame(age = c(20, 30, 40),
                    sex = c("Female", "Male", "Male"),
                    score_t1 = c(30, 35, 32),
                    score_t2 = c(33, 34, 37),
                    score_t3 = c(36, 35, 38),
                    speed_t1 = c(2, 3, 1),
                    speed_t2 = c(3, 4, 5),
                    speed_t3 = c(1, 8, 6))

# gather multiple columns. both time and speed are gathered.
to_long(
  data = mydat,
  keys = "time",
  values = c("score", "speed"),
  c("score_t1", "score_t2", "score_t3"),
  c("speed_t1", "speed_t2", "speed_t3")
)

# alternative syntax, using "reshape_longer()"
reshape_longer(
  mydat,
  columns = list(
    c("score_t1", "score_t2", "score_t3"),
    c("speed_t1", "speed_t2", "speed_t3")
  ),
  names.to = "time",
  values.to = c("score", "speed")
)

# or ...
reshape_longer(
  mydat,
  list(3:5, 6:8),
  names.to = "time",
  values.to = c("score", "speed")
)

# gather multiple columns, use numeric key-value
to_long(
  data = mydat,
  keys = "time",
  values = c("score", "speed"),
  c("score_t1", "score_t2", "score_t3"),
  c("speed_t1", "speed_t2", "speed_t3"),
  recode.key = TRUE
)

# gather multiple columns by colum names and colum indices
to_long(
  data = mydat,
  keys = "time",
  values = c("score", "speed"),
  c("score_t1", "score_t2", "score_t3"),
  6:8,
  recode.key = TRUE
)

# gather multiple columns, use separate key-columns
# for each value-vector
to_long(
  data = mydat,
  keys = c("time_score", "time_speed"),
  values = c("score", "speed"),
  c("score_t1", "score_t2", "score_t3"),
  c("speed_t1", "speed_t2", "speed_t3")
)

# gather multiple columns, label columns
mydat &lt;- to_long(
  data = mydat,
  keys = "time",
  values = c("score", "speed"),
  c("score_t1", "score_t2", "score_t3"),
  c("speed_t1", "speed_t2", "speed_t3"),
  labels = c("Test Score", "Time needed to finish")
)

library(sjlabelled)
str(mydat$score)
get_label(mydat$speed)

</code></pre>

<hr>
<h2 id='to_value'>Convert factors to numeric variables</h2><span id='topic+to_value'></span>

<h3>Description</h3>

<p>This function converts (replaces) factor levels with the
related factor level index number, thus the factor is converted to
a numeric variable. <code>to_value()</code> and <code>to_numeric()</code> are aliases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_value(x, ..., start.at = NULL, keep.labels = TRUE, use.labels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_value_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="to_value_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="to_value_+3A_start.at">start.at</code></td>
<td>
<p>Starting index, i.e. the lowest numeric value of the variable's
value range. By default, this argument is <code>NULL</code>, hence the lowest
value of the returned numeric variable corresponds to the lowest factor
level (if factor levels are numeric) or to <code>1</code> (if factor levels
are not numeric).</p>
</td></tr>
<tr><td><code id="to_value_+3A_keep.labels">keep.labels</code></td>
<td>
<p>Logical, if <code>TRUE</code>, former factor levels will be added as
value labels. For numeric factor levels, values labels will be used,
if present. See 'Examples' and <code><a href="sjlabelled.html#topic+set_labels">set_labels</a></code> for more details.</p>
</td></tr>
<tr><td><code id="to_value_+3A_use.labels">use.labels</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> has numeric value labels,
these value labels will be set as numeric values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric variable with values ranging either from <code>start.at</code> to
<code>start.at</code> + length of factor levels, or to the corresponding
factor levels (if these were numeric). If <code>x</code> is a data frame,
the complete data frame <code>x</code> will be returned, where variables
specified in <code>...</code> are coerced to numeric; if <code>...</code> is
not specified, applies to all variables in the data frame.
</p>


<h3>Note</h3>

<p>This function is kept for backwards-compatibility. It is preferred to
use <code><a href="sjlabelled.html#topic+as_numeric">as_numeric</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sjlabelled)
data(efc)
test &lt;- as_label(efc$e42dep)
table(test)
table(to_value(test))

# Find more examples at '?sjlabelled::as_numeric'
</code></pre>

<hr>
<h2 id='trim'>Trim leading and trailing whitespaces from strings</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>Trims leading and trailing whitespaces from strings or
character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>Character vector or string, or a list or data frame with such vectors.
Function is vectorized, i.e. vector may have a length greater than
1. See 'Examples'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trimmed <code>x</code>, i.e. with leading and trailing spaces removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trim("white space at end ")
trim(" white space at start and end ")
trim(c(" string1 ", "   string2", "string 3   "))

tmp &lt;- data.frame(a = c(" string1 ", "   string2", "string 3   "),
                  b = c(" strong one  ", "    string two", "  third string "),
                  c = c(" str1 ", "   str2", "str3   "))
tmp
trim(tmp)

</code></pre>

<hr>
<h2 id='typical_value'>Return the typical value of a vector</h2><span id='topic+typical_value'></span>

<h3>Description</h3>

<p>This function returns the &quot;typical&quot; value of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typical_value(x, fun = "mean", weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typical_value_+3A_x">x</code></td>
<td>
<p>A variable.</p>
</td></tr>
<tr><td><code id="typical_value_+3A_fun">fun</code></td>
<td>
<p>Character vector, naming the function to be applied to
<code>x</code>. Currently, <code>"mean"</code>, <code>"weighted.mean"</code>,
<code>"median"</code> and <code>"mode"</code> are supported, which call the
corresponding R functions (except <code>"mode"</code>, which calls an
internal function to compute the most common value). <code>"zero"</code>
simply returns 0. <strong>Note:</strong> By default, if <code>x</code> is a factor,
only <code>fun = "mode"</code> is applicable; for all other functions (including
the default, <code>"mean"</code>) the reference level of <code>x</code> is returned.
For character vectors, only the mode is returned. You can use a named
vector to apply other different functions to integer, numeric and categorical
<code>x</code>, where factors are first converted to numeric vectors, e.g.
<code>fun = c(numeric = "median", factor = "mean")</code>. See 'Examples'.</p>
</td></tr>
<tr><td><code id="typical_value_+3A_weights">weights</code></td>
<td>
<p>Name of variable in <code>x</code> that indicated the vector of
weights that will be applied to weight all observations. Default is
<code>NULL</code>, so no weights are used.</p>
</td></tr>
<tr><td><code id="typical_value_+3A_...">...</code></td>
<td>
<p>Further arguments, passed down to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, for numeric variables, <code>typical_value()</code> returns the
mean value of <code>x</code> (unless changed with the <code>fun</code>-argument).
<br /> <br />
For factors, the reference level is returned or the most common value
(if <code>fun = "mode"</code>), unless <code>fun</code> is a named vector. If
<code>fun</code> is a named vector, specify the function for integer, numeric
and categorical variables as element names, e.g.
<code>fun = c(integer = "median", factor = "mean")</code>. In this case,
factors are converted to numeric values (using <code><a href="#topic+to_value">to_value</a></code>)
and the related function is applied. You may abbreviate the names
<code>fun = c(i = "median", f = "mean")</code>. See also 'Examples'.
<br /> <br />
For character vectors the most common value (mode) is returned.
</p>


<h3>Value</h3>

<p>The &quot;typical&quot; value of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
typical_value(iris$Sepal.Length)

library(purrr)
map(iris, ~ typical_value(.x))

# example from ?stats::weighted.mean
wt &lt;- c(5,  5,  4,  1) / 15
x &lt;- c(3.7, 3.3, 3.5, 2.8)

typical_value(x, fun = "weighted.mean")
typical_value(x, fun = "weighted.mean", weights = wt)

# for factors, return either reference level or mode value
set.seed(123)
x &lt;- sample(iris$Species, size = 30, replace = TRUE)
typical_value(x)
typical_value(x, fun = "mode")

# for factors, use a named vector to apply other functions than "mode"
map(iris, ~ typical_value(.x, fun = c(n = "median", f = "mean")))
</code></pre>

<hr>
<h2 id='var_rename'>Rename variables</h2><span id='topic+var_rename'></span><span id='topic+rename_variables'></span><span id='topic+rename_columns'></span>

<h3>Description</h3>

<p>This function renames variables in a data frame, i.e. it
renames the columns of the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_rename(x, ..., verbose = TRUE)

rename_variables(x, ..., verbose = TRUE)

rename_columns(x, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_rename_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="var_rename_+3A_...">...</code></td>
<td>
<p>A named vector, or pairs of named vectors, where the name (lhs)
equals the column name that should be renamed, and the value (rhs) is
the new column name.</p>
</td></tr>
<tr><td><code id="var_rename_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a warning is displayed when variable
names do not exist in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, with new column names for those variables specified in <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dummy &lt;- data.frame(
  a = sample(1:4, 10, replace = TRUE),
  b = sample(1:4, 10, replace = TRUE),
  c = sample(1:4, 10, replace = TRUE)
)

rename_variables(dummy, a = "first.col", c = "3rd.col")

# using quasi-quotation
library(rlang)
v1 &lt;- "first.col"
v2 &lt;- "3rd.col"
rename_variables(dummy, a = !!v1, c = !!v2)

x1 &lt;- "a"
x2 &lt;- "b"
rename_variables(dummy, !!x1 := !!v1, !!x2 := !!v2)

# using a named vector
new_names &lt;- c(a = "first.col", c = "3rd.col")
rename_variables(dummy, new_names)
</code></pre>

<hr>
<h2 id='var_type'>Determine variable type</h2><span id='topic+var_type'></span>

<h3>Description</h3>

<p>This function returns the type of a variable as character. It
is similar to <code>pillar::type_sum()</code>, however, the
return value is not truncated, and <code>var_type()</code> works
on data frames and within pipe-chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_type(x, ..., abbr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_type_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="var_type_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
<tr><td><code id="var_type_+3A_abbr">abbr</code></td>
<td>
<p>Logical, if <code>TRUE</code>, returns a shortened, abbreviated value
for the variable type (as returned by <code>pillar::type_sum()</code>).
If <code>FALSE</code> (default), a longer &quot;description&quot; is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variable type of <code>x</code>, as character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)

var_type(1)
var_type(1L)
var_type("a")

var_type(efc$e42dep)
var_type(to_factor(efc$e42dep))

library(dplyr)
var_type(efc, contains("cop"))
</code></pre>

<hr>
<h2 id='word_wrap'>Insert line breaks in long labels</h2><span id='topic+word_wrap'></span>

<h3>Description</h3>

<p>Insert line breaks in long character strings. Useful if you want to wordwrap
labels / titles for plots or tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>word_wrap(labels, wrap, linesep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="word_wrap_+3A_labels">labels</code></td>
<td>
<p>Label(s) as character string, where a line break should be
inserted. Several strings may be passed as vector  (see 'Examples').</p>
</td></tr>
<tr><td><code id="word_wrap_+3A_wrap">wrap</code></td>
<td>
<p>Maximum amount of chars per line (i.e. line length). If
<code>wrap = Inf</code> or <code>wrap = 0</code>, no word wrap will be performed
(i.e. <code>labels</code> will be returned as is).</p>
</td></tr>
<tr><td><code id="word_wrap_+3A_linesep">linesep</code></td>
<td>
<p>By default, this argument is <code>NULL</code> and a regular new line
string (<code>"\n"</code>) is used. For HTML-purposes, for instance, <code>linesep</code>
could be <code>"&lt;br&gt;"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New label(s) with line breaks inserted at every <code>wrap</code>'s position.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>word_wrap(c("A very long string", "And another even longer string!"), 10)

message(word_wrap("Much too long string for just one line!", 15))
</code></pre>

<hr>
<h2 id='zap_inf'>Convert infiite or NaN values into regular NA</h2><span id='topic+zap_inf'></span>

<h3>Description</h3>

<p>Replaces all infinite (<code>Inf</code> and <code>-Inf</code>) or <code>NaN</code>
values with regular <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zap_inf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zap_inf_+3A_x">x</code></td>
<td>
<p>A vector or a data frame.</p>
</td></tr>
<tr><td><code id="zap_inf_+3A_...">...</code></td>
<td>
<p>Optional, unquoted names of variables that should be selected for
further processing. Required, if <code>x</code> is a data frame (and no
vector) and only selected variables from <code>x</code> should be processed.
You may also use functions like <code>:</code> or tidyselect's
select-helpers.
See 'Examples' or <a href="../doc/design_philosophy.html">package-vignette</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, where all <code>Inf</code>, <code>-Inf</code> and <code>NaN</code> are converted to <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, NA, 3, NaN, 4, NA, 5, Inf, -Inf, 6, 7)
zap_inf(x)

data(efc)
# produce some NA and NaN values
efc$e42dep[1] &lt;- NaN
efc$e42dep[2] &lt;- NA
efc$c12hour[1] &lt;- NaN
efc$c12hour[2] &lt;- NA
efc$e17age[2] &lt;- NaN
efc$e17age[1] &lt;- NA

# only zap NaN for c12hour
zap_inf(efc$c12hour)

# only zap NaN for c12hour and e17age, not for e42dep,
# but return complete data framee
zap_inf(efc, c12hour, e17age)

# zap NaN for complete data frame
zap_inf(efc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
