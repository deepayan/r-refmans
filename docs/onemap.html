<!DOCTYPE html><html><head><title>Help for package onemap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {onemap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acum'><p>Perform gaussian sum</p></a></li>
<li><a href='#add_marker'><p>Creates a new sequence by adding markers.</p></a></li>
<li><a href='#add_redundants'><p>Add the redundant markers removed by create_data_bins function</p></a></li>
<li><a href='#Bonferroni_alpha'><p>Calculates individual significance level to be used to achieve a global alpha (with Bonferroni)</p></a></li>
<li><a href='#check_data'><p>Onemap object sanity check</p></a></li>
<li><a href='#check_twopts'><p>Twopts object sanity check</p></a></li>
<li><a href='#combine_onemap'><p>Combine OneMap datasets</p></a></li>
<li><a href='#compare'><p>Compare all possible orders (exhaustive search) for a given sequence of</p>
markers</a></li>
<li><a href='#create_data_bins'><p>New dataset based on bins</p></a></li>
<li><a href='#create_dataframe_for_plot_outcross'><p>Create a dataframe suitable for a ggplot2 graphic</p></a></li>
<li><a href='#create_depths_profile'><p>Create database and ggplot graphic of allele reads depths</p></a></li>
<li><a href='#create_probs'><p>Build genotype probabilities matrix for hmm</p></a></li>
<li><a href='#draw_map'><p>Draw a genetic map</p></a></li>
<li><a href='#draw_map2'><p>Draw a linkage map</p></a></li>
<li><a href='#drop_marker'><p>Creates a new sequence by dropping markers.</p></a></li>
<li><a href='#empty_onemap_obj'><p>Produce empty object to avoid code break. Function for internal purpose.</p></a></li>
<li><a href='#est_map_hmm_out'><p>C++ routine for multipoint analysis in outcrossing populations</p></a></li>
<li><a href='#extract_depth'><p>Extract allele counts of progeny and parents of vcf file</p></a></li>
<li><a href='#filter_2pts_gaps'><p>Filter markers based on 2pts distance</p></a></li>
<li><a href='#filter_missing'><p>Filter markers according with a missing data threshold</p></a></li>
<li><a href='#filter_prob'><p>Function filter genotypes by genotype probability</p></a></li>
<li><a href='#find_bins'><p>Allocate markers into bins</p></a></li>
<li><a href='#generate_overlapping_batches'><p>Function to divide the sequence in batches with user defined size</p></a></li>
<li><a href='#group'><p>Assign markers to linkage groups</p></a></li>
<li><a href='#group_seq'><p>Assign markers to preexisting linkage groups</p></a></li>
<li><a href='#group_upgma'><p>Assign markers to linkage groups</p></a></li>
<li><a href='#haldane'><p>Apply Haldane mapping function</p></a></li>
<li><a href='#keep_only_selected_mks'><p>Keep in the onemap and twopts object only markers in the sequences</p></a></li>
<li><a href='#kosambi'><p>Apply Kosambi mapping function</p></a></li>
<li><a href='#make_seq'><p>Create a sequence of markers based on other OneMap object types</p></a></li>
<li><a href='#map'><p>Construct the linkage map for a sequence of markers</p></a></li>
<li><a href='#map_avoid_unlinked'><p>Repeat HMM if map find unlinked marker</p></a></li>
<li><a href='#map_overlapping_batches'><p>Mapping overlapping batches</p></a></li>
<li><a href='#map_save_ram'><p>Perform map using background objects with only selected markers. It saves ram memory during the procedure.</p>
It is useful if dealing with many markers in total data set.</a></li>
<li><a href='#mapmaker_example_f2'>
<p>Simulated data from a F2 population</p></a></li>
<li><a href='#marker_type'><p>Informs the segregation patterns of markers</p></a></li>
<li><a href='#mds_onemap'><p>OneMap interface with MDSMap package with option for multipoint distances estimation</p></a></li>
<li><a href='#onemap_example_bc'><p>Simulated data from a backcross population</p></a></li>
<li><a href='#onemap_example_f2'>
<p>Simulated data from a F2 population</p></a></li>
<li><a href='#onemap_example_out'><p>Data from a full-sib family derived from two outbred parents</p></a></li>
<li><a href='#onemap_example_riself'>
<p>Simulated data from a RIL population produced by selfing.</p></a></li>
<li><a href='#onemap_read_vcfR'><p>Convert vcf file to onemap object</p></a></li>
<li><a href='#order_seq'><p>Search for the best order of markers combining compare and try_seq</p>
functions</a></li>
<li><a href='#parents_haplotypes'><p>Generates data.frame with parents estimated haplotypes</p></a></li>
<li><a href='#pick_batch_sizes'><p>Picking optimal batch size values</p></a></li>
<li><a href='#plot_by_segreg_type'><p>Draw a graphic showing the number of markers of each segregation pattern.</p></a></li>
<li><a href='#plot.group.upgma'><p>Show the results of grouping procedure</p></a></li>
<li><a href='#plot.onemap'><p>Draw a graphic of raw data for any OneMap population</p></a></li>
<li><a href='#plot.onemap_progeny_haplotypes'><p>Plots progeny haplotypes</p></a></li>
<li><a href='#plot.onemap_progeny_haplotypes_counts'><p>Plot recombination breakpoints counts for each individual</p></a></li>
<li><a href='#plot.onemap_segreg_test'><p>Plot p-values for chi-square tests of expected segregation</p></a></li>
<li><a href='#print.compare'><p>print method for object class 'compare'</p></a></li>
<li><a href='#print.group'><p>Show the results of grouping procedure</p></a></li>
<li><a href='#print.group_seq'><p>Show the results of grouping markers to preexisting sequence</p></a></li>
<li><a href='#print.group.upgma'><p>Show the results of grouping procedure</p></a></li>
<li><a href='#print.onemap'><p>Print method for object class 'onemap'</p></a></li>
<li><a href='#print.onemap_bin'><p>print method for object class 'onemap_bin'</p></a></li>
<li><a href='#print.onemap_segreg_test'><p>Show the results of segregation tests</p></a></li>
<li><a href='#print.order'><p>Print order_seq object</p></a></li>
<li><a href='#print.rf_2pts'><p>Print method for object class 'rf_2pts'</p></a></li>
<li><a href='#print.sequence'><p>Print method for object class 'sequence'</p></a></li>
<li><a href='#print.try'><p>Print method for object class 'try'</p></a></li>
<li><a href='#progeny_haplotypes'><p>Generate data.frame with genotypes estimated by HMM and its probabilities</p></a></li>
<li><a href='#progeny_haplotypes_counts'><p>Plot number of breakpoints by individuals</p></a></li>
<li><a href='#rcd'><p>Rapid Chain Delineation</p></a></li>
<li><a href='#read_mapmaker'><p>Read data from a Mapmaker raw file</p></a></li>
<li><a href='#read_onemap'><p>Read data from all types of progenies supported by OneMap</p></a></li>
<li><a href='#record'><p>Recombination Counting and Ordering</p></a></li>
<li><a href='#remove_inds'><p>Remove individuals from the onemap object</p></a></li>
<li><a href='#rf_2pts'><p>Two-point analysis between genetic markers</p></a></li>
<li><a href='#rf_graph_table'><p>Plots pairwise recombination fractions and LOD Scores in a heatmap</p></a></li>
<li><a href='#rf_snp_filter_onemap'><p>Filter markers according with a two-points recombination fraction and LOD threshold. Adapted from MAPpoly.</p></a></li>
<li><a href='#ripple_seq'><p>Compares and displays plausible alternative orders for a given linkage</p>
group</a></li>
<li><a href='#rm_dupli_mks'><p>Remove duplicated markers keeping the one with less missing data</p></a></li>
<li><a href='#seeded_map'><p>Construct the linkage map for a sequence of markers after seeding phases</p></a></li>
<li><a href='#select_segreg'><p>Show markers with/without segregation distortion</p></a></li>
<li><a href='#seq_by_type'><p>Extract marker number by name</p></a></li>
<li><a href='#seriation'><p>Seriation</p></a></li>
<li><a href='#set_map_fun'><p>Defines the default mapping function</p></a></li>
<li><a href='#sort_by_pos'><p>Sort markers in onemap object by their position in reference genome</p></a></li>
<li><a href='#split_2pts'><p>Split rf_2pts object by markers</p></a></li>
<li><a href='#split_onemap'><p>Split onemap data sets</p></a></li>
<li><a href='#suggest_lod'><p>Suggests a LOD Score for two point tests</p></a></li>
<li><a href='#test_segregation'><p>test_segregation</p></a></li>
<li><a href='#test_segregation_of_a_marker'><p>test_segregation_of_a_marker</p></a></li>
<li><a href='#try_seq'><p>Try to map a marker into every possible position between markers</p>
in a given map</a></li>
<li><a href='#try_seq_by_seq'><p>Run try_seq considering previous sequence</p></a></li>
<li><a href='#ug'><p>Unidirectional Growth</p></a></li>
<li><a href='#vcf_example_bc'>
<p>Data generated from VCF file with biallelic markers from a f2 backcross population</p></a></li>
<li><a href='#vcf_example_f2'><p>Data generated from VCF file with biallelic markers from a f2 intercross population</p></a></li>
<li><a href='#vcf_example_out'><p>Data generated from VCF file with biallelic markers from a full-sib family derived from two outbred parents</p></a></li>
<li><a href='#vcf_example_riself'>
<p>Data generated from VCF file with biallelic markers from a RIL population produced by selfing</p></a></li>
<li><a href='#vcf2raw'><p>These functions are defunct and no longer available.</p></a></li>
<li><a href='#write_map'><p>Write a genetic map to a file</p></a></li>
<li><a href='#write_onemap_raw'><p>Convert onemap object to onemap raw file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Construction of Genetic Maps in Experimental Crosses</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of molecular marker data from model (backcrosses,
    F2 and recombinant inbred lines) and non-model systems (i. e.
    outcrossing species). For the later, it allows statistical
    analysis by simultaneously estimating linkage and linkage
    phases (genetic map construction) according to Wu et al. (2002)
    &lt;<a href="https://doi.org/10.1006%2Ftpbi.2002.1577">doi:10.1006/tpbi.2002.1577</a>&gt;. All analysis are based on multipoint 
    approaches using hidden Markov models.</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabriel Margarido [aut],
  Marcelo Mollinari [aut],
  Cristiane Taniguti [ctb, cre],
  Getulio Ferreira [ctb],
  Rodrigo Amadeu [ctb],
  Karl Broman [ctb],
  Katharine Preedy [ctb, cph] (MDS ordering algorithm),
  Bastian Schiffthaler [ctb, cph] (HMM parallelization),
  Augusto Garcia [aut, ctb]</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.10.5)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 2.2.1), plotly (&ge; 4.7.1), reshape2 (&ge; 1.4.1),
Rcpp (&ge; 0.10.5), graphics, methods, stats, utils, grDevices,
smacof, princurve, parallel, dplyr, tidyr, htmlwidgets, ggpubr,
RColorBrewer, dendextend, rebus, vcfR (&ge; 1.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.10), rmarkdown, testthat, stringr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/augusto-garcia/onemap">https://github.com/augusto-garcia/onemap</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/augusto-garcia/onemap/wiki">https://github.com/augusto-garcia/onemap/wiki</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cristiane Taniguti &lt;chtaniguti@tamu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-26 04:36:06 UTC; chtan</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-26 05:00:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
</table>
<hr>
<h2 id='acum'>Perform gaussian sum</h2><span id='topic+acum'></span>

<h3>Description</h3>

<p>Perform gaussian sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acum(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acum_+3A_w">w</code></td>
<td>
<p>vector of numbers</p>
</td></tr>
</table>

<hr>
<h2 id='add_marker'>Creates a new sequence by adding markers.</h2><span id='topic+add_marker'></span>

<h3>Description</h3>

<p>Creates a new sequence by adding markers from a predetermined
one. The markers are added in the end of the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_marker(input.seq, mrks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_marker_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="add_marker_+3A_mrks">mrks</code></td>
<td>
<p>a vector containing the markers to be added from the
<code>sequence</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list
containing the following components:
</p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the (ordered) indices of
markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between
markers in the sequence, in corresponding positions. <code>-1</code>
means that there are no defined linkage phases.</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the recombination fractions
between markers in the sequence. <code>-1</code> means that there
are no estimated recombination fractions.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code>
with the raw data.</p>
</td></tr>
<tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>
<p>@author Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop_marker">drop_marker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(onemap_example_out)
twopt &lt;- rf_2pts(onemap_example_out)
all_mark &lt;- make_seq(twopt,"all")
groups &lt;- group(all_mark)
(LG1 &lt;- make_seq(groups,1))
(LG.aug&lt;-add_marker(LG1, c(4,7)))

</code></pre>

<hr>
<h2 id='add_redundants'>Add the redundant markers removed by create_data_bins function</h2><span id='topic+add_redundants'></span>

<h3>Description</h3>

<p>Add the redundant markers removed by create_data_bins function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_redundants(sequence, onemap.obj, bins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_redundants_+3A_sequence">sequence</code></td>
<td>
<p>object of class <code>sequence</code></p>
</td></tr>
<tr><td><code id="add_redundants_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>object of class <code>onemap.obj</code> before redundant markers were removed</p>
</td></tr>
<tr><td><code id="add_redundants_+3A_bins">bins</code></td>
<td>
<p>object of class <code>onemap_bin</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>New sequence object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_bins">find_bins</a></code>
</p>

<hr>
<h2 id='Bonferroni_alpha'>Calculates individual significance level to be used to achieve a global alpha (with Bonferroni)</h2><span id='topic+Bonferroni_alpha'></span>

<h3>Description</h3>

<p>It shows the alpha value to be used in each chi-square segregation test, in order to achieve
a given global type I error. To do so, it uses Bonferroni's criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bonferroni_alpha(x, global.alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bonferroni_alpha_+3A_x">x</code></td>
<td>
<p>an object of class onemap_segreg_test</p>
</td></tr>
<tr><td><code id="Bonferroni_alpha_+3A_global.alpha">global.alpha</code></td>
<td>
<p>the global alpha that</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the alpha value for each test (numeric)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(onemap_example_bc) # Loads a fake backcross dataset installed with onemap
 Chi &lt;- test_segregation(onemap_example_bc) # Performs the chi-square test for all markers
 print(Chi) # Shows the results of the Chi-square tests
 Bonferroni_alpha (Chi) # Shows the individual alpha level to be used


</code></pre>

<hr>
<h2 id='check_data'>Onemap object sanity check</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>Based on MAPpoly check_data_sanity function by Marcelo Mollinari
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_+3A_x">x</code></td>
<td>
<p>an object of class <code>onemap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if consistent, returns 0. If not consistent, returns a 
vector with a number of tests, where <code>TRUE</code> indicates
a failed test.
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_bc)
check_data(onemap_example_bc)


</code></pre>

<hr>
<h2 id='check_twopts'>Twopts object sanity check</h2><span id='topic+check_twopts'></span>

<h3>Description</h3>

<p>Based on MAPpoly check_data_sanity function by Marcelo Mollinari
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_twopts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_twopts_+3A_x">x</code></td>
<td>
<p>an object of class <code>onemap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if consistent, returns 0. If not consistent, returns a 
vector with a number of tests, where <code>TRUE</code> indicates
a failed test.
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_bc)
twopts &lt;- rf_2pts(onemap_example_bc)
check_twopts(twopts)

</code></pre>

<hr>
<h2 id='combine_onemap'>Combine OneMap datasets</h2><span id='topic+combine_onemap'></span>

<h3>Description</h3>

<p>Merge two or more OneMap datasets from the same cross type. Creates an
object of class <code>onemap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_onemap(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_onemap_+3A_...">...</code></td>
<td>
<p>Two or more <code>onemap</code> dataset objects of the same cross
type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of OneMap datasets, all from the same cross type (full-sib,
backcross, F2 intercross or recombinant inbred lines obtained by self-
or sib-mating), merges marker and phenotype information to create a
single <code>onemap</code> object.
</p>
<p>If sample IDs are present in all datasets (the standard new format), not
all individuals need to be genotyped in all datasets - the merged dataset
will contain all available information, with missing data elsewhere. If
sample IDs are missing in at least one dataset, it is required that all
datasets have the same number of individuals, and it is assumed that they
are arranged in the same order in every dataset.
</p>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>a string indicating that this is a
combined dataset.</p>
</td></tr> <tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a
matrix with phenotypic values. Each column contains data for a trait and
each row represents an individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a>
</p>


<h3>References</h3>

<p>Lincoln, S. E., Daly, M. J. and Lander, E. S. (1993)
Constructing genetic linkage maps with MAPMAKER/EXP Version 3.0: a tutorial
and reference manual. <em>A Whitehead Institute for Biomedical Research
Technical Report</em>.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> and
<code><a href="#topic+read_mapmaker">read_mapmaker</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    data("onemap_example_out")
    data("vcf_example_out")
    combined_data &lt;- combine_onemap(onemap_example_out, vcf_example_out)
  
</code></pre>

<hr>
<h2 id='compare'>Compare all possible orders (exhaustive search) for a given sequence of
markers</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>For a given sequence with <code class="reqn">n</code> markers, computes the multipoint
likelihood of all <code class="reqn">\frac{n!}{2}</code> possible orders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(input.seq, n.best = 50, tol = 0.001, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_n.best">n.best</code></td>
<td>
<p>the number of best orders to store in object (defaults to
50).</p>
</td></tr>
<tr><td><code id="compare_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="compare_+3A_verbose">verbose</code></td>
<td>
<p>if <code>FALSE</code> (default), simplified output is displayed.
if <code>TRUE</code>, detailed output is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the number <code class="reqn">\frac{n!}{2}</code> is large even for moderate values
of <code class="reqn">n</code>, this function is to be used only for sequences with
relatively few markers. If markers were genotyped in an outcross population,
linkage phases need to be estimated and therefore more states need to be
visited in the Markov chain; when segregation types are D1, D2 and C,
computation can required a very long time (specially when markers linked in
repulsion are involved), so we recommend to use this function up to 6 or 7 markers.
For inbred-based populations, up to 10 or 11 markers can be ordered with this function,
since linkage phase are known.
The multipoint likelihood is calculated according to Wu et al.
(2002b) (Eqs. 7a to 11), assuming that the recombination fraction is the
same in both parents. Hidden Markov chain codes adapted from Broman et al.
(2008) were used.
</p>


<h3>Value</h3>

<p>An object of class <code>compare</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>best.ord</code></td>
<td>
<p>a <code>matrix</code> containing the best
orders.</p>
</td></tr> <tr><td><code>best.ord.rf</code></td>
<td>
<p>a <code>matrix</code> with recombination frequencies
for the corresponding best orders.</p>
</td></tr> <tr><td><code>best.ord.phase</code></td>
<td>
<p>a <code>matrix</code>
with linkage phases for the best orders.</p>
</td></tr> <tr><td><code>best.ord.like</code></td>
<td>
<p>a
<code>vector</code> with log-likelihood values for the best orders.</p>
</td></tr>
<tr><td><code>best.ord.LOD</code></td>
<td>
<p>a <code>vector</code> with LOD Score values for the best
orders.</p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with
the raw data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with
the 2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>
<p>Jiang, C. and Zeng, Z.-B. (1997). Mapping quantitative trait loci with
dominant and missing markers in various crosses from two inbred lines.
<em>Genetica</em> 101: 47-58.
</p>
<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M. J., Lincoln,
S. E. and Newburg, L. (1987) MAPMAKER: An interactive computer package for
constructing primary genetic linkage maps of experimental and natural
populations. <em>Genomics</em> 1: 174-181.
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia, A.  A. F.
(2009) Evaluation of algorithms used to order markers on genetics maps.
_Heredity_ 103: 494-502.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage mapping of
sex-specific differences. <em>Genetical Research</em> 79: 85-96
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marker_type">marker_type</a></code> for details about segregation
types and <code><a href="#topic+make_seq">make_seq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #outcrossing example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  markers &lt;- make_seq(twopt,c(12,14,15,26,28))
  (markers.comp &lt;- compare(markers))
  (markers.comp &lt;- compare(markers,verbose=TRUE))

  #F2 example
  data(onemap_example_f2)
  twopt &lt;- rf_2pts(onemap_example_f2)
  markers &lt;- make_seq(twopt,c(17,26,29,30,44,46,55))
  (markers.comp &lt;- compare(markers))
  (markers.comp &lt;- compare(markers,verbose=TRUE))



</code></pre>

<hr>
<h2 id='create_data_bins'>New dataset based on bins</h2><span id='topic+create_data_bins'></span>

<h3>Description</h3>

<p>Creates a new dataset based on <code>onemap_bin</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_data_bins(input.obj, bins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_data_bins_+3A_input.obj">input.obj</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="create_data_bins_+3A_bins">bins</code></td>
<td>
<p>an object of class <code>onemap_bin</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>onemap_bin</code> object,
creates a new data set where the redundant markers are
collapsed into bins and represented by the marker with the lower
amount of missing data among those on the bin.
</p>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_bins">find_bins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data("onemap_example_f2")
  (bins&lt;-find_bins(onemap_example_f2, exact=FALSE))
  onemap_bins &lt;- create_data_bins(onemap_example_f2, bins)

</code></pre>

<hr>
<h2 id='create_dataframe_for_plot_outcross'>Create a dataframe suitable for a ggplot2 graphic</h2><span id='topic+create_dataframe_for_plot_outcross'></span>

<h3>Description</h3>

<p>An internal function that prepares a dataframe suitable for
drawing a graphic of raw data using ggplot2, i. e., a data frame
with long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dataframe_for_plot_outcross(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_dataframe_for_plot_outcross_+3A_x">x</code></td>
<td>
<p>an object of classes <code>onemap</code> and <code>outcross</code>, with data and additional information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe
</p>

<hr>
<h2 id='create_depths_profile'>Create database and ggplot graphic of allele reads depths</h2><span id='topic+create_depths_profile'></span>

<h3>Description</h3>

<p>Create database and ggplot graphic of allele reads depths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_depths_profile(
  onemap.obj = NULL,
  vcfR.object = NULL,
  vcf = NULL,
  parent1 = NULL,
  parent2 = NULL,
  vcf.par = "AD",
  recovering = FALSE,
  mks = NULL,
  inds = NULL,
  GTfrom = "onemap",
  alpha = 1,
  rds.file = "data.rds",
  y_lim = NULL,
  x_lim = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_depths_profile_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_vcfr.object">vcfR.object</code></td>
<td>
<p>object of class vcfR;</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_vcf">vcf</code></td>
<td>
<p>path to VCF file.</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_parent1">parent1</code></td>
<td>
<p>a character specifying the first parent ID</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_parent2">parent2</code></td>
<td>
<p>a character specifying the second parent ID</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_vcf.par">vcf.par</code></td>
<td>
<p>the vcf parameter that store the allele depth information.</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_recovering">recovering</code></td>
<td>
<p>logical. If TRUE, all markers in vcf are consider, if FALSE only those in onemap.obj</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_mks">mks</code></td>
<td>
<p>a vector of characters specifying the markers names to be considered or NULL to consider all markers</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_inds">inds</code></td>
<td>
<p>a vector of characters specifying the individual names to be considered or NULL to consider all individuals</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_gtfrom">GTfrom</code></td>
<td>
<p>the graphic should contain the genotypes from onemap.obj or from the vcf? Specify using &quot;onemap&quot;, &quot;vcf&quot; or &quot;prob&quot;.</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_alpha">alpha</code></td>
<td>
<p>define the transparency of the dots in the graphic</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_rds.file">rds.file</code></td>
<td>
<p>rds file name to store the data frame with values used to build the graphic</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_y_lim">y_lim</code></td>
<td>
<p>set scale limit for y axis</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_x_lim">x_lim</code></td>
<td>
<p>set scale limit for x axis</p>
</td></tr>
<tr><td><code id="create_depths_profile_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print tracing information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an rds file and a ggplot graphic.
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onemap_read_vcfR">onemap_read_vcfR</a></code>
</p>

<hr>
<h2 id='create_probs'>Build genotype probabilities matrix for hmm</h2><span id='topic+create_probs'></span>

<h3>Description</h3>

<p>The genotypes probabilities can be calculated considering a global error (default method)
or considering a genotype error probability for each genotype. Furthermore, user can provide 
directly the genotype probability matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_probs(
  input.obj = NULL,
  global_error = NULL,
  genotypes_errors = NULL,
  genotypes_probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_probs_+3A_input.obj">input.obj</code></td>
<td>
<p>object of class onemap or onemap sequence</p>
</td></tr>
<tr><td><code id="create_probs_+3A_global_error">global_error</code></td>
<td>
<p>a integer specifying the global error value</p>
</td></tr>
<tr><td><code id="create_probs_+3A_genotypes_errors">genotypes_errors</code></td>
<td>
<p>a matrix with dimensions (number of individuals) x (number of markers) with genotypes errors values</p>
</td></tr>
<tr><td><code id="create_probs_+3A_genotypes_probs">genotypes_probs</code></td>
<td>
<p>a matrix with dimensions (number of individuals)*(number of markers) x possible genotypes 
(i.e., a ab ba b) with four columns for f2 and outcrossing populations, and two for backcross and RILs).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genotype probability matrix has number of individuals x number of markers rows and
four columns (or two if considering backcross or RILs populations), one for each possible genotype
of the population. This format follows the one proposed by MAPpoly.
</p>
<p>The genotype probabilities come from SNP calling methods. If you do not have them, you can use a global
error or a error value for each genotype. The OneMap until 2.1 version have only the global error option.
</p>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)
  new.data &lt;- create_probs(onemap_example_out, global_error = 10^-5)
  
</code></pre>

<hr>
<h2 id='draw_map'>Draw a genetic map</h2><span id='topic+draw_map'></span>

<h3>Description</h3>

<p>Provides a simple draw of a genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_map(
  map.list,
  horizontal = FALSE,
  names = FALSE,
  grid = FALSE,
  cex.mrk = 1,
  cex.grp = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_map_+3A_map.list">map.list</code></td>
<td>
<p>a map, i.e. an object of class <code>sequence</code> with a
predefined order, linkage phases, recombination fraction and likelihood;
also it could be a list of maps.</p>
</td></tr>
<tr><td><code id="draw_map_+3A_horizontal">horizontal</code></td>
<td>
<p>if <code>TRUE</code>, indicates that the map should be plotted
horizontally. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="draw_map_+3A_names">names</code></td>
<td>
<p>if <code>TRUE</code>, displays the names of the markers. Default is
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="draw_map_+3A_grid">grid</code></td>
<td>
<p>if <code>TRUE</code>, displays a grid in the background. Default is
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="draw_map_+3A_cex.mrk">cex.mrk</code></td>
<td>
<p>the magnification to be used for markers.</p>
</td></tr>
<tr><td><code id="draw_map_+3A_cex.grp">cex.grp</code></td>
<td>
<p>the magnification to be used for group axis annotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>figure with genetic map draw
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 #outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  lg&lt;-group(make_seq(twopt, "all"))
  maps&lt;-vector("list", lg$n.groups)
  for(i in 1:lg$n.groups)
     maps[[i]]&lt;- make_seq(order_seq(input.seq= make_seq(lg,i),twopt.alg =
   "rcd"), "force")
  draw_map(maps, grid=TRUE)
  draw_map(maps, grid=TRUE, horizontal=TRUE)


</code></pre>

<hr>
<h2 id='draw_map2'>Draw a linkage map</h2><span id='topic+draw_map2'></span>

<h3>Description</h3>

<p>Provides a simple draw of a linkage map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_map2(
  ...,
  tag = NULL,
  id = TRUE,
  pos = TRUE,
  cex.label = NULL,
  main = NULL,
  group.names = NULL,
  centered = FALSE,
  y.axis = TRUE,
  space = NULL,
  col.group = NULL,
  col.mark = NULL,
  col.tag = NULL,
  output = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_map2_+3A_...">...</code></td>
<td>
<p>map(s). Object(s) of class <code>sequence</code> and/or <code>data.frame</code>. If <code>data.frame</code>, it must have two columns: column 1: marker id; column 2: position (cM) (<code>numeric</code>).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_tag">tag</code></td>
<td>
<p>name(s) of the marker(s) to highlight. If &quot;all&quot;, all markers will be highlighted. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_id">id</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), shows name(s) of tagged marker(s).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_pos">pos</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), shows position(s) of tagged marker(s).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_cex.label">cex.label</code></td>
<td>
<p>the magnification used for label(s) of tagged marker(s). If <code>NULL</code> (default), the cex will be automatically calculated to avoid overlapping.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_main">main</code></td>
<td>
<p>an overall title for the plot. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_group.names">group.names</code></td>
<td>
<p>name(s) to identify the group(s). If <code>NULL</code> (default), the name(s) of the sequence(s) will be used.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_centered">centered</code></td>
<td>
<p>logical. If <code>TRUE</code>, the group(s) will be aligned in the center. If <code>FALSE</code> (default), the group(s) will be aligned at the top.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_y.axis">y.axis</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), shows y axis. If centered = <code>TRUE</code>, the y axis will always be hidden.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_space">space</code></td>
<td>
<p>numerical. Spacing between groups. If <code>NULL</code> (default), the spacing will be automatically calculated to avoid overlapping.</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_col.group">col.group</code></td>
<td>
<p>the color used for group(s).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_col.mark">col.mark</code></td>
<td>
<p>the color used for marker(s).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_col.tag">col.tag</code></td>
<td>
<p>the color used for highlighted marker(s) and its/theirs label(s).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_output">output</code></td>
<td>
<p>the name of the output file. The file format can be specified by adding its extension. Available formats: 'bmp', 'jpeg', 'png', 'tiff', 'pdf' and 'eps' (default).</p>
</td></tr>
<tr><td><code id="draw_map2_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print tracing information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot graphic with genetic map draw
</p>


<h3>Author(s)</h3>

<p>Getulio Caixeta Ferreira, <a href="mailto:getulio.caifer@gmail.com">getulio.caifer@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("onemap_example_out")
twopt &lt;- rf_2pts(onemap_example_out)
lg&lt;-group(make_seq(twopt, "all"))
seq1&lt;-make_seq(order_seq(input.seq= make_seq(lg,1),twopt.alg = "rcd"), "force")
seq2&lt;-make_seq(order_seq(input.seq= make_seq(lg,2),twopt.alg = "rcd"), "force")
seq3&lt;-make_seq(order_seq(input.seq= make_seq(lg,3),twopt.alg = "rcd"), "force")
draw_map2(seq1,seq2,seq3,tag = c("M1","M2","M3","M4","M5"),
output = paste0(tempfile(), ".png"))


</code></pre>

<hr>
<h2 id='drop_marker'>Creates a new sequence by dropping markers.</h2><span id='topic+drop_marker'></span>

<h3>Description</h3>

<p>Creates a new sequence by dropping markers from a predetermined
one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_marker(input.seq, mrks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_marker_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="drop_marker_+3A_mrks">mrks</code></td>
<td>
<p>a vector containing the markers to be removed
from the <code>sequence</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list
containing the following components:
</p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the (ordered) indices of
markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between
markers in the sequence, in corresponding positions. <code>-1</code>
means that there are no defined linkage phases.</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the recombination fractions
between markers in the sequence. <code>-1</code> means that there
are no estimated recombination fractions.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code>
with the raw data.</p>
</td></tr>
<tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>
<p>@author Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_marker">add_marker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_out)
twopt &lt;- rf_2pts(onemap_example_out)
all_mark &lt;- make_seq(twopt,"all")
groups &lt;- group(all_mark)
(LG1 &lt;- make_seq(groups,1))
(LG.aug&lt;-drop_marker(LG1, c(10,14)))


</code></pre>

<hr>
<h2 id='empty_onemap_obj'>Produce empty object to avoid code break. Function for internal purpose.</h2><span id='topic+empty_onemap_obj'></span>

<h3>Description</h3>

<p>Produce empty object to avoid code break. Function for internal purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_onemap_obj(vcf, P1, P2, cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_onemap_obj_+3A_vcf">vcf</code></td>
<td>
<p>object of class vcfR</p>
</td></tr>
<tr><td><code id="empty_onemap_obj_+3A_p1">P1</code></td>
<td>
<p>character with parent 1 ID</p>
</td></tr>
<tr><td><code id="empty_onemap_obj_+3A_p2">P2</code></td>
<td>
<p>character with parent 2 ID</p>
</td></tr>
<tr><td><code id="empty_onemap_obj_+3A_cross">cross</code></td>
<td>
<p>type of cross. Must be one of: <code>"outcross"</code> for full-sibs;
<code>"f2 intercross"</code> for an F2 intercross progeny; <code>"f2 backcross"</code>;
<code>"ri self"</code> for recombinant inbred lines by self-mating; or
<code>"ri sib"</code> for recombinant inbred lines by sib-mating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='est_map_hmm_out'>C++ routine for multipoint analysis in outcrossing populations</h2><span id='topic+est_map_hmm_out'></span>

<h3>Description</h3>

<p>It calls C++ routine that implements the methodology of Hidden
Markov Models (HMM) to construct multipoint linkage maps in
outcrossing species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_map_hmm_out(
  geno,
  error,
  type,
  phase,
  rf.vec = NULL,
  verbose = TRUE,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_map_hmm_out_+3A_geno">geno</code></td>
<td>
<p>matrix of genotypes. Rows represent marker and columns
represent individuals.</p>
</td></tr>
<tr><td><code id="est_map_hmm_out_+3A_type">type</code></td>
<td>
<p>a vector indicating the type of marker. For more
information see <code><a href="#topic+read_onemap">read_onemap</a></code></p>
</td></tr>
<tr><td><code id="est_map_hmm_out_+3A_phase">phase</code></td>
<td>
<p>a vector indicating the linkage phases between
markers. For more information see
<code><a href="#topic+make_seq">make_seq</a></code></p>
</td></tr>
<tr><td><code id="est_map_hmm_out_+3A_rf.vec">rf.vec</code></td>
<td>
<p>a vector containing the recombination fraction
initial values</p>
</td></tr>
<tr><td><code id="est_map_hmm_out_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print tracing information.</p>
</td></tr>
<tr><td><code id="est_map_hmm_out_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to
evaluate convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the re-estimated vector of recombination
fractions and the logarithm of the likelihood
</p>

<hr>
<h2 id='extract_depth'>Extract allele counts of progeny and parents of vcf file</h2><span id='topic+extract_depth'></span>

<h3>Description</h3>

<p>Uses vcfR package and onemap object to generates list of vectors with
reference allele count and total counts for each marker and genotypes 
included in onemap object (only available for biallelic sites)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_depth(
  vcfR.object = NULL,
  onemap.object = NULL,
  vcf.par = c("GQ", "AD", "DPR, PL", "GL"),
  parent1 = "P1",
  parent2 = "P2",
  f1 = "F1",
  recovering = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_depth_+3A_vcfr.object">vcfR.object</code></td>
<td>
<p>object output from vcfR package</p>
</td></tr>
<tr><td><code id="extract_depth_+3A_onemap.object">onemap.object</code></td>
<td>
<p>onemap object output from read_onemap, read_mapmaker or onemap_read_vcf function</p>
</td></tr>
<tr><td><code id="extract_depth_+3A_vcf.par">vcf.par</code></td>
<td>
<p>vcf format field that contain allele counts informations, the implemented are: AD, DPR, GQ, PL, GL. 
AD and DPR return a list with allele depth information. GQ returns a matrix with error probability for each genotype. 
PL return a data.frame with genotypes probabilities for every genotype.</p>
</td></tr>
<tr><td><code id="extract_depth_+3A_parent1">parent1</code></td>
<td>
<p>parent 1 identification in vcfR object</p>
</td></tr>
<tr><td><code id="extract_depth_+3A_parent2">parent2</code></td>
<td>
<p>parent 2 identification in vcfR object</p>
</td></tr>
<tr><td><code id="extract_depth_+3A_f1">f1</code></td>
<td>
<p>if your cross type is f2, you must define the F1 individual</p>
</td></tr>
<tr><td><code id="extract_depth_+3A_recovering">recovering</code></td>
<td>
<p>TRUE/FALSE, if TRUE evaluate all markers from vcf file, if FALSE evaluate only markers in onemap object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following components: </p>
<table>
<tr><td><code>palt</code></td>
<td>
<p>a <code>matrix</code> with parent 1 and 2 
alternative allele counts.</p>
</td></tr> <tr><td><code>pref</code></td>
<td>
<p>a <code>matrix</code> with parent 1 and 2 
reference allele counts.</p>
</td></tr> <tr><td><code>psize</code></td>
<td>
<p>a <code>matrix</code> with parent 1 and 2 
total allele counts.</p>
</td></tr><tr><td><code>oalt</code></td>
<td>
<p>a <code>matrix</code> with progeny 
alternative allele counts.</p>
</td></tr><tr><td><code>oref</code></td>
<td>
<p>a <code>matrix</code> with progeny 
reference allele counts.</p>
</td></tr><tr><td><code>osize</code></td>
<td>
<p>a <code>matrix</code> with progeny 
total allele counts.</p>
</td></tr><tr><td><code>n.mks</code></td>
<td>
<p>total number of markers.</p>
</td></tr> 
<tr><td><code>n.ind</code></td>
<td>
<p>total number of individuals in progeny.</p>
</td></tr> <tr><td><code>inds</code></td>
<td>
<p>progeny individuals identification.</p>
</td></tr>
<tr><td><code>mks</code></td>
<td>
<p>markers identification.</p>
</td></tr> <tr><td><code>onemap.object</code></td>
<td>
<p>same onemap.object inputted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='filter_2pts_gaps'>Filter markers based on 2pts distance</h2><span id='topic+filter_2pts_gaps'></span>

<h3>Description</h3>

<p>Filter markers based on 2pts distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_2pts_gaps(input.seq, max.gap = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_2pts_gaps_+3A_input.seq">input.seq</code></td>
<td>
<p>object of class sequence with ordered markers</p>
</td></tr>
<tr><td><code id="filter_2pts_gaps_+3A_max.gap">max.gap</code></td>
<td>
<p>maximum gap measured in kosambi centimorgans allowed between adjacent markers. 
Markers that presents the defined distance between both adjacent neighbors will be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New sequence object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='filter_missing'>Filter markers according with a missing data threshold</h2><span id='topic+filter_missing'></span>

<h3>Description</h3>

<p>Filter markers according with a missing data threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_missing(
  onemap.obj = NULL,
  threshold = 0.25,
  by = "markers",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_missing_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_threshold">threshold</code></td>
<td>
<p>a numeric from 0 to 1 to define the threshold of missing data allowed</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_by">by</code></td>
<td>
<p>character defining if 'markers' or 'individuals' should be filtered</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)
  filt_obj &lt;- filter_missing(onemap_example_out, threshold=0.25)
 
</code></pre>

<hr>
<h2 id='filter_prob'>Function filter genotypes by genotype probability</h2><span id='topic+filter_prob'></span>

<h3>Description</h3>

<p>Function filter genotypes by genotype probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_prob(onemap.obj = NULL, threshold = 0.8, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_prob_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="filter_prob_+3A_threshold">threshold</code></td>
<td>
<p>a numeric from 0 to 1 to define the threshold for 
the probability of the called genotype (highest probability)</p>
</td></tr>
<tr><td><code id="filter_prob_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print tracing information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)
  filt_obj &lt;- filter_prob(onemap_example_out, threshold=0.8)
 
</code></pre>

<hr>
<h2 id='find_bins'>Allocate markers into bins</h2><span id='topic+find_bins'></span>

<h3>Description</h3>

<p>Function to allocate markers with redundant information into bins.
Within each bin, the pairwise recombination fraction between markers is zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_bins(input.obj, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_bins_+3A_input.obj">input.obj</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="find_bins_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code>, it only allocates markers with
the exact same information into bins, including missing data; if
<code>FALSE</code>, missing data are not considered when allocating markers.
In the latter case, the marker with the lowest amount of missing data is
taken as the representative marker on that bin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>onemap_bin</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>bins</code></td>
<td>
<p>a list containing the bins. Each element of
the list is a table whose lines indicate the name of the marker, the bin in
which that particular marker was allocated and the percentage of missing data.
The name of each element of the list corresponds to the marker with the lower
amount of missing data among those on the bin</p>
</td></tr><tr><td><code>n.mar</code></td>
<td>
<p>total number of markers.</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr> <tr><td><code>exact.search</code></td>
<td>
<p>logical; indicates if
the search was performed with the argument <code>exact=TRUE</code> or <code>exact=FALSE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_data_bins">create_data_bins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data("vcf_example_out")
  (bins&lt;-find_bins(vcf_example_out, exact=FALSE))



</code></pre>

<hr>
<h2 id='generate_overlapping_batches'>Function to divide the sequence in batches with user defined size</h2><span id='topic+generate_overlapping_batches'></span>

<h3>Description</h3>

<p>Function to divide the sequence in batches with user defined size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_overlapping_batches(input.seq, size = 50, overlap = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_overlapping_batches_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="generate_overlapping_batches_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="generate_overlapping_batches_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
</table>

<hr>
<h2 id='group'>Assign markers to linkage groups</h2><span id='topic+group'></span>

<h3>Description</h3>

<p>Identifies linkage groups of markers, using results from two-point
(pairwise) analysis and the <em>transitive</em> property of linkage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group(input.seq, LOD = NULL, max.rf = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="group_+3A_lod">LOD</code></td>
<td>
<p>a (positive) real number used as minimum LOD score
(threshold) to declare linkage.</p>
</td></tr>
<tr><td><code id="group_+3A_max.rf">max.rf</code></td>
<td>
<p>a real number (usually smaller than 0.5) used as
maximum recombination fraction to declare linkage.</p>
</td></tr>
<tr><td><code id="group_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, current progress is shown;
if <code>FALSE</code>, no output is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the arguments specifying thresholds used to group markers, i.e., minimum
LOD Score and maximum recombination fraction, are <code>NULL</code> (default),
the values used are those contained in object <code>input.seq</code>. If not
using <code>NULL</code>, the new values override the ones in object
<code>input.seq</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>group</code>, which is a list
containing the following components: </p>
<table>
<tr><td><code>data.name</code></td>
<td>
<p>name of
the object of class <code>onemap</code> that contains the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf.2ts</code>
used as input, i.e., containing information used to assign
markers to linkage groups.</p>
</td></tr> <tr><td><code>marnames</code></td>
<td>
<p>marker names,
according to the input file.</p>
</td></tr> <tr><td><code>n.mar</code></td>
<td>
<p>total number of
markers.</p>
</td></tr>  <tr><td><code>LOD</code></td>
<td>
<p>minimum LOD Score to declare linkage.</p>
</td></tr>
<tr><td><code>max.rf</code></td>
<td>
<p>maximum recombination fraction to declare
linkage.</p>
</td></tr> <tr><td><code>n.groups</code></td>
<td>
<p>number of linkage groups found.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>number of the linkage group to which each marker
is assigned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a> and
Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Lincoln, S. E., Daly, M. J. and Lander, E. S. (1993)
Constructing genetic linkage maps with MAPMAKER/EXP Version
3.0: a tutorial and reference manual. <em>A Whitehead
Institute for Biomedical Research Technical Report</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_2pts">rf_2pts</a></code> and
<code><a href="#topic+make_seq">make_seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)
  twopts &lt;- rf_2pts(onemap_example_out)

  all.data &lt;- make_seq(twopts,"all")
  link_gr &lt;- group(all.data)
  link_gr
  print(link_gr, details=FALSE) #omit the names of the markers

</code></pre>

<hr>
<h2 id='group_seq'>Assign markers to preexisting linkage groups</h2><span id='topic+group_seq'></span>

<h3>Description</h3>

<p>Identifies linkage groups of markers combining input <code>sequences</code> objects with
unlinked markers from <code>rf_2pts</code> object. The results from two-point
(pairwise) analysis and the <em>transitive</em> property of linkage are used for
grouping, as <code>group</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_seq(
  input.2pts,
  seqs = "CHROM",
  unlink.mks = "all",
  repeated = FALSE,
  LOD = NULL,
  max.rf = NULL,
  min_mks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_seq_+3A_input.2pts">input.2pts</code></td>
<td>
<p>an object of class <code>rf_2pts</code>.</p>
</td></tr>
<tr><td><code id="group_seq_+3A_seqs">seqs</code></td>
<td>
<p>a list of objects of class <code>sequence</code> or the string
&quot;CHROM&quot; if there is <code>CHROM</code> information available in the input
data file.</p>
</td></tr>
<tr><td><code id="group_seq_+3A_unlink.mks">unlink.mks</code></td>
<td>
<p>a object of class <code>sequence</code> with the number of
the markers to be grouped with the preexisting sequences defined by <code>seqs</code>
parameter. Using the string &quot;all&quot;, all remaining markers of
the <code>rf_2pts</code> object will be tested.</p>
</td></tr>
<tr><td><code id="group_seq_+3A_repeated">repeated</code></td>
<td>
<p>logical. If <code>TRUE</code>, markers grouped in more than
one of the sequences are kept in the output sequences. If <code>FALSE</code>,
they are removed of the output sequences.</p>
</td></tr>
<tr><td><code id="group_seq_+3A_lod">LOD</code></td>
<td>
<p>a (positive) real number used as minimum LOD score
(threshold) to declare linkage.</p>
</td></tr>
<tr><td><code id="group_seq_+3A_max.rf">max.rf</code></td>
<td>
<p>a real number (usually smaller than 0.5) used as
maximum recombination fraction to declare linkage.</p>
</td></tr>
<tr><td><code id="group_seq_+3A_min_mks">min_mks</code></td>
<td>
<p>integer defining the minimum number of markers that a provided 
sequence (seqs or CHROM) should have to be considered a group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the arguments specifying thresholds used to group markers, i.e., minimum
LOD Score and maximum recombination fraction, are <code>NULL</code> (default),
the values used are those contained in object <code>input.2pts</code>. If not
using <code>NULL</code>, the new values override the ones in object
<code>input.2pts</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>group_seq</code>, which is a list
containing the following components: </p>
<table>
<tr><td><code>data.name</code></td>
<td>
<p>name of
the object of class <code>onemap</code> that contains the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf.2ts</code>
used as input, i.e., containing information used to assign
markers to linkage groups.</p>
</td></tr> <tr><td><code>mk.names</code></td>
<td>
<p>marker names,
according to the input file.</p>
</td></tr> <tr><td><code>input.seqs</code></td>
<td>
<p>list with the numbers
of the markers in each inputted sequence</p>
</td></tr>  <tr><td><code>input.unlink.mks</code></td>
<td>
<p>numbers of
the unlinked markers in inputted sequence</p>
</td></tr> <tr><td><code>out.seqs</code></td>
<td>
<p>list with the
numbers of the markers in each outputted sequence</p>
</td></tr> <tr><td><code>n.unlinked</code></td>
<td>
<p>number
of markers that remained unlinked</p>
</td></tr> <tr><td><code>n.repeated</code></td>
<td>
<p>number of markers which
repeated in more than one group</p>
</td></tr> <tr><td><code>n.mar</code></td>
<td>
<p>total number of markers evaluated</p>
</td></tr>
<tr><td><code>LOD</code></td>
<td>
<p>minimum LOD Score to declare linkage.</p>
</td></tr> <tr><td><code>max.rf</code></td>
<td>
<p>maximum
recombination fraction to declare linkage.</p>
</td></tr> <tr><td><code>sequences</code></td>
<td>
<p>list of outputted
sequences</p>
</td></tr> <tr><td><code>repeated</code></td>
<td>
<p>list with the number of the markers that are repeated
in each outputted sequence</p>
</td></tr> <tr><td><code>unlinked</code></td>
<td>
<p>number of the markers which remained
unlinked</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code> and <code><a href="#topic+group">group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_out) # load OneMap's fake dataset for a outcrossing population
data(vcf_example_out) # load OneMap's fake dataset from a VCF file for a outcrossing population
comb_example &lt;- combine_onemap(onemap_example_out, vcf_example_out) # Combine datasets
twopts &lt;- rf_2pts(comb_example)

out_CHROM &lt;- group_seq(twopts, seqs="CHROM", repeated=FALSE)
out_CHROM

seq1 &lt;- make_seq(twopts, c(1,2,3,4,5,25,26))
seq2 &lt;- make_seq(twopts, c(8,18))
seq3 &lt;- make_seq(twopts, c(4,16,20,21,24,29))

out_seqs &lt;- group_seq(twopts, seqs=list(seq1,seq2,seq3))
out_seqs

</code></pre>

<hr>
<h2 id='group_upgma'>Assign markers to linkage groups</h2><span id='topic+group_upgma'></span>

<h3>Description</h3>

<p>Identifies linkage groups of markers using the results of two-point
(pairwise) analysis and UPGMA method. Function adapted from MAPpoly package
written by Marcelo Mollinari.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_upgma(input.seq, expected.groups = NULL, inter = TRUE, comp.mat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_upgma_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.rf.matrix</code></p>
</td></tr>
<tr><td><code id="group_upgma_+3A_expected.groups">expected.groups</code></td>
<td>
<p>when available, inform the number of expected 
linkage groups (i.e. chromosomes) for the species</p>
</td></tr>
<tr><td><code id="group_upgma_+3A_inter">inter</code></td>
<td>
<p>if <code>TRUE</code> (default), plots a dendrogram highlighting the
expected groups before continue</p>
</td></tr>
<tr><td><code id="group_upgma_+3A_comp.mat">comp.mat</code></td>
<td>
<p>if <code>TRUE</code>, shows a comparison between the reference
based and the linkage based grouping, if the sequence information is
available (default = FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>group</code>, which is a list
containing the following components:
</p>
<table>
<tr><td><code>data.name</code></td>
<td>
<p>the referred dataset name</p>
</td></tr>
<tr><td><code>hc.snp</code></td>
<td>
<p>a list containing information related to 
the UPGMA grouping method</p>
</td></tr>
<tr><td><code>expected.groups</code></td>
<td>
<p>the number of expected linkage groups</p>
</td></tr>
<tr><td><code>groups.snp</code></td>
<td>
<p>the groups to which each of the markers belong</p>
</td></tr>
<tr><td><code>seq.vs.grouped.snp</code></td>
<td>
<p>comparison between the genomic group information
(when available) and the groups provided by <code>group_upgma</code></p>
</td></tr>
<tr><td><code>LOD</code></td>
<td>
<p>minimum LOD Score to declare linkage.</p>
</td></tr> 
<tr><td><code>max.rf</code></td>
<td>
<p>maximum recombination fraction to declare linkage.</p>
</td></tr>
<tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf.2ts</code>
used as input, i.e., containing information used to assign
markers to linkage groups.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>
<p>Cristiane Taniguti <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
doi: <a href="https://doi.org/10.1534/g3.119.400378">10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data("vcf_example_out")
 twopts &lt;- rf_2pts(vcf_example_out)
 input.seq &lt;- make_seq(twopts, "all")
 lgs &lt;- group_upgma(input.seq, expected.groups = 3, comp.mat=TRUE, inter = FALSE)
 plot(lgs)

</code></pre>

<hr>
<h2 id='haldane'>Apply Haldane mapping function</h2><span id='topic+haldane'></span>

<h3>Description</h3>

<p>Apply Haldane mapping function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haldane(rcmb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haldane_+3A_rcmb">rcmb</code></td>
<td>
<p>vector of recombination fraction values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with centimorgan values
</p>

<hr>
<h2 id='keep_only_selected_mks'>Keep in the onemap and twopts object only markers in the sequences</h2><span id='topic+keep_only_selected_mks'></span>

<h3>Description</h3>

<p>Keep in the onemap and twopts object only markers in the sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_only_selected_mks(list.sequences = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_only_selected_mks_+3A_list.sequences">list.sequences</code></td>
<td>
<p>a list of objects 'sequence'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of objects 'sequences' with internal onemap and twopts objects reduced
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti
</p>

<hr>
<h2 id='kosambi'>Apply Kosambi mapping function</h2><span id='topic+kosambi'></span>

<h3>Description</h3>

<p>Apply Kosambi mapping function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kosambi(rcmb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kosambi_+3A_rcmb">rcmb</code></td>
<td>
<p>vector of recombination fraction values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with centimorgan values
</p>

<hr>
<h2 id='make_seq'>Create a sequence of markers based on other OneMap object types</h2><span id='topic+make_seq'></span>

<h3>Description</h3>

<p>Makes a sequence of markers based on an object of another type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_seq(input.obj, arg = NULL, phase = NULL, data.name = NULL, twopt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_seq_+3A_input.obj">input.obj</code></td>
<td>
<p>an object of class <code>onemap</code>, <code>rf_2pts</code>,
<code>group</code>, <code>compare</code>, <code>try</code> or <code>order</code>.</p>
</td></tr>
<tr><td><code id="make_seq_+3A_arg">arg</code></td>
<td>
<p>its value depends on the type of object <code>input.obj</code>. For
a <code>onemap</code> object, <code>arg</code> must be a string corresponding to one
of the reference sequences on which markers are anchored (usually
chromosomes). This requires that <code>CHROM</code> information be available in
the input data file. It can also be a <code>vector</code> of integers specifying
which markers comprise the sequence. For an object <code>rf_2pts</code>,
<code>arg</code> can be the string &quot;all&quot;, resulting in a sequence with all
markers in the raw data (generally done for grouping markers); otherwise,
it must be a <code>vector</code> of integers specifying which markers comprise
the sequence. For an object of class <code>group</code>, <code>arg</code> must be an
integer specifying the group. For a <code>compare</code> object, <code>arg</code> is
an integer indicating the corresponding order (arranged according to the
likelihood); if <code>NULL</code> (default), the best order is taken. For an
object of class <code>try</code>, <code>arg</code> must be an integer less than or
equal to the length of the original sequence plus one; the sequence
obtained will be that with the additional marker in the position indicated
by <code>arg</code>.  Finally, for an <code>order</code> object, <code>arg</code> is a
string: &quot;safe&quot; means the order that contains only markers mapped with the
provided threshold; &quot;force&quot; means the order with all markers.</p>
</td></tr>
<tr><td><code id="make_seq_+3A_phase">phase</code></td>
<td>
<p>its value is also dependent on the type of <code>input.obj</code>.
For an <code>rf_2pts</code> or <code>onemap</code> object, <code>phase</code> can be a
<code>vector</code> with user- defined linkage phases (its length is equal to the
number of markers minus one); if <code>NULL</code> (default), other functions will
try to find the best linkage phases. For example, if <code>phase</code> takes on
the vector <code>c(1,2,3,4)</code>, the sequence of linkage phases will be
coupling/coupling, coupling/repulsion, repulsion/coupling and
repulsion/repulsion for a sequence of five markers. If <code>input.obj</code> is
of class <code>compare</code> or <code>try</code>, this argument indicates which
combination of linkage phases should be chosen, for the particular order
given by argument <code>arg</code>. In both cases, <code>NULL</code> (default) makes the
best combination to be taken. If <code>input.obj</code> is of class, <code>group</code>, 
<code>group.upgma</code> or <code>order</code>, this argument has no effect.</p>
</td></tr>
<tr><td><code id="make_seq_+3A_data.name">data.name</code></td>
<td>
<p>the object which
contains the raw data. This does not have to be defined by the
user: it is here for compatibility issues when calling <code>make_seq</code> from
inside other functions.</p>
</td></tr>
<tr><td><code id="make_seq_+3A_twopt">twopt</code></td>
<td>
<p>the object which
contains the two-point information. This does not have to be defined by the
user: it is here for compatibility issues when calling <code>make_seq</code> from
inside other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a>
</p>


<h3>References</h3>

<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M.
J., Lincoln, S. E. and Newburg, L. (1987) MAPMAKER: An interactive computer
package for constructing primary genetic linkage maps of experimental and
natural populations. <em>Genomics</em> 1: 174-181.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare">compare</a></code>, <code><a href="#topic+try_seq">try_seq</a></code>,
<code><a href="#topic+order_seq">order_seq</a></code> and <code><a href="#topic+map">map</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)

  all_mark &lt;- make_seq(twopt,"all")
  all_mark &lt;- make_seq(twopt,1:30) # same as above, for this data set
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.ord &lt;- order_seq(LG1)
  (LG1.final &lt;- make_seq(LG1.ord)) # safe order
  (LG1.final.all &lt;- make_seq(LG1.ord,"force")) # forced order

  markers &lt;- make_seq(twopt,c(2,3,12,14))
  markers.comp &lt;- compare(markers)
  (base.map &lt;- make_seq(markers.comp))
  base.map &lt;- make_seq(markers.comp,1,1) # same as above
  (extend.map &lt;- try_seq(base.map,30))
  (base.map &lt;- make_seq(extend.map,5)) # fifth position is the best

</code></pre>

<hr>
<h2 id='map'>Construct the linkage map for a sequence of markers</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Estimates the multipoint log-likelihood, linkage phases and recombination
frequencies for a sequence of markers in a given order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(
  input.seq,
  tol = 1e-04,
  verbose = FALSE,
  rm_unlinked = FALSE,
  phase_cores = 1,
  parallelization.type = "PSOCK",
  global_error = NULL,
  genotypes_errors = NULL,
  genotypes_probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="map_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="map_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print tracing information.</p>
</td></tr>
<tr><td><code id="map_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and returns a vector with remaining 
marker numbers (useful for mds_onemap and map_avoid_unlinked functions).</p>
</td></tr>
<tr><td><code id="map_+3A_phase_cores">phase_cores</code></td>
<td>
<p>number of computer cores to be used in analysis</p>
</td></tr>
<tr><td><code id="map_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="map_+3A_global_error">global_error</code></td>
<td>
<p>single value to be considered as error probability in HMM emission function</p>
</td></tr>
<tr><td><code id="map_+3A_genotypes_errors">genotypes_errors</code></td>
<td>
<p>matrix individuals x markers with error values for each marker</p>
</td></tr>
<tr><td><code id="map_+3A_genotypes_probs">genotypes_probs</code></td>
<td>
<p>table containing the probability distribution for each combination of marker × individual. 
Each line on this table represents the combination of one marker with one individual, and the respective probabilities.
The table should contain four three columns (prob(AA), prob(AB) and prob(BB)) and individuals*markers rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Markers are mapped in the order defined in the object <code>input.seq</code>. If
this object also contains a user-defined combination of linkage phases,
recombination frequencies and log-likelihood are estimated for that
particular case. Otherwise, the best linkage phase combination is also
estimated. The multipoint likelihood is calculated according to Wu et al.
(2002b)(Eqs. 7a to 11), assuming that the recombination fraction is the
same in both parents. Hidden Markov chain codes adapted from Broman et al.
(2008) were used.
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adapted from Karl Broman (package 'qtl') by Gabriel R A Margarido,
<a href="mailto:gramarga@usp.br">gramarga@usp.br</a> and Marcelo Mollinari, <a href="mailto:mmollina@gmail.com">mmollina@gmail.com</a>,
with minor changes by Cristiane Taniguti and Bastian Schiffthaler
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>
<p>Jiang, C. and Zeng, Z.-B. (1997). Mapping quantitative trait loci with
dominant and missing markers in various crosses from two inbred lines.
<em>Genetica</em> 101: 47-58.
</p>
<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M. J., Lincoln,
S. E. and Newburg, L. (1987) MAPMAKER: An interactive computer package for
constructing primary genetic linkage maps of experimental and natural
populations. <em>Genomics</em> 1: 174-181.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage mapping of
sex-specific differences. <em>Genetical Research</em> 79: 85-96
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)

  markers &lt;- make_seq(twopt,c(30,12,3,14,2)) # correct phases
  map(markers)

  markers &lt;- make_seq(twopt,c(30,12,3,14,2),phase=c(4,1,4,3)) # incorrect phases
  map(markers)
  
</code></pre>

<hr>
<h2 id='map_avoid_unlinked'>Repeat HMM if map find unlinked marker</h2><span id='topic+map_avoid_unlinked'></span>

<h3>Description</h3>

<p>Repeat HMM if map find unlinked marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_avoid_unlinked(
  input.seq,
  size = NULL,
  overlap = NULL,
  phase_cores = 1,
  tol = 1e-04,
  parallelization.type = "PSOCK",
  max.gap = FALSE,
  global_error = NULL,
  genotypes_errors = NULL,
  genotypes_probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_avoid_unlinked_+3A_input.seq">input.seq</code></td>
<td>
<p>object of class sequence</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_max.gap">max.gap</code></td>
<td>
<p>the marker will be removed if it have gaps higher than this defined threshold in both sides</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_global_error">global_error</code></td>
<td>
<p>single value to be considered as error probability in HMM emission function</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_genotypes_errors">genotypes_errors</code></td>
<td>
<p>matrix individuals x markers with error values for each marker</p>
</td></tr>
<tr><td><code id="map_avoid_unlinked_+3A_genotypes_probs">genotypes_probs</code></td>
<td>
<p>table containing the probability distribution for each combination of marker × individual. 
Each line on this table represents the combination of one marker with one individual, and the respective probabilities.
The table should contain four three columns (prob(AA), prob(AB) and prob(BB)) and individuals*markers rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)

  markers &lt;- make_seq(twopt,c(30,12,3,14,2)) # correct phases
  map_avoid_unlinked(markers)

  markers &lt;- make_seq(twopt,c(30,12,3,14,2),phase=c(4,1,4,3)) # incorrect phases
  map_avoid_unlinked(markers)

   
</code></pre>

<hr>
<h2 id='map_overlapping_batches'>Mapping overlapping batches</h2><span id='topic+map_overlapping_batches'></span>

<h3>Description</h3>

<p>Apply the batch mapping algorithm using overlapping windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_overlapping_batches(
  input.seq,
  size = 50,
  overlap = 15,
  phase_cores = 1,
  verbose = FALSE,
  seeds = NULL,
  tol = 1e-04,
  rm_unlinked = TRUE,
  max.gap = FALSE,
  parallelization.type = "PSOCK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_overlapping_batches_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE its output progress status
information.</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_seeds">seeds</code></td>
<td>
<p>A vector of phase information used as seeds for the first
batch</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and map is performed again.</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_max.gap">max.gap</code></td>
<td>
<p>the marker will be removed if it have gaps higher than this defined threshold in both sides</p>
</td></tr>
<tr><td><code id="map_overlapping_batches_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm implements the overlapping batch maps for high density
marker sets. The mapping problem is reduced to a number of subsets (batches)
which carry information forward in order to more accurately estimate
recombination fractions and phasing. It is a adapted version of
map.overlapping.batches function of BatchMap package. The main differences are
that this onemap version do not have the option to reorder the markers 
according to ripple algorithm and, if the it finds markers that do not reach the linkage
criterias, the algorithm remove the problematic marker and repeat the analysis.
Than, the output map can have few markers compared with the input.seq.
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>outcross</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf.2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pick_batch_sizes">pick_batch_sizes</a></code>, <code><a href="#topic+map">map</a></code>
</p>

<hr>
<h2 id='map_save_ram'>Perform map using background objects with only selected markers. It saves ram memory during the procedure.
It is useful if dealing with many markers in total data set.</h2><span id='topic+map_save_ram'></span>

<h3>Description</h3>

<p>Perform map using background objects with only selected markers. It saves ram memory during the procedure.
It is useful if dealing with many markers in total data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_save_ram(
  input.seq,
  tol = 1e-04,
  verbose = FALSE,
  rm_unlinked = FALSE,
  phase_cores = 1,
  size = NULL,
  overlap = NULL,
  parallelization.type = "PSOCK",
  max.gap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_save_ram_+3A_input.seq">input.seq</code></td>
<td>
<p>object of class sequence</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print tracing information.</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and returns a vector with remaining 
marker numbers (useful for mds_onemap and map_avoid_unlinked functions).</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="map_save_ram_+3A_max.gap">max.gap</code></td>
<td>
<p>the marker will be removed if it have gaps higher than this defined threshold in both sides</p>
</td></tr>
</table>

<hr>
<h2 id='mapmaker_example_f2'>
Simulated data from a F2 population
</h2><span id='topic+mapmaker_example_f2'></span>

<h3>Description</h3>

<p>Simulated data set from a F2 population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mapmaker_example_f2")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 8
$ geno         : num [1:200, 1:66] 1 3 2 2 1 0 3 1 1 3 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : NULL
.. ..$ : chr [1:66] &quot;M1&quot; &quot;M2&quot; &quot;M3&quot; &quot;M4&quot; ...
$ n.ind        : num 200
$ n.mar        : num 66
$ segr.type    : chr [1:66] &quot;A.H.B&quot; &quot;C.A&quot; &quot;D.B&quot; &quot;C.A&quot; ...
$ segr.type.num: num [1:66] 1 3 2 3 3 2 1 3 2 1 ...
$ input        : chr &quot;/home/cristiane/R/x86_64-pc-linux-gnu-library/3.4/onemap/extdata/mapmaker_example_f2.raw&quot;
$ n.phe        : num 1
$ pheno        : num [1:200, 1] 37.6 36.4 37.2 35.8 37.1 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : NULL
.. ..$ : chr &quot;Trait_1&quot;
- attr(*, &quot;class&quot;)= chr [1:2] &quot;onemap&quot; &quot;f2&quot;
</p>


<h3>Details</h3>

<p>A total of 200 individuals were genotyped for 66 markers (36
co-dominant, i.e. a, ab or b and 30 dominant i.e. c or a and d or b) with 15% of missing data. 
There is one quantitative phenotype to show how
to use <code>onemap</code> output as <code>R\qtl</code> and <code>QTL Cartographer</code> input. Also, it is used
for the analysis in the tutorial that comes with OneMap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mapmaker_example_f2)

# perform two-point analyses
twopts &lt;- rf_2pts(mapmaker_example_f2)
twopts
</code></pre>

<hr>
<h2 id='marker_type'>Informs the segregation patterns of markers</h2><span id='topic+marker_type'></span>

<h3>Description</h3>

<p>Informs the type of segregation of all markers from an object of class
<code>sequence</code>. For outcross populations it uses the notation by <cite>Wu
et al., 2002</cite>. For backcrosses, F2s and RILs, it uses the
traditional notation from MAPMAKER i.e. AA, AB, BB, not AA and not BB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker_type(input.seq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker_type_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The segregation types are (<cite>Wu et al., 2002</cite>): </p>

<table>
<tr>
 <td style="text-align: left;"> Type
</td><td style="text-align: center;"> Cross </td><td style="text-align: center;"> Segregation </td>
</tr>
<tr>
 <td style="text-align: left;"> A.1 </td><td style="text-align: center;"> ab x cd </td><td style="text-align: center;"> 1:1:1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> A.2 </td><td style="text-align: center;">
ab x ac </td><td style="text-align: center;"> 1:1:1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> A.3 </td><td style="text-align: center;"> ab x co </td><td style="text-align: center;"> 1:1:1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> A.4 </td><td style="text-align: center;"> ao x bo
</td><td style="text-align: center;"> 1:1:1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> B1.5 </td><td style="text-align: center;"> ab x ao </td><td style="text-align: center;"> 1:2:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> B2.6 </td><td style="text-align: center;"> ao x ab </td><td style="text-align: center;">
1:2:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> B3.7 </td><td style="text-align: center;"> ab x ab </td><td style="text-align: center;"> 1:2:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> C8 </td><td style="text-align: center;"> ao x ao </td><td style="text-align: center;"> 3:1 </td>
</tr>
<tr>
 <td style="text-align: left;">
D1.9 </td><td style="text-align: center;"> ab x cc </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D1.10 </td><td style="text-align: center;"> ab x aa </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D1.11 </td><td style="text-align: center;">
ab x oo </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D1.12 </td><td style="text-align: center;"> bo x aa </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D1.13 </td><td style="text-align: center;"> ao x oo
</td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D2.14 </td><td style="text-align: center;"> cc x ab </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D2.15 </td><td style="text-align: center;"> aa x ab </td><td style="text-align: center;"> 1:1
</td>
</tr>
<tr>
 <td style="text-align: left;"> D2.16 </td><td style="text-align: center;"> oo x ab </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D2.17 </td><td style="text-align: center;"> aa x bo </td><td style="text-align: center;"> 1:1 </td>
</tr>
<tr>
 <td style="text-align: left;"> D2.18
</td><td style="text-align: center;"> oo x ao </td><td style="text-align: center;"> 1:1 </td>
</tr>

</table>



<h3>Value</h3>

<p>data.frame with segregation types of all markers in the
sequence are displayed on the screen.
</p>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a>
</p>


<h3>References</h3>

<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002)
Simultaneous maximum likelihood estimation of linkage and linkage phases in
outcrossing species. <em>Theoretical Population Biology</em> 61: 349-363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(onemap_example_out)
 twopts &lt;- rf_2pts(onemap_example_out)
 markers.ex &lt;- make_seq(twopts,c(3,6,8,12,16,25))
 marker_type(input.seq = markers.ex) # segregation type for some markers

 data(onemap_example_f2)
 twopts &lt;- rf_2pts(onemap_example_f2)
 all_mrk&lt;-make_seq(twopts, "all")
 lgs&lt;-group(all_mrk)
 lg1&lt;-make_seq(lgs,1)
 marker_type(lg1) # segregation type for linkage group 1

</code></pre>

<hr>
<h2 id='mds_onemap'>OneMap interface with MDSMap package with option for multipoint distances estimation</h2><span id='topic+mds_onemap'></span>

<h3>Description</h3>

<p>For a given sequence of markers, apply mds method described in Preedy and Hackett (2016)
using MDSMap package to ordering markers and estimates the genetic distances with OneMap
multipoint approach. Also gives MDSMap input file format for directly analysis in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mds_onemap(
  input.seq,
  out.file = NULL,
  p = NULL,
  ispc = TRUE,
  displaytext = FALSE,
  weightfn = "lod2",
  mapfn = "haldane",
  ndim = 2,
  rm_unlinked = TRUE,
  size = NULL,
  overlap = NULL,
  phase_cores = 1,
  tol = 1e-05,
  hmm = TRUE,
  parallelization.type = "PSOCK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mds_onemap_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code></p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_out.file">out.file</code></td>
<td>
<p>path to the generated MDSMap input file.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_p">p</code></td>
<td>
<p>Integer - the penalty for deviations from the sphere - higher p
forces points more closely onto a sphere.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_ispc">ispc</code></td>
<td>
<p>Logical determining the method to be used to estimate the map. By default 
this is TRUE and the method of principal curves will be used. If FALSE then the 
constrained MDS method will be used.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_displaytext">displaytext</code></td>
<td>
<p>Shows markers names in analysis graphic view</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_weightfn">weightfn</code></td>
<td>
<p>Character string specifying the values to use for the weight
matrix in the MDS 'lod2' or 'lod'.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_mapfn">mapfn</code></td>
<td>
<p>Character string specifying the map function to use on the
recombination fractions 'haldane' is default, 'kosambi' or 'none'.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions to be considered in the multidimensional scaling procedure (default = 2)</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and mds is performed again.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_hmm">hmm</code></td>
<td>
<p>logical defining if the HMM must be applied to estimate multipoint
genetic distances</p>
</td></tr>
<tr><td><code id="mds_onemap_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For better description about MDS method, see MDSMap package vignette.
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>References</h3>

<p>Preedy, K. F.  and  Hackett, C. A.  (2016). A rapid marker ordering approach for high-density
genetic linkage maps in experimental autotetraploid populations using multidimensional
scaling. <em>Theoretical and Applied Genetics</em> 129: 2117-2132
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia, A. A. F.
(2009) Evaluation of algorithms used to order markers on genetics maps.
<em>Heredity</em> 103: 494-502.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage mapping of
sex-specific differences. <em>Genetical Research</em> 79: 85-96
</p>


<h3>See Also</h3>

<p><a href="https://CRAN.R-project.org/package=MDSMap">https://CRAN.R-project.org/package=MDSMap</a>.
</p>

<hr>
<h2 id='onemap_example_bc'>Simulated data from a backcross population</h2><span id='topic+onemap_example_bc'></span>

<h3>Description</h3>

<p>Simulated data set from a backcross population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(onemap_example_bc)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 10
$ geno         : num [1:150, 1:67] 1 2 1 1 2 1 2 1 1 2 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:150] &quot;ID1&quot; &quot;ID2&quot; &quot;ID3&quot; &quot;ID4&quot; ...
.. ..$ : chr [1:67] &quot;M1&quot; &quot;M2&quot; &quot;M3&quot; &quot;M4&quot; ...
$ n.ind        : int 150
$ n.mar        : int 67
$ segr.type    : chr [1:67] &quot;A.H&quot; &quot;A.H&quot; &quot;A.H&quot; &quot;A.H&quot; ...
$ segr.type.num: logi [1:67] NA NA NA NA NA NA ...
$ n.phe        : int 1
$ pheno        : num [1:150, 1] 40.8 39.5 37.9 34.2 38.9 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : NULL
.. ..$ : chr &quot;Trait_1&quot;
$ CHROM        : NULL
$ POS          : NULL
$ input        : chr &quot;onemap_example_bc.raw&quot;
- attr(*, &quot;class&quot;)= chr [1:2] &quot;onemap&quot; &quot;backcross&quot;
</p>


<h3>Details</h3>

<p>A total of 150 individuals were genotyped for 67 markers with 15% of
missing data. There is one quantitative phenotype to show how
to use <code>onemap</code> output as <code>R\qtl</code> input.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> and <code><a href="#topic+read_mapmaker">read_mapmaker</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(onemap_example_bc)

# perform two-point analyses
twopts &lt;- rf_2pts(onemap_example_bc)
twopts
</code></pre>

<hr>
<h2 id='onemap_example_f2'>
Simulated data from a F2 population
</h2><span id='topic+onemap_example_f2'></span>

<h3>Description</h3>

<p>Simulated data set from a F2 population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("onemap_example_f2")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 10
$ geno         : num [1:200, 1:66] 1 3 2 2 1 0 3 1 1 3 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:200] &quot;IND1&quot; &quot;IND2&quot; &quot;IND3&quot; &quot;IND4&quot; ...
.. ..$ : chr [1:66] &quot;M1&quot; &quot;M2&quot; &quot;M3&quot; &quot;M4&quot; ...
$ n.ind        : int 200
$ n.mar        : int 66
$ segr.type    : chr [1:66] &quot;A.H.B&quot; &quot;C.A&quot; &quot;D.B&quot; &quot;C.A&quot; ...
$ segr.type.num: num [1:66] 1 3 2 3 3 2 1 3 2 1 ...
$ n.phe        : int 1
$ pheno        : num [1:200, 1] 37.6 36.4 37.2 35.8 37.1 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : NULL
.. ..$ : chr &quot;Trait_1&quot;
$ CHROM        : NULL
$ POS          : NULL
$ input        : chr &quot;/home/cristiane/R/x86_64-pc-linux-gnu-library/3.4/onemap/extdata/onemap_example_f2.raw&quot;
- attr(*, &quot;class&quot;)= chr [1:2] &quot;onemap&quot; &quot;f2&quot;
</p>


<h3>Details</h3>

<p>A total of 200 individuals were genotyped for 66 markers (36
co-dominant, i.e. a, ab or b and 30 dominant i.e. c or a and d or b) with 15% of missing data. 
There is one quantitative phenotype to show how
to use <code>onemap</code> output as <code>R\qtl</code> and <code>QTL Cartographer</code> input. Also, it is used
for the analysis in the tutorial that comes with OneMap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(onemap_example_f2)
plot(onemap_example_f2)
</code></pre>

<hr>
<h2 id='onemap_example_out'>Data from a full-sib family derived from two outbred parents</h2><span id='topic+onemap_example_out'></span>

<h3>Description</h3>

<p>Simulated data set for an outcross, i.e., an F1 population obtained by
crossing two non-homozygous parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(onemap_example_out)</code></pre>


<h3>Format</h3>

<p>An object of class <code>onemap</code>.
</p>


<h3>Details</h3>

<p>A total of 100 F1 individuals were genotyped for 30 markers. The data
currently contains only genotype information (no phenotypes). It is
included to be used as a reference in order to understand how a data
file needs to be. Also, it is used for the analysis in the tutorial
that comes with OneMap.
</p>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> for details about objects of class
<code>onemap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(onemap_example_out)

# perform two-point analyses
twopts &lt;- rf_2pts(onemap_example_out)
twopts
</code></pre>

<hr>
<h2 id='onemap_example_riself'>
Simulated data from a RIL population produced by selfing.
</h2><span id='topic+onemap_example_riself'></span>

<h3>Description</h3>

<p>Simulated biallelic data set for an <code>ri self</code> population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("onemap_example_riself")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 10
$ geno         : num [1:100, 1:68] 3 1 3 1 1 1 1 1 1 1 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:100] &quot;ID1&quot; &quot;ID2&quot; &quot;ID3&quot; &quot;ID4&quot; ...
.. ..$ : chr [1:68] &quot;M1&quot; &quot;M2&quot; &quot;M3&quot; &quot;M4&quot; ...
$ n.ind        : int 100
$ n.mar        : int 68
$ segr.type    : chr [1:68] &quot;A.B&quot; &quot;A.B&quot; &quot;A.B&quot; &quot;A.B&quot; ...
$ segr.type.num: logi [1:68] NA NA NA NA NA NA ...
$ n.phe        : int 0
$ pheno        : NULL
$ CHROM        : NULL
$ POS          : NULL
$ input        : chr &quot;onemap_example_riself.raw&quot;
- attr(*, &quot;class&quot;)= chr [1:2] &quot;onemap&quot; &quot;riself&quot;
</p>


<h3>Details</h3>

<p>A total of 100 F1 individuals were genotyped for 68 markers. The data
currently contains only genotype information (no phenotypes). It is
included to be used as a reference in order to understand how a data
file needs to be. 
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@usp.br">chtaniguti@usp.br</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> for details about objects of class
<code>onemap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(onemap_example_riself)
plot(onemap_example_riself)
</code></pre>

<hr>
<h2 id='onemap_read_vcfR'>Convert vcf file to onemap object</h2><span id='topic+onemap_read_vcfR'></span>

<h3>Description</h3>

<p>Converts data from a vcf file to onemap initial object, while identify 
the appropriate marker segregation patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onemap_read_vcfR(
  vcf = NULL,
  vcfR.object = NULL,
  cross = c("outcross", "f2 intercross", "f2 backcross", "ri self", "ri sib"),
  parent1 = NULL,
  parent2 = NULL,
  f1 = NULL,
  only_biallelic = TRUE,
  output_info_rds = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onemap_read_vcfR_+3A_vcf">vcf</code></td>
<td>
<p>string defining the path to VCF file;</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_vcfr.object">vcfR.object</code></td>
<td>
<p>object of class vcfR;</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_cross">cross</code></td>
<td>
<p>type of cross. Must be one of: <code>"outcross"</code> for full-sibs;
<code>"f2 intercross"</code> for an F2 intercross progeny; <code>"f2 backcross"</code>;
<code>"ri self"</code> for recombinant inbred lines by self-mating; or
<code>"ri sib"</code> for recombinant inbred lines by sib-mating.</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_parent1">parent1</code></td>
<td>
<p><code>string</code> specifying sample ID of the first parent. If f2 backcross population, define here the ID of the backcrossed parent.</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_parent2">parent2</code></td>
<td>
<p><code>string</code> specifying sample ID of the second parent.</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_f1">f1</code></td>
<td>
<p><code>string</code> if you are working with f2 intercross or backcross populations you may have f1 parents in you vcf, specify its ID here</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_only_biallelic">only_biallelic</code></td>
<td>
<p>if TRUE (default) only biallelic markers are considered, if FALSE multiallelic markers are included.</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_output_info_rds">output_info_rds</code></td>
<td>
<p>define a name for the file with alleles information.</p>
</td></tr>
<tr><td><code id="onemap_read_vcfR_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only biallelic SNPs and indels for diploid variant sites are considered.
</p>
<p>Genotype information on the parents is required for all cross types. For
full-sib progenies, both outbred parents must be genotyped. For backcrosses,
F2 intercrosses and recombinant inbred lines, the <em>original inbred
lines</em> must be genotyped. Particularly for backcross progenies, the
<em>recurrent line must be provided as the first parent</em> in the function
arguments.
</p>
<p>Marker type is determined based on parental genotypes. Variants for which parent
genotypes cannot be determined are discarded.
</p>
<p>Reference sequence ID and position for each variant site are also stored.
</p>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>See Also</h3>

<p><code>read_onemap</code> for a description of the output object of class onemap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- onemap_read_vcfR(vcf=system.file("extdata/vcf_example_out.vcf.gz", package = "onemap"),
                 cross="outcross",
                 parent1=c("P1"),
                 parent2=c("P2"))

                
</code></pre>

<hr>
<h2 id='order_seq'>Search for the best order of markers combining compare and try_seq
functions</h2><span id='topic+order_seq'></span>

<h3>Description</h3>

<p>For a given sequence of markers, this function first uses the
<code>compare</code> function to create a framework for a subset of informative
markers. Then, it tries to map remaining ones using the <code>try_seq</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_seq(
  input.seq,
  n.init = 5,
  subset.search = c("twopt", "sample"),
  subset.n.try = 30,
  subset.THRES = 3,
  twopt.alg = c("rec", "rcd", "ser", "ug"),
  THRES = 3,
  touchdown = FALSE,
  tol = 0.1,
  rm_unlinked = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_seq_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_n.init">n.init</code></td>
<td>
<p>the number of markers to be used in the <code>compare</code> step
(defaults to 5).</p>
</td></tr>
<tr><td><code id="order_seq_+3A_subset.search">subset.search</code></td>
<td>
<p>a character string indicating which method should be
used to search for a subset of informative markers for the
<code><a href="#topic+compare">compare</a></code> step. It is used for backcross, <code class="reqn">F_2</code> or RIL
populations, but not for outcrosses. See the <code>Details</code> section.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_subset.n.try">subset.n.try</code></td>
<td>
<p>integer. The number of times to repeat the subset
search procedure. It is only used if <code>subset.search=="sample"</code>. See
the <code>Details</code> section.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_subset.thres">subset.THRES</code></td>
<td>
<p>numerical. The threshold for the subset search
procedure. It is only used if <code>subset.search=="sample"</code>. See the
<code>Details</code> section.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_twopt.alg">twopt.alg</code></td>
<td>
<p>a character string indicating which two-point algorithm
should be used if <code>subset.search=="twopt"</code>. See the <code>Details</code>
section.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_thres">THRES</code></td>
<td>
<p>threshold to be used when positioning markers in the
<code>try_seq</code> step.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_touchdown">touchdown</code></td>
<td>
<p>logical. If <code>FALSE</code> (default), the <code>try_seq</code>
step is run only once, with the value of <code>THRES</code>. If <code>TRUE</code>,
<code>try_seq</code> runs with <code>THRES</code> and then once more, with
<code>THRES-1</code>. The latter calculations take longer, but usually are able
to map more markers.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_tol">tol</code></td>
<td>
<p>tolerance number for the C routine, i.e., the value used to
evaluate convergence of the EM algorithm.</p>
</td></tr>
<tr><td><code id="order_seq_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and returns a vector with remaining 
marker numbers (useful for mds_onemap and map_avoid_unlinked functions).</p>
</td></tr>
<tr><td><code id="order_seq_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE its output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For outcrossing populations, the initial subset and the order in which
remaining markers will be used in the <code>try_seq</code> step is given by the
degree of informativeness of markers (i.e markers of type A, B, C and D, in
this order).
</p>
<p>For backcrosses, F2s or RILs, two methods can be used for
choosing the initial subset: i) <code>"sample"</code> randomly chooses a number
of markers, indicated by <code>n.init</code>, and calculates the multipoint
log-likelihood of the <code class="reqn">\frac{n.init!}{2}</code> possible orders.
If the LOD Score of the second best order is greater than
<code>subset.THRES</code>, than it takes the best order to proceed with the
<code>try_seq</code> step. If not, the procedure is repeated. The maximum number
of times to repeat this procedure is given by the <code>subset.n.try</code>
argument. ii) <code>"twopt"</code> uses a two-point based algorithm, given by the
option <code>"twopt.alg"</code>, to construct a two-point based map. The options
are <code>"rec"</code> for RECORD algorithm, <code>"rcd"</code> for Rapid Chain
Delineation, <code>"ser"</code> for Seriation and <code>"ug"</code> for Unidirectional
Growth. Then, equally spaced markers are taken from this map. The
<code>"compare"</code> step will then be applied on this subset of markers.
</p>
<p>In both cases, the order in which the other markers will be used in the
<code>try_seq</code> step is given by marker types (i.e. co-dominant before
dominant) and by the missing information on each marker.
</p>
<p>After running the <code>compare</code> and <code>try_seq</code> steps, which result in
a &quot;safe&quot; order, markers that could not be mapped are &quot;forced&quot; into the map,
resulting in a map with all markers positioned.
</p>


<h3>Value</h3>

<p>An object of class <code>order</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>ord</code></td>
<td>
<p>an object of class <code>sequence</code>
containing the &quot;safe&quot; order.</p>
</td></tr> <tr><td><code>mrk.unpos</code></td>
<td>
<p>a <code>vector</code> with
unpositioned markers (if they exist).</p>
</td></tr> <tr><td><code>LOD.unpos</code></td>
<td>
<p>a <code>matrix</code>
with LOD-Scores for unmapped markers, if any, for each position in the
&quot;safe&quot; order.</p>
</td></tr> <tr><td><code>THRES</code></td>
<td>
<p>the same as the input value, just for
printing.</p>
</td></tr> <tr><td><code>ord.all</code></td>
<td>
<p>an object of class <code>sequence</code> containing the
&quot;forced&quot; order, i.e., the best order with all markers.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@usp.br">gramarga@usp.br</a> and Marcelo
Mollinari, <a href="mailto:mmollina@gmail.com">mmollina@gmail.com</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>
<p>Jiang, C. and Zeng, Z.-B. (1997). Mapping quantitative trait loci with
dominant and missing markers in various crosses from two inbred lines.
<em>Genetica</em> 101: 47-58.
</p>
<p>Lander, E. S. and Green, P. (1987). Construction of multilocus genetic
linkage maps in humans. <em>Proc. Natl. Acad. Sci. USA</em> 84: 2363-2367.
</p>
<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M. J., Lincoln,
S. E. and Newburg, L. (1987) MAPMAKER: An interactive computer package for
constructing primary genetic linkage maps of experimental and natural
populations. <em>Genomics</em> 1: 174-181.
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia, A. A. F.
(2009) Evaluation of algorithms used to order markers on genetics maps.
<em>Heredity</em> 103: 494-502.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage mapping of
sex-specific differences. <em>Genetical Research</em> 79: 85-96
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>, <code><a href="#topic+compare">compare</a></code> and
<code><a href="#topic+try_seq">try_seq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG2 &lt;- make_seq(groups,2)
  LG2.ord &lt;- order_seq(LG2,touchdown=TRUE)
  LG2.ord
  make_seq(LG2.ord) # get safe sequence
  make_seq(LG2.ord,"force") # get forced sequence


</code></pre>

<hr>
<h2 id='parents_haplotypes'>Generates data.frame with parents estimated haplotypes</h2><span id='topic+parents_haplotypes'></span>

<h3>Description</h3>

<p>Generates data.frame with parents estimated haplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parents_haplotypes(..., group_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parents_haplotypes_+3A_...">...</code></td>
<td>
<p>objects of class sequence</p>
</td></tr>
<tr><td><code id="parents_haplotypes_+3A_group_names">group_names</code></td>
<td>
<p>vector of characters defining the group names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with group ID (group), marker number (mk.number) 
and names (mk.names), position in centimorgan (dist) and parents haplotypes 
(P1_1, P1_2, P2_1, P2_2)
</p>


<h3>Author(s)</h3>

<p>Getulio Caixeta Ferreira, <a href="mailto:getulio.caifer@gmail.com">getulio.caifer@gmail.com</a>
</p>
<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("onemap_example_out")
twopts &lt;- rf_2pts(onemap_example_out)
lg1 &lt;- make_seq(twopts, 1:5)
lg1.map &lt;- map(lg1)
parents_haplotypes(lg1.map)

</code></pre>

<hr>
<h2 id='pick_batch_sizes'>Picking optimal batch size values</h2><span id='topic+pick_batch_sizes'></span>

<h3>Description</h3>

<p>Suggest an optimal batch size value for use in
<code><a href="#topic+map_overlapping_batches">map_overlapping_batches</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_batch_sizes(input.seq, size = 50, overlap = 15, around = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_batch_sizes_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="pick_batch_sizes_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="pick_batch_sizes_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="pick_batch_sizes_+3A_around">around</code></td>
<td>
<p>The range around the center which is maximally allowed
to be searched.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer value for the size which most evenly divides batches. In
case of ties, bigger batch sizes are preferred.
</p>


<h3>Author(s)</h3>

<p>Bastian Schiffthaler, <a href="mailto:bastian.schiffthaler@umu.se">bastian.schiffthaler@umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map_overlapping_batches">map_overlapping_batches</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  LG &lt;- structure(list(seq.num = seq(1,800)), class = "sequence")
  batchsize &lt;- pick_batch_sizes(LG, 50, 19)

</code></pre>

<hr>
<h2 id='plot_by_segreg_type'>Draw a graphic showing the number of markers of each segregation pattern.</h2><span id='topic+plot_by_segreg_type'></span>

<h3>Description</h3>

<p>The function receives an object of class <code>onemap</code>.
For outcrossing populations, it can show detailed information (all 18 possible categories),
or a simplified version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_by_segreg_type(x, subcateg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_by_segreg_type_+3A_x">x</code></td>
<td>
<p>an object of class <code>onemap</code></p>
</td></tr>
<tr><td><code id="plot_by_segreg_type_+3A_subcateg">subcateg</code></td>
<td>
<p>a TRUE/FALSE option to indicate if results will be plotted showing
all possible categories (only for outcrossing populations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot graphic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_out) #Outcrossing data
plot_by_segreg_type(onemap_example_out)
plot_by_segreg_type(onemap_example_out, subcateg=FALSE)

data(onemap_example_bc)
plot_by_segreg_type(onemap_example_bc)

data(mapmaker_example_f2)
plot_by_segreg_type(mapmaker_example_f2)


</code></pre>

<hr>
<h2 id='plot.group.upgma'>Show the results of grouping procedure</h2><span id='topic+plot.group.upgma'></span>

<h3>Description</h3>

<p>It shows the linkage groups as well as the unlinked markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'group.upgma'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.group.upgma_+3A_x">x</code></td>
<td>
<p>an object of class group.upgma</p>
</td></tr>
<tr><td><code id="plot.group.upgma_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='plot.onemap'>Draw a graphic of raw data for any OneMap population</h2><span id='topic+plot.onemap'></span>

<h3>Description</h3>

<p>Shows a heatmap (in ggplot2, a graphic of geom &quot;tile&quot;) for raw data.
Lines correspond to markers and columns to individuals.
The function can plot a graph for all marker types, depending of the cross type (dominant/codominant markers, in all combinations).
The function receives a onemap object of class <code>onemap</code>, reads information
from genotypes from this object, converts it to a long dataframe format
using function melt() from package reshape2() or internal function create_dataframe_for_plot_outcross(), converts numbers from the object
to genetic notation (according to the cross type), then plots the graphic.
If there is more than 20 markers, removes y labels
For outcross populations, it can show all markers together, or it can split them according the segregation
pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap'
plot(x, all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.onemap_+3A_x">x</code></td>
<td>
<p>an object of class <code>onemap</code>, with data and additional information</p>
</td></tr>
<tr><td><code id="plot.onemap_+3A_all">all</code></td>
<td>
<p>a TRUE/FALSE option to indicate if results will be
plotted together (if TRUE) or splitted based on their
segregation pattern. Only used for outcross populations.</p>
</td></tr>
<tr><td><code id="plot.onemap_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot graphic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# library(ggplot2)
data(onemap_example_bc) # Loads a fake backcross dataset installed with onemap
plot(onemap_example_bc) # This will show you the graph

# You can store the graphic in an object, then save it with a number of properties
# For details, see the help of ggplot2's function ggsave()
g &lt;- plot(onemap_example_bc)

data(onemap_example_f2) # Loads a fake backcross dataset installed with onemap
plot(onemap_example_f2) # This will show you the graph

# You can store the graphic in an object, then save it with a number of properties
# For details, see the help of ggplot2's function ggsave()
g &lt;- plot(onemap_example_f2)

data(onemap_example_out) # Loads a fake full-sib dataset installed with onemap
plot(onemap_example_out) # This will show you the graph for all markers
plot(onemap_example_out, all=FALSE) # This will show you the graph splitted for marker types

# You can store the graphic in an object, then save it.
# For details, see the help of ggplot2's function ggsave()
g &lt;- plot(onemap_example_out, all=FALSE)


</code></pre>

<hr>
<h2 id='plot.onemap_progeny_haplotypes'>Plots progeny haplotypes</h2><span id='topic+plot.onemap_progeny_haplotypes'></span>

<h3>Description</h3>

<p>Figure is generated with the haplotypes for each selected individual. As a representation, the recombination breakpoints are here considered 
to be in the mean point of the distance between two markers.  It is important to highlight that it did not reflects the exact breakpoint position, 
specially if the genetic map have low resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap_progeny_haplotypes'
plot(
  x,
  col = NULL,
  position = "stack",
  show_markers = TRUE,
  main = "Genotypes",
  ncol = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_x">x</code></td>
<td>
<p>object of class onemap_progeny_haplotypes</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_col">col</code></td>
<td>
<p>Color of parents' homologous.</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_position">position</code></td>
<td>
<p>&quot;split&quot; or &quot;stack&quot;; if &quot;split&quot; (default) the alleles' are plotted separately. if &quot;stack&quot; the parents' alleles are plotted together.</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_show_markers">show_markers</code></td>
<td>
<p>logical; if  <code>TRUE</code>, the markers (default) are plotted.</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_main">main</code></td>
<td>
<p>An overall title for the plot; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of the facet_wrap</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot graphic
</p>


<h3>Author(s)</h3>

<p>Getulio Caixeta Ferreira, <a href="mailto:getulio.caifer@gmail.com">getulio.caifer@gmail.com</a>
</p>
<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("onemap_example_out")
twopts &lt;- rf_2pts(onemap_example_out)
lg1 &lt;- make_seq(twopts, 1:5)
lg1.map &lt;- map(lg1)
plot(progeny_haplotypes(lg1.map))


</code></pre>

<hr>
<h2 id='plot.onemap_progeny_haplotypes_counts'>Plot recombination breakpoints counts for each individual</h2><span id='topic+plot.onemap_progeny_haplotypes_counts'></span>

<h3>Description</h3>

<p>Plot recombination breakpoints counts for each individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap_progeny_haplotypes_counts'
plot(x, by_homolog = FALSE, n.graphics = NULL, ncol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.onemap_progeny_haplotypes_counts_+3A_x">x</code></td>
<td>
<p>object of class onemap_progeny_haplotypes_counts</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_counts_+3A_by_homolog">by_homolog</code></td>
<td>
<p>logical, if TRUE plots counts by homolog (two for each individuals), if FALSE plots total counts by individual</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_counts_+3A_n.graphics">n.graphics</code></td>
<td>
<p>integer defining the number of graphics to be plotted, they separate the individuals in different plots</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_counts_+3A_ncol">ncol</code></td>
<td>
<p>integer defining the number of columns in plot</p>
</td></tr>
<tr><td><code id="plot.onemap_progeny_haplotypes_counts_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot graphic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("onemap_example_out")
twopts &lt;- rf_2pts(onemap_example_out)
lg1 &lt;- make_seq(twopts, 1:5)
lg1.map &lt;- map(lg1)
prog.haplo &lt;- progeny_haplotypes(lg1.map, most_likely = TRUE)
plot(progeny_haplotypes_counts(prog.haplo))


</code></pre>

<hr>
<h2 id='plot.onemap_segreg_test'>Plot p-values for chi-square tests of expected segregation</h2><span id='topic+plot.onemap_segreg_test'></span>

<h3>Description</h3>

<p>Draw a graphic showing the p-values (re-scaled to -log10(p-values)) associated with the
chi-square tests for the expected segregation patterns for all markers in a dataset.
It includes a vertical line showing the threshold for declaring statistical significance
if Bonferroni's correction is considered, as well as the percentage of markers that
will be discarded if this criterion is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap_segreg_test'
plot(x, order = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.onemap_segreg_test_+3A_x">x</code></td>
<td>
<p>an object of class onemap_segreg_test (produced by onemap's function
test_segregation()), i. e., after performing segregation tests</p>
</td></tr>
<tr><td><code id="plot.onemap_segreg_test_+3A_order">order</code></td>
<td>
<p>a variable to define if p-values will be ordered in the plot</p>
</td></tr>
<tr><td><code id="plot.onemap_segreg_test_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot graphic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(onemap_example_bc) # load OneMap's fake dataset for a backcross population
 BC.seg &lt;- test_segregation(onemap_example_bc) # Applies chi-square tests
 print(BC.seg) # Shows the results
 plot(BC.seg) # Plot the graph, ordering the p-values
 plot(BC.seg, order=FALSE) # Plot the graph showing the results keeping the order in the dataset

 data(onemap_example_out) # load OneMap's fake dataset for an outcrossing population
 Out.seg &lt;- test_segregation(onemap_example_out) # Applies chi-square tests
 print(Out.seg) # Shows the results
 plot(Out.seg) # Plot the graph, ordering the p-values
 plot(Out.seg, order=FALSE) # Plot the graph showing the results keeping the order in the dataset

</code></pre>

<hr>
<h2 id='print.compare'>print method for object class 'compare'</h2><span id='topic+print.compare'></span>

<h3>Description</h3>

<p>print method for object class 'compare'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compare'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.compare_+3A_x">x</code></td>
<td>
<p>object of class compare</p>
</td></tr>
<tr><td><code id="print.compare_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>compare object description
</p>

<hr>
<h2 id='print.group'>Show the results of grouping procedure</h2><span id='topic+print.group'></span>

<h3>Description</h3>

<p>It shows the linkage groups as well as the unlinked markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'group'
print(x, detailed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.group_+3A_x">x</code></td>
<td>
<p>an object of class group</p>
</td></tr>
<tr><td><code id="print.group_+3A_detailed">detailed</code></td>
<td>
<p>logical. If <code>TRUE</code> the markers in each
linkage group are printed.</p>
</td></tr>
<tr><td><code id="print.group_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='print.group_seq'>Show the results of grouping markers to preexisting sequence</h2><span id='topic+print.group_seq'></span>

<h3>Description</h3>

<p>It shows the groups sequences, the repeated markers, as well as the unlinked markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'group_seq'
print(x, detailed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.group_seq_+3A_x">x</code></td>
<td>
<p>an object of class group_seq</p>
</td></tr>
<tr><td><code id="print.group_seq_+3A_detailed">detailed</code></td>
<td>
<p>logical. If <code>TRUE</code> the markers in each
linkage group sequence are printed.</p>
</td></tr>
<tr><td><code id="print.group_seq_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='print.group.upgma'>Show the results of grouping procedure</h2><span id='topic+print.group.upgma'></span>

<h3>Description</h3>

<p>It shows the linkage groups as well as the unlinked markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'group.upgma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.group.upgma_+3A_x">x</code></td>
<td>
<p>an object of class group.upgma</p>
</td></tr>
<tr><td><code id="print.group.upgma_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='print.onemap'>Print method for object class 'onemap'</h2><span id='topic+print.onemap'></span>

<h3>Description</h3>

<p>Print method for object class 'onemap'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.onemap_+3A_x">x</code></td>
<td>
<p>object of class onemap</p>
</td></tr>
<tr><td><code id="print.onemap_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>printed information about onemap object
</p>

<hr>
<h2 id='print.onemap_bin'>print method for object class 'onemap_bin'</h2><span id='topic+print.onemap_bin'></span>

<h3>Description</h3>

<p>print method for object class 'onemap_bin'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap_bin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.onemap_bin_+3A_x">x</code></td>
<td>
<p>object of class <code>onemap_bin</code></p>
</td></tr>
<tr><td><code id="print.onemap_bin_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='print.onemap_segreg_test'>Show the results of segregation tests</h2><span id='topic+print.onemap_segreg_test'></span>

<h3>Description</h3>

<p>It shows the results of Chisquare tests performed for all markers in a onemap object
of cross type outcross, backcross, F2 intercross or recombinant inbred lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'onemap_segreg_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.onemap_segreg_test_+3A_x">x</code></td>
<td>
<p>an object of class onemap_segreg_test</p>
</td></tr>
<tr><td><code id="print.onemap_segreg_test_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with marker name, H0 hypothesis, chi-square statistics,
p-values, and 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 data(onemap_example_out) # Loads a fake outcross dataset installed with onemap
 Chi &lt;- test_segregation(onemap_example_out) # Performs the chi-square test for all markers
 print(Chi) # Shows the results


</code></pre>

<hr>
<h2 id='print.order'>Print order_seq object</h2><span id='topic+print.order'></span>

<h3>Description</h3>

<p>Print order_seq object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'order'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.order_+3A_x">x</code></td>
<td>
<p>object of class order_seq</p>
</td></tr>
<tr><td><code id="print.order_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>printed information about order_seq object
</p>

<hr>
<h2 id='print.rf_2pts'>Print method for object class 'rf_2pts'</h2><span id='topic+print.rf_2pts'></span>

<h3>Description</h3>

<p>It shows the linkage groups as well as the unlinked markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rf_2pts'
print(x, mrk = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rf_2pts_+3A_x">x</code></td>
<td>
<p>an object of class <code>rf_2pts</code>.</p>
</td></tr>
<tr><td><code id="print.rf_2pts_+3A_mrk">mrk</code></td>
<td>
<p>a vector containing a pair of markers, so detailed
results of the two-point analysis will be printed for them.
Can be numeric or character strings indicating the
numbers/names corresponding to any markers in the input file.</p>
</td></tr>
<tr><td><code id="print.rf_2pts_+3A_...">...</code></td>
<td>
<p>further arguments, passed to other methods. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='print.sequence'>Print method for object class 'sequence'</h2><span id='topic+print.sequence'></span>

<h3>Description</h3>

<p>Print method for object class 'sequence'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sequence'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sequence_+3A_x">x</code></td>
<td>
<p>object of class sequence</p>
</td></tr>
<tr><td><code id="print.sequence_+3A_...">...</code></td>
<td>
<p>corrently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>printed information about sequence object
</p>

<hr>
<h2 id='print.try'>Print method for object class 'try'</h2><span id='topic+print.try'></span>

<h3>Description</h3>

<p>Print method for object class 'try'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'try'
print(x, j = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.try_+3A_x">x</code></td>
<td>
<p>an object of class <code>try</code>.</p>
</td></tr>
<tr><td><code id="print.try_+3A_j">j</code></td>
<td>
<p>if <code>NULL</code> (default), output is a summary of the
results for all possible positions of the additional
marker. Otherwise, an integer makes detailed output to be
printed for the corresponding position. This integer must be
less than or equal to the length of the original sequence plus
1.  @param ... further arguments, passed to other
methods. Currently ignored.</p>
</td></tr>
<tr><td><code id="print.try_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='progeny_haplotypes'>Generate data.frame with genotypes estimated by HMM and its probabilities</h2><span id='topic+progeny_haplotypes'></span>

<h3>Description</h3>

<p>Generate data.frame with genotypes estimated by HMM and its probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progeny_haplotypes(..., ind = 1, group_names = NULL, most_likely = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progeny_haplotypes_+3A_...">...</code></td>
<td>
<p>Map(s) or list(s) of maps. Object(s) of class sequence.</p>
</td></tr>
<tr><td><code id="progeny_haplotypes_+3A_ind">ind</code></td>
<td>
<p>vector with individual index to be evaluated or &quot;all&quot; to include all individuals</p>
</td></tr>
<tr><td><code id="progeny_haplotypes_+3A_group_names">group_names</code></td>
<td>
<p>Names of the groups.</p>
</td></tr>
<tr><td><code id="progeny_haplotypes_+3A_most_likely">most_likely</code></td>
<td>
<p>logical; if  <code>TRUE</code>, the most likely genotype receive 1 and all the rest 0. 
If there are more than one most likely both receive 0.5.
if FALSE (default) the genotype probability is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame information: individual (ind) and marker ID, group ID (grp), position in centimorgan (pos), 
genotypes probabilities (prob), parents, and the parents homologs and the allele IDs.
</p>


<h3>Author(s)</h3>

<p>Getulio Caixeta Ferreira, <a href="mailto:getulio.caifer@gmail.com">getulio.caifer@gmail.com</a>
</p>
<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("onemap_example_out")
twopts &lt;- rf_2pts(onemap_example_out)
lg1 &lt;- make_seq(twopts, 1:5)
lg1.map &lt;- map(lg1)
progeny_haplotypes(lg1.map)

</code></pre>

<hr>
<h2 id='progeny_haplotypes_counts'>Plot number of breakpoints by individuals</h2><span id='topic+progeny_haplotypes_counts'></span>

<h3>Description</h3>

<p>Generate graphic with the number of break points for each individual 
considering the most likely genotypes estimated by the HMM.
Genotypes with same probability for two genotypes are removed.
By now, only available for outcrossing and f2 intercross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progeny_haplotypes_counts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progeny_haplotypes_counts_+3A_x">x</code></td>
<td>
<p>object of class onemap_progeny_haplotypes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns individuals ID (ind), group ID (grp),
homolog (homolog) and counts of breakpoints
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("onemap_example_out")
twopts &lt;- rf_2pts(onemap_example_out)
lg1 &lt;- make_seq(twopts, 1:5)
lg1.map &lt;- map(lg1)
progeny_haplotypes_counts(progeny_haplotypes(lg1.map, most_likely = TRUE))


</code></pre>

<hr>
<h2 id='rcd'>Rapid Chain Delineation</h2><span id='topic+rcd'></span>

<h3>Description</h3>

<p>Implements the marker ordering algorithm <em>Rapid Chain Delineation</em>
(<cite>Doerge, 1996</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcd(
  input.seq,
  LOD = 0,
  max.rf = 0.5,
  tol = 1e-04,
  rm_unlinked = TRUE,
  size = NULL,
  overlap = NULL,
  phase_cores = 1,
  hmm = TRUE,
  parallelization.type = "PSOCK",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcd_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="rcd_+3A_lod">LOD</code></td>
<td>
<p>minimum LOD-Score threshold used when constructing the pairwise
recombination fraction matrix.</p>
</td></tr>
<tr><td><code id="rcd_+3A_max.rf">max.rf</code></td>
<td>
<p>maximum recombination fraction threshold used as the LOD
value above.</p>
</td></tr>
<tr><td><code id="rcd_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="rcd_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and rcd is performed again.</p>
</td></tr>
<tr><td><code id="rcd_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="rcd_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="rcd_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="rcd_+3A_hmm">hmm</code></td>
<td>
<p>logical defining if the HMM must be applied to estimate multipoint
genetic distances</p>
</td></tr>
<tr><td><code id="rcd_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="rcd_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Rapid Chain Delineation</em> (<em>RCD</em>) is an algorithm for marker
ordering in linkage groups. It is not an exhaustive search method and,
therefore, is not computationally intensive. However, it does not guarantee
that the best order is always found. The only requirement is a matrix with
recombination fractions between markers.  Next is an excerpt from QTL
Cartographer Version 1.17 Manual describing the <em>RCD</em> algorithm
(<cite>Basten et al., 2005</cite>):
</p>
<p><em>The linkage group is initiated with the pair of markers having the
smallest recombination fraction. The remaining markers are placed in a
&ldquo;pool&rdquo; awaiting placement on the map. The linkage group is extended
by adding markers from the pool of unlinked markers. Each terminal marker
of the linkage group is a candidate for extension of the chain: The
unlinked marker that has the smallest recombination fraction with either is
added to the chain subject to the provision that the recombination fraction
is statistically significant at a prespecified level. This process is
repeated as long as markers can be added to the chain.</em>
</p>
<p>After determining the order with <em>RCD</em>, the final map is constructed
using the multipoint approach (function <code><a href="#topic+map">map</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a>
</p>


<h3>References</h3>

<p>Basten, C. J., Weir, B. S. and Zeng, Z.-B. (2005) <em>QTL
Cartographer Version 1.17: A Reference Manual and Tutorial for QTL
Mapping</em>.
</p>
<p>Doerge, R. W. (1996) Constructing genetic maps by rapid chain delineation.
<em>Journal of Quantitative Trait Loci</em> 2: 121-132.
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia, A. A. F.
(2009) Evaluation of algorithms used to order markers on genetics maps.
<em>Heredity</em> 103: 494-502.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>, <code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.rcd &lt;- rcd(LG1, hmm = FALSE)

  #F2 example
  data(onemap_example_f2)
  twopt &lt;- rf_2pts(onemap_example_f2)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.rcd &lt;- rcd(LG1, hmm = FALSE)
  LG1.rcd


</code></pre>

<hr>
<h2 id='read_mapmaker'>Read data from a Mapmaker raw file</h2><span id='topic+read_mapmaker'></span>

<h3>Description</h3>

<p>Imports data from a Mapmaker raw file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mapmaker(file = NULL, dir = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_mapmaker_+3A_file">file</code></td>
<td>
<p>the name of the input file which contains the data to be read.</p>
</td></tr>
<tr><td><code id="read_mapmaker_+3A_dir">dir</code></td>
<td>
<p>directory where the input file is located.</p>
</td></tr>
<tr><td><code id="read_mapmaker_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about MAPMAKER files see <cite>Lincoln et al.</cite> (1993). The
current version supports backcross, F2s and RIL populations. The file
can contain phenotypic data, but it will not be used in the analysis.
</p>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker in <code>onemap</code> fashion. Each column contains data
for a marker and each row represents an individual.</p>
</td></tr>
</table>
<p><code>MAPMAKER/EXP</code> fashion, i.e., 1, 2, 3: AA, AB, BB, respectively; 3, 4:
BB, not BB, respectively; 1, 5: AA, not AA, respectively. Each column
contains data for a marker and each row represents an individual.
</p>
<table>
<tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr> <tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr>
<tr><td><code>segr.type</code></td>
<td>
<p>a vector with the segregation type of each marker, as
<code>strings</code>. Segregation types were adapted from outcross segregation
types, using the same notation. For details see <a href="#topic+read_onemap">read_onemap</a>.</p>
</td></tr>
<tr><td><code>segr.type.num</code></td>
<td>
<p>a vector with the segregation type of each marker,
represented in a simplified manner as integers. Segregation types were
adapted from outcross segregation types. For details see
<a href="#topic+read_onemap">read_onemap</a>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values.  Each column contains data for a trait and each row represents an
individual. Currently ignored.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adapted from Karl Broman (package <span class="pkg">qtl</span>) by Marcelo Mollinari,
<a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>
<p>Lincoln, S. E., Daly, M. J. and Lander, E. S. (1993) Constructing genetic
linkage maps with MAPMAKER/EXP Version 3.0: a tutorial and reference
manual. <em>A Whitehead Institute for Biomedical Research Technical
Report</em>.
</p>


<h3>See Also</h3>

<p><code>mapmaker_example_bc</code> and <code>mapmaker_example_f2</code> raw files in the
package source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 map_data &lt;-read_mapmaker(file=system.file("extdata/mapmaker_example_f2.raw", package = "onemap"))
 #Checking 'mapmaker_example_f2'
 data(mapmaker_example_f2)
 names(mapmaker_example_f2)

</code></pre>

<hr>
<h2 id='read_onemap'>Read data from all types of progenies supported by OneMap</h2><span id='topic+read_onemap'></span>

<h3>Description</h3>

<p>Imports data derived from outbred parents (full-sib family) or inbred
parents (backcross, F2 intercross and recombinant inbred lines obtained
by self- or sib-mating). Creates an object of class <code>onemap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_onemap(inputfile = NULL, dir = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_onemap_+3A_inputfile">inputfile</code></td>
<td>
<p>the name of the input file which contains the data to be read.</p>
</td></tr>
<tr><td><code id="read_onemap_+3A_dir">dir</code></td>
<td>
<p>directory where the input file is located.</p>
</td></tr>
<tr><td><code id="read_onemap_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file format is similar to that used by <code>MAPMAKER/EXP</code>
(<cite>Lincoln et al.</cite>, 1993). The first line indicates the cross type
and is structured as <code>data type {cross}</code>, where <code>cross</code>
must be one of <code>"outcross"</code>, <code>"f2 intercross"</code>,
<code>"f2 backcross"</code>, <code>"ri self"</code> or  <code>"ri sib"</code>. The second line
contains five integers: i) the number of individuals; ii) the number of
markers; iii) an indicator variable taking the value 1 if there is CHROM
information, i.e., if markers are anchored on any reference sequence, and
0 otherwise; iv) a similar 1/0 variable indicating whether there is POS
information for markers; and v) the number of phenotypic traits.
</p>
<p>The next line contains sample IDs, separated by empty spaces or tabs.
Addition of this sample ID requirement makes it possible for separate input
datasets to be merged.
</p>
<p>Next comes the genotype data for all markers. Each new marker is initiated
with a &ldquo;*&rdquo; (without the quotes) followed by the marker name, without
any space between them. Each marker name is followed by the corresponding
segregation type, which may be: <code>"A.1"</code>, <code>"A.2"</code>, <code>"A.3"</code>,
<code>"A.4"</code>, <code>"B1.5"</code>, <code>"B2.6"</code>, <code>"B3.7"</code>, <code>"C.8"</code>,
<code>"D1.9"</code>, <code>"D1.10"</code>, <code>"D1.11"</code>, <code>"D1.12"</code>,
<code>"D1.13"</code>, <code>"D2.14"</code>, <code>"D2.15"</code>, <code>"D2.16"</code>,
<code>"D2.17"</code> or <code>"D2.18"</code> (without quotes), for full-sibs [see
<code><a href="#topic+marker_type">marker_type</a></code> and <cite>Wu et al.</cite> (2002) for details].
Other cross types have special marker types: <code>"A.H"</code> for backcrosses;
<code>"A.H.B"</code> for F2 intercrosses; and <code>"A.B"</code> for recombinant inbred
lines.
</p>
<p>After the segregation type comes the genotype data for the
corresponding marker. Depending on the segregation type, genotypes may be
denoted by <code>ac</code>, <code>ad</code>, <code>bc</code>, <code>bd</code>, <code>a</code>, <code>ba</code>,
<code>b</code>, <code>bc</code>, <code>ab</code> and <code>o</code>, in several possible
combinations. To make things easier, we have followed <strong>exactly</strong> the
notation used by <cite>Wu et al.</cite> (2002). Allowed values for backcrosses
are <code>a</code> and <code>ab</code>; for F2 crosses they are <code>a</code>, <code>ab</code> and
<code>b</code>; for RILs they may be <code>a</code> and <code>b</code>. Genotypes <em>must</em>
be separated by a space. Missing values are denoted by <code>"-"</code>.
</p>
<p>If there is physical information for markers, i.e., if they are anchored at
specific positions in reference sequences (usually chromosomes), this is
included immediately after the marker data. These lines start with special
keywords <code>*CHROM</code> and <code>*POS</code> and contain <code>strings</code> and
<code>integers</code>, respectively, indicating the reference sequence and
position for each marker. These also need to be separated by spaces.
</p>
<p>Finally, if there is phenotypic data, it will be added just after the marker
or <code>CHROM</code>/<code>POS</code> data. They need to be separated by spaces as
well, using the same symbol for missing information.
</p>
<p>The <code>example</code> directory in the package distribution contains an
example data file to be read with this function. Further instructions can
be found at the tutorial distributed along with this package.
</p>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>matrix containing HMM emission probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a>
</p>


<h3>References</h3>

<p>Lincoln, S. E., Daly, M. J. and Lander, E. S. (1993)
Constructing genetic linkage maps with MAPMAKER/EXP Version 3.0: a tutorial
and reference manual. <em>A Whitehead Institute for Biomedical Research
Technical Report</em>.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combine_onemap">combine_onemap</a></code> and the <code>example</code>
directory in the package source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 outcr_data &lt;- read_onemap(inputfile= 
 system.file("extdata/onemap_example_out.raw", package= "onemap"))

</code></pre>

<hr>
<h2 id='record'>Recombination Counting and Ordering</h2><span id='topic+record'></span>

<h3>Description</h3>

<p>Implements the marker ordering algorithm <em>Recombination Counting and
Ordering</em> (<cite>Van Os et al., 2005</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record(
  input.seq,
  times = 10,
  LOD = 0,
  max.rf = 0.5,
  tol = 1e-04,
  rm_unlinked = TRUE,
  size = NULL,
  overlap = NULL,
  phase_cores = 1,
  hmm = TRUE,
  parallelization.type = "PSOCK",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="record_+3A_times">times</code></td>
<td>
<p>integer. Number of replicates of the RECORD procedure.</p>
</td></tr>
<tr><td><code id="record_+3A_lod">LOD</code></td>
<td>
<p>minimum LOD-Score threshold used when constructing the pairwise
recombination fraction matrix.</p>
</td></tr>
<tr><td><code id="record_+3A_max.rf">max.rf</code></td>
<td>
<p>maximum recombination fraction threshold used as the LOD
value above.</p>
</td></tr>
<tr><td><code id="record_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="record_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and record is performed again.</p>
</td></tr>
<tr><td><code id="record_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="record_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="record_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="record_+3A_hmm">hmm</code></td>
<td>
<p>logical defining if the HMM must be applied to estimate multipoint
genetic distances</p>
</td></tr>
<tr><td><code id="record_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="record_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Recombination Counting and Ordering</em> (<em>RECORD</em>) is an algorithm
for marker ordering in linkage groups. It is not an exhaustive search
method and, therefore, is not computationally intensive. However, it does
not guarantee that the best order is always found. The only requirement is
a matrix with recombination fractions between markers.
</p>
<p>After determining the order with <em>RECORD</em>, the final map is
constructed using the multipoint approach (function
<code><a href="#topic+map">map</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia,
A. A. F. (2009) Evaluation of algorithms used to order markers on genetics
maps. <em>Heredity</em> 103: 494-502.
</p>
<p>Van Os, H., Stam, P., Visser, R.G.F. and Van Eck, H.J. (2005) RECORD: a
novel method for ordering loci on a genetic linkage map. <em>Theoretical
and Applied Genetics</em> 112: 30-40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code> and <code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  ##outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.rec &lt;- record(LG1, hmm = FALSE)

  ##F2 example
  data(onemap_example_f2)
  twopt &lt;- rf_2pts(onemap_example_f2)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.rec &lt;- record(LG1, hmm = FALSE)
  LG1.rec

</code></pre>

<hr>
<h2 id='remove_inds'>Remove individuals from the onemap object</h2><span id='topic+remove_inds'></span>

<h3>Description</h3>

<p>Remove individuals from the onemap object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_inds(onemap.obj, rm.ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_inds_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>object of class onemap</p>
</td></tr>
<tr><td><code id="remove_inds_+3A_rm.ind">rm.ind</code></td>
<td>
<p>vector of characters with individuals names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>onemap</code> without the selected individuals, 
i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='rf_2pts'>Two-point analysis between genetic markers</h2><span id='topic+rf_2pts'></span>

<h3>Description</h3>

<p>Performs the two-point (pairwise) analysis proposed by <cite>Wu et al.
(2002)</cite> between all pairs of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_2pts(input.obj, LOD = 3, max.rf = 0.5, verbose = TRUE, rm_mks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_2pts_+3A_input.obj">input.obj</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="rf_2pts_+3A_lod">LOD</code></td>
<td>
<p>minimum LOD Score to declare linkage (defaults to <code>3</code>).</p>
</td></tr>
<tr><td><code id="rf_2pts_+3A_max.rf">max.rf</code></td>
<td>
<p>maximum recombination fraction to declare linkage (defaults
to <code>0.50</code>).</p>
</td></tr>
<tr><td><code id="rf_2pts_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, current progress is shown; if
<code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="rf_2pts_+3A_rm_mks">rm_mks</code></td>
<td>
<p>logical. If <code>TRUE</code> the algorithm will remove the markers for which it found numerical 
problems to calculates the recombination fraction. The numerical problems can happens because of excess of 
missing data or segregation deviation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>n</code> markers, there are </p>
<p style="text-align: center;"><code class="reqn">\frac{n(n-1)}{2}</code>
</p>
<p> pairs of
markers to be analyzed. Therefore, completion of the two-point analyses can
take a long time.
</p>


<h3>Value</h3>

<p>An object of class <code>rf_2pts</code>, which is a list containing the
following components:  </p>
<table>
<tr><td><code>n.mar</code></td>
<td>
<p>total number of markers.</p>
</td></tr> <tr><td><code>LOD</code></td>
<td>
<p>minimum LOD Score to declare
linkage.</p>
</td></tr> <tr><td><code>max.rf</code></td>
<td>
<p>maximum recombination fraction to declare linkage.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr> <tr><td><code>analysis</code></td>
<td>
<p>an array with the
complete results of the two-point analysis for each pair of markers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The thresholds used for <code>LOD</code> and <code>max.rf</code> will be used in
subsequent analyses, but can be overriden.
</p>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a> and Marcelo Mollinari <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002)
Simultaneous maximum likelihood estimation of linkage and linkage phases in
outcrossing species. <em>Theoretical Population Biology</em> 61: 349-363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)

  twopts &lt;- rf_2pts(onemap_example_out,LOD=3,max.rf=0.5) # perform two-point analyses
  twopts

  print(twopts,c("M1","M2")) # detailed results for markers 1 and 2

  
</code></pre>

<hr>
<h2 id='rf_graph_table'>Plots pairwise recombination fractions and LOD Scores in a heatmap</h2><span id='topic+rf_graph_table'></span>

<h3>Description</h3>

<p>Plots a matrix of pairwise recombination fraction or
LOD Scores using a color scale. Any value of the
matrix can be easily accessed using an interactive plotly-html interface,
helping users to check for possible problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_graph_table(
  input.seq,
  graph.LOD = FALSE,
  main = NULL,
  inter = FALSE,
  html.file = NULL,
  mrk.axis = "numbers",
  lab.xy = NULL,
  n.colors = 4,
  display = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_graph_table_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code> with a predefined
order.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_graph.lod">graph.LOD</code></td>
<td>
<p>logical. If <code>TRUE</code>, displays the LOD heatmap, otherwise,
displays the recombination fraction heatmap.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_main">main</code></td>
<td>
<p>character. The title of the plot.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_inter">inter</code></td>
<td>
<p>logical. If <code>TRUE</code>, an interactive HTML graphic is plotted.
Otherwise, a default graphic device is used.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_html.file">html.file</code></td>
<td>
<p>character naming the html file with interative graphic.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_mrk.axis">mrk.axis</code></td>
<td>
<p>character, &quot;names&quot; to display marker names in the axis, &quot;numbers&quot; to display
marker numbers and &quot;none&quot; to display axis free of labels.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_lab.xy">lab.xy</code></td>
<td>
<p>character vector with length 2, first component is the label of x axis and second of the y axis.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_n.colors">n.colors</code></td>
<td>
<p>integer. Number of colors in the pallete.</p>
</td></tr>
<tr><td><code id="rf_graph_table_+3A_display">display</code></td>
<td>
<p>logical. If inter <code>TRUE</code> and display <code>TRUE</code> interactive graphic is plotted in browser automatically when run the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The color scale varies from red (small distances or big LODs) to purple.
When hover on a cell, a dialog box is displayed with some information
about corresponding markers for that cell (line (y) <code class="reqn">\times</code> column (x)). They are:
<code class="reqn">i</code>) the name of the markers; <code class="reqn">ii</code>) the number of
the markers on the data set; <code class="reqn">iii</code>) the segregation types; <code class="reqn">iv</code>)
the recombination fraction between the markers and <code class="reqn">v</code>) the LOD-Score
for each possible linkage phase calculated via two-point analysis. For
neighbor markers, the multipoint recombination fraction is printed;
otherwise, the two-point recombination fraction is printed. For markers of
type <code>D1</code> and <code>D2</code>, it is impossible to calculate recombination
fraction via two-point analysis and, therefore, the corresponding cell will
be empty (white color). For cells on the diagonal of the matrix, the name, the number and
the type of the marker are printed, as well as the percentage of missing
data for that marker.
</p>


<h3>Value</h3>

<p>a ggplot graphic
</p>


<h3>Author(s)</h3>

<p>Rodrigo Amadeu, <a href="mailto:rramadeu@gmail.com">rramadeu@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.rcd &lt;- rcd(LG1)
  rf_graph_table(LG1.rcd, inter=FALSE)


  ##F2 example
  data(onemap_example_f2)
  twopt &lt;- rf_2pts(onemap_example_f2)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)

  ##"pre-allocate" an empty list of length groups$n.groups (3, in this case)
  maps.list&lt;-vector("list", groups$n.groups)

  for(i in 1:groups$n.groups){
    ##create linkage group i
    LG.cur &lt;- make_seq(groups,i)
    ##ordering
    map.cur&lt;-order_seq(LG.cur, subset.search = "sample")
    ##assign the map of the i-th group to the maps.list
    maps.list[[i]]&lt;-make_seq(map.cur, "force")
  }

</code></pre>

<hr>
<h2 id='rf_snp_filter_onemap'>Filter markers according with a two-points recombination fraction and LOD threshold. Adapted from MAPpoly.</h2><span id='topic+rf_snp_filter_onemap'></span>

<h3>Description</h3>

<p>Filter markers according with a two-points recombination fraction and LOD threshold. Adapted from MAPpoly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_snp_filter_onemap(
  input.seq,
  thresh.LOD.rf = 5,
  thresh.rf = 0.15,
  probs = c(0.05, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_snp_filter_onemap_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>onemap</code>.</p>
</td></tr>
<tr><td><code id="rf_snp_filter_onemap_+3A_thresh.lod.rf">thresh.LOD.rf</code></td>
<td>
<p>LOD score threshold for recombination fraction (default = 5)</p>
</td></tr>
<tr><td><code id="rf_snp_filter_onemap_+3A_thresh.rf">thresh.rf</code></td>
<td>
<p>threshold for recombination fractions (default = 0.15)</p>
</td></tr>
<tr><td><code id="rf_snp_filter_onemap_+3A_probs">probs</code></td>
<td>
<p>indicates the probability corresponding to the filtering quantiles. (default = c(0.05, 1))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data("vcf_example_out")
 twopts &lt;- rf_2pts(vcf_example_out)
 seq1 &lt;- make_seq(twopts, which(vcf_example_out$CHROM == "1"))
filt_seq &lt;- rf_snp_filter_onemap(seq1, 20, 0.5, c(0.5,1))

</code></pre>

<hr>
<h2 id='ripple_seq'>Compares and displays plausible alternative orders for a given linkage
group</h2><span id='topic+ripple_seq'></span>

<h3>Description</h3>

<p>For a given sequence of ordered markers, computes the multipoint likelihood
of alternative orders, by shuffling subsets (windows) of markers within the
sequence. For each position of the window, all possible <code class="reqn">(ws)!</code>
orders are compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ripple_seq(input.seq, ws = 4, ext.w = NULL, LOD = 3, tol = 0.1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ripple_seq_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code> with a
predefined order.</p>
</td></tr>
<tr><td><code id="ripple_seq_+3A_ws">ws</code></td>
<td>
<p>an integer specifying the length of the window size
(defaults to 4).</p>
</td></tr>
<tr><td><code id="ripple_seq_+3A_ext.w">ext.w</code></td>
<td>
<p>an integer specifying how many markers should be
considered in the vicinity of the permuted window. If
<code>ext.w=NULL</code> all markers in the sequence are
considered. In this version, it is used only in backcross,
<code class="reqn">F_2</code> or RIL crosses.</p>
</td></tr>
<tr><td><code id="ripple_seq_+3A_lod">LOD</code></td>
<td>
<p>threshold for the LOD-Score, so that alternative orders
with LOD less then or equal to this threshold will be
displayed.</p>
</td></tr>
<tr><td><code id="ripple_seq_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to
evaluate convergence.</p>
</td></tr>
<tr><td><code id="ripple_seq_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Large values for the window size make computations very slow, specially if
there are many partially informative markers.
</p>


<h3>Value</h3>

<p>This function does not return any value; it just produces
text output to suggest alternative orders.
</p>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a> and
Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>
<p>Jiang, C. and Zeng, Z.-B. (1997). Mapping quantitative trait loci with
dominant and missing markers in various crosses from two inbred lines.
<em>Genetica</em> 101: 47-58.
</p>
<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M. J., Lincoln,
S. E. and Newburg, L. (1987) MAPMAKER: An interactive computer package for
constructing primary genetic linkage maps of experimental and natural
populations. <em>Genomics</em> 1: 174-181.
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia, A. A. F.
(2009) Evaluation of algorithms used to order markers on genetics maps.
<em>Heredity</em> 103: 494-502.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage mapping of
sex-specific differences. <em>Genetical Research</em> 79: 85-96
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>,
<code><a href="#topic+compare">compare</a></code>, <code><a href="#topic+try_seq">try_seq</a></code>
and <code><a href="#topic+order_seq">order_seq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Outcross example
 data(onemap_example_out)
 twopt &lt;- rf_2pts(onemap_example_out)
 markers &lt;- make_seq(twopt,c(27,16,20,4,19,21,23,9,24,29))
 markers.map &lt;- map(markers)
 ripple_seq(markers.map)

#F2 example
data(onemap_example_f2)
twopt &lt;- rf_2pts(onemap_example_f2)
all_mark &lt;- make_seq(twopt,"all")
groups &lt;- group(all_mark)
LG3 &lt;- make_seq(groups,1)
LG3.ord &lt;- order_seq(LG3, subset.search = "twopt", twopt.alg = "rcd", touchdown=TRUE)
LG3.ord
make_seq(LG3.ord) # get safe sequence
ord.1&lt;-make_seq(LG3.ord,"force") # get forced sequence
ripple_seq(ord.1, ws=5)


</code></pre>

<hr>
<h2 id='rm_dupli_mks'>Remove duplicated markers keeping the one with less missing data</h2><span id='topic+rm_dupli_mks'></span>

<h3>Description</h3>

<p>Remove duplicated markers keeping the one with less missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_dupli_mks(onemap.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_dupli_mks_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>object of class <code>onemap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='seeded_map'>Construct the linkage map for a sequence of markers after seeding phases</h2><span id='topic+seeded_map'></span>

<h3>Description</h3>

<p>Estimates the multipoint log-likelihood, linkage phases and recombination
frequencies for a sequence of markers in a given order using seeded phases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seeded_map(
  input.seq,
  tol = 1e-04,
  phase_cores = 1,
  seeds,
  verbose = FALSE,
  rm_unlinked = FALSE,
  parallelization.type = "PSOCK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seeded_map_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="seeded_map_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="seeded_map_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="seeded_map_+3A_seeds">seeds</code></td>
<td>
<p>A vector given the integer encoding of phases for the first
<em>N</em> positions of the map</p>
</td></tr>
<tr><td><code id="seeded_map_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
<tr><td><code id="seeded_map_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and map is performed again.</p>
</td></tr>
<tr><td><code id="seeded_map_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Markers are mapped in the order defined in the object <code>input.seq</code>. The
best combination of linkage phases is also estimated starting from the first
position not in the given seeds.The multipoint likelihood is calculated
according to Wu et al. (2002b)(Eqs. 7a to 11), assuming that the
recombination fraction is the same in both parents. Hidden Markov chain
codes adapted from Broman et al. (2008) were used.
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>outcross</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adapted from Karl Broman (package 'qtl') by Gabriel R A Margarido,
<a href="mailto:gramarga@usp.br">gramarga@usp.br</a> and Marcelo Mollinari, <a href="mailto:mmollina@gmail.com">mmollina@gmail.com</a>.
Modified to use seeded phases by Bastian Schiffthaler
<a href="mailto:bastian.schiffthaler@umu.se">bastian.schiffthaler@umu.se</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>
<p>Jiang, C. and Zeng, Z.-B. (1997). Mapping quantitative trait loci with
dominant and missing markers in various crosses from two inbred lines.
<em>Genetica</em> 101: 47-58.
</p>
<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M. J., Lincoln,
S. E. and Newburg, L. (1987) MAPMAKER: An interactive computer package for
constructing primary genetic linkage maps of experimental and natural
populations. <em>Genomics</em> 1: 174-181.
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a) Simultaneous maximum
likelihood estimation of linkage and linkage phases in outcrossing species.
<em>Theoretical Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage mapping of
sex-specific differences. <em>Genetical Research</em> 79: 85-96
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)

  markers &lt;- make_seq(twopt,c(30,12,3,14,2))
  seeded_map(markers, seeds = c(4,2))

</code></pre>

<hr>
<h2 id='select_segreg'>Show markers with/without segregation distortion</h2><span id='topic+select_segreg'></span>

<h3>Description</h3>

<p>A function to shows which marker have segregation distortion if Bonferroni's correction is
applied for the Chi-square tests of mendelian segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_segreg(x, distorted = FALSE, numbers = FALSE, threshold = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_segreg_+3A_x">x</code></td>
<td>
<p>an object of class onemap_segreg_test</p>
</td></tr>
<tr><td><code id="select_segreg_+3A_distorted">distorted</code></td>
<td>
<p>a TRUE/FALSE variable to show distorted or non-distorted markers</p>
</td></tr>
<tr><td><code id="select_segreg_+3A_numbers">numbers</code></td>
<td>
<p>a TRUE/FALSE variable to show the numbers or the names of the markers</p>
</td></tr>
<tr><td><code id="select_segreg_+3A_threshold">threshold</code></td>
<td>
<p>a number between 0 and 1 to specify the threshold (alpha) to be considered in the test. 
If NULL, it uses the threshold alpha = 0.05. Bonferroni correction is applied for multiple test correction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with marker names or numbers, according to the option for &quot;distorted&quot; and &quot;numbers&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Loads a fake backcross dataset installed with onemap
 data(onemap_example_out)
 # Performs the chi-square test for all markers
 Chi &lt;- test_segregation(onemap_example_out)
 # To show non-distorted markers
 select_segreg(Chi)
 # To show markers with segregation distortion
 select_segreg(Chi, distorted=TRUE)
 # To show the numbers of the markers with segregation distortion
 select_segreg(Chi, distorted=TRUE, numbers=TRUE)

</code></pre>

<hr>
<h2 id='seq_by_type'>Extract marker number by name</h2><span id='topic+seq_by_type'></span>

<h3>Description</h3>

<p>Extract marker number by name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_by_type(sequence, mk_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_by_type_+3A_sequence">sequence</code></td>
<td>
<p>object of class or sequence</p>
</td></tr>
<tr><td><code id="seq_by_type_+3A_mk_type">mk_type</code></td>
<td>
<p>vector of character with marker type to be selected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New sequence object of class <code>sequence</code> with selected marker type, 
which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>
</p>

<hr>
<h2 id='seriation'>Seriation</h2><span id='topic+seriation'></span>

<h3>Description</h3>

<p>Implements the marker ordering algorithm <em>Seriation</em> (<cite>Buetow &amp;
Chakravarti, 1987</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriation(
  input.seq,
  LOD = 0,
  max.rf = 0.5,
  tol = 1e-04,
  rm_unlinked = TRUE,
  size = NULL,
  overlap = NULL,
  phase_cores = 1,
  hmm = TRUE,
  parallelization.type = "PSOCK",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriation_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="seriation_+3A_lod">LOD</code></td>
<td>
<p>minimum LOD-Score threshold used when constructing the pairwise
recombination fraction matrix.</p>
</td></tr>
<tr><td><code id="seriation_+3A_max.rf">max.rf</code></td>
<td>
<p>maximum recombination fraction threshold used as the LOD
value above.</p>
</td></tr>
<tr><td><code id="seriation_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="seriation_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and ug is performed again.</p>
</td></tr>
<tr><td><code id="seriation_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="seriation_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="seriation_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="seriation_+3A_hmm">hmm</code></td>
<td>
<p>logical defining if the HMM must be applied to estimate multipoint
genetic distances</p>
</td></tr>
<tr><td><code id="seriation_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="seriation_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Seriation</em> is an algorithm for marker ordering in linkage groups. It
is not an exhaustive search method and, therefore, is not computationally
intensive. However, it does not guarantee that the best order is always
found. The only requirement is a matrix with recombination fractions
between markers.
</p>
<p>NOTE: When there are to many pairs of markers with the same value in the
recombination fraction matrix, it can result in ties during the ordination
process and the <em>Seriation</em> algorithm may not work properly. This is
particularly relevant for outcrossing populations with mixture of markers
of type <code>D1</code> and <code>D2</code>. When this occurs, the function shows the
following error message: <code>There are too many ties in the ordination
process - please, consider using another ordering algorithm</code>.
</p>
<p>After determining the order with <em>Seriation</em>, the final map is
constructed using the multipoint approach (function
<code><a href="#topic+map">map</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel R A Margarido, <a href="mailto:gramarga@gmail.com">gramarga@gmail.com</a>
</p>


<h3>References</h3>

<p>Buetow, K. H. and Chakravarti, A. (1987) Multipoint gene
mapping using seriation. I. General methods. <em>American Journal of
Human Genetics</em> 41: 180-188.
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia, A. A. F.
(2009) Evaluation of algorithms used to order markers on genetics maps.
<em>Heredity</em> 103: 494-502.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>, <code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  ##outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG3 &lt;- make_seq(groups,3)
  LG3.ser &lt;- seriation(LG3)

</code></pre>

<hr>
<h2 id='set_map_fun'>Defines the default mapping function</h2><span id='topic+set_map_fun'></span>

<h3>Description</h3>

<p>Defines the function that should be used to display the genetic map through
the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_map_fun(type = c("kosambi", "haldane"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_map_fun_+3A_type">type</code></td>
<td>
<p>Indicates the function that should be used, which can be
<code>"kosambi"</code> or <code>"haldane"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>
<p>Kosambi, D. D. (1944) The estimation of map distance from recombination
values. <em>Annuaire of Eugenetics</em> 12: 172-175.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Haldane, J. B. S. (1919) The combination of linkage values and
the calculation of distance between the loci of linked factors.
<em>Journal of Genetics</em> 8: 299-309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kosambi">kosambi</a></code> and <code><a href="#topic+haldane">haldane</a></code>
</p>

<hr>
<h2 id='sort_by_pos'>Sort markers in onemap object by their position in reference genome</h2><span id='topic+sort_by_pos'></span>

<h3>Description</h3>

<p>Sort markers in onemap object by their position in reference genome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_by_pos(onemap.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_by_pos_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>object of class onemap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>onemap</code>, i.e., a list with the following
components: </p>
<table>
<tr><td><code>geno</code></td>
<td>
<p>a matrix with integers indicating the genotypes
read for each marker. Each column contains data for a marker and each row
represents an individual.</p>
</td></tr> <tr><td><code>n.ind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.mar</code></td>
<td>
<p>number of markers.</p>
</td></tr> <tr><td><code>segr.type</code></td>
<td>
<p>a vector with the
segregation type of each marker, as <code>strings</code>.</p>
</td></tr> <tr><td><code>segr.type.num</code></td>
<td>
<p>a
vector with the segregation type of each marker, represented in a
simplified manner as integers, i.e. 1 corresponds to markers of type
<code>"A"</code>; 2 corresponds to markers of type <code>"B1.5"</code>; 3 corresponds
to markers of type <code>"B2.6"</code>; 4 corresponds to markers of type
<code>"B3.7"</code>; 5 corresponds to markers of type <code>"C.8"</code>; 6 corresponds
to markers of type <code>"D1"</code> and 7 corresponds to markers of type
<code>"D2"</code>. Markers for F2 intercrosses are coded as 1; all other crosses
are left as <code>NA</code>.</p>
</td></tr> <tr><td><code>input</code></td>
<td>
<p>the name of the input file.</p>
</td></tr>
<tr><td><code>n.phe</code></td>
<td>
<p>number of phenotypes.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p>a matrix with phenotypic
values. Each column contains data for a trait and each row represents an
individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='split_2pts'>Split rf_2pts object by markers</h2><span id='topic+split_2pts'></span>

<h3>Description</h3>

<p>Split rf_2pts object by markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_2pts(twopts.obj, mks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_2pts_+3A_twopts.obj">twopts.obj</code></td>
<td>
<p>object of class rf_2pts</p>
</td></tr>
<tr><td><code id="split_2pts_+3A_mks">mks</code></td>
<td>
<p>markers names (vector of characters) or number (vector of integers) to be removed and added to a new rf_2pts object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>rf_2pts</code> with only the selected markers, which is a list containing the
following components:  </p>
<table>
<tr><td><code>n.mar</code></td>
<td>
<p>total number of markers.</p>
</td></tr> <tr><td><code>LOD</code></td>
<td>
<p>minimum LOD Score to declare
linkage.</p>
</td></tr> <tr><td><code>max.rf</code></td>
<td>
<p>maximum recombination fraction to declare linkage.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='split_onemap'>Split onemap data sets</h2><span id='topic+split_onemap'></span>

<h3>Description</h3>

<p>Receives one onemap object and a vector with markers names to be 
removed from the input onemap object and inserted in a new one. The output
is a list containing the two onemap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_onemap(onemap.obj = NULL, mks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_onemap_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>object of class onemap</p>
</td></tr>
<tr><td><code id="split_onemap_+3A_mks">mks</code></td>
<td>
<p>markers names (vector of characters) or number (vector of integers) to be removed and added to a new onemap object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing in first level the original onemap object without 
the indicated markers and the second level the new onemap object with only 
the indicated markers
</p>

<hr>
<h2 id='suggest_lod'>Suggests a LOD Score for two point tests</h2><span id='topic+suggest_lod'></span>

<h3>Description</h3>

<p>It suggests a LOD Score for declaring statistical significance for two-point tests
for linkage between all pairs of markers, considering that multiple tests are being performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest_lod(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggest_lod_+3A_x">x</code></td>
<td>
<p>an object of class <code>sequence</code> or <code>onemap</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a somehow naive approach, the function calculates the number of two-point tests that
will be performed for all markers in the data set, and then using this to calculate
the global alpha required to control type I error using Bonferroni's correction.
</p>
<p>From this global alpha, the corresponding quantile from the chi-square distribution is taken
and then converted to LOD Score.
</p>
<p>This can be seen as just an initial approximation to help users to select a LOD Score for two
point tests.
</p>


<h3>Value</h3>

<p>the suggested LOD to be used for testing linkage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_bc) # Loads a fake backcross dataset installed with onemap
suggest_lod(onemap_example_bc) # An value that should be used to start the analysis

</code></pre>

<hr>
<h2 id='test_segregation'>test_segregation</h2><span id='topic+test_segregation'></span>

<h3>Description</h3>

<p>Using OneMap internal function test_segregation_of_a_marker(),
performs the Chi-square test to check if all markers in a dataset are following
the expected segregation pattern, i. e., 1:1:1:1 (A), 1:2:1 (B), 3:1 (C) and 1:1 (D)
according to OneMap's notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_segregation(x, simulate.p.value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_segregation_+3A_x">x</code></td>
<td>
<p>an object of class <code>onemap</code>, with data and additional information.</p>
</td></tr>
<tr><td><code id="test_segregation_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical indicating whether to compute p-values by Monte Carlo simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, it identifies the correct segregation pattern and corresponding H0 hypothesis,
and then tests it.
</p>


<h3>Value</h3>

<p>an object of class onemap_segreg_test, which is a list with marker name,
H0 hypothesis being tested, the chi-square statistics, the associated p-values
and the % of individuals genotyped. To see the object, it is necessary to print
it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(onemap_example_out) # Loads a fake outcross dataset installed with onemap
 Chi &lt;- test_segregation(onemap_example_out) # Performs the chi-square test for all markers
 print(Chi) # Shows the results


</code></pre>

<hr>
<h2 id='test_segregation_of_a_marker'>test_segregation_of_a_marker</h2><span id='topic+test_segregation_of_a_marker'></span>

<h3>Description</h3>

<p>Applies the chi-square test to check if markers are following the
expected segregation pattern, i. e., 1:1:1:1 (A), 1:2:1 (B), 3:1 (C) and 1:1 (D)
according to OneMap's notation. It does not use Yate's correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_segregation_of_a_marker(x, marker, simulate.p.value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_segregation_of_a_marker_+3A_x">x</code></td>
<td>
<p>an object of class <code>onemap</code>, with data and additional information.</p>
</td></tr>
<tr><td><code id="test_segregation_of_a_marker_+3A_marker">marker</code></td>
<td>
<p>the marker which will be tested for its segregation.</p>
</td></tr>
<tr><td><code id="test_segregation_of_a_marker_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical indicating whether to compute p-values by Monte Carlo simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the function selects the correct segregation pattern, then it
defines the H0 hypothesis, and then tests it, together with percentage of
missing data.
</p>


<h3>Value</h3>

<p>a list with the H0 hypothesis being tested, the chi-square statistics,
the associated p-values, and the % of individuals genotyped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_bc) # Loads a fake backcross dataset installed with onemap
test_segregation_of_a_marker(onemap_example_bc,1)

data(onemap_example_out) # Loads a fake outcross dataset installed with onemap
test_segregation_of_a_marker(onemap_example_out,1)

</code></pre>

<hr>
<h2 id='try_seq'>Try to map a marker into every possible position between markers
in a given map</h2><span id='topic+try_seq'></span>

<h3>Description</h3>

<p>For a given linkage map, tries do add an additional unpositioned
marker.  This function estimates parameters for all possible maps
including the new marker in all possible positions, while keeping
the original linkage map unaltered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_seq(input.seq, mrk, tol = 0.1, pos = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_seq_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code> with a
predefined order.</p>
</td></tr>
<tr><td><code id="try_seq_+3A_mrk">mrk</code></td>
<td>
<p>the index of the marker to be tried, according to the
input file.</p>
</td></tr>
<tr><td><code id="try_seq_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to
evaluate convergence.</p>
</td></tr>
<tr><td><code id="try_seq_+3A_pos">pos</code></td>
<td>
<p>defines in which position the new marker <code>mrk</code>
should be placed for the diagnostic graphic. If <code>NULL</code>
(default), the marker is placed on the best position i.e. the
one which results LOD = 0.00</p>
</td></tr>
<tr><td><code id="try_seq_+3A_verbose">verbose</code></td>
<td>
<p>if <code>FALSE</code> (default), simplified output is
displayed.  if <code>TRUE</code>, detailed output is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>try</code>, which is a list containing
the following components: </p>
<table>
<tr><td><code>ord</code></td>
<td>
<p>a <code>list</code> containing
results for every linkage map estimated.  These results
include linkage phases, recombination frequencies and
log-likelihoods.</p>
</td></tr> <tr><td><code>LOD</code></td>
<td>
<p>a <code>vector</code> with LOD-Scores
for each position where the additional marker is placed. This
Score is based on the best combination of linkage phases for
each map.</p>
</td></tr>  <tr><td><code>try.ord</code></td>
<td>
<p>a <code>matrix</code> with the orders of
all linkage maps.</p>
</td></tr>  <tr><td><code>data.name</code></td>
<td>
<p>name of the object of
class <code>onemap</code> with the raw data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of
the object of class <code>rf_2pts</code> with the 2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S.,
Yandell, B.  (2008) <em>qtl: Tools for analyzing QTL
experiments</em> R package version 1.09-43
</p>
<p>Jiang, C. and Zeng, Z.-B. (1997). Mapping quantitative trait loci
with dominant and missing markers in various crosses from two
inbred lines.  <em>Genetica</em> 101: 47-58.
</p>
<p>Lander, E. S., Green, P., Abrahamson, J., Barlow, A., Daly, M. J.,
Lincoln, S. E. and Newburg, L. (1987) MAPMAKER: An interactive
computer package for constructing primary genetic linkage maps
of experimental and natural populations. <em>Genomics</em> 1:
174-181.
</p>
<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia,
A. A. F.  (2009) Evaluation of algorithms used to order
markers on genetic maps.  <em>Heredity</em> 103: 494-502
</p>
<p>Wu, R., Ma, C.-X., Painter, I. and Zeng, Z.-B. (2002a)
Simultaneous maximum likelihood estimation of linkage and
linkage phases in outcrossing species.  <em>Theoretical
Population Biology</em> 61: 349-363.
</p>
<p>Wu, R., Ma, C.-X., Wu, S. S. and Zeng, Z.-B. (2002b). Linkage
mapping of sex-specific differences. <em>Genetical Research</em>
79: 85-96
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code> and
<code><a href="#topic+compare">compare</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #outcrossing example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  markers &lt;- make_seq(twopt,c(2,3,12,14))
  markers.comp &lt;- compare(markers)
  base.map &lt;- make_seq(markers.comp,1)

  extend.map &lt;- try_seq(base.map,30)
  extend.map
  print(extend.map,5) # best position
  print(extend.map,4) # second best position


</code></pre>

<hr>
<h2 id='try_seq_by_seq'>Run try_seq considering previous sequence</h2><span id='topic+try_seq_by_seq'></span>

<h3>Description</h3>

<p>It uses try_seq function repeatedly trying to positioned each marker 
in a vector of markers into a already ordered sequence.
Each marker in the vector <code>"markers"</code> is kept in the sequence 
if the difference of LOD and total group size of the models 
with and without the marker are below the thresholds <code>"lod.thr"</code> and <code>"cM.thr"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_seq_by_seq(sequence, markers, cM.thr = 10, lod.thr = -10, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_seq_by_seq_+3A_sequence">sequence</code></td>
<td>
<p>object of class sequence with ordered markers</p>
</td></tr>
<tr><td><code id="try_seq_by_seq_+3A_markers">markers</code></td>
<td>
<p>vector of integers defining the marker numbers to be inserted in the <code>sequence</code></p>
</td></tr>
<tr><td><code id="try_seq_by_seq_+3A_cm.thr">cM.thr</code></td>
<td>
<p>number defining the threshold for total map size increase when inserting a single marker</p>
</td></tr>
<tr><td><code id="try_seq_by_seq_+3A_lod.thr">lod.thr</code></td>
<td>
<p>the difference of LODs between model before and after inserting the marker need to have 
value higher than the value defined in this argument</p>
</td></tr>
<tr><td><code id="try_seq_by_seq_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>name of the object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>

<hr>
<h2 id='ug'>Unidirectional Growth</h2><span id='topic+ug'></span>

<h3>Description</h3>

<p>Implements the marker ordering algorithm <em>Unidirectional Growth</em>
(<cite>Tan &amp; Fu, 2006</cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ug(
  input.seq,
  LOD = 0,
  max.rf = 0.5,
  tol = 1e-04,
  rm_unlinked = TRUE,
  size = NULL,
  overlap = NULL,
  phase_cores = 1,
  hmm = TRUE,
  parallelization.type = "PSOCK",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ug_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="ug_+3A_lod">LOD</code></td>
<td>
<p>minimum LOD-Score threshold used when constructing the pairwise
recombination fraction matrix.</p>
</td></tr>
<tr><td><code id="ug_+3A_max.rf">max.rf</code></td>
<td>
<p>maximum recombination fraction threshold used as the LOD
value above.</p>
</td></tr>
<tr><td><code id="ug_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to evaluate
convergence.</p>
</td></tr>
<tr><td><code id="ug_+3A_rm_unlinked">rm_unlinked</code></td>
<td>
<p>When some pair of markers do not follow the linkage criteria, 
if <code>TRUE</code> one of the markers is removed and ug is performed again.</p>
</td></tr>
<tr><td><code id="ug_+3A_size">size</code></td>
<td>
<p>The center size around which an optimum is to be searched</p>
</td></tr>
<tr><td><code id="ug_+3A_overlap">overlap</code></td>
<td>
<p>The desired overlap between batches</p>
</td></tr>
<tr><td><code id="ug_+3A_phase_cores">phase_cores</code></td>
<td>
<p>The number of parallel processes to use when estimating
the phase of a marker. (Should be no more than 4)</p>
</td></tr>
<tr><td><code id="ug_+3A_hmm">hmm</code></td>
<td>
<p>logical defining if the HMM must be applied to estimate multipoint
genetic distances</p>
</td></tr>
<tr><td><code id="ug_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="ug_+3A_verbose">verbose</code></td>
<td>
<p>A logical, if TRUE it output progress status
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Unidirectional Growth</em> (<em>UG</em>) is an algorithm for marker
ordering in linkage groups. It is not an exhaustive search method and,
therefore, is not computationally intensive. However, it does not guarantee
that the best order is always found. The only requirement is a matrix with
recombination fractions between markers.
</p>
<p>After determining the order with <em>UG</em>, the final map is constructed
using the multipoint approach (function <code><a href="#topic+map">map</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>sequence</code>, which is a list containing the
following components: </p>
<table>
<tr><td><code>seq.num</code></td>
<td>
<p>a <code>vector</code> containing the
(ordered) indices of markers in the sequence, according to the input file.</p>
</td></tr>
<tr><td><code>seq.phases</code></td>
<td>
<p>a <code>vector</code> with the linkage phases between markers
in the sequence, in corresponding positions. <code>-1</code> means that there are
no defined linkage phases.</p>
</td></tr> <tr><td><code>seq.rf</code></td>
<td>
<p>a <code>vector</code> with the
recombination frequencies between markers in the sequence. <code>-1</code> means
that there are no estimated recombination frequencies.</p>
</td></tr>
<tr><td><code>seq.like</code></td>
<td>
<p>log-likelihood of the corresponding linkage map.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>object of class <code>onemap</code> with the raw
data.</p>
</td></tr> <tr><td><code>twopt</code></td>
<td>
<p>object of class <code>rf_2pts</code> with the
2-point analyses.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Mollinari, M., Margarido, G. R. A., Vencovsky, R. and Garcia,
A. A. F. (2009) Evaluation of algorithms used to order markers on genetics
maps. <em>Heredity</em> 103: 494-502.
</p>
<p>Tan, Y. and Fu, Y. (2006) A novel method for estimating linkage maps.
<em>Genetics</em> 173: 2383-2390.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_seq">make_seq</a></code>, <code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #outcross example
  data(onemap_example_out)
  twopt &lt;- rf_2pts(onemap_example_out)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.ug &lt;- ug(LG1)

  #F2 example
  data(mapmaker_example_f2)
  twopt &lt;- rf_2pts(mapmaker_example_f2)
  all_mark &lt;- make_seq(twopt,"all")
  groups &lt;- group(all_mark)
  LG1 &lt;- make_seq(groups,1)
  LG1.ug &lt;- ug(LG1)
  LG1.ug

</code></pre>

<hr>
<h2 id='vcf_example_bc'>
Data generated from VCF file with biallelic markers from a f2 backcross population
</h2><span id='topic+vcf_example_bc'></span>

<h3>Description</h3>

<p>Simulated biallelic data set for an backcross population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("vcf_example_bc")</code></pre>


<h3>Format</h3>

<p>An object of class <code>onemap</code>.
</p>


<h3>Details</h3>

<p>A total of 142 backcross individuals were genotyped with 25 markers. The data
was generated from a VCF file. It contains chromossome and position
informations for each marker. It is included to be used as a example in
order to understand how to convert VCF file to OneMap input data with the functions 
<code>vcf2raw</code> and <code>onemap_read_vcfR</code>. 
</p>


<h3>Author(s)</h3>

<p>Cristiane Hayumi Taniguti, <a href="mailto:chaytaniguti@gmail.com">chaytaniguti@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> for details about objects of class
<code>onemap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcf_example_bc)
plot(vcf_example_bc) 
</code></pre>

<hr>
<h2 id='vcf_example_f2'>Data generated from VCF file with biallelic markers from a f2 intercross population</h2><span id='topic+vcf_example_f2'></span>

<h3>Description</h3>

<p>Simulated biallelic data set for an f2 population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vcf_example_f2)</code></pre>


<h3>Format</h3>

<p>An object of class <code>onemap</code>.
</p>


<h3>Details</h3>

<p>A total of 192 F2 individuals were genotyped with 25 markers. The data
was generated from a VCF file. It contains chromossome and position
informations for each marker. It is included to be used as a reference in
order to understand how to convert VCF file to OneMap input data. Also,
it is used for the analysis in the tutorial that comes with OneMap.
</p>


<h3>Author(s)</h3>

<p>Cristiane Hayumi Taniguti, <a href="mailto:chaytaniguti@gmail.com">chaytaniguti@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> for details about objects of class
<code>onemap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcf_example_f2)

# plot markers informations
plot(vcf_example_f2)
</code></pre>

<hr>
<h2 id='vcf_example_out'>Data generated from VCF file with biallelic markers from a full-sib family derived from two outbred parents</h2><span id='topic+vcf_example_out'></span>

<h3>Description</h3>

<p>Simulated biallelic data set for an outcross, i.e., an F1 population obtained by
crossing two non-homozygous parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vcf_example_out)</code></pre>


<h3>Format</h3>

<p>An object of class <code>onemap</code>.
</p>


<h3>Details</h3>

<p>A total of 92 F1 individuals were genotyped with 27 markers. The data
was generated from a VCF file. It contains chromossome and position
informations for each marker. It is included to be used as a reference in
order to understand how to convert VCF file to OneMap input data. Also,
it is used for the analysis in the tutorial that comes with OneMap.
</p>


<h3>Author(s)</h3>

<p>Cristiane Hayumi Taniguti, <a href="mailto:chaytaniguti@gmail.com">chaytaniguti@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> for details about objects of class
<code>onemap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcf_example_out)

# plot markers informations
plot(vcf_example_out)
</code></pre>

<hr>
<h2 id='vcf_example_riself'>
Data generated from VCF file with biallelic markers from a RIL population produced by selfing
</h2><span id='topic+vcf_example_riself'></span>

<h3>Description</h3>

<p>Simulated biallelic data set for an <code>ri self</code> population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("vcf_example_riself")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 10
$ geno         : num [1:92, 1:25] 3 3 1 3 1 3 3 1 3 1 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:92] &quot;ID1&quot; &quot;ID3&quot; &quot;ID4&quot; &quot;ID5&quot; ...
.. ..$ : chr [1:25] &quot;SNP16&quot; &quot;SNP12&quot; &quot;SNP17&quot; &quot;SNP10&quot; ...
$ n.ind        : int 92
$ n.mar        : int 25
$ segr.type    : chr [1:25] &quot;A.B&quot; &quot;A.B&quot; &quot;A.B&quot; &quot;A.B&quot; ...
$ segr.type.num: logi [1:25] NA NA NA NA NA NA ...
$ n.phe        : int 0
$ pheno        : NULL
$ CHROM        : chr [1:25] &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; ...
$ POS          : int [1:25] 1791 6606 9001 11326 11702 15533 17151 18637 19146 19220 ...
$ input        : chr &quot;vcf_example_riself.raw&quot;
- attr(*, &quot;class&quot;)= chr [1:2] &quot;onemap&quot; &quot;riself&quot;
</p>


<h3>Details</h3>

<p>A total of 92 rils individuals were genotyped with 25 markers. The data
was generated from a VCF file. It contains chromossome and position
informations for each marker. It is included to be used as a example in
order to understand how to convert VCF file to OneMap input data with the functions 
<code>vcf2raw</code> and <code>onemap_read_vcfR</code>. 
</p>


<h3>Author(s)</h3>

<p>Cristiane Hayumi Taniguti, <a href="mailto:chaytaniguti@gmail.com">chaytaniguti@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+read_onemap">read_onemap</a></code> for details about objects of class
<code>onemap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcf_example_riself)
plot(vcf_example_riself)
</code></pre>

<hr>
<h2 id='vcf2raw'>These functions are defunct and no longer available.</h2><span id='topic+vcf2raw'></span>

<h3>Description</h3>

<p>These functions are defunct and no longer available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcf2raw()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='write_map'>Write a genetic map to a file</h2><span id='topic+write_map'></span>

<h3>Description</h3>

<p>Write a genetic map to a file, base on a given map, or a list of maps. The
output file can be used as an input to perform QTL mapping using the package
R/qtl. It is also possible to create an output to be used with
QTLCartographer program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_map(map.list, file.out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_map_+3A_map.list">map.list</code></td>
<td>
<p>a map, i.e. an object of class <code>sequence</code> with a
predefined order, linkage phases, recombination fraction and likelihood or
a list of maps.</p>
</td></tr>
<tr><td><code id="write_map_+3A_file.out">file.out</code></td>
<td>
<p>output map file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is available only for backcross, F2 and RILs.
</p>


<h3>Value</h3>

<p>file with genetic map information
</p>
<p>Wang S., Basten, C. J. and Zeng Z.-B. (2010) Windows QTL Cartographer 2.5.
Department of Statistics, North Carolina State University, Raleigh, NC.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollina@usp.br">mmollina@usp.br</a>
</p>


<h3>References</h3>

<p>Broman, K. W., Wu, H., Churchill, G., Sen, S., Yandell, B.
(2008) <em>qtl: Tools for analyzing QTL experiments</em> R package version
1.09-43
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapmaker_example_f2)
twopt&lt;-rf_2pts(mapmaker_example_f2)
lg&lt;-group(make_seq(twopt, "all"))

##"pre-allocate" an empty list of length lg$n.groups (3, in this case)
maps.list&lt;-vector("list", lg$n.groups)

for(i in 1:lg$n.groups){
  ##create linkage group i
  LG.cur &lt;- make_seq(lg,i)
  ##ordering
  map.cur&lt;-order_seq(LG.cur, subset.search = "sample")
  ##assign the map of the i-th group to the maps.list
  maps.list[[i]]&lt;-make_seq(map.cur, "force")

  ##write maps.list to ".map" file
  write_map(maps.list, tempfile(fileext = ".map"))

}


</code></pre>

<hr>
<h2 id='write_onemap_raw'>Convert onemap object to onemap raw file</h2><span id='topic+write_onemap_raw'></span>

<h3>Description</h3>

<p>Converts onemap R object to onemap input file. The input file brings information about the mapping population:
First line: cross type, it can be &quot;outcrossing&quot;, &quot;f2 intercross&quot;, &quot;f2 backcross&quot;, &quot;ri self&quot; or &quot;ri sib&quot;.
Second line:  number of individuals, number of markers, presence (1) or absence (0) of chromossome and position of the markers, and number of phenotypes mesured.
Third line: Individuals/sample names; 
Followed lines: marker name, marker type and genotypes. One line for each marker.
Final lines: chromossome, position and phenotypes informations. 
See more about input file format at vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_onemap_raw(onemap.obj = NULL, file.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_onemap_raw_+3A_onemap.obj">onemap.obj</code></td>
<td>
<p>object of class 'onemap'</p>
</td></tr>
<tr><td><code id="write_onemap_raw_+3A_file.name">file.name</code></td>
<td>
<p>a character for the onemap raw file name. Default is &quot;out.raw&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a onemap input file
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>See Also</h3>

<p><code>read_onemap</code> for a description of the output object of class onemap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(onemap_example_out)
write_onemap_raw(onemap_example_out, file.name = paste0(tempfile(), ".raw"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
