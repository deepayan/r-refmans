<!DOCTYPE html><html><head><title>Help for package understandBPMN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {understandBPMN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activity_multiple_times_executed'><p>activity sometimes multiple times executed</p></a></li>
<li><a href='#activity_names_repetitions'><p>activity names repetitions</p></a></li>
<li><a href='#avg_connector_degree'><p>Average connector degree</p></a></li>
<li><a href='#calculate_metrics'><p>A calculation function for all metrics</p></a></li>
<li><a href='#coefficient_network_connectivity'><p>Coefficient of network connectivity</p></a></li>
<li><a href='#cognitive_weight'><p>Cognitive weights</p></a></li>
<li><a href='#connectivity_level_between_pools'><p>The connectivity level between pools</p></a></li>
<li><a href='#connector_heterogeneity'><p>Connector heterogeneity</p></a></li>
<li><a href='#connector_mismatch'><p>Connector mismatch</p></a></li>
<li><a href='#control_flow_complexity'><p>Control flow complexity</p></a></li>
<li><a href='#coupling_metric'><p>Coupling metric</p></a></li>
<li><a href='#create_internal_doc'><p>A function for creating internal documents</p></a></li>
<li><a href='#create_path_and_repetition_log'><p>Path and repetition log</p></a></li>
<li><a href='#cross_connectivity'><p>Cross Connectivity</p></a></li>
<li><a href='#cyclicity'><p>Cyclicity</p></a></li>
<li><a href='#cyclomatic_metric'><p>Cyclomatic metric of McCabe</p></a></li>
<li><a href='#density_process_model'><p>Density</p></a></li>
<li><a href='#depth'><p>Depth</p></a></li>
<li><a href='#diameter'><p>Diameter</p></a></li>
<li><a href='#direct_parallel_relations'><p>Direct and parallel relations</p></a></li>
<li><a href='#filtered_path_log_parallel'><p>Filter path log with only traces containing the parallel gateway together with the relevant activity</p></a></li>
<li><a href='#max_connector_degree'><p>Maximum connector degree</p></a></li>
<li><a href='#n_data_objects'><p>Data Objects</p></a></li>
<li><a href='#n_duplicate_tasks'><p>Duplicate tasks</p></a></li>
<li><a href='#n_empty_sequence_flows'><p>Empty sequence flows</p></a></li>
<li><a href='#n_message_flows'><p>Number of message flows</p></a></li>
<li><a href='#n_pools'><p>Number of pools</p></a></li>
<li><a href='#n_swimlanes'><p>Number of swimlanes</p></a></li>
<li><a href='#separability'><p>Separability</p></a></li>
<li><a href='#sequentiality'><p>Sequentiality</p></a></li>
<li><a href='#size_process_model'><p>Size</p></a></li>
<li><a href='#some_traces_without_activity'><p>activity sometimes not in traces</p></a></li>
<li><a href='#structuredness'><p>Structuredness</p></a></li>
<li><a href='#task_names'><p>Task names</p></a></li>
<li><a href='#token_split'><p>Token Split</p></a></li>
<li><a href='#traces_contain_relation'><p>Relation in traces</p></a></li>
<li><a href='#understandBPMN'><p>understandBPMN - understandability metrics for BPMN models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculator of Understandability Metrics for BPMN</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate several understandability metrics of BPMN models. BPMN stands for business process modelling notation and is a language for expressing business processes into business process diagrams. Examples of these understandability metrics are: average connector degree, maximum connector degree, sequentiality, cyclicity, diameter, depth, token split, control flow complexity, connector mismatch, connector heterogeneity, separability, structuredness and cross connectivity. See R documentation and paper on metric implementation included in this package for more information concerning the metrics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>XML, dplyr, purrr, tidyr, tibble, Rcpp (&ge; 0.12.15), devtools,
usethis, R.utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-27 09:47:06 UTC; lucp8407</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Lieben [aut],
  Gert Janssenswillen [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gert Janssenswillen &lt;gert.janssenswillen@uhasselt.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-27 11:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='activity_multiple_times_executed'>activity sometimes multiple times executed</h2><span id='topic+activity_multiple_times_executed'></span>

<h3>Description</h3>

<p> This functions returns true or false on whether or not an activity is sometimes multiple times executed
This can be useful for measuring the understandability using behavioral profiles.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>activity_multiple_times_executed(repetition_and_path_log, xml_internal_doc,
  activity, direct_parallel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activity_multiple_times_executed_+3A_repetition_and_path_log">repetition_and_path_log</code></td>
<td>
<p>repetition and path log list object created by the function create_repetition_and_path_log</p>
</td></tr>
<tr><td><code id="activity_multiple_times_executed_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="activity_multiple_times_executed_+3A_activity">activity</code></td>
<td>
<p>the activity name</p>
</td></tr>
<tr><td><code id="activity_multiple_times_executed_+3A_direct_parallel">direct_parallel</code></td>
<td>
<p>a table containing the direct and parallel relations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean value indicating whether it is true that an activity can be executed multiple times in the same path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: activity_multiple_times_executed(log, doc, "A")
</code></pre>

<hr>
<h2 id='activity_names_repetitions'>activity names repetitions</h2><span id='topic+activity_names_repetitions'></span>

<h3>Description</h3>

<p> This functions returns a list containing the repetitions with their respective activity names
This can be useful for measuring the understandability using behavioral profiles.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>activity_names_repetitions(repetition_and_path_log, xml_internal_doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activity_names_repetitions_+3A_repetition_and_path_log">repetition_and_path_log</code></td>
<td>
<p>repetition and path log list object created by the function create_repetition_and_path_log</p>
</td></tr>
<tr><td><code id="activity_names_repetitions_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the repetitions with their respective activity names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: activity_multiple_times_executed(log, doc, "A")
</code></pre>

<hr>
<h2 id='avg_connector_degree'>Average connector degree</h2><span id='topic+avg_connector_degree'></span>

<h3>Description</h3>

<p>Average connector degree is defined as the average incoming and outgoing sequence flows of all gateways and activities with at least two incoming or outgoing sequence flows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_connector_degree(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_connector_degree_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="avg_connector_degree_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the average connector degree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
avg_connector_degree(file_path)
</code></pre>

<hr>
<h2 id='calculate_metrics'>A calculation function for all metrics</h2><span id='topic+calculate_metrics'></span>

<h3>Description</h3>

<p>Creation object containing all metrics, which are :
the number of empty sequence flows, the number of duplicate tasks, the number of data objects, the number of pools, the number of swimlanes,
the number of message flows, the density, the coefficient of network connectivity, the average connector degree,
the maximum connector degree, the sequentiality, the cyclicity, the diameter, the depth, the token_split,
the control flow complexity, the connector mismatch, the connector heterogeneity and the crs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_metrics(file_path, cross_connectivity_metric = TRUE,
  signavio = FALSE, generate_new_path_log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_metrics_+3A_file_path">file_path</code></td>
<td>
<p>file path of the BPMN file and</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_cross_connectivity_metric">cross_connectivity_metric</code></td>
<td>
<p>a param indicating whether cross_connectivity shall be calculated as well</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with one row and for each metric a column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
calculate_metrics(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='coefficient_network_connectivity'>Coefficient of network connectivity</h2><span id='topic+coefficient_network_connectivity'></span>

<h3>Description</h3>

<p>Coefficient of network connectivity is defined as the number of sequence flows divided by the size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefficient_network_connectivity(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficient_network_connectivity_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="coefficient_network_connectivity_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the coefficient of network connectivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coefficient_network_connectivity(file_path)
</code></pre>

<hr>
<h2 id='cognitive_weight'>Cognitive weights</h2><span id='topic+cognitive_weight'></span>

<h3>Description</h3>

<p>Cognitive weight is defined as a weighted sum of gateways and activities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cognitive_weight(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cognitive_weight_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="cognitive_weight_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the control flow complexity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cognitive_weight(file_path)
</code></pre>

<hr>
<h2 id='connectivity_level_between_pools'>The connectivity level between pools</h2><span id='topic+connectivity_level_between_pools'></span>

<h3>Description</h3>

<p>The connectivity level between pools is the number of message flows over the number of pools
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity_level_between_pools(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_level_between_pools_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="connectivity_level_between_pools_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the connectivity level between pools
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
connectivity_level_between_pools(file_path)
</code></pre>

<hr>
<h2 id='connector_heterogeneity'>Connector heterogeneity</h2><span id='topic+connector_heterogeneity'></span>

<h3>Description</h3>

<p>Connector heterogeneity is defined as the sum of minus - p times the log of p of all gateways. p is defined as the number of a particular type of gateway divided by all gateways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connector_heterogeneity(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connector_heterogeneity_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="connector_heterogeneity_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the connector heterogeneity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
connector_heterogeneity(file_path)
</code></pre>

<hr>
<h2 id='connector_mismatch'>Connector mismatch</h2><span id='topic+connector_mismatch'></span>

<h3>Description</h3>

<p>Connector mismatch is the absolute value of the difference between split gateways and join gateways for each type of gateway, ie parallel, exclusive, inclusive, complex and event based gateways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connector_mismatch(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connector_mismatch_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="connector_mismatch_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the connector mismatch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
connector_mismatch(file_path)
</code></pre>

<hr>
<h2 id='control_flow_complexity'>Control flow complexity</h2><span id='topic+control_flow_complexity'></span>

<h3>Description</h3>

<p>Control flow complexity is defined as the sum of the outgoing of exclusive gateways, the number of parallel gateways
and two to the power of all outgoing sequence flows of the inclusive gateways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_flow_complexity(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_flow_complexity_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="control_flow_complexity_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the control flow complexity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
control_flow_complexity(file_path)
</code></pre>

<hr>
<h2 id='coupling_metric'>Coupling metric</h2><span id='topic+coupling_metric'></span>

<h3>Description</h3>

<p>Coupling metric is defined as the sum of the number of activities, AND-splits and a weighterd number of OR and XOR splits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coupling_metric(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coupling_metric_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="coupling_metric_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the control flow complexity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coupling_metric(file_path)
</code></pre>

<hr>
<h2 id='create_internal_doc'>A function for creating internal documents</h2><span id='topic+create_internal_doc'></span>

<h3>Description</h3>

<p>Is used for creating xml documents which nearly every function of this package needs as an input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_internal_doc(bpmn_file, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_internal_doc_+3A_bpmn_file">bpmn_file</code></td>
<td>
<p>file path of the BPMN file</p>
</td></tr>
<tr><td><code id="create_internal_doc_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object containing the xml document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
create_internal_doc(file_path)
</code></pre>

<hr>
<h2 id='create_path_and_repetition_log'>Path and repetition log</h2><span id='topic+create_path_and_repetition_log'></span>

<h3>Description</h3>

<p>This function returns a list with four or three nested list objects:
- One for the paths:
Assumption: if a path contains a loop, the path contains one repetition (so two times) of the execution of this loop
Assumption: there is no difference made between the type of gateways.
So the path log is not a path log according to the definition found in the literature, but more a kind of a path log
Assumption: for each split and join in the log, an extra element is added with the name &quot;split&quot; or &quot;join&quot;
- One list object for the loops (repetitions) which start with a join and end with a join
- One list object for the loops (repetitions) which start with a split and end with a split
( - One list for the paths in which all gateways have a certain type)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_path_and_repetition_log(file_path,
  add_path_log_for_structuredness = TRUE, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_path_and_repetition_log_+3A_file_path">file_path</code></td>
<td>
<p>internal document containing an xml</p>
</td></tr>
<tr><td><code id="create_path_and_repetition_log_+3A_add_path_log_for_structuredness">add_path_log_for_structuredness</code></td>
<td>
<p>a boolean value indicating whether the structured path log should be added. Is standard TRUE</p>
</td></tr>
<tr><td><code id="create_path_and_repetition_log_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the path log, a list of repetitions starting with join, a list of repetitions starting with split, (optional: structured path log)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
create_path_and_repetition_log(file_path)
</code></pre>

<hr>
<h2 id='cross_connectivity'>Cross Connectivity</h2><span id='topic+cross_connectivity'></span>

<h3>Description</h3>

<p>The cross-connectivity metric that measures the strength of the links between process model elements.
The definition of this new metric builds on the hypothesis that process models are easier understood and contain less errors if they have a high cross-connectivity.
The metric is calculated based on the creation of a data frame containing the values of all connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_connectivity(file_path, signavio = FALSE,
  path_log_already_created = FALSE, generate_new_path_log = FALSE,
  time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_connectivity_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="cross_connectivity_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="cross_connectivity_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="cross_connectivity_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="cross_connectivity_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the cross connectivity of a model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cross_connectivity(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='cyclicity'>Cyclicity</h2><span id='topic+cyclicity'></span>

<h3>Description</h3>

<p>Cyclicity is defined as the number of nodes on a cycle divided by the total number of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyclicity(file_path, signavio = FALSE,
  path_log_already_created = FALSE, generate_new_path_log = FALSE,
  time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclicity_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="cyclicity_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="cyclicity_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="cyclicity_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="cyclicity_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the cyclicity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cyclicity(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='cyclomatic_metric'>Cyclomatic metric of McCabe</h2><span id='topic+cyclomatic_metric'></span>

<h3>Description</h3>

<p>Cyclomatic metric takes into account the behavioral complexity of a process model. It is calculated by taking the number of activities minus
the number of events, gateways and connector activities plus the number of strongly connected components.
The number of strongly connected components is calculated by taking the number of exclusive gateways at depth level zero, when the depth is calculated only including exclusive gateways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyclomatic_metric(file_path, signavio = FALSE,
  path_log_already_created = FALSE, generate_new_path_log = FALSE,
  time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyclomatic_metric_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="cyclomatic_metric_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="cyclomatic_metric_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="cyclomatic_metric_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="cyclomatic_metric_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the coefficient of network connectivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cyclomatic_metric(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='density_process_model'>Density</h2><span id='topic+density_process_model'></span>

<h3>Description</h3>

<p>Density is defined as the number of sequence flows divided by the size times the size minus one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_process_model(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_process_model_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="density_process_model_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
density_process_model(file_path)
</code></pre>

<hr>
<h2 id='depth'>Depth</h2><span id='topic+depth'></span>

<h3>Description</h3>

<p>Depth is defined as the the nesting of the process model.
If there is a split gateway, the depth is increased with one.
If there is a join gateway, the depth is decreased with one.
The cumulative sum is taken and the maximum of the cumulative sum is calculated for each path.
The nesting depth is the maximum of each path value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(file_path, signavio = FALSE, path_log_already_created = FALSE,
  generate_new_path_log = FALSE, time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="depth_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="depth_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="depth_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="depth_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the depth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
depth(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='diameter'>Diameter</h2><span id='topic+diameter'></span>

<h3>Description</h3>

<p>Length of longest path, in practice the length of longest path.
The assumption is made that one repetition for each loop is allowed and these repetitions count as well for the diameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diameter(file_path, signavio = FALSE, path_log_already_created = FALSE,
  generate_new_path_log = FALSE, time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="diameter_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="diameter_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="diameter_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="diameter_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the diameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
diameter(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='direct_parallel_relations'>Direct and parallel relations</h2><span id='topic+direct_parallel_relations'></span>

<h3>Description</h3>

<p> This functions returns a table containing all direct and parallel relations between activities. The table contains five columns:
- the two first represent activity ids
- the third represents the type of relations, which is parallel or direct
- the last two columns are the corresponding activity names for the first two columns

</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_parallel_relations(repetition_and_path_log, xml_internal_doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct_parallel_relations_+3A_repetition_and_path_log">repetition_and_path_log</code></td>
<td>
<p>repetition and path log list object created by the function create_repetition_and_path_log</p>
</td></tr>
<tr><td><code id="direct_parallel_relations_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table as described in the description
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: direct_parallel_relations(repetition_and_path_log, xml_internal_doc)
</code></pre>

<hr>
<h2 id='filtered_path_log_parallel'>Filter path log with only traces containing the parallel gateway together with the relevant activity</h2><span id='topic+filtered_path_log_parallel'></span>

<h3>Description</h3>

<p> This functions returns a path log with no traces with a parallel gateway of which the given activity is part but not included

</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtered_path_log_parallel(structured_path_log, xml_internal_doc,
  activity_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtered_path_log_parallel_+3A_structured_path_log">structured_path_log</code></td>
<td>
<p>repetition and path log list object created by the function create_repetition_and_path_log</p>
</td></tr>
<tr><td><code id="filtered_path_log_parallel_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="filtered_path_log_parallel_+3A_activity_name">activity_name</code></td>
<td>
<p>name of the activity for the relevant filtering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the filtered path log
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: direct_parallel_relations(repetition_and_path_log, xml_internal_doc)
</code></pre>

<hr>
<h2 id='max_connector_degree'>Maximum connector degree</h2><span id='topic+max_connector_degree'></span>

<h3>Description</h3>

<p>Maximum connector degree is defined as the gateway or activity with the most incoming and outgoing sequence flows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_connector_degree(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_connector_degree_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="max_connector_degree_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the maximum connector degree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
max_connector_degree(file_path)
</code></pre>

<hr>
<h2 id='n_data_objects'>Data Objects</h2><span id='topic+n_data_objects'></span>

<h3>Description</h3>

<p>The number of data objects includes all data objects and data stores of a BPMN diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_data_objects(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_data_objects_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="n_data_objects_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the number of data objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_data_objects(file_path)
</code></pre>

<hr>
<h2 id='n_duplicate_tasks'>Duplicate tasks</h2><span id='topic+n_duplicate_tasks'></span>

<h3>Description</h3>

<p>Duplicate tasks are tasks which share the same name with other tasks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_duplicate_tasks(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_duplicate_tasks_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="n_duplicate_tasks_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the number of duplicate tasks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_duplicate_tasks(file_path)
</code></pre>

<hr>
<h2 id='n_empty_sequence_flows'>Empty sequence flows</h2><span id='topic+n_empty_sequence_flows'></span>

<h3>Description</h3>

<p>Empty sequence flow is defined as a flow which connects a split parallel gateway with a join parallel gateway without any tasks in between
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_empty_sequence_flows(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_empty_sequence_flows_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="n_empty_sequence_flows_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the number of empty sequence flows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_empty_sequence_flows(file_path)
</code></pre>

<hr>
<h2 id='n_message_flows'>Number of message flows</h2><span id='topic+n_message_flows'></span>

<h3>Description</h3>

<p>Number of message flows. Message flows are used for communication between processes and link message events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_message_flows(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_message_flows_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="n_message_flows_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the number of message flows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_message_flows(file_path)
</code></pre>

<hr>
<h2 id='n_pools'>Number of pools</h2><span id='topic+n_pools'></span>

<h3>Description</h3>

<p>Number of pools in the process models. A pool represents an organisation or an entity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_pools(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_pools_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="n_pools_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the number of pools
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_pools(file_path)
</code></pre>

<hr>
<h2 id='n_swimlanes'>Number of swimlanes</h2><span id='topic+n_swimlanes'></span>

<h3>Description</h3>

<p>Number of swimlanes in the pools. A swimlane represents a person, role or team
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_swimlanes(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_swimlanes_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="n_swimlanes_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the number of swimlanes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_swimlanes(file_path)
</code></pre>

<hr>
<h2 id='separability'>Separability</h2><span id='topic+separability'></span>

<h3>Description</h3>

<p>A cut vertex is a node which if removed, splits the diagram into two pieces
The consequence is that elements which are part of each path can be defined as a cut vertex
Separability is defined as the number of cut vertices divided by (the size of the model - 2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separability(file_path, signavio = FALSE,
  path_log_already_created = FALSE, generate_new_path_log = FALSE,
  time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separability_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="separability_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="separability_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="separability_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="separability_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the separability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
separability(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='sequentiality'>Sequentiality</h2><span id='topic+sequentiality'></span>

<h3>Description</h3>

<p>Sequentiality is defined as the number of sequence flows connecting two tasks divided by the total number of sequence flows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequentiality(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequentiality_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="sequentiality_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the sequentiality
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sequentiality(file_path)
</code></pre>

<hr>
<h2 id='size_process_model'>Size</h2><span id='topic+size_process_model'></span>

<h3>Description</h3>

<p>The size of a model is the number of tasks, gateways and events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size_process_model(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_process_model_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="size_process_model_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
size_process_model(file_path)
</code></pre>

<hr>
<h2 id='some_traces_without_activity'>activity sometimes not in traces</h2><span id='topic+some_traces_without_activity'></span>

<h3>Description</h3>

<p> This functions returns true or false on whether or not an activity is sometimes not part of a trace
This can be useful for measuring the understandability using behavioral profiles.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>some_traces_without_activity(repetition_and_path_log, xml_internal_doc,
  activity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="some_traces_without_activity_+3A_repetition_and_path_log">repetition_and_path_log</code></td>
<td>
<p>repetition and path log list object created by the function create_repetition_and_path_log</p>
</td></tr>
<tr><td><code id="some_traces_without_activity_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="some_traces_without_activity_+3A_activity">activity</code></td>
<td>
<p>the activity name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean value indicating whether it is true on whether or not an activity is sometimes not part of a trace
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: some_traces_without_activity(log, doc, "A")
</code></pre>

<hr>
<h2 id='structuredness'>Structuredness</h2><span id='topic+structuredness'></span>

<h3>Description</h3>

<p>Structuredness measures to which extent the process model can be divided into block structured structures (matching gateways)
Calculation: 1 - size of reduced process model / size of normal process model
To get the reduced process model, the following rules are applied:
-removal of trivial constructs (one incoming and one outgoing sequence flow)
-removal of matching gateways (for loops, this means first a join then a split, for all other gateways, it's the other way around)
-loops with other than XOR-gateways and non-matching gateways are kept
-gateways which are the consequence of multiple start or end events are removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structuredness(file_path, signavio = FALSE,
  path_log_already_created = FALSE, generate_new_path_log = FALSE,
  time_to_generate_path_log = 1500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structuredness_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="structuredness_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
<tr><td><code id="structuredness_+3A_path_log_already_created">path_log_already_created</code></td>
<td>
<p>boolean which indicates whether the path log has already been created before or not. When you are not sure, it is best to use the standard which is false</p>
</td></tr>
<tr><td><code id="structuredness_+3A_generate_new_path_log">generate_new_path_log</code></td>
<td>
<p>used when it is not possible to save the path log such as with the Rapid miner or in unit tests and examples</p>
</td></tr>
<tr><td><code id="structuredness_+3A_time_to_generate_path_log">time_to_generate_path_log</code></td>
<td>
<p>time which is the maximum time to generate a new path log in seconds. The standard setting is 1500 seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the structuredness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structuredness(file_path, generate_new_path_log = TRUE)
</code></pre>

<hr>
<h2 id='task_names'>Task names</h2><span id='topic+task_names'></span>

<h3>Description</h3>

<p>A function which returns the task names together with the task ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>task_names(xml_internal_doc, filter_non_connector_activities = FALSE,
  signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="task_names_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="task_names_+3A_filter_non_connector_activities">filter_non_connector_activities</code></td>
<td>
<p>attribute indicating whether non connector activities should be filtered. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="task_names_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object containing a table with the IDs and tasknames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
task_names(create_internal_doc(file_path))
</code></pre>

<hr>
<h2 id='token_split'>Token Split</h2><span id='topic+token_split'></span>

<h3>Description</h3>

<p>Token split is defined as the sum of the outgoing flows of parallel, inclusive and complex gateways minus one,
because otherwise the token_split value is always one, while it should be zero if there are
</p>


<h3>Usage</h3>

<pre><code class='language-R'>token_split(file_path, signavio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="token_split_+3A_file_path">file_path</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="token_split_+3A_signavio">signavio</code></td>
<td>
<p>boolean which indicates whether the file stems from signavio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer indicating the token_split
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
token_split(file_path)
</code></pre>

<hr>
<h2 id='traces_contain_relation'>Relation in traces</h2><span id='topic+traces_contain_relation'></span>

<h3>Description</h3>

<p> This functions returns true or false on whether there exists always or sometimes an (indirect) relation between two activities in a process model.
This can be useful for measuring the understandability using behavioral profiles. Always means that wheneve activity 1 is part of the trace, activity 2 will some time follow activity 1.
Sometimes means that there should be at least one case where there is an indirect relation and at least one case where there is not.
The indirect relations between two activities due to a parallel construct are left out of scope for this function.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>traces_contain_relation(repetition_and_path_log, xml_internal_doc,
  activity_1, activity_2, always = TRUE, filter_indirect = TRUE,
  precede = FALSE, alternate_response = FALSE,
  alternate_precedence = FALSE, chain_response = FALSE,
  chain_precedence = FALSE, negation_alternate_precedence = FALSE,
  negation_alternate_response = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traces_contain_relation_+3A_repetition_and_path_log">repetition_and_path_log</code></td>
<td>
<p>repetition and path log list object created by the function create_repetition_and_path_log</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_xml_internal_doc">xml_internal_doc</code></td>
<td>
<p>document object created using the create_internal_document function</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_activity_1">activity_1</code></td>
<td>
<p>the activity name of the first activity</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_activity_2">activity_2</code></td>
<td>
<p>the activity name of the second activity in the relation</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_always">always</code></td>
<td>
<p>a boolean value indicating whether there should be always a direct relation. If it is false, it is assumed to be tested for the sometimes case.</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_filter_indirect">filter_indirect</code></td>
<td>
<p>a boolean value indicating whether indirect relations are targeted. If not, all relations are used</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_precede">precede</code></td>
<td>
<p>a boolean value indicating whether precede or follows relation is tested</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_alternate_response">alternate_response</code></td>
<td>
<p>a boolean indicating whether an alternate response relation is tested</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_alternate_precedence">alternate_precedence</code></td>
<td>
<p>a boolean indicating whether an alternate precedence relation is tested</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_chain_response">chain_response</code></td>
<td>
<p>a boolean indicating whether a chain response relation is tested</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_chain_precedence">chain_precedence</code></td>
<td>
<p>a boolean indicating whether a chain precedence relation is tested</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_negation_alternate_precedence">negation_alternate_precedence</code></td>
<td>
<p>a boolean indicating whether a negation alternate precedence relation is tested</p>
</td></tr>
<tr><td><code id="traces_contain_relation_+3A_negation_alternate_response">negation_alternate_response</code></td>
<td>
<p>a boolean indicating whether a negation alternate response relation is tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean value indicating whether it is true that there is always or sometimes an indirect relation between activity_1 and activity_2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: traces_contain_relation(log, doc, "A", "F", TRUE, TRUE)
</code></pre>

<hr>
<h2 id='understandBPMN'>understandBPMN - understandability metrics for BPMN models</h2><span id='topic+understandBPMN'></span><span id='topic+understandBPMN-package'></span>

<h3>Description</h3>

<p>This package provides the implementation of several comprehensibility and complexity metrics for BPMN models
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
