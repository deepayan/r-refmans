<!DOCTYPE html><html><head><title>Help for package mixvlmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixvlmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_covlmc'><p>Convert an object to a Variable Length Markov Chain with covariates (coVLMC)</p></a></li>
<li><a href='#as_sequence'><p>Extract the sequence encoded by a node</p></a></li>
<li><a href='#as_vlmc'><p>Convert an object to a Variable Length Markov Chain (VLMC)</p></a></li>
<li><a href='#as_vlmc.ctx_tree_cpp'><p>Convert an object to a Variable Length Markov Chain (VLMC)</p></a></li>
<li><a href='#autoplot.tune_covlmc'><p>Create a complete ggplot for the results of automatic COVLMC complexity</p>
selection</a></li>
<li><a href='#autoplot.tune_vlmc'><p>Create a complete ggplot for the results of automatic VLMC complexity</p>
selection</a></li>
<li><a href='#children'><p>Find the children nodes of a node in a context tree</p></a></li>
<li><a href='#context_number'><p>Number of contexts of a context tree</p></a></li>
<li><a href='#context_number.covlmc'><p>Contexts number of a VLMC with covariates</p></a></li>
<li><a href='#contexts'><p>Contexts of a context tree</p></a></li>
<li><a href='#contexts.covlmc'><p>Contexts of a VLMC with covariates</p></a></li>
<li><a href='#contexts.ctx_tree'><p>Contexts of a context tree</p></a></li>
<li><a href='#contexts.vlmc'><p>Contexts of a VLMC</p></a></li>
<li><a href='#counts'><p>Report the distribution of values that follow occurrences of a sequence</p></a></li>
<li><a href='#covariate_depth'><p>Maximal covariate memory of a VLMC with covariates</p></a></li>
<li><a href='#covariate_memory'><p>Covariate memory length for a COVLMC context</p></a></li>
<li><a href='#covlmc'><p>Fit a Variable Length Markov Chain with Covariates (coVLMC)</p></a></li>
<li><a href='#covlmc_control'><p>Control for coVLMC fitting</p></a></li>
<li><a href='#ctx_tree'><p>Build a context tree for a discrete time series</p></a></li>
<li><a href='#cutoff'><p>Cut off values for VLMC like model</p></a></li>
<li><a href='#cutoff.covlmc'><p>Cut off values for pruning the context tree of a VLMC with covariates</p></a></li>
<li><a href='#cutoff.ctx_node'><p>Cut off value for pruning a node in the context tree of a VLMC</p></a></li>
<li><a href='#cutoff.vlmc'><p>Cut off values for pruning the context tree of a VLMC</p></a></li>
<li><a href='#depth'><p>Depth of a context tree</p></a></li>
<li><a href='#draw'><p>Text based representation of a context tree</p></a></li>
<li><a href='#draw_control'><p>Control parameters for <code>draw</code></p></a></li>
<li><a href='#draw.covlmc'><p>Text based representation of a covlmc model</p></a></li>
<li><a href='#draw.ctx_tree_cpp'><p>Text based representation of a context tree</p></a></li>
<li><a href='#draw.vlmc'><p>Text based representation of a vlmc</p></a></li>
<li><a href='#find_sequence'><p>Find the node of a sequence in a context tree</p></a></li>
<li><a href='#find_sequence.covlmc'><p>Find the node of a sequence in a COVLMC context tree</p></a></li>
<li><a href='#globalearthquake'><p>Significant Earthquake Dataset</p></a></li>
<li><a href='#is_context'><p>Report the nature of a node in a context tree</p></a></li>
<li><a href='#is_covlmc'><p>Test if the object is a covlmc model</p></a></li>
<li><a href='#is_ctx_tree'><p>Test if the object is a context tree</p></a></li>
<li><a href='#is_merged'><p>Merging status of a COVLMC context</p></a></li>
<li><a href='#is_reversed'><p>Report the ordering convention of the node</p></a></li>
<li><a href='#is_vlmc'><p>Test if the object is a vlmc model</p></a></li>
<li><a href='#logLik.covlmc'><p>Log-Likelihood of a VLMC with covariates</p></a></li>
<li><a href='#logLik.vlmc'><p>Log-Likelihood of a VLMC</p></a></li>
<li><a href='#loglikelihood'><p>Log-Likelihood of a VLMC</p></a></li>
<li><a href='#loglikelihood.covlmc'><p>Log-Likelihood of a VLMC with covariates</p></a></li>
<li><a href='#merged_with'><p>Merged contexts in a COVLMC</p></a></li>
<li><a href='#metrics'><p>Predictive quality metrics for context based models</p></a></li>
<li><a href='#metrics.covlmc'><p>Predictive quality metrics for VLMC with covariates</p></a></li>
<li><a href='#metrics.ctx_node'><p>Predictive quality metrics for a node of a context tree</p></a></li>
<li><a href='#metrics.ctx_node_covlmc'><p>Predictive quality metrics for a node of a COVLMC context tree</p></a></li>
<li><a href='#metrics.vlmc'><p>Predictive quality metrics for VLMC</p></a></li>
<li><a href='#mixvlmc-package'><p>mixvlmc: Variable Length Markov Chains with Covariates</p></a></li>
<li><a href='#model'><p>Logistic model of a COVLMC context</p></a></li>
<li><a href='#parent'><p>Find the parent of a node in a context tree</p></a></li>
<li><a href='#plot.tune_vlmc'><p>Plot the results of automatic (CO)VLMC complexity selection</p></a></li>
<li><a href='#positions'><p>Report the positions of a sequence associated to a node</p></a></li>
<li><a href='#powerconsumption'><p>Individual household electric power consumption</p></a></li>
<li><a href='#predict.covlmc'><p>Next state prediction in a discrete time series for a VLMC with covariates</p></a></li>
<li><a href='#predict.vlmc'><p>Next state prediction in a discrete time series for a VLMC</p></a></li>
<li><a href='#print.contexts'><p>Print a context list</p></a></li>
<li><a href='#prune'><p>Prune a Variable Length Markov Chain (VLMC)</p></a></li>
<li><a href='#prune.covlmc'><p>Prune a Variable Length Markov Chain with covariates</p></a></li>
<li><a href='#rev.ctx_node'><p>Reverse Sequence</p></a></li>
<li><a href='#simulate.covlmc'><p>Simulate a discrete time series for a covlmc</p></a></li>
<li><a href='#simulate.vlmc'><p>Simulate a discrete time series for a vlmc</p></a></li>
<li><a href='#simulate.vlmc_cpp'><p>Simulate a discrete time series for a vlmc</p></a></li>
<li><a href='#states'><p>State space of a context tree</p></a></li>
<li><a href='#trim'><p>Trim a context tree</p></a></li>
<li><a href='#trim.covlmc'><p>Trim a COVLMC</p></a></li>
<li><a href='#trim.vlmc'><p>This function returns a trimmed VLMC from which match positions have been</p>
removed.</a></li>
<li><a href='#trim.vlmc_cpp'><p>This function returns a trimmed VLMC from which match positions have been</p>
removed.</a></li>
<li><a href='#tune_covlmc'><p>Fit an optimal Variable Length Markov Chain with Covariates (coVLMC)</p></a></li>
<li><a href='#tune_vlmc'><p>Fit an optimal Variable Length Markov Chain (VLMC)</p></a></li>
<li><a href='#vlmc'><p>Fit a Variable Length Markov Chain (VLMC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variable Length Markov Chains with Covariates</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates Variable Length Markov Chains (VLMC) models and VLMC with
    covariates models from discrete sequences. Supports model selection via
    information criteria and simulation of new sequences from an estimated
    model. See BÃ¼hlmann, P. and Wyner, A. J. (1999) &lt;<a href="https://doi.org/10.1214%2Faos%2F1018031204">doi:10.1214/aos/1018031204</a>&gt;
    for VLMC and Zanin Zambom, A., Kim, S. and Lopes Garcia, N. (2022)
    &lt;<a href="https://doi.org/10.1111%2Fjtsa.12615">doi:10.1111/jtsa.12615</a>&gt; for VLMC with covariates.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fabrice-rossi/mixvlmc">https://github.com/fabrice-rossi/mixvlmc</a>,
<a href="https://fabrice-rossi.github.io/mixvlmc/">https://fabrice-rossi.github.io/mixvlmc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fabrice-rossi/mixvlmc/issues">https://github.com/fabrice-rossi/mixvlmc/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, butcher, ggplot2, methods, nnet, pROC, Rcpp (&ge;
1.0.8.3), rlang, stats, stringr, VGAM, withr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table, foreach, geodist, knitr, rmarkdown, testthat (&ge;
3.0.0), tibble, vdiffr, waldo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>covlmc*</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 20:39:33 UTC; fabrice</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabrice Rossi <a href="https://orcid.org/0000-0003-4638-1286"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Hugo Le Picard <a href="https://orcid.org/0000-0002-7023-2996"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  GuÃ©nolÃ© Joubioux [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabrice Rossi &lt;Fabrice.Rossi@apiacoa.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-31 16:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_covlmc'>Convert an object to a Variable Length Markov Chain with covariates (coVLMC)</h2><span id='topic+as_covlmc'></span><span id='topic+as_covlmc.tune_covlmc'></span>

<h3>Description</h3>

<p>This generic function converts an object into a covlmc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_covlmc(x, ...)

## S3 method for class 'tune_covlmc'
as_covlmc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_covlmc_+3A_x">x</code></td>
<td>
<p>an object to convert into a covlmc.</p>
</td></tr>
<tr><td><code id="as_covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for conversion functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a covlmc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tune_covlmc">tune_covlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## conversion from the results of tune_covlmc
pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
dts_best_model_tune &lt;- tune_covlmc(dts, dts_cov)
dts_best_model &lt;- as_covlmc(dts_best_model_tune)
draw(dts_best_model)
</code></pre>

<hr>
<h2 id='as_sequence'>Extract the sequence encoded by a node</h2><span id='topic+as_sequence'></span>

<h3>Description</h3>

<p>This function returns the sequence represented by the <code>node</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sequence(node, reverse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sequence_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
<tr><td><code id="as_sequence_+3A_reverse">reverse</code></td>
<td>
<p>specifies whether the sequence should be reported in reverse
temporal order (<code>TRUE</code>) or in the temporal order (<code>FALSE</code>). Defaults to the
order associated to the <code>ctx_node</code> which is determined by the parameters of
the call to <code><a href="#topic+contexts">contexts()</a></code> or <code><a href="#topic+find_sequence">find_sequence()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sequence represented by the <code>node</code> object, a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c("A", "B", "C", "A", "A", "B", "B", "C", "C", "A")
dts_tree &lt;- ctx_tree(dts, max_depth = 3)
res &lt;- find_sequence(dts_tree, "A")
as_sequence(res)
</code></pre>

<hr>
<h2 id='as_vlmc'>Convert an object to a Variable Length Markov Chain (VLMC)</h2><span id='topic+as_vlmc'></span><span id='topic+as_vlmc.ctx_tree'></span><span id='topic+as_vlmc.tune_vlmc'></span>

<h3>Description</h3>

<p>This generic function converts an object into a vlmc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_vlmc(x, ...)

## S3 method for class 'ctx_tree'
as_vlmc(x, alpha, cutoff, ...)

## S3 method for class 'tune_vlmc'
as_vlmc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_vlmc_+3A_x">x</code></td>
<td>
<p>an object to convert into a vlmc.</p>
</td></tr>
<tr><td><code id="as_vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for conversion functions.</p>
</td></tr>
<tr><td><code id="as_vlmc_+3A_alpha">alpha</code></td>
<td>
<p>cut off parameter applied during the conversion, quantile scale
(if specified)</p>
</td></tr>
<tr><td><code id="as_vlmc_+3A_cutoff">cutoff</code></td>
<td>
<p>cut off parameter applied during the conversion, native scale
(if specified)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a context tree into a VLMC. If <code>alpha</code> or
<code>cutoff</code> is specified, it is used to reduce the complexity of the tree as in
a direct call to <code><a href="#topic+vlmc">vlmc()</a></code> (<code><a href="#topic+prune">prune()</a></code>).
</p>


<h3>Value</h3>

<p>a vlmc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctx_tree">ctx_tree()</a></code>
</p>
<p><code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## conversion from a context tree
dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
draw(dts_ctree)
dts_vlmc &lt;- as_vlmc(dts_ctree)
class(dts_vlmc)
draw(dts_vlmc)
## conversion from the result of tune_vlmc
dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
tune_result &lt;- tune_vlmc(dts)
tune_result
dts_best_vlmc &lt;- as_vlmc(tune_result)
draw(dts_best_vlmc)
</code></pre>

<hr>
<h2 id='as_vlmc.ctx_tree_cpp'>Convert an object to a Variable Length Markov Chain (VLMC)</h2><span id='topic+as_vlmc.ctx_tree_cpp'></span>

<h3>Description</h3>

<p>This generic function converts an object into a vlmc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_tree_cpp'
as_vlmc(x, alpha, cutoff, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_vlmc.ctx_tree_cpp_+3A_x">x</code></td>
<td>
<p>an object to convert into a vlmc.</p>
</td></tr>
<tr><td><code id="as_vlmc.ctx_tree_cpp_+3A_alpha">alpha</code></td>
<td>
<p>cut off parameter applied during the conversion, quantile scale
(if specified)</p>
</td></tr>
<tr><td><code id="as_vlmc.ctx_tree_cpp_+3A_cutoff">cutoff</code></td>
<td>
<p>cut off parameter applied during the conversion, native scale
(if specified)</p>
</td></tr>
<tr><td><code id="as_vlmc.ctx_tree_cpp_+3A_...">...</code></td>
<td>
<p>additional arguments for conversion functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a context tree into a VLMC. If <code>alpha</code> or
<code>cutoff</code> is specified, it is used to reduce the complexity of the tree as in
a direct call to <code><a href="#topic+vlmc">vlmc()</a></code> (<code><a href="#topic+prune">prune()</a></code>).
</p>


<h3>Value</h3>

<p>a vlmc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctx_tree">ctx_tree()</a></code>
</p>
<p><code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## conversion from a context tree
dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3, backend = "C++")
draw(dts_ctree)
dts_vlmc &lt;- as_vlmc(dts_ctree)
class(dts_vlmc)
draw(dts_vlmc)

</code></pre>

<hr>
<h2 id='autoplot.tune_covlmc'>Create a complete ggplot for the results of automatic COVLMC complexity
selection</h2><span id='topic+autoplot.tune_covlmc'></span>

<h3>Description</h3>

<p>This function prepares a plot of the results of <code><a href="#topic+tune_covlmc">tune_covlmc()</a></code> using
ggplot2. The result can be passed to <code><a href="base.html#topic+print">print()</a></code> to display the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune_covlmc'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.tune_covlmc_+3A_object">object</code></td>
<td>
<p>a <code>tune_covlmc</code> object</p>
</td></tr>
<tr><td><code id="autoplot.tune_covlmc_+3A_...">...</code></td>
<td>
<p>additional parameters (not used currently)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graphical representation proposed by this function is complete, while the
one produced by <code><a href="#topic+plot.tune_covlmc">plot.tune_covlmc()</a></code> is minimalistic. We use here the
faceting capabilities of ggplot2 to combine on a single graphical
representation the evolution of multiple characteristics of the VLMC during
the pruning process, while <code><a href="#topic+plot.tune_covlmc">plot.tune_covlmc()</a></code> shows only the selection
criterion or the log likelihood. Each facet of the resulting plot shows a
quantity as a function of the cut off expressed in quantile or native scale.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week %in% 10:12, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
dts_best_model_tune &lt;- tune_covlmc(dts, dts_cov, criterion = "AIC")
covlmc_plot &lt;- ggplot2::autoplot(dts_best_model_tune)
print(covlmc_plot)

</code></pre>

<hr>
<h2 id='autoplot.tune_vlmc'>Create a complete ggplot for the results of automatic VLMC complexity
selection</h2><span id='topic+autoplot.tune_vlmc'></span>

<h3>Description</h3>

<p>This function prepares a plot of the results of <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code> using ggplot2.
The result can be passed to <code><a href="base.html#topic+print">print()</a></code> to display the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune_vlmc'
autoplot(object, cutoff = c("quantile", "native"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.tune_vlmc_+3A_object">object</code></td>
<td>
<p>a <code>tune_vlmc</code> object</p>
</td></tr>
<tr><td><code id="autoplot.tune_vlmc_+3A_cutoff">cutoff</code></td>
<td>
<p>the scale used for the cut off criterion (default &quot;quantile&quot;)</p>
</td></tr>
<tr><td><code id="autoplot.tune_vlmc_+3A_...">...</code></td>
<td>
<p>additional parameters (not used currently)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graphical representation proposed by this function is complete, while the
one produced by <code><a href="#topic+plot.tune_vlmc">plot.tune_vlmc()</a></code> is minimalistic. We use here the faceting
capabilities of ggplot2 to combine on a single graphical representation the
evolution of multiple characteristics of the VLMC during the pruning process,
while <code><a href="#topic+plot.tune_vlmc">plot.tune_vlmc()</a></code> shows only the selection criterion or the log
likelihood. Each facet of the resulting plot shows a quantity as a function
of the cut off expressed in quantile or native scale.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week %in% 10:11, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_best_model_tune &lt;- tune_vlmc(dts, criterion = "BIC")
vlmc_plot &lt;- ggplot2::autoplot(dts_best_model_tune)
print(vlmc_plot)
## simple post customisation
print(vlmc_plot + ggplot2::geom_point())
</code></pre>

<hr>
<h2 id='children'>Find the children nodes of a node in a context tree</h2><span id='topic+children'></span><span id='topic+children.ctx_node'></span><span id='topic+children.ctx_node_cpp'></span>

<h3>Description</h3>

<p>This function returns a list (possibly empty) of <code>ctx_node</code> objects. Each
object represents one of the children of the node represented by the <code>node</code>
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>children(node)

## S3 method for class 'ctx_node'
children(node)

## S3 method for class 'ctx_node_cpp'
children(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="children_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each node of a context tree represents a sequence. When <code><a href="#topic+find_sequence">find_sequence()</a></code> is
called with success, the returned object represents the corresponding node in
the context tree. If this node has no child, the present function returns an
empty list. When the node has at least one child, the function returns a list
with one value for each element in the state space (see <code><a href="#topic+states">states()</a></code>). The
value is <code>NULL</code> if the corresponding child is empty, while it is a <code>ctx_node</code>
object when the child is present. Each <code>ctx_node</code> object is associated to the
sequence obtained by adding to the past of the sequence represented by <code>node</code>
an observation of the associated state (this corresponds to an extension to
the left of the sequence in temporal order).
</p>


<h3>Value</h3>

<p>a list of <code>ctx_node</code> objects, see details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
ctx_00 &lt;- find_sequence(dts_ctree, c(0, 0))
## this context can only be extended in the past by 1:
children(ctx_00)
ctx_10 &lt;- find_sequence(dts_ctree, c(1, 0))
## this context can be extended by both states
children(ctx_10)
## C++ backend
dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3, backend = "C++")
ctx_00 &lt;- find_sequence(dts_ctree, c(0, 0))
## this context can only be extended in the past by 1:
children(ctx_00)
ctx_10 &lt;- find_sequence(dts_ctree, c(1, 0))
## this context can be extended by both states
children(ctx_10)
</code></pre>

<hr>
<h2 id='context_number'>Number of contexts of a context tree</h2><span id='topic+context_number'></span>

<h3>Description</h3>

<p>This function returns the number of distinct contexts in a context tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>context_number(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_number_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of contexts of the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
# should be 8
context_number(dts_ctree)
</code></pre>

<hr>
<h2 id='context_number.covlmc'>Contexts number of a VLMC with covariates</h2><span id='topic+context_number.covlmc'></span>

<h3>Description</h3>

<p>This function returns the total number of contexts of a VLMC with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
context_number(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_number.covlmc_+3A_ct">ct</code></td>
<td>
<p>a fitted covlmc model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of contexts present in the VLMC with covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 10)
# should be 3
context_number(m_cov)
</code></pre>

<hr>
<h2 id='contexts'>Contexts of a context tree</h2><span id='topic+contexts'></span>

<h3>Description</h3>

<p>This function extracts from a context tree a description of all of its
contexts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contexts(ct, sequence = FALSE, reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contexts_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="contexts_+3A_sequence">sequence</code></td>
<td>
<p>if <code>TRUE</code> the function returns its results as a <code>data.frame</code>,
if <code>FALSE</code> (default) as a list of <code>ctx_node</code> objects. (see details)</p>
</td></tr>
<tr><td><code id="contexts_+3A_reverse">reverse</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>). See details.</p>
</td></tr>
<tr><td><code id="contexts_+3A_...">...</code></td>
<td>
<p>additional arguments for the contexts function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour consists in returning a list of all the contexts
contained in the tree using <code>ctx_node</code> objects (as returned by e.g.
<code><a href="#topic+find_sequence">find_sequence()</a></code>) (with <code>type="list"</code>). The properties of the contexts can
then be explored using adapted functions such as <code><a href="#topic+counts">counts()</a></code> and
<code><a href="#topic+positions">positions()</a></code>. The result list is of class <code>contexts</code>. When <code>sequence=TRUE</code>,
the method returns a data.frame whose first column, named <code>context</code>, contains
the contexts as vectors (i.e. the value returned by <code>as_sequence()</code> applied
to a <code>ctx_node</code> object). Other columns contain context specific values which
depend on the actual class of the tree and on additional parameters. In all
implementations of <code>contexts()</code>, setting the additional parameters to any no
default value leads to a <code>data.frame</code> result.
</p>


<h3>Value</h3>

<p>A list of class <code>contexts</code> containing the contexts represented in
this tree (as <code>ctx_node</code>) or a data.frame.
</p>


<h3>State order in a context</h3>

<p>Notice that contexts are given by default
in the temporal order and not in the &quot;reverse&quot; order used by many VLMC
research papers: older values are on the left. For instance, the context
<code>c(1, 0)</code> is reported if the sequence 0, then 1 appeared in the time series
used to build the context tree. Set reverse to <code>TRUE</code> for the reverse
convention which is somewhat easier to relate to the way the context trees
are represented by <code><a href="#topic+draw">draw()</a></code> (i.e. recent values at the top the tree).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_sequence">find_sequence()</a></code> and <code><a href="#topic+find_sequence.covlmc">find_sequence.covlmc()</a></code> for direct access to
a specific context, and <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code> and
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code> for concrete implementations of <code>contexts()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
dts_tree &lt;- ctx_tree(dts, max_depth = 3, min_size = 5)
contexts(dts_tree)
contexts(dts_tree, TRUE, TRUE)
</code></pre>

<hr>
<h2 id='contexts.covlmc'>Contexts of a VLMC with covariates</h2><span id='topic+contexts.covlmc'></span>

<h3>Description</h3>

<p>This function returns the different contexts present in a VLMC with
covariates, possibly with some associated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
contexts(
  ct,
  sequence = FALSE,
  reverse = FALSE,
  frequency = NULL,
  positions = FALSE,
  local = FALSE,
  metrics = FALSE,
  model = NULL,
  hsize = FALSE,
  merging = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contexts.covlmc_+3A_ct">ct</code></td>
<td>
<p>a fitted covlmc model.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_sequence">sequence</code></td>
<td>
<p>if <code>TRUE</code> the function returns its results as a <code>data.frame</code>,
if <code>FALSE</code> (default) as a list of <code>ctx_node</code> objects. (see details)</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_reverse">reverse</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>). See details.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_frequency">frequency</code></td>
<td>
<p>specifies the counts to be included in the result
data.frame. The default value of <code>NULL</code> does not include anything.
<code>"total"</code> gives the number of occurrences of each context in the original
sequence. <code>"detailed"</code> includes in addition the break down of these
occurrences into all the possible states.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_positions">positions</code></td>
<td>
<p>logical (defaults to FALSE). Specify whether the positions
of each context in the time series used to build the context tree should be
reported in a <code>positions</code> column of the result data frame. The availability
of the positions depends on the way the context tree was built. See details
for the definition of a position.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_local">local</code></td>
<td>
<p>specifies how the counts reported by <code>frequency</code> are computed.
When <code>local</code> is <code>FALSE</code> (default value) the counts include both counts that
are specific to the context (if any) and counts from the descendants of the
context in the tree. When <code>local</code> is <code>TRUE</code> the counts include only the
number of times the context appears without being the last part of a longer
context.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_metrics">metrics</code></td>
<td>
<p>if TRUE, adds predictive metrics for each context (see
<code><a href="#topic+metrics">metrics()</a></code> for the definition of predictive metrics).</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_model">model</code></td>
<td>
<p>specifies whether to include the model associated to a each
context. The default result with <code>model=NULL</code> does not include any model.
Setting <code>model</code> to <code>"coef"</code> adds the coefficients of the models in a <code>coef</code>
column, while <code>"full"</code> include the models themselves (as R objects) in a
<code>model</code> column.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_hsize">hsize</code></td>
<td>
<p>if TRUE, adds a <code>hsize</code> column to the result data frame that
gives for each context the size of the history of covariates used by the
model.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_merging">merging</code></td>
<td>
<p>if TRUE, adds a <code>merged</code> column to the result data frame. For
a normal context, the value of <code>merged</code> is FALSE. Contexts that share the
same model have a TRUE <code>merged</code> value.</p>
</td></tr>
<tr><td><code id="contexts.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the contexts function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour of the function is to return a list of all the
contexts using <code>ctx_node_covlmc</code> objects (as returned by
<code><a href="#topic+find_sequence.covlmc">find_sequence.covlmc()</a></code>). The properties of the contexts can then be
explored using adapted functions such as <code><a href="#topic+counts">counts()</a></code>, <code><a href="#topic+covariate_memory">covariate_memory()</a></code>,
<code><a href="#topic+cutoff.ctx_node">cutoff.ctx_node()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code>, <code><a href="#topic+model">model()</a></code>, <code><a href="#topic+merged_with">merged_with()</a></code> and
<code><a href="#topic+positions">positions()</a></code>.
</p>
<p>When <code>sequence=TRUE</code> the method returns a data.frame whose first column,
named <code>context</code>, contains the contexts as vectors (i.e. the value returned
by <code>as_sequence()</code> applied to a <code>ctx_node</code> object). Other columns contain
context specific values specified by the additional parameters. Setting any
of those parameters to a value that ask for reporting information will
toggle the result type of the function to <code>data.frame</code>.
</p>
<p>See <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code> for details about the <code>frequency</code> parameter. When
<code>model</code> is non <code>NULL</code>, the resulting <code>data.frame</code> contains the models
associated to each context (either the full R model or its coefficients).
Other columns are added is the corresponding parameters are set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>contexts</code> containing the contexts represented in
this tree (as <code>ctx_node_covlmc</code>) or a data.frame.
</p>


<h3>Positions</h3>

<p>A position of a context <code>ctx</code> in the time series <code>x</code> is
an index value <code>t</code> such that the context ends with <code>x[t]</code>. Thus <code>x[t+1]</code> is
after the context. For instance if <code>x=c(0, 0, 1, 1)</code> and <code>ctx=c(0, 1)</code> (in
standard state order), then the position of <code>ctx</code> in <code>x</code> is 3.
</p>


<h3>State order in a context</h3>

<p>Notice that contexts are given by default
in the temporal order and not in the &quot;reverse&quot; order used by many VLMC
research papers: older values are on the left. For instance, the context
<code>c(1, 0)</code> is reported if the sequence 0, then 1 appeared in the time series
used to build the context tree. Set reverse to <code>TRUE</code> for the reverse
convention which is somewhat easier to relate to the way the context trees
are represented by <code><a href="#topic+draw">draw()</a></code> (i.e. recent values at the top the tree).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_sequence">find_sequence()</a></code> and <code><a href="#topic+find_sequence.covlmc">find_sequence.covlmc()</a></code> for direct access to
a specific context, and <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code> and
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code> for concrete implementations of <code>contexts()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(0, median(pc$active_power), max(pc$active_power))
dts &lt;- cut(pc$active_power, breaks = breaks)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
## direct representation with ctx_node_covlmc objects
m_cov_ctxs &lt;- contexts(m_cov)
m_cov_ctxs
sapply(m_cov_ctxs, covariate_memory)
sapply(m_cov_ctxs, is_merged)
sapply(m_cov_ctxs, model)
## data.frame interface
contexts(m_cov, model = "coef")
contexts(m_cov, model = "full", hsize = TRUE)
</code></pre>

<hr>
<h2 id='contexts.ctx_tree'>Contexts of a context tree</h2><span id='topic+contexts.ctx_tree'></span><span id='topic+contexts.ctx_tree_cpp'></span>

<h3>Description</h3>

<p>This function extracts from a context tree a description of all of its
contexts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_tree'
contexts(
  ct,
  sequence = FALSE,
  reverse = FALSE,
  frequency = NULL,
  positions = FALSE,
  ...
)

## S3 method for class 'ctx_tree_cpp'
contexts(
  ct,
  sequence = FALSE,
  reverse = FALSE,
  frequency = NULL,
  positions = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contexts.ctx_tree_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="contexts.ctx_tree_+3A_sequence">sequence</code></td>
<td>
<p>if <code>TRUE</code> the function returns its results as a <code>data.frame</code>,
if <code>FALSE</code> (default) as a list of <code>ctx_node</code> objects. (see details)</p>
</td></tr>
<tr><td><code id="contexts.ctx_tree_+3A_reverse">reverse</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>). See details.</p>
</td></tr>
<tr><td><code id="contexts.ctx_tree_+3A_frequency">frequency</code></td>
<td>
<p>specifies the counts to be included in the result
data.frame. The default value of <code>NULL</code> does not include anything.
<code>"total"</code> gives the number of occurrences of each context in the original
sequence. <code>"detailed"</code> includes in addition the break down of these
occurrences into all the possible states.</p>
</td></tr>
<tr><td><code id="contexts.ctx_tree_+3A_positions">positions</code></td>
<td>
<p>logical (defaults to FALSE). Specify whether the positions
of each context in the time series used to build the context tree should be
reported in a <code>positions</code> column of the result data frame. The availability
of the positions depends on the way the context tree was built. See details
for the definition of a position.</p>
</td></tr>
<tr><td><code id="contexts.ctx_tree_+3A_...">...</code></td>
<td>
<p>additional arguments for the contexts function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour of the function is to return a list of all the
contexts using <code>ctx_node</code> objects (as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code>). The
properties of the contexts can then be explored using adapted functions
such as <code><a href="#topic+counts">counts()</a></code> and <code><a href="#topic+positions">positions()</a></code>.
</p>
<p>When <code>sequence=TRUE</code> the method returns a data.frame whose first column,
named <code>context</code>, contains the contexts as vectors (i.e. the value returned
by <code>as_sequence()</code> applied to a <code>ctx_node</code> object). Other columns contain
context specific values specified by the additional parameters. Setting any
of those parameters to a value that ask for reporting information will
toggle the result type of the function to <code>data.frame</code>.
</p>
<p>If <code>frequency="total"</code>, an additional column named <code>freq</code> gives the number
of occurrences of each context in the series used to build the tree. If
<code>frequency="detailed"</code>, one additional column is added per state in the
context space. Each column records the number of times a given context is
followed by the corresponding value in the original series.
</p>


<h3>Value</h3>

<p>A list of class <code>contexts</code> containing the contexts represented in
this tree (as <code>ctx_node</code>) or a data.frame.
</p>


<h3>Positions</h3>

<p>A position of a context <code>ctx</code> in the time series <code>x</code> is
an index value <code>t</code> such that the context ends with <code>x[t]</code>. Thus <code>x[t+1]</code> is
after the context. For instance if <code>x=c(0, 0, 1, 1)</code> and <code>ctx=c(0, 1)</code> (in
standard state order), then the position of <code>ctx</code> in <code>x</code> is 3.
</p>


<h3>State order in a context</h3>

<p>Notice that contexts are given by default
in the temporal order and not in the &quot;reverse&quot; order used by many VLMC
research papers: older values are on the left. For instance, the context
<code>c(1, 0)</code> is reported if the sequence 0, then 1 appeared in the time series
used to build the context tree. Set reverse to <code>TRUE</code> for the reverse
convention which is somewhat easier to relate to the way the context trees
are represented by <code><a href="#topic+draw">draw()</a></code> (i.e. recent values at the top the tree).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_sequence">find_sequence()</a></code> and <code><a href="#topic+find_sequence.covlmc">find_sequence.covlmc()</a></code> for direct access to
a specific context, and <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code> and
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code> for concrete implementations of <code>contexts()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
dts_tree &lt;- ctx_tree(dts, max_depth = 3, min_size = 5)
## direct representation with ctx_node objects
contexts(dts_tree)
## data.frame format
contexts(dts_tree, sequence = TRUE)
contexts(dts_tree, frequency = "total")
contexts(dts_tree, frequency = "detailed")
</code></pre>

<hr>
<h2 id='contexts.vlmc'>Contexts of a VLMC</h2><span id='topic+contexts.vlmc'></span><span id='topic+contexts.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function extracts all the contexts from a fitted VLMC, possibly with
some associated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
contexts(
  ct,
  sequence = FALSE,
  reverse = FALSE,
  frequency = NULL,
  positions = FALSE,
  local = FALSE,
  cutoff = NULL,
  metrics = FALSE,
  ...
)

## S3 method for class 'vlmc_cpp'
contexts(
  ct,
  sequence = FALSE,
  reverse = FALSE,
  frequency = NULL,
  positions = FALSE,
  local = FALSE,
  cutoff = NULL,
  metrics = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contexts.vlmc_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_sequence">sequence</code></td>
<td>
<p>if <code>TRUE</code> the function returns its results as a <code>data.frame</code>,
if <code>FALSE</code> (default) as a list of <code>ctx_node</code> objects. (see details)</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_reverse">reverse</code></td>
<td>
<p>logical (defaults to <code>FALSE</code>). See details.</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_frequency">frequency</code></td>
<td>
<p>specifies the counts to be included in the result
data.frame. The default value of <code>NULL</code> does not include anything.
<code>"total"</code> gives the number of occurrences of each context in the original
sequence. <code>"detailed"</code> includes in addition the break down of these
occurrences into all the possible states.</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_positions">positions</code></td>
<td>
<p>logical (defaults to FALSE). Specify whether the positions
of each context in the time series used to build the context tree should be
reported in a <code>positions</code> column of the result data frame. The availability
of the positions depends on the way the context tree was built. See details
for the definition of a position.</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_local">local</code></td>
<td>
<p>specifies how the counts reported by <code>frequency</code> are computed.
When <code>local</code> is <code>FALSE</code> (default value) the counts include both counts that
are specific to the context (if any) and counts from the descendants of the
context in the tree. When <code>local</code> is <code>TRUE</code> the counts include only the
number of times the context appears without being the last part of a longer
context.</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_cutoff">cutoff</code></td>
<td>
<p>specifies whether to include the cut off value associated to
each context (see <code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+prune">prune()</a></code>). The default result with
<code>cutoff=NULL</code> does not include those values. Setting <code>cutoff</code> to <code>quantile</code>
adds the cut off values in quantile scale, while <code>cutoff="native"</code> adds
them in the native scale. The returned values are directly based on the log
likelihood ratio computed in the context tree and are not modified to
ensure pruning (as when <code><a href="#topic+cutoff">cutoff()</a></code> is called by  <code>raw=TRUE</code>).</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_metrics">metrics</code></td>
<td>
<p>if TRUE, adds predictive metrics for each context (see
<code><a href="#topic+metrics">metrics()</a></code> for the definition of predictive metrics).</p>
</td></tr>
<tr><td><code id="contexts.vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the contexts function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour of the function is to return a list of all the
contexts using <code>ctx_node</code> objects (as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code>). The
properties of the contexts can then be explored using adapted functions
such as <code><a href="#topic+counts">counts()</a></code>, <code><a href="#topic+cutoff.ctx_node">cutoff.ctx_node()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code> and
<code><a href="#topic+positions">positions()</a></code>.
</p>
<p>When <code>sequence=TRUE</code> the method returns a data.frame whose first column,
named <code>context</code>, contains the contexts as vectors (i.e. the value returned
by <code>as_sequence()</code> applied to a <code>ctx_node</code> object). Other columns contain
context specific values specified by the additional parameters. Setting any
of those parameters to a value that ask for reporting information will
toggle the result type of the function to <code>data.frame</code>.
</p>
<p>The <code>frequency</code> parameter is described in details in the documentation of
<code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>. When <code>cutoff</code> is non <code>NULL</code>, the resulting
<code>data.frame</code> contains a <code>cutoff</code> column with the cut off values, either in
quantile or in native scale. See <code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code> and <code><a href="#topic+prune.vlmc">prune.vlmc()</a></code> for the
definitions of cut off values and of the two scales.
</p>


<h3>Value</h3>

<p>A list of class <code>contexts</code> containing the contexts represented in
this tree (as <code>ctx_node</code>) or a data.frame.
</p>


<h3>Cut off values</h3>

<p>The cut off values reported by <code>contexts.vlmc</code> can
be different from the ones reported by <code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code> for three reasons:
</p>

<ol>
<li> <p><code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code> reports only useful cut off values, i.e., cut off values
that should induce a simplification of the VLMC when used in <code><a href="#topic+prune">prune()</a></code>.
This exclude cut off values associated to simple contexts that are smaller
than the ones of their descendants in the context tree. Those values are
reported by <code>context.vlmc</code>.
</p>
</li>
<li> <p><code>context.vlmc</code> reports only cut off values of actual contexts, while
<code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code> reports cut off values for all nodes of the context tree.
</p>
</li>
<li><p> values are not modified to induce pruning, contrarily to the default
behaviour of <code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code>
</p>
</li></ol>



<h3>Positions</h3>

<p>A position of a context <code>ctx</code> in the time series <code>x</code> is
an index value <code>t</code> such that the context ends with <code>x[t]</code>. Thus <code>x[t+1]</code> is
after the context. For instance if <code>x=c(0, 0, 1, 1)</code> and <code>ctx=c(0, 1)</code> (in
standard state order), then the position of <code>ctx</code> in <code>x</code> is 3.
</p>


<h3>State order in a context</h3>

<p>Notice that contexts are given by default
in the temporal order and not in the &quot;reverse&quot; order used by many VLMC
research papers: older values are on the left. For instance, the context
<code>c(1, 0)</code> is reported if the sequence 0, then 1 appeared in the time series
used to build the context tree. Set reverse to <code>TRUE</code> for the reverse
convention which is somewhat easier to relate to the way the context trees
are represented by <code><a href="#topic+draw">draw()</a></code> (i.e. recent values at the top the tree).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_sequence">find_sequence()</a></code> and <code><a href="#topic+find_sequence.covlmc">find_sequence.covlmc()</a></code> for direct access to
a specific context, and <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code> and
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code> for concrete implementations of <code>contexts()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
model &lt;- vlmc(dts, alpha = 0.5)
## direct representation with ctx_node objects
model_ctxs &lt;- contexts(model)
model_ctxs
sapply(model_ctxs, cutoff, scale = "quantile")
sapply(model_ctxs, cutoff, scale = "native")
sapply(model_ctxs, function(x) metrics(x)$accuracy)
## data.frame format
contexts(model, frequency = "total")
contexts(model, cutoff = "quantile")
contexts(model, cutoff = "native", metrics = TRUE)
</code></pre>

<hr>
<h2 id='counts'>Report the distribution of values that follow occurrences of a sequence</h2><span id='topic+counts'></span><span id='topic+counts.ctx_node'></span><span id='topic+counts.ctx_node_cpp'></span>

<h3>Description</h3>

<p>This function reports the number of occurrences of the sequence represented
by <code>node</code> in the original time series used to build the associated context
tree (not including a possible final occurrence not followed by any value at
the end of the original time series). In addition if <code>frequency=="detailed"</code>,
the function reports the frequencies of each of the possible value of the
time series when they appear just after the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts(node, frequency = c("detailed", "total"), local = FALSE)

## S3 method for class 'ctx_node'
counts(node, frequency = c("detailed", "total"), local = FALSE)

## S3 method for class 'ctx_node_cpp'
counts(node, frequency = c("detailed", "total"), local = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counts_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
<tr><td><code id="counts_+3A_frequency">frequency</code></td>
<td>
<p>specifies the counts to be included in the result. <code>"total"</code>
gives the number of occurrences of the sequence in the original sequence.
<code>"detailed"</code> includes in addition the break down of these occurrences into
all the possible states.</p>
</td></tr>
<tr><td><code id="counts_+3A_local">local</code></td>
<td>
<p>specifies how the counts are computed. When <code>local</code> is <code>FALSE</code>
(default value) the counts include both counts that are specific to the
context (if any) and counts from the descendants of the context in the
tree. When <code>local</code> is <code>TRUE</code> the counts include only the number of times
the context appears without being the last part of a longer context.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either an integer when <code>frequency="total"</code> which gives the total
number of occurrences of the sequence represented by <code>node</code> or a
<code>data.frame</code> with a <code>total</code> column with the same value and a column for
each of the possible value of the original time series, reporting counts in
each column (see the description above).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contexts">contexts()</a></code> and <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
dts_tree &lt;- ctx_tree(dts, max_depth = 3, min_size = 5)
subseq &lt;- find_sequence(dts_tree, factor(c("A", "A"), levels = c("A", "B", "C")))
if (!is.null(subseq)) {
  counts(subseq)
}
</code></pre>

<hr>
<h2 id='covariate_depth'>Maximal covariate memory of a VLMC with covariates</h2><span id='topic+covariate_depth'></span>

<h3>Description</h3>

<p>This function return the longest covariate memory used by a VLMC
with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariate_depth(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariate_depth_+3A_model">model</code></td>
<td>
<p>a covlmc object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the longest covariate memory of this model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
m_nocovariate &lt;- vlmc(dts)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 10)
covariate_depth(m_cov)
</code></pre>

<hr>
<h2 id='covariate_memory'>Covariate memory length for a COVLMC context</h2><span id='topic+covariate_memory'></span>

<h3>Description</h3>

<p>This function returns the length of the memory of a COVLMC context represented
by a <code>ctx_node_covlmc</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariate_memory(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariate_memory_+3A_node">node</code></td>
<td>
<p>A <code>ctx_node_covlmc</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code> or
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the memory length, an integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 10)
ctxs &lt;- contexts(m_cov)
## get all the memory lengths
sapply(ctxs, covariate_memory)
</code></pre>

<hr>
<h2 id='covlmc'>Fit a Variable Length Markov Chain with Covariates (coVLMC)</h2><span id='topic+covlmc'></span>

<h3>Description</h3>

<p>This function fits a  Variable Length Markov Chain with covariates (coVLMC)
to a discrete time series coupled with a time series of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covlmc(
  x,
  covariate,
  alpha = 0.05,
  min_size = 5L,
  max_depth = 100L,
  keep_data = TRUE,
  control = covlmc_control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covlmc_+3A_x">x</code></td>
<td>
<p>a discrete time series; can be numeric, character, factor or logical.</p>
</td></tr>
<tr><td><code id="covlmc_+3A_covariate">covariate</code></td>
<td>
<p>a data frame of covariates.</p>
</td></tr>
<tr><td><code id="covlmc_+3A_alpha">alpha</code></td>
<td>
<p>number in (0,1) (default: 0.05) cut off value in the pruning
phase (in quantile scale).</p>
</td></tr>
<tr><td><code id="covlmc_+3A_min_size">min_size</code></td>
<td>
<p>number &gt;= 1 (default: 5). Tune the minimum number of
observations for a context in the growing phase of the context tree (see
below for details).</p>
</td></tr>
<tr><td><code id="covlmc_+3A_max_depth">max_depth</code></td>
<td>
<p>integer &gt;= 1 (default: 100). Longest context considered in
growing phase of the context tree.</p>
</td></tr>
<tr><td><code id="covlmc_+3A_keep_data">keep_data</code></td>
<td>
<p>logical (defaults to <code>TRUE</code>). If <code>TRUE</code>, the original data
are stored in the resulting object to enable post pruning (see
<code><a href="#topic+prune.covlmc">prune.covlmc()</a></code>).</p>
</td></tr>
<tr><td><code id="covlmc_+3A_control">control</code></td>
<td>
<p>a list with control parameters, see <code><a href="#topic+covlmc_control">covlmc_control()</a></code>.</p>
</td></tr>
<tr><td><code id="covlmc_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+covlmc_control">covlmc_control()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is built using the algorithm described in Zanin Zambom et al. As
for the <code><a href="#topic+vlmc">vlmc()</a></code> approach, the algorithm builds first a context tree (see
<code><a href="#topic+ctx_tree">ctx_tree()</a></code>). The <code>min_size</code> parameter is used to compute the actual number
of observations per context in the growing phase of the tree. It is computed
as <code>min_size*(1+ncol(covariate)*d)*(s-1)</code> where <code>d</code> is the length of the
context (a.k.a. the depth in the tree) and <code>s</code> is the number of states. This
corresponds to ensuring min_size observations per parameter of the logistic
regression during the estimation phase.
</p>
<p>Then logistic models are adjusted in the leaves at the tree: the goal of each
logistic model is to estimate the conditional distribution of the next state
of the times series given the context (the recent past of the time series)
and delayed versions of the covariates. A pruning strategy is used to
simplified the models (mainly to reduce the time window associated to the
covariates) and the tree itself.
</p>
<p>Parameters specified by <code>control</code> are used to fine tune the behaviour of the
algorithm.
</p>


<h3>Value</h3>

<p>a fitted covlmc model.
</p>


<h3>Logistic models</h3>

<p>By default, <code>covlmc</code> uses two different computing <em>engines</em> for logistic
models:
</p>

<ul>
<li><p> when the time series has only two states, <code>covlmc</code> uses <code><a href="stats.html#topic+glm">stats::glm()</a></code>
with a binomial link (<code><a href="stats.html#topic+family">stats::binomial()</a></code>);
</p>
</li>
<li><p> when the time series has at least three
states, <code>covlmc</code> use <code><a href="VGAM.html#topic+vglm">VGAM::vglm()</a></code> with a multinomial link
(<code><a href="VGAM.html#topic+multinomial">VGAM::multinomial()</a></code>).
</p>
</li></ul>

<p>Both engines are able to detect degenerate cases and lead to more robust
results that using <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>. It is nevertheless possible to
replace <code><a href="stats.html#topic+glm">stats::glm()</a></code> and <code><a href="VGAM.html#topic+vglm">VGAM::vglm()</a></code> with <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code> by setting
the global option <code>mixvlmc.predictive</code> to <code>"multinom"</code> (the default value is
<code>"glm"</code>). Notice that while results should be comparable, there is no
guarantee that they will be identical.
</p>


<h3>References</h3>


<ul>
<li><p> BÃ¼hlmann, P. and Wyner, A. J. (1999), &quot;Variable length Markov chains.&quot; Ann.
Statist. 27 (2) 480-513 <a href="https://doi.org/10.1214/aos/1018031204">doi:10.1214/aos/1018031204</a>
</p>
</li>
<li><p> Zanin Zambom, A., Kim, S. and Lopes Garcia, N. (2022), &quot;Variable length Markov chain
with exogenous covariates.&quot; J. Time Ser. Anal., 43 (2)
312-328 <a href="https://doi.org/10.1111/jtsa.12615">doi:10.1111/jtsa.12615</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cutoff.covlmc">cutoff.covlmc()</a></code> and <code><a href="#topic+prune.covlmc">prune.covlmc()</a></code> for post-pruning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(1 / 3, 2 / 3, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 15)
draw(m_cov)
withr::with_options(
  list(mixvlmc.predictive = "multinom"),
  m_cov_nnet &lt;- covlmc(dts, dts_cov, min_size = 15)
)
draw(m_cov_nnet)
</code></pre>

<hr>
<h2 id='covlmc_control'>Control for coVLMC fitting</h2><span id='topic+covlmc_control'></span>

<h3>Description</h3>

<p>This function creates a list with parameters used to fine tune the coVLMC
fitting algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covlmc_control(pseudo_obs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covlmc_control_+3A_pseudo_obs">pseudo_obs</code></td>
<td>
<p>number of fake observations of each state to add to the
observed ones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pseudo_obs</code> is used to regularize the probability estimations when a
context is only observed followed by always the same state. Transition
probabilities are computed after adding <code>pseudo_obs</code> pseudo observations
of each of the states (including the observed one). This corresponds to a
Bayesian posterior mean estimation with a Dirichlet prior.
</p>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- rep(c(0, 1), 100)
dts_cov &lt;- data.frame(y = rep(0, length(dts)))
default_model &lt;- covlmc(dts, dts_cov)
contexts(default_model, type = "data.frame", model = "coef")$coef
control &lt;- covlmc_control(pseudo_obs = 10)
model &lt;- covlmc(dts, dts_cov, control = control)
contexts(model, type = "data.frame", model = "coef")$coef
</code></pre>

<hr>
<h2 id='ctx_tree'>Build a context tree for a discrete time series</h2><span id='topic+ctx_tree'></span>

<h3>Description</h3>

<p>This function builds a context tree for a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctx_tree(
  x,
  min_size = 2L,
  max_depth = 100L,
  keep_position = TRUE,
  backend = getOption("mixvlmc.backend", "R")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctx_tree_+3A_x">x</code></td>
<td>
<p>a discrete time series; can be numeric, character, factor or
logical.</p>
</td></tr>
<tr><td><code id="ctx_tree_+3A_min_size">min_size</code></td>
<td>
<p>integer &gt;= 1 (default: 2). Minimum number of observations for
a context to be included in the tree.</p>
</td></tr>
<tr><td><code id="ctx_tree_+3A_max_depth">max_depth</code></td>
<td>
<p>integer &gt;= 1 (default: 100). Maximum length of a context to
be included in the tree.</p>
</td></tr>
<tr><td><code id="ctx_tree_+3A_keep_position">keep_position</code></td>
<td>
<p>logical (default: TRUE). Should the context tree keep
the position of the contexts.</p>
</td></tr>
<tr><td><code id="ctx_tree_+3A_backend">backend</code></td>
<td>
<p>&quot;R&quot; or &quot;C++&quot; (default: as specified by the &quot;mixvlmc.backend&quot;
option). Specifies the implementation used to represent the context tree
and to built it. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree represents all the sequences of symbols/states of length smaller
than <code>max_depth</code> that appear at least <code>min_size</code> times in the time series and
stores the frequencies of the states that follow each context. Optionally,
the positions of the contexts in the time series can be stored in the tree.
</p>


<h3>Value</h3>

<p>a context tree (of class that inherits from <code>ctx_tree</code>).
</p>


<h3>Back ends</h3>

<p>Two back ends are available to compute context trees:
</p>

<ul>
<li><p> the &quot;R&quot; back end represents the tree in pure R data structures (nested lists)
that be easily processed further in pure R (C++ helper functions are used
to speed up the construction).
</p>
</li>
<li><p> the &quot;C++&quot; back end represents the tree with C++ classes. This back end is
considered experimental. The tree is built with an optimised suffix tree
algorithm which speeds up the construction by at least a factor 10 in
standard settings. As the tree is kept outside of R direct reach, context
trees built with the C++ back end must be restored after a
<code>saveRDS()</code>/<code>readRDS()</code> sequence. This is done automatically by recomputing
completely the context tree.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
## get all contexts of length 2
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 2)
draw(dts_ctree)
</code></pre>

<hr>
<h2 id='cutoff'>Cut off values for VLMC like model</h2><span id='topic+cutoff'></span>

<h3>Description</h3>

<p>This generic function returns one or more cut off values that are guaranteed
to have an effect on the <code>model</code> passed to the function when a simplification
procedure is applied (in general a tree pruning operation as provided by
<code><a href="#topic+prune">prune()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutoff(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff_+3A_model">model</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="cutoff_+3A_...">...</code></td>
<td>
<p>additional arguments for the cutoff function implementations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact definition of what is a cut off value depends on the model type and
is documented in concrete implementation of the function.
</p>


<h3>Value</h3>

<p>a cut off value or a vector of cut off values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune">prune()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts)
draw(model)
model_cuts &lt;- cutoff(model)
model_2 &lt;- prune(model, model_cuts[2])
draw(model_2)
</code></pre>

<hr>
<h2 id='cutoff.covlmc'>Cut off values for pruning the context tree of a VLMC with covariates</h2><span id='topic+cutoff.covlmc'></span>

<h3>Description</h3>

<p>This function returns all the cut off values that should induce a pruning of
the context tree of a VLMC with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
cutoff(model, raw = FALSE, tolerance = .Machine$double.eps^0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff.covlmc_+3A_model">model</code></td>
<td>
<p>a fitted COVLMC model.</p>
</td></tr>
<tr><td><code id="cutoff.covlmc_+3A_raw">raw</code></td>
<td>
<p>specify whether the returned values should be limit values
computed in the model or modified values that guarantee pruning (see
details)</p>
</td></tr>
<tr><td><code id="cutoff.covlmc_+3A_tolerance">tolerance</code></td>
<td>
<p>specify the minimum separation between two consecutive
values of the cut off in native mode (before any transformation). See
details.</p>
</td></tr>
<tr><td><code id="cutoff.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the <code>cutoff</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice that the list of cut off values returned by the function is not as
complete as the one computed for a VLMC without covariates. Indeed, pruning
the COVLMC tree creates new pruning opportunities that are not evaluated
during the construction of the initial model, while all pruning opportunities
are computed during the construction of a VLMC context tree. Nevertheless,
the largest value returned by the function is guaranteed to produce the least
pruned tree consistent with the reference one.
</p>
<p>For large COVLMC, some cut off values can be almost identical, with a
difference of the order of the machine epsilon value. The <code>tolerance</code>
parameter is used to keep only values that are different enough. This is done
in the quantile scale, before transformations implemented when <code>raw</code> is
<code>FALSE</code>.
</p>
<p>Notice that the loglikelihood scale is not directly useful in COVLMC as the
differences in model sizes are not constant through the pruning process. As a
consequence, this function does not provide <code>mode</code> parameter, contrarily to
<code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code>.
</p>
<p>Setting <code>raw</code> to <code>TRUE</code> removes the small perturbation that are subtracted
from the log-likelihood ratio values computed from the COVLMC (in quantile
scale).
</p>
<p>As automated model selection is provided by <code><a href="#topic+tune_covlmc">tune_covlmc()</a></code>, the direct use of
<code>cutoff</code> should be reserved to advanced exploration of the set of trees that
can be obtained from a complex one, e.g. to implement model selection
techniques that are not provided by <code><a href="#topic+tune_covlmc">tune_covlmc()</a></code>.
</p>


<h3>Value</h3>

<p>a vector of cut off values, <code>NULL</code> if none can be computed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
m_nocovariate &lt;- vlmc(dts)
draw(m_nocovariate)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
draw(m_cov)
cutoff(m_cov)
</code></pre>

<hr>
<h2 id='cutoff.ctx_node'>Cut off value for pruning a node in the context tree of a VLMC</h2><span id='topic+cutoff.ctx_node'></span>

<h3>Description</h3>

<p>This function returns the cut off value associated to a specific node in the
context tree interpreted as a VLMC. The node is represented by a <code>ctx_node</code>
object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code> or <code><a href="#topic+contexts">contexts()</a></code>. For details, see
<code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_node'
cutoff(model, scale = c("quantile", "native"), raw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff.ctx_node_+3A_model">model</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
<tr><td><code id="cutoff.ctx_node_+3A_scale">scale</code></td>
<td>
<p>specify whether the results should be &quot;native&quot; log likelihood
ratio values or expressed in a &quot;quantile&quot; scale of a chi-squared
distribution (defaults to &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="cutoff.ctx_node_+3A_raw">raw</code></td>
<td>
<p>specify whether the returned values should be limit values
computed in the model or modified values that guarantee pruning (see
details in <code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code>)</p>
</td></tr>
<tr><td><code id="cutoff.ctx_node_+3A_...">...</code></td>
<td>
<p>additional arguments for the <code>cutoff</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cut off value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutoff">cutoff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts)
model_ctxs &lt;- contexts(model)
cutoff(model_ctxs[[1]])
cutoff(model_ctxs[[2]], scale = "native", raw = TRUE)
</code></pre>

<hr>
<h2 id='cutoff.vlmc'>Cut off values for pruning the context tree of a VLMC</h2><span id='topic+cutoff.vlmc'></span><span id='topic+cutoff.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function returns a collection of cut off values that are guaranteed to
induce all valid pruned trees of the context tree of a VLMC. Pruning is
implemented by the <code><a href="#topic+prune">prune()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
cutoff(
  model,
  scale = c("quantile", "native"),
  raw = FALSE,
  tolerance = .Machine$double.eps^0.5,
  ...
)

## S3 method for class 'vlmc_cpp'
cutoff(
  model,
  scale = c("quantile", "native"),
  raw = FALSE,
  tolerance = .Machine$double.eps^0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutoff.vlmc_+3A_model">model</code></td>
<td>
<p>a fitted VLMC model.</p>
</td></tr>
<tr><td><code id="cutoff.vlmc_+3A_scale">scale</code></td>
<td>
<p>specify whether the results should be &quot;native&quot; log likelihood
ratio values or expressed in a &quot;quantile&quot; scale of a chi-squared
distribution (defaults to &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="cutoff.vlmc_+3A_raw">raw</code></td>
<td>
<p>specify whether the returned values should be limit values
computed in the model or modified values that guarantee pruning (see
details)</p>
</td></tr>
<tr><td><code id="cutoff.vlmc_+3A_tolerance">tolerance</code></td>
<td>
<p>specify the minimum separation between two consecutive
values of the cut off in native mode (before any transformation). See
details.</p>
</td></tr>
<tr><td><code id="cutoff.vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the cutoff function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function returns values that can be used directly to induce
pruning in the context tree. This is done by computing the log likelihood
ratios used by the context algorithm on the reference VLMC and by keeping the
relevant ones. From them the function selects intermediate values that are
guaranteed to generate via pruning all the VLMC models that could be
generated by using larger values of the <code>cutoff</code> parameter that was used to
build the reference model (or smaller values of the <code>alpha</code> parameter in
&quot;quantile&quot; scale).
</p>
<p>Setting the <code>raw</code> parameter to <code>TRUE</code> removes this operation on the values
and asks the function to return the relevant log likelihood ratios.
</p>
<p>For large VLMC, some log likelihood ratios can be almost identical, with a
difference of the order of the machine epsilon value. The <code>tolerance</code>
parameter is used to keep only values that are different enough. This is done
in the native scale, before transformations implemented when <code>raw</code> is
<code>FALSE</code>.
</p>
<p>As automated model selection is provided by <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>, the direct use of
<code>cutoff</code> should be reserved to advanced exploration of the set of trees that
can be obtained from a complex one, e.g. to implement model selection
techniques that are not provided by <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>.
</p>


<h3>Value</h3>

<p>a vector of cut off values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune">prune()</a></code> and <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts)
draw(model)
model_cuts &lt;- cutoff(model)
model_2 &lt;- prune(model, model_cuts[2])
draw(model_2)
</code></pre>

<hr>
<h2 id='depth'>Depth of a context tree</h2><span id='topic+depth'></span>

<h3>Description</h3>

<p>This function returns the depth of a context tree, i.e. the length of the
longest context represented in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the depth of the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
## should be 3
depth(dts_ctree)
</code></pre>

<hr>
<h2 id='draw'>Text based representation of a context tree</h2><span id='topic+draw'></span>

<h3>Description</h3>

<p>This function 'draws' a context tree as a text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(ct, control = draw_control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="draw_+3A_control">control</code></td>
<td>
<p>a list of low level control parameters of the text
representation. See details and <code><a href="#topic+draw_control">draw_control()</a></code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>additional arguments for draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses basic &quot;ascii art&quot; to represent the context tree. Characters
used to represent the structure of the tree, e.g. branches, can be modified
using <code><a href="#topic+draw_control">draw_control()</a></code>.
</p>
<p>In addition to the structure of the context tree, <code>draw</code> can represent
information attached to the node (contexts and partial contexts). This is
controlled by additional parameters depending on the type of the context
tree.
</p>


<h3>Value</h3>

<p>the context tree (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(c(0, 1), 100, replace = TRUE)
ctree &lt;- ctx_tree(dts, min_size = 10, max_depth = 2)
draw(ctree)
dts_c &lt;- sample(c("A", "B", "CD"), 100, replace = TRUE)
ctree_c &lt;- ctx_tree(dts_c, min_size = 10, max_depth = 2)
draw(ctree_c, draw_control(root = "x"))
</code></pre>

<hr>
<h2 id='draw_control'>Control parameters for <code>draw</code></h2><span id='topic+draw_control'></span>

<h3>Description</h3>

<p>This function returns a list used to fine tune the <code><a href="#topic+draw">draw()</a></code> function behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_control(
  root = "*",
  first_node = "+",
  next_node = "'",
  vbranch = "|",
  hbranch = "--",
  open_ct = "(",
  close_ct = ")"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_control_+3A_root">root</code></td>
<td>
<p>character used for the root node.</p>
</td></tr>
<tr><td><code id="draw_control_+3A_first_node">first_node</code></td>
<td>
<p>characters used for the first child of a node.</p>
</td></tr>
<tr><td><code id="draw_control_+3A_next_node">next_node</code></td>
<td>
<p>characters used for other children of a node.</p>
</td></tr>
<tr><td><code id="draw_control_+3A_vbranch">vbranch</code></td>
<td>
<p>characters used to represent a branch in a vertical way.</p>
</td></tr>
<tr><td><code id="draw_control_+3A_hbranch">hbranch</code></td>
<td>
<p>characters used to represent a branch in a horizontal was.</p>
</td></tr>
<tr><td><code id="draw_control_+3A_open_ct">open_ct</code></td>
<td>
<p>characters used to start each node specific text representation.</p>
</td></tr>
<tr><td><code id="draw_control_+3A_close_ct">close_ct</code></td>
<td>
<p>characters used to end each node specific text representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_control(open_ct = "[", close_ct = "]")
</code></pre>

<hr>
<h2 id='draw.covlmc'>Text based representation of a covlmc model</h2><span id='topic+draw.covlmc'></span>

<h3>Description</h3>

<p>This function 'draws' a context tree as a text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
draw(
  ct,
  control = draw_control(),
  model = c("coef", "full"),
  p_value = TRUE,
  digits = 4,
  with_state = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.covlmc_+3A_ct">ct</code></td>
<td>
<p>a fitted covlmc model.</p>
</td></tr>
<tr><td><code id="draw.covlmc_+3A_control">control</code></td>
<td>
<p>a list of low level control parameters of the text
representation. See details and <code><a href="#topic+draw_control">draw_control()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.covlmc_+3A_model">model</code></td>
<td>
<p>this parameter controls the display of logistic models
associated to nodes. The default <code>model="coef"</code> represents the coefficients
of the logistic models associated to each context. <code>model="full"</code> includes
the name of the variables in the representation (see details). Setting
<code>model=NULL</code> removes the model representations. Additional parameters can
be used to tweak model representations (see details).</p>
</td></tr>
<tr><td><code id="draw.covlmc_+3A_p_value">p_value</code></td>
<td>
<p>specifies whether the p-values of the likelihood ratio tests
conducted during the covlmc construction must be included in the
representation.</p>
</td></tr>
<tr><td><code id="draw.covlmc_+3A_digits">digits</code></td>
<td>
<p>numerical parameters and p-values are represented using the
<a href="base.html#topic+Round">base::signif</a> function, using the number of significant digits specified
with this parameter.</p>
</td></tr>
<tr><td><code id="draw.covlmc_+3A_with_state">with_state</code></td>
<td>
<p>specifies whether to display the state associated to each
dimension of the logistic model (see details).</p>
</td></tr>
<tr><td><code id="draw.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses basic &quot;ascii art&quot; to represent the context tree. Characters
used to represent the structure of the tree, e.g. branches, can be modified
using <code><a href="#topic+draw_control">draw_control()</a></code>.
</p>
<p>In addition to the structure of the context tree, <code>draw</code> can represent
information attached to the node (contexts and partial contexts). This is
controlled by additional parameters depending on the type of the context
tree.
</p>


<h3>Value</h3>

<p>the context tree (invisibly).
</p>


<h3>Tweaking model representation</h3>

<p>Model representations are affected by the following additional parameter:
</p>

<ul>
<li> <p><code>time_sep</code>: character(s) used to split the coefficients list by blocks
associated to time delays in the covariate inclusion into the logistic
model. The first block contains the intercept(s), the second block the
covariate values a time t-1, the third block at time t-2, etc.
</p>
</li></ul>



<h3>Variable representation</h3>

<p>When <code>model="full"</code>, the representation includes the names of the variables
used by the logistic models. Names are the one generated by the underlying
logistic model, e.g. <code><a href="stats.html#topic+glm">stats::glm()</a></code>. Numerical variable names are used as
is, while factors have levels appended. The intercept is denoted <code>(I)</code> to
save space. The time delays are represented by an underscore followed by
the time delay. For instance if the model uses the numerical covariate <code>y</code>
with two delays, it will appear as to variables <code>y_1</code> and <code>y_2</code>.
</p>


<h3>State representation</h3>

<p>When <code>model</code> is not <code>NULL</code>, the coefficients of the logistic models are
presented, organized in rows associated to states. One state is used as the
reference state and the logistic model aims at predicting the ratio of
probability between another state and the reference one (in log scale).
When <code>with_state</code> is <code>TRUE</code>, the display includes for each row of
coefficients the target state. This is useful when using e.g. <code>VGAM::vglm</code>
as unused levels of the target variable will be automatically dropped from
the model, leading to a reduce number of rows. The reference state is
either shown on the first row if <code>model</code> is <code>"full"</code> or after the state on
each row if <code>model</code> is <code>"coef"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
draw(m_cov, digits = 3)
draw(m_cov, model = NULL)
draw(m_cov, p_value = FALSE)
draw(m_cov, p_value = FALSE, time_sep = " | ")
draw(m_cov, model = "full", time_sep = " | ")
</code></pre>

<hr>
<h2 id='draw.ctx_tree_cpp'>Text based representation of a context tree</h2><span id='topic+draw.ctx_tree_cpp'></span><span id='topic+draw.ctx_tree'></span>

<h3>Description</h3>

<p>This function 'draws' a context tree as a text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_tree_cpp'
draw(ct, control = draw_control(), frequency = NULL, ...)

## S3 method for class 'ctx_tree'
draw(ct, control = draw_control(), frequency = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.ctx_tree_cpp_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="draw.ctx_tree_cpp_+3A_control">control</code></td>
<td>
<p>a list of low level control parameters of the text
representation. See details and <code><a href="#topic+draw_control">draw_control()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.ctx_tree_cpp_+3A_frequency">frequency</code></td>
<td>
<p>this parameter controls the display of node level
information in the tree. The default <code>NULL</code> value does not include
anything. Setting <code>frequency</code> to <code>"total"</code> includes the frequency of the
(partial) context of the node, while <code>"detailed"</code> includes the frequency of
the states that follow the context (as in <code><a href="#topic+contexts.ctx_tree">contexts.ctx_tree()</a></code>).</p>
</td></tr>
<tr><td><code id="draw.ctx_tree_cpp_+3A_...">...</code></td>
<td>
<p>additional arguments for draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses basic &quot;ascii art&quot; to represent the context tree. Characters
used to represent the structure of the tree, e.g. branches, can be modified
using <code><a href="#topic+draw_control">draw_control()</a></code>.
</p>
<p>In addition to the structure of the context tree, <code>draw</code> can represent
information attached to the node (contexts and partial contexts). This is
controlled by additional parameters depending on the type of the context
tree.
</p>


<h3>Value</h3>

<p>the context tree (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts_c &lt;- sample(c("A", "B", "CD"), 100, replace = TRUE)
ctree_c &lt;- ctx_tree(dts_c, min_size = 10, max_depth = 2)
draw(ctree_c, frequency = "total")
draw(ctree_c, frequency = "detailed")
</code></pre>

<hr>
<h2 id='draw.vlmc'>Text based representation of a vlmc</h2><span id='topic+draw.vlmc'></span><span id='topic+draw.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function 'draws' a context tree as a text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
draw(ct, control = draw_control(), prob = TRUE, ...)

## S3 method for class 'vlmc_cpp'
draw(ct, control = draw_control(), prob = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.vlmc_+3A_ct">ct</code></td>
<td>
<p>a fitted vlmc.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_control">control</code></td>
<td>
<p>a list of low level control parameters of the text
representation. See details and <code><a href="#topic+draw_control">draw_control()</a></code>.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_prob">prob</code></td>
<td>
<p>this parameter controls the display of node level information in
the tree. The default <code>prob=TRUE</code> represents the conditional distribution
of the states given the (partial) context associated to the node. Setting
<code>prob=FALSE</code> replaces the conditional distribution by the frequency of the
states that follow the context as in <code><a href="#topic+draw.ctx_tree">draw.ctx_tree()</a></code>. Setting <code>prob=NULL</code>
removes all additional information.</p>
</td></tr>
<tr><td><code id="draw.vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses basic &quot;ascii art&quot; to represent the context tree. Characters
used to represent the structure of the tree, e.g. branches, can be modified
using <code><a href="#topic+draw_control">draw_control()</a></code>.
</p>
<p>In addition to the structure of the context tree, <code>draw</code> can represent
information attached to the node (contexts and partial contexts). This is
controlled by additional parameters depending on the type of the context
tree.
</p>


<h3>Value</h3>

<p>the context tree (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(c("A", "B", "C"), 500, replace = TRUE)
model &lt;- vlmc(dts, alpha = 0.05)
draw(model)
draw(model, prob = FALSE)
draw(model, prob = NULL)
</code></pre>

<hr>
<h2 id='find_sequence'>Find the node of a sequence in a context tree</h2><span id='topic+find_sequence'></span><span id='topic+find_sequence.ctx_tree'></span><span id='topic+find_sequence.ctx_tree_cpp'></span>

<h3>Description</h3>

<p>This function checks whether the sequence <code>ctx</code> is represented in the context
tree <code>ct</code>. If this is the case, it returns a description of matching node, an
object of class <code>ctx_node</code>. If the sequence is not represented in the tree,
the function return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_sequence(ct, ctx, reverse = FALSE, ...)

## S3 method for class 'ctx_tree'
find_sequence(ct, ctx, reverse = FALSE, ...)

## S3 method for class 'ctx_tree_cpp'
find_sequence(ct, ctx, reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_sequence_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="find_sequence_+3A_ctx">ctx</code></td>
<td>
<p>a sequence to search in the context tree</p>
</td></tr>
<tr><td><code id="find_sequence_+3A_reverse">reverse</code></td>
<td>
<p>specifies whether the sequence <code>ctx</code> is given the
temporal order (<code>FALSE</code>, default value) or in the reverse temporal order
(<code>TRUE</code>). See the dedicated section.</p>
</td></tr>
<tr><td><code id="find_sequence_+3A_...">...</code></td>
<td>
<p>additional parameters for the find_sequence function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks for sequences in general. The <code><a href="#topic+is_context">is_context()</a></code> function can
be used on the resulting object to test if the sequence is in addition a
proper context.
</p>


<h3>Value</h3>

<p>an object of class <code>ctx_node</code> if the sequence <code>ctx</code> is represented
in the context tree, <code>NULL</code> when this is not the case.
</p>


<h3>State order in a sequence</h3>

<p>sequence are given by default
in the temporal order and not in the &quot;reverse&quot; order used by many VLMC
research papers: older values are on the left. For instance, the context
<code>c(1, 0)</code> is reported if the sequence 0, then 1 appeared in the time series
used to build the context tree. In the present function, <code>reverse</code> refers
both to the order used for the <code>ctx</code> parameter and for the default order used by the resulting <code>ctx_node</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c("A", "B", "C", "A", "A", "B", "B", "C", "C", "A")
dts_tree &lt;- ctx_tree(dts, max_depth = 3)
find_sequence(dts_tree, "A")
## returns NULL as "A" "C" does not appear in dts
find_sequence(dts_tree, c("A", "C"))
</code></pre>

<hr>
<h2 id='find_sequence.covlmc'>Find the node of a sequence in a COVLMC context tree</h2><span id='topic+find_sequence.covlmc'></span>

<h3>Description</h3>

<p>This function checks whether the sequence <code>ctx</code> is represented in the context
tree of the COVLMC model <code>ct</code>. If this is the case, it returns a description
of matching node, an object of class <code>ctx_node_covlmc</code>. If the sequence is
not represented in the tree, the function return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
find_sequence(ct, ctx, reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_sequence.covlmc_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="find_sequence.covlmc_+3A_ctx">ctx</code></td>
<td>
<p>a sequence to search in the context tree</p>
</td></tr>
<tr><td><code id="find_sequence.covlmc_+3A_reverse">reverse</code></td>
<td>
<p>specifies whether the sequence <code>ctx</code> is given the
temporal order (<code>FALSE</code>, default value) or in the reverse temporal order
(<code>TRUE</code>). See the dedicated section.</p>
</td></tr>
<tr><td><code id="find_sequence.covlmc_+3A_...">...</code></td>
<td>
<p>additional parameters for the find_sequence function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks for sequences in general. The <code><a href="#topic+is_context">is_context()</a></code> function can
be used on the resulting object to test if the sequence is in addition a
proper context.
</p>


<h3>Value</h3>

<p>an object of class <code>ctx_node_covlmc</code> if the sequence <code>ctx</code> is represented
in the context tree, <code>NULL</code> when this is not the case
</p>


<h3>State order in a sequence</h3>

<p>sequence are given by default
in the temporal order and not in the &quot;reverse&quot; order used by many VLMC
research papers: older values are on the left. For instance, the context
<code>c(1, 0)</code> is reported if the sequence 0, then 1 appeared in the time series
used to build the context tree. In the present function, <code>reverse</code> refers
both to the order used for the <code>ctx</code> parameter and for the default order used by the resulting <code>ctx_node</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 10)

## not in the tree
vals &lt;- states(m_cov)
find_sequence(m_cov, c(vals[2], vals[2]))
## in the tree but not a context
node &lt;- find_sequence(m_cov, c(vals[1]))
node
is_context(node)
## in the tree and a context
node &lt;- find_sequence(m_cov, c(vals[1], vals[1]))
node
is_context(node)
model(node)
</code></pre>

<hr>
<h2 id='globalearthquake'>Significant Earthquake Dataset</h2><span id='topic+globalearthquake'></span>

<h3>Description</h3>

<p>A data set containing Earthquake that have occured during the period of
1900-2022 with GPS coordinates and magnitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalearthquake
</code></pre>


<h3>Format</h3>

<p>A data frame with 98785 rows and 12 variables:
</p>

<dl>
<dt>date_time</dt><dd><p>Date and time in POSIXct format</p>
</dd>
<dt>latitude</dt><dd><p>latitude of the earthquake, from -90Â° to 90Â°</p>
</dd>
<dt>longitude</dt><dd><p>longitude of the earthquake, from -180Â° to 180Â°</p>
</dd>
<dt>mag</dt><dd><p>the magnitude of the earthquake, indicating its strenth</p>
</dd>
<dt>Date</dt><dd><p>date when the seisme occured</p>
</dd>
<dt>nbweeks</dt><dd><p>number of weeks since 1900/01/01</p>
</dd>
<dt>year</dt><dd><p>year</p>
</dd>
<dt>month</dt><dd><p>month of the year</p>
</dd>
<dt>month_day</dt><dd><p>day of the month</p>
</dd>
<dt>week</dt><dd><p>week number</p>
</dd>
<dt>week_day</dt><dd><p>day of the week from 1 = Sunday to 7 = Saturday</p>
</dd>
<dt>year_day</dt><dd><p>day of the year from 1 to 366</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a compiled version of the full data set available on
<a href="https://www.usgs.gov/programs/earthquake-hazards">U.S. Geological Survey Earthquake Events</a>
(USGS) which is in the
<a href="https://www.usgs.gov/information-policies-and-instructions/copyrights-and-credits">public domain</a>.
</p>
<p>The data set contains only the earthquake between 1900 and 2022
with a magnitude higher than 5.
</p>


<h3>Source</h3>

<p>Earthquake Catalog, U.S. Geological Survey, Department of the Interior.
<a href="https://www.usgs.gov/programs/earthquake-hazards">https://www.usgs.gov/programs/earthquake-hazards</a>
</p>

<hr>
<h2 id='is_context'>Report the nature of a node in a context tree</h2><span id='topic+is_context'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> if the node is a proper context, <code>FALSE</code>
in the other case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_context(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_context_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the node <code>node</code> is a proper context,
<code>FALSE</code> when this is not the case
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
draw(dts_ctree)
## 0, 0 is a context but 1, 0 is not
is_context(find_sequence(dts_ctree, c(0, 0)))
is_context(find_sequence(dts_ctree, c(1, 0)))
</code></pre>

<hr>
<h2 id='is_covlmc'>Test if the object is a covlmc model</h2><span id='topic+is_covlmc'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for VLMC models with covariates and <code>FALSE</code> for other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_covlmc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_covlmc_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for VLMC models with covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
# should be true
is_ctx_tree(m_cov)
# should be true
is_covlmc(m_cov)
# should be false
is_vlmc(m_cov)
</code></pre>

<hr>
<h2 id='is_ctx_tree'>Test if the object is a context tree</h2><span id='topic+is_ctx_tree'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for context trees and <code>FALSE</code> for other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ctx_tree(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_ctx_tree_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for context trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 2)
is_ctx_tree(dts_ctree)
is_ctx_tree(dts)
</code></pre>

<hr>
<h2 id='is_merged'>Merging status of a COVLMC context</h2><span id='topic+is_merged'></span>

<h3>Description</h3>

<p>The function returns <code>TRUE</code> if the context represented by this node is merged
with at least another one and <code>FALSE</code> if this is not the case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_merged(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_merged_+3A_node">node</code></td>
<td>
<p>A <code>ctx_node_covlmc</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code> or
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a COVLMC is built on a time series with at least three distinct states,
some contexts can be merged: they use the same logistic model, leading to a
more parsimonious model. Those contexts are reported individually by
functions such as <code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code>. The present function can be used
to detect such merging, while <code><a href="#topic+merged_with">merged_with()</a></code> can be used to recover the
other contexts.
</p>


<h3>Value</h3>

<p>TRUE or FALSE, depending on the nature of the context
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merged_with">merged_with()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 15, ]
dts &lt;- cut(pc$active_power, breaks = c(0, 1, 2, 3, 8))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5, alpha = 0.1)
ctxs &lt;- contexts(m_cov)
## no merging
sapply(ctxs, is_merged)
</code></pre>

<hr>
<h2 id='is_reversed'>Report the ordering convention of the node</h2><span id='topic+is_reversed'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> if the node is using a reverse temporal ordering
and <code>FALSE</code> in the other case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_reversed(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_reversed_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the node <code>node</code> use a reverse temporal ordering, <code>FALSE</code>
when this is not the case
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rev.ctx_node">rev.ctx_node()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
is_reversed(find_sequence(dts_ctree, c(0, 0)))
is_reversed(find_sequence(dts_ctree, c(1, 0), reverse = TRUE))
</code></pre>

<hr>
<h2 id='is_vlmc'>Test if the object is a vlmc model</h2><span id='topic+is_vlmc'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> for VLMC models and <code>FALSE</code> for other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_vlmc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_vlmc_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for VLMC models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts)
# should be true
is_ctx_tree(model)
# should be true
is_vlmc(model)
# should be false
is_covlmc(model)
</code></pre>

<hr>
<h2 id='logLik.covlmc'>Log-Likelihood of a VLMC with covariates</h2><span id='topic+logLik.covlmc'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood of a VLMC with covariates
fitted on a discrete time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
logLik(object, initial = c("truncated", "specific", "extended"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.covlmc_+3A_object">object</code></td>
<td>
<p>the covlmc representation.</p>
</td></tr>
<tr><td><code id="logLik.covlmc_+3A_initial">initial</code></td>
<td>
<p>specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are
integrated in the likelihood. Defaults to <code>"truncated"</code>. See
<code><a href="#topic+loglikelihood">loglikelihood()</a></code> for details.</p>
</td></tr>
<tr><td><code id="logLik.covlmc_+3A_...">...</code></td>
<td>
<p>additional parameters for logLik.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>logLik</code>. This is a number, the log-likelihood of
the (CO)VLMC with the following attributes:
</p>

<ul>
<li> <p><code>df</code>: the number of parameters used by the VLMC for this likelihood calculation
</p>
</li>
<li> <p><code>nobs</code>: the number of observations included in this likelihood calculation
</p>
</li>
<li> <p><code>initial</code>: the value of the <code>initial</code> parameter used to compute this likelihood
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+loglikelihood">loglikelihood()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Likelihood for a fitted VLMC with covariates.
pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
ll &lt;- logLik(m_cov)
attributes(ll)

</code></pre>

<hr>
<h2 id='logLik.vlmc'>Log-Likelihood of a VLMC</h2><span id='topic+logLik.vlmc'></span><span id='topic+logLik.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood of a VLMC fitted on a discrete
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
logLik(object, initial = c("truncated", "specific", "extended"), ...)

## S3 method for class 'vlmc_cpp'
logLik(object, initial = c("truncated", "specific", "extended"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.vlmc_+3A_object">object</code></td>
<td>
<p>the vlmc representation.</p>
</td></tr>
<tr><td><code id="logLik.vlmc_+3A_initial">initial</code></td>
<td>
<p>specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are
integrated in the likelihood. Defaults to <code>"truncated"</code>. See
<code><a href="#topic+loglikelihood">loglikelihood()</a></code> for details.</p>
</td></tr>
<tr><td><code id="logLik.vlmc_+3A_...">...</code></td>
<td>
<p>additional parameters for logLik.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>logLik</code>. This is a number, the log-likelihood of
the (CO)VLMC with the following attributes:
</p>

<ul>
<li> <p><code>df</code>: the number of parameters used by the VLMC for this likelihood calculation
</p>
</li>
<li> <p><code>nobs</code>: the number of observations included in this likelihood calculation
</p>
</li>
<li> <p><code>initial</code>: the value of the <code>initial</code> parameter used to compute this likelihood
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+loglikelihood">loglikelihood()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
m_nocovariate &lt;- vlmc(dts)
ll &lt;- logLik(m_nocovariate)
ll
attributes(ll)
</code></pre>

<hr>
<h2 id='loglikelihood'>Log-Likelihood of a VLMC</h2><span id='topic+loglikelihood'></span><span id='topic+loglikelihood.vlmc'></span><span id='topic+loglikelihood.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood of a VLMC fitted on a discrete time series.
When the optional argument <code>newdata</code> is provided, the function evaluates instead the
log-likelihood for this (new) discrete time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood(
  vlmc,
  newdata,
  initial = c("truncated", "specific", "extended"),
  ignore,
  ...
)

## S3 method for class 'vlmc'
loglikelihood(
  vlmc,
  newdata,
  initial = c("truncated", "specific", "extended"),
  ignore,
  ...
)

## S3 method for class 'vlmc_cpp'
loglikelihood(
  vlmc,
  newdata,
  initial = c("truncated", "specific", "extended"),
  ignore,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_+3A_vlmc">vlmc</code></td>
<td>
<p>the vlmc representation.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_newdata">newdata</code></td>
<td>
<p>an optional discrete time series.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_initial">initial</code></td>
<td>
<p>specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are integrated
in the likelihood. Defaults to <code>"truncated"</code>. See below for details.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_ignore">ignore</code></td>
<td>
<p>specifies the number of initial values for which the loglikelihood
will not be computed. The minimal number depends on the likelihood function as
detailed below.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_...">...</code></td>
<td>
<p>additional parameters for loglikelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the likelihood function depends on the value of the
<code>initial</code> parameters, see the section below as well as the dedicated
vignette: <code>vignette("likelihood", package = "mixvlmc")</code>.
</p>
<p>For VLMC objects, the method <code>loglikelihood.vlmc</code> will be used. For VLMC with covariables, <code>loglikelihood.covlmc</code>
will instead be called. For more informations on <code>loglikelihood</code> methods, use <code>methods(loglikelihood)</code> and their associated documentation.
</p>


<h3>Value</h3>

<p>an object of class <code>logLikMixVLMC</code> and <code>logLik</code>. This is a number,
the log-likelihood of the (CO)VLMC with the following attributes:
</p>

<ul>
<li> <p><code>df</code>: the number of parameters used by the VLMC for this likelihood calculation
</p>
</li>
<li> <p><code>nobs</code>: the number of observations included in this likelihood calculation
</p>
</li>
<li> <p><code>initial</code>: the value of the <code>initial</code> parameter used to compute this likelihood
</p>
</li></ul>



<h3>likelihood calculation</h3>

<p>In a (CO)VLMC of <code><a href="#topic+depth">depth()</a></code>=k, we need k past values in order to compute the
context of a given observation. As a consequence, in a time series <code>x</code>, the
contexts of <code>x[1]</code> to <code>x[k]</code> are unknown. Depending on the value of <code>initial</code>
different likelihood functions are used to tackle this difficulty:
</p>

<ul>
<li> <p><code>initial=="truncated"</code>: the likelihood is computed using only
<code>x[(k+1):length(x)]</code>
</p>
</li>
<li> <p><code>initial=="specific"</code>: the likelihood is computed on the full time series
using a specific context for the initial values, <code>x[1]</code> to <code>x[k]</code>. Each of
the specific context is unique, leading to a perfect likelihood of 1 (0 in
log scale). Thus the numerical value of the likelihood is identical as the
one obtained with <code>initial=="truncated"</code> but it is computed on <code>length(x)</code>
with a model with more parameters than in this previous case.
</p>
</li>
<li> <p><code>initial=="extended"</code> (default): the likelihood is computed on the full time series
using an extended context matching for the initial values, <code>x[1]</code> to <code>x[k]</code>.
This can be seen as a compromised between the two other possibilities:
the relaxed context matching needs in general to turn internal nodes
of the context tree into actual context, increasing the number of parameters,
but not as much as with &quot;specific&quot;. However, the likelihood of say <code>x[1]</code>
with an empty context is generally not 1 and thus the full likelihood is
smaller than the one computed with &quot;specific&quot;.
</p>
</li></ul>

<p>In all cases, the <code>ignore</code> first values of the time series are not included
in the computed likelihood, but still used to compute contexts. If <code>ignore</code>
is not specified, it is set to the minimal possible value, that is k for the
<code>truncated</code> likelihood and 0 for the other ones. If it is specified, it must
be larger or equal to k for <code>truncated</code>.
</p>
<p>See the dedicated vignette for a more mathematically oriented discussion:
<code>vignette("likelihood", package = "mixvlmc")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">stats::logLik()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Likelihood for a fitted VLMC.
pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
m_nocovariate &lt;- vlmc(dts)
ll &lt;- loglikelihood(m_nocovariate)
ll
attr(ll, "nobs")
attr(ll, "df")

## Likelihood for a new time series with previously fitted VLMC.
pc_new &lt;- powerconsumption[powerconsumption$week == 11, ]
dts_new &lt;- cut(pc_new$active_power, breaks = breaks, labels = labels)
ll_new &lt;- loglikelihood(m_nocovariate, newdata = dts_new)
ll_new
attributes(ll_new)
ll_new_specific &lt;- loglikelihood(m_nocovariate, initial = "specific", newdata = dts_new)
ll_new_specific
attributes(ll_new_specific)
ll_new_extended &lt;- loglikelihood(m_nocovariate, initial = "extended", newdata = dts_new)
ll_new_extended
attributes(ll_new_extended)

</code></pre>

<hr>
<h2 id='loglikelihood.covlmc'>Log-Likelihood of a VLMC with covariates</h2><span id='topic+loglikelihood.covlmc'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood of a VLMC with covariates fitted
on a discrete time series. When the optional arguments <code>newdata</code> is
provided, the function evaluates instead the log-likelihood for this (new)
discrete time series on the new covariates which must be provided through the
<code>newcov</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
loglikelihood(
  vlmc,
  newdata,
  initial = c("truncated", "specific", "extended"),
  ignore,
  newcov,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood.covlmc_+3A_vlmc">vlmc</code></td>
<td>
<p>the covlmc representation.</p>
</td></tr>
<tr><td><code id="loglikelihood.covlmc_+3A_newdata">newdata</code></td>
<td>
<p>an optional discrete time series.</p>
</td></tr>
<tr><td><code id="loglikelihood.covlmc_+3A_initial">initial</code></td>
<td>
<p>specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are integrated
in the likelihood. Defaults to <code>"truncated"</code>. See below for details.</p>
</td></tr>
<tr><td><code id="loglikelihood.covlmc_+3A_ignore">ignore</code></td>
<td>
<p>specifies the number of initial values for which the loglikelihood
will not be computed. The minimal number depends on the likelihood function as
detailed below.</p>
</td></tr>
<tr><td><code id="loglikelihood.covlmc_+3A_newcov">newcov</code></td>
<td>
<p>an optional data frame with the new values for the covariates.</p>
</td></tr>
<tr><td><code id="loglikelihood.covlmc_+3A_...">...</code></td>
<td>
<p>additional parameters for loglikelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the likelihood function depends on the value of the
<code>initial</code> parameters, see the section below as well as the dedicated
vignette: <code>vignette("likelihood", package = "mixvlmc")</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>logLikMixVLMC</code> and <code>logLik</code>. This is a number,
the log-likelihood of the (CO)VLMC with the following attributes:
</p>

<ul>
<li> <p><code>df</code>: the number of parameters used by the VLMC for this likelihood calculation
</p>
</li>
<li> <p><code>nobs</code>: the number of observations included in this likelihood calculation
</p>
</li>
<li> <p><code>initial</code>: the value of the <code>initial</code> parameter used to compute this likelihood
</p>
</li></ul>



<h3>likelihood calculation</h3>

<p>In a (CO)VLMC of <code><a href="#topic+depth">depth()</a></code>=k, we need k past values in order to compute the
context of a given observation. As a consequence, in a time series <code>x</code>, the
contexts of <code>x[1]</code> to <code>x[k]</code> are unknown. Depending on the value of <code>initial</code>
different likelihood functions are used to tackle this difficulty:
</p>

<ul>
<li> <p><code>initial=="truncated"</code>: the likelihood is computed using only
<code>x[(k+1):length(x)]</code>
</p>
</li>
<li> <p><code>initial=="specific"</code>: the likelihood is computed on the full time series
using a specific context for the initial values, <code>x[1]</code> to <code>x[k]</code>. Each of
the specific context is unique, leading to a perfect likelihood of 1 (0 in
log scale). Thus the numerical value of the likelihood is identical as the
one obtained with <code>initial=="truncated"</code> but it is computed on <code>length(x)</code>
with a model with more parameters than in this previous case.
</p>
</li>
<li> <p><code>initial=="extended"</code> (default): the likelihood is computed on the full time series
using an extended context matching for the initial values, <code>x[1]</code> to <code>x[k]</code>.
This can be seen as a compromised between the two other possibilities:
the relaxed context matching needs in general to turn internal nodes
of the context tree into actual context, increasing the number of parameters,
but not as much as with &quot;specific&quot;. However, the likelihood of say <code>x[1]</code>
with an empty context is generally not 1 and thus the full likelihood is
smaller than the one computed with &quot;specific&quot;.
</p>
</li></ul>

<p>In all cases, the <code>ignore</code> first values of the time series are not included
in the computed likelihood, but still used to compute contexts. If <code>ignore</code>
is not specified, it is set to the minimal possible value, that is k for the
<code>truncated</code> likelihood and 0 for the other ones. If it is specified, it must
be larger or equal to k for <code>truncated</code>.
</p>
<p>See the dedicated vignette for a more mathematically oriented discussion:
<code>vignette("likelihood", package = "mixvlmc")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">stats::logLik()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Likelihood for a fitted VLMC with covariates.
pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
ll &lt;- loglikelihood(m_cov)
ll
attr(ll, "nobs")

## Likelihood for new time series and covariates with previously
## fitted VLMC with covariates
pc_new &lt;- powerconsumption[powerconsumption$week == 11, ]
dts_new &lt;- cut(pc_new$active_power, breaks = breaks, labels = labels)
dts_cov_new &lt;- data.frame(day_night = (pc_new$hour &gt;= 7 &amp; pc_new$hour &lt;= 17))
ll_new &lt;- loglikelihood(m_cov, newdata = dts_new, newcov = dts_cov_new)
ll_new
attributes(ll_new)

</code></pre>

<hr>
<h2 id='merged_with'>Merged contexts in a COVLMC</h2><span id='topic+merged_with'></span>

<h3>Description</h3>

<p>The function returns <code>NULL</code> when the context represented by the <code>node</code>
parameter is not merged with another context (see <code><a href="#topic+is_merged">is_merged()</a></code>). In the
other case, it returns a list of contexts with which this one is merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merged_with(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merged_with_+3A_node">node</code></td>
<td>
<p>A <code>ctx_node_covlmc</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code> or
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the context is merged, the function returns a list with one value for each
element in the state space (see <code><a href="#topic+states">states()</a></code>). The value is <code>NULL</code> if the
corresponding context is not merged with the <code>node</code> context, while it is a
<code>ctx_node_covlmc</code> object in the other case. A context merged with <code>node</code>
differs from the context represented by <code>node</code> only in its last value (in
temporal order) which is used as its name in the list. For instance, if the
context <code>ABC</code> is merged only with <code>CBC</code> (when represented in temporal
ordering), then the resulting list is of the form <code>list("A" = NULL, "B" = NULL, "C"= ctx_node_covlmc(CBX))</code>.
</p>


<h3>Value</h3>

<p>NULL or a list of contexts merged with <code>node</code> represented by
<code>ctx_node_covlmc</code> objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_merged">is_merged()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc_week_15_16 &lt;- powerconsumption[powerconsumption$week %in% c(15, 16), ]
elec &lt;- pc_week_15_16$active_power
elec_dts &lt;- cut(elec, breaks = c(0, 0.4, 2, 8), labels = c("low", "typical", "high"))
elec_cov &lt;- data.frame(day = (pc_week_15_16$hour &gt;= 7 &amp; pc_week_15_16$hour &lt;= 18))
elec_tune &lt;- tune_covlmc(elec_dts, elec_cov, min_size = 5)
elec_model &lt;- prune(as_covlmc(elec_tune), alpha = 3.961e-10)
ctxs &lt;- contexts(elec_model)
for (ctx in ctxs) {
  if (is_merged(ctx)) {
    print(ctx)
    cat("\nis merged with\n\n")
    print(merged_with(ctx))
  }
}
</code></pre>

<hr>
<h2 id='metrics'>Predictive quality metrics for context based models</h2><span id='topic+metrics'></span>

<h3>Description</h3>

<p>This function computes and returns predictive quality metrics for context
based models such as VLMC and VLMC with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics_+3A_model">model</code></td>
<td>
<p>The context based model on which to compute predictive metrics.</p>
</td></tr>
<tr><td><code id="metrics_+3A_...">...</code></td>
<td>
<p>Additional parameters for predictive metrics computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A context based model computes transition probabilities for its contexts.
Using a maximum transition probability decision rule, this can be used to
predict the new state that is the more likely to follow the current one,
given the context (see <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>). The quality of these predictions is
evaluated using standard metrics including:
</p>

<ul>
<li><p> accuracy
</p>
</li>
<li><p> the full confusion matrix
</p>
</li>
<li><p> the area under the roc curve (AUC), considering the context based model as
a (conditional) probability estimator. We use Hand and Till (2001) multiclass
AUC in case of a state space with more than 2 states
</p>
</li></ul>



<h3>Value</h3>

<p>The returned value is guaranteed to have at least three components
</p>

<ul>
<li> <p><code>accuracy</code>: the accuracy of the predictions
</p>
</li>
<li> <p><code>conf_mat</code>: the confusion matrix of the predictions, with predicted values
in rows and true values in columns
</p>
</li>
<li> <p><code>auc</code>: the AUC of the predictive model
</p>
</li></ul>



<h3>References</h3>

<p>David J. Hand and Robert J. Till (2001). &quot;A Simple Generalisation
of the Area Under the ROC Curve for Multiple Class Classification Problems.&quot;
<em>Machine Learning</em> 45(2), p. 171&ndash;186. DOI: <a href="https://doi.org/10.1023/A%3A1010920819831">doi:10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code>, <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
model &lt;- vlmc(dts)
metrics(model)

</code></pre>

<hr>
<h2 id='metrics.covlmc'>Predictive quality metrics for VLMC with covariates</h2><span id='topic+metrics.covlmc'></span><span id='topic+print.metrics.covlmc'></span>

<h3>Description</h3>

<p>This function computes and returns predictive quality metrics for context
based models such as VLMC and VLMC with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
metrics(model, ...)

## S3 method for class 'metrics.covlmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics.covlmc_+3A_model">model</code></td>
<td>
<p>The context based model on which to compute predictive metrics.</p>
</td></tr>
<tr><td><code id="metrics.covlmc_+3A_...">...</code></td>
<td>
<p>Additional parameters for predictive metrics computation.</p>
</td></tr>
<tr><td><code id="metrics.covlmc_+3A_x">x</code></td>
<td>
<p>A metrics.covlmc object, results of a call to <code><a href="#topic+metrics.covlmc">metrics.covlmc()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A context based model computes transition probabilities for its contexts.
Using a maximum transition probability decision rule, this can be used to
predict the new state that is the more likely to follow the current one,
given the context (see <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>). The quality of these predictions is
evaluated using standard metrics including:
</p>

<ul>
<li><p> accuracy
</p>
</li>
<li><p> the full confusion matrix
</p>
</li>
<li><p> the area under the roc curve (AUC), considering the context based model as
a (conditional) probability estimator. We use Hand and Till (2001) multiclass
AUC in case of a state space with more than 2 states
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>metrics.covlmc</code> with the following components:
</p>

<ul>
<li> <p><code>accuracy</code>: the accuracy of the predictions
</p>
</li>
<li> <p><code>conf_mat</code>: the confusion matrix of the predictions, with predicted values
in rows and true values in columns
</p>
</li>
<li> <p><code>auc</code>: the AUC of the predictive model
</p>
</li></ul>

<p>The object has a print method that recalls basic information about the model
together with the values of the components above.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(metrics.covlmc)</code>: Prints the predictive metrics of the VLMC model with covariates.
</p>
</li></ul>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> documentation and in
the dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first
initial values of a time series do not in general have a proper context for
a COVLMC with a non zero order. In order to predict something meaningful
for those values, we rely on the notion of extended context defined in the
documents mentioned above. This follows the same logic as using
<code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> with the parameter <code>initial="extended"</code>. All
covlmc functions that need to manipulate initial values with no proper
context use the same approach.
</p>


<h3>References</h3>

<p>David J. Hand and Robert J. Till (2001). &quot;A Simple Generalisation
of the Area Under the ROC Curve for Multiple Class Classification Problems.&quot;
<em>Machine Learning</em> 45(2), p. 171&ndash;186. DOI: <a href="https://doi.org/10.1023/A%3A1010920819831">doi:10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code>, <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
metrics(m_cov)

</code></pre>

<hr>
<h2 id='metrics.ctx_node'>Predictive quality metrics for a node of a context tree</h2><span id='topic+metrics.ctx_node'></span>

<h3>Description</h3>

<p>This function computes and returns predictive quality metrics for a node
(<code>ctx_node</code>) extracted from a context tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_node'
metrics(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics.ctx_node_+3A_model">model</code></td>
<td>
<p>T <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code>.</p>
</td></tr>
<tr><td><code id="metrics.ctx_node_+3A_...">...</code></td>
<td>
<p>Additional parameters for predictive metrics computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compared to <code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>, this function focuses on a single context and
assesses the quality of its predictions, disregarding observations that have
other contexts. Apart from this limited scope, the function operates as
<code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>.
</p>


<h3>Value</h3>

<p>The returned value is guaranteed to have at least three components
</p>

<ul>
<li> <p><code>accuracy</code>: the accuracy of the predictions
</p>
</li>
<li> <p><code>conf_mat</code>: the confusion matrix of the predictions, with predicted values
in rows and true values in columns
</p>
</li>
<li> <p><code>auc</code>: the AUC of the predictive model
</p>
</li></ul>



<h3>References</h3>

<p>David J. Hand and Robert J. Till (2001). &quot;A Simple Generalisation
of the Area Under the ROC Curve for Multiple Class Classification Problems.&quot;
<em>Machine Learning</em> 45(2), p. 171&ndash;186. DOI: <a href="https://doi.org/10.1023/A%3A1010920819831">doi:10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code>, <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts)
model_ctxs &lt;- contexts(model)
metrics(model_ctxs[[4]])
</code></pre>

<hr>
<h2 id='metrics.ctx_node_covlmc'>Predictive quality metrics for a node of a COVLMC context tree</h2><span id='topic+metrics.ctx_node_covlmc'></span>

<h3>Description</h3>

<p>This function computes and returns predictive quality metrics for a node
(<code>ctx_node_covlmc</code>) extracted from a covlmc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_node_covlmc'
metrics(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics.ctx_node_covlmc_+3A_model">model</code></td>
<td>
<p>A <code>ctx_node_covlmc</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code> or
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code></p>
</td></tr>
<tr><td><code id="metrics.ctx_node_covlmc_+3A_...">...</code></td>
<td>
<p>Additional parameters for predictive metrics computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compared to <code><a href="#topic+metrics.covlmc">metrics.covlmc()</a></code>, this function focuses on a single context and
assesses the quality of its predictions, disregarding observations that have
other contexts. Apart from this limited scope, the function operates as
<code><a href="#topic+metrics.covlmc">metrics.covlmc()</a></code>.
</p>


<h3>Value</h3>

<p>an object of class <code>metrics.covlmc</code> with the following components:
</p>

<ul>
<li> <p><code>accuracy</code>: the accuracy of the predictions
</p>
</li>
<li> <p><code>conf_mat</code>: the confusion matrix of the predictions, with predicted values
in rows and true values in columns
</p>
</li>
<li> <p><code>auc</code>: the AUC of the predictive model
</p>
</li></ul>



<h3>References</h3>

<p>David J. Hand and Robert J. Till (2001). &quot;A Simple Generalisation
of the Area Under the ROC Curve for Multiple Class Classification Problems.&quot;
<em>Machine Learning</em> 45(2), p. 171&ndash;186. DOI: <a href="https://doi.org/10.1023/A%3A1010920819831">doi:10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code>, <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
m_ctxs &lt;- contexts(m_cov)
## get the predictive metrics for each context
lapply(m_ctxs, metrics)
</code></pre>

<hr>
<h2 id='metrics.vlmc'>Predictive quality metrics for VLMC</h2><span id='topic+metrics.vlmc'></span><span id='topic+print.metrics.vlmc'></span>

<h3>Description</h3>

<p>This function computes and returns predictive quality metrics for context
based models such as VLMC and VLMC with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
metrics(model, ...)

## S3 method for class 'metrics.vlmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics.vlmc_+3A_model">model</code></td>
<td>
<p>The context based model on which to compute predictive metrics.</p>
</td></tr>
<tr><td><code id="metrics.vlmc_+3A_...">...</code></td>
<td>
<p>Additional parameters for predictive metrics computation.</p>
</td></tr>
<tr><td><code id="metrics.vlmc_+3A_x">x</code></td>
<td>
<p>A metrics.vlmc object, results of a call to <code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A context based model computes transition probabilities for its contexts.
Using a maximum transition probability decision rule, this can be used to
predict the new state that is the more likely to follow the current one,
given the context (see <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>). The quality of these predictions is
evaluated using standard metrics including:
</p>

<ul>
<li><p> accuracy
</p>
</li>
<li><p> the full confusion matrix
</p>
</li>
<li><p> the area under the roc curve (AUC), considering the context based model as
a (conditional) probability estimator. We use Hand and Till (2001) multiclass
AUC in case of a state space with more than 2 states
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>metrics.vlmc</code> with the following components:
</p>

<ul>
<li> <p><code>accuracy</code>: the accuracy of the predictions
</p>
</li>
<li> <p><code>conf_mat</code>: the confusion matrix of the predictions, with predicted values
in rows and true values in columns
</p>
</li>
<li> <p><code>auc</code>: the AUC of the predictive model
</p>
</li></ul>

<p>The object has a print method that recalls basic information about the
model together with the values of the components above.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(metrics.vlmc)</code>: Prints the predictive metrics of the VLMC model.
</p>
</li></ul>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> documentation and in the
dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first initial
values of a time series do not in general have a proper context for a VLMC
with a non zero order. In order to predict something meaningful for those
values, we rely on the notion of extended context defined in the documents
mentioned above. This follows the same logic as using
<code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> with the parameter <code>initial="extended"</code>. All vlmc
functions that need to manipulate initial values with no proper context use
the same approach.
</p>


<h3>References</h3>

<p>David J. Hand and Robert J. Till (2001). &quot;A Simple Generalisation
of the Area Under the ROC Curve for Multiple Class Classification Problems.&quot;
<em>Machine Learning</em> 45(2), p. 171&ndash;186. DOI: <a href="https://doi.org/10.1023/A%3A1010920819831">doi:10.1023/A:1010920819831</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metrics.vlmc">metrics.vlmc()</a></code>, <code><a href="#topic+metrics.ctx_node">metrics.ctx_node()</a></code>, <code><a href="#topic+contexts.vlmc">contexts.vlmc()</a></code>, <code><a href="#topic+predict.vlmc">predict.vlmc()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
breaks &lt;- c(
  0,
  median(powerconsumption$active_power, na.rm = TRUE),
  max(powerconsumption$active_power, na.rm = TRUE)
)
labels &lt;- c(0, 1)
dts &lt;- cut(pc$active_power, breaks = breaks, labels = labels)
model &lt;- vlmc(dts)
metrics(model)

</code></pre>

<hr>
<h2 id='mixvlmc-package'>mixvlmc: Variable Length Markov Chains with Covariates</h2><span id='topic+mixvlmc'></span><span id='topic+mixvlmc-package'></span>

<h3>Description</h3>

<p>Estimates Variable Length Markov Chains (VLMC) models and VLMC with covariates models from discrete sequences. Supports model selection via information criteria and simulation of new sequences from an estimated model. See BÃ¼hlmann, P. and Wyner, A. J. (1999) <a href="https://doi.org/10.1214/aos/1018031204">doi:10.1214/aos/1018031204</a> for VLMC and Zanin Zambom, A., Kim, S. and Lopes Garcia, N. (2022) <a href="https://doi.org/10.1111/jtsa.12615">doi:10.1111/jtsa.12615</a> for VLMC with covariates.
</p>


<h3>Package options</h3>

<p>Mixvlmc uses the following <code><a href="base.html#topic+options">options()</a></code>:
</p>

<ul>
<li> <p><code>mixvlmc.maxit</code>: maximum number of iterations in model fitting for <code><a href="#topic+covlmc">covlmc()</a></code>
</p>
</li>
<li> <p><code>mixvlmc.predictive</code>: specifies the computing engine used for model fitting
for <code><a href="#topic+covlmc">covlmc()</a></code>. Two values are supported:
</p>

<ul>
<li> <p><code>"glm"</code> (default value): <code><a href="#topic+covlmc">covlmc()</a></code> uses <code><a href="stats.html#topic+glm">stats::glm()</a></code> with a binomial
link (<code><a href="stats.html#topic+family">stats::binomial()</a></code>) for a two values state space, and <code><a href="VGAM.html#topic+vglm">VGAM::vglm()</a></code>
with a multinomial link (<code><a href="VGAM.html#topic+multinomial">VGAM::multinomial()</a></code>) for a state space with
three or more values;
</p>
</li>
<li> <p><code>"multinom"</code>: <code><a href="#topic+covlmc">covlmc()</a></code> uses <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code> in all cases.
</p>
</li></ul>

<p>The first option <code>"glm"</code> is recommended as both <code><a href="stats.html#topic+glm">stats::glm()</a></code> and <code><a href="VGAM.html#topic+vglm">VGAM::vglm()</a></code>
are able to detect and deal with degeneracy in the data set.
</p>
</li>
<li> <p><code>mixvlmc.backend</code>: specifies the implementation used for the context tree
construction in <code><a href="#topic+ctx_tree">ctx_tree()</a></code>, <code><a href="#topic+vlmc">vlmc()</a></code> and <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>. Two values are
supported:
</p>

<ul>
<li> <p><code>"R"</code> (default value): this corresponds to the original almost pure R
implementation.
</p>
</li>
<li> <p><code>"C++"</code>: this corresponds to the experimental C++ implementation. This
version is significantly faster than the R version, but is still
considered experimental.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Fabrice Rossi <a href="mailto:Fabrice.Rossi@apiacoa.org">Fabrice.Rossi@apiacoa.org</a> (<a href="https://orcid.org/0000-0003-4638-1286">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Hugo Le Picard <a href="mailto:lepicardhugo@gmail.com">lepicardhugo@gmail.com</a> (<a href="https://orcid.org/0000-0002-7023-2996">ORCID</a>) [contributor]
</p>
</li>
<li><p> GuÃ©nolÃ© Joubioux <a href="mailto:guenole.joubioux@gmail.com">guenole.joubioux@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/fabrice-rossi/mixvlmc">https://github.com/fabrice-rossi/mixvlmc</a>
</p>
</li>
<li> <p><a href="https://fabrice-rossi.github.io/mixvlmc/">https://fabrice-rossi.github.io/mixvlmc/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fabrice-rossi/mixvlmc/issues">https://github.com/fabrice-rossi/mixvlmc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='model'>Logistic model of a COVLMC context</h2><span id='topic+model'></span>

<h3>Description</h3>

<p>This function returns a representation of the logistic model associated to a
COVLMC context from its node in the associated context tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(node, type = c("coef", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_+3A_node">node</code></td>
<td>
<p>A <code>ctx_node_covlmc</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code> or
<code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code></p>
</td></tr>
<tr><td><code id="model_+3A_type">type</code></td>
<td>
<p>specifies the model information to return, either the
coefficients only (<code>type="coef"</code> default case) or the full model object
(<code>type="full"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Full model extraction is only possible if the COVLMC model what not fully
trimmed (see <code><a href="#topic+trim.covlmc">trim.covlmc()</a></code>). Notice that <code><a href="#topic+find_sequence.covlmc">find_sequence.covlmc()</a></code> can
produce node that are not context: in this case this function return <code>NULL</code>.
</p>


<h3>Value</h3>

<p>if <code>node</code> is a context, the coefficients of the logistic model (as a
vector or a matrix depending on the size of the state space) or a logistic
model as a R object. If <code>node</code> is not a context, <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 10)
vals &lt;- states(m_cov)
node &lt;- find_sequence(m_cov, c(vals[1], vals[1]))
node
model(node)
model(node, type = "full")

</code></pre>

<hr>
<h2 id='parent'>Find the parent of a node in a context tree</h2><span id='topic+parent'></span><span id='topic+parent.ctx_node'></span><span id='topic+parent.ctx_node_cpp'></span>

<h3>Description</h3>

<p>This function returns the parent node of the node represented by the
<code>node</code> parameter. The result is <code>NULL</code> if <code>node</code> is the root node of
its context tree (representing the empty sequence).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent(node)

## S3 method for class 'ctx_node'
parent(node)

## S3 method for class 'ctx_node_cpp'
parent(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parent_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each node of a context tree represents a sequence. When <code><a href="#topic+find_sequence">find_sequence()</a></code> is
called with success, the returned object represents the corresponding node in
the context tree. Unless the original sequence is empty, this node has a
parent node which is returned as a <code>ctx_node</code> object by the present function.
Another interpretation is that the function returns the <code>node</code> object
associated to the sequence obtained by removing the oldest value from the
original sequence.
</p>


<h3>Value</h3>

<p>a <code>ctx_node</code> object if <code>node</code> does correspond to the empty
sequence or <code>NULL</code> when this is not the case
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3)
ctx_00 &lt;- find_sequence(dts_ctree, c(0, 0))
## the parent sequence/node corresponds to the 0 context
parent(ctx_00)
identical(parent(ctx_00), find_sequence(dts_ctree, c(0)))
## C++ backend
dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 3, backend = "C++")
ctx_00 &lt;- find_sequence(dts_ctree, c(0, 0))
## the parent sequence/node corresponds to the 0 context
parent(ctx_00)
identical(parent(ctx_00), find_sequence(dts_ctree, c(0)))
</code></pre>

<hr>
<h2 id='plot.tune_vlmc'>Plot the results of automatic (CO)VLMC complexity selection</h2><span id='topic+plot.tune_vlmc'></span><span id='topic+plot.tune_covlmc'></span>

<h3>Description</h3>

<p>This function plots the results of <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code> or <code><a href="#topic+tune_covlmc">tune_covlmc()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune_vlmc'
plot(
  x,
  value = c("criterion", "likelihood"),
  cutoff = c("quantile", "native"),
  ...
)

## S3 method for class 'tune_covlmc'
plot(
  x,
  value = c("criterion", "likelihood"),
  cutoff = c("quantile", "native"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tune_vlmc_+3A_x">x</code></td>
<td>
<p>a <code>tune_vlmc</code> object</p>
</td></tr>
<tr><td><code id="plot.tune_vlmc_+3A_value">value</code></td>
<td>
<p>the criterion to plot (default &quot;criterion&quot;).</p>
</td></tr>
<tr><td><code id="plot.tune_vlmc_+3A_cutoff">cutoff</code></td>
<td>
<p>the scale used for the cut off criterion (default &quot;quantile&quot;)</p>
</td></tr>
<tr><td><code id="plot.tune_vlmc_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="base.html#topic+plot">base::plot()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard plot consists in showing the evolution of the criterion
used to select the model (<code><a href="stats.html#topic+AIC">AIC()</a></code> or <code><a href="stats.html#topic+BIC">BIC()</a></code>) as a function of the
cut off criterion expressed in the quantile scale (the quantile is used
by default to offer a common default behaviour between <code><a href="#topic+vlmc">vlmc()</a></code> and
<code><a href="#topic+covlmc">covlmc()</a></code>). Parameters can be used to display instead the <code><a href="#topic+loglikelihood">loglikelihood()</a></code>
of the model (by setting <code>value="likelihood"</code>) and to use the native
scale for the cut off when available (by setting <code>cutoff="native"</code>).
</p>


<h3>Value</h3>

<p>the <code>tune_vlmc</code> object invisibly
</p>


<h3>Customisation</h3>

<p>The function sets several default before calling <code><a href="base.html#topic+plot">base::plot()</a></code>, namely:
</p>

<ul>
<li> <p><code>type</code>: &quot;l&quot; by default to use a line representation;
</p>
</li>
<li> <p><code>xlab</code>: &quot;Cut off (quantile scale)&quot; by default, adapted to the actual
scale;
</p>
</li>
<li> <p><code>ylab</code>: the name of the criterion or &quot;Log likelihood&quot;.
</p>
</li></ul>

<p>These parameters can be overridden by specifying other values when calling
the function. All parameters specified in addition to <code>x</code>, <code>value</code> and
<code>cutoff</code> are passed to <code><a href="base.html#topic+plot">base::plot()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
tune_result &lt;- tune_vlmc(dts)
## default plot
plot(tune_result)
## likelihood
plot(tune_result, value = "likelihood")
## parameters overriding
plot(tune_result,
  value = "likelihood",
  xlab = "Cut off", type = "b"
)
pc &lt;- powerconsumption[powerconsumption$week %in% 10:12, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
dts_best_model_tune &lt;- tune_covlmc(dts, dts_cov, criterion = "AIC")
plot(dts_best_model_tune)
plot(dts_best_model_tune, value = "likelihood")

</code></pre>

<hr>
<h2 id='positions'>Report the positions of a sequence associated to a node</h2><span id='topic+positions'></span><span id='topic+positions.ctx_node'></span><span id='topic+positions.ctx_node_cpp'></span>

<h3>Description</h3>

<p>This function returns the positions of the sequence represented by <code>node</code>
in the time series used to build the context tree in which the sequence is
represented. This is only possible is those positions were saved during the
construction of the context tree. In positions were not saved, a call to this
function produces an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positions(node)

## S3 method for class 'ctx_node'
positions(node)

## S3 method for class 'ctx_node_cpp'
positions(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positions_+3A_node">node</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A position of a sequence <code>ctx</code> in the time series <code>x</code> is an index value <code>t</code>
such that the sequence ends with <code>x[t]</code>. Thus <code>x[t+1]</code> is after the context.
For instance if <code>x=c(0, 0, 1, 1)</code> and <code>ctx=c(0, 1)</code> (in standard state
order), then the position of <code>ctx</code> in <code>x</code> is 3.
</p>


<h3>Value</h3>

<p>positions of the sequence represented by <code>node</code> is the original
time series as a integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
dts_tree &lt;- ctx_tree(dts, max_depth = 3, min_size = 5)
subseq &lt;- find_sequence(dts_tree, factor(c("B", "A"), levels = c("A", "B", "C")))
if (!is.null(subseq)) {
  positions(subseq)
}
</code></pre>

<hr>
<h2 id='powerconsumption'>Individual household electric power consumption</h2><span id='topic+powerconsumption'></span>

<h3>Description</h3>

<p>A data set containing measurements of the electric power consumption of one
household with a time resolution of 10 minutes for the full year of 2008.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerconsumption
</code></pre>


<h3>Format</h3>

<p>A data frame with 52704 rows and 15 variables:
</p>

<dl>
<dt>month</dt><dd><p>month of 2008</p>
</dd>
<dt>month_day</dt><dd><p>day of the month</p>
</dd>
<dt>hour</dt><dd><p>hour (0 to 23)</p>
</dd>
<dt>minute</dt><dd><p>starting minute of the 10 minutes period of this row</p>
</dd>
<dt>active_power</dt><dd><p>global average active power on the 10 minute period
(in kilowatt)</p>
</dd>
<dt>reactive_power</dt><dd><p>global average reactive power on the 10 minute
period (in kilowatt)</p>
</dd>
<dt>voltage</dt><dd><p>Average voltage on the 10 minute period (in volt)</p>
</dd>
<dt>intensity</dt><dd><p>global average current intensity  on the 10 minute
period (in ampere)</p>
</dd>
<dt>sub_metering_1</dt><dd><p>energy sub-metering No. 1 (in watt-hour of active
energy averaged over the 10 minute period). It corresponds to the kitchen,
containing mainly a dishwasher, an oven and a microwave (hot plates are
not electric but gas powered)</p>
</dd>
<dt>sub_metering_2</dt><dd><p>energy sub-metering No. 2 (in watt-hour of active
energy averaged over the 10 minute period). It corresponds to the laundry
room, containing a washing-machine, a tumble-drier, a refrigerator and a light.</p>
</dd>
<dt>sub_metering_3</dt><dd><p>energy sub-metering No. 3 (in watt-hour of active energy
averaged over the 10 minute period). It corresponds to an electric
water-heater and an air-conditioner.</p>
</dd>
<dt>week</dt><dd><p>week number</p>
</dd>
<dt>week_day</dt><dd><p>day of the week from 1 = Sunday to 7 = Saturday</p>
</dd>
<dt>year_day</dt><dd><p>day of the year from 1 to 366 (2008 is a leap year)</p>
</dd>
<dt>date_time</dt><dd><p>Date and time in POSIXct format</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a simplified version of the full data available on the UCI Machine
Learning Repository under a
<a href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons
Attribution 4.0 International</a> (CC BY 4.0) license, and provided by Georges
Hebrail and Alice Berard.
</p>
<p>The original data have been averaged over a 10 minute time period (discarding
missing data in each period). The data set contains only
the measurements from year 2008.
</p>
<p>Notice that the different variables are expressed in the adapted units.
In particular, the sub-meters are measuring active energy (in watt-hour) while
the global active power is expressed in kilowatt.
</p>


<h3>Source</h3>

<p>Individual household electric power consumption, 2012, G. Hebrail and A. Berard,
UC Irvine Machine Learning repository.
<a href="https://doi.org/10.24432/C58K54">doi:10.24432/C58K54</a>
</p>

<hr>
<h2 id='predict.covlmc'>Next state prediction in a discrete time series for a VLMC with covariates</h2><span id='topic+predict.covlmc'></span>

<h3>Description</h3>

<p>This function computes one step ahead predictions for a discrete time series
based on a VLMC with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
predict(
  object,
  newdata,
  newcov,
  type = c("raw", "probs"),
  final_pred = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.covlmc_+3A_object">object</code></td>
<td>
<p>a fitted covlmc object.</p>
</td></tr>
<tr><td><code id="predict.covlmc_+3A_newdata">newdata</code></td>
<td>
<p>a time series adapted to the covlmc object.</p>
</td></tr>
<tr><td><code id="predict.covlmc_+3A_newcov">newcov</code></td>
<td>
<p>a data frame with the new values for the covariates.</p>
</td></tr>
<tr><td><code id="predict.covlmc_+3A_type">type</code></td>
<td>
<p>character indicating the type of prediction required. The default
<code>"raw"</code> returns actual predictions in the form of a new time series. The
alternative <code>"probs"</code> returns a matrix of prediction probabilities (see
details).</p>
</td></tr>
<tr><td><code id="predict.covlmc_+3A_final_pred">final_pred</code></td>
<td>
<p>if <code>TRUE</code> (default value), the predictions include a final
prediction step, made by computing the context of the full time series.
When <code>FALSE</code> this final prediction is not included.</p>
</td></tr>
<tr><td><code id="predict.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a time series <code>X</code>, at time step <code>t</code>, a context is computed using
observations from <code>X[1]</code> to <code>X[t-1]</code> (see the dedicated section). The
prediction is then the most probable state for <code>X[t]</code> given this logistic
model of the context and the corresponding values of the covariates. The time
series of predictions is returned by the function when <code>type="raw"</code> (default
case).
</p>
<p>When <code>type="probs"</code>, the function returns of the probabilities of each state
for <code>X[t]</code> as estimated by the logistic models. Those probabilities are
returned as a matrix of probabilities with column names given by the state
names.
</p>


<h3>Value</h3>

<p>A vector of predictions if <code>type="raw"</code> or a matrix of state
probabilities if <code>type="probs"</code>.
</p>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> documentation and in
the dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first
initial values of a time series do not in general have a proper context for
a COVLMC with a non zero order. In order to predict something meaningful
for those values, we rely on the notion of extended context defined in the
documents mentioned above. This follows the same logic as using
<code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> with the parameter <code>initial="extended"</code>. All
covlmc functions that need to manipulate initial values with no proper
context use the same approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 10, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.2, 0.7, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5, alpha = 0.5)
dts_probs &lt;- predict(m_cov, dts[1:144], dts_cov[1:144, , drop = FALSE], type = "probs")
dts_preds &lt;- predict(m_cov, dts[1:144], dts_cov[1:144, , drop = FALSE],
  type = "raw", final_pred = FALSE
)
</code></pre>

<hr>
<h2 id='predict.vlmc'>Next state prediction in a discrete time series for a VLMC</h2><span id='topic+predict.vlmc'></span><span id='topic+predict.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function computes one step ahead predictions for a discrete time series
based on a VLMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
predict(object, newdata, type = c("raw", "probs"), final_pred = TRUE, ...)

## S3 method for class 'vlmc_cpp'
predict(object, newdata, type = c("raw", "probs"), final_pred = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.vlmc_+3A_object">object</code></td>
<td>
<p>a fitted vlmc object.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_newdata">newdata</code></td>
<td>
<p>a time series adapted to the vlmc object.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_type">type</code></td>
<td>
<p>character indicating the type of prediction required. The default
<code>"raw"</code> returns actual predictions in the form of a new time series. The
alternative <code>"probs"</code> returns a matrix of prediction probabilities (see
details).</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_final_pred">final_pred</code></td>
<td>
<p>if <code>TRUE</code> (default value), the predictions include a final
prediction step, made by computing the context of the full time series.
When <code>FALSE</code> this final prediction is not included.</p>
</td></tr>
<tr><td><code id="predict.vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a time series <code>X</code>, at time step <code>t</code>, a context is computed using
observations from <code>X[1]</code> to <code>X[t-1]</code> (see the dedicated section). The
prediction is then the most probable state for <code>X[t]</code> given this contexts.
Ties are broken according to the natural order in the state space, favouring
&quot;small&quot; values. The time series of predictions is returned by the function
when <code>type="raw"</code> (default case).
</p>
<p>When <code>type="probs"</code>, each <code>X[t]</code> is associated to the conditional
probabilities of the next state given the context. Those probabilities are
returned as a matrix of probabilities with column names given by the state
names.
</p>


<h3>Value</h3>

<p>A vector of predictions if <code>type="raw"</code> or a matrix of state
probabilities if <code>type="probs"</code>.
</p>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> documentation and in the
dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first initial
values of a time series do not in general have a proper context for a VLMC
with a non zero order. In order to predict something meaningful for those
values, we rely on the notion of extended context defined in the documents
mentioned above. This follows the same logic as using
<code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> with the parameter <code>initial="extended"</code>. All vlmc
functions that need to manipulate initial values with no proper context use
the same approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts, min_size = 5)
predict(model, dts[1:5])
predict(model, dts[1:5], "probs")
## C++ backend
pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts, min_size = 5, backend = "C++")
predict(model, dts[1:5])
predict(model, dts[1:5], "probs")
</code></pre>

<hr>
<h2 id='print.contexts'>Print a context list</h2><span id='topic+print.contexts'></span>

<h3>Description</h3>

<p>This function prints a list of contexts i.e. a <code>contexts</code> object listing
<code>ctx_node</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'contexts'
print(x, reverse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.contexts_+3A_x">x</code></td>
<td>
<p>the <code>contexts</code> object to print</p>
</td></tr>
<tr><td><code id="print.contexts_+3A_reverse">reverse</code></td>
<td>
<p>specifies whether the contexts should be reported in
temporal order (<code>FALSE</code>, default value) or in reverse temporal order (<code>TRUE</code>).
If the parameter is not specified, the contexts are displayed in order
specified by the call to <code>contexts()</code> used to build the context list.</p>
</td></tr>
<tr><td><code id="print.contexts_+3A_...">...</code></td>
<td>
<p>additional arguments for the print function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>x</code> object, invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contexts">contexts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c("A", "B", "C", "A", "A", "B", "B", "C", "C", "A")
dts_tree &lt;- ctx_tree(dts, max_depth = 3)
print(contexts(dts_tree))
</code></pre>

<hr>
<h2 id='prune'>Prune a Variable Length Markov Chain (VLMC)</h2><span id='topic+prune'></span><span id='topic+prune.vlmc'></span><span id='topic+prune.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function prunes a VLMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(vlmc, alpha = 0.05, cutoff = NULL, ...)

## S3 method for class 'vlmc'
prune(vlmc, alpha = 0.05, cutoff = NULL, ...)

## S3 method for class 'vlmc_cpp'
prune(vlmc, alpha = 0.05, cutoff = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_vlmc">vlmc</code></td>
<td>
<p>a fitted VLMC model.</p>
</td></tr>
<tr><td><code id="prune_+3A_alpha">alpha</code></td>
<td>
<p>number in (0,1] (default: 0.05) cut off value in quantile scale
for pruning.</p>
</td></tr>
<tr><td><code id="prune_+3A_cutoff">cutoff</code></td>
<td>
<p>positive number: cut off value in native (log likelihood ratio)
scale for pruning. Defaults to the value obtained from <code>alpha</code>. Takes
precedence over <code>alpha</code> if specified.</p>
</td></tr>
<tr><td><code id="prune_+3A_...">...</code></td>
<td>
<p>additional arguments for the prune function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, pruning a VLMC is more efficient than constructing two VLMC (the
base one and pruned one). Up to numerical instabilities, building a VLMC with
a <code>a</code> cut off and then pruning it with a <code>b</code> cut off (with <code>a&gt;b</code>) should
produce the same VLMC than building directly the VLMC with a <code>b</code> cut off.
Interesting cut off values can be extracted from a VLMC using the <code><a href="#topic+cutoff">cutoff()</a></code>
function.
</p>
<p>As automated model selection is provided by <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>, the direct use of <code>cutoff</code>
should be reserved to advanced exploration of the set of trees that can be
obtained from a complex one, e.g. to implement model selection techniques that
are not provided by <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>.
</p>


<h3>Value</h3>

<p>a pruned VLMC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
base_model &lt;- vlmc(dts, alpha = 0.1)
model_cuts &lt;- cutoff(base_model)
pruned_model &lt;- prune(base_model, model_cuts[3])
draw(pruned_model)
direct_simple &lt;- vlmc(dts, alpha = model_cuts[3])
draw(direct_simple)
# pruned_model and direct_simple should be identical
all.equal(pruned_model, direct_simple)
</code></pre>

<hr>
<h2 id='prune.covlmc'>Prune a Variable Length Markov Chain with covariates</h2><span id='topic+prune.covlmc'></span>

<h3>Description</h3>

<p>This function prunes a vlmc with covariates. This model must have been
estimated with <code>keep_data=TRUE</code> to enable the pruning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
prune(vlmc, alpha = 0.05, cutoff = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune.covlmc_+3A_vlmc">vlmc</code></td>
<td>
<p>a fitted VLMC model with covariates.</p>
</td></tr>
<tr><td><code id="prune.covlmc_+3A_alpha">alpha</code></td>
<td>
<p>number in (0,1) (default: 0.05) cutoff value in quantile scale
for pruning.</p>
</td></tr>
<tr><td><code id="prune.covlmc_+3A_cutoff">cutoff</code></td>
<td>
<p>not supported by the vlmc with covariates.</p>
</td></tr>
<tr><td><code id="prune.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the prune function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Post pruning a VLMC with covariates is not as straightforward as the same
procedure applied to <code><a href="#topic+vlmc">vlmc()</a></code> (see <code><a href="#topic+cutoff.vlmc">cutoff.vlmc()</a></code> and <code><a href="#topic+prune.vlmc">prune.vlmc()</a></code>). For
efficiency reasons, <code><a href="#topic+covlmc">covlmc()</a></code> estimates only the logistic models that are
considered useful for a given set construction parameters. With a more
aggressive pruning threshold, some contexts become leaves of the context tree
and new logistic models must be estimated. Thus the pruning opportunities
given by <code><a href="#topic+cutoff.covlmc">cutoff.covlmc()</a></code> are only a subset of interesting cut offs for a
given covlmc.
</p>
<p>Nevertheless, <code>covlmc</code> share with <code><a href="#topic+vlmc">vlmc()</a></code> the principle that post pruning a
covlmc should give the same model as buidling directly the covlmc, provided
that the post pruning alpha is smaller than the alpha used to build the
initial model.
</p>


<h3>Value</h3>

<p>a pruned covlmc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5, keep_data = TRUE)
draw(m_cov)
m_cov_cuts &lt;- cutoff(m_cov)
p_cov &lt;- prune(m_cov, m_cov_cuts[1])
draw(p_cov)
</code></pre>

<hr>
<h2 id='rev.ctx_node'>Reverse Sequence</h2><span id='topic+rev.ctx_node'></span>

<h3>Description</h3>

<p>This function reverses the order in which the sequence represented by the
<code>ctx_node</code> parameter will be reported in other functions, mainly
<code><a href="#topic+as_sequence">as_sequence()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctx_node'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev.ctx_node_+3A_x">x</code></td>
<td>
<p>a <code>ctx_node</code> object as returned by <code><a href="#topic+find_sequence">find_sequence()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ctx_node</code> using the opposite ordering convention as the parameter
of the function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_reversed">is_reversed()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c("A", "B", "C", "A", "A", "B", "B", "C", "C", "A")
dts_tree &lt;- ctx_tree(dts, max_depth = 3)
res &lt;- find_sequence(dts_tree, c("A", "B"))
print(res)
r_res &lt;- rev(res)
print(r_res)
as_sequence(r_res)
</code></pre>

<hr>
<h2 id='simulate.covlmc'>Simulate a discrete time series for a covlmc</h2><span id='topic+simulate.covlmc'></span>

<h3>Description</h3>

<p>This function simulates a time series from the distribution estimated by the
given covlmc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
simulate(object, nsim = 1, seed = NULL, covariate, init = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.covlmc_+3A_object">object</code></td>
<td>
<p>a fitted covlmc object.</p>
</td></tr>
<tr><td><code id="simulate.covlmc_+3A_nsim">nsim</code></td>
<td>
<p>length of the simulated time series (defaults to 1).</p>
</td></tr>
<tr><td><code id="simulate.covlmc_+3A_seed">seed</code></td>
<td>
<p>an optional random seed (see the dedicated section).</p>
</td></tr>
<tr><td><code id="simulate.covlmc_+3A_covariate">covariate</code></td>
<td>
<p>values of the covariates.</p>
</td></tr>
<tr><td><code id="simulate.covlmc_+3A_init">init</code></td>
<td>
<p>an optional initial sequence for the time series.</p>
</td></tr>
<tr><td><code id="simulate.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A VLMC with covariates model needs covariates to compute its transition
probabilities. The covariates must be submitted as a data frame using the
<code>covariate</code> argument. In addition,  the time series can be initiated by a
fixed sequence specified via the <code>init</code> parameter.
</p>


<h3>Value</h3>

<p>a simulated discrete time series of the same type as the one used to
build the covlmc with a <code>seed</code> attribute (see the Random seed section). The
results has also the <code>dts</code> class to hide the <code>seed</code> attribute when using
<code>print</code> or similar function.
</p>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> documentation and in
the dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first
initial values of a time series do not in general have a proper context for
a COVLMC with a non zero order. In order to simulate something meaningful
for those values, we rely on the notion of extended context defined in the
documents mentioned above. This follows the same logic as using
<code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> with the parameter <code>initial="extended"</code>. All
covlmc functions that need to manipulate initial values with no proper
context use the same approach.
</p>


<h3>Random seed</h3>

<p>This function reproduce the behaviour of <code><a href="stats.html#topic+simulate">stats::simulate()</a></code>. If <code>seed</code> is
<code>NULL</code> the function does not change the random generator state and returns
the value of <a href="base.html#topic+.Random.seed">.Random.seed</a> as a <code>seed</code> attribute in the return value. This
can be used to reproduce exactly the simulation results by setting
<a href="base.html#topic+.Random.seed">.Random.seed</a> to this value. Notice that if the random seed has not be
initialised by R so far, the function issues a call to <code>runif(1)</code> to
perform this initialisation (as is done in <code><a href="stats.html#topic+simulate">stats::simulate()</a></code>).
</p>
<p>It <code>seed</code> is an integer, it is used in a call to <code><a href="base.html#topic+set.seed">set.seed()</a></code> before the
simulation takes place. The integer is saved as a <code>seed</code> attribute in the
return value. The integer seed is completed by an attribute <code>kind</code> which
contains the value <code style="white-space: pre;">&#8288;as.list([RNGkind()])&#8288;</code> exactly as with
<code><a href="stats.html#topic+simulate">stats::simulate()</a></code>. The random generator state is reset to its original
value at the end of the call.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">stats::simulate()</a></code> for details and examples on the random number generator setting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 5)
# new week with day light from 6:00 to 18:00
new_cov &lt;- data.frame(day_night = rep(c(rep(FALSE, 59), rep(TRUE, 121), rep(FALSE, 60)), times = 7))
new_dts &lt;- simulate(m_cov, nrow(new_cov), seed = 0, covariate = new_cov)
new_dts_2 &lt;- simulate(m_cov, nrow(new_cov), seed = 0, covariate = new_cov, init = dts[1:10])
</code></pre>

<hr>
<h2 id='simulate.vlmc'>Simulate a discrete time series for a vlmc</h2><span id='topic+simulate.vlmc'></span>

<h3>Description</h3>

<p>This function simulates a time series from the distribution estimated by the
given vlmc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
simulate(object, nsim = 1L, seed = NULL, init = NULL, burnin = 0L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.vlmc_+3A_object">object</code></td>
<td>
<p>a fitted vlmc object.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_nsim">nsim</code></td>
<td>
<p>length of the simulated time series (defaults to 1).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_seed">seed</code></td>
<td>
<p>an optional random seed (see the dedicated section).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_init">init</code></td>
<td>
<p>an optional initial sequence for the time series.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_burnin">burnin</code></td>
<td>
<p>number of initial observations to discard or <code>"auto"</code> (see the
dedicated section).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series can be initiated by a fixed sequence specified via the <code>init</code>
parameter.
</p>


<h3>Value</h3>

<p>a simulated discrete time series of the same type as the one used to
build the vlmc with a <code>seed</code> attribute (see the Random seed section). The
results has also the <code>dts</code> class to hide the <code>seed</code> attribute when using
<code>print</code> or similar function.
</p>


<h3>Burn in (Warm up) period</h3>

<p>When using a VLMC for simulation purposes, we are generally interested in
the stationary distribution of the corresponding Markov chain. To reduce
the dependence of the samples from the initial values and get closer to
this stationary distribution (if it exists), it is recommended to discard
the first samples which are produced in a so-called &quot;burn in&quot; (or &quot;warm
up&quot;) period. The <code>burnin</code> parameter can be used to implement this approach.
The VLMC is used to produce a sample of size <code>burnin + nsim</code> but the first
<code>burnin</code> values are discarded. Notice that this burn in values can be
partially given by the <code>init</code> parameter if it is specified.
</p>
<p>If <code>burnin</code> is set to <code>"auto"</code>, the <code>burnin</code> period is set to <code>64 * context_number(object)</code>, following the heuristic proposed in MÃ¤chler and
BÃ¼hlmann (2004).
</p>


<h3>Random seed</h3>

<p>This function reproduce the behaviour of <code><a href="stats.html#topic+simulate">stats::simulate()</a></code>. If <code>seed</code> is
<code>NULL</code> the function does not change the random generator state and returns
the value of <a href="base.html#topic+.Random.seed">.Random.seed</a> as a <code>seed</code> attribute in the return value. This
can be used to reproduce exactly the simulation results by setting
<a href="base.html#topic+.Random.seed">.Random.seed</a> to this value. Notice that if the random seed has not be
initialised by R so far, the function issues a call to <code>runif(1)</code> to
perform this initialisation (as is done in <code><a href="stats.html#topic+simulate">stats::simulate()</a></code>).
</p>
<p>It <code>seed</code> is an integer, it is used in a call to <code><a href="base.html#topic+set.seed">set.seed()</a></code> before the
simulation takes place. The integer is saved as a <code>seed</code> attribute in the
return value. The integer seed is completed by an attribute <code>kind</code> which
contains the value <code style="white-space: pre;">&#8288;as.list([RNGkind()])&#8288;</code> exactly as with
<code><a href="stats.html#topic+simulate">stats::simulate()</a></code>. The random generator state is reset to its original
value at the end of the call.
</p>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> documentation and in the
dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first initial
values of a time series do not in general have a proper context for a VLMC
with a non zero order. In order to simulate something meaningful for those
values when <code>init</code> is not provided, we rely on the notion of extended
context defined in the documents mentioned above. This follows the same
logic as using <code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> with the parameter
<code>initial="extended"</code>. All vlmc functions that need to manipulate initial
values with no proper context use the same approach.
</p>


<h3>References</h3>

<p>MÃ¤chler, M. and BÃ¼hlmann, P. (2004) &quot;Variable Length Markov
Chains: Methodology, Computing, and Software&quot; Journal of Computational and
Graphical Statistics, 13 (2), 435-455, <a href="https://doi.org/10.1198/1061860043524">doi:10.1198/1061860043524</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">stats::simulate()</a></code> for details and examples on the random number
generator setting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts, min_size = 5)
new_dts &lt;- simulate(model, 500, seed = 0)
new_dts_2 &lt;- simulate(model, 500, seed = 0, init = dts[1:5])
new_dts_3 &lt;- simulate(model, 500, seed = 0, burnin = 500)
</code></pre>

<hr>
<h2 id='simulate.vlmc_cpp'>Simulate a discrete time series for a vlmc</h2><span id='topic+simulate.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function simulates a time series from the distribution estimated by the
given vlmc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc_cpp'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  init = NULL,
  burnin = 0L,
  sample = c("fast", "slow", "R"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.vlmc_cpp_+3A_object">object</code></td>
<td>
<p>a fitted vlmc object.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_cpp_+3A_nsim">nsim</code></td>
<td>
<p>length of the simulated time series (defaults to 1).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_cpp_+3A_seed">seed</code></td>
<td>
<p>an optional random seed (see the dedicated section).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_cpp_+3A_init">init</code></td>
<td>
<p>an optional initial sequence for the time series.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_cpp_+3A_burnin">burnin</code></td>
<td>
<p>number of initial observations to discard or <code>"auto"</code> (see the
dedicated section).</p>
</td></tr>
<tr><td><code id="simulate.vlmc_cpp_+3A_sample">sample</code></td>
<td>
<p>specifies which implementation of <code><a href="base.html#topic+sample">base::sample()</a></code> to use.
See the dedicated section.</p>
</td></tr>
<tr><td><code id="simulate.vlmc_cpp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series can be initiated by a fixed sequence specified via the <code>init</code>
parameter.
</p>


<h3>Value</h3>

<p>a simulated discrete time series of the same type as the one used to
build the vlmc with a <code>seed</code> attribute (see the Random seed section). The
results has also the <code>dts</code> class to hide the <code>seed</code> attribute when using
<code>print</code> or similar function.
</p>


<h3>sampling method</h3>

<p>The R backend for <code><a href="#topic+vlmc">vlmc()</a></code> uses <code><a href="base.html#topic+sample">base::sample()</a></code> to generate samples for each
context. Internally, this function sorts the probabilities of each state in
decreasing probability order (among other things), which is not needed in our
case. The C++ backend can be used with three different implementations:
</p>

<ul>
<li> <p><code>sample="fast"</code> uses a dedicated C++ implementation adapted to the data structures
used internally. In general, the simulated time series obtained with this
implementation will be different from the one generated with the R backend,
even using the same seed.
</p>
</li>
<li> <p><code>sample="slow"</code> uses another C++ implementation that mimics <code><a href="base.html#topic+sample">base::sample()</a></code> in
order to maximize the chance to provide identical simulation results regardless
of the backend (when using the same random seed). This process is not perfect
as we use the std::lib sort algorithm which is not guaranteed to give identical
results as the ones of R internal 'revsort'.
</p>
</li>
<li> <p><code>sample="R"</code> uses direct calls to <code><a href="base.html#topic+sample">base::sample()</a></code>. Results are guaranteed
to be identical between the two backends, but at the price of higher running
time.
</p>
</li></ul>



<h3>Burn in (Warm up) period</h3>

<p>When using a VLMC for simulation purposes, we are generally interested in
the stationary distribution of the corresponding Markov chain. To reduce
the dependence of the samples from the initial values and get closer to
this stationary distribution (if it exists), it is recommended to discard
the first samples which are produced in a so-called &quot;burn in&quot; (or &quot;warm
up&quot;) period. The <code>burnin</code> parameter can be used to implement this approach.
The VLMC is used to produce a sample of size <code>burnin + nsim</code> but the first
<code>burnin</code> values are discarded. Notice that this burn in values can be
partially given by the <code>init</code> parameter if it is specified.
</p>
<p>If <code>burnin</code> is set to <code>"auto"</code>, the <code>burnin</code> period is set to <code>64 * context_number(object)</code>, following the heuristic proposed in MÃ¤chler and
BÃ¼hlmann (2004).
</p>


<h3>Random seed</h3>

<p>This function reproduce the behaviour of <code><a href="stats.html#topic+simulate">stats::simulate()</a></code>. If <code>seed</code> is
<code>NULL</code> the function does not change the random generator state and returns
the value of <a href="base.html#topic+.Random.seed">.Random.seed</a> as a <code>seed</code> attribute in the return value. This
can be used to reproduce exactly the simulation results by setting
<a href="base.html#topic+.Random.seed">.Random.seed</a> to this value. Notice that if the random seed has not be
initialised by R so far, the function issues a call to <code>runif(1)</code> to
perform this initialisation (as is done in <code><a href="stats.html#topic+simulate">stats::simulate()</a></code>).
</p>
<p>It <code>seed</code> is an integer, it is used in a call to <code><a href="base.html#topic+set.seed">set.seed()</a></code> before the
simulation takes place. The integer is saved as a <code>seed</code> attribute in the
return value. The integer seed is completed by an attribute <code>kind</code> which
contains the value <code style="white-space: pre;">&#8288;as.list([RNGkind()])&#8288;</code> exactly as with
<code><a href="stats.html#topic+simulate">stats::simulate()</a></code>. The random generator state is reset to its original
value at the end of the call.
</p>


<h3>Extended contexts</h3>

<p>As explained in details in <code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> documentation and in the
dedicated <code>vignette("likelihood", package = "mixvlmc")</code>, the first initial
values of a time series do not in general have a proper context for a VLMC
with a non zero order. In order to simulate something meaningful for those
values when <code>init</code> is not provided, we rely on the notion of extended
context defined in the documents mentioned above. This follows the same
logic as using <code><a href="#topic+loglikelihood.vlmc">loglikelihood.vlmc()</a></code> with the parameter
<code>initial="extended"</code>. All vlmc functions that need to manipulate initial
values with no proper context use the same approach.
</p>


<h3>References</h3>

<p>MÃ¤chler, M. and BÃ¼hlmann, P. (2004) &quot;Variable Length Markov
Chains: Methodology, Computing, and Software&quot; Journal of Computational and
Graphical Statistics, 13 (2), 435-455, <a href="https://doi.org/10.1198/1061860043524">doi:10.1198/1061860043524</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">stats::simulate()</a></code> for details and examples on the random number
generator setting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1))))
model &lt;- vlmc(dts, min_size = 5)
new_dts &lt;- simulate(model, 500, seed = 0)
new_dts_2 &lt;- simulate(model, 500, seed = 0, init = dts[1:5])
new_dts_3 &lt;- simulate(model, 500, seed = 0, burnin = 500)
</code></pre>

<hr>
<h2 id='states'>State space of a context tree</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>This function returns the state space of a context tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="states_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the state space of the context tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- c(0, 1, 1, 1, 0, 0, 1, 0, 1, 0)
dts_ctree &lt;- ctx_tree(dts, min_size = 1, max_depth = 2)
## should be c(0, 1)
states(dts_ctree)
</code></pre>

<hr>
<h2 id='trim'>Trim a context tree</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>This function returns a trimmed context tree from which match positions
have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(ct, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p>additional arguments for the trim function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trimmed context tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## context tree trimming
dts &lt;- sample(as.factor(c("A", "B", "C")), 1000, replace = TRUE)
dts_tree &lt;- ctx_tree(dts, max_depth = 10, min_size = 5, keep_position = TRUE)
print(object.size(dts_tree))
dts_tree &lt;- trim(dts_tree)
print(object.size(dts_tree))
</code></pre>

<hr>
<h2 id='trim.covlmc'>Trim a COVLMC</h2><span id='topic+trim.covlmc'></span>

<h3>Description</h3>

<p>This function returns a trimmed COVLMC from which cached data have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covlmc'
trim(ct, keep_model = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.covlmc_+3A_ct">ct</code></td>
<td>
<p>a context tree.</p>
</td></tr>
<tr><td><code id="trim.covlmc_+3A_keep_model">keep_model</code></td>
<td>
<p>specifies whether to keep the internal models (or not)</p>
</td></tr>
<tr><td><code id="trim.covlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the trim function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called with <code>keep_model</code> set to <code>FALSE</code> (default case), the trimming is maximal and reduces
further usability of the model. In particular <code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> cannot be used
for new data, <code><a href="#topic+contexts.covlmc">contexts.covlmc()</a></code> do not support model extraction, and
<code><a href="#topic+simulate.covlmc">simulate.covlmc()</a></code>, <code><a href="#topic+metrics.covlmc">metrics.covlmc()</a></code>  and <code><a href="#topic+prune.covlmc">prune.covlmc()</a></code> cannot be used at all.
</p>
<p>Called with <code>keep_model</code> set to <code>TRUE</code>, the trimming process is less complete. In
particular internal models are simplified using <code><a href="butcher.html#topic+butcher">butcher::butcher()</a></code> and some
additional minor reductions. This saves less memory but enables the use of
<code><a href="#topic+loglikelihood.covlmc">loglikelihood.covlmc()</a></code> for new data as
well as the use of <code><a href="#topic+simulate.covlmc">simulate.covlmc()</a></code>.
</p>


<h3>Value</h3>

<p>a trimmed context tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tune_covlmc">tune_covlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week %in% 5:7, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
m_cov &lt;- covlmc(dts, dts_cov, min_size = 10, keep_data = TRUE)
print(object.size(m_cov), units = "Mb")
t_m_cov_model &lt;- trim(m_cov, keep_model = TRUE)
print(object.size(t_m_cov_model), units = "Mb")
t_m_cov &lt;- trim(m_cov)
print(object.size(t_m_cov), units = "Mb")
</code></pre>

<hr>
<h2 id='trim.vlmc'>This function returns a trimmed VLMC from which match positions have been
removed.</h2><span id='topic+trim.vlmc'></span>

<h3>Description</h3>

<p>This function returns a trimmed context tree from which match positions
have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc'
trim(ct, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.vlmc_+3A_ct">ct</code></td>
<td>
<p>a VLMC.</p>
</td></tr>
<tr><td><code id="trim.vlmc_+3A_...">...</code></td>
<td>
<p>additional arguments for the trim function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trimmed VLMC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## VLMC trimming is generally useless unless match positions were kept
pc &lt;- powerconsumption[powerconsumption$week %in% 5:6, ]
dts &lt;- cut(pc$active_power, breaks = 4)
model &lt;- vlmc(dts, keep_match = TRUE)
print(object.size(model))
model &lt;- trim(model)
## memory use should be reduced
print(object.size(model))
nm_model &lt;- vlmc(dts)
print(object.size(nm_model))
nm_model &lt;- trim(nm_model)
## no effect when match positions are not kept
print(object.size(nm_model))
</code></pre>

<hr>
<h2 id='trim.vlmc_cpp'>This function returns a trimmed VLMC from which match positions have been
removed.</h2><span id='topic+trim.vlmc_cpp'></span>

<h3>Description</h3>

<p>This function returns a trimmed context tree from which match positions
have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlmc_cpp'
trim(ct, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.vlmc_cpp_+3A_ct">ct</code></td>
<td>
<p>a VLMC.</p>
</td></tr>
<tr><td><code id="trim.vlmc_cpp_+3A_...">...</code></td>
<td>
<p>additional arguments for the trim function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trimming in the C++ backend is done directly in the <code>Rcpp</code> managed memory and
cannot be detected at R level using e.g. <code><a href="utils.html#topic+object.size">utils::object.size()</a></code>.
</p>


<h3>Value</h3>

<p>a trimmed VLMC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## VLMC trimming is generally useless unless match positions were kept
pc &lt;- powerconsumption[powerconsumption$week %in% 5:6, ]
dts &lt;- cut(pc$active_power, breaks = 4)
model &lt;- vlmc(dts, backend = "C++", keep_match = TRUE)
model &lt;- trim(model)
</code></pre>

<hr>
<h2 id='tune_covlmc'>Fit an optimal Variable Length Markov Chain with Covariates (coVLMC)</h2><span id='topic+tune_covlmc'></span>

<h3>Description</h3>

<p>This function fits a Variable Length Markov Chain with Covariates (coVLMC) to
a discrete time series coupled with a time series of covariates by optimizing
an information criterion (BIC or AIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_covlmc(
  x,
  covariate,
  criterion = c("BIC", "AIC"),
  initial = c("truncated", "specific", "extended"),
  alpha_init = NULL,
  min_size = 5,
  max_depth = 100,
  verbose = 0,
  save = c("best", "initial", "all"),
  trimming = c("full", "partial", "none"),
  best_trimming = c("none", "partial", "full")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_covlmc_+3A_x">x</code></td>
<td>
<p>a discrete time series; can be numeric, character, factor and
logical.</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_covariate">covariate</code></td>
<td>
<p>a data frame of covariates.</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_criterion">criterion</code></td>
<td>
<p>criterion used to select the best model. Either <code>"BIC"</code>
(default) or <code>"AIC"</code> (see details).</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_initial">initial</code></td>
<td>
<p>specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are
integrated in the likelihood. See <code><a href="#topic+loglikelihood">loglikelihood()</a></code> for details.</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_alpha_init">alpha_init</code></td>
<td>
<p>if non <code>NULL</code> used as the initial cut off parameter (in
quantile scale) to build the initial VLMC</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_min_size">min_size</code></td>
<td>
<p>integer &gt;= 1 (default: 5). Tune the minimum number of
observations for a context in the growing phase of the context tree (see
<code><a href="#topic+covlmc">covlmc()</a></code> for details).</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_max_depth">max_depth</code></td>
<td>
<p>integer &gt;= 1 (default: 100). Longest context considered in
growing phase of the initial context tree (see details).</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_verbose">verbose</code></td>
<td>
<p>integer &gt;= 0 (default: 0). Verbosity level of the pruning
process.</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_save">save</code></td>
<td>
<p>specify which BIC models are saved during the pruning process.
The default value <code>"best"</code> asks the function to keep only the best model
according to the <code>criterion</code>. When <code>save="initial"</code> the function keeps <em>in
addition</em> the initial (complex) model which is then pruned during the
selection process. When <code>save="all"</code>, the function returns all the models
considered during the selection process. See details for memory occupation.</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_trimming">trimming</code></td>
<td>
<p>specify the type of trimming used when saving the
intermediate models, see details.</p>
</td></tr>
<tr><td><code id="tune_covlmc_+3A_best_trimming">best_trimming</code></td>
<td>
<p>specify the type of trimming used when saving the best
model and the initial one (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automates the process of fitting a large coVLMC to a discrete
time series with <code><a href="#topic+covlmc">covlmc()</a></code> and of pruning the tree (with <code><a href="#topic+cutoff">cutoff()</a></code> and
<code><a href="#topic+prune">prune()</a></code>) to get an optimal with respect to an information criterion. To
avoid missing long term dependencies, the function uses the <code>max_depth</code>
parameter as an initial guess but then relies on an automatic increase of the
value to make sure the initial context tree is only limited by the <code>min_size</code>
parameter. The initial value of the <code>alpha</code> parameter of <code><a href="#topic+covlmc">covlmc()</a></code> is also
set to a conservative value (0.5) to avoid prior simplification of the
context tree. This can be overridden by setting the <code>alpha_init</code> parameter to
a more adapted value.
</p>
<p>Once the initial coVLMC is obtained, the <code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+prune">prune()</a></code> functions
are used to build all the coVLMC models that could be generated using smaller
values of the alpha parameter. The best model is selected from this
collection, including the initial complex tree, as the one that minimizes the
chosen information criterion.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>

<ul>
<li> <p><code>best_model</code>: the optimal COVLMC
</p>
</li>
<li> <p><code>criterion</code>: the criterion used to select the optimal VLMC
</p>
</li>
<li> <p><code>initial</code>: the likelihood function used to select the optimal VLMC
</p>
</li>
<li> <p><code>results</code>: a data frame with details about the pruning process
</p>
</li>
<li> <p><code>saved_models</code>: a list of intermediate COVLMCs if <code>save="initial"</code> or
<code>save="all"</code>. It contains an <code>initial</code> component with the large coVLMC
obtained first and an <code>all</code> component with a list of all the <em>other</em> coVLMC
obtained by pruning the initial one.
</p>
</li></ul>



<h3>Memory occupation</h3>

<p><code>covlmc</code> objects tend to be large and saving all the models during the
search for the optimal model can lead to an unreasonable use of memory. To
avoid this problem, models are kept in trimmed form only using
<code><a href="#topic+trim.covlmc">trim.covlmc()</a></code> with <code>keep_model=FALSE</code>. Both the initial model and the
best one are saved untrimmed. This default behaviour corresponds to
<code>trimming="full"</code>. Setting <code>trimming="partial"</code> asks the function to use
<code>keep_model=TRUE</code> in <code><a href="#topic+trim.covlmc">trim.covlmc()</a></code> for intermediate models. Finally,
<code>trimming="none"</code> turns off trimming, which is discouraged expected for
small data sets.
</p>
<p>In parallel processing contexts (e.g. using <a href="foreach.html#topic+foreach">foreach::%dopar%</a>), the memory
occupation of the results can become very large as models tend to keep
environments attached to the formulas. In this situation, it is highly
recommended to trim all saved models, including the best one and the
initial one. This can be done via the <code>best_trimming</code> parameter whose
possible values are identical to the ones of <code>trimming</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covlmc">covlmc()</a></code>, <code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+prune">prune()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week %in% 6:7, ]
dts &lt;- cut(pc$active_power, breaks = c(0, quantile(pc$active_power, probs = c(0.5, 1))))
dts_cov &lt;- data.frame(day_night = (pc$hour &gt;= 7 &amp; pc$hour &lt;= 17))
dts_best_model_tune &lt;- tune_covlmc(dts, dts_cov)
draw(as_covlmc(dts_best_model_tune))
</code></pre>

<hr>
<h2 id='tune_vlmc'>Fit an optimal Variable Length Markov Chain (VLMC)</h2><span id='topic+tune_vlmc'></span>

<h3>Description</h3>

<p>This function fits a Variable Length Markov Chain (VLMC) to a discrete time
series by optimizing an information criterion (BIC or AIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_vlmc(
  x,
  criterion = c("BIC", "AIC"),
  initial = c("truncated", "specific", "extended"),
  alpha_init = NULL,
  cutoff_init = NULL,
  min_size = 2L,
  max_depth = 100L,
  backend = getOption("mixvlmc.backend", "R"),
  verbose = 0,
  save = c("best", "initial", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_vlmc_+3A_x">x</code></td>
<td>
<p>a discrete time series; can be numeric, character, factor and
logical.</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_criterion">criterion</code></td>
<td>
<p>criterion used to select the best model. Either <code>"BIC"</code>
(default) or <code>"AIC"</code> (see details).</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_initial">initial</code></td>
<td>
<p>specifies the likelihood function, more precisely the way the
first few observations for which contexts cannot be calculated are
integrated in the likelihood. Default to <code>"truncated"</code>. See
<code><a href="#topic+loglikelihood">loglikelihood()</a></code> for details.</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_alpha_init">alpha_init</code></td>
<td>
<p>if non <code>NULL</code> used as the initial cut off parameter (in
quantile scale) to build the initial VLMC</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_cutoff_init">cutoff_init</code></td>
<td>
<p>if non <code>NULL</code> used as the initial cut off parameter to
build the initial VLMC. Takes precedence over <code>alpha_init</code> if specified.</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_min_size">min_size</code></td>
<td>
<p>integer &gt;= 1 (default: 2). Minimum number of observations for
a context in the growing phase of the initial context tree.</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_max_depth">max_depth</code></td>
<td>
<p>integer &gt;= 1 (default: 100). Longest context considered in
growing phase of the initial context tree (see details).</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_backend">backend</code></td>
<td>
<p>backend &quot;R&quot; or &quot;C++&quot; (default: as specified by the
&quot;mixvlmc.backend&quot; option). Specifies the implementation used to represent
the context tree and to built it. See <code><a href="#topic+vlmc">vlmc()</a></code> for details.</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_verbose">verbose</code></td>
<td>
<p>integer &gt;= 0 (default: 0). Verbosity level of the pruning
process.</p>
</td></tr>
<tr><td><code id="tune_vlmc_+3A_save">save</code></td>
<td>
<p>specify which BIC models are saved during the pruning process.
The default value <code>"best"</code> asks the function to keep only the best model
according to the <code>criterion</code>. When <code>save="initial"</code> the function keeps <em>in
addition</em> the initial (complex) model which is then pruned during the
selection process. When <code>save="all"</code>, the function returns all the models
considered during the selection process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automates the process of fitting a large VLMC to a discrete
time series with <code><a href="#topic+vlmc">vlmc()</a></code> and of pruning the tree (with <code><a href="#topic+cutoff">cutoff()</a></code> and
<code><a href="#topic+prune">prune()</a></code>) to get an optimal with respect to an information criterion. To
avoid missing long term dependencies, the function uses the <code>max_depth</code>
parameter as an initial guess but then relies on an automatic increase of the
value to make sure the initial context tree is only limited by the <code>min_size</code>
parameter. The initial value of the <code>cutoff</code> parameter of <code><a href="#topic+vlmc">vlmc()</a></code> is also
set to conservative values (depending on the criterion) to avoid prior
simplification of the context tree. This default value can be overridden
using the <code>cutoff_init</code> or <code>alpha_init</code> parameter.
</p>
<p>Once the initial VLMC is obtained, the <code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+prune">prune()</a></code> functions are
used to build all the VLMC models that could be generated using larger values
of the initial cut off parameter. The best model is selected from this
collection, including the initial complex tree, as the one that minimizes the
chosen information criterion.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>

<ul>
<li> <p><code>best_model</code>: the optimal VLMC
</p>
</li>
<li> <p><code>criterion</code>: the criterion used to select the optimal VLMC
</p>
</li>
<li> <p><code>initial</code>: the likelihood function used to select the optimal VLMC
</p>
</li>
<li> <p><code>results</code>: a data frame with details about the pruning process
</p>
</li>
<li> <p><code>saved_models</code>: a list of intermediate VLMCs if <code>save="initial"</code> or
<code>save="all"</code>. It contains an <code>initial</code> component with the large VLMC
obtained first and an <code>all</code> component with a list of all the <em>other</em> VLMC
obtained by pruning the initial one.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+vlmc">vlmc()</a></code>, <code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+prune">prune()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- sample(as.factor(c("A", "B", "C")), 100, replace = TRUE)
tune_result &lt;- tune_vlmc(dts)
draw(tune_result$best_model)
</code></pre>

<hr>
<h2 id='vlmc'>Fit a Variable Length Markov Chain (VLMC)</h2><span id='topic+vlmc'></span>

<h3>Description</h3>

<p>This function fits a  Variable Length Markov Chain (VLMC) to a discrete time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlmc(
  x,
  alpha = 0.05,
  cutoff = NULL,
  min_size = 2L,
  max_depth = 100L,
  prune = TRUE,
  keep_match = FALSE,
  backend = getOption("mixvlmc.backend", "R")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vlmc_+3A_x">x</code></td>
<td>
<p>a discrete time series; can be numeric, character, factor or
logical.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_alpha">alpha</code></td>
<td>
<p>number in (0,1] (default: 0.05) cut off value in quantile scale
in the pruning phase.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_cutoff">cutoff</code></td>
<td>
<p>non negative number: cut off value in native (likelihood ratio)
scale in the pruning phase. Defaults to the value obtained from <code>alpha</code>.
Takes precedence over <code>alpha</code> is specified.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_min_size">min_size</code></td>
<td>
<p>integer &gt;= 1 (default: 2). Minimum number of observations for
a context in the growing phase of the context tree.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_max_depth">max_depth</code></td>
<td>
<p>integer &gt;= 1 (default: 100). Longest context considered in
growing phase of the context tree.</p>
</td></tr>
<tr><td><code id="vlmc_+3A_prune">prune</code></td>
<td>
<p>logical: specify whether the context tree should be pruned
(default behaviour).</p>
</td></tr>
<tr><td><code id="vlmc_+3A_keep_match">keep_match</code></td>
<td>
<p>logical: specify whether to keep the context matches
(default to FALSE)</p>
</td></tr>
<tr><td><code id="vlmc_+3A_backend">backend</code></td>
<td>
<p>&quot;R&quot; or &quot;C++&quot; (default: as specified by the &quot;mixvlmc.backend&quot;
option). Specifies the implementation used to represent the context tree
and to built it. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The VLMC is built using BÃ¼hlmann and Wyner's algorithm which consists in
fitting a context tree (see <code><a href="#topic+ctx_tree">ctx_tree()</a></code>) to a time series and then pruning
it in such as way that the conditional distribution of the next state of the
time series given the context is significantly different from the
distribution given a truncated version of the context.
</p>
<p>The construction of the context tree is controlled by <code>min_size</code> and
<code>max_depth</code>, exactly as in <code><a href="#topic+ctx_tree">ctx_tree()</a></code>. Significativity is measured using a
likelihood ratio test (threshold can be specified in terms of the ratio
itself with <code>cutoff</code>) or in quantile scale with <code>alpha</code>.
</p>
<p>Pruning can be postponed by setting <code>prune=FALSE</code>. Using a combination of
<code><a href="#topic+cutoff">cutoff()</a></code> and <code><a href="#topic+prune">prune()</a></code>, the complexity of the VLMC can then be adjusted.
Any VLMC model can be pruned after construction, <code>prune=FALSE</code> is a
convenience parameter to avoid setting <code>alpha=1</code> (which essentially prevents
any pruning). Automated model selection is provided by <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>.
</p>


<h3>Value</h3>

<p>a fitted vlmc model.
</p>


<h3>Back ends</h3>

<p>Two back ends are available to compute context trees:
</p>

<ul>
<li><p> the &quot;R&quot; back end represents the tree in pure R data structures (nested lists)
that be easily processed further in pure R (C++ helper functions are used
to speed up the construction).
</p>
</li>
<li><p> the &quot;C++&quot; back end represents the tree with C++ classes. This back end is
considered experimental. The tree is built with an optimised suffix tree
algorithm which speeds up the construction by at least a factor 10 in
standard settings. As the tree is kept outside of R direct reach, context
trees built with the C++ back end must be restored after a
<code>saveRDS()</code>/<code>readRDS()</code> sequence. This is done automatically by recomputing
completely the context tree.
</p>
</li></ul>



<h3>References</h3>

<p>BÃ¼hlmann, P. and Wyner, A. J. (1999), &quot;Variable length Markov
chains. Ann. Statist.&quot; 27 (2) 480-513 <a href="https://doi.org/10.1214/aos/1018031204">doi:10.1214/aos/1018031204</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutoff">cutoff()</a></code>, <code><a href="#topic+prune">prune()</a></code> and <code><a href="#topic+tune_vlmc">tune_vlmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc &lt;- powerconsumption[powerconsumption$week == 5, ]
dts &lt;- cut(pc$active_power,
  breaks = c(0, quantile(pc$active_power, probs = c(0.25, 0.5, 0.75, 1)))
)
model &lt;- vlmc(dts)
draw(model)
depth(model)
## reduce the detph of the model
shallow_model &lt;- vlmc(dts, max_depth = 3)
draw(shallow_model, prob = FALSE)
## improve probability estimates
robust_model &lt;- vlmc(dts, min_size = 25)
draw(robust_model, prob = FALSE) ## show the frequencies
draw(robust_model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
