<!DOCTYPE html><html lang="en"><head><title>Help for package iclogcondist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iclogcondist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#case_II_X'><p>Construct Case II Interval Censoring Data</p></a></li>
<li><a href='#current_status_X'><p>Construct Case I Interval Censoring Data (Current Status Data)</p></a></li>
<li><a href='#data_prep'><p>Prepare Data for Interval-Censored Model</p></a></li>
<li><a href='#find_dir_deriv'><p>Compute Directional Derivatives for Active Set Algorithm</p></a></li>
<li><a href='#find_qsi'><p>Compute qsi Matrix</p></a></li>
<li><a href='#get_F_at_x'><p>Generic Function to compute F at X</p></a></li>
<li><a href='#get_F_at_x.iclogcondist'><p>Evaluate F(x) for Objects of Class 'iclogcondist'</p></a></li>
<li><a href='#ic_LCM_UMLE'><p>Compute Least Concave Majorant (LCM) of the log of the Unconstrained MLE for Interval-Censored Data</p></a></li>
<li><a href='#ic_LCMLE'><p>Compute the log-concave MLE for Interval-censored Data using an Active Set Algorithm</p></a></li>
<li><a href='#ic_UMLE'><p>Compute Unconstrained Maximum Likelihood Estimate for Interval-Censored Data</p></a></li>
<li><a href='#iclogcondist_visualization'><p>Visualize the Estimated Cumulative Distribution Functions</p></a></li>
<li><a href='#icm_subset_cpp'><p>Iterative Convex Minorant (ICM) Subset Algorithm</p></a></li>
<li><a href='#initial_values'><p>Initial Values for Estimation under Log-concavity with Interval-Censored Data</p></a></li>
<li><a href='#lgnm'><p>LGNM Data: Case II Interval Censoring Example</p></a></li>
<li><a href='#neg_log_like'><p>Compute the Negative Log-Likelihood for the Interval-Censored Model</p></a></li>
<li><a href='#plot.iclogcondist'><p>Plot Method for iclogcondist_plot Objects</p></a></li>
<li><a href='#ptllogis'><p>Cumulative Distribution Function of a Truncated Log-Logistic Distribution</p></a></li>
<li><a href='#ptlnorm'><p>Cumulative Distribution Function of a Truncated Log-Normal Distribution</p></a></li>
<li><a href='#ptweibull'><p>Cumulative Distribution Function of a Truncated Weibull Distribution</p></a></li>
<li><a href='#qtllogis'><p>Quantile Function of a Truncated Log-Logistic Distribution</p></a></li>
<li><a href='#qtlnorm'><p>Quantile Function of a Truncated Log-Normal Distribution</p></a></li>
<li><a href='#qtweibull'><p>Quantile Function of a Truncated Weibull Distribution</p></a></li>
<li><a href='#rtllogis'><p>Simulate from a Truncated Log-Logistic Distribution</p></a></li>
<li><a href='#rtlnorm'><p>Simulate from a Truncated Log-Normal Distribution</p></a></li>
<li><a href='#rtweibull'><p>Simulate from a Truncated Weibull Distribution</p></a></li>
<li><a href='#simulate_ic_data'><p>Simulate Interval-Censored Data</p></a></li>
<li><a href='#unique_X_weight'><p>Find Unique Rows in a Matrix and Their Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Log-Concave Distribution Estimation with Interval-Censored Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>We consider the non-parametric maximum likelihood estimation of the underlying distribution function, assuming log-concavity, based on mixed-case interval-censored data. The algorithm implemented is base on Chi Wing Chu, Hok Kan Ling and Chaoyu Yuan (2024, &lt;<a href="https://doi.org/10.48550%2FarXiv.2411.19878">doi:10.48550/arXiv.2411.19878</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, flexsurv, ggplot2, icenReg, monotone, fdrtool</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-04 02:43:33 UTC; ycyma</td>
</tr>
<tr>
<td>Author:</td>
<td>Chi Wing Chu [aut],
  Hok Kan Ling [aut],
  Chaoyu Yuan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chaoyu Yuan &lt;chaoyu.yuan@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-05 19:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='case_II_X'>Construct Case II Interval Censoring Data</h2><span id='topic+case_II_X'></span>

<h3>Description</h3>

<p>This function constructs case II interval-censored data using the provided event times and censoring (survey) times.
Each individual's event time is either left-censored, right-censored, or interval-censored
based on two survey times: the left and right bounds of the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_II_X(event_times, survey_times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="case_II_X_+3A_event_times">event_times</code></td>
<td>
<p>A numeric vector of event times for each individual.</p>
</td></tr>
<tr><td><code id="case_II_X_+3A_survey_times">survey_times</code></td>
<td>
<p>A numeric matrix with two columns, where each row contains the left and right
censoring (survey) times for each individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns, where each row represents an individual's interval-censored data.
The first column is the left endpoint, and the second column is the right endpoint.
If the event time is before the left survey time, the interval is <code>(0, left survey time]</code>.
If the event time is after the right survey time, the interval is <code>(right survey time, Inf)</code>.
If the event time falls between the left and right survey times, the interval is <code>(left survey time, right survey time]</code>.
</p>

<hr>
<h2 id='current_status_X'>Construct Case I Interval Censoring Data (Current Status Data)</h2><span id='topic+current_status_X'></span>

<h3>Description</h3>

<p>This function constructs case I interval-censored data (current status data)
using the provided event times and censoring (survey) times.
Each individual's event time is either left-censored or right-censored at their survey time,
depending on whether the event has occurred by the survey time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_status_X(event_times, survey_times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="current_status_X_+3A_event_times">event_times</code></td>
<td>
<p>A numeric vector of event times for each individual.</p>
</td></tr>
<tr><td><code id="current_status_X_+3A_survey_times">survey_times</code></td>
<td>
<p>A numeric vector of censoring (survey) times for each individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns, where each row represents an individual's interval-censored data.
The first column is the left endpoint, and the second column is the right endpoint.
If the event time is before the survey time, the interval is <code>(0, survey_time]</code>.
If the event time is after the survey time, the interval is <code>(survey_time, Inf)</code>.
</p>

<hr>
<h2 id='data_prep'>Prepare Data for Interval-Censored Model</h2><span id='topic+data_prep'></span>

<h3>Description</h3>

<p>This function processes interval-censored data and prepares various components needed for model fitting, including unique time points, censoring intervals, and weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_prep(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_prep_+3A_x">X</code></td>
<td>
<p>A matrix or data frame of interval-censored data where each row contains the lower and upper bounds of the interval for each observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>tau</dt><dd><p>Unique time points.</p>
</dd>
<dt>m</dt><dd><p>The number of unique time points (excluding infinity if present).</p>
</dd>
<dt>L_Rc</dt><dd><p>Indices of observations where the event is in the intersection of L group and the complement of R group. 
The L group consists of samples with left intervals time &lt;= min(all right intervals time). 
The R group consists of samples with infinity right interval time.</p>
</dd>
<dt>Lc_R</dt><dd><p>Indices of observations where the event is in the intersection of the complement of L group and R group.</p>
</dd>
<dt>Lc_Rc</dt><dd><p>Indices of observations where the event is in the intersection of the complement of L group and the complement of R group.</p>
</dd>
<dt>ri</dt><dd><p>Indices corresponding to the right bounds of the intervals in <code>tau</code>.</p>
</dd>
<dt>li</dt><dd><p>Indices corresponding to the left bounds of the intervals in <code>tau</code>.</p>
</dd>
<dt>tau_no_Inf</dt><dd><p>Unique time points excluding infinity.</p>
</dd>
<dt>weight</dt><dd><p>Weights for each unique interval.</p>
</dd>
<dt>X</dt><dd><p>Processed matrix of interval-censored data with unique rows.</p>
</dd>
</dl>


<hr>
<h2 id='find_dir_deriv'>Compute Directional Derivatives for Active Set Algorithm</h2><span id='topic+find_dir_deriv'></span>

<h3>Description</h3>

<p>This function computes the directional derivatives for the active set algorithm used in the estimation 
of the distribution function under log-concavity with interval-censored data.
The calculation takes advantage of the specific structure of the basis matrix, making it efficient to compute in <code>O(n)</code> time complexity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dir_deriv(diff_tau, first_order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_dir_deriv_+3A_diff_tau">diff_tau</code></td>
<td>
<p>A numeric vector containing the differences between consecutive time points (tau).</p>
</td></tr>
<tr><td><code id="find_dir_deriv_+3A_first_order">first_order</code></td>
<td>
<p>A numeric vector representing the first-order derivatives at each time point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>length(diff_tau) + 1</code> representing the directional derivatives for the active set algorithm.
</p>

<hr>
<h2 id='find_qsi'>Compute qsi Matrix</h2><span id='topic+find_qsi'></span>

<h3>Description</h3>

<p>This function computes the qsi matrix for specified indices and time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_qsi(is, tau_no_Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_qsi_+3A_is">is</code></td>
<td>
<p>Indices of nodes.</p>
</td></tr>
<tr><td><code id="find_qsi_+3A_tau_no_inf">tau_no_Inf</code></td>
<td>
<p>Unique time points excluding infinity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qsi matrix.
</p>

<hr>
<h2 id='get_F_at_x'>Generic Function to compute F at X</h2><span id='topic+get_F_at_x'></span>

<h3>Description</h3>

<p>Computes the value of the function <code class="reqn">F(x)</code> for a given object of class <code>iclogcondist</code>. 
This is a generic function to compute <code class="reqn">F(x)</code> for object class <code>iclogcondist</code>. 
For usage details, please refer to function <code>get_F_at_x.iclogcondist</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_F_at_x(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_F_at_x_+3A_object">object</code></td>
<td>
<p>An object for which the method is defined.</p>
</td></tr>
<tr><td><code id="get_F_at_x_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values, either <code class="reqn">F(x)</code> or <code class="reqn">log(F(x))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
data(lgnm)

# Evaluate for LCMLE object
fit_LCMLE &lt;- ic_LCMLE(lgnm)
get_F_at_x(fit_LCMLE)

# Evaluate for UMLE object
fit_UMLE &lt;- ic_UMLE(lgnm)
x = seq(0.001, 6, length.out = 1000)
get_F_at_x(fit_UMLE, x = x)
</code></pre>

<hr>
<h2 id='get_F_at_x.iclogcondist'>Evaluate F(x) for Objects of Class 'iclogcondist'</h2><span id='topic+get_F_at_x.iclogcondist'></span>

<h3>Description</h3>

<p>Computes the value of the function <code class="reqn">F(x)</code> for a given object of class <code>iclogcondist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iclogcondist'
get_F_at_x(object, x = NA, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_F_at_x.iclogcondist_+3A_object">object</code></td>
<td>
<p>An object of class <code>iclogcondist</code>. Must also belong to one of the subclasses:
<code>"ic_LCMLE"</code>, <code>"ic_LCM_UMLE"</code>, or <code>"ic_UMLE"</code>.</p>
</td></tr>
<tr><td><code id="get_F_at_x.iclogcondist_+3A_x">x</code></td>
<td>
<p>A numeric vector of values at which <code class="reqn">F(x)</code> is evaluated. If not specified,
the <code>tau_no_Inf</code> attribute of the <code>object</code> object is used.</p>
</td></tr>
<tr><td><code id="get_F_at_x.iclogcondist_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, returns the result in log-transformed form.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_F_at_x.iclogcondist_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values, either <code class="reqn">F(x)</code> or <code class="reqn">log(F(x))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
data(lgnm)

# Evaluate for LCMLE object
fit_LCMLE &lt;- ic_LCMLE(lgnm)
get_F_at_x(fit_LCMLE)

# Evaluate for UMLE object
fit_UMLE &lt;- ic_UMLE(lgnm)
x = seq(0.001, 6, length.out = 1000)
get_F_at_x(fit_UMLE, x = x)
</code></pre>

<hr>
<h2 id='ic_LCM_UMLE'>Compute Least Concave Majorant (LCM) of the log of the Unconstrained MLE for Interval-Censored Data</h2><span id='topic+ic_LCM_UMLE'></span>

<h3>Description</h3>

<p>This function computes the Least Concave Majorant (LCM) of the log of the unconstrained MLE for interval-censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_LCM_UMLE(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic_LCM_UMLE_+3A_x">X</code></td>
<td>
<p>A matrix with two columns, where each row represents an interval (L, R] for interval-censored data.
<code>L</code> and <code>R</code> are the left and right endpoints, respectively, with <code>R = Inf</code> indicating right-censoring.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>A list with <code>tau_no_Inf</code> (finite values of <code>tau</code>), <code>phi_hat</code> (LCM of log of <code>F_hat</code>), 
and <code>F_hat</code> (exp of <code>phi_hat</code>).</p>
</td></tr>
<tr><td><code>knot_info</code></td>
<td>
<p>A list with <code>knot_index</code> (indices of knots in <code>tau_no_Inf</code>), 
<code>tau_on_knot</code> (values of <code>tau</code> at knots), 
<code>F_on_knot</code> (<code>F_hat</code> at knots), 
and <code>phi_on_knot</code> (<code>phi_hat</code> at knots).</p>
</td></tr>
<tr><td><code>neg_log_likelihood</code></td>
<td>
<p>The negative log-likelihood of the LCM fit.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Vector of weights corresponding to each interval in the data.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The original interval-censored data matrix input.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(lgnm)
result &lt;- ic_LCM_UMLE(X = lgnm)
</code></pre>

<hr>
<h2 id='ic_LCMLE'>Compute the log-concave MLE for Interval-censored Data using an Active Set Algorithm</h2><span id='topic+ic_LCMLE'></span>

<h3>Description</h3>

<p>This function computes the log-concave MLE of the cumulative distribution function for interval-censored data under log-concavity
on the underlying distribution function based on an active set algorithm. The active set algorithm adjusts the knots set based on
certain directional derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_LCMLE(
  X,
  initial = "LCM",
  print = FALSE,
  max_iter = 500,
  tol_conv = 1e-07,
  tol_conv_like = 1e-10,
  tol_K = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic_LCMLE_+3A_x">X</code></td>
<td>
<p>A matrix with two columns, where each row represents an interval (L, R] for interval-censored data.
<code>L</code> and <code>R</code> are the left and right endpoints, with <code>R = Inf</code> indicating right-censoring.</p>
</td></tr>
<tr><td><code id="ic_LCMLE_+3A_initial">initial</code></td>
<td>
<p>A character string specifying the method of obtaining an initial value (&quot;LCM&quot; or &quot;MLE&quot;) for the estimation process. Default is <code>"LCM"</code>.</p>
</td></tr>
<tr><td><code id="ic_LCMLE_+3A_print">print</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints the iterative process details. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ic_LCMLE_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer specifying the maximum number of iterations for the algorithm. Default is 500.</p>
</td></tr>
<tr><td><code id="ic_LCMLE_+3A_tol_conv">tol_conv</code></td>
<td>
<p>A numeric tolerance level for convergence based on the directional derivatives. Default is <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="ic_LCMLE_+3A_tol_conv_like">tol_conv_like</code></td>
<td>
<p>A numeric tolerance level for convergence based on log-likelihood difference. Default is <code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="ic_LCMLE_+3A_tol_k">tol_K</code></td>
<td>
<p>A numeric tolerance for checking if v^T phi is in K (constraint set) in active constraint set <code>A</code>. Default is <code>1e-5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>A list containing <code>tau_no_Inf</code> (unique finite <code>tau</code> values), <code>phi_hat</code> (estimate of <code>log F</code>), and <code>F_hat</code> (estimate of <code>F</code>).</p>
</td></tr>
<tr><td><code>knot_info</code></td>
<td>
<p>A list with <code>knot_index</code> (indices of active knots in <code>tau_no_Inf</code>), <code>tau_on_knot</code> (tau values at active knots), 
<code>F_on_knot</code> (MLE cumulative distribution function values at active knots), and <code>phi_on_knot</code> (logarithmic estimates of <code>F</code> at active knots).</p>
</td></tr>
<tr><td><code>neg_log_likelihood</code></td>
<td>
<p>Vector of negative log-likelihood values for each iteration of the algorithm.</p>
</td></tr>
<tr><td><code>dir_derivs</code></td>
<td>
<p>Vector of directional derivatives for each iteration.</p>
</td></tr>
<tr><td><code>iter_no</code></td>
<td>
<p>Integer representing the total number of iterations.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Vector of weights corresponding to each interval in the data.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The original interval-censored data matrix input.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
data(lgnm)
result &lt;- ic_LCMLE(X = lgnm, initial = "LCM", print = TRUE, max_iter = 500)
print(result$est)
</code></pre>

<hr>
<h2 id='ic_UMLE'>Compute Unconstrained Maximum Likelihood Estimate for Interval-Censored Data</h2><span id='topic+ic_UMLE'></span>

<h3>Description</h3>

<p>This function computes the unconstrained maximum likelihood estimate (UMLE) for interval-censored data. 
It utilizes the non-parametric MLE from the <code>ic_np</code> function in the <code>icenReg</code> package as a starting point 
and prepares key components such as cumulative probabilities, log-transformed values, and knot information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_UMLE(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic_UMLE_+3A_x">X</code></td>
<td>
<p>A matrix with two columns, where each row represents an interval (L, R] for interval-censored data.
<code>L</code> and <code>R</code> are left and right endpoints, respectively, with <code>R = Inf</code> indicating right-censoring.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ic_np</code> function from the <code>icenReg</code> package is used to compute the non-parametric MLE for 
interval-censored data. This provides initial estimates of probabilities (<code>p_hat</code>) and jump points 
(<code>knot</code>) in the cumulative distribution function. These are then processed to compute the 
cumulative probabilities (<code>F_hat</code>) and log-transformed values (<code>phi_hat</code>) at unique time points.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>A list with <code>tau_no_Inf</code> (finite values of <code>tau</code>), <code>phi_hat</code> (log of <code>F_hat</code> values), 
and <code>F_hat</code> (MLE cumulative distribution function values).</p>
</td></tr>
<tr><td><code>knot_info</code></td>
<td>
<p>A list with <code>knot_index</code> (indices of knots in <code>tau_no_Inf</code>), <code>tau_on_knot</code> (values of <code>tau</code> at knots), 
<code>F_on_knot</code> (MLE at knots), and <code>phi_on_knot</code> (log of <code>F</code> at knots).</p>
</td></tr>
<tr><td><code>neg_log_likelihood</code></td>
<td>
<p>The negative log-likelihood of the MLE fit.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>Vector of weights corresponding to each interval in the data.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The original interval-censored data matrix input.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Anderson-Bergman, C. (2016) An efficient implementation of the EMICM algorithm for the interval censored NPMLE
<em>Journal of Computational and Graphical Statistics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lgnm)
result &lt;- ic_UMLE(X = lgnm)
</code></pre>

<hr>
<h2 id='iclogcondist_visualization'>Visualize the Estimated Cumulative Distribution Functions</h2><span id='topic+iclogcondist_visualization'></span>

<h3>Description</h3>

<p>This function visualizes a user-specified distribution <code>true_dist</code> (if available) and the estimated
cumulative distribution functions (CDF) <code class="reqn">F(t)</code> and <code class="reqn">log F(t)</code> for a given range.
The function overlays the estimated functions from a list of fitted models
on the same plot, allowing comparison with the user-specified distribution (if provided).
In a simulation study, the user-specified distribution can correspond to the true underlying distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iclogcondist_visualization(X, range = NA, fit_list = list(), true_dist = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iclogcondist_visualization_+3A_x">X</code></td>
<td>
<p>A dataset or input data used to prepare the plot range if <code>range</code> is not specified.</p>
</td></tr>
<tr><td><code id="iclogcondist_visualization_+3A_range">range</code></td>
<td>
<p>A numeric vector of length 2 specifying the range of <code>t</code> values for plotting.
If <code>NA</code> the function calculates the range based on the input data <code>X</code>.</p>
</td></tr>
<tr><td><code id="iclogcondist_visualization_+3A_fit_list">fit_list</code></td>
<td>
<p>A named list of fitted models, where each element is expected to contain
an <code>est</code> object with estimates for generating the CDF plots. The name of the list should be <code>"LCMLE"</code>,<code>"UMLE"</code> or <code>"LCM_UMLE"</code></p>
</td></tr>
<tr><td><code id="iclogcondist_visualization_+3A_true_dist">true_dist</code></td>
<td>
<p>Optional. A data frame or list containing the user-specified distribution values,
with components <code>x</code> and <code>y</code> representing the values of <code class="reqn">t</code> and <code class="reqn">F(t)</code> respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two ggplot objects: <code>logF_plot</code> for <code class="reqn">log F(t)</code> and <code>F_plot</code> for <code class="reqn">F(t)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage
data(lgnm)
fit_LCMLE &lt;- ic_LCMLE(lgnm)
fit_UMLE &lt;- ic_UMLE(lgnm)
iclogcondist_visualization(
  X = lgnm,
  range = c(0, 10),
  fit_list = list(
    "UMLE" = fit_UMLE,
    "LCMLE" = fit_LCMLE
  )
)

</code></pre>

<hr>
<h2 id='icm_subset_cpp'>Iterative Convex Minorant (ICM) Subset Algorithm</h2><span id='topic+icm_subset_cpp'></span>

<h3>Description</h3>

<p>This function implements the ICM algorithm for solving the sub-problem in the active set algorithm.
This is a support of the active set algorithm, computing the optimal values <code>phi_tilde</code> with reduced number of knots in the sub-problem.
It uses backtracking to ensure convergence (Jongbloed, 1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icm_subset_cpp(
  phi_tilde_initial,
  is,
  tau_no_Inf,
  L_Rc,
  Lc_R,
  Lc_Rc,
  ri,
  li,
  weight,
  tol = 1e-10,
  max_iter = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icm_subset_cpp_+3A_phi_tilde_initial">phi_tilde_initial</code></td>
<td>
<p>A numeric vector representing the initial values of the reduced variables <code>phi_tilde</code>.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_is">is</code></td>
<td>
<p>A numeric vector indicating the nodes with unequal left-hand slope and right-hand slope.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_tau_no_inf">tau_no_Inf</code></td>
<td>
<p>A numeric vector containing the unique time points, excluding infinity.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_l_rc">L_Rc</code></td>
<td>
<p>Indices of observations where the event is in the intersection of L group and the complement of R group. 
The L group consists of samples with left intervals time &lt;= min(all right intervals time). 
The R group consists of samples with infinity right interval time.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_lc_r">Lc_R</code></td>
<td>
<p>Indices of observations where the event is in the intersection of the complement of L group and R group.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_lc_rc">Lc_Rc</code></td>
<td>
<p>Indices of observations where the event is in the intersection of the complement of L group and the complement of R group.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_ri">ri</code></td>
<td>
<p>A numeric vector of indices corresponding to the right bounds of the intervals in <code>tau_no_Inf</code>.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_li">li</code></td>
<td>
<p>A numeric vector of indices corresponding to the left bounds of the intervals in <code>tau_no_Inf</code>.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_weight">weight</code></td>
<td>
<p>A numeric vector representing the weights for each observation.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_tol">tol</code></td>
<td>
<p>A numeric value specifying the tolerance for convergence. Default is <code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="icm_subset_cpp_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer specifying the maximum number of iterations. Default is <code>500</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>phi_tilde_hat</dt><dd><p>The estimated values of the reduced variable <code>phi_tilde</code> at the end of the ICM iterations.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jongbloed, G.: The iterative convex minorant algorithm for nonparametric estimation. J. Comput. Gr. Stat. 7(3), 310â€“321 (1998)
</p>

<hr>
<h2 id='initial_values'>Initial Values for Estimation under Log-concavity with Interval-Censored Data</h2><span id='topic+initial_values'></span>

<h3>Description</h3>

<p>This function obtains initial values for the maximum likelihood estimation under log-concavity with 
interval-censored data based on the unconstrained maximum likelihood estimate (MLE) 
or its least concave majorant (LCM). 
Alternatively, the user can provide a numeric vector of initial values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_values(X, initial = "LCM")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_values_+3A_x">X</code></td>
<td>
<p>A matrix or data frame of interval-censored data, where each row contains the lower and upper bounds of the interval for each observation.</p>
</td></tr>
<tr><td><code id="initial_values_+3A_initial">initial</code></td>
<td>
<p>A character string specifying the method for generating initial values. 
The default is <code>"LCM"</code>, which uses the least concave majorant of the log of the unconstrained MLE. 
Other options are <code>"MLE"</code> for the unconstrained maximum likelihood estimate 
or a numeric vector provided by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>phi_hat</dt><dd><p>The initial values of the <code>phi</code> parameter based on the specified method.</p>
</dd>
<dt>phi_hat_MLE</dt><dd><p>Initial values based on the unconstrained MLE.</p>
</dd>
<dt>phi_hat_LCM</dt><dd><p>Initial values based on the least concave majorant.</p>
</dd>
</dl>


<hr>
<h2 id='lgnm'>LGNM Data: Case II Interval Censoring Example</h2><span id='topic+lgnm'></span>

<h3>Description</h3>

<p>This dataset, <code>lgnm</code>, provides an example of case II interval censoring data for illustrating the functions in this package. 
The event time is simulated from a log-normal distribution with parameters mean = 0 and standard deviation = 1.
The left censoring time is drawn from a uniform distribution between 0 and 2, and the right censoring time is drawn 
from a uniform distribution between the left censoring time and 20. Both the left and right censoring times are rounded to four decimal places.
</p>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 2 variables:
</p>

<dl>
<dt>left</dt><dd><p>The left censoring time.</p>
</dd>
<dt>right</dt><dd><p>The right censoring time.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Synthetic data generated for illustration purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lgnm)
head(lgnm)
</code></pre>

<hr>
<h2 id='neg_log_like'>Compute the Negative Log-Likelihood for the Interval-Censored Model</h2><span id='topic+neg_log_like'></span>

<h3>Description</h3>

<p>This function computes the negative log-likelihood of an interval-censored model based on the specified parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_log_like(x, weight, li, ri, L_Rc, Lc_R, Lc_Rc, type = "", tau_no_Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neg_log_like_+3A_x">x</code></td>
<td>
<p>A numeric vector of parameter estimates (can be in terms of <code>phi</code>, or <code>F</code>).</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_weight">weight</code></td>
<td>
<p>A numeric vector of weights for the observations.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_li">li</code></td>
<td>
<p>A numeric vector of indices corresponding to the left bounds of the intervals in <code>tau_no_Inf</code>.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_ri">ri</code></td>
<td>
<p>A numeric vector of indices corresponding to the right bounds of the intervals in <code>tau_no_Inf</code>.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_l_rc">L_Rc</code></td>
<td>
<p>Indices of observations where the event is in the intersection of L group and the complement of R group. 
The L group consists of samples with left intervals time &lt;= min(all right intervals time). 
The R group consists of samples with infinity right interval time.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_lc_r">Lc_R</code></td>
<td>
<p>Indices of observations where the event is in the intersection of the complement of L group and R group.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_lc_rc">Lc_Rc</code></td>
<td>
<p>Indices of observations where the event is in the intersection of the complement of L group and the complement of R group.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_type">type</code></td>
<td>
<p>A character string indicating the parameterization of <code>x</code>. Options are <code>"phi"</code> (log of F), or <code>"F"</code>.</p>
</td></tr>
<tr><td><code id="neg_log_like_+3A_tau_no_inf">tau_no_Inf</code></td>
<td>
<p>A numeric vector of unique time points excluding infinity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The negative log-likelihood value.
</p>

<hr>
<h2 id='plot.iclogcondist'>Plot Method for iclogcondist_plot Objects</h2><span id='topic+plot.iclogcondist'></span>

<h3>Description</h3>

<p>This function generates a plot for objects of class <code>iclogcondist</code>, which are typically generated by 
<code>ic_UMLE</code>, <code>ic_LCM_UMLE</code>, or <code>ic_LCMLE</code>. The plot can display either the cumulative 
distribution function <code>F(t)</code> or the log cumulative distribution function <code>logF(t)</code>, depending on the 
setting of the <code>log</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iclogcondist'
plot(x, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.iclogcondist_+3A_x">x</code></td>
<td>
<p>An object of class <code>iclogcondist</code>, typically generated by <code>ic_UMLE</code>, <code>ic_LCM_UMLE</code>, or <code>ic_LCMLE</code>.</p>
</td></tr>
<tr><td><code id="plot.iclogcondist_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, plots the log cumulative distribution function <code>logF(t)</code>. 
If <code>FALSE</code>, plots <code>F(t)</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.iclogcondist_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible <code>ggplot</code> object representing the plot. The plot is also displayed in the current graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage with ic_UMLE, ic_LCM_UMLE, and ic_LCMLE
data(lgnm)
X &lt;- lgnm
fit_UMLE &lt;- ic_UMLE(X)
fit_LCM_UMLE &lt;- ic_LCM_UMLE(X)
fit_LCMLE &lt;- ic_LCMLE(X)
plot(fit_UMLE, log = TRUE)   # Plot logF(t) for UMLE
plot(fit_LCM_UMLE, log = FALSE)  # Plot F(t) for LCM_UMLE
plot(fit_LCMLE, log = FALSE) # Plot F(t) for LCMLE
</code></pre>

<hr>
<h2 id='ptllogis'>Cumulative Distribution Function of a Truncated Log-Logistic Distribution</h2><span id='topic+ptllogis'></span>

<h3>Description</h3>

<p>This function computes the cumulative distribution function (CDF) of a truncated log-logistic distribution
at a given point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptllogis(x, shape = 1, scale = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptllogis_+3A_x">x</code></td>
<td>
<p>A numeric vector at which to evaluate the CDF.</p>
</td></tr>
<tr><td><code id="ptllogis_+3A_shape">shape</code></td>
<td>
<p>A positive numeric value representing the shape parameter of the log-logistic distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ptllogis_+3A_scale">scale</code></td>
<td>
<p>A positive numeric value representing the scale parameter of the log-logistic distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ptllogis_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the CDF values of the truncated log-logistic distribution at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate the CDF at x = 2 for a truncated log-logistic distribution
ptllogis(2, shape = 2, scale = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='ptlnorm'>Cumulative Distribution Function of a Truncated Log-Normal Distribution</h2><span id='topic+ptlnorm'></span>

<h3>Description</h3>

<p>This function computes the cumulative distribution function (CDF) of a truncated log-normal distribution
at a given point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptlnorm(x, meanlog = 0, sdlog = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptlnorm_+3A_x">x</code></td>
<td>
<p>A numeric vector at which to evaluate the CDF.</p>
</td></tr>
<tr><td><code id="ptlnorm_+3A_meanlog">meanlog</code></td>
<td>
<p>A numeric value representing the mean of the log-normal distribution on the log scale. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="ptlnorm_+3A_sdlog">sdlog</code></td>
<td>
<p>A positive numeric value representing the standard deviation of the log-normal distribution on the log scale. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ptlnorm_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the CDF values of the truncated log-normal distribution at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate the CDF at x = 2 for a truncated log-normal distribution
ptlnorm(2, meanlog = 0, sdlog = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='ptweibull'>Cumulative Distribution Function of a Truncated Weibull Distribution</h2><span id='topic+ptweibull'></span>

<h3>Description</h3>

<p>This function computes the cumulative distribution function (CDF) of a truncated Weibull distribution
at a given point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptweibull(x, shape = 1, scale = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptweibull_+3A_x">x</code></td>
<td>
<p>A numeric vector at which to evaluate the CDF.</p>
</td></tr>
<tr><td><code id="ptweibull_+3A_shape">shape</code></td>
<td>
<p>A positive numeric value representing the shape parameter of the Weibull distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ptweibull_+3A_scale">scale</code></td>
<td>
<p>A positive numeric value representing the scale parameter of the Weibull distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ptweibull_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the CDF values of the truncated Weibull distribution at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate the CDF at x = 2 for a truncated Weibull distribution
ptweibull(2, shape = 2, scale = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='qtllogis'>Quantile Function of a Truncated Log-Logistic Distribution</h2><span id='topic+qtllogis'></span>

<h3>Description</h3>

<p>This function computes the quantiles of a truncated log-logistic distribution for a given probability vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtllogis(q, shape = 1, scale = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtllogis_+3A_q">q</code></td>
<td>
<p>A numeric vector of probabilities for which to calculate the quantiles.</p>
</td></tr>
<tr><td><code id="qtllogis_+3A_shape">shape</code></td>
<td>
<p>A positive numeric value representing the shape parameter of the log-logistic distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="qtllogis_+3A_scale">scale</code></td>
<td>
<p>A positive numeric value representing the scale parameter of the log-logistic distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="qtllogis_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of quantiles corresponding to the given probabilities in <code>q</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the 0.5 quantile of a truncated log-logistic distribution
qtllogis(0.5, shape = 2, scale = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='qtlnorm'>Quantile Function of a Truncated Log-Normal Distribution</h2><span id='topic+qtlnorm'></span>

<h3>Description</h3>

<p>This function computes the quantiles of a truncated log-normal distribution for a given probability vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtlnorm(q, meanlog = 0, sdlog = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtlnorm_+3A_q">q</code></td>
<td>
<p>A numeric vector of probabilities for which to calculate the quantiles.</p>
</td></tr>
<tr><td><code id="qtlnorm_+3A_meanlog">meanlog</code></td>
<td>
<p>A numeric value representing the mean of the log-normal distribution on the log scale. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="qtlnorm_+3A_sdlog">sdlog</code></td>
<td>
<p>A positive numeric value representing the standard deviation of the log-normal distribution on the log scale. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="qtlnorm_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of quantiles corresponding to the given probabilities in <code>q</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the 0.5 quantile of a truncated log-normal distribution
qtlnorm(0.5, meanlog = 0, sdlog = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='qtweibull'>Quantile Function of a Truncated Weibull Distribution</h2><span id='topic+qtweibull'></span>

<h3>Description</h3>

<p>This function computes the quantiles of a truncated Weibull distribution for a given probability vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtweibull(q, shape = 1, scale = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtweibull_+3A_q">q</code></td>
<td>
<p>A numeric vector of probabilities for which to calculate the quantiles.</p>
</td></tr>
<tr><td><code id="qtweibull_+3A_shape">shape</code></td>
<td>
<p>A positive numeric value representing the shape parameter of the Weibull distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="qtweibull_+3A_scale">scale</code></td>
<td>
<p>A positive numeric value representing the scale parameter of the Weibull distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="qtweibull_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of quantiles corresponding to the given probabilities in <code>q</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the 0.5 quantile of a truncated Weibull distribution
qtweibull(0.5, shape = 2, scale = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='rtllogis'>Simulate from a Truncated Log-Logistic Distribution</h2><span id='topic+rtllogis'></span>

<h3>Description</h3>

<p>This function generates random samples from a truncated log-logistic distribution
using an acceptance-rejection method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtllogis(n, shape = 1, scale = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtllogis_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of random samples to generate.</p>
</td></tr>
<tr><td><code id="rtllogis_+3A_shape">shape</code></td>
<td>
<p>A positive numeric value representing the shape parameter of the log-logistic distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="rtllogis_+3A_scale">scale</code></td>
<td>
<p>A positive numeric value representing the scale parameter of the log-logistic distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="rtllogis_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of <code>n</code> random samples from the truncated log-logistic distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 random samples from a truncated log-logistic distribution
rtllogis(10, shape = 2, scale = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='rtlnorm'>Simulate from a Truncated Log-Normal Distribution</h2><span id='topic+rtlnorm'></span>

<h3>Description</h3>

<p>This function generates random samples from a truncated log-normal distribution
using an acceptance-rejection method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtlnorm(n, meanlog = 0, sdlog = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtlnorm_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of random samples to generate.</p>
</td></tr>
<tr><td><code id="rtlnorm_+3A_meanlog">meanlog</code></td>
<td>
<p>A numeric value representing the mean of the log-normal distribution on the log scale. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="rtlnorm_+3A_sdlog">sdlog</code></td>
<td>
<p>A positive numeric value representing the standard deviation of the log-normal distribution on the log scale. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="rtlnorm_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of <code>n</code> random samples from the truncated log-normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 random samples from a truncated log-normal distribution
rtlnorm(10, meanlog = 0, sdlog = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='rtweibull'>Simulate from a Truncated Weibull Distribution</h2><span id='topic+rtweibull'></span>

<h3>Description</h3>

<p>This function generates random samples from a truncated Weibull distribution
using inverse transform sampling. When <code>shape = 1</code>, it reduces to a truncated exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtweibull(n, shape = 1, scale = 1, upper_bound = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtweibull_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of random samples to generate.</p>
</td></tr>
<tr><td><code id="rtweibull_+3A_shape">shape</code></td>
<td>
<p>A positive numeric value representing the shape parameter of the Weibull distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="rtweibull_+3A_scale">scale</code></td>
<td>
<p>A positive numeric value representing the scale parameter of the Weibull distribution. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="rtweibull_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A positive numeric value indicating the upper truncation point. Default is <code>Inf</code> (no truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of <code>n</code> random samples from the truncated Weibull distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 10 random samples from a truncated Weibull distribution
rtweibull(10, shape = 2, scale = 1, upper_bound = 5)

</code></pre>

<hr>
<h2 id='simulate_ic_data'>Simulate Interval-Censored Data</h2><span id='topic+simulate_ic_data'></span>

<h3>Description</h3>

<p>This function generates interval-censored data, where the event times
are generated from one of the following distributions: Weibull, log-normal and log-logistic.
It supports both case 1 and case 2 interval censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_ic_data(
  n,
  dist,
  para1,
  para2,
  upper_bound = Inf,
  C1_upper = 1,
  case = 2,
  rounding = FALSE,
  round_digit = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_ic_data_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of observations to generate.</p>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_dist">dist</code></td>
<td>
<p>A character string indicating the distribution to use for event times. 
Options are <code>"lognormal"</code>, <code>"weibull"</code>, or <code>"loglogistic"</code>.</p>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_para1">para1</code></td>
<td>
<p>A numeric value representing the first parameter of the distribution:
</p>

<ul>
<li> <p><code>"lognormal"</code>: Mean of the log-normal distribution (meanlog).
</p>
</li>
<li> <p><code>"weibull"</code> and <code>"loglogistic"</code>: Shape parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_para2">para2</code></td>
<td>
<p>A numeric value representing the second parameter of the distribution:
</p>

<ul>
<li> <p><code>"lognormal"</code>: Standard deviation of the log-normal distribution (sdlog).
</p>
</li>
<li> <p><code>"weibull"</code> and <code>"loglogistic"</code>: Scale parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_upper_bound">upper_bound</code></td>
<td>
<p>A numeric value specifying the upper bound for event times, 
corresponding to a truncated distribution. Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_c1_upper">C1_upper</code></td>
<td>
<p>A numeric value specifying the upper limit for the first censoring time <code>C1</code>. 
Default is 1.</p>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_case">case</code></td>
<td>
<p>An integer specifying the censoring case to simulate:
</p>

<ul>
<li> <p><code>1</code>: Current status (case 1 interval censoring)
</p>
</li>
<li> <p><code>2</code>: Case 2 Interval censoring
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_rounding">rounding</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, generated times are rounded to a specified number of decimal places. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulate_ic_data_+3A_round_digit">round_digit</code></td>
<td>
<p>An integer specifying the number of digits for rounding when <code>rounding = TRUE</code>. Default is 4.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> **Censoring Times**:
</p>

<ul>
<li><p> In <code>case = 1</code> (current status), one censoring time is generated, where it follows <code>U(0, C1_upper)</code>.
</p>
</li>
<li><p> In <code>case = 2</code> (case 2 interval censoring), two censoring times are generated:
</p>

<ul>
<li> <p><code>C1</code>: sampled from <code>U(0, C1_upper)</code>.
</p>
</li>
<li> <p><code>C2</code>: sampled from <code>U(C1, min(upper_bound, 20))</code>.
</p>
</li></ul>

</li></ul>

</li>
<li><p> **Distributions**:
</p>

<ul>
<li><p> **Weibull**: Parameterized by shape (<code>para1</code>) and scale (<code>para2</code>).
</p>
</li>
<li><p> **Log-logistic**: Parameterized by shape (<code>para1</code>) and scale (<code>para2</code>).
</p>
</li>
<li><p> **Log-normal**: Parameterized by mean (<code>para1</code>) and standard deviation (<code>para2</code>).
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A matrix of interval-censored data where each row represents an interval (L, R] containing the unobserved event time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data with a truncated Weibull distribution and case II interval censoring
simulate_ic_data(n = 100, dist = "weibull", para1 = 2, para2 = 1, upper_bound = 5, case = 2)
</code></pre>

<hr>
<h2 id='unique_X_weight'>Find Unique Rows in a Matrix and Their Weights</h2><span id='topic+unique_X_weight'></span>

<h3>Description</h3>

<p>This function finds the unique rows of a given matrix and calculates the frequency (weight) of each unique row. 
It returns both the unique rows and the weights (the number of occurrences of each row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_X_weight(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unique_X_weight_+3A_x">X</code></td>
<td>
<p>A matrix. The matrix whose unique rows are to be found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two components:
</p>

<dl>
<dt>unique_X</dt><dd><p>A matrix of the unique rows from the input matrix.</p>
</dd>
<dt>weight</dt><dd><p>An integer vector containing the frequency (weight) of each unique row.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
